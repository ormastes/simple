# After Each Feature Specification
# Feature #184: BDD after_each hooks for test teardown
# Category: Testing Framework | Difficulty: 2 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 184,
    name: 'After Each Hooks',
    category: 'Testing Framework',
    difficulty: 2,
    status: 'Complete',
    impl_type: 'Simple',
    spec_ref: 'doc/spec/testing/testing_bdd_framework.md',
    files: [
        'simple/std_lib/src/spec/dsl.spl'
    ],
    tests: [
        'simple/std_lib/test/system/spec/spec_framework_spec.spl'
    ],
    description: 'BDD after_each hooks for running cleanup code after each test example. Ensures resources are released and state is cleaned up.',
    code_examples: [],
    dependencies: [183],
    required_by: [],
    notes: 'Runs after each it block. Runs even if test fails. Child hooks run before parent hooks.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('  AFTER EACH HOOKS FEATURE SPECIFICATION (#184)')
print('  Category: Testing Framework | Difficulty: 2 | Status: Complete')
print('')


# -----------------------------------------------------
# Teardown Definition
# -----------------------------------------------------

describe "Teardown definition":
    """
    TODO: Add documentation here
    """
    context "after_each registers hooks":
        """
        TODO: Add documentation here
        """
        it "stores cleanup blocks":
            """
            TODO: Add documentation here
            """

struct TeardownHook:
    hook_type: text
    cleanup_fn: text

fn create_teardown(name: text) -> TeardownHook:
    return TeardownHook { hook_type: "after_each", cleanup_fn: name }

val hook = create_teardown("close_connection")
if hook.hook_type == "after_each":
else:

        it "supports multiple cleanups":
            """
            TODO: Add documentation here
            """

val hooks = [
    create_teardown("cleanup1"),
    create_teardown("cleanup2")
]
if hooks.len() == 2:
else:

# -----------------------------------------------------
# Teardown Execution
# -----------------------------------------------------

print('')
describe "Teardown execution":
    """
    TODO: Add documentation here
    """
    context "runs after each test":
        """
        TODO: Add documentation here
        """
        it "executes cleanup":
            """
            TODO: Add documentation here
            """

fn cleanup() -> text:
    return "cleaned"

if cleanup() == "cleaned":
else:

        it "runs for every test":
            """
            TODO: Add documentation here
            """

fn count_teardowns(num_tests: i64) -> i64:
    var teardown_count = 0
    var i = 0
    while i < num_tests:
        teardown_count = teardown_count + 1
        i = i + 1
    return teardown_count

if count_teardowns(3) == 3:
else:

# -----------------------------------------------------
# Guaranteed Execution
# -----------------------------------------------------

print('')
describe "Guaranteed execution":
    """
    TODO: Add documentation here
    """
    context "runs even on failure":
        """
        TODO: Add documentation here
        """
        it "runs after passing tests":
            """
            TODO: Add documentation here
            """

fn run_with_teardown(test_passes: bool) -> text:
    var teardown_ran = false
    if test_passes:
        teardown_ran = true
    else:
        teardown_ran = true
    if teardown_ran:
        return "teardown executed"
    return "no teardown"

if run_with_teardown(true) == "teardown executed":
else:

        it "runs after failing tests":
            """
            TODO: Add documentation here
            """

if run_with_teardown(false) == "teardown executed":
else:

# -----------------------------------------------------
# Reverse Order
# -----------------------------------------------------

print('')
describe "Reverse order":
    """
    TODO: Add documentation here
    """
    context "child before parent":
        """
        TODO: Add documentation here
        """
        it "runs child hooks first":
            """
            TODO: Add documentation here
            """

struct HookOrder:
    child_hooks: List<text>
    parent_hooks: List<text>

fn get_teardown_order(order: HookOrder) -> List<text>:
    return order.child_hooks + order.parent_hooks

val tear_order = HookOrder { child_hooks: ["child"], parent_hooks: ["parent"] }
val exec_order = get_teardown_order(tear_order)
if exec_order[0] == "child" and exec_order[1] == "parent":
else:

        it "maintains LIFO order":
            """
            TODO: Add documentation here
            """

fn lifo_teardown(items: List<text>) -> List<text>:
    var reversed = []
    var i = items.len() - 1
    while i >= 0:
        reversed = reversed + [items[i]]
        i = i - 1
    return reversed

val original = ["first", "second", "third"]
val lifo = lifo_teardown(original)
if lifo[0] == "third" and lifo[2] == "first":
else:

# =====================================================
# Documentation Output
# =====================================================

print('')
print('  GENERATED DOCUMENTATION')
print('')
print('# After Each Hooks')
print('')
print("**Feature ID:** #184")
print("**Category:** Testing Framework")
print("**Difficulty:** Level 2/5")
print("**Status:** Complete")
print("**Implementation:** Simple")
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Usage Example')
print('')
print('```simple')
describe ""Database"":
    """
    TODO: Add documentation here
    """
print('    after_each:')
print('        db.rollback()')
print('        db.close()')
print('')
        it ""inserts record"":
            """
            TODO: Add documentation here
            """
print('        db.insert(record)')
print('        expect(db.count).to eq(1)')
print('```')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('  TEST SUMMARY')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
    print('All tests PASSED!')