# BDD Tests for CallEventRecorder
# Feature: Diagram Generation - Call Event Recording
#
# Tests the call event recorder for capturing function call sequences
# during test execution for diagram generation.

import std.spec
import diagram.{CallEvent, CallEventRecorder, CallType, record_call, record_return}

describe "CallEventRecorder":
    context "Initialization":
        it "should create empty recorder":
            let rec = CallEventRecorder.new("test_case")
            expect rec.event_count() == 0
            expect rec.current_depth() == 0

        it "should store test name":
            let rec = CallEventRecorder.new("my_test")
            expect rec.test_name == "my_test"

        it "should start recording by default":
            let rec = CallEventRecorder.new("test")
            expect rec.is_recording == true

    context "Recording calls":
        it "should record a simple function call":
            let rec = CallEventRecorder.new("test")
            rec.record_call("target_fn", None, [], CallType.Direct)

            expect rec.event_count() == 1
            let events = rec.get_events()
            expect events[0].callee == "target_fn"
            expect events[0].is_return == false

        it "should record method call with class":
            let rec = CallEventRecorder.new("test")
            rec.record_call("do_work", Some("MyClass"), ["arg1"], CallType.Method)

            let events = rec.get_events()
            expect events[0].callee == "do_work"
            expect events[0].callee_class == Some("MyClass")
            expect events[0].call_type == CallType.Method

        it "should capture arguments":
            let rec = CallEventRecorder.new("test")
            rec.record_call("fn", None, ["a", "b", "c"], CallType.Direct)

            let events = rec.get_events()
            expect events[0].arguments.len() == 3
            expect events[0].arguments[0] == "a"
            expect events[0].arguments[1] == "b"
            expect events[0].arguments[2] == "c"

        it "should track sequence numbers":
            let rec = CallEventRecorder.new("test")
            rec.record_call("fn1", None, [], CallType.Direct)
            rec.record_call("fn2", None, [], CallType.Direct)
            rec.record_call("fn3", None, [], CallType.Direct)

            let events = rec.get_events()
            expect events[0].sequence_num == 0
            expect events[1].sequence_num == 1
            expect events[2].sequence_num == 2

    context "Call stack tracking":
        it "should track call depth":
            let rec = CallEventRecorder.new("test")

            # Call at depth 0
            rec.record_call("outer", None, [], CallType.Direct)
            expect rec.current_depth() == 1

            # Nested call at depth 1
            rec.record_call("inner", None, [], CallType.Direct)
            expect rec.current_depth() == 2

        it "should record caller from stack":
            let rec = CallEventRecorder.new("test")

            rec.record_call("outer", None, [], CallType.Direct)
            rec.record_call("inner", None, [], CallType.Direct)

            let events = rec.get_events()
            expect events[0].caller == "(test)"  # No caller for first call
            expect events[1].caller == "outer"   # outer called inner

        it "should handle return and update depth":
            let rec = CallEventRecorder.new("test")

            rec.record_call("outer", None, [], CallType.Direct)
            rec.record_call("inner", None, [], CallType.Direct)
            expect rec.current_depth() == 2

            rec.record_return(Some("result"))
            expect rec.current_depth() == 1

    context "Recording returns":
        it "should record return event":
            let rec = CallEventRecorder.new("test")

            rec.record_call("fn", None, [], CallType.Direct)
            rec.record_return(Some("42"))

            expect rec.event_count() == 2
            let events = rec.get_events()
            expect events[1].is_return == true
            expect events[1].return_value == Some("42")

        it "should handle void return":
            let rec = CallEventRecorder.new("test")

            rec.record_call("fn", None, [], CallType.Direct)
            rec.record_return(None)

            let events = rec.get_events()
            expect events[1].return_value == None

        it "should match return to correct call":
            let rec = CallEventRecorder.new("test")

            rec.record_call("outer", None, [], CallType.Direct)
            rec.record_call("inner", None, [], CallType.Direct)
            rec.record_return(Some("inner_result"))

            let events = rec.get_events()
            expect events[2].callee == "inner"  # Return from inner

    context "Class tracking":
        it "should collect seen classes":
            let rec = CallEventRecorder.new("test")

            rec.record_call("method1", Some("ClassA"), [], CallType.Method)
            rec.record_call("method2", Some("ClassB"), [], CallType.Method)
            rec.record_call("method3", Some("ClassA"), [], CallType.Method)

            let classes = rec.get_classes()
            expect classes.len() == 2
            expect classes.contains("ClassA") == true
            expect classes.contains("ClassB") == true

    context "Architectural entities":
        it "should mark entities as architectural":
            let rec = CallEventRecorder.new("test")

            rec.mark_architectural("UserService")
            rec.mark_architectural("Database")

            expect rec.is_architectural("UserService") == true
            expect rec.is_architectural("Database") == true
            expect rec.is_architectural("SomeClass") == false

        it "should return architectural entities set":
            let rec = CallEventRecorder.new("test")

            rec.mark_architectural("Service")
            rec.mark_architectural("Repository")

            let entities = rec.get_architectural_entities()
            expect entities.len() == 2

    context "Recording control":
        it "should stop recording when stopped":
            let rec = CallEventRecorder.new("test")

            rec.record_call("fn1", None, [], CallType.Direct)
            rec.stop()
            rec.record_call("fn2", None, [], CallType.Direct)

            expect rec.event_count() == 1

        it "should resume recording after start":
            let rec = CallEventRecorder.new("test")

            rec.stop()
            rec.start()
            rec.record_call("fn", None, [], CallType.Direct)

            expect rec.event_count() == 1

        it "should clear all events":
            let rec = CallEventRecorder.new("test")

            rec.record_call("fn1", None, [], CallType.Direct)
            rec.record_call("fn2", None, [], CallType.Direct)
            rec.clear()

            expect rec.event_count() == 0
            expect rec.get_classes().len() == 0

    context "CallEvent formatting":
        it "should format call with args":
            let event = CallEvent.new_call(
                0, 100, "caller", "target",
                None, Some("MyClass"),
                ["x", "y"],
                CallType.Method, 0
            )

            expect event.format_call() == "MyClass.target(x, y)"

        it "should format call without class":
            let event = CallEvent.new_call(
                0, 100, "caller", "standalone_fn",
                None, None,
                ["arg"],
                CallType.Direct, 0
            )

            expect event.format_call() == "standalone_fn(arg)"

        it "should get participant names":
            let event = CallEvent.new_call(
                0, 100, "caller", "method",
                Some("CallerClass"), Some("CalleeClass"),
                [],
                CallType.Method, 0
            )

            expect event.get_caller_participant() == "CallerClass"
            expect event.get_callee_participant() == "CalleeClass"

        it "should format return value":
            let event = CallEvent.new_return(
                0, 100, "caller", "callee",
                None, None,
                Some("Result(42)"),
                0
            )

            expect event.format_return() == "Result(42)"

        it "should format void return":
            let event = CallEvent.new_return(
                0, 100, "caller", "callee",
                None, None,
                None,
                0
            )

            expect event.format_return() == "(void)"
