# Generator Codegen Feature Specification
# Feature #96: Generator state machine code generation
# Category: Codegen | Difficulty: 4 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 96,
    name: 'Generator Codegen',
    category: 'Codegen',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'src/compiler/src/mir/generator.rs',
    files: [
        'src/compiler/src/mir/generator.rs',
        'src/compiler/src/mir/state_machine_utils.rs',
        'src/compiler/src/codegen/instr_async.rs'
    ],
    tests: [
        'src/driver/tests/runner_async_tests.rs'
    ],
    description: 'Generator state machine code generation. Transforms generator functions with yield statements into resumable state machines with dispatcher entry blocks.',
    code_examples: [],
    dependencies: [5, 42],
    required_by: [],
    notes: 'Generators are lowered to state machines with dispatcher + resume blocks. Liveness analysis preserves values across suspension points.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  GENERATOR CODEGEN FEATURE SPECIFICATION (#96)')
print('  Category: Codegen | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

# -----------------------------------------------------
# Basic Generator State Machine
# -----------------------------------------------------

print('describe Generator state machine:')
print('  context single yield:')
print('    it generates dispatcher for single yield:')

let gen1 = generator(\: yield 42)
let val1 = next(gen1)
if val1 == 42:
    print('      [PASS] single yield state machine')
    passed = passed + 1
else:
    print('      [FAIL] single yield state machine')
    failed = failed + 1

print('    it returns nil after exhaustion:')

let gen_exhaust = generator(\: yield 100)
let first = next(gen_exhaust)
let second = next(gen_exhaust)
if first == 100 and second == nil:
    print('      [PASS] exhaustion returns nil')
    passed = passed + 1
else:
    print('      [FAIL] exhaustion returns nil')
    failed = failed + 1

# -----------------------------------------------------
# Multiple Yield Points
# -----------------------------------------------------

print('')
print('  context multiple yields:')
print('    it handles sequential yields:')

let gen_seq = generator(\: [yield 1, yield 2, yield 3])
let v1 = next(gen_seq)
let v2 = next(gen_seq)
let v3 = next(gen_seq)
if v1 == 1 and v2 == 2 and v3 == 3:
    print('      [PASS] sequential yields')
    passed = passed + 1
else:
    print('      [FAIL] sequential yields')
    failed = failed + 1

print('    it creates correct state transitions:')

let gen_states = generator(\: [yield 10, yield 20, yield 30, yield 40])
let sum_states = next(gen_states) + next(gen_states) + next(gen_states) + next(gen_states)
if sum_states == 100:
    print('      [PASS] state transitions')
    passed = passed + 1
else:
    print('      [FAIL] state transitions')
    failed = failed + 1

# -----------------------------------------------------
# Value Preservation Across Yields
# -----------------------------------------------------

print('')
print('describe Value preservation:')
print('  context computed value preservation:')
print('    it preserves computed values:')

let gen_preserve = generator(\: [yield 10, yield 20, yield 30])
let p1 = next(gen_preserve)
let p2 = next(gen_preserve)
let p3 = next(gen_preserve)
if p1 == 10 and p2 == 20 and p3 == 30:
    print('      [PASS] value preservation')
    passed = passed + 1
else:
    print('      [FAIL] value preservation')
    failed = failed + 1

print('    it preserves incremental values:')

let gen_incr = generator(\: [yield 1, yield 2, yield 3])
let m1 = next(gen_incr)
let m2 = next(gen_incr)
let m3 = next(gen_incr)
if m1 == 1 and m2 == 2 and m3 == 3:
    print('      [PASS] incremental values')
    passed = passed + 1
else:
    print('      [FAIL] incremental values')
    failed = failed + 1

# -----------------------------------------------------
# Control Flow in Generators
# -----------------------------------------------------

print('')
print('describe Control flow lowering:')
print('  context sequential yields:')
print('    it handles sequential control:')

let gen_seq2 = generator(\: [yield 5, yield 10, yield 15])
let seq_sum = next(gen_seq2) + next(gen_seq2) + next(gen_seq2)
if seq_sum == 30:
    print('      [PASS] sequential control')
    passed = passed + 1
else:
    print('      [FAIL] sequential control')
    failed = failed + 1

print('')
print('  context alternating yields:')
print('    it handles alternating patterns:')

let gen_alt = generator(\: [yield 1, yield 10, yield 2, yield 20])
let a1 = next(gen_alt)
let a2 = next(gen_alt)
let a3 = next(gen_alt)
let a4 = next(gen_alt)
if a1 == 1 and a2 == 10 and a3 == 2 and a4 == 20:
    print('      [PASS] alternating patterns')
    passed = passed + 1
else:
    print('      [FAIL] alternating patterns')
    failed = failed + 1

# -----------------------------------------------------
# Generator with External State
# -----------------------------------------------------

print('')
print('describe External state capture:')
print('  context captured variables:')
print('    it captures external values:')

let base_val = 100
let gen_capture = generator(\: [yield base_val, yield base_val])
let c1 = next(gen_capture)
let c2 = next(gen_capture)
if c1 == 100 and c2 == 100:
    print('      [PASS] captured values')
    passed = passed + 1
else:
    print('      [FAIL] captured values')
    failed = failed + 1

# -----------------------------------------------------
# Generator Composition
# -----------------------------------------------------

print('')
print('describe Generator composition:')
print('  context multiple generators:')
print('    it handles concurrent generators:')

let gen_a = generator(\: [yield 1, yield 2])
let gen_b = generator(\: [yield 10, yield 20])

let a1 = next(gen_a)
let b1 = next(gen_b)
let a2 = next(gen_a)
let b2 = next(gen_b)

if a1 == 1 and b1 == 10 and a2 == 2 and b2 == 20:
    print('      [PASS] concurrent generators')
    passed = passed + 1
else:
    print('      [FAIL] concurrent generators')
    failed = failed + 1

# -----------------------------------------------------
# Generator Collection
# -----------------------------------------------------

print('')
print('describe Generator collection:')
print('  context collect to array:')
print('    it collects generator values:')

let gen_collect = generator(\: [yield 1, yield 2, yield 3])
let collected = collect(gen_collect)
if collected.len() == 3 and collected[0] == 1 and collected[2] == 3:
    print('      [PASS] collect generator')
    passed = passed + 1
else:
    print('      [FAIL] collect generator')
    failed = failed + 1

# -----------------------------------------------------
# Range Generator Pattern
# -----------------------------------------------------

print('')
print('describe Range generator pattern:')
print('  context counting generator:')
print('    it generates range values:')

let gen_range = generator(\: [yield 0, yield 1, yield 2, yield 3, yield 4])
let range_sum = next(gen_range) + next(gen_range) + next(gen_range) + next(gen_range) + next(gen_range)
if range_sum == 10:
    print('      [PASS] range generator')
    passed = passed + 1
else:
    print('      [FAIL] range generator')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Generator Codegen')
print('')
print("**Feature ID:** #96")
print("**Category:** Codegen")
print("**Difficulty:** Level 4/5")
print("**Status:** Complete")
print("**Implementation:** Rust")
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## State Machine Structure')
print('')
print('| Component | Purpose |')
print('|-----------|---------|')
print('| Dispatcher | Entry block routing by state |')
print('| Resume Blocks | Continuation after each yield |')
print('| State Variable | Tracks current suspension point |')
print('| Frame | Preserved local variables |')
print('')
print('## Lowering Process')
print('')
print('1. Identify yield points in generator body')
print('2. Split blocks at each yield')
print('3. Create dispatcher with state-based jumps')
print('4. Generate resume blocks for continuations')
print('5. Compute liveness for frame allocation')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
