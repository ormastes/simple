# Error Handling Feature Specification
# Feature #35: Result-based error handling
# Category: Control Flow | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List<String>
    tests: List<String>
    description: String
    code_examples: List<String>
    dependencies: List<Int>
    required_by: List<Int>
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 35,
    name: 'Error Handling',
    category: 'Control Flow',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/types.md',
    files: [
        'src/compiler/src/interpreter.rs',
        'src/runtime/src/value/objects.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_advanced_features_tests.rs'
    ],
    description: 'Result-based error handling with Ok/Err variants. Supports unwrap, is_ok/is_err checks, unwrap_or, and the ? operator for error propagation.',
    code_examples: [],
    dependencies: [10, 27],
    required_by: [],
    notes: 'Uses algebraic Result type instead of exceptions. The ? operator enables concise error propagation.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  ERROR HANDLING FEATURE SPECIFICATION (#35)')
print('  Category: Control Flow | Difficulty: 3 | Status: Complete')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

# -----------------------------------------------------
# Result Type Basics
# -----------------------------------------------------

print('describe Result type:')
print('  context Ok variant:')
print('    it creates Ok with value:')

let res_ok = Ok(42)
if res_ok.unwrap() == 42:
    print('      [PASS] Ok unwrap returns value')
    passed = passed + 1
else:
    print('      [FAIL] Ok unwrap returns value')
    failed = failed + 1

print('    it detects Ok with is_ok:')

if res_ok.is_ok():
    print('      [PASS] is_ok returns true')
    passed = passed + 1
else:
    print('      [FAIL] is_ok returns true')
    failed = failed + 1

print('    it is not Err:')

if not res_ok.is_err():
    print('      [PASS] is_err returns false')
    passed = passed + 1
else:
    print('      [FAIL] is_err returns false')
    failed = failed + 1

print('')
print('  context Err variant:')
print('    it creates Err with message:')

let res_err = Err("error message")
if res_err.is_err():
    print('      [PASS] is_err returns true')
    passed = passed + 1
else:
    print('      [FAIL] is_err returns true')
    failed = failed + 1

print('    it is not Ok:')

if not res_err.is_ok():
    print('      [PASS] is_ok returns false')
    passed = passed + 1
else:
    print('      [FAIL] is_ok returns false')
    failed = failed + 1

# -----------------------------------------------------
# unwrap_or
# -----------------------------------------------------

print('')
print('describe unwrap_or:')
print('  context with Ok value:')
print('    it returns the Ok value:')

let ok_result = Ok(100)
if ok_result.unwrap_or(0) == 100:
    print('      [PASS] unwrap_or returns Ok value')
    passed = passed + 1
else:
    print('      [FAIL] unwrap_or returns Ok value')
    failed = failed + 1

print('')
print('  context with Err value:')
print('    it returns the fallback:')

let err_result = Err("failed")
if err_result.unwrap_or(99) == 99:
    print('      [PASS] unwrap_or returns fallback')
    passed = passed + 1
else:
    print('      [FAIL] unwrap_or returns fallback')
    failed = failed + 1

# -----------------------------------------------------
# Functions Returning Result
# -----------------------------------------------------

print('')
print('describe Functions returning Result:')
print('  context safe division:')
print('    it returns Ok for valid division:')

fn safe_divide(a, b):
    if b == 0:
        return Err("division by zero")
    return Ok(a / b)

let div_result = safe_divide(20, 4)
if div_result.unwrap() == 5:
    print('      [PASS] safe_divide returns Ok')
    passed = passed + 1
else:
    print('      [FAIL] safe_divide returns Ok')
    failed = failed + 1

print('    it returns Err for zero divisor:')

let zero_result = safe_divide(10, 0)
if zero_result.is_err():
    print('      [PASS] safe_divide returns Err')
    passed = passed + 1
else:
    print('      [FAIL] safe_divide returns Err')
    failed = failed + 1

print('    it works with unwrap_or:')

if safe_divide(10, 0).unwrap_or(-1) == -1:
    print('      [PASS] handles Err with unwrap_or')
    passed = passed + 1
else:
    print('      [FAIL] handles Err with unwrap_or')
    failed = failed + 1

# -----------------------------------------------------
# ? Operator for Error Propagation
# -----------------------------------------------------

print('')
print('describe Question mark operator:')
print('  context propagating Ok:')
print('    it continues execution on Ok:')

fn may_fail(x):
    if x < 0:
        return Err("negative")
    return Ok(x * 2)

fn caller_ok(x):
    let val = may_fail(x)?
    return Ok(val + 1)

let prop_result = caller_ok(5)
if prop_result.unwrap() == 11:
    print('      [PASS] ? continues on Ok')
    passed = passed + 1
else:
    print('      [FAIL] ? continues on Ok')
    failed = failed + 1

print('')
print('  context propagating Err:')
print('    it returns early on Err:')

fn caller_err(x):
    let val = may_fail(x)?
    return Ok(val + 1)

let early_result = caller_err(-5)
if early_result.unwrap_or(-99) == -99:
    print('      [PASS] ? propagates Err')
    passed = passed + 1
else:
    print('      [FAIL] ? propagates Err')
    failed = failed + 1

print('')
print('  context chained operations:')
print('    it chains multiple ? operators:')

fn step1(x):
    if x < 0:
        return Err("step1 failed")
    return Ok(x + 10)

fn step2(x):
    if x > 100:
        return Err("step2 failed")
    return Ok(x * 2)

fn pipeline(x):
    let a = step1(x)?
    let b = step2(a)?
    return Ok(b)

let chain_result = pipeline(5)
if chain_result.unwrap() == 30:
    print('      [PASS] chained ? operators')
    passed = passed + 1
else:
    print('      [FAIL] chained ? operators')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Error Handling')
print('')
print('**Feature ID:** #35')
print('**Category:** Control Flow')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Result Type')
print('')
print('```simple')
print('# Creating Results')
print('let ok = Ok(42)')
print('let err = Err("error message")')
print('')
print('# Checking state')
print('if result.is_ok():')
print('    # handle success')
print('if result.is_err():')
print('    # handle error')
print('')
print('# Extracting values')
print('let value = result.unwrap()        # panics on Err')
print('let value = result.unwrap_or(0)    # returns 0 on Err')
print('```')
print('')
print('## Error Propagation')
print('')
print('```simple')
print('fn caller():')
print('    let val = may_fail()?  # Returns early if Err')
print('    return Ok(val + 1)')
print('```')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
