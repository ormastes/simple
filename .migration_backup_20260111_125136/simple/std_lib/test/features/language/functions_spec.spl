# Functions Feature Specification
# Feature #12: Named functions, closures, lambdas, higher-order functions
# Category: Language | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List<String>
    tests: List<String>
    description: String
    code_examples: List<String>
    dependencies: List<Int>
    required_by: List<Int>
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 12,
    name: "Functions",
    category: "Language",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: [
        "src/compiler/src/interpreter_call.rs",
        "src/parser/src/expressions/mod.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_basic_tests.rs"
    ],
    description: "First-class functions with lexical closure. Supports named functions, anonymous lambdas, default parameters, variadic arguments, and higher-order functions like map/filter/reduce.",
    code_examples: [
        "# Named function",
        "fn greet(name: String) -> String:",
        "    return \"Hello, \" + name + \"!\"",
        "",
        "# Lambda expression",
        "let double = \\x: x * 2",
        "",
        "# Higher-order functions",
        "let evens = [1,2,3,4].filter(\\x: x % 2 == 0)"
    ],
    dependencies: [1, 2],
    required_by: [11],
    notes: "Functions are first-class values. Closures capture lexical environment."
}

# =====================================================
# BDD Specification Tests
# =====================================================

print("============================================================")
print("  FUNCTIONS FEATURE SPECIFICATION (#12)")
print("  Category: Language | Difficulty: 3 | Status: Complete")
print("============================================================")
print("")

let mut passed = 0
let mut failed = 0

print("describe Function definitions:")

print("  it defines and calls named functions:")
fn add(a, b):
    return a + b
if add(2, 3) == 5:
    print("    [PASS] named function add(2, 3) = 5")
    passed = passed + 1
else:
    print("    [FAIL] named function")
    failed = failed + 1

print("  it supports recursive functions:")
fn factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
if factorial(5) == 120:
    print("    [PASS] recursive factorial(5) = 120")
    passed = passed + 1
else:
    print("    [FAIL] recursive function")
    failed = failed + 1

print("  it supports nested functions:")
fn outer(x):
    fn inner(y):
        return x + y
    return inner(10)
if outer(5) == 15:
    print("    [PASS] nested function")
    passed = passed + 1
else:
    print("    [FAIL] nested function")
    failed = failed + 1

print("")
print("describe Lambda expressions:")

print("  it creates inline lambdas:")
let double = \x: x * 2
if double(5) == 10:
    print("    [PASS] lambda \\x: x * 2")
    passed = passed + 1
else:
    print("    [FAIL] lambda")
    failed = failed + 1

print("  it supports multi-param lambdas:")
let add_lambda = \a, b: a + b
if add_lambda(3, 4) == 7:
    print("    [PASS] multi-param lambda")
    passed = passed + 1
else:
    print("    [FAIL] multi-param lambda")
    failed = failed + 1

print("")
print("describe Higher-order functions:")

print("  it uses map:")
let nums = [1, 2, 3]
let doubled = nums.map(\x: x * 2)
if doubled == [2, 4, 6]:
    print("    [PASS] map doubles list")
    passed = passed + 1
else:
    print("    [FAIL] map")
    failed = failed + 1

print("  it uses filter:")
let nums2 = [1, 2, 3, 4, 5]
let evens = nums2.filter(\x: x % 2 == 0)
if evens == [2, 4]:
    print("    [PASS] filter keeps evens")
    passed = passed + 1
else:
    print("    [FAIL] filter")
    failed = failed + 1

print("  it uses reduce:")
let nums3 = [1, 2, 3, 4]
let sum = nums3.reduce(0, \acc, x: acc + x)
if sum == 10:
    print("    [PASS] reduce sums to 10")
    passed = passed + 1
else:
    print("    [FAIL] reduce")
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# {FEATURE.name}")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5")
print("**Status:** {FEATURE.status}")
print("**Implementation:** {FEATURE.impl_type}")
print("")
print("## Description")
print("")
print(FEATURE.description)
print("")
print("## Implementation Files")
print("")
for file in FEATURE.files:
    print("- `{file}`")
print("")
print("## Test Files")
print("")
for test in FEATURE.tests:
    print("- `{test}`")
print("")
print("## Code Examples")
print("")
print("```simple")
for example in FEATURE.code_examples:
    print(example)
print("```")
print("")
if FEATURE.dependencies.len() > 0:
    print("## Dependencies")
    print("")
    print("Depends on: {FEATURE.dependencies}")
    print("")
if FEATURE.required_by.len() > 0:
    print("## Required By")
    print("")
    print("Features: {FEATURE.required_by}")
    print("")
print("## Notes")
print("")
print(FEATURE.notes)

# Summary
print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print("Passed: {passed}")
print("Failed: {failed}")
if failed == 0:
    print("All tests PASSED!")
print("============================================================")
