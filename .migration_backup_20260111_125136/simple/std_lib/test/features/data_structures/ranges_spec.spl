# Ranges Feature Specification
# Feature #34: Range Expressions
# Category: Data Structures | Difficulty: 2 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List<String>
    tests: List<String>
    description: String
    code_examples: List<String>
    dependencies: List<Int>
    required_by: List<Int>
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 34,
    name: 'Ranges',
    category: 'Data Structures',
    difficulty: 2,
    status: 'Complete',
    impl_type: 'Simple',
    spec_ref: 'doc/spec/data_structures.md',
    files: [
        'simple/std_lib/src/core/range.spl'
    ],
    tests: [
        'simple/std_lib/test/unit/core/range_spec.spl'
    ],
    description: 'Range expressions for iteration and slicing. Supports inclusive (start..end), exclusive (start..<end), and unbounded ranges.',
    code_examples: [],
    dependencies: [13],
    required_by: [],
    notes: 'Lazy evaluation for memory efficiency. Step parameter for custom increments. Used with for loops and slice operations.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  RANGES FEATURE SPECIFICATION (#34)')
print('  Category: Data Structures | Difficulty: 2 | Status: Complete')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

# -----------------------------------------------------
# Range Creation
# -----------------------------------------------------

print('describe Range creation:')
print('  context inclusive range:')
print('    it creates start..end:')

struct Range:
    start: i64
    end_val: i64
    inclusive: Bool
    step: i64

fn range_inclusive(s: i64, e: i64) -> Range:
    return Range { start: s, end_val: e, inclusive: true, step: 1 }

let incl = range_inclusive(1, 5)
if incl.start == 1 and incl.end_val == 5 and incl.inclusive:
    print('      [PASS] inclusive range')
    passed = passed + 1
else:
    print('      [FAIL] inclusive range')
    failed = failed + 1

print('')
print('  context exclusive range:')
print('    it creates start..<end:')

fn range_exclusive(s: i64, e: i64) -> Range:
    return Range { start: s, end_val: e, inclusive: false, step: 1 }

let excl = range_exclusive(1, 5)
if excl.start == 1 and excl.end_val == 5 and not excl.inclusive:
    print('      [PASS] exclusive range')
    passed = passed + 1
else:
    print('      [FAIL] exclusive range')
    failed = failed + 1

print('')
print('  context with step:')
print('    it creates stepped range:')

fn range_with_step(s: i64, e: i64, st: i64) -> Range:
    return Range { start: s, end_val: e, inclusive: true, step: st }

let stepped = range_with_step(0, 10, 2)
if stepped.step == 2:
    print('      [PASS] stepped range')
    passed = passed + 1
else:
    print('      [FAIL] stepped range')
    failed = failed + 1

# -----------------------------------------------------
# Range Iteration
# -----------------------------------------------------

print('')
print('describe Range iteration:')
print('  context to list:')
print('    it converts inclusive to list:')

fn range_to_list(r: Range) -> List<i64>:
    let mut result = []
    let mut i = r.start
    if r.inclusive:
        while i <= r.end_val:
            result = result + [i]
            i = i + r.step
    else:
        while i < r.end_val:
            result = result + [i]
            i = i + r.step
    return result

let incl_list = range_to_list(incl)
if incl_list.len() == 5:
    print('      [PASS] inclusive to list')
    passed = passed + 1
else:
    print('      [FAIL] inclusive to list')
    failed = failed + 1

print('    it converts exclusive to list:')

let excl_list = range_to_list(excl)
if excl_list.len() == 4:
    print('      [PASS] exclusive to list')
    passed = passed + 1
else:
    print('      [FAIL] exclusive to list')
    failed = failed + 1

print('    it applies step:')

let stepped_list = range_to_list(stepped)
if stepped_list.len() == 6:
    print('      [PASS] step applied')
    passed = passed + 1
else:
    print('      [FAIL] step applied')
    failed = failed + 1

print('')
print('  context sum over range:')
print('    it sums range values:')

fn range_sum(r: Range) -> i64:
    let items = range_to_list(r)
    let mut total = 0
    let mut i = 0
    while i < items.len():
        total = total + items[i]
        i = i + 1
    return total

let sum_range = range_inclusive(1, 5)
if range_sum(sum_range) == 15:
    print('      [PASS] range sum')
    passed = passed + 1
else:
    print('      [FAIL] range sum')
    failed = failed + 1

# -----------------------------------------------------
# Range Properties
# -----------------------------------------------------

print('')
print('describe Range properties:')
print('  context length:')
print('    it calculates inclusive length:')

fn range_len(r: Range) -> i64:
    if r.inclusive:
        return ((r.end_val - r.start) / r.step) + 1
    else:
        return (r.end_val - r.start) / r.step

if range_len(incl) == 5:
    print('      [PASS] inclusive length')
    passed = passed + 1
else:
    print('      [FAIL] inclusive length')
    failed = failed + 1

print('    it calculates exclusive length:')

if range_len(excl) == 4:
    print('      [PASS] exclusive length')
    passed = passed + 1
else:
    print('      [FAIL] exclusive length')
    failed = failed + 1

print('')
print('  context contains:')
print('    it checks membership:')

fn range_contains(r: Range, val: i64) -> Bool:
    if val < r.start:
        return false
    if r.inclusive:
        return val <= r.end_val
    else:
        return val < r.end_val

if range_contains(incl, 3):
    print('      [PASS] contains value')
    passed = passed + 1
else:
    print('      [FAIL] contains value')
    failed = failed + 1

print('    it excludes out of range:')

if not range_contains(incl, 6):
    print('      [PASS] excludes out of range')
    passed = passed + 1
else:
    print('      [FAIL] excludes out of range')
    failed = failed + 1

print('')
print('  context empty check:')
print('    it detects empty range:')

fn range_is_empty(r: Range) -> Bool:
    if r.inclusive:
        return r.start > r.end_val
    else:
        return r.start >= r.end_val

let empty_range = range_exclusive(5, 5)
if range_is_empty(empty_range):
    print('      [PASS] empty detected')
    passed = passed + 1
else:
    print('      [FAIL] empty detected')
    failed = failed + 1

# -----------------------------------------------------
# Reverse Range
# -----------------------------------------------------

print('')
print('describe Reverse range:')
print('  context descending:')
print('    it creates reverse range:')

fn range_reverse(s: i64, e: i64) -> Range:
    return Range { start: s, end_val: e, inclusive: true, step: -1 }

fn reverse_to_list(r: Range) -> List<i64>:
    let mut result = []
    let mut i = r.start
    while i >= r.end_val:
        result = result + [i]
        i = i + r.step
    return result

let rev = range_reverse(5, 1)
let rev_list = reverse_to_list(rev)
if rev_list.len() == 5 and rev_list[0] == 5:
    print('      [PASS] reverse range')
    passed = passed + 1
else:
    print('      [FAIL] reverse range')
    failed = failed + 1

# -----------------------------------------------------
# Slice Application
# -----------------------------------------------------

print('')
print('describe Slice application:')
print('  context array slicing:')
print('    it slices array with range:')

fn slice_array(arr: List<i64>, r: Range) -> List<i64>:
    let mut result = []
    let indices = range_to_list(r)
    let mut i = 0
    while i < indices.len():
        let idx = indices[i]
        if idx >= 0 and idx < arr.len():
            result = result + [arr[idx]]
        i = i + 1
    return result

let arr = [10, 20, 30, 40, 50]
let slice_range = range_exclusive(1, 4)
let sliced = slice_array(arr, slice_range)
if sliced.len() == 3 and sliced[0] == 20:
    print('      [PASS] array sliced')
    passed = passed + 1
else:
    print('      [FAIL] array sliced')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Ranges')
print('')
print('**Feature ID:** #34')
print('**Category:** Data Structures')
print('**Difficulty:** Level 2/5')
print('**Status:** Complete')
print('**Implementation:** Simple')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Range Types')
print('')
print('| Syntax | Type | Example |')
print('|--------|------|---------|')
print('| start..end | Inclusive | 1..5 = [1,2,3,4,5] |')
print('| start..<end | Exclusive | 1..<5 = [1,2,3,4] |')
print('| start..end by step | Stepped | 0..10 by 2 = [0,2,4,6,8,10] |')
print('')
print('## Operations')
print('')
print('| Operation | Description |')
print('|-----------|-------------|')
print('| len() | Number of elements |')
print('| contains(v) | Check if v in range |')
print('| to_list() | Convert to list |')
print('| reverse() | Iterate backwards |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
