# Sets Feature Specification
# Feature #33: Set Data Structure
# Category: Data Structures | Difficulty: 2 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List<String>
    tests: List<String>
    description: String
    code_examples: List<String>
    dependencies: List<Int>
    required_by: List<Int>
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 33,
    name: 'Sets',
    category: 'Data Structures',
    difficulty: 2,
    status: 'Complete',
    impl_type: 'Simple',
    spec_ref: 'doc/spec/data_structures.md',
    files: [
        'simple/std_lib/src/core/collections/set.spl'
    ],
    tests: [
        'simple/std_lib/test/unit/core/set_spec.spl'
    ],
    description: 'Unordered collection of unique elements. Supports add, remove, contains, and set operations (union, intersection, difference).',
    code_examples: [],
    dependencies: [20],
    required_by: [],
    notes: 'Hash-based for O(1) operations. Elements must be hashable. Iteration order not guaranteed.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  SETS FEATURE SPECIFICATION (#33)')
print('  Category: Data Structures | Difficulty: 2 | Status: Complete')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

# -----------------------------------------------------
# Set Creation
# -----------------------------------------------------

print('describe Set creation:')
print('  context empty set:')
print('    it creates empty set:')

struct SimpleSet:
    elements: List<i64>

fn new_set() -> SimpleSet:
    return SimpleSet { elements: [] }

let empty = new_set()
if empty.elements.len() == 0:
    print('      [PASS] empty set created')
    passed = passed + 1
else:
    print('      [FAIL] empty set created')
    failed = failed + 1

print('')
print('  context from elements:')
print('    it creates from list:')

fn set_from_list(items: List<i64>) -> SimpleSet:
    let mut unique = []
    let mut i = 0
    while i < items.len():
        let mut found = false
        let mut j = 0
        while j < unique.len():
            if unique[j] == items[i]:
                found = true
            j = j + 1
        if not found:
            unique = unique + [items[i]]
        i = i + 1
    return SimpleSet { elements: unique }

let from_list = set_from_list([1, 2, 3, 2, 1])
if from_list.elements.len() == 3:
    print('      [PASS] created from list')
    passed = passed + 1
else:
    print('      [FAIL] created from list')
    failed = failed + 1

# -----------------------------------------------------
# Element Operations
# -----------------------------------------------------

print('')
print('describe Element operations:')
print('  context add element:')
print('    it adds new element:')

fn set_add(s: SimpleSet, elem: i64) -> SimpleSet:
    let mut i = 0
    while i < s.elements.len():
        if s.elements[i] == elem:
            return s
        i = i + 1
    return SimpleSet { elements: s.elements + [elem] }

let with_elem = set_add(empty, 42)
if with_elem.elements.len() == 1:
    print('      [PASS] element added')
    passed = passed + 1
else:
    print('      [FAIL] element added')
    failed = failed + 1

print('    it ignores duplicates:')

let with_dup = set_add(with_elem, 42)
if with_dup.elements.len() == 1:
    print('      [PASS] duplicate ignored')
    passed = passed + 1
else:
    print('      [FAIL] duplicate ignored')
    failed = failed + 1

print('')
print('  context contains check:')
print('    it finds element:')

fn set_contains(s: SimpleSet, elem: i64) -> Bool:
    let mut i = 0
    while i < s.elements.len():
        if s.elements[i] == elem:
            return true
        i = i + 1
    return false

if set_contains(with_elem, 42):
    print('      [PASS] element found')
    passed = passed + 1
else:
    print('      [FAIL] element found')
    failed = failed + 1

print('    it returns false for missing:')

if not set_contains(with_elem, 99):
    print('      [PASS] missing not found')
    passed = passed + 1
else:
    print('      [FAIL] missing not found')
    failed = failed + 1

print('')
print('  context remove element:')
print('    it removes element:')

fn set_remove(s: SimpleSet, elem: i64) -> SimpleSet:
    let mut result = []
    let mut i = 0
    while i < s.elements.len():
        if s.elements[i] != elem:
            result = result + [s.elements[i]]
        i = i + 1
    return SimpleSet { elements: result }

let multi = set_from_list([1, 2, 3])
let removed = set_remove(multi, 2)
if removed.elements.len() == 2 and not set_contains(removed, 2):
    print('      [PASS] element removed')
    passed = passed + 1
else:
    print('      [FAIL] element removed')
    failed = failed + 1

# -----------------------------------------------------
# Set Operations
# -----------------------------------------------------

print('')
print('describe Set operations:')
print('  context union:')
print('    it combines sets:')

fn set_union(a: SimpleSet, b: SimpleSet) -> SimpleSet:
    let mut result = a
    let mut i = 0
    while i < b.elements.len():
        result = set_add(result, b.elements[i])
        i = i + 1
    return result

let set_a = set_from_list([1, 2, 3])
let set_b = set_from_list([3, 4, 5])
let union_set = set_union(set_a, set_b)
if union_set.elements.len() == 5:
    print('      [PASS] union combines')
    passed = passed + 1
else:
    print('      [FAIL] union combines')
    failed = failed + 1

print('')
print('  context intersection:')
print('    it finds common elements:')

fn set_intersection(a: SimpleSet, b: SimpleSet) -> SimpleSet:
    let mut result = []
    let mut i = 0
    while i < a.elements.len():
        if set_contains(b, a.elements[i]):
            result = result + [a.elements[i]]
        i = i + 1
    return SimpleSet { elements: result }

let intersect = set_intersection(set_a, set_b)
if intersect.elements.len() == 1 and set_contains(intersect, 3):
    print('      [PASS] intersection found')
    passed = passed + 1
else:
    print('      [FAIL] intersection found')
    failed = failed + 1

print('')
print('  context difference:')
print('    it finds unique to first:')

fn set_difference(a: SimpleSet, b: SimpleSet) -> SimpleSet:
    let mut result = []
    let mut i = 0
    while i < a.elements.len():
        if not set_contains(b, a.elements[i]):
            result = result + [a.elements[i]]
        i = i + 1
    return SimpleSet { elements: result }

let diff = set_difference(set_a, set_b)
if diff.elements.len() == 2:
    print('      [PASS] difference found')
    passed = passed + 1
else:
    print('      [FAIL] difference found')
    failed = failed + 1

# -----------------------------------------------------
# Set Properties
# -----------------------------------------------------

print('')
print('describe Set properties:')
print('  context size:')
print('    it returns element count:')

fn set_size(s: SimpleSet) -> i64:
    return s.elements.len()

if set_size(set_a) == 3:
    print('      [PASS] size correct')
    passed = passed + 1
else:
    print('      [FAIL] size correct')
    failed = failed + 1

print('')
print('  context empty check:')
print('    it detects empty set:')

fn set_is_empty(s: SimpleSet) -> Bool:
    return s.elements.len() == 0

if set_is_empty(empty):
    print('      [PASS] empty detected')
    passed = passed + 1
else:
    print('      [FAIL] empty detected')
    failed = failed + 1

print('')
print('  context subset check:')
print('    it detects subset:')

fn is_subset(a: SimpleSet, b: SimpleSet) -> Bool:
    let mut i = 0
    while i < a.elements.len():
        if not set_contains(b, a.elements[i]):
            return false
        i = i + 1
    return true

let small = set_from_list([1, 2])
let big = set_from_list([1, 2, 3, 4])
if is_subset(small, big):
    print('      [PASS] subset detected')
    passed = passed + 1
else:
    print('      [FAIL] subset detected')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Sets')
print('')
print('**Feature ID:** #33')
print('**Category:** Data Structures')
print('**Difficulty:** Level 2/5')
print('**Status:** Complete')
print('**Implementation:** Simple')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Operations')
print('')
print('| Operation | Description | Complexity |')
print('|-----------|-------------|------------|')
print('| add | Add element | O(1) |')
print('| remove | Remove element | O(1) |')
print('| contains | Check membership | O(1) |')
print('| union | Combine sets | O(n) |')
print('| intersection | Common elements | O(n) |')
print('| difference | Unique to first | O(n) |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
