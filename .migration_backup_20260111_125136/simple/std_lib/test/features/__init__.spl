# Feature Documentation Test Framework
# Provides common infrastructure for BDD feature documentation tests
# Each category folder contains feature specs that generate documentation

# =====================================================
# Feature Metadata Class
# =====================================================

class FeatureMetadata:
    """Metadata for a single feature in the Simple language."""
    id: Int                    # Feature ID (#1, #2, etc.)
    name: String               # Feature name ("Lexer", "Parser", etc.)
    category: String           # Category ("Infrastructure", "Language", etc.)
    difficulty: Int            # Difficulty level (1-5)
    status: String             # "Complete", "In Progress", "Planned"
    impl_type: String          # "Rust", "Simple", "Rust+Simple"
    spec_ref: String           # Reference to spec file
    files: List[String]        # Implementation files
    tests: List[String]        # Test files
    description: String        # Feature description
    code_examples: List[String]     # Code examples
    dependencies: List[Int]    # Feature IDs this depends on
    required_by: List[Int]     # Feature IDs that depend on this
    notes: String              # Additional notes

# =====================================================
# Feature Registry Class
# =====================================================

class FeatureRegistry:
    """Registry that stores and manages feature metadata."""
    features: List
    category_name: String

    fn new(category: String):
        return FeatureRegistry { features: [], category_name: category }

    fn register(meta):
        self.features = self.features + [meta]

    fn get(id: Int):
        for item in self.features:
            if item.id == id:
                return item
        return None

    fn get_all():
        return self.features

    fn count():
        return self.features.len()

    fn count_by_status(status: String):
        let mut count = 0
        for item in self.features:
            if item.status == status:
                count = count + 1
        return count

    fn count_by_difficulty(level: Int):
        let mut count = 0
        for item in self.features:
            if item.difficulty == level:
                count = count + 1
        return count

# =====================================================
# Documentation Generator
# =====================================================

class DocGenerator:
    """Generates markdown documentation from feature metadata."""
    registry: FeatureRegistry

    fn new(registry: FeatureRegistry):
        return DocGenerator { registry: registry }

    fn generate_feature_doc(meta) -> String:
        """Generate markdown documentation for a single feature."""
        let mut doc = ""
        doc = doc + "# {meta.name}\n\n"
        doc = doc + "**Feature ID:** #{meta.id}\n"
        doc = doc + "**Category:** {meta.category}\n"
        doc = doc + "**Difficulty:** Level {meta.difficulty}/5\n"
        doc = doc + "**Status:** {meta.status}\n"
        doc = doc + "**Implementation:** {meta.impl_type}\n\n"
        doc = doc + "## Description\n\n{meta.description}\n\n"

        if meta.spec_ref != "":
            doc = doc + "## Specification\n\nSee [{meta.spec_ref}]({meta.spec_ref})\n\n"

        if meta.files.len() > 0:
            doc = doc + "## Implementation Files\n\n"
            for file in meta.files:
                doc = doc + "- `{file}`\n"
            doc = doc + "\n"

        if meta.tests.len() > 0:
            doc = doc + "## Test Files\n\n"
            for test in meta.tests:
                doc = doc + "- `{test}`\n"
            doc = doc + "\n"

        if meta.code_examples.len() > 0:
            doc = doc + "## Code Examples\n\n```simple\n"
            for example in meta.code_examples:
                doc = doc + example + "\n"
            doc = doc + "```\n\n"

        if meta.dependencies.len() > 0:
            doc = doc + "## Dependencies\n\nDepends on features: {meta.dependencies}\n\n"

        if meta.required_by.len() > 0:
            doc = doc + "## Required By\n\nRequired by features: {meta.required_by}\n\n"

        if meta.notes != "":
            doc = doc + "## Notes\n\n{meta.notes}\n"

        return doc

    fn generate_category_index() -> String:
        """Generate index markdown for all features in the category."""
        let features = self.registry.get_all()
        let mut doc = ""
        doc = doc + "# {self.registry.category_name} Features\n\n"
        doc = doc + "Total features: {features.len()}\n\n"

        doc = doc + "## Status Summary\n\n"
        let complete = self.registry.count_by_status("Complete")
        let in_progress = self.registry.count_by_status("In Progress")
        let planned = self.registry.count_by_status("Planned")
        doc = doc + "- Complete: {complete}\n"
        doc = doc + "- In Progress: {in_progress}\n"
        doc = doc + "- Planned: {planned}\n\n"

        doc = doc + "## Difficulty Distribution\n\n"
        for level in [1, 2, 3, 4, 5]:
            let count = self.registry.count_by_difficulty(level)
            if count > 0:
                doc = doc + "- Level {level}: {count} features\n"
        doc = doc + "\n"

        doc = doc + "## Feature List\n\n"
        doc = doc + "| ID | Name | Difficulty | Status |\n"
        doc = doc + "|-----|------|------------|--------|\n"
        for f in features:
            doc = doc + "| #{f.id} | {f.name} | {f.difficulty} | {f.status} |\n"

        return doc

# =====================================================
# Test Runner Helper
# =====================================================

class SpecRunner:
    """Runs feature spec tests and tracks results."""
    passed: Int
    failed: Int
    registry: FeatureRegistry
    doc_generator: DocGenerator

    fn new(category: String):
        let reg = FeatureRegistry.new(category)
        return SpecRunner {
            passed: 0,
            failed: 0,
            registry: reg,
            doc_generator: DocGenerator.new(reg)
        }

    fn register(meta):
        self.registry.register(meta)

    fn test(name: String, condition: Bool):
        if condition:
            print("    [PASS] {name}")
            self.passed = self.passed + 1
        else:
            print("    [FAIL] {name}")
            self.failed = self.failed + 1

    fn print_summary():
        print("")
        print("============================================================")
        print("                    {self.registry.category_name} SUMMARY")
        print("============================================================")
        print("Features: {self.registry.count()}")
        print("Tests Passed: {self.passed}")
        print("Tests Failed: {self.failed}")

        if self.failed == 0:
            print("")
            print("All tests PASSED!")
        else:
            print("")
            print("{self.failed} test(s) FAILED!")
        print("============================================================")

    fn generate_docs() -> String:
        return self.doc_generator.generate_category_index()

# =====================================================
# Helper Functions
# =====================================================

fn create_feature(id: Int, name: String, category: String, difficulty: Int,
                  status: String, impl_type: String, description: String):
    """Create a basic feature metadata with common defaults."""
    return FeatureMetadata {
        id: id,
        name: name,
        category: category,
        difficulty: difficulty,
        status: status,
        impl_type: impl_type,
        spec_ref: "",
        files: [],
        tests: [],
        description: description,
        code_examples: [],
        dependencies: [],
        required_by: [],
        notes: ""
    }

fn difficulty_label(level: Int) -> String:
    """Get human-readable difficulty label."""
    if level == 1:
        return "Beginner"
    elif level == 2:
        return "Easy"
    elif level == 3:
        return "Intermediate"
    elif level == 4:
        return "Advanced"
    elif level == 5:
        return "Expert"
    else:
        return "Unknown"

fn status_emoji(status: String) -> String:
    """Get emoji for status."""
    if status == "Complete":
        return "âœ…"
    elif status == "In Progress":
        return "ğŸ”„"
    elif status == "Planned":
        return "ğŸ“‹"
    else:
        return "â“"

# Export all
export FeatureMetadata
export FeatureRegistry
export DocGenerator
export SpecRunner
export create_feature
export difficulty_label
export status_emoji
