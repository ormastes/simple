# Async Default Feature Specification
# Feature #44: Async-by-default functions
# Category: Concurrency | Difficulty: 3 | Status: Planned

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List<String>
    tests: List<String>
    description: String
    code_examples: List<String>
    dependencies: List<Int>
    required_by: List<Int>
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 44,
    name: 'Async Default',
    category: 'Concurrency',
    difficulty: 3,
    status: 'Planned',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/async_default.md',
    files: [
        'src/compiler/src/effects.rs',
        'src/parser/src/statements/mod.rs'
    ],
    tests: [
        'src/driver/tests/runner_async_tests.rs'
    ],
    description: 'Functions are async by default. Use sync keyword to mark explicitly synchronous functions. Compiler infers async/sync effect from function body.',
    code_examples: [],
    dependencies: [41, 45, 46],
    required_by: [],
    notes: 'Requires suspension operator (#45) and effect inference (#46) to be fully functional.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  ASYNC DEFAULT FEATURE SPECIFICATION (#44)')
print('  Category: Concurrency | Difficulty: 3 | Status: Planned')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0
let mut skipped = 0

# -----------------------------------------------------
# Async-by-default Functions
# -----------------------------------------------------

print('describe Async-by-default functions:')
print('  context basic fn declaration:')

print('    [SKIP] it treats fn as async-capable:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when async-default is ready
# fn fetch_data() -> Data:
#     let resp ~= http.get(url)
#     return parse(resp)

print('    [SKIP] it infers sync when no suspension:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when effect inference is ready
# fn double(x: i64) -> i64:
#     return x * 2
# # Should be inferred as sync

print('')
print('  context explicit sync keyword:')

print('    [SKIP] it allows sync fn declaration:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when sync keyword is parsed
# sync fn compute(x: i64) -> i64:
#     return x * x

print('    [SKIP] it rejects suspension in sync fn:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when compiler validates sync constraint
# sync fn bad():
#     let x ~= fetch()  # Should error

# -----------------------------------------------------
# Promise Type Wrapping
# -----------------------------------------------------

print('')
print('describe Promise type wrapping:')
print('  context return type transformation:')

print('    [SKIP] it wraps async fn return in Promise:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when Promise type is available
# fn fetch_user(id: UserId) -> User:  # Returns Promise<User>
#     ...

print('    [SKIP] it preserves sync fn return type:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when effect inference is ready
# sync fn add(a: i64, b: i64) -> i64:  # Returns i64 directly
#     return a + b

# -----------------------------------------------------
# Effect Propagation
# -----------------------------------------------------

print('')
print('describe Effect propagation:')
print('  context calling async from sync:')

print('    [SKIP] it errors when sync calls async:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when effect checking is ready

print('    [SKIP] it allows async to call sync:')
skipped = skipped + 1
# TODO: [stdlib][P1] Implement when effect inference is ready

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Async Default')
print('')
print('**Feature ID:** #44')
print('**Category:** Concurrency')
print('**Difficulty:** Level 3/5')
print('**Status:** Planned')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Syntax')
print('')
print('```simple')
print('# Async by default (may suspend)')
print('fn fetch_user(id: UserId) -> User:')
print('    let resp ~= http.get("/users/{id}")')
print('    return parse(resp)')
print('')
print('# Explicit sync (compiler verifies no suspension)')
print('sync fn compute(x: i64) -> i64:')
print('    return x * x')
print('```')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed + skipped
print("Passed:  {passed}")
print("Failed:  {failed}")
print("Skipped: {skipped}")
print("Total:   {total}")
if failed == 0:
    print('All tests PASSED (or skipped)!')
print('============================================================')
