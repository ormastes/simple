# Integration Tests for Diagram Generation
# Feature: End-to-end diagram generation from test execution
#
# Tests the full workflow of recording test execution and
# generating Mermaid diagrams for sequence, class, and architecture views.

import std.spec
import diagram.{
    CallEventRecorder, CallType, DiagramConfig,
    generate_sequence, generate_class_diagram, generate_arch_diagram,
    with_sequence_diagram, with_all_diagrams,
    trace_call, trace_method, trace_return, mark_architectural
}

# Sample classes for testing
class UserService:
    fn authenticate(username: String, password: String) -> Bool:
        trace_method("UserService", "authenticate", [username, "***"])
        let result = self.validate_credentials(username, password)
        trace_return(Some(result.to_string()))
        return result

    fn validate_credentials(username: String, password: String) -> Bool:
        trace_method("UserService", "validate_credentials", [username])
        let result = username == "admin" and password == "secret"
        trace_return(Some(result.to_string()))
        return result

class Database:
    fn query(sql: String) -> List[String]:
        trace_method("Database", "query", [sql])
        let result = ["row1", "row2"]
        trace_return(Some("[row1, row2]"))
        return result

describe "Diagram Integration":
    context "Sequence diagram generation":
        it "should generate diagram from method calls":
            let rec = CallEventRecorder.new("auth_test")

            rec.record_call("authenticate", Some("UserService"), ["admin", "***"], CallType.Method)
            rec.record_call("validate_credentials", Some("UserService"), ["admin"], CallType.Method)
            rec.record_return(Some("true"))
            rec.record_return(Some("true"))

            let config = DiagramConfig.new().with_sequence()
            let output = generate_sequence(rec, config)

            expect output.contains("sequenceDiagram") == true
            expect output.contains("UserService") == true
            expect output.contains("authenticate") == true
            expect output.contains("validate_credentials") == true

        it "should include timing and return values":
            let rec = CallEventRecorder.new("timing_test")

            rec.record_call("process", Some("Handler"), ["data"], CallType.Method)
            rec.record_return(Some("Result(42)"))

            let config = DiagramConfig.new().with_sequence()
            let output = generate_sequence(rec, config)

            expect output.contains("Result(42)") == true

    context "Class diagram generation":
        it "should extract classes from calls":
            let rec = CallEventRecorder.new("class_test")

            rec.record_call("methodA", Some("ClassA"), [], CallType.Method)
            rec.record_call("methodB", Some("ClassB"), [], CallType.Method)
            rec.record_call("methodC", Some("ClassA"), [], CallType.Method)

            let config = DiagramConfig.new().with_class_diagram()
            let output = generate_class_diagram(rec, config)

            expect output.contains("classDiagram") == true
            expect output.contains("class ClassA") == true
            expect output.contains("class ClassB") == true

        it "should show relationships":
            let rec = CallEventRecorder.new("rel_test")

            rec.record_call("handleRequest", Some("Controller"), [], CallType.Method)
            rec.record_call("process", Some("Service"), [], CallType.Method)

            let config = DiagramConfig.new().with_class_diagram()
            let output = generate_class_diagram(rec, config)

            expect output.contains("Controller --> Service") == true

    context "Architecture diagram generation":
        it "should show only architectural entities":
            let rec = CallEventRecorder.new("arch_test")

            rec.mark_architectural("UserService")
            rec.mark_architectural("AuthService")

            rec.record_call("method", Some("UserService"), [], CallType.Method)
            rec.record_call("method", Some("Helper"), [], CallType.Method)
            rec.record_call("method", Some("AuthService"), [], CallType.Method)

            let config = DiagramConfig.new().with_architecture()
            let output = generate_arch_diagram(rec, config)

            expect output.contains("flowchart TD") == true
            expect output.contains("UserService") == true
            expect output.contains("AuthService") == true

        it "should treat packages as architectural by default":
            let rec = CallEventRecorder.new("pkg_test")

            rec.record_call("method", Some("app.services.UserService"), [], CallType.Method)
            rec.record_call("method", Some("app.repos.UserRepo"), [], CallType.Method)

            let config = DiagramConfig.new().with_architecture()
            let output = generate_arch_diagram(rec, config)

            expect output.contains("subgraph") == true
            expect output.contains("app") == true

    context "Filtering":
        it "should apply include filter across diagrams":
            let rec = CallEventRecorder.new("filter_test")

            rec.record_call("m", Some("UserService"), [], CallType.Method)
            rec.record_call("m", Some("DebugHelper"), [], CallType.Method)
            rec.record_call("m", Some("AuthService"), [], CallType.Method)

            let config = DiagramConfig.new()
                .with_sequence()
                .with_include("*Service")

            let output = generate_sequence(rec, config)

            expect output.contains("UserService") == true
            expect output.contains("AuthService") == true
            expect output.contains("DebugHelper") == false

        it "should apply exclude filter":
            let rec = CallEventRecorder.new("exclude_test")

            rec.record_call("m", Some("UserService"), [], CallType.Method)
            rec.record_call("m", Some("InternalHelper"), [], CallType.Method)

            let config = DiagramConfig.new()
                .with_sequence()
                .with_exclude("*Helper,*Internal*")

            let output = generate_sequence(rec, config)

            expect output.contains("UserService") == true
            expect output.contains("InternalHelper") == false

    context "All diagram types":
        it "should generate all diagrams from same recording":
            let rec = CallEventRecorder.new("all_test")

            rec.mark_architectural("Controller")
            rec.mark_architectural("Service")

            rec.record_call("handle", Some("Controller"), [], CallType.Method)
            rec.record_call("process", Some("Service"), ["data"], CallType.Method)
            rec.record_return(Some("result"))
            rec.record_return(Some("response"))

            let config = DiagramConfig.new().with_all()

            # Sequence diagram
            let seq = generate_sequence(rec, config)
            expect seq.contains("sequenceDiagram") == true

            # Class diagram
            let cls = generate_class_diagram(rec, config)
            expect cls.contains("classDiagram") == true

            # Architecture diagram
            let arch = generate_arch_diagram(rec, config)
            expect arch.contains("flowchart TD") == true

describe "Diagram Tracing API":
    context "Manual tracing":
        it "should record traced calls":
            let rec = CallEventRecorder.new("trace_test")
            diagram.set_recorder(rec)

            trace_method("MyClass", "myMethod", ["arg1", "arg2"])
            trace_return(Some("result"))

            let events = rec.get_events()
            expect events.len() == 2
            expect events[0].callee == "myMethod"
            expect events[0].callee_class == Some("MyClass")

            diagram.clear_recorder()

        it "should track architectural entities":
            let rec = CallEventRecorder.new("arch_trace_test")
            diagram.set_recorder(rec)

            mark_architectural("CoreService")
            mark_architectural("Repository")

            expect rec.is_architectural("CoreService") == true
            expect rec.is_architectural("Repository") == true
            expect rec.is_architectural("Helper") == false

            diagram.clear_recorder()
