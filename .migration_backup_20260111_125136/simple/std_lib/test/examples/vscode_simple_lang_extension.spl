# Simple Language Extension for VSCode
# Provides language features for Simple programming language

import vscode.commands
import vscode.languages
import vscode.window

# Extension state
let diagnostic_collection: DiagnosticCollection? = none
let keywords: List[String] = ["fn", "let", "if", "else", "elif", "for", "while", "return", "import", "export", "class", "pub", "match", "async", "await"]
let types: List[String] = ["i32", "i64", "f32", "f64", "String", "bool", "List", "Dict", "Option", "Result"]

# Extension entry points

fn activate(context: ExtensionContext):
    """Called when extension is activated."""
    print("Simple Language Extension activated!")

    window.show_information_message("Simple Language Extension loaded")

    # Create diagnostic collection
    diagnostic_collection = DiagnosticCollection.new("simple")
    context.push(diagnostic_collection!.id)

    # Register language features
    register_completion_provider(context)
    register_hover_provider(context)
    register_code_actions(context)
    register_diagnostics(context)

    # Register commands
    register_commands(context)

fn deactivate():
    """Called when extension is deactivated."""
    print("Simple Language Extension deactivated")

    # Cleanup
    if diagnostic_collection != none:
        diagnostic_collection!.dispose()

# Language feature providers

fn register_completion_provider(context: ExtensionContext):
    """Register completion provider for Simple language."""
    let provider_id = languages.register_completion_provider(
        "simple",
        provide_completions
    )
    context.push(provider_id)

fn provide_completions(document: TextDocument, position: Position): List[CompletionItem] =
    """Provide completion items at cursor position."""
    let items: List[CompletionItem] = []

    # Get current line
    let line = document.line_at(position.line)
    let text_before_cursor = line.text.substring(0, position.character)

    # Keyword completions
    for keyword in keywords:
        if keyword.starts_with(text_before_cursor) or text_before_cursor == "":
            let item = CompletionItem.new(keyword, CompletionItemKind_Keyword)
            item.detail = "Simple keyword"
            item.documentation = "Keyword: {keyword}"
            items.append(item)

    # Type completions
    if text_before_cursor.ends_with(":") or text_before_cursor.ends_with("->"):
        for type_name in types:
            let item = CompletionItem.new(type_name, CompletionItemKind_Class)
            item.detail = "Simple type"
            item.documentation = "Type: {type_name}"
            items.append(item)

    # Function snippets
    if text_before_cursor.ends_with("fn "):
        let item = CompletionItem.new("function", CompletionItemKind_Snippet)
        item.insert_text = "fn ${1:name}(${2:args}): ${3:ReturnType} =\n    ${4:body}"
        item.documentation = "Function definition template"
        items.append(item)

    items

fn register_hover_provider(context: ExtensionContext):
    """Register hover provider."""
    let provider_id = languages.register_hover_provider(
        "simple",
        provide_hover
    )
    context.push(provider_id)

fn provide_hover(document: TextDocument, position: Position): Hover? =
    """Provide hover information for symbol at cursor."""
    let range = document.get_word_range_at_position(position)
    if range == none:
        return none

    # Get word at cursor
    let word = document.get_text_in_range(range!)

    # Look up documentation
    let docs = get_documentation(word)

    if docs != "":
        return some(Hover.new(docs))

    none

fn register_code_actions(context: ExtensionContext):
    """Register code action provider."""
    let provider_id = languages.register_code_actions_provider(
        "simple",
        provide_code_actions
    )
    context.push(provider_id)

fn provide_code_actions(document: TextDocument, range: Range, context: CodeActionContext): List[CodeAction] =
    """Provide code actions (quick fixes)."""
    let actions: List[CodeAction] = []

    # Iterate through diagnostics
    for diagnostic in context.diagnostics:
        # Quick fix for unused variable
        if diagnostic.code == "unused-variable":
            let action = CodeAction.new(
                "Remove unused variable",
                CodeActionKind_QuickFix
            )
            action.diagnostics = [diagnostic]

            # Create edit to delete the line
            let edit = WorkspaceEdit.new()
            edit.delete(document.uri, diagnostic.range)
            action.edit = edit

            actions.append(action)

        # Quick fix for missing import
        elif diagnostic.code == "undefined-symbol":
            let action = CodeAction.new(
                "Add import statement",
                CodeActionKind_QuickFix
            )
            action.diagnostics = [diagnostic]

            # Add import at top of file
            let edit = WorkspaceEdit.new()
            let import_line = "import std.{symbol}\n"
            edit.insert(document.uri, Position.new(0, 0), import_line)
            action.edit = edit

            actions.append(action)

    actions

fn register_diagnostics(context: ExtensionContext):
    """Register diagnostic updates."""
    # Update diagnostics on document change
    workspace.on_did_change_text_document(fn(event):
        update_diagnostics(event.document)
    )

    # Update diagnostics on document open
    workspace.on_did_open_text_document(fn(document):
        update_diagnostics(document)
    )

fn update_diagnostics(document: TextDocument):
    """Update diagnostics for a document."""
    if document.language_id != "simple":
        return

    let diagnostics: List[Diagnostic] = []

    # Simple syntax checking
    let text = document.get_text()
    let lines = text.split("\n")

    for i in 0..lines.len():
        let line = lines[i]

        # Check for TODO comments
        if line.contains("TODO"):
            let start = line.index_of("TODO")
            let diagnostic = Diagnostic.new(
                Range.new(
                    Position.new(i, start),
                    Position.new(i, start + 4)
                ),
                "TODO comment found",
                DiagnosticSeverity_Information
            )
            diagnostic.source = "simple"
            diagnostic.code = "todo-comment"
            diagnostics.append(diagnostic)

        # Check for unused variables (simplified)
        if line.contains("let ") and not line.contains("="):
            let diagnostic = Diagnostic.new(
                Range.new(Position.new(i, 0), Position.new(i, line.len())),
                "Unused variable",
                DiagnosticSeverity_Warning
            )
            diagnostic.source = "simple"
            diagnostic.code = "unused-variable"
            diagnostics.append(diagnostic)

        # Check for missing return type
        if line.contains("fn ") and not line.contains("->") and not line.contains("):"):
            let diagnostic = Diagnostic.new(
                Range.new(Position.new(i, 0), Position.new(i, line.len())),
                "Function missing return type annotation",
                DiagnosticSeverity_Hint
            )
            diagnostic.source = "simple"
            diagnostic.code = "missing-return-type"
            diagnostics.append(diagnostic)

    # Update collection
    if diagnostic_collection != none:
        diagnostic_collection!.set(document.uri, diagnostics)

# Command registration

fn register_commands(context: ExtensionContext):
    """Register extension commands."""
    # Format document command
    let cmd1 = commands.register_command(
        "simple.formatDocument",
        format_document
    )
    context.push(cmd1)

    # Run tests command
    let cmd2 = commands.register_command(
        "simple.runTests",
        run_tests
    )
    context.push(cmd2)

    # Show info command
    let cmd3 = commands.register_command(
        "simple.showInfo",
        show_extension_info
    )
    context.push(cmd3)

fn format_document(args: List[String]):
    """Format current document."""
    let editor = window.get_active_text_editor()
    if editor == none:
        window.show_error_message("No active editor")
        return

    let document = editor!.document

    # Format the document (simplified)
    let formatted = format_simple_code(document.get_text())

    # Apply edit
    let edit = WorkspaceEdit.new()
    let full_range = Range.new(
        Position.new(0, 0),
        Position.new(document.line_count, 0)
    )
    edit.replace(document.uri, full_range, formatted)

    workspace.apply_edit(edit)

    window.show_information_message("Document formatted")

fn run_tests(args: List[String]):
    """Run Simple tests."""
    let terminal = window.create_terminal("Simple Tests")
    terminal.show()
    terminal.send_text("simple test")

    window.show_information_message("Running tests...")

fn show_extension_info(args: List[String]):
    """Show extension information."""
    let info = "Simple Language Extension v1.0.0\n"
    info = info + "Features:\n"
    info = info + "- Syntax highlighting\n"
    info = info + "- Code completion\n"
    info = info + "- Hover documentation\n"
    info = info + "- Diagnostics\n"
    info = info + "- Code actions"

    window.show_information_message(info)

# Helper functions

fn get_documentation(symbol: String): String =
    """Look up documentation for a symbol."""
    # In real implementation, would query documentation database
    # For demo, return hardcoded docs for common symbols

    if symbol == "fn":
        return "**fn** - Function definition keyword\n\nDefines a new function."
    elif symbol == "let":
        return "**let** - Variable binding keyword\n\nBinds a value to a name."
    elif symbol == "if":
        return "**if** - Conditional expression\n\nExecutes code based on a condition."
    elif symbol == "List":
        return "**List[T]** - Dynamic array type\n\nA growable array of elements."
    else:
        return ""

fn format_simple_code(code: String): String =
    """Format Simple code (simplified implementation)."""
    # In real implementation, would use proper AST-based formatting
    # For demo, just ensure consistent indentation

    let lines = code.split("\n")
    let formatted_lines: List[String] = []
    let indent_level = 0

    for line in lines:
        let trimmed = line.trim()

        # Decrease indent for closing braces
        if trimmed.starts_with("}") or trimmed.starts_with("]") or trimmed == "":
            if indent_level > 0:
                indent_level = indent_level - 1

        # Add indentation
        let indent = "    " * indent_level
        formatted_lines.append(indent + trimmed)

        # Increase indent for opening braces and colons
        if trimmed.ends_with(":") or trimmed.ends_with("{") or trimmed.ends_with("["):
            indent_level = indent_level + 1

    formatted_lines.join("\n")
