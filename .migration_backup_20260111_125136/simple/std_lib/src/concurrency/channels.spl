/**
Channel Utilities

Channels provide typed communication between concurrent actors.
They are safer than raw send/recv with explicit sender/receiver.

Basic Channel Usage:
```sdoctest
>>> let (tx, rx) = channel()
>>> tx.send(42)
>>> rx.recv()
Some(42)
```
*/

/**
Bounded channel with capacity limit
*/
struct BoundedChannel[T]:
    capacity: Int
    buffer: List[T]
    closed: Bool

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> Bool:
        """Check if channel has no buffered items."""
        return self.buffer.is_empty()

    fn is_full() -> Bool:
        """Check if channel is at capacity."""
        return len(self.buffer) >= self.capacity

    fn is_closed() -> Bool:
        """Check if channel is closed."""
        return self.closed

    fn len() -> Int:
        """Get number of buffered items."""
        return len(self.buffer)

    fn available() -> Int:
        """Get available space in buffer."""
        return self.capacity - len(self.buffer)

    fn utilization() -> f64:
        """Calculate buffer utilization (0.0 to 1.0)."""
        if self.capacity > 0:
            return (len(self.buffer) as f64) / (self.capacity as f64)
        return 0.0

    fn can_send() -> Bool:
        """Check if can send without blocking."""
        return not self.closed and not self.is_full()

    fn summary() -> String:
        """Get summary of channel state."""
        let status = if self.closed: "closed" else: "open"
        let util = (self.utilization() * 100.0) as Int
        return "BoundedChannel: {self.len()}/{self.capacity} ({util}% full), {status}"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(capacity: Int) -> BoundedChannel[T]:
        return BoundedChannel(
            capacity: capacity,
            buffer: [],
            closed: false
        )

    fn send(value: T) -> Bool:
        if self.closed:
            return false
        if len(self.buffer) >= self.capacity:
            # In full impl, would block
            return false
        self.buffer.push(value)
        return true

    fn recv() -> Option[T]:
        if self.buffer.is_empty:
            if self.closed:
                return Option.None
            # In full impl, would block
            return Option.None
        return Option.Some(self.buffer.pop_front())

    fn close():
        self.closed = true

/**
Unbounded channel (no capacity limit)
*/
struct UnboundedChannel[T]:
    buffer: List[T]
    closed: Bool

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> Bool:
        """Check if channel has no buffered items."""
        return self.buffer.is_empty()

    fn is_closed() -> Bool:
        """Check if channel is closed."""
        return self.closed

    fn len() -> Int:
        """Get number of buffered items."""
        return len(self.buffer)

    fn has_items() -> Bool:
        """Check if channel has buffered items."""
        return not self.buffer.is_empty()

    fn can_send() -> Bool:
        """Check if can send (always true for unbounded unless closed)."""
        return not self.closed

    fn can_recv() -> Bool:
        """Check if can receive (has items)."""
        return not self.buffer.is_empty()

    fn summary() -> String:
        """Get summary of channel state."""
        let status = if self.closed: "closed" else: "open"
        return "UnboundedChannel: {self.len()} items, {status}"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new() -> UnboundedChannel[T]:
        return UnboundedChannel(
            buffer: [],
            closed: false
        )

    fn send(value: T):
        if not self.closed:
            self.buffer.push(value)

    fn recv() -> Option[T]:
        if self.buffer.is_empty:
            return Option.None
        return Option.Some(self.buffer.pop_front())

    fn close():
        self.closed = true

/**
One-shot channel for single value transfer
*/
struct Oneshot[T]:
    value: Option[T]
    completed: Bool

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_completed() -> Bool:
        """Check if value has been sent."""
        return self.completed

    fn is_pending() -> Bool:
        """Check if still waiting for value."""
        return not self.completed

    fn has_value() -> Bool:
        """Check if has a value (completed)."""
        return self.completed

    fn can_send() -> Bool:
        """Check if can send (not yet completed)."""
        return not self.completed

    fn summary() -> String:
        """Get summary of oneshot state."""
        let status = if self.completed: "completed" else: "pending"
        return "Oneshot: {status}"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new() -> Oneshot[T]:
        return Oneshot(value: Option.None, completed: false)

    fn send(value: T) -> Bool:
        if self.completed:
            return false
        self.value = Option.Some(value)
        self.completed = true
        return true

    fn recv() -> Option[T]:
        if self.completed:
            return self.value
        return Option.None

/**
Create a sender/receiver pair (sugar for channel creation)

```sdoctest
>>> let (tx, rx) = channel()
>>> tx.send(42)
>>> rx.recv()
Some(42)
```
*/
fn channel():
    let ch = UnboundedChannel.new()
    return (ch, ch)  # Same object, but conceptually tx/rx

/**
Create a bounded channel pair
*/
fn bounded_channel(capacity: Int):
    let ch = BoundedChannel.new(capacity)
    return (ch, ch)

/**
Create a oneshot channel pair
*/
fn oneshot():
    let ch = Oneshot.new()
    return (ch, ch)
