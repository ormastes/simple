# ============================================================================
# Simple Physics Library - OBB (Oriented Bounding Box)
# ============================================================================
#
# This module provides the OBB (Oriented Bounding Box) class for narrow-phase
# collision detection. OBBs are bounding boxes that can be rotated in 3D space,
# allowing for tighter bounds around rotated objects compared to AABBs.
#
# The OBB class supports:
# - Axis generation via quaternion rotation
# - Corner point computation
# - SAT (Separating Axis Theorem) projection
# - Conservative conversion to AABB

export OBB

import std.core as core
from std.physics.collision import AABB


# ============================================================================
# OBB - Oriented Bounding Box
# ============================================================================

class OBB:
    """Oriented Bounding Box for narrow-phase collision detection.

    Attributes:
        center: Center position
        half_extents: Half-extents along local axes
        rotation: Orientation quaternion
    """
    center: core.Vector3
    half_extents: core.Vector3
    rotation: core.Quaternion

    fn __init__(center: core.Vector3,
        half_extents: core.Vector3,
        rotation: core.Quaternion = core.Quaternion::identity()
    ):
        """Initialize OBB.

        Args:
            center: Center position
            half_extents: Half-extents (half-width, half-height, half-depth)
            rotation: Orientation (default: identity)
        """
        self.center = center
        self.half_extents = half_extents
        self.rotation = rotation

    fn get_axes() -> [core.Vector3]:
        """Get the three local axes of the box.

        Returns:
            List of 3 axis vectors (x, y, z)
        """
        # Transform standard axes by rotation quaternion
        let x_axis = self.rotation.rotate_vector(core.Vector3(1.0, 0.0, 0.0))
        let y_axis = self.rotation.rotate_vector(core.Vector3(0.0, 1.0, 0.0))
        let z_axis = self.rotation.rotate_vector(core.Vector3(0.0, 0.0, 1.0))
        return [x_axis, y_axis, z_axis]

    fn get_corners() -> [core.Vector3]:
        """Get all 8 corners of the box.

        Returns:
            List of 8 corner positions
        """
        let axes = self.get_axes()
        let x_offset = axes[0].scale(self.half_extents.x)
        let y_offset = axes[1].scale(self.half_extents.y)
        let z_offset = axes[2].scale(self.half_extents.z)

        # Generate all 8 combinations of +/- offsets
        return [
            self.center.add(x_offset).add(y_offset).add(z_offset),
            self.center.add(x_offset).add(y_offset).sub(z_offset),
            self.center.add(x_offset).sub(y_offset).add(z_offset),
            self.center.add(x_offset).sub(y_offset).sub(z_offset),
            self.center.sub(x_offset).add(y_offset).add(z_offset),
            self.center.sub(x_offset).add(y_offset).sub(z_offset),
            self.center.sub(x_offset).sub(y_offset).add(z_offset),
            self.center.sub(x_offset).sub(y_offset).sub(z_offset),
        ]

    fn project_onto_axis(axis: core.Vector3) -> (f64, f64):
        """Project OBB onto an axis and return min/max.

        Args:
            axis: Axis to project onto (should be normalized)

        Returns:
            Tuple of (min, max) projection values
        """
        let corners = self.get_corners()
        let mut min_proj = corners[0].dot(axis)
        let mut max_proj = min_proj

        for i in range(1, 8):
            let proj = corners[i].dot(axis)
            if proj < min_proj:
                min_proj = proj
            if proj > max_proj:
                max_proj = proj

        return (min_proj, max_proj)

    fn to_aabb() -> AABB:
        """Convert to axis-aligned bounding box (conservative bounds).

        Returns:
            AABB that contains this OBB
        """
        let corners = self.get_corners()
        let mut min = corners[0]
        let mut max = corners[0]

        for i in range(1, 8):
            let corner = corners[i]
            min = core.Vector3(
                min.x.min(corner.x),
                min.y.min(corner.y),
                min.z.min(corner.z)
            )
            max = core.Vector3(
                max.x.max(corner.x),
                max.y.max(corner.y),
                max.z.max(corner.z)
            )

        return AABB(min, max)
