# Mesh Class - Vertex and index buffer container
#
# Core mesh structure for 3D geometry.

export Mesh

use core.*
use graphics.math.*
use mesh_types.*

# =============================================================================
# Mesh - Vertex and index buffer container
# =============================================================================

pub struct Mesh:
    vertices: Array[MeshVertex]
    indices: Array[u32]
    bounds: AABB

impl Mesh:
    # Constructors
    pub fn new() -> Mesh:
        return Mesh {
            vertices: Array::new(),
            indices: Array::new(),
            bounds: AABB::empty()
        }

    pub fn from_vertices(vertices: Array[MeshVertex], indices: Array[u32]) -> Mesh:
        let mut mesh = Mesh {
            vertices: vertices,
            indices: indices,
            bounds: AABB::empty()
        }
        mesh.compute_bounds()
        return mesh

    # Data access
    pub fn get_vertices(self) -> Array[MeshVertex]:
        return self.vertices

    pub fn get_indices(self) -> Array[u32]:
        return self.indices

    pub fn get_vertex_count(self) -> i32:
        return self.vertices.len()

    pub fn get_index_count(self) -> i32:
        return self.indices.len()

    pub fn get_triangle_count(self) -> i32:
        return self.indices.len() / 3

    pub fn get_bounds(self) -> AABB:
        return self.bounds

    # Modification
    pub fn add_vertex(mut self, vertex: MeshVertex):
        self.vertices.push(vertex)
        self.bounds.expand(vertex.position)

    pub fn add_triangle(mut self, i0: u32, i1: u32, i2: u32):
        self.indices.push(i0)
        self.indices.push(i1)
        self.indices.push(i2)

    pub fn clear(mut self):
        self.vertices.clear()
        self.indices.clear()
        self.bounds = AABB::empty()

    # Computation
    pub fn compute_bounds(mut self):
        self.bounds = AABB::empty()
        for vertex in self.vertices:
            self.bounds.expand(vertex.position)

    pub fn compute_normals(mut self):
        # Initialize all normals to zero
        for i in 0..self.vertices.len():
            self.vertices[i].normal = Vec3::zero()

        # Accumulate face normals
        for i in 0..self.get_triangle_count():
            let i0 = self.indices[i * 3] as i32
            let i1 = self.indices[i * 3 + 1] as i32
            let i2 = self.indices[i * 3 + 2] as i32

            let v0 = self.vertices[i0].position
            let v1 = self.vertices[i1].position
            let v2 = self.vertices[i2].position

            let edge1 = v1 - v0
            let edge2 = v2 - v0
            let normal = edge1.cross(edge2)

            self.vertices[i0].normal = self.vertices[i0].normal + normal
            self.vertices[i1].normal = self.vertices[i1].normal + normal
            self.vertices[i2].normal = self.vertices[i2].normal + normal

        # Normalize all normals
        for i in 0..self.vertices.len():
            self.vertices[i].normal = self.vertices[i].normal.normalize()

    pub fn compute_tangents(mut self):
        # Initialize all tangents to zero
        for i in 0..self.vertices.len():
            self.vertices[i].tangent = Vec4::zero()

        # Compute tangents per triangle
        for i in 0..self.get_triangle_count():
            let i0 = self.indices[i * 3] as i32
            let i1 = self.indices[i * 3 + 1] as i32
            let i2 = self.indices[i * 3 + 2] as i32

            let v0 = self.vertices[i0]
            let v1 = self.vertices[i1]
            let v2 = self.vertices[i2]

            let edge1 = v1.position - v0.position
            let edge2 = v2.position - v0.position
            let delta_uv1 = Vec2::new(
                v1.tex_coord.x - v0.tex_coord.x,
                v1.tex_coord.y - v0.tex_coord.y
            )
            let delta_uv2 = Vec2::new(
                v2.tex_coord.x - v0.tex_coord.x,
                v2.tex_coord.y - v0.tex_coord.y
            )

            let f = 1.0 / (delta_uv1.x * delta_uv2.y - delta_uv2.x * delta_uv1.y)
            let tangent = Vec3::new(
                f * (delta_uv2.y * edge1.x - delta_uv1.y * edge2.x),
                f * (delta_uv2.y * edge1.y - delta_uv1.y * edge2.y),
                f * (delta_uv2.y * edge1.z - delta_uv1.y * edge2.z)
            )

            let tangent4 = Vec4::from_vec3(tangent, 1.0)
            self.vertices[i0].tangent = self.vertices[i0].tangent + tangent4
            self.vertices[i1].tangent = self.vertices[i1].tangent + tangent4
            self.vertices[i2].tangent = self.vertices[i2].tangent + tangent4

        # Normalize tangents
        for i in 0..self.vertices.len():
            let t = self.vertices[i].tangent.xyz().normalize()
            self.vertices[i].tangent = Vec4::from_vec3(t, 1.0)
