# Animation Utilities - Math helpers and keyframe functions
#
# Shared utilities for animation interpolation and math.

export lerp_vec3, slerp_quat, blend_transforms
export find_keyframe_pair_position, find_keyframe_pair_rotation, find_keyframe_pair_scale
export lerp_f32, min_f32, clamp_f32, acos_f32, sin_f32, sqrt_f32, cos_f32

use graphics.math.*

# Forward declarations for keyframe types
pub struct PositionKey:
    time: f32
    value: Vec3

pub struct RotationKey:
    time: f32
    value: Quat

pub struct ScaleKey:
    time: f32
    value: Vec3

# =============================================================================
# Animation Blending
# =============================================================================

fn blend_transforms(
    a: Transform,
    b: Transform,
    t: f32
) -> Transform:
    return Transform::new(
        lerp_vec3(a.translation, b.translation, t),
        slerp_quat(a.rotation, b.rotation, t),
        lerp_vec3(a.scale, b.scale, t)
    )

# =============================================================================
# Keyframe Utilities
# =============================================================================

fn find_keyframe_pair_position(
    keys: &Array<PositionKey>,
    time: f32
) -> (PositionKey, PositionKey, f32):
    # Find surrounding keyframes
    for i in 0..(keys.len() - 1):
        if time >= keys[i].time and time < keys[i + 1].time:
            let t = (time - keys[i].time) / (keys[i + 1].time - keys[i].time)
            return (keys[i], keys[i + 1], t)

    # Return last keyframe
    let last_idx = keys.len() - 1
    return (keys[last_idx], keys[last_idx], 0.0)

fn find_keyframe_pair_rotation(
    keys: &Array<RotationKey>,
    time: f32
) -> (RotationKey, RotationKey, f32):
    for i in 0..(keys.len() - 1):
        if time >= keys[i].time and time < keys[i + 1].time:
            let t = (time - keys[i].time) / (keys[i + 1].time - keys[i].time)
            return (keys[i], keys[i + 1], t)

    let last_idx = keys.len() - 1
    return (keys[last_idx], keys[last_idx], 0.0)

fn find_keyframe_pair_scale(
    keys: &Array<ScaleKey>,
    time: f32
) -> (ScaleKey, ScaleKey, f32):
    for i in 0..(keys.len() - 1):
        if time >= keys[i].time and time < keys[i + 1].time:
            let t = (time - keys[i].time) / (keys[i + 1].time - keys[i].time)
            return (keys[i], keys[i + 1], t)

    let last_idx = keys.len() - 1
    return (keys[last_idx], keys[last_idx], 0.0)

# =============================================================================
# Math Helpers
# =============================================================================

pub fn lerp_vec3(a: Vec3, b: Vec3, t: f32) -> Vec3:
    return a * (1.0 - t) + b * t

pub fn slerp_quat(a: Quat, b: Quat, t: f32) -> Quat:
    # Spherical linear interpolation
    let dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

    # Ensure shortest path
    let mut b_adjusted = b
    if dot < 0.0:
        b_adjusted = Quat::new(-b.x, -b.y, -b.z, -b.w)
        dot = -dot

    # Linear interpolation for close quaternions
    if dot > 0.9995:
        return Quat::new(
            lerp_f32(a.x, b_adjusted.x, t),
            lerp_f32(a.y, b_adjusted.y, t),
            lerp_f32(a.z, b_adjusted.z, t),
            lerp_f32(a.w, b_adjusted.w, t)
        ).normalize()

    # Spherical interpolation
    let theta = acos_f32(dot)
    let sin_theta = sin_f32(theta)

    let w_a = sin_f32((1.0 - t) * theta) / sin_theta
    let w_b = sin_f32(t * theta) / sin_theta

    return Quat::new(
        a.x * w_a + b_adjusted.x * w_b,
        a.y * w_a + b_adjusted.y * w_b,
        a.z * w_a + b_adjusted.z * w_b,
        a.w * w_a + b_adjusted.w * w_b
    )

pub fn lerp_f32(a: f32, b: f32, t: f32) -> f32:
    return a * (1.0 - t) + b * t

pub fn min_f32(a: f32, b: f32) -> f32:
    if a < b: a else: b

pub fn clamp_f32(value: f32, min: f32, max: f32) -> f32:
    if value < min:
        return min
    if value > max:
        return max
    return value

pub fn acos_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

pub fn sin_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

pub fn sqrt_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

pub fn cos_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

# =============================================================================
# Quaternion Extensions
# =============================================================================

impl Quat:
    pub fn normalize(self) -> Quat:
        let len = sqrt_f32(self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w)
        if len == 0.0:
            return Quat::identity()

        return Quat::new(
            self.x / len,
            self.y / len,
            self.z / len,
            self.w / len
        )

    pub fn look_rotation(forward: Vec3, up: Vec3) -> Quat:
        # Simplified - would use proper quaternion from rotation matrix
        return Quat::identity()

    pub fn from_axis_angle(axis: Vec3, angle: f32) -> Quat:
        let half_angle = angle * 0.5
        let s = sin_f32(half_angle)

        return Quat::new(
            axis.x * s,
            axis.y * s,
            axis.z * s,
            cos_f32(half_angle)
        )

# =============================================================================
# Transform Extensions
# =============================================================================

impl Transform:
    pub fn to_matrix(self) -> Mat4:
        # TRS to matrix
        return Mat4::from_trs(self.translation, self.rotation, self.scale)
