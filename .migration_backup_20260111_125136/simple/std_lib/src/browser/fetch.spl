# Browser Fetch API
#
# Provides HTTP request functionality for making network requests from the browser.
# Supports GET, POST, PUT, DELETE and other HTTP methods with full async/await support.
#
# Example:
#   ```
#   import browser.fetch as fetch
#
#   # GET request
#   let response = await fetch.get("https://api.example.com/users")
#   let data = await response.json()
#
#   # POST request with JSON
#   let user = {"name": "Alice", "email": "alice@example.com"}
#   let response = await fetch.post_json("/api/users", user)
#   ```

# Make a GET request
#
# Example:
#   ```
#   let response = await fetch.get("/api/data")
#   if response.ok():
#       let text = await response.text()
#   ```
@async
@extern("browser", "fetch_get")
fn get(url: str) -> Response:
    pass

# Make a POST request with text body
#
# Example:
#   ```
#   let response = await fetch.post("/api/data", "request body")
#   ```
@async
@extern("browser", "fetch_post")
fn post(url: str, body: str) -> Response:
    pass

# Make a PUT request
@async
@extern("browser", "fetch_put")
fn put(url: str, body: str) -> Response:
    pass

# Make a DELETE request
@async
@extern("browser", "fetch_delete")
fn delete(url: str) -> Response:
    pass

# Make a PATCH request
@async
@extern("browser", "fetch_patch")
fn patch(url: str, body: str) -> Response:
    pass

# Make a HEAD request
@async
@extern("browser", "fetch_head")
fn head(url: str) -> Response:
    pass

# Make a GET request and parse JSON response
#
# Convenience method that combines get() + response.json()
#
# Example:
#   ```
#   let users = await fetch.get_json("/api/users")
#   for user in users:
#       console.log(user.name)
#   ```
@async
@extern("browser", "fetch_get_json")
fn get_json(url: str) -> Value:
    pass

# Make a POST request with JSON body
#
# Automatically serializes the body to JSON and sets Content-Type header.
#
# Example:
#   ```
#   let new_user = {"name": "Bob", "age": 30}
#   let response = await fetch.post_json("/api/users", new_user)
#   let created = await response.json()
#   ```
@async
@extern("browser", "fetch_post_json")
fn post_json(url: str, body: Value) -> Response:
    pass

# Make a PUT request with JSON body
@async
@extern("browser", "fetch_put_json")
fn put_json(url: str, body: Value) -> Response:
    pass

# Make a PATCH request with JSON body
@async
@extern("browser", "fetch_patch_json")
fn patch_json(url: str, body: Value) -> Response:
    pass

# Make a custom request with full options
#
# Example:
#   ```
#   let options = RequestOptions()
#       .method("POST")
#       .header("Authorization", "Bearer token")
#       .body("data")
#
#   let response = await fetch.request("/api/endpoint", options)
#   ```
@async
@extern("browser", "fetch_request")
fn request(url: str, options: RequestOptions) -> Response:
    pass

# Request options builder
class RequestOptions:
    # Create new request options
    fn new() -> RequestOptions:
        pass

    # Set HTTP method
    fn method(method: str) -> RequestOptions:
        pass

    # Set request body
    fn body(body: str) -> RequestOptions:
        pass

    # Add a header
    fn header(name: str, value: str) -> RequestOptions:
        pass

    # Set multiple headers
    fn headers(headers: Map[str, str]) -> RequestOptions:
        pass

    # Set request mode (cors, no-cors, same-origin)
    fn mode(mode: str) -> RequestOptions:
        pass

    # Set credentials mode (omit, same-origin, include)
    fn credentials(credentials: str) -> RequestOptions:
        pass

    # Set cache mode (default, no-cache, reload, force-cache)
    fn cache(cache: str) -> RequestOptions:
        pass

    # Set redirect mode (follow, error, manual)
    fn redirect(redirect: str) -> RequestOptions:
        pass

    # Set referrer
    fn referrer(referrer: str) -> RequestOptions:
        pass

    # Set timeout in milliseconds
    fn timeout(ms: i64) -> RequestOptions:
        pass

# HTTP Response
class Response:
    # Get response status code
    #
    # Example:
    #   ```
    #   let response = await fetch.get("/api/data")
    #   if response.status() == 200:
    #       # Success
    #   ```
    @extern("browser", "response_get_status")
    fn status() -> i64:
        pass

    # Get response status text
    @extern("browser", "response_get_status_text")
    fn status_text() -> str:
        pass

    # Check if response is ok (status 200-299)
    #
    # Example:
    #   ```
    #   if response.ok():
    #       let data = await response.json()
    #   else:
    #       console.error("Request failed:", response.status())
    #   ```
    @extern("browser", "response_is_ok")
    fn ok() -> bool:
        pass

    # Get response headers
    @extern("browser", "response_get_headers")
    fn headers() -> Headers:
        pass

    # Get specific header value
    @extern("browser", "response_get_header")
    fn header(name: str) -> str:
        pass

    # Get response URL
    @extern("browser", "response_get_url")
    fn url() -> str:
        pass

    # Check if response was redirected
    @extern("browser", "response_is_redirected")
    fn redirected() -> bool:
        pass

    # Read response body as text
    #
    # Example:
    #   ```
    #   let html = await response.text()
    #   ```
    @async
    @extern("browser", "response_text")
    fn text() -> str:
        pass

    # Parse response body as JSON
    #
    # Example:
    #   ```
    #   let data = await response.json()
    #   console.log(data.message)
    #   ```
    @async
    @extern("browser", "response_json")
    fn json() -> Value:
        pass

    # Read response body as blob
    @async
    @extern("browser", "response_blob")
    fn blob() -> Blob:
        pass

    # Read response body as array buffer
    @async
    @extern("browser", "response_array_buffer")
    fn array_buffer() -> ArrayBuffer:
        pass

    # Clone the response
    @extern("browser", "response_clone")
    fn clone() -> Response:
        pass

# HTTP Headers
class Headers:
    # Create new headers
    fn new() -> Headers:
        pass

    # Get header value
    @extern("browser", "headers_get")
    fn get(name: str) -> str:
        pass

    # Set header value
    @extern("browser", "headers_set")
    fn set(name: str, value: str):
        pass

    # Append header value
    @extern("browser", "headers_append")
    fn append(name: str, value: str):
        pass

    # Delete header
    @extern("browser", "headers_delete")
    fn delete(name: str):
        pass

    # Check if header exists
    @extern("browser", "headers_has")
    fn has(name: str) -> bool:
        pass

    # Get all header names
    @extern("browser", "headers_keys")
    fn keys() -> List<str>:
        pass

    # Get all header values
    @extern("browser", "headers_values")
    fn values() -> List<str>:
        pass

    # Get all headers as map
    @extern("browser", "headers_entries")
    fn entries() -> Map[str, str]:
        pass

# Blob (binary large object)
class Blob:
    # Get blob size in bytes
    @extern("browser", "blob_get_size")
    fn size() -> i64:
        pass

    # Get blob MIME type
    @extern("browser", "blob_get_type")
    fn type() -> str:
        pass

    # Read blob as text
    @async
    @extern("browser", "blob_text")
    fn text() -> str:
        pass

    # Read blob as array buffer
    @async
    @extern("browser", "blob_array_buffer")
    fn array_buffer() -> ArrayBuffer:
        pass

    # Slice blob
    @extern("browser", "blob_slice")
    fn slice(start: i64, end: i64) -> Blob:
        pass

# ArrayBuffer for binary data
class ArrayBuffer:
    # Get buffer size
    @extern("browser", "array_buffer_get_byte_length")
    fn byte_length() -> i64:
        pass

    # Slice buffer
    @extern("browser", "array_buffer_slice")
    fn slice(start: i64, end: i64) -> ArrayBuffer:
        pass

# Abort controller for canceling requests
class AbortController:
    # Create new abort controller
    @extern("browser", "abort_controller_new")
    fn new() -> AbortController:
        pass

    # Get the abort signal
    @extern("browser", "abort_controller_signal")
    fn signal() -> AbortSignal:
        pass

    # Abort the request
    #
    # Example:
    #   ```
    #   let controller = AbortController.new()
    #   let signal = controller.signal()
    #
    #   # Start request with signal
    #   let promise = fetch.get_with_signal("/api/slow", signal)
    #
    #   # Cancel request after 5 seconds
    #   await sleep(5000)
    #   controller.abort()
    #   ```
    @extern("browser", "abort_controller_abort")
    fn abort():
        pass

# Abort signal
class AbortSignal:
    # Check if aborted
    @extern("browser", "abort_signal_is_aborted")
    fn aborted() -> bool:
        pass

    # Add abort event listener
    @extern("browser", "abort_signal_add_listener")
    fn on_abort(handler: fn):
        pass

# Timeout helper - abort request after delay
#
# Example:
#   ```
#   let controller = AbortController.new()
#
#   # Auto-abort after 5 seconds
#   fetch.abort_after(controller, 5000)
#
#   let response = await fetch.get_with_signal("/api/data", controller.signal())
#   ```
@async
fn abort_after(controller: AbortController, ms: i64):
    await sleep(ms)
    controller.abort()

# Helper: sleep for milliseconds
@async
@extern("browser", "sleep")
fn sleep(ms: i64):
    pass
