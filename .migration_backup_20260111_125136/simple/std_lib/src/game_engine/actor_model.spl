# Actor Model for Game Logic
#
# Engine-agnostic game logic using Simple's actor model
# Provides concurrent, message-passing game entities
#
# Features:
# - Game entity actors
# - Message-based communication
# - Concurrent game logic
# - Actor lifecycle management
# - Integration with engine update loops

import sys.ffi

mod actor_model

# GameMessage
# Standard messages for game actors
pub enum GameMessage:
    Update(f32)                    # Delta time
    Spawn((f32, f32, f32))        # Position
    Despawn
    SetPosition((f32, f32, f32))
    GetPosition
    Damage(i32)
    Heal(i32)
    Custom(String, ffi.VoidPtr)   # Custom message type + data

impl GameMessage:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_update(self) -> bool:
        """Check if message is Update."""
        match self:
            case Update(_): true
            case _: false

    pub fn is_spawn(self) -> bool:
        """Check if message is Spawn."""
        match self:
            case Spawn(_): true
            case _: false

    pub fn is_despawn(self) -> bool:
        """Check if message is Despawn."""
        match self:
            case Despawn: true
            case _: false

    pub fn is_set_position(self) -> bool:
        """Check if message is SetPosition."""
        match self:
            case SetPosition(_): true
            case _: false

    pub fn is_get_position(self) -> bool:
        """Check if message is GetPosition."""
        match self:
            case GetPosition: true
            case _: false

    pub fn is_damage(self) -> bool:
        """Check if message is Damage."""
        match self:
            case Damage(_): true
            case _: false

    pub fn is_heal(self) -> bool:
        """Check if message is Heal."""
        match self:
            case Heal(_): true
            case _: false

    pub fn is_custom(self) -> bool:
        """Check if message is Custom."""
        match self:
            case Custom(_, _): true
            case _: false

    pub fn get_delta(self) -> f32:
        """Get delta time from Update message."""
        if self is GameMessage::Update(delta):
            return delta
        else:
            return 0.0

    pub fn to_string(self) -> String:
        """Convert message to string representation."""
        match self:
            case Update(delta): "Update({delta})"
            case Spawn(pos): "Spawn({pos.0}, {pos.1}, {pos.2})"
            case Despawn: "Despawn"
            case SetPosition(pos): "SetPosition({pos.0}, {pos.1}, {pos.2})"
            case GetPosition: "GetPosition"
            case Damage(amount): "Damage({amount})"
            case Heal(amount): "Heal({amount})"
            case Custom(msg_type, _): "Custom({msg_type})"

    pub fn description(self) -> String:
        """Get message description."""
        match self:
            case Update(_): "Frame update with delta time"
            case Spawn(_): "Spawn entity at position"
            case Despawn: "Remove entity from world"
            case SetPosition(_): "Set entity position"
            case GetPosition: "Query entity position"
            case Damage(_): "Deal damage to entity"
            case Heal(_): "Heal entity"
            case Custom(_, _): "Custom game message"

    pub fn summary(self) -> String:
        """Get comprehensive summary of the game message.
        Returns: summary with message type, description, and category
        Example: GameMessage.Update(0.016).summary()
                # → "GameMessage: Update(0.016) (Frame update with delta time, lifecycle)"
        """
        let msg_str = self.to_string()
        let desc = self.description()
        let mut category = "other"

        if self.is_update():
            category = "lifecycle"
        elif self.is_spawn() or self.is_despawn():
            category = "lifecycle"
        elif self.is_set_position() or self.is_get_position():
            category = "transform"
        elif self.is_damage() or self.is_heal():
            category = "health"
        elif self.is_custom():
            category = "custom"

        "GameMessage: {msg_str} ({desc}, {category})"


# GameEntity trait
# Common interface for game entities using actors
pub trait GameEntity:
    # Lifecycle
    me on_spawn()
    me on_despawn()
    me on_update(delta: f32)

    # Message handling
    me handle_message(message: GameMessage) -> Option[GameMessage]

    # State queries
    fn is_alive() -> bool
    fn get_entity_id() -> i32


# EntityActor
# Simple actor wrapper for game entities
pub struct EntityActor:
    entity_id: i32
    position: (f32, f32, f32)
    health: i32
    max_health: i32
    alive: bool
    engine_object_ptr: ffi.VoidPtr  # Godot Node or Unreal AActor

impl EntityActor:
    pub fn new(entity_id: i32, engine_object_ptr: ffi.VoidPtr) -> EntityActor:
        return EntityActor(
            entity_id: entity_id,
            position: (0.0, 0.0, 0.0),
            health: 100,
            max_health: 100,
            alive: true,
            engine_object_ptr: engine_object_ptr,
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_position(self) -> (f32, f32, f32):
        """Get entity position.

        Returns:
            Position tuple (x, y, z)

        Example:
            actor.get_position()  # → (0.0, 0.0, 0.0)
        """
        return self.position

    pub fn get_health(self) -> i32:
        """Get current health.

        Returns:
            Current health value

        Example:
            actor.get_health()  # → 100
        """
        return self.health

    pub fn get_max_health(self) -> i32:
        """Get maximum health.

        Returns:
            Maximum health value

        Example:
            actor.get_max_health()  # → 100
        """
        return self.max_health

    pub fn health_percentage(self) -> f32:
        """Get health as percentage.

        Returns:
            Health percentage (0.0 to 1.0)

        Example:
            actor.health_percentage()  # → 1.0
        """
        if self.max_health == 0:
            return 0.0
        return self.health as f32 / self.max_health as f32

    pub fn is_full_health(self) -> bool:
        """Check if at full health.

        Returns:
            true if health equals max_health

        Example:
            actor.is_full_health()  # → true
        """
        return self.health >= self.max_health

    pub fn is_dead(self) -> bool:
        """Check if entity is dead.

        Returns:
            true if not alive

        Example:
            actor.is_dead()  # → false
        """
        return not self.alive

    pub fn has_engine_object(self) -> bool:
        """Check if has valid engine object pointer.

        Returns:
            true if pointer is not null

        Example:
            actor.has_engine_object()  # → true
        """
        return not ffi.is_null_ptr(self.engine_object_ptr)

    pub fn summary(self) -> String:
        """Get entity actor summary.

        Returns:
            Human-readable summary

        Example:
            actor.summary()
            # → "EntityActor #1: alive, pos=(0.0, 0.0, 0.0), health=100/100 (100%)"
        """
        let (x, y, z) = self.position
        let status = if self.alive { "alive" } else { "dead" }
        let health_pct = (self.health_percentage() * 100.0) as i32
        return "EntityActor #{self.entity_id}: {status}, pos=({x}, {y}, {z}), health={self.health}/{self.max_health} ({health_pct}%)"

impl GameEntity for EntityActor:
    me on_spawn():
        self.alive = true
        # Sync with engine
        sync_entity_to_engine(self.engine_object_ptr, self.position)

    me on_despawn():
        self.alive = false
        # Notify engine
        despawn_engine_object(self.engine_object_ptr)

    me on_update(delta: f32):
        # Update logic here
        pass

    me handle_message(message: GameMessage) -> Option[GameMessage]:
        if message is GameMessage::Update(delta):
            self.on_update(delta)
            return None

        elif message is GameMessage::SetPosition((x, y, z)):
            self.position = (x, y, z)
            sync_entity_to_engine(self.engine_object_ptr, self.position)
            return None

        elif message is GameMessage::GetPosition:
            return Some(GameMessage::SetPosition(self.position))

        elif message is GameMessage::Damage(amount):
            self.health = self.health - amount
            if self.health <= 0:
                self.health = 0
                self.alive = false
                self.on_despawn()
            return None

        elif message is GameMessage::Heal(amount):
            self.health = self.health + amount
            if self.health > self.max_health:
                self.health = self.max_health
            return None

        elif message is GameMessage::Despawn:
            self.on_despawn()
            return None

        else:
            return None

    fn is_alive() -> bool:
        return self.alive

    fn get_entity_id() -> i32:
        return self.entity_id


# EntityManager
# Manages collection of game entity actors
pub struct EntityManager:
    entities: Vec[(i32, EntityActor)]  # entity_id -> actor
    next_id: i32

impl EntityManager:
    pub fn new() -> EntityManager:
        return EntityManager(
            entities: [],
            next_id: 1,
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn entity_count(self) -> usize:
        """Get number of entities.

        Returns:
            Entity count

        Example:
            manager.entity_count()  # → 5
        """
        return self.entities.len()

    pub fn has_entities(self) -> bool:
        """Check if has any entities.

        Returns:
            true if entity count > 0

        Example:
            manager.has_entities()  # → true
        """
        return self.entities.len() > 0

    pub fn is_empty(self) -> bool:
        """Check if manager is empty.

        Returns:
            true if no entities

        Example:
            manager.is_empty()  # → false
        """
        return self.entities.len() == 0

    pub fn has_entity(self, entity_id: i32) -> bool:
        """Check if entity with ID exists.

        Args:
            entity_id: Entity ID to check

        Returns:
            true if entity exists

        Example:
            manager.has_entity(5)  # → true
        """
        for (id, _) in self.entities:
            if id == entity_id:
                return true
        return false

    pub fn get_next_id(self) -> i32:
        """Get next entity ID that will be assigned.

        Returns:
            Next entity ID

        Example:
            manager.get_next_id()  # → 6
        """
        return self.next_id

    pub fn summary(self) -> String:
        """Get entity manager summary.

        Returns:
            Human-readable summary

        Example:
            manager.summary()
            # → "EntityManager: 5 entities, next_id=6"
        """
        let count = self.entity_count()
        return "EntityManager: {count} entities, next_id={self.next_id}"

    # Spawn new entity
    pub fn spawn_entity(mut self, engine_object_ptr: ffi.VoidPtr) -> i32:
        let entity_id = self.next_id
        self.next_id = self.next_id + 1

        let mut entity = EntityActor::new(entity_id, engine_object_ptr)
        entity.on_spawn()

        self.entities.push((entity_id, entity))
        return entity_id

    # Despawn entity
    pub fn despawn_entity(mut self, entity_id: i32):
        let mut new_entities = Vec::new()
        for (id, mut entity) in self.entities:
            if id == entity_id:
                entity.on_despawn()
            else:
                new_entities.push((id, entity))
        self.entities = new_entities

    # Send message to entity
    pub fn send_message(mut self, entity_id: i32, message: GameMessage) -> Option[GameMessage]:
        for (id, mut entity) in self.entities:
            if id == entity_id:
                return entity.handle_message(message)
        return None

    # Broadcast message to all entities
    pub fn broadcast_message(mut self, message: GameMessage):
        for (id, mut entity) in self.entities:
            entity.handle_message(message)

    # Update all entities
    pub fn update_all(mut self, delta: f32):
        self.broadcast_message(GameMessage::Update(delta))

    # Get entity count
    pub fn get_entity_count(self) -> i32:
        return self.entities.len()


# Global entity manager
let mut ENTITY_MANAGER: Option[EntityManager] = None

# Get global entity manager
pub fn get_entity_manager() -> EntityManager:
    if ENTITY_MANAGER.is_none():
        ENTITY_MANAGER = Some(EntityManager::new())

    return ENTITY_MANAGER.unwrap()


# Utility functions

# Spawn entity
pub fn spawn_game_entity(engine_object_ptr: ffi.VoidPtr) -> i32:
    let mut manager = get_entity_manager()
    return manager.spawn_entity(engine_object_ptr)

# Despawn entity
pub fn despawn_game_entity(entity_id: i32):
    let mut manager = get_entity_manager()
    manager.despawn_entity(entity_id)

# Send message to entity
pub fn send_entity_message(entity_id: i32, message: GameMessage) -> Option[GameMessage]:
    let mut manager = get_entity_manager()
    return manager.send_message(entity_id, message)

# Update all game entities
pub fn update_game_entities(delta: f32):
    let mut manager = get_entity_manager()
    manager.update_all(delta)


# Engine synchronization (internal)
fn sync_entity_to_engine(engine_object_ptr: ffi.VoidPtr, position: (f32, f32, f32)):
    let (x, y, z) = position
    # Detect engine type and sync accordingly
    if is_godot_object(engine_object_ptr):
        godot_set_position(engine_object_ptr, x, y, z)
    else:
        unreal_set_position(engine_object_ptr, x, y, z)

fn despawn_engine_object(engine_object_ptr: ffi.VoidPtr):
    if is_godot_object(engine_object_ptr):
        godot_queue_free(engine_object_ptr)
    else:
        unreal_destroy_actor(engine_object_ptr)

fn is_godot_object(object_ptr: ffi.VoidPtr) -> bool:
    # Stub - would check object type
    return false


# FFI declarations
extern "C":
    fn godot_set_position(node: ffi.VoidPtr, x: f32, y: f32, z: f32)
    fn godot_queue_free(node: ffi.VoidPtr)
    fn unreal_set_position(actor: ffi.VoidPtr, x: f32, y: f32, z: f32)
    fn unreal_destroy_actor(actor: ffi.VoidPtr)


# Example usage:
#
# # Spawn game entity
# let entity_id = spawn_game_entity(godot_node_ptr)
#
# # Send messages
# send_entity_message(entity_id, GameMessage::SetPosition((10.0, 0.0, 5.0)))
# send_entity_message(entity_id, GameMessage::Damage(25))
#
# # Update all entities (call from game loop)
# update_game_entities(0.016)  # 60 FPS
#
# # Check entity position
# let response = send_entity_message(entity_id, GameMessage::GetPosition)
# if response.is_some():
#     if response.unwrap() is GameMessage::SetPosition((x, y, z)):
#         print("Entity at {x}, {y}, {z}")
#
# # Despawn entity
# despawn_game_entity(entity_id)
