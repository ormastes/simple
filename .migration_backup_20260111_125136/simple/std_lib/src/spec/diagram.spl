# Diagram Generation Module
# Provides call flow tracing and Mermaid diagram generation

# ============================================================================
# Types
# ============================================================================

enum DiagramType:
    Sequence
    Class
    Architecture

impl DiagramType:
    fn is_sequence() -> Bool:
        """Check if this is Sequence diagram type.
        Returns: true for Sequence
        Example: DiagramType.Sequence.is_sequence()  # → true
        """
        match self:
            case DiagramType.Sequence: true
            case _: false

    fn is_class() -> Bool:
        """Check if this is Class diagram type.
        Returns: true for Class
        Example: DiagramType.Class.is_class()  # → true
        """
        match self:
            case DiagramType.Class: true
            case _: false

    fn is_architecture() -> Bool:
        """Check if this is Architecture diagram type.
        Returns: true for Architecture
        Example: DiagramType.Architecture.is_architecture()  # → true
        """
        match self:
            case DiagramType.Architecture: true
            case _: false

    fn is_behavioral() -> Bool:
        """Check if diagram type shows behavior (Sequence).
        Returns: true for Sequence
        Example: DiagramType.Sequence.is_behavioral()  # → true
        """
        match self:
            case DiagramType.Sequence: true
            case _: false

    fn is_structural() -> Bool:
        """Check if diagram type shows structure (Class or Architecture).
        Returns: true for Class or Architecture
        Example: DiagramType.Class.is_structural()  # → true
        """
        match self:
            case DiagramType.Class: true
            case DiagramType.Architecture: true
            case _: false

    fn to_string() -> String:
        """Convert DiagramType to string representation.
        Returns: lowercase diagram type name
        Example: DiagramType.Sequence.to_string()  # → "sequence"
        """
        match self:
            case DiagramType.Sequence: "sequence"
            case DiagramType.Class: "class"
            case DiagramType.Architecture: "architecture"

    fn description() -> String:
        """Get human-readable description of the diagram type.
        Returns: descriptive explanation
        Example: DiagramType.Sequence.description()
                # → "Sequence diagram showing message flow over time"
        """
        match self:
            case DiagramType.Sequence: "Sequence diagram showing message flow over time"
            case DiagramType.Class: "Class diagram showing types and relationships"
            case DiagramType.Architecture: "Architecture diagram showing component structure"

    fn summary() -> String:
        """Get comprehensive summary of the diagram type.
        Returns: summary with type name, description, and category
        Example: DiagramType.Class.summary()
                # → "DiagramType: class (Class diagram showing types and relationships, structural)"
        """
        let name = self.to_string()
        let desc = self.description()
        let category = if self.is_behavioral():
            "behavioral"
        else:
            "structural"
        "DiagramType: {name} ({desc}, {category})"

struct DiagramConfig:
    diagram_type: DiagramType
    output_dir: String
    include_timestamps: Bool
    include_arguments: Bool
    max_depth: Int

    fn new() -> DiagramConfig:
        return DiagramConfig {
            diagram_type: DiagramType.Sequence,
            output_dir: ".diagrams",
            include_timestamps: false,
            include_arguments: true,
            max_depth: 10
        }

enum CallType:
    Direct
    Method
    Ffi
    Closure
    Constructor

impl CallType:
    fn is_direct() -> Bool:
        """Check if this is Direct call type.
        Returns: true for Direct
        Example: CallType.Direct.is_direct()  # → true
        """
        match self:
            case CallType.Direct: true
            case _: false

    fn is_method() -> Bool:
        """Check if this is Method call type.
        Returns: true for Method
        Example: CallType.Method.is_method()  # → true
        """
        match self:
            case CallType.Method: true
            case _: false

    fn is_ffi() -> Bool:
        """Check if this is FFI call type.
        Returns: true for Ffi
        Example: CallType.Ffi.is_ffi()  # → true
        """
        match self:
            case CallType.Ffi: true
            case _: false

    fn is_closure() -> Bool:
        """Check if this is Closure call type.
        Returns: true for Closure
        Example: CallType.Closure.is_closure()  # → true
        """
        match self:
            case CallType.Closure: true
            case _: false

    fn is_constructor() -> Bool:
        """Check if this is Constructor call type.
        Returns: true for Constructor
        Example: CallType.Constructor.is_constructor()  # → true
        """
        match self:
            case CallType.Constructor: true
            case _: false

    fn is_native() -> Bool:
        """Check if call is native Simple code (not FFI).
        Returns: true for Direct, Method, Closure, or Constructor
        Example: CallType.Method.is_native()  # → true
        """
        match self:
            case CallType.Direct: true
            case CallType.Method: true
            case CallType.Closure: true
            case CallType.Constructor: true
            case CallType.Ffi: false

    fn is_object_oriented() -> Bool:
        """Check if call is object-oriented (Method or Constructor).
        Returns: true for Method or Constructor
        Example: CallType.Method.is_object_oriented()  # → true
        """
        match self:
            case CallType.Method: true
            case CallType.Constructor: true
            case _: false

    fn is_functional() -> Bool:
        """Check if call is functional-style (Direct or Closure).
        Returns: true for Direct or Closure
        Example: CallType.Closure.is_functional()  # → true
        """
        match self:
            case CallType.Direct: true
            case CallType.Closure: true
            case _: false

    fn to_string() -> String:
        """Convert CallType to string representation.
        Returns: lowercase call type name
        Example: CallType.Method.to_string()  # → "method"
        """
        match self:
            case CallType.Direct: "direct"
            case CallType.Method: "method"
            case CallType.Ffi: "ffi"
            case CallType.Closure: "closure"
            case CallType.Constructor: "constructor"

    fn description() -> String:
        """Get human-readable description of the call type.
        Returns: descriptive explanation
        Example: CallType.Ffi.description()
                # → "FFI call to external native code"
        """
        match self:
            case CallType.Direct: "Direct function call"
            case CallType.Method: "Object method invocation"
            case CallType.Ffi: "FFI call to external native code"
            case CallType.Closure: "Closure or lambda invocation"
            case CallType.Constructor: "Object constructor call"

    fn summary() -> String:
        """Get comprehensive summary of the call type.
        Returns: summary with type name, description, and category
        Example: CallType.Method.summary()
                # → "CallType: method (Object method invocation, native, object-oriented)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut props = []

        if self.is_native():
            props.push("native")
        else:
            props.push("external")

        if self.is_object_oriented():
            props.push("object-oriented")
        elif self.is_functional():
            props.push("functional")

        let props_str = props.join(", ")
        "CallType: {name} ({desc}, {props_str})"

struct CallEvent:
    callee: String
    callee_class: Option[String]
    arguments: List[String]
    call_type: CallType
    return_value: Option[String]
    timestamp_ns: Int

    fn new(callee: String, call_type: CallType) -> CallEvent:
        return CallEvent {
            callee: callee,
            callee_class: None,
            arguments: [],
            call_type: call_type,
            return_value: None,
            timestamp_ns: 0
        }

class CallEventRecorder:
    events: List[CallEvent]
    architectural_entities: List[String]
    enabled: Bool

    fn new() -> CallEventRecorder:
        return CallEventRecorder {
            events: [],
            architectural_entities: [],
            enabled: false
        }

    fn enable() -> Void:
        self.enabled = true

    fn disable() -> Void:
        self.enabled = false

    fn clear() -> Void:
        self.events = []
        self.architectural_entities = []

    fn record(event: CallEvent) -> Void:
        if self.enabled:
            self.events.push(event)

    fn mark_architectural(entity: String) -> Void:
        if not self.architectural_entities.contains(entity):
            self.architectural_entities.push(entity)

# ============================================================================
# Global Recorder
# ============================================================================

let global_recorder: Option[CallEventRecorder] = None

fn set_recorder(recorder: CallEventRecorder) -> Void:
    global_recorder = Some(recorder)

fn get_recorder() -> Option[CallEventRecorder]:
    return global_recorder

fn clear_recorder() -> Void:
    match global_recorder:
        case Some(rec):
            rec.clear()
        case None:
            pass

# ============================================================================
# Tracing Functions (Simple-side)
# ============================================================================

fn trace_call(name: String) -> Void:
    match global_recorder:
        case Some(rec):
            let event = CallEvent.new(name, CallType.Direct)
            rec.record(event)
        case None:
            pass

fn trace_method(class_name: String, method_name: String, args: List[String]) -> Void:
    match global_recorder:
        case Some(rec):
            let event = CallEvent {
                callee: method_name,
                callee_class: Some(class_name),
                arguments: args,
                call_type: CallType.Method,
                return_value: None,
                timestamp_ns: 0
            }
            rec.record(event)
        case None:
            pass

fn trace_return(value: Option[String]) -> Void:
    pass

fn mark_architectural(entity: String) -> Void:
    match global_recorder:
        case Some(rec):
            rec.mark_architectural(entity)
        case None:
            pass

# ============================================================================
# Diagram Generation (Simple-side)
# ============================================================================

fn generate_sequence() -> String:
    return "sequenceDiagram"

fn generate_class_diagram() -> String:
    return "classDiagram"

fn generate_arch_diagram() -> String:
    return "flowchart TD"

# ============================================================================
# Context Helpers
# ============================================================================

fn with_sequence_diagram[T](config: DiagramConfig, block: fn() -> T) -> T:
    enable_ffi_recording()
    clear_ffi_recording()
    let result = block()
    disable_ffi_recording()
    return result

fn with_all_diagrams[T](config: DiagramConfig, block: fn() -> T) -> T:
    enable_ffi_recording()
    clear_ffi_recording()
    let result = block()
    disable_ffi_recording()
    return result

fn with_diagram[T](dtype: DiagramType, config: DiagramConfig, block: fn() -> T) -> T:
    enable_ffi_recording()
    clear_ffi_recording()
    let result = block()
    disable_ffi_recording()
    return result

# ============================================================================
# File Operations
# ============================================================================

fn save_diagram(path: String, content: String) -> Void:
    pass

fn diagram_exists(path: String) -> Bool:
    return false

fn diagram_placeholder(dtype: DiagramType) -> String:
    return "diagram placeholder"

# ============================================================================
# FFI Declarations
# ============================================================================

extern fn rt_diagram_enable() -> Void
extern fn rt_diagram_disable() -> Void
extern fn rt_diagram_clear() -> Void
extern fn rt_diagram_is_enabled() -> Bool
extern fn rt_diagram_trace_method(class_name: String, method_name: String) -> Void
extern fn rt_diagram_trace_method_with_args(class_name: String, method_name: String, args: String) -> Void
extern fn rt_diagram_trace_return(value: String) -> Void
extern fn rt_diagram_mark_architectural(entity: String) -> Void
extern fn rt_diagram_generate_sequence() -> String
extern fn rt_diagram_generate_class() -> String
extern fn rt_diagram_generate_arch() -> String
extern fn rt_diagram_free_string(ptr: Int) -> Void

# ============================================================================
# FFI Wrappers
# ============================================================================

fn enable_ffi_recording() -> Void:
    rt_diagram_enable()

fn disable_ffi_recording() -> Void:
    rt_diagram_disable()

fn clear_ffi_recording() -> Void:
    rt_diagram_clear()

fn generate_sequence_ffi() -> String:
    return rt_diagram_generate_sequence()

fn generate_class_ffi() -> String:
    return rt_diagram_generate_class()

fn generate_arch_ffi() -> String:
    return rt_diagram_generate_arch()

# ============================================================================
# Exports
# ============================================================================

export DiagramType, DiagramConfig
export CallType, CallEvent, CallEventRecorder
export set_recorder, get_recorder, clear_recorder
export trace_call, trace_method, trace_return, mark_architectural
export generate_sequence, generate_class_diagram, generate_arch_diagram
export with_sequence_diagram, with_all_diagrams, with_diagram
export save_diagram, diagram_exists, diagram_placeholder
export enable_ffi_recording, disable_ffi_recording, clear_ffi_recording
export generate_sequence_ffi, generate_class_ffi, generate_arch_ffi
