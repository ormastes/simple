# Multi-Level Mode Configuration (#2051)
# Configuration hierarchy: Test → Block → File → Directory → Project

import execution_mode.{ExecutionMode, ModeSet, string_to_mode}

## Failure Strategy
enum FailureStrategy:
    # Continue with next mode on failure (default)
    SkipRemaining

    # Stop all modes if any mode fails
    FailAll

    # Run all modes, report all failures at end
    CollectAll

impl FailureStrategy:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_skip_remaining() -> Bool:
        """Check if strategy is SkipRemaining."""
        match self:
            case SkipRemaining: true
            case _: false

    fn is_fail_all() -> Bool:
        """Check if strategy is FailAll."""
        match self:
            case FailAll: true
            case _: false

    fn is_collect_all() -> Bool:
        """Check if strategy is CollectAll."""
        match self:
            case CollectAll: true
            case _: false

    fn should_stop_on_failure() -> Bool:
        """Check if should stop execution on first failure."""
        return self.is_fail_all()

    fn should_continue_on_failure() -> Bool:
        """Check if should continue despite failures."""
        return not self.should_stop_on_failure()

    fn to_string() -> String:
        """Convert to string representation."""
        return failure_strategy_to_string(self)

    fn summary() -> String:
        """Get summary of failure strategy."""
        let name = self.to_string()
        let behavior = if self.is_skip_remaining(): "skip remaining modes on failure"
                       else if self.is_fail_all(): "stop all modes on failure"
                       else: "collect all failures"
        return "FailureStrategy: {name} ({behavior})"

## Mode Configuration
struct ModeConfig:
    modes: Option[ModeSet]
    skip_modes: Option[ModeSet]
    only_modes: Option[ModeSet]
    failure_strategy: Option[FailureStrategy]
    parent: Option[ModeConfig]

## ModeConfig Implementation
impl ModeConfig:
    fn new() -> ModeConfig:
        ModeConfig {
            modes: None,
            skip_modes: None,
            only_modes: None,
            failure_strategy: None,
            parent: None
        }

    fn with_parent(parent: ModeConfig) -> ModeConfig:
        let mut config = ModeConfig.new()
        config.parent = Some(parent)
        return config

    me set_modes(modes: ModeSet) -> ModeConfig:
        self.modes = Some(modes)
        return self

    me set_skip_modes(modes: ModeSet) -> ModeConfig:
        self.skip_modes = Some(modes)
        return self

    me set_only_modes(modes: ModeSet) -> ModeConfig:
        self.only_modes = Some(modes)
        return self

    me set_failure_strategy(strategy: FailureStrategy) -> ModeConfig:
        self.failure_strategy = Some(strategy)
        return self

    fn resolve_modes() -> ModeSet:
        if self.only_modes.is_some():
            return self.only_modes.unwrap()

        let mut effective_modes = ModeSet.all()
        if self.modes.is_some():
            effective_modes = self.modes.unwrap()
        elif self.parent.is_some():
            effective_modes = self.parent.unwrap().resolve_modes()

        let skip = self.resolve_skip_modes()
        effective_modes = effective_modes.difference(skip)
        return effective_modes

    fn resolve_skip_modes() -> ModeSet:
        let mut skip = ModeSet.new([])
        if self.skip_modes.is_some():
            skip = self.skip_modes.unwrap()

        if self.parent.is_some():
            let parent_skip = self.parent.unwrap().resolve_skip_modes()
            skip = skip.union_with(parent_skip)

        return skip

    fn resolve_failure_strategy() -> FailureStrategy:
        if self.failure_strategy.is_some():
            return self.failure_strategy.unwrap()

        if self.parent.is_some():
            return self.parent.unwrap().resolve_failure_strategy()

        return FailureStrategy.SkipRemaining

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_modes() -> Bool:
        """Check if modes are explicitly set."""
        return self.modes.is_some()

    fn has_skip_modes() -> Bool:
        """Check if skip modes are set."""
        return self.skip_modes.is_some()

    fn has_only_modes() -> Bool:
        """Check if only modes are set."""
        return self.only_modes.is_some()

    fn has_failure_strategy() -> Bool:
        """Check if failure strategy is explicitly set."""
        return self.failure_strategy.is_some()

    fn has_parent() -> Bool:
        """Check if config has a parent."""
        return self.parent.is_some()

    fn is_root_config() -> Bool:
        """Check if this is a root config (no parent)."""
        return not self.has_parent()

    fn uses_only_modes() -> Bool:
        """Check if using only_modes restriction."""
        return self.has_only_modes()

    fn is_inherited() -> Bool:
        """Check if config inherits from parent."""
        return self.has_parent() and not self.has_modes() and not self.has_only_modes()

    fn is_override() -> Bool:
        """Check if config overrides parent."""
        return self.has_parent() and (self.has_modes() or self.has_only_modes())

    fn get_effective_modes() -> ModeSet:
        """Get the effective mode set after resolution."""
        return self.resolve_modes()

    fn get_effective_strategy() -> FailureStrategy:
        """Get the effective failure strategy after resolution."""
        return self.resolve_failure_strategy()

    fn summary() -> String:
        """Get summary of mode configuration."""
        let modes = self.resolve_modes()
        let strategy = self.resolve_failure_strategy()
        let mode_count = modes.size()
        let has_parent_str = if self.has_parent(): "inherited" else: "root"
        return "ModeConfig: {mode_count} modes, {strategy.to_string()} strategy ({has_parent_str})"

## Configuration Levels
enum ConfigLevel:
    Project
    Directory
    File
    Block
    Test

impl ConfigLevel:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_project() -> Bool:
        """Check if this is Project level."""
        match self:
            case Project: true
            case _: false

    fn is_directory() -> Bool:
        """Check if this is Directory level."""
        match self:
            case Directory: true
            case _: false

    fn is_file() -> Bool:
        """Check if this is File level."""
        match self:
            case File: true
            case _: false

    fn is_block() -> Bool:
        """Check if this is Block level."""
        match self:
            case Block: true
            case _: false

    fn is_test() -> Bool:
        """Check if this is Test level."""
        match self:
            case Test: true
            case _: false

    fn specificity() -> Int:
        """Get specificity level (higher is more specific)."""
        match self:
            case Project: 0
            case Directory: 1
            case File: 2
            case Block: 3
            case Test: 4

    fn is_more_specific_than(other: ConfigLevel) -> Bool:
        """Check if this level is more specific than another."""
        return self.specificity() > other.specificity()

    fn is_less_specific_than(other: ConfigLevel) -> Bool:
        """Check if this level is less specific than another."""
        return self.specificity() < other.specificity()

    fn to_string() -> String:
        """Convert to string representation."""
        match self:
            case Project: "project"
            case Directory: "directory"
            case File: "file"
            case Block: "block"
            case Test: "test"

    fn summary() -> String:
        """Get summary of config level."""
        let name = self.to_string()
        let spec = self.specificity()
        return "ConfigLevel: {name} (specificity={spec})"

struct ConfigSource:
    level: ConfigLevel
    path: Option[String]
    name: Option[String]

impl ConfigSource:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_path() -> Bool:
        """Check if path is set."""
        return self.path.is_some()

    fn has_name() -> Bool:
        """Check if name is set."""
        return self.name.is_some()

    fn is_project_level() -> Bool:
        """Check if source is at project level."""
        return self.level.is_project()

    fn is_directory_level() -> Bool:
        """Check if source is at directory level."""
        return self.level.is_directory()

    fn is_file_level() -> Bool:
        """Check if source is at file level."""
        return self.level.is_file()

    fn is_block_level() -> Bool:
        """Check if source is at block level."""
        return self.level.is_block()

    fn is_test_level() -> Bool:
        """Check if source is at test level."""
        return self.level.is_test()

    fn get_specificity() -> Int:
        """Get specificity level of this source."""
        return self.level.specificity()

    fn summary() -> String:
        """Get summary of config source."""
        let level_str = self.level.to_string()
        let path_str = if self.has_path(): self.path.unwrap() else: "no path"
        let name_str = if self.has_name(): self.name.unwrap() else: "no name"
        return "ConfigSource: {level_str} level - path={path_str}, name={name_str}"

## Project-Level Configuration
struct ProjectConfig:
    default_modes: ModeSet
    mode_failure_strategy: FailureStrategy

impl ProjectConfig:
    fn default() -> ProjectConfig:
        ProjectConfig {
            default_modes: ModeSet.all(),
            mode_failure_strategy: FailureStrategy.SkipRemaining
        }

    fn to_mode_config() -> ModeConfig:
        let mut config = ModeConfig.new()
        config = config.set_modes(self.default_modes)
        config = config.set_failure_strategy(self.mode_failure_strategy)
        return config

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn uses_all_modes() -> Bool:
        """Check if using all available modes."""
        return self.default_modes.equals(ModeSet.all())

    fn mode_count() -> Int:
        """Get number of default modes."""
        return self.default_modes.size()

    fn uses_skip_remaining() -> Bool:
        """Check if using SkipRemaining strategy."""
        return self.mode_failure_strategy.is_skip_remaining()

    fn uses_fail_all() -> Bool:
        """Check if using FailAll strategy."""
        return self.mode_failure_strategy.is_fail_all()

    fn uses_collect_all() -> Bool:
        """Check if using CollectAll strategy."""
        return self.mode_failure_strategy.is_collect_all()

    fn summary() -> String:
        """Get summary of project configuration."""
        let mode_count = self.mode_count()
        let strategy = self.mode_failure_strategy.to_string()
        return "ProjectConfig: {mode_count} modes, {strategy} strategy"

## Directory-Level Configuration
struct DirectoryConfig:
    modes: Option[ModeSet]
    skip_modes: Option[ModeSet]
    mode_failure_strategy: Option[FailureStrategy]

impl DirectoryConfig:
    fn new() -> DirectoryConfig:
        DirectoryConfig {
            modes: None,
            skip_modes: None,
            mode_failure_strategy: None
        }

    fn to_mode_config(parent: ModeConfig) -> ModeConfig:
        let mut config = ModeConfig.with_parent(parent)

        if self.modes.is_some():
            config = config.set_modes(self.modes.unwrap())

        if self.skip_modes.is_some():
            config = config.set_skip_modes(self.skip_modes.unwrap())

        if self.mode_failure_strategy.is_some():
            config = config.set_failure_strategy(self.mode_failure_strategy.unwrap())

        return config

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_modes() -> Bool:
        """Check if modes are explicitly set."""
        return self.modes.is_some()

    fn has_skip_modes() -> Bool:
        """Check if skip modes are set."""
        return self.skip_modes.is_some()

    fn has_failure_strategy() -> Bool:
        """Check if failure strategy is set."""
        return self.mode_failure_strategy.is_some()

    fn is_empty() -> Bool:
        """Check if config has no settings."""
        return not self.has_modes() and not self.has_skip_modes() and not self.has_failure_strategy()

    fn has_any_settings() -> Bool:
        """Check if config has any settings."""
        return not self.is_empty()

    fn summary() -> String:
        """Get summary of directory configuration."""
        let parts = []
        if self.has_modes():
            parts.push("modes set")
        if self.has_skip_modes():
            parts.push("skip modes set")
        if self.has_failure_strategy():
            parts.push("strategy set")
        if parts.is_empty():
            return "DirectoryConfig: empty"
        return "DirectoryConfig: {parts.join(\", \")}"

## File-Level Configuration
struct FileConfig:
    modes: Option[ModeSet]
    skip_modes: Option[ModeSet]
    only_modes: Option[ModeSet]
    mode_failure_strategy: Option[FailureStrategy]

impl FileConfig:
    fn new() -> FileConfig:
        FileConfig {
            modes: None,
            skip_modes: None,
            only_modes: None,
            mode_failure_strategy: None
        }

    fn to_mode_config(parent: ModeConfig) -> ModeConfig:
        let mut config = ModeConfig.with_parent(parent)

        if self.modes.is_some():
            config = config.set_modes(self.modes.unwrap())

        if self.skip_modes.is_some():
            config = config.set_skip_modes(self.skip_modes.unwrap())

        if self.only_modes.is_some():
            config = config.set_only_modes(self.only_modes.unwrap())

        if self.mode_failure_strategy.is_some():
            config = config.set_failure_strategy(self.mode_failure_strategy.unwrap())

        return config

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_modes() -> Bool:
        """Check if modes are explicitly set."""
        return self.modes.is_some()

    fn has_skip_modes() -> Bool:
        """Check if skip modes are set."""
        return self.skip_modes.is_some()

    fn has_only_modes() -> Bool:
        """Check if only modes are set."""
        return self.only_modes.is_some()

    fn has_failure_strategy() -> Bool:
        """Check if failure strategy is set."""
        return self.mode_failure_strategy.is_some()

    fn is_empty() -> Bool:
        """Check if config has no settings."""
        return not self.has_modes() and not self.has_skip_modes() and
               not self.has_only_modes() and not self.has_failure_strategy()

    fn has_any_settings() -> Bool:
        """Check if config has any settings."""
        return not self.is_empty()

    fn uses_only_modes() -> Bool:
        """Check if using only_modes restriction."""
        return self.has_only_modes()

    fn summary() -> String:
        """Get summary of file configuration."""
        let parts = []
        if self.has_modes():
            parts.push("modes set")
        if self.has_skip_modes():
            parts.push("skip modes set")
        if self.has_only_modes():
            parts.push("only modes set")
        if self.has_failure_strategy():
            parts.push("strategy set")
        if parts.is_empty():
            return "FileConfig: empty"
        return "FileConfig: {parts.join(\", \")}"

## Helper Functions

export fn string_to_failure_strategy(s: String) -> Option[FailureStrategy]:
    match s:
        case "skip_remaining" => Some(FailureStrategy.SkipRemaining)
        case "fail_all" => Some(FailureStrategy.FailAll)
        case "collect_all" => Some(FailureStrategy.CollectAll)
        case _ => None

export fn failure_strategy_to_string(strategy: FailureStrategy) -> String:
    match strategy:
        case FailureStrategy.SkipRemaining => "skip_remaining"
        case FailureStrategy.FailAll => "fail_all"
        case FailureStrategy.CollectAll => "collect_all"

export fn parse_mode_list(mode_names: List[String]) -> Option[ModeSet]:
    let mut modes = []
    let mut valid = true

    for name in mode_names:
        match string_to_mode(name):
            case Some(mode) => modes.push(mode)
            case None => valid = false

    if valid:
        return Some(ModeSet.new(modes))
    else:
        return None

## Exports
export FailureStrategy
export ModeConfig
export ProjectConfig
export DirectoryConfig
export FileConfig
export ConfigLevel
export ConfigSource
