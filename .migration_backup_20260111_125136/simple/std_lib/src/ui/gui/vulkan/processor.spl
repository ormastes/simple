# Async Element Processor
#
# Convert element tree to GPU draw list.

use core.*
use concurrency.*
use ui.element.*

import types.{DrawList, VertexBuilder, LayoutResult, DirtyRegion}

export AsyncElementProcessor

# ============================================================================
# Async Element Processor
# ============================================================================

struct AsyncElementProcessor:
    vertex_builder: VertexBuilder
    draw_list: DrawList

impl AsyncElementProcessor:
    fn new() -> AsyncElementProcessor:
        return AsyncElementProcessor {
            vertex_builder: VertexBuilder::new(),
            draw_list: DrawList::new()
        }

    async fn process_tree_async(self, tree: &ElementTree, layout: &LayoutResult)
        -> Future[DrawList]:
        # Clear previous frame
        self.draw_list.clear()
        self.vertex_builder.clear()

        # Process tree (can be parallelized by subtree)
        await self.process_element_async(tree.root(), layout)

        # Finalize
        self.draw_list.vertices = self.vertex_builder.vertices
        self.draw_list.indices = self.vertex_builder.indices

        return Future::ready(self.draw_list)

    async fn process_element_async(self, elem: &Element, layout: &LayoutResult)
        -> Future[()]:
        # TODO: [ui][P3] Generate geometry for this element
        # Can spawn parallel tasks for children

        return Future::ready(())

    async fn process_dirty_regions_async(self, layouts: &Array[LayoutResult])
        -> Future[DrawList]:
        # TODO: [ui][P3] Process only dirty regions
        return Future::ready(DrawList::new())
