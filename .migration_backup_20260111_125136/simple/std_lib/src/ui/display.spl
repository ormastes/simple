# Display - Display Widgets (Text, Icon, Image, Badge, ProgressBar)
#
# Provides display-only widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Text style configuration
pub struct TextStyle:
    font_size: Option[i32]
    font_weight: Option[String]
    font_family: Option[String]
    color: Option[Color]
    line_height: Option[f64]
    text_align: Option[TextAlign]
    text_decoration: Option[TextDecoration]

pub enum TextAlign:
    Left
    Center
    Right
    Justify

impl TextAlign:
    pub fn to_string(self) -> String:
        """Convert text align to string."""
        match self:
            case Left: "left"
            case Center: "center"
            case Right: "right"
            case Justify: "justify"

    pub fn description(self) -> String:
        """Get text align description."""
        match self:
            case Left: "Align text to the left"
            case Center: "Center text"
            case Right: "Align text to the right"
            case Justify: "Justify text (align both left and right)"

    pub fn is_left(self) -> bool:
        """Check if align is Left."""
        match self:
            case Left: true
            case _: false

    pub fn is_center(self) -> bool:
        """Check if align is Center."""
        match self:
            case Center: true
            case _: false

    pub fn is_right(self) -> bool:
        """Check if align is Right."""
        match self:
            case Right: true
            case _: false

    pub fn is_justify(self) -> bool:
        """Check if align is Justify."""
        match self:
            case Justify: true
            case _: false

    pub fn summary(self) -> String:
        """Get text align summary."""
        let name = self.to_string()
        let desc = self.description()
        return "TextAlign: {name} ({desc})"

pub enum TextDecoration:
    None
    Underline
    Overline
    LineThrough

impl TextDecoration:
    pub fn to_string(self) -> String:
        """Convert text decoration to string."""
        match self:
            case None: "none"
            case Underline: "underline"
            case Overline: "overline"
            case LineThrough: "line-through"

    pub fn description(self) -> String:
        """Get text decoration description."""
        match self:
            case None: "No text decoration"
            case Underline: "Underline text"
            case Overline: "Line above text"
            case LineThrough: "Line through text (strikethrough)"

    pub fn is_none(self) -> bool:
        """Check if decoration is None."""
        match self:
            case None: true
            case _: false

    pub fn is_underline(self) -> bool:
        """Check if decoration is Underline."""
        match self:
            case Underline: true
            case _: false

    pub fn is_overline(self) -> bool:
        """Check if decoration is Overline."""
        match self:
            case Overline: true
            case _: false

    pub fn is_line_through(self) -> bool:
        """Check if decoration is LineThrough."""
        match self:
            case LineThrough: true
            case _: false

    pub fn has_decoration(self) -> bool:
        """Check if has any decoration (not None)."""
        match self:
            case None: false
            case _: true

    pub fn summary(self) -> String:
        """Get text decoration summary."""
        let name = self.to_string()
        let desc = self.description()
        return "TextDecoration: {name} ({desc})"

impl TextStyle:
    # Create default body text style
    pub fn body() -> TextStyle:
        return TextStyle {
            font_size: Some(16),
            font_weight: Some("400".to_string()),
            font_family: None,
            color: None,
            line_height: Some(1.5),
            text_align: None,
            text_decoration: None
        }

    # Create heading styles
    pub fn h1() -> TextStyle:
        return TextStyle::body()
            .font_size(32)
            .font_weight("700")

    pub fn h2() -> TextStyle:
        return TextStyle::body()
            .font_size(24)
            .font_weight("600")

    pub fn h3() -> TextStyle:
        return TextStyle::body()
            .font_size(20)
            .font_weight("600")

    pub fn caption() -> TextStyle:
        return TextStyle::body()
            .font_size(12)

    # Builder methods
    pub fn font_size(mut self, size: i32) -> TextStyle:
        self.font_size = Some(size)
        return self

    pub fn font_weight(mut self, weight: &str) -> TextStyle:
        self.font_weight = Some(weight.to_string())
        return self

    pub fn font_family(mut self, family: &str) -> TextStyle:
        self.font_family = Some(family.to_string())
        return self

    pub fn color(mut self, color: Color) -> TextStyle:
        self.color = Some(color)
        return self

    pub fn line_height(mut self, height: f64) -> TextStyle:
        self.line_height = Some(height)
        return self

    pub fn text_align(mut self, align: TextAlign) -> TextStyle:
        self.text_align = Some(align)
        return self

    pub fn underline(mut self) -> TextStyle:
        self.text_decoration = Some(TextDecoration::Underline)
        return self

    pub fn bold(mut self) -> TextStyle:
        self.font_weight = Some("700".to_string())
        return self

    pub fn italic(self) -> TextStyle:
        # Would need font-style property in full implementation
        return self

# Text - Display text widget
pub struct Text:
    content: String
    style: TextStyle

impl Text:
    # Create a new text widget
    pub fn new(content: &str) -> Text:
        return Text {
            content: content.to_string(),
            style: TextStyle::body()
        }

    # Set text style
    pub fn style(mut self, style: TextStyle) -> Text:
        self.style = style
        return self

impl Widget for Text:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::text(id, &self.content)
            .with_class("text")

        # Apply font size
        if let Some(size) = self.style.font_size:
            elem = elem.with_style("font-size", &"{size}px")

        # Apply font weight
        if let Some(weight) = &self.style.font_weight:
            elem = elem.with_style("font-weight", weight)

        # Apply font family
        if let Some(family) = &self.style.font_family:
            elem = elem.with_style("font-family", family)

        # Apply color
        if let Some(color) = &self.style.color:
            elem = elem.with_style("color", &color.to_css())

        # Apply line height
        if let Some(height) = self.style.line_height:
            elem = elem.with_style("line-height", &height.to_string())

        # Apply text align
        if let Some(align) = &self.style.text_align:
            let align_str = match align:
                case TextAlign::Left: "left"
                case TextAlign::Center: "center"
                case TextAlign::Right: "right"
                case TextAlign::Justify: "justify"
            elem = elem.with_style("text-align", align_str)

        # Apply text decoration
        if let Some(decoration) = &self.style.text_decoration:
            let decoration_str = match decoration:
                case TextDecoration::None: "none"
                case TextDecoration::Underline: "underline"
                case TextDecoration::Overline: "overline"
                case TextDecoration::LineThrough: "line-through"
            elem = elem.with_style("text-decoration", decoration_str)

        return WidgetNode::new(elem)

# Icon - Display icon widget
pub struct Icon:
    name: String
    size: i32
    color: Option[Color]

impl Icon:
    # Create a new icon
    pub fn new(name: &str) -> Icon:
        return Icon {
            name: name.to_string(),
            size: 24,
            color: None
        }

    # Set icon size
    pub fn size(mut self, size: i32) -> Icon:
        self.size = size
        return self

    # Set icon color
    pub fn color(mut self, color: Color) -> Icon:
        self.color = Some(color)
        return self

impl Widget for Icon:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Span)
            .with_class("icon")
            .with_class(&"icon-{self.name}")
            .with_style("display", "inline-flex")
            .with_style("width", &"{self.size}px")
            .with_style("height", &"{self.size}px")

        # Apply color
        if let Some(color) = &self.color:
            elem = elem.with_style("color", &color.to_css())

        return WidgetNode::new(elem)

# Image fit modes
pub enum ImageFit:
    Contain  # Maintain aspect ratio, fit within bounds
    Cover    # Maintain aspect ratio, cover bounds
    Fill     # Stretch to fill bounds
    None     # Original size
    ScaleDown # Like contain, but don't upscale

impl ImageFit:
    pub fn to_string(self) -> String:
        """Convert image fit to string."""
        match self:
            case Contain: "contain"
            case Cover: "cover"
            case Fill: "fill"
            case None: "none"
            case ScaleDown: "scale-down"

    pub fn description(self) -> String:
        """Get image fit description."""
        match self:
            case Contain: "Maintain aspect ratio, fit within bounds"
            case Cover: "Maintain aspect ratio, cover bounds"
            case Fill: "Stretch to fill bounds (may distort)"
            case None: "Display at original size"
            case ScaleDown: "Like contain, but don't upscale"

    pub fn is_contain(self) -> bool:
        """Check if fit is Contain."""
        match self:
            case Contain: true
            case _: false

    pub fn is_cover(self) -> bool:
        """Check if fit is Cover."""
        match self:
            case Cover: true
            case _: false

    pub fn is_fill(self) -> bool:
        """Check if fit is Fill."""
        match self:
            case Fill: true
            case _: false

    pub fn is_none(self) -> bool:
        """Check if fit is None (original size)."""
        match self:
            case None: true
            case _: false

    pub fn is_scale_down(self) -> bool:
        """Check if fit is ScaleDown."""
        match self:
            case ScaleDown: true
            case _: false

    pub fn maintains_aspect_ratio(self) -> bool:
        """Check if mode maintains aspect ratio."""
        match self:
            case Contain: true
            case Cover: true
            case ScaleDown: true
            case _: false

    pub fn can_distort(self) -> bool:
        """Check if mode can distort image."""
        match self:
            case Fill: true
            case _: false

    pub fn can_upscale(self) -> bool:
        """Check if mode allows upscaling."""
        match self:
            case Contain: true
            case Cover: true
            case Fill: true
            case _: false

    pub fn summary(self) -> String:
        """Get image fit summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.maintains_aspect_ratio():
            props.push("maintains aspect")
        if self.can_distort():
            props.push("can distort")
        if self.can_upscale():
            props.push("upscales")
        let props_str = if props.len() > 0: ", {props.join(', ')}" else: ""
        return "ImageFit: {name} ({desc}{props_str})"

# Image - Display image widget
pub struct Image:
    src: String
    alt: String
    width: Option[i32]
    height: Option[i32]
    fit: ImageFit

impl Image:
    # Create a new image
    pub fn new(src: &str) -> Image:
        return Image {
            src: src.to_string(),
            alt: String::new(),
            width: None,
            height: None,
            fit: ImageFit::Contain
        }

    # Set alt text
    pub fn alt(mut self, alt: &str) -> Image:
        self.alt = alt.to_string()
        return self

    # Set width
    pub fn width(mut self, width: i32) -> Image:
        self.width = Some(width)
        return self

    # Set height
    pub fn height(mut self, height: i32) -> Image:
        self.height = Some(height)
        return self

    # Set fit mode
    pub fn fit(mut self, fit: ImageFit) -> Image:
        self.fit = fit
        return self

impl Widget for Image:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Div)
            .with_class("image")
            .with_attr("src", &self.src)
            .with_attr("alt", &self.alt)

        # Apply dimensions
        if let Some(w) = self.width:
            elem = elem.with_style("width", &"{w}px")
        if let Some(h) = self.height:
            elem = elem.with_style("height", &"{h}px")

        # Apply fit mode
        let fit_str = match self.fit:
            case ImageFit::Contain: "contain"
            case ImageFit::Cover: "cover"
            case ImageFit::Fill: "fill"
            case ImageFit::None: "none"
            case ImageFit::ScaleDown: "scale-down"
        elem = elem.with_style("object-fit", fit_str)

        return WidgetNode::new(elem)

# Badge variant
pub enum BadgeVariant:
    Default
    Primary
    Secondary
    Success
    Warning
    Error

impl BadgeVariant:
    pub fn to_string(self) -> String:
        """Convert badge variant to string."""
        match self:
            case Default: "default"
            case Primary: "primary"
            case Secondary: "secondary"
            case Success: "success"
            case Warning: "warning"
            case Error: "error"

    pub fn description(self) -> String:
        """Get badge variant description."""
        match self:
            case Default: "Default badge (neutral)"
            case Primary: "Primary badge (important)"
            case Secondary: "Secondary badge (less prominent)"
            case Success: "Success badge (positive)"
            case Warning: "Warning badge (caution)"
            case Error: "Error badge (critical)"

    pub fn is_default(self) -> bool:
        """Check if variant is Default."""
        match self:
            case Default: true
            case _: false

    pub fn is_primary(self) -> bool:
        """Check if variant is Primary."""
        match self:
            case Primary: true
            case _: false

    pub fn is_secondary(self) -> bool:
        """Check if variant is Secondary."""
        match self:
            case Secondary: true
            case _: false

    pub fn is_success(self) -> bool:
        """Check if variant is Success."""
        match self:
            case Success: true
            case _: false

    pub fn is_warning(self) -> bool:
        """Check if variant is Warning."""
        match self:
            case Warning: true
            case _: false

    pub fn is_error(self) -> bool:
        """Check if variant is Error."""
        match self:
            case Error: true
            case _: false

    pub fn is_semantic(self) -> bool:
        """Check if variant is semantic (Success, Warning, or Error)."""
        match self:
            case Success: true
            case Warning: true
            case Error: true
            case _: false

    pub fn summary(self) -> String:
        """Get badge variant summary."""
        let name = self.to_string()
        let desc = self.description()
        let semantic = if self.is_semantic(): "semantic" else: "non-semantic"
        return "BadgeVariant: {name} ({desc}, {semantic})"

# Badge - Small status indicator
pub struct Badge:
    content: String
    variant: BadgeVariant

impl Badge:
    # Create a new badge
    pub fn new(content: &str) -> Badge:
        return Badge {
            content: content.to_string(),
            variant: BadgeVariant::Default
        }

    # Create a count badge
    pub fn count(count: u32) -> Badge:
        return Badge::new(&count.to_string())

    # Set variant to primary
    pub fn primary(mut self) -> Badge:
        self.variant = BadgeVariant::Primary
        return self

    # Set variant to success
    pub fn success(mut self) -> Badge:
        self.variant = BadgeVariant::Success
        return self

    # Set variant to warning
    pub fn warning(mut self) -> Badge:
        self.variant = BadgeVariant::Warning
        return self

    # Set variant to error
    pub fn error(mut self) -> Badge:
        self.variant = BadgeVariant::Error
        return self

impl Widget for Badge:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let variant_class = match self.variant:
            case BadgeVariant::Default: "badge-default"
            case BadgeVariant::Primary: "badge-primary"
            case BadgeVariant::Secondary: "badge-secondary"
            case BadgeVariant::Success: "badge-success"
            case BadgeVariant::Warning: "badge-warning"
            case BadgeVariant::Error: "badge-error"

        let elem = Element::new(id, ElementKind::Span)
            .with_class("badge")
            .with_class(variant_class)
            .with_text(&self.content)
            .with_style("display", "inline-flex")
            .with_style("align-items", "center")
            .with_style("justify-content", "center")
            .with_style("padding", "2px 8px")
            .with_style("border-radius", "12px")
            .with_style("font-size", "12px")
            .with_style("font-weight", "500")

        return WidgetNode::new(elem)

# ProgressBar - Progress indicator
pub struct ProgressBar:
    value: f64  # 0.0 to 1.0
    indeterminate: bool
    show_label: bool
    color: Option[Color]

impl ProgressBar:
    # Create a new progress bar
    pub fn new(value: f64) -> ProgressBar:
        return ProgressBar {
            value: value.clamp(0.0, 1.0),
            indeterminate: false,
            show_label: false,
            color: None
        }

    # Create indeterminate progress bar
    pub fn indeterminate() -> ProgressBar:
        return ProgressBar {
            value: 0.0,
            indeterminate: true,
            show_label: false,
            color: None
        }

    # Show percentage label
    pub fn show_label(mut self) -> ProgressBar:
        self.show_label = true
        return self

    # Set progress color
    pub fn color(mut self, color: Color) -> ProgressBar:
        self.color = Some(color)
        return self

impl Widget for ProgressBar:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut container = Element::new(id, ElementKind::Div)
            .with_class("progress-bar")
            .with_style("width", "100%")
            .with_style("height", "4px")
            .with_style("background-color", "#e0e0e0")
            .with_style("border-radius", "2px")
            .with_style("overflow", "hidden")

        # Create progress fill
        let fill_id = ctx.alloc_id()
        let mut fill = Element::new(fill_id, ElementKind::Div)
            .with_class("progress-fill")
            .with_style("height", "100%")
            .with_style("transition", "width 0.3s ease")

        if self.indeterminate:
            fill = fill
                .with_class("progress-indeterminate")
                .with_style("width", "30%")
                # Would add animation in CSS
        else:
            let percent = (self.value * 100.0) as i32
            fill = fill.with_style("width", &"{percent}%")

        # Apply color
        if let Some(color) = &self.color:
            fill = fill.with_style("background-color", &color.to_css())
        else:
            fill = fill.with_style("background-color", "#2196f3")

        container = container.with_child(fill)

        # Add label if requested
        if self.show_label and not self.indeterminate:
            let percent = (self.value * 100.0) as i32
            let label = Element::text(ctx.alloc_id(), &"{percent}%")
                .with_class("progress-label")
                .with_style("font-size", "12px")
                .with_style("margin-top", "4px")

            # Wrap in column to stack label below
            let wrapper_id = ctx.alloc_id()
            let wrapper = Element::new(wrapper_id, ElementKind::Div)
                .with_class("progress-wrapper")
                .with_child(container)
                .with_child(label)

            return WidgetNode::new(wrapper)

        return WidgetNode::new(container)

# Divider - Visual separator
pub struct Divider:
    orientation: DividerOrientation
    thickness: i32
    color: Option[Color]

pub enum DividerOrientation:
    Horizontal
    Vertical

impl DividerOrientation:
    pub fn to_string(self) -> String:
        """Convert divider orientation to string."""
        match self:
            case Horizontal: "horizontal"
            case Vertical: "vertical"

    pub fn description(self) -> String:
        """Get divider orientation description."""
        match self:
            case Horizontal: "Horizontal divider (full width)"
            case Vertical: "Vertical divider (full height)"

    pub fn is_horizontal(self) -> bool:
        """Check if orientation is Horizontal."""
        match self:
            case Horizontal: true
            case _: false

    pub fn is_vertical(self) -> bool:
        """Check if orientation is Vertical."""
        match self:
            case Vertical: true
            case _: false

    pub fn summary(self) -> String:
        """Get divider orientation summary."""
        let name = self.to_string()
        let desc = self.description()
        return "DividerOrientation: {name} ({desc})"

impl Divider:
    # Create horizontal divider
    pub fn horizontal() -> Divider:
        return Divider {
            orientation: DividerOrientation::Horizontal,
            thickness: 1,
            color: None
        }

    # Create vertical divider
    pub fn vertical() -> Divider:
        return Divider {
            orientation: DividerOrientation::Vertical,
            thickness: 1,
            color: None
        }

    # Set thickness
    pub fn thickness(mut self, thickness: i32) -> Divider:
        self.thickness = thickness
        return self

    # Set color
    pub fn color(mut self, color: Color) -> Divider:
        self.color = Some(color)
        return self

impl Widget for Divider:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Div)
            .with_class("divider")

        match self.orientation:
            case DividerOrientation::Horizontal:
                elem = elem
                    .with_style("width", "100%")
                    .with_style("height", &"{self.thickness}px")
            case DividerOrientation::Vertical:
                elem = elem
                    .with_style("width", &"{self.thickness}px")
                    .with_style("height", "100%")
                    .with_style("align-self", "stretch")

        # Apply color
        let color = self.color.unwrap_or(Color::hex("#e0e0e0").unwrap())
        elem = elem.with_style("background-color", &color.to_css())

        return WidgetNode::new(elem)
