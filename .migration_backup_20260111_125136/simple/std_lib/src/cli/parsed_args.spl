# CLI ParsedArgs - Parsed argument results

export ParsedArgs

import cli.file as file

# Parsed arguments result with staged files
pub struct ParsedArgs:
    flags: Dict<String, bool>
    options: Dict<String, String>
    positionals: Array<String>
    files: file.StagedFiles  # Automatically staged files

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_flags(self) -> bool:
        """Check if any flags are present."""
        return self.flags.len() > 0

    pub fn has_options(self) -> bool:
        """Check if any options are present."""
        return self.options.len() > 0

    pub fn has_positionals(self) -> bool:
        """Check if any positional arguments are present."""
        return self.positionals.len() > 0

    pub fn has_files(self) -> bool:
        """Check if any files are staged."""
        return self.files.staged().len() > 0

    pub fn flag_count(self) -> usize:
        """Get number of flags."""
        return self.flags.len()

    pub fn option_count(self) -> usize:
        """Get number of options."""
        return self.options.len()

    pub fn positional_count(self) -> usize:
        """Get number of positional arguments."""
        return self.positionals.len()

    pub fn file_count(self) -> usize:
        """Get number of staged files."""
        return self.files.staged().len()

    pub fn is_empty(self) -> bool:
        """Check if no arguments are present."""
        return not self.has_flags() and not self.has_options() and not self.has_positionals()

    pub fn has_option(self, name: String) -> bool:
        """Check if an option is present."""
        return self.options.contains_key(name)

    pub fn get_flag_names(self) -> Array<String>:
        """Get all flag names."""
        return self.flags.keys()

    pub fn get_option_names(self) -> Array<String>:
        """Get all option names."""
        return self.options.keys()

    pub fn summary(self) -> String:
        """Get summary of parsed arguments."""
        return "ParsedArgs: {self.flag_count()} flags, {self.option_count()} options, {self.positional_count()} positionals, {self.file_count()} files"

    # =========================================================================
    # Existing Methods
    # =========================================================================

    # Check if a flag is present
    pub fn has_flag(self, name: String) -> bool:
        let result = false
        if self.flags.contains_key(name):
            result = self.flags.get(name).unwrap_or(false)
        return result

    # Get a flag value
    pub fn get_flag(self, name: String) -> bool:
        return self.has_flag(name)

    # Get an option value as string
    pub fn get_option(self, name: String) -> Option<String>:
        if self.options.contains_key(name):
            return Some(self.options.get(name).unwrap())
        return None

    # Get an option value with default
    pub fn get_option_or(self, name: String, default: String) -> String:
        let result = ""
        if self.options.contains_key(name):
            result = self.options.get(name).unwrap()
        else:
            result = default
        return result

    # Get a positional argument by index
    pub fn get_positional_at(self, index: i32) -> Option<String>:
        if index >= 0 and index < self.positionals.len():
            return Some(self.positionals[index])
        return None

    # Get all positionals
    pub fn get_all_positionals(self) -> Array<String>:
        return self.positionals

    # Get all successfully staged files
    pub fn get_staged_files(self) -> Array<file.FileInfo>:
        return self.files.staged()

    # Get file by option name
    pub fn get_file(self, name: String) -> Option<file.FileInfo>:
        # Find file matching this option name
        for f in self.files.staged():
            # TODO: [stdlib][P2] Track which arg each file came from
            # For now, return first file
            return Some(f)
        return None
