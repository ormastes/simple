# Buffered I/O - Buffered readers and writers

use units.size.*
use io.fs.*

# Default buffer size
const DEFAULT_BUF_SIZE: u64 = 8192

# Buffered reader
struct BufReader:
    inner: File
    buffer: Bytes
    pos: u64
    cap: u64

impl BufReader:
    fn new(file: File) -> BufReader:
        return BufReader::with_capacity(file, DEFAULT_BUF_SIZE)

    fn with_capacity(file: File, capacity: u64) -> BufReader:
        return BufReader {
            inner: file,
            buffer: Bytes::with_capacity(capacity),
            pos: 0,
            cap: 0
        }

    # Fill buffer from underlying reader
    async fn fill_buf(self) -> Result[&Bytes, IoError]:
        if self.pos >= self.cap:
            self.cap = (await self.inner.read(&mut self.buffer)?) as u64
            self.pos = 0
        return Ok(&self.buffer.slice(self.pos, self.cap))

    # Consume n bytes from buffer
    fn consume(n: u64):
        self.pos = self.pos + n.min(self.cap - self.pos)

    # Read into buffer
    pub async fn read(self, buf: &mut Bytes) -> Result[ByteCount, IoError]:
        # If buffer is empty, read directly for large requests
        if self.pos == self.cap and buf.len() >= self.buffer.capacity():
            return self.inner.read(buf)

        # Otherwise use buffered read
        let available = await self.fill_buf()?
        let to_copy = available.len().min(buf.len())
        buf.copy_from(available, 0, to_copy)
        self.consume(to_copy)
        return Ok(to_copy_bytes)

    # Read line (until newline or EOF)
    pub async fn read_line(self) -> Result[Text, IoError]:
        let mut result = ""
        loop:
            let available = await self.fill_buf()?
            if available.len() == 0:
                break

            let newline = available.find_byte('\n' as u8)
            match newline:
                case Some(idx):
                    result = result + available.slice(0, idx + 1).to_utf8().unwrap_or("")
                    self.consume(idx + 1)
                    break
                case None:
                    result = result + available.to_utf8().unwrap_or("")
                    self.consume(available.len())

        return Ok(result_text)

    # Read all lines
    pub async fn lines(self) -> Result[Array[Text], IoError]:
        let mut lines: Array[Text] = []
        loop:
            let line = await self.read_line()?
            if (line as str).is_empty():
                break
            lines.push(line)
        return Ok(lines)

    # Get underlying file
    fn into_inner() -> File:
        return self.inner

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_buffer_size() -> u64:
        """Get buffer capacity.

        Returns:
            Buffer size in bytes

        Example:
            reader.get_buffer_size()  # → 8192
        """
        return self.buffer.capacity()

    fn available() -> u64:
        """Get number of buffered bytes available.

        Returns:
            Bytes available in buffer

        Example:
            reader.available()  # → 1024
        """
        return self.cap - self.pos

    fn is_buffer_empty() -> bool:
        """Check if buffer is empty.

        Returns:
            true if no buffered data

        Example:
            reader.is_buffer_empty()  # → false
        """
        return self.pos >= self.cap

    fn buffer_position() -> u64:
        """Get current position in buffer.

        Returns:
            Position in buffer

        Example:
            reader.buffer_position()  # → 512
        """
        return self.pos

    fn summary() -> String:
        """Get buffered reader summary.

        Returns:
            Human-readable summary

        Example:
            reader.summary()
            # → "BufReader: buffer=8192 bytes, available=1024 bytes"
        """
        let capacity = self.get_buffer_size()
        let avail = self.available()
        return "BufReader: buffer={capacity} bytes, available={avail} bytes"

# Buffered writer
struct BufWriter:
    inner: File
    buffer: Bytes
    pos: u64

impl BufWriter:
    fn new(file: File) -> BufWriter:
        return BufWriter::with_capacity(file, DEFAULT_BUF_SIZE)

    fn with_capacity(file: File, capacity: u64) -> BufWriter:
        return BufWriter {
            inner: file,
            buffer: Bytes::with_capacity(capacity),
            pos: 0
        }

    # Flush buffer to underlying writer
    pub async fn flush(self) -> Result[(), IoError]:
        if self.pos > 0:
            await self.inner.write_all(&self.buffer.slice(0, self.pos))?
            self.pos = 0
        return self.inner.flush()

    # Write data
    pub async fn write(self, data: &Bytes) -> Result[ByteCount, IoError]:
        # If data is larger than buffer, flush and write directly
        if data.len() >= self.buffer.capacity():
            await self.flush()?
            return self.inner.write(data)

        # If data would overflow buffer, flush first
        if self.pos + data.len() > self.buffer.capacity():
            await self.flush()?

        # Copy to buffer
        self.buffer.copy_from(data, self.pos, data.len())
        self.pos = self.pos + data.len()
        return Ok(data.len()_bytes)

    # Write all data
    pub async fn write_all(self, data: &Bytes) -> Result[(), IoError]:
        let mut written: u64 = 0
        while written < data.len():
            let n = await self.write(&data.slice(written, data.len()))?
            written = written + (n as u64)
        return Ok(())

    # Write line (with newline)
    pub async fn write_line(self, text: &Text) -> Result[ByteCount, IoError]:
        let bytes = (text as str).to_bytes()
        let n1 = await self.write(&bytes)?
        let n2 = await self.write(&"\n".to_bytes())?
        return Ok(((n1 as u64) + (n2 as u64))_bytes)

    # Get underlying file
    async fn into_inner(self) -> Result[File, IoError]:
        await self.flush()?
        return Ok(self.inner)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_buffer_size() -> u64:
        """Get buffer capacity.

        Returns:
            Buffer size in bytes

        Example:
            writer.get_buffer_size()  # → 8192
        """
        return self.buffer.capacity()

    fn buffered() -> u64:
        """Get number of buffered bytes not yet flushed.

        Returns:
            Bytes in buffer

        Example:
            writer.buffered()  # → 512
        """
        return self.pos

    fn is_buffer_empty() -> bool:
        """Check if buffer is empty.

        Returns:
            true if no buffered data

        Example:
            writer.is_buffer_empty()  # → true
        """
        return self.pos == 0

    fn is_buffer_full() -> bool:
        """Check if buffer is full.

        Returns:
            true if buffer at capacity

        Example:
            writer.is_buffer_full()  # → false
        """
        return self.pos >= self.buffer.capacity()

    fn remaining_capacity() -> u64:
        """Get remaining buffer capacity.

        Returns:
            Bytes available in buffer

        Example:
            writer.remaining_capacity()  # → 7680
        """
        return self.buffer.capacity() - self.pos

    fn summary() -> String:
        """Get buffered writer summary.

        Returns:
            Human-readable summary

        Example:
            writer.summary()
            # → "BufWriter: buffer=8192 bytes, buffered=512 bytes"
        """
        let capacity = self.get_buffer_size()
        let buffered = self.buffered()
        return "BufWriter: buffer={capacity} bytes, buffered={buffered} bytes"

# Line writer - buffers until newline
struct LineWriter:
    inner: BufWriter

impl LineWriter:
    fn new(file: File) -> LineWriter:
        return LineWriter { inner: BufWriter::new(file) }

    pub async fn write(self, data: &Bytes) -> Result[ByteCount, IoError]:
        let n = await self.inner.write(data)?

        # Flush if we wrote a newline
        if data.contains_byte('\n' as u8):
            await self.inner.flush()?

        return Ok(n)

    pub async fn flush(self) -> Result[(), IoError]:
        return self.inner.flush()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_buffer_size() -> u64:
        """Get underlying buffer size.

        Returns:
            Buffer capacity in bytes

        Example:
            writer.get_buffer_size()  # → 8192
        """
        return self.inner.get_buffer_size()

    fn buffered() -> u64:
        """Get number of buffered bytes.

        Returns:
            Bytes in buffer

        Example:
            writer.buffered()  # → 256
        """
        return self.inner.buffered()

    fn is_empty() -> bool:
        """Check if buffer is empty.

        Returns:
            true if no buffered data

        Example:
            writer.is_empty()  # → false
        """
        return self.inner.is_buffer_empty()

    fn summary() -> String:
        """Get line writer summary.

        Returns:
            Human-readable summary

        Example:
            writer.summary()
            # → "LineWriter: buffer=8192 bytes, buffered=256 bytes"
        """
        let capacity = self.get_buffer_size()
        let buffered = self.buffered()
        return "LineWriter: buffer={capacity} bytes, buffered={buffered} bytes"
