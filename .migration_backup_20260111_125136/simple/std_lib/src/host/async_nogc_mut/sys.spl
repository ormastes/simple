# System module - Process control and standard streams
# Provides access to stdin, stdout, stderr, arguments, and process control

import host.io.term

# Extern declarations for FFI
extern fn rt_get_args() -> List[String]
extern fn rt_exit(code: Int) -> Void

# Standard output stream
pub class Stdout:
    term: term.Terminal

    pub fn new() -> Stdout:
        return Stdout { term: term.Terminal.default() }

    @io
    pub fn write(self, s: String) -> Result<Int, String>:
        match self.term.write(s):
            case Ok(count):
                return Ok(count.bytes as Int)
            case Err(e):
                return Err("Write error: {e}")

    @io
    pub fn flush(self) -> Result<(), String>:
        match self.term.flush():
            case Ok(_):
                return Ok(())
            case Err(e):
                return Err("Flush error: {e}")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn writeln(self, s: String) -> Result<Int, String>:
        """Write string with newline to stdout.

        Args:
            s: String to write

        Returns:
            Number of bytes written on success, error message on failure

        Example:
            stdout.writeln("Hello")
        """
        return self.write(s + "\n")

    pub fn print(self, s: String) -> Result<(), String>:
        """Print string to stdout and flush.

        Args:
            s: String to print

        Returns:
            Ok on success, error message on failure

        Example:
            stdout.print("Hello")
        """
        match self.write(s):
            case Ok(_):
                return self.flush()
            case Err(e):
                return Err(e)

    pub fn println(self, s: String) -> Result<(), String>:
        """Print string with newline to stdout and flush.

        Args:
            s: String to print

        Returns:
            Ok on success, error message on failure

        Example:
            stdout.println("Hello")
        """
        match self.writeln(s):
            case Ok(_):
                return self.flush()
            case Err(e):
                return Err(e)

# Standard error stream
pub class Stderr:
    term: term.Terminal

    pub fn new() -> Stderr:
        return Stderr { term: term.Terminal.default() }

    @io
    pub fn write(self, s: String) -> Result<Int, String>:
        match self.term.write_err(s):
            case Ok(count):
                return Ok(count.bytes as Int)
            case Err(e):
                return Err("Write error: {e}")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn writeln(self, s: String) -> Result<Int, String>:
        """Write string with newline to stderr.

        Args:
            s: String to write

        Returns:
            Number of bytes written on success, error message on failure

        Example:
            stderr.writeln("Error message")
        """
        return self.write(s + "\n")

    pub fn print_error(self, s: String) -> Result<Int, String>:
        """Print error message to stderr (alias for writeln).

        Args:
            s: Error message to print

        Returns:
            Number of bytes written on success, error message on failure

        Example:
            stderr.print_error("Fatal error")
        """
        return self.writeln(s)

# Command line arguments
pub class Args:
    @pure
    pub fn get_args() -> List<String>:
        return rt_get_args()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    @pure
    pub fn count() -> Int:
        """Get number of command line arguments.

        Returns:
            Argument count (including program name)

        Example:
            Args.count()  # → 3
        """
        return rt_get_args().len()

    @pure
    pub fn get(index: Int) -> Option[String]:
        """Get argument at index.

        Args:
            index: Argument index (0 = program name)

        Returns:
            Some(arg) if index is valid, None otherwise

        Example:
            Args.get(1)  # → Some("arg1")
        """
        let args = rt_get_args()
        if index >= 0 and index < args.len():
            return Some(args[index])
        return None

    @pure
    pub fn program_name() -> String:
        """Get program name (first argument).

        Returns:
            Program name

        Example:
            Args.program_name()  # → "myapp"
        """
        let args = rt_get_args()
        if args.len() > 0:
            return args[0]
        return ""

    @pure
    pub fn has_args() -> Bool:
        """Check if program has command line arguments (beyond program name).

        Returns:
            true if arguments exist

        Example:
            Args.has_args()  # → true
        """
        return rt_get_args().len() > 1

# Global stdout instance
pub let stdout: Stdout = Stdout.new()

# Global stderr instance
pub let stderr: Stderr = Stderr.new()

# Global args instance
pub let args: Args = Args.new()

# Exit the process with the given code
@io
pub fn exit(code: Int) -> Never:
    rt_exit(code)
    # Unreachable, but needed for type system
    loop:
        pass
