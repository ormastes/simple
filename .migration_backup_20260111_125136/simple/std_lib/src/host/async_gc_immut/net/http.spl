# HTTP Client - Immutable Variant
# Functional style HTTP with immutable request/response builders

use units.net.*
use units.url.*
use units.size.*
use host.common.io.error.IoError
use host.common.net.types.HttpMethod

# HTTP Header (immutable)
struct Header:
    name: str
    value: str

impl Header:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_name() -> str:
        """Get header name.

        Returns:
            Header name

        Example:
            header.get_name()  # → "Content-Type"
        """
        return self.name

    fn get_value() -> str:
        """Get header value.

        Returns:
            Header value

        Example:
            header.get_value()  # → "application/json"
        """
        return self.value

    fn summary() -> String:
        """Get header summary.

        Returns:
            Human-readable summary

        Example:
            header.summary()
            # → "Header: Content-Type: application/json"
        """
        return "Header: {self.name}: {self.value}"

# HTTP Headers collection (immutable, uses persistent list)
struct Headers:
    items: List[Header]

impl Headers:
    fn empty() -> Headers:
        Headers { items: List.empty() }

    # Add header, return new Headers
    fn with(name: str, value: str) -> Headers:
        Headers { items: self.items.prepend(Header { name: name, value: value }) }

    # Get header value
    fn get(name: str) -> Option[str]:
        match self.items.find(|h| h.name.eq_ignore_case(name)):
            case Some(h): Some(h.value)
            case None: None

    # Get all values for header
    fn get_all(name: str) -> List[str]:
        self.items
            .filter(|h| h.name.eq_ignore_case(name))
            .map(|h| h.value)

    fn len() -> u64:
        self.items.len()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> bool:
        """Check if headers collection is empty.

        Returns:
            true if empty

        Example:
            headers.is_empty()  # → false
        """
        return self.items.len() == 0

    fn has(name: str) -> bool:
        """Check if header exists.

        Args:
            name: Header name

        Returns:
            true if header exists

        Example:
            headers.has("Content-Type")  # → true
        """
        return self.get(name).is_some()

    fn count() -> u64:
        """Get number of headers (alias for len).

        Returns:
            Header count

        Example:
            headers.count()  # → 5
        """
        return self.len()

    fn summary() -> String:
        """Get headers summary.

        Returns:
            Human-readable summary

        Example:
            headers.summary()
            # → "Headers: 5 items"
        """
        let count = self.count()
        return "Headers: {count} items"

# HTTP Request (immutable builder)
struct Request:
    method: HttpMethod
    url: Url
    headers: Headers
    body: Option[Bytes]

impl Request:
    # Create GET request
    fn get(url: Url) -> Request:
        Request {
            method: HttpMethod::GET,
            url: url,
            headers: Headers::empty(),
            body: None
        }

    # Create POST request
    fn post(url: Url) -> Request:
        Request {
            method: HttpMethod::POST,
            url: url,
            headers: Headers::empty(),
            body: None
        }

    # Create request with method
    fn new(method: HttpMethod, url: Url) -> Request:
        Request {
            method: method,
            url: url,
            headers: Headers::empty(),
            body: None
        }

    # Add header, return new request
    fn with_header(name: str, value: str) -> Request:
        Request {
            method: self.method,
            url: self.url,
            headers: self.headers.with(name, value),
            body: self.body
        }

    # Set body, return new request
    fn with_body(body: Bytes) -> Request:
        Request {
            method: self.method,
            url: self.url,
            headers: self.headers,
            body: Some(body)
        }

    # Set JSON body, return new request
    fn with_json(json: str) -> Request:
        self.with_header("Content-Type", "application/json")
            .with_body(json.to_bytes())

    # Set form body, return new request
    fn with_form(form: str) -> Request:
        self.with_header("Content-Type", "application/x-www-form-urlencoded")
            .with_body(form.to_bytes())

    # Execute request
    pub async fn send(self) -> Result[Response, IoError]:
        return native_http_request(self)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_method() -> HttpMethod:
        """Get HTTP method.

        Returns:
            HTTP method

        Example:
            request.get_method()  # → HttpMethod::GET
        """
        return self.method

    fn get_url() -> Url:
        """Get request URL.

        Returns:
            URL

        Example:
            request.get_url()
        """
        return self.url

    fn get_headers() -> Headers:
        """Get request headers.

        Returns:
            Headers collection

        Example:
            request.get_headers()
        """
        return self.headers

    fn get_body() -> Option[Bytes]:
        """Get request body.

        Returns:
            Body bytes if present

        Example:
            request.get_body()  # → Some(bytes)
        """
        return self.body

    fn has_body() -> bool:
        """Check if request has body.

        Returns:
            true if body present

        Example:
            request.has_body()  # → true
        """
        return self.body.is_some()

    fn has_header(name: str) -> bool:
        """Check if request has header.

        Args:
            name: Header name

        Returns:
            true if header exists

        Example:
            request.has_header("Content-Type")  # → true
        """
        return self.headers.has(name)

    fn is_get() -> bool:
        """Check if request method is GET.

        Returns:
            true if GET

        Example:
            request.is_get()  # → true
        """
        return self.method == HttpMethod::GET

    fn is_post() -> bool:
        """Check if request method is POST.

        Returns:
            true if POST

        Example:
            request.is_post()  # → false
        """
        return self.method == HttpMethod::POST

    fn summary() -> String:
        """Get request summary.

        Returns:
            Human-readable summary

        Example:
            request.summary()
            # → "Request: GET https://api.example.com, 3 headers"
        """
        let method_str = self.method.to_string()
        let url_str = self.url.to_string()
        let header_count = self.headers.count()
        return "Request: {method_str} {url_str}, {header_count} headers"

# HTTP Response (immutable)
struct Response:
    status: u16
    headers: Headers
    body: Bytes

impl Response:
    fn status() -> u16:
        self.status

    fn is_success() -> bool:
        self.status >= 200 and self.status < 300

    fn is_redirect() -> bool:
        self.status >= 300 and self.status < 400

    fn is_client_error() -> bool:
        self.status >= 400 and self.status < 500

    fn is_server_error() -> bool:
        self.status >= 500

    fn headers() -> Headers:
        self.headers

    fn body() -> Bytes:
        self.body

    fn text() -> Result[str, IoError]:
        match self.body.to_utf8():
            case Ok(s): Ok(s)
            case Err(_): Err(IoError::InvalidData)

    fn content_length() -> Option[ByteCount]:
        match self.headers.get("Content-Length"):
            case Some(s):
                match s.parse_u64():
                    case Ok(n): Some(n_bytes)
                    case Err(_): None
            case None: None

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_status() -> u16:
        """Get status code (alias for status).

        Returns:
            HTTP status code

        Example:
            response.get_status()  # → 200
        """
        return self.status()

    fn get_headers() -> Headers:
        """Get response headers (alias for headers).

        Returns:
            Headers collection

        Example:
            response.get_headers()
        """
        return self.headers()

    fn get_body() -> Bytes:
        """Get response body (alias for body).

        Returns:
            Body bytes

        Example:
            response.get_body()
        """
        return self.body()

    fn is_ok() -> bool:
        """Check if status is 200 OK.

        Returns:
            true if 200

        Example:
            response.is_ok()  # → true
        """
        return self.status == 200

    fn is_error() -> bool:
        """Check if status is error (4xx or 5xx).

        Returns:
            true if error

        Example:
            response.is_error()  # → false
        """
        return self.is_client_error() or self.is_server_error()

    fn has_body() -> bool:
        """Check if response has body.

        Returns:
            true if body not empty

        Example:
            response.has_body()  # → true
        """
        return self.body.len() > 0

    fn body_length() -> usize:
        """Get body length in bytes.

        Returns:
            Body size

        Example:
            response.body_length()  # → 1024
        """
        return self.body.len()

    fn has_header(name: str) -> bool:
        """Check if response has header.

        Args:
            name: Header name

        Returns:
            true if header exists

        Example:
            response.has_header("Content-Type")  # → true
        """
        return self.headers.has(name)

    fn summary() -> String:
        """Get response summary.

        Returns:
            Human-readable summary

        Example:
            response.summary()
            # → "Response: 200 OK, 1024 bytes"
        """
        let status = self.status
        let size = self.body_length()
        let status_text = if self.is_success():
            "OK"
        elif self.is_redirect():
            "Redirect"
        elif self.is_client_error():
            "Client Error"
        elif self.is_server_error():
            "Server Error"
        else:
            "Unknown"
        return "Response: {status} {status_text}, {size} bytes"

# ===============================
# Convenience Functions
# ===============================

# Simple GET request
pub async fn get(url: Url) -> Result[Response, IoError]:
    Request::get(url).send()

# Simple POST with body
pub async fn post(url: Url, body: Bytes) -> Result[Response, IoError]:
    Request::post(url).with_body(body).send()

# POST JSON
pub async fn post_json(url: Url, json: str) -> Result[Response, IoError]:
    Request::post(url).with_json(json).send()

# ===============================
# Native function declarations
# ===============================

extern fn native_http_request(req: Request) -> Result[Response, IoError]
