# File Handle Operations (GC Mutable Variant)
#
# Streaming file operations with staging support.

use units.file.*
use units.size.*
use host.common.io.*

export File

# File handle for streaming operations with staging support
pub struct File:
    handle: i64
    path: FilePath
    mode: OpenMode
    stage_state: Option<StageState>  # Staging state

impl File:
    # Open file with mode (auto-staging enabled by default)
    pub async fn open(path: FilePath, mode: OpenMode) -> Result<File, IoError>:
        # Resolve relative paths to absolute paths
        let resolved_path = native_path_resolve(path)?

        # Check file existence for read/write modes
        if mode == OpenMode::Read or mode == OpenMode::Write:
            let file_exists = await exists(resolved_path)
            if not file_exists and mode == OpenMode::Read:
                return Err(IoError::NotFound)

        # Open file handle
        let handle = native_fs_open(resolved_path, mode)?
        let mut file = File {
            handle: handle,
            path: resolved_path,
            mode: mode,
            stage_state: None
        }

        # Auto-stage on read mode for performance
        if mode == OpenMode::Read:
            await file.stage_auto()?

        return Ok(file)

    # Read convenience methods
    pub async fn open_read(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Read)

    pub async fn open_write(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Write)

    pub async fn create(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Create)

    # Wait for staging to complete if in progress
    async fn wait_for_staging(self):
        if let Some(state) = self.stage_state:
            while state.status == StagingStatus::Staging:
                await async_yield()

    # Read up to `buf.len()` bytes (optimized with staging)
    pub async fn read(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        await self.wait_for_staging()

        if let Some(state) = self.stage_state:
            match state.mode:
                case StageMode::Mmap | StageMode::MmapShared:
                    let pos_result = await self.position()?
                    let pos = pos_result as u64
                    let to_read = buf.len().min(state.mmap_size - pos)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, pos, buf, to_read)
                        await self.seek(SeekFrom::Current(to_read as i64))?
                    return Ok(to_read_bytes)

                case StageMode::Prefetch:
                    if let Some(prefetch) = state.prefetch_buf:
                        let pos_result = await self.position()?
                        let pos = pos_result as u64
                        let to_read = buf.len().min(prefetch.len() - pos)
                        if to_read > 0:
                            buf.copy_from(&prefetch.slice(pos, pos + to_read), 0, to_read)
                            await self.seek(SeekFrom::Current(to_read as i64))?
                        return Ok(to_read_bytes)

                case _:
                    pass

        return native_file_read(self.handle, buf)

    # Read exact number of bytes
    pub async fn read_exact(self, buf: &mut Bytes) -> Result<(), IoError>:
        let mut read_total: u64 = 0
        let target = buf.len()
        while read_total < target:
            let remaining = target - read_total
            let slice = buf.slice_mut(read_total, target)
            let n = await self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write bytes
    pub async fn write(self, data: &Bytes) -> Result<ByteCount, IoError>:
        await self.wait_for_staging()
        return native_file_write(self.handle, data)

    # Write all bytes
    pub async fn write_all(self, data: &Bytes) -> Result<(), IoError>:
        let mut written: u64 = 0
        let total = data.len()
        while written < total:
            let slice = data.slice(written, total)
            let n = await self.write(&slice)?
            written = written + (n as u64)
        return Ok(())

    # Flush buffers
    pub async fn flush(self) -> Result<(), IoError>:
        return native_file_flush(self.handle)

    # Seek position
    pub async fn seek(self, pos: SeekFrom) -> Result<ByteCount, IoError>:
        await self.wait_for_staging()
        return native_file_seek(self.handle, pos)

    # Get current position
    pub async fn position(self) -> Result<ByteCount, IoError>:
        return self.seek(SeekFrom::Current(0))

    # Get file size
    pub async fn size(self) -> Result<ByteCount, IoError>:
        let current = await self.position()?
        let end = await self.seek(SeekFrom::End(0))?
        await self.seek(SeekFrom::Start(current as u64))?
        return Ok(end)

    # Sync to disk
    pub async fn sync_all(self) -> Result<(), IoError>:
        return native_file_sync(self.handle)

    # Close file
    pub async fn close(self) -> Result<(), IoError>:
        if let Some(state) = self.stage_state:
            if state.mode == StageMode::Mmap and state.mmap_ptr != 0:
                native_mmap_unmap(state.mmap_ptr, state.mmap_size)
        return native_file_close(self.handle)

    # ===============================
    # Staging API
    # ===============================

    # Auto-stage file based on size
    pub async fn stage_auto(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::Adaptive,
            status: StagingStatus::Staging,
            mmap_ptr: 0, mmap_size: 0,
            is_shared: false, prefetch_buf: None,
            staged_files: Array<FilePath>::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 > 1_048_576:  # 1MB threshold
            return self.stage_mmap()
        elif size_u64 > 0:
            return self.stage_prefetch()
        else:
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

    # Memory-map the file (private)
    pub async fn stage_mmap(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staging,
            mmap_ptr: 0, mmap_size: 0,
            is_shared: false, prefetch_buf: None,
            staged_files: Array<FilePath>::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        let mmap_ptr = native_mmap_create(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staged,
            mmap_ptr: mmap_ptr, mmap_size: size_u64,
            is_shared: false, prefetch_buf: None,
            staged_files: Array<FilePath>::new()
        })
        return Ok(())

    # Memory-map the file (shared)
    pub async fn stage_mmap_shared(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staging,
            mmap_ptr: 0, mmap_size: 0,
            is_shared: true, prefetch_buf: None,
            staged_files: Array<FilePath>::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        let mmap_ptr = native_mmap_create_shared(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staged,
            mmap_ptr: mmap_ptr, mmap_size: size_u64,
            is_shared: true, prefetch_buf: None,
            staged_files: Array<FilePath>::new()
        })
        return Ok(())

    # Prefetch entire file into memory
    pub async fn stage_prefetch(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staging,
            mmap_ptr: 0, mmap_size: 0,
            is_shared: false, prefetch_buf: None,
            staged_files: Array<FilePath>::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        await self.seek(SeekFrom::Start(0))?
        let mut buffer = Bytes::with_capacity(size_u64)
        await self.read_exact(&mut buffer)?
        await self.seek(SeekFrom::Start(0))?

        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staged,
            mmap_ptr: 0, mmap_size: 0,
            is_shared: false, prefetch_buf: Some(buffer),
            staged_files: Array<FilePath>::new()
        })

        native_fadvise_sequential(self.handle)
        return Ok(())

    # Remove staging
    pub fn unstage(self):
        unstage_cleanup(self.stage_state)
        self.stage_state = None

    # Check if file is staged
    pub fn is_staged(self) -> bool:
        return is_staged(self.stage_state)

    # Get staging mode
    pub fn get_stage_mode(self) -> StageMode:
        return get_stage_mode(self.stage_state)

    # ===============================
    # Synchronous Operations
    # ===============================

    # Open file (sync, blocking)
    pub fn open_sync(path: FilePath, mode: OpenMode) -> Result<File, IoError>:
        # Resolve relative paths to absolute paths
        let resolved_path = native_path_resolve(path)?

        # Check file existence for read mode
        if mode == OpenMode::Read:
            if not native_file_exists_sync(resolved_path):
                return Err(IoError::NotFound)

        # Open file handle
        let handle = native_fs_open(resolved_path, mode)?
        let file = File {
            handle: handle,
            path: resolved_path,
            mode: mode,
            stage_state: None
        }

        return Ok(file)

    # Read convenience methods (sync)
    pub fn open_read_sync(path: FilePath) -> Result<File, IoError>:
        return File::open_sync(path, OpenMode::Read)

    pub fn open_write_sync(path: FilePath) -> Result<File, IoError>:
        return File::open_sync(path, OpenMode::Write)

    pub fn create_sync(path: FilePath) -> Result<File, IoError>:
        return File::open_sync(path, OpenMode::Create)

    # Read bytes (sync)
    pub fn read_sync(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return read_sync_with_staging(self.handle, buf, self.stage_state)

    # Read exact bytes (sync)
    pub fn read_exact_sync(self, buf: &mut Bytes) -> Result<(), IoError>:
        let mut read_total: u64 = 0
        let target = buf.len()
        while read_total < target:
            let slice = buf.slice_mut(read_total, target)
            let n = self.read_sync(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write bytes (sync)
    pub fn write_sync(self, data: &Bytes) -> Result<ByteCount, IoError>:
        return native_file_write_sync(self.handle, data)

    # Write all bytes (sync)
    pub fn write_all_sync(self, data: &Bytes) -> Result<(), IoError>:
        return write_all_sync_impl(self.handle, data)

    # Flush buffers (sync)
    pub fn flush_sync(self) -> Result<(), IoError>:
        return native_file_flush_sync(self.handle)

    # Seek position (sync)
    pub fn seek_sync(self, pos: SeekFrom) -> Result<ByteCount, IoError>:
        return native_file_seek_sync(self.handle, pos)

    # Get current position (sync)
    pub fn position_sync(self) -> Result<ByteCount, IoError>:
        return self.seek_sync(SeekFrom::Current(0))

    # Get file size (sync)
    pub fn size_sync(self) -> Result<ByteCount, IoError>:
        let current = self.position_sync()?
        let end = self.seek_sync(SeekFrom::End(0))?
        self.seek_sync(SeekFrom::Start(current as u64))?
        return Ok(end)

    # Sync to disk (sync)
    pub fn sync_all_sync(self) -> Result<(), IoError>:
        return native_file_sync_sync(self.handle)

    # Close file (sync)
    pub fn close_sync(self) -> Result<(), IoError>:
        return close_sync_with_staging(self.handle, self.stage_state)

    # ===============================
    # Positioned I/O (pread/pwrite)
    # ===============================

    # Read at offset without changing file position (thread-safe)
    pub fn pread(self, buf: &mut Bytes, offset: u64) -> Result<ByteCount, IoError>:
        return pread_with_staging(self.handle, buf, offset, self.stage_state)

    # Write at offset without changing file position (thread-safe)
    pub fn pwrite(self, data: &Bytes, offset: u64) -> Result<ByteCount, IoError>:
        return pwrite_impl(self.handle, data, offset)

    # ===============================
    # Sync Staging with Preload
    # ===============================

    # Stage file with mmap preload (sync, for use before parallel processing)
    pub fn stage_mmap_sync(self) -> Result<(), IoError>:
        let size = self.size_sync()?
        self.stage_state = Some(stage_mmap_sync_impl(self.handle, size as u64)?)
        return Ok(())

    # Stage file with shared mmap (sync, for multi-process access)
    pub fn stage_mmap_shared_sync(self) -> Result<(), IoError>:
        let size = self.size_sync()?
        self.stage_state = Some(stage_mmap_shared_sync_impl(self.handle, size as u64)?)
        return Ok(())

    # Stage file by prefetching entire content (sync)
    pub fn stage_prefetch_sync(self) -> Result<(), IoError>:
        let size = self.size_sync()?
        let size_u64 = size as u64

        if size_u64 == 0:
            self.stage_state = Some(create_empty_staged_state(StageMode::Prefetch, false))
            return Ok(())

        self.seek_sync(SeekFrom::Start(0))?
        let mut buffer = Bytes::with_capacity(size_u64)
        self.read_exact_sync(&mut buffer)?
        self.seek_sync(SeekFrom::Start(0))?

        self.stage_state = Some(create_staged_prefetch_state(buffer))
        native_fadvise_sequential(self.handle)
        return Ok(())

# Helper to check existence
async fn exists(path: FilePath) -> bool:
    match native_fs_metadata(path):
        case Ok(_): return true
        case Err(_): return false
