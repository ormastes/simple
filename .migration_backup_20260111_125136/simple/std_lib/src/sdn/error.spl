///
Module: sdn.error

SDN error types with span information for diagnostics.

Provides:
- Span: Source location tracking (line, column, start, end)
- SdnError: Error variants for parsing and document operations
- Helper functions for creating errors
///

# Public exports
export Span, SdnError
export syntax_error, syntax_error_with_span, unexpected_token

/// Source location in SDN document
struct Span:
    start: Int
    end: Int
    line: Int
    column: Int

    fn new(start: Int, end: Int, line: Int, column: Int) -> Span:
        return Span(
            start: start,
            end: end,
            line: line,
            column: column
        )

    fn merge(other: Span) -> Span:
        """Merge two spans into one covering both"""
        let min_start = if self.start < other.start:
            self.start
        else:
            other.start

        let max_end = if self.end > other.end:
            self.end
        else:
            other.end

        return Span(
            start: min_start,
            end: max_end,
            line: self.line,
            column: self.column
        )

    fn default() -> Span:
        """Default span at line 1, column 1"""
        return Span.new(0, 0, 1, 1)

    fn to_string() -> String:
        return "${self.line}:${self.column}"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> bool:
        """Check if span is empty (start equals end)."""
        return self.start == self.end

    fn len() -> Int:
        """Get length of span."""
        return self.end - self.start

    fn is_single_line() -> bool:
        """Check if span is on a single line."""
        return true  # Spans don't track end line, assumed single

    fn is_at_start() -> bool:
        """Check if span is at document start (line 1, column 1)."""
        return self.line == 1 and self.column == 1

    fn contains(pos: Int) -> bool:
        """Check if position is within this span."""
        return pos >= self.start and pos < self.end

    fn overlaps(other: Span) -> bool:
        """Check if this span overlaps with another."""
        return self.start < other.end and other.start < self.end

    fn summary() -> String:
        """Get summary of span."""
        let len = self.len()
        return "Span: ${self.line}:${self.column} [${self.start}..${self.end}] ({len} chars)"

/// SDN parse and document errors
enum SdnError:
    SyntaxError:
        message: String
        line: Int
        column: Int
        span: Option[Span]

    UnexpectedToken:
        expected: String
        found: String
        span: Span

    UnexpectedEof:
        span: Option[Span]

    InvalidNumber:
        literal: String

    UnclosedString:
        span: Option[Span]

    InvalidIndentation:
        line: Int

    InvalidEscape:
        sequence: String

    PathNotFound:
        path: String

    TypeMismatch:
        expected: String
        found: String

    InvalidTableRow:
        expected: Int
        found: Int

    IoError:
        message: String

impl SdnError:
    fn to_string() -> String:
        """Format error as human-readable message"""
        match self:
            case SyntaxError(msg, line, col, _):
                return "Syntax error at ${line}:${col}: ${msg}"

            case UnexpectedToken(exp, found, span):
                return "Unexpected token at ${span.to_string()}: expected ${exp}, found ${found}"

            case UnexpectedEof(_):
                return "Unexpected end of file"

            case InvalidNumber(lit):
                return "Invalid number literal: ${lit}"

            case UnclosedString(_):
                return "Unclosed string literal"

            case InvalidIndentation(line):
                return "Invalid indentation at line ${line}"

            case InvalidEscape(seq):
                return "Invalid escape sequence: ${seq}"

            case PathNotFound(path):
                return "Path not found: ${path}"

            case TypeMismatch(exp, found):
                return "Type mismatch: expected ${exp}, found ${found}"

            case InvalidTableRow(exp, found):
                return "Invalid table row: expected ${exp} columns, found ${found}"

            case IoError(msg):
                return "I/O error: ${msg}"

    fn span() -> Option[Span]:
        """Get the span associated with this error, if any"""
        match self:
            case SyntaxError(_, _, _, span):
                return span

            case UnexpectedToken(_, _, span):
                return Some(span)

            case UnclosedString(span):
                return span

            case UnexpectedEof(span):
                return span

            case _:
                return None

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_syntax_error() -> bool:
        """Check if this is SyntaxError."""
        match self:
            case SyntaxError(_, _, _, _): true
            case _: false

    fn is_unexpected_token() -> bool:
        """Check if this is UnexpectedToken."""
        match self:
            case UnexpectedToken(_, _, _): true
            case _: false

    fn is_unexpected_eof() -> bool:
        """Check if this is UnexpectedEof."""
        match self:
            case UnexpectedEof(_): true
            case _: false

    fn is_invalid_number() -> bool:
        """Check if this is InvalidNumber."""
        match self:
            case InvalidNumber(_): true
            case _: false

    fn is_unclosed_string() -> bool:
        """Check if this is UnclosedString."""
        match self:
            case UnclosedString(_): true
            case _: false

    fn is_invalid_indentation() -> bool:
        """Check if this is InvalidIndentation."""
        match self:
            case InvalidIndentation(_): true
            case _: false

    fn is_invalid_escape() -> bool:
        """Check if this is InvalidEscape."""
        match self:
            case InvalidEscape(_): true
            case _: false

    fn is_path_not_found() -> bool:
        """Check if this is PathNotFound."""
        match self:
            case PathNotFound(_): true
            case _: false

    fn is_type_mismatch() -> bool:
        """Check if this is TypeMismatch."""
        match self:
            case TypeMismatch(_, _): true
            case _: false

    fn is_invalid_table_row() -> bool:
        """Check if this is InvalidTableRow."""
        match self:
            case InvalidTableRow(_, _): true
            case _: false

    fn is_io_error() -> bool:
        """Check if this is IoError."""
        match self:
            case IoError(_): true
            case _: false

    fn is_parse_error() -> bool:
        """Check if this is a parsing error (syntax, token, eof, string)."""
        match self:
            case SyntaxError(_, _, _, _): true
            case UnexpectedToken(_, _, _): true
            case UnexpectedEof(_): true
            case UnclosedString(_): true
            case _: false

    fn is_document_error() -> bool:
        """Check if this is a document error (path, type, table row)."""
        match self:
            case PathNotFound(_): true
            case TypeMismatch(_, _): true
            case InvalidTableRow(_, _): true
            case _: false

    fn has_span() -> bool:
        """Check if error has associated span."""
        return self.span().is_some()

    fn description() -> String:
        """Get detailed error description."""
        return self.to_string()

    fn name() -> String:
        """Get error variant name.

        Returns:
            Short error name

        Example:
            SdnError::UnexpectedEof(...).name()  # → "unexpected_eof"
        """
        match self:
            case SyntaxError(_, _, _, _): return "syntax_error"
            case UnexpectedToken(_, _, _): return "unexpected_token"
            case UnexpectedEof(_): return "unexpected_eof"
            case InvalidNumber(_): return "invalid_number"
            case UnclosedString(_): return "unclosed_string"
            case InvalidIndentation(_): return "invalid_indentation"
            case InvalidEscape(_): return "invalid_escape"
            case PathNotFound(_): return "path_not_found"
            case TypeMismatch(_, _): return "type_mismatch"
            case InvalidTableRow(_, _): return "invalid_table_row"
            case IoError(_): return "io_error"

    fn is_recoverable() -> bool:
        """Check if error might be recoverable.

        Returns:
            true for document errors that might be fixed
            false for parse errors (need to fix source)

        Example:
            SdnError::PathNotFound("x").is_recoverable()  # → true
            SdnError::SyntaxError(...).is_recoverable()  # → false
        """
        match self:
            case PathNotFound(_): true
            case TypeMismatch(_, _): true
            case _: false

    fn severity() -> String:
        """Get error severity level.

        Returns:
            "fatal" for parse errors, "error" for document errors, "warning" for IO

        Example:
            SdnError::SyntaxError(...).severity()  # → "fatal"
            SdnError::PathNotFound(...).severity()  # → "error"
        """
        match self:
            case SyntaxError(_, _, _, _): return "fatal"
            case UnexpectedToken(_, _, _): return "fatal"
            case UnexpectedEof(_): return "fatal"
            case UnclosedString(_): return "fatal"
            case InvalidIndentation(_): return "fatal"
            case InvalidEscape(_): return "fatal"
            case InvalidNumber(_): return "fatal"
            case IoError(_): return "warning"
            case _: return "error"

    fn category() -> String:
        """Get error category.

        Returns:
            "parse", "document", or "io"

        Example:
            SdnError::SyntaxError(...).category()  # → "parse"
            SdnError::PathNotFound(...).category()  # → "document"
        """
        if self.is_parse_error():
            return "parse"
        else if self.is_document_error():
            return "document"
        else if self.is_io_error():
            return "io"
        else:
            return "unknown"

    fn summary() -> String:
        """Get comprehensive error summary.

        Returns:
            Human-readable summary with category and severity

        Example:
            SdnError::SyntaxError("bad", 1, 1, None).summary()
            # → "SdnError: syntax_error [parse] (fatal)"
        """
        let name = self.name()
        let cat = self.category()
        let sev = self.severity()
        return "SdnError: {name} [{cat}] ({sev})"

/// Create a syntax error with line and column
fn syntax_error(message: String, line: Int, column: Int) -> SdnError:
    return SdnError.SyntaxError(
        message: message,
        line: line,
        column: column,
        span: None
    )

/// Create a syntax error with a span
fn syntax_error_with_span(message: String, span: Span) -> SdnError:
    return SdnError.SyntaxError(
        message: message,
        line: span.line,
        column: span.column,
        span: Some(span)
    )

/// Create an unexpected token error
fn unexpected_token(expected: String, found: String, span: Span) -> SdnError:
    return SdnError.UnexpectedToken(
        expected: expected,
        found: found,
        span: span
    )
