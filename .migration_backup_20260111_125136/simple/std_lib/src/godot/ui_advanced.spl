# Godot Advanced UI Widgets
#
# Type-safe wrappers for complex UI components
#
# Features:
# - Tree (hierarchical list)
# - ItemList (selectable grid/list)
# - TabContainer (tabbed interface)
# - OptionButton (dropdown menu)
# - ScrollContainer (scrollable content)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_tree.html

import godot.ffi
import godot.variant
import godot.ui

mod ui_advanced

# Tree Widget
# Hierarchical tree view with columns
pub struct Tree extends godot.ui.Control:

impl Tree:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Tree:
        return Tree(base: godot.ui.Control::from_ptr(ptr))

    # Create root item
    pub fn create_item(mut self, parent: Option[TreeItem] = None) -> TreeItem:
        let obj = self.base.base.as_object()

        if parent.is_none():
            let result = obj.call0("create_item")
            return TreeItem::from_ptr(result.as_object().ptr())
        else:
            let parent_item = parent.unwrap()
            let parent_var = variant.Variant::from_object(variant.Object::from_ptr(parent_item.ptr))
            let result = obj.call1("create_item", parent_var)
            return TreeItem::from_ptr(result.as_object().ptr())

    # Get root item
    pub fn get_root(self) -> Option[TreeItem]:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_root")

        if result.is_null():
            return None
        else:
            return Some(TreeItem::from_ptr(result.as_object().ptr()))

    # Clear tree
    pub fn clear(mut self):
        let obj = self.base.base.as_object()
        obj.call0("clear")

    # Get selected item
    pub fn get_selected(self) -> Option[TreeItem]:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_selected")

        if result.is_null():
            return None
        else:
            return Some(TreeItem::from_ptr(result.as_object().ptr()))

    # Set columns
    pub fn set_columns(mut self, amount: i32):
        let obj = self.base.base.as_object()
        let amount_var = variant.Variant::from_int(amount as i64)
        obj.call1("set_columns", amount_var)

    # Set column title
    pub fn set_column_title(mut self, column: i32, title: String):
        let obj = self.base.base.as_object()
        let col_var = variant.Variant::from_int(column as i64)
        let title_var = variant.Variant::from_string(title)
        obj.call2("set_column_title", col_var, title_var)

    # Set hide root
    pub fn set_hide_root(mut self, enable: bool):
        let obj = self.base.base.as_object()
        let hide_var = variant.Variant::from_bool(enable)
        obj.call1("set_hide_root", hide_var)


# Tree Item
# Single item in tree
pub struct TreeItem:
    ptr: ffi.GDExtensionObjectPtr

impl TreeItem:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> TreeItem:
        return TreeItem(ptr: ptr)

    # Set text
    pub fn set_text(mut self, column: i32, text: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let col_var = variant.Variant::from_int(column as i64)
        let text_var = variant.Variant::from_string(text)
        obj.call2("set_text", col_var, text_var)

    # Get text
    pub fn get_text(self, column: i32) -> String:
        let obj = variant.Object::from_ptr(self.ptr)
        let col_var = variant.Variant::from_int(column as i64)
        let result = obj.call1("get_text", col_var)
        return result.as_string()

    # Set icon
    pub fn set_icon(mut self, column: i32, texture: godot.resource.Resource):
        let obj = variant.Object::from_ptr(self.ptr)
        let col_var = variant.Variant::from_int(column as i64)
        let tex_var = variant.Variant::from_object(texture.as_object())
        obj.call2("set_icon", col_var, tex_var)

    # Set selectable
    pub fn set_selectable(mut self, column: i32, selectable: bool):
        let obj = variant.Object::from_ptr(self.ptr)
        let col_var = variant.Variant::from_int(column as i64)
        let sel_var = variant.Variant::from_bool(selectable)
        obj.call2("set_selectable", col_var, sel_var)

    # Set editable
    pub fn set_editable(mut self, column: i32, enabled: bool):
        let obj = variant.Object::from_ptr(self.ptr)
        let col_var = variant.Variant::from_int(column as i64)
        let edit_var = variant.Variant::from_bool(enabled)
        obj.call2("set_editable", col_var, edit_var)

    # Set collapsed
    pub fn set_collapsed(mut self, enable: bool):
        let obj = variant.Object::from_ptr(self.ptr)
        let col_var = variant.Variant::from_bool(enable)
        obj.call1("set_collapsed", col_var)

    # Get parent
    pub fn get_parent(self) -> Option[TreeItem]:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_parent")

        if result.is_null():
            return None
        else:
            return Some(TreeItem::from_ptr(result.as_object().ptr()))

    # Get children
    pub fn get_child_count(self) -> i32:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_child_count")
        return result.as_int() as i32


# ItemList Widget
# Selectable list/grid of items
pub struct ItemList extends godot.ui.Control:

impl ItemList:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> ItemList:
        return ItemList(base: godot.ui.Control::from_ptr(ptr))

    # Add item
    pub fn add_item(mut self, text: String, icon: Option[godot.resource.Resource] = None) -> i32:
        let obj = self.base.base.as_object()
        let text_var = variant.Variant::from_string(text)

        if icon.is_none():
            let result = obj.call1("add_item", text_var)
            return result.as_int() as i32
        else:
            let icon_res = icon.unwrap()
            let icon_var = variant.Variant::from_object(icon_res.as_object())
            let result = obj.call2("add_item", text_var, icon_var)
            return result.as_int() as i32

    # Add icon item
    pub fn add_icon_item(mut self, icon: godot.resource.Resource) -> i32:
        let obj = self.base.base.as_object()
        let icon_var = variant.Variant::from_object(icon.as_object())
        let result = obj.call1("add_icon_item", icon_var)
        return result.as_int() as i32

    # Set item text
    pub fn set_item_text(mut self, idx: i32, text: String):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(idx as i64)
        let text_var = variant.Variant::from_string(text)
        obj.call2("set_item_text", idx_var, text_var)

    # Get item text
    pub fn get_item_text(self, idx: i32) -> String:
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(idx as i64)
        let result = obj.call1("get_item_text", idx_var)
        return result.as_string()

    # Remove item
    pub fn remove_item(mut self, idx: i32):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(idx as i64)
        obj.call1("remove_item", idx_var)

    # Clear items
    pub fn clear(mut self):
        let obj = self.base.base.as_object()
        obj.call0("clear")

    # Get item count
    pub fn get_item_count(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_item_count")
        return result.as_int() as i32

    # Select item
    pub fn select(mut self, idx: i32):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(idx as i64)
        obj.call1("select", idx_var)

    # Deselect item
    pub fn deselect(mut self, idx: i32):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(idx as i64)
        obj.call1("deselect", idx_var)

    # Get selected items
    pub fn get_selected_items(self) -> Array[i32]:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_selected_items")
        # TODO: [stdlib][P2] Parse PackedInt32Array
        return []  # Placeholder

    # Check if selected
    pub fn is_selected(self, idx: i32) -> bool:
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(idx as i64)
        let result = obj.call1("is_selected", idx_var)
        return result.as_bool()

    # Set max columns
    pub fn set_max_columns(mut self, amount: i32):
        let obj = self.base.base.as_object()
        let amount_var = variant.Variant::from_int(amount as i64)
        obj.call1("set_max_columns", amount_var)

    # Set icon mode
    pub fn set_icon_mode(mut self, mode: IconMode):
        let obj = self.base.base.as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_icon_mode", mode_var)


# TabContainer Widget
# Tabbed interface container
pub struct TabContainer extends godot.ui.Control:

impl TabContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> TabContainer:
        return TabContainer(base: godot.ui.Control::from_ptr(ptr))

    # Get current tab
    pub fn get_current_tab(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_current_tab")
        return result.as_int() as i32

    # Set current tab
    pub fn set_current_tab(mut self, tab_idx: i32):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(tab_idx as i64)
        obj.call1("set_current_tab", idx_var)

    # Get tab count
    pub fn get_tab_count(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_tab_count")
        return result.as_int() as i32

    # Set tab title
    pub fn set_tab_title(mut self, tab_idx: i32, title: String):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(tab_idx as i64)
        let title_var = variant.Variant::from_string(title)
        obj.call2("set_tab_title", idx_var, title_var)

    # Get tab title
    pub fn get_tab_title(self, tab_idx: i32) -> String:
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(tab_idx as i64)
        let result = obj.call1("get_tab_title", idx_var)
        return result.as_string()

    # Set tab icon
    pub fn set_tab_icon(mut self, tab_idx: i32, icon: godot.resource.Resource):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(tab_idx as i64)
        let icon_var = variant.Variant::from_object(icon.as_object())
        obj.call2("set_tab_icon", idx_var, icon_var)

    # Set tab disabled
    pub fn set_tab_disabled(mut self, tab_idx: i32, disabled: bool):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(tab_idx as i64)
        let dis_var = variant.Variant::from_bool(disabled)
        obj.call2("set_tab_disabled", idx_var, dis_var)

    # Set tabs visible
    pub fn set_tabs_visible(mut self, visible: bool):
        let obj = self.base.base.as_object()
        let vis_var = variant.Variant::from_bool(visible)
        obj.call1("set_tabs_visible", vis_var)


# OptionButton Widget
# Dropdown menu
pub struct OptionButton extends godot.ui.Control:

impl OptionButton:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> OptionButton:
        return OptionButton(base: godot.ui.Control::from_ptr(ptr))

    # Add item
    pub fn add_item(mut self, label: String, id: i32 = -1):
        let obj = self.base.base.as_object()
        let label_var = variant.Variant::from_string(label)
        let id_var = variant.Variant::from_int(id as i64)
        obj.call2("add_item", label_var, id_var)

    # Add icon item
    pub fn add_icon_item(mut self, icon: godot.resource.Resource, label: String, id: i32 = -1):
        let obj = self.base.base.as_object()
        let icon_var = variant.Variant::from_object(icon.as_object())
        let label_var = variant.Variant::from_string(label)
        let id_var = variant.Variant::from_int(id as i64)
        obj.call3("add_icon_item", icon_var, label_var, id_var)

    # Clear items
    pub fn clear(mut self):
        let obj = self.base.base.as_object()
        obj.call0("clear")

    # Get selected ID
    pub fn get_selected_id(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_selected_id")
        return result.as_int() as i32

    # Get selected index
    pub fn get_selected(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_selected")
        return result.as_int() as i32

    # Select by index
    pub fn select(mut self, idx: i32):
        let obj = self.base.base.as_object()
        let idx_var = variant.Variant::from_int(idx as i64)
        obj.call1("select", idx_var)

    # Get item count
    pub fn get_item_count(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_item_count")
        return result.as_int() as i32


# ScrollContainer
# Scrollable content area
pub struct ScrollContainer extends godot.ui.Control:

impl ScrollContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> ScrollContainer:
        return ScrollContainer(base: godot.ui.Control::from_ptr(ptr))

    # Set horizontal scroll
    pub fn set_h_scroll(mut self, value: i32):
        let obj = self.base.base.as_object()
        let val_var = variant.Variant::from_int(value as i64)
        obj.call1("set_h_scroll", val_var)

    # Get horizontal scroll
    pub fn get_h_scroll(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_h_scroll")
        return result.as_int() as i32

    # Set vertical scroll
    pub fn set_v_scroll(mut self, value: i32):
        let obj = self.base.base.as_object()
        let val_var = variant.Variant::from_int(value as i64)
        obj.call1("set_v_scroll", val_var)

    # Get vertical scroll
    pub fn get_v_scroll(self) -> i32:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_v_scroll")
        return result.as_int() as i32

    # Set scroll deadzone
    pub fn set_deadzone(mut self, deadzone: i32):
        let obj = self.base.base.as_object()
        let dead_var = variant.Variant::from_int(deadzone as i64)
        obj.call1("set_deadzone", dead_var)


# Enums

pub enum IconMode:
    Top = 0      # Icon above text
    Left = 1     # Icon left of text

impl IconMode:
    pub fn to_string(self) -> String:
        """Convert icon mode to string."""
        match self:
            case Top: "Top"
            case Left: "Left"

    pub fn description(self) -> String:
        """Get icon mode description."""
        match self:
            case Top: "Icon positioned above text"
            case Left: "Icon positioned to the left of text"

    pub fn is_top(self) -> bool:
        """Check if icon mode is Top."""
        match self:
            case Top: true
            case _: false

    pub fn is_left(self) -> bool:
        """Check if icon mode is Left."""
        match self:
            case Left: true
            case _: false

    pub fn is_vertical(self) -> bool:
        """Check if icon mode uses vertical layout (Top)."""
        match self:
            case Top: true
            case _: false

    pub fn is_horizontal(self) -> bool:
        """Check if icon mode uses horizontal layout (Left)."""
        match self:
            case Left: true
            case _: false

    pub fn mode_value(self) -> i32:
        """Get the numeric mode value for Godot ItemList API."""
        match self:
            case Top: 0
            case Left: 1

    pub fn summary(self) -> String:
        """Get icon mode summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.is_vertical():
            props.push("vertical")
        if self.is_horizontal():
            props.push("horizontal")
        let mode = self.mode_value()
        props.push("mode={mode}")
        if props.len() > 0:
            let props_str = ", ".join(props)
            return "IconMode: {name} ({desc}, {props_str})"
        else:
            return "IconMode: {name} ({desc})"


# Array placeholder
pub struct Array[T]:
    items: Vec[T]
