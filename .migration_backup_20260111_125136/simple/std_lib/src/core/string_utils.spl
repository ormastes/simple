# String Utilities - Iterators, Bytes type, helper functions
use core.traits.*
use core.collections.*

# ============================================
# Bytes Type (binary data)
# ============================================

type Bytes = List[u8]

impl Bytes:
    fn from_string(s: String) -> Bytes:
        var bytes = List::with_capacity(s.len)
        danger:
            for i in 0..s.len:
                bytes.push(s.data.offset(i as isize).read())
        bytes

# ============================================
# Helper functions
# ============================================

fn is_whitespace(b: u8) -> bool:
    b == ' ' as u8 or b == '\t' as u8 or b == '\n' as u8 or b == '\r' as u8

# Character methods (would be in a separate char module)
impl char:
    fn len_utf8() -> usize:
        let code = self as u32
        if code < 0x80: 1
        else if code < 0x800: 2
        else if code < 0x10000: 3
        else: 4

    fn encode_utf8_to(ptr: *u8):
        let code = self as u32
        danger:
            if code < 0x80:
                ptr.write(code as u8)
            else if code < 0x800:
                ptr.write((0xC0 | (code >> 6)) as u8)
                ptr.offset(1).write((0x80 | (code & 0x3F)) as u8)
            else if code < 0x10000:
                ptr.write((0xE0 | (code >> 12)) as u8)
                ptr.offset(1).write((0x80 | ((code >> 6) & 0x3F)) as u8)
                ptr.offset(2).write((0x80 | (code & 0x3F)) as u8)
            else:
                ptr.write((0xF0 | (code >> 18)) as u8)
                ptr.offset(1).write((0x80 | ((code >> 12) & 0x3F)) as u8)
                ptr.offset(2).write((0x80 | ((code >> 6) & 0x3F)) as u8)
                ptr.offset(3).write((0x80 | (code & 0x3F)) as u8)

    fn is_ascii() -> bool:
        (self as u32) < 0x80

    fn is_alphabetic() -> bool:
        let c = self as u32
        (c >= 'a' as u32 and c <= 'z' as u32) or (c >= 'A' as u32 and c <= 'Z' as u32)

    fn is_numeric() -> bool:
        let c = self as u32
        c >= '0' as u32 and c <= '9' as u32

    fn is_alphanumeric() -> bool:
        self.is_alphabetic() or self.is_numeric()

    fn is_whitespace() -> bool:
        let c = self as u32
        c == ' ' as u32 or c == '\t' as u32 or c == '\n' as u32 or c == '\r' as u32

    fn uppercased() -> char:
        let c = self as u32
        if c >= 'a' as u32 and c <= 'z' as u32:
            (c - 32) as char
        else:
            self

    fn lowercased() -> char:
        let c = self as u32
        if c >= 'A' as u32 and c <= 'Z' as u32:
            (c + 32) as char
        else:
            self

# ============================================
# Global string functions
# ============================================

# Join list of strings
fn join(sep: &str, parts: List[String]) -> String:
    var result = String::new()
    for (i, part) in parts.enumerate():
        if i > 0:
            result.push_str(sep)
        result.push_str(part.as_str())
    result

# Format string (simplified)
fn format(template: &str, args: List[String]) -> String:
    var result = String::new()
    var arg_idx: usize = 0
    var i: usize = 0
    while i < template.len():
        danger:
            let b = template.as_ptr().offset(i as isize).read()
            if b == '{' as u8 and i + 1 < template.len():
                let next = template.as_ptr().offset((i + 1) as isize).read()
                if next == '}' as u8:
                    if arg_idx < args.len():
                        result.push_str(args.get(arg_idx).expect("valid").as_str())
                        arg_idx = arg_idx + 1
                    i = i + 2
                    continue
            result.push_byte(b)
        i = i + 1
    result
