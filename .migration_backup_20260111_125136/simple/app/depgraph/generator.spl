# Dependency Graph Generator - Output Generator Module
# Generates .__init__.spl files with dependency analysis

import analyzer

extern fn native_fs_write_string(path: String, content: String) -> Any

# Helper to join paths
fn path_join(base: String, child: String) -> String:
    if base.ends_with("/"):
        return base + child
    return base + "/" + child

# Generation options
class GeneratorOptions:
    include_comments: Bool      # Include descriptive comments
    include_externals: Bool     # Include external dependency list
    include_visibility: Bool    # Include visibility annotations
    preserve_manual: Bool       # Preserve manually added exports

    fn new() -> GeneratorOptions:
        return GeneratorOptions(
            include_comments: true,
            include_externals: true,
            include_visibility: true,
            preserve_manual: true
        )

# Generate .__init__.spl content
pub fn generate_content(
    analysis: analyzer.AnalysisResult,
    options: GeneratorOptions
) -> String:
    let mut lines: List<String> = []

    # Header
    if options.include_comments:
        lines.push("# Auto-generated dependency analysis")
        lines.push("# DO NOT EDIT - regenerate with: simple_depgraph {analysis.directory}")
        lines.push("# Generated for module: {analysis.module_path}")
        lines.push("")

    # External dependencies section
    if options.include_externals:
        let externals = analyzer.get_unique_externals(analysis)
        if externals.len() > 0:
            lines.push("# External dependencies (imports from outside this module tree)")
            for ext in externals:
                lines.push("# external: {ext}")
            lines.push("")

    # Child modules section
    let visible = analyzer.get_visible_children(analysis)
    let blocked = analyzer.get_blocked_children(analysis)

    if analysis.child_modules.len() > 0:
        lines.push("# Child modules")

        # Public modules first
        for vis in analysis.child_visibility:
            if vis.is_declared_pub:
                if vis.is_externally_visible():
                    if options.include_comments:
                        lines.push("pub mod {vis.name}  # externally visible")
                    else:
                        lines.push("pub mod {vis.name}")
                else:
                    if options.include_comments:
                        lines.push("pub mod {vis.name}  # BLOCKED: no export use")
                    else:
                        lines.push("pub mod {vis.name}")

        # Private modules
        for vis in analysis.child_visibility:
            if not vis.is_declared_pub:
                if options.include_comments:
                    lines.push("mod {vis.name}  # private (no pub mod)")
                else:
                    lines.push("mod {vis.name}")

        lines.push("")

    # Export use section
    if analysis.public_exports.len() > 0:
        lines.push("# Re-exports (accessible to parent)")
        for exp_path in analysis.public_exports:
            lines.push("export use {exp_path}")
        lines.push("")

    # Visibility summary
    if options.include_visibility and options.include_comments:
        lines.push("# Visibility Summary")
        lines.push("# ------------------")
        if visible.len() > 0:
            let vis_str = visible.join(", ")
            lines.push("# Externally visible: {vis_str}")
        if blocked.len() > 0:
            let blk_str = blocked.join(", ")
            lines.push("# Blocked (need export use): {blk_str}")
        lines.push("")

    # Internal dependencies (for reference)
    if options.include_comments and analysis.internal_deps.len() > 0:
        let mut internal_paths: List<String> = []
        for dep in analysis.internal_deps:
            if not internal_paths.contains(dep.path):
                internal_paths.push(dep.path)
        internal_paths.sort()

        lines.push("# Internal dependencies")
        for path in internal_paths:
            lines.push("# internal: {path}")
        lines.push("")

    return lines.join("\n")

# Write .__init__.spl file
pub fn write_dot_init(
    analysis: analyzer.AnalysisResult,
    options: GeneratorOptions
) -> Result<String, String>:
    let content = generate_content(analysis, options)
    let output_path = path_join(analysis.directory, ".__init__.spl")

    let write_result = native_fs_write_string(output_path, content)
    match write_result:
        case Err(e):
            return Err("Failed to write {output_path}: {e}")
        case Ok(_):
            return Ok(output_path)

# Generate for multiple directories (from recursive scan)
pub fn generate_all(
    analyses: List<analyzer.AnalysisResult>,
    options: GeneratorOptions
) -> Result<List<String>, String>:
    let generated: List<String> = []

    for analysis in analyses:
        let result = write_dot_init(analysis, options)
        match result:
            case Err(e):
                # Log warning but continue
                print("[WARN] {e}")
            case Ok(path):
                generated.push(path)

    return Ok(generated)

# Generate summary report
pub fn generate_summary(analyses: List<analyzer.AnalysisResult>) -> String:
    let mut lines: List<String> = []

    lines.push("# Dependency Graph Summary")
    lines.push("# ========================")
    lines.push("")

    let mut total_externals: List<String> = []
    let mut total_internals = 0
    let mut total_modules = 0
    let mut total_blocked = 0

    for analysis in analyses:
        total_modules = total_modules + analysis.child_modules.len()
        total_internals = total_internals + analysis.internal_deps.len()

        let blocked = analyzer.get_blocked_children(analysis)
        total_blocked = total_blocked + blocked.len()

        for dep in analysis.external_deps:
            if not total_externals.contains(dep.path):
                total_externals.push(dep.path)

    lines.push("# Directories analyzed: {analyses.len()}")
    lines.push("# Total modules: {total_modules}")
    lines.push("# Internal dependencies: {total_internals}")
    lines.push("# External dependencies: {total_externals.len()}")
    lines.push("# Blocked children: {total_blocked}")
    lines.push("")

    if total_externals.len() > 0:
        total_externals.sort()
        lines.push("# All external dependencies:")
        for ext in total_externals:
            lines.push("#   - {ext}")
        lines.push("")

    return lines.join("\n")

# Print analysis as human-readable output
pub fn print_analysis(analysis: analyzer.AnalysisResult):
    print("Directory: {analysis.directory}")
    print("Module: {analysis.module_path}")
    print("")

    let externals = analyzer.get_unique_externals(analysis)
    if externals.len() > 0:
        print("External dependencies:")
        for ext in externals:
            print("  - {ext}")
        print("")

    print("Child modules:")
    for vis in analysis.child_visibility:
        let status = if vis.is_externally_visible(): "visible" else: "BLOCKED"
        let pub_status = if vis.is_declared_pub: "pub mod" else: "mod"
        print("  {pub_status} {vis.name} ({status})")
    print("")

    if analysis.public_exports.len() > 0:
        print("Exports:")
        for pub_exp in analysis.public_exports:
            print("  export use {pub_exp}")
        print("")
