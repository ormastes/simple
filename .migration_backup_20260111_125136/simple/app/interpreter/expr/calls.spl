# Function and Method Calls
#
# Call evaluation, argument binding, method dispatch.

import ..core.{Interpreter, Value, InterpreterError, RuntimeValue}
from . import {evaluate}

export eval_call, eval_method_call

# Evaluate a function call
fn eval_call(interp: &Interpreter, callee: &Expr, args: &Array<Expr>) -> Result<Value, InterpreterError>:
    # Evaluate the callee
    let func = evaluate(interp, callee)?

    # Evaluate arguments
    let arg_values: Array<Value> = []
    for arg in args:
        let val = evaluate(interp, arg)?
        arg_values.push(val)

    # Call the function
    return call_value(interp, func, arg_values)

# Evaluate a method call
fn eval_method_call(interp: &Interpreter, obj_expr: &Expr, method: &str, args: &Array<Expr>) -> Result<Value, InterpreterError>:
    # Evaluate the object
    let obj = evaluate(interp, obj_expr)?

    # Evaluate arguments
    let arg_values: Array<Value> = []
    for arg in args:
        let val = evaluate(interp, arg)?
        arg_values.push(val)

    # Dispatch the method
    return call_method(interp, obj, method, arg_values)

# Call a value as a function
fn call_value(interp: &Interpreter, func: Value, args: Array<Value>) -> Result<Value, InterpreterError>:
    match func.data:
        case RuntimeValue::Function { name, params, body }:
            return call_function(interp, &name, &params, &body, args)

        case RuntimeValue::Closure { func, env }:
            return call_closure(interp, &func, &env, args)

        case _:
            return Err(InterpreterError::TypeError("not callable".to_string()))

# Call a user-defined function
fn call_function(interp: &Interpreter, name: &str, params: &Array<String>, body: &Block, args: Array<Value>) -> Result<Value, InterpreterError>:
    # Check arity
    if args.len() != params.len():
        return Err(InterpreterError::ArityError {
            expected: params.len(),
            got: args.len()
        })

    # Create new scope
    interp.env.push_scope()

    # Bind parameters
    for i in 0..params.len():
        interp.env.define(params[i].clone(), args[i].clone())

    # Execute body
    let result = interp.eval_block(body)

    # Pop scope
    interp.env.pop_scope()

    return result

# Call a closure
fn call_closure(interp: &Interpreter, func: &RuntimeValue, captured_env: &Environment, args: Array<Value>) -> Result<Value, InterpreterError>:
    # TODO: [stdlib][P1] Implement closure calls with captured environment
    return Err(InterpreterError::NotImplemented("closures".to_string()))

# Call a method on an object
fn call_method(interp: &Interpreter, obj: Value, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match obj.data:
        case RuntimeValue::Object { class, fields }:
            return call_object_method(interp, &class, &fields, method, args)

        case RuntimeValue::Array(arr):
            return call_array_method(interp, &arr, method, args)

        case RuntimeValue::String(s):
            return call_string_method(interp, &s, method, args)

        case RuntimeValue::Dict(d):
            return call_dict_method(interp, &d, method, args)

        case _:
            return Err(InterpreterError::TypeError("no methods on this type".to_string()))

# Built-in array methods
fn call_array_method(interp: &Interpreter, arr: &Array<Value>, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match method:
        case "len":
            return Ok(Value::int(arr.len() as i64))

        case "push":
            if args.len() != 1:
                return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
            # Note: Would need mutable reference
            return Err(InterpreterError::NotImplemented("array.push".to_string()))

        case "pop":
            return Err(InterpreterError::NotImplemented("array.pop".to_string()))

        case "is_empty":
            return Ok(Value::bool(arr.is_empty()))

        case _:
            return Err(InterpreterError::AttributeError(method.to_string()))

# Built-in string methods
fn call_string_method(interp: &Interpreter, s: &String, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match method:
        case "len":
            return Ok(Value::int(s.len() as i64))

        case "is_empty":
            return Ok(Value::bool(s.is_empty()))

        case "contains":
            if args.len() != 1:
                return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(sub):
                    return Ok(Value::bool(s.contains(sub)))
                case _:
                    return Err(InterpreterError::TypeError("contains requires string".to_string()))

        case "starts_with":
            if args.len() != 1:
                return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(prefix):
                    return Ok(Value::bool(s.starts_with(prefix)))
                case _:
                    return Err(InterpreterError::TypeError("starts_with requires string".to_string()))

        case "ends_with":
            if args.len() != 1:
                return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(suffix):
                    return Ok(Value::bool(s.ends_with(suffix)))
                case _:
                    return Err(InterpreterError::TypeError("ends_with requires string".to_string()))

        case "to_upper":
            return Ok(Value::string(s.to_uppercase()))

        case "to_lower":
            return Ok(Value::string(s.to_lowercase()))

        case "trim":
            return Ok(Value::string(s.trim().to_string()))

        case "split":
            if args.len() != 1:
                return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(sep):
                    let parts: Array<Value> = s.split(sep).map(|p| Value::string(p.to_string())).collect()
                    return Ok(Value::array(parts))
                case _:
                    return Err(InterpreterError::TypeError("split requires string".to_string()))

        case _:
            return Err(InterpreterError::AttributeError(method.to_string()))

# Built-in dict methods
fn call_dict_method(interp: &Interpreter, d: &Dict<Value, Value>, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match method:
        case "len":
            return Ok(Value::int(d.len() as i64))

        case "is_empty":
            return Ok(Value::bool(d.is_empty()))

        case "contains_key":
            if args.len() != 1:
                return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
            return Ok(Value::bool(d.contains_key(&args[0])))

        case "keys":
            let keys: Array<Value> = d.keys().cloned().collect()
            return Ok(Value::array(keys))

        case "values":
            let values: Array<Value> = d.values().cloned().collect()
            return Ok(Value::array(values))

        case _:
            return Err(InterpreterError::AttributeError(method.to_string()))

# Call method on object instance
fn call_object_method(interp: &Interpreter, class: &str, fields: &Dict<String, Value>, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    # TODO: [stdlib][P3] Look up method in class definition
    return Err(InterpreterError::NotImplemented("object methods".to_string()))
