# Arithmetic Operations
#
# Binary operators: +, -, *, /, %, **
# Unary operators: -, +, not

import ..core.{Value, InterpreterError}

export eval_binary_op, eval_unary_op

# Binary operation evaluation
fn eval_binary_op(op: &BinOp, left: Value, right: Value) -> Result<Value, InterpreterError>:
    match op:
        case BinOp::Add:
            return eval_add(left, right)
        case BinOp::Sub:
            return eval_sub(left, right)
        case BinOp::Mul:
            return eval_mul(left, right)
        case BinOp::Div:
            return eval_div(left, right)
        case BinOp::Mod:
            return eval_mod(left, right)
        case BinOp::Pow:
            return eval_pow(left, right)
        case BinOp::Eq:
            return eval_eq(left, right)
        case BinOp::Ne:
            return eval_ne(left, right)
        case BinOp::Lt:
            return eval_lt(left, right)
        case BinOp::Le:
            return eval_le(left, right)
        case BinOp::Gt:
            return eval_gt(left, right)
        case BinOp::Ge:
            return eval_ge(left, right)
        case BinOp::And:
            return eval_and(left, right)
        case BinOp::Or:
            return eval_or(left, right)
        case _:
            return Err(InterpreterError::NotImplemented("binary op".to_string()))

# Unary operation evaluation
fn eval_unary_op(op: &UnaryOp, val: Value) -> Result<Value, InterpreterError>:
    match op:
        case UnaryOp::Neg:
            return eval_neg(val)
        case UnaryOp::Not:
            return eval_not(val)
        case UnaryOp::Pos:
            return Ok(val)
        case _:
            return Err(InterpreterError::NotImplemented("unary op".to_string()))

# Addition
fn eval_add(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::int(l + r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l + r))
        case _:
            pass

    match (left.as_string(), right.as_string()):
        case (Some(l), Some(r)):
            return Ok(Value::string(l.clone() + r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot add these types".to_string()))

# Subtraction
fn eval_sub(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::int(l - r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l - r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot subtract these types".to_string()))

# Multiplication
fn eval_mul(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::int(l * r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l * r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot multiply these types".to_string()))

# Division
fn eval_div(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            if r == 0:
                return Err(InterpreterError::DivisionByZero)
            return Ok(Value::int(l / r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            if r == 0.0:
                return Err(InterpreterError::DivisionByZero)
            return Ok(Value::float(l / r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot divide these types".to_string()))

# Modulo
fn eval_mod(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            if r == 0:
                return Err(InterpreterError::DivisionByZero)
            return Ok(Value::int(l % r))
        case _:
            return Err(InterpreterError::TypeError("modulo requires integers".to_string()))

# Power
fn eval_pow(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l.pow(r)))
        case _:
            return Err(InterpreterError::TypeError("power requires numbers".to_string()))

# Negation
fn eval_neg(val: Value) -> Result<Value, InterpreterError>:
    match val.as_int():
        case Some(n):
            return Ok(Value::int(-n))
        case _:
            pass

    match val.as_float():
        case Some(f):
            return Ok(Value::float(-f))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot negate this type".to_string()))

# Logical not
fn eval_not(val: Value) -> Result<Value, InterpreterError>:
    return Ok(Value::bool(not val.is_truthy()))

# Comparison operations (stubs)
fn eval_eq(left: Value, right: Value) -> Result<Value, InterpreterError>:
    # TODO: [stdlib][P3] Deep equality
    return Err(InterpreterError::NotImplemented("equality".to_string()))

fn eval_ne(left: Value, right: Value) -> Result<Value, InterpreterError>:
    let eq = eval_eq(left, right)?
    return eval_not(eq)

fn eval_lt(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l < r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l < r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

fn eval_le(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l <= r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l <= r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

fn eval_gt(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l > r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l > r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

fn eval_ge(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l >= r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l >= r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

# Logical operations
fn eval_and(left: Value, right: Value) -> Result<Value, InterpreterError>:
    if not left.is_truthy():
        return Ok(left)
    return Ok(right)

fn eval_or(left: Value, right: Value) -> Result<Value, InterpreterError>:
    if left.is_truthy():
        return Ok(left)
    return Ok(right)
