# Core Traits - Fundamental type behaviors
# These traits define common operations for types

# Default trait - types with a default value
trait Default:
    fn default() -> Self

# Clone trait - deep copy
trait Clone:
    fn clone() -> Self

# Copy trait - bitwise copy (marker trait)
trait Copy: Clone

# Eq trait - equality comparison
trait Eq:
    fn eq(other: &Self) -> bool

    fn ne(other: &Self) -> bool:
        return not self.eq(other)

# Ord trait - total ordering
trait Ord: Eq:
    fn cmp(other: &Self) -> Ordering

    fn lt(other: &Self) -> bool:
        return self.cmp(other) == Ordering::Less

    fn le(other: &Self) -> bool:
        return self.cmp(other) != Ordering::Greater

    fn gt(other: &Self) -> bool:
        return self.cmp(other) == Ordering::Greater

    fn ge(other: &Self) -> bool:
        return self.cmp(other) != Ordering::Less

    fn max(other: Self) -> Self:
        if self.ge(&other):
            return self
        return other

    fn min(other: Self) -> Self:
        if self.le(&other):
            return self
        return other

    fn clamp(min: Self, max: Self) -> Self:
        if self.lt(&min):
            return min
        if self.gt(&max):
            return max
        return self

# Ordering enum for comparisons
enum Ordering:
    Less
    Equal
    Greater

impl Ordering:
    fn is_less() -> bool:
        return self == Ordering::Less

    fn is_equal() -> bool:
        return self == Ordering::Equal

    fn is_greater() -> bool:
        return self == Ordering::Greater

    fn reverse() -> Ordering:
        match self:
            case Ordering::Less: return Ordering::Greater
            case Ordering::Equal: return Ordering::Equal
            case Ordering::Greater: return Ordering::Less

# Hash trait - for hashable types
trait Hash:
    fn hash() -> u64

# Display trait - human-readable string representation
trait Display:
    fn fmt() -> str

# Debug trait - debug string representation
trait Debug:
    fn debug_fmt() -> str

# From/Into traits - type conversions
trait From[T]:
    fn from(value: T) -> Self

trait Into[T]:
    fn into() -> T

# Default implementations
impl Into[T] for Self where Self: From[T]:
    fn into() -> T:
        return T::from(self)

# TryFrom/TryInto - fallible conversions
trait TryFrom[T]:
    type Error
    fn try_from(value: T) -> Result[Self, Self::Error]

trait TryInto[T]:
    type Error
    fn try_into() -> Result[T, Self::Error]

# Iterator trait
trait Iterator:
    type Item
    fn next() -> Option[Self::Item]

    fn count() -> u64:
        let mut n: u64 = 0
        while self.next().is_some():
            n = n + 1
        return n

    fn last() -> Option[Self::Item]:
        let mut last = None
        loop:
            match self.next():
                case Some(v): last = Some(v)
                case None: break
        return last

    fn nth(n: u64) -> Option[Self::Item]:
        for _ in 0..n:
            self.next()
        return self.next()

    fn collect[C: FromIterator[Self::Item]](self) -> C:
        return C::from_iter(self)

# FromIterator trait - create collections from iterators
trait FromIterator[T]:
    fn from_iter[I: Iterator[Item=T]](iter: I) -> Self

# IntoIterator trait - convert to iterator
trait IntoIterator:
    type Item
    type IntoIter: Iterator[Item=Self::Item]
    fn into_iter() -> Self::IntoIter

# Add trait - addition operator
trait Add[Rhs = Self]:
    type Output
    fn add(rhs: Rhs) -> Self::Output

# Sub trait - subtraction operator
trait Sub[Rhs = Self]:
    type Output
    fn sub(rhs: Rhs) -> Self::Output

# Mul trait - multiplication operator
trait Mul[Rhs = Self]:
    type Output
    fn mul(rhs: Rhs) -> Self::Output

# Div trait - division operator
trait Div[Rhs = Self]:
    type Output
    fn div(rhs: Rhs) -> Self::Output

# Neg trait - negation operator
trait Neg:
    type Output
    fn neg() -> Self::Output

# Not trait - logical not operator
trait Not:
    type Output
    fn not() -> Self::Output

# Index trait - indexing operator
trait Index[Idx]:
    type Output
    fn index(idx: Idx) -> &Self::Output

# IndexMut trait - mutable indexing
trait IndexMut[Idx]: Index[Idx]:
    fn index_mut(idx: Idx) -> &mut Self::Output

# Deref trait - dereference
trait Deref:
    type Target
    fn deref() -> &Self::Target

# DerefMut trait - mutable dereference
trait DerefMut: Deref:
    fn deref_mut() -> &mut Self::Target

# Drop trait - destructor
trait Drop:
    fn drop()

# Sized trait - types with known size at compile time (marker)
trait Sized

# ============================================
# I/O Traits
# ============================================

# SeekFrom - position for seeking
enum SeekFrom:
    Start(u64)
    End(i64)
    Current(i64)

impl SeekFrom:
    fn start(pos: u64) -> SeekFrom:
        SeekFrom::Start(pos)

    fn end(pos: i64) -> SeekFrom:
        SeekFrom::End(pos)

    fn current(pos: i64) -> SeekFrom:
        SeekFrom::Current(pos)

# Read trait - for types that can be read from
trait Read:
    fn read(buf: &mut [u8]) -> Result[usize, IoError]

    fn read_exact(buf: &mut [u8]) -> Result[(), IoError]:
        let mut offset: usize = 0
        while offset < buf.len():
            match self.read(&mut buf[offset..]):
                case Ok(0): return Err(IoError::UnexpectedEof)
                case Ok(n): offset = offset + n
                case Err(e): return Err(e)
        Ok(())

    fn read_to_end(buf: &mut Array[u8]) -> Result[usize, IoError]:
        let mut total: usize = 0
        let mut chunk = [0u8; 4096]
        loop:
            match self.read(&mut chunk):
                case Ok(0): return Ok(total)
                case Ok(n):
                    buf.extend_from_slice(&chunk[0..n])
                    total = total + n
                case Err(e): return Err(e)

    fn read_to_string(s: &mut String) -> Result[usize, IoError]:
        let mut buf = Array::new()
        let n = self.read_to_end(&mut buf)?
        match String::from_utf8(buf):
            case Ok(str):
                s.push_str(&str)
                Ok(n)
            case Err(_): Err(IoError::InvalidData)

# Write trait - for types that can be written to
trait Write:
    fn write(buf: &[u8]) -> Result[usize, IoError]
    fn flush() -> Result[(), IoError]

    fn write_all(buf: &[u8]) -> Result[(), IoError]:
        let mut offset: usize = 0
        while offset < buf.len():
            match self.write(&buf[offset..]):
                case Ok(0): return Err(IoError::WriteZero)
                case Ok(n): offset = offset + n
                case Err(e): return Err(e)
        Ok(())

    fn write_fmt(args: str) -> Result[(), IoError]:
        self.write_all(args.as_bytes())

# Seek trait - for types that support seeking
trait Seek:
    fn seek(pos: SeekFrom) -> Result[u64, IoError]

    fn rewind() -> Result[(), IoError]:
        self.seek(SeekFrom::Start(0)).map(|_| ())

    fn stream_position() -> Result[u64, IoError]:
        self.seek(SeekFrom::Current(0))

    fn stream_len() -> Result[u64, IoError]:
        let old_pos = self.stream_position()?
        let len = self.seek(SeekFrom::End(0))?
        if old_pos != len:
            self.seek(SeekFrom::Start(old_pos))?
        Ok(len)

# BufRead trait - for buffered reading
trait BufRead: Read:
    fn fill_buf() -> Result[&[u8], IoError]
    fn consume(amt: usize)

    fn read_until(byte: u8, buf: &mut Array[u8]) -> Result[usize, IoError]:
        let mut read: usize = 0
        loop:
            let available = self.fill_buf()?
            if available.is_empty():
                return Ok(read)

            match available.iter().position(|&b| b == byte):
                case Some(i):
                    buf.extend_from_slice(&available[0..=i])
                    self.consume(i + 1)
                    return Ok(read + i + 1)
                case None:
                    buf.extend_from_slice(available)
                    let len = available.len()
                    self.consume(len)
                    read = read + len

    fn read_line(buf: &mut String) -> Result[usize, IoError]:
        let mut bytes = Array::new()
        let n = self.read_until('\n' as u8, &mut bytes)?
        match String::from_utf8(bytes):
            case Ok(s):
                buf.push_str(&s)
                Ok(n)
            case Err(_): Err(IoError::InvalidData)

# ============================================
# Collection Traits
# ============================================

# Len trait - for types with a length
trait Len:
    fn len() -> usize

    fn is_empty() -> bool:
        self.len() == 0

# Extend trait - extend collection with items
trait Extend[A]:
    fn extend[I: IntoIterator[Item=A]](self, iter: I)

# AsSlice trait - view as slice
trait AsSlice[T]:
    fn as_slice() -> &[T]

# AsMutSlice trait - view as mutable slice
trait AsMutSlice[T]: AsSlice[T]:
    fn as_mut_slice() -> &mut [T]

# Clear trait - clear contents
trait Clear:
    fn clear()

# Capacity trait - for types with capacity
trait Capacity:
    fn capacity() -> usize

    fn is_full() -> bool:
        false  # Default: no limit

# Reserve trait - for types that can reserve capacity
trait Reserve:
    fn reserve(additional: usize)
    fn shrink_to_fit()

# ============================================
# Conversion Traits
# ============================================

# AsRef trait - cheap reference conversion
trait AsRef[T]:
    fn as_ref() -> &T

# AsMut trait - cheap mutable reference conversion
trait AsMut[T]:
    fn as_mut() -> &mut T

# Borrow trait - borrowing
trait Borrow[Borrowed]:
    fn borrow() -> &Borrowed

# BorrowMut trait - mutable borrowing
trait BorrowMut[Borrowed]: Borrow[Borrowed]:
    fn borrow_mut() -> &mut Borrowed

# ToOwned trait - create owned copy
trait ToOwned:
    type Owned
    fn to_owned() -> Self::Owned

# ToString trait - convert to string
trait ToString:
    fn to_string() -> String

# Default impl: Display types can be converted to string
impl ToString for T where T: Display:
    fn to_string() -> String:
        self.fmt()

# FromStr trait - parse from string
trait FromStr:
    type Err
    fn from_str(s: &str) -> Result[Self, Self::Err]

# ============================================
# Error Trait
# ============================================

# Error trait - base error trait
trait Error: Display:
    fn source() -> Option[&dyn Error]:
        None

    fn description() -> str:
        self.fmt()

# ============================================
# Iterator Enhancement Traits
# ============================================

# DoubleEndedIterator - can iterate from both ends
trait DoubleEndedIterator: Iterator:
    fn next_back() -> Option[Self::Item]

    fn rev() -> Rev[Self]:
        Rev::new(self)

    fn rfind(predicate: fn(&Self::Item) -> bool) -> Option[Self::Item]:
        loop:
            match self.next_back():
                case Some(item):
                    if predicate(&item):
                        return Some(item)
                case None:
                    return None

# ExactSizeIterator - knows its exact length
trait ExactSizeIterator: Iterator:
    fn len() -> usize

    fn is_empty() -> bool:
        self.len() == 0

# FusedIterator - returns None forever after first None (marker)
trait FusedIterator: Iterator

# ============================================
# Marker Traits
# ============================================

# Send trait - safe to send between threads (marker)
trait Send

# Sync trait - safe to share between threads (marker)
trait Sync

# Unpin trait - safe to move after pinning (marker)
trait Unpin

# ============================================
# Function Traits
# ============================================

# Fn trait - callable by shared reference
trait Fn[Args, Output]:
    fn call(args: Args) -> Output

# FnMut trait - callable by mutable reference
trait FnMut[Args, Output]: Fn[Args, Output]:
    fn call_mut(args: Args) -> Output

# FnOnce trait - callable by value (consuming)
trait FnOnce[Args, Output]:
    fn call_once(args: Args) -> Output

# ============================================
# Reverse Iterator Wrapper
# ============================================

struct Rev[I]:
    iter: I

impl Rev[I] where I: DoubleEndedIterator:
    fn new(iter: I) -> Rev[I]:
        Rev { iter: iter }

impl Iterator for Rev[I] where I: DoubleEndedIterator:
    type Item = I::Item

    fn next() -> Option[Self::Item]:
        self.iter.next_back()

impl DoubleEndedIterator for Rev[I] where I: DoubleEndedIterator:
    fn next_back() -> Option[Self::Item]:
        self.iter.next()
