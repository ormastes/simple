# Persistent (immutable) data structures
# Structural sharing for efficient updates

# Persistent list (cons list)
enum List[T]:
    Nil
    Cons(T, Box[List[T]])

impl List[T]:
    fn empty() -> List[T]:
        List.Nil

    fn prepend(x: T) -> List[T]:
        List.Cons(x, Box.new(self))

    fn head() -> Option[T]:
        match self:
            List.Cons(x, _) => Some(x)
            List.Nil => None

    fn tail() -> Option[List[T]]:
        match self:
            List.Cons(_, xs) => Some(*xs)
            List.Nil => None

    fn is_empty() -> bool:
        match self:
            List.Nil => true
            _ => false

    fn len() -> u64:
        match self:
            List.Nil => 0
            List.Cons(_, xs) => 1 + xs.len()

# Fold operations
fn fold_left[T, U](list: List[T], init: U, f: fn(U, T) -> U) -> U:
    match list:
        List.Nil => init
        List.Cons(x, xs) => fold_left(*xs, f(init, x), f)

fn fold_right[T, U](list: List[T], init: U, f: fn(T, U) -> U) -> U:
    match list:
        List.Nil => init
        List.Cons(x, xs) => f(x, fold_right(*xs, init, f))
