# File System API - Async file operations (Immutable Variant)
# Functional programming style - all operations return new values
# Uses persistent data structures with structural sharing

use units.file.*
use units.size.*
use units.time.*
use host.common.io.error.IoError
use host.common.io.types.*
use core.traits.*

# Immutable directory entries collection
# Uses persistent list for functional iteration
struct DirEntries:
    entries: List<DirEntry>

impl DirEntries:
    fn new(entries: Array<DirEntry>) -> DirEntries:
        DirEntries { entries: List.from_array(entries) }

    # Functional iteration - returns (entry, remaining)
    fn next() -> Option<(DirEntry, DirEntries)>:
        match self.entries.head():
            case Some(entry):
                match self.entries.tail():
                    case Some(rest): return Some((entry, DirEntries { entries: rest }))
                    case None: return Some((entry, DirEntries { entries: List.empty() }))
            case None: return None

    fn is_empty() -> bool:
        self.entries.is_empty()

    fn len() -> u64:
        self.entries.len()

    # Functional transformations - returns new DirEntries (immutable)
    fn filtered(pred: fn(DirEntry) -> bool) -> DirEntries:
        DirEntries { entries: self.entries.filtered(pred) }

    fn map<U>(self, f: fn(DirEntry) -> U) -> List<U>:
        self.entries.map(f)

    fn find(pred: fn(DirEntry) -> bool) -> Option<DirEntry>:
        self.entries.find(pred)

# ===============================
# File System Operations (Pure Functions)
# ===============================

# Read entire file as bytes
pub async fn read(path: FilePath) -> Result<Bytes, IoError>:
    return native_fs_read(path)

# Read entire file as text (UTF-8)
pub async fn read_text(path: FilePath) -> Result<Text, IoError>:
    let bytes = await read(path)?
    match bytes.to_utf8():
        case Ok(s): return Ok(s_text)
        case Err(_): return Err(IoError::InvalidData)

# Write bytes to file (creates or overwrites)
pub async fn write(path: FilePath, data: Bytes) -> Result<ByteCount, IoError>:
    return native_fs_write(path, &data)

# Write text to file (UTF-8)
pub async fn write_text(path: FilePath, text: Text) -> Result<ByteCount, IoError>:
    let bytes = (text as str).to_bytes()
    return await write(path, bytes)

# Append bytes to file
pub async fn append(path: FilePath, data: Bytes) -> Result<ByteCount, IoError>:
    return native_fs_append(path, &data)

# Append text to file
pub async fn append_text(path: FilePath, text: Text) -> Result<ByteCount, IoError>:
    let bytes = (text as str).to_bytes()
    return await append(path, bytes)

# ===============================
# Directory Operations
# ===============================

# Create directory
pub async fn create_dir(path: DirPath) -> Result<(), IoError>:
    return native_fs_create_dir(path, false)

# Create directory and all parent directories
pub async fn create_dir_all(path: DirPath) -> Result<(), IoError>:
    return native_fs_create_dir(path, true)

# Remove file
pub async fn remove(path: FilePath) -> Result<(), IoError>:
    return native_fs_remove_file(path)

# Remove empty directory
pub async fn remove_dir(path: DirPath) -> Result<(), IoError>:
    return native_fs_remove_dir(path, false)

# Remove directory and all contents
pub async fn remove_dir_all(path: DirPath) -> Result<(), IoError>:
    return native_fs_remove_dir(path, true)

# Rename file or directory
pub async fn rename(src: FilePath, dst: FilePath) -> Result<(), IoError>:
    return native_fs_rename(src, dst)

# Copy file
pub async fn copy(src: FilePath, dst: FilePath) -> Result<ByteCount, IoError>:
    return native_fs_copy(src, dst)

# ===============================
# Metadata Operations
# ===============================

# Check if path exists
pub async fn exists(path: FilePath) -> bool:
    match native_fs_metadata(path):
        case Ok(_): return true
        case Err(_): return false

# Get file metadata
pub async fn metadata(path: FilePath) -> Result<FileMetadata, IoError>:
    return native_fs_metadata(path)

# List directory contents (returns immutable DirEntries)
pub async fn read_dir(path: DirPath) -> Result<DirEntries, IoError>:
    let native_entries = native_fs_read_dir(path)?
    return Ok(DirEntries::new(native_entries.entries))

# ===============================
# Immutable File Handle
# ===============================

# Immutable file handle for streaming operations
# Each operation returns a new FileReader/FileWriter state
struct FileReader:
    handle: i64
    path: FilePath
    position: ByteCount

impl FileReader:
    # Open file for reading
    pub async fn open(path: FilePath) -> Result<FileReader, IoError>:
        let handle = native_fs_open(path, OpenMode::Read)?
        return Ok(FileReader { handle: handle, path: path, position: 0_bytes })

    # Read and return (bytes_read, new_reader_state)
    pub async fn read(self, max_bytes: ByteCount) -> Result<(Bytes, FileReader), IoError>:
        let buf = Bytes::with_capacity(max_bytes as u64)
        let n = native_file_read(self.handle, &buf)?
        let new_pos = self.position + n
        return Ok((buf, FileReader { handle: self.handle, path: self.path, position: new_pos }))

    # Read all remaining bytes
    pub async fn read_all(self) -> Result<Bytes, IoError>:
        let mut result = Bytes::empty()
        let mut reader = self
        loop:
            let (chunk, next) = await reader.read(8192_bytes)?
            if chunk.is_empty():
                break
            result = result.append(chunk)
            reader = next
        return Ok(result)

    fn position() -> ByteCount:
        self.position

    # Seek and return new reader state
    pub async fn seek(self, pos: SeekFrom) -> Result<FileReader, IoError>:
        let new_pos = native_file_seek(self.handle, pos)?
        return Ok(FileReader { handle: self.handle, path: self.path, position: new_pos })

    # Close (consumes reader)
    pub async fn close(self) -> Result<(), IoError>:
        return native_file_close(self.handle)

struct FileWriter:
    handle: i64
    path: FilePath
    bytes_written: ByteCount

impl FileWriter:
    # Open file for writing
    pub async fn open(path: FilePath) -> Result<FileWriter, IoError>:
        let handle = native_fs_open(path, OpenMode::Write)?
        return Ok(FileWriter { handle: handle, path: path, bytes_written: 0_bytes })

    # Create new file
    pub async fn create(path: FilePath) -> Result<FileWriter, IoError>:
        let handle = native_fs_open(path, OpenMode::Create)?
        return Ok(FileWriter { handle: handle, path: path, bytes_written: 0_bytes })

    # Write and return new writer state
    pub async fn write(self, data: Bytes) -> Result<FileWriter, IoError>:
        let n = native_file_write(self.handle, &data)?
        return Ok(FileWriter {
            handle: self.handle,
            path: self.path,
            bytes_written: self.bytes_written + n
        })

    fn bytes_written() -> ByteCount:
        self.bytes_written

    # Flush and return new state
    pub async fn flush(self) -> Result<FileWriter, IoError>:
        native_file_flush(self.handle)?
        return Ok(self)

    # Sync to disk and return new state
    pub async fn sync(self) -> Result<FileWriter, IoError>:
        native_file_sync(self.handle)?
        return Ok(self)

    # Close (consumes writer)
    pub async fn close(self) -> Result<(), IoError>:
        return native_file_close(self.handle)

# ===============================
# Functional File Operations
# ===============================

# Process file line by line with a pure function
pub async fn process_lines<U>(
    path: FilePath,
    init: U,
    f: fn(U, Text) -> U
) -> Result<U, IoError>:
    let text = await read_text(path)?
    let lines = (text as str).lines()
    return Ok(lines.fold(init, |acc, line| f(acc, line_text)))

# Transform file contents
pub async fn transform(
    src: FilePath,
    dst: FilePath,
    f: fn(Bytes) -> Bytes
) -> Result<ByteCount, IoError>:
    let data = await read(src)?
    let transformed = f(data)
    return await write(dst, transformed)

# Transform text file
pub async fn transform_text(
    src: FilePath,
    dst: FilePath,
    f: fn(Text) -> Text
) -> Result<ByteCount, IoError>:
    let text = await read_text(src)?
    let transformed = f(text)
    return await write_text(dst, transformed)

# ===============================
# Native function declarations
# ===============================

extern fn native_fs_read(path: FilePath) -> Result<Bytes, IoError>
extern fn native_fs_write(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_fs_append(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_fs_create_dir(path: DirPath, recursive: bool) -> Result<(), IoError>
extern fn native_fs_remove_file(path: FilePath) -> Result<(), IoError>
extern fn native_fs_remove_dir(path: DirPath, recursive: bool) -> Result<(), IoError>
extern fn native_fs_rename(src: FilePath, dst: FilePath) -> Result<(), IoError>
extern fn native_fs_copy(src: FilePath, dst: FilePath) -> Result<ByteCount, IoError>
extern fn native_fs_metadata(path: FilePath) -> Result<FileMetadata, IoError>
extern fn native_fs_read_dir(path: DirPath) -> Result<DirEntries, IoError>
extern fn native_fs_open(path: FilePath, mode: OpenMode) -> Result<i64, IoError>
extern fn native_file_read(handle: i64, buf: &Bytes) -> Result<ByteCount, IoError>
extern fn native_file_write(handle: i64, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_file_flush(handle: i64) -> Result<(), IoError>
extern fn native_file_seek(handle: i64, pos: SeekFrom) -> Result<ByteCount, IoError>
extern fn native_file_sync(handle: i64) -> Result<(), IoError>
extern fn native_file_close(handle: i64) -> Result<(), IoError>
