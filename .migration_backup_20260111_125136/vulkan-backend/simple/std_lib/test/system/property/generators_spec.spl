# Property Testing Framework - Generator Tests
# Tests for built-in generators and combinators

module tests.property.generators_spec:
    use std.spec.{describe, context, it, expect}
    use std.spec.property.generators as gen
    use core.option.{Some, None}
    use core.result.{Ok, Err}

    describe("Generator Framework"):
        context("Primitive Generators"):
            it("generates i64 values"):
                let g = gen.i64()
                let v1 = g.generate(42)
                let v2 = g.generate(43)
                expect(v1).to_not_equal(v2)

            it("generates i64 in range"):
                let g = gen.i64_range(0, 100)
                for seed in 0..10:
                    let v = g.generate(seed)
                    expect(v).to_be_gte(0)
                    expect(v).to_be_lt(100)

            it("generates u64 values"):
                let g = gen.u64()
                let v = g.generate(42)
                expect(v).to_be_gte(0)

            it("generates bool values"):
                let g = gen.bool()
                let v1 = g.generate(42)
                let v2 = g.generate(43)
                # Should generate mix of true/false
                let mut has_true = false
                let mut has_false = false
                for seed in 0..100:
                    if g.generate(seed):
                        has_true = true
                    else:
                        has_false = true
                expect(has_true).to_be_true()
                expect(has_false).to_be_true()

            it("generates string values"):
                let g = gen.string()
                let v = g.generate(42)
                expect(v).to_be_instance_of(String)

            it("generates ascii strings"):
                let g = gen.ascii()
                let v = g.generate(42)
                expect(v).to_be_instance_of(String)

            it("generates strings with length constraints"):
                let g = gen.string_with_length(5, 10)
                for seed in 0..10:
                    let v = g.generate(seed)
                    expect(v.length()).to_be_gte(5)
                    expect(v.length()).to_be_lte(10)

        context("Collection Generators"):
            it("generates lists"):
                let g = gen.list(gen.i64())
                let v = g.generate(42)
                expect(v).to_be_instance_of([i64])

            it("generates lists with length constraints"):
                let g = gen.list_with_length(gen.i64(), 3, 7)
                for seed in 0..10:
                    let v = g.generate(seed)
                    expect(v.length()).to_be_gte(3)
                    expect(v.length()).to_be_lte(7)

            it("generates Option values"):
                let g = gen.option(gen.i64())
                let mut has_some = false
                let mut has_none = false
                for seed in 0..100:
                    match g.generate(seed):
                        Some(_) -> has_some = true
                        None -> has_none = true
                expect(has_some).to_be_true()
                expect(has_none).to_be_true()

            it("generates Result values"):
                let g = gen.result(gen.i64(), gen.string())
                let mut has_ok = false
                let mut has_err = false
                for seed in 0..100:
                    match g.generate(seed):
                        Ok(_) -> has_ok = true
                        Err(_) -> has_err = true
                expect(has_ok).to_be_true()
                expect(has_err).to_be_true()

        context("Tuple Generators"):
            it("generates 2-tuples"):
                let g = gen.tuple2(gen.i64(), gen.string())
                let (a, b) = g.generate(42)
                expect(a).to_be_instance_of(i64)
                expect(b).to_be_instance_of(String)

            it("generates 3-tuples"):
                let g = gen.tuple3(gen.i64(), gen.bool(), gen.string())
                let (a, b, c) = g.generate(42)
                expect(a).to_be_instance_of(i64)
                expect(b).to_be_instance_of(bool)
                expect(c).to_be_instance_of(String)

        context("Generator Combinators"):
            it("maps generator output"):
                let g = gen.map(gen.i64(), |x| x * 2)
                let v = g.generate(42)
                # Should be even (double of something)
                expect(v % 2).to_equal(0)

            it("filters generator output"):
                let g = gen.filter(gen.i64_range(0, 100), |x| x > 50)
                for seed in 0..20:
                    let v = g.generate(seed)
                    # Most should pass filter
                    # (may occasionally fail due to max_tries)

            it("flat_maps generators"):
                let g = gen.flat_map(
                    gen.i64_range(0, 5),
                    |size| gen.list_with_length(gen.i64(), size, size)
                )
                let v = g.generate(42)
                expect(v).to_be_instance_of([i64])

            it("chooses from one_of"):
                let g = gen.one_of([
                    gen.i64_range(0, 10),
                    gen.i64_range(100, 110),
                    gen.i64_range(1000, 1010)
                ])
                let v = g.generate(42)
                expect(v).to_be_instance_of(i64)

            it("chooses by frequency"):
                let g = gen.frequency([
                    (8, gen.i64_range(0, 10)),      # 80% small
                    (2, gen.i64_range(100, 110))    # 20% large
                ])
                let mut small_count = 0
                let mut large_count = 0
                for seed in 0..100:
                    let v = g.generate(seed)
                    if v < 10:
                        small_count += 1
                    else:
                        large_count += 1
                # Expect roughly 80/20 split (allow variance)
                expect(small_count).to_be_gt(large_count)

        context("Shrinking"):
            it("shrinks i64 towards zero"):
                let g = gen.i64()
                let shrinks = g.shrink(100)
                expect(shrinks).to_contain(0)
                expect(shrinks).to_contain(50)

            it("shrinks lists to smaller lists"):
                let g = gen.list(gen.i64())
                let big_list = [1, 2, 3, 4, 5]
                let shrinks = g.shrink(big_list)
                expect(shrinks).to_contain([])
                expect(shrinks.length()).to_be_gt(0)

            it("shrinks bool to false"):
                let g = gen.bool()
                let shrinks = g.shrink(true)
                expect(shrinks).to_equal([false])

            it("shrinks Option to None"):
                let g = gen.option(gen.i64())
                let shrinks = g.shrink(Some(42))
                expect(shrinks).to_equal([None])

            it("shrinks strings to empty"):
                let g = gen.string()
                let shrinks = g.shrink("hello")
                expect(shrinks).to_contain("")
