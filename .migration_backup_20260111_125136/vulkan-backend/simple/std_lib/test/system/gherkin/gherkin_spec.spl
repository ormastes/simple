# Gherkin DSL System Tests
# Tests for feature/scenario/given/when/then BDD syntax
#
# These tests validate that the Gherkin DSL correctly transforms to
# BDD spec framework calls and executes properly.

use spec.*

# ============================================================================
# Test: Basic Feature and Scenario Structure
# ============================================================================

describe "Gherkin DSL":
    describe "feature block":
        it "transforms feature to describe":
            # The parser transforms `feature Name:` to `feature("Name", block)`
            # which should create a describe block named "Feature: Name"
            let executed = false
            feature "Test Feature":
                executed = true
            expect(executed).to_be_true()

        it "supports nested scenarios":
            let scenario_count = 0
            feature "Multi Scenario":
                scenario "First":
                    scenario_count = scenario_count + 1
                scenario "Second":
                    scenario_count = scenario_count + 1
            expect(scenario_count).to_equal(2)

    describe "scenario block":
        it "transforms scenario to context with it":
            let executed = false
            scenario "Simple Test":
                executed = true
            expect(executed).to_be_true()

        it "supports given/when/then steps":
            let steps_executed: List<String> = []
            scenario "Step Execution":
                given "initial state":
                    steps_executed.push("given")
                when "action happens":
                    steps_executed.push("when")
                then "result is expected":
                    steps_executed.push("then")
            expect(steps_executed).to_equal(["given", "when", "then"])

    describe "step keywords":
        it "executes given step for setup":
            let setup_done = false
            given "a precondition":
                setup_done = true
            expect(setup_done).to_be_true()

        it "executes when step for action":
            let action_done = false
            when "an action occurs":
                action_done = true
            expect(action_done).to_be_true()

        it "executes then step for assertion":
            let assertion_done = false
            then "a result is verified":
                assertion_done = true
            expect(assertion_done).to_be_true()

        it "executes and_then for chained assertions":
            let assertions: List<String> = []
            then "first assertion":
                assertions.push("first")
            and_then "second assertion":
                assertions.push("second")
            expect(assertions).to_equal(["first", "second"])

# ============================================================================
# Test: Examples Tables
# ============================================================================

describe "Examples Tables":
    it "registers examples table with name":
        examples "addition":
            a  b  result
            1  2  3
            5  5  10
        # Table should be registered in examples_registry
        let table = get_examples("addition")
        expect(table).to_be_some()

    it "parses header row from examples":
        examples "test_data":
            x  y  z
            1  2  3
        let rows = get_examples("test_data").unwrap()
        let headers = get_examples_headers(rows)
        expect(headers).to_equal(["x", "y", "z"])

    it "extracts data rows excluding header":
        examples "values":
            num  doubled
            1    2
            5    10
            10   20
        let rows = get_examples("values").unwrap()
        let data = get_examples_data(rows)
        expect(data.len()).to_equal(3)

# ============================================================================
# Test: Scenario Outline with Parameterization
# ============================================================================

describe "Scenario Outline":
    # Register test examples
    examples "arithmetic":
        a   b   sum
        1   2   3
        10  20  30
        -5  5   0

    it "runs scenario for each examples row":
        let execution_count = 0
        scenario outline "Addition Test":
            given "two numbers":
                let a = get_var("a")
                let b = get_var("b")
            then "sum is correct":
                execution_count = execution_count + 1
            examples "arithmetic":
        # Should run 3 times (once per data row)
        expect(execution_count).to_equal(3)

    it "substitutes placeholders with values":
        let captured_values: List<i64> = []
        scenario outline "Capture Values":
            when "using value <a>":
                captured_values.push(get_var("a"))
            examples "arithmetic":
        expect(captured_values).to_equal([1, 10, -5])

# ============================================================================
# Test: Step Definition Registration
# ============================================================================

describe "Step Definitions":
    # Define reusable step
    define_given "a calculator at <n>":
        let n = params.get("n").unwrap()
        set_var("calc_value", n)

    define_when "adding <amount>":
        let current = get_var("calc_value")
        let amount = params.get("amount").unwrap()
        set_var("calc_value", current + amount)

    define_then "value is <expected>":
        let actual = get_var("calc_value")
        let expected = params.get("expected").unwrap()
        expect(actual).to_equal(expected)

    it "matches step patterns":
        scenario "Calculator Test":
            given "a calculator at 10":
            when "adding 5":
            then "value is 15":

    it "extracts placeholders from patterns":
        scenario "Placeholder Extraction":
            given "a calculator at 100":
            let value = get_var("calc_value")
            expect(value).to_equal(100)

# ============================================================================
# Test: Pattern Matching
# ============================================================================

describe "Pattern Matching":
    it "matches exact patterns":
        let result = match_pattern("fresh calculator", "fresh calculator")
        expect(result).to_be_some()
        expect(result.unwrap().len()).to_equal(0)

    it "captures placeholder values":
        let result = match_pattern("add 5", "add <n>")
        expect(result).to_be_some()
        let captures = result.unwrap()
        expect(captures.get("n")).to_equal(Some(5))

    it "captures multiple placeholders":
        let result = match_pattern("from 10 to 20", "from <start> to <end>")
        expect(result).to_be_some()
        let captures = result.unwrap()
        expect(captures.get("start")).to_equal(Some(10))
        expect(captures.get("end")).to_equal(Some(20))

    it "returns None for non-matching patterns":
        let result = match_pattern("add 5", "subtract <n>")
        expect(result).to_be_none()

    it "returns None for different lengths":
        let result = match_pattern("add 5 6", "add <n>")
        expect(result).to_be_none()

# ============================================================================
# Test: Context Variables
# ============================================================================

describe "Scenario Context":
    it "stores and retrieves variables":
        scenario "Variable Test":
            set_var("test_key", 42)
            let value = get_var("test_key")
            expect(value).to_equal(42)

    it "isolates variables between scenarios":
        scenario "First Scenario":
            set_var("isolated", "first")

        scenario "Second Scenario":
            # Should not see variable from first scenario
            set_var("isolated", "second")
            expect(get_var("isolated")).to_equal("second")

# ============================================================================
# Test: Integration with BDD Framework
# ============================================================================

describe "BDD Integration":
    it "feature maps to describe":
        # Verify feature creates proper describe block
        feature "Integration Test":
            expect(true).to_be_true()

    it "inherits hooks from parent describe":
        let hook_executed = false
        describe "Parent":
            before_each:
                hook_executed = true

            feature "Child Feature":
                scenario "Uses Hook":
                    expect(hook_executed).to_be_true()

    it "supports expect matchers in then blocks":
        scenario "Matcher Usage":
            given "a value":
                set_var("value", 42)
            then "assertions work":
                expect(get_var("value")).to_equal(42)
                expect(get_var("value")).to_be_gt(0)
                expect(get_var("value")).not_to_be_nil()

# ============================================================================
# Test: Two-Space Delimiter Examples (SDN Integration)
# ============================================================================

describe "Two-Space Delimiter":
    # Examples with multi-word values separated by two+ spaces
    examples "operations":
        start  operation       result
        10     add 5           15
        10     multiply by 2   20
        100    subtract 30     70

    it "parses multi-word values correctly":
        let rows = get_examples("operations").unwrap()
        let data = get_examples_data(rows)
        # "add 5" should be a single value, not split
        let first_row = data[0]
        expect(first_row[1]).to_equal("add 5")

    it "handles operation patterns in scenario outline":
        scenario outline "Operation Test":
            given "calculator at <start>":
            when "<operation>":
            then "result is <result>":
            examples "operations":
