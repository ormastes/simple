# Tests for Tree-sitter Highlight Queries
# Validates highlights.scm captures all Simple language constructs

import spec.{describe, it, expect, before_each}
import parser.treesitter.{TreeSitterParser, Query, QueryCursor}

describe("Tree-sitter Highlight Queries"):
    let parser: Option<TreeSitterParser>
    let query: Option<Query>

    before_each():
        parser = TreeSitterParser.new("simple")

        # Load highlight query from queries/highlights.scm
        query = Query.new("simple", "highlights")

    describe("Keyword Captures"):
        it("captures fn keyword"):
            let code = "fn main(): void"

            if parser == none or query == none:
                expect(true).to_be_false()
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            # Find 'fn' keyword capture
            let found_fn = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "keyword" and capture.node.text(code) == "fn":
                        found_fn = true

            expect(found_fn).to_be_true()

        it("captures control flow keywords"):
            let code = "if x > 0:\n    return x\nelse:\n    return 0"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let keywords_found = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "keyword.control":
                        keywords_found.append(capture.node.text(code))

            expect(keywords_found).to_contain("if")
            expect(keywords_found).to_contain("else")
            expect(keywords_found).to_contain("return")

        it("captures async keywords"):
            let code = "async fn fetch(): void\nawait result"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let async_keywords = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "keyword.async":
                        async_keywords.append(capture.node.text(code))

            expect(async_keywords).to_contain("async")
            expect(async_keywords).to_contain("await")

    describe("Function Captures"):
        it("captures function definitions"):
            let code = "fn calculate(x: i32): i32 = x * 2"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_definition = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "function.definition":
                        expect(capture.node.text(code)).to_equal("calculate")
                        found_definition = true

            expect(found_definition).to_be_true()

        it("captures function calls"):
            let code = "let result = calculate(10)"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_call = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "function.call":
                        expect(capture.node.text(code)).to_equal("calculate")
                        found_call = true

            expect(found_call).to_be_true()

        it("captures builtin functions"):
            let code = "print(\"Hello\")\nlen(items)\nrange(10)"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let builtins = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "function.builtin":
                        builtins.append(capture.node.text(code))

            expect(builtins).to_contain("print")
            expect(builtins).to_contain("len")
            expect(builtins).to_contain("range")

    describe("Type Captures"):
        it("captures primitive types"):
            let code = "let x: i32 = 10\nlet y: f64 = 3.14\nlet flag: bool = true"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let types_found = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "type.builtin":
                        types_found.append(capture.node.text(code))

            expect(types_found).to_contain("i32")
            expect(types_found).to_contain("f64")
            expect(types_found).to_contain("bool")

        it("captures user-defined types"):
            let code = "class Point:\n    x: i32\n    y: i32"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_class_def = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "type.class.definition":
                        expect(capture.node.text(code)).to_equal("Point")
                        found_class_def = true

            expect(found_class_def).to_be_true()

        it("captures type parameters"):
            let code = "fn identity<T>(x: T): T = x"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_type_param = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "type.parameter":
                        expect(capture.node.text(code)).to_equal("T")
                        found_type_param = true

            expect(found_type_param).to_be_true()

    describe("Variable and Parameter Captures"):
        it("captures parameters with higher priority"):
            let code = "fn add(x: i32, y: i32): i32 = x + y"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let parameters = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "parameter":
                        parameters.append(capture.node.text(code))

            expect(parameters).to_contain("x")
            expect(parameters).to_contain("y")
            expect(parameters.len()).to_equal(2)

        it("captures variable definitions"):
            let code = "let count = 0\nlet name = \"Alice\""

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let variables = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "variable.definition":
                        variables.append(capture.node.text(code))

            expect(variables).to_contain("count")
            expect(variables).to_contain("name")

        it("captures field access"):
            let code = "point.x\nobj.field_name"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let properties = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "property":
                        properties.append(capture.node.text(code))

            expect(properties).to_contain("x")
            expect(properties).to_contain("field_name")

    describe("Literal Captures"):
        it("captures integer literals"):
            let code = "let x = 42\nlet y = 0xFF\nlet z = 0b1010"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let numbers = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "number":
                        numbers.append(capture.node.text(code))

            expect(numbers).to_contain("42")
            expect(numbers).to_contain("0xFF")
            expect(numbers).to_contain("0b1010")

        it("captures string literals"):
            let code = "let s1 = \"hello\"\nlet s2 = 'world'"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_strings = 0
            for match in matches:
                for capture in match.captures:
                    if capture.name == "string":
                        found_strings += 1

            expect(found_strings).to_be_greater_than_or_equal(2)

        it("captures f-strings as special"):
            let code = "let msg = f\"Hello, {name}!\""

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_fstring = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "string.special":
                        found_fstring = true

            expect(found_fstring).to_be_true()

        it("captures boolean literals"):
            let code = "let flag1 = true\nlet flag2 = false"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let booleans = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "boolean":
                        booleans.append(capture.node.text(code))

            expect(booleans).to_contain("true")
            expect(booleans).to_contain("false")

    describe("Operator Captures"):
        it("captures arithmetic operators"):
            let code = "x + y - z * 2 / 3 % 4"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let operators = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "operator.arithmetic":
                        operators.append(capture.node.text(code))

            expect(operators).to_contain("+")
            expect(operators).to_contain("-")
            expect(operators).to_contain("*")
            expect(operators).to_contain("/")
            expect(operators).to_contain("%")

        it("captures comparison operators"):
            let code = "x == y\na != b\nc < d\ne > f\ng <= h\ni >= j"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let comparisons = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "operator.comparison":
                        comparisons.append(capture.node.text(code))

            expect(comparisons.len()).to_be_greater_than_or_equal(6)

        it("captures logical operators"):
            let code = "x and y\na or b\nnot c"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let logical = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "operator.logical":
                        logical.append(capture.node.text(code))

            expect(logical).to_contain("and")
            expect(logical).to_contain("or")
            expect(logical).to_contain("not")

    describe("Comment Captures"):
        it("captures line comments"):
            let code = "# This is a comment\nlet x = 10  # inline comment"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_comments = 0
            for match in matches:
                for capture in match.captures:
                    if capture.name == "comment":
                        found_comments += 1

            expect(found_comments).to_be_greater_than_or_equal(2)

        it("captures doc comments"):
            let code = "\"\"\"This is a doc comment\"\"\"\nfn foo(): void"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_doc_comment = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "comment.documentation":
                        found_doc_comment = true

            expect(found_doc_comment).to_be_true()

    describe("Priority System"):
        it("parameters have higher priority than variables"):
            # In a function parameter, 'x' should be captured as parameter, not variable
            let code = "fn test(x: i32): void"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let x_captures = []
            for match in matches:
                for capture in match.captures:
                    if capture.node.text(code) == "x":
                        x_captures.append(capture.name)

            # Should capture as parameter, possibly also as variable (lower priority)
            expect(x_captures).to_contain("parameter")

        it("function definitions have higher priority than calls"):
            # Function name in definition should be captured as definition
            let code = "fn calculate(x: i32): i32 = x"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let calculate_captures = []
            for match in matches:
                for capture in match.captures:
                    if capture.node.text(code) == "calculate":
                        calculate_captures.append(capture.name)

            expect(calculate_captures).to_contain("function.definition")
