# Unit tests for LSP hover handler

import spec.{describe, it, expect}
import lsp.handlers.hover as hover
import parser.treesitter.{TreeSitterParser, Span, NodeId, Node}

describe("Hover Handler"):
    it("finds node at position"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo(): return 1"
        let tree = parser.parse(source).unwrap()

        # Position at "fn" keyword (line 0, column 0)
        let node = hover.find_node_at_position(tree, 0, 0)
        expect(node.is_some()).to_be(true)

    it("returns None when position is outside source"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1"
        let tree = parser.parse(source).unwrap()

        # Position far outside source
        let node = hover.find_node_at_position(tree, 100, 100)
        expect(node.is_none()).to_be(true)

    it("finds deepest node at position"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo(x: i32): return x"
        let tree = parser.parse(source).unwrap()

        # Position at parameter "x" (should find identifier, not entire param)
        let node = hover.find_node_at_position(tree, 0, 7)
        expect(node.is_some()).to_be(true)

        match node:
            case Some(n):
                # Should be an identifier or similar leaf node
                expect(n.children.len()).to_be_less_than(3)
            case None:
                # Fail test
                expect(false).to_be(true)

    it("provides hover content for keywords"):
        let keyword_node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "keyword",
            span: Span(start_byte: 0, end_byte: 2, start_line: 0, end_line: 0, start_column: 0, end_column: 2),
            children: [],
            fields: {},
            has_error: false,
            text: "fn"
        )

        let content = hover.get_hover_content(keyword_node, "fn")
        expect(content.is_some()).to_be(true)

        match content:
            case Some(text):
                expect(text).to_contain("fn")
                expect(text).to_contain("Function")
            case None:
                expect(false).to_be(true)

    it("provides hover content for identifiers"):
        let ident_node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "identifier",
            span: Span(start_byte: 0, end_byte: 3, start_line: 0, end_line: 0, start_column: 0, end_column: 3),
            children: [],
            fields: {},
            has_error: false,
            text: "foo"
        )

        let content = hover.get_hover_content(ident_node, "foo")
        expect(content.is_some()).to_be(true)

    it("provides hover content for literals"):
        let int_node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "integer",
            span: Span(start_byte: 0, end_byte: 2, start_line: 0, end_line: 0, start_column: 0, end_column: 2),
            children: [],
            fields: {},
            has_error: false,
            text: "42"
        )

        let content = hover.get_hover_content(int_node, "42")
        expect(content.is_some()).to_be(true)

        match content:
            case Some(text):
                expect(text).to_contain("integer")
                expect(text).to_contain("42")
            case None:
                expect(false).to_be(true)

    it("returns None for uninteresting nodes"):
        let unknown_node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "unknown_node_type",
            span: Span(start_byte: 0, end_byte: 1, start_line: 0, end_line: 0, start_column: 0, end_column: 1),
            children: [],
            fields: {},
            has_error: false,
            text: "x"
        )

        let content = hover.get_hover_content(unknown_node, "x")
        expect(content.is_none()).to_be(true)

    it("handles hover request for valid position"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo(): return 1"
        let tree = parser.parse(source).unwrap()

        # Hover over "fn" keyword
        let result = hover.handle_hover(tree, source, 0, 0).unwrap()
        expect(result.is_some()).to_be(true)

    it("returns None for hover outside source"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1"
        let tree = parser.parse(source).unwrap()

        let result = hover.handle_hover(tree, source, 100, 100).unwrap()
        expect(result.is_none()).to_be(true)

    it("creates hover with markdown content"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42"
        let tree = parser.parse(source).unwrap()

        # Hover over "let" keyword
        let result = hover.handle_hover(tree, source, 0, 0).unwrap()

        match result:
            case Some(hover_data):
                expect(hover_data.contains_key("contents")).to_be(true)
                expect(hover_data.contains_key("range")).to_be(true)

                let contents = hover_data["contents"]
                expect(contents.contains_key("kind")).to_be(true)
                expect(contents["kind"]).to_equal("markdown")
            case None:
                # May not have hover for this position
                pass

describe("Type Documentation"):
    it("provides documentation for built-in types"):
        let int_doc = hover.get_type_documentation("Int")
        expect(int_doc.is_some()).to_be(true)

        match int_doc:
            case Some(doc):
                expect(doc).to_contain("Int")
                expect(doc).to_contain("64-bit")
            case None:
                expect(false).to_be(true)

    it("returns None for unknown types"):
        let unknown_doc = hover.get_type_documentation("UnknownType")
        expect(unknown_doc.is_none()).to_be(true)

    it("documents collection types"):
        let list_doc = hover.get_type_documentation("List")
        expect(list_doc.is_some()).to_be(true)

        let dict_doc = hover.get_type_documentation("Dict")
        expect(dict_doc.is_some()).to_be(true)

    it("documents option and result types"):
        let option_doc = hover.get_type_documentation("Option")
        expect(option_doc.is_some()).to_be(true)

        match option_doc:
            case Some(doc):
                expect(doc).to_contain("Option")
                expect(doc).to_contain("Some")
                expect(doc).to_contain("None")
            case None:
                expect(false).to_be(true)

        let result_doc = hover.get_type_documentation("Result")
        expect(result_doc.is_some()).to_be(true)

describe("Keyword Documentation"):
    it("provides documentation for control flow keywords"):
        # Test through get_hover_content
        let if_node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "keyword",
            span: Span(start_byte: 0, end_byte: 2, start_line: 0, end_line: 0, start_column: 0, end_column: 2),
            children: [],
            fields: {},
            has_error: false,
            text: "if"
        )

        let content = hover.get_hover_content(if_node, "if")
        expect(content.is_some()).to_be(true)

        match content:
            case Some(doc):
                expect(doc).to_contain("if")
                expect(doc).to_contain("Conditional")
            case None:
                expect(false).to_be(true)

    it("provides documentation for loop keywords"):
        let loop_node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "keyword",
            span: Span(start_byte: 0, end_byte: 4, start_line: 0, end_line: 0, start_column: 0, end_column: 4),
            children: [],
            fields: {},
            has_error: false,
            text: "loop"
        )

        let content = hover.get_hover_content(loop_node, "loop")
        expect(content.is_some()).to_be(true)

        match content:
            case Some(doc):
                expect(doc).to_contain("loop")
                expect(doc).to_contain("Infinite")
            case None:
                expect(false).to_be(true)
