# Diff Spec - Tests for Keyed Diffing Algorithm
#
# Tests the diff algorithm that computes minimal patches.

use spec.*
use ui.element.*
use ui.patchset.*
use ui.diff.*

describe "diff":
    it "returns empty patches for identical trees":
        let id = NodeId::new(1)
        let elem1 = Element::div(id)
        let elem2 = Element::div(id)

        let result = diff(&elem1, &elem2)
        expect(result.patches().is_empty()).to(be_true())

    it "detects text changes":
        let id = NodeId::new(1)
        let old = Element::text(id, "Hello")
        let new = Element::text(id, "World")

        let result = diff(&old, &new)
        expect(result.patches().len()).to(equal(1))

    it "detects attribute additions":
        let id = NodeId::new(1)
        let old = Element::div(id)
        let new = Element::div(id).with_attr("data-value", "123")

        let result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects attribute removals":
        let id = NodeId::new(1)
        let old = Element::div(id).with_attr("data-value", "123")
        let new = Element::div(id)

        let result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects attribute changes":
        let id = NodeId::new(1)
        let old = Element::div(id).with_attr("data-value", "old")
        let new = Element::div(id).with_attr("data-value", "new")

        let result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects class additions":
        let id = NodeId::new(1)
        let old = Element::div(id)
        let new = Element::div(id).with_class("active")

        let result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects class removals":
        let id = NodeId::new(1)
        let old = Element::div(id).with_class("active")
        let new = Element::div(id)

        let result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

describe "diff children":
    it "handles empty children":
        let id = NodeId::new(1)
        let old = Element::div(id)
        let new = Element::div(id)

        let result = diff(&old, &new)
        expect(result.patches().is_empty()).to(be_true())

    it "detects new children":
        let parent_id = NodeId::new(1)
        let child_id = NodeId::new(2)

        let old = Element::div(parent_id)
        let child = Element::text(child_id, "New Child")
        let new = Element::div(parent_id).with_child(child)

        let result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects removed children":
        let parent_id = NodeId::new(1)
        let child_id = NodeId::new(2)

        let child = Element::text(child_id, "Child")
        let old = Element::div(parent_id).with_child(child)
        let new = Element::div(parent_id)

        let result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "matches keyed children":
        let parent_id = NodeId::new(1)

        let child1 = Element::text(NodeId::new(2), "A").with_key("key-a")
        let child2 = Element::text(NodeId::new(3), "B").with_key("key-b")
        let child3 = Element::text(NodeId::new(4), "C").with_key("key-c")

        let old = Element::div(parent_id)
            .with_child(child1.clone())
            .with_child(child2.clone())
            .with_child(child3.clone())

        # Reorder: A, B, C -> C, A, B
        let new = Element::div(parent_id)
            .with_child(child3)
            .with_child(child1)
            .with_child(child2)

        let result = diff(&old, &new)
        # Should detect moves, not remove/insert pairs
        expect(result.patches().len()).to(be_greater_than(0))

describe "LIS algorithm":
    it "computes longest increasing subsequence":
        let arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
        let lis = longest_increasing_subsequence(&arr)

        # Verify result is increasing
        let mut prev: Option<u64> = None
        for idx in &lis:
            let val = arr[idx]
            if let Some(p) = prev:
                expect(val).to(be_greater_than(p))
            prev = Some(val)

    it "handles empty array":
        let arr: Array<u64> = []
        let lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(0))

    it "handles single element":
        let arr = [42]
        let lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(1))

    it "handles already sorted":
        let arr = [1, 2, 3, 4, 5]
        let lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(5))

    it "handles reverse sorted":
        let arr = [5, 4, 3, 2, 1]
        let lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(1))
