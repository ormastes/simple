# BDD DSL - RSpec-style describe/context/it blocks
# Implements example group registration and hook management
# Extended with Context Sharing support and Shared Examples (TEST-010, TEST-011)

import registry.{ExampleGroup, Example, Hook, ContextDefinition, Given, SharedExampleDefinition}

# Current execution context (stack of groups)
let group_stack: List<ExampleGroup> = []
let current_group: Option<ExampleGroup> = None

# Current context definition being built (for Context { ... })
let current_context_def: Option<ContextDefinition> = None

# context_def: Define a reusable named context
# Usage: context_def :admin_user: ...
export fn context_def(name: Symbol, block: Fn() -> Void) -> Void:
    let def = ContextDefinition.new(name)
    current_context_def = Some(def)

    # Execute block to collect givens
    block()

    # Register the context definition
    match current_context_def:
        case Some(context_def):
            registry.register_context(name, context_def)
        case None:
            pass

    current_context_def = None

# describe: Create a top-level example group
# Usage: describe "MyClass": ...
export fn describe(description: String, block: Fn() -> Void) -> Void:
    group = ExampleGroup.new(description, parent=None)
    group_stack.push(group)
    current_group = Some(group)
    
    # Execute block to collect nested specs
    block()
    
    # Register with global registry
    registry.register_group(group)
    
    group_stack.pop()
    current_group = if group_stack.is_empty():
        None
    else:
        Some(group_stack.last())

# context: Create a nested example group (alias for describe)
# Usage: context "when logged in": ...
export fn context(description: String, block: Fn() -> Void) -> Void:
    match current_group:
        case Some(parent):
            group = ExampleGroup.new(description, parent=Some(parent))
            parent.add_child(group)
            group_stack.push(group)
            current_group = Some(group)

            block()

            group_stack.pop()
            current_group = Some(parent)
        case None:
            # If no parent, treat as top-level describe
            describe(description, block)

# context: Reference a single reusable context (capital C Context definition)
# Usage: context :admin_user: ...
export fn context(name: Symbol, block: Fn() -> Void) -> Void:
    context_with_symbols([name], block)

# context_compose: Reference and compose multiple reusable contexts
# Usage: context_compose :admin_user, :with_database: ...
export fn context_compose(names: List<Symbol>, block: Fn() -> Void) -> Void:
    context_with_symbols(names, block)

# context_with_symbols: Create nested group and apply context definitions
# Internal helper for context(:symbol) syntax
fn context_with_symbols(names: List<Symbol>, block: Fn() -> Void) -> Void:
    match current_group:
        case Some(parent):
            # Create intermediate group for composing contexts
            let context_names = names.map(fn(s): s.to_string())
            let group_desc = "with " + context_names.join(", ")

            group = ExampleGroup.new(group_desc, parent=Some(parent))
            parent.add_child(group)
            group_stack.push(group)
            current_group = Some(group)

            # Apply each context definition's givens as before_each hooks
            for name in names:
                match registry.get_context(name):
                    case Some(context_def):
                        # Add givens as hooks
                        for given in context_def.givens:
                            match given:
                                case Given.Lazy(given_name, given_block):
                                    # Create before_each hook that stores the value
                                    let lazy_hook = Hook.BeforeEach(fn():
                                        let value = given_block()
                                        runtime.set_example_state(given_name.to_string(), value)
                                    )
                                    group.add_hook(lazy_hook)
                                case Given.Eager(given_block):
                                    # Add eager setup as before_each
                                    group.add_hook(Hook.BeforeEach(given_block))
                    case None:
                        panic("Context ${name} not found")

            block()

            group_stack.pop()
            current_group = Some(parent)
        case None:
            panic("context() must be called within a describe or context block")

# it: Define a single test example
# Usage: it "does something": ...
export fn it(description: String, block: Fn() -> Void) -> Void:
    match current_group:
        case Some(group):
            example = Example.new(description, block)
            group.add_example(example)
        case None:
            panic("it() must be called within a describe or context block")

# skip: Define a pending/skipped test example
# Usage: skip "does something not yet implemented": ...
export fn skip(description: String, block: Fn() -> Void) -> Void:
    match current_group:
        case Some(group):
            example = Example.new(description, block).skip()
            group.add_example(example)
        case None:
            panic("skip() must be called within a describe or context block")

# ============================================================================
# TEST-012: Let Memoization - Per-example state management
# ============================================================================
#
# Simple provides two styles of let for different use cases:
#
# 1. `let` (macro) - Eager evaluation before each example
#    - Value is computed before each example runs
#    - Use when the value is always needed
#    - Syntax: let x = make_x()
#
# 2. `let_lazy` - True lazy memoization
#    - Value is computed only on first access within an example
#    - Value is cached for the duration of the example
#    - Access via: `x` (implicit) or `get_let(:x)` (explicit)
#    - Use for expensive computations that may not be needed
#    - Syntax: let_lazy :x, \: make_x()
#
# Both are reset/cleared between examples automatically.

# let: Define eager per-example state (runs before each example)
# Usage: let user = User.new("test")
# Note: This is a compile-time macro that transforms to before_each
export macro let(name: Str const, value: Any) -> ():
    emit result:
        return nil

# let_lazy: Define truly lazy memoized per-example state
# Usage: let_lazy :user, \: User.new("test")
# The block is only evaluated when the value is first accessed within an example
export fn let_lazy(name: Symbol, block: Fn() -> Any) -> Void:
    match current_group:
        case Some(group):
            # Create a before_each hook that registers the memoized block
            # The block itself is NOT called here - only when accessed
            let name_str = name.to_string()
            let lazy_hook = Hook.BeforeEach(fn():
                runtime.set_memoized(name_str, block)
            )
            group.add_hook(lazy_hook)
        case None:
            panic("let_lazy() must be called within a describe or context block")

# get_let: Explicitly get a lazy memoized value (triggers evaluation if needed)
# Usage: let value = get_let(:user)
# This is useful when you want to be explicit about accessing memoized state
export fn get_let(name: Symbol) -> Any:
    let name_str = name.to_string()
    match runtime.get_memoized(name_str):
        case Some(value):
            return value
        case None:
            # Fall back to regular example state
            match runtime.get_example_state(name_str):
                case Some(value):
                    return value
                case None:
                    panic("No let/let_lazy value found for '${name_str}'")

# Check if a let value exists (either lazy or eager)
export fn has_let(name: Symbol) -> Bool:
    let name_str = name.to_string()
    return runtime.has_memoized(name_str) or runtime.get_example_state(name_str).is_some()

# given: Define a fixture (unnamed eager setup)
# Usage: given { setup_code() }  -> Runs before each example
export fn given(block: Fn() -> Void) -> Void:
    match current_context_def:
        case Some(def):
            # Eager given inside a Context definition
            def.add_given(Given.Eager(block))
        case None:
            # Regular eager setup (like before_each) when not in Context definition
            match current_group:
                case Some(group):
                    group.add_hook(Hook.BeforeEach(block))
                case None:
                    panic("given() must be called within a describe/context block or Context definition")

# given: Reference a context_def within a given block (overloaded version)
# Usage: given :context_name -> Apply context_def givens inside given block
# This allows composing contexts inline within setup blocks
export fn given(context_name: Symbol) -> Void:
    match current_group:
        case Some(group):
            # Look up the context definition
            match registry.get_context(context_name):
                case Some(context_def):
                    # Apply each given from the context as before_each hooks
                    for given in context_def.givens:
                        match given:
                            case Given.Lazy(given_name, given_block):
                                # Create before_each hook that stores the memoized value
                                let lazy_hook = Hook.BeforeEach(fn():
                                    let value = given_block()
                                    runtime.set_example_state(given_name.to_string(), value)
                                )
                                group.add_hook(lazy_hook)
                            case Given.Eager(given_block):
                                # Add eager setup as before_each
                                group.add_hook(Hook.BeforeEach(given_block))
                case None:
                    panic("Context ${context_name} not found")
        case None:
            panic("given() must be called within a describe/context block")

# given: Define a named eager fixture (overloaded version)
# Usage: given :setup, \: setup_code()  -> Named eager setup that runs before each example
# Named eager fixtures run eagerly (before each example) but can be documented/identified by name
export fn given(name: Symbol, block: Fn() -> Void) -> Void:
    match current_context_def:
        case Some(def):
            # Named eager given inside a Context definition
            def.add_given(Given.Eager(block))
        case None:
            # Named eager setup in regular context - same behavior as unnamed given
            match current_group:
                case Some(group):
                    group.add_hook(Hook.BeforeEach(block))
                case None:
                    panic("given() must be called within a describe/context block or Context definition")

# given_lazy: Define a lazy (memoized) fixture
# Usage in Context definition: given_lazy :user, \: User.new("test")
# Usage in context block: given_lazy :user, \: User.new("test")
# Lazy fixtures are memoized per example (called once, cached for duration of example)
export fn given_lazy(name: Symbol, block: Fn() -> Any) -> Void:
    match current_context_def:
        case Some(def):
            # In context definition - add to context's givens list
            def.add_given(Given.Lazy(name, block))
        case None:
            # In regular context/describe block - create before_each hook with memoization
            match current_group:
                case Some(group):
                    # Create a before_each hook that memoizes the value
                    let lazy_hook = Hook.BeforeEach(fn():
                        let value = block()
                        runtime.set_example_state(name.to_string(), value)
                    )
                    group.add_hook(lazy_hook)
                case None:
                    panic("given_lazy() must be called within a describe/context block or Context definition")

# then: BDD-style assertion (optional - synonym for expect truthy)
# Usage: then { expression_is_truthy }
# This is syntactic sugar for: expect(...).to be_truthy
export fn then(block: Fn() -> Bool) -> Void:
    result = block()
    if not result:
        panic("Expected truthy value in then block")

# Hook definitions
export fn before_each(block: Fn() -> Void) -> Void:
    match current_group:
        case Some(group):
            group.add_hook(Hook.BeforeEach(block))
        case None:
            panic("before_each() must be called within a describe or context block")

export fn after_each(block: Fn() -> Void) -> Void:
    match current_group:
        case Some(group):
            group.add_hook(Hook.AfterEach(block))
        case None:
            panic("after_each() must be called within a describe or context block")

export fn before_all(block: Fn() -> Void) -> Void:
    match current_group:
        case Some(group):
            group.add_hook(Hook.BeforeAll(block))
        case None:
            panic("before_all() must be called within a describe or context block")

export fn after_all(block: Fn() -> Void) -> Void:
    match current_group:
        case Some(group):
            group.add_hook(Hook.AfterAll(block))
        case None:
            panic("after_all() must be called within a describe or context block")

# ============================================================================
# TEST-010: Shared Examples - Define reusable example groups
# ============================================================================
#
# shared_examples allows you to define a group of examples that can be
# included in multiple describe/context blocks using it_behaves_like.
#
# The shared examples block has access to helper functions and fixtures
# defined in the scope where it_behaves_like is called.
#
# Usage:
#   shared_examples "a stack-like container":
#       it "supports push/pop":
#           s = make()  # Uses 'make' function from calling scope
#           s.push(1)
#           expect s.pop() to eq 1
#
#   describe "Stack":
#       fn make() -> Stack:
#           return Stack.new()
#
#       it_behaves_like "a stack-like container"
#
export fn shared_examples(name: String, block: Fn() -> Void) -> Void:
    let definition = SharedExampleDefinition.new(name, block)
    registry.register_shared_examples(name, definition)

# Variant with description for documentation
export fn shared_examples(name: String, description: String, block: Fn() -> Void) -> Void:
    let definition = SharedExampleDefinition.new(name, block).with_description(description)
    registry.register_shared_examples(name, definition)

# ============================================================================
# TEST-011: it_behaves_like - Include shared examples in current context
# ============================================================================
#
# it_behaves_like includes the examples from a shared_examples definition
# into the current describe/context block. It creates a nested context
# named "behaves like {name}" and executes the shared block within it.
#
# The shared examples have access to:
# - Helper functions defined in the current scope (e.g., factory functions)
# - Fixtures defined via given/given_lazy in the current context
# - The full example group hierarchy for hook execution
#
# Usage:
#   describe "Stack":
#       fn make() -> Stack:
#           return Stack.new()
#
#       it_behaves_like "a stack-like container"
#
#   describe "Deque":
#       fn make() -> Deque:
#           return Deque.new()
#
#       it_behaves_like "a stack-like container"
#
export fn it_behaves_like(name: String) -> Void:
    match registry.get_shared_examples(name):
        case Some(definition):
            # Create a nested context for the shared examples
            # This provides proper isolation and hook inheritance
            let context_name = "behaves like ${name}"
            context(context_name, definition.block)
        case None:
            panic("Shared example '${name}' not found. Did you define it with shared_examples(\"${name}\")?")

# Variant: include_examples is an alias for it_behaves_like (RSpec compatibility)
export fn include_examples(name: String) -> Void:
    it_behaves_like(name)
