# HTTP Server
#
# Accept loop and connection handler for HTTP requests.

use units.net.*
use units.size.*
use units.time.*
use host.async_nogc_mut.net.tcp.*
use host.common.io.error.IoError
use web.http.request.*
use web.http.response.*

# Server configuration
pub struct ServerConfig:
    addr: SocketAddr
    keep_alive: bool
    keep_alive_timeout: Duration
    max_connections: u32
    read_timeout: Duration
    write_timeout: Duration
    max_body_size: ByteCount

impl ServerConfig:
    # Create config with socket address
    pub fn new(addr: SocketAddr) -> ServerConfig:
        return ServerConfig {
            addr: addr,
            keep_alive: true,
            keep_alive_timeout: 60.seconds(),
            max_connections: 1000,
            read_timeout: 30.seconds(),
            write_timeout: 30.seconds(),
            max_body_size: 10.megabytes()
        }

    # Create config for localhost with port
    pub fn bind_local(port: u16) -> ServerConfig:
        let addr = SocketAddr::new(IpAddr::localhost(), Port::new(port))
        return ServerConfig::new(addr)

    # Builder methods
    pub fn with_keep_alive(self, enabled: bool) -> ServerConfig:
        self.keep_alive = enabled
        return self

    pub fn with_keep_alive_timeout(self, timeout: Duration) -> ServerConfig:
        self.keep_alive_timeout = timeout
        return self

    pub fn with_max_connections(self, max: u32) -> ServerConfig:
        self.max_connections = max
        return self

    pub fn with_read_timeout(self, timeout: Duration) -> ServerConfig:
        self.read_timeout = timeout
        return self

    pub fn with_write_timeout(self, timeout: Duration) -> ServerConfig:
        self.write_timeout = timeout
        return self

    pub fn with_max_body_size(self, size: ByteCount) -> ServerConfig:
        self.max_body_size = size
        return self

# Handler function type
pub type HttpHandler = fn(HttpRequest) -> async HttpResponse

# HTTP Server
pub struct HttpServer:
    config: ServerConfig
    handler: HttpHandler

impl HttpServer:
    # Create new server with config
    pub fn new(config: ServerConfig) -> HttpServer:
        return HttpServer {
            config: config,
            handler: default_handler
        }

    # Create server on localhost port
    pub fn localhost(port: u16) -> HttpServer:
        return HttpServer::new(ServerConfig::bind_local(port))

    # Set request handler
    pub fn handler(self, h: HttpHandler) -> HttpServer:
        self.handler = h
        return self

    # Get server address
    pub fn addr(self) -> SocketAddr:
        return self.config.addr

    # Run the server (blocking)
    pub async fn run(self) -> Result[(), IoError]:
        let listener = await TcpListener::bind(self.config.addr)?

        loop:
            let (stream, peer_addr) = await listener.accept()?

            # Spawn connection handler
            spawn self.handle_connection(stream)

    # Handle single connection
    async fn handle_connection(self, stream: TcpStream):
        # Set timeouts
        let _ = stream.set_read_timeout(Some(self.config.read_timeout))
        let _ = stream.set_write_timeout(Some(self.config.write_timeout))

        loop:
            # Parse request
            match await HttpRequest::parse(&stream):
                case Ok(request):
                    # Check Connection header for keep-alive
                    let should_close = request.header("connection")
                        .map(|v| v.to_lower() == "close")
                        .unwrap_or(false)

                    # Call handler
                    let response = await (self.handler)(request)

                    # Send response
                    match await response.send(&stream):
                        case Ok(_):
                            if should_close or not self.config.keep_alive:
                                break
                        case Err(_):
                            break

                case Err(HttpError::ConnectionClosed):
                    break

                case Err(e):
                    # Send error response
                    let error_resp = server_error_page(&e.to_str())
                    let _ = await error_resp.send(&stream)
                    break

        # Close connection
        let _ = await stream.close()

# Default handler returns 404
fn default_handler(request: HttpRequest) -> async HttpResponse:
    return not_found_page(request.path())

# Quick server helper
pub async fn serve(port: u16, handler: HttpHandler) -> Result[(), IoError]:
    let server = HttpServer::localhost(port).handler(handler)
    return await server.run()
