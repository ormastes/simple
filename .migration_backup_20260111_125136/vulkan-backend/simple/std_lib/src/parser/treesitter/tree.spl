# Tree representation for parsed Simple language source
# Immutable CST with arena allocation and structural sharing

import core.{Option, Result}

# Handle to a node in the arena (not a pointer)
struct NodeId:
    index: u32
    generation: u32

# Source location span
struct Span:
    start_byte: i64
    end_byte: i64
    start_line: i64
    end_line: i64
    start_column: i64
    end_column: i64

    fn contains(line: i64, column: i64) -> bool:
        if self.start_line == line and self.end_line == line:
            return self.start_column <= column and column < self.end_column
        elif self.start_line == line:
            return self.start_column <= column
        elif self.end_line == line:
            return column < self.end_column
        else:
            return self.start_line < line and line < self.end_line

# Alias for Span (tree-sitter compatibility)
type Range = Span

# Parse tree node (immutable)
struct Node:
    id: NodeId
    kind: str                    # "function_def", "identifier", etc.
    span: Span
    children: [NodeId]           # Child node handles
    fields: {str: NodeId}        # Named fields (@name, @params)
    has_error: bool              # Contains ERROR node?
    text: str                    # Cached text slice

    fn child_count() -> i64:
        return self.children.len()

    fn child(index: i64) -> Option[NodeId]:
        if index >= 0 and index < self.children.len():
            return Some(self.children[index])
        else:
            return None

    fn child_by_field(field_name: str) -> Option[NodeId]:
        return self.fields.get(field_name)

    fn is_named() -> bool:
        # Named nodes (non-tokens) have lowercase kind
        return self.kind.len() > 0 and self.kind[0].is_lowercase()

# Arena allocator for nodes (based on core_nogc/arena.spl pattern)
struct NodeArena:
    nodes: [Node]
    generation: u32

    fn new() -> NodeArena:
        return NodeArena(nodes: [], generation: 0)

    me alloc(node: Node) -> NodeId:
        let index = self.nodes.len() as u32
        self.nodes.push(node)
        return NodeId(index: index, generation: self.generation)

    fn get(id: NodeId) -> Option[Node]:
        if id.generation != self.generation:
            return None
        if id.index >= 0 and (id.index as i64) < self.nodes.len():
            return Some(self.nodes[id.index as i64])
        else:
            return None

    fn clone_shallow() -> NodeArena:
        # Structural sharing - copy arena reference
        return NodeArena(
            nodes: self.nodes,
            generation: self.generation + 1
        )

# Immutable parse tree
struct Tree:
    root_node: NodeId
    arena: NodeArena
    source: str
    version: u32

    fn root() -> Option[Node]:
        return self.arena.get(self.root_node)

    fn get_node(id: NodeId) -> Option[Node]:
        return self.arena.get(id)

    fn walk() -> TreeCursor:
        return TreeCursor(
            tree: self,
            current: self.root_node,
            depth: 0
        )

# Tree cursor for efficient traversal
struct TreeCursor:
    tree: Tree
    current: NodeId
    depth: i64

    fn node() -> Option[Node]:
        return self.tree.get_node(self.current)

    me goto_first_child() -> bool:
        match self.node():
            case Some(node):
                match node.child(0):
                    case Some(child_id):
                        self.current = child_id
                        self.depth = self.depth + 1
                        return true
                    case None:
                        return false
            case None:
                return false

    me goto_next_sibling() -> bool:
        # TODO: Implement sibling navigation (requires parent tracking)
        return false

    me goto_parent() -> bool:
        # TODO: Implement parent navigation (requires parent tracking)
        return false
