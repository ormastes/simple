/**
Allocator Interface

Custom memory allocation strategies for performance-critical code.

Features:
- Arena: Batch allocations with single deallocation
- Pool: Object reuse for fixed-size allocations
- @allocator decorator: Custom allocator for classes

```sdoctest
>>> let arena = Arena.new(1000)
>>> let ptr = arena.alloc(42)
>>> arena.reset()  # Free all at once
```
*/

# FFI declarations for allocator operations
extern fn rt_arena_new(capacity: i64) -> i64
extern fn rt_arena_alloc(arena: i64, size: i64) -> i64
extern fn rt_arena_reset(arena: i64)
extern fn rt_arena_free(arena: i64)
extern fn rt_arena_used(arena: i64) -> i64
extern fn rt_arena_capacity(arena: i64) -> i64

extern fn rt_pool_new(object_size: i64, capacity: i64) -> i64
extern fn rt_pool_acquire(pool: i64) -> i64
extern fn rt_pool_release(pool: i64, ptr: i64)
extern fn rt_pool_free(pool: i64)
extern fn rt_pool_available(pool: i64) -> i64
extern fn rt_pool_capacity(pool: i64) -> i64

/**
Allocator trait - interface for custom allocators.

Implement this trait to create custom allocation strategies.

```sdoctest
>>> trait Allocator:
...     fn alloc(self, size: i64) -> i64
...     fn dealloc(self, ptr: i64)
```
*/
trait Allocator:
    /**
    Allocate memory of the given size.
    Returns a pointer (as i64) to the allocated memory.
    */
    fn alloc(size: i64) -> i64

    /**
    Deallocate memory at the given pointer.
    */
    fn dealloc(ptr: i64)

    /**
    Returns true if this allocator supports individual deallocation.
    Arena allocators return false.
    */
    fn supports_dealloc() -> Bool:
        return true

/**
Arena allocator for batch allocations.

Allocates memory linearly from a pre-allocated buffer.
All allocations are freed at once via reset().
Ideal for temporary allocations with known lifetime.

```sdoctest
>>> let arena = Arena.new(1024)
>>> let p1 = arena.alloc_raw(64)
>>> let p2 = arena.alloc_raw(128)
>>> arena.used()  # Returns bytes used
192
>>> arena.reset()
>>> arena.used()
0
```
*/
struct Arena:
    _handle: i64
    _capacity: i64

    /**
    Create a new arena with the given capacity in bytes.
    */
    fn new(capacity: i64) -> Arena:
        let handle = rt_arena_new(capacity)
        return Arena(_handle: handle, _capacity: capacity)

    /**
    Allocate raw bytes from the arena.
    Returns 0 if the arena is full.
    */
    fn alloc_raw(size: i64) -> i64:
        return rt_arena_alloc(self._handle, size)

    /**
    Reset the arena, freeing all allocations.
    Does not release the underlying memory.
    */
    fn reset():
        rt_arena_reset(self._handle)

    /**
    Get the number of bytes currently used.
    */
    fn used() -> i64:
        return rt_arena_used(self._handle)

    /**
    Get the total capacity in bytes.
    */
    fn capacity() -> i64:
        return rt_arena_capacity(self._handle)

    /**
    Check if the arena has space for the given size.
    */
    fn has_space(size: i64) -> Bool:
        return self.used() + size <= self.capacity()

    /**
    Free the arena and release underlying memory.
    */
    fn free():
        rt_arena_free(self._handle)

    # Implement Allocator trait
    fn alloc(size: i64) -> i64:
        return self.alloc_raw(size)

    fn dealloc(ptr: i64):
        # Arena doesn't support individual deallocation
        pass

    fn supports_dealloc() -> Bool:
        return false

/**
Typed arena for allocating objects of a specific type.

```sdoctest
>>> struct Node:
...     value: i64
...     next: i64
>>> let arena = TypedArena[Node].new(100)
>>> let node = arena.alloc(Node(value: 42, next: 0))
```
*/
struct TypedArena[T]:
    _arena: Arena
    _object_size: i64

    /**
    Create a new typed arena with capacity for N objects.
    */
    fn new(capacity: i64) -> TypedArena[T]:
        let object_size = 64  # Placeholder - would use sizeof(T)
        let arena = Arena.new(capacity * object_size)
        return TypedArena(_arena: arena, _object_size: object_size)

    /**
    Allocate a new object in the arena.
    */
    fn alloc(value: T) -> T:
        let ptr = self._arena.alloc_raw(self._object_size)
        # In real impl, would copy value to ptr
        return value

    /**
    Reset the arena, invalidating all allocated objects.
    */
    fn reset():
        self._arena.reset()

    /**
    Get the number of objects allocated.
    */
    fn count() -> i64:
        return self._arena.used() / self._object_size

    /**
    Get the maximum number of objects.
    */
    fn capacity() -> i64:
        return self._arena.capacity() / self._object_size

    /**
    Free the arena.
    */
    fn free():
        self._arena.free()

/**
Object pool for reusing fixed-size allocations.

Maintains a pool of pre-allocated objects that can be
acquired and released for reuse.

```sdoctest
>>> let pool = Pool.new(64, 100)  # 100 objects of 64 bytes
>>> let buf = pool.acquire()
>>> pool.release(buf)
```
*/
struct Pool:
    _handle: i64
    _object_size: i64
    _capacity: i64

    /**
    Create a new pool with objects of the given size.

    Arguments:
    - object_size: Size of each object in bytes
    - capacity: Maximum number of objects in the pool
    */
    fn new(object_size: i64, capacity: i64) -> Pool:
        let handle = rt_pool_new(object_size, capacity)
        return Pool(
            _handle: handle,
            _object_size: object_size,
            _capacity: capacity
        )

    /**
    Acquire an object from the pool.
    Returns 0 if the pool is exhausted.
    */
    fn acquire() -> i64:
        return rt_pool_acquire(self._handle)

    /**
    Release an object back to the pool for reuse.
    */
    fn release(ptr: i64):
        rt_pool_release(self._handle, ptr)

    /**
    Get the number of available objects.
    */
    fn available() -> i64:
        return rt_pool_available(self._handle)

    /**
    Get the total capacity.
    */
    fn capacity() -> i64:
        return rt_pool_capacity(self._handle)

    /**
    Check if the pool has available objects.
    */
    fn has_available() -> Bool:
        return self.available() > 0

    /**
    Free the pool and all objects.
    */
    fn free():
        rt_pool_free(self._handle)

    # Implement Allocator trait
    fn alloc(size: i64) -> i64:
        if size > self._object_size:
            return 0
        return self.acquire()

    fn dealloc(ptr: i64):
        self.release(ptr)

/**
Typed object pool for reusing objects of a specific type.

```sdoctest
>>> struct Buffer:
...     data: [u8]
...     size: i64
>>> let pool = TypedPool[Buffer].new(100)
>>> let buf = pool.acquire()
>>> buf.size = 1024
>>> pool.release(buf)
```
*/
struct TypedPool[T]:
    _pool: Pool
    _object_size: i64

    /**
    Create a new typed pool with capacity for N objects.
    */
    fn new(capacity: i64) -> TypedPool[T]:
        let object_size = 64  # Placeholder - would use sizeof(T)
        let pool = Pool.new(object_size, capacity)
        return TypedPool(_pool: pool, _object_size: object_size)

    /**
    Acquire an object from the pool.
    Returns None if the pool is exhausted.
    */
    fn acquire() -> Option[T]:
        let ptr = self._pool.acquire()
        if ptr == 0:
            return Option.None
        # In real impl, would read object from ptr
        return Option.None  # Placeholder

    /**
    Release an object back to the pool.
    */
    fn release(obj: T):
        # In real impl, would get ptr from obj and release
        pass

    /**
    Get the number of available objects.
    */
    fn available() -> i64:
        return self._pool.available()

    /**
    Get the total capacity.
    */
    fn capacity() -> i64:
        return self._pool.capacity()

    /**
    Free the pool.
    */
    fn free():
        self._pool.free()

/**
Bump allocator - simple linear allocator.

Even simpler than Arena - just bumps a pointer forward.
No metadata overhead, but no reset capability.

```sdoctest
>>> let bump = BumpAllocator.new(4096)
>>> let p1 = bump.alloc(100)
>>> let p2 = bump.alloc(200)
>>> bump.remaining()
3796
```
*/
struct BumpAllocator:
    _buffer: i64
    _capacity: i64
    _offset: i64

    fn new(capacity: i64) -> BumpAllocator:
        let buffer = rt_arena_new(capacity)
        return BumpAllocator(
            _buffer: buffer,
            _capacity: capacity,
            _offset: 0
        )

    fn alloc(size: i64) -> i64:
        if self._offset + size > self._capacity:
            return 0
        let ptr = self._buffer + self._offset
        self._offset = self._offset + size
        return ptr

    fn remaining() -> i64:
        return self._capacity - self._offset

    fn used() -> i64:
        return self._offset

    fn free():
        rt_arena_free(self._buffer)

/**
Allocator configuration for classes.

Use with @allocator decorator to specify custom allocation.
*/
struct AllocatorConfig:
    allocator_type: str
    capacity: i64

    fn arena(capacity: i64) -> AllocatorConfig:
        return AllocatorConfig(allocator_type: "arena", capacity: capacity)

    fn pool(capacity: i64) -> AllocatorConfig:
        return AllocatorConfig(allocator_type: "pool", capacity: capacity)

    fn default() -> AllocatorConfig:
        return AllocatorConfig(allocator_type: "gc", capacity: 0)
