"""
# Simple Language Concurrency - Test Specification

**Status:** Reference
**Feature IDs:** 
**Source:** concurrency.md
**Type:** Extracted Examples (Category B)

## Overview

This file contains executable test cases extracted from concurrency.md.
The original specification file remains as architectural reference documentation.

**Note:** This is a test extraction file. For complete specification text,
design rationale, and architecture, see doc/spec/concurrency.md

## Extracted Test Cases

24 test cases extracted covering:
- Core functionality examples
- Edge cases and validation
- Integration patterns
"""

## Test: Actors (Processes) (Line ~9)

"""
spawn: Creates a new process:
"""
test "actors_processes_1":
    let pid = spawn(fn():
        do_work()
        send(self(), :done)
    )
    assert_compiles()

## Test: Actors (Processes) (Line ~18)

"""
send: Sends an asynchronous message to a process:
"""
test "actors_processes_2":
    send(pid, "hello")
    send(pid, Msg(data))
    assert_compiles()

## Test: Actors (Processes) (Line ~27)

"""
receive: Waits for messages using pattern matching:
"""
test "actors_processes_3":
    receive:
        case "ping":
            print "pong"
        case ("add", x, y):
            print "{x} + {y} = {x+y}"
        case Msg(data):
            handle_data(data)
        case _:
            print "Got something"
    assert_compiles()

## Test: Actors (Processes) (Line ~41)

"""
```simple
receive:
    case "ping":
        print "pong"
    case ("add", x, y):
        print "{x} ...
"""
fn ping(pong_pid, count: i32):
    for i in range(count):
        send(pong_pid, "ping")
        receive:
            case "pong":
                print "Ping received pong"
    print "Ping finished"

fn pong():
    loop:
        receive:
            case "ping":
                print "Pong received ping"
                send(sender(), "pong")
            case :done:
                print "Pong finished"
                break loop

let pong_pid = spawn(fn(): pong())
spawn(fn(): ping(pong_pid, count: 3))
send(pong_pid, :done)

## Test: Async Effects and Stackless Coroutine Actors (Line ~9)

"""
A `async` function is guaranteed by the compiler not to block or spin forever:
"""
fn handle(msg: Msg) async:
    # guaranteed non-blocking
    ...

## Test: Async Effects and Stackless Coroutine Actors (Line ~27)

"""
Allowed loops (must be statically finite):
"""
test "async_effects_and_stackless_coroutine_actors_6":
    # OK: constant-bounded range
    for i in 0 .. 100:
        process(i)

    # OK: fixed-size array iteration
    let items: [i64; 10] = ...
    for elem in items:
        handle(elem)
    assert_compiles()

## Test: Async Effects and Stackless Coroutine Actors (Line ~49)

"""
Call rule: A `async` function may only call other `async` functions or whitelisted intrinsics.
"""
test "async_effects_and_stackless_coroutine_actors_7":
    actor Counter:
        state:
            value: i64 = 0

        on Inc(by: i64) async:
            self.value = self.value + by

        on Get(reply_to: Pid[i64]) async:
            send reply_to, self.value

        on Reset() async:
            self.value = 0
    assert_compiles()

## Test: Async Effects and Stackless Coroutine Actors (Line ~81)

"""
Multi-step behavior is modeled by storing state in `self` fields (state machines):
"""
test "async_effects_and_stackless_coroutine_actors_8":
    enum ParserMode:
        ReadingHeader
        ReadingBody
        Done

    actor StreamParser:
        state:
            mode: ParserMode = ParserMode.ReadingHeader
            buffer: Bytes = Bytes.empty()

        on Data(chunk: Bytes) async:
            match self.mode:
                case ReadingHeader:
                    self.buffer->append(chunk)
                    if header_complete(self.buffer):
                        self.mode = ParserMode.ReadingBody
                case ReadingBody:
                    self.buffer->append(chunk)
                    if body_complete(self.buffer):
                        self.mode = ParserMode.Done
                case Done:
                    pass
    assert_compiles()

## Test: Isolated Threads (Line ~14)

"""
1. No shared mutable state - Cannot access mutable globals
2. Copy or const only - Data must be copi...
"""
test "isolated_threads_9":
    let data = [1, 2, 3, 4, 5]
    let result_channel = Channel<i64>.new()

    spawn_isolated(data, result_channel) \copied_data, chan:
        let sum = copied_data.sum()
        chan.send(sum)

    let total = result_channel.recv()
    assert_compiles()

## Test: Isolated Threads (Line ~46)

"""
| Data Type | Reason |
|-----------|--------|
| Mutable globals | Would create data races |
| `stati...
"""
test "isolated_threads_10":
    let numbers = Channel<i64>.new()
    let results = Channel<str>.new()

    # Producer thread
    spawn_isolated(numbers) \out:
        for i in 0..100:
            out.send(i)
        out.close()

    # Consumer thread
    spawn_isolated(numbers, results) \inp, out:
        while let Some(n) = inp.recv():
            out.send("processed: {n}")
        out.close()

    for msg in results:
        print msg
    assert_compiles()

## Test: Futures and Promises (Line ~18)

"""
In threaded mode, futures execute in a background thread pool similar to JavaScript's event loop. Wh...
"""
test "futures_and_promises_11":
    # Futures run in background automatically
    let f1 = future(expensive_computation())
    let f2 = future(fetch_data())

    # await blocks until the future completes
    let result1 = await f1
    let result2 = await f2
    assert_compiles()

## Test: Futures and Promises (Line ~30)

"""
Configure the thread pool size:
"""
test "futures_and_promises_12":
    async_workers(8)  # Use 8 worker threads
    assert_compiles()

## Test: Futures and Promises (Line ~38)

"""
For embedded systems or game loops where you need precise control over when async work executes, use...
"""
test "futures_and_promises_13":
    # Set manual mode before creating any futures
    async_mode("manual")

    # Create futures - they don't execute yet
    let f1 = future(compute_physics())
    let f2 = future(update_ai())

    # In your main loop, poll futures explicitly
    fn game_loop():
        while running:
            # Poll individual futures
            poll_future(f1)
            poll_future(f2)

            # Or poll all pending futures
            poll_all_futures()

            # Check results
            if is_ready(f1):
                let physics = await f1

            render()
    assert_compiles()

## Test: Futures and Promises (Line ~77)

"""
| Function | Description |
|----------|-------------|
| `async_mode()` | Get current mode ("threaded...
"""
test "futures_and_promises_14":
    enum FutureState:
        Pending     # Not started
        Running     # Currently executing
        Fulfilled   # Completed successfully
        Rejected    # Completed with error
    assert_compiles()

## Test: Futures and Promises (Line ~87)

"""
```simple
enum FutureState:
    Pending     # Not started
    Running     # Currently executing
    ...
"""
test "futures_and_promises_15":
    # Create a future that computes a value
    let f = future(compute_value())

    # Create an already-resolved future
    let resolved = resolved(42)

    # Create an already-rejected future
    let rejected = rejected("error message")

    # Check if a future is ready
    if is_ready(f):
        let result = await f
    assert_compiles()

## Test: Futures and Promises (Line ~104)

"""
```simple
# Create a future that computes a value
let f = future(compute_value())
"""
fn fetch_data() async -> Data:
    let response = await http_get("https://api.example.com")
    return parse(response)

## Test: Futures and Promises (Line ~124)

"""
| Combinator | Description |
|------------|-------------|
| `then` | Transform result |
| `catch` | ...
"""
test "futures_and_promises_17":
    let futures = [get_a(), get_b(), get_c()]
    let all_results = Future.all(futures)
    let first = Future.race(futures)
    let first_success = Future.any(futures)
    assert_compiles()

## Test: Futures and Promises (Line ~133)

"""
```simple
let futures = [get_a(), get_b(), get_c()]
let all_results = Future.all(futures)
let first ...
"""
test "futures_and_promises_18":
    actor DataService:
        state:
            cache: Dict<String, Data> = {}

        on FetchData(key: String, reply_to: Pid) async:
            if key in self.cache:
                send reply_to, self.cache[key]
            else:
                let data = await fetch_from_remote(key)
                self.cache[key] = data
                send reply_to, data
    assert_compiles()

## Test: Futures and Promises (Line ~149)

"""
on FetchData(key: String, reply_to: Pid) async:
        if key in self.cache:
            send reply...
"""
fn request<T>(pid: Pid, msg: Msg) async -> T:
    let (future, promise) = promise<T>()
    send pid, Request(msg, promise)
    return await future

let result = await request(service_pid, GetData("key"))

## Test: Runtime Guards (Line ~7)

"""
When entering a `async` function, the runtime sets a thread-local flag:
"""
test "runtime_guards_20":
    TLS.current_context = Context.Async
    assert_compiles()

## Test: Runtime Guards (Line ~13)

"""
All blocking APIs check this flag:
"""
fn sleep(ms: i64):
    if TLS.current_context == Context.Async:
        panic("sleep() called from async context")

## Test: Failure Handling (Line ~5)

"""
In Erlang style, processes can monitor or link to each other:
"""
test "failure_handling_22":
    # Link processes (crash propagation)
    link(pid)

    # Monitor process (receive notification on crash)
    let monitor_ref = monitor(pid)

    receive:
        case Down(ref, pid, reason) if ref == monitor_ref:
            print "Process {pid} died: {reason}"
    assert_compiles()

## Test: Failure Handling (Line ~19)

"""
Supervisors can restart crashed processes:
"""
test "failure_handling_23":
    actor Supervisor:
        state:
            workers: List<Pid> = []

        on WorkerCrashed(pid: Pid, reason: Error) async:
            # Restart the worker
            let new_pid = spawn_worker()
            self.workers->replace(pid, new_pid)
    assert_compiles()

## Test: Note on Semantic Types (Line ~5)

"""
Actor message types and handler signatures should use semantic types:
"""
test "note_on_semantic_types_24":
    # Message types with semantic fields
    struct SpawnEnemy:
        pos: Position        # Not (f64, f64)
        hp: HitPoints        # Not i32

    struct DamageEnemy:
        target: EnemyId      # Not i64
        amount: Damage       # Not i32

    actor GameWorld:
        on SpawnEnemy(msg: SpawnEnemy) async:
            ...

        on DamageEnemy(msg: DamageEnemy) async:
            ...
    assert_compiles()

