#!/usr/bin/env simple
# Build Bootstrap Package (Simple)
# Creates a minimal runtime-only installation package
# Pure Simple implementation - replaces build-bootstrap.sh

# FFI declarations
extern fn rt_process_run(cmd: text, args: List<text>) -> (text, text, i32)
extern fn rt_platform_name() -> text
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_copy(src: text, dest: text) -> bool
extern fn rt_dir_create_all(path: text) -> bool
extern fn rt_env_cwd() -> text
extern fn rt_env_get(name: text) -> text?
extern fn rt_exit(code: i32)

fn run(cmd: text, args: List<text>) -> (text, text, i32):
    rt_process_run(cmd, args)

fn run_or_fail(cmd: text, args: List<text>) -> (text, text, i32):
    val (stdout, stderr, code) = rt_process_run(cmd, args)
    if code != 0:
        print "Error: '{cmd}' failed with exit code {code}"
        if stderr.trim() != "":
            print "  stderr: {stderr}"
        rt_exit(1)
    (stdout, stderr, code)

fn read_file(path: text) -> text:
    val result = rt_file_read_text(path)
    if val Some(content) = result:
        return content
    ""

fn main():
    print "Building Simple Bootstrap Package"
    print ""

    # Step 1: Detect platform (use TARGET env var for cross-compilation)
    val target_env = rt_env_get("TARGET")

    var os_name = ""
    var arch_name = ""

    if val Some(target) = target_env:
        if target.trim() != "":
            print "Using TARGET: {target}"
            # Parse Rust target triple: arch-vendor-os-abi (e.g. x86_64-unknown-linux-gnu)
            val parts = target.split("-")
            # Arch is first component
            arch_name = match parts[0]:
                "x86_64": "x86_64"
                "aarch64": "arm64"
                _: parts[0]
            # OS: find linux/darwin/windows in the triple
            if target.contains("linux"):
                os_name = "linux"
            elif target.contains("apple") or target.contains("darwin"):
                os_name = "darwin"
            elif target.contains("windows"):
                os_name = "windows"
            else:
                os_name = parts[2] ?? "unknown"

    if os_name == "":
        val platform_raw = rt_platform_name()
        os_name = match platform_raw:
            "linux": "linux"
            "macos": "darwin"
            "windows": "windows"
            _: platform_raw

    if arch_name == "":
        val (arch_stdout, _, _) = run("uname", ["-m"])
        val arch_raw = arch_stdout.trim()
        arch_name = match arch_raw:
            "x86_64": "x86_64"
            "amd64": "x86_64"
            "arm64": "arm64"
            "aarch64": "arm64"
            _: arch_raw

    val platform = "{os_name}-{arch_name}"
    print "Platform: {platform}"
    print ""

    # Step 2: Get version
    var version = ""
    if rt_file_exists("VERSION"):
        version = read_file("VERSION").trim()
    else:
        val cargo_content = read_file("rust/driver/Cargo.toml")
        for line in cargo_content.split("\n"):
            if line.starts_with("version = "):
                version = line.split("\"")[1]
                break

    print "Version: {version}"
    print ""

    val output = "simple-bootstrap-{version}-{platform}.spk"

    # Step 3: Build optimized runtime
    print "Step 1/7: Building optimized runtime..."
    val cwd = rt_env_cwd()

    # Check if we have a previous Simple runtime to use (self-hosting build)
    val prev_runtime_env = rt_env_get("SIMPLE_RUNTIME")
    var use_simple_build = false
    var prev_runtime_path = ""

    if val Some(runtime) = prev_runtime_env:
        if runtime.trim() != "":
            prev_runtime_path = runtime.trim()
            if rt_file_exists(prev_runtime_path):
                print "Using previous Simple runtime for self-hosting build"
                print "  Runtime: {prev_runtime_path}"
                use_simple_build = true

    var runtime_path = "rust/target/release-opt/simple"
    if val Some(target) = target_env:
        if target.trim() != "":
            runtime_path = "rust/target/{target.trim()}/release-opt/simple"

    if use_simple_build:
        # Self-hosting build using Simple build system
        print "Building with Simple (self-hosting)..."
        val (_, stderr, code) = run(prev_runtime_path, ["src/app/build/main.spl", "--bootstrap", "--quiet"])

        if code != 0:
            print "⚠ Self-hosting build failed, falling back to cargo"
            print "  stderr: {stderr}"
            use_simple_build = false
        else:
            print "✓ Self-hosting build succeeded"

    if not use_simple_build:
        # Fallback to cargo build (bootstrap from scratch)
        print "Building with cargo (bootstrap from scratch)..."
        var cargo_args = ["build", "--profile", "release-opt", "--quiet", "--manifest-path", "{cwd}/rust/Cargo.toml"]

        if val Some(target) = target_env:
            if target.trim() != "":
                cargo_args = cargo_args.merge(["--target", target.trim()])

        run_or_fail("cargo", cargo_args)

    if not rt_file_exists(runtime_path):
        print "Error: Runtime binary not found at {runtime_path}"
        rt_exit(1)

    print "✓ Runtime built"
    print ""

    # Step 4: Create package structure
    print "Step 2/7: Creating package structure..."
    val tmp_dir = "/tmp/simple-bootstrap-ssh"
    run("rm", ["-rf", tmp_dir])
    rt_dir_create_all("{tmp_dir}/bin")
    rt_dir_create_all("{tmp_dir}/lib/simple/stdlib")
    rt_dir_create_all("{tmp_dir}/lib/simple/app")
    print "✓ Directory structure created"
    print ""

    # Step 5: Copy runtime binary
    print "Step 3/7: Copying runtime binary..."
    rt_file_copy(runtime_path, "{tmp_dir}/bin/simple")
    run("chmod", ["755", "{tmp_dir}/bin/simple"])
    print "✓ Runtime copied"
    print ""

    # Step 6: Copy stdlib files
    print "Step 4/7: Copying stdlib files..."
    val stdlib_files = ["core.spl", "io.spl", "json.spl", "http.spl"]
    var stdlib_copied = 0

    for f in stdlib_files:
        if rt_file_exists("src/std/{f}"):
            rt_file_copy("src/std/{f}", "{tmp_dir}/lib/simple/stdlib/{f}")
            print "  ✓ {f}"
            stdlib_copied = stdlib_copied + 1
        elif rt_file_exists("src/std/src/{f}"):
            rt_file_copy("src/std/src/{f}", "{tmp_dir}/lib/simple/stdlib/{f}")
            print "  ✓ {f} (from src/)"
            stdlib_copied = stdlib_copied + 1

    if stdlib_copied == 0:
        if rt_file_exists("src/std/src"):
            print "  ℹ Copying stdlib directory structure..."
            run("cp", ["-r", "src/std/src/.", "{tmp_dir}/lib/simple/stdlib/"])
            print "  ✓ Stdlib directory copied"
        else:
            print "  ⚠ Note: Stdlib may be embedded in runtime binary"
    print ""

    # Step 7: Copy essential apps
    print "Step 5/7: Copying essential apps..."
    val app_dirs = ["cli", "run", "compile", "check", "repl"]

    for app in app_dirs:
        if rt_file_exists("src/app/{app}"):
            run("cp", ["-r", "src/app/{app}", "{tmp_dir}/lib/simple/app/"])
            print "  ✓ {app}/"
        else:
            print "  ⚠ Warning: {app}/ not found"
    print ""

    # Step 8: Generate manifest
    print "Step 6/7: Generating manifest..."

    var commit = "unknown"
    val (git_stdout, _, git_code) = run("git", ["rev-parse", "--short", "HEAD"])
    if git_code == 0:
        commit = git_stdout.trim()

    val (ts_stdout, _, _) = run("date", ["-u", "+%Y-%m-%dT%H:%M:%SZ"])
    val timestamp = ts_stdout.trim()

    val (stat_stdout, _, stat_code) = run("stat", ["-c%s", runtime_path])
    var runtime_size = "0"
    if stat_code == 0:
        runtime_size = stat_stdout.trim()
    else:
        # macOS fallback
        val (mac_stdout, _, mac_code) = run("stat", ["-f%z", runtime_path])
        if mac_code == 0:
            runtime_size = mac_stdout.trim()

    val manifest = "package:\n  name: simple-bootstrap\n  version: {version}\n  type: bootstrap\n  platform: {platform}\n\nbuild:\n  timestamp: {timestamp}\n  profile: release-opt\n  commit: {commit}\n\nruntime:\n  binary: simple\n  size: {runtime_size}\n  checksum: sha256:placeholder\n\ncontents:\n  stdlib: [\n    core.spl,\n    io.spl,\n    json.spl,\n    http.spl\n  ]\n\n  apps: [\n    cli,\n    run,\n    compile,\n    check,\n    repl\n  ]\n\ninstall:\n  default_prefix: ~/.local\n  system_prefix: /usr/local\n\n  binaries:\n    - name: simple\n      target: bin/simple\n      type: executable\n\n  paths:\n    runtime: lib/simple/\n    stdlib: lib/simple/stdlib/\n    apps: lib/simple/app/"

    rt_file_write_text("{tmp_dir}/manifest.sdn", manifest)
    print "✓ Manifest generated"
    print ""

    # Step 9: Create SPK archive
    print "Step 7/7: Creating SPK archive..."
    run_or_fail("tar", ["-czf", output, "-C", tmp_dir, "."])

    print "✓ Package created: {output}"
    print ""

    # Cleanup
    run("rm", ["-rf", tmp_dir])

    # Summary
    print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print "✓ Bootstrap package built successfully"
    print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print ""
    print "Package:  {output}"
    print "Platform: {platform}"
    print "Version:  {version}"
    print ""
    print "To install:"
    print "  tar -xzf {output} -C /tmp/simple-test"
    print "  export PATH=\"/tmp/simple-test/bin:$PATH\""
    print ""
