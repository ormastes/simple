#!/usr/bin/env simple
# Distribution Package Builder Script
#
# Usage:
#   simple script/package-dist.spl [OPTIONS]
#
# Options:
#   --version=VERSION        Package version (default: auto-detect from simple.sdn)
#   --profile=PROFILE        Build profile (default: bootstrap)
#   --platform=PLATFORM      Build specific platform (default: all)
#   --bootstrap-only         Build only bootstrap packages
#   --full-only              Build only full packages
#   --compress               Compress binaries with UPX
#   --help                   Show this help

use app.io.{shell, rt_file_exists, rt_file_read_text, rt_dir_create}
use std.platform.{platform_name}

# ===========================================================================
# Configuration
# ===========================================================================

class Config:
    version: text
    profile: text
    platform: text           # "all" or specific platform
    package_type: text       # "bootstrap", "full", or "both"
    compress: bool
    target_dir: text

fn parse_args(args: [text]) -> Config:
    var config = Config(
        version: get_version_from_sdn(),
        profile: "bootstrap",
        platform: "all",
        package_type: "both",
        compress: false,
        target_dir: "dist"
    )

    for arg in args:
        if arg.starts_with("--version="):
            config.version = arg.substring(10)
        elif arg.starts_with("--profile="):
            config.profile = arg.substring(10)
        elif arg.starts_with("--platform="):
            config.platform = arg.substring(11)
        elif arg == "--bootstrap-only":
            config.package_type = "bootstrap"
        elif arg == "--full-only":
            config.package_type = "full"
        elif arg == "--compress":
            config.compress = true
        elif arg == "--help":
            print_help()
            exit(0)

    config

fn get_version_from_sdn() -> text:
    if rt_file_exists("simple.sdn"):
        val content = rt_file_read_text("simple.sdn")
        val lines = content.split("\n")
        for line in lines:
            if line.contains("version:"):
                val parts = line.split(":")
                if parts.len() >= 2:
                    return parts[1].trim()
    "0.5.0"  # Default

fn print_help():
    print "Distribution Package Builder"
    print ""
    print "Usage:"
    print "  simple script/package-dist.spl [OPTIONS]"
    print ""
    print "Options:"
    print "  --version=VERSION        Package version (default: auto-detect)"
    print "  --profile=PROFILE        Build profile (default: bootstrap)"
    print "  --platform=PLATFORM      Build specific platform (linux-x86_64, etc.)"
    print "  --bootstrap-only         Build only bootstrap packages"
    print "  --full-only              Build only full packages"
    print "  --compress               Compress binaries with UPX"
    print "  --help                   Show this help"
    print ""
    print "Examples:"
    print "  simple script/package-dist.spl"
    print "  simple script/package-dist.spl --platform=linux-x86_64"
    print "  simple script/package-dist.spl --bootstrap-only --compress"

# ===========================================================================
# Platform Definitions
# ===========================================================================

val platforms = [
    ("linux-x86_64", "x86_64-unknown-linux-gnu"),
    ("linux-aarch64", "aarch64-unknown-linux-gnu"),
    ("darwin-x86_64", "x86_64-apple-darwin"),
    ("darwin-arm64", "aarch64-apple-darwin"),
    ("windows-x86_64", "x86_64-pc-windows-msvc"),
    ("windows-aarch64", "aarch64-pc-windows-msvc")
]

# ===========================================================================
# Package Builder
# ===========================================================================

fn build_packages(config: Config):
    print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print "Simple Distribution Package Builder"
    print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print ""
    print "Configuration:"
    print "  Version:  {config.version}"
    print "  Profile:  {config.profile}"
    print "  Platform: {config.platform}"
    print "  Type:     {config.package_type}"
    print "  Compress: {config.compress}"
    print ""

    # Create output directory
    rt_dir_create(config.target_dir)

    # Determine which platforms to build
    val platforms_to_build = if config.platform == "all":
        platforms
    else:
        platforms.filter(\(name, triple): name == config.platform)

    if platforms_to_build.len() == 0:
        print "Error: Unknown platform '{config.platform}'"
        print "Available platforms: {platforms.map(\(name, _): name).join(', ')}"
        exit(1)

    # Build for each platform
    var success_count = 0
    var total_count = 0

    for (platform, triple) in platforms_to_build:
        total_count = total_count + 1

        print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        print "Building: {platform}"
        print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

        val result = build_platform(config, platform, triple)
        if result:
            success_count = success_count + 1
        print ""

    # Summary
    print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print "Summary"
    print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print "  Success: {success_count}/{total_count} platform(s)"
    print "  Output:  {config.target_dir}/"
    print ""

    if success_count > 0:
        print "✓ Package(s) built successfully!"
        list_packages(config.target_dir)
    else:
        print "✗ No packages built"
        exit(1)

fn build_platform(config: Config, platform: text, triple: text) -> bool:
    # Find runtime binary
    val runtime_path = find_runtime_binary(config.profile, triple, platform)
    if runtime_path.len() == 0:
        print "  ✗ Runtime binary not found"
        print "    Build it first with: simple build --profile={config.profile} --target={triple}"
        return false

    print "  Runtime: {runtime_path}"

    # Build bootstrap package
    if config.package_type == "bootstrap" or config.package_type == "both":
        print "  Building bootstrap package..."
        val bootstrap_ok = build_bootstrap_package(config, platform, runtime_path)
        if not bootstrap_ok:
            print "  ✗ Bootstrap package failed"
            return false

    # Build full package
    if config.package_type == "full" or config.package_type == "both":
        print "  Building full package..."
        val full_ok = build_full_package(config, platform, runtime_path)
        if not full_ok:
            print "  ✗ Full package failed"
            return false

    print "  ✓ Package(s) built successfully"
    true

fn find_runtime_binary(profile: text, triple: text, platform: text) -> text:
    val ext = if platform.starts_with("windows"): ".exe" else: ""

    # Try different locations
    val candidates = [
        "rust/target/{triple}/{profile}/simple{ext}",
        "rust/target/{profile}/simple{ext}",
        "bin/release/simple{ext}"
    ]

    for candidate in candidates:
        if rt_file_exists(candidate):
            return candidate

    ""

fn build_bootstrap_package(config: Config, platform: text, runtime_path: text) -> bool:
    val pkg_name = "simple-bootstrap-{config.version}-{platform}.tar.gz"
    val stage_dir = "{config.target_dir}/stage-bootstrap-{platform}"

    # Create staging directory
    shell("rm -rf {stage_dir}")
    rt_dir_create(stage_dir)

    # Copy runtime
    val ext = if platform.starts_with("windows"): ".exe" else: ""
    rt_dir_create("{stage_dir}/bin")
    shell("cp {runtime_path} {stage_dir}/bin/simple{ext}")

    # Strip if not Windows
    if not platform.starts_with("windows"):
        shell("strip {stage_dir}/bin/simple{ext} 2>/dev/null")

    # Compress if requested
    if config.compress:
        val upx_check = shell("which upx 2>/dev/null")
        if upx_check.exit_code == 0:
            print "    Compressing with UPX..."
            shell("upx --best --lzma {stage_dir}/bin/simple{ext} 2>/dev/null")

    # Copy minimal Simple code
    shell("cp -r lib {stage_dir}/ 2>/dev/null")
    shell("cp -r examples {stage_dir}/ 2>/dev/null")
    shell("cp README.md {stage_dir}/ 2>/dev/null")
    shell("cp LICENSE {stage_dir}/ 2>/dev/null")

    # Create archive
    val tar_result = shell("tar -czf {config.target_dir}/{pkg_name} -C {stage_dir} .")
    if tar_result.exit_code != 0:
        print "    ✗ tar failed: {tar_result.stderr}"
        return false

    # Generate checksum
    shell("sha256sum {config.target_dir}/{pkg_name} > {config.target_dir}/{pkg_name}.sha256")

    # Cleanup
    shell("rm -rf {stage_dir}")

    print "    ✓ {pkg_name}"
    true

fn build_full_package(config: Config, platform: text, runtime_path: text) -> bool:
    val pkg_name = "simple-full-{config.version}-{platform}.tar.gz"
    val stage_dir = "{config.target_dir}/stage-full-{platform}"

    # Create staging directory
    shell("rm -rf {stage_dir}")
    rt_dir_create(stage_dir)

    # Copy runtime
    val ext = if platform.starts_with("windows"): ".exe" else: ""
    rt_dir_create("{stage_dir}/bin")
    shell("cp {runtime_path} {stage_dir}/bin/simple{ext}")

    # Strip if not Windows
    if not platform.starts_with("windows"):
        shell("strip {stage_dir}/bin/simple{ext} 2>/dev/null")

    # Copy all Simple source (NO rust/)
    shell("cp -r src {stage_dir}/ 2>/dev/null")
    shell("cp -r lib {stage_dir}/ 2>/dev/null")
    shell("cp -r examples {stage_dir}/ 2>/dev/null")
    shell("cp -r doc {stage_dir}/ 2>/dev/null")
    shell("cp README.md {stage_dir}/ 2>/dev/null")
    shell("cp LICENSE {stage_dir}/ 2>/dev/null")
    shell("cp CHANGELOG.md {stage_dir}/ 2>/dev/null")
    shell("cp simple.sdn {stage_dir}/ 2>/dev/null")

    # Create archive
    val tar_result = shell("tar -czf {config.target_dir}/{pkg_name} -C {stage_dir} .")
    if tar_result.exit_code != 0:
        print "    ✗ tar failed: {tar_result.stderr}"
        return false

    # Generate checksum
    shell("sha256sum {config.target_dir}/{pkg_name} > {config.target_dir}/{pkg_name}.sha256")

    # Cleanup
    shell("rm -rf {stage_dir}")

    print "    ✓ {pkg_name}"
    true

fn list_packages(dir: text):
    print "Packages:"
    val ls_result = shell("ls -lh {dir}/*.tar.gz 2>/dev/null")
    if ls_result.exit_code == 0:
        print ls_result.stdout
    else:
        print "  (no packages found)"

fn exit(code: i32):
    # TODO: Implement proper exit
    pass

# ===========================================================================
# Main
# ===========================================================================

fn main():
    use std.env.args

    val config = parse_args(args())
    build_packages(config)
