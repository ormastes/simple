# Call Event Recorder
# Records function calls during test execution for diagram generation
#
# Features:
# - Ordered event log with sequence numbers
# - Timestamp tracking (microseconds from test start)
# - Caller/callee relationships with class context
# - Argument and return value capture
# - Call stack depth tracking

import core.{time, Option, List, Dict, Set}

# Call type enumeration
enum CallType:
    Direct      # Direct function call
    Method      # Method call on object
    FFI         # Foreign function interface call
    Closure     # Closure/lambda invocation
    Constructor # Constructor call (new)

impl CallType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_direct() -> bool:
        """Check if this is Direct call type.

        Returns:
            true for Direct

        Example:
            CallType::Direct.is_direct()  # → true
        """
        match self:
            case Direct: true
            case _: false

    fn is_method() -> bool:
        """Check if this is Method call type.

        Returns:
            true for Method

        Example:
            CallType::Method.is_method()  # → true
        """
        match self:
            case Method: true
            case _: false

    fn is_ffi() -> bool:
        """Check if this is FFI call type.

        Returns:
            true for FFI

        Example:
            CallType::FFI.is_ffi()  # → true
        """
        match self:
            case FFI: true
            case _: false

    fn is_closure() -> bool:
        """Check if this is Closure call type.

        Returns:
            true for Closure

        Example:
            CallType::Closure.is_closure()  # → true
        """
        match self:
            case Closure: true
            case _: false

    fn is_constructor() -> bool:
        """Check if this is Constructor call type.

        Returns:
            true for Constructor

        Example:
            CallType::Constructor.is_constructor()  # → true
        """
        match self:
            case Constructor: true
            case _: false

    fn is_foreign() -> bool:
        """Check if call crosses language boundary.

        Returns:
            true for FFI

        Example:
            CallType::FFI.is_foreign()  # → true
            CallType::Direct.is_foreign()  # → false
        """
        match self:
            case FFI: true
            case _: false

    fn is_object_oriented() -> bool:
        """Check if call is object-oriented.

        Returns:
            true for Method and Constructor

        Example:
            CallType::Method.is_object_oriented()  # → true
            CallType::Direct.is_object_oriented()  # → false
        """
        match self:
            case Method: true
            case Constructor: true
            case _: false

    fn is_functional() -> bool:
        """Check if call is functional style.

        Returns:
            true for Closure

        Example:
            CallType::Closure.is_functional()  # → true
        """
        match self:
            case Closure: true
            case _: false

    fn to_string() -> String:
        """Convert call type to string.

        Returns:
            Call type name

        Example:
            CallType::Method.to_string()  # → "method"
        """
        match self:
            case Direct: "direct"
            case Method: "method"
            case FFI: "ffi"
            case Closure: "closure"
            case Constructor: "constructor"

    fn description() -> String:
        """Get call type description.

        Returns:
            Human-readable description

        Example:
            CallType::FFI.description()
            # → "Foreign function interface call"
        """
        match self:
            case Direct: "Direct function call"
            case Method: "Method call on object"
            case FFI: "Foreign function interface call"
            case Closure: "Closure/lambda invocation"
            case Constructor: "Constructor call (new)"

    fn summary() -> String:
        """Get summary of call type.

        Returns:
            Human-readable summary

        Example:
            CallType::Method.summary()
            # → "CallType: method (object-oriented)"
        """
        let name = self.to_string()
        let category = if self.is_object_oriented():
                           "object-oriented"
                       else if self.is_functional():
                           "functional"
                       else if self.is_foreign():
                           "foreign"
                       else:
                           "procedural"
        return "CallType: {name} ({category})"

# Single call event in the execution trace
struct CallEvent:
    sequence_num: u64       # Global ordering within test
    timestamp_us: u64       # Microseconds from recording start
    caller: String          # Caller function/method name
    callee: String          # Called function/method name
    caller_class: Option<String>  # Caller's class if method
    callee_class: Option<String>  # Callee's class if method
    arguments: List<String>       # Argument values as strings
    return_value: Option<String>  # Return value as string (set on return)
    call_type: CallType           # Type of call
    depth: u32                    # Call stack depth
    is_return: Bool               # True if this is a return event

    # Create a call entry event
    fn new_call(seq: u64, ts: u64, caller: String, callee: String,
                caller_cls: Option<String>, callee_cls: Option<String>,
                args: List<String>, call_type: CallType, depth: u32) -> CallEvent:
        return CallEvent {
            sequence_num: seq,
            timestamp_us: ts,
            caller: caller,
            callee: callee,
            caller_class: caller_cls,
            callee_class: callee_cls,
            arguments: args,
            return_value: None,
            call_type: call_type,
            depth: depth,
            is_return: false,
        }

    # Create a return event
    fn new_return(seq: u64, ts: u64, caller: String, callee: String,
                  caller_cls: Option<String>, callee_cls: Option<String>,
                  ret_val: Option<String>, depth: u32) -> CallEvent:
        return CallEvent {
            sequence_num: seq,
            timestamp_us: ts,
            caller: caller,
            callee: callee,
            caller_class: caller_cls,
            callee_class: callee_cls,
            arguments: [],
            return_value: ret_val,
            call_type: CallType.Direct,
            depth: depth,
            is_return: true,
        }

    # Get participant name for sequence diagram (class.method or just function)
    fn get_caller_participant() -> String:
        match self.caller_class:
            case Some(cls):
                return cls
            case None:
                return self.caller

    fn get_callee_participant() -> String:
        match self.callee_class:
            case Some(cls):
                return cls
            case None:
                return self.callee

    # Format call for display
    fn format_call() -> String:
        let args_str = self.arguments.join(", ")
        match self.callee_class:
            case Some(cls):
                return "${cls}.${self.callee}(${args_str})"
            case None:
                return "${self.callee}(${args_str})"

    fn format_return() -> String:
        match self.return_value:
            case Some(val):
                return val
            case None:
                return "(void)"

# Stack frame for tracking call depth
struct StackFrame:
    function_name: String
    class_name: Option<String>
    entry_time_us: u64

# Call event recorder - collects events during test execution
class CallEventRecorder:
    test_name: String
    events: List<CallEvent>
    call_stack: List<StackFrame>
    sequence_counter: u64
    start_time_us: u64
    classes_seen: Set<String>
    architectural_entities: Set<String>
    is_recording: Bool

    fn new(test_name: String) -> CallEventRecorder:
        return CallEventRecorder {
            test_name: test_name,
            events: [],
            call_stack: [],
            sequence_counter: 0,
            start_time_us: time.now_us(),
            classes_seen: Set.new(),
            architectural_entities: Set.new(),
            is_recording: true,
        }

    # Start recording (resets state)
    fn start(mut self) -> Void:
        self.events = []
        self.call_stack = []
        self.sequence_counter = 0
        self.start_time_us = time.now_us()
        self.classes_seen = Set.new()
        self.architectural_entities = Set.new()
        self.is_recording = true

    # Stop recording
    fn stop(mut self) -> Void:
        self.is_recording = false

    # Get elapsed time in microseconds
    fn elapsed_us() -> u64:
        return time.now_us() - self.start_time_us

    # Get current call stack depth
    fn current_depth() -> u32:
        return self.call_stack.len() as u32

    # Get current caller (top of stack)
    fn current_caller() -> Option<StackFrame>:
        if self.call_stack.is_empty():
            return None
        return Some(self.call_stack.last())

    # Record a function call entry
    fn record_call(mut self, callee: String, callee_class: Option<String>,
                   args: List<String>, call_type: CallType) -> Void:
        if not self.is_recording:
            return

        let ts = self.elapsed_us()
        let depth = self.current_depth()

        # Get caller info from stack
        let (caller, caller_class) = match self.current_caller():
            case Some(frame):
                (frame.function_name, frame.class_name)
            case None:
                ("(test)", None)

        # Track classes
        match callee_class:
            case Some(cls):
                self.classes_seen.insert(cls)
            case None:
                pass
        match caller_class:
            case Some(cls):
                self.classes_seen.insert(cls)
            case None:
                pass

        # Create and store event
        let event = CallEvent.new_call(
            self.sequence_counter,
            ts,
            caller,
            callee,
            caller_class,
            callee_class,
            args,
            call_type,
            depth
        )
        self.events.push(event)
        self.sequence_counter += 1

        # Push onto call stack
        let frame = StackFrame {
            function_name: callee,
            class_name: callee_class,
            entry_time_us: ts,
        }
        self.call_stack.push(frame)

    # Record a function return
    fn record_return(mut self, return_value: Option<String>) -> Void:
        if not self.is_recording:
            return
        if self.call_stack.is_empty():
            return

        let ts = self.elapsed_us()
        let frame = self.call_stack.pop()
        let depth = self.current_depth()

        # Get caller info (now the top of stack after pop)
        let (caller, caller_class) = match self.current_caller():
            case Some(f):
                (f.function_name, f.class_name)
            case None:
                ("(test)", None)

        let event = CallEvent.new_return(
            self.sequence_counter,
            ts,
            caller,
            frame.function_name,
            caller_class,
            frame.class_name,
            return_value,
            depth
        )
        self.events.push(event)
        self.sequence_counter += 1

    # Mark an entity as architectural
    fn mark_architectural(mut self, entity: String) -> Void:
        self.architectural_entities.insert(entity)

    # Check if entity is architectural
    fn is_architectural(entity: String) -> Bool:
        return self.architectural_entities.contains(entity)

    # Get all recorded events
    fn get_events() -> List<CallEvent>:
        return self.events

    # Get all classes seen in the trace
    fn get_classes() -> Set<String>:
        return self.classes_seen

    # Get architectural entities
    fn get_architectural_entities() -> Set<String>:
        return self.architectural_entities

    # Get event count
    fn event_count() -> u64:
        return self.events.len() as u64

    # Clear all recorded events
    fn clear(mut self) -> Void:
        self.events = []
        self.call_stack = []
        self.sequence_counter = 0
        self.classes_seen = Set.new()

# Global recorder instance (per-test context)
let _current_recorder: Option<CallEventRecorder> = None

# Get or create recorder for current test
fn get_recorder() -> CallEventRecorder:
    match _current_recorder:
        case Some(rec):
            return rec
        case None:
            let rec = CallEventRecorder.new("(unnamed)")
            _current_recorder = Some(rec)
            return rec

# Set recorder for a specific test
fn set_recorder(recorder: CallEventRecorder) -> Void:
    _current_recorder = Some(recorder)

# Clear current recorder
fn clear_recorder() -> Void:
    _current_recorder = None

# Convenience functions for recording
fn record_call(callee: String, args: List<String>) -> Void:
    get_recorder().record_call(callee, None, args, CallType.Direct)

fn record_method_call(class_name: String, method: String, args: List<String>) -> Void:
    get_recorder().record_call(method, Some(class_name), args, CallType.Method)

fn record_return(value: Option<String>) -> Void:
    get_recorder().record_return(value)

fn record_ffi_call(callee: String, args: List<String>) -> Void:
    get_recorder().record_call(callee, None, args, CallType.FFI)

# Exports
export CallType, CallEvent, StackFrame, CallEventRecorder
export get_recorder, set_recorder, clear_recorder
export record_call, record_method_call, record_return, record_ffi_call
