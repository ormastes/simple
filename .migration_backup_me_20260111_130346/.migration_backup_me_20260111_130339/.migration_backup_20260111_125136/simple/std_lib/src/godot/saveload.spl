# Godot Save/Load System
#
# Type-safe wrappers for Godot's file I/O and configuration
#
# Features:
# - ConfigFile (INI-style save files)
# - FileAccess (binary and text file I/O)
# - Save game management
# - Settings persistence
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_configfile.html

import godot.ffi
import godot.variant

mod saveload

# Config File
# INI-style configuration and save files
pub struct ConfigFile:
    ptr: ffi.GDExtensionObjectPtr

impl ConfigFile:
    # Create new config file
    pub fn new() -> ConfigFile:
        let ptr = ffi.godot_new_object("ConfigFile")
        return ConfigFile(ptr: ptr)

    # Load from file
    pub fn load(path: String) -> Result[ConfigFile, String]:
        let mut config = ConfigFile::new()
        let result = config.load_file(path)

        if result.is_ok():
            return Ok(config)
        else:
            return Err(result.unwrap_err())

    # Load file (instance method)
    fn load_file(mut self, path: String) -> Result[(), String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let path_var = variant.Variant::from_string(path)
        let result = obj.call1("load", path_var)

        let error_code = result.as_int()
        if error_code == 0:  # OK
            return Ok(())
        else:
            return Err("Failed to load config: error {error_code}")

    # Save to file
    pub fn save(self, path: String) -> Result[(), String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let path_var = variant.Variant::from_string(path)
        let result = obj.call1("save", path_var)

        let error_code = result.as_int()
        if error_code == 0:
            return Ok(())
        else:
            return Err("Failed to save config: error {error_code}")

    # Set value
    pub fn set_value(mut self, section: String, key: String, value: variant.Variant):
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        obj.call3("set_value", section_var, key_var, value)

    # Get value
    pub fn get_value(self, section: String, key: String, default: variant.Variant) -> variant.Variant:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        return obj.call3("get_value", section_var, key_var, default)

    # Check if has section
    pub fn has_section(self, section: String) -> bool:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let result = obj.call1("has_section", section_var)
        return result.as_bool()

    # Check if has key
    pub fn has_section_key(self, section: String, key: String) -> bool:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        let result = obj.call2("has_section_key", section_var, key_var)
        return result.as_bool()

    # Erase section
    pub fn erase_section(mut self, section: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        obj.call1("erase_section", section_var)

    # Erase key
    pub fn erase_section_key(mut self, section: String, key: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        obj.call2("erase_section_key", section_var, key_var)

    # Get all sections
    pub fn get_sections(self) -> Array[String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_sections")
        # TODO: [stdlib][P2] Parse PackedStringArray
        return []  # Placeholder

    # Get all keys in section
    pub fn get_section_keys(self, section: String) -> Array[String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let result = obj.call1("get_section_keys", section_var)
        # TODO: [stdlib][P2] Parse PackedStringArray
        return []  # Placeholder

    # Clear all data
    pub fn clear(mut self):
        let obj = variant.Object::from_ptr(self.ptr)
        obj.call0("clear")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> bool:
        """Check if config file has no sections.

        Returns:
            true if empty

        Example:
            config.is_empty()  # → false
        """
        return self.get_sections().len() == 0

    fn has_key(section: String, key: String) -> bool:
        """Check if section and key exist (alias for has_section_key).

        Args:
            section: Section name
            key: Key name

        Returns:
            true if exists

        Example:
            config.has_key("player", "name")  # → true
        """
        return self.has_section_key(section, key)

    fn try_save(path: String) -> bool:
        """Try to save config, returning true on success.

        Args:
            path: File path

        Returns:
            true if saved successfully

        Example:
            config.try_save("user://config.cfg")  # → true
        """
        return self.save(path).is_ok()

    fn remove_section(mut self, section: String):
        """Remove a section (alias for erase_section).

        Args:
            section: Section name

        Example:
            config.remove_section("old_data")
        """
        self.erase_section(section)

    fn remove_key(mut self, section: String, key: String):
        """Remove a key (alias for erase_section_key).

        Args:
            section: Section name
            key: Key name

        Example:
            config.remove_key("player", "old_stat")
        """
        self.erase_section_key(section, key)

    fn summary() -> String:
        """Get config file summary.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # → "ConfigFile: 3 sections"
        """
        let count = self.get_sections().len()
        return "ConfigFile: {count} sections"


# File Access
# Low-level file I/O
pub struct FileAccess:
    ptr: ffi.GDExtensionObjectPtr

impl FileAccess:
    # Open file for reading
    pub fn open_read(path: String) -> Result[FileAccess, String]:
        return FileAccess::open(path, ModeFlags::Read)

    # Open file for writing
    pub fn open_write(path: String) -> Result[FileAccess, String]:
        return FileAccess::open(path, ModeFlags::Write)

    # Open file with mode
    pub fn open(path: String, mode: ModeFlags) -> Result[FileAccess, String]:
        let path_var = variant.Variant::from_string(path)
        let mode_var = variant.Variant::from_int(mode as i64)
        
        # TODO: [stdlib][P3] Call FileAccess::open static method
        # let result = call_static("FileAccess", "open", path_var, mode_var)

        # For now, create dummy instance
        let ptr = ffi.godot_new_object("FileAccess")
        return Ok(FileAccess(ptr: ptr))

    # Check if file exists
    pub fn file_exists(path: String) -> bool:
        let path_var = variant.Variant::from_string(path)
        # TODO: [stdlib][P3] Call FileAccess::file_exists static method
        return false  # Placeholder

    # Read entire file as string
    pub fn get_as_text(self) -> String:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_as_text")
        return result.as_string()

    # Store string to file
    pub fn store_string(mut self, text: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let text_var = variant.Variant::from_string(text)
        obj.call1("store_string", text_var)

    # Read line
    pub fn get_line(self) -> String:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_line")
        return result.as_string()

    # Store line
    pub fn store_line(mut self, line: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let line_var = variant.Variant::from_string(line)
        obj.call1("store_line", line_var)

    # Read 32-bit integer
    pub fn get_32(self) -> i32:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_32")
        return result.as_int() as i32

    # Store 32-bit integer
    pub fn store_32(mut self, value: i32):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_int(value as i64)
        obj.call1("store_32", val_var)

    # Read 64-bit integer
    pub fn get_64(self) -> i64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_64")
        return result.as_int()

    # Store 64-bit integer
    pub fn store_64(mut self, value: i64):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_int(value)
        obj.call1("store_64", val_var)

    # Read float
    pub fn get_float(self) -> f32:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_float")
        return result.as_float() as f32

    # Store float
    pub fn store_float(mut self, value: f32):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_float(value as f64)
        obj.call1("store_float", val_var)

    # Read double
    pub fn get_double(self) -> f64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_double")
        return result.as_float()

    # Store double
    pub fn store_double(mut self, value: f64):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_float(value)
        obj.call1("store_double", val_var)

    # Check if at end of file
    pub fn eof_reached(self) -> bool:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("eof_reached")
        return result.as_bool()

    # Get file position
    pub fn get_position(self) -> i64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_position")
        return result.as_int()

    # Seek to position
    pub fn seek(mut self, position: i64):
        let obj = variant.Object::from_ptr(self.ptr)
        let pos_var = variant.Variant::from_int(position)
        obj.call1("seek", pos_var)

    # Get file length
    pub fn get_length(self) -> i64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_length")
        return result.as_int()

    # Close file
    pub fn close(mut self):
        let obj = variant.Object::from_ptr(self.ptr)
        obj.call0("close")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_eof() -> bool:
        """Check if at end of file (alias for eof_reached).

        Returns:
            true if at EOF

        Example:
            file.is_eof()  # → false
        """
        return self.eof_reached()

    fn has_more_data() -> bool:
        """Check if more data is available (not at EOF).

        Returns:
            true if not at EOF

        Example:
            file.has_more_data()  # → true
        """
        return not self.eof_reached()

    fn get_size() -> i64:
        """Get file length (alias for get_length).

        Returns:
            File size in bytes

        Example:
            file.get_size()  # → 1024
        """
        return self.get_length()

    fn is_empty() -> bool:
        """Check if file is empty (length is 0).

        Returns:
            true if empty

        Example:
            file.is_empty()  # → false
        """
        return self.get_length() == 0

    fn at_start() -> bool:
        """Check if at start of file (position is 0).

        Returns:
            true if at start

        Example:
            file.at_start()  # → true
        """
        return self.get_position() == 0

    fn seek_start(mut self):
        """Seek to start of file (position 0).

        Example:
            file.seek_start()
        """
        self.seek(0)

    fn seek_end(mut self):
        """Seek to end of file.

        Example:
            file.seek_end()
        """
        self.seek(self.get_length())

    fn read_text() -> String:
        """Read entire file as text (alias for get_as_text).

        Returns:
            File contents as string

        Example:
            text = file.read_text()
        """
        return self.get_as_text()

    fn write_text(mut self, text: String):
        """Write text to file (alias for store_string).

        Args:
            text: Text to write

        Example:
            file.write_text("Hello, World!")
        """
        self.store_string(text)

    fn write_line(mut self, line: String):
        """Write line to file (alias for store_line).

        Args:
            line: Line to write

        Example:
            file.write_line("log entry")
        """
        self.store_line(line)

    fn summary() -> String:
        """Get file access summary.

        Returns:
            Human-readable summary

        Example:
            file.summary()
            # → "FileAccess: size=1024, pos=512"
        """
        let size = self.get_length()
        let pos = self.get_position()
        return "FileAccess: size={size}, pos={pos}"


# File Mode Flags
pub enum ModeFlags:
    Read = 1
    Write = 2
    ReadWrite = 3
    WriteRead = 7

impl ModeFlags:
    pub fn to_string(self) -> String:
        """Convert mode flags to string."""
        match self:
            case Read: "Read"
            case Write: "Write"
            case ReadWrite: "ReadWrite"
            case WriteRead: "WriteRead"

    pub fn description(self) -> String:
        """Get mode flags description."""
        match self:
            case Read: "Read-only file access"
            case Write: "Write-only file access (creates/truncates file)"
            case ReadWrite: "Read and write file access"
            case WriteRead: "Write and read file access with creation"

    pub fn is_read(self) -> bool:
        """Check if mode is Read."""
        match self:
            case Read: true
            case _: false

    pub fn is_write(self) -> bool:
        """Check if mode is Write."""
        match self:
            case Write: true
            case _: false

    pub fn is_read_write(self) -> bool:
        """Check if mode is ReadWrite."""
        match self:
            case ReadWrite: true
            case _: false

    pub fn is_write_read(self) -> bool:
        """Check if mode is WriteRead."""
        match self:
            case WriteRead: true
            case _: false

    pub fn can_read(self) -> bool:
        """Check if mode allows reading."""
        match self:
            case Read: true
            case ReadWrite: true
            case WriteRead: true
            case _: false

    pub fn can_write(self) -> bool:
        """Check if mode allows writing."""
        match self:
            case Write: true
            case ReadWrite: true
            case WriteRead: true
            case _: false

    pub fn is_read_only(self) -> bool:
        """Check if mode is read-only (cannot write)."""
        match self:
            case Read: true
            case _: false

    pub fn is_write_only(self) -> bool:
        """Check if mode is write-only (cannot read)."""
        match self:
            case Write: true
            case _: false

    pub fn flag_value(self) -> i32:
        """Get the numeric flag value for Godot FileAccess API."""
        match self:
            case Read: 1
            case Write: 2
            case ReadWrite: 3
            case WriteRead: 7

    pub fn summary(self) -> String:
        """Get mode flags summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.can_read():
            props.push("read")
        if self.can_write():
            props.push("write")
        if self.is_read_only():
            props.push("read-only")
        if self.is_write_only():
            props.push("write-only")
        let flag = self.flag_value()
        props.push("flag={flag}")
        if props.len() > 0:
            let props_str = ", ".join(props)
            return "ModeFlags: {name} ({desc}, {props_str})"
        else:
            return "ModeFlags: {name} ({desc})"


# Save Game Manager
# High-level save/load API
pub struct SaveGameManager:
    save_dir: String
    current_slot: i32

impl SaveGameManager:
    # Create new save manager
    pub fn new(save_dir: String = "user://saves/") -> SaveGameManager:
        return SaveGameManager(save_dir: save_dir, current_slot: 0)

    # Get save file path
    fn get_save_path(slot: i32) -> String:
        return "{self.save_dir}save_{slot}.cfg"

    # Save game state
    pub fn save_game(mut self, slot: i32, data: SaveData) -> Result[(), String]:
        let mut config = ConfigFile::new()

        # Player data
        config.set_value("player", "name", variant.Variant::from_string(data.player_name))
        config.set_value("player", "level", variant.Variant::from_int(data.player_level as i64))
        config.set_value("player", "health", variant.Variant::from_int(data.player_health as i64))
        config.set_value("player", "position_x", variant.Variant::from_float(data.position_x))
        config.set_value("player", "position_y", variant.Variant::from_float(data.position_y))

        # Game progress
        config.set_value("progress", "current_scene", variant.Variant::from_string(data.current_scene))
        config.set_value("progress", "playtime", variant.Variant::from_float(data.playtime))

        # Save to file
        let path = self.get_save_path(slot)
        let result = config.save(path)

        if result.is_ok():
            self.current_slot = slot
            println("Game saved to slot {slot}")
            return Ok(())
        else:
            return Err(result.unwrap_err())

    # Load game state
    pub fn load_game(mut self, slot: i32) -> Result[SaveData, String]:
        let path = self.get_save_path(slot)
        let result = ConfigFile::load(path)

        if result.is_err():
            return Err(result.unwrap_err())

        let config = result.unwrap()

        # Load player data
        let default_str = variant.Variant::from_string("")
        let default_int = variant.Variant::from_int(0)
        let default_float = variant.Variant::from_float(0.0)

        let name = config.get_value("player", "name", default_str).as_string()
        let level = config.get_value("player", "level", default_int).as_int() as i32
        let health = config.get_value("player", "health", default_int).as_int() as i32
        let pos_x = config.get_value("player", "position_x", default_float).as_float()
        let pos_y = config.get_value("player", "position_y", default_float).as_float()

        # Load progress
        let scene = config.get_value("progress", "current_scene", default_str).as_string()
        let playtime = config.get_value("progress", "playtime", default_float).as_float()

        let data = SaveData(
            player_name: name,
            player_level: level,
            player_health: health,
            position_x: pos_x,
            position_y: pos_y,
            current_scene: scene,
            playtime: playtime
        )

        self.current_slot = slot
        println("Game loaded from slot {slot}")

        return Ok(data)

    # Check if save exists
    pub fn has_save(self, slot: i32) -> bool:
        let path = self.get_save_path(slot)
        return FileAccess::file_exists(path)

    # Delete save
    pub fn delete_save(mut self, slot: i32) -> Result[(), String]:
        """Delete a save file.

        Args:
            slot: Save slot number

        Returns:
            Ok if successful, Err with message if failed
        """
        @extern("runtime", "rt_file_remove")
        fn _rt_file_remove(path_ptr: &u8, path_len: u64) -> bool

        let path = self.get_save_path(slot)
        let success = _rt_file_remove(path.ptr(), path.len())

        if success:
            return Ok(())
        else:
            return Err("Failed to delete save file: {path}")

    # Get all save slots
    pub fn get_save_slots(self) -> Array[i32]:
        let mut slots: Array[i32] = []

        for i in range(0, 10):
            if self.has_save(i):
                slots.push(i)

        return slots

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_slot_empty(slot: i32) -> bool:
        """Check if save slot is empty (no save file).

        Args:
            slot: Save slot number

        Returns:
            true if slot is empty

        Example:
            manager.is_slot_empty(0)  # → false
        """
        return not self.has_save(slot)

    fn try_save_game(mut self, slot: i32, data: SaveData) -> bool:
        """Try to save game, returning true on success.

        Args:
            slot: Save slot number
            data: Save data to write

        Returns:
            true if saved successfully

        Example:
            manager.try_save_game(0, data)  # → true
        """
        return self.save_game(slot, data).is_ok()

    fn try_load_game(mut self, slot: i32) -> Option[SaveData]:
        """Try to load game, returning None on failure.

        Args:
            slot: Save slot number

        Returns:
            Option containing save data or None

        Example:
            if let Some(data) = manager.try_load_game(0):
                # Use data
        """
        let result = self.load_game(slot)
        if result.is_ok():
            return Some(result.unwrap())
        else:
            return None

    fn try_delete_save(mut self, slot: i32) -> bool:
        """Try to delete save, returning true on success.

        Args:
            slot: Save slot number

        Returns:
            true if deleted successfully

        Example:
            manager.try_delete_save(0)  # → true
        """
        return self.delete_save(slot).is_ok()

    fn get_current_slot() -> i32:
        """Get the currently active save slot.

        Returns:
            Current slot number

        Example:
            manager.get_current_slot()  # → 0
        """
        return self.current_slot

    fn has_any_saves() -> bool:
        """Check if there are any save files.

        Returns:
            true if at least one save exists

        Example:
            manager.has_any_saves()  # → true
        """
        return self.get_save_slots().len() > 0

    fn count_saves() -> i32:
        """Count the number of save files.

        Returns:
            Number of saves

        Example:
            manager.count_saves()  # → 3
        """
        return self.get_save_slots().len()

    fn summary() -> String:
        """Get save game manager summary.

        Returns:
            Human-readable summary

        Example:
            manager.summary()
            # → "SaveGameManager: 3 saves, current=0"
        """
        let count = self.count_saves()
        let current = self.current_slot
        return "SaveGameManager: {count} saves, current={current}"


# Save Data Structure
pub struct SaveData:
    # Player data
    player_name: String
    player_level: i32
    player_health: i32
    position_x: f64
    position_y: f64

    # Game progress
    current_scene: String
    playtime: f64


# Settings Manager
# Persistent game settings
pub struct SettingsManager:
    config: ConfigFile
    config_path: String

impl SettingsManager:
    # Create new settings manager
    pub fn new(config_path: String = "user://settings.cfg") -> SettingsManager:
        let mut config = ConfigFile::new()
        let _ = config.load_file(config_path)  # Ignore error if file doesn't exist

        return SettingsManager(config: config, config_path: config_path)

    # Get setting
    pub fn get_setting(self, key: String, default: variant.Variant) -> variant.Variant:
        return self.config.get_value("settings", key, default)

    # Set setting
    pub fn set_setting(mut self, key: String, value: variant.Variant):
        self.config.set_value("settings", key, value)

    # Save settings
    pub fn save(self) -> Result[(), String]:
        return self.config.save(self.config_path)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get(key: String, default: variant.Variant) -> variant.Variant:
        """Get setting value (alias for get_setting).

        Args:
            key: Setting key
            default: Default value if not found

        Returns:
            Setting value or default

        Example:
            volume = settings.get("volume", Variant::from_int(100))
        """
        return self.get_setting(key, default)

    fn set(mut self, key: String, value: variant.Variant):
        """Set setting value (alias for set_setting).

        Args:
            key: Setting key
            value: Setting value

        Example:
            settings.set("volume", Variant::from_int(80))
        """
        self.set_setting(key, value)

    fn try_save() -> bool:
        """Try to save settings, returning true on success.

        Returns:
            true if saved successfully

        Example:
            settings.try_save()  # → true
        """
        return self.save().is_ok()

    fn has_setting(key: String) -> bool:
        """Check if setting exists.

        Args:
            key: Setting key

        Returns:
            true if setting exists

        Example:
            settings.has_setting("volume")  # → true
        """
        return self.config.has_section_key("settings", key)

    fn summary() -> String:
        """Get settings manager summary.

        Returns:
            Human-readable summary

        Example:
            settings.summary()
            # → "SettingsManager: path=user://settings.cfg"
        """
        return "SettingsManager: path={self.config_path}"


# Array placeholder
pub struct Array[T]:
    items: Vec[T]

impl[T] Array[T]:
    pub fn push(mut self, item: T):
        pass
