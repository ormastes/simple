# Unit tests for grammar testing framework

import spec.{describe, it, expect}
import parser.treesitter.grammar_test as gt
import parser.treesitter.{TreeSitterParser}

describe("GrammarTestCase"):
    it("creates test case"):
        let test = gt.GrammarTestCase.new(
            "test function",
            "simple",
            "fn main(): return 1",
            "source_file"
        )

        expect(test.name).to_equal("test function")
        expect(test.language).to_equal("simple")
        expect(test.should_error).to_be(false)

    it("adds structure expectation"):
        let test = gt.GrammarTestCase.new(
            "test",
            "simple",
            "let x = 1",
            "source_file"
        ).with_structure(gt.TreeStructure.new("source_file"))

        expect(test.expected_structure.is_some()).to_be(true)

    it("marks as expecting error"):
        let test = gt.GrammarTestCase.new(
            "test",
            "simple",
            "fn broken(",
            "source_file"
        ).expect_error()

        expect(test.should_error).to_be(true)

describe("TreeStructure"):
    it("creates tree structure"):
        let structure = gt.TreeStructure.new("function_def")

        expect(structure.kind).to_equal("function_def")
        expect(structure.children.len()).to_equal(0)

    it("adds children"):
        let structure = gt.TreeStructure.new("source_file")
            .with_child(gt.TreeStructure.new("function_def"))

        expect(structure.children.len()).to_equal(1)

    it("adds fields"):
        let structure = gt.TreeStructure.new("function_def")
            .with_field("name", gt.TreeStructure.new("identifier"))

        expect(structure.fields.contains_key("name")).to_be(true)

describe("GrammarTestResult"):
    it("creates success result"):
        let result = gt.GrammarTestResult.success("test", 10.5)

        expect(result.passed).to_be(true)
        expect(result.error_message.is_none()).to_be(true)
        expect(result.parse_time_ms).to_equal(10.5)

    it("creates failure result"):
        let result = gt.GrammarTestResult.failure("test", "error message", 5.0)

        expect(result.passed).to_be(false)
        expect(result.error_message.is_some()).to_be(true)

describe("GrammarTestSuite"):
    it("creates test suite"):
        let suite = gt.GrammarTestSuite.new("My Tests")

        expect(suite.name).to_equal("My Tests")
        expect(suite.tests.len()).to_equal(0)

    it("adds tests"):
        let mut suite = gt.GrammarTestSuite.new("My Tests")

        let test = gt.GrammarTestCase.new(
            "test",
            "simple",
            "let x = 1",
            "source_file"
        )

        suite.add_test(test)

        expect(suite.tests.len()).to_equal(1)

    it("runs test suite"):
        let mut suite = gt.GrammarTestSuite.new("Simple Tests")

        # Add a simple test
        suite.add_test(gt.GrammarTestCase.new(
            "parse let statement",
            "simple",
            "let x = 42\n",
            "source_file"
        ))

        let result = suite.run()

        expect(result.passed_count).to_be_greater_than(0)

describe("run_test"):
    it("runs successful test"):
        let test = gt.GrammarTestCase.new(
            "simple function",
            "simple",
            "fn main(): return 1\n",
            "source_file"
        )

        let result = gt.run_test(test)

        expect(result.passed).to_be(true)

    it("runs test expecting error"):
        let test = gt.GrammarTestCase.new(
            "broken function",
            "simple",
            "fn broken(\n",
            "source_file"
        ).expect_error()

        let result = gt.run_test(test)

        # Should pass because we expect error
        expect(result.passed).to_be(true)

    it("fails when kind mismatch"):
        let test = gt.GrammarTestCase.new(
            "test",
            "simple",
            "let x = 1\n",
            "wrong_kind"  # Wrong expected kind
        )

        let result = gt.run_test(test)

        expect(result.passed).to_be(false)

describe("GrammarTestBuilder"):
    it("builds test suite"):
        let builder = gt.GrammarTestBuilder.new()
            .test("test1", "simple", "let x = 1\n", "source_file")
            .test("test2", "simple", "let y = 2\n", "source_file")

        let suite = builder.build()

        expect(suite.tests.len()).to_equal(2)

    it("builds test with structure"):
        let structure = gt.TreeStructure.new("source_file")

        let builder = gt.GrammarTestBuilder.new()
            .test_with_structure(
                "test",
                "simple",
                "let x = 1\n",
                structure
            )

        let suite = builder.build()

        expect(suite.tests.len()).to_equal(1)
        expect(suite.tests[0].expected_structure.is_some()).to_be(true)

    it("builds error test"):
        let builder = gt.GrammarTestBuilder.new()
            .test_error("broken", "simple", "fn broken(")

        let suite = builder.build()

        expect(suite.tests.len()).to_equal(1)
        expect(suite.tests[0].should_error).to_be(true)

describe("GrammarSnapshot"):
    it("creates snapshot from parse"):
        let snapshot = gt.GrammarSnapshot.from_parse(
            "simple function",
            "fn main(): return 1\n",
            "simple"
        ).unwrap()

        expect(snapshot.name).to_equal("simple function")
        expect(snapshot.source).to_equal("fn main(): return 1\n")
        expect(snapshot.tree_repr.len()).to_be_greater_than(0)

    it("verifies unchanged snapshot"):
        let snapshot = gt.GrammarSnapshot.from_parse(
            "test",
            "let x = 42\n",
            "simple"
        ).unwrap()

        let matches = snapshot.verify("simple").unwrap()

        expect(matches).to_be(true)

describe("tree_to_string"):
    it("converts tree to string"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\n"
        let tree = parser.parse(source).unwrap()

        let tree_str = gt.tree_to_string(tree.root_node, tree, 0)

        expect(tree_str.len()).to_be_greater_than(0)
        expect(tree_str.contains("source_file")).to_be(true)

describe("GrammarCorpus"):
    it("creates corpus"):
        let corpus = gt.GrammarCorpus.new("Simple Corpus", "simple")

        expect(corpus.name).to_equal("Simple Corpus")
        expect(corpus.language).to_equal("simple")

    it("adds files"):
        let mut corpus = gt.GrammarCorpus.new("Test", "simple")

        let file = gt.CorpusTestFile.new(
            "test.spl",
            "let x = 1\n"
        )

        corpus.add_file(file)

        expect(corpus.test_files.len()).to_equal(1)

    it("runs corpus"):
        let mut corpus = gt.GrammarCorpus.new("Simple Files", "simple")

        # Add some test files
        corpus.add_file(gt.CorpusTestFile.new(
            "test1.spl",
            "fn add(x: Int, y: Int): return x + y\n"
        ))

        corpus.add_file(gt.CorpusTestFile.new(
            "test2.spl",
            "class Point:\n    x: Int\n    y: Int\n"
        ))

        let result = corpus.run()

        expect(result.passed_count).to_be_greater_than(0)

describe("CorpusTestFile"):
    it("creates corpus file"):
        let file = gt.CorpusTestFile.new("test.spl", "let x = 1\n")

        expect(file.path).to_equal("test.spl")
        expect(file.expected_no_errors).to_be(true)

    it("allows errors"):
        let file = gt.CorpusTestFile.new("broken.spl", "fn broken(")
            .allow_errors()

        expect(file.expected_no_errors).to_be(false)

describe("count_errors"):
    it("counts no errors in valid tree"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42\n"
        let tree = parser.parse(source).unwrap()

        let error_count = gt.count_errors(tree.root_node, tree)

        expect(error_count).to_equal(0)

    it("counts errors in invalid tree"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn broken(\n"
        let tree = parser.parse(source).unwrap()

        let error_count = gt.count_errors(tree.root_node, tree)

        expect(error_count).to_be_greater_than(0)

describe("Integration"):
    it("runs complete test suite"):
        let suite = gt.GrammarTestBuilder.new()
            .test("let statement", "simple", "let x = 1\n", "source_file")
            .test("function", "simple", "fn main(): return 1\n", "source_file")
            .test("class", "simple", "class Point:\n    x: Int\n", "source_file")
            .test_error("broken", "simple", "fn broken(")
            .build()

        let result = suite.run()

        expect(result.passed_count).to_be_greater_than(0)
        expect(result.all_passed()).to_be(true)

describe("Example Usage"):
    it("demonstrates fluent API"):
        # Build test suite with fluent API
        let suite = gt.GrammarTestBuilder.new()
            # Valid code
            .test("arithmetic", "simple", "let x = 1 + 2 * 3\n", "source_file")
            .test("if statement", "simple", "if x > 0:\n    print(\"positive\")\n", "source_file")
            .test("match", "simple", "match x:\n    case 0: print(\"zero\")\n", "source_file")

            # Error cases
            .test_error("missing colon", "simple", "fn broken()\n    return 1")
            .test_error("unclosed paren", "simple", "let x = add(1, 2")

            .build()

        let result = suite.run()

        expect(result.all_passed()).to_be(true)

    it("demonstrates corpus testing"):
        let mut corpus = gt.GrammarCorpus.new("Example Files", "simple")

        # Add various test files
        corpus.add_file(gt.CorpusTestFile.new(
            "functions.spl",
            """
fn add(x: Int, y: Int) -> Int:
    return x + y

fn multiply(x: Int, y: Int) -> Int:
    return x * y
"""
        ))

        corpus.add_file(gt.CorpusTestFile.new(
            "classes.spl",
            """
class Counter:
    count: Int

    fn increment(mut self):
        self.count = self.count + 1
"""
        ))

        let result = corpus.run()

        expect(result.passed_count).to_equal(2)
