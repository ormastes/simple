# Unit tests for Simple language grammar

import spec.{describe, it, expect}
import parser.treesitter.grammar_simple as grammar_simple
import parser.treesitter.{TreeSitterParser}

describe("SimpleGrammar"):
    it("creates Simple grammar"):
        let grammar = grammar_simple.SimpleGrammar.new()

        expect(grammar.get_grammar().language).to_equal("simple")

    it("has source_file as entry rule"):
        let grammar = grammar_simple.SimpleGrammar.new()
        let g = grammar.get_grammar()

        expect(g.has_rule("source_file")).to_be(true)

describe("Function Definitions"):
    it("parses simple function"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn add(x: Int, y: Int) -> Int:\n    return x + y\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses function without return type"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn greet(name: String):\n    print(name)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses function with no parameters"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn main():\n    print(\"Hello\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Class Definitions"):
    it("parses simple class"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "class Point:\n    x: Int\n    y: Int\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses class with methods"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "class Counter:\n    count: Int\n    fn increment(mut self):\n        self.count = self.count + 1\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses generic class"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "class Box<T>:\n    value: T\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Struct Definitions"):
    it("parses simple struct"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "struct Rectangle:\n    width: Float\n    height: Float\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Enum Definitions"):
    it("parses simple enum"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "enum Color:\n    Red\n    Green\n    Blue\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses enum with tuple variants"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "enum Option<T>:\n    Some(T)\n    None\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses enum with struct variants"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "enum Shape:\n    Circle { radius: Float }\n    Rectangle { width: Float, height: Float }\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Import Statements"):
    it("parses simple import"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "import math\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses import with path"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "import std.collections.list\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses import with alias"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "import math as m\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Let Statements"):
    it("parses simple let"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses let with type annotation"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x: Int = 42\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses mutable let"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let mut count: Int = 0\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("If Statements"):
    it("parses simple if"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "if x > 0:\n    print(\"positive\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses if-else"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "if x > 0:\n    print(\"positive\")\nelse:\n    print(\"non-positive\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses if-elif-else"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "if x > 0:\n    print(\"positive\")\nelif x < 0:\n    print(\"negative\")\nelse:\n    print(\"zero\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Match Statements"):
    it("parses simple match"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match x:\n    case 0: print(\"zero\")\n    case _: print(\"other\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses match with enum patterns"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match option:\n    case Some(value): print(value)\n    case None: print(\"nothing\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses match with guard"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match x:\n    case n if n > 0: print(\"positive\")\n    case _: print(\"other\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Loop Statements"):
    it("parses for loop"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "for i in 0..10:\n    print(i)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses while loop"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "while x < 10:\n    x = x + 1\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses infinite loop"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "loop:\n    print(\"infinite\")\n    break\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Expressions"):
    it("parses binary expressions"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let result = x + y * z\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses unary expressions"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let neg = -x\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses call expressions"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let result = add(1, 2)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses index expressions"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let item = list[0]\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses field access"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = point.x\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses lambda expressions"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let add = |x, y| x + y\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Literals"):
    it("parses integer literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses float literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let pi = 3.14159\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses string literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let msg = \"Hello, World!\"\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses f-string literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let msg = f\"x = {x}\"\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses boolean literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let flag = true\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses nil literal"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let nothing = nil\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses array literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let numbers = [1, 2, 3, 4, 5]\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses tuple literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let pair = (1, 2)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses dict literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let ages = {\"Alice\": 30, \"Bob\": 25}\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses struct literals"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let p = Point(x: 10, y: 20)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Patterns"):
    it("parses identifier patterns"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match x:\n    case value: print(value)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses wildcard patterns"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match x:\n    case _: print(\"anything\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses tuple patterns"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match pair:\n    case (x, y): print(x, y)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses struct patterns"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match point:\n    case Point(x: px, y: py): print(px, py)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses enum patterns"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "match option:\n    case Some(val): print(val)\n    case None: print(\"nothing\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Types"):
    it("parses named types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x: Int = 42\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses generic types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let list: List<Int> = [1, 2, 3]\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses function types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let f: fn(Int, Int) -> Int = add\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses tuple types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let pair: (Int, String) = (1, \"one\")\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses array types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let numbers: [Int] = [1, 2, 3]\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses dict types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let ages: {String: Int} = {\"Alice\": 30}\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses option types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let maybe: Int? = Some(42)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

    it("parses result types"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let result: Int! = Ok(42)\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Complex Programs"):
    it("parses complete program"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = """
import std.io

class Counter:
    count: Int

    fn new() -> Counter:
        Counter(count: 0)

    fn increment(mut self):
        self.count = self.count + 1

    fn get() -> Int:
        return self.count

fn main():
    let mut counter = Counter.new()
    counter.increment()
    io.println(f"Count: {counter.get()}")
"""
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.kind).to_equal("source_file")

describe("Error Recovery"):
    it("recovers from missing colon"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn broken()\n    return 42\n"
        let tree = parser.parse(source).unwrap()

        # Should have ERROR node but still parse
        expect(tree.root_node.has_error).to_be(true)

    it("recovers from unclosed paren"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = add(1, 2\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.has_error).to_be(true)

    it("recovers from unexpected token"):
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn test(): return @ 42\n"
        let tree = parser.parse(source).unwrap()

        expect(tree.root_node.has_error).to_be(true)
