///
Module: sdn.document

Editable SDN document API with formatting preservation.

Provides:
- Document wrapper for parsed SDN
- Path-based mutation (set, delete, push)
- Serialization (to_sdn, to_json)
- File I/O (from_file, write_file)
- Modification tracking

Usage:
    import sdn.document
    let doc = SdnDocument.parse("name: Alice\nage: 30")
    doc.set("age", SdnValue.Int(31))
    let sdn_text = doc.to_sdn()
///

import error.{SdnError, Span}
import parser.parse
import value.SdnValue
import serializer.{to_sdn, to_json}

# Public exports
export SdnDocument

/// Editable SDN document that preserves formatting where possible
class SdnDocument:
    source: String           # Original source text
    root: SdnValue          # Parsed value tree
    modified: Bool          # Track if document has been modified

    fn parse(source: String) -> Result[SdnDocument, SdnError]:
        """Parse source into an editable document"""
        match parse(source):
            case Ok(root):
                return Ok(SdnDocument(
                    source: source,
                    root: root,
                    modified: False
                ))
            case Err(e):
                return Err(e)

    fn from_file(path: String) -> Result[SdnDocument, SdnError]:
        """Load document from file"""
        match fs.read_to_string(path):
            case Ok(source):
                return SdnDocument.parse(source)
            case Err(e):
                return Err(SdnError.IoError(message: e.to_string()))

    fn root() -> SdnValue:
        """Get the root value"""
        return self.root

    fn root_mut(mut self) -> SdnValue:
        """Get mutable root value"""
        self.modified = True
        return self.root

    fn get(path: String) -> Option[SdnValue]:
        """Get value at path (e.g., \"server.port\")"""
        return self.root.get_path(path)

    fn get_mut(mut self, path: String) -> Option[SdnValue]:
        """Get mutable value at path"""
        self.modified = True
        return self.root.get_path_mut(path)

    fn set(mut self, path: String, value: SdnValue) -> Result[Nil, SdnError]:
        """Set value at path"""
        self.modified = True

        let parts = path.split(".")

        if parts.len == 0:
            return Err(SdnError.PathNotFound(path: path))

        if parts.len == 1:
            # Direct child of root
            match self.root:
                case SdnValue.Dict(mut dict):
                    dict[parts[0]] = value
                    return Ok(nil)
                case _:
                    return Err(SdnError.TypeMismatch(
                        expected: "dict",
                        found: self.root.type_name()
                    ))

        # Navigate to parent
        let parent_path = parts[0..parts.len-1].join(".")
        let key = parts[parts.len - 1]

        match self.root.get_path_mut(parent_path):
            case Some(parent):
                match parent:
                    case SdnValue.Dict(mut dict):
                        dict[key] = value
                        return Ok(nil)
                    case _:
                        return Err(SdnError.TypeMismatch(
                            expected: "dict",
                            found: parent.type_name()
                        ))
            case None:
                return Err(SdnError.PathNotFound(path: path))

    fn delete(mut self, path: String) -> Result[Nil, SdnError]:
        """Delete value at path"""
        self.modified = True

        let parts = path.split(".")

        if parts.len == 0:
            return Err(SdnError.PathNotFound(path: path))

        if parts.len == 1:
            # Direct child of root
            match self.root:
                case SdnValue.Dict(mut dict):
                    if dict.contains_key(parts[0]):
                        dict.remove(parts[0])
                        return Ok(nil)
                    else:
                        return Err(SdnError.PathNotFound(path: path))
                case _:
                    return Err(SdnError.PathNotFound(path: path))

        # Navigate to parent
        let parent_path = parts[0..parts.len-1].join(".")
        let key = parts[parts.len - 1]

        match self.root.get_path_mut(parent_path):
            case Some(parent):
                match parent:
                    case SdnValue.Dict(mut dict):
                        if dict.contains_key(key):
                            dict.remove(key)
                            return Ok(nil)
                        else:
                            return Err(SdnError.PathNotFound(path: path))
                    case _:
                        return Err(SdnError.PathNotFound(path: path))
            case None:
                return Err(SdnError.PathNotFound(path: path))

    fn push(mut self, path: String, value: SdnValue) -> Result[Nil, SdnError]:
        """Push value to array at path"""
        self.modified = True

        match self.root.get_path_mut(path):
            case Some(mut arr):
                if arr.push(value):
                    return Ok(nil)
                else:
                    return Err(SdnError.TypeMismatch(
                        expected: "array",
                        found: arr.type_name()
                    ))
            case None:
                return Err(SdnError.PathNotFound(path: path))

    fn is_modified() -> Bool:
        """Check if document was modified"""
        return self.modified

    fn to_sdn() -> String:
        """Render document back to SDN string"""
        return to_sdn(self.root)

    fn to_json() -> String:
        """Render document as JSON string"""
        return to_json(self.root)

    fn write_file(path: String) -> Result[Nil, SdnError]:
        """Write document to file"""
        let content = self.to_sdn()
        match fs.write(path, content):
            case Ok(_):
                return Ok(nil)
            case Err(e):
                return Err(SdnError.IoError(message: e.to_string()))
