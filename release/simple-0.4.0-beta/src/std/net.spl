# Network I/O
#
# TCP/UDP sockets, HTTP client, and URL parsing.
# Provides network communication primitives for Simple programs.
#
# Components:
# - TcpListener: TCP server socket
# - TcpStream: TCP client connection
# - UdpSocket: UDP datagram socket
# - HttpClient: HTTP/HTTPS client
# - Url: URL parsing and manipulation
#
# Usage:
#   val listener = TcpListener.bind("127.0.0.1:8080")?
#   val stream = listener.accept()?
#   stream.write("HTTP/1.1 200 OK\r\n\r\n")
#
# Architecture:
# - Non-blocking I/O with timeout support
# - Zero-copy where possible
# - Cross-platform (Linux, macOS, Windows)
# - IPv4 and IPv6 support

use std.error.*

# ============================================================================
# TcpListener - TCP Server Socket
# ============================================================================

class TcpListener:
    """TCP server socket.

    Listens for incoming TCP connections.

    Example:
        val listener = TcpListener.bind("127.0.0.1:8080")?
        while true:
            val stream = listener.accept()?
            handle_client(stream)
    """
    handle: [u8]?

    static fn bind(addr: text) -> Result<TcpListener, SimpleError>:
        """Bind to address and start listening.

        Args:
            addr: Address in format "host:port"

        Returns:
            Result with TcpListener or error

        Example:
            val listener = TcpListener.bind("0.0.0.0:8080")?
        """
        tcp_listener_bind(addr)

    fn accept() -> Result<TcpStream, SimpleError>:
        """Accept incoming connection.

        Returns:
            Result with TcpStream or error

        Blocks until connection arrives.
        """
        tcp_listener_accept(self)

    fn accept_timeout(timeout_ms: i64) -> Result<TcpStream, SimpleError>:
        """Accept with timeout.

        Args:
            timeout_ms: Timeout in milliseconds

        Returns:
            Result with TcpStream or timeout error
        """
        tcp_listener_accept_timeout(self, timeout_ms)

    fn local_addr() -> text?:
        """Get local address.

        Returns:
            Some(address) or None
        """
        tcp_listener_local_addr(self)

    fn set_nonblocking(nonblocking: bool) -> bool:
        """Set non-blocking mode.

        Args:
            nonblocking: true for non-blocking

        Returns:
            true on success
        """
        tcp_listener_set_nonblocking(self, nonblocking)

    me close():
        """Close listener."""
        tcp_listener_close(self)

# ============================================================================
# TcpStream - TCP Connection
# ============================================================================

class TcpStream:
    """TCP connection stream.

    Bidirectional TCP connection.

    Example:
        val stream = TcpStream.connect("example.com:80")?
        stream.write("GET / HTTP/1.1\r\n\r\n")
        val response = stream.read(1024)?
    """
    handle: [u8]?

    static fn connect(addr: text) -> Result<TcpStream, SimpleError>:
        """Connect to remote address.

        Args:
            addr: Address in format "host:port"

        Returns:
            Result with TcpStream or error

        Example:
            val stream = TcpStream.connect("127.0.0.1:8080")?
        """
        tcp_stream_connect(addr)

    static fn connect_timeout(addr: text, timeout_ms: i64) -> Result<TcpStream, SimpleError>:
        """Connect with timeout.

        Args:
            addr: Address in format "host:port"
            timeout_ms: Timeout in milliseconds

        Returns:
            Result with TcpStream or timeout error
        """
        tcp_stream_connect_timeout(addr, timeout_ms)

    fn read(size: usize) -> Result<[u8], SimpleError>:
        """Read bytes from stream.

        Args:
            size: Maximum bytes to read

        Returns:
            Result with bytes or error

        Blocks until data available.
        """
        tcp_stream_read(self, size)

    fn read_exact(size: usize) -> Result<[u8], SimpleError>:
        """Read exact number of bytes.

        Args:
            size: Exact bytes to read

        Returns:
            Result with bytes or error

        Blocks until all bytes read.
        """
        tcp_stream_read_exact(self, size)

    fn read_line() -> Result<text, SimpleError>:
        """Read line from stream.

        Returns:
            Result with line (including newline) or error
        """
        tcp_stream_read_line(self)

    fn write(data: [u8]) -> Result<usize, SimpleError>:
        """Write bytes to stream.

        Args:
            data: Bytes to write

        Returns:
            Result with bytes written or error
        """
        tcp_stream_write(self, data)

    fn write_all(data: [u8]) -> Result<(), SimpleError>:
        """Write all bytes.

        Args:
            data: Bytes to write

        Returns:
            Result or error

        Blocks until all bytes written.
        """
        tcp_stream_write_all(self, data)

    fn flush() -> Result<(), SimpleError>:
        """Flush write buffer.

        Returns:
            Result or error
        """
        tcp_stream_flush(self)

    fn peer_addr() -> text?:
        """Get remote peer address.

        Returns:
            Some(address) or None
        """
        tcp_stream_peer_addr(self)

    fn local_addr() -> text?:
        """Get local address.

        Returns:
            Some(address) or None
        """
        tcp_stream_local_addr(self)

    fn set_read_timeout(timeout_ms: i64?) -> bool:
        """Set read timeout.

        Args:
            timeout_ms: Timeout in ms or None for blocking

        Returns:
            true on success
        """
        tcp_stream_set_read_timeout(self, timeout_ms)

    fn set_write_timeout(timeout_ms: i64?) -> bool:
        """Set write timeout.

        Args:
            timeout_ms: Timeout in ms or None for blocking

        Returns:
            true on success
        """
        tcp_stream_set_write_timeout(self, timeout_ms)

    fn set_nodelay(nodelay: bool) -> bool:
        """Set TCP_NODELAY (disable Nagle's algorithm).

        Args:
            nodelay: true to disable Nagle

        Returns:
            true on success
        """
        tcp_stream_set_nodelay(self, nodelay)

    fn set_nonblocking(nonblocking: bool) -> bool:
        """Set non-blocking mode.

        Args:
            nonblocking: true for non-blocking

        Returns:
            true on success
        """
        tcp_stream_set_nonblocking(self, nonblocking)

    me close():
        """Close stream."""
        tcp_stream_close(self)

# ============================================================================
# UdpSocket - UDP Datagram Socket
# ============================================================================

class UdpSocket:
    """UDP datagram socket.

    Connectionless UDP socket for sending/receiving datagrams.

    Example:
        val socket = UdpSocket.bind("127.0.0.1:8080")?
        val (data, addr) = socket.recv_from(1024)?
        socket.send_to(data, addr)
    """
    handle: [u8]?

    static fn bind(addr: text) -> Result<UdpSocket, SimpleError>:
        """Bind to address.

        Args:
            addr: Address in format "host:port"

        Returns:
            Result with UdpSocket or error

        Example:
            val socket = UdpSocket.bind("0.0.0.0:8080")?
        """
        udp_socket_bind(addr)

    fn recv_from(size: usize) -> Result<([u8], text), SimpleError>:
        """Receive datagram.

        Args:
            size: Maximum bytes to receive

        Returns:
            Result with (data, sender_addr) or error

        Blocks until datagram arrives.
        """
        udp_socket_recv_from(self, size)

    fn send_to(data: [u8], addr: text) -> Result<usize, SimpleError>:
        """Send datagram to address.

        Args:
            data: Bytes to send
            addr: Destination address

        Returns:
            Result with bytes sent or error
        """
        udp_socket_send_to(self, data, addr)

    fn connect(addr: text) -> Result<(), SimpleError>:
        """Connect to remote address.

        Args:
            addr: Remote address

        Returns:
            Result or error

        After connect, use send/recv instead of send_to/recv_from.
        """
        udp_socket_connect(self, addr)

    fn send(data: [u8]) -> Result<usize, SimpleError>:
        """Send to connected peer.

        Args:
            data: Bytes to send

        Returns:
            Result with bytes sent or error

        Requires prior connect().
        """
        udp_socket_send(self, data)

    fn recv(size: usize) -> Result<[u8], SimpleError>:
        """Receive from connected peer.

        Args:
            size: Maximum bytes to receive

        Returns:
            Result with data or error

        Requires prior connect().
        """
        udp_socket_recv(self, size)

    fn local_addr() -> text?:
        """Get local address.

        Returns:
            Some(address) or None
        """
        udp_socket_local_addr(self)

    fn set_broadcast(broadcast: bool) -> bool:
        """Enable/disable broadcast.

        Args:
            broadcast: true to enable

        Returns:
            true on success
        """
        udp_socket_set_broadcast(self, broadcast)

    fn set_multicast_loop(multicast_loop: bool) -> bool:
        """Enable/disable multicast loopback.

        Args:
            multicast_loop: true to enable

        Returns:
            true on success
        """
        udp_socket_set_multicast_loop(self, multicast_loop)

    fn join_multicast(multicast_addr: text) -> bool:
        """Join multicast group.

        Args:
            multicast_addr: Multicast address

        Returns:
            true on success
        """
        udp_socket_join_multicast(self, multicast_addr)

    fn leave_multicast(multicast_addr: text) -> bool:
        """Leave multicast group.

        Args:
            multicast_addr: Multicast address

        Returns:
            true on success
        """
        udp_socket_leave_multicast(self, multicast_addr)

    fn set_read_timeout(timeout_ms: i64?) -> bool:
        """Set read timeout.

        Args:
            timeout_ms: Timeout in ms or None for blocking

        Returns:
            true on success
        """
        udp_socket_set_read_timeout(self, timeout_ms)

    fn set_nonblocking(nonblocking: bool) -> bool:
        """Set non-blocking mode.

        Args:
            nonblocking: true for non-blocking

        Returns:
            true on success
        """
        udp_socket_set_nonblocking(self, nonblocking)

    me close():
        """Close socket."""
        udp_socket_close(self)

# ============================================================================
# HttpClient - HTTP/HTTPS Client
# ============================================================================

enum HttpMethod:
    """HTTP request method."""
    GET
    POST
    PUT
    DELETE
    HEAD
    OPTIONS
    PATCH

impl HttpMethod:
    fn to_string() -> text:
        """Convert to string."""
        match self:
            case HttpMethod.GET: "GET"
            case HttpMethod.POST: "POST"
            case HttpMethod.PUT: "PUT"
            case HttpMethod.DELETE: "DELETE"
            case HttpMethod.HEAD: "HEAD"
            case HttpMethod.OPTIONS: "OPTIONS"
            case HttpMethod.PATCH: "PATCH"

class HttpRequest:
    """HTTP request.

    Example:
        val req = HttpRequest.new(HttpMethod.GET, "/api/users")
            .header("Accept", "application/json")
            .header("User-Agent", "SimpleHTTP/1.0")
    """
    method: HttpMethod
    path: text
    headers: {text: text}
    body: [u8]?

    static fn new(method: HttpMethod, path: text) -> HttpRequest:
        """Create HTTP request.

        Args:
            method: HTTP method
            path: Request path

        Returns:
            HttpRequest
        """
        HttpRequest(
            method: method,
            path: path,
            headers: {},
            body: None
        )

    me header(name: text, value: text) -> HttpRequest:
        """Add header.

        Args:
            name: Header name
            value: Header value

        Returns:
            Self (for chaining)
        """
        self.headers[name] = value
        self

    me body_text(text: text) -> HttpRequest:
        """Set text body.

        Args:
            text: Body text

        Returns:
            Self (for chaining)
        """
        self.body = Some(text.as_bytes())
        self

    me body_bytes(bytes: [u8]) -> HttpRequest:
        """Set binary body.

        Args:
            bytes: Body bytes

        Returns:
            Self (for chaining)
        """
        self.body = Some(bytes)
        self

class HttpResponse:
    """HTTP response.

    Example:
        val resp = client.get("https://api.example.com/users")?
        print "Status: {resp.status}"
        print "Body: {resp.body_text()}"
    """
    status: i64
    reason: text
    headers: {text: text}
    body: [u8]

    fn is_success() -> bool:
        """Check if response is successful (2xx).

        Returns:
            true if status 200-299
        """
        self.status >= 200 and self.status < 300

    fn is_redirect() -> bool:
        """Check if response is redirect (3xx).

        Returns:
            true if status 300-399
        """
        self.status >= 300 and self.status < 400

    fn is_client_error() -> bool:
        """Check if response is client error (4xx).

        Returns:
            true if status 400-499
        """
        self.status >= 400 and self.status < 500

    fn is_server_error() -> bool:
        """Check if response is server error (5xx).

        Returns:
            true if status 500-599
        """
        self.status >= 500 and self.status < 600

    fn body_text() -> text:
        """Get body as text.

        Returns:
            Body decoded as UTF-8
        """
        bytes_to_string(self.body)

    fn header(name: text) -> text?:
        """Get header value.

        Args:
            name: Header name (case-insensitive)

        Returns:
            Some(value) or None
        """
        self.headers.get(name.to_lower())

class HttpClient:
    """HTTP/HTTPS client.

    Supports GET, POST, PUT, DELETE, etc.

    Example:
        val client = HttpClient.new()
        val resp = client.get("https://api.example.com/users")?
        if resp.is_success():
            print resp.body_text()
    """
    timeout_ms: i64?
    follow_redirects: bool
    max_redirects: i64

    static fn new() -> HttpClient:
        """Create HTTP client with defaults.

        Returns:
            HttpClient
        """
        HttpClient(
            timeout_ms: Some(30000),  # 30 second default
            follow_redirects: true,
            max_redirects: 10
        )

    me set_timeout(timeout_ms: i64?) -> HttpClient:
        """Set request timeout.

        Args:
            timeout_ms: Timeout in ms or None for no timeout

        Returns:
            Self (for chaining)
        """
        self.timeout_ms = timeout_ms
        self

    me set_follow_redirects(follow: bool) -> HttpClient:
        """Set redirect following.

        Args:
            follow: true to follow redirects

        Returns:
            Self (for chaining)
        """
        self.follow_redirects = follow
        self

    fn get(url: text) -> Result<HttpResponse, SimpleError>:
        """Send GET request.

        Args:
            url: Full URL

        Returns:
            Result with HttpResponse or error

        Example:
            val resp = client.get("https://example.com")?
        """
        val req = HttpRequest.new(HttpMethod.GET, "/")
        self.request(url, req)

    fn post(url: text, body: [u8]) -> Result<HttpResponse, SimpleError>:
        """Send POST request.

        Args:
            url: Full URL
            body: Request body

        Returns:
            Result with HttpResponse or error
        """
        val req = HttpRequest.new(HttpMethod.POST, "/")
            .body_bytes(body)
        self.request(url, req)

    fn put(url: text, body: [u8]) -> Result<HttpResponse, SimpleError>:
        """Send PUT request.

        Args:
            url: Full URL
            body: Request body

        Returns:
            Result with HttpResponse or error
        """
        val req = HttpRequest.new(HttpMethod.PUT, "/")
            .body_bytes(body)
        self.request(url, req)

    fn delete(url: text) -> Result<HttpResponse, SimpleError>:
        """Send DELETE request.

        Args:
            url: Full URL

        Returns:
            Result with HttpResponse or error
        """
        val req = HttpRequest.new(HttpMethod.DELETE, "/")
        self.request(url, req)

    fn request(url: text, request: HttpRequest) -> Result<HttpResponse, SimpleError>:
        """Send custom request.

        Args:
            url: Full URL
            request: HttpRequest

        Returns:
            Result with HttpResponse or error
        """
        http_request(self, url, request)

# ============================================================================
# Url - URL Parsing and Manipulation
# ============================================================================

class Url:
    """URL parser and builder.

    Parses and manipulates URLs.

    Example:
        val url = Url.parse("https://example.com:8080/path?key=value")?
        print url.host()      # "example.com"
        print url.port()      # Some(8080)
        print url.path()      # "/path"
    """
    scheme: text
    host: text
    port: i64?
    path: text
    query: text?
    fragment: text?

    static fn parse(url: text) -> Result<Url, SimpleError>:
        """Parse URL from string.

        Args:
            url: URL string

        Returns:
            Result with Url or error

        Example:
            val url = Url.parse("https://example.com/path")?
        """
        url_parse(url)

    fn scheme() -> text:
        """Get URL scheme.

        Returns:
            Scheme (e.g., "http", "https")
        """
        self.scheme

    fn host() -> text:
        """Get host.

        Returns:
            Host (domain or IP)
        """
        self.host

    fn port() -> i64?:
        """Get port.

        Returns:
            Some(port) or None if default
        """
        self.port

    fn path() -> text:
        """Get path.

        Returns:
            Path (e.g., "/api/users")
        """
        self.path

    fn query() -> text?:
        """Get query string.

        Returns:
            Some(query) or None
        """
        self.query

    fn fragment() -> text?:
        """Get fragment.

        Returns:
            Some(fragment) or None
        """
        self.fragment

    fn query_params() -> {text: text}:
        """Parse query parameters.

        Returns:
            Dict of key-value pairs

        Example:
            val params = url.query_params()
            val value = params.get("key")?
        """
        if not self.query.?:
            return {}

        val query = self.query.unwrap()
        var params: {text: text} = {}

        for pair in query.split("&"):
            val parts = pair.split("=")
            if parts.len() == 2:
                val key = url_decode(parts[0])
                val value = url_decode(parts[1])
                params[key] = value

        params

    fn to_string() -> text:
        """Convert to string.

        Returns:
            Full URL string
        """
        var result = "{self.scheme}://{self.host}"

        if val Some(p) = self.port:
            result = result + ":{p}"

        result = result + self.path

        if val Some(q) = self.query:
            result = result + "?{q}"

        if val Some(f) = self.fragment:
            result = result + "#{f}"

        result

class UrlBuilder:
    """URL builder.

    Construct URLs programmatically.

    Example:
        val url = UrlBuilder.new()
            .scheme("https")
            .host("example.com")
            .path("/api/users")
            .query_param("page", "1")
            .build()
    """
    scheme: text
    host: text
    port: i64?
    path: text
    query_params: [(text, text)]
    fragment: text?

    static fn new() -> UrlBuilder:
        """Create URL builder.

        Returns:
            UrlBuilder
        """
        UrlBuilder(
            scheme: "http",
            host: "",
            port: None,
            path: "/",
            query_params: [],
            fragment: None
        )

    me scheme(scheme: text) -> UrlBuilder:
        """Set scheme.

        Args:
            scheme: URL scheme (e.g., "https")

        Returns:
            Self (for chaining)
        """
        self.scheme = scheme
        self

    me host(host: text) -> UrlBuilder:
        """Set host.

        Args:
            host: Host (domain or IP)

        Returns:
            Self (for chaining)
        """
        self.host = host
        self

    me port(port: i64) -> UrlBuilder:
        """Set port.

        Args:
            port: Port number

        Returns:
            Self (for chaining)
        """
        self.port = Some(port)
        self

    me path(path: text) -> UrlBuilder:
        """Set path.

        Args:
            path: URL path

        Returns:
            Self (for chaining)
        """
        self.path = path
        self

    me query_param(key: text, value: text) -> UrlBuilder:
        """Add query parameter.

        Args:
            key: Parameter name
            value: Parameter value

        Returns:
            Self (for chaining)
        """
        self.query_params = self.query_params.push((key, value))
        self

    me fragment(fragment: text) -> UrlBuilder:
        """Set fragment.

        Args:
            fragment: URL fragment

        Returns:
            Self (for chaining)
        """
        self.fragment = Some(fragment)
        self

    fn build() -> text:
        """Build URL string.

        Returns:
            Complete URL
        """
        var result = "{self.scheme}://{self.host}"

        if val Some(p) = self.port:
            result = result + ":{p}"

        result = result + self.path

        if self.query_params.len() > 0:
            var query_parts: [text] = []
            for (key, value) in self.query_params:
                val encoded_key = url_encode(key)
                val encoded_value = url_encode(value)
                query_parts = query_parts.push("{encoded_key}={encoded_value}")
            result = result + "?" + query_parts.join("&")

        if val Some(f) = self.fragment:
            result = result + "#{f}"

        result

# ============================================================================
# Convenience Functions
# ============================================================================

fn get(url: text) -> Result<HttpResponse, SimpleError>:
    """Send GET request.

    Args:
        url: Full URL

    Returns:
        Result with HttpResponse or error

    Example:
        val resp = get("https://example.com")?
        print resp.body_text()
    """
    HttpClient.new().get(url)

fn post(url: text, body: [u8]) -> Result<HttpResponse, SimpleError>:
    """Send POST request.

    Args:
        url: Full URL
        body: Request body

    Returns:
        Result with HttpResponse or error
    """
    HttpClient.new().post(url, body)

fn download(url: text, path: text) -> Result<(), SimpleError>:
    """Download file from URL.

    Args:
        url: File URL
        path: Destination path

    Returns:
        Result or error

    Example:
        download("https://example.com/file.zip", "file.zip")?
    """
    val resp = get(url)?
    if not resp.is_success():
        return Err(error("HTTP {resp.status}: {resp.reason}"))

    file_write_bytes(path, resp.body)
    Ok(())

# ============================================================================
# FFI Functions
# ============================================================================

# TCP
extern fn tcp_listener_bind(addr: text) -> Result<TcpListener, SimpleError>
extern fn tcp_listener_accept(listener: TcpListener) -> Result<TcpStream, SimpleError>
extern fn tcp_listener_accept_timeout(listener: TcpListener, timeout_ms: i64) -> Result<TcpStream, SimpleError>
extern fn tcp_listener_local_addr(listener: TcpListener) -> text?
extern fn tcp_listener_set_nonblocking(listener: TcpListener, nonblocking: bool) -> bool
extern fn tcp_listener_close(listener: TcpListener)

extern fn tcp_stream_connect(addr: text) -> Result<TcpStream, SimpleError>
extern fn tcp_stream_connect_timeout(addr: text, timeout_ms: i64) -> Result<TcpStream, SimpleError>
extern fn tcp_stream_read(stream: TcpStream, size: usize) -> Result<[u8], SimpleError>
extern fn tcp_stream_read_exact(stream: TcpStream, size: usize) -> Result<[u8], SimpleError>
extern fn tcp_stream_read_line(stream: TcpStream) -> Result<text, SimpleError>
extern fn tcp_stream_write(stream: TcpStream, data: [u8]) -> Result<usize, SimpleError>
extern fn tcp_stream_write_all(stream: TcpStream, data: [u8]) -> Result<(), SimpleError>
extern fn tcp_stream_flush(stream: TcpStream) -> Result<(), SimpleError>
extern fn tcp_stream_peer_addr(stream: TcpStream) -> text?
extern fn tcp_stream_local_addr(stream: TcpStream) -> text?
extern fn tcp_stream_set_read_timeout(stream: TcpStream, timeout_ms: i64?) -> bool
extern fn tcp_stream_set_write_timeout(stream: TcpStream, timeout_ms: i64?) -> bool
extern fn tcp_stream_set_nodelay(stream: TcpStream, nodelay: bool) -> bool
extern fn tcp_stream_set_nonblocking(stream: TcpStream, nonblocking: bool) -> bool
extern fn tcp_stream_close(stream: TcpStream)

# UDP
extern fn udp_socket_bind(addr: text) -> Result<UdpSocket, SimpleError>
extern fn udp_socket_recv_from(socket: UdpSocket, size: usize) -> Result<([u8], text), SimpleError>
extern fn udp_socket_send_to(socket: UdpSocket, data: [u8], addr: text) -> Result<usize, SimpleError>
extern fn udp_socket_connect(socket: UdpSocket, addr: text) -> Result<(), SimpleError>
extern fn udp_socket_send(socket: UdpSocket, data: [u8]) -> Result<usize, SimpleError>
extern fn udp_socket_recv(socket: UdpSocket, size: usize) -> Result<[u8], SimpleError>
extern fn udp_socket_local_addr(socket: UdpSocket) -> text?
extern fn udp_socket_set_broadcast(socket: UdpSocket, broadcast: bool) -> bool
extern fn udp_socket_set_multicast_loop(socket: UdpSocket, multicast_loop: bool) -> bool
extern fn udp_socket_join_multicast(socket: UdpSocket, multicast_addr: text) -> bool
extern fn udp_socket_leave_multicast(socket: UdpSocket, multicast_addr: text) -> bool
extern fn udp_socket_set_read_timeout(socket: UdpSocket, timeout_ms: i64?) -> bool
extern fn udp_socket_set_nonblocking(socket: UdpSocket, nonblocking: bool) -> bool
extern fn udp_socket_close(socket: UdpSocket)

# HTTP
extern fn http_request(client: HttpClient, url: text, request: HttpRequest) -> Result<HttpResponse, SimpleError>

# URL
extern fn url_parse(url: text) -> Result<Url, SimpleError>
extern fn url_encode(text: text) -> text
extern fn url_decode(text: text) -> text

# Utilities
extern fn bytes_to_string(bytes: [u8]) -> text
extern fn file_write_bytes(path: text, data: [u8]) -> Result<(), SimpleError>

# ============================================================================
# Exports
# ============================================================================

export TcpListener
export TcpStream
export UdpSocket
export HttpMethod
export HttpRequest
export HttpResponse
export HttpClient
export Url
export UrlBuilder
export get
export post
export download
