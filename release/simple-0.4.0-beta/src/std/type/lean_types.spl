# Pure Type Inference (Lean 4 Formal Verification Model)
#
# Exact match to TypeInferenceCompile.lean.
# Port of rust/type/src/lib.rs (LeanTy/LeanExpr section)

export LeanTy, LeanExpr, lean_infer, infer_deterministic

# Type matching TypeInferenceCompile.lean exactly
enum LeanTy:
    Nat
    Bool
    Str
    Generic(name: text, args: [LeanTy])
    Arrow(arg: LeanTy, ret: LeanTy)

# Expression matching TypeInferenceCompile.lean exactly
enum LeanExpr:
    LitNat(value: i64)
    LitBool(value: bool)
    LitStr(value: text)
    Add(left: LeanExpr, right: LeanExpr)
    Concat(left: LeanExpr, right: LeanExpr)
    Generic(name: text, args: [LeanExpr])
    IfElse(cond: LeanExpr, then_branch: LeanExpr, else_branch: LeanExpr)
    Lam(body: LeanExpr)
    App(func: LeanExpr, arg: LeanExpr)

# Pure type inference function matching Lean exactly
fn lean_infer(expr: LeanExpr) -> LeanTy?:
    match expr:
        case LeanExpr.LitNat(_): Some(LeanTy.Nat)
        case LeanExpr.LitBool(_): Some(LeanTy.Bool)
        case LeanExpr.LitStr(_): Some(LeanTy.Str)

        case LeanExpr.Add(a, b):
            val ta = lean_infer(a)
            val tb = lean_infer(b)
            if not ta.? or not tb.?:
                return None
            match (ta.unwrap(), tb.unwrap()):
                case (LeanTy.Nat, LeanTy.Nat): Some(LeanTy.Nat)
                case _: None

        case LeanExpr.Concat(a, b):
            val ta = lean_infer(a)
            val tb = lean_infer(b)
            if not ta.? or not tb.?:
                return None
            match (ta.unwrap(), tb.unwrap()):
                case (LeanTy.Str, LeanTy.Str): Some(LeanTy.Str)
                case _: None

        case LeanExpr.Generic(name, args):
            var arg_tys = []
            for arg in args:
                val t = lean_infer(arg)
                if not t.?:
                    return None
                arg_tys.push(t.unwrap())
            Some(LeanTy.Generic(name: name, args: arg_tys))

        case LeanExpr.IfElse(c, t, e):
            val cond_ty = lean_infer(c)
            if not cond_ty.? or cond_ty.unwrap() != LeanTy.Bool:
                return None
            val then_ty = lean_infer(t)
            val else_ty = lean_infer(e)
            if not then_ty.? or not else_ty.?:
                return None
            if then_ty.unwrap() == else_ty.unwrap():
                then_ty
            else:
                None

        case LeanExpr.Lam(body):
            val body_ty = lean_infer(body)
            if not body_ty.?:
                return None
            Some(LeanTy.Arrow(arg: LeanTy.Nat, ret: body_ty.unwrap()))

        case LeanExpr.App(f, x):
            val f_ty = lean_infer(f)
            if not f_ty.?:
                return None
            match f_ty.unwrap():
                case LeanTy.Arrow(arg_ty, ret_ty):
                    val x_ty = lean_infer(x)
                    if not x_ty.?:
                        return None
                    if x_ty.unwrap() == arg_ty:
                        Some(ret_ty)
                    else:
                        None
                case _: None

# Determinism theorem: inference returns at most one type
fn infer_deterministic(e: LeanExpr) -> bool:
    val t1 = lean_infer(e)
    val t2 = lean_infer(e)
    t1 == t2
