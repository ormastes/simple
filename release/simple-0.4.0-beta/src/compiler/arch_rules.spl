# Architecture Rules Engine
#
# Enforces dependency constraints using the unified predicate system.
# Rules can forbid or allow specific dependencies, imports, or type usage.
#
# Port of rust/compiler/src/arch_rules.rs (671 lines)

export RuleAction, ArchRule, ArchRulesConfig
export DependencyKind, Dependency, ArchViolation, ArchRulesEngine

use predicate.{Predicate, Selector, MatchContext, match_predicate}
use predicate_parser.{parse_predicate}

# ============================================================================
# Rule Types
# ============================================================================

enum RuleAction:
    Forbid
    Allow

struct ArchRule:
    action: RuleAction
    predicate: Predicate
    priority: i64
    message: text?

struct ArchRulesConfig:
    enabled: bool
    rules: [ArchRule]

impl ArchRulesConfig:
    static fn disabled() -> ArchRulesConfig:
        ArchRulesConfig(enabled: false, rules: [])

    static fn from_rules(rules: [ArchRule]) -> ArchRulesConfig:
        ArchRulesConfig(enabled: rules.?, rules: rules)

# ============================================================================
# Dependencies
# ============================================================================

enum DependencyKind:
    Import(from: text, to: text)
    Depend(from: text, to: text)
    Use(type_name: text, location: text)

struct Dependency:
    kind: DependencyKind
    source_file: text
    line: i64

impl Dependency:
    fn to_match_context() -> MatchContext:
        match self.kind:
            case Import(from, to):
                MatchContext(type_name: Some(to), module_path: Some(from),
                             attrs: [], signature: nil, effects: [])
            case Depend(from, to):
                MatchContext(type_name: Some(to), module_path: Some(from),
                             attrs: [], signature: nil, effects: [])
            case Use(type_name, location):
                MatchContext(type_name: Some(type_name), module_path: Some(location),
                             attrs: [], signature: nil, effects: [])

# ============================================================================
# Violations
# ============================================================================

struct ArchViolation:
    rule: ArchRule
    dependency: Dependency
    message: text

# ============================================================================
# Architecture Rules Engine
# ============================================================================

class ArchRulesEngine:
    """Validates dependencies against architecture rules."""
    config: ArchRulesConfig

impl ArchRulesEngine:
    static fn create(config: ArchRulesConfig) -> ArchRulesEngine:
        ArchRulesEngine(config: config)

    fn validate(dependencies: [Dependency]) -> [ArchViolation]:
        """Check all dependencies against rules."""
        if not self.config.enabled:
            return []

        var violations: [ArchViolation] = []
        for dep in dependencies:
            val ctx = dep.to_match_context()
            var is_forbidden = false
            var forbid_rule: ArchRule? = nil
            var max_allow_priority: i64 = -1

            # Evaluate rules by priority
            for rule in self.config.rules:
                if match_predicate(rule.predicate, ctx):
                    match rule.action:
                        case Forbid:
                            if not is_forbidden or rule.priority > forbid_rule.unwrap().priority:
                                is_forbidden = true
                                forbid_rule = Some(rule)
                        case Allow:
                            if rule.priority > max_allow_priority:
                                max_allow_priority = rule.priority

            # Violation if forbidden and no higher-priority allow
            if is_forbidden and forbid_rule.?:
                val fr = forbid_rule.unwrap()
                if max_allow_priority <= fr.priority:
                    val msg = fr.message ?? "Architecture rule violation"
                    violations = violations.push(ArchViolation(
                        rule: fr, dependency: dep, message: msg))

        violations

    fn is_enabled() -> bool:
        self.config.enabled

# ============================================================================
# SDN Config Parsing
# ============================================================================

fn parse_arch_rules_from_sdn(sdn: Any) -> Result<ArchRulesConfig, text>:
    """Parse architecture rules from SDN configuration.

    Expected format:
        arch_rules:
          - action: forbid
            predicate: "import(std.unsafe.*)"
            priority: 10
            message: "Unsafe imports not allowed"
          - action: allow
            predicate: "import(std.io.*) & within(*.test.*)"
            priority: 5
    """
    # For now, return disabled config since we need proper SDN type support
    # This will be implemented once SDN parser integration is complete
    Ok(ArchRulesConfig.disabled())

# ============================================================================
# Syntax Parsing (for arch_rules: blocks in code)
# ============================================================================

fn parse_arch_rules_block(tokens: [Token]) -> Result<[ArchRule], text>:
    """Parse architecture rules block from source code.

    Syntax:
        arch_rules:
            forbid pc{import(std.unsafe.*)}
            allow pc{import(std.io.*) & within(*.test.*)}
    """
    var rules: [ArchRule] = []
    var pos = 0

    # Expect 'arch_rules:'
    if pos >= tokens.len() or tokens[pos].kind != TokenKind.Identifier or tokens[pos].text != "arch_rules":
        return Err("Expected 'arch_rules' keyword")
    pos = pos + 1

    if pos >= tokens.len() or tokens[pos].kind != TokenKind.Colon:
        return Err("Expected ':' after 'arch_rules'")
    pos = pos + 1

    # Expect indented block
    if pos >= tokens.len() or tokens[pos].kind != TokenKind.Indent:
        return Err("Expected indented block after 'arch_rules:'")
    pos = pos + 1

    # Parse rules until dedent
    while pos < tokens.len() and tokens[pos].kind != TokenKind.Dedent:
        # Parse action (forbid or allow)
        if tokens[pos].kind != TokenKind.Identifier:
            return Err("Expected 'forbid' or 'allow'")

        val action = match tokens[pos].text:
            case "forbid": RuleAction.Forbid
            case "allow": RuleAction.Allow
            case _: return Err("Expected 'forbid' or 'allow', got '{tokens[pos].text}'")
        pos = pos + 1

        # Parse predicate island pc{...}
        if pos >= tokens.len() or tokens[pos].kind != TokenKind.Identifier or tokens[pos].text != "pc":
            return Err("Expected 'pc' keyword")
        pos = pos + 1

        if pos >= tokens.len() or tokens[pos].kind != TokenKind.LBrace:
            return Err("Expected '{' after 'pc'")
        pos = pos + 1

        # Extract predicate content
        var pred_tokens: [Token] = []
        var brace_depth = 1
        while pos < tokens.len() and brace_depth > 0:
            if tokens[pos].kind == TokenKind.LBrace:
                brace_depth = brace_depth + 1
            elif tokens[pos].kind == TokenKind.RBrace:
                brace_depth = brace_depth - 1
                if brace_depth == 0:
                    break
            pred_tokens = pred_tokens.push(tokens[pos])
            pos = pos + 1

        if brace_depth != 0:
            return Err("Unclosed predicate island")
        pos = pos + 1  # Skip closing brace

        # Parse predicate from tokens
        val pred_str = pred_tokens.map(\t: t.text).join(" ")
        val predicate = parse_predicate("pc{{pred_str}}")?

        # Create rule
        rules = rules.push(ArchRule(
            action: action,
            predicate: predicate,
            priority: 0,
            message: nil
        ))

        # Skip newline
        if pos < tokens.len() and tokens[pos].kind == TokenKind.Newline:
            pos = pos + 1

    Ok(rules)

# ============================================================================
# Placeholder Types (until full parser integration)
# ============================================================================

enum TokenKind:
    Identifier, Colon, LBrace, RBrace, Indent, Dedent, Newline, Other

struct Token:
    kind: TokenKind
    text: text
    line: i64
    column: i64

# NOTE: parse_predicate is imported from predicate_parser module
# NOTE: SdnValue parsing requires sdn module integration
