"""
Trait System - Phase 2B: Impl Blocks

Implements trait implementations (impl Trait for Type).

Status: Phase 2B Complete
"""

type Symbol = text
type Span = text

# ============================================================================
# Type System (Simplified)
# ============================================================================

enum HirType:
    """Simplified type system"""
    Int
    Str
    Bool
    Named(name: Symbol)
    Generic(name: Symbol, args: [HirType])

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Named(name): name
            case Generic(name, args): "{name}<...>"

    fn type_name() -> Symbol:
        """Get the base type name"""
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Named(name): name
            case Generic(name, _): name

# ============================================================================
# Trait Reference
# ============================================================================

class TraitRef:
    """Reference to a trait"""
    name: text

impl TraitRef:
    static fn new(name: Symbol) -> TraitRef:
        TraitRef(name: name)

    fn to_string() -> text:
        self.name

# ============================================================================
# Method Implementation
# ============================================================================

class MethodImpl:
    """Method implementation in an impl block"""
    name: text
    body: text  # Placeholder for HirExpr

impl MethodImpl:
    static fn new(name: Symbol) -> MethodImpl:
        MethodImpl(
            name: name,
            body: "/* body */"
        )

# ============================================================================
# Impl Block
# ============================================================================

class ImplBlock:
    """
    Trait implementation for a type

    Example:
        impl Display for Point:
            fn to_string() -> text:
                "Point({self.x}, {self.y})"
    """
    trait_ref: text      # TraitRef
    for_type: text       # HirType
    methods: text        # Dict<Symbol, MethodImpl>
    type_params: text    # Placeholder for generic params

impl ImplBlock:
    static fn new(trait_ref: TraitRef, for_type: HirType) -> ImplBlock:
        ImplBlock(
            trait_ref: trait_ref,
            for_type: for_type,
            methods: {},
            type_params: "[]"
        )

    me add_method(method: MethodImpl):
        """Add method implementation"""
        self.methods[method.name] = method

    fn has_method(name: Symbol) -> bool:
        """Check if method is implemented"""
        name in self.methods

    fn get_method(name: Symbol) -> MethodImpl:
        """Get method implementation"""
        if name in self.methods:
            return self.methods[name]
        MethodImpl.new("NotFound")

    fn method_count() -> i64:
        """Count implemented methods"""
        self.methods.len()

    fn to_string() -> text:
        val trait_name = self.trait_ref.name
        val type_name = self.for_type.type_name()
        "impl {trait_name} for {type_name}"

# ============================================================================
# Impl Registry
# ============================================================================

class ImplRegistry:
    """
    Stores all impl blocks

    Indexed by (trait, type) pairs for fast lookup
    """
    impls: text  # [ImplBlock]
    index: text  # Dict<(Symbol, Symbol), ImplBlock>

impl ImplRegistry:
    static fn new() -> ImplRegistry:
        ImplRegistry(
            impls: [],
            index: {}
        )

    me register_impl(impl_block: ImplBlock) -> bool:
        """
        Register an impl block

        Returns: true if registered, false if conflict
        """
        val trait_name = impl_block.trait_ref.name
        val type_name = impl_block.for_type.type_name()
        val key = "{trait_name}::{type_name}"

        # Check for duplicate
        if key in self.index:
            return false  # Conflict

        # Register
        self.impls.push(impl_block)
        self.index[key] = impl_block
        true

    fn find_impl(trait_name: Symbol, type_name: Symbol) -> ImplBlock:
        """
        Find impl block for (trait, type) pair

        Returns: ImplBlock or dummy if not found
        """
        val key = "{trait_name}::{type_name}"

        if key in self.index:
            return self.index[key]

        # Return dummy impl
        val dummy_trait = TraitRef.new("NotFound")
        val dummy_type = HirType.Named(name: "NotFound")
        ImplBlock.new(dummy_trait, dummy_type)

    fn has_impl(trait_name: Symbol, type_name: Symbol) -> bool:
        """Check if impl exists"""
        val key = "{trait_name}::{type_name}"
        key in self.index

    fn count_impls() -> i64:
        """Count registered impls"""
        self.impls.len()

    me define_builtin_impls():
        """Define standard library impls"""

        # impl Display for i32
        val display_i32 = ImplBlock.new(
            TraitRef.new("Display"),
            HirType.Int
        )
        val to_string_i32 = MethodImpl.new("to_string")
        display_i32.add_method(to_string_i32)
        self.register_impl(display_i32)

        # impl Display for String
        val display_str = ImplBlock.new(
            TraitRef.new("Display"),
            HirType.Str
        )
        val to_string_str = MethodImpl.new("to_string")
        display_str.add_method(to_string_str)
        self.register_impl(display_str)

        # impl Eq for i32
        val eq_i32 = ImplBlock.new(
            TraitRef.new("Eq"),
            HirType.Int
        )
        val eq_method_i32 = MethodImpl.new("eq")
        eq_i32.add_method(eq_method_i32)
        self.register_impl(eq_i32)

        # impl Ord for i32
        val ord_i32 = ImplBlock.new(
            TraitRef.new("Ord"),
            HirType.Int
        )
        val lt_method = MethodImpl.new("lt")
        val gt_method = MethodImpl.new("gt")
        ord_i32.add_method(lt_method)
        ord_i32.add_method(gt_method)
        self.register_impl(ord_i32)

# ============================================================================
# Impl Validator
# ============================================================================

class ImplValidator:
    """
    Validates impl blocks

    Checks:
    - All trait methods are implemented
    - Method signatures match trait
    - Orphan rule (impl in trait or type's crate)
    """
    trait_registry: text
    impl_registry: text

impl ImplValidator:
    static fn new(trait_registry, impl_registry) -> ImplValidator:
        ImplValidator(
            trait_registry: trait_registry,
            impl_registry: impl_registry
        )

    fn validate_impl(impl_block: ImplBlock) -> bool:
        """
        Validate impl block completeness

        For now, just returns true (placeholder)
        In real implementation:
        - Check all trait methods implemented
        - Check method signatures match
        """
        true

    fn check_orphan_rule(impl_block: ImplBlock) -> bool:
        """
        Check orphan rule

        Rule: impl must be in trait's crate OR type's crate

        For now, always returns true (placeholder)
        """
        true

    fn check_conflicting_impls(impl_block: ImplBlock) -> bool:
        """
        Check for conflicting impls

        Rule: no two impls for same (trait, type) pair

        Returns: true if no conflict, false if conflict
        """
        val trait_name = impl_block.trait_ref.name
        val type_name = impl_block.for_type.type_name()

        not self.impl_registry.has_impl(trait_name, type_name)

# ============================================================================
# Tests
# ============================================================================

fn test_impl_block_basic():
    """Test basic impl block creation"""
    val trait_ref = TraitRef.new("Display")
    val for_type = HirType.Int

    val impl_block = ImplBlock.new(trait_ref, for_type)

    assert impl_block.to_string() == "impl Display for i32", "Impl string"
    assert impl_block.method_count() == 0, "No methods initially"

    # Add method
    val method = MethodImpl.new("to_string")
    impl_block.add_method(method)

    assert impl_block.method_count() == 1, "One method"
    assert impl_block.has_method("to_string"), "Has to_string"

    print "âœ… Basic impl block"

fn test_impl_registry():
    """Test impl registry"""
    val registry = ImplRegistry.new()

    assert registry.count_impls() == 0, "Empty registry"

    # Register impl
    val impl_block = ImplBlock.new(
        TraitRef.new("Display"),
        HirType.Int
    )
    val registered = registry.register_impl(impl_block)

    assert registered, "Registered"
    assert registry.count_impls() == 1, "One impl"

    print "âœ… Impl registry"

fn test_impl_lookup():
    """Test impl lookup"""
    val registry = ImplRegistry.new()

    # Register Display for i32
    val impl_block = ImplBlock.new(
        TraitRef.new("Display"),
        HirType.Int
    )
    registry.register_impl(impl_block)

    # Lookup
    assert registry.has_impl("Display", "i32"), "Has Display for i32"
    assert not registry.has_impl("Display", "String"), "No Display for String"

    val found = registry.find_impl("Display", "i32")
    assert found.trait_ref.name == "Display", "Found correct impl"

    print "âœ… Impl lookup"

fn test_conflicting_impls():
    """Test conflicting impl detection"""
    val registry = ImplRegistry.new()

    # Register first impl
    val impl1 = ImplBlock.new(
        TraitRef.new("Display"),
        HirType.Int
    )
    val first = registry.register_impl(impl1)

    # Try to register duplicate
    val impl2 = ImplBlock.new(
        TraitRef.new("Display"),
        HirType.Int
    )
    val second = registry.register_impl(impl2)

    assert first, "First succeeds"
    assert not second, "Second fails (conflict)"
    assert registry.count_impls() == 1, "Only one impl"

    print "âœ… Conflict detection"

fn test_builtin_impls():
    """Test built-in impl definitions"""
    val registry = ImplRegistry.new()
    registry.define_builtin_impls()

    # Check standard impls exist
    assert registry.has_impl("Display", "i32"), "Display for i32"
    assert registry.has_impl("Display", "String"), "Display for String"
    assert registry.has_impl("Eq", "i32"), "Eq for i32"
    assert registry.has_impl("Ord", "i32"), "Ord for i32"

    assert registry.count_impls() == 4, "4 built-in impls"

    # Check method completeness
    val ord_i32 = registry.find_impl("Ord", "i32")
    assert ord_i32.has_method("lt"), "Ord has lt"
    assert ord_i32.has_method("gt"), "Ord has gt"

    print "âœ… Built-in impls"

fn test_method_lookup():
    """Test method lookup in impl blocks"""
    val impl_block = ImplBlock.new(
        TraitRef.new("Display"),
        HirType.Int
    )

    val method = MethodImpl.new("to_string")
    impl_block.add_method(method)

    assert impl_block.has_method("to_string"), "Has method"
    assert not impl_block.has_method("debug"), "No debug method"

    val found = impl_block.get_method("to_string")
    assert found.name == "to_string", "Found correct method"

    print "âœ… Method lookup"

fn test_generic_types():
    """Test impl for generic types"""
    val option_i32 = HirType.Generic(
        name: "Option",
        args: [HirType.Int]
    )

    val impl_block = ImplBlock.new(
        TraitRef.new("Display"),
        option_i32
    )

    assert impl_block.to_string() == "impl Display for Option", "Generic impl string"
    assert impl_block.for_type.type_name() == "Option", "Base type name"

    print "âœ… Generic types"

fn main():
    print ""
    print "Impl Blocks Tests"
    print "================="

    test_impl_block_basic()
    test_impl_registry()
    test_impl_lookup()
    test_conflicting_impls()
    test_builtin_impls()
    test_method_lookup()
    test_generic_types()

    print ""
    print "ðŸŽ‰ Phase 2B Complete!"
    print ""
    print "Implemented:"
    print "  âœ… ImplBlock - trait implementations"
    print "  âœ… ImplRegistry - impl storage & lookup"
    print "  âœ… Conflict detection (no duplicate impls)"
    print "  âœ… Built-in impls (Display, Eq, Ord for primitives)"
    print "  âœ… Method storage and lookup"
    print "  âœ… Generic type support"
    print ""
    print "Progress: 16/30 hours (53% of Phase 2)"
    print "Next: Phase 2C - Obligation Solver (10h)"
