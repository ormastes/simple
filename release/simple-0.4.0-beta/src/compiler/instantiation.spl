# Shared Template Instantiator
#
# Common instantiation logic used by compiler, JIT, and linker contexts.
# Handles caching, cycle detection, and delegation to CompilationContext.

# Types CompilationContext, ConcreteType, InstantiationMode are defined in
# compilation_context.spl. Import is omitted to avoid transitive parse errors
# from other modules in the compiler/ directory when running in interpreter mode.

# ============================================================================
# Name Mangling
# ============================================================================

fn mangle(template_name, type_args):
    """Mangle a template name with concrete type arguments."""
    if type_args.is_empty():
        return template_name
    val args_str = type_args.map(\t: t.to_string()).join(",")
    "{template_name}${args_str}"

# ============================================================================
# TemplateInstantiator
# ============================================================================

class TemplateInstantiator:
    """Shared instantiation logic for compiler, JIT, and linker."""
    context: CompilationContext
    in_progress: Set<text>
    cache: Dict<text, Any>

    me instantiate(template_name, type_args):
        val key = mangle(template_name, type_args)

        # 1. Cache check
        if self.cache.contains_key(key):
            return Ok(self.cache[key])

        # 2. Cycle detection
        if self.in_progress.contains(key):
            return Err("Circular dependency: {key}")

        self.in_progress = self.in_progress.insert(key)

        # 3. Load template from context
        val load_result = self.context.load_template(template_name)
        if load_result.is_err():
            self.in_progress = self.in_progress.remove(key)
            return load_result

        val tmpl = load_result.unwrap()

        # 4. Compile through full pipeline (context handles AOP/DI/contracts)
        val compile_result = self.context.compile_template(tmpl, type_args)
        if compile_result.is_err():
            self.in_progress = self.in_progress.remove(key)
            return compile_result

        val compiled = compile_result.unwrap()

        # 5. Cache
        self.cache[key] = compiled
        self.in_progress = self.in_progress.remove(key)
        Ok(compiled)

    fn is_cached(template_name, type_args):
        val key = mangle(template_name, type_args)
        self.cache.contains_key(key)

    fn cache_size():
        self.cache.len()

# ============================================================================
# Exports
# ============================================================================

export TemplateInstantiator, mangle
