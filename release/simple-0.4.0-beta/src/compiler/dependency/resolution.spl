# Module Resolution
#
# Implements the module path resolution semantics verified in:
# verification/module_resolution/src/ModuleResolution.lean
#
# Proven Properties (Lean theorems):
# 1. wellformed_not_ambiguous: In well-formed filesystems, resolution never returns ambiguous
# 2. unique_path_form: Unique resolution returns one of the two expected path forms
# 3. unique_implies_exists: Unique resolution implies the file exists
# 4. notfound_means_neither: Not found means neither file nor directory exists

# A module path segment is a non-empty string identifier
#
# Corresponds to Lean: `structure Segment where name : String; nonEmpty : name ≠ ""`
struct Segment:
    name: text

impl Segment:
    # Create a new segment from a name
    # Returns None if the name is empty (maintains Lean invariant)
    static fn new(name: text) -> Segment?:
        if name.len() == 0:
            return nil
        Some(Segment(name: name))

    # Get the segment name
    fn name() -> text:
        self.name

    # Check if two segments are equal
    fn equals(other: Segment) -> bool:
        self.name == other.name

# A module path is a non-empty list of segments (e.g., `crate.sys.http`)
#
# Corresponds to Lean: `structure ModPath where segments : List Segment; nonEmpty : segments ≠ []`
struct ModPath:
    segments: List<Segment>

impl ModPath:
    # Create a new module path from segments
    # Returns None if segments is empty (maintains Lean invariant)
    static fn new(segments: List<Segment>) -> ModPath?:
        if segments.len() == 0:
            return nil
        Some(ModPath(segments: segments))

    # Parse a dot-separated module path string (e.g., "crate.sys.http")
    static fn parse(path: text) -> ModPath?:
        var segments: List<Segment> = []

        # Split on dots and filter out empty segments
        val parts = path.split(".")
        for part in parts:
            match Segment.new(part):
                case Some(seg):
                    segments.push(seg)
                case nil:
                    # Skip empty segments
                    ()

        # ModPath.new already returns ModPath?, so no need to wrap again
        ModPath.new(segments)

    # Get the segments
    fn segments() -> List<Segment>:
        self.segments

    # Check if this path starts with "crate"
    fn is_absolute() -> bool:
        if self.segments.len() == 0:
            return false
        self.segments[0].name() == "crate"

    # Get the path without the leading "crate" segment
    fn without_crate_prefix() -> ModPath?:
        if self.is_absolute() and self.segments.len() > 1:
            # Create new list without first segment
            var new_segments: List<Segment> = []
            var i = 1
            while i < self.segments.len():
                new_segments.push(self.segments[i])
                i = i + 1
            # ModPath.new already returns ModPath?, so no need to wrap again
            ModPath.new(new_segments)
        else if not self.is_absolute():
            # Already relative, return clone
            Some(ModPath(segments: self.segments))
        else:
            # Just "crate", can't remove prefix
            nil

    # Convert to string representation
    fn to_string() -> text:
        if self.segments.len() == 0:
            return ""

        var names = []
        for seg in self.segments:
            names.push(seg.name())
        names.join(".")

# Module can be either a file or a directory with __init__.spl
#
# Corresponds to Lean: `inductive FileKind | file | directory`
enum FileKind:
    File        # foo.spl
    Directory   # foo/__init__.spl

impl FileKind:
    # Convert to string for debugging
    fn to_string() -> text:
        match self:
            case FileKind.File:
                "File"
            case FileKind.Directory:
                "Directory"

# The result of resolving a module path
#
# Corresponds to Lean: `inductive ResolutionResult`
enum ResolutionResult:
    Unique(kind: FileKind, path: text)
    Ambiguous(file_path: text, dir_path: text)
    NotFound

impl ResolutionResult:
    # Check if resolution was successful (unique)
    fn is_unique() -> bool:
        match self:
            case ResolutionResult.Unique(_, _):
                true
            case _:
                false

    # Check if resolution was ambiguous
    fn is_ambiguous() -> bool:
        match self:
            case ResolutionResult.Ambiguous(_, _):
                true
            case _:
                false

    # Check if module was not found
    fn is_not_found() -> bool:
        match self:
            case ResolutionResult.NotFound:
                true
            case _:
                false

    # Convert to string for debugging
    fn to_string() -> text:
        match self:
            case ResolutionResult.Unique(kind, path):
                "Unique({kind.to_string()}, {path})"
            case ResolutionResult.Ambiguous(fp, dp):
                "Ambiguous({fp}, {dp})"
            case ResolutionResult.NotFound:
                "NotFound"

# File system state: tracks which files exist
#
# Corresponds to Lean: `structure FileSystem where files : List String`
struct FileSystem:
    files: List<text>

impl FileSystem:
    # Create a new empty filesystem
    static fn new() -> FileSystem:
        FileSystem(files: [])

    # Create a filesystem from a list of file paths
    static fn from_files(files: List<text>) -> FileSystem:
        FileSystem(files: files)

    # Check if a file exists in the filesystem
    #
    # Corresponds to Lean: `def FileSystem.exists`
    # Note: Renamed to `has_file` because `exists` is reserved keyword in Simple
    fn has_file(path: text) -> bool:
        for file in self.files:
            if file == path:
                return true
        false

    # Add a file to the filesystem
    me add_file(path: text):
        self.files.push(path)

# Convert a module path to a filesystem path for file resolution
#
# Corresponds to Lean: `def toFilePath`
fn to_file_path(root: text, mp: ModPath) -> text:
    var path = root + "/"

    val segs = mp.segments()
    var i = 0
    while i < segs.len():
        if i > 0:
            path = path + "/"
        path = path + segs[i].name()
        i = i + 1

    path + ".spl"

# Convert a module path to a filesystem path for directory resolution
#
# Corresponds to Lean: `def toDirPath`
fn to_dir_path(root: text, mp: ModPath) -> text:
    var path = root + "/"

    val segs = mp.segments()
    var i = 0
    while i < segs.len():
        if i > 0:
            path = path + "/"
        path = path + segs[i].name()
        i = i + 1

    path + "/__init__.spl"

# Resolve a module path in a filesystem
#
# Corresponds to Lean: `def resolve`
#
# This is the core resolution algorithm verified by Lean theorems
fn resolve(fs: FileSystem, root: text, mp: ModPath) -> ResolutionResult:
    val file_path = to_file_path(root, mp)
    val dir_path = to_dir_path(root, mp)

    val file_exists = fs.has_file(file_path)
    val dir_exists = fs.has_file(dir_path)

    # Match both booleans (corresponds to Lean match pattern)
    if file_exists and dir_exists:
        ResolutionResult.Ambiguous(file_path: file_path, dir_path: dir_path)
    else if file_exists:
        ResolutionResult.Unique(kind: FileKind.File, path: file_path)
    else if dir_exists:
        ResolutionResult.Unique(kind: FileKind.Directory, path: dir_path)
    else:
        ResolutionResult.NotFound

# Check if a filesystem is well-formed
# (no module has both file and directory forms)
#
# Corresponds to Lean: `def wellFormed`
fn is_well_formed(fs: FileSystem, root: text) -> bool:
    # In Simple, we'll check all existing files to ensure no conflicts
    # For each .spl file, check that the corresponding __init__.spl doesn't exist

    for file_path in fs.files:
        if file_path.ends_with(".spl") and not file_path.ends_with("__init__.spl"):
            # Extract the directory path
            # If file is "foo/bar.spl", check for "foo/bar/__init__.spl"
            val base = file_path[0..-4]  # Remove ".spl"
            val init_path = base + "/__init__.spl"

            if fs.has_file(init_path):
                return false

    true

# Public exports
export Segment
export ModPath
export FileKind
export ResolutionResult
export FileSystem
export to_file_path
export to_dir_path
export resolve
export is_well_formed
