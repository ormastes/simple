# Backend Selector
#
# Selects which backend to use (JIT vs AOT) based on compilation options.
# All backend selection logic is in Simple - Rust only provides the execution.

use compiler.backend_types.*
use compiler.backend.optimization_passes.*

# ============================================================================
# FFI Declarations
# ============================================================================

# Get host target architecture at runtime
extern fn rt_get_host_target_code() -> i64

# ============================================================================
# Backend Selection
# ============================================================================

enum BackendKind:
    """Which backend to use for compilation."""
    Jit         # Just-In-Time compilation (immediate execution)
    Aot         # Ahead-Of-Time compilation (object file output)
    Interpreter # Tree-walking interpreter (no native code)

enum TargetArch:
    """Target architecture."""
    X86_64
    Aarch64
    Riscv64
    Host       # Detect at runtime

struct BackendOptions:
    """Options for backend selection and configuration."""
    kind: BackendKind
    target: TargetArch
    optimization: OptimizationLevel
    output_path: text?
    enable_profiling: bool
    enable_coverage: bool
    is_pic: bool  # Position-independent code (required for shared libs/PIE)

impl BackendOptions:
    static fn jit() -> BackendOptions:
        """Options for JIT compilation."""
        BackendOptions(
            kind: BackendKind.Jit,
            target: TargetArch.Host,
            optimization: OptimizationLevel.Speed,
            output_path: nil,
            enable_profiling: false,
            enable_coverage: false,
            is_pic: true  # JIT always uses PIC
        )

    static fn aot(output: text) -> BackendOptions:
        """Options for AOT compilation."""
        BackendOptions(
            kind: BackendKind.Aot,
            target: TargetArch.Host,
            optimization: OptimizationLevel.Speed,
            output_path: Some(output),
            enable_profiling: false,
            enable_coverage: false,
            is_pic: true  # Default to PIC for compatibility with PIE/shared libs
        )

    static fn interpreter() -> BackendOptions:
        """Options for interpreter mode."""
        BackendOptions(
            kind: BackendKind.Interpreter,
            target: TargetArch.Host,
            optimization: OptimizationLevel.None,
            output_path: nil,
            enable_profiling: false,
            enable_coverage: false,
            is_pic: false  # Interpreter doesn't need PIC
        )

    me with_target(target: TargetArch) -> BackendOptions:
        """Set target architecture."""
        self.target = target
        self

    me with_optimization(level: OptimizationLevel) -> BackendOptions:
        """Set optimization level."""
        self.optimization = level
        self

    me with_profiling(enabled: bool) -> BackendOptions:
        """Enable profiling instrumentation."""
        self.enable_profiling = enabled
        self

    me with_coverage(enabled: bool) -> BackendOptions:
        """Enable coverage instrumentation."""
        self.enable_coverage = enabled
        self

    me with_pic(enabled: bool) -> BackendOptions:
        """Enable position-independent code generation."""
        self.is_pic = enabled
        self

# ============================================================================
# Backend Selector
# ============================================================================

struct BackendSelector:
    """Selects and configures backend based on options."""
    options: BackendOptions
    pass_config: PassConfig

impl BackendSelector:
    static fn new(options: BackendOptions) -> BackendSelector:
        """Create backend selector."""
        val pass_config = PassConfig.for_level(options.optimization)
        BackendSelector(
            options: options,
            pass_config: pass_config
        )

    fn should_use_jit() -> bool:
        """Check if JIT backend should be used."""
        self.options.kind == BackendKind.Jit

    fn should_use_aot() -> bool:
        """Check if AOT backend should be used."""
        self.options.kind == BackendKind.Aot

    fn should_use_interpreter() -> bool:
        """Check if interpreter should be used."""
        self.options.kind == BackendKind.Interpreter

    fn target_code() -> i64:
        """Get Cranelift target code."""
        match self.options.target:
            case X86_64: 0
            case Aarch64: 1
            case Riscv64: 2
            case Host: rt_get_host_target_code()  # Detect at runtime

    fn optimization_level_string() -> text:
        """Get optimization level as string for Rust FFI.

        Maps to Cranelift settings:
        - "none" = no optimizations (opt_level=0)
        - "speed" = optimize for speed (opt_level=speed)
        - "size" = optimize for size (opt_level=size_and_speed)

        These strings MUST match Cranelift's expected values.
        """
        match self.options.optimization:
            case None: "none"
            case Speed: "speed"
            case Size: "size_and_speed"  # Cranelift's actual setting name
            case Debug: "none"

    fn backend_name() -> text:
        """Get human-readable backend name."""
        match self.options.kind:
            case Jit: "JIT"
            case Aot: "AOT"
            case Interpreter: "Interpreter"

# ============================================================================
# Auto-Selection
# ============================================================================

fn select_backend_auto(has_output_file: bool, is_debug: bool) -> BackendOptions:
    """Automatically select backend based on compilation context."""
    if is_debug:
        # Debug mode: use interpreter or JIT with debug opts
        if has_output_file:
            BackendOptions.aot("output.o").with_optimization(OptimizationLevel.Debug)
        else:
            BackendOptions.jit().with_optimization(OptimizationLevel.Debug)
    else:
        # Release mode: use optimal backend
        if has_output_file:
            BackendOptions.aot("output.o").with_optimization(OptimizationLevel.Speed)
        else:
            BackendOptions.jit().with_optimization(OptimizationLevel.Speed)

fn select_backend_for_script() -> BackendOptions:
    """Select backend for running scripts (prefer JIT)."""
    BackendOptions.jit()

fn select_backend_for_build() -> BackendOptions:
    """Select backend for building executables (use AOT)."""
    BackendOptions.aot("output.o")

fn select_backend_for_test() -> BackendOptions:
    """Select backend for running tests (use JIT with coverage)."""
    BackendOptions.jit().with_coverage(true)

# ============================================================================
# Exports
# ============================================================================

export BackendKind, TargetArch, BackendOptions
export BackendSelector
export select_backend_auto, select_backend_for_script
export select_backend_for_build, select_backend_for_test
