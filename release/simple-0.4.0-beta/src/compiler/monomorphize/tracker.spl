# Compile-Time Tracking of Generic Instantiations
#
# This module tracks instantiations during compilation to populate
# the note.sdn section for lazy instantiation and dependency analysis.
#
# Phase 3: Compile-Time Tracking
#
# Port of: rust/compiler/src/monomorphize/tracker.rs (375 lines)

export InstantiationTracker
export TrackingContext

use compiler.monomorphize.types (ConcreteType)
use compiler.monomorphize.note_sdn (
    NoteSdnMetadata, InstantiationEntry, PossibleInstantiationEntry,
    TypeInferenceEntry, DependencyEdge, DependencyKind, InstantiationStatus,
    CircularError, CircularWarning
)
use compiler.monomorphize.cycle_detector (detect_cycles, analyze_and_update_cycles)

# ============================================================================
# Instantiation Tracker
# ============================================================================

struct InstantiationTracker:
    """Tracks instantiations during compilation.

    Accumulates note.sdn metadata during monomorphization to record:
    - All compiled instantiations (with source locations)
    - Possible/deferrable instantiations
    - Type inference events
    - Dependencies between instantiations
    - Circular dependency errors/warnings

    Used to generate .sdn metadata for lazy instantiation and
    dependency analysis.

    ROBUSTNESS:
    - Prevents duplicate tracking (via tracked_names set)
    - Handles pending dependencies (added when from_inst is tracked)
    - Integrates cycle detection
    - Supports multi-file compilation (merge)
    """
    # Accumulated note.sdn metadata
    metadata: NoteSdnMetadata

    # Current instantiation ID counter
    next_inst_id: i64

    # Set of already-tracked mangled names (avoid duplicates)
    tracked_names: {text: bool}

    # Current source file being compiled
    current_file: text

    # Current object file target
    current_obj: text

    # Pending dependencies to add after instantiation completes
    # (from_inst, to_inst, kind)
    pending_deps: [(text, text, DependencyKind)]

impl InstantiationTracker:
    static fn new(source_file: text, obj_file: text) -> InstantiationTracker:
        """Create a new tracker for a compilation unit."""
        InstantiationTracker(
            metadata: NoteSdnMetadata.new(),
            next_inst_id: 0,
            tracked_names: {},
            current_file: source_file,
            current_obj: obj_file,
            pending_deps: []
        )

    fn current_file() -> text:
        """Get the current source file."""
        self.current_file

    me set_current_file(file: text):
        """Set the current source file."""
        self.current_file = file

    me track_instantiation(
        template: text,
        type_args: [ConcreteType],
        mangled_name: text,
        source_loc: text,
        status: InstantiationStatus
    ):
        """Track a compiled instantiation.

        Records an instantiation in the metadata and prevents duplicates.

        ROBUSTNESS:
        - Skips if already tracked (via tracked_names)
        - Flushes pending dependencies after tracking
        """
        # Skip if already tracked
        if self.tracked_names.contains_key(mangled_name):
            return

        val entry = InstantiationEntry.new(
            template.clone(),
            type_args.clone(),
            mangled_name.clone(),
            self.current_file.clone(),
            source_loc.clone(),
            self.current_obj.clone(),
            status
        )

        self.metadata.add_instantiation(entry)
        self.tracked_names[mangled_name.clone()] = true
        self.next_inst_id = self.next_inst_id + 1

        # Process pending dependencies
        self.flush_pending_deps()

    me track_possible(
        template: text,
        type_args: [ConcreteType],
        mangled_name: text,
        required_by: text,
        can_defer: bool
    ):
        """Track a possible (deferrable) instantiation.

        Records an instantiation that could be deferred to JIT time.

        ROBUSTNESS: Skips if already tracked as compiled.
        """
        # Skip if already tracked as compiled
        if self.tracked_names.contains_key(mangled_name):
            return

        val entry = PossibleInstantiationEntry.new(
            template.clone(),
            type_args.clone(),
            mangled_name.clone(),
            required_by.clone(),
            can_defer
        )

        self.metadata.add_possible(entry)

    me track_type_inference(inferred_type: text, expr: text, context: text, source_loc: text):
        """Track a type inference event.

        Records type inference for debugging and analysis.
        """
        val entry = TypeInferenceEntry.new(
            inferred_type.clone(),
            expr.clone(),
            context.clone(),
            self.current_file.clone(),
            source_loc.clone()
        )

        self.metadata.add_type_inference(entry)

    me track_dependency(from_inst: text, to_inst: text, dep_kind: DependencyKind):
        """Track a dependency between instantiations.

        If from_inst is not yet tracked, queues the dependency
        to be added later (when from_inst is tracked).

        ROBUSTNESS: Defers dependencies until from_inst is tracked.
        """
        # If from_inst is not yet tracked, queue the dependency
        if not self.tracked_names.contains_key(from_inst):
            self.pending_deps.push((from_inst.clone(), to_inst.clone(), dep_kind))
            return

        val edge = DependencyEdge.new(from_inst.clone(), to_inst.clone(), dep_kind)
        self.metadata.add_dependency(edge)

    me flush_pending_deps():
        """Flush pending dependencies that can now be added.

        Processes all pending dependencies and adds them if from_inst
        is now tracked.

        ROBUSTNESS: Retains dependencies that still can't be added.
        """
        var remaining: [(text, text, DependencyKind)] = []

        for (from, to, kind) in self.pending_deps:
            if self.tracked_names.contains_key(from):
                val edge = DependencyEdge.new(from.clone(), to.clone(), kind)
                self.metadata.add_dependency(edge)
            else:
                remaining.push((from, to, kind))

        self.pending_deps = remaining

    me analyze_cycles():
        """Analyze for circular dependencies and update metadata.

        Runs cycle detection and populates circular_errors and
        circular_warnings in metadata.
        """
        analyze_and_update_cycles(self.metadata)

    fn has_circular_errors() -> bool:
        """Check if there are any circular errors."""
        not self.metadata.circular_errors.is_empty()

    fn circular_errors() -> [CircularError]:
        """Get circular errors."""
        self.metadata.circular_errors.clone()

    fn circular_warnings() -> [CircularWarning]:
        """Get circular warnings."""
        self.metadata.circular_warnings.clone()

    me finalize() -> NoteSdnMetadata:
        """Finalize tracking and return the metadata.

        Flushes pending dependencies, analyzes cycles, and
        returns the complete metadata.

        ROBUSTNESS: Ensures all tracking is complete before returning.
        """
        # Flush any remaining pending deps
        self.flush_pending_deps()

        # Analyze cycles
        self.analyze_cycles()

        self.metadata.clone()

    fn metadata() -> NoteSdnMetadata:
        """Get a reference to the current metadata (for inspection)."""
        self.metadata.clone()

    me merge(other: NoteSdnMetadata):
        """Merge metadata from another tracker (for multi-file compilation).

        Combines metadata from multiple compilation units.

        ROBUSTNESS:
        - Prevents duplicate instantiations
        - Re-analyzes cycles after merge
        """
        # Merge instantiations
        for inst in other.instantiations:
            if not self.tracked_names.contains_key(inst.mangled_name):
                self.tracked_names[inst.mangled_name.clone()] = true
                self.metadata.add_instantiation(inst)

        # Merge possible instantiations
        for poss in other.possible:
            if not self.tracked_names.contains_key(poss.mangled_name):
                self.metadata.add_possible(poss)

        # Merge type inferences
        for inf in other.type_inferences:
            self.metadata.add_type_inference(inf)

        # Merge dependencies
        for dep in other.dependencies:
            self.metadata.add_dependency(dep)

        # Re-analyze cycles after merge
        self.analyze_cycles()

# ============================================================================
# Tracking Context (Builder Pattern)
# ============================================================================

struct TrackingContext:
    """Builder for tracking instantiations during monomorphization.

    Provides a convenient API for tracking dependencies during
    the instantiation process.

    Usage:
        val ctx = TrackingContext.start(tracker, "List", [Int], "List$Int")
        ctx.depends_on_type_param("Int")
        ctx.depends_on_field_type("Node$Int")
        ctx.complete("test.spl:10:5", InstantiationStatus.Compiled)

    ROBUSTNESS: Ensures all dependency information is recorded.
    """
    # Reference to the tracker (Note: in Simple, we can't have &mut,
    # so we'll need to modify tracker directly)
    tracker: InstantiationTracker

    # Current instantiation being tracked
    current_template: text
    current_type_args: [ConcreteType]
    current_mangled: text

impl TrackingContext:
    static fn start(
        tracker: InstantiationTracker,
        template: text,
        type_args: [ConcreteType],
        mangled_name: text
    ) -> TrackingContext:
        """Start tracking a new instantiation.

        Returns a context that can record dependencies.
        """
        TrackingContext(
            tracker: tracker,
            current_template: template.clone(),
            current_type_args: type_args.clone(),
            current_mangled: mangled_name.clone()
        )

    me depends_on(to_inst: text, kind: DependencyKind):
        """Record that this instantiation depends on another type."""
        self.tracker.track_dependency(
            self.current_mangled.clone(),
            to_inst,
            kind
        )

    me depends_on_type_param(type_name: text):
        """Record a type parameter dependency."""
        self.depends_on(type_name, DependencyKind.TypeParam)

    me depends_on_field_type(type_name: text):
        """Record a field type dependency."""
        self.depends_on(type_name, DependencyKind.FieldType)

    me complete(source_loc: text, status: InstantiationStatus):
        """Complete the instantiation tracking.

        Records the instantiation in the tracker.
        """
        self.tracker.track_instantiation(
            self.current_template.clone(),
            self.current_type_args.clone(),
            self.current_mangled.clone(),
            source_loc,
            status
        )

# ============================================================================
# Usage Examples
# ============================================================================
#
# # Create a tracker for a compilation unit
# val tracker = InstantiationTracker.new("test.spl", "test.o")
#
# # Track a compiled instantiation
# tracker.track_instantiation(
#     "List",
#     [ConcreteType.Int],
#     "List$Int",
#     "test.spl:10:5",
#     InstantiationStatus.Compiled
# )
#
# # Track a dependency
# tracker.track_dependency("List$Int", "Int", DependencyKind.TypeParam)
#
# # Track a possible/deferrable instantiation
# tracker.track_possible(
#     "List",
#     [ConcreteType.Float],
#     "List$Float",
#     "math_module",
#     true  # can_defer
# )
#
# # Using TrackingContext (builder pattern)
# val ctx = TrackingContext.start(
#     tracker,
#     "Container",
#     [ConcreteType.Int],
#     "Container$Int"
# )
# ctx.depends_on_type_param("Int")
# ctx.depends_on_field_type("List$Int")
# ctx.complete("test.spl:20:3", InstantiationStatus.Compiled)
#
# # Finalize and get metadata
# val metadata = tracker.finalize()
# print "Tracked {metadata.instantiations.len()} instantiations"
# print "Found {metadata.circular_errors.len()} circular errors"
#
# # Multi-file compilation
# val tracker1 = InstantiationTracker.new("module1.spl", "module1.o")
# val tracker2 = InstantiationTracker.new("module2.spl", "module2.o")
# # ... track in both ...
# tracker1.merge(tracker2.finalize())
# val combined = tracker1.finalize()
#
# ============================================================================
# Dependency Tracking Workflow
# ============================================================================
#
# During monomorphization:
#
# 1. Start tracking an instantiation
#    tracker.track_instantiation("List", [Int], "List$Int", ...)
#
# 2. As you process the body, record dependencies
#    tracker.track_dependency("List$Int", "Int", DependencyKind.TypeParam)
#    tracker.track_dependency("List$Int", "Node$Int", DependencyKind.FieldType)
#
# 3. If dependency target not yet tracked, it's queued in pending_deps
#    tracker.track_dependency("List$Int", "Option$Int", ...)  # queued
#
# 4. When Option$Int is later tracked, pending deps are flushed
#    tracker.track_instantiation("Option", [Int], "Option$Int", ...)
#    # Automatically flushes: List$Int -> Option$Int dependency
#
# 5. At end of compilation, finalize
#    val metadata = tracker.finalize()
#    # - Flushes remaining pending deps
#    # - Runs cycle detection
#    # - Returns complete metadata for .sdn output
#
# ============================================================================
# Cycle Detection Integration
# ============================================================================
#
# After tracking all instantiations and dependencies:
#
# tracker.analyze_cycles()
#
# This populates:
# - metadata.circular_errors - Hard cycles (E0420)
# - metadata.circular_warnings - Soft cycles (indirection via Option/Pointer)
#
# Check for errors:
# if tracker.has_circular_errors():
#     for err in tracker.circular_errors():
#         print "ERROR[E0420]: {err.cycle}"
#         print "Suggestion: {err.suggestion}"
#
# ============================================================================
# Tracking Categories
# ============================================================================
#
# 1. Compiled Instantiations (track_instantiation)
#    - Fully compiled to native code
#    - Status: Compiled, Cached, Failed
#    - Includes source location + object file
#
# 2. Possible Instantiations (track_possible)
#    - Could be deferred to JIT time
#    - Includes "required_by" and "can_defer" flag
#    - Not in object file (stored in .smf template)
#
# 3. Type Inferences (track_type_inference)
#    - Records type inference events
#    - For debugging and analysis
#    - Includes expression + context
#
# 4. Dependencies (track_dependency)
#    - Edges in instantiation graph
#    - Kinds: TypeParam, FieldType, ReturnType, CallTarget, etc.
#    - Used for cycle detection
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - track_instantiation: O(1) hash insert + O(pending_deps) flush
# - track_dependency: O(1) if from_inst tracked, else O(1) queue
# - flush_pending_deps: O(pending_deps) scan
# - finalize: O(V + E) cycle detection (V=nodes, E=edges)
# - merge: O(n) where n = size of other metadata
#
# Expected performance: Same as Rust (same data structures, hash tables)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Duplicate Prevention:
# - [x] tracked_names prevents duplicate instantiations
# - [x] Skips already-tracked in track_instantiation
# - [x] Skips already-tracked in track_possible
#
# Dependency Handling:
# - [x] Pending dependencies queued until from_inst tracked
# - [x] Flush after each instantiation
# - [x] Flush before finalize
#
# Cycle Detection:
# - [x] Integrates with cycle_detector module
# - [x] Populates circular_errors and circular_warnings
# - [x] Re-analyzes after merge
#
# Multi-File Support:
# - [x] Merge combines metadata from multiple trackers
# - [x] Prevents duplicate merging (via tracked_names)
#
# Memory Safety:
# - [x] No buffer overflows (Simple arrays safe)
# - [x] No use-after-free (Simple ownership)
# - [x] No null pointers (explicit types)
#
# Edge Cases:
# - [x] Empty tracking (finalize returns empty metadata)
# - [x] Duplicate tracking (skipped)
# - [x] Forward dependencies (queued in pending_deps)
# - [x] Merge with empty metadata (works)
#
# TODO:
# - [ ] Add priority tracking (for instantiation order)
# - [ ] Add cost estimation (compile time prediction)
# - [ ] Add incremental tracking (delta updates)
# - [ ] Add visualization export (graphviz .dot format)
#
