# Escape Analysis
#
# Determines whether objects escape the current function/scope.
# Used for:
# - Stack allocation optimization (non-escaping objects)
# - GC root tracking (escaping objects need roots)
# - Barrier optimization (local objects may skip barriers)
#
# Escape states:
# - NoEscape: Object stays local, can be stack-allocated
# - ArgEscape: Escapes as function argument (may return)
# - GlobalEscape: Escapes to global/heap (definitely GC-managed)

# ============================================================================
# Escape State
# ============================================================================

enum EscapeState:
    """Escape state of an allocation."""
    NoEscape        # Stays local to function
    ArgEscape       # Escapes via function argument
    ReturnEscape    # Escapes via return value
    GlobalEscape    # Escapes to global variable
    FieldEscape     # Stored in escaping object's field
    Unknown         # Cannot determine

impl EscapeState:
    fn to_text() -> text:
        match self:
            case NoEscape: "no_escape"
            case ArgEscape: "arg_escape"
            case ReturnEscape: "return_escape"
            case GlobalEscape: "global_escape"
            case FieldEscape: "field_escape"
            case Unknown: "unknown"

    fn escapes() -> bool:
        """Check if this state represents escaping."""
        match self:
            case NoEscape: false
            case _: true

    fn can_stack_allocate() -> bool:
        """Check if object can be stack-allocated."""
        match self:
            case NoEscape: true
            case _: false

    fn merge_with(other: EscapeState) -> EscapeState:
        """Merge two escape states (lattice join)."""
        match (self, other):
            case (Unknown, _) | (_, Unknown):
                Unknown
            case (GlobalEscape, _) | (_, GlobalEscape):
                GlobalEscape
            case (ReturnEscape, _) | (_, ReturnEscape):
                ReturnEscape
            case (FieldEscape, _) | (_, FieldEscape):
                FieldEscape
            case (ArgEscape, _) | (_, ArgEscape):
                ArgEscape
            case (NoEscape, NoEscape):
                NoEscape

# ============================================================================
# Allocation Site
# ============================================================================

struct AllocationSite:
    """An allocation in the program."""
    id: i64
    program_point: i64
    type_id: i64
    size_bytes: i64?       # Known size or nil for dynamic
    escape_state: EscapeState

impl AllocationSite:
    static fn create(id: i64, point: i64, type_id: i64) -> AllocationSite:
        AllocationSite(
            id: id,
            program_point: point,
            type_id: type_id,
            size_bytes: nil,
            escape_state: EscapeState.Unknown
        )

    fn to_text() -> text:
        "alloc_{self.id} @ {self.program_point}: {self.escape_state.to_text()}"

# ============================================================================
# Points-To Set
# ============================================================================

class PointsToSet:
    """Set of allocation sites a variable may point to."""
    allocations: [i64]  # Allocation site IDs

    static fn empty() -> PointsToSet:
        PointsToSet(allocations: [])

    static fn singleton(alloc_id: i64) -> PointsToSet:
        PointsToSet(allocations: [alloc_id])

    me add(alloc_id: i64):
        """Add an allocation to the set."""
        if not self.allocations.contains(alloc_id):
            self.allocations = self.allocations.push(alloc_id)

    fn union(other: PointsToSet) -> PointsToSet:
        """Union two points-to sets."""
        var result = PointsToSet(allocations: self.allocations)
        for id in other.allocations:
            result.add(id)
        result

    fn is_empty() -> bool:
        self.allocations.is_empty()

    fn contains(alloc_id: i64) -> bool:
        self.allocations.contains(alloc_id)

    fn all() -> [i64]:
        self.allocations

# ============================================================================
# Escape Analysis
# ============================================================================

class EscapeAnalysis:
    """Performs escape analysis on a function.

    Uses flow-insensitive points-to analysis combined with
    escape state tracking.
    """
    # Allocation sites in the function
    allocations: Dict<i64, AllocationSite>
    next_alloc_id: i64

    # Points-to information (variable -> allocations)
    points_to: Dict<i64, PointsToSet>  # Local ID -> points-to set

    # Field points-to (type, field) -> allocations
    field_points_to: Dict<(i64, i64), PointsToSet>

    # Statistics
    total_allocations: i64
    stack_eligible: i64

    static fn create() -> EscapeAnalysis:
        EscapeAnalysis(
            allocations: {},
            next_alloc_id: 0,
            points_to: {},
            field_points_to: {},
            total_allocations: 0,
            stack_eligible: 0
        )

    me record_allocation(point: i64, type_id: i64, dest_local: i64) -> i64:
        """Record an allocation and return its ID."""
        val id = self.next_alloc_id
        self.next_alloc_id = self.next_alloc_id + 1
        self.total_allocations = self.total_allocations + 1

        val site = AllocationSite.create(id, point, type_id)
        self.allocations[id] = site

        # Initialize points-to for destination
        var pts = self.points_to.get(dest_local) ?? PointsToSet.empty()
        pts.add(id)
        self.points_to[dest_local] = pts

        id

    me record_copy(from_local: i64, to_local: i64):
        """Record a copy (to = from)."""
        val from_pts = self.points_to.get(from_local) ?? PointsToSet.empty()
        var to_pts = self.points_to.get(to_local) ?? PointsToSet.empty()
        to_pts = to_pts.union(from_pts)
        self.points_to[to_local] = to_pts

    me record_field_store(base_local: i64, field_idx: i64, value_local: i64, type_id: i64):
        """Record a field store (base.field = value)."""
        val value_pts = self.points_to.get(value_local) ?? PointsToSet.empty()
        val base_pts = self.points_to.get(base_local) ?? PointsToSet.empty()

        # Value escapes to field
        for alloc_id in value_pts.all():
            self.mark_escape(alloc_id, EscapeState.FieldEscape)

        # Store in field points-to
        val key = (type_id, field_idx)
        var field_pts = self.field_points_to.get(key) ?? PointsToSet.empty()
        field_pts = field_pts.union(value_pts)
        self.field_points_to[key] = field_pts

    me record_field_load(base_local: i64, field_idx: i64, dest_local: i64, type_id: i64):
        """Record a field load (dest = base.field)."""
        val key = (type_id, field_idx)
        val field_pts = self.field_points_to.get(key) ?? PointsToSet.empty()

        var dest_pts = self.points_to.get(dest_local) ?? PointsToSet.empty()
        dest_pts = dest_pts.union(field_pts)
        self.points_to[dest_local] = dest_pts

    me record_return(local: i64):
        """Record a return of a local."""
        val pts = self.points_to.get(local) ?? PointsToSet.empty()
        for alloc_id in pts.all():
            self.mark_escape(alloc_id, EscapeState.ReturnEscape)

    me record_call_arg(local: i64):
        """Record passing a local as a call argument."""
        val pts = self.points_to.get(local) ?? PointsToSet.empty()
        for alloc_id in pts.all():
            self.mark_escape(alloc_id, EscapeState.ArgEscape)

    me record_global_store(local: i64):
        """Record storing a local to a global variable."""
        val pts = self.points_to.get(local) ?? PointsToSet.empty()
        for alloc_id in pts.all():
            self.mark_escape(alloc_id, EscapeState.GlobalEscape)

    me mark_escape(alloc_id: i64, state: EscapeState):
        """Mark an allocation as escaping."""
        match self.allocations.get(alloc_id):
            case Some(site):
                val new_state = site.escape_state.merge_with(state)
                self.allocations[alloc_id] = AllocationSite(
                    id: site.id,
                    program_point: site.program_point,
                    type_id: site.type_id,
                    size_bytes: site.size_bytes,
                    escape_state: new_state
                )
            case None:
                pass

    me finalize():
        """Finalize analysis and compute statistics."""
        # Mark unknown as NoEscape (conservative for unanalyzed)
        for id, site in self.allocations:
            if site.escape_state == EscapeState.Unknown:
                self.allocations[id] = AllocationSite(
                    id: site.id,
                    program_point: site.program_point,
                    type_id: site.type_id,
                    size_bytes: site.size_bytes,
                    escape_state: EscapeState.NoEscape
                )

        # Count stack-eligible allocations
        self.stack_eligible = 0
        for _, site in self.allocations:
            if site.escape_state.can_stack_allocate():
                self.stack_eligible = self.stack_eligible + 1

    fn get_escape_state(alloc_id: i64) -> EscapeState:
        """Get escape state for an allocation."""
        match self.allocations.get(alloc_id):
            case Some(site): site.escape_state
            case None: EscapeState.Unknown

    fn can_stack_allocate(alloc_id: i64) -> bool:
        """Check if allocation can be stack-allocated."""
        self.get_escape_state(alloc_id).can_stack_allocate()

    fn get_non_escaping() -> [AllocationSite]:
        """Get all non-escaping allocations."""
        var result: [AllocationSite] = []
        for _, site in self.allocations:
            if not site.escape_state.escapes():
                result = result.push(site)
        result

    fn get_escaping() -> [AllocationSite]:
        """Get all escaping allocations."""
        var result: [AllocationSite] = []
        for _, site in self.allocations:
            if site.escape_state.escapes():
                result = result.push(site)
        result

    fn stack_allocation_ratio() -> f64:
        """Get ratio of stack-eligible allocations."""
        if self.total_allocations == 0:
            0.0
        else:
            self.stack_eligible.to_f64() / self.total_allocations.to_f64()

# ============================================================================
# Exports
# ============================================================================

export EscapeState, AllocationSite, PointsToSet
export EscapeAnalysis
