# Lazy instantiation at link-time.
#
# This module handles on-demand instantiation of generic templates
# when resolving missing symbols during linking.
#
# Phase 4: Link-Time Lazy Instantiation

use ../monomorphize/note_sdn.*
use ../compilation_context.{GenericTemplate, ConcreteType}
use ../instantiation.{TemplateInstantiator, mangle}
use linker_context.LinkerCompilationContext

# ============================================================================
# Result Types
# ============================================================================

enum LazyInstantiationResult:
    """Result of lazy instantiation attempt."""
    Success(code: [u8], symbol: text, metadata: NoteSdnMetadata)
    NotFound(symbol: text)
    CircularDependency(cycle: [text])
    Deferred(symbol: text)
    Error(message: text)

impl LazyInstantiationResult:
    fn is_success() -> bool:
        match self:
            case Success(_, _, _): true
            case _: false

    fn is_deferred() -> bool:
        match self:
            case Deferred(_): true
            case _: false

    fn is_error() -> bool:
        match self:
            case Error(_): true
            case CircularDependency(_): true
            case _: false

# ============================================================================
# Configuration
# ============================================================================

struct LazyInstantiatorConfig:
    """Configuration for lazy instantiation."""
    allow_defer: bool
    max_depth: i32
    verbose: bool

impl LazyInstantiatorConfig:
    static fn default() -> LazyInstantiatorConfig:
        LazyInstantiatorConfig(
            allow_defer: true,
            max_depth: 100,
            verbose: false
        )

# ============================================================================
# Lazy Instantiator
# ============================================================================

struct LazyInstantiator:
    """Lazy instantiator for link-time instantiation."""
    config: LazyInstantiatorConfig
    input_metadata: Dict<text, NoteSdnMetadata>
    output_metadata: NoteSdnMetadata
    in_progress: Set<text>
    depth: i32
    instantiated: Dict<text, [u8]>

impl LazyInstantiator:
    static fn new(config: LazyInstantiatorConfig) -> LazyInstantiator:
        """Create a new lazy instantiator."""
        LazyInstantiator(
            config: config,
            input_metadata: {},
            output_metadata: NoteSdnMetadata.new(),
            in_progress: {},
            depth: 0,
            instantiated: {}
        )

    me load_metadata(smf_path: text, metadata: NoteSdnMetadata):
        """Load note.sdn metadata from an input SMF file."""
        # Merge instantiations into output
        for inst in metadata.instantiations:
            self.output_metadata = self.output_metadata.add_instantiation(inst)

        # Keep possible entries for lookup
        self.input_metadata[smf_path] = metadata

    fn can_instantiate(symbol: text) -> bool:
        """Check if a symbol can be lazily instantiated."""
        for (_, metadata) in self.input_metadata:
            for poss in metadata.possible:
                if poss.mangled_name == symbol:
                    return true
        false

    fn find_possible(symbol: text) -> (text, PossibleInstantiationEntry)?:
        """Find possible instantiation entry for a symbol."""
        for (path, metadata) in self.input_metadata:
            for entry in metadata.possible:
                if entry.mangled_name == symbol:
                    return Some((path, entry))
        None

    me try_instantiate(symbol: text) -> LazyInstantiationResult:
        """Try to instantiate a missing symbol."""
        # Check depth limit
        if self.depth >= self.config.max_depth:
            return LazyInstantiationResult.Error(
                "Maximum instantiation depth ({self.config.max_depth}) exceeded"
            )

        # Check if already instantiated
        if self.instantiated.contains_key(symbol):
            return LazyInstantiationResult.Success(
                code: self.instantiated[symbol],
                symbol: symbol,
                metadata: self.output_metadata
            )

        # Check for cycle
        if self.in_progress.contains(symbol):
            val cycle = self.in_progress.to_list()
            return LazyInstantiationResult.CircularDependency(cycle)

        # Find possible entry
        val found = self.find_possible(symbol)
        if not found.?:
            return LazyInstantiationResult.NotFound(symbol)

        val (source_path, entry) = found.unwrap()

        # Check if can defer
        if entry.can_defer and self.config.allow_defer:
            return LazyInstantiationResult.Deferred(symbol)

        # Start instantiation
        self.in_progress = self.in_progress.insert(symbol)
        self.depth = self.depth + 1

        if self.config.verbose:
            print "[lazy-inst] Instantiating {symbol} from {source_path}"

        # Perform instantiation
        val result = self.do_instantiate(entry, source_path)

        # Cleanup
        self.in_progress = self.in_progress.remove(symbol)
        self.depth = self.depth - 1

        result

    me do_instantiate(entry: PossibleInstantiationEntry, source_path: text) -> LazyInstantiationResult:
        """Perform the actual instantiation through unified CompilationContext pipeline."""
        # Create instantiation entry for metadata tracking
        val inst_entry = InstantiationEntry(
            template_name: entry.template_name,
            type_args: entry.type_args,
            mangled_name: entry.mangled_name,
            from_file: source_path,
            from_loc: "{source_path}:0:0",
            to_obj: "link_output.o",
            status: InstantiationStatus.Compiled
        )

        # Add to output metadata
        self.output_metadata = self.output_metadata.add_instantiation(inst_entry)

        # Add dependency edge
        val dep = DependencyEdge(
            from_inst: entry.required_by,
            to_inst: entry.mangled_name,
            dep_kind: DependencyKind.TypeParam
        )
        self.output_metadata = self.output_metadata.add_dependency(dep)

        # Build linker compilation context from input metadata
        # TODO: Load actual templates from input SMF TemplateCode sections
        var object_templates: Dict<text, GenericTemplate> = {}
        object_templates[entry.template_name] = GenericTemplate(
            name: entry.template_name,
            type_params: entry.type_args.split(",").map(\s: s.trim()),
            ast_data: nil
        )

        val linker_ctx = LinkerCompilationContext.from_objects(object_templates, nil, nil)
        var instantiator = TemplateInstantiator(
            context: linker_ctx,
            in_progress: {},
            cache: {}
        )

        # Parse type args from the entry
        val type_args = entry.type_args.split(",").map(\s: ConcreteType(name: s.trim()))

        # Compile through unified pipeline
        match instantiator.instantiate(entry.template_name, type_args):
            case Ok(unit):
                val compiled_code = unit.code
                self.instantiated[entry.mangled_name] = compiled_code

                LazyInstantiationResult.Success(
                    code: compiled_code,
                    symbol: entry.mangled_name,
                    metadata: self.output_metadata
                )

            case Err(msg):
                LazyInstantiationResult.Error(msg)

    fn get_instantiable_missing(missing_symbols: [text]) -> [text]:
        """Get all missing symbols that could be instantiated."""
        missing_symbols.filter(\s: self.can_instantiate(s))

    me instantiate_all_missing(missing_symbols: [text]) -> [LazyInstantiationResult]:
        """Instantiate all missing symbols that can be instantiated."""
        val instantiable = self.get_instantiable_missing(missing_symbols)
        var results: [LazyInstantiationResult] = []

        for symbol in instantiable:
            val result = self.try_instantiate(symbol)
            results = results.push(result)

        results

    fn get_output_metadata() -> NoteSdnMetadata:
        """Get the output metadata."""
        self.output_metadata

    fn finalize() -> NoteSdnMetadata:
        """Finalize and return the output metadata."""
        self.output_metadata

# ============================================================================
# Statistics
# ============================================================================

struct LazyInstantiationStats:
    """Statistics from lazy instantiation."""
    instantiated: i32
    deferred: i32
    not_found: i32
    errors: i32

impl LazyInstantiationStats:
    static fn default() -> LazyInstantiationStats:
        LazyInstantiationStats(
            instantiated: 0,
            deferred: 0,
            not_found: 0,
            errors: 0
        )

    static fn from_results(results: [LazyInstantiationResult]) -> LazyInstantiationStats:
        var stats = LazyInstantiationStats.default()

        for result in results:
            match result:
                case Success(_, _, _):
                    stats.instantiated = stats.instantiated + 1
                case Deferred(_):
                    stats.deferred = stats.deferred + 1
                case NotFound(_):
                    stats.not_found = stats.not_found + 1
                case Error(_):
                    stats.errors = stats.errors + 1
                case CircularDependency(_):
                    stats.errors = stats.errors + 1

        stats

# ============================================================================
# Exports
# ============================================================================

export LazyInstantiationResult
export LazyInstantiatorConfig
export LazyInstantiator
export LazyInstantiationStats
