# @pending
"""
# Type Inference Specification

# @skip

**Status:** Partial Implementation (Hindley-Milner scaffold working)
**Feature IDs:** #13
**Keywords:** 
**Last Updated:** 2026-01-05
**Migrated From:** doc/spec/type_inference.md

## Overview

Simple uses a Hindley-Milner-style type inference system that automatically deduces types for expressions, variables, and functions without requiring explicit type annotations in most cases.
"""
# @skip

# Test cases extracted from specification

## Test: Inference Rules

it "inference_rules_1":
    """
    Inference Rules
    """
    # Integer literals
    val x = 42           # x: Int

    # Float literals
    val y = 3.14         # y: Float

    # String literals
    val s = "hello"      # s: Str

    # Boolean literals
    val b = true         # b: Bool

    # Nil literal
    val n = nil          # n: Nil
    pass

## Test: Inference Rules

it "inference_rules_2":
    """
    Inference Rules
    """
    val a = 1 + 2        # a: Int (Int + Int -> Int)
    val b = 3.0 * 1.5    # b: Float (Float * Float -> Float)
    pass

## Test: Inference Rules

it "inference_rules_3":
    """
    Inference Rules
    """
    val cmp = 1 < 2      # cmp: Bool
    pass

## Test: Inference Rules

it "inference_rules_4":
    """
    Inference Rules
    """
    val logic = true and false  # logic: Bool
    pass

## Test: Inference Rules

it "inference_rules_5":
    """
    Inference Rules
    """
    val bits = 5 << 2    # bits: Int
    pass

## Test: Inference Rules

"""
### Scenario: Arrays:...

Arrays:
"""
it "inference_rules_6":
    """
    Inference Rules
    """
    val arr = [1, 2, 3]           # arr: Array<Int>
    val empty: Array<Int> = []    # Explicit type for empty array
    val nested = [[1, 2], [3, 4]] # nested: Array<Array<Int>>
    pass

## Test: Inference Rules

"""
### Scenario: Tuples:...

Tuples:
"""
it "inference_rules_7":
    """
    Inference Rules
    """
    val t = (1, "hi", true)       # t: (Int, Str, Bool)
    val first = t[0]              # first: Int
    pass

## Test: Inference Rules

"""
### Scenario: Dictionaries:...

Dictionaries:
"""
it "inference_rules_8":
    """
    Inference Rules
    """
    val dict = {"a": 1, "b": 2}   # dict: {Str: Int}
    val val = dict["a"]           # val: Int
    pass

## Test: Inference Rules

"""
### Scenario: Function Definition:...

Function Definition:
"""
# Inferred parameter and return types
fn add(a, b):
    return a + b              # Infers: (Int, Int) -> Int

# Explicit types
fn greet(name: str) -> str:
    return "Hello, " + name

## Test: Inference Rules

"""
### Scenario: Function Calls:...

Function Calls:
"""
it "inference_rules_10":
    """
    Inference Rules
    """
    val result = add(1, 2)        # result: Int
    pass

## Test: Inference Rules

"""
### Scenario: Higher-Order Functions:...

Higher-Order Functions:
"""
fn apply(f, x):
    return f(x)               # f: (T) -> R, x: T, return: R

fn inc(n):
    return n + 1              # inc: (Int) -> Int

val r = apply(inc, 5)         # r: Int

## Test: Inference Rules

"""
### Scenario: Match Expressions:...

Match Expressions:
"""
it "inference_rules_12":
    """
    Inference Rules
    """
    enum Color:
        Red
        Green
        Blue(i64)

    val c = Color.Blue(42)
    match c:
        Color.Red:
            0                     # Branch type: Int
        Color.Green:
            1                     # Branch type: Int
        Color.Blue(val):
            val                   # Branch type: Int, val: Int
    # Result type: Int (all branches unify)
    pass

## Test: Inference Rules

"""
### Scenario: Destructuring:...

Destructuring:
"""
it "inference_rules_13":
    """
    Inference Rules
    """
    # Tuple pattern
    val (x, y) = (1, 2)           # x: Int, y: Int

    # Array pattern
    val [a, b, c] = [1, 2, 3]     # a, b, c: Int

    # Struct pattern
    struct Point:
        x: i64
        y: i64

    val Point { x, y } = Point { x: 1, y: 2 }  # x, y: i64
    pass

## Test: Inference Rules

"""
### Scenario: If Expressions:...

If Expressions:
"""
it "inference_rules_14":
    """
    Inference Rules
    """
    # Branches must unify to same type
    val val = if x > 0:
        1                         # Branch 1: Int
    else:
        2                         # Branch 2: Int
    # Result: Int
    pass

## Test: Inference Rules

"""
### Scenario: Loops:...

Loops:
"""
it "inference_rules_15":
    """
    Inference Rules
    """
    # While loop
    var i = 0
    while i < 10:
        i = i + 1

    # For loop
    for x in range(0, 10):        # x: Int (inferred from range)
        print(x)
    pass

## Test: Type Unification

"""
### Scenario: Prevents infinite types:...

Prevents infinite types:
"""
it "type_unification_16":
    """
    Type Unification
    """
    # This would fail: T = Array<T>
    val x = [x]  # Error: occurs check failed
    pass

## Test: Type Unification

"""
### Scenario: Type variables are resolved through substitution:...

Type variables are resolved through substitution:
"""
it "type_unification_17":
    """
    Type Unification
    """
    val arr = []           # arr: Array<?T>
    arr[0] = 42            # Unify ?T with Int
    # arr: Array<Int>
    pass

## Test: Examples

it "examples_18":
    """
    Examples
    """
    # All types inferred automatically
    val numbers = [1, 2, 3, 4, 5]      # Array<Int>
    val sum = 0                         # Int
    for n in numbers:                   # n: Int
        sum = sum + n
    # sum: Int
    pass

## Test: Examples

fn map(f, arr):
    var result = []
    for x in arr:
        result.append(f(x))
    return result

fn double(x):
    return x * 2

val nums = [1, 2, 3]               # Array<Int>
val doubled = map(double, nums)    # Array<Int>

## Test: Examples

enum Option<T>:
    Some(T)
    None

fn unwrap_or(opt, default):
    match opt:
        Option.Some(val):
            val                    # Type inferred from T
        Option.None:
            default                # Must unify with T
# Return type: T

## Test: Examples

# Async by default
fn fetch_data():
    val response = http.get("https://api.example.com")  # Async call
    return response.json()
# Inferred as async

# Explicit sync
sync fn compute():
    return 2 + 2
# Explicitly sync

## Test: Error Messages

it "error_messages_22":
    """
    Error Messages
    """
    val x = 1 + "hello"
    # Error: Type mismatch
    #   Expected: Int
    #   Found: Str
    pass

## Test: Error Messages

it "error_messages_23":
    """
    Error Messages
    """
    val result = unknown_var + 1
    # Error: Undefined identifier: unknown_var
    pass

## Test: Error Messages

it "error_messages_24":
    """
    Error Messages
    """
    val x = [x]
    # Error: Occurs check failed
    #   Cannot unify Var(0) with Array<Var(0)>
    #   This would create an infinite type
    pass

