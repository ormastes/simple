# Lazy Value Tests
#
# Tests for lazy evaluation and memoization.

# @skip
use lazy_val.{
    Lazy,
    LazyState,
    LazyError,
    LazyStats,
    Memo,
    lazy,
    force,
    is_evaluated,
    get_lazy_stats,
    reset_lazy_stats
}

describe "LazyState":
    it "checks pending state":
        val state = LazyState.Pending

        assert state.is_pending()
        assert not state.is_ready()
        assert not state.is_evaluating()

    it "checks ready state":
        val state = LazyState.Ready(42)

        assert state.is_ready()
        assert not state.is_pending()

    it "checks evaluating state":
        val state = LazyState.Evaluating

        assert state.is_evaluating()
        assert not state.is_pending()

    it "checks failed state":
        val state = LazyState.Failed("error")

        assert state.is_failed()
        assert not state.is_ready()

describe "Lazy - Creation":
    it "creates lazy value":
        var computed = false
        val lazy_val = Lazy.new(\:
            computed = true
            42
        )

        assert not computed
        assert lazy_val.is_pending()

    it "creates already-evaluated value":
        val lazy_val = Lazy.of(42)

        assert lazy_val.is_evaluated()
        assert lazy_val.get() == Some(42)

    it "creates failed value":
        val lazy_val = Lazy.failed("test error")

        assert lazy_val.is_failed()

    it "uses shorthand constructor":
        val lazy_val = lazy(\: 42)

        assert lazy_val.is_pending()

describe "Lazy - Force Evaluation":
    it "forces evaluation":
        var lazy_val = Lazy.new(\: 42)

        val result = lazy_val.force()

        assert result == Ok(42)
        assert lazy_val.is_evaluated()

    it "caches result":
        var call_count = 0
        var lazy_val = Lazy.new(\:
            call_count = call_count + 1
            42
        )

        lazy_val.force()
        lazy_val.force()
        lazy_val.force()

        assert call_count == 1

    it "returns cached value":
        var lazy_val = Lazy.of(42)

        val r1 = lazy_val.force()
        val r2 = lazy_val.force()

        assert r1 == Ok(42)
        assert r2 == Ok(42)

    it "handles force_or_default":
        var lazy_val = Lazy.new(\: 42)

        val result = lazy_val.force_or_default(0)

        assert result == 42

    it "uses default on failed value":
        var lazy_val = Lazy.failed("error")

        val result = lazy_val.force_or_default(99)

        assert result == 99

describe "Lazy - Cycle Detection":
    # Note: Actual cycle detection requires self-referential lazy values
    # which are tricky to set up in tests. This tests the mechanism.

    it "detects evaluation state":
        val lazy_val = Lazy.new(\: 42)

        assert not lazy_val.state.is_evaluating()

describe "Lazy - Queries":
    it "checks is_evaluated":
        var lazy_val = Lazy.new(\: 42)

        assert not lazy_val.is_evaluated()

        lazy_val.force()

        assert lazy_val.is_evaluated()

    it "checks is_pending":
        var lazy_val = Lazy.new(\: 42)

        assert lazy_val.is_pending()

        lazy_val.force()

        assert not lazy_val.is_pending()

    it "gets value without forcing":
        var lazy_val = Lazy.new(\: 42)

        assert lazy_val.get() == nil

        lazy_val.force()

        assert lazy_val.get() == Some(42)

describe "Lazy - Transformations":
    it "maps lazily":
        var lazy_val = Lazy.new(\: 21)
        val doubled = lazy_val.map(\x: x * 2)

        assert not lazy_val.is_evaluated()
        assert not doubled.is_evaluated()

        var d = doubled
        val result = d.force()

        assert result == Ok(42)

    it "flat_maps lazily":
        var lazy_val = Lazy.new(\: 10)
        val chained = lazy_val.flat_map(\x: Lazy.new(\: x + 5))

        var c = chained
        val result = c.force()

        assert result == Ok(15)

    it "zips two lazy values":
        val lazy1 = Lazy.new(\: 10)
        val lazy2 = Lazy.new(\: 20)

        val zipped = lazy1.zip(lazy2)

        var z = zipped
        val result = z.force()

        assert result == Ok((10, 20))

    it "filters lazy value":
        val lazy_val = Lazy.new(\: 42)
        val filtered = lazy_val.filter(\x: x > 40)

        var f = filtered
        val result = f.force()

        assert result == Ok(Some(42))

    it "filters out non-matching":
        val lazy_val = Lazy.new(\: 10)
        val filtered = lazy_val.filter(\x: x > 40)

        var f = filtered
        val result = f.force()

        assert result == Ok(nil)

describe "Lazy - Display":
    it "formats pending":
        val lazy_val = Lazy.new(\: 42)
        assert lazy_val.fmt().contains("pending")

    it "formats ready":
        var lazy_val = Lazy.of(42)
        assert lazy_val.fmt().contains("ready")

    it "formats failed":
        val lazy_val = Lazy.failed("error")
        assert lazy_val.fmt().contains("failed")

describe "Lazy - Statistics":
    it "tracks created count":
        reset_lazy_stats()

        Lazy.new(\: 1)
        Lazy.new(\: 2)
        Lazy.new(\: 3)

        val stats = get_lazy_stats()
        assert stats.total_created >= 3

    it "tracks forced count":
        reset_lazy_stats()

        var lazy_val = Lazy.new(\: 42)
        lazy_val.force()

        val stats = get_lazy_stats()
        assert stats.total_forced >= 1

    it "tracks cache hits and misses":
        reset_lazy_stats()

        var lazy_val = Lazy.new(\: 42)
        lazy_val.force()  # Miss
        lazy_val.force()  # Hit
        lazy_val.force()  # Hit

        val stats = get_lazy_stats()
        assert stats.cache_misses >= 1
        assert stats.cache_hits >= 2

    it "calculates hit rate":
        reset_lazy_stats()

        var lazy_val = Lazy.new(\: 42)
        lazy_val.force()  # Miss
        lazy_val.force()  # Hit

        val stats = get_lazy_stats()
        assert stats.hit_rate() == 0.5

describe "LazyError":
    it "formats cycle detected":
        val err = LazyError.CycleDetected
        assert err.message().contains("Cycle")

    it "formats evaluation failed":
        val err = LazyError.EvaluationFailed("test error")
        assert err.message().contains("test error")

describe "Memo - Basic Operations":
    it "creates empty memo":
        val memo = Memo.new()

        assert memo.size() == 0

    it "computes and caches":
        var memo = Memo.new()

        val result = memo.get_or_compute(5, \: 5 * 5)

        assert result == 25
        assert memo.size() == 1

    it "returns cached value":
        var memo = Memo.new()
        var call_count = 0

        memo.get_or_compute(5, \:
            call_count = call_count + 1
            25
        )
        memo.get_or_compute(5, \:
            call_count = call_count + 1
            25
        )

        assert call_count == 1

    it "computes different keys":
        var memo = Memo.new()

        memo.get_or_compute(2, \: 4)
        memo.get_or_compute(3, \: 9)
        memo.get_or_compute(4, \: 16)

        assert memo.size() == 3
        assert memo.get(2) == Some(4)
        assert memo.get(3) == Some(9)
        assert memo.get(4) == Some(16)

    it "checks containment":
        var memo = Memo.new()

        memo.get_or_compute(5, \: 25)

        assert memo.contains(5)
        assert not memo.contains(10)

    it "clears cache":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)
        memo.get_or_compute(2, \: 4)
        memo.clear()

        assert memo.size() == 0

describe "Memo - Statistics":
    it "tracks lookups":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)
        memo.get_or_compute(1, \: 1)
        memo.get_or_compute(2, \: 4)

        val stats = memo.get_stats()
        assert stats.total_lookups == 3

    it "tracks hits and misses":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)  # Miss
        memo.get_or_compute(1, \: 1)  # Hit
        memo.get_or_compute(2, \: 4)  # Miss

        val stats = memo.get_stats()
        assert stats.cache_misses == 2
        assert stats.cache_hits == 1

    it "calculates hit rate":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)  # Miss
        memo.get_or_compute(1, \: 1)  # Hit
        memo.get_or_compute(1, \: 1)  # Hit

        val stats = memo.get_stats()
        val hit_rate = stats.hit_rate()
        # 2 hits / 3 lookups = 0.666...
        assert hit_rate > 0.6 and hit_rate < 0.7
