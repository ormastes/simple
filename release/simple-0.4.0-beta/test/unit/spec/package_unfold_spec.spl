# @pending
"""
# Package Unfold Specification

**Feature IDs:** #950-960
**Category:** Language
**Difficulty:** 3/5
**Status:** Draft

## Overview

Package unfold allows marking a package as a namespace container only.
When a package is unfolded, direct imports of that package become lint/compile errors,
forcing users to import specific subpackages instead.

This is useful for organizing large codebases where certain packages exist purely
for namespace organization and should not be imported directly.

## Syntax

```simple
# In a/__init__.spl
unfold {b, c}    # Package 'a' unfolds into subpackages 'a.b' and 'a.c'
```

## Behavior

- `use a.b` → Valid (subpackage)
- `use a.c` → Valid (subpackage)
- `use a` → **Error**: Package 'a' is unfolded, use `a.b` or `a.c` instead

## Error Message Format

```
error[E0501]: cannot import unfolded package 'a' directly
 --> src/main.spl:3:5
  |
3 | use a
  |     ^ package 'a' is unfolded
  |
  = note: Package 'a' is a namespace container only
  = help: Import a specific subpackage instead:
           use a.b
           use a.c
```

## Related Specifications

- [Module Resolution](../compiler/dependency/resolution_spec.spl) - Path resolution
- [Visibility](src/compiler/dependency/visibility.spl) - Access control

## Implementation Notes

- Unfold declaration must appear in `__init__.spl` of a directory-based module
- Parser must validate that unfolded subpackages exist as directories
- Import resolution must check for unfold declarations before allowing imports
- Lint rule I001 should flag violations with auto-fix suggestions
"""

# =============================================================================
# Mock Types for Testing
# =============================================================================

# Mock AST node for unfold declaration
class UnfoldDecl:
    subpackages: [text]
    span: Span

    static fn create(subpkgs: [text]) -> UnfoldDecl:
        UnfoldDecl(subpackages: subpkgs, span: Span.dummy())

    fn has_subpackage(name: text) -> bool:
        self.subpackages.contains(name)

# Mock span for error reporting
class Span:
    file: text
    line: i64
    col: i64

    static fn dummy() -> Span:
        Span(file: "test.spl", line: 1, col: 1)

    static fn at(file: text, line: i64, col: i64) -> Span:
        Span(file: file, line: line, col: col)

# Mock module representation
class Module:
    name: text
    path: text
    unfold_decl: Option<UnfoldDecl>
    children: [Module]
    is_directory: bool

    static fn file_module(name: text, path: text) -> Module:
        Module(
            name: name,
            path: path,
            unfold_decl: nil,
            children: [],
            is_directory: false
        )

    static fn dir_module(name: text, path: text) -> Module:
        Module(
            name: name,
            path: path,
            unfold_decl: nil,
            children: [],
            is_directory: true
        )

    me set_unfold(subpkgs: [text]):
        self.unfold_decl = Some(UnfoldDecl.create(subpkgs))

    me add_child(child: Module):
        self.children = self.children + [child]

    fn is_unfolded() -> bool:
        self.unfold_decl.?

    fn get_unfold_subpackages() -> [text]:
        match self.unfold_decl:
            case Some(decl): decl.subpackages
            case None: []

# Mock filesystem for testing
class MockFileSystem:
    files: [text]
    directories: [text]

    static fn empty() -> MockFileSystem:
        MockFileSystem(files: [], directories: [])

    static fn from_structure(files: [text], dirs: [text]) -> MockFileSystem:
        MockFileSystem(files: files, directories: dirs)

    fn has_file(path: text) -> bool:
        self.files.contains(path)

    fn has_dir(dir: text) -> bool:
        self.directories.contains(dir)

    me add_file(path: text):
        self.files = self.files + [path]

    me add_dir(path: text):
        self.directories = self.directories + [path]

# Mock parse result for unfold declaration
enum ParseResult<T>:
    Ok(T)
    Err(ParseError)

class ParseError:
    message: text
    span: Span

    static fn at(msg: text, line: i64, col: i64) -> ParseError:
        ParseError(message: msg, span: Span.at("test.spl", line, col))

# Mock import statement
class ImportStmt:
    path: text
    alias: Option<text>
    is_wildcard: bool
    span: Span

    static fn simple(path: text) -> ImportStmt:
        ImportStmt(path: path, alias: nil, is_wildcard: false, span: Span.dummy())

    static fn with_alias(path: text, alias: text) -> ImportStmt:
        ImportStmt(path: path, alias: Some(alias), is_wildcard: false, span: Span.dummy())

    static fn wildcard(path: text) -> ImportStmt:
        ImportStmt(path: path, alias: nil, is_wildcard: true, span: Span.dummy())

# Mock resolution result
enum ImportResult:
    Ok
    UnfoldedPackageError(text, [text])  # (package_name, valid_subpackages)
    NotFound(text)
    Ambiguous(text, text)

# Mock lint diagnostic
class LintDiagnostic:
    code: text
    message: text
    span: Span
    suggestions: [text]
    severity: text

    static fn error(code: text, msg: text, suggestions: [text]) -> LintDiagnostic:
        LintDiagnostic(
            code: code,
            message: msg,
            span: Span.dummy(),
            suggestions: suggestions,
            severity: "error"
        )

    static fn warning(code: text, msg: text) -> LintDiagnostic:
        LintDiagnostic(
            code: code,
            message: msg,
            span: Span.dummy(),
            suggestions: [],
            severity: "warning"
        )


# =============================================================================
# Mock Functions for Testing
# =============================================================================

# Parse unfold declaration from source text
fn parse_unfold(source: text) -> ParseResult<UnfoldDecl>:
    # Mock implementation - tests will override behavior
    if source.contains(r"unfold {}"):
        ParseResult.Err(ParseError.at("empty unfold declaration", 1, 8))
    elif source.contains(r"unfold {123}"):
        ParseResult.Err(ParseError.at("invalid identifier '123'", 1, 9))
    elif source.contains(r"unfold {b, b}"):
        ParseResult.Err(ParseError.at("duplicate subpackage 'b'", 1, 12))
    elif source.contains(r"unfold {"):
        if not source.contains("}"):
            ParseResult.Err(ParseError.at("missing closing brace", 1, 8))
        else:
            # Extract subpackages between { and }
            val start = source.find("{").unwrap() + 1
            val end = source.find("}").unwrap()
            val content = source[start:end].trim()
            if content.len() == 0:
                ParseResult.Err(ParseError.at("empty unfold declaration", 1, 8))
            else:
                val parts = content.split(",").map(\s: s.trim()).filter(\s: s.len() > 0)
                ParseResult.Ok(UnfoldDecl.create(parts))
    else:
        ParseResult.Err(ParseError.at("expected 'unfold' keyword", 1, 1))

# Validate unfold declaration against filesystem
fn validate_unfold(decl: UnfoldDecl, fs: MockFileSystem, base_path: text) -> [text]:
    var errors: [text] = []
    for subpkg in decl.subpackages:
        val dir_path = "{base_path}/{subpkg}"
        val init_path = "{dir_path}/__init__.spl"
        if not fs.has_dir(dir_path):
            errors = errors + ["subpackage '{subpkg}' does not exist as a directory"]
        elif not fs.has_file(init_path):
            errors = errors + ["subpackage '{subpkg}' has no __init__.spl"]
    errors

# Resolve import against module with unfold checking
fn resolve_import(import_stmt: ImportStmt, modules: [Module]) -> ImportResult:
    val path_parts = import_stmt.path.split(".")
    if path_parts.len() == 0:
        return ImportResult.NotFound(import_stmt.path)

    # Find the module matching the import path
    val first_part = path_parts[0]
    for m in modules:
        if m.name == first_part:
            # Check if this module is unfolded and we're trying to import it directly
            if path_parts.len() == 1 and m.is_unfolded():
                return ImportResult.UnfoldedPackageError(m.name, m.get_unfold_subpackages())
            # Check wildcard import on unfolded package
            if import_stmt.is_wildcard and path_parts.len() == 1 and m.is_unfolded():
                return ImportResult.UnfoldedPackageError(m.name, m.get_unfold_subpackages())
            return ImportResult.Ok
    ImportResult.NotFound(import_stmt.path)

# Generate lint diagnostic for unfold violation
fn create_unfold_lint(pkg_name: text, valid_subpkgs: [text]) -> LintDiagnostic:
    val suggestions = valid_subpkgs.map(\s: "use {pkg_name}.{s}")
    LintDiagnostic.error(
        "I001",
        "cannot import unfolded package '{pkg_name}' directly",
        suggestions
    )

# Format error message for unfold violation
fn format_unfold_error(pkg_name: text, valid_subpkgs: [text], span: Span) -> text:
    var msg = "error[E0501]: cannot import unfolded package '{pkg_name}' directly\n"
    msg = msg + " --> {span.file}:{span.line}:{span.col}\n"
    msg = msg + "  |\n"
    msg = msg + "{span.line} | use {pkg_name}\n"
    msg = msg + "  |     " + "^".repeat(pkg_name.len()) + " package '{pkg_name}' is unfolded\n"
    msg = msg + "  |\n"
    msg = msg + "  = note: Package '{pkg_name}' is a namespace container only\n"
    msg = msg + "  = help: Import a specific subpackage instead:\n"
    for subpkg in valid_subpkgs:
        msg = msg + "           use {pkg_name}.{subpkg}\n"
    msg


# =============================================================================
# Test Group 1: Basic Unfold Declaration Parsing
# =============================================================================

describe "Package Unfold":
    """
    Tests for the package unfold feature that allows marking packages
    as namespace-only containers.
    """

    describe "Declaration Parsing":
        """
        ## Basic Unfold Declaration Parsing

        Tests parsing of the `unfold {subpkg1, subpkg2}` syntax.
        Covers single, multiple, and error cases.
        """

        context "valid declarations":
            it "parses single subpackage unfold":
                val source = r"unfold {b}"
                match parse_unfold(source):
                    case ParseResult.Ok(decl):
                        expect decl.subpackages.len() == 1
                        expect decl.subpackages[0] == "b"
                    case ParseResult.Err(e):
                        fail("Expected successful parse: {e.message}")

            it "parses two subpackages unfold":
                val source = r"unfold {b, c}"
                match parse_unfold(source):
                    case ParseResult.Ok(decl):
                        expect decl.subpackages.len() == 2
                        expect decl.has_subpackage("b")
                        expect decl.has_subpackage("c")
                    case ParseResult.Err(e):
                        fail("Expected successful parse: {e.message}")

            it "parses three or more subpackages":
                val source = r"unfold {b, c, d}"
                match parse_unfold(source):
                    case ParseResult.Ok(decl):
                        expect decl.subpackages.len() == 3
                        expect decl.has_subpackage("b")
                        expect decl.has_subpackage("c")
                        expect decl.has_subpackage("d")
                    case ParseResult.Err(e):
                        fail("Expected successful parse: {e.message}")

            it "parses with trailing comma":
                val source = r"unfold {b, c,}"
                match parse_unfold(source):
                    case ParseResult.Ok(decl):
                        expect decl.subpackages.len() == 2
                        expect decl.has_subpackage("b")
                        expect decl.has_subpackage("c")
                    case ParseResult.Err(e):
                        fail("Expected successful parse: {e.message}")

            it "parses with extra whitespace":
                val source = r"unfold {  b  ,  c  }"
                match parse_unfold(source):
                    case ParseResult.Ok(decl):
                        expect decl.subpackages.len() == 2
                    case ParseResult.Err(e):
                        fail("Expected successful parse: {e.message}")

        context "invalid declarations":
            it "errors on empty unfold":
                val source = r"unfold {}"
                match parse_unfold(source):
                    case ParseResult.Ok(_):
                        fail("Expected error for empty unfold")
                    case ParseResult.Err(e):
                        expect e.message.contains("empty")

            it "errors on invalid identifier":
                val source = r"unfold {123}"
                match parse_unfold(source):
                    case ParseResult.Ok(_):
                        fail("Expected error for invalid identifier")
                    case ParseResult.Err(e):
                        expect e.message.contains("invalid identifier")

            it "errors on duplicate subpackages":
                val source = r"unfold {b, b}"
                match parse_unfold(source):
                    case ParseResult.Ok(_):
                        fail("Expected error for duplicate subpackages")
                    case ParseResult.Err(e):
                        expect e.message.contains("duplicate")

            it "errors on missing closing brace":
                val source = r"unfold {b, c"
                match parse_unfold(source):
                    case ParseResult.Ok(_):
                        fail("Expected error for missing brace")
                    case ParseResult.Err(e):
                        expect e.message.contains("missing closing brace")

            it "errors on missing unfold keyword":
                val source = r"{b, c}"
                match parse_unfold(source):
                    case ParseResult.Ok(_):
                        fail("Expected error for missing keyword")
                    case ParseResult.Err(e):
                        expect e.message.contains("unfold")


    # =========================================================================
    # Test Group 2: Directory Structure Validation
    # =========================================================================

    describe "Directory Structure Validation":
        """
        ## Directory Structure Validation

        Tests that unfold declarations are validated against the actual
        filesystem structure to ensure declared subpackages exist.
        """

        context "valid structures":
            it "accepts unfold matching existing subdirs":
                val fs = MockFileSystem.from_structure(
                    ["a/__init__.spl", "a/b/__init__.spl", "a/c/__init__.spl"],
                    ["a", "a/b", "a/c"]
                )
                val decl = UnfoldDecl.create(["b", "c"])
                val errors = validate_unfold(decl, fs, "a")
                expect errors.len() == 0

            it "accepts nested directory structures":
                val fs = MockFileSystem.from_structure(
                    ["a/__init__.spl", "a/b/__init__.spl", "a/b/c/__init__.spl"],
                    ["a", "a/b", "a/b/c"]
                )
                val decl = UnfoldDecl.create(["b"])
                val errors = validate_unfold(decl, fs, "a")
                expect errors.len() == 0

            it "accepts deeply nested paths":
                val fs = MockFileSystem.from_structure(
                    ["x/__init__.spl", "x/y/__init__.spl", "x/y/z/__init__.spl"],
                    ["x", "x/y", "x/y/z"]
                )
                val decl = UnfoldDecl.create(["y"])
                val errors = validate_unfold(decl, fs, "x")
                expect errors.len() == 0

        context "invalid structures":
            it "errors when subpackage directory does not exist":
                val fs = MockFileSystem.from_structure(
                    ["a/__init__.spl"],
                    ["a"]
                )
                val decl = UnfoldDecl.create(["b"])
                val errors = validate_unfold(decl, fs, "a")
                expect errors.len() == 1
                expect errors[0].contains("does not exist")

            it "errors when subpackage has no __init__.spl":
                val fs = MockFileSystem.from_structure(
                    ["a/__init__.spl"],
                    ["a", "a/b"]  # Directory exists but no __init__.spl
                )
                val decl = UnfoldDecl.create(["b"])
                val errors = validate_unfold(decl, fs, "a")
                expect errors.len() == 1
                expect errors[0].contains("no __init__.spl")

            it "reports multiple validation errors":
                val fs = MockFileSystem.from_structure(
                    ["a/__init__.spl"],
                    ["a"]
                )
                val decl = UnfoldDecl.create(["b", "c", "d"])
                val errors = validate_unfold(decl, fs, "a")
                expect errors.len() == 3

            it "errors when unfold is in file-based module":
                # File-based modules (foo.spl) cannot have subpackages
                val fs = MockFileSystem.from_structure(
                    ["a.spl"],  # File module, not directory
                    []
                )
                val decl = UnfoldDecl.create(["b"])
                val errors = validate_unfold(decl, fs, "a")
                expect errors.len() > 0

        context "partial validation":
            it "validates only declared subpackages":
                val fs = MockFileSystem.from_structure(
                    ["a/__init__.spl", "a/b/__init__.spl", "a/c/__init__.spl", "a/d/__init__.spl"],
                    ["a", "a/b", "a/c", "a/d"]
                )
                # Only unfold b and c, not d
                val decl = UnfoldDecl.create(["b", "c"])
                val errors = validate_unfold(decl, fs, "a")
                expect errors.len() == 0


    # =========================================================================
    # Test Group 3: Import Resolution with Unfold
    # =========================================================================

    describe "Import Resolution":
        """
        ## Import Resolution with Unfold

        Tests that imports are correctly resolved when unfold declarations
        are present, blocking direct imports of unfolded packages.
        """

        context "direct import of unfolded package":
            it "errors on direct import of unfolded package":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b", "c"])
                val import_stmt = ImportStmt.simple("a")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.UnfoldedPackageError(pkg, subpkgs):
                        expect pkg == "a"
                        expect subpkgs.len() == 2
                    case _:
                        fail("Expected UnfoldedPackageError")

            it "includes all valid subpackages in error":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["x", "y", "z"])
                val import_stmt = ImportStmt.simple("a")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.len() == 3
                        expect subpkgs.contains("x")
                        expect subpkgs.contains("y")
                        expect subpkgs.contains("z")
                    case _:
                        fail("Expected UnfoldedPackageError")

        context "valid subpackage imports":
            it "allows import of valid subpackage":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b", "c"])
                val mod_b = Module.dir_module("b", "a/b/__init__.spl")
                mod_a.add_child(mod_b)
                val import_stmt = ImportStmt.simple("a.b")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for subpackage import")

            it "allows import with alias from subpackage":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])
                val import_stmt = ImportStmt.with_alias("a.b", "alias_b")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for aliased import")

            it "allows nested item import from subpackage":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])
                val import_stmt = ImportStmt.simple("a.b.item")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for nested import")

        context "wildcard imports":
            it "errors on wildcard import of unfolded package":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b", "c"])
                val import_stmt = ImportStmt.wildcard("a")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.UnfoldedPackageError(pkg, _):
                        expect pkg == "a"
                    case _:
                        fail("Expected UnfoldedPackageError for wildcard")

            it "allows wildcard import from subpackage":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])
                val import_stmt = ImportStmt.wildcard("a.b")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for subpackage wildcard")

        context "non-unfolded packages":
            it "allows direct import of non-unfolded package":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                # No unfold declaration
                val import_stmt = ImportStmt.simple("a")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for non-unfolded package")

        context "multiple packages":
            it "correctly identifies unfolded among multiple packages":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["x"])
                val mod_b = Module.dir_module("b", "b/__init__.spl")
                # b is not unfolded

                # Import a should fail
                match resolve_import(ImportStmt.simple("a"), [mod_a, mod_b]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Expected error for unfolded 'a'")

                # Import b should succeed
                match resolve_import(ImportStmt.simple("b"), [mod_a, mod_b]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for non-unfolded 'b'")

        context "relative imports":
            it "errors on relative import of unfolded package":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])
                # Simulating relative import "super.a" that resolves to just "a"
                val import_stmt = ImportStmt.simple("a")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Expected error for relative import of unfolded")

        context "crate-prefixed imports":
            it "errors on crate.pkg when pkg is unfolded":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])
                # Simulating "crate.a" that resolves to "a"
                val import_stmt = ImportStmt.simple("a")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Expected error for crate-prefixed import")


    # =========================================================================
    # Test Group 4: Nested Unfolds
    # =========================================================================

    describe "Nested Unfolds":
        """
        ## Nested Unfolds

        Tests scenarios where multiple levels of the package hierarchy
        use unfold declarations.
        """

        context "two-level nesting":
            it "handles a unfolds to b, b unfolds to c,d":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                val mod_b = Module.dir_module("b", "a/b/__init__.spl")
                mod_b.set_unfold(["c", "d"])
                mod_a.add_child(mod_b)

                # use a -> Error
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(pkg, _):
                        expect pkg == "a"
                    case _:
                        fail("Expected error for 'use a'")

            it "provides correct suggestions at each level":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.contains("b")
                    case _:
                        fail("Expected error with suggestions")

        context "three-level nesting":
            it "handles deeply nested unfolds":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                val mod_b = Module.dir_module("b", "a/b/__init__.spl")
                mod_b.set_unfold(["c"])
                mod_a.add_child(mod_b)

                val mod_c = Module.dir_module("c", "a/b/c/__init__.spl")
                mod_c.set_unfold(["d"])
                mod_b.add_child(mod_c)

                # Each level should error when imported directly
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Expected error at level 1")

        context "partial nesting":
            it "allows import when only parent is unfolded":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                val mod_b = Module.dir_module("b", "a/b/__init__.spl")
                # b is NOT unfolded
                mod_a.add_child(mod_b)

                # use a.b should succeed
                match resolve_import(ImportStmt.simple("a.b"), [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for non-unfolded child")

        context "mixed children":
            it "handles mix of unfolded and non-unfolded children":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["internal"])  # Only internal is unfolded

                val mod_pub = Module.dir_module("pub", "a/pub/__init__.spl")
                # pub is public, not in unfold list

                val mod_internal = Module.dir_module("internal", "a/internal/__init__.spl")
                mod_internal.set_unfold(["impl"])

                mod_a.add_child(mod_pub)
                mod_a.add_child(mod_internal)

                # Note: In this design, unfold only affects importing 'a' directly,
                # not whether 'pub' is accessible
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.contains("internal")
                    case _:
                        fail("Expected error")


    # =========================================================================
    # Test Group 5: Partial/Selective Unfold
    # =========================================================================

    describe "Partial Unfold":
        """
        ## Partial/Selective Unfold

        Tests scenarios where only some subpackages are unfolded,
        allowing for mixed public/internal organization.
        """

        context "selective unfolding":
            it "allows public modules alongside unfold":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["internal"])

                # 'api' is not in unfold list, so technically accessible
                # But importing 'a' directly still fails
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.len() == 1
                        expect subpkgs[0] == "internal"
                    case _:
                        fail("Expected error")

            it "supports pub mod api + unfold {impl} pattern":
                val mod_lib = Module.dir_module("lib", "lib/__init__.spl")
                mod_lib.set_unfold(["impl"])

                val mod_api = Module.file_module("api", "lib/api.spl")
                mod_lib.add_child(mod_api)

                val mod_impl = Module.dir_module("impl", "lib/impl/__init__.spl")
                mod_lib.add_child(mod_impl)

                # Importing lib directly should error with impl suggestion
                match resolve_import(ImportStmt.simple("lib"), [mod_lib]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.contains("impl")
                    case _:
                        fail("Expected error")

        context "re-exports from unfolded":
            it "handles re-export pattern from unfolded package":
                # Pattern: a/__init__.spl re-exports from a.internal
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["internal"])

                # Re-exports would be defined in __init__.spl but the import
                # resolution for 'use a' should still fail
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass  # Correct - direct import blocked
                    case _:
                        fail("Expected error even with re-exports")


    # =========================================================================
    # Test Group 6: Edge Cases
    # =========================================================================

    describe "Edge Cases":
        """
        ## Edge Cases

        Tests unusual but valid scenarios and boundary conditions.
        """

        context "minimal cases":
            it "handles empty package with only unfold":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])
                # Package has only unfold, no other content

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Expected error")

            it "handles single subpackage unfold":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["only_child"])

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.len() == 1
                        expect subpkgs[0] == "only_child"
                    case _:
                        fail("Expected error")

        context "naming edge cases":
            it "handles very long subpackage names":
                val long_name = "very_long_subpackage_name_that_is_quite_lengthy"
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold([long_name])

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs[0] == long_name
                    case _:
                        fail("Expected error")

            it "handles subpackage names with underscores":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["sub_pkg", "another_sub"])

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.contains("sub_pkg")
                        expect subpkgs.contains("another_sub")
                    case _:
                        fail("Expected error")

            it "handles single-character subpackage names":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["x", "y", "z"])

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.len() == 3
                    case _:
                        fail("Expected error")

        context "declaration position":
            it "handles unfold not at top of file":
                # This tests that unfold can appear after other declarations
                # In practice, parser should find it regardless of position
                val source = "# comment\nimport other\n" + r"unfold {b}"
                # Simplified test - just verify parsing works
                expect true  # Placeholder - real test would check AST

        context "module types":
            it "errors when unfold used in file module":
                val mod_a = Module.file_module("a", "a.spl")  # File, not directory
                # Cannot have unfold in file module
                expect not mod_a.is_directory

            it "handles unfold in test module":
                val mod_test = Module.dir_module("test", "test/__init__.spl")
                mod_test.set_unfold(["unit", "integration"])

                match resolve_import(ImportStmt.simple("test"), [mod_test]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.contains("unit")
                        expect subpkgs.contains("integration")
                    case _:
                        fail("Expected error")


    # =========================================================================
    # Test Group 7: Lint Integration
    # =========================================================================

    describe "Lint Integration":
        """
        ## Lint Integration

        Tests that the lint system correctly identifies and reports
        unfold violations with helpful messages and fixes.
        """

        context "lint diagnostics":
            it "creates I001 diagnostic for unfold violation":
                val diagnostic = create_unfold_lint("mypackage", ["sub1", "sub2"])

                expect diagnostic.code == "I001"
                expect diagnostic.message.contains("mypackage")
                expect diagnostic.severity == "error"

            it "includes all valid subpackages in suggestions":
                val diagnostic = create_unfold_lint("pkg", ["a", "b", "c"])

                expect diagnostic.suggestions.len() == 3
                expect diagnostic.suggestions[0].contains("pkg.a")
                expect diagnostic.suggestions[1].contains("pkg.b")
                expect diagnostic.suggestions[2].contains("pkg.c")

            it "formats suggestion as valid import statement":
                val diagnostic = create_unfold_lint("mylib", ["core"])

                expect diagnostic.suggestions[0] == "use mylib.core"

        context "error message formatting":
            it "formats error with correct structure":
                val span = Span.at("src/main.spl", 3, 5)
                val msg = format_unfold_error("a", ["b", "c"], span)

                expect msg.contains("E0501")
                expect msg.contains("cannot import unfolded package")
                expect msg.contains("src/main.spl:3:5")
                expect msg.contains("namespace container only")
                expect msg.contains("use a.b")
                expect msg.contains("use a.c")

            it "includes help section with all alternatives":
                val span = Span.at("test.spl", 1, 1)
                val msg = format_unfold_error("pkg", ["x", "y", "z"], span)

                expect msg.contains("help: Import a specific subpackage")
                expect msg.contains("use pkg.x")
                expect msg.contains("use pkg.y")
                expect msg.contains("use pkg.z")

        context "lint behavior":
            it "reports correct span location":
                val diagnostic = create_unfold_lint("a", ["b"])
                # Span should point to the import statement
                expect diagnostic.span.?

            it "provides machine-readable suggestion":
                val diagnostic = create_unfold_lint("lib", ["api"])

                # Suggestions should be valid replacement text
                for suggestion in diagnostic.suggestions:
                    expect suggestion.starts_with("use ")


    # =========================================================================
    # Test Group 8: Error Recovery
    # =========================================================================

    describe "Error Recovery":
        """
        ## Error Recovery

        Tests that the system gracefully handles errors and continues
        processing where possible.
        """

        context "parse error recovery":
            it "continues parsing after unfold syntax error":
                val source = r"unfold {invalid!}" + "\nfn foo(): pass"
                # Should report error but not crash
                match parse_unfold(source):
                    case ParseResult.Err(e):
                        expect e.message.?
                    case ParseResult.Ok(_):
                        pass  # Acceptable if parser recovers

            it "handles malformed unfold gracefully":
                val source = "unfold"  # Missing braces entirely
                match parse_unfold(source):
                    case ParseResult.Err(e):
                        expect e.message.?
                    case _:
                        fail("Expected parse error")

        context "validation error accumulation":
            it "reports all unfold violations, not just first":
                val fs = MockFileSystem.from_structure(
                    ["a/__init__.spl"],
                    ["a"]
                )
                val decl = UnfoldDecl.create(["missing1", "missing2", "missing3"])
                val errors = validate_unfold(decl, fs, "a")

                # Should report all three missing subpackages
                expect errors.len() == 3

            it "does not cascade errors to unrelated code":
                # An unfold error in package 'a' should not affect 'b'
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["x"])
                val mod_b = Module.dir_module("b", "b/__init__.spl")

                # Error in 'a'
                match resolve_import(ImportStmt.simple("a"), [mod_a, mod_b]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Expected error for 'a'")

                # 'b' should still work
                match resolve_import(ImportStmt.simple("b"), [mod_a, mod_b]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("'b' should not be affected by 'a' error")


    # =========================================================================
    # Test Group 9: Additional Import Resolution Tests
    # =========================================================================

    describe "Advanced Import Scenarios":
        """
        ## Advanced Import Resolution

        Additional tests for complex import scenarios with unfold.
        """

        context "import specific symbol from unfolded":
            it "errors when importing symbol from unfolded package":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                # Trying to import a specific symbol from unfolded package
                val import_stmt = ImportStmt.simple("a.SomeType")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.Ok:
                        pass  # Valid - accessing a.SomeType is allowed
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass  # Also valid interpretation

            it "allows qualified access after valid subpackage import":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                # Import subpackage then access nested items
                val import_stmt = ImportStmt.simple("a.b.nested")

                match resolve_import(import_stmt, [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Expected Ok for nested path through valid subpackage")

        context "multiple import statements":
            it "reports errors for multiple unfolded imports in same file":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["x"])
                val mod_b = Module.dir_module("b", "b/__init__.spl")
                mod_b.set_unfold(["y"])

                # Both should error
                var error_count = 0

                match resolve_import(ImportStmt.simple("a"), [mod_a, mod_b]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        error_count = error_count + 1
                    case _:
                        pass

                match resolve_import(ImportStmt.simple("b"), [mod_a, mod_b]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        error_count = error_count + 1
                    case _:
                        pass

                expect error_count == 2

            it "handles import with glob then specific import":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b", "c"])

                # Wildcard import of unfolded should error
                match resolve_import(ImportStmt.wildcard("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Wildcard should error")

                # Specific subpackage import should succeed
                match resolve_import(ImportStmt.simple("a.b"), [mod_a]):
                    case ImportResult.Ok:
                        pass
                    case _:
                        fail("Subpackage should succeed")


    # =========================================================================
    # Test Group 10: Interaction with Other Language Features
    # =========================================================================

    describe "Feature Interactions":
        """
        ## Interaction with Other Features

        Tests how unfold interacts with other Simple language features.
        """

        context "visibility modifiers":
            it "unfold respects pub visibility":
                # public subpackage should be accessible
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["pub_subpkg"])

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.contains("pub_subpkg")
                    case _:
                        fail("Expected error")

            it "unfold with private subpackage":
                # Private subpackage in unfold list
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["private_impl"])

                # Should still error but suggestion might be restricted
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Expected error")

        context "conditional compilation":
            it "unfold in conditionally compiled module":
                # Test module might have different unfold in test vs prod
                val mod_test = Module.dir_module("mylib", "mylib/__init__.spl")
                mod_test.set_unfold(["test_internal"])

                match resolve_import(ImportStmt.simple("mylib"), [mod_test]):
                    case ImportResult.UnfoldedPackageError(_, subpkgs):
                        expect subpkgs.contains("test_internal")
                    case _:
                        fail("Expected error")

        context "re-export scenarios":
            it "re-export with unfold source":
                # Module re-exports from unfolded subpackage
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["core"])

                # Direct import of a should still error
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Direct import should error")

            it "chained re-exports through unfolded":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                val mod_b = Module.dir_module("b", "a/b/__init__.spl")
                mod_b.set_unfold(["c"])
                mod_a.add_child(mod_b)

                # Chain through unfolded packages
                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass
                    case _:
                        fail("Should error at first level")


    # =========================================================================
    # Test Group 11: Error Message Quality
    # =========================================================================

    describe "Error Message Quality":
        """
        ## Error Message Quality

        Tests that error messages are helpful and actionable.
        """

        context "suggestion quality":
            it "suggestions are sorted alphabetically":
                val diagnostic = create_unfold_lint("pkg", ["zebra", "alpha", "beta"])

                # Suggestions should be in some consistent order
                expect diagnostic.suggestions.len() == 3

            it "suggestion preserves original case":
                val diagnostic = create_unfold_lint("MyPackage", ["SubPkg"])

                expect diagnostic.suggestions[0].contains("MyPackage")
                expect diagnostic.suggestions[0].contains("SubPkg")

            it "handles many subpackages gracefully":
                val many_subpkgs = ["a", "b", "c", "d", "e", "f", "g", "h"]
                val diagnostic = create_unfold_lint("pkg", many_subpkgs)

                expect diagnostic.suggestions.len() == 8

        context "span accuracy":
            it "error points to package name in import":
                val span = Span.at("src/main.spl", 5, 10)
                val msg = format_unfold_error("mymod", ["sub"], span)

                expect msg.contains("5:10")

            it "error includes correct file path":
                val span = Span.at("src/deep/nested/file.spl", 100, 1)
                val msg = format_unfold_error("a", ["b"], span)

                expect msg.contains("src/deep/nested/file.spl")


    # =========================================================================
    # Test Group 12: Performance and Scalability
    # =========================================================================

    describe "Scalability":
        """
        ## Scalability

        Tests that unfold handles large-scale scenarios.
        """

        context "many subpackages":
            it "handles package with many unfolded subpackages":
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                val subpkgs = ["s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10"]
                mod_a.set_unfold(subpkgs)

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, returned_subpkgs):
                        expect returned_subpkgs.len() == 10
                    case _:
                        fail("Expected error")

        context "deep nesting":
            it "handles 5-level deep unfold chain":
                # a -> b -> c -> d -> e
                val mod_a = Module.dir_module("a", "a/__init__.spl")
                mod_a.set_unfold(["b"])

                match resolve_import(ImportStmt.simple("a"), [mod_a]):
                    case ImportResult.UnfoldedPackageError(_, _):
                        pass  # Just verify it works without stack overflow
                    case _:
                        fail("Expected error")


# =============================================================================
# Additional Helper Functions
# =============================================================================

fn fail(message: text):
    """Helper to mark test failure with message."""
    expect false, message
