"""
# Backend Basic Tests

**Feature IDs:** #920-925
**Category:** Testing
**Difficulty:** 3/5
**Status:** In Progress

## Overview

Basic tests for backend instruction completeness verification.
Tests the MIR test builder API and backend capability detection.

## Testing Strategy

1. **Builder API:** Verify fluent builder interface works
2. **Instruction Coverage:** Test key instruction categories
3. **Backend Selection:** Verify backend targeting works
4. **Test Generation:** Verify test case metadata is correct
"""

use sspec.{describe, it, expect, context}
use compiler.backend.mir_test_builder.{
    MirTestBuilder,
    BackendTarget,
    new_test_builder,
    simple_arithmetic_test,
    control_flow_test
}

# ============================================================================
# Test Group 1: Builder API
# ============================================================================

describe "MIR Test Builder - API":
    """
    ## Builder Interface

    Test the fluent builder API for constructing MIR test cases.
    """

    context "basic construction":
        it "creates builder with factory function":
            val builder = new_test_builder("test1")
            expect builder.test_name == "test1"

        it "builds test case with metadata":
            val builder = new_test_builder("arithmetic")
            builder.add_const_int(0, 42)
            builder.add_ret(0)
            val test_case = builder.build()

            expect test_case.name == "arithmetic"
            expect test_case.instructions.len() == 2

    context "instruction generation":
        it "generates const_int instruction":
            val builder = new_test_builder("const_test")
            builder.add_const_int(5, 123)
            val test_case = builder.build()

            expect test_case.instructions.len() == 1
            expect test_case.instructions[0].contains("123")

        it "generates binop instruction":
            val builder = new_test_builder("binop_test")
            builder.add_const_int(0, 10)
            builder.add_const_int(1, 20)
            builder.add_binop(2, "add", 0, 1)
            val test_case = builder.build()

            expect test_case.instructions.len() == 3
            expect test_case.instructions[2].contains("add")

# ============================================================================
# Test Group 2: Helper Functions
# ============================================================================

describe "MIR Test Builder - Helpers":
    """
    ## Pre-built Test Patterns

    Test the helper functions that create common test patterns.
    """

    context "arithmetic helper":
        it "creates simple arithmetic test":
            val test_case = simple_arithmetic_test()

            expect test_case.name == "simple_arithmetic"
            expect test_case.instructions.len() == 4  # 2 consts + 1 add + 1 ret

        it "uses correct backend targets":
            val test_case = simple_arithmetic_test()

            # Should work on all backends except Vulkan (CPU operation)
            expect test_case.expected_backends.len() >= 3

    context "control flow helper":
        it "creates control flow test":
            val test_case = control_flow_test()

            expect test_case.name == "control_flow"
            expect test_case.instructions.len() >= 2

# ============================================================================
# Test Group 3: Backend Selection
# ============================================================================

describe "MIR Test Builder - Backend Targeting":
    """
    ## Backend Selection

    Test backend target selection for tests.
    """

    context "single backend":
        it "restricts to interpreter only":
            val builder = new_test_builder("interpreter_only")
            builder.only_backend(BackendTarget.Interpreter)
            val test_case = builder.build()

            expect test_case.expected_backends.len() == 1
            expect test_case.expected_backends[0] == BackendTarget.Interpreter

    context "multiple backends":
        it "allows multiple backend targets":
            val builder = new_test_builder("multi_backend")
            builder.only_backends([BackendTarget.Cranelift, BackendTarget.LLVM])
            val test_case = builder.build()

            expect test_case.expected_backends.len() == 2

# ============================================================================
# Test Group 4: Instruction Categories
# ============================================================================

describe "MIR Test Builder - Instruction Types":
    """
    ## Instruction Coverage

    Verify different instruction categories can be generated.
    """

    context "constants":
        it "generates integer constant":
            val builder = new_test_builder("int_const")
            builder.add_const_int(0, 42)
            val test_case = builder.build()

            expect test_case.instructions[0].contains("const_int")

        it "generates float constant":
            val builder = new_test_builder("float_const")
            builder.add_const_float(0, 3.14)
            val test_case = builder.build()

            expect test_case.instructions[0].contains("const_float")

        it "generates bool constant":
            val builder = new_test_builder("bool_const")
            builder.add_const_bool(0, true)
            val test_case = builder.build()

            expect test_case.instructions[0].contains("const_bool")

    context "control flow":
        it "generates return instruction":
            val builder = new_test_builder("ret_test")
            builder.add_const_int(0, 0)
            builder.add_ret(0)
            val test_case = builder.build()

            expect test_case.instructions[1].contains("ret")

        it "generates void return":
            val builder = new_test_builder("ret_void_test")
            builder.add_ret_void()
            val test_case = builder.build()

            expect test_case.instructions[0].contains("void")

        it "generates branch instruction":
            val builder = new_test_builder("branch_test")
            builder.add_const_bool(0, true)
            builder.add_branch(0, 1, 2)
            val test_case = builder.build()

            expect test_case.instructions[1].contains("br")

        it "generates jump instruction":
            val builder = new_test_builder("jump_test")
            builder.add_jump(5)
            val test_case = builder.build()

            expect test_case.instructions[0].contains("jmp")

# ============================================================================
# Test Group 5: Register Allocation
# ============================================================================

describe "MIR Test Builder - Register Tracking":
    """
    ## Virtual Register Allocation

    Verify the builder tracks virtual register usage.
    """

    context "register numbering":
        it "tracks next available register":
            val builder = new_test_builder("reg_test")
            expect builder.next_vreg == 0

            builder.add_const_int(5, 100)
            expect builder.next_vreg == 6  # Updated to dest + 1

        it "handles non-sequential register IDs":
            val builder = new_test_builder("nonseq_test")
            builder.add_const_int(10, 1)
            builder.add_const_int(2, 2)
            builder.add_const_int(20, 3)

            expect builder.next_vreg == 21  # Tracks highest used + 1
