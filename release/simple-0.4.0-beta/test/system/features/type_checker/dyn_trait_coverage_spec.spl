# DynTrait Type Checking - Coverage Tests
# These tests exercise the Rust type checker implementation
# Run with: simple test test/system/features/type_checker/dyn_trait_coverage_spec.spl

feature "DynTrait Type System":
    """
    Dynamic trait objects (dyn Trait) enable runtime polymorphism.
    The type checker must verify:
    - Trait implementations exist before coercion
    - Method calls are type-safe
    - Dispatch mode is correctly determined
    """

    scenario "Create and use dyn trait object":
        """Basic dyn trait usage"""
        given:
            trait Show:
                fn show() -> str

            class Point impl Show:
                x: i64
                y: i64

                fn show() -> str:
                    "Point({self.x}, {self.y})"

        when "using dyn trait":
            val point = Point(x: 3, y: 4)
            val showable: dyn Show = point
            val result = showable.show()

        then "should call correct implementation":
            assert result == "Point(3, 4)"

    scenario "Array of dyn trait objects":
        """Heterogeneous collections via dyn trait"""
        given:
            trait Drawable:
                fn draw() -> str

            class Circle impl Drawable:
                radius: i64
                fn draw() -> str: "Circle({self.radius})"

            class Square impl Drawable:
                side: i64
                fn draw() -> str: "Square({self.side})"

        when "creating heterogeneous array":
            val shapes: [dyn Drawable] = [
                Circle(radius: 5),
                Square(side: 10)
            ]

        then "should store different types":
            assert shapes.len() == 2
            assert shapes[0].draw() == "Circle(5)"
            assert shapes[1].draw() == "Square(10)"

    scenario "Optional dyn trait":
        """dyn trait with Option type"""
        given:
            trait Logger:
                fn log(msg: str)

            class ConsoleLogger impl Logger:
                fn log(msg: str):
                    print msg

        when "using Optional dyn trait":
            var maybe_logger: Option<dyn Logger> = None
            maybe_logger = Some(ConsoleLogger())

        then "should handle Some and None":
            assert maybe_logger.is_some()

feature "Transitive Mixin Resolution":
    """
    Mixins with transitive dependencies must be resolved correctly.
    All fields from the entire mixin hierarchy should be available.
    """

    scenario "Two-level mixin inheritance":
        """Fields from base mixin should be accessible"""
        given:
            mixin Base:
                id: i64

            mixin Timestamped requires Base:
                created_at: i64

        when "applying transitive mixin":
            class Article with Timestamped:
                title: str

            val article = Article(title: "Hello")

        then "should have all fields":
            # From Timestamped (direct)
            article.created_at = 1234567890

            # From Base (transitive)
            article.id = 1

            assert article.id == 1
            assert article.created_at == 1234567890

    scenario "Diamond mixin dependency":
        """Shared base mixin should not be duplicated"""
        given:
            mixin Base:
                id: i64

            mixin Left requires Base:
                left_val: str

            mixin Right requires Base:
                right_val: str

        when "applying both branches":
            class Combined with Left, Right:
                own_val: i64

            val obj = Combined(own_val: 42)

        then "base fields accessible without duplication":
            obj.id = 1
            obj.left_val = "L"
            obj.right_val = "R"

            assert obj.id == 1
            assert obj.left_val == "L"
            assert obj.right_val == "R"
            assert obj.own_val == 42
