# @pending
"""
# Tensor Interface Consistency Specification

**Feature IDs:** #1920, #1930
**Category:** ML, Collections, API
**Status:** Complete

Tests that tensor interfaces are consistent between core and torch.
Verifies that basic tensor operations work the same way regardless
of the underlying implementation.
"""

use ml.torch as torch
use ml.torch.tensor_ffi as tensor_ffi
use ml.torch.device.Device
use ml.torch.dtype.DType

describe "Tensor Interface Consistency":
    """
    Tests that tensor operations have consistent interfaces
    across different implementations.
    """

    context "tensor creation":
        """
        ### Scenario: Creating Tensors

        Tests various tensor creation methods with consistent syntax.
        """

        it "creates tensor from array":
            val data = [1.0, 2.0, 3.0, 4.0]
            val t = torch.tensor(data)
            expect t.shape() == [4]

        it "creates tensor with explicit shape":
            val data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
            val t = torch.tensor(data).reshape([2, 3])
            expect t.shape() == [2, 3]

        it "creates zero tensor":
            val t = torch.zeros([3, 4])
            expect t.shape() == [3, 4]

        it "creates ones tensor":
            val t = torch.ones([2, 5])
            expect t.shape() == [2, 5]

    context "tensor indexing":
        """
        ### Scenario: Tensor Indexing

        Tests that indexing works consistently (including negative indices).
        """

        it "accesses elements by index":
            val data = [10.0, 20.0, 30.0, 40.0, 50.0]
            val t = torch.tensor(data)
            expect t[0] == 10.0
            expect t[2] == 30.0

        it "supports negative indexing":
            val data = [10.0, 20.0, 30.0, 40.0, 50.0]
            val t = torch.tensor(data)
            expect t[-1] == 50.0
            expect t[-2] == 40.0

        it "slices tensors":
            val data = [1.0, 2.0, 3.0, 4.0, 5.0]
            val t = torch.tensor(data)
            val sliced = t[1:4]
            expect sliced.shape() == [3]

    context "tensor operations":
        """
        ### Scenario: Tensor Operations

        Tests mathematical operations on tensors.
        """

        it "performs element-wise addition":
            val a = torch.tensor([1.0, 2.0, 3.0])
            val b = torch.tensor([4.0, 5.0, 6.0])
            val c = a + b
            expect c.shape() == [3]

        it "performs element-wise multiplication":
            val a = torch.tensor([2.0, 3.0, 4.0])
            val b = torch.tensor([5.0, 6.0, 7.0])
            val c = a * b
            expect c.shape() == [3]

        it "performs matrix multiplication with @":
            val a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            val b = torch.tensor([[5.0, 6.0], [7.0, 8.0]])
            val c = a @ b
            expect c.shape() == [2, 2]

    context "tensor properties":
        """
        ### Scenario: Tensor Properties

        Tests accessing tensor metadata and properties.
        """

        it "gets tensor shape":
            val t = torch.zeros([3, 4, 5])
            expect t.shape() == [3, 4, 5]

        it "gets tensor dimension count":
            val t = torch.zeros([2, 3, 4])
            expect t.ndim() == 3

        it "gets tensor element count":
            val t = torch.zeros([2, 3, 4])
            expect t.numel() == 24

        it "gets tensor dtype":
            val t = torch.zeros([2, 3])
            expect t.dtype() == DType.Float32

        it "gets tensor device":
            val t = torch.zeros([2, 3])
            expect t.device() == Device.CPU

    context "tensor reshaping":
        """
        ### Scenario: Tensor Reshaping

        Tests shape manipulation operations.
        """

        it "reshapes tensor":
            val t = torch.zeros([6])
            val reshaped = t.reshape([2, 3])
            expect reshaped.shape() == [2, 3]

        it "flattens tensor":
            val t = torch.zeros([2, 3, 4])
            val flattened = t.flatten()
            expect flattened.shape() == [24]

        it "transposes 2D tensor":
            val t = torch.zeros([3, 4])
            val transposed = t.t()
            expect transposed.shape() == [4, 3]

    context "tensor with dict config":
        """
        ### Scenario: Creating Tensors with Dict Config

        Tests that dict syntax works for tensor configuration.
        """

        it "creates tensor with device config":
            val config = {
                "device": "cpu",
                "dtype": "float32",
                "requires_grad": false
            }
            # Note: This tests that dict syntax is valid
            expect config["device"] == "cpu"

        it "creates tensor metadata dict":
            val metadata = {
                "name": "input_tensor",
                "shape": [3, 224, 224],
                "channels": 3
            }
            expect metadata["name"] == "input_tensor"
            expect metadata["channels"] == 3

        it "stores tensor info in dict":
            val t = torch.zeros([2, 3])
            val info = {
                "shape": t.shape(),
                "dtype": t.dtype().to_string(),
                "numel": t.numel()
            }
            expect info["numel"] == 6
