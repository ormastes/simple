# Feature Spec Template
#
# This template shows how to write BDD specs that generate feature documentation.
# Copy this file and replace the placeholders with your feature details.
#
# The spec runner will export feature metadata to:
#   doc/features/{category}/{id}_{short_name}.md

use std.spec
use std.spec.matchers

# Feature metadata attributes
# These are read by the spec runner to generate documentation
@feature:
    id: 0000                          # Replace with feature ID
    name: "Feature Name"              # Short name
    category: "infrastructure"        # Category folder name
    difficulty: 3                     # 1=Trivial, 2=Easy, 3=Medium, 4=Hard, 5=Very Hard
    status: "complete"                # "complete", "in_progress", "planned"
    impl: "R"                         # "R"=Rust, "S"=Simple, "S+R"=Both
    spec_link: "spec/lexer_parser.md" # Path to specification document
    impl_files:
        - file: "src/parser/src/lexer/mod.rs"
          purpose: "Main implementation"
    depends_on: []                    # List of dependency feature IDs
    required_by: []                   # List of dependent feature IDs

describe "Feature #0000: Feature Name":
    """
    Feature description goes here.

    This text is extracted into the Description section of the
    generated feature documentation.
    """

    context "Core functionality":
        """
        Context description explains this group of behaviors.
        """

        it "should perform the basic operation":
            """
            Example description for documentation.
            """
            # Arrange
            val input = setup_test_data()

            # Act
            val result = perform_operation(input)

            # Assert
            expect(result).to(be_truthy())

        it "should handle edge cases":
            """
            Documents edge case handling.
            """
            val edge_input = edge_case_data()
            val result = perform_operation(edge_input)
            expect(result).to(equal(expected_edge_result))

    context "Error handling":
        """
        Error handling behaviors.
        """

        it "should report meaningful errors":
            expect_raises(FeatureError):
                invalid_operation()

    context "Performance characteristics":
        """
        Performance-related behaviors.
        """

        @skip("Performance tests run separately")
        it "should complete within acceptable time":
            val start = time.now()
            heavy_operation()
            val elapsed = time.now() - start
            expect(elapsed).to(be_less_than(Duration.from_ms(100)))

# Example usage documentation is extracted from this block
context "Usage examples":
    """
    Code examples extracted into the Examples section.
    """

    it "demonstrates basic usage":
        """
        ```simple
        # Basic usage example
        val feature = create_feature()
        val result = feature.process(input)
        print(result)
        ```
        """
        pass

# Notes section content
@feature_notes:
    """
    - Implementation detail 1
    - Performance consideration
    - Future improvement
    """
