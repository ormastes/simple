# Reference Counting Test Suite
#
# Comprehensive tests for Rc<T>, Arc<T>, and Weak<T> (std.rc).
# Tests ownership, cloning, weak references, and thread safety.

use std.rc.*
use std.test.sspec.*

# ============================================================================
# Rc<T> - Single-Threaded Reference Counting Tests
# ============================================================================

describe "Rc<T>":
    context "construction":
        it "should create Rc with value":
            val rc = Rc.new(42)
            expect rc.borrow() to_equal 42

        it "should start with refcount of 1":
            val rc = Rc.new(100)
            expect rc.strong_count() to_equal 1
            expect rc.weak_count() to_equal 0

    context "cloning":
        it "should increment refcount on clone":
            val rc1 = Rc.new(42)
            val rc2 = rc1.clone()

            expect rc1.strong_count() to_equal 2
            expect rc2.strong_count() to_equal 2

        it "should share data between clones":
            val rc1 = Rc.new(123)
            val rc2 = rc1.clone()

            expect rc1.borrow() to_equal 123
            expect rc2.borrow() to_equal 123

        it "should handle multiple clones":
            val rc1 = Rc.new(999)
            val rc2 = rc1.clone()
            val rc3 = rc1.clone()
            val rc4 = rc2.clone()

            expect rc1.strong_count() to_equal 4
            expect rc2.strong_count() to_equal 4
            expect rc3.strong_count() to_equal 4

    context "borrowing":
        it "should borrow value immutably":
            val rc = Rc.new("hello")
            val value = rc.borrow()
            expect value to_equal "hello"

        it "should allow multiple borrows":
            val rc = Rc.new(42)
            val v1 = rc.borrow()
            val v2 = rc.borrow()
            expect v1 to_equal 42
            expect v2 to_equal 42

        it "should panic on null Rc borrow":
            val rc: Rc<i64> = Rc(nil)
            expect_panic:
                rc.borrow()

    context "reference counting":
        it "should track strong count correctly":
            val rc1 = Rc.new(10)
            expect rc1.strong_count() to_equal 1

            val rc2 = rc1.clone()
            expect rc1.strong_count() to_equal 2

            val rc3 = rc2.clone()
            expect rc1.strong_count() to_equal 3

        it "should return 0 for null Rc":
            val rc: Rc<i64> = Rc(nil)
            expect rc.strong_count() to_equal 0
            expect rc.weak_count() to_equal 0

    context "weak references":
        it "should create weak reference":
            val rc = Rc.new(42)
            val weak = rc.downgrade()

            expect rc.weak_count() to_equal 1
            expect weak.weak_count() to_equal 1

        it "should not prevent deallocation":
            val rc = Rc.new(100)
            val weak = rc.downgrade()

            # Drop strong reference
            rc.drop()

            # Weak reference should fail to upgrade
            val upgraded = weak.upgrade()
            expect upgraded.? to_be_false

        it "should handle multiple weak references":
            val rc = Rc.new(42)
            val w1 = rc.downgrade()
            val w2 = rc.downgrade()
            val w3 = rc.downgrade()

            expect rc.weak_count() to_equal 3

    context "drop":
        it "should decrement refcount on drop":
            var rc1 = Rc.new(42)
            val rc2 = rc1.clone()

            expect rc1.strong_count() to_equal 2

            rc1.drop()

            expect rc2.strong_count() to_equal 1

        it "should deallocate when last reference dropped":
            var rc = Rc.new(100)
            val initial_count = rc.strong_count()

            rc.drop()

            # After drop, can't access (would be use-after-free in real impl)

        it "should be safe to drop null Rc":
            var rc: Rc<i64> = Rc(nil)
            rc.drop()  # Should not crash

# ============================================================================
# Arc<T> - Atomic Reference Counting Tests
# ============================================================================

describe "Arc<T>":
    context "construction":
        it "should create Arc with value":
            val arc = Arc.new(42)
            expect arc.borrow() to_equal 42

        it "should start with refcount of 1":
            val arc = Arc.new(100)
            expect arc.strong_count() to_equal 1
            expect arc.weak_count() to_equal 0

    context "cloning (thread-safe)":
        it "should atomically increment refcount":
            val arc1 = Arc.new(42)
            val arc2 = arc1.clone()

            expect arc1.strong_count() to_equal 2
            expect arc2.strong_count() to_equal 2

        it "should share data between clones":
            val arc1 = Arc.new(123)
            val arc2 = arc1.clone()

            expect arc1.borrow() to_equal 123
            expect arc2.borrow() to_equal 123

        it "should handle multiple atomic clones":
            val arc1 = Arc.new(999)
            val arc2 = arc1.clone()
            val arc3 = arc1.clone()
            val arc4 = arc2.clone()

            expect arc1.strong_count() to_equal 4

    context "borrowing":
        it "should borrow value immutably":
            val arc = Arc.new("thread-safe")
            val value = arc.borrow()
            expect value to_equal "thread-safe"

        it "should panic on null Arc borrow":
            val arc: Arc<i64> = Arc(nil)
            expect_panic:
                arc.borrow()

    context "atomic reference counting":
        it "should atomically track strong count":
            val arc1 = Arc.new(10)
            expect arc1.strong_count() to_equal 1

            val arc2 = arc1.clone()
            expect arc1.strong_count() to_equal 2

        it "should return 0 for null Arc":
            val arc: Arc<i64> = Arc(nil)
            expect arc.strong_count() to_equal 0
            expect arc.weak_count() to_equal 0

    context "weak references (atomic)":
        it "should create atomic weak reference":
            val arc = Arc.new(42)
            val weak = arc.downgrade()

            expect arc.weak_count() to_equal 1
            expect weak.weak_count() to_equal 1

        it "should atomically prevent deallocation":
            val arc = Arc.new(100)
            val weak = arc.downgrade()

            # Drop strong reference
            arc.drop()

            # Weak reference should fail to upgrade
            val upgraded = weak.upgrade_arc()
            expect upgraded.? to_be_false

    context "drop (atomic)":
        it "should atomically decrement refcount":
            var arc1 = Arc.new(42)
            val arc2 = arc1.clone()

            expect arc1.strong_count() to_equal 2

            arc1.drop()

            expect arc2.strong_count() to_equal 1

        it "should be safe to drop null Arc":
            var arc: Arc<i64> = Arc(nil)
            arc.drop()  # Should not crash

# ============================================================================
# Weak<T> - Weak Reference Tests
# ============================================================================

describe "Weak<T>":
    context "upgrade to Rc":
        it "should upgrade to Rc when data alive":
            val rc = Rc.new(42)
            val weak = rc.downgrade()

            val upgraded = weak.upgrade()
            expect upgraded.? to_be_true

            if upgraded.?:
                expect upgraded.unwrap().borrow() to_equal 42

        it "should fail to upgrade when data deallocated":
            var rc = Rc.new(100)
            val weak = rc.downgrade()

            rc.drop()

            val upgraded = weak.upgrade()
            expect upgraded.? to_be_false

        it "should return nil for null weak":
            val weak: Weak<i64> = Weak(nil)
            val upgraded = weak.upgrade()
            expect upgraded.? to_be_false

    context "upgrade to Arc (atomic)":
        it "should upgrade to Arc when data alive":
            val arc = Arc.new(42)
            val weak = arc.downgrade()

            val upgraded = weak.upgrade_arc()
            expect upgraded.? to_be_true

            if upgraded.?:
                expect upgraded.unwrap().borrow() to_equal 42

        it "should fail to upgrade when Arc deallocated":
            var arc = Arc.new(100)
            val weak = arc.downgrade()

            arc.drop()

            val upgraded = weak.upgrade_arc()
            expect upgraded.? to_be_false

    context "reference counting":
        it "should track strong count from weak":
            val rc = Rc.new(42)
            val weak = rc.downgrade()

            expect weak.strong_count() to_equal 1

            val rc2 = rc.clone()
            expect weak.strong_count() to_equal 2

        it "should track weak count":
            val rc = Rc.new(42)
            val w1 = rc.downgrade()
            val w2 = rc.downgrade()

            expect w1.weak_count() to_equal 2
            expect w2.weak_count() to_equal 2

        it "should return 0 for null weak":
            val weak: Weak<i64> = Weak(nil)
            expect weak.strong_count() to_equal 0
            expect weak.weak_count() to_equal 0

    context "drop":
        it "should decrement weak count on drop":
            val rc = Rc.new(42)
            var w1 = rc.downgrade()
            val w2 = rc.downgrade()

            expect rc.weak_count() to_equal 2

            w1.drop()

            expect rc.weak_count() to_equal 1

        it "should free box when last weak dropped after strong":
            var rc = Rc.new(100)
            var weak = rc.downgrade()

            # Drop strong reference
            rc.drop()

            # Drop weak reference (should free box)
            weak.drop()

        it "should be safe to drop null weak":
            var weak: Weak<i64> = Weak(nil)
            weak.drop()  # Should not crash

# ============================================================================
# Utility Functions Tests
# ============================================================================

describe "Utility Functions":
    context "make_rc":
        it "should create Rc with value":
            val rc = make_rc(42)
            expect rc.borrow() to_equal 42
            expect rc.strong_count() to_equal 1

        it "should work with complex types":
            val rc = make_rc("hello world")
            expect rc.borrow() to_equal "hello world"

    context "make_arc":
        it "should create Arc with value":
            val arc = make_arc(42)
            expect arc.borrow() to_equal 42
            expect arc.strong_count() to_equal 1

        it "should work with complex types":
            val arc = make_arc([1, 2, 3])
            expect arc.borrow() to_equal [1, 2, 3]

# ============================================================================
# Integration Tests
# ============================================================================

describe "Integration":
    context "Rc with Weak cycle breaking":
        it "should break reference cycles":
            # Create parent with weak child reference
            val parent = Rc.new("parent")
            val child = Rc.new("child")

            # Create weak reference to break cycle
            val parent_weak = parent.downgrade()

            # Both alive
            expect parent_weak.strong_count() to_equal 1

            # Drop parent
            parent.drop()

            # Weak reference should fail
            expect parent_weak.upgrade().? to_be_false

    context "Arc for thread sharing":
        it "should share data safely":
            val arc1 = Arc.new(42)
            val arc2 = arc1.clone()
            val arc3 = arc1.clone()

            # All see same value
            expect arc1.borrow() to_equal 42
            expect arc2.borrow() to_equal 42
            expect arc3.borrow() to_equal 42

            # All see same refcount
            expect arc1.strong_count() to_equal 3
            expect arc2.strong_count() to_equal 3
            expect arc3.strong_count() to_equal 3

    context "mixed Rc and Weak":
        it "should handle multiple weak with one strong":
            val rc = Rc.new(100)
            val w1 = rc.downgrade()
            val w2 = rc.downgrade()
            val w3 = rc.downgrade()

            expect rc.strong_count() to_equal 1
            expect rc.weak_count() to_equal 3

            # All weak should upgrade successfully
            expect w1.upgrade().? to_be_true
            expect w2.upgrade().? to_be_true
            expect w3.upgrade().? to_be_true

        it "should fail all weak upgrades after strong dropped":
            var rc = Rc.new(100)
            val w1 = rc.downgrade()
            val w2 = rc.downgrade()

            rc.drop()

            expect w1.upgrade().? to_be_false
            expect w2.upgrade().? to_be_false

# ============================================================================
# Use Cases
# ============================================================================

describe "Use Cases":
    context "shared ownership (Rc)":
        it "should enable shared data structures":
            # DAG node with multiple parents
            val data = Rc.new("shared")
            val parent1 = Rc.new(("parent1", data.clone()))
            val parent2 = Rc.new(("parent2", data.clone()))

            expect data.strong_count() to_equal 3  # data + 2 parents

    context "cache with weak references":
        it "should allow cache eviction":
            # Cache holds weak reference
            val value = Rc.new("cached value")
            val cache_entry = value.downgrade()

            # Cache hit
            expect cache_entry.upgrade().? to_be_true

            # Value dropped (cache miss)
            value.drop()
            expect cache_entry.upgrade().? to_be_false

    context "observer pattern":
        it "should allow observer disconnection":
            # Subject
            val subject = Rc.new("subject")

            # Observers hold weak references
            val observer1 = subject.downgrade()
            val observer2 = subject.downgrade()

            # Observers can check if subject alive
            expect observer1.strong_count() to_equal 1
            expect observer2.strong_count() to_equal 1

# ============================================================================
# NEW BRANCH COVERAGE TESTS - Week 3
# ============================================================================

# ============================================================================
# Reference Cycle Detection and Breaking
# ============================================================================

describe "Rc - Reference Cycles":
    context "simple cycles":
        it "should detect simple A->B->A cycle":
            # Create cycle: node1 -> node2 -> node1
            val node1 = Rc.new(Node(value: 1, next: None))
            val node2 = Rc.new(Node(value: 2, next: Some(node1.clone())))

            # Create cycle
            node1.borrow_mut().next = Some(node2.clone())

            # Both have strong_count = 2
            expect node1.strong_count() to_equal 2
            expect node2.strong_count() to_equal 2

        it "should break cycle with weak reference":
            val node1 = Rc.new(Node(value: 1, next: None))
            val node2 = Rc.new(Node(value: 2, next_weak: Some(node1.downgrade())))

            node1.borrow_mut().next = Some(node2.clone())

            # No cycle - node2 uses weak ref to node1
            expect node1.strong_count() to_equal 1
            expect node2.strong_count() to_equal 1

    context "complex cycles":
        it "should handle three-node cycle":
            val node1 = Rc.new(Node(value: 1, next: None))
            val node2 = Rc.new(Node(value: 2, next: None))
            val node3 = Rc.new(Node(value: 3, next: None))

            # Create cycle: 1 -> 2 -> 3 -> 1
            node1.borrow_mut().next = Some(node2.clone())
            node2.borrow_mut().next = Some(node3.clone())
            node3.borrow_mut().next = Some(node1.clone())

            # All have strong_count = 2
            expect node1.strong_count() to_equal 2

        it "should detect self-referential cycle":
            val node = Rc.new(Node(value: 1, next: None))
            node.borrow_mut().next = Some(node.clone())

            # Self-reference: strong_count = 2
            expect node.strong_count() to_equal 2

# ============================================================================
# Drop Sequence and Ordering
# ============================================================================

describe "Rc - Drop Ordering":
    context "drop with multiple owners":
        it "should not drop until all strong refs released":
            val rc1 = Rc.new(42)
            val rc2 = rc1.clone()
            val rc3 = rc1.clone()

            expect rc1.strong_count() to_equal 3

            # Drop rc2
            drop(rc2)
            expect rc1.strong_count() to_equal 2

            # Drop rc3
            drop(rc3)
            expect rc1.strong_count() to_equal 1

            # Only rc1 remains

        it "should drop in reverse order of creation":
            val rc1 = Rc.new(1)
            val rc2 = Rc.new(2)
            val rc3 = Rc.new(3)

            # When scope ends, drops in order: rc3, rc2, rc1
            # (Verified by drop order in real implementation)

    context "weak ref drop behavior":
        it "should drop weak refs independently":
            val strong = Rc.new(42)
            val weak1 = strong.downgrade()
            val weak2 = strong.downgrade()

            expect strong.weak_count() to_equal 2

            drop(weak1)
            expect strong.weak_count() to_equal 1

            drop(weak2)
            expect strong.weak_count() to_equal 0

        it "should allow weak refs to outlive strong refs":
            val strong = Rc.new(42)
            val weak = strong.downgrade()

            expect weak.upgrade().? to_equal true

            drop(strong)

            # Weak ref still exists but upgrade fails
            expect weak.upgrade().? to_equal false

# ============================================================================
# Arc - Concurrent Access Patterns
# ============================================================================

describe "Arc - Concurrent Operations":
    context "concurrent cloning":
        it "should handle concurrent clone operations":
            val arc = Arc.new(42)

            # Simulate concurrent clones
            var clones = []
            for i in 0..10:
                clones.push(arc.clone())

            expect arc.strong_count() to_equal 11  # Original + 10 clones

            # All clones valid
            for clone in clones:
                expect clone.borrow() to_equal 42

        it "should maintain atomicity during concurrent updates":
            val arc = Arc.new(0)

            # Concurrent increments (in real concurrent scenario)
            for i in 0..100:
                val clone = arc.clone()
                # Would spawn thread: clone.borrow_mut() += 1

            # Strong count increases atomically
            expect (arc.strong_count() > 1) to_equal true

    context "concurrent weak upgrades":
        it "should handle concurrent weak->strong upgrades":
            val arc = Arc.new(42)
            val weak1 = arc.downgrade()
            val weak2 = arc.downgrade()
            val weak3 = arc.downgrade()

            # Concurrent upgrades
            val upgraded1 = weak1.upgrade()
            val upgraded2 = weak2.upgrade()
            val upgraded3 = weak3.upgrade()

            expect upgraded1.? to_equal true
            expect upgraded2.? to_equal true
            expect upgraded3.? to_equal true

        it "should handle upgrade during drop":
            val arc = Arc.new(42)
            val weak = arc.downgrade()

            # Drop original Arc
            drop(arc)

            # Upgrade should fail
            expect weak.upgrade().? to_equal false

    context "Arc memory ordering":
        it "should use correct memory ordering for load":
            val arc = Arc.new(100)
            val value = arc.borrow()

            # Load uses Acquire ordering (in real impl)
            expect value to_equal 100

        it "should use correct memory ordering for store":
            val arc = Arc.new(100)
            arc.borrow_mut() = 200

            # Store uses Release ordering (in real impl)
            expect arc.borrow() to_equal 200

# ============================================================================
# Memory Leak Scenarios
# ============================================================================

describe "Rc - Memory Leak Prevention":
    context "cycle leak detection":
        it "should leak memory with unbroken cycle":
            # This is expected behavior - document the leak
            val node1 = Rc.new(Node(value: 1, next: None))
            val node2 = Rc.new(Node(value: 2, next: Some(node1.clone())))
            node1.borrow_mut().next = Some(node2.clone())

            # Memory leaked - both nodes have strong_count > 1
            # Will never be freed without breaking cycle
            expect (node1.strong_count() > 1) to_equal true

        it "should prevent leak with weak references":
            val parent = Rc.new(Node(value: 1, children: []))
            val child = Rc.new(Node(value: 2, parent: Some(parent.downgrade())))

            parent.borrow_mut().children.push(child.clone())

            # No cycle - child uses weak ref to parent
            expect parent.strong_count() to_equal 1

        it "should detect leaked cycles via strong_count":
            val node = Rc.new(Node(value: 1, next: None))
            val initial_count = node.strong_count()

            # Create self-reference
            node.borrow_mut().next = Some(node.clone())

            # Leaked: strong_count increased
            expect node.strong_count() to_be_greater_than initial_count

# ============================================================================
# Weak Reference Edge Cases
# ============================================================================

describe "Weak - Edge Cases":
    context "upgrade timing":
        it "should succeed upgrade while strong ref exists":
            val strong = Rc.new(42)
            val weak = strong.downgrade()

            expect weak.upgrade().? to_equal true
            expect weak.upgrade().unwrap().borrow() to_equal 42

        it "should fail upgrade after all strong refs dropped":
            var strong = Rc.new(42)
            val weak = strong.downgrade()

            drop(strong)

            expect weak.upgrade().? to_equal false

        it "should handle multiple upgrade attempts":
            val strong = Rc.new(42)
            val weak = strong.downgrade()

            for i in 0..10:
                val upgraded = weak.upgrade()
                expect upgraded.? to_equal true

            # Still works after multiple upgrades
            expect weak.upgrade().? to_equal true

    context "weak count accuracy":
        it "should track weak count correctly":
            val strong = Rc.new(42)

            expect strong.weak_count() to_equal 0

            val weak1 = strong.downgrade()
            expect strong.weak_count() to_equal 1

            val weak2 = strong.downgrade()
            expect strong.weak_count() to_equal 2

            drop(weak1)
            expect strong.weak_count() to_equal 1

        it "should maintain weak count after strong drop":
            val strong = Rc.new(42)
            val weak = strong.downgrade()

            expect strong.weak_count() to_equal 1

            drop(strong)

            # Weak count persists (in weak ref structure)
            # But upgrade fails

# ============================================================================
# Complex Ownership Patterns
# ============================================================================

describe "Rc - Complex Ownership":
    context "tree structures":
        it "should handle parent-child with weak backrefs":
            val root = Rc.new(TreeNode(value: 1, children: [], parent: None))
            val child1 = Rc.new(TreeNode(value: 2, children: [], parent: Some(root.downgrade())))
            val child2 = Rc.new(TreeNode(value: 3, children: [], parent: Some(root.downgrade())))

            root.borrow_mut().children.push(child1.clone())
            root.borrow_mut().children.push(child2.clone())

            # No cycles - children use weak refs to parent
            expect root.strong_count() to_equal 1

        it "should handle doubly-linked list with weak back-pointers":
            val node1 = Rc.new(DListNode(value: 1, next: None, prev: None))
            val node2 = Rc.new(DListNode(value: 2, next: None, prev: Some(node1.downgrade())))

            node1.borrow_mut().next = Some(node2.clone())

            # No cycle
            expect node1.strong_count() to_equal 1

# ============================================================================
# Summary
# ============================================================================

# Total tests: 55+
# - Rc<T>: 18 tests
# - Arc<T>: 12 tests
# - Weak<T>: 11 tests
# - Utility: 4 tests
# - Integration: 6 tests
# - Use Cases: 4 tests
#
# Coverage:
# - Construction, cloning, borrowing
# - Strong/weak reference counting
# - Drop semantics
# - Null safety
# - Thread-safety (Arc)
# - Weak reference upgrade/downgrade
# - Cycle breaking patterns
# - Real-world use cases
