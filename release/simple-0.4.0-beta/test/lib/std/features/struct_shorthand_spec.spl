# @pending
# @skip
"""
# Struct Field Shorthand Specification

**Feature IDs:** #STRUCT-SHORTHAND
**Category:** Syntax
**Status:** Implemented

Struct field shorthand allows omitting the field name when the variable name
matches. This reduces boilerplate when constructing structs from local variables.

## Syntax

```simple
# Without shorthand (verbose)
val point = Point(x: x, y: y)

# With shorthand (when variable names match field names)
val point = Point(x, y)

# Mixed shorthand and explicit
val point = Point(x, y: computed_y)
```

## Key Behaviors

- Variable name must exactly match the field name
- Order must match the struct definition
- Can mix shorthand and explicit field names
- Works with any struct type
"""
use std.spec.*

describe "Struct Field Shorthand":
    """
    ## Struct Construction Shorthand Specification

    Struct shorthand syntax reduces verbosity when constructing structs from
    variables with matching names. This test suite verifies:
    - Basic shorthand when variable matches field name
    - Mixed shorthand and explicit field syntax
    - Shorthand with different field types
    - Interaction with nested structs
    - Error cases (mismatched names still require explicit syntax)
    """

    context "basic struct shorthand":
        it "uses shorthand for matching variable names":
            struct Point:
                x: i64
                y: i64
            val x = 10
            val y = 20
            val point = Point(x, y)
            expect point.x == 10
            expect point.y == 20

        it "constructs struct with all shorthand fields":
            struct Person:
                name: text
                age: i64
            val name = "Alice"
            val age = 30
            val person = Person(name, age)
            expect person.name == "Alice"
            expect person.age == 30

    context "mixed shorthand and explicit":
        it "mixes shorthand with explicit named argument":
            struct Point:
                x: i64
                y: i64
            val x = 10
            val point = Point(x, y: 20)
            expect point.x == 10
            expect point.y == 20

        it "uses explicit then shorthand":
            struct Point:
                x: i64
                y: i64
            val y = 20
            val point = Point(x: 10, y)
            expect point.x == 10
            expect point.y == 20

        it "mixes in complex struct":
            struct Config:
                host: text
                port: i64
                timeout: i64
            val host = "localhost"
            val timeout = 30
            val config = Config(host, port: 8080, timeout)
            expect config.host == "localhost"
            expect config.port == 8080
            expect config.timeout == 30

    context "shorthand with computed values":
        it "uses shorthand after computation":
            struct Rectangle:
                width: i64
                height: i64
            val width = 5 * 2
            val height = 3 * 2
            val rect = Rectangle(width, height)
            expect rect.width == 10
            expect rect.height == 6

        it "uses shorthand from function return":
            struct Point:
                x: i64
                y: i64
            fn get_x() -> i64:
                100
            fn get_y() -> i64:
                200
            val x = get_x()
            val y = get_y()
            val point = Point(x, y)
            expect point.x == 100
            expect point.y == 200

    context "shorthand with different types":
        it "handles text fields":
            struct Message:
                sender: text
                content: text
            val sender = "Alice"
            val content = "Hello!"
            val msg = Message(sender, content)
            expect msg.sender == "Alice"
            expect msg.content == "Hello!"

        it "handles boolean fields":
            struct Flags:
                enabled: bool
                visible: bool
            val enabled = true
            val visible = false
            val flags = Flags(enabled, visible)
            expect flags.enabled == true
            expect flags.visible == false

        it "handles mixed types":
            struct Record:
                id: i64
                name: text
                active: bool
            val id = 42
            val name = "Test"
            val active = true
            val record = Record(id, name, active)
            expect record.id == 42
            expect record.name == "Test"
            expect record.active == true

    context "shorthand in nested structs":
        it "uses shorthand when nesting":
            struct Point:
                x: i64
                y: i64
            struct Line:
                start: Point
                endpoint: Point
            val x = 0
            val y = 0
            val start = Point(x, y)
            val x2 = 10
            val y2 = 10
            val endpoint = Point(x: x2, y: y2)
            val line = Line(start, endpoint)
            expect line.start.x == 0
            expect line.endpoint.x == 10

    context "explicit syntax still works":
        it "allows fully explicit construction":
            struct Point:
                x: i64
                y: i64
            val a = 100
            val b = 200
            val point = Point(x: a, y: b)
            expect point.x == 100
            expect point.y == 200

        it "allows equals syntax explicitly":
            struct Point:
                x: i64
                y: i64
            val point = Point(x=30, y=40)
            expect point.x == 30
            expect point.y == 40

    context "shorthand in collections":
        it "uses shorthand in list of structs":
            struct Point:
                x: i64
                y: i64
            var points: [Point] = []
            for i in 0..3:
                val x = i * 10
                val y = i * 20
                points = points.append(Point(x, y))
            expect points[0].x == 0
            expect points[1].x == 10
            expect points[2].x == 20

        it "uses shorthand with map":
            struct Point:
                x: i64
                y: i64
            val coords = [(1, 2), (3, 4), (5, 6)]
            val points = coords.map(\pair:
                val (x, y) = pair
                Point(x, y)
            )
            expect points[0].x == 1
            expect points[1].y == 4
