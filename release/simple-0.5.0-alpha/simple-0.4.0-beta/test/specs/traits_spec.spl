# @pending
"""
# Simple Language Traits and Implementations - Test Specification

# @skip

**Status:** âœ… Implemented (uses existing coherence rules)
**Feature IDs:** 
**Source:** traits.md
**Type:** Extracted Examples (Category B)

## Overview

This file contains executable test cases extracted from traits.md.
The original specification file remains as architectural reference documentation.

**Note:** This is a test extraction file. For complete specification text,
design rationale, and architecture, see doc/spec/traits.md

## Extracted Test Cases

36 test cases extracted covering:
- Core functionality examples
- Edge cases and validation
- Integration patterns
"""
# @skip

## Test: Defining a Trait (Line ~3)

it "defining_a_trait_1":
    trait Printable:
        fn stringify() -> String
        fn print_self():
            # default implementation
            print self.stringify()
    pass

## Test: Defining a Trait (Line ~19)

"""
The special `self` keyword in trait definitions refers to the implementing instance type (like `Self...
"""
it "defining_a_trait_2":
    trait Comparable:
        fn compare(other: Self) -> i32
        fn equals(other: Self) -> bool:
            return self.compare(other) == 0
        fn less_than(other: Self) -> bool:
            return self.compare(other) < 0
        fn greater_than(other: Self) -> bool:
            return self.compare(other) > 0
    pass

## Test: Implementing a Trait (Line ~5)

"""
To implement a trait for a type, use an `impl Trait for Type` block:
"""
it "implementing_a_trait_3":
    struct Person:
        name: String
        age: i32

    impl Printable for Person:
        fn stringify() -> String:
            return "{self.name} (age {self.age})"
        # print_self uses the trait's default implementation
    pass

## Test: Implementing a Trait (Line ~22)

"""
A type can implement any number of traits:
"""
it "implementing_a_trait_4":
    struct Point:
        x: f64
        y: f64

    impl Printable for Point:
        fn stringify() -> String:
            return "({self.x}, {self.y})"

    impl Comparable for Point:
        fn compare(other: Point) -> i32:
            val d1 = self.x * self.x + self.y * self.y
            val d2 = other.x * other.x + other.y * other.y
            if d1 < d2: return -1
            if d1 > d2: return 1
            return 0
    pass

## Test: Dispatch (Line ~7)

"""
Traits support static dispatch by default - the compiler knows at compile time the exact type and ca...
"""
fn log<T: Printable>(item: T):
    item.print_self()

val p = Person(name: "Alice", age: 30)
log(p)  # Compiler knows T = Person

## Test: Dispatch (Line ~21)

"""
For cases where the concrete type isn't known at compile time, traits use dynamic dispatch by defaul...
"""
it "dispatch_6":
    val x: Printable = somePrintableObject  # Uses vtable
    x.print_self()  # Dynamic dispatch
    pass

## Test: Trait Bounds and Generics (Line ~5)

"""
Traits are often used as bounds on type parameters:
"""
fn print_all<T: Printable>(items: List<T>):
    for item in items:
        item.print_self()

## Test: Trait Bounds and Generics (Line ~15)

"""
This generic function `print_all` can accept a list of any type `T` that implements `Printable`. The...
"""
fn process<T: Printable + Comparable>(items: List<T>):
    for item in items:
        item.print_self()
    items.sort(\a, b: a.compare(b))

## Test: Trait Bounds and Generics (Line ~28)

"""
For complex bounds, use where clauses:
"""
fn complex<T, U>(a: T, b: U) -> String
    where T: Printable,
          U: Comparable + Printable:
    return "{a.stringify()} vs {b.stringify()}"

## Test: Trait Inheritance (Line ~5)

"""
One trait can require another:
"""
it "trait_inheritance_10":
    trait Drawable: Printable:
        fn draw()

    # Any Drawable must also be Printable
    impl Drawable for Widget:
        fn stringify() -> String:
            return "Widget"
        fn draw():
            # drawing code
    pass

## Test: Associated Types (Line ~5)

"""
Traits can include associated type placeholders:
"""
it "associated_types_11":
    trait Container:
        type Item
        fn add(item: Self.Item)
        fn get(index: i32) -> Self.Item?

    struct IntList:
        items: [i32]

    impl Container for IntList:
        type Item = i32
        fn add(item: i32):
            self.items.push(item)
        fn get(index: i32) -> Option<i32>:
            if index < self.items.len():
                return Some(self.items[index])
            return None
    pass

## Test: Trait Objects and Collections (Line ~5)

"""
Trait objects allow storing different types that implement the same trait:
"""
it "trait_objects_and_collections_12":
    val printables: [Printable] = [
        Person(name: "Alice", age: 30),
        Point(x: 1.0, y: 2.0),
        Widget("button"),
    ]

    for p in printables:
        p.print_self()  # Dynamic dispatch
    pass

## Test: Common Standard Traits (Line ~18)

"""
Common traits can be automatically derived:
"""
it "common_standard_traits_13":
    #[derive(Eq, Hash, Clone, Debug)]
    struct Point:
        x: f64
        y: f64
    pass

## Test: Note on Semantic Types (Line ~5)

"""
Trait methods in public APIs should follow the same semantic type guidelines as regular functions:
"""
it "note_on_semantic_types_14":
    # GOOD: Use semantic types in public trait methods
    trait UserService:
        fn get_user(id: UserId) -> Option<User>
        fn set_status(id: UserId, status: UserStatus)

    # Standard library traits use Option/Result
    trait Iterator:
        type Item
        fn next() -> Option<Self.Item>
    pass

## Test: Interface Bindings (Static Polymorphism) (Line ~9)

"""
Important: The `bind` statement only supports static dispatch. There is no `static` or `dyn` keyword...
"""
it "interface_bindings_static_polymorphism_15":
    bind TraitName = ImplTypeName
    pass

## Test: Interface Bindings (Static Polymorphism) (Line ~15)

"""
```simple
bind TraitName = ImplTypeName
```
"""
it "interface_bindings_static_polymorphism_16":
    trait Logger:
        fn log(msg: str) -> str

    class ConsoleLogger:
        fn log(msg: str) -> str:
            return "Console: " + msg

    class FileLogger:
        fn log(msg: str) -> str:
            return "File: " + msg

    # Bind Logger to ConsoleLogger for this module
    bind Logger = ConsoleLogger

    static fn create_logger() -> Logger:
        return ConsoleLogger()

    fn main():
        val logger: Logger = create_logger()
        # With binding, this dispatches statically to ConsoleLogger::log
        # No vtable lookup required
        val result = logger.log("Hello")
        # result is "Console: Hello"
    pass

## Test: Collection Traits (Line ~46)

"""
| Type | Iterable | Collection | Sequence | MutSequence | ImmutSequence | Growable | Sliceable |
|--...
"""
it "collection_traits_17":
    # Works with List, Array, Slice, String
    fn sum<C: Sequence<T>, T: Add[Output=T> + Default](seq: C) -> T:
        seq.fold(T::default(), |acc, x| acc + x)

    # Works with List and Array
    fn find_max<C: Sequence<T>, T: Ord>(seq: C) -> Option<T>:
        seq.max()

    # Works with any mutable sequence
    fn reverse_in_place<C: MutSequence<T>, T>(seq: &mut C):
        seq.reverse()

    # Only List (Growable) can use push
    fn append_all<C: Growable<T>, T: Clone>(dest: &mut C, items: Slice<T>):
        for item in items:
            dest.push(item.clone())
    pass

## Test: Inherent Impl Blocks (Line ~5)

"""
Methods can be added directly to types without using traits:
"""
it "inherent_impl_blocks_18":
    struct Point:
        x: f64
        y: f64

    impl Point:
        fn new(x: f64, y: f64) -> Point:
            return Point(x: x, y: y)

        fn distance(other: Point) -> f64:
            val dx = self.x - other.x
            val dy = self.y - other.y
            return (dx * dx + dy * dy).sqrt()

        fn origin() -> Point:  # Associated function (no self)
            return Point(x: 0.0, y: 0.0)

    # Usage
    val p1 = Point.new(3.0, 4.0)
    val p2 = Point.origin()
    val d = p1.distance(p2)  # 5.0
    pass

## Test: Inherent Impl Blocks (Line ~41)

"""
Extension methods allow adding methods to types defined elsewhere:
"""
it "inherent_impl_blocks_19":
    # In your module
    impl String:
        fn to_title_case() -> String:
            # implementation
            ...

    # Now all Strings have to_title_case()
    val title = "hello world".to_title_case()  # "Hello World"
    pass

## Test: Inherent Impl Blocks (Line ~62)

it "inherent_impl_blocks_20":
    # Define a local extension trait
    trait StringExt:
        fn to_title_case() -> String
        fn word_count() -> i32

    # Implement for foreign type - ALLOWED because trait is local
    impl StringExt for String:
        fn to_title_case() -> String:
            # implementation
            return self  # simplified

        fn word_count() -> i32:
            return self.split(" ").len()

    # Usage
    fn main():
        val text = "hello world"
        print(text.to_title_case())  # Works!
        print(text.word_count())      # Works!
    pass

## Test: Inherent Impl Blocks (Line ~100)

"""
Example - Extending Standard Types:
"""
it "inherent_impl_blocks_21":
    # In your crate
    trait SliceExt<T>:
        fn sum() -> T where T: Add

    impl<T: Add> SliceExt<T> for [T]:
        fn sum() -> T:
            val result = T::default()
            for item in self:
                result = result + item
            return result

    # Usage
    use my_extensions::SliceExt

    fn main():
        val numbers = [1, 2, 3, 4, 5]
        print(numbers.sum())  # 15
    pass

## Test: Inherent Impl Blocks (Line ~122)

"""
Example - Multiple Extension Traits:
"""
it "inherent_impl_blocks_22":
    trait JsonExt:
        fn to_json() -> String

    trait XmlExt:
        fn to_xml() -> String

    struct User:
        name: String
        age: i32

    impl JsonExt for User:
        fn to_json() -> String:
            return "{\"name\":\"" + self.name + "\"}"

    impl XmlExt for User:
        fn to_xml() -> String:
            return "<user><name>" + self.name + "</name></user>"

    # Different contexts can use different extensions
    use json::JsonExt
    val user = User(name: "Alice", age: 30)
    print(user.to_json())  # JSON output

    use xml::XmlExt
    print(user.to_xml())   # XML output
    pass

## Test: Trait Coherence Rules (Line ~9)

"""
The orphan rule prevents defining trait implementations in "orphan" modules:
"""
it "trait_coherence_rules_23":
    # ALLOWED: Implementing your trait for any type
    # (trait is local)
    trait MyTrait:
        fn my_method()

    impl MyTrait for String:  # OK - MyTrait is local
        fn my_method():
            pass

    # ALLOWED: Implementing any trait for your type
    # (type is local)
    struct MyType:
        value: i32

    impl Display for MyType:  # OK - MyType is local
        fn fmt() -> str:
            return "{self.value}"

    # FORBIDDEN: Implementing foreign trait for foreign type
    impl Display for String:  # ERROR - both Display and String are foreign
        fn fmt() -> str:
            return self
    pass

## Test: Trait Coherence Rules (Line ~44)

"""
Two trait implementations overlap if there exists a type that could match both:
"""
it "trait_coherence_rules_24":
    # Overlapping implementations - ERROR
    trait Process:
        fn process()

    impl Process for i32:
        fn process():
            print("i32")

    impl<T: Clone> Process for T:  # ERROR: overlaps with impl for i32
        fn process():
            print("generic")
    pass

## Test: Trait Coherence Rules (Line ~64)

"""
Specialization allows a more specific implementation to override a general one:
"""
it "trait_coherence_rules_25":
    # With specialization enabled
    trait Process:
        fn process()

    #[default]
    impl<T> Process for T:
        fn process():
            print("default")

    impl Process for i32:  # OK - specializes the default
        fn process():
            print("specialized for i32")
    pass

## Test: Trait Coherence Rules (Line ~85)

"""
Blanket implementations apply to all types matching a bound:
"""
it "trait_coherence_rules_26":
    # Blanket impl: all types implementing Debug also get Printable
    impl<T: Debug> Printable for T:
        fn stringify() -> String:
            return self.debug_fmt()
    pass

## Test: Trait Coherence Rules (Line ~98)

"""
Associated types in trait implementations must be consistent:
"""
it "trait_coherence_rules_27":
    trait Container:
        type Item

    # Each implementation fixes the associated type
    impl Container for IntList:
        type Item = i32

    impl Container for StringList:
        type Item = String

    # Cannot have multiple impls with different Item for same type
    impl Container for IntList:  # ERROR: conflicting impl
        type Item = i64
    pass

## Test: Trait Coherence Rules (Line ~118)

"""
Negative bounds exclude types from a blanket impl:
"""
it "trait_coherence_rules_28":
    # Not yet implemented
    impl<T: !Copy> Clone for T:
        fn clone() -> T:
            # deep clone for non-Copy types
    pass

## Test: Trait Coherence Rules (Line ~161)

it "trait_coherence_rules_29":
    # Wrap foreign type in local newtype
    struct MyString(String)

    impl ForeignTrait for MyString:
        # Now allowed - MyString is local
    pass

## Test: Trait Coherence Rules (Line ~170)

it "trait_coherence_rules_30":
    # Define local trait with desired methods
    trait StringExt:
        fn my_extension() -> String

    impl StringExt for String:
        fn my_extension() -> String:
            # implementation
    pass

## Test: Trait Coherence Rules (Line ~181)

it "trait_coherence_rules_31":
    struct MyWrapper:
        inner: ForeignType

    impl MyWrapper:
        fn delegate_method():
            self.inner.original_method()
    pass

## Test: Related Specifications (Line ~16)

it "related_specifications_32":
    # Negative bound: T must NOT implement Clone
    impl<T: !Clone> Copy for T:
        fn copy() -> T:
            # implementation
            ...

    # Multiple bounds: T must be Send but NOT Sync
    impl<T: Send + !Sync> SafeWrapper for T:
        # implementation
        ...
    pass

## Test: Related Specifications (Line ~32)

"""
1. Conditional Blanket Impls:
"""
it "related_specifications_33":
    # Default implementation for non-Copy types
    #[default]
    impl<T: !Copy> Clone for T:
        fn clone() -> T:
            return self.deep_clone()

    # Specialized for Copy types (more efficient)
    impl<T: Copy> Clone for T:
        fn clone() -> T:
            return self  # Simple copy
    pass

## Test: Related Specifications (Line ~46)

"""
2. Avoiding Conflicts:
"""
it "related_specifications_34":
    trait Serialize:
        fn to_bytes() -> [u8]

    # For types that don't have Display
    impl<T: !Display> Serialize for T:
        fn to_bytes() -> [u8]:
            return binary_serialize(self)

    # For types with Display (use text format)
    impl<T: Display> Serialize for T:
        fn to_bytes() -> [u8]:
            return self.to_string().as_bytes()
    pass

## Test: Related Specifications (Line ~62)

"""
3. Marker Trait Exclusion:
"""
it "related_specifications_35":
    trait UnsafePointer: ...

    # Only for types that are NOT UnsafePointer
    impl<T: !UnsafePointer> Safe for T:
        # Safe operations only
        ...
    pass

## Test: Related Specifications (Line ~81)

"""
Example - Complete Pattern:
"""
it "related_specifications_36":
    trait Process:
        fn process()

    # Default for all types except Clone
    #[default]
    impl<T: !Clone> Process for T:
        fn process():
            print("processing non-cloneable")

    # Specific for Clone types
    impl<T: Clone> Process for T:
        fn process():
            print("processing cloneable")
    pass

