# @pending
"""
# Simple Language Syntax Specification

# @skip

**Status:** Stable
**Feature IDs:** #10-19
**Keywords:** syntax, lexical, operators, execution-modes, indentation
**Last Updated:** 2025-12-28
**Topics:** syntax, type-system
**Symbols:** Token, Operator, ExecutionMode, Parser, Lexer
**Module:** simple_parser
**Migrated From:** doc/spec/syntax.md

## Overview

Comprehensive specification of Simple's syntax, execution modes, and lexical structure.

Simple uses Python-like indentation with type annotations and explicit execution mode control.

## Related Specifications

- **Types** - Type annotations and type syntax
- **Functions** - Function definition syntax
- **Async Default** - Execution mode semantics
- **Parser** - Parser implementation details
"""
# @skip

# Test cases extracted from specification

## Test: Execution Modes

"""
### Scenario: ### Compiler Mode (Native Codegen)
- Requires explicit type annotations on all f...

### Compiler Mode (Native Codegen)
- Requires explicit type annotations on all function parameters and return types (like Rust)
- Compiles to native machine code via Cranelift
- Faster execution, suitable for production
- Example:
"""
fn add(a: i64, b: i64) -> i64:
      return a + b

## Test: Execution Modes

"""
### Scenario: ### Interpreter Mode
- Type annotations are optional - types are inferred at run...

### Interpreter Mode
- Type annotations are optional - types are inferred at runtime
- Supports all language features including dynamic typing
- Better for prototyping and scripting
- Example:
"""
fn add(a, b):
      return a + b

## Test: Syntax Overview

it "syntax_overview_3":
    """
    Syntax Overview
    """
    # An if/else example with indentation
    if x > 0:
        print "x is positive"
    else:
        print "x is non-positive"
    pass

## Test: Syntax Overview

it "syntax_overview_4":
    """
    Syntax Overview
    """
    # Iterating with a trailing block (using backslash for lambda params)
    list.each \item:
        print "Item: {item}"

    # Multiple parameters
    map.each \key, value:
        print "{key}: {value}"
    pass

## Test: Literals

it "literals_5":
    """
    Literals
    """
    # Decimal (default)
    val count = 1_000_000         # underscores for readability

    # Hexadecimal (0x prefix)
    val color = 0xFF5733          # RGB color
    val mask = 0x0000_FFFF        # bit mask

    # Binary (0b prefix)
    val flags = 0b1010_0101       # bit flags

    # Octal (0o prefix)
    val permissions = 0o755       # Unix file permissions
    pass

## Test: Literals

it "literals_6":
    """
    Literals
    """
    val pi = 3.14159
    val avogadro = 6.022e23       # scientific notation
    val tiny = 1.5e-10
    val big = 1_234_567.890_123   # with underscores
    pass

## Test: Literals

it "literals_7":
    """
    Literals
    """
    val a = 42i32                 # i32
    val b = 100u64                # u64
    val c = 3.14f32               # f32 (single precision)
    val d = 2.718f64              # f64 (double precision)
    pass

## Test: Literals

it "literals_8":
    """
    Literals
    """
    # Physical units
    val distance = 100_km         # length type
    val duration = 2_hr           # time type
    val weight = 5_kg             # mass type

    # Semantic IDs
    val user = 42_uid             # UserId type
    val order = 100_oid           # OrderId type

    # Percentages
    val discount = 20_pct         # Percentage type (stored as 0.2)
    pass

## Test: String Literals

it "string_literals_9":
    """
    String Literals
    """
    val name = "world"
    val count = 42
    val msg = "Hello, {name}! Count is {count + 1}"
    # Result: "Hello, world! Count is 43"
    pass

## Test: String Literals

it "string_literals_10":
    """
    String Literals
    """
    val regex = '[a-z]+\d{2,3}'     # No escaping needed
    val path = 'C:\Users\name'      # Backslashes are literal
    val template = '{name}'         # Braces are literal, not interpolation
    pass

## Test: String Literals

it "string_literals_11":
    """
    String Literals
    """
    val msg = f"Hello, {name}!"  # Same as "Hello, {name}!"
    pass

## Test: String Literals

it "string_literals_12":
    """
    String Literals
    """
    # File paths (supports mingw-style with drive letters)
    val config = "/etc/config.json"_file
    val win_path = "C:/Users/data.txt"_file    # mingw-style drive letter

    # Network addresses
    val server = "192.168.1.1"_ip
    val api = "https://api.example.com/v1"_http
    val ftp_server = "ftp://files.example.com"_ftp

    # Socket addresses
    val endpoint = "127.0.0.1:8080"_sock

    # URLs and components
    val host = "example.com"_host
    val path = "/api/users"_urlpath
    pass

## Test: String Literals

it "string_literals_13":
    """
    String Literals
    """
    # ERROR: postfix not allowed on interpolated strings
    val url = "https://{host}/api"_http

    # OK: explicit conversion
    val url = HttpUrl::from_str("https://{host}/api")?
    pass

## Test: Operators

it "operators_14":
    """
    Operators
    """
    # Suspending assignment
    val user ~= fetch_user(id)

    # Suspending guard
    if~ is_ready():
        proceed()

    # Suspending loop
    while~ not done():
        _ ~= timer.sleep(100_ms)

    # Discard result
    _ ~= timer.sleep(100_ms)
    pass

## Test: Functional Update Syntax (`->`)

it "functional_update_syntax___15":
    """
    Functional Update Syntax (`->`)
    """
    var data = load_data()
    data->normalize()           # data = data.normalize()
    data->filter(min: 0)        # data = data.filter(min: 0)
    data->save("out.txt")       # data = data.save("out.txt")
    pass

## Test: Functional Update Syntax (`->`)

it "functional_update_syntax___16":
    """
    Functional Update Syntax (`->`)
    """
    data->normalize()->filter(min: 0)->save("out.txt")
    pass

## Test: Functional Update Syntax (`->`)

"""
### Scenario: 1. Immutable data transformations - When methods return new instances:...

1. Immutable data transformations - When methods return new instances:
"""
it "functional_update_syntax___17":
    """
    Functional Update Syntax (`->`)
    """
    var list = [1, 2, 3]
       list->append(4)->sort()->reverse()
       # list is now [4, 3, 2, 1]
    pass

## Test: Functional Update Syntax (`->`)

"""
### Scenario: 2. Builder patterns - When constructing objects step by step:...

2. Builder patterns - When constructing objects step by step:
"""
it "functional_update_syntax___18":
    """
    Functional Update Syntax (`->`)
    """
    var config = Config.new()
       config->set_host("localhost")->set_port(8080)->set_timeout(30)
    pass

## Test: Functional Update Syntax (`->`)

"""
### Scenario: 3. State machine transitions:...

3. State machine transitions:
"""
it "functional_update_syntax___19":
    """
    Functional Update Syntax (`->`)
    """
    var parser = Parser.new(input)
       parser->read_header()->validate()->parse_body()
    pass

## Test: Parsing Design Rationale

"""
### Scenario: 1. No-parentheses calls restricted to statement level: Parentheses can only be o...

1. No-parentheses calls restricted to statement level: Parentheses can only be omitted for the outermost method call in a statement:
"""
it "parsing_design_rationale_20":
    """
    Parsing Design Rationale
    """
    # Valid: outermost call drops parens
       print format("value: {x}")
       user.set name: "Alice", age: 30

       # Invalid: nested no-paren call is ambiguous
       # print format "value: {x}"  # Error: use parens for nested calls
    pass

## Test: Parsing Design Rationale

"""
### Scenario: 2. Backslash-prefixed lambda parameters: Lambda/block parameters use `\x` rather...

2. Backslash-prefixed lambda parameters: Lambda/block parameters use `\x` rather than `|x|`. The backslash is unambiguous:
"""
it "parsing_design_rationale_21":
    """
    Parsing Design Rationale
    """
    # Clear lambda syntax
       val double = \x: x * 2
       items.filter \x: x > 0

       # Multiple parameters
       pairs.map \a, b: a + b
    pass

