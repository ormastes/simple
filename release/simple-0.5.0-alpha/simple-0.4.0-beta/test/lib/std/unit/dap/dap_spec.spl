# @pending
"""
DAP Module Tests
Feature: Debug Adapter Protocol Support
Category: DAP, Debugging
Status: In Progress

Tests for DAP types, handlers, and fail-safe integration.
"""

use std.mcp.dap.*
use std.failsafe.core.*

describe "BreakpointLocation":
    it "creates basic location":
        val loc = BreakpointLocation.new("test.spl", 42)
        expect(loc.file == "test.spl")
        expect(loc.line == 42)
        expect(loc.column.is_none())
        expect(loc.condition.is_none())

    it "adds condition":
        val loc = BreakpointLocation.new("test.spl", 42)
            .with_condition("x > 10")

        match loc.condition:
            case Some(c):
                expect(c == "x > 10")
            case nil:
                expect(false)

    it "converts to dict":
        val loc = BreakpointLocation.new("test.spl", 42)
        val dict = loc.to_dict()

        expect(dict.get("file") == "test.spl")
        expect(dict.get("line") == 42)

describe "Breakpoint":
    it "creates breakpoint":
        val loc = BreakpointLocation.new("test.spl", 10)
        val bp = Breakpoint.new(1, loc)

        expect(bp.id == 1)
        expect(bp.verified)
        expect(bp.location.line == 10)

    it "converts to dict":
        val loc = BreakpointLocation.new("test.spl", 10)
        val bp = Breakpoint.new(1, loc)
        val dict = bp.to_dict()

        expect(dict.get("id") == 1)
        expect(dict.get("verified") == true)
        expect(dict.get("line") == 10)

describe "StackFrame":
    it "creates stack frame":
        val frame = StackFrame.new(1, "main", "main.spl", 10, 5)

        expect(frame.id == 1)
        expect(frame.name == "main")
        expect(frame.source == "main.spl")
        expect(frame.line == 10)
        expect(frame.column == 5)

    it "converts to dict":
        val frame = StackFrame.new(1, "test_fn", "test.spl", 20, 0)
        val dict = frame.to_dict()

        expect(dict.get("id") == 1)
        expect(dict.get("name") == "test_fn")
        expect(dict.get("line") == 20)

describe "VariableScope":
    it "converts to string":
        expect(VariableScope.Local.to_string() == "local")
        expect(VariableScope.Arguments.to_string() == "arguments")
        expect(VariableScope.Closure.to_string() == "closure")
        expect(VariableScope.Global.to_string() == "global")
        expect(VariableScope.Register.to_string() == "register")

describe "Variable":
    it "creates variable":
        val v = Variable.new("x", "42", "i64")

        expect(v.name == "x")
        expect(v.value == "42")
        expect(v.var_type == "i64")
        expect(v.scope == VariableScope.Local)

    it "converts to dict":
        val v = Variable.new("count", "100", "i64")
        val dict = v.to_dict()

        expect(dict.get("name") == "count")
        expect(dict.get("value") == "100")
        expect(dict.get("type") == "i64")

describe "Scope":
    it "creates scope":
        val scope = Scope.new("Local", 1000)

        expect(scope.name == "Local")
        expect(scope.variables_reference == 1000)
        expect(not scope.expensive)

    it "converts to dict":
        val scope = Scope.new("Global", 2000)
        val dict = scope.to_dict()

        expect(dict.get("name") == "Global")
        expect(dict.get("variablesReference") == 2000)

describe "Thread":
    it "creates thread":
        val thread = Thread.new(1, "main")

        expect(thread.id == 1)
        expect(thread.name == "main")

    it "converts to dict":
        val thread = Thread.new(2, "worker")
        val dict = thread.to_dict()

        expect(dict.get("id") == 2)
        expect(dict.get("name") == "worker")

describe "EvaluateResult":
    it "creates result":
        val result = EvaluateResult.new("42", "i64")

        expect(result.result == "42")
        expect(result.result_type == "i64")
        expect(result.variables_reference == 0)

    it "converts to dict":
        val result = EvaluateResult.new("hello", "text")
        val dict = result.to_dict()

        expect(dict.get("result") == "hello")
        expect(dict.get("type") == "text")

describe "StepType":
    it "converts to string":
        expect(StepType.Into.to_string() == "into")
        expect(StepType.Over.to_string() == "over")
        expect(StepType.Out.to_string() == "out")
        expect(StepType.Continue.to_string() == "continue")
        expect(StepType.Pause.to_string() == "pause")

describe "DapSessionState":
    it "creates session":
        val state = DapSessionState.new("session_1")

        expect(state.session_id == "session_1")
        expect(not state.initialized)
        expect(not state.launched)
        expect(not state.terminated)

    it "adds breakpoints":
        var state = DapSessionState.new("session_1")

        val loc = BreakpointLocation.new("test.spl", 10)
        val bp = state.add_breakpoint(loc)

        expect(bp.id == 1)
        expect(state.next_breakpoint_id == 2)

        val bps = state.get_breakpoints("test.spl")
        expect(bps.len() == 1)

    it "removes breakpoints":
        var state = DapSessionState.new("session_1")

        state.add_breakpoint(BreakpointLocation.new("test.spl", 10))
        state.add_breakpoint(BreakpointLocation.new("test.spl", 20))

        val removed = state.remove_breakpoint("test.spl", 10)
        expect(removed)

        val bps = state.get_breakpoints("test.spl")
        expect(bps.len() == 1)
        expect(bps[0].location.line == 20)

    it "handles non-existent breakpoint removal":
        var state = DapSessionState.new("session_1")
        val removed = state.remove_breakpoint("test.spl", 100)
        expect(not removed)

describe "DapHandler":
    it "creates handler":
        val handler = DapHandler.new("session_1")
        expect(not handler.state.initialized)

    it "handles initialize":
        var handler = DapHandler.new("session_1")
        val result = handler.handle_initialize({})

        expect(handler.state.initialized)
        expect(result.get("supportsConfigurationDoneRequest") == true)

    it "handles set breakpoints":
        var handler = DapHandler.new("session_1")
        handler.handle_initialize({})

        val result = handler.handle_set_breakpoints({
            "source": { "path": "test.spl" },
            "breakpoints": [
                { "line": 10 },
                { "line": 20 }
            ]
        })

        val bps = result.get("breakpoints") as List<Dict<text, Any>>
        expect(bps.len() == 2)

    it "handles launch":
        var handler = DapHandler.new("session_1")
        handler.handle_initialize({})
        handler.handle_launch({})

        expect(handler.state.launched)

    it "handles threads":
        var handler = DapHandler.new("session_1")
        val result = handler.handle_threads({})

        val threads = result.get("threads") as List<Dict<text, Any>>
        expect(threads.len() == 1)

    it "handles terminate":
        var handler = DapHandler.new("session_1")
        handler.handle_initialize({})
        handler.handle_launch({})
        handler.handle_terminate({})

        expect(handler.state.terminated)

describe "DapFailSafeContext":
    it "creates context":
        val ctx = DapFailSafeContext.new("dap_server")
        expect(ctx.request_count == 0)
        expect(ctx.error_count == 0)

    it "tracks requests":
        var ctx = DapFailSafeContext.new("dap_server")

        ctx.execute("initialize", "vscode", \: 42)
        ctx.execute("launch", "vscode", \: 42)

        expect(ctx.request_count == 2)

    it "calculates error rate":
        var ctx = DapFailSafeContext.new("dap_server")
        ctx.request_count = 10
        ctx.error_count = 2

        expect(ctx.error_rate() == 0.2)

    it "gets health status":
        val ctx = DapFailSafeContext.new("dap_server")
        expect(ctx.get_health() == HealthStatus.Healthy)

    it "resets state":
        var ctx = DapFailSafeContext.new("dap_server")
        ctx.request_count = 100
        ctx.error_count = 10

        ctx.reset()

        expect(ctx.request_count == 0)
        expect(ctx.error_count == 0)

describe "FailSafeDapServer":
    it "creates server":
        val server = FailSafeDapServer.new("dap_server", "session_1")
        expect(server.get_health() == HealthStatus.Healthy)

    it "handles initialize command":
        var server = FailSafeDapServer.new("dap_server", "session_1")
        val result = server.handle("initialize", {}, "vscode")

        expect(result.contains("supportsConfigurationDoneRequest"))

    it "handles unknown command":
        var server = FailSafeDapServer.new("dap_server", "session_1")
        val result = server.handle("unknownCommand", {}, "vscode")

        expect(result.contains("error"))

    it "gets statistics":
        var server = FailSafeDapServer.new("dap_server", "session_1")
        server.handle("initialize", {}, "vscode")

        val stats = server.get_stats()
        expect(stats.get("request_count") == 1)

    it "resets server":
        var server = FailSafeDapServer.new("dap_server", "session_1")
        server.handle("initialize", {}, "vscode")
        server.handle("launch", {}, "vscode")

        server.reset()

        val stats = server.get_stats()
        expect(stats.get("request_count") == 0)
