# Error Recovery System - Comprehensive SSpec Tests
# Tests for Phase 1: Enhanced Error Messages

use std.parser.error_recovery.*

feature "Contextual Error Messages":
    """
    Enhanced error messages with context, suggestions, and help text.

    Goal: Replace cryptic token mismatch errors with actionable messages
    that explain WHAT went wrong, WHERE, and HOW to fix it.
    """

    context "when creating contextual errors":

        it "creates error with all fields":
            val err = ContextualSyntaxError(
                context: "function arguments",
                message: "expected comma before argument 'b'",
                span: Span(line: 5, column: 20),
                suggestion: Some("Insert comma before 'b'"),
                help: Some("Use: func(a: 1, b: 2)")
            )

            err.context.should_equal("function arguments")
            err.message.should_equal("expected comma before argument 'b'")
            err.span.line.should_equal(5)
            err.span.column.should_equal(20)
            err.suggestion.should_be_some()
            err.help.should_be_some()

        it "creates error without optional fields":
            val err = ContextualSyntaxError(
                context:  "dict literal",
                message:  "expected colon after key",
                span:  Span(line:  10, column:  5),
                suggestion:  None,
                help:  None
            )

            err.suggestion.should_be_none()
            err.help.should_be_none()

        it "formats error message without color":
            val source = "fn test():\n    func(a: 1 b: 2)\n"
            val err = ContextualSyntaxError(
                context:  "function arguments",
                message:  "expected comma before argument 'b'",
                span:  Span(line:  2, column:  15),
                suggestion:  Some("Insert comma before 'b'"),
                help:  Some("Use: func(a: 1, b: 2)")
            )

            val formatted = err.format(source, use_color: false)

            formatted.should_contain("error[E0013]")
            formatted.should_contain("function arguments")
            formatted.should_contain("expected comma before argument 'b'")
            formatted.should_contain("line 2:15")
            formatted.should_contain("func(a: 1 b: 2)")
            formatted.should_contain("Suggestion: Insert comma before 'b'")
            formatted.should_contain("Help: Use: func(a: 1, b: 2)")

        it "formats error message with color":
            val source = "val x = {a: 1 b: 2}"
            val err = ContextualSyntaxError(
                context:  "dict literal",
                message:  "expected comma between entries",
                span:  Span(line:  1, column:  15),
                suggestion:  Some("Insert comma after value"),
                help:  None
            )

            val formatted = err.format(source, use_color: true)

            formatted.should_contain("\x1b[1;31merror[E0013]:\x1b[0m")
            formatted.should_contain("\x1b[1;36mSuggestion:\x1b[0m")


feature "Common Mistake Detection":
    """
    Detect common programming mistakes from other languages.
    """

    context "missing comma mistakes":

        it "provides message for missing comma in args":
            val mistake = CommonMistake.MissingCommaInArgs
            val msg = mistake.message()

            msg.should_contain("func(a: 1 b: 2)")
            msg.should_contain("func(a: 1, b: 2)")

        it "provides message for missing comma in dict":
            val mistake = CommonMistake.MissingCommaInDict
            val msg = mistake.message()

            msg.should_contain("{a: 1 b: 2}")
            msg.should_contain("{a: 1, b: 2}")

        it "provides message for missing comma in struct":
            val mistake = CommonMistake.MissingCommaInStruct
            val msg = mistake.message()

            msg.should_contain("Point(x: 1 y: 2)")
            msg.should_contain("Point(x: 1, y: 2)")

        it "provides suggestion for each mistake":
            CommonMistake.MissingCommaInArgs.suggestion()
                .should_equal("Insert comma between arguments")

            CommonMistake.MissingCommaInDict.suggestion()
                .should_equal("Insert comma between dict entries")

            CommonMistake.MissingCommaInStruct.suggestion()
                .should_equal("Insert comma between struct fields")

    context "missing colon mistakes":

        it "provides message for missing colon before block":
            val mistake = CommonMistake.MissingColonBeforeBlock
            val msg = mistake.message()

            msg.should_contain("fn foo()")
            msg.should_contain("fn foo():")

        it "provides message for missing colon in dict":
            val mistake = CommonMistake.MissingColonInDict
            val msg = mistake.message()

            msg.should_contain("{key value}")
            msg.should_contain("{key: value}")

    context "indentation mistakes":

        it "provides message for missing indent after colon":
            val mistake = CommonMistake.MissingIndentAfterColon
            val msg = mistake.message()

            msg.should_contain("fn foo():")
            msg.should_contain("return 42")
            msg.should_contain("    return 42")

        it "provides message for wrong indent level":
            val mistake = CommonMistake.WrongIndentLevel
            val msg = mistake.message()

            msg.should_contain("Inconsistent indentation")
            msg.should_contain("4 spaces or tabs")

    context "language-specific mistakes":

        it "provides message for Python def":
            val mistake = CommonMistake.PythonDef
            val msg = mistake.message()

            msg.should_contain("def add(a, b)")
            msg.should_contain("fn add(a, b)")

        it "provides message for Python None":
            val mistake = CommonMistake.PythonNone
            val msg = mistake.message()

            msg.should_contain("return None")
            msg.should_contain("return nil")

        it "provides message for Rust let mut":
            val mistake = CommonMistake.RustLetMut
            val msg = mistake.message()

            msg.should_contain("let mut x = 5")
            msg.should_contain("var x = 5")

        it "provides message for Java new":
            val mistake = CommonMistake.JavaNew
            val msg = mistake.message()

            msg.should_contain("new Point(1, 2)")
            msg.should_contain("Point(x: 1, y: 2)")


feature "Error Detection Helpers":
    """
    Helper functions to detect specific error patterns.
    """

    context "detecting missing comma in function arguments":

        it "detects identifier followed by colon":
            val current = Token(
                kind: TokenKind.Identifier,
                lexeme: "volume",
                span:  Span(line:  1, column:  20)
            )
            val next = Token(
                kind: TokenKind.Colon,
                lexeme: ":",
                span:  Span(line:  1, column:  26)
            )

            val is_missing = detect_missing_comma_in_args(current, next)
            is_missing.should_be_true()

        it "detects identifier followed by equals":
            val current = Token(
                kind: TokenKind.Identifier,
                lexeme: "name",
                span:  Span(line:  1, column:  10)
            )
            val next = Token(
                kind: TokenKind.Assign,
                lexeme: "=",
                span:  Span(line:  1, column:  15)
            )

            val is_missing = detect_missing_comma_in_args(current, next)
            is_missing.should_be_true()

        it "does not detect when not identifier":
            val current = Token(
                kind: TokenKind.Comma,
                lexeme: ",",
                span:  Span(line:  1, column:  10)
            )
            val next = Token(
                kind: TokenKind.Colon,
                lexeme: ":",
                span:  Span(line:  1, column:  11)
            )

            val is_missing = detect_missing_comma_in_args(current, next)
            is_missing.should_be_false()

        it "does not detect when next is not colon/equals":
            val current = Token(
                kind: TokenKind.Identifier,
                lexeme: "x",
                span:  Span(line:  1, column:  5)
            )
            val next = Token(
                kind: TokenKind.RParen,
                lexeme: ")",
                span:  Span(line:  1, column:  6)
            )

            val is_missing = detect_missing_comma_in_args(current, next)
            is_missing.should_be_false()

    context "detecting missing comma in dict":

        it "detects dict entry pattern":
            val prev = Token(
                kind: TokenKind.Identifier,
                lexeme: "1",
                span:  Span(line:  1, column:  8)
            )
            val current = Token(
                kind: TokenKind.Identifier,
                lexeme: "b",
                span:  Span(line:  1, column:  10)
            )
            val next = Token(
                kind: TokenKind.Colon,
                lexeme: ":",
                span:  Span(line:  1, column:  11)
            )

            val is_missing = detect_missing_comma_in_dict(current, next, prev)
            is_missing.should_be_true()

        it "does not detect when prev is comma":
            val prev = Token(
                kind: TokenKind.Comma,
                lexeme: ",",
                span:  Span(line:  1, column:  8)
            )
            val current = Token(
                kind: TokenKind.Identifier,
                lexeme: "b",
                span:  Span(line:  1, column:  10)
            )
            val next = Token(
                kind: TokenKind.Colon,
                lexeme: ":",
                span:  Span(line:  1, column:  11)
            )

            val is_missing = detect_missing_comma_in_dict(current, next, prev)
            is_missing.should_be_false()

    context "detecting missing colon before block":

        it "detects newline after function signature":
            val token = Token(
                kind: TokenKind.Newline,
                lexeme: "\n",
                span:  Span(line:  1, column:  10)
            )

            val is_missing = detect_missing_colon_before_block(token)
            is_missing.should_be_true()

        it "detects indent after function signature":
            val token = Token(
                kind: TokenKind.Indent,
                lexeme: "    ",
                span:  Span(line:  2, column:  1)
            )

            val is_missing = detect_missing_colon_before_block(token)
            is_missing.should_be_true()

        it "does not detect other tokens":
            val token = Token(
                kind: TokenKind.Colon,
                lexeme: ":",
                span:  Span(line:  1, column:  10)
            )

            val is_missing = detect_missing_colon_before_block(token)
            is_missing.should_be_false()


feature "Fix Suggestion System":
    """
    Automatic fix generation with confidence scores.
    """

    context "creating fix suggestions":

        it "creates fix with high confidence":
            val fix = FixSuggestion(
                description: "Insert missing comma",
                span:  Span(line:  5, column:  15),
                replacement: ", ",
                confidence: Confidence.High
            )

            fix.description.should_equal("Insert missing comma")
            fix.replacement.should_equal(", ")
            fix.confidence.should_equal(Confidence.High)

        it "creates fix with medium confidence":
            val fix = FixSuggestion(
                description: "Add indentation",
                span:  Span(line:  10, column:  1),
                replacement: "    ",
                confidence: Confidence.Medium
            )

            fix.confidence.should_equal(Confidence.Medium)

        it "creates fix with low confidence":
            val fix = FixSuggestion(
                description: "Possible fix",
                span:  Span(line:  20, column:  5),
                replacement: ":",
                confidence: Confidence.Low
            )

            fix.confidence.should_equal(Confidence.Low)

    context "generating diffs":

        it "generates unified diff for insertion":
            val source = "func(a: 1 b: 2)"
            val fix = FixSuggestion(
                description: "Insert comma",
                span:  Span(line:  1, column:  11),
                replacement: ", ",
                confidence: Confidence.High
            )

            val diff = fix.generate_diff(source)

            diff.should_contain("--- before")
            diff.should_contain("+++ after")
            diff.should_contain("-func(a: 1 b: 2)")
            diff.should_contain("+func(a: 1, b: 2)")

        it "generates diff for multiple line source":
            val source = "fn test():\n    func(a: 1 b: 2)\n    return"
            val fix = FixSuggestion(
                description: "Insert comma",
                span:  Span(line:  2, column:  15),
                replacement: ", ",
                confidence: Confidence.High
            )

            val diff = fix.generate_diff(source)

            diff.should_contain("@@ -2,1 +2,1 @@")
            diff.should_contain("-    func(a: 1 b: 2)")
            diff.should_contain("+    func(a: 1, b: 2)")

    context "managing collections of fixes":

        it "finds best fix from collection":
            val fixes = [
                FixSuggestion(
                    description: "Fix 1",
                    span:  Span(line:  1, column:  1),
                    replacement: ",",
                    confidence: Confidence.Low
                ),
                FixSuggestion(
                    description: "Fix 2",
                    span:  Span(line:  1, column:  1),
                    replacement: ", ",
                    confidence: Confidence.High
                ),
                FixSuggestion(
                    description: "Fix 3",
                    span:  Span(line:  1, column:  1),
                    replacement: " ,",
                    confidence: Confidence.Medium
                )
            ]

            val suggestions = FixSuggestions(
                error_message:  "Missing comma",
                error_span:  Span(line:  1, column:  10),
                fixes: fixes
            )

            val best = suggestions.best_fix()
            best.should_be_some()
            best.unwrap().confidence.should_equal(Confidence.High)
            best.unwrap().description.should_equal("Fix 2")

        it "returns None when no fixes available":
            val suggestions = FixSuggestions(
                error_message:  "Error",
                error_span:  Span(line:  1, column:  1),
                fixes: []
            )

            val best = suggestions.best_fix()
            best.should_be_none()


feature "Error Builder Pattern":
    """
    Fluent API for constructing contextual errors.
    """

    context "building errors step by step":

        it "builds error with all fields":
            val err = ErrorBuilder()
                .context("function arguments")
                .message("expected comma before argument 'b'")
                .at_span(Span(line:  5, column:  20))
                .suggest("Insert comma before 'b'")
                .help_text("Use: func(a: 1, b: 2)")
                .build()

            err.context.should_equal("function arguments")
            err.message.should_equal("expected comma before argument 'b'")
            err.span.line.should_equal(5)
            err.span.column.should_equal(20)
            err.suggestion.should_be_some()
            err.help.should_be_some()

        it "builds error with minimal fields":
            val err = ErrorBuilder()
                .context("dict literal")
                .message("expected colon")
                .at_span(Span(line:  10, column:  5))
                .build()

            err.context.should_equal("dict literal")
            err.message.should_equal("expected colon")
            err.suggestion.should_be_none()
            err.help.should_be_none()

        it "allows method chaining in any order":
            val err = ErrorBuilder()
                .at_span(Span(line:  1, column:  1))
                .message("test message")
                .context("test context")
                .build()

            err.context.should_equal("test context")
            err.message.should_equal("test message")


feature "Integration Scenarios":
    """
    Real-world usage scenarios combining multiple components.
    """

    context "handling missing comma in function call":

        it "detects error and provides full guidance":
            # Simulate parser state
            val source = "AudioSource(name: 'test' volume: 1.0)"

            val current_token = Token(
                kind: TokenKind.Identifier,
                lexeme: "volume",
                span:  Span(line:  1, column:  26)
            )

            val next_token = Token(
                kind: TokenKind.Colon,
                lexeme: ":",
                span:  Span(line:  1, column:  32)
            )

            # Detect mistake
            val has_mistake = detect_missing_comma_in_args(current_token, next_token)
            has_mistake.should_be_true()

            # Create contextual error
            val err = ErrorBuilder()
                .context("function arguments")
                .message("expected comma before argument 'volume'")
                .at_span(current_token.span)
                .suggest("Insert comma before 'volume'")
                .help_text("Use: AudioSource(name: 'test', volume: 1.0)")
                .build()

            # Verify error message
            val formatted = err.format(source, use_color: false)
            formatted.should_contain("error[E0013]")
            formatted.should_contain("function arguments")
            formatted.should_contain("expected comma before argument 'volume'")

            # Create fix suggestion
            val fix = FixSuggestion(
                description: "Insert comma",
                span:  Span(line:  1, column:  25),
                replacement: ", ",
                confidence: Confidence.High
            )

            # Verify diff
            val diff = fix.generate_diff(source)
            diff.should_contain("AudioSource(name: 'test' volume: 1.0)")
            diff.should_contain("AudioSource(name: 'test', volume: 1.0)")

    context "handling missing comma in dict literal":

        it "provides complete error recovery workflow":
            val source = "{key1: 'value1' key2: 'value2'}"

            # Detect pattern
            val prev = Token(kind: TokenKind.Identifier, lexeme: "'value1'", span:  Span(line:  1, column:  15))
            val current = Token(kind: TokenKind.Identifier, lexeme: "key2", span:  Span(line:  1, column:  17))
            val next = Token(kind: TokenKind.Colon, lexeme: ":", span:  Span(line:  1, column:  21))

            val has_mistake = detect_missing_comma_in_dict(current, next, prev)
            has_mistake.should_be_true()

            # Build error
            val err = ErrorBuilder()
                .context("dict literal")
                .message("expected comma between dict entries")
                .at_span(current.span)
                .suggest("Insert comma after the value")
                .help_text("Dict entries must be separated by commas: {a: 1, b: 2}")
                .build()

            err.context.should_equal("dict literal")
            err.suggestion.should_be_some()

    context "handling missing colon before block":

        it "provides complete error recovery workflow":
            val source = "fn test()\n    return 42"

            # Detect pattern
            val token = Token(kind: TokenKind.Newline, lexeme: "\n", span:  Span(line:  1, column:  10))

            val has_mistake = detect_missing_colon_before_block(token)
            has_mistake.should_be_true()

            # Build error
            val err = ErrorBuilder()
                .context("function definition")
                .message("expected colon before function body")
                .at_span(token.span)
                .suggest("Insert ':' at end of line")
                .help_text("Function definitions require a colon: fn name():")
                .build()

            # Verify
            val formatted = err.format(source, use_color: false)
            formatted.should_contain("function definition")
            formatted.should_contain("expected colon before function body")


feature "Edge Cases and Robustness":
    """
    Test edge cases and error handling.
    """

    context "handling invalid spans":

        it "handles line out of bounds gracefully":
            val source = "short"
            val fix = FixSuggestion(
                description: "Fix",
                span:  Span(line:  100, column:  1),
                replacement: ",",
                confidence: Confidence.High
            )

            val diff = fix.generate_diff(source)
            diff.should_contain("Error: line out of bounds")

        it "handles column at line boundary":
            val source = "test"
            val fix = FixSuggestion(
                description: "Fix",
                span:  Span(line:  1, column:  5),
                replacement: ",",
                confidence: Confidence.High
            )

            val diff = fix.generate_diff(source)
            diff.should_contain("+test,")

    context "handling empty inputs":

        it "formats error for empty source":
            val err = ContextualSyntaxError(
                context:  "test",
                message:  "test error",
                span:  Span(line:  1, column:  1),
                suggestion:  None,
                help:  None
            )

            val formatted = err.format("", use_color: false)
            formatted.should_contain("error[E0013]")

        it "handles empty fixes collection":
            val suggestions = FixSuggestions(
                error_message:  "Error",
                error_span:  Span(line:  1, column:  1),
                fixes: []
            )

            suggestions.best_fix().should_be_none()
