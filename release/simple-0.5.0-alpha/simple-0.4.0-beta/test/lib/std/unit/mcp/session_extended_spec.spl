# @pending
"""
MCP Session Manager Extended Tests
Feature: Debug Session Management - Edge Cases & State Transitions
Category: MCP, Debug
Status: In Progress

Extended tests covering session state transitions, breakpoint edge cases,
multi-session scenarios, and error resilience for the SessionManager.
"""


# ----------- Inline type definitions -----------

enum SessionState:
    Created
    Running
    Paused
    Terminated

enum TargetType:
    Interpreter
    Smf
    Native

class SessionBreakpoint:
    id: Int
    file: String
    line: Int
    condition: Option<String>
    enabled: Bool
    hit_count: Int

    static fn at_line(id: Int, file: String, line: Int) -> SessionBreakpoint:
        SessionBreakpoint(
            id: id,
            file: file,
            line: line,
            condition: None,
            enabled: true,
            hit_count: 0
        )

class DebugSession:
    id: String
    target_type: TargetType
    program_path: String
    state: SessionState
    breakpoints: List<SessionBreakpoint>
    args: List<String>

    static fn create(id: String, target_type: TargetType, program_path: String) -> DebugSession:
        DebugSession(
            id: id,
            target_type: target_type,
            program_path: program_path,
            state: SessionState.Created,
            breakpoints: [],
            args: []
        )

class SessionManager:
    sessions: Dict<String, DebugSession>
    next_session_id: Int
    next_bp_id: Int

    static fn empty() -> SessionManager:
        SessionManager(
            sessions: {},
            next_session_id: 1,
            next_bp_id: 1
        )

impl SessionManager:
    me create_session(target_type: TargetType, program_path: String) -> String:
        val id = "session_{self.next_session_id}"
        self.next_session_id = self.next_session_id + 1
        val session = DebugSession.create(id, target_type, program_path)
        self.sessions[id] = session
        id

    fn get_session(id: String) -> Option<DebugSession>:
        self.sessions.get(id)

    fn list_sessions() -> List<DebugSession>:
        var result: List<DebugSession> = []
        for (_, session) in self.sessions.items():
            result.push(session)
        result

    me remove_session(id: String) -> Bool:
        match self.sessions.get(id):
            case Some(_):
                self.sessions.remove(id)
                true
            case None:
                false

    me add_breakpoint(session_id: String, file: String, line: Int) -> Option<Int>:
        match self.sessions.get(session_id):
            case Some(session):
                val bp_id = self.next_bp_id
                self.next_bp_id = self.next_bp_id + 1
                val bp = SessionBreakpoint.at_line(bp_id, file, line)
                session.breakpoints.push(bp)
                Some(bp_id)
            case None:
                None

    fn remove_breakpoint(session_id: String, bp_id: Int) -> Bool:
        match self.sessions.get(session_id):
            case Some(session):
                val initial_len = session.breakpoints.len()
                session.breakpoints = session.breakpoints.filter(\bp: bp.id != bp_id)
                session.breakpoints.len() < initial_len
            case None:
                false

    me set_state(session_id: String, new_state: SessionState):
        match self.sessions.get(session_id):
            case Some(session):
                session.state = new_state
            case None:
                pass

# ----------- Tests -----------

describe "SessionManager state transitions":
    it "transitions Created -> Running":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
        mgr.set_state(sid, SessionState.Running)
        match mgr.get_session(sid):
            case Some(s):
                match s.state:
                    case SessionState.Running: expect(true)
                    case _: expect(false)
            case None: expect(false)

    it "transitions Running -> Paused":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
        mgr.set_state(sid, SessionState.Running)
        mgr.set_state(sid, SessionState.Paused)
        match mgr.get_session(sid):
            case Some(s):
                match s.state:
                    case SessionState.Paused: expect(true)
                    case _: expect(false)
            case None: expect(false)

    it "transitions Paused -> Running (resume)":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
        mgr.set_state(sid, SessionState.Running)
        mgr.set_state(sid, SessionState.Paused)
        mgr.set_state(sid, SessionState.Running)
        match mgr.get_session(sid):
            case Some(s):
                match s.state:
                    case SessionState.Running: expect(true)
                    case _: expect(false)
            case None: expect(false)

    it "transitions Running -> Terminated":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
        mgr.set_state(sid, SessionState.Running)
        mgr.set_state(sid, SessionState.Terminated)
        match mgr.get_session(sid):
            case Some(s):
                match s.state:
                    case SessionState.Terminated: expect(true)
                    case _: expect(false)
            case None: expect(false)

    it "set_state on non-existent session does nothing":
        var mgr = SessionManager.empty()
        mgr.set_state("fake_id", SessionState.Running)
        expect(mgr.list_sessions().len() == 0)

describe "SessionManager multi-session":
    it "manages multiple sessions of different types":
        var mgr = SessionManager.empty()
        val s1 = mgr.create_session(TargetType.Interpreter, "a.spl")
        val s2 = mgr.create_session(TargetType.Smf, "b.smf")
        val s3 = mgr.create_session(TargetType.Native, "c.bin")
        expect(mgr.list_sessions().len() == 3)

    it "sessions have independent state":
        var mgr = SessionManager.empty()
        val s1 = mgr.create_session(TargetType.Interpreter, "a.spl")
        val s2 = mgr.create_session(TargetType.Interpreter, "b.spl")
        mgr.set_state(s1, SessionState.Running)
        mgr.set_state(s2, SessionState.Paused)
        match mgr.get_session(s1):
            case Some(sess1):
                match sess1.state:
                    case SessionState.Running: expect(true)
                    case _: expect(false)
            case None: expect(false)
        match mgr.get_session(s2):
            case Some(sess2):
                match sess2.state:
                    case SessionState.Paused: expect(true)
                    case _: expect(false)
            case None: expect(false)

    it "removing one session doesn't affect others":
        var mgr = SessionManager.empty()
        val s1 = mgr.create_session(TargetType.Interpreter, "a.spl")
        val s2 = mgr.create_session(TargetType.Interpreter, "b.spl")
        mgr.remove_session(s1)
        expect(mgr.list_sessions().len() == 1)
        match mgr.get_session(s2):
            case Some(_): expect(true)
            case None: expect(false)

    it "session ids are monotonically increasing":
        var mgr = SessionManager.empty()
        val s1 = mgr.create_session(TargetType.Interpreter, "a.spl")
        val s2 = mgr.create_session(TargetType.Interpreter, "b.spl")
        val s3 = mgr.create_session(TargetType.Interpreter, "c.spl")
        expect(s1 == "session_1")
        expect(s2 == "session_2")
        expect(s3 == "session_3")

    it "ids continue after removal":
        var mgr = SessionManager.empty()
        val s1 = mgr.create_session(TargetType.Interpreter, "a.spl")
        mgr.remove_session(s1)
        val s2 = mgr.create_session(TargetType.Interpreter, "b.spl")
        expect(s2 == "session_2")

describe "SessionManager breakpoint edge cases":
    it "multiple breakpoints in same file":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
        mgr.add_breakpoint(sid, "test.spl", 10)
        mgr.add_breakpoint(sid, "test.spl", 20)
        mgr.add_breakpoint(sid, "test.spl", 30)
        match mgr.get_session(sid):
            case Some(s): expect(s.breakpoints.len() == 3)
            case None: expect(false)

    it "breakpoints across different files":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "main.spl")
        mgr.add_breakpoint(sid, "main.spl", 10)
        mgr.add_breakpoint(sid, "util.spl", 5)
        mgr.add_breakpoint(sid, "lib.spl", 42)
        match mgr.get_session(sid):
            case Some(s): expect(s.breakpoints.len() == 3)
            case None: expect(false)

    it "breakpoint ids are globally unique across sessions":
        var mgr = SessionManager.empty()
        val s1 = mgr.create_session(TargetType.Interpreter, "a.spl")
        val s2 = mgr.create_session(TargetType.Interpreter, "b.spl")
        match mgr.add_breakpoint(s1, "a.spl", 1):
            case Some(bp1):
                match mgr.add_breakpoint(s2, "b.spl", 1):
                    case Some(bp2): expect(bp1 != bp2)
                    case None: expect(false)
            case None: expect(false)

    it "remove breakpoint that doesn't exist returns false":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
        mgr.add_breakpoint(sid, "test.spl", 10)
        expect(not mgr.remove_breakpoint(sid, 999))

    it "remove breakpoint from non-existent session returns false":
        var mgr = SessionManager.empty()
        expect(not mgr.remove_breakpoint("fake", 1))

    it "removing all breakpoints one by one":
        var mgr = SessionManager.empty()
        val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
        mgr.add_breakpoint(sid, "test.spl", 10)
        mgr.add_breakpoint(sid, "test.spl", 20)
        expect(mgr.remove_breakpoint(sid, 1))
        expect(mgr.remove_breakpoint(sid, 2))
        match mgr.get_session(sid):
            case Some(s): expect(s.breakpoints.len() == 0)
            case None: expect(false)

describe "SessionBreakpoint":
    it "defaults to enabled":
        val bp = SessionBreakpoint.at_line(1, "test.spl", 42)
        expect(bp.enabled)

    it "defaults to zero hit count":
        val bp = SessionBreakpoint.at_line(1, "test.spl", 42)
        expect(bp.hit_count == 0)

    it "stores correct file and line":
        val bp = SessionBreakpoint.at_line(5, "src/main.spl", 100)
        expect(bp.file == "src/main.spl")
        expect(bp.line == 100)
        expect(bp.id == 5)

    it "has no condition by default":
        val bp = SessionBreakpoint.at_line(1, "test.spl", 1)
        match bp.condition:
            case None: expect(true)
            case Some(_): expect(false)

describe "DebugSession":
    it "stores target type correctly":
        val s1 = DebugSession.create("s1", TargetType.Interpreter, "a.spl")
        val s2 = DebugSession.create("s2", TargetType.Smf, "b.smf")
        val s3 = DebugSession.create("s3", TargetType.Native, "c.bin")
        match s1.target_type:
            case TargetType.Interpreter: expect(true)
            case _: expect(false)
        match s2.target_type:
            case TargetType.Smf: expect(true)
            case _: expect(false)
        match s3.target_type:
            case TargetType.Native: expect(true)
            case _: expect(false)

    it "starts with empty args":
        val s = DebugSession.create("s1", TargetType.Interpreter, "test.spl")
        expect(s.args.len() == 0)

    it "starts with empty breakpoints":
        val s = DebugSession.create("s1", TargetType.Interpreter, "test.spl")
        expect(s.breakpoints.len() == 0)
