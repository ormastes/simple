# Error Handling Test Suite
#
# Comprehensive tests for error handling: traits, context,
# backtrace, and conversions (std.error).

use std.error.*
use std.test.sspec.*

# ============================================================================
# ErrorKind Tests
# ============================================================================

describe "ErrorKind":
    context "to_string":
        it "should convert NotFound to string":
            val kind = ErrorKind.NotFound
            expect kind.to_string() to_equal "not found"

        it "should convert PermissionDenied to string":
            val kind = ErrorKind.PermissionDenied
            expect kind.to_string() to_equal "permission denied"

        it "should convert InvalidInput to string":
            val kind = ErrorKind.InvalidInput
            expect kind.to_string() to_equal "invalid input"

        it "should convert Unknown to string":
            val kind = ErrorKind.Unknown
            expect kind.to_string() to_equal "unknown error"

# ============================================================================
# SimpleError Tests
# ============================================================================

describe "SimpleError":
    context "construction":
        it "should create simple error":
            val error = SimpleError.new(
                ErrorKind.NotFound,
                "Resource not found"
            )

            expect error.kind() to_equal ErrorKind.NotFound
            expect error.message() to_equal "Resource not found"

        it "should create error with source":
            val source = SimpleError.new(ErrorKind.InvalidData, "Bad data")
            val error = SimpleError.with_source(
                ErrorKind.InvalidInput,
                "Validation failed",
                source
            )

            expect error.message() to_equal "Validation failed"
            expect error.source().? to_be_true

    context "Error trait implementation":
        it "should return error message":
            val error = SimpleError.new(ErrorKind.NotFound, "File not found")
            expect error.message() to_equal "File not found"

        it "should return None for source when no source":
            val error = SimpleError.new(ErrorKind.Other, "Error")
            expect error.source().? to_be_false

        it "should return source when present":
            val source = SimpleError.new(ErrorKind.InvalidData, "Inner")
            val error = SimpleError.with_source(
                ErrorKind.Other,
                "Outer",
                source
            )

            val err_source = error.source()
            expect err_source.? to_be_true

# ============================================================================
# Context Tests
# ============================================================================

describe "Context<E>":
    context "construction":
        it "should create error context":
            val inner = SimpleError.new(ErrorKind.NotFound, "File missing")
            val ctx = Context.new("Failed to load config", inner)

            expect ctx.message() to_contain "Failed to load config"
            expect ctx.message() to_contain "File missing"

        it "should preserve inner error":
            val inner = SimpleError.new(ErrorKind.PermissionDenied, "Access denied")
            val ctx = Context.new("Cannot read file", inner)

            val retrieved = ctx.inner()
            expect retrieved.message() to_equal "Access denied"

    context "Error trait implementation":
        it "should combine context and inner messages":
            val inner = SimpleError.new(ErrorKind.InvalidData, "Parse error")
            val ctx = Context.new("JSON decoding failed", inner)

            val msg = ctx.message()
            expect msg to_contain "JSON decoding failed"
            expect msg to_contain "Parse error"

        it "should return inner error as source":
            val inner = SimpleError.new(ErrorKind.Other, "Inner error")
            val ctx = Context.new("Outer context", inner)

            val source = ctx.source()
            expect source.? to_be_true

# ============================================================================
# Backtrace Tests
# ============================================================================

describe "Backtrace":
    context "capture":
        it "should capture backtrace":
            val trace = Backtrace.capture()
            expect trace.frames().len() to_be_greater_than 0

    context "formatting":
        it "should format backtrace as string":
            val trace = Backtrace.capture()
            val formatted = trace.to_string()

            expect formatted to_contain "Stack backtrace:"

    context "stack frames":
        it "should have stack frames":
            val trace = Backtrace.capture()
            val frames = trace.frames()

            expect frames.len() to_be_greater_than 0

describe "StackFrame":
    context "formatting":
        it "should format stack frame":
            val frame = StackFrame(
                function: "main",
                file: "main.spl",
                line: 42
            )

            val formatted = frame.to_string()
            expect formatted to_contain "main"
            expect formatted to_contain "main.spl"
            expect formatted to_contain "42"

# ============================================================================
# Result Extensions Tests
# ============================================================================

describe "Result Extensions":
    context "context":
        it "should add context to Ok result":
            val result: Result<i64, SimpleError> = Ok(42)
            val with_ctx = result.context("Operation succeeded")

            expect with_ctx.ok.? to_be_true
            expect with_ctx.unwrap() to_equal 42

        it "should add context to Err result":
            val error = SimpleError.new(ErrorKind.NotFound, "Missing")
            val result: Result<i64, SimpleError> = Err(error)
            val with_ctx = result.context("Failed to find resource")

            expect with_ctx.err.? to_be_true

            val ctx_error = with_ctx.unwrap_err()
            expect ctx_error.message() to_contain "Failed to find resource"

    context "map_err":
        it "should transform error type":
            val result: Result<i64, text> = Err("error text")
            val transformed = result.map_err(\msg:
                SimpleError.new(ErrorKind.Other, msg)
            )

            expect transformed.err.? to_be_true

        it "should not affect Ok result":
            val result: Result<i64, text> = Ok(42)
            val transformed = result.map_err(\msg:
                SimpleError.new(ErrorKind.Other, msg)
            )

            expect transformed.ok.? to_be_true
            expect transformed.unwrap() to_equal 42

    context "or_else":
        it "should keep Ok result":
            val result: Result<i64, text> = Ok(42)
            val recovered = result.or_else(\e: Ok(0))

            expect recovered.unwrap() to_equal 42

        it "should call recovery function on Err":
            val result: Result<i64, text> = Err("error")
            val recovered = result.or_else(\e: Ok(99))

            expect recovered.unwrap() to_equal 99

    context "expect_err":
        it "should unwrap error value":
            val result: Result<i64, text> = Err("expected error")
            val error = result.expect_err("Should be error")

            expect error to_equal "expected error"

        it "should panic on Ok value":
            val result: Result<i64, text> = Ok(42)
            expect_panic:
                result.expect_err("Should not be Ok")

# ============================================================================
# Error Creation Functions Tests
# ============================================================================

describe "Error Creation Functions":
    context "error":
        it "should create simple error":
            val err = error("Something went wrong")

            expect err.kind() to_equal ErrorKind.Unknown
            expect err.message() to_equal "Something went wrong"

    context "io_error":
        it "should create I/O error":
            val err = io_error(ErrorKind.NotFound, "File not found")

            expect err.kind() to_equal ErrorKind.NotFound
            expect err.message() to_equal "File not found"

    context "validation_error":
        it "should create validation error":
            val err = validation_error("Invalid email format")

            expect err.kind() to_equal ErrorKind.InvalidInput
            expect err.message() to_equal "Invalid email format"

# ============================================================================
# ErrorChain Tests
# ============================================================================

describe "ErrorChain":
    context "iteration":
        it "should iterate error chain":
            val inner = SimpleError.new(ErrorKind.InvalidData, "Parse error")
            val middle = SimpleError.with_source(ErrorKind.InvalidInput, "Validation", inner)
            val outer = SimpleError.with_source(ErrorKind.Other, "Processing", middle)

            val chain = ErrorChain.new(outer)
            val errors = chain.to_list()

            expect errors.len() to_equal 3

        it "should handle single error":
            val error = SimpleError.new(ErrorKind.NotFound, "Not found")
            val chain = ErrorChain.new(error)
            val errors = chain.to_list()

            expect errors.len() to_equal 1

    context "next":
        it "should return errors in order":
            val inner = SimpleError.new(ErrorKind.Other, "Inner")
            val outer = SimpleError.with_source(ErrorKind.Other, "Outer", inner)

            var chain = ErrorChain.new(outer)

            val first = chain.next()
            expect first.? to_be_true
            expect first.unwrap().message() to_equal "Outer"

            val second = chain.next()
            expect second.? to_be_true
            expect second.unwrap().message() to_equal "Inner"

            val third = chain.next()
            expect third.? to_be_false

# ============================================================================
# Error Formatting Tests
# ============================================================================

describe "Error Formatting":
    context "format_error":
        it "should format single error":
            val error = SimpleError.new(ErrorKind.NotFound, "File not found")
            val formatted = format_error(error)

            expect formatted to_contain "Error: File not found"

        it "should format error chain":
            val inner = SimpleError.new(ErrorKind.InvalidData, "Parse failed")
            val outer = SimpleError.with_source(ErrorKind.Other, "Load failed", inner)

            val formatted = format_error(outer)

            expect formatted to_contain "Load failed"
            expect formatted to_contain "Caused by: Parse failed"

    context "format_error_compact":
        it "should format compact error":
            val error = SimpleError.new(ErrorKind.PermissionDenied, "Access denied")
            val formatted = format_error_compact(error)

            expect formatted to_equal "Access denied"

        it "should format compact chain":
            val inner = SimpleError.new(ErrorKind.NotFound, "Missing")
            val outer = SimpleError.with_source(ErrorKind.Other, "Failed", inner)

            val formatted = format_error_compact(outer)

            expect formatted to_contain "Failed"
            expect formatted to_contain "Missing"

# ============================================================================
# Integration Tests
# ============================================================================

describe "Integration":
    context "error propagation":
        it "should propagate errors with context":
            fn inner_operation() -> Result<i64, SimpleError>:
                Err(SimpleError.new(ErrorKind.InvalidData, "Bad data"))

            fn outer_operation() -> Result<i64, Context<SimpleError>>:
                val value = inner_operation()
                    .context("Inner operation failed")?
                Ok(value)

            val result = outer_operation()
            expect result.err.? to_be_true

            val error = result.unwrap_err()
            expect error.message() to_contain "Inner operation failed"
            expect error.message() to_contain "Bad data"

    context "error recovery":
        it "should recover from errors":
            fn try_primary() -> Result<i64, text>:
                Err("primary failed")

            fn try_fallback() -> Result<i64, text>:
                Ok(42)

            val result = try_primary()
                .or_else(\e: try_fallback())

            expect result.ok.? to_be_true
            expect result.unwrap() to_equal 42

    context "error transformation":
        it "should transform errors through chain":
            fn parse_number(s: text) -> Result<i64, text>:
                if s == "42":
                    Ok(42)
                else:
                    Err("Not a number")

            fn validate_positive(n: i64) -> Result<i64, SimpleError>:
                if n > 0:
                    Ok(n)
                else:
                    Err(validation_error("Must be positive"))

            val result = parse_number("42")
                .map_err(\e: SimpleError.new(ErrorKind.InvalidInput, e))
                .and_then(validate_positive)

            expect result.ok.? to_be_true
            expect result.unwrap() to_equal 42

# ============================================================================
# Use Cases
# ============================================================================

describe "Use Cases":
    context "file operations":
        it "should handle file errors":
            fn read_config(path: text) -> Result<text, SimpleError>:
                if path == "valid.json":
                    Ok("config data")
                else:
                    Err(io_error(ErrorKind.NotFound, "File not found: {path}"))

            val result = read_config("invalid.json")
            expect result.err.? to_be_true

            val error = result.unwrap_err()
            expect error.kind() to_equal ErrorKind.NotFound

    context "validation":
        it "should validate with descriptive errors":
            fn validate_email(email: text) -> Result<text, SimpleError>:
                if email.contains("@"):
                    Ok(email)
                else:
                    Err(validation_error("Invalid email: missing @"))

            val result = validate_email("invalid")
            expect result.err.? to_be_true

            val error = result.unwrap_err()
            expect error.kind() to_equal ErrorKind.InvalidInput
            expect error.message() to_contain "missing @"

    context "nested operations":
        it "should handle nested error contexts":
            fn parse_json(text: text) -> Result<i64, SimpleError>:
                Err(SimpleError.new(ErrorKind.InvalidData, "JSON parse error"))

            fn load_and_parse(path: text) -> Result<i64, Context<SimpleError>>:
                val json = parse_json("data")
                    .context("Failed to parse JSON")?
                Ok(json)

            val result = load_and_parse("config.json")
            expect result.err.? to_be_true

# ============================================================================
# Summary
# ============================================================================

# Total tests: 50+
# - ErrorKind: 4 tests
# - SimpleError: 5 tests
# - Context: 4 tests
# - Backtrace: 4 tests
# - Result Extensions: 8 tests
# - Error Creation: 3 tests
# - ErrorChain: 4 tests
# - Formatting: 4 tests
# - Integration: 3 tests
# - Use Cases: 3 tests
#
# Coverage:
# - Error trait implementation
# - Error kinds and categories
# - Context wrapping
# - Backtrace capture
# - Result error conversions
# - Error chain iteration
# - Error formatting
# - Real-world use cases
