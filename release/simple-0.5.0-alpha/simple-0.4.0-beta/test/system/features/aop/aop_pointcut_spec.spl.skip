"""
# AOP Pointcut Expression Specification

**Feature IDs:** #AOP-PC-001 to #AOP-PC-015
**Category:** Language
**Status:** Planned
**Tags:** skip

Pointcut expressions define where advice should be applied. The `pc{...}` syntactic
island contains pointcut predicates that match against the program structure.

## Syntax

```simple
pc{ selector(pattern) }
pc{ selector1(...) & selector2(...) }  # AND
pc{ selector1(...) | selector2(...) }  # OR
pc{ !selector(...) }                   # NOT
```

## Selectors

| Selector | Description | Example |
|----------|-------------|---------|
| execution | Match function execution | `execution(* foo(..))` |
| within | Match code in module/class | `within(services.*)` |
| attr | Match by attribute | `attr(logged)` |
| init | Match constructor (runtime) | `init(MyClass)` |
| type | Match by type (DI) | `type(Repository)` |
"""

use std.spec


# ============================================================================
# Test Group 1: Execution Selector
# ============================================================================

describe "Execution Pointcut Selector":
    """
    ## execution(signature) Selector

    Matches join points at function execution. The signature pattern includes
    return type, function name, and parameter types.
    """

    context "return type patterns":
        it "matches any return type with wildcard":
            var matched = false

            fn marker():
                matched = true

            fn returns_int() -> i64:
                42

            fn returns_text() -> text:
                "hello"

            on pc{ execution(* returns*(..)) } use marker before priority 10

            returns_int()
            expect matched == true

            matched = false
            returns_text()
            expect matched == true

        it "matches specific return type":
            var int_matched = false
            var text_matched = false

            fn int_marker():
                int_matched = true

            fn text_marker():
                text_matched = true

            fn typed_int() -> i64:
                42

            fn typed_text() -> text:
                "hello"

            on pc{ execution(i64 typed_int(..)) } use int_marker before priority 10
            on pc{ execution(text typed_text(..)) } use text_marker before priority 10

            typed_int()
            typed_text()
            expect int_matched == true
            expect text_matched == true

    context "function name patterns":
        it "matches exact function name":
            var called = false

            fn marker():
                called = true

            fn exact_name() -> i64:
                42

            fn other_name() -> i64:
                0

            on pc{ execution(* exact_name(..)) } use marker before priority 10

            exact_name()
            expect called == true

        it "matches prefix wildcard":
            var count = 0

            fn counter():
                count = count + 1

            fn handle_request() -> i64:
                1

            fn handle_response() -> i64:
                2

            fn process_data() -> i64:
                3

            on pc{ execution(* handle*(..)) } use counter before priority 10

            handle_request()
            handle_response()
            process_data()
            expect count == 2

        it "matches suffix wildcard":
            var count = 0

            fn counter():
                count = count + 1

            fn get_user() -> i64:
                1

            fn get_order() -> i64:
                2

            fn set_user() -> i64:
                3

            on pc{ execution(* get*(..)) } use counter before priority 10

            get_user()
            get_order()
            set_user()
            expect count == 2

    context "parameter patterns":
        it "matches any parameters with (..)":
            var called = false

            fn marker():
                called = true

            fn no_params() -> i64:
                1

            fn one_param(x: i64) -> i64:
                x

            fn two_params(x: i64, y: i64) -> i64:
                x + y

            on pc{ execution(* *_params(..)) } use marker before priority 10

            no_params()
            expect called == true

            called = false
            one_param(1)
            expect called == true

            called = false
            two_params(1, 2)
            expect called == true

        it "matches empty parameters with ()":
            var called = false

            fn marker():
                called = true

            fn empty_params() -> i64:
                42

            fn has_params(x: i64) -> i64:
                x

            on pc{ execution(* empty_params()) } use marker before priority 10

            empty_params()
            expect called == true


# ============================================================================
# Test Group 2: Within Selector
# ============================================================================

describe "Within Pointcut Selector":
    """
    ## within(pattern) Selector

    Matches join points within a specified module, class, or package scope.
    Uses glob patterns with * and ** for flexible matching.
    """

    context "module scope":
        it "matches functions within module":
            var called = false

            fn marker():
                called = true

            module services:
                fn process() -> i64:
                    42

            on pc{ within(services) & execution(* *(..)) } use marker before priority 10

            services.process()
            expect called == true

        it "matches with single wildcard segment":
            var count = 0

            fn counter():
                count = count + 1

            module api:
                module v1:
                    fn handler() -> i64:
                        1

            module api:
                module v2:
                    fn handler() -> i64:
                        2

            on pc{ within(api.*) & execution(* handler(..)) } use counter before priority 10

            api.v1.handler()
            api.v2.handler()
            expect count == 2

        it "matches with double wildcard segments":
            var count = 0

            fn counter():
                count = count + 1

            module deep:
                module nested:
                    module path:
                        fn target() -> i64:
                            42

            on pc{ within(deep.**) & execution(* target(..)) } use counter before priority 10

            deep.nested.path.target()
            expect count == 1


# ============================================================================
# Test Group 3: Attribute Selector
# ============================================================================

describe "Attribute Pointcut Selector":
    """
    ## attr(name) Selector

    Matches join points on elements decorated with the specified attribute.
    """

    context "function attributes":
        it "matches function with attribute":
            var logged = false

            fn logger():
                logged = true

            @traced
            fn traced_operation() -> i64:
                42

            fn untraced_operation() -> i64:
                0

            on pc{ attr(traced) } use logger before priority 10

            traced_operation()
            expect logged == true

            logged = false
            untraced_operation()
            expect logged == false

        it "matches multiple attributes":
            var count = 0

            fn counter():
                count = count + 1

            @critical
            @logged
            fn important() -> i64:
                42

            @logged
            fn regular() -> i64:
                0

            on pc{ attr(critical) & attr(logged) } use counter before priority 10

            important()
            expect count == 1

            regular()
            expect count == 1  # Still 1, regular doesn't have @critical


# ============================================================================
# Test Group 4: Type Selector (DI Context)
# ============================================================================

describe "Type Pointcut Selector":
    """
    ## type(pattern) Selector

    Matches types for dependency injection binding selection.
    Only valid in DI context, not for weaving.
    """

    context "exact type matching":
        it "matches specific type for binding":
            trait Repository:
                fn get(id: i64) -> Option<text>

            class SqlRepository impl Repository:
                fn get(id: i64) -> Option<text>:
                    Some("sql:{id}")

            # DI binding using type selector
            # bind on pc{ type(Repository) } -> SqlRepository scope Singleton priority 10

            # Type selector is validated at compile time
            expect true == true

    context "type pattern with wildcard":
        it "matches type pattern":
            # Type patterns can use wildcards
            # bind on pc{ type(*Repository) } -> DefaultImpl scope Singleton

            expect true == true


# ============================================================================
# Test Group 5: Init Selector (Runtime)
# ============================================================================

describe "Init Pointcut Selector":
    """
    ## init(pattern) Selector

    Matches constructor/initialization join points for runtime interception
    via DI proxies. Only available with runtime weaving.
    """

    context "constructor interception":
        it "matches class initialization":
            class Target:
                value: i64

                fn new() -> Target:
                    Target(value: 42)

            var intercepted = false

            fn init_interceptor(proceed):
                intercepted = true
                proceed()

            on pc{ init(Target) } use init_interceptor around priority 10

            val t = Target()
            expect intercepted == true
            expect t.value == 42


# ============================================================================
# Test Group 6: Logical Operators
# ============================================================================

describe "Pointcut Logical Operators":
    """
    ## Combining Pointcuts

    Pointcuts can be combined using logical operators with precedence:
    ! (NOT) > & (AND) > | (OR)
    """

    context "AND operator":
        it "requires both conditions":
            var called = false

            fn marker():
                called = true

            @important
            fn important_calc() -> i64:
                42

            fn regular_calc() -> i64:
                0

            @important
            fn important_other() -> i64:
                1

            on pc{ execution(* *_calc(..)) & attr(important) } use marker before priority 10

            important_calc()
            expect called == true

            called = false
            regular_calc()
            expect called == false  # Missing @important

            called = false
            important_other()
            expect called == false  # Not *_calc

    context "OR operator":
        it "matches either condition":
            var count = 0

            fn counter():
                count = count + 1

            fn option_a() -> i64:
                1

            fn option_b() -> i64:
                2

            fn option_c() -> i64:
                3

            on pc{ execution(* option_a(..)) | execution(* option_b(..)) } use counter before priority 10

            option_a()
            option_b()
            option_c()
            expect count == 2

    context "NOT operator":
        it "excludes matching pointcuts":
            var count = 0

            fn counter():
                count = count + 1

            fn included() -> i64:
                1

            fn excluded() -> i64:
                2

            on pc{ execution(* *(..)) & !execution(* excluded(..)) } use counter before priority 10

            included()
            excluded()
            expect count == 1

    context "precedence":
        it "applies NOT before AND before OR":
            var count = 0

            fn counter():
                count = count + 1

            @flagA
            fn func_a() -> i64:
                1

            @flagB
            fn func_b() -> i64:
                2

            fn func_c() -> i64:
                3

            # !attr(flagA) & attr(flagB) | execution(* func_c(..))
            # = ((!attr(flagA)) & attr(flagB)) | execution(* func_c(..))
            on pc{ !attr(flagA) & attr(flagB) | execution(* func_c(..)) } use counter before priority 10

            func_a()  # Has flagA, fails !attr(flagA)
            func_b()  # Has flagB, passes !attr(flagA) & attr(flagB)
            func_c()  # Matches execution(* func_c(..))
            expect count == 2

    context "grouping with parentheses":
        it "overrides precedence with parens":
            var count = 0

            fn counter():
                count = count + 1

            @flag
            fn flagged() -> i64:
                1

            fn unflagged() -> i64:
                2

            # !(attr(flag) | execution(* unflagged(..)))
            # Matches nothing in this case - both are excluded
            on pc{ !(attr(flag) | execution(* unflagged(..))) } use counter before priority 10

            flagged()
            unflagged()
            expect count == 0


# ============================================================================
# Test Group 7: Wildcard Patterns
# ============================================================================

describe "Wildcard Patterns in Pointcuts":
    """
    ## Path and Name Wildcards

    Wildcards allow flexible matching in pointcut expressions:
    - `*` matches one segment/character sequence
    - `**` matches zero or more segments
    """

    context "single segment wildcard":
        it "matches one segment with *":
            var count = 0

            fn counter():
                count = count + 1

            module api:
                module users:
                    fn list() -> i64:
                        1

            module api:
                module orders:
                    fn list() -> i64:
                        2

            module internal:
                module data:
                    fn list() -> i64:
                        3

            on pc{ within(api.*) & execution(* list(..)) } use counter before priority 10

            api.users.list()
            api.orders.list()
            internal.data.list()
            expect count == 2

    context "multi-segment wildcard":
        it "matches zero or more segments with **":
            var count = 0

            fn counter():
                count = count + 1

            module root:
                fn shallow() -> i64:
                    1

            module root:
                module mid:
                    fn medium() -> i64:
                        2

            module root:
                module mid:
                    module deep:
                        fn nested() -> i64:
                            3

            on pc{ within(root.**) } use counter before priority 10

            root.shallow()
            root.mid.medium()
            root.mid.deep.nested()
            expect count == 3

    context "prefix and suffix wildcards":
        it "matches prefix with name*":
            var count = 0

            fn counter():
                count = count + 1

            fn get_user() -> i64:
                1

            fn get_order() -> i64:
                2

            fn set_user() -> i64:
                3

            on pc{ execution(* get*(..)) } use counter before priority 10

            get_user()
            get_order()
            set_user()
            expect count == 2

        it "matches suffix with *name":
            var count = 0

            fn counter():
                count = count + 1

            fn user_service() -> i64:
                1

            fn order_service() -> i64:
                2

            fn user_controller() -> i64:
                3

            on pc{ execution(* *_service(..)) } use counter before priority 10

            user_service()
            order_service()
            user_controller()
            expect count == 2
