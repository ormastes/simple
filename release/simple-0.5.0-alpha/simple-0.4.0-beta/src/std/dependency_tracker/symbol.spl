# Symbol Table
#
# Cross-module symbol resolution and tracking.
# Port of rust/dependency_tracker/src/symbol.rs

export SymbolKind, SymbolEntry, SymbolTable, SymbolConflictError, ProjectSymbols

# The kind of a symbol entry
enum SymbolKind:
    Function    # Function definition
    Type        # Type definition (struct, class, enum)
    Constant    # Constant value
    Variable    # Variable
    Macro       # Macro definition
    Module      # Module

impl SymbolKind:
    fn is_macro() -> bool:
        match self:
            case SymbolKind.Macro: true
            case _: false

# A symbol entry in the symbol table
struct SymbolEntry:
    name: text
    qualified_name: text
    kind: SymbolKind
    visibility: text          # "public" or "private"
    source_module: text
    source_file: text?
    is_imported: bool
    original_name: text?

impl SymbolEntry:
    # Create a locally-defined symbol
    static fn local(name: text, qualified_name: text, kind: SymbolKind,
                    visibility: text, source_module: text) -> SymbolEntry:
        SymbolEntry(name: name, qualified_name: qualified_name, kind: kind,
                    visibility: visibility, source_module: source_module,
                    source_file: None, is_imported: false, original_name: None)

    # Create an imported symbol
    static fn imported(name: text, qualified_name: text, kind: SymbolKind,
                       visibility: text, source_module: text) -> SymbolEntry:
        SymbolEntry(name: name, qualified_name: qualified_name, kind: kind,
                    visibility: visibility, source_module: source_module,
                    source_file: None, is_imported: true, original_name: None)

    # Create an aliased import (e.g., `use foo.Bar as Baz`)
    static fn aliased(alias: text, original: text, qualified_name: text,
                      kind: SymbolKind, visibility: text,
                      source_module: text) -> SymbolEntry:
        SymbolEntry(name: alias, qualified_name: qualified_name, kind: kind,
                    visibility: visibility, source_module: source_module,
                    source_file: None, is_imported: true,
                    original_name: Some(original))

    fn is_public() -> bool:
        self.visibility == "public"

    fn with_source_file(path: text) -> SymbolEntry:
        SymbolEntry(name: self.name, qualified_name: self.qualified_name,
                    kind: self.kind, visibility: self.visibility,
                    source_module: self.source_module, source_file: Some(path),
                    is_imported: self.is_imported, original_name: self.original_name)

# Error when a symbol is already defined
struct SymbolConflictError:
    name: text
    existing_qualified: text
    new_qualified: text

impl SymbolConflictError:
    fn message() -> text:
        "Symbol '{self.name}' already defined as '{self.existing_qualified}', cannot redefine as '{self.new_qualified}'"

# A symbol table for a single module
class SymbolTable:
    module_path: text
    symbols: Dict<text, SymbolEntry>

impl SymbolTable:
    static fn for_module(module_path: text) -> SymbolTable:
        SymbolTable(module_path: module_path, symbols: {})

    # Define a new symbol (errors on conflict)
    me define(entry: SymbolEntry) -> Result<(), SymbolConflictError>:
        if self.symbols.has(entry.name):
            val existing = self.symbols[entry.name]
            return Err(SymbolConflictError(
                name: entry.name,
                existing_qualified: existing.qualified_name,
                new_qualified: entry.qualified_name))
        self.symbols[entry.name] = entry
        Ok(())

    # Define or replace a symbol (for re-exports)
    me define_or_replace(entry: SymbolEntry):
        self.symbols[entry.name] = entry

    fn lookup(name: text) -> SymbolEntry?:
        if self.symbols.has(name):
            Some(self.symbols[name])
        else:
            None

    fn all_symbols() -> [SymbolEntry]:
        self.symbols.values()

    fn public_symbols() -> [SymbolEntry]:
        self.symbols.values().filter(\s: s.is_public())

    fn local_symbols() -> [SymbolEntry]:
        self.symbols.values().filter(\s: not s.is_imported)

    fn macros() -> [SymbolEntry]:
        self.symbols.values().filter(\s: s.kind.is_macro())

    fn public_non_macros() -> [SymbolEntry]:
        self.symbols.values().filter(\s: s.is_public() and not s.kind.is_macro())

    fn public_macros() -> [SymbolEntry]:
        self.symbols.values().filter(\s: s.is_public() and s.kind.is_macro())

    fn contains(name: text) -> bool:
        self.symbols.has(name)

    fn len() -> i64:
        self.symbols.len()

    me remove(name: text) -> SymbolEntry?:
        if self.symbols.has(name):
            val entry = self.symbols[name]
            self.symbols.remove(name)
            Some(entry)
        else:
            None

# A collection of symbol tables for all modules in a project
class ProjectSymbols:
    tables: Dict<text, SymbolTable>

impl ProjectSymbols:
    static fn empty() -> ProjectSymbols:
        ProjectSymbols(tables: {})

    # Get or create a symbol table for a module
    me get_or_create(module_path: text) -> SymbolTable:
        if not self.tables.has(module_path):
            self.tables[module_path] = SymbolTable.for_module(module_path)
        self.tables[module_path]

    fn get(module_path: text) -> SymbolTable?:
        if self.tables.has(module_path):
            Some(self.tables[module_path])
        else:
            None

    # Look up a fully qualified symbol (e.g., "crate.sys.http.Router")
    fn lookup_qualified(qualified_name: text) -> SymbolEntry?:
        val dot_pos = qualified_name.rfind(".")
        if not dot_pos.?:
            return None
        val module_path = qualified_name[:dot_pos.unwrap()]
        val symbol_name = qualified_name[dot_pos.unwrap() + 1:]
        if self.tables.has(module_path):
            self.tables[module_path].lookup(symbol_name)
        else:
            None

    fn module_paths() -> [text]:
        self.tables.keys()
