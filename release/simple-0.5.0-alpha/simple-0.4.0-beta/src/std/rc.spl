# Reference Counting - Rc<T> and Arc<T>
#
# Smart pointers with automatic reference counting for shared ownership.
# Provides deterministic deallocation (unlike GC) with reference tracking.
#
# Types:
# - Rc<T>: Single-threaded reference counting (fast)
# - Arc<T>: Atomic reference counting (thread-safe)
# - Weak<T>: Weak references (don't prevent deallocation)
#
# Usage:
#   val rc = Rc.new(obj)
#   val clone = rc.clone()  // Increment refcount
#   // When all Rc dropped, object deallocated
#
# Arc for thread-safe sharing:
#   val arc = Arc.new(obj)
#   // Safe to share across threads

# use std.atomic.*  # Not needed for basic RC/ARC
# use std.allocator.*  # Not needed - we declare extern fns directly

# ============================================================================
# FFI Functions (Rc/Arc Box Management)
# ============================================================================
# These functions are implemented in Rust (rust/compiler/src/interpreter_extern/rc.rs)
# and registered in the interpreter (rust/compiler/src/interpreter_extern/mod.rs:494-515).
# Declarations commented out to allow runtime resolution (like allocator.spl pattern).

# Rc box operations (non-atomic)
# extern fn rc_box_size() -> usize
# extern fn rc_box_init(ptr: i64, value: i64, strong: usize, weak: usize)
# extern fn rc_box_get_value(ptr: i64) -> i64
# extern fn rc_box_drop_value(ptr: i64)
# extern fn rc_box_strong_count(ptr: i64) -> usize
# extern fn rc_box_weak_count(ptr: i64) -> usize
# extern fn rc_box_inc_strong(ptr: i64)
# extern fn rc_box_dec_strong(ptr: i64) -> usize
# extern fn rc_box_inc_weak(ptr: i64)
# extern fn rc_box_dec_weak(ptr: i64) -> usize

# Arc box operations (atomic)
# extern fn arc_box_size() -> usize
# extern fn arc_box_init(ptr: i64, value: i64, strong: usize, weak: usize)
# extern fn arc_box_get_value(ptr: i64) -> i64
# extern fn arc_box_drop_value(ptr: i64)
# extern fn arc_box_strong_count(ptr: i64) -> usize
# extern fn arc_box_weak_count(ptr: i64) -> usize
# extern fn arc_box_inc_strong(ptr: i64)
# extern fn arc_box_dec_strong(ptr: i64) -> usize
# extern fn arc_box_inc_weak(ptr: i64)
# extern fn arc_box_dec_weak(ptr: i64) -> usize

# System allocator
# extern fn sys_malloc(size: usize, align: usize) -> i64
# extern fn sys_free(ptr: i64, size: usize, align: usize)

# ============================================================================
# Rc - Single-Threaded Reference Counting
# ============================================================================

class Rc:
    ptr: i64

    static fn new(value: i64) -> Rc:
        """Create new Rc with value.

        Args:
            value: Value to store (moved into Rc)

        Returns:
            Rc owning the value
        """
        val box_size = rc_box_size()
        val ptr = sys_malloc(box_size, 8)
        rc_box_init(ptr, value, 1, 0)
        Rc(ptr)

    fn clone() -> Rc:
        """Clone Rc, incrementing reference count.

        Returns:
            New Rc pointing to same data

        Refcount incremented by 1.
        """
        rc_box_inc_strong(self.ptr)
        Rc(self.ptr)

    fn borrow() -> i64:
        """Borrow value immutably.

        Returns:
            Reference to value

        Panics: If Rc is null
        """
        rc_box_get_value(self.ptr)

    fn strong_count() -> usize:
        """Get strong reference count.

        Returns:
            Number of strong references (Rc)
        """
        rc_box_strong_count(self.ptr)

    fn weak_count() -> usize:
        """Get weak reference count.

        Returns:
            Number of weak references (Weak)
        """
        rc_box_weak_count(self.ptr)

    fn downgrade() -> Weak:
        """Create weak reference.

        Returns:
            Weak reference to same data

        Weak references don't prevent deallocation.
        """
        rc_box_inc_weak(self.ptr)
        Weak(self.ptr, false)

    me drop():
        """Drop Rc, decrementing reference count.

        If last reference, deallocates data.
        """
        val count = rc_box_dec_strong(self.ptr)

        if count == 0:
            # Last strong reference - deallocate data
            rc_box_drop_value(self.ptr)

            # Check weak count
            val weak = rc_box_weak_count(self.ptr)
            if weak == 0:
                # No weak references - free box
                val box_size = rc_box_size()
                sys_free(self.ptr, box_size, 8)

# ============================================================================
# Arc - Atomic Reference Counting
# ============================================================================

class Arc:
    ptr: i64

    static fn new(value: i64) -> Arc:
        """Create new Arc with value.

        Args:
            value: Value to store (moved into Arc)

        Returns:
            Arc owning the value
        """
        val box_size = arc_box_size()
        val ptr = sys_malloc(box_size, 8)
        arc_box_init(ptr, value, 1, 0)
        Arc(ptr)

    fn clone() -> Arc:
        """Clone Arc, atomically incrementing reference count.

        Returns:
            New Arc pointing to same data

        Thread-safe operation.
        """
        arc_box_inc_strong(self.ptr)
        Arc(self.ptr)

    fn borrow() -> i64:
        """Borrow value immutably.

        Returns:
            Reference to value

        Panics: If Arc is null
        """
        arc_box_get_value(self.ptr)

    fn strong_count() -> usize:
        """Get strong reference count (atomic read).

        Returns:
            Number of strong references (Arc)
        """
        arc_box_strong_count(self.ptr)

    fn weak_count() -> usize:
        """Get weak reference count (atomic read).

        Returns:
            Number of weak references (Weak)
        """
        arc_box_weak_count(self.ptr)

    fn downgrade() -> Weak:
        """Create weak reference (thread-safe).

        Returns:
            Weak reference to same data
        """
        arc_box_inc_weak(self.ptr)
        Weak(self.ptr, true)

    me drop():
        """Drop Arc, atomically decrementing reference count.

        If last reference, deallocates data.
        Thread-safe operation.
        """
        val count = arc_box_dec_strong(self.ptr)

        if count == 0:
            # Last strong reference - deallocate data
            arc_box_drop_value(self.ptr)

            # Check weak count
            val weak = arc_box_weak_count(self.ptr)
            if weak == 0:
                # No weak references - free box
                val box_size = arc_box_size()
                sys_free(self.ptr, box_size, 8)

# ============================================================================
# Weak - Weak Reference
# ============================================================================

class Weak:
    ptr: i64
    is_atomic: bool  # True for Arc-based, false for Rc-based

    fn upgrade() -> i64?:
        """Try to upgrade to Rc.

        Returns:
            Some(Rc) if data still alive
            None if data was deallocated

        Thread-safe for Arc-based weak references.
        """
        val strong = if self.is_atomic:
            arc_box_strong_count(self.ptr)
        else:
            rc_box_strong_count(self.ptr)

        if strong == 0:
            # Data already deallocated
            return nil

        # Increment strong count and return new Rc
        if self.is_atomic:
            arc_box_inc_strong(self.ptr)
            # FIXME: Should return Some(Arc(self.ptr)) but can't construct Arc/Rc
            # from weak due to type system limitations
            Some(arc_box_get_value(self.ptr))
        else:
            rc_box_inc_strong(self.ptr)
            Some(rc_box_get_value(self.ptr))

    fn upgrade_arc() -> i64?:
        """Try to upgrade to Arc (atomic version).

        Returns:
            Some(Arc) if data still alive
            None if data was deallocated
        """
        upgrade()

    fn strong_count() -> usize:
        """Get strong reference count.

        Returns:
            Number of strong references
        """
        if self.is_atomic:
            arc_box_strong_count(self.ptr)
        else:
            rc_box_strong_count(self.ptr)

    fn weak_count() -> usize:
        """Get weak reference count.

        Returns:
            Number of weak references (including self)
        """
        if self.is_atomic:
            arc_box_weak_count(self.ptr)
        else:
            rc_box_weak_count(self.ptr)

    me drop():
        """Drop weak reference.

        If last weak reference and no strong references, frees box.
        """
        val count = if self.is_atomic:
            arc_box_dec_weak(self.ptr)
        else:
            rc_box_dec_weak(self.ptr)

        if count == 0:
            # Last weak reference
            val strong = if self.is_atomic:
                arc_box_strong_count(self.ptr)
            else:
                rc_box_strong_count(self.ptr)

            if strong == 0:
                # No strong references either - free box
                val box_size = if self.is_atomic:
                    arc_box_size()
                else:
                    rc_box_size()
                sys_free(self.ptr, box_size, 8)

# ============================================================================
# Utility Functions
# ============================================================================

fn make_rc(value: i64) -> Rc:
    """Convenience function to create Rc.

    Args:
        value: Value to wrap in Rc

    Returns:
        Rc owning value

    Example:
        val rc = make_rc(42)
    """
    Rc.new(value)

fn make_arc(value: i64) -> Arc:
    """Convenience function to create Arc.

    Args:
        value: Value to wrap in Arc

    Returns:
        Arc owning value

    Example:
        val arc = make_arc(42)
    """
    Arc.new(value)

# ============================================================================
# Exports
# ============================================================================

export Rc
export Arc
export Weak
export make_rc
export make_arc
