# Package FFI Bindings
# Exposes Rust FFI functions to Simple code

# Low-level FFI declarations (map to C functions)
extern fn rt_package_sha256(file_path: text) -> text
extern fn rt_package_create_tarball(source_dir: text, output_path: text) -> i32
extern fn rt_package_extract_tarball(tarball_path: text, dest_dir: text) -> i32
extern fn rt_package_file_size(file_path: text) -> i64
extern fn rt_package_copy_file(src_path: text, dst_path: text) -> i32
extern fn rt_package_mkdir_all(dir_path: text) -> i32
extern fn rt_package_remove_dir_all(dir_path: text) -> i32
extern fn rt_package_create_symlink(target: text, link_path: text) -> i32
extern fn rt_package_chmod(file_path: text, mode: i32) -> i32
extern fn rt_package_exists(path: text) -> i32
extern fn rt_package_is_dir(path: text) -> i32
extern fn rt_package_free_string(ptr: text) -> ()

# High-level wrapper functions

fn calculate_checksum(file_path: text) -> text:
    """Calculate SHA256 checksum of a file.

    Returns checksum in format: sha256:hexdigest
    """
    rt_package_sha256(file_path)

fn create_tarball(source_dir: text, output_path: text) -> bool:
    """Create a gzip-compressed tarball from a directory.

    Args:
        source_dir: Source directory to archive
        output_path: Output .tar.gz file path

    Returns:
        true if successful, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_create_tarball) from app.io or compiler.ffi
    rt_package_create_tarball(source_dir, output_path) == 0

fn extract_tarball(tarball_path: text, dest_dir: text) -> bool:
    """Extract a gzip-compressed tarball to a directory.

    Args:
        tarball_path: Path to .tar.gz file
        dest_dir: Destination directory

    Returns:
        true if successful, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_extract_tarball) from app.io or compiler.ffi
    rt_package_extract_tarball(tarball_path, dest_dir) == 0

fn get_file_size(file_path: text) -> i64:
    """Get file size in bytes.

    Returns:
        File size in bytes, or -1 on error
    """
    # TODO: Replace direct FFI call with wrapper (package_file_size) from app.io or compiler.ffi
    rt_package_file_size(file_path)

fn copy_file(src_path: text, dst_path: text) -> bool:
    """Copy a file from source to destination.

    Args:
        src_path: Source file path
        dst_path: Destination file path

    Returns:
        true if successful, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_copy_file) from app.io or compiler.ffi
    rt_package_copy_file(src_path, dst_path) == 0

fn mkdir_all(dir_path: text) -> bool:
    """Create directory and all parent directories.

    Args:
        dir_path: Directory path to create

    Returns:
        true if successful, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_mkdir_all) from app.io or compiler.ffi
    rt_package_mkdir_all(dir_path) == 0

fn remove_dir_all(dir_path: text) -> bool:
    """Remove directory and all contents recursively.

    Args:
        dir_path: Directory path to remove

    Returns:
        true if successful, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_remove_dir_all) from app.io or compiler.ffi
    rt_package_remove_dir_all(dir_path) == 0

fn create_symlink(target: text, link_path: text) -> bool:
    """Create a symbolic link.

    Args:
        target: Target path
        link_path: Symbolic link path

    Returns:
        true if successful, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_create_symlink) from app.io or compiler.ffi
    rt_package_create_symlink(target, link_path) == 0

fn set_permissions(file_path: text, mode: i32) -> bool:
    """Set file permissions (Unix only).

    Args:
        file_path: File path
        mode: Permission mode (e.g., 0o755)

    Returns:
        true if successful, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_chmod) from app.io or compiler.ffi
    rt_package_chmod(file_path, mode) == 0

fn path_exists(path: text) -> bool:
    """Check if a path exists.

    Args:
        path: File or directory path

    Returns:
        true if path exists, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_exists) from app.io or compiler.ffi
    rt_package_exists(path) == 1

fn is_directory(path: text) -> bool:
    """Check if a path is a directory.

    Args:
        path: Path to check

    Returns:
        true if path is a directory, false otherwise
    """
    # TODO: Replace direct FFI call with wrapper (package_is_dir) from app.io or compiler.ffi
    rt_package_is_dir(path) == 1
