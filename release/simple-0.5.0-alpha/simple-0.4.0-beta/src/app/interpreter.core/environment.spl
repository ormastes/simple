# Environment - Variable Bindings
#
# Manages variable scopes and bindings using interned symbols.
#
# Performance optimization: Uses SymbolId (i64) instead of String keys.
# - Comparison: O(1) integer compare vs O(n) string compare
# - Hashing: Direct use of id vs computing string hash
# - Memory: One interned string vs many duplicate strings

from value import {Value}
from symbol import {SymbolId, intern, resolve, get_or_none}
# TODO: Re-enable when collections module is complete
# from ..collections.persistent_dict import {Dict}

export Environment, Scope, Binding, EnvironmentWithInterner

# ============================================================================
# Binding - A single variable binding
# ============================================================================

struct Binding:
    """A variable binding in a scope."""
    name: SymbolId      # Interned name (was: String)
    value: Value
    mutable: bool

impl Binding:
    fn name_str() -> text:
        """Get the string representation of the binding name."""
        resolve(self.name) ?? "<unknown>"

# ============================================================================
# Scope - A lexical scope (block)
# ============================================================================

struct Scope:
    """A single scope (lexical block).

    Uses Dict for bindings, enabling O(1) scope snapshots
    via structural sharing. Push/pop scope only copies the modified path
    (~7 nodes) rather than the entire bindings map.
    """
    bindings: Dict<i64, Binding>  # SymbolId.id -> Binding (HAMT, structural sharing)
    parent: Option<&Scope>

impl Scope:
    static fn new() -> Scope:
        """Create a new empty scope."""
        Scope(
            bindings: Dict.new(),
            parent: None
        )

    static fn with_parent(parent: &Scope) -> Scope:
        """Create a new scope with a parent."""
        Scope(
            bindings: Dict.new(),
            parent: Some(parent)
        )

    fn define(name: SymbolId, value: Value, mutable: bool) -> Scope:
        """Define a variable in this scope. Returns new scope (persistent)."""
        val new_bindings = self.bindings.set(name.id, Binding(
            name: name,
            value: value,
            mutable: mutable
        ))
        Scope(
            bindings: new_bindings,
            parent: self.parent
        )

    fn define_str(name: text, value: Value, mutable: bool) -> Scope:
        """Define a variable by string name (auto-interns)."""
        val sym = intern(name)
        self.define(sym, value, mutable)

    fn get(name: SymbolId) -> Binding?:
        """Look up a binding by SymbolId."""
        val found = self.bindings.get(name.id)
        if found.?:
            return found
        if self.parent.?:
            return self.parent.unwrap().get(name)
        None

    fn get_str(name: text) -> Binding?:
        """Look up a binding by string name.

        First checks if the string is interned. If not, the binding
        cannot exist (all bindings use interned symbols).
        """
        val sym = get_or_none(name)
        if sym.?:
            self.get(sym.unwrap())
        else:
            None

    fn set(name: SymbolId, value: Value) -> Result<Scope, text>:
        """Set a variable's value. Returns new scope (persistent)."""
        val found = self.bindings.get(name.id)
        if found.?:
            val current_binding = found.unwrap()
            if not current_binding.mutable:
                val name_str = resolve(name) ?? "<unknown>"
                return Err("Cannot assign to immutable variable: {name_str}")
            val new_bindings = self.bindings.set(name.id, Binding(
                name: current_binding.name,
                value: value,
                mutable: current_binding.mutable
            ))
            return Ok(Scope(
                bindings: new_bindings,
                parent: self.parent
            ))
        if self.parent.?:
            return self.parent.unwrap().set(name, value)
        val name_str = resolve(name) ?? "<unknown>"
        Err("Undefined variable: {name_str}")

    fn set_str(name: text, value: Value) -> Result<Scope, text>:
        """Set a variable's value by string name."""
        val sym = get_or_none(name)
        if sym.?:
            self.set(sym.unwrap(), value)
        else:
            Err("Undefined variable: {name}")

# ============================================================================
# Environment - Stack of scopes
# ============================================================================

struct Environment:
    """The environment (stack of scopes)."""
    scopes: [Scope]
    globals: Scope

impl Environment:
    static fn new() -> Environment:
        """Create a new environment with an empty scope."""
        Environment(
            scopes: [Scope.new()],
            globals: Scope.new()
        )

    # ------------------------------------------------------------------------
    # Scope management
    # ------------------------------------------------------------------------

    me push_scope():
        """Enter a new scope.

        With Dict, the parent scope's bindings are shared
        (not copied). Only new/modified bindings allocate new nodes.
        """
        val parent = self.current_scope()
        self.scopes = self.scopes.push(Scope.with_parent(parent))

    me pop_scope():
        """Exit current scope.

        The popped scope's bindings are reclaimed if no other references.
        Shared nodes with parent scope persist (structural sharing).
        """
        if self.scopes.len() > 1:
            self.scopes = self.scopes[0:self.scopes.len() - 1]

    fn current_scope() -> &Scope:
        """Get current scope."""
        &self.scopes[self.scopes.len() - 1]

    # ------------------------------------------------------------------------
    # Variable operations (SymbolId)
    # ------------------------------------------------------------------------

    me define(name: SymbolId, value: Value):
        """Define a mutable variable in current scope."""
        val idx = self.scopes.len() - 1
        self.scopes[idx] = self.scopes[idx].define(name, value, true)

    me define_const(name: SymbolId, value: Value):
        """Define an immutable variable in current scope."""
        val idx = self.scopes.len() - 1
        self.scopes[idx] = self.scopes[idx].define(name, value, false)

    fn get(name: SymbolId) -> Value?:
        """Get a variable's value by SymbolId."""
        if val Some(current_binding) = self.current_scope().get(name):
            return Some(current_binding.value.clone())
        if val Some(current_binding) = self.globals.get(name):
            return Some(current_binding.value.clone())
        None

    me set(name: SymbolId, value: Value) -> Result<(), text>:
        """Set a variable's value."""
        val idx = self.scopes.len() - 1
        match self.scopes[idx].set(name, value):
            case Ok(new_scope):
                self.scopes[idx] = new_scope
                Ok(())
            case Err(msg):
                Err(msg)

    me define_global(name: SymbolId, value: Value):
        """Define a global variable."""
        self.globals = self.globals.define(name, value, true)

    # ------------------------------------------------------------------------
    # Variable operations (String - convenience wrappers)
    # ------------------------------------------------------------------------

    me define_str(name: text, value: Value):
        """Define a mutable variable by string name (auto-interns)."""
        self.define(intern(name), value)

    me define_const_str(name: text, value: Value):
        """Define an immutable variable by string name (auto-interns)."""
        self.define_const(intern(name), value)

    fn get_str(name: text) -> Value?:
        """Get a variable's value by string name."""
        val sym = get_or_none(name)
        if sym.?:
            self.get(sym.unwrap())
        else:
            None

    me set_str(name: text, value: Value) -> Result<(), text>:
        """Set a variable's value by string name."""
        val sym = get_or_none(name)
        if sym.?:
            self.set(sym.unwrap(), value)
        else:
            Err("Undefined variable: {name}")

    me define_global_str(name: text, value: Value):
        """Define a global variable by string name (auto-interns)."""
        self.define_global(intern(name), value)

# ============================================================================
# EnvironmentWithInterner - Environment bundled with interner reference
# ============================================================================

struct EnvironmentWithInterner:
    """Environment with explicit interner reference.

    Useful when passing environment between modules or actors
    where the global interner might not be appropriate.
    """
    env: Environment
    interner: &SymbolInterner

impl EnvironmentWithInterner:
    static fn new() -> EnvironmentWithInterner:
        EnvironmentWithInterner(
            env: Environment.new(),
            interner: &GLOBAL_INTERNER
        )

    static fn with_interner(interner: &SymbolInterner) -> EnvironmentWithInterner:
        EnvironmentWithInterner(
            env: Environment.new(),
            interner: interner
        )

    fn intern(s: text) -> SymbolId:
        self.interner.intern(s)

    fn resolve(id: SymbolId) -> text?:
        self.interner.resolve(id)
