# Slicing and Indexing Utilities
#
# Python-style slicing, index normalization, and collection iteration.
#
# Port of rust/compiler/src/interpreter_helpers/utilities.rs (partial - slicing)

from ..core import {Value, InterpreterError}

export normalize_index, slice_collection, iter_to_vec

# ============================================================================
# Index Normalization
# ============================================================================

# Normalize a Python-style index (supports negative indices)
fn normalize_index(idx: i64, len: i64) -> i64:
    if idx < 0:
        (len + idx).max(0)
    else:
        idx.min(len)

# ============================================================================
# Collection Slicing
# ============================================================================

# Slice a collection with Python-style semantics
# Supports positive step (forward) and negative step (backward)
fn slice_collection(items: [Value], start: i64, end: i64, step: i64) -> [Value]:
    val len = items.len()

    if step > 0:
        # Forward iteration
        var result = []
        var i = start
        while i < end and i < len:
            if i >= 0:
                result = result.push(items[i])
            i = i + step
        result
    else:
        # Backward iteration (negative step)
        var result = []
        val actual_start = if start == 0: len - 1 else: start.min(len - 1)
        val actual_end = if end == len: -1 else: end
        var i = actual_start
        while i > actual_end and i >= 0:
            if i < len:
                result = result.push(items[i])
            i = i + step
        result

# Slice with default step of 1
fn slice_default(items: [Value], start: i64, end: i64) -> [Value]:
    slice_collection(items, start, end, 1)

# ============================================================================
# Collection Iteration
# ============================================================================

# Convert a value to an iterable vector (for comprehensions and for-loops)
fn iter_to_vec(val: Value) -> Result<[Value], InterpreterError>:
    match val.type_name():
        case "Array":
            Ok(val.as_array() ?? [])

        case "FrozenArray":
            Ok(val.as_frozen_array() ?? [])

        case "Tuple":
            Ok(val.as_tuple() ?? [])

        case "String":
            val s = val.as_string() ?? ""
            Ok(s.chars().map(\c: Value.string(c)))

        case "Dict":
            val entries = val.dict_entries()
            if entries.?:
                Ok(entries.unwrap().map(\(k, v): Value.tuple([Value.string(k), v])))
            else:
                Ok([])

        case "Range":
            val start = val.range_start() ?? 0
            val end = val.range_end() ?? 0
            val inclusive = val.range_inclusive() ?? false
            if inclusive:
                Ok([for i in start..=end: Value.int(i)])
            else:
                Ok([for i in start..end: Value.int(i)])

        case _:
            Err(InterpreterError.TypeError("cannot iterate over {val.type_name()}"))
