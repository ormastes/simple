# Runtime Value Module - Full Specification
#
# Complete specification for generating runtime_value.rs with:
# - RuntimeValue enum
# - ValueType enum
# - All FFI functions with full implementations
# - Unit tests
#
# Usage: simple ffi-gen --gen-module specs/runtime_value_full.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)

# ============================================================================
# Module Specification
# ============================================================================

fn runtime_value_module() -> ModuleSpec:
    var builder = ModuleBuilder.start("runtime_value")
        .doc("Runtime Value FFI\n\nFull implementation of RuntimeValue for Simple language.\nSupports: nil, bool, int, float, string, array, dict, object, function")

    # Imports
    builder = builder
        .add_import("std::collections::HashMap")
        .add_import("std::ffi::CString")
        .add_import("std::os::raw::c_char")
        .add_import("std::sync::Arc")

    # ValueType enum
    builder = builder.add_enum(value_type_enum())

    # RuntimeValue enum
    builder = builder.add_enum(runtime_value_enum())

    # Impl block for RuntimeValue
    builder = builder.add_impl(runtime_value_impl())

    # Constructor functions
    builder = builder
        .add_fn(fn_rt_value_nil())
        .add_fn(fn_rt_value_bool())
        .add_fn(fn_rt_value_int())
        .add_fn(fn_rt_value_float())
        .add_fn(fn_rt_value_string())
        .add_fn(fn_rt_value_array_new())
        .add_fn(fn_rt_value_dict_new())

    # Type checking functions
    builder = builder
        .add_fn(fn_rt_value_type())
        .add_fn(fn_rt_value_is_nil())
        .add_fn(fn_rt_value_is_bool())
        .add_fn(fn_rt_value_is_int())
        .add_fn(fn_rt_value_is_float())
        .add_fn(fn_rt_value_is_string())
        .add_fn(fn_rt_value_is_array())
        .add_fn(fn_rt_value_is_dict())

    # Conversion functions
    builder = builder
        .add_fn(fn_rt_value_as_bool())
        .add_fn(fn_rt_value_as_int())
        .add_fn(fn_rt_value_as_float())
        .add_fn(fn_rt_value_as_string())

    # Arithmetic functions
    builder = builder
        .add_fn(fn_rt_value_add())
        .add_fn(fn_rt_value_sub())
        .add_fn(fn_rt_value_mul())
        .add_fn(fn_rt_value_div())

    # Comparison functions
    builder = builder
        .add_fn(fn_rt_value_eq())
        .add_fn(fn_rt_value_lt())

    # Printing functions
    builder = builder
        .add_fn(fn_rt_value_print())
        .add_fn(fn_rt_value_println())

    # Memory management functions
    builder = builder
        .add_fn(fn_rt_value_free())
        .add_fn(fn_rt_value_clone())

    # Tests
    builder = builder
        .add_test(test_value_nil())
        .add_test(test_value_int())
        .add_test(test_value_string())
        .add_test(test_arithmetic())
        .add_test(test_comparison())

    builder.build()

# ============================================================================
# Type Definitions
# ============================================================================

fn value_type_enum() -> EnumSpec:
    var spec = EnumSpec(
        name: "ValueType",
        generics: [],
        repr_attr: "C",
        derives: ["Debug", "Clone", "Copy", "PartialEq", "Eq"],
        variants: [
            EnumVariantSpec.unit_with_value("Nil", "0"),
            EnumVariantSpec.unit_with_value("Bool", "1"),
            EnumVariantSpec.unit_with_value("Int", "2"),
            EnumVariantSpec.unit_with_value("Float", "3"),
            EnumVariantSpec.unit_with_value("String", "4"),
            EnumVariantSpec.unit_with_value("Array", "5"),
            EnumVariantSpec.unit_with_value("Dict", "6"),
            EnumVariantSpec.unit_with_value("Object", "7"),
            EnumVariantSpec.unit_with_value("Function", "8")
        ],
        visibility: "pub",
        doc: "Value type tags"
    )
    spec

fn runtime_value_enum() -> EnumSpec:
    var spec = EnumSpec(
        name: "RuntimeValue",
        generics: [],
        repr_attr: "C",
        derives: [],
        variants: [
            EnumVariantSpec.unit("Nil"),
            EnumVariantSpec.tuple("Bool", ["bool"]),
            EnumVariantSpec.tuple("Int", ["i64"]),
            EnumVariantSpec.tuple("Float", ["f64"]),
            EnumVariantSpec.tuple("String", ["Arc<String>"]),
            EnumVariantSpec.tuple("Array", ["Arc<Vec<Box<RuntimeValue>>>"]),
            EnumVariantSpec.tuple("Dict", ["Arc<HashMap<String, Box<RuntimeValue>>>"]),
            EnumVariantSpec.tuple("Object", ["Arc<dyn std::any::Any + Send + Sync>"]),
            EnumVariantSpec.tuple("Function", ["usize"])
        ],
        visibility: "pub",
        doc: "Runtime Value - tagged union for Simple values"
    )
    spec

fn runtime_value_impl() -> ImplSpec:
    val type_tag_method = MethodSpec.method(
        "type_tag", "&self", [], "ValueType",
        "match self {\n" +
        "    RuntimeValue::Nil => ValueType::Nil,\n" +
        "    RuntimeValue::Bool(_) => ValueType::Bool,\n" +
        "    RuntimeValue::Int(_) => ValueType::Int,\n" +
        "    RuntimeValue::Float(_) => ValueType::Float,\n" +
        "    RuntimeValue::String(_) => ValueType::String,\n" +
        "    RuntimeValue::Array(_) => ValueType::Array,\n" +
        "    RuntimeValue::Dict(_) => ValueType::Dict,\n" +
        "    RuntimeValue::Object(_) => ValueType::Object,\n" +
        "    RuntimeValue::Function(_) => ValueType::Function,\n" +
        "}"
    )
    ImplSpec.inherent("RuntimeValue", [type_tag_method])

# ============================================================================
# Constructor Functions
# ============================================================================

fn fn_rt_value_nil() -> FFIFnSpec:
    FFIFnSpec.extern_c("rt_value_nil", [], "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Nil))"
    )

fn fn_rt_value_bool() -> FFIFnSpec:
    FFIFnSpec.extern_c("rt_value_bool",
        [FFIParamSpec.simple("value", "bool")],
        "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Bool(value)))"
    )

fn fn_rt_value_int() -> FFIFnSpec:
    FFIFnSpec.extern_c("rt_value_int",
        [FFIParamSpec.simple("value", "i64")],
        "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Int(value)))"
    )

fn fn_rt_value_float() -> FFIFnSpec:
    FFIFnSpec.extern_c("rt_value_float",
        [FFIParamSpec.simple("value", "f64")],
        "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Float(value)))"
    )

fn fn_rt_value_string() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_string",
        [
            FFIParamSpec.simple("ptr", "*const c_char"),
            FFIParamSpec.simple("len", "usize")
        ],
        "*mut RuntimeValue",
        "if ptr.is_null() {\n" +
        "    return rt_value_nil();\n" +
        "}\n" +
        "\n" +
        "let bytes = std::slice::from_raw_parts(ptr as *const u8, len);\n" +
        "let s = String::from_utf8_lossy(bytes).into_owned();\n" +
        "Box::into_raw(Box::new(RuntimeValue::String(Arc::new(s))))"
    )

fn fn_rt_value_array_new() -> FFIFnSpec:
    FFIFnSpec.extern_c("rt_value_array_new", [], "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Array(Arc::new(Vec::new()))))"
    )

fn fn_rt_value_dict_new() -> FFIFnSpec:
    FFIFnSpec.extern_c("rt_value_dict_new", [], "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Dict(Arc::new(HashMap::new()))))"
    )

# ============================================================================
# Type Checking Functions
# ============================================================================

fn fn_rt_value_type() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_type",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "ValueType",
        "if value.is_null() {\n" +
        "    return ValueType::Nil;\n" +
        "}\n" +
        "(*value).type_tag()"
    )

fn fn_rt_value_is_nil() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_is_nil",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "value.is_null() || matches!(*value, RuntimeValue::Nil)"
    )

fn fn_rt_value_is_bool() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_is_bool",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Bool(_))"
    )

fn fn_rt_value_is_int() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_is_int",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Int(_))"
    )

fn fn_rt_value_is_float() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_is_float",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Float(_))"
    )

fn fn_rt_value_is_string() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_is_string",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::String(_))"
    )

fn fn_rt_value_is_array() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_is_array",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Array(_))"
    )

fn fn_rt_value_is_dict() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_is_dict",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Dict(_))"
    )

# ============================================================================
# Conversion Functions
# ============================================================================

fn fn_rt_value_as_bool() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_as_bool",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "bool",
        "if value.is_null() {\n" +
        "    return false;\n" +
        "}\n" +
        "match &*value {\n" +
        "    RuntimeValue::Bool(b) => *b,\n" +
        "    RuntimeValue::Nil => false,\n" +
        "    RuntimeValue::Int(i) => *i != 0,\n" +
        "    _ => true, // Everything else is truthy\n" +
        "}"
    )

fn fn_rt_value_as_int() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_as_int",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "i64",
        "if value.is_null() {\n" +
        "    return 0;\n" +
        "}\n" +
        "match &*value {\n" +
        "    RuntimeValue::Int(i) => *i,\n" +
        "    RuntimeValue::Float(f) => *f as i64,\n" +
        "    RuntimeValue::Bool(b) => if *b {{ 1 }} else {{ 0 }},\n" +
        "    _ => 0,\n" +
        "}"
    )

fn fn_rt_value_as_float() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_as_float",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "f64",
        "if value.is_null() {\n" +
        "    return 0.0;\n" +
        "}\n" +
        "match &*value {\n" +
        "    RuntimeValue::Float(f) => *f,\n" +
        "    RuntimeValue::Int(i) => *i as f64,\n" +
        "    _ => 0.0,\n" +
        "}"
    )

fn fn_rt_value_as_string() -> FFIFnSpec:
    var spec = FFIFnSpec.unsafe_extern_c("rt_value_as_string",
        [
            FFIParamSpec.simple("value", "*const RuntimeValue"),
            FFIParamSpec.simple("out_len", "*mut usize")
        ],
        "*const c_char",
        "if value.is_null() || out_len.is_null() {\n" +
        "    if !out_len.is_null() {\n" +
        "        *out_len = 0;\n" +
        "    }\n" +
        "    return std::ptr::null();\n" +
        "}\n" +
        "\n" +
        "match &*value {\n" +
        "    RuntimeValue::String(s) => {\n" +
        "        *out_len = s.len();\n" +
        "        s.as_ptr() as *const c_char\n" +
        "    }\n" +
        "    _ => {\n" +
        "        *out_len = 0;\n" +
        "        std::ptr::null()\n" +
        "    }\n" +
        "}"
    )
    spec.doc = "Get string from value (returns ptr and length)\nCaller must NOT free the returned pointer - it's owned by the value"
    spec

# ============================================================================
# Arithmetic Functions
# ============================================================================

fn fn_rt_value_add() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_add",
        [
            FFIParamSpec.simple("left", "*const RuntimeValue"),
            FFIParamSpec.simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {\n" +
        "    return rt_value_nil();\n" +
        "}\n" +
        "\n" +
        "match (&*left, &*right) {\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => rt_value_int(a + b),\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a + b),\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 + b),\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a + *b as f64),\n" +
        "    (RuntimeValue::String(a), RuntimeValue::String(b)) => {\n" +
        "        let result = format!(\"{}{}\", a, b);\n" +
        "        let c_str = CString::new(result).unwrap();\n" +
        "        rt_value_string(c_str.as_ptr(), c_str.as_bytes().len())\n" +
        "    }\n" +
        "    _ => rt_value_nil(),\n" +
        "}"
    )

fn fn_rt_value_sub() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_sub",
        [
            FFIParamSpec.simple("left", "*const RuntimeValue"),
            FFIParamSpec.simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {\n" +
        "    return rt_value_nil();\n" +
        "}\n" +
        "\n" +
        "match (&*left, &*right) {\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => rt_value_int(a - b),\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a - b),\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 - b),\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a - *b as f64),\n" +
        "    _ => rt_value_nil(),\n" +
        "}"
    )

fn fn_rt_value_mul() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_mul",
        [
            FFIParamSpec.simple("left", "*const RuntimeValue"),
            FFIParamSpec.simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {\n" +
        "    return rt_value_nil();\n" +
        "}\n" +
        "\n" +
        "match (&*left, &*right) {\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => rt_value_int(a * b),\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a * b),\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 * b),\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a * (*b as f64)),\n" +
        "    _ => rt_value_nil(),\n" +
        "}"
    )

fn fn_rt_value_div() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_div",
        [
            FFIParamSpec.simple("left", "*const RuntimeValue"),
            FFIParamSpec.simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {\n" +
        "    return rt_value_nil();\n" +
        "}\n" +
        "\n" +
        "match (&*left, &*right) {\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => {\n" +
        "        if *b == 0 {\n" +
        "            return rt_value_nil(); // Division by zero\n" +
        "        }\n" +
        "        rt_value_int(a / b)\n" +
        "    }\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a / b),\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 / b),\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a / (*b as f64)),\n" +
        "    _ => rt_value_nil(),\n" +
        "}"
    )

# ============================================================================
# Comparison Functions
# ============================================================================

fn fn_rt_value_eq() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_eq",
        [
            FFIParamSpec.simple("left", "*const RuntimeValue"),
            FFIParamSpec.simple("right", "*const RuntimeValue")
        ],
        "bool",
        "if left.is_null() && right.is_null() {\n" +
        "    return true;\n" +
        "}\n" +
        "if left.is_null() || right.is_null() {\n" +
        "    return false;\n" +
        "}\n" +
        "\n" +
        "match (&*left, &*right) {\n" +
        "    (RuntimeValue::Nil, RuntimeValue::Nil) => true,\n" +
        "    (RuntimeValue::Bool(a), RuntimeValue::Bool(b)) => a == b,\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => a == b,\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => a == b,\n" +
        "    (RuntimeValue::String(a), RuntimeValue::String(b)) => a == b,\n" +
        "    _ => false,\n" +
        "}"
    )

fn fn_rt_value_lt() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_lt",
        [
            FFIParamSpec.simple("left", "*const RuntimeValue"),
            FFIParamSpec.simple("right", "*const RuntimeValue")
        ],
        "bool",
        "if left.is_null() || right.is_null() {\n" +
        "    return false;\n" +
        "}\n" +
        "\n" +
        "match (&*left, &*right) {\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => a < b,\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => a < b,\n" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => (*a as f64) < *b,\n" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => *a < (*b as f64),\n" +
        "    (RuntimeValue::String(a), RuntimeValue::String(b)) => a < b,\n" +
        "    _ => false,\n" +
        "}"
    )

# ============================================================================
# Printing Functions
# ============================================================================

fn fn_rt_value_print() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_print",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "()",
        "if value.is_null() {\n" +
        "    print!(\"nil\");\n" +
        "    return;\n" +
        "}\n" +
        "\n" +
        "match &*value {\n" +
        "    RuntimeValue::Nil => print!(\"nil\"),\n" +
        "    RuntimeValue::Bool(b) => print!(\"{}\", b),\n" +
        "    RuntimeValue::Int(i) => print!(\"{}\", i),\n" +
        "    RuntimeValue::Float(f) => print!(\"{}\", f),\n" +
        "    RuntimeValue::String(s) => print!(\"{}\", s),\n" +
        "    RuntimeValue::Array(_) => print!(\"[Array]\"),\n" +
        "    RuntimeValue::Dict(_) => print!(\"{{{{Dict}}}}\"),\n" +
        "    RuntimeValue::Object(_) => print!(\"<Object>\"),\n" +
        "    RuntimeValue::Function(_) => print!(\"<Function>\"),\n" +
        "}"
    )

fn fn_rt_value_println() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_println",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "()",
        "rt_value_print(value);\nprintln!();"
    )

# ============================================================================
# Memory Management Functions
# ============================================================================

fn fn_rt_value_free() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_free",
        [FFIParamSpec.simple("value", "*mut RuntimeValue")],
        "()",
        "if !value.is_null() {\n" +
        "    drop(Box::from_raw(value));\n" +
        "}"
    )

fn fn_rt_value_clone() -> FFIFnSpec:
    FFIFnSpec.unsafe_extern_c("rt_value_clone",
        [FFIParamSpec.simple("value", "*const RuntimeValue")],
        "*mut RuntimeValue",
        "if value.is_null() {\n" +
        "    return rt_value_nil();\n" +
        "}\n" +
        "\n" +
        "let cloned = match &*value {\n" +
        "    RuntimeValue::Nil => RuntimeValue::Nil,\n" +
        "    RuntimeValue::Bool(b) => RuntimeValue::Bool(*b),\n" +
        "    RuntimeValue::Int(i) => RuntimeValue::Int(*i),\n" +
        "    RuntimeValue::Float(f) => RuntimeValue::Float(*f),\n" +
        "    RuntimeValue::String(s) => RuntimeValue::String(Arc::clone(s)),\n" +
        "    RuntimeValue::Array(a) => RuntimeValue::Array(Arc::clone(a)),\n" +
        "    RuntimeValue::Dict(d) => RuntimeValue::Dict(Arc::clone(d)),\n" +
        "    RuntimeValue::Object(o) => RuntimeValue::Object(Arc::clone(o)),\n" +
        "    RuntimeValue::Function(f) => RuntimeValue::Function(*f),\n" +
        "};\n" +
        "\n" +
        "Box::into_raw(Box::new(cloned))"
    )

# ============================================================================
# Test Specifications
# ============================================================================

fn test_value_nil() -> TestSpec:
    TestSpec.test("test_value_nil",
        "unsafe {\n" +
        "    let val = rt_value_nil();\n" +
        "    assert!(!val.is_null());\n" +
        "    assert!(rt_value_is_nil(val));\n" +
        "    assert_eq!(rt_value_type(val), ValueType::Nil);\n" +
        "    rt_value_free(val);\n" +
        "}"
    )

fn test_value_int() -> TestSpec:
    TestSpec.test("test_value_int",
        "unsafe {\n" +
        "    let val = rt_value_int(42);\n" +
        "    assert!(!val.is_null());\n" +
        "    assert!(rt_value_is_int(val));\n" +
        "    assert_eq!(rt_value_as_int(val), 42);\n" +
        "    rt_value_free(val);\n" +
        "}"
    )

fn test_value_string() -> TestSpec:
    TestSpec.test("test_value_string",
        "unsafe {\n" +
        "    let s = CString::new(\"hello\").unwrap();\n" +
        "    let val = rt_value_string(s.as_ptr(), s.as_bytes().len());\n" +
        "    assert!(!val.is_null());\n" +
        "    assert!(rt_value_is_string(val));\n" +
        "\n" +
        "    let mut len = 0;\n" +
        "    let ptr = rt_value_as_string(val, &mut len);\n" +
        "    assert!(!ptr.is_null());\n" +
        "    assert_eq!(len, 5);\n" +
        "\n" +
        "    rt_value_free(val);\n" +
        "}"
    )

fn test_arithmetic() -> TestSpec:
    TestSpec.test("test_arithmetic",
        "unsafe {\n" +
        "    let a = rt_value_int(10);\n" +
        "    let b = rt_value_int(5);\n" +
        "\n" +
        "    let sum = rt_value_add(a, b);\n" +
        "    assert_eq!(rt_value_as_int(sum), 15);\n" +
        "\n" +
        "    let diff = rt_value_sub(a, b);\n" +
        "    assert_eq!(rt_value_as_int(diff), 5);\n" +
        "\n" +
        "    let prod = rt_value_mul(a, b);\n" +
        "    assert_eq!(rt_value_as_int(prod), 50);\n" +
        "\n" +
        "    let quot = rt_value_div(a, b);\n" +
        "    assert_eq!(rt_value_as_int(quot), 2);\n" +
        "\n" +
        "    rt_value_free(a);\n" +
        "    rt_value_free(b);\n" +
        "    rt_value_free(sum);\n" +
        "    rt_value_free(diff);\n" +
        "    rt_value_free(prod);\n" +
        "    rt_value_free(quot);\n" +
        "}"
    )

fn test_comparison() -> TestSpec:
    TestSpec.test("test_comparison",
        "unsafe {\n" +
        "    let a = rt_value_int(10);\n" +
        "    let b = rt_value_int(5);\n" +
        "    let c = rt_value_int(10);\n" +
        "\n" +
        "    assert!(!rt_value_eq(a, b));\n" +
        "    assert!(rt_value_eq(a, c));\n" +
        "    assert!(rt_value_lt(b, a));\n" +
        "    assert!(!rt_value_lt(a, b));\n" +
        "\n" +
        "    rt_value_free(a);\n" +
        "    rt_value_free(b);\n" +
        "    rt_value_free(c);\n" +
        "}"
    )
