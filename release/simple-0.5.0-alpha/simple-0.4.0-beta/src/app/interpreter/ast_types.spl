# AST Type Definitions
#
# Core types for interpreter AST (expressions, statements, patterns).
# Extracted from ast_convert.spl for better modularity.

import parser.treesitter.tree.{Tree, Node, NodeId, NodeArena}

# =============================================================================
# AST Types
# =============================================================================

# Module represents a complete source file
struct Module:
    statements: Array<Statement>
    imports: Array<Import>

struct Import:
    path: String
    names: Array<String>
    alias: Option<String>

# Statement types
enum Statement:
    Let(LetBinding)
    Return(Option<Expr>)
    If { cond: Expr, then_block: Block, else_block: Option<Block> }
    Match { value: Expr, cases: Array<MatchCase> }
    For { pattern: Pattern, iterable: Expr, body: Block }
    While { cond: Expr, body: Block }
    Loop(Block)
    Break
    Continue
    Expression(Expr)
    FunctionDef { name: String, params: Array<Param>, return_type: Option<String>, body: Block }
    StructDef { name: String, fields: Array<StructField> }
    EnumDef { name: String, variants: Array<EnumVariant> }
    ImplDef { type_name: String, trait_name: Option<String>, methods: Array<Statement> }
    Export { names: Array<String> }
    Pass

struct LetBinding:
    name: String
    type_annotation: Option<String>
    value: Expr
    mutable: bool

struct Block:
    statements: Array<Statement>

struct MatchCase:
    pattern: Pattern
    guard: Option<Expr>
    body: Block

struct Param:
    name: String
    type_annotation: Option<String>
    default_value: Option<Expr>

struct StructField:
    name: String
    type_annotation: String
    default_value: Option<Expr>

struct EnumVariant:
    name: String
    fields: Option<Array<StructField>>

# Pattern types for match expressions
enum Pattern:
    Wildcard
    Identifier(String)
    Literal(Literal)
    Tuple(Array<Pattern>)
    Struct { name: String, fields: Array<(String, Pattern)> }
    Enum { variant: String, data: Option<Box<Pattern>> }

# Expression types
enum Expr:
    Literal(Literal)
    Identifier(String)
    Binary { op: BinaryOp, left: Box<Expr>, right: Box<Expr> }
    Unary { op: UnaryOp, operand: Box<Expr> }
    Call { callee: Box<Expr>, args: Array<Expr> }
    MethodCall { object: Box<Expr>, method: String, args: Array<Expr> }
    Index { collection: Box<Expr>, index: Box<Expr> }
    Field { object: Box<Expr>, field: String }
    Array(Array<Expr>)
    Dict(Array<(Expr, Expr)>)
    Tuple(Array<Expr>)
    Lambda { params: Array<String>, body: Box<Expr> }
    If { cond: Box<Expr>, then_expr: Box<Expr>, else_expr: Box<Expr> }
    Match { value: Box<Expr>, cases: Array<(Pattern, Expr)> }
    Range { start: Box<Expr>, end: Box<Expr>, inclusive: bool }
    Await(Box<Expr>)
    Try(Box<Expr>)

# Literal values
enum Literal:
    Nil
    Bool(bool)
    Int(i64)
    Float(f64)
    String(String)
    Char(char)

# Binary operators
enum BinaryOp:
    Add, Sub, Mul, Div, Mod, Pow
    Eq, NotEq, Lt, LtEq, Gt, GtEq
    And, Or
    BitAnd, BitOr, BitXor, Shl, Shr

# Unary operators
enum UnaryOp:
    Neg, Not, BitNot, Ref, Deref

# =============================================================================
# Exports
# =============================================================================

export Module, Import
export Statement, LetBinding, Block, MatchCase
export Param, StructField, EnumVariant
export Pattern
export Expr
export Literal
export BinaryOp, UnaryOp
