# Compiler Integration Tests
#
# End-to-end tests for the Simple compiler.
# These tests verify complete compilation scenarios from
# source code through codegen and execution.
#
# Test categories:
# - Basic compilation: Variables, expressions, control flow
# - Type system: Type checking, inference, generics
# - Functions: Calls, closures, methods
# - Memory: Allocation, GC interaction
# - Error messages: Diagnostics quality

use test.integration.mod.*

# ============================================================================
# Basic Compilation Tests
# ============================================================================

fn basic_compilation_suite() -> IntegrationTestSuite:
    """Tests for basic compilation functionality."""
    var suite = IntegrationTestSuite.create("Basic Compilation")

    # Hello World
    suite.add_test(
        output_test("hello_world",
            "print \"Hello, World!\"",
            "Hello, World!\n"
        )
    )

    # Variable declarations
    suite.add_test(
        output_test("val_declaration",
            "val x = 42\nprint x",
            "42\n"
        )
    )

    suite.add_test(
        output_test("var_declaration",
            "var x = 10\nx = x + 5\nprint x",
            "15\n"
        )
    )

    # String interpolation
    suite.add_test(
        output_test("string_interpolation",
            "val name = \"Alice\"\nprint \"Hello, {name}!\"",
            "Hello, Alice!\n"
        )
    )

    # Basic arithmetic
    suite.add_test(
        output_test("arithmetic",
            "print (2 + 3) * 4",
            "20\n"
        )
    )

    suite

# ============================================================================
# Control Flow Tests
# ============================================================================

fn control_flow_suite() -> IntegrationTestSuite:
    """Tests for control flow constructs."""
    var suite = IntegrationTestSuite.create("Control Flow")

    # If expression
    suite.add_test(
        output_test("if_expression",
            "val x = 5\nval result = if x > 3: \"big\" else: \"small\"\nprint result",
            "big\n"
        )
    )

    # If statement
    suite.add_test(
        output_test("if_statement",
            "val x = 10\nif x > 5:\n    print \"greater\"",
            "greater\n"
        )
    )

    # Match expression
    suite.add_test(
        output_test("match_basic",
            "val x = 2\nmatch x:\n    case 1: print \"one\"\n    case 2: print \"two\"\n    case _: print \"other\"",
            "two\n"
        )
    )

    # While loop
    suite.add_test(
        output_test("while_loop",
            "var i = 0\nwhile i < 3:\n    print i\n    i = i + 1",
            "0\n1\n2\n"
        )
    )

    # For loop
    suite.add_test(
        output_test("for_loop",
            "for i in 0..3:\n    print i",
            "0\n1\n2\n"
        )
    )

    suite

# ============================================================================
# Function Tests
# ============================================================================

fn function_suite() -> IntegrationTestSuite:
    """Tests for functions and closures."""
    var suite = IntegrationTestSuite.create("Functions")

    # Basic function
    suite.add_test(
        output_test("basic_function",
            "fn add(a: i64, b: i64) -> i64:\n    a + b\n\nprint add(2, 3)",
            "5\n"
        )
    )

    # Function with implicit return
    suite.add_test(
        output_test("implicit_return",
            "fn square(x: i64) -> i64:\n    x * x\n\nprint square(7)",
            "49\n"
        )
    )

    # Recursive function
    suite.add_test(
        output_test("recursive_function",
            "fn factorial(n: i64) -> i64:\n    if n <= 1: 1 else: n * factorial(n - 1)\n\nprint factorial(5)",
            "120\n"
        )
    )

    # Lambda expression
    suite.add_test(
        output_test("lambda",
            "val double = \\x: x * 2\nprint double(21)",
            "42\n"
        )
    )

    # Higher-order function
    suite.add_test(
        output_test("higher_order",
            "fn apply(f: fn(i64) -> i64, x: i64) -> i64:\n    f(x)\n\nprint apply(\\x: x + 10, 32)",
            "42\n"
        )
    )

    suite

# ============================================================================
# Type System Tests
# ============================================================================

fn type_system_suite() -> IntegrationTestSuite:
    """Tests for type system features."""
    var suite = IntegrationTestSuite.create("Type System")

    # Type inference
    suite.add_test(
        output_test("type_inference",
            "val x = 42\nval y = 3.14\nval z = \"hello\"\nprint \"types ok\"",
            "types ok\n"
        )
    )

    # Optional type
    suite.add_test(
        output_test("optional_some",
            "val opt: i64? = Some(42)\nmatch opt:\n    case Some(x): print x\n    case None: print \"none\"",
            "42\n"
        )
    )

    suite.add_test(
        output_test("optional_none",
            "val opt: i64? = nil\nmatch opt:\n    case Some(x): print x\n    case None: print \"none\"",
            "none\n"
        )
    )

    # Result type
    suite.add_test(
        output_test("result_ok",
            "fn safe_div(a: i64, b: i64) -> Result<i64, text>:\n    if b == 0: Err(\"div by zero\") else: Ok(a / b)\n\nmatch safe_div(10, 2):\n    case Ok(x): print x\n    case Err(e): print e",
            "5\n"
        )
    )

    suite

# ============================================================================
# Struct and Method Tests
# ============================================================================

fn struct_suite() -> IntegrationTestSuite:
    """Tests for structs and methods."""
    var suite = IntegrationTestSuite.create("Structs and Methods")

    # Basic struct
    suite.add_test(
        output_test("basic_struct",
            "struct Point:\n    x: i64\n    y: i64\n\nval p = Point(x: 3, y: 4)\nprint p.x",
            "3\n"
        )
    )

    # Struct with method
    suite.add_test(
        output_test("struct_method",
            "struct Point:\n    x: i64\n    y: i64\n\nimpl Point:\n    fn sum() -> i64:\n        self.x + self.y\n\nval p = Point(x: 3, y: 4)\nprint p.sum()",
            "7\n"
        )
    )

    # Static method
    suite.add_test(
        output_test("static_method",
            "struct Point:\n    x: i64\n    y: i64\n\nimpl Point:\n    static fn origin() -> Point:\n        Point(x: 0, y: 0)\n\nval p = Point.origin()\nprint p.x",
            "0\n"
        )
    )

    # Mutable method
    suite.add_test(
        output_test("mutable_method",
            "class Counter:\n    value: i64\n\nimpl Counter:\n    me increment():\n        self.value = self.value + 1\n\nvar c = Counter(value: 0)\nc.increment()\nc.increment()\nprint c.value",
            "2\n"
        )
    )

    suite

# ============================================================================
# Enum Tests
# ============================================================================

fn enum_suite() -> IntegrationTestSuite:
    """Tests for enums and pattern matching."""
    var suite = IntegrationTestSuite.create("Enums")

    # Simple enum
    suite.add_test(
        output_test("simple_enum",
            "enum Color:\n    Red\n    Green\n    Blue\n\nval c = Color.Red\nmatch c:\n    case Red: print \"red\"\n    case Green: print \"green\"\n    case Blue: print \"blue\"",
            "red\n"
        )
    )

    # Enum with data
    suite.add_test(
        output_test("enum_with_data",
            "enum Shape:\n    Circle(radius: f64)\n    Rectangle(width: f64, height: f64)\n\nval s = Shape.Circle(3.14)\nmatch s:\n    case Circle(r): print \"circle\"\n    case Rectangle(w, h): print \"rect\"",
            "circle\n"
        )
    )

    suite

# ============================================================================
# Collection Tests
# ============================================================================

fn collection_suite() -> IntegrationTestSuite:
    """Tests for collections."""
    var suite = IntegrationTestSuite.create("Collections")

    # Array literal
    suite.add_test(
        output_test("array_literal",
            "val arr = [1, 2, 3]\nprint arr[0]",
            "1\n"
        )
    )

    # Array map
    suite.add_test(
        output_test("array_map",
            "val arr = [1, 2, 3]\nval doubled = arr.map(\\x: x * 2)\nprint doubled[1]",
            "4\n"
        )
    )

    # Array filter
    suite.add_test(
        output_test("array_filter",
            "val arr = [1, 2, 3, 4, 5]\nval evens = arr.filter(\\x: x % 2 == 0)\nprint evens.len()",
            "2\n"
        )
    )

    # Range
    suite.add_test(
        output_test("range",
            "var sum = 0\nfor i in 1..=5:\n    sum = sum + i\nprint sum",
            "15\n"
        )
    )

    suite

# ============================================================================
# Error Message Tests
# ============================================================================

fn error_message_suite() -> IntegrationTestSuite:
    """Tests for error message quality."""
    var suite = IntegrationTestSuite.create("Error Messages")

    # Type mismatch
    suite.add_test(
        error_test("type_mismatch",
            "val x: i64 = \"hello\"",
            "type mismatch"
        )
    )

    # Undefined variable
    suite.add_test(
        error_test("undefined_variable",
            "print undefined_var",
            "undefined"
        )
    )

    # Wrong number of arguments
    suite.add_test(
        error_test("wrong_arity",
            "fn add(a: i64, b: i64) -> i64:\n    a + b\n\nprint add(1)",
            "argument"
        )
    )

    # Missing field
    suite.add_test(
        error_test("missing_field",
            "struct Point:\n    x: i64\n    y: i64\n\nval p = Point(x: 1)",
            "field"
        )
    )

    suite

# ============================================================================
# Run All Suites
# ============================================================================

fn run_all_compiler_tests() -> [IntegrationSuiteResult]:
    """Run all compiler integration test suites."""
    var results: [IntegrationSuiteResult] = []

    results = results.push(basic_compilation_suite().run_all())
    results = results.push(control_flow_suite().run_all())
    results = results.push(function_suite().run_all())
    results = results.push(type_system_suite().run_all())
    results = results.push(struct_suite().run_all())
    results = results.push(enum_suite().run_all())
    results = results.push(collection_suite().run_all())
    results = results.push(error_message_suite().run_all())

    results

fn format_all_results(results: [IntegrationSuiteResult]) -> text:
    """Format results from all suites."""
    var output = "Compiler Integration Test Results\n"
    output = "{output}═══════════════════════════════════════════════════════════\n\n"

    var total_passed = 0
    var total_failed = 0

    for suite_result in results:
        output = "{output}{suite_result.format_summary()}\n"
        total_passed = total_passed + suite_result.total_passed
        total_failed = total_failed + suite_result.total_failed

    output = "{output}\n═══════════════════════════════════════════════════════════\n"
    output = "{output}Total Passed: {total_passed}\n"
    output = "{output}Total Failed: {total_failed}\n"

    if total_failed == 0:
        output = "{output}\n✓ All tests passed!\n"
    else:
        output = "{output}\n✗ Some tests failed!\n"

    output

# ============================================================================
# Exports
# ============================================================================

export basic_compilation_suite, control_flow_suite, function_suite
export type_system_suite, struct_suite, enum_suite
export collection_suite, error_message_suite
export run_all_compiler_tests, format_all_results
