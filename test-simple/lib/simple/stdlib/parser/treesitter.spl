# Treesitter Parser - Pure Simple Implementation
#
# Pure Simple implementation using Simple's built-in parser.
# Provides tree-sitter-compatible API without C library dependencies.
#
# This wraps the existing Simple parser to provide a tree-sitter-like interface.

export TreeSitterParser, Tree, Node, Query, QueryCursor
export Point, Edit, QueryResult, CapturedNode
export TreeSitterError
export Lexer, Token, TokenKind

# Import Simple's pure parser
use lib.pure.parser (parse, ParseError)
use lib.pure.ast (Module, Stmt, Expr)
use lib.pure.lexer (Token, TokenKind, lex_source)

# ============================================================================
# Error Types
# ============================================================================

enum TreeSitterError:
    ParserCreationFailed(language: text)
    ParseFailed(message: text)
    QueryCreationFailed(message: text)
    InvalidHandle
    InvalidNode

impl TreeSitterError:
    fn to_string() -> text:
        match self:
            case ParserCreationFailed(lang):
                "Failed to create parser for language: {lang}"
            case ParseFailed(msg):
                "Parse failed: {msg}"
            case QueryCreationFailed(msg):
                "Query creation failed: {msg}"
            case InvalidHandle:
                "Invalid handle"
            case InvalidNode:
                "Invalid node"

# ============================================================================
# Lexer - Wrapper for Pure Simple Lexer
# ============================================================================

class Lexer:
    """Wrapper for Simple lexer with tree-sitter-compatible API.

    Example:
        var lexer = Lexer(source: "fn main(): pass")
        val tokens = lexer.tokenize()
    """
    source: text

    fn tokenize() -> Result<[Token], TreeSitterError>:
        """Tokenize source code.

        Returns:
            Result with token list or error
        """
        val tokens = lex_source(self.source)
        Ok(tokens)

# ============================================================================
# Supporting Types
# ============================================================================

struct Point:
    """Position in source code (line, column)."""
    row: i64
    column: i64

enum NodeData:
    """Wrapper for different AST node types."""
    ModuleNode(Module)
    StmtNode(Stmt)
    ExprNode(Expr)

struct Edit:
    """Edit operation for incremental parsing."""
    start_byte: i64
    old_end_byte: i64
    new_end_byte: i64
    start_point: Point
    old_end_point: Point
    new_end_point: Point

# ============================================================================
# TreeSitterParser - Main Parser Wrapper
# ============================================================================

class TreeSitterParser:
    """Wrapper for Simple parser with tree-sitter-compatible API.

    Example:
        val parser = TreeSitterParser.create("simple")?
        val tree = parser.parse("fn main(): pass")?
        val root = tree.root_node()
    """
    language: text

    static fn create(language: text) -> Result<TreeSitterParser, TreeSitterError>:
        """Create new parser for language.

        Args:
            language - Language name (currently only "simple" supported)

        Returns:
            Result with parser or error
        """
        if language != "simple":
            return Err(TreeSitterError.ParserCreationFailed(language))

        Ok(TreeSitterParser(language: language))

    fn parse(source: text) -> Result<Tree, TreeSitterError>:
        """Parse source code.

        Args:
            source - Source code to parse

        Returns:
            Result with syntax tree or error
        """
        match parse(source):
            Ok(module):
                Ok(Tree(_module: Some(module), source: source))
            Err(err):
                Err(TreeSitterError.ParseFailed(err.message))

    fn parse_incremental(source: text, old_tree: Tree, edits: [Edit]) -> Result<Tree, TreeSitterError>:
        """Parse with incremental update.

        Args:
            source - New source code
            old_tree - Previous tree (currently ignored, full reparse)
            edits - List of edits (currently ignored)

        Returns:
            Result with new tree or error

        Note:
            Currently does full reparse. Incremental parsing to be added later.
        """
        # For now, just do full reparse
        # TODO: Implement true incremental parsing using edit information
        self.parse(source)

    fn free():
        """Free parser resources (no-op for Pure Simple)."""
        ()

# ============================================================================
# Tree - Syntax Tree Wrapper
# ============================================================================

class Tree:
    """Wrapper for syntax tree.

    Example:
        val tree = parser.parse(source)?
        val root = tree.root_node()
        print "Root type: {root.kind()}"
    """
    _module: Module?
    source: text

    fn root_node() -> Node:
        """Get root node of tree.

        Returns:
            Root node
        """
        if not self._module.?:
            # Return null node if no module
            return Node(_node_data: None, tree: self, source: self.source)

        # Return module as root node
        val module = self._module.unwrap()
        Node(_node_data: Some(NodeData.ModuleNode(module)), tree: self, source: self.source)

    fn edit(edit: Edit):
        """Apply edit for incremental parsing.

        Args:
            edit - Edit operation

        Note:
            Currently a no-op. Edits are applied during next parse.
        """
        # Store edit for next incremental parse
        # TODO: Track edits for true incremental parsing
        ()

    fn free():
        """Free tree resources."""
        self._module = None

# ============================================================================
# Node - AST Node Wrapper
# ============================================================================

class Node:
    """Wrapper for syntax tree node.

    Example:
        val node = tree.root_node()
        print "Type: {node.kind()}"
        print "Children: {node.child_count()}"
        for i in 0..node.child_count():
            val child = node.child(i)?
            print "  {child.kind()}"
    """
    _node_data: NodeData?
    tree: Tree
    source: text

    fn is_null() -> bool:
        """Check if node is null/invalid."""
        not self._node_data.?

    fn kind() -> text:
        """Get node type string.

        Returns:
            Type name (e.g., "function_definition", "module")
        """
        if not self._node_data.?:
            return "null"

        match self._node_data.unwrap():
            case NodeData.ModuleNode(_):
                "module"
            case NodeData.StmtNode(stmt):
                match stmt:
                    case Stmt.Function(_, _, _, _): "function_definition"
                    case Stmt.Struct(_, _): "struct_definition"
                    case Stmt.Enum(_, _): "enum_definition"
                    case Stmt.Let(_, _, _): "let_statement"
                    case Stmt.Assign(_, _): "assignment"
                    case Stmt.Return(_): "return_statement"
                    case Stmt.While(_, _): "while_statement"
                    case Stmt.For(_, _, _): "for_statement"
                    case Stmt.Expr(_): "expression_statement"
            case NodeData.ExprNode(expr):
                match expr:
                    case Expr.Literal(_): "literal"
                    case Expr.Identifier(_): "identifier"
                    case Expr.Binary(_, _, _): "binary_expression"
                    case Expr.Unary(_, _): "unary_expression"
                    case Expr.Call(_, _): "call_expression"
                    case Expr.Lambda(_, _): "lambda_expression"
                    case Expr.List(_): "list_expression"
                    case Expr.Tuple(_): "tuple_expression"
                    case Expr.Index(_, _): "index_expression"
                    case Expr.Field(_, _): "field_expression"
                    case Expr.If(_, _, _): "if_expression"
                    case Expr.Match(_, _): "match_expression"
                    case Expr.Block(_): "block_expression"

    fn start_byte() -> i64:
        """Get start byte offset.

        Note: Position tracking not implemented yet. Returns 0.
        """
        # TODO: Add position tracking to pure Simple AST
        0

    fn end_byte() -> i64:
        """Get end byte offset.

        Note: Position tracking not implemented yet. Returns source length.
        """
        # TODO: Add position tracking to pure Simple AST
        self.source.len()

    fn start_point() -> Point:
        """Get start position (row, column).

        Note: Position tracking not implemented yet. Returns (0, 0).
        """
        # TODO: Add position tracking to pure Simple AST
        Point(row: 0, column: 0)

    fn end_point() -> Point:
        """Get end position (row, column).

        Note: Position tracking not implemented yet. Returns (0, 0).
        """
        # TODO: Add position tracking to pure Simple AST
        Point(row: 0, column: 0)

    fn child_count() -> i64:
        """Get number of children (including anonymous)."""
        if not self._node_data.?:
            return 0

        val children = self._get_children()
        children.len()

    fn child(index: i64) -> Node?:
        """Get child at index.

        Args:
            index - Child index

        Returns:
            Child node or None if out of bounds
        """
        if not self._node_data.?:
            return None

        val children = self._get_children()

        if index < 0 or index >= children.len():
            return None

        Some(Node(_node_data: Some(children[index]), tree: self.tree, source: self.source))

    fn _get_children() -> [NodeData]:
        """Extract children from AST node.

        Returns:
            List of child NodeData
        """
        if not self._node_data.?:
            return []

        match self._node_data.unwrap():
            case NodeData.ModuleNode(module):
                # Module children are statements
                var children: [NodeData] = []
                for stmt in module.statements:
                    children.push(NodeData.StmtNode(stmt))
                children
            case NodeData.StmtNode(stmt):
                match stmt:
                    case Stmt.Function(_, _, _, body):
                        var children: [NodeData] = []
                        for s in body:
                            children.push(NodeData.StmtNode(s))
                        children
                    case Stmt.Let(_, _, expr):
                        [NodeData.ExprNode(expr)]
                    case Stmt.Assign(_, expr):
                        [NodeData.ExprNode(expr)]
                    case Stmt.Return(expr_opt):
                        match expr_opt:
                            Some(expr): [NodeData.ExprNode(expr)]
                            None: []
                    case Stmt.While(cond, body):
                        var children: [NodeData] = [NodeData.ExprNode(cond)]
                        for s in body:
                            children.push(NodeData.StmtNode(s))
                        children
                    case Stmt.For(_, iter, body):
                        var children: [NodeData] = [NodeData.ExprNode(iter)]
                        for s in body:
                            children.push(NodeData.StmtNode(s))
                        children
                    case Stmt.Expr(expr):
                        [NodeData.ExprNode(expr)]
                    case _:
                        []
            case NodeData.ExprNode(expr):
                match expr:
                    case Expr.Binary(_, left, right):
                        [NodeData.ExprNode(left), NodeData.ExprNode(right)]
                    case Expr.Unary(_, operand):
                        [NodeData.ExprNode(operand)]
                    case Expr.Call(func, args):
                        var children: [NodeData] = [NodeData.ExprNode(func)]
                        for arg in args:
                            children.push(NodeData.ExprNode(arg))
                        children
                    case Expr.List(items):
                        var children: [NodeData] = []
                        for item in items:
                            children.push(NodeData.ExprNode(item))
                        children
                    case Expr.Tuple(items):
                        var children: [NodeData] = []
                        for item in items:
                            children.push(NodeData.ExprNode(item))
                        children
                    case Expr.Index(obj, index):
                        [NodeData.ExprNode(obj), NodeData.ExprNode(index)]
                    case Expr.Field(obj, _):
                        [NodeData.ExprNode(obj)]
                    case Expr.If(cond, then_expr, else_expr):
                        [NodeData.ExprNode(cond), NodeData.ExprNode(then_expr), NodeData.ExprNode(else_expr)]
                    case Expr.Block(stmts):
                        var children: [NodeData] = []
                        for stmt in stmts:
                            children.push(NodeData.StmtNode(stmt))
                        children
                    case _:
                        []

    fn named_child_count() -> i64:
        """Get number of named children (excludes anonymous).

        Note: All nodes are considered named in this implementation.
        """
        self.child_count()

    fn named_child(index: i64) -> Node?:
        """Get named child at index.

        Args:
            index - Named child index

        Returns:
            Child node or None if out of bounds

        Note: All nodes are considered named in this implementation.
        """
        self.child(index)

    fn parent() -> Node?:
        """Get parent node.

        Returns:
            Parent node or None if root

        Note: Parent navigation not implemented yet. Returns None.
        """
        # TODO: Add parent tracking to node structure
        None

    fn next_sibling() -> Node?:
        """Get next sibling.

        Returns:
            Next sibling or None if last

        Note: Sibling navigation not implemented yet. Returns None.
        """
        # TODO: Add sibling tracking to node structure
        None

    fn prev_sibling() -> Node?:
        """Get previous sibling.

        Returns:
            Previous sibling or None if first

        Note: Sibling navigation not implemented yet. Returns None.
        """
        # TODO: Add sibling tracking to node structure
        None

    fn is_named() -> bool:
        """Check if node is named (not anonymous).

        Note: All nodes are considered named in this implementation.
        """
        self._node_data.?

    fn is_missing() -> bool:
        """Check if node is missing (error recovery).

        Note: Error recovery not tracked. Returns false.
        """
        false

    fn is_extra() -> bool:
        """Check if node is extra (e.g., whitespace).

        Note: No extra nodes in this implementation. Returns false.
        """
        false

    fn has_error() -> bool:
        """Check if node or descendants have errors.

        Note: Error tracking not implemented. Returns false.
        """
        # TODO: Add error tracking to AST
        false

    fn text() -> text:
        """Get node text from source.

        Returns:
            Substring of source for this node
        """
        val start = self.start_byte()
        val end = self.end_byte()
        self.source[start:end]

# ============================================================================
# Query - Pattern Matching
# ============================================================================

class Query:
    """Wrapper for pattern matching queries.

    Example:
        val query = Query.create("simple", "(function_definition name: (identifier) @name)")?
        val cursor = QueryCursor.create()
        cursor.exec(query, tree.root_node())
    """
    language: text
    pattern: text
    capture_names: [text]

    static fn create(language: text, source: text) -> Result<Query, TreeSitterError>:
        """Create query from S-expression pattern.

        Args:
            language - Language name
            source - S-expression query (e.g., "(function_definition name: (identifier) @name)")

        Returns:
            Result with query or error
        """
        if language != "simple":
            return Err(TreeSitterError.QueryCreationFailed("Only 'simple' language supported"))

        # Parse query to extract capture names
        var captures: [text] = []
        var i = 0
        while i < source.len():
            # Look for @ followed by identifier
            if source[i] == '@':
                var j = i + 1
                while j < source.len() and (source[j].is_alphanumeric() or source[j] == '_'):
                    j = j + 1
                if j > i + 1:
                    captures.push(source[i+1:j])
                i = j
            else:
                i = i + 1

        Ok(Query(
            language: language,
            pattern: source,
            capture_names: captures
        ))

    fn free():
        """Free query resources (no-op for Pure Simple implementation)."""
        ()

# ============================================================================
# QueryCursor - Query Execution
# ============================================================================

class QueryCursor:
    """Cursor for executing queries.

    Example:
        val cursor = QueryCursor.create()
        cursor.exec(query, node)
        val matches = cursor.matches()
    """
    _query: Query?
    _root: Node?
    _matches: [QueryResult]
    _current_index: i64

    static fn create() -> QueryCursor:
        """Create new query cursor.

        Returns:
            Query cursor
        """
        QueryCursor(_query: None, _root: None, _matches: [], _current_index: 0)

    me exec(query: Query, node: Node):
        """Execute query on node.

        Args:
            query - Query to execute
            node - Root node to search from
        """
        self._query = Some(query)
        self._root = Some(node)
        self._matches = []
        self._current_index = 0

        # Find all matches
        self._find_matches(node, 0)

    me _find_matches(node: Node, pattern_idx: i64):
        """Recursively find matches in AST.

        Args:
            node - Current node
            pattern_idx - Pattern index (always 0 for now)
        """
        if not self._query.?:
            return

        val query = self._query.unwrap()

        # Simple pattern matching: check if node type matches pattern
        # TODO: Implement full S-expression pattern matching
        val node_type = node.kind()

        # Extract pattern node type (simplified)
        val pattern_type = self._extract_pattern_type(query.pattern)

        # Check if this node matches
        if node_type == pattern_type:
            # Collect captures
            var captures: [CapturedNode] = []

            # For each capture name, try to find matching child
            for i in 0..query.capture_names.len():
                val capture_name = query.capture_names[i]
                # Try to find child with matching type
                # This is a simplified version
                val child_opt = self._find_capture_node(node, capture_name)
                if child_opt.?:
                    val child = child_opt.unwrap()
                    captures.push(CapturedNode(node: child, index: i))

            if captures.len() > 0:
                self._matches.push(QueryResult(pattern_index: 0, captures: captures))

        # Recurse into children
        for i in 0..node.child_count():
            val child_opt = node.child(i)
            if child_opt.?:
                self._find_matches(child_opt.unwrap(), pattern_idx)

    fn _extract_pattern_type(pattern: text) -> text:
        """Extract node type from S-expression pattern.

        Args:
            pattern - S-expression pattern

        Returns:
            Node type string
        """
        # Simple extraction: find first word after (
        var start = 0
        while start < pattern.len() and pattern[start] != '(':
            start = start + 1
        start = start + 1  # Skip (

        while start < pattern.len() and pattern[start] == ' ':
            start = start + 1

        var end = start
        while end < pattern.len() and pattern[end] != ' ' and pattern[end] != ')':
            end = end + 1

        pattern[start:end]

    fn _find_capture_node(node: Node, capture_name: text) -> Node?:
        """Find child node for capture.

        Args:
            node - Parent node
            capture_name - Capture name (e.g., "name")

        Returns:
            Matching child node or None
        """
        # Simple heuristic: find child with type matching capture name
        for i in 0..node.child_count():
            val child_opt = node.child(i)
            if child_opt.?:
                val child = child_opt.unwrap()
                if child.kind().contains(capture_name):
                    return Some(child)
        None

    fn set_byte_range(start: i64, end: i64):
        """Set byte range for search optimization.

        Args:
            start - Start byte
            end - End byte

        Note:
            Currently ignored. Full implementation would filter matches by byte range.
        """
        # TODO: Implement byte range filtering
        ()

    me next_match() -> QueryResult?:
        """Get next query match.

        Returns:
            Query match or None if no more matches
        """
        if self._current_index >= self._matches.len():
            return None

        val match = self._matches[self._current_index]
        self._current_index = self._current_index + 1
        Some(match)

    fn free():
        """Free cursor resources."""
        self._query = None
        self._root = None
        self._matches = []

# ============================================================================
# Query Results
# ============================================================================

struct QueryResult:
    """A single query match result."""
    pattern_index: i64
    captures: [CapturedNode]

struct CapturedNode:
    """A single captured node."""
    node: Node
    index: i64
