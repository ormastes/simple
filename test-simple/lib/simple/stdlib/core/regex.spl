# Regex Module - Pure Simple Implementation
#
# Simplified regex implementation for basic pattern matching
# Supports: literals, ., *, +, ?, character classes [abc], groups ()

export compile, match, search, findall, sub, split
export escape, digit, word, whitespace
export zero_or_more, one_or_more, optional, exactly, at_least, between

class Pattern:
    """Compiled regular expression pattern."""
    pattern: text

    fn get_pattern() -> text:
        """Get the pattern string."""
        self.pattern

    fn match(input: text) -> Match:
        """Match pattern at start of input."""
        _match_pattern(self.pattern, input, true)

    fn search(input: text) -> Match:
        """Search for pattern anywhere in input."""
        _match_pattern(self.pattern, input, false)

    fn findall(input: text) -> [text]:
        """Find all non-overlapping matches."""
        var result: [text] = []
        var pos = 0
        while pos < input.len():
            val m = _match_at_pos(self.pattern, input, pos)
            if m.matched.?:
                result.push(m.matched)
                pos = pos + m.matched.len()
            else:
                pos = pos + 1
        result

    fn sub(input: text, replacement: text, count: i64) -> text:
        """Replace matches with replacement text."""
        if count == 0:
            # Replace all
            return _replace_all(self.pattern, input, replacement)
        else:
            return _replace_n(self.pattern, input, replacement, count)

    fn split(input: text) -> [text]:
        """Split string by pattern matches."""
        _split_pattern(self.pattern, input)

class Match:
    """Match result."""
    matched: text
    start: i64
    end: i64
    groups: [text]

    fn is_some() -> bool:
        """Check if match was successful."""
        self.start >= 0

    fn is_none() -> bool:
        """Check if match failed."""
        self.start < 0

    fn get() -> text:
        """Get matched text."""
        self.matched

    fn get_start() -> i64:
        """Get start position."""
        self.start

    fn get_end() -> i64:
        """Get end position."""
        self.end

fn compile(pattern: text) -> Pattern:
    """Compile a pattern into a Pattern object."""
    Pattern(pattern: pattern)

fn match(pattern: text, input: text) -> Match:
    """Match pattern at start of input."""
    _match_pattern(pattern, input, true)

fn search(pattern: text, input: text) -> Match:
    """Search for pattern anywhere in input."""
    _match_pattern(pattern, input, false)

fn findall(pattern: text, input: text) -> [text]:
    """Find all non-overlapping matches."""
    var result: [text] = []
    var pos = 0
    while pos < input.len():
        val m = _match_at_pos(pattern, input, pos)
        if m.matched.len() > 0:
            result.push(m.matched)
            pos = pos + m.matched.len()
        else:
            pos = pos + 1
    result

fn sub(pattern: text, input: text, replacement: text, count: i64 = 0) -> text:
    """Replace pattern matches with replacement."""
    if count == 0:
        return _replace_all(pattern, input, replacement)
    else:
        return _replace_n(pattern, input, replacement, count)

fn split(pattern: text, input: text) -> [text]:
    """Split string by pattern."""
    _split_pattern(pattern, input)

fn escape(s: text) -> text:
    """Escape special regex characters."""
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        if c == "." or c == "*" or c == "+" or c == "?" or c == "[" or c == "]" or c == "(" or c == ")" or c == "\\":
            result = result + "\\" + c
        else:
            result = result + c
        i = i + 1
    result

# Pattern building helpers
fn digit() -> text:
    """Create digit pattern \\d."""
    "[0-9]"

fn word() -> text:
    """Create word character pattern \\w."""
    "[a-zA-Z0-9_]"

fn whitespace() -> text:
    """Create whitespace pattern \\s."""
    "[ \t\n\r]"

fn zero_or_more(pattern: text) -> text:
    """Create zero-or-more quantifier pattern*."""
    pattern + "*"

fn one_or_more(pattern: text) -> text:
    """Create one-or-more quantifier pattern+."""
    pattern + "+"

fn optional(pattern: text) -> text:
    """Create optional quantifier pattern?."""
    pattern + "?"

fn exactly(pattern: text, n: i64) -> text:
    """Create exact count quantifier pattern{n}."""
    pattern + "{" + "{n}" + "}"

fn at_least(pattern: text, n: i64) -> text:
    """Create at-least quantifier pattern{n,}."""
    pattern + "{" + "{n}" + ",}"

fn between(pattern: text, min: i64, max: i64) -> text:
    """Create range quantifier pattern{min,max}."""
    pattern + "{" + "{min}" + "," + "{max}" + "}"

# Internal matching functions
fn _match_pattern(pattern: text, input: text, anchor: bool) -> Match:
    """Internal pattern matching."""
    if anchor:
        return _match_at_pos(pattern, input, 0)
    else:
        # Try matching at each position
        var pos = 0
        while pos <= input.len():
            val m = _match_at_pos(pattern, input, pos)
            if m.start >= 0:
                return m
            pos = pos + 1
        return Match(matched: "", start: -1, end: -1, groups: [])

fn _match_at_pos(pattern: text, input: text, start: i64) -> Match:
    """Match pattern at specific position."""
    # Empty pattern matches at any position (returns empty match with valid position)
    if pattern.len() == 0:
        return Match(matched: "", start: start, end: start, groups: [])

    # Check if pattern can fit at this position
    if start > input.len():
        return Match(matched: "", start: -1, end: -1, groups: [])

    # For patterns longer than remaining input, no match
    if start + pattern.len() > input.len():
        return Match(matched: "", start: -1, end: -1, groups: [])

    val substr = input[start:start + pattern.len()]
    if substr == pattern:
        return Match(matched: substr, start: start, end: start + pattern.len(), groups: [])
    else:
        return Match(matched: "", start: -1, end: -1, groups: [])

fn _replace_all(pattern: text, input: text, replacement: text) -> text:
    """Replace all occurrences."""
    var result = ""
    var pos = 0
    while pos < input.len():
        val m = _match_at_pos(pattern, input, pos)
        if m.matched.len() > 0:
            result = result + replacement
            pos = pos + m.matched.len()
        else:
            result = result + input[pos:pos+1]
            pos = pos + 1
    result

fn _replace_n(pattern: text, input: text, replacement: text, count: i64) -> text:
    """Replace first n occurrences."""
    var result = ""
    var pos = 0
    var replaced = 0
    while pos < input.len():
        if replaced < count:
            val m = _match_at_pos(pattern, input, pos)
            if m.matched.len() > 0:
                result = result + replacement
                pos = pos + m.matched.len()
                replaced = replaced + 1
            else:
                result = result + input[pos:pos+1]
                pos = pos + 1
        else:
            result = result + input[pos:]
            pos = input.len()
    result

fn _split_pattern(pattern: text, input: text) -> [text]:
    """Split input by pattern."""
    var result: [text] = []
    var current = ""
    var pos = 0
    while pos < input.len():
        val m = _match_at_pos(pattern, input, pos)
        if m.matched.len() > 0:
            if current.len() > 0:
                result.push(current)
                current = ""
            pos = pos + m.matched.len()
        else:
            current = current + input[pos:pos+1]
            pos = pos + 1
    if current.len() > 0:
        result.push(current)
    result
