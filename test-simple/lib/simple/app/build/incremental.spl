# Incremental Build System
#
# Tracks dependencies and only rebuilds changed components

export IncrementalConfig, IncrementalResult, default_incremental_config

use app.build.types (BuildConfig, BuildResult, BuildProfile)
use app.build.cargo (Cargo)

# Dependency graph node
struct DepNode:
    module: text
    dependencies: [text]
    last_modified: i64
    hash: text

# Build cache entry
struct CacheEntry:
    module: text
    profile: text
    source_hash: text
    output_path: text
    timestamp: i64

# Incremental build configuration
struct IncrementalConfig:
    enabled: bool
    cache_dir: text
    track_deps: bool
    verify_hash: bool
    max_cache_size_mb: i64

# Incremental build result
struct IncrementalResult:
    success: bool
    modules_built: i64
    modules_cached: i64
    modules_skipped: i64
    cache_hit_rate: f64
    duration_ms: i64

impl IncrementalResult:
    fn summary() -> text:
        val total = self.modules_built + self.modules_cached + self.modules_skipped
        val cache_pct = if total > 0:
            (self.modules_cached * 100) / total
        else:
            0
        "Built {self.modules_built}/{total} modules ({cache_pct}% cached)"

# Incremental build orchestrator
class IncrementalBuild:
    # Build with incremental compilation
    static fn build(config: BuildConfig, incremental_config: IncrementalConfig) -> IncrementalResult:
        if not incremental_config.enabled:
            # Fall back to full build
            val result = Cargo.build(config)
            return IncrementalResult(
                success: result.success,
                modules_built: 1,  # Assume 1 for full build
                modules_cached: 0,
                modules_skipped: 0,
                cache_hit_rate: 0.0,
                duration_ms: result.duration_ms
            )

        # Load dependency graph
        val dep_graph = load_dependency_graph()

        # Load cache
        val cache = load_build_cache(incremental_config.cache_dir)

        # Determine what needs rebuilding
        val to_rebuild = find_modules_to_rebuild(dep_graph, cache)

        # Build only changed modules
        # TODO: Implement selective module building
        # For now, fall back to full cargo build which handles incrementality
        val start_time = current_time_ms()
        val result = Cargo.build(config)
        val duration = current_time_ms() - start_time

        # Update cache
        if result.success:
            update_build_cache(cache, dep_graph, incremental_config.cache_dir)

        IncrementalResult(
            success: result.success,
            modules_built: to_rebuild.len(),
            modules_cached: dep_graph.len() - to_rebuild.len(),
            modules_skipped: 0,
            cache_hit_rate: calculate_cache_hit_rate(to_rebuild.len(), dep_graph.len()),
            duration_ms: duration
        )

    # Quick incremental build
    static fn quick() -> IncrementalResult:
        val config = BuildConfig(
            profile: BuildProfile.Debug,
            features: [],
            workspace_root: "build/rust/ffi_gen",
            target_dir: "build/rust/ffi_gen/target",
            jobs: 4,
            verbose: false
        )

        val incremental_config = default_incremental_config()
        IncrementalBuild.build(config, incremental_config)

    # Clean incremental cache
    static fn clean_cache(cache_dir: text) -> bool:
        # TODO: Implement cache cleanup
        print "Cleaning incremental cache: {cache_dir}"
        true

# Dependency graph builder
class DepGraphBuilder:
    # Build dependency graph from source files
    static fn build_graph(root: text) -> [DepNode]:
        # TODO: Parse source files to build dependency graph
        # For now, return empty graph
        []

    # Update dependency graph
    static fn update_graph(graph: [DepNode], changes: [text]) -> [DepNode]:
        # TODO: Incrementally update graph based on file changes
        graph

# Cache manager
class CacheManager:
    # Load build cache
    static fn load(cache_dir: text) -> [CacheEntry]:
        # TODO: Load from cache_dir/build_cache.sdn
        []

    # Save build cache
    static fn save(cache: [CacheEntry], cache_dir: text) -> bool:
        # TODO: Save to cache_dir/build_cache.sdn
        true

    # Verify cache entry is valid
    static fn verify(entry: CacheEntry, source_path: text) -> bool:
        # Check if source file hash matches cached hash
        # TODO: Implement hash verification
        true

    # Prune old cache entries
    static fn prune(cache: [CacheEntry], max_size_mb: i64) -> [CacheEntry]:
        # Remove old entries to keep cache under max size
        # TODO: Implement LRU or timestamp-based pruning
        cache

# Load dependency graph
fn load_dependency_graph() -> [DepNode]:
    # TODO: Load from dependency graph file
    # For now, return empty graph (cargo handles dependencies)
    []

# Load build cache
fn load_build_cache(cache_dir: text) -> [CacheEntry]:
    CacheManager.load(cache_dir)

# Find modules that need rebuilding
fn find_modules_to_rebuild(dep_graph: [DepNode], cache: [CacheEntry]) -> [text]:
    # TODO: Compare modification times and hashes
    # Return list of modules that need rebuilding
    # For now, let cargo handle this
    []

# Update build cache after successful build
fn update_build_cache(cache: [CacheEntry], dep_graph: [DepNode], cache_dir: text):
    # TODO: Update cache entries with new hashes and timestamps
    # Save updated cache
    CacheManager.save(cache, cache_dir)

# Calculate cache hit rate
fn calculate_cache_hit_rate(modules_built: i64, total_modules: i64) -> f64:
    if total_modules == 0:
        return 0.0

    val cached = total_modules - modules_built
    val rate = (cached * 100) / total_modules
    # Convert to float (approximation since we don't have float division yet)
    0.0  # TODO: Implement proper float calculation

# Get current time in milliseconds
fn current_time_ms() -> i64:
    # TODO: Use proper time FFI
    0

# Default incremental configuration
fn default_incremental_config() -> IncrementalConfig:
    IncrementalConfig(
        enabled: true,
        cache_dir: "build/rust/ffi_gen/target/incremental",
        track_deps: true,
        verify_hash: true,
        max_cache_size_mb: 1024
    )

# Print incremental result
fn print_incremental_result(result: IncrementalResult):
    print ""
    print "=========================================="
    print "Incremental Build Result"
    print "=========================================="
    print ""
    print result.summary()
    print ""
    print "Statistics:"
    print "  Modules built:   {result.modules_built}"
    print "  Modules cached:  {result.modules_cached}"
    print "  Modules skipped: {result.modules_skipped}"
    print "  Duration:        {result.duration_ms}ms"

    if result.modules_cached > 0:
        val total = result.modules_built + result.modules_cached
        val saved_pct = (result.modules_cached * 100) / total
        print ""
        print "Time saved by caching: ~{saved_pct}%"
