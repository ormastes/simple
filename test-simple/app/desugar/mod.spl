# Desugar Module - Source-Level Transformation
#
# Orchestrates desugaring passes that transform Simple code into forms
# the current runtime can execute. Primary use case: transform static
# method definitions and calls into module-level functions.
#
# NOTE: This module runs on the Rust runtime, so it MUST NOT use any
# static fn patterns. All functions are module-level.
# BUG workarounds from doc/report/runtime_parser_bugs_2026-02-06.md applied.

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool

use app.desugar.static_methods (desugar_static_methods)
use app.desugar.enum_constructors (desugar_enum_constructors)
use app.desugar.rewriter (rewrite_static_calls)

export desugar_file, desugar_source

# Desugar a source file in-place or to an output path
fn desugar_file(input_path: text, output_path: text) -> bool:
    val source = rt_file_read_text(input_path)
    val source = source ?? ""
    if source == "":
        print "error: could not read file: {input_path}"
        return false

    val result = desugar_source(source)
    val ok = rt_file_write_text(output_path, result)
    ok

# Desugar source text, returning transformed source
fn desugar_source(source: text) -> text:
    # Pass 1: Extract static method definitions from impl blocks,
    #         hoist them as module-level functions named TypeName__method_name
    val pass1 = desugar_static_methods(source)

    # Pass 2: Extract enum variants and generate factory functions
    #         named EnumName__VariantName
    val pass2 = desugar_enum_constructors(pass1)

    # Pass 3: Rewrite Type.method(args) calls to TypeName__method_name(args)
    #         This handles both static methods and enum constructors
    val pass3 = rewrite_static_calls(pass2)

    pass3

# Main entry point for CLI: simple desugar <file> [-o <output>]
fn main() -> i64:
    extern fn rt_cli_args() -> [text]
    val args = rt_cli_args()
    # BUG-01 workaround: use explicit 0:len instead of [:len]

    if args.len() < 2:
        print "Usage: simple desugar <file.spl> [-o <output.spl>]"
        print ""
        print "Transforms static method definitions and calls into module-level"
        print "functions that the current runtime can execute."
        return 1

    val input = args[1]
    var output = ""

    # Parse -o flag
    var i = 2
    while i < args.len():
        if args[i] == "-o" and i + 1 < args.len():
            output = args[i + 1]
            i = i + 2
        else:
            i = i + 1

    if output == "":
        # Default: print to stdout
        val source = rt_file_read_text(input)
        val source = source ?? ""
        if source == "":
            print "error: could not read file: {input}"
            return 1
        val result = desugar_source(source)
        print result
        return 0
    else:
        if desugar_file(input, output):
            print "desugared: {input} -> {output}"
            return 0
        else:
            return 1
