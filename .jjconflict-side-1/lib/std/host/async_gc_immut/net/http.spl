# HTTP Client - Immutable Variant
# Functional style HTTP with immutable request/response builders

use units.net.*
use units.url.*
use units.size.*
use host.common.io.error.IoError
use host.common.net.types.HttpMethod

# HTTP Header (immutable)
struct Header:
    name: str
    value: str

# HTTP Headers collection (immutable, uses persistent list)
struct Headers:
    items: List[Header]

impl Headers:
    fn empty() -> Headers:
        Headers { items: List.empty() }

    # Add header, return new Headers
    fn with(self, name: str, value: str) -> Headers:
        Headers { items: self.items.prepend(Header { name: name, value: value }) }

    # Get header value
    fn get(self, name: str) -> Option[str]:
        match self.items.find(|h| h.name.eq_ignore_case(name)):
            case Some(h): Some(h.value)
            case None: None

    # Get all values for header
    fn get_all(self, name: str) -> List[str]:
        self.items
            .filter(|h| h.name.eq_ignore_case(name))
            .map(|h| h.value)

    fn len(self) -> u64:
        self.items.len()

# HTTP Request (immutable builder)
struct Request:
    method: HttpMethod
    url: Url
    headers: Headers
    body: Option[Bytes]

impl Request:
    # Create GET request
    fn get(url: Url) -> Request:
        Request {
            method: HttpMethod::GET,
            url: url,
            headers: Headers::empty(),
            body: None
        }

    # Create POST request
    fn post(url: Url) -> Request:
        Request {
            method: HttpMethod::POST,
            url: url,
            headers: Headers::empty(),
            body: None
        }

    # Create request with method
    fn new(method: HttpMethod, url: Url) -> Request:
        Request {
            method: method,
            url: url,
            headers: Headers::empty(),
            body: None
        }

    # Add header, return new request
    fn with_header(self, name: str, value: str) -> Request:
        Request {
            method: self.method,
            url: self.url,
            headers: self.headers.with(name, value),
            body: self.body
        }

    # Set body, return new request
    fn with_body(self, body: Bytes) -> Request:
        Request {
            method: self.method,
            url: self.url,
            headers: self.headers,
            body: Some(body)
        }

    # Set JSON body, return new request
    fn with_json(self, json: str) -> Request:
        self.with_header("Content-Type", "application/json")
            .with_body(json.to_bytes())

    # Set form body, return new request
    fn with_form(self, form: str) -> Request:
        self.with_header("Content-Type", "application/x-www-form-urlencoded")
            .with_body(form.to_bytes())

    # Execute request
    pub async fn send(self) -> Result[Response, IoError]:
        return native_http_request(self)

# HTTP Response (immutable)
struct Response:
    status: u16
    headers: Headers
    body: Bytes

impl Response:
    fn status(self) -> u16:
        self.status

    fn is_success(self) -> bool:
        self.status >= 200 and self.status < 300

    fn is_redirect(self) -> bool:
        self.status >= 300 and self.status < 400

    fn is_client_error(self) -> bool:
        self.status >= 400 and self.status < 500

    fn is_server_error(self) -> bool:
        self.status >= 500

    fn headers(self) -> Headers:
        self.headers

    fn body(self) -> Bytes:
        self.body

    fn text(self) -> Result[str, IoError]:
        match self.body.to_utf8():
            case Ok(s): Ok(s)
            case Err(_): Err(IoError::InvalidData)

    fn content_length(self) -> Option[ByteCount]:
        match self.headers.get("Content-Length"):
            case Some(s):
                match s.parse_u64():
                    case Ok(n): Some(n_bytes)
                    case Err(_): None
            case None: None

# ===============================
# Convenience Functions
# ===============================

# Simple GET request
pub async fn get(url: Url) -> Result[Response, IoError]:
    Request::get(url).send()

# Simple POST with body
pub async fn post(url: Url, body: Bytes) -> Result[Response, IoError]:
    Request::post(url).with_body(body).send()

# POST JSON
pub async fn post_json(url: Url, json: str) -> Result[Response, IoError]:
    Request::post(url).with_json(json).send()

# ===============================
# Native function declarations
# ===============================

extern fn native_http_request(req: Request) -> Result[Response, IoError]
