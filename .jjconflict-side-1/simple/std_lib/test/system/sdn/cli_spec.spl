///
SDN CLI System Tests

End-to-end tests for SDN CLI commands.
Tests real CLI execution with file I/O.

No mocks - tests the entire stack:
- CLI argument parsing
- File reading/writing
- SDN parsing/serialization
- Exit codes and error messages
///

import std.spec
import std.process
import std.fs
import std.path
import std.random

describe "SDN CLI System Tests":
    context "check command":
        it "validates valid SDN file":
            let (file, path) = create_temp_file("name: Alice\nage: 30")

            let result = run_sdn_cli(["check", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("valid")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "reports syntax errors":
            let (file, path) = create_temp_file("name: Alice\n  invalid syntax")

            let result = run_sdn_cli(["check", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 1
                    expect output.stderr.contains("error") || output.stdout.contains("error")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "handles missing file":
            let result = run_sdn_cli(["check", "/nonexistent/file.sdn"])

            match result:
                case Ok(output):
                    expect output.exit_code == 1
                case Err(e):
                    fail("CLI execution failed: ${e}")

    context "to-json command":
        it "converts SDN to JSON":
            let sdn_content = "name: Alice\nage: 30\nenabled: true"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["to-json", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("Alice")
                    expect output.stdout.contains("30")
                    expect output.stdout.contains("true")
                    # Should be valid JSON
                    expect is_valid_json(output.stdout)
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "handles nested structures":
            let sdn_content = """
server:
    host: localhost
    port: 8080
    config:
        debug: true
        workers: 4
"""
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["to-json", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("server")
                    expect output.stdout.contains("localhost")
                    expect output.stdout.contains("8080")
                    expect output.stdout.contains("debug")
                    expect is_valid_json(output.stdout)
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "handles arrays and dicts":
            let sdn_content = "items = [1, 2, 3]\nconfig = {x: 10, y: 20}"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["to-json", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("[1, 2, 3]") || output.stdout.contains("[1,2,3]")
                    expect is_valid_json(output.stdout)
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

    context "from-json command":
        it "converts JSON to SDN":
            let json_content = '{"name": "Alice", "age": 30, "enabled": true}'
            let (file, path) = create_temp_file(json_content)

            let result = run_sdn_cli(["from-json", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("name")
                    expect output.stdout.contains("Alice")
                    expect output.stdout.contains("age")
                    expect output.stdout.contains("30")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "handles nested JSON objects":
            let json_content = '{"server": {"host": "localhost", "port": 8080}}'
            let (file, path) = create_temp_file(json_content)

            let result = run_sdn_cli(["from-json", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("server")
                    expect output.stdout.contains("host")
                    expect output.stdout.contains("localhost")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "handles JSON arrays":
            let json_content = '{"items": [1, 2, 3, 4, 5]}'
            let (file, path) = create_temp_file(json_content)

            let result = run_sdn_cli(["from-json", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("items")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

    context "get command":
        it "extracts top-level value":
            let sdn_content = "name: Alice\nage: 30"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["get", path, "name"])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("Alice")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "extracts nested value via path":
            let sdn_content = "server:\n    host: localhost\n    port: 8080"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["get", path, "server.host"])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("localhost")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "handles missing path":
            let sdn_content = "name: Alice"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["get", path, "nonexistent"])

            match result:
                case Ok(output):
                    expect output.exit_code == 1
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

    context "set command":
        it "sets top-level value":
            let sdn_content = "name: Alice\nage: 30"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["set", path, "name", "Bob"])

            match result:
                case Ok(output):
                    expect output.exit_code == 0

                    # Verify file was updated
                    let updated = fs.read_to_string(path)
                    match updated:
                        case Ok(content):
                            expect content.contains("Bob")
                        case Err(e):
                            fail("Failed to read updated file: ${e}")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "sets nested value":
            let sdn_content = "server:\n    host: localhost\n    port: 8080"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["set", path, "server.port", "9000"])

            match result:
                case Ok(output):
                    expect output.exit_code == 0

                    # Verify update
                    let updated = fs.read_to_string(path)
                    match updated:
                        case Ok(content):
                            expect content.contains("9000")
                        case Err(e):
                            fail("Failed to read updated file: ${e}")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "handles invalid path":
            let sdn_content = "name: Alice"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["set", path, "nonexistent.nested", "value"])

            match result:
                case Ok(output):
                    expect output.exit_code == 1
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

    context "fmt command":
        it "formats file to stdout":
            let sdn_content = "name:Alice\n  age:  30"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["fmt", path])

            match result:
                case Ok(output):
                    expect output.exit_code == 0
                    expect output.stdout.contains("name")
                    expect output.stdout.contains("Alice")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

        it "formats file in-place with --write":
            let sdn_content = "name:Alice\nage:30"
            let (file, path) = create_temp_file(sdn_content)

            let result = run_sdn_cli(["fmt", path, "--write"])

            match result:
                case Ok(output):
                    expect output.exit_code == 0

                    # Verify file was formatted
                    let formatted = fs.read_to_string(path)
                    match formatted:
                        case Ok(content):
                            # Should have proper spacing
                            expect content.contains(": ")
                        case Err(e):
                            fail("Failed to read formatted file: ${e}")
                case Err(e):
                    fail("CLI execution failed: ${e}")

            cleanup_temp_file(path)

### Helper Functions

fn run_sdn_cli(args: List[String]) -> Result[ProcessOutput, String]:
    """
    Run SDN CLI command

    Returns process output with exit code, stdout, stderr
    """
    let sdn_binary = find_sdn_binary()

    match sdn_binary:
        case Some(path):
            return process.run_command(path, args)
        case None:
            return Err("SDN CLI binary not found")

fn find_sdn_binary() -> Option[String]:
    """Find SDN CLI binary"""
    let candidates = [
        "simple/bin_simple/simple_sdn",
        "./simple/bin_simple/simple_sdn",
        "../../../bin_simple/simple_sdn",
        "target/debug/simple_sdn"
    ]

    for path in candidates:
        if fs.exists(path):
            return Some(path)

    return None

fn create_temp_file(content: String) -> (File, String):
    """Create temporary file with content"""
    let temp_dir = "/tmp/sdn_test"
    fs.create_dir_all(temp_dir)

    let random_id = random.random_int(1000, 9999)
    let file_path = "${temp_dir}/test_${random_id}.sdn"

    match fs.write(file_path, content):
        case Ok(file):
            return (file, file_path)
        case Err(e):
            fail("Failed to create temp file: ${e}")

fn cleanup_temp_file(path: String):
    """Remove temporary file"""
    fs.remove(path)

fn is_valid_json(text: String) -> Bool:
    """Check if text is valid JSON"""
    match json.parse(text):
        case Ok(_):
            return True
        case Err(_):
            return False
