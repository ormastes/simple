# Interactive - Interactive Widgets (Button, TextField, Checkbox, Select, Slider)
#
# Provides interactive form and control widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Button variants
pub enum ButtonVariant:
    Primary
    Secondary
    Outlined
    Text
    Icon

# Button - Clickable button widget
pub struct Button:
    label: String
    icon: Option[String]
    on_click: Option[fn()]
    variant: ButtonVariant
    disabled: bool
    full_width: bool

impl Button:
    # Create a new button with label
    pub fn new(label: &str) -> Button:
        return Button {
            label: label.to_string(),
            icon: None,
            on_click: None,
            variant: ButtonVariant::Primary,
            disabled: false,
            full_width: false
        }

    # Set button icon
    pub fn icon(self, icon: &str) -> Button:
        self.icon = Some(icon.to_string())
        return self

    # Set click handler
    pub fn on_click(self, handler: fn()) -> Button:
        self.on_click = Some(handler)
        return self

    # Set variant
    pub fn variant(self, variant: ButtonVariant) -> Button:
        self.variant = variant
        return self

    # Make button secondary
    pub fn secondary(self) -> Button:
        self.variant = ButtonVariant::Secondary
        return self

    # Make button outlined
    pub fn outlined(self) -> Button:
        self.variant = ButtonVariant::Outlined
        return self

    # Make button text-only
    pub fn text(self) -> Button:
        self.variant = ButtonVariant::Text
        return self

    # Set disabled state
    pub fn disabled(self, value: bool) -> Button:
        self.disabled = value
        return self

    # Make button full width
    pub fn full_width(self) -> Button:
        self.full_width = true
        return self

impl Widget for Button:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::button(id, &self.label)

        # Apply variant classes
        let variant_class = match self.variant:
            case ButtonVariant::Primary: "btn-primary"
            case ButtonVariant::Secondary: "btn-secondary"
            case ButtonVariant::Outlined: "btn-outlined"
            case ButtonVariant::Text: "btn-text"
            case ButtonVariant::Icon: "btn-icon"

        elem = elem
            .with_class("btn")
            .with_class(variant_class)

        # Apply full width
        if self.full_width:
            elem = elem
                .with_class("btn-full-width")
                .with_style("width", "100%")

        # Apply disabled state
        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Register click handler
        if let Some(handler) = &self.on_click:
            # In a real implementation, this would register the handler
            # with the event system and assign a unique ID
            elem = elem.on_event("click", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# TextField - Text input widget
pub struct TextField:
    value: String
    placeholder: String
    on_change: Option[fn(String)]
    on_submit: Option[fn(String)]
    multiline: bool
    max_length: Option[u32]
    disabled: bool
    password: bool
    autofocus: bool

impl TextField:
    # Create a new text field
    pub fn new() -> TextField:
        return TextField {
            value: String::new(),
            placeholder: String::new(),
            on_change: None,
            on_submit: None,
            multiline: false,
            max_length: None,
            disabled: false,
            password: false,
            autofocus: false
        }

    # Set initial value
    pub fn value(self, value: &str) -> TextField:
        self.value = value.to_string()
        return self

    # Set placeholder text
    pub fn placeholder(self, placeholder: &str) -> TextField:
        self.placeholder = placeholder.to_string()
        return self

    # Set change handler
    pub fn on_change(self, handler: fn(String)) -> TextField:
        self.on_change = Some(handler)
        return self

    # Set submit handler (Enter key)
    pub fn on_submit(self, handler: fn(String)) -> TextField:
        self.on_submit = Some(handler)
        return self

    # Make multiline (textarea)
    pub fn multiline(self) -> TextField:
        self.multiline = true
        return self

    # Set max length
    pub fn max_length(self, length: u32) -> TextField:
        self.max_length = Some(length)
        return self

    # Set disabled state
    pub fn disabled(self, value: bool) -> TextField:
        self.disabled = value
        return self

    # Make password field
    pub fn password(self) -> TextField:
        self.password = true
        return self

    # Enable autofocus
    pub fn autofocus(self) -> TextField:
        self.autofocus = true
        return self

impl Widget for TextField:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = if self.multiline:
            Element::new(id, ElementKind::Input)
                .with_attr("type", "textarea")
        else:
            Element::input(id)
                .with_attr("type", if self.password { "password" } else { "text" })

        elem = elem
            .with_class("text-field")
            .with_attr("value", &self.value)
            .with_attr("placeholder", &self.placeholder)

        # Apply max length
        if let Some(max_len) = self.max_length:
            elem = elem.with_attr("maxlength", &max_len.to_string())

        # Apply disabled state
        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Apply autofocus
        if self.autofocus:
            elem = elem.with_attr("autofocus", "true")

        # Register handlers
        if let Some(_) = &self.on_change:
            elem = elem.on_event("input", 0)  # Placeholder handler ID
        if let Some(_) = &self.on_submit:
            elem = elem.on_event("submit", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# Checkbox - Boolean toggle widget
pub struct Checkbox:
    checked: bool
    label: String
    on_change: Option[fn(bool)]
    disabled: bool

impl Checkbox:
    # Create a new checkbox
    pub fn new(label: &str) -> Checkbox:
        return Checkbox {
            checked: false,
            label: label.to_string(),
            on_change: None,
            disabled: false
        }

    # Set checked state
    pub fn checked(self, checked: bool) -> Checkbox:
        self.checked = checked
        return self

    # Set change handler
    pub fn on_change(self, handler: fn(bool)) -> Checkbox:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(self, value: bool) -> Checkbox:
        self.disabled = value
        return self

impl Widget for Checkbox:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Checkbox)
            .with_class("checkbox")
            .with_attr("type", "checkbox")

        if self.checked:
            elem = elem.with_attr("checked", "true")

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Wrap with label
        let label_id = ctx.alloc_id()
        let mut label = Element::new(label_id, ElementKind::Div)
            .with_class("checkbox-wrapper")
            .with_child(elem)
            .with_child(
                Element::text(ctx.alloc_id(), &self.label)
                    .with_class("checkbox-label")
            )

        # Register change handler
        if let Some(_) = &self.on_change:
            label = label.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode::new(label)

# Select - Dropdown selection widget
pub struct Select:
    options: Array[(String, String)]  # (value, label) pairs
    selected: Option[String]
    placeholder: String
    on_change: Option[fn(String)]
    disabled: bool

impl Select:
    # Create a new select widget
    pub fn new() -> Select:
        return Select {
            options: [],
            selected: None,
            placeholder: String::new(),
            on_change: None,
            disabled: false
        }

    # Add an option
    pub fn option(self, value: &str, label: &str) -> Select:
        self.options.push((value.to_string(), label.to_string()))
        return self

    # Set options from array
    pub fn options(self, options: Array[(String, String)]) -> Select:
        self.options = options
        return self

    # Set selected value
    pub fn selected(self, value: &str) -> Select:
        self.selected = Some(value.to_string())
        return self

    # Set placeholder
    pub fn placeholder(self, placeholder: &str) -> Select:
        self.placeholder = placeholder.to_string()
        return self

    # Set change handler
    pub fn on_change(self, handler: fn(String)) -> Select:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(self, value: bool) -> Select:
        self.disabled = value
        return self

impl Widget for Select:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Select)
            .with_class("select")

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Add placeholder option
        if not self.placeholder.is_empty():
            let placeholder_opt = Element::new(ctx.alloc_id(), ElementKind::Div)
                .with_attr("value", "")
                .with_attr("disabled", "true")
                .with_attr("selected", "true")
                .with_text(&self.placeholder)
            elem = elem.with_child(placeholder_opt)

        # Add options
        for (value, label) in &self.options:
            let mut option = Element::new(ctx.alloc_id(), ElementKind::Div)
                .with_attr("value", value)
                .with_text(label)

            if let Some(selected) = &self.selected:
                if selected == value:
                    option = option.with_attr("selected", "true")

            elem = elem.with_child(option)

        # Register change handler
        if let Some(_) = &self.on_change:
            elem = elem.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# Slider - Range input widget
pub struct Slider:
    value: f64
    min: f64
    max: f64
    step: f64
    on_change: Option[fn(f64)]
    disabled: bool

impl Slider:
    # Create a new slider
    pub fn new(value: f64) -> Slider:
        return Slider {
            value: value,
            min: 0.0,
            max: 100.0,
            step: 1.0,
            on_change: None,
            disabled: false
        }

    # Set min value
    pub fn min(self, min: f64) -> Slider:
        self.min = min
        return self

    # Set max value
    pub fn max(self, max: f64) -> Slider:
        self.max = max
        return self

    # Set step increment
    pub fn step(self, step: f64) -> Slider:
        self.step = step
        return self

    # Set change handler
    pub fn on_change(self, handler: fn(f64)) -> Slider:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(self, value: bool) -> Slider:
        self.disabled = value
        return self

impl Widget for Slider:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Input)
            .with_class("slider")
            .with_attr("type", "range")
            .with_attr("value", &self.value.to_string())
            .with_attr("min", &self.min.to_string())
            .with_attr("max", &self.max.to_string())
            .with_attr("step", &self.step.to_string())

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Register change handler
        if let Some(_) = &self.on_change:
            elem = elem.on_event("input", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# Radio - Radio button group widget
pub struct RadioGroup:
    name: String
    options: Array[(String, String)]  # (value, label) pairs
    selected: Option[String]
    on_change: Option[fn(String)]
    disabled: bool

impl RadioGroup:
    # Create a new radio group
    pub fn new(name: &str) -> RadioGroup:
        return RadioGroup {
            name: name.to_string(),
            options: [],
            selected: None,
            on_change: None,
            disabled: false
        }

    # Add an option
    pub fn option(self, value: &str, label: &str) -> RadioGroup:
        self.options.push((value.to_string(), label.to_string()))
        return self

    # Set selected value
    pub fn selected(self, value: &str) -> RadioGroup:
        self.selected = Some(value.to_string())
        return self

    # Set change handler
    pub fn on_change(self, handler: fn(String)) -> RadioGroup:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(self, value: bool) -> RadioGroup:
        self.disabled = value
        return self

impl Widget for RadioGroup:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut group = Element::new(id, ElementKind::Div)
            .with_class("radio-group")

        # Create radio buttons
        for (value, label) in &self.options:
            let radio_id = ctx.alloc_id()
            let mut radio = Element::new(radio_id, ElementKind::Radio)
                .with_attr("type", "radio")
                .with_attr("name", &self.name)
                .with_attr("value", value)

            if let Some(selected) = &self.selected:
                if selected == value:
                    radio = radio.with_attr("checked", "true")

            if self.disabled:
                radio = radio.with_attr("disabled", "true")

            # Wrap with label
            let wrapper = Element::new(ctx.alloc_id(), ElementKind::Div)
                .with_class("radio-wrapper")
                .with_child(radio)
                .with_child(
                    Element::text(ctx.alloc_id(), label)
                        .with_class("radio-label")
                )

            group = group.with_child(wrapper)

        # Register change handler
        if let Some(_) = &self.on_change:
            group = group.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode::new(group)
