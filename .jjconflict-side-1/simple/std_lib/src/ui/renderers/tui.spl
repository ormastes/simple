# TuiRenderer - Terminal UI Renderer
#
# Renders widgets to terminal using ANSI escape codes and box-drawing characters.
# Implements the RenderBackend trait for Terminal platform.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*
use ui.render_backend.*
use ui.viewport.*

# Terminal cell - represents a single character position
pub struct TermCell:
    pub char: String  # UTF-8 character (may be multi-byte)
    pub fg_color: Option[AnsiColor]
    pub bg_color: Option[AnsiColor]
    pub bold: bool
    pub italic: bool
    pub underline: bool

impl TermCell:
    pub fn empty() -> TermCell:
        return TermCell {
            char: " ".to_string(),
            fg_color: None,
            bg_color: None,
            bold: false,
            italic: false,
            underline: false
        }

    pub fn with_char(char: &str) -> TermCell:
        let mut cell = TermCell::empty()
        cell.char = char.to_string()
        return cell

# ANSI color codes
pub enum AnsiColor:
    Black
    Red
    Green
    Yellow
    Blue
    Magenta
    Cyan
    White
    BrightBlack
    BrightRed
    BrightGreen
    BrightYellow
    BrightBlue
    BrightMagenta
    BrightCyan
    BrightWhite
    Rgb(u8, u8, u8)

impl AnsiColor:
    # Get ANSI foreground code
    pub fn fg_code(self) -> String:
        match self:
            case AnsiColor::Black: return "\x1b[30m"
            case AnsiColor::Red: return "\x1b[31m"
            case AnsiColor::Green: return "\x1b[32m"
            case AnsiColor::Yellow: return "\x1b[33m"
            case AnsiColor::Blue: return "\x1b[34m"
            case AnsiColor::Magenta: return "\x1b[35m"
            case AnsiColor::Cyan: return "\x1b[36m"
            case AnsiColor::White: return "\x1b[37m"
            case AnsiColor::BrightBlack: return "\x1b[90m"
            case AnsiColor::BrightRed: return "\x1b[91m"
            case AnsiColor::BrightGreen: return "\x1b[92m"
            case AnsiColor::BrightYellow: return "\x1b[93m"
            case AnsiColor::BrightBlue: return "\x1b[94m"
            case AnsiColor::BrightMagenta: return "\x1b[95m"
            case AnsiColor::BrightCyan: return "\x1b[96m"
            case AnsiColor::BrightWhite: return "\x1b[97m"
            case AnsiColor::Rgb(r, g, b): return f"\x1b[38;2;{r};{g};{b}m"

    # Get ANSI background code
    pub fn bg_code(self) -> String:
        match self:
            case AnsiColor::Black: return "\x1b[40m"
            case AnsiColor::Red: return "\x1b[41m"
            case AnsiColor::Green: return "\x1b[42m"
            case AnsiColor::Yellow: return "\x1b[43m"
            case AnsiColor::Blue: return "\x1b[44m"
            case AnsiColor::Magenta: return "\x1b[45m"
            case AnsiColor::Cyan: return "\x1b[46m"
            case AnsiColor::White: return "\x1b[47m"
            case AnsiColor::BrightBlack: return "\x1b[100m"
            case AnsiColor::BrightRed: return "\x1b[101m"
            case AnsiColor::BrightGreen: return "\x1b[102m"
            case AnsiColor::BrightYellow: return "\x1b[103m"
            case AnsiColor::BrightBlue: return "\x1b[104m"
            case AnsiColor::BrightMagenta: return "\x1b[105m"
            case AnsiColor::BrightCyan: return "\x1b[106m"
            case AnsiColor::BrightWhite: return "\x1b[107m"
            case AnsiColor::Rgb(r, g, b): return f"\x1b[48;2;{r};{g};{b}m"

# Terminal buffer - double-buffered character grid
pub struct TermBuffer:
    width: u32
    height: u32
    front: Array[Array[TermCell]]
    back: Array[Array[TermCell]]
    cursor_x: u32
    cursor_y: u32

impl TermBuffer:
    pub fn new(width: u32, height: u32) -> TermBuffer:
        let mut front = []
        let mut back = []

        for y in 0..height:
            let mut row_front = []
            let mut row_back = []
            for x in 0..width:
                row_front.push(TermCell::empty())
                row_back.push(TermCell::empty())
            front.push(row_front)
            back.push(row_back)

        return TermBuffer {
            width: width,
            height: height,
            front: front,
            back: back,
            cursor_x: 0,
            cursor_y: 0
        }

    # Get cell at position (back buffer)
    pub fn get(self, x: u32, y: u32) -> Option[&mut TermCell]:
        if x >= self.width or y >= self.height:
            return None
        return Some(&mut self.back[y as usize][x as usize])

    # Set cell at position
    pub fn set(self, x: u32, y: u32, cell: TermCell):
        if let Some(target) = self.get(x, y):
            *target = cell

    # Write text at position
    pub fn write(self, x: u32, y: u32, text: &str):
        let mut cx = x
        for ch in text.chars():
            if cx >= self.width:
                break
            self.set(cx, y, TermCell::with_char(&ch.to_string()))
            cx += 1

    # Draw box at position
    pub fn draw_box(self, x: u32, y: u32, width: u32, height: u32):
        # Box drawing characters
        let tl = "┌"  # Top-left
        let tr = "┐"  # Top-right
        let bl = "└"  # Bottom-left
        let br = "┘"  # Bottom-right
        let h = "─"   # Horizontal
        let v = "│"   # Vertical

        # Top border
        self.set(x, y, TermCell::with_char(tl))
        for i in 1..(width - 1):
            self.set(x + i, y, TermCell::with_char(h))
        self.set(x + width - 1, y, TermCell::with_char(tr))

        # Sides
        for i in 1..(height - 1):
            self.set(x, y + i, TermCell::with_char(v))
            self.set(x + width - 1, y + i, TermCell::with_char(v))

        # Bottom border
        self.set(x, y + height - 1, TermCell::with_char(bl))
        for i in 1..(width - 1):
            self.set(x + i, y + height - 1, TermCell::with_char(h))
        self.set(x + width - 1, y + height - 1, TermCell::with_char(br))

    # Clear buffer
    pub fn clear(self):
        for y in 0..self.height:
            for x in 0..self.width:
                self.back[y as usize][x as usize] = TermCell::empty()

    # Swap buffers and generate diff
    pub fn present(self) -> String:
        let mut output = String::new()

        # Compare front and back buffers, only output differences
        for y in 0..self.height:
            for x in 0..self.width:
                let front_cell = &self.front[y as usize][x as usize]
                let back_cell = &self.back[y as usize][x as usize]

                if front_cell != back_cell:
                    # Move cursor
                    output.push_str(&f"\x1b[{y + 1};{x + 1}H")

                    # Apply styling
                    if back_cell.bold:
                        output.push_str("\x1b[1m")
                    if back_cell.italic:
                        output.push_str("\x1b[3m")
                    if back_cell.underline:
                        output.push_str("\x1b[4m")

                    # Apply colors
                    if let Some(fg) = &back_cell.fg_color:
                        output.push_str(&fg.fg_code())
                    if let Some(bg) = &back_cell.bg_color:
                        output.push_str(&bg.bg_code())

                    # Output character
                    output.push_str(&back_cell.char)

                    # Reset styling
                    output.push_str("\x1b[0m")

        # Swap buffers
        std::mem::swap(&mut self.front, &mut self.back)

        return output

# TUI Renderer implementation
pub struct TuiRenderer:
    viewport: Viewport
    buffer: TermBuffer
    initialized: bool

impl TuiRenderer:
    pub fn new() -> TuiRenderer:
        return TuiRenderer {
            viewport: Viewport::new(80, 24, 1.0),
            buffer: TermBuffer::new(80, 24),
            initialized: false
        }

    # Render an element to terminal buffer
    fn render_element(self, elem: &Element, x: u32, y: u32, max_width: u32, max_height: u32):
        match elem.kind:
            case ElementKind::Box:
                self.render_box(elem, x, y, max_width, max_height)
            case ElementKind::Text:
                self.render_text(elem, x, y, max_width)
            case ElementKind::Button:
                self.render_button(elem, x, y, max_width)
            case ElementKind::Input:
                self.render_input(elem, x, y, max_width)
            case _:
                # Default: render as text
                if let Some(text) = &elem.text:
                    self.buffer.write(x, y, text)

        # Render children (simplified layout)
        let mut child_y = y + 1
        for child in &elem.children:
            if child_y >= y + max_height:
                break
            self.render_element(child, x + 2, child_y, max_width - 2, max_height - (child_y - y))
            child_y += 2

    fn render_box(self, elem: &Element, x: u32, y: u32, width: u32, height: u32):
        self.buffer.draw_box(x, y, width.min(self.viewport.width - x), height.min(self.viewport.height - y))

    fn render_text(self, elem: &Element, x: u32, y: u32, max_width: u32):
        if let Some(text) = &elem.text:
            let truncated = if text.len() > max_width as usize:
                &text[0..(max_width as usize - 3)] + "..."
            else:
                text
            self.buffer.write(x, y, &truncated)

    fn render_button(self, elem: &Element, x: u32, y: u32, max_width: u32):
        let label = elem.text.as_ref().unwrap_or(&"".to_string())
        let button_text = f"[ {label} ]"
        self.buffer.write(x, y, &button_text)

    fn render_input(self, elem: &Element, x: u32, y: u32, max_width: u32):
        let value = elem.attrs.get("value").unwrap_or(&"".to_string())
        let placeholder = elem.attrs.get("placeholder").unwrap_or(&"".to_string())
        let text = if value.is_empty() { placeholder } else { value }

        self.buffer.write(x, y, "[")
        self.buffer.write(x + 1, y, text)
        self.buffer.write(x + max_width - 1, y, "]")

impl RenderBackend for TuiRenderer:
    fn init(self, viewport: Viewport) -> Result[(), String]:
        self.viewport = viewport
        self.buffer = TermBuffer::new(viewport.width, viewport.height)

        # Enable raw mode, alternate screen, etc.
        # In real implementation, would call termios/crossterm
        print("\x1b[?1049h")  # Enter alternate screen
        print("\x1b[?25l")    # Hide cursor

        self.initialized = true
        return Ok(())

    fn render(self, tree: &ElementTree, ctx: &RenderContext) -> RenderResult:
        if not self.initialized:
            return RenderResult::Error("Renderer not initialized".to_string())

        let start_time = 0.0  # Would use actual timer

        # Render element tree to buffer
        self.render_element(tree.root(), 0, 0, self.viewport.width, self.viewport.height)

        let metrics = RenderMetrics {
            render_time_ms: 0.0,  # Placeholder
            element_count: self.count_elements(tree.root()),
            draw_calls: 1
        }

        return RenderResult::Success(RenderOutput {
            data: String::new(),
            metrics: metrics
        })

    fn resize(self, viewport: Viewport):
        self.viewport = viewport
        self.buffer = TermBuffer::new(viewport.width, viewport.height)

    fn clear(self):
        self.buffer.clear()

    fn present(self):
        # Output diff to terminal
        let diff = self.buffer.present()
        print(&diff)

    fn shutdown(self):
        # Restore terminal state
        print("\x1b[?25h")    # Show cursor
        print("\x1b[?1049l")  # Exit alternate screen
        self.initialized = false

    fn capabilities(self) -> RendererCapabilities:
        return RendererCapabilities::limited()

impl TuiRenderer:
    fn count_elements(self, elem: &Element) -> u32:
        let mut count = 1u32
        for child in &elem.children:
            count += self.count_elements(child)
        return count

# Example usage:
#
# let renderer = TuiRenderer::new()
# let viewport = Viewport::new(80, 24, 1.0)
# renderer.init(viewport)?
#
# loop:
#     renderer.clear()
#     renderer.render(&element_tree, &ctx)?
#     renderer.present()
#
#     # Handle input events
#     if should_quit:
#         break
#
# renderer.shutdown()
