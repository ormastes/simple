# Events - UI Event System
#
# Platform-agnostic event types and handling for UI widgets.
# Supports mouse, keyboard, focus, and custom events.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*

# Event handler ID (unique identifier for registered handlers)
pub struct HandlerId:
    id: u64

impl HandlerId:
    pub fn new(id: u64) -> HandlerId:
        return HandlerId { id: id }

    pub fn value(self) -> u64:
        return self.id

# Mouse button enumeration
pub enum MouseButton:
    Left
    Right
    Middle
    Back
    Forward

# Keyboard key enumeration (common keys)
pub enum Key:
    # Letters
    A, B, C, D, E, F, G, H, I, J, K, L, M
    N, O, P, Q, R, S, T, U, V, W, X, Y, Z
    # Numbers
    Num0, Num1, Num2, Num3, Num4, Num5, Num6, Num7, Num8, Num9
    # Special keys
    Enter
    Escape
    Backspace
    Tab
    Space
    Delete
    Insert
    Home
    End
    PageUp
    PageDown
    # Arrow keys
    ArrowUp
    ArrowDown
    ArrowLeft
    ArrowRight
    # Function keys
    F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12
    # Modifiers
    Shift
    Control
    Alt
    Meta
    # Other
    CapsLock
    NumLock
    ScrollLock

impl Key:
    # Parse key from string
    pub fn from_string(s: &str) -> Option[Key]:
        match s:
            case "Enter": return Some(Key::Enter)
            case "Escape": return Some(Key::Escape)
            case "Backspace": return Some(Key::Backspace)
            case "Tab": return Some(Key::Tab)
            case " ": return Some(Key::Space)
            case "ArrowUp": return Some(Key::ArrowUp)
            case "ArrowDown": return Some(Key::ArrowDown)
            case "ArrowLeft": return Some(Key::ArrowLeft)
            case "ArrowRight": return Some(Key::ArrowRight)
            case _: return None

# Keyboard modifiers
pub struct KeyModifiers:
    pub shift: bool
    pub ctrl: bool
    pub alt: bool
    pub meta: bool

impl KeyModifiers:
    pub fn none() -> KeyModifiers:
        return KeyModifiers {
            shift: false,
            ctrl: false,
            alt: false,
            meta: false
        }

    pub fn has_modifiers(self) -> bool:
        return self.shift or self.ctrl or self.alt or self.meta

# Mouse event data
pub struct MouseEventData:
    pub button: MouseButton
    pub x: i32
    pub y: i32
    pub screen_x: i32
    pub screen_y: i32
    pub modifiers: KeyModifiers
    pub click_count: u32  # For detecting double/triple clicks

# Keyboard event data
pub struct KeyboardEventData:
    pub key: Key
    pub code: String  # Physical key code (e.g., "KeyA")
    pub char: Option[String]  # Character representation if printable
    pub modifiers: KeyModifiers
    pub repeat: bool

# Focus event data
pub struct FocusEventData:
    pub related_target: Option[NodeId]  # Element losing/gaining focus

# Input event data (for text input)
pub struct InputEventData:
    pub value: String
    pub selection_start: u32
    pub selection_end: u32

# Change event data (for form elements)
pub struct ChangeEventData:
    pub value: String
    pub checked: Option[bool]  # For checkboxes/radios

# Scroll event data
pub struct ScrollEventData:
    pub scroll_top: i32
    pub scroll_left: i32
    pub scroll_height: i32
    pub scroll_width: i32

# Resize event data
pub struct ResizeEventData:
    pub width: i32
    pub height: i32

# Custom event data
pub struct CustomEventData:
    pub detail: String  # JSON-encoded custom data

# Platform-agnostic event types
pub enum Event:
    # Mouse events
    Click(NodeId, MouseEventData)
    DoubleClick(NodeId, MouseEventData)
    MouseDown(NodeId, MouseEventData)
    MouseUp(NodeId, MouseEventData)
    MouseMove(NodeId, MouseEventData)
    MouseEnter(NodeId, MouseEventData)
    MouseLeave(NodeId, MouseEventData)
    ContextMenu(NodeId, MouseEventData)

    # Keyboard events
    KeyDown(NodeId, KeyboardEventData)
    KeyUp(NodeId, KeyboardEventData)
    KeyPress(NodeId, KeyboardEventData)

    # Focus events
    Focus(NodeId, FocusEventData)
    Blur(NodeId, FocusEventData)

    # Input events
    Input(NodeId, InputEventData)
    Change(NodeId, ChangeEventData)
    Submit(NodeId)

    # Scroll events
    Scroll(NodeId, ScrollEventData)

    # Resize events
    Resize(NodeId, ResizeEventData)

    # Custom events
    Custom(NodeId, String, CustomEventData)

impl Event:
    # Get the target element ID
    pub fn target_id(self) -> NodeId:
        match self:
            case Click(id, _): return id
            case DoubleClick(id, _): return id
            case MouseDown(id, _): return id
            case MouseUp(id, _): return id
            case MouseMove(id, _): return id
            case MouseEnter(id, _): return id
            case MouseLeave(id, _): return id
            case ContextMenu(id, _): return id
            case KeyDown(id, _): return id
            case KeyUp(id, _): return id
            case KeyPress(id, _): return id
            case Focus(id, _): return id
            case Blur(id, _): return id
            case Input(id, _): return id
            case Change(id, _): return id
            case Submit(id): return id
            case Scroll(id, _): return id
            case Resize(id, _): return id
            case Custom(id, _, _): return id

    # Get event type name
    pub fn type_name(self) -> &str:
        match self:
            case Click(_, _): return "click"
            case DoubleClick(_, _): return "dblclick"
            case MouseDown(_, _): return "mousedown"
            case MouseUp(_, _): return "mouseup"
            case MouseMove(_, _): return "mousemove"
            case MouseEnter(_, _): return "mouseenter"
            case MouseLeave(_, _): return "mouseleave"
            case ContextMenu(_, _): return "contextmenu"
            case KeyDown(_, _): return "keydown"
            case KeyUp(_, _): return "keyup"
            case KeyPress(_, _): return "keypress"
            case Focus(_, _): return "focus"
            case Blur(_, _): return "blur"
            case Input(_, _): return "input"
            case Change(_, _): return "change"
            case Submit(_): return "submit"
            case Scroll(_, _): return "scroll"
            case Resize(_, _): return "resize"
            case Custom(_, name, _): return name

# Event propagation control
pub enum PropagationStatus:
    Continue      # Continue propagating
    StopPropagation  # Stop bubbling/capturing
    StopImmediatePropagation  # Stop all handlers

# Event phase
pub enum EventPhase:
    Capturing  # Event travels down from root to target
    AtTarget   # Event is at the target element
    Bubbling   # Event bubbles up from target to root

# Event context (passed to handlers)
pub struct EventContext:
    pub event: Event
    pub phase: EventPhase
    pub current_target: NodeId
    pub propagation: PropagationStatus
    pub default_prevented: bool

impl EventContext:
    pub fn new(event: Event, phase: EventPhase, current_target: NodeId) -> EventContext:
        return EventContext {
            event: event,
            phase: phase,
            current_target: current_target,
            propagation: PropagationStatus::Continue,
            default_prevented: false
        }

    # Stop event propagation
    pub fn stop_propagation(self):
        self.propagation = PropagationStatus::StopPropagation

    # Stop immediate propagation
    pub fn stop_immediate_propagation(self):
        self.propagation = PropagationStatus::StopImmediatePropagation

    # Prevent default action
    pub fn prevent_default(self):
        self.default_prevented = true

# Event handler function type
pub type EventHandler = fn(&mut EventContext)

# Event listener with phase
pub struct EventListener:
    handler_id: HandlerId
    handler: EventHandler
    phase: EventPhase
    once: bool  # Remove after first invocation

impl EventListener:
    pub fn new(handler_id: HandlerId, handler: EventHandler) -> EventListener:
        return EventListener {
            handler_id: handler_id,
            handler: handler,
            phase: EventPhase::Bubbling,
            once: false
        }

    # Set to capture phase
    pub fn capture(self) -> EventListener:
        self.phase = EventPhase::Capturing
        return self

    # Set to run once
    pub fn once(self) -> EventListener:
        self.once = true
        return self

    # Invoke the handler
    pub fn invoke(self, ctx: &mut EventContext):
        (self.handler)(ctx)

# Event registry - manages event handlers
pub struct EventRegistry:
    # Map: (NodeId, event_type) -> Array[EventListener]
    listeners: Dict[(NodeId, String), Array[EventListener]]
    next_handler_id: u64

impl EventRegistry:
    pub fn new() -> EventRegistry:
        return EventRegistry {
            listeners: Dict::new(),
            next_handler_id: 0
        }

    # Register an event listener
    pub fn add_listener(
        self,
        target: NodeId,
        event_type: &str,
        handler: EventHandler
    ) -> HandlerId:
        let handler_id = HandlerId::new(self.next_handler_id)
        self.next_handler_id = self.next_handler_id + 1

        let listener = EventListener::new(handler_id, handler)
        let key = (target, event_type.to_string())

        match self.listeners.get_mut(&key):
            case Some(listeners):
                listeners.push(listener)
            case None:
                self.listeners.insert(key, [listener])

        return handler_id

    # Remove an event listener
    pub fn remove_listener(self, target: NodeId, event_type: &str, handler_id: HandlerId):
        let key = (target, event_type.to_string())
        if let Some(listeners) = self.listeners.get_mut(&key):
            listeners.retain(|l| l.handler_id.value() != handler_id.value())

    # Get listeners for an element and event type
    pub fn get_listeners(
        self,
        target: NodeId,
        event_type: &str
    ) -> Option[&Array[EventListener]]:
        let key = (target, event_type.to_string())
        return self.listeners.get(&key)

    # Dispatch an event through the DOM tree
    pub fn dispatch_event(self, event: Event, root: &Element) -> bool:
        let target_id = event.target_id()
        let event_type = event.type_name()

        # Build propagation path (root to target)
        let path = self.build_path(root, target_id)
        if path.is_empty():
            return false

        # Capturing phase (root to target)
        for i in 0..(path.len() - 1):
            let mut ctx = EventContext::new(event.clone(), EventPhase::Capturing, path[i])
            self.invoke_listeners(&mut ctx, path[i], event_type)

            if ctx.propagation != PropagationStatus::Continue:
                return ctx.default_prevented

        # At target phase
        let mut ctx = EventContext::new(event.clone(), EventPhase::AtTarget, target_id)
        self.invoke_listeners(&mut ctx, target_id, event_type)

        if ctx.propagation == PropagationStatus::StopImmediatePropagation:
            return ctx.default_prevented

        # Bubbling phase (target to root)
        for i in (0..(path.len() - 1)).rev():
            let mut ctx = EventContext::new(event.clone(), EventPhase::Bubbling, path[i])
            self.invoke_listeners(&mut ctx, path[i], event_type)

            if ctx.propagation != PropagationStatus::Continue:
                return ctx.default_prevented

        return ctx.default_prevented

    # Build path from root to target
    fn build_path(self, root: &Element, target_id: NodeId) -> Array[NodeId]:
        let mut path: Array[NodeId] = []
        self.find_path(root, target_id, &mut path)
        path.reverse()
        return path

    fn find_path(self, elem: &Element, target_id: NodeId, path: &mut Array[NodeId]) -> bool:
        if elem.id == target_id:
            path.push(elem.id)
            return true

        for child in &elem.children:
            if self.find_path(child, target_id, path):
                path.push(elem.id)
                return true

        return false

    # Invoke listeners for a node
    fn invoke_listeners(self, ctx: &mut EventContext, node_id: NodeId, event_type: &str):
        if let Some(listeners) = self.get_listeners(node_id, event_type):
            let mut to_remove: Array[HandlerId] = []

            for listener in listeners:
                if listener.phase == ctx.phase or ctx.phase == EventPhase::AtTarget:
                    listener.invoke(ctx)

                    if listener.once:
                        to_remove.push(listener.handler_id)

                    if ctx.propagation == PropagationStatus::StopImmediatePropagation:
                        break

            # Remove one-time listeners
            for handler_id in &to_remove:
                self.remove_listener(node_id, event_type, handler_id)

# Convenience functions for common event handlers

# Create a click handler
pub fn on_click(handler: fn()) -> EventHandler:
    return fn(ctx: &mut EventContext):
        handler()

# Create a input handler
pub fn on_input(handler: fn(String)) -> EventHandler:
    return fn(ctx: &mut EventContext):
        match &ctx.event:
            case Event::Input(_, data):
                handler(data.value.clone())
            case _: pass

# Create a change handler
pub fn on_change(handler: fn(String)) -> EventHandler:
    return fn(ctx: &mut EventContext):
        match &ctx.event:
            case Event::Change(_, data):
                handler(data.value.clone())
            case _: pass

# Create a key handler
pub fn on_key_down(handler: fn(Key, KeyModifiers)) -> EventHandler:
    return fn(ctx: &mut EventContext):
        match &ctx.event:
            case Event::KeyDown(_, data):
                handler(data.key, data.modifiers)
            case _: pass

# Create a submit handler
pub fn on_submit(handler: fn()) -> EventHandler:
    return fn(ctx: &mut EventContext):
        ctx.prevent_default()  # Prevent default form submission
        handler()
