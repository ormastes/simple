# State - Reactive State Management
#
# Provides reactive state containers that trigger UI updates when modified.
# Based on: doc/research/ui_framework_unified.md

use core.*

# Reactive state container
pub struct State[T]:
    value: T
    subscribers: Array[fn(T)]
    id: u64

impl[T] State[T]:
    # Create a new state with initial value
    pub fn new(initial: T) -> State[T]:
        return State {
            value: initial,
            subscribers: [],
            id: 0  # Would be generated in real implementation
        }

    # Get the current value
    pub fn get(self) -> &T:
        return &self.value

    # Set a new value and notify subscribers
    pub fn set(self, new_value: T):
        self.value = new_value
        self.notify()

    # Update value using a function
    pub fn update(self, updater: fn(&mut T)):
        updater(&mut self.value)
        self.notify()

    # Subscribe to state changes
    pub fn subscribe(self, handler: fn(T)):
        self.subscribers.push(handler)

    # Unsubscribe from state changes (by index)
    pub fn unsubscribe(self, index: usize):
        if index < self.subscribers.len():
            self.subscribers.remove(index)

    # Notify all subscribers of state change
    fn notify(self):
        for subscriber in &self.subscribers:
            subscriber(self.value.clone())

# Computed state - derived from other state
pub struct Computed[T]:
    compute_fn: fn() -> T
    value: Option[T]
    dependencies: Array[u64]  # IDs of dependent states

impl[T] Computed[T]:
    # Create a new computed state
    pub fn new(compute_fn: fn() -> T) -> Computed[T]:
        return Computed {
            compute_fn: compute_fn,
            value: None,
            dependencies: []
        }

    # Get the computed value (lazy evaluation)
    pub fn get(self) -> &T:
        if self.value.is_none():
            self.value = Some((self.compute_fn)())
        return self.value.as_ref().unwrap()

    # Invalidate cached value (called when dependencies change)
    pub fn invalidate(self):
        self.value = None

    # Add a dependency
    pub fn add_dependency(self, state_id: u64):
        if not self.dependencies.contains(&state_id):
            self.dependencies.push(state_id)

# Signal - lightweight reactive primitive
pub struct Signal[T]:
    value: T
    version: u64

impl[T] Signal[T]:
    # Create a new signal
    pub fn new(initial: T) -> Signal[T]:
        return Signal {
            value: initial,
            version: 0
        }

    # Get the current value
    pub fn get(self) -> &T:
        return &self.value

    # Set a new value
    pub fn set(self, new_value: T):
        self.value = new_value
        self.version = self.version + 1

    # Get the current version (for change tracking)
    pub fn version(self) -> u64:
        return self.version

# Effect - side effect that runs when dependencies change
pub struct Effect:
    effect_fn: fn()
    dependencies: Array[u64]
    last_run: u64

impl Effect:
    # Create a new effect
    pub fn new(effect_fn: fn()) -> Effect:
        return Effect {
            effect_fn: effect_fn,
            dependencies: [],
            last_run: 0
        }

    # Run the effect
    pub fn run(self):
        (self.effect_fn)()
        self.last_run = self.last_run + 1

    # Add a dependency
    pub fn add_dependency(self, state_id: u64):
        if not self.dependencies.contains(&state_id):
            self.dependencies.push(state_id)

# StateStore - centralized state management
pub struct StateStore:
    states: Dict[String, Box[dyn Any]]
    effects: Array[Effect]
    next_id: u64

impl StateStore:
    # Create a new state store
    pub fn new() -> StateStore:
        return StateStore {
            states: Dict::new(),
            effects: [],
            next_id: 0
        }

    # Register a state with a key
    pub fn register[T](self, key: &str, state: State[T]):
        self.states.insert(key.to_string(), Box::new(state))

    # Get a state by key
    pub fn get[T](self, key: &str) -> Option[&State[T]]:
        match self.states.get(key):
            case Some(boxed):
                # Would need proper type casting in real implementation
                return None  # Placeholder
            case None:
                return None

    # Register an effect
    pub fn add_effect(self, effect: Effect):
        self.effects.push(effect)

    # Run all effects
    pub fn run_effects(self):
        for effect in &mut self.effects:
            effect.run()

    # Allocate a unique ID
    pub fn alloc_id(self) -> u64:
        let id = self.next_id
        self.next_id = self.next_id + 1
        return id

# Ref - mutable reference to DOM element
pub struct Ref[T]:
    value: Option[T]

impl[T] Ref[T]:
    # Create a new empty ref
    pub fn new() -> Ref[T]:
        return Ref { value: None }

    # Get the current value
    pub fn get(self) -> Option[&T]:
        return self.value.as_ref()

    # Set the value
    pub fn set(self, value: T):
        self.value = Some(value)

    # Clear the value
    pub fn clear(self):
        self.value = None

# Context - shared data across widget tree
pub struct Context[T]:
    value: T
    key: String

impl[T] Context[T]:
    # Create a new context
    pub fn new(key: &str, value: T) -> Context[T]:
        return Context {
            value: value,
            key: key.to_string()
        }

    # Get the context value
    pub fn get(self) -> &T:
        return &self.value

    # Update the context value
    pub fn set(self, value: T):
        self.value = value

# ContextProvider - provides context to children
pub struct ContextProvider[T]:
    context: Context[T]
    children: Array[Box[Widget]]

impl[T] ContextProvider[T]:
    # Create a new context provider
    pub fn new(context: Context[T]) -> ContextProvider[T]:
        return ContextProvider {
            context: context,
            children: []
        }

    # Add a child widget
    pub fn child(self, widget: impl Widget) -> ContextProvider[T]:
        self.children.push(Box::new(widget))
        return self

# Hooks - functional state management utilities

# useState - create a state hook
pub fn use_state[T](initial: T) -> State[T]:
    return State::new(initial)

# useComputed - create a computed value
pub fn use_computed[T](compute_fn: fn() -> T) -> Computed[T]:
    return Computed::new(compute_fn)

# useEffect - create a side effect
pub fn use_effect(effect_fn: fn()) -> Effect:
    let effect = Effect::new(effect_fn)
    effect.run()  # Run immediately on creation
    return effect

# useRef - create a mutable reference
pub fn use_ref[T]() -> Ref[T]:
    return Ref::new()

# useContext - access context value
pub fn use_context[T](key: &str) -> Option[&T]:
    # Would need actual context lookup in real implementation
    return None

# Example usage:
#
# let count = use_state(0)
# let doubled = use_computed(|| count.get() * 2)
#
# use_effect(||:
#     print(f"Count changed to: {count.get()}")
# )
#
# Button::new("Increment")
#     .on_click(|| count.set(count.get() + 1))
