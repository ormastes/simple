# JSON-RPC Transport Layer
# Handles Content-Length protocol over stdin/stdout

import sys
import io.stdio as stdio
import core.json as json
import core.string as str

# Read a JSON-RPC message from stdin
# Messages use Content-Length header protocol:
#   Content-Length: 123\r\n
#   \r\n
#   {json payload}
fn read_message() -> Result<Dict, String>:
    # Read headers until we find Content-Length
    let mut content_length: Option<Int> = None

    loop:
        let line = stdio.read_line()?
        let trimmed = line.trim()

        # Empty line signals end of headers
        if trimmed.is_empty():
            break

        # Parse Content-Length header
        if trimmed.starts_with("Content-Length:"):
            let parts = trimmed.split(":")
            if parts.len() >= 2:
                let length_str = parts[1].trim()
                match length_str.parse_int():
                    case Ok(length):
                        content_length = Some(length)
                    case Err(e):
                        return Err(f"Invalid Content-Length: {e}")

        # Ignore other headers (Content-Type, etc.)

    # Ensure we got Content-Length
    match content_length:
        case None:
            return Err("Missing Content-Length header")
        case Some(length):
            # Read exactly 'length' bytes of JSON content
            let content = stdio.read_exact(length)?

            # Parse JSON
            match json.parse(content):
                case Ok(parsed):
                    # Ensure it's a dictionary
                    match parsed:
                        case Dict(dict):
                            return Ok(dict)
                        case _:
                            return Err("JSON payload is not an object")
                case Err(e):
                    return Err(f"JSON parse error: {e}")

# Write a JSON-RPC message to stdout
# Adds Content-Length header and proper formatting
fn write_message(data: Dict) -> Result<Nil, String>:
    # Serialize to JSON
    let json_str = json.stringify(data)?
    let content_bytes = json_str.as_bytes()
    let content_length = content_bytes.len()

    # Build message with headers
    let mut message = f"Content-Length: {content_length}\r\n"
    message = message + "\r\n"
    message = message + json_str

    # Write to stdout
    stdio.write(message)?
    stdio.flush()?

    Ok(nil)

# Write a JSON-RPC response
fn write_response(id: Int, result: Dict) -> Result<Nil, String>:
    let response = {
        "jsonrpc": "2.0",
        "id": id,
        "result": result
    }
    write_message(response)

# Write a JSON-RPC error response
fn write_error(id: Int, code: Int, message: String) -> Result<Nil, String>:
    let response = {
        "jsonrpc": "2.0",
        "id": id,
        "error": {
            "code": code,
            "message": message
        }
    }
    write_message(response)

# Write a JSON-RPC notification
fn write_notification(method: String, params: Dict) -> Result<Nil, String>:
    let notification = {
        "jsonrpc": "2.0",
        "method": method,
        "params": params
    }
    write_message(notification)

# Parse message type from raw JSON-RPC message
fn parse_message_type(data: Dict) -> Result<String, String>:
    # Check if it's a request (has 'id' and 'method')
    if data.contains_key("id") and data.contains_key("method"):
        return Ok("request")

    # Check if it's a response (has 'id' and 'result' or 'error')
    if data.contains_key("id"):
        if data.contains_key("result") or data.contains_key("error"):
            return Ok("response")

    # Check if it's a notification (has 'method' but no 'id')
    if data.contains_key("method") and not data.contains_key("id"):
        return Ok("notification")

    Err("Unknown message type")

# Helper: Log a message to stderr for debugging
fn log_debug(message: String):
    # Only log if SIMPLE_LSP_DEBUG is set
    match sys.env.get("SIMPLE_LSP_DEBUG"):
        case Some(_):
            stdio.write_stderr(f"[LSP DEBUG] {message}\n")
        case None:
            pass

# Helper: Log an error to stderr
fn log_error(message: String):
    stdio.write_stderr(f"[LSP ERROR] {message}\n")
