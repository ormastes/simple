# Custom Blocks API - Complete Examples
#
# This file demonstrates all three tiers of the custom blocks API:
# - Tier 1: Minimal API (block(), const_block())
# - Tier 2: Builder API (BlockBuilder)
# - Tier 3: Full trait (BlockDefinition)

use compiler.blocks.easy.{block, block_with_validation, const_block}
use compiler.blocks.builder.{BlockBuilder}
use compiler.blocks.utils.{parse_json, highlight_keywords, strip_indent}
use compiler.blocks.value.{BlockValue}
use compiler.blocks.registry.{register_block, with_block}
use compiler.blocks.definition.{BlockDefinition, ConstValue}

# ============================================================================
# Example 1: Heredoc Block (Tier 1 - Minimal)
# ============================================================================

fn example_heredoc():
    """Simple heredoc block with text trimming."""

    # Define block in 3 lines
    val heredoc = block("heredoc", LexerMode.Raw, \text:
        Ok(BlockValue.Raw(text.trim()))
    )

    # Use it
    with_block(heredoc, \:
        val doc = heredoc{
            This is a heredoc.
            Multiple lines supported.
            Leading/trailing whitespace trimmed.
        }

        print "Heredoc content:"
        print doc
    )

# ============================================================================
# Example 2: Color Literal (Tier 1 - With Validation)
# ============================================================================

fn example_color():
    """Color literal with hex validation."""

    val color = block_with_validation("color", LexerMode.Raw,
        # Parser
        \text:
            val hex = text.trim()
            if hex.starts_with("#") and hex.len() == 7:
                Ok(BlockValue.Custom("Color", hex))
            else:
                Err("Expected #RRGGBB color format")
        ,
        # Validator
        \value:
            match value:
                case Custom("Color", hex):
                    # Additional validation
                    if not is_valid_hex(hex[1:]):
                        ["Invalid hex color code"]
                    else:
                        []
                case _:
                    ["Invalid color value"]
    )

    with_block(color, \:
        # Valid color
        val bg = color{ #FF5733 }
        print "Background color: {bg}"

        # Invalid color would error
        # val bad = color{ invalid }
    )

fn is_valid_hex(s: text) -> bool:
    """Check if string is valid hex (0-9, A-F)."""
    s.len() == 6 and s.chars().all(\c:
        (c >= '0' and c <= '9') or (c >= 'A' and c <= 'F') or (c >= 'a' and c <= 'f')
    )

# ============================================================================
# Example 3: Regex with Compile-Time Eval (Tier 1 - Const)
# ============================================================================

fn example_regex():
    """Regex pattern compiled at compile time."""

    val re = const_block("re", LexerMode.Raw,
        # Parser
        \pattern:
            val compiled = compile_regex_pattern(pattern.trim())?
            Ok(BlockValue.Regex(compiled))
        ,
        # Compile-time evaluator
        \value:
            match value:
                case Regex(pattern): Some(ConstValue.String(pattern.raw))
                case _: nil
    )

    with_block(re, \:
        # Pattern compiled at compile time
        val email = re{ ^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$ }

        # Use it
        print email.matches("test@example.com")  # true
        print email.matches("invalid")           # false
    )

fn compile_regex_pattern(pattern: text) -> Result<RegexPattern, text>:
    """Placeholder regex compiler."""
    # TODO: Real regex compilation
    Ok(RegexPattern(raw: pattern, _handle: 0))

# ============================================================================
# Example 4: JSON Block (Tier 2 - Builder + Utils)
# ============================================================================

fn example_json():
    """JSON block using builder API and pre-built parser."""

    val json = BlockBuilder("json")
        .raw_text()
        .simple_parser(parse_json)  # Pre-built from utils
        .doc("Parse JSON data at compile time")
        .example('{"name": "Alice"}', "Simple object")
        .build()

    with_block(json, \:
        val data = json{
            {
                "name": "Alice",
                "age": 30,
                "city": "NYC"
            }
        }

        print "Name: {data.name}"
        print "Age: {data.age}"
    )

# ============================================================================
# Example 5: SQL Block (Tier 2 - Builder with Validation)
# ============================================================================

fn example_sql():
    """SQL block with PostgreSQL validation."""

    val sql = BlockBuilder("sql")
        .raw_text()
        .simple_parser(\text:
            parse_sql_query(text.trim())
        )
        .simple_validator(\value:
            match value:
                case Sql(query):
                    validate_sql_postgres(query)
                case _:
                    ["Expected SQL query"]
        )
        .highlighter(\text:
            highlight_keywords(text, [
                "SELECT", "FROM", "WHERE", "JOIN", "ORDER", "GROUP",
                "INSERT", "UPDATE", "DELETE", "CREATE", "ALTER", "DROP"
            ])
        )
        .build()

    with_block(sql, \:
        val users = sql{
            SELECT name, email, age
            FROM users
            WHERE age > 21
            ORDER BY name
        }

        print "Query table: {users.table}"
        print "Columns: {users.columns.join(", ")}"
    )

fn parse_sql_query(text: text) -> Result<BlockValue, text>:
    """Placeholder SQL parser."""
    # TODO: Real SQL parser
    Ok(BlockValue.Sql(SqlQuery(
        raw: text,
        kind: SqlKind.Select,
        tables: ["users"],
        columns: ["name", "email", "age"],
        params: []
    )))

fn validate_sql_postgres(query: SqlQuery) -> [text]:
    """Placeholder PostgreSQL validator."""
    # TODO: Real validation
    []

# ============================================================================
# Example 6: Tensor Math (Tier 2 - Builder with Math Features)
# ============================================================================

fn example_tensor():
    """Tensor expressions with math operators."""

    val tensor = BlockBuilder("tensor")
        .math_mode()
        .enable_all_math()  # ^, ', implicit mul, @, broadcast ops
        .simple_parser(\expr:
            parse_tensor_notation(expr)
        )
        .simple_validator(\value:
            check_tensor_dimensions(value)
        )
        .doc("Tensor expressions with matrix operations")
        .example("A @ B + C'", "Matrix multiply and transpose")
        .example("x^2 .+ y^2", "Element-wise operations")
        .build()

    with_block(tensor, \:
        # Use math operators
        val result = tensor{
            A @ B^2 + C' .* D
        }

        print "Tensor expression parsed"
        print "Operations: {result.ops.join(", ")}"
    )

fn parse_tensor_notation(expr: text) -> Result<BlockValue, text>:
    """Placeholder tensor parser."""
    Ok(BlockValue.Custom("Tensor", {
        "expr": expr,
        "ops": ["matrix_mul", "power", "transpose", "broadcast_mul"]
    }))

fn check_tensor_dimensions(value: BlockValue) -> [text]:
    """Placeholder dimension checker."""
    []

# ============================================================================
# Example 7: GraphQL (Tier 2 - Builder with Full IDE Support)
# ============================================================================

fn example_graphql():
    """GraphQL queries with IDE support."""

    val graphql = BlockBuilder("graphql")
        .raw_text()
        .simple_parser(\query:
            parse_graphql_query(query)
        )
        .highlighter(\text:
            highlight_graphql_syntax(text)
        )
        .completer(\text, cursor:
            complete_graphql_fields(text, cursor)
        )
        .hover_provider(\text, cursor:
            hover_graphql_types(text, cursor)
        )
        .doc("GraphQL queries with full IDE support")
        .example("""
            query GetUser($id: ID!) {
                user(id: $id) {
                    name
                    email
                }
            }
        """, "Parameterized query")
        .build()

    with_block(graphql, \:
        val query = graphql{
            query GetUser($id: ID!) {
                user(id: $id) {
                    name
                    email
                    posts {
                        title
                        createdAt
                    }
                }
            }
        }

        print "GraphQL query parsed"
        print "Operation: {query.operation}"
    )

# Placeholder GraphQL helpers
fn parse_graphql_query(text: text) -> Result<BlockValue, text>:
    Ok(BlockValue.Custom("GraphQL", {"operation": "query"}))

fn highlight_graphql_syntax(text: text) -> [HighlightToken]:
    []

fn complete_graphql_fields(text: text, cursor: i64) -> [Completion]:
    []

fn hover_graphql_types(text: text, cursor: i64) -> HoverInfo?:
    nil

# ============================================================================
# Example 8: Custom Math (Tier 3 - Full BlockDefinition)
# ============================================================================

struct CustomMathDef: BlockDefinition:
    """Advanced math block with custom lexer.

    Demonstrates full control using BlockDefinition trait.
    """

    fn kind() -> text:
        "custommath"

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        var features = SyntaxFeatures.math()
        features.custom_keywords = ["sum", "prod", "integral"]
        features

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Custom parsing logic
        val expr = parse_custom_math(payload)?
        Ok(BlockValue.Custom("CustomMath", expr))

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        # Custom validation
        match value:
            case Custom("CustomMath", expr):
                validate_math_expr(expr, ctx)
            case _:
                [BlockError.validation("Expected CustomMath expression")]

    fn eval_const(value: BlockValue) -> ConstValue?:
        # Try to evaluate at compile time
        match value:
            case Custom("CustomMath", expr):
                try_eval_math(expr)
            case _:
                nil

    fn highlight(payload: text) -> [HighlightToken]:
        # Custom syntax highlighting
        highlight_math_keywords(payload)

    fn description() -> text:
        "Advanced math block with custom operators and functions"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "sum(i=1..n) i^2",
                description: "Summation notation",
                output: Some("n*(n+1)*(2n+1)/6")
            ),
            BlockExample(
                code: "integral(0..1) x^2 dx",
                description: "Definite integral",
                output: Some("1/3")
            )
        ]

fn parse_custom_math(text: text) -> Result<Any, BlockError>:
    # Placeholder
    Ok({})

fn validate_math_expr(expr: Any, ctx: BlockContext) -> [BlockError]:
    []

fn try_eval_math(expr: Any) -> ConstValue?:
    nil

fn highlight_math_keywords(text: text) -> [HighlightToken]:
    []

fn example_custom_math():
    """Advanced math with custom keywords."""

    register_block(CustomMathDef())

    # Use custom math block
    val result = custommath{
        sum(i=1..10) i^2
    }

    print "Custom math result: {result}"

# ============================================================================
# Main - Run All Examples
# ============================================================================

fn main():
    print "=== Custom Blocks API Examples ===\n"

    print "Example 1: Heredoc"
    example_heredoc()
    print ""

    print "Example 2: Color Literal"
    example_color()
    print ""

    print "Example 3: Regex (Compile-Time)"
    example_regex()
    print ""

    print "Example 4: JSON (Builder + Utils)"
    example_json()
    print ""

    print "Example 5: SQL (Builder + Validation)"
    example_sql()
    print ""

    print "Example 6: Tensor Math (Builder + Math Features)"
    example_tensor()
    print ""

    print "Example 7: GraphQL (Full IDE Support)"
    example_graphql()
    print ""

    print "Example 8: Custom Math (Full Trait)"
    example_custom_math()
    print ""

    print "All examples completed!"

# ============================================================================
# Summary Table
# ============================================================================

"""
Block Examples Summary:

┌────────────┬─────────────────┬──────────┬────────────────────────┐
│ Block      │ Tier            │ Lines    │ Features               │
├────────────┼─────────────────┼──────────┼────────────────────────┤
│ heredoc    │ Minimal (1)     │ 3        │ Text trimming          │
│ color      │ Validation (1)  │ 15       │ Hex validation         │
│ re         │ Const (1)       │ 12       │ Compile-time eval      │
│ json       │ Builder (2)     │ 5        │ Pre-built parser       │
│ sql        │ Builder (2)     │ 15       │ Validation + highlight │
│ tensor     │ Builder (2)     │ 12       │ Math features          │
│ graphql    │ Builder (2)     │ 20       │ Full IDE support       │
│ custommath │ Full Trait (3)  │ 60       │ Custom everything      │
└────────────┴─────────────────┴──────────┴────────────────────────┘

Key Takeaways:
1. 80% of blocks need only Tier 1 (3-15 lines)
2. 15% benefit from Tier 2 builder (5-20 lines)
3. 5% require Tier 3 full trait (60+ lines)

Progressive disclosure works:
- Simple things remain simple
- Complex things are possible
- No unnecessary abstraction
"""
