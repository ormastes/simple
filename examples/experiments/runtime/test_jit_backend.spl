#!/usr/bin/env simple
# Test JIT backend infrastructure
#
# This tests:
# 1. Can we create JIT execution managers?
# 2. Can we switch backends (Cranelift/LLVM)?
# 3. What's currently working?

use compiler.execution.mod (LocalExecutionManager, set_jit_backend, get_jit_backend)

fn test_backend_control():
    print "=== Testing JIT Backend Control ==="

    val original = get_jit_backend()
    print "Original backend: {original}"

    set_jit_backend("cranelift")
    val current = get_jit_backend()
    print "After setting cranelift: {current}"

    # Restore
    set_jit_backend(original)
    print "Restored to: {get_jit_backend()}"

fn test_execution_manager_creation():
    print "\n=== Testing Execution Manager Creation ==="

    # Test Cranelift backend
    val em_cran = LocalExecutionManager.cranelift()
    print "Cranelift backend: {em_cran.backend_name()}"
    print "Has function 'main': {em_cran.has_function(\"main\")}"
    em_cran.cleanup()

    # Test auto-selection
    val em_auto = LocalExecutionManager.auto_select()
    print "Auto-selected backend: {em_auto.backend_name()}"
    em_auto.cleanup()

fn test_mir_compilation():
    print "\n=== Testing MIR Compilation ==="

    val em = LocalExecutionManager.cranelift()

    # Note: We can't test actual compilation without MIR data
    # The exec_manager expects MIR (mid-level IR), not Simple source

    print "To actually compile, we need:"
    print "  1. Simple source code"
    print "  2. Compile to MIR (using existing compiler pipeline)"
    print "  3. Serialize MIR to string format"
    print "  4. Pass to exec_manager.compile()"
    print ""
    print "The full pipeline exists in Rust, but needs Simple wrappers"

    em.cleanup()

fn main():
    test_backend_control()
    test_execution_manager_creation()
    test_mir_compilation()

    print "\n=== Summary ==="
    print "✓ JIT backend control works (set/get)"
    print "✓ Execution manager creation works"
    print "✓ Cranelift JIT backend is available"
    print ""
    print "Next steps to test value semantics in JIT mode:"
    print "  1. Need Simple → MIR compilation wrapper"
    print "  2. Need MIR serialization to string"
    print "  3. Then can compile autograd with JIT"
    print "  4. Test if JIT has reference semantics"

main()
