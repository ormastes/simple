# Performance Tools Demo
# Demonstrates profiling, benchmarking, and optimization analysis

import perf.profiler
import perf.benchmark

# Example 1: Profiling regions of code
fn demo_profiling():
    print "=== Profiling Demo ==="
    print ""

    profiler.init_profiler()

    # Profile different operations
    profiler.profile_region("fibonacci", \:
        fibonacci(20)
    )

    profiler.profile_region("array_ops", \:
        var arr = []
        for i in 0..1000:
            arr.push(i * 2)
        arr.sum()
    )

    profiler.profile_region("dict_ops", \:
        var dict = {}
        for i in 0..1000:
            dict[i.to_string()] = i * 2
    )

    # Print profile report
    profiler.print_profile()
    print ""

    # Show optimization suggestions
    val suggestions = profiler.analyze_hotspots()
    if not suggestions.is_empty():
        print "Optimization Suggestions:"
        for sugg in suggestions:
            print "  {sugg}"

fn fibonacci(n: i64) -> i64:
    if n <= 1:
        return n
    fibonacci(n - 1) + fibonacci(n - 2)

# Example 2: Benchmarking
fn demo_benchmarking():
    print "=== Benchmarking Demo ==="
    print ""

    var suite = benchmark.BenchSuite.create("Performance Tests")

    # Benchmark 1: Array vs List operations
    val result1 = suite.run_bench("array_push", 1000, \:
        var arr = []
        for i in 0..100:
            arr.push(i)
    )
    suite.add_result(result1)

    # Benchmark 2: Dict lookup
    var test_dict = {}
    for i in 0..100:
        test_dict[i.to_string()] = i

    val result2 = suite.run_bench("dict_lookup", 1000, \:
        for i in 0..100:
            val _ = test_dict[i.to_string()]
    )
    suite.add_result(result2)

    # Benchmark 3: String concatenation
    val result3 = suite.run_bench("string_concat", 1000, \:
        var s = ""
        for i in 0..50:
            s = s + "x"
    )
    suite.add_result(result3)

    # Benchmark 4: String builder (faster)
    val result4 = suite.run_bench("string_join", 1000, \:
        var parts = []
        for i in 0..50:
            parts.push("x")
        parts.join("")
    )
    suite.add_result(result4)

    # Print results
    print suite.report()

    # Save results
    suite.save("benchmark_results.json")

# Example 3: Using benchmark helper
fn demo_simple_benchmark():
    print "=== Simple Benchmark Demo ==="
    print ""

    # Quick benchmark without full suite
    profiler.benchmark("quick_sort", 100, \:
        val arr = [5, 2, 8, 1, 9, 3, 7, 4, 6]
        quick_sort(arr)
    )

fn quick_sort(arr: List<i64>) -> List<i64>:
    if arr.len() <= 1:
        return arr

    val pivot = arr[arr.len() / 2]
    val less = arr.filter(\x: x < pivot)
    val equal = arr.filter(\x: x == pivot)
    val greater = arr.filter(\x: x > pivot)

    quick_sort(less).merge(equal).merge(quick_sort(greater))

# Example 4: Performance comparison
fn demo_comparison():
    print "=== Performance Comparison Demo ==="
    print ""

    print "Comparing different approaches to summing array:"
    print ""

    val test_arr = [for i in 0..1000: i]

    # Approach 1: Manual loop
    profiler.benchmark("manual_loop", 100, \:
        var sum = 0
        for x in test_arr:
            sum = sum + x
    )

    # Approach 2: Built-in sum
    profiler.benchmark("builtin_sum", 100, \:
        test_arr.sum()
    )

    # Approach 3: Reduce
    profiler.benchmark("reduce", 100, \:
        test_arr.reduce(0, \acc, x: acc + x)
    )

# Main entry point
fn main():
    print "Simple Performance Tools Demo"
    print "=" * 60
    print ""

    demo_profiling()
    print "\n"

    demo_benchmarking()
    print "\n"

    demo_simple_benchmark()
    print "\n"

    demo_comparison()
    print "\n"

    print "=" * 60
    print "Demo complete!"
    print ""
    print "Try analyzing this file with:"
    print "  simple perf optimize examples/perf_demo.spl"
