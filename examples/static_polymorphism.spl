# Static Polymorphism Example
# Demonstrates interface bindings for static dispatch optimization

# Define a Logger trait
trait Logger:
    fn log(self, msg: str)
    fn level(self) -> i32

# Console logger implementation
struct ConsoleLogger:
    prefix: str

impl Logger for ConsoleLogger:
    fn log(self, msg: str):
        print("{self.prefix}: {msg}")

    fn level(self) -> i32:
        return 1

# File logger implementation
struct FileLogger:
    path: str

impl Logger for FileLogger:
    fn log(self, msg: str):
        # Would write to file
        pass

    fn level(self) -> i32:
        return 2

# Interface binding - binds Logger trait to ConsoleLogger
# This enables static dispatch optimization
bind Logger = ConsoleLogger

# With the binding above, type inference knows:
# - When Logger is used, resolve to ConsoleLogger
# - Calls to Logger methods can be statically dispatched

fn main():
    # Type inference resolves 'logger' to ConsoleLogger due to binding
    let logger = ConsoleLogger(prefix: "APP")

    # This call can be statically dispatched (monomorphized)
    # because the binding tells the compiler the concrete type
    logger.log("Hello, static polymorphism!")

    print("Logger level: {logger.level()}")
