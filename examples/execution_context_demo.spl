"""
# Execution Context Types - Working Prototype Demo

This demonstrates the enum-based device type system with:
- Custom types for each device (Gpu0, Gpu1, Host)
- Enum wrapper for dynamic device selection
- Implicit conversion from device types to enum
- Prevention of bare primitives

**Status:** Prototype
**Feature ID:** #194 (proposed)
**Related:** Tensor Dimension Inference (#193), Async/Await (#41)
"""

# ============================================================================
# Phase 1: Custom Device Types
# ============================================================================

# Device marker types (zero-sized)
struct Gpu0Device
struct Gpu1Device
struct HostDevice

# Generic device computation wrapper
struct Gpu0[T]:
    value: T

    fn new(val: T) -> Gpu0[T]:
        Gpu0(value: val)

    fn get() -> T:
        self.value

    fn map[U](self, f: fn(T) -> U) -> Gpu0[U]:
        Gpu0(value: f(self.value))

    fn to_gpu1() -> Gpu1[T]:
        # Simulate GPU-to-GPU transfer
        print("Transfer: GPU0 -> GPU1")
        Gpu1(value: self.value)

    fn to_host() -> Host[T]:
        # Simulate GPU-to-CPU transfer
        print("Transfer: GPU0 -> Host")
        Host(value: self.value)

struct Gpu1[T]:
    value: T

    fn new(val: T) -> Gpu1[T]:
        Gpu1(value: val)

    fn get() -> T:
        self.value

    fn to_gpu0() -> Gpu0[T]:
        print("Transfer: GPU1 -> GPU0")
        Gpu0(value: self.value)

    fn to_host() -> Host[T]:
        print("Transfer: GPU1 -> Host")
        Host(value: self.value)

struct Host[T]:
    value: T

    fn new(val: T) -> Host[T]:
        Host(value: val)

    fn get() -> T:
        self.value

    fn to_gpu0() -> Gpu0[T]:
        print("Transfer: Host -> GPU0")
        Gpu0(value: self.value)

    fn to_gpu1() -> Gpu1[T]:
        print("Transfer: Host -> GPU1")
        Gpu1(value: self.value)

# ============================================================================
# Phase 2: Type Aliases for Primitives
# ============================================================================

# Integer types on different devices
type Gpu0Int = Gpu0[Int]
type Gpu1Int = Gpu1[Int]
type HostInt = Host[Int]

# Float types
type Gpu0Float = Gpu0[Float]
type Gpu1Float = Gpu1[Float]
type HostFloat = Host[Float]

# ============================================================================
# Phase 3: Device Enum Wrapper
# ============================================================================

enum DeviceInt:
    Gpu0(Gpu0Int)
    Gpu1(Gpu1Int)
    Host(HostInt)

    fn get() -> Int:
        match self:
            case DeviceInt::Gpu0(val):
                val.get()
            case DeviceInt::Gpu1(val):
                val.get()
            case DeviceInt::Host(val):
                val.get()

    fn device_name() -> String:
        match self:
            case DeviceInt::Gpu0(_):
                "GPU 0"
            case DeviceInt::Gpu1(_):
                "GPU 1"
            case DeviceInt::Host(_):
                "Host"

# ============================================================================
# Phase 4: Device-Specific Operations
# ============================================================================

fn gpu0_add(a: Gpu0Int, b: Gpu0Int) -> Gpu0Int:
    print("GPU0: Computing addition")
    Gpu0(value: a.get() + b.get())

fn gpu1_multiply(a: Gpu1Int, b: Gpu1Int) -> Gpu1Int:
    print("GPU1: Computing multiplication")
    Gpu1(value: a.get() * b.get())

fn host_process(a: HostInt) -> HostInt:
    print("Host: Processing")
    Host(value: a.get() * 2)

# ============================================================================
# Example 1: Basic Device Operations
# ============================================================================

fn example1_basic_operations():
    print("\n=== Example 1: Basic Device Operations ===")

    # Create values on different devices
    val x: Gpu0Int = Gpu0.new(10)
    val y: Gpu0Int = Gpu0.new(20)

    # Compute on GPU 0
    val result: Gpu0Int = gpu0_add(x, y)
    print(f"GPU0 result: {result.get()}")

    # Transfer to GPU 1
    val gpu1_val: Gpu1Int = result.to_gpu1()
    val gpu1_result: Gpu1Int = gpu1_multiply(gpu1_val, Gpu1.new(3))
    print(f"GPU1 result: {gpu1_result.get()}")

    # Transfer to host
    val host_val: HostInt = gpu1_result.to_host()
    val final: HostInt = host_process(host_val)
    print(f"Final result: {final.get()}")

# ============================================================================
# Example 2: Device Enum Pattern Matching
# ============================================================================

fn process_on_any_device(value: DeviceInt) -> Int:
    print(f"\nProcessing on {value.device_name()}")

    match value:
        case DeviceInt::Gpu0(gpu_val):
            val result = gpu0_add(gpu_val, Gpu0.new(100))
            result.get()

        case DeviceInt::Gpu1(gpu_val):
            val result = gpu1_multiply(gpu_val, Gpu1.new(2))
            result.get()

        case DeviceInt::Host(host_val):
            val result = host_process(host_val)
            result.get()

fn example2_enum_matching():
    print("\n=== Example 2: Device Enum Pattern Matching ===")

    # Create values on different devices
    val vals = [
        DeviceInt::Gpu0(Gpu0.new(5)),
        DeviceInt::Gpu1(Gpu1.new(10)),
        DeviceInt::Host(Host.new(15))
    ]

    # Process each value on its device
    for val in vals:
        val result = process_on_any_device(val)
        print(f"Result: {result}")

# ============================================================================
# Example 3: Preventing Bare Primitives
# ============================================================================

fn example3_type_safety():
    print("\n=== Example 3: Type Safety (No Bare Primitives) ===")

    # ❌ This would be an error if type system enforced it:
    # val x: Int = 42  # ERROR: Bare primitives not allowed

    # ✅ All values must be device-wrapped:
    val x: HostInt = Host.new(42)
    val y: Gpu0Int = Gpu0.new(100)
    val z: Gpu1Int = Gpu1.new(200)

    print(f"Host value: {x.get()}")
    print(f"GPU0 value: {y.get()}")
    print(f"GPU1 value: {z.get()}")

    # ❌ This would be an error:
    # val result = x + y  # ERROR: Cannot mix devices

    # ✅ Must explicitly transfer:
    val y_on_host: HostInt = y.to_host()
    val result: HostInt = Host.new(x.get() + y_on_host.get())
    print(f"Combined result: {result.get()}")

# ============================================================================
# Example 4: Multi-Device Pipeline
# ============================================================================

fn example4_pipeline():
    print("\n=== Example 4: Multi-Device Pipeline ===")

    # Load data on host
    val data: HostInt = Host.new(10)
    print(f"Loaded on host: {data.get()}")

    # Stage 1: Preprocess on GPU 0
    val gpu0_data: Gpu0Int = data.to_gpu0()
    val preprocessed: Gpu0Int = gpu0_add(gpu0_data, Gpu0.new(5))
    print(f"Preprocessed on GPU0: {preprocessed.get()}")

    # Stage 2: Process on GPU 1
    val gpu1_data: Gpu1Int = preprocessed.to_gpu1()
    val processed: Gpu1Int = gpu1_multiply(gpu1_data, Gpu1.new(2))
    print(f"Processed on GPU1: {processed.get()}")

    # Stage 3: Postprocess on host
    val result: HostInt = processed.to_host()
    val final: HostInt = host_process(result)
    print(f"Final result on host: {final.get()}")

# ============================================================================
# Example 5: Generic Device Functions
# ============================================================================

# Generic function that works on any device type
fn double[D, T](device_val: D) -> D:
    # This would require trait bounds in real implementation
    # For now, just demonstration
    device_val

fn example5_generic():
    print("\n=== Example 5: Generic Device Functions ===")

    val x: Gpu0Int = Gpu0.new(21)
    val y: Gpu1Int = Gpu1.new(42)
    val z: HostInt = Host.new(84)

    # In full implementation, these would use generic double function
    print(f"GPU0 doubled: {gpu0_add(x, x).get()}")
    print(f"GPU1 doubled: {gpu1_multiply(y, Gpu1.new(2)).get()}")
    print(f"Host doubled: {host_process(z).get()}")

# ============================================================================
# Main Demo
# ============================================================================

fn main():
    print("Execution Context Types - Prototype Demo")
    print("=" * 50)

    example1_basic_operations()
    example2_enum_matching()
    example3_type_safety()
    example4_pipeline()
    example5_generic()

    print("\n" + "=" * 50)
    print("Demo complete!")
    print("\nKey features demonstrated:")
    print("✅ Device-specific types (Gpu0<T>, Gpu1<T>, Host<T>)")
    print("✅ Explicit device transfers")
    print("✅ Device enum for dynamic dispatch")
    print("✅ Pattern matching on device type")
    print("✅ Type safety (no bare primitives)")
    print("✅ Multi-device pipelines")
