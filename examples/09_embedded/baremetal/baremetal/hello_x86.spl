# Simple x86 Bare-Metal "Hello World"
#
# This is a minimal x86 bare-metal kernel that:
# - Boots via multiboot
# - Writes "Hello, x86!" to VGA text buffer
# - Halts the CPU
#
# Build: simple build examples/baremetal/hello_x86.spl --bare-metal -o hello_x86.elf
# Run: qemu-system-i386 -kernel hello_x86.elf -serial stdio -nographic

# VGA text buffer at 0xB8000
val VGA_BUFFER: u32 = 0xB8000
val VGA_WIDTH: u32 = 80
val VGA_HEIGHT: u32 = 25

# VGA color codes
val COLOR_WHITE_ON_BLACK: u8 = 0x0F

# Write a character to VGA buffer
fn vga_put_char(x: u32, y: u32, ch: u8, color: u8):
    val offset = (y * VGA_WIDTH + x) * 2
    val addr = VGA_BUFFER + offset

    unsafe:
        # Write character
        *(addr as ptr<u8>) = ch
        # Write color attribute
        *((addr + 1) as ptr<u8>) = color

# Write a string to VGA buffer
fn vga_print(x: u32, y: u32, msg: text):
    var col = x
    for ch in msg:
        if col >= VGA_WIDTH:
            break
        vga_put_char(col, y, ch as u8, COLOR_WHITE_ON_BLACK)
        col += 1

# Clear the screen
fn vga_clear():
    for y in 0..VGA_HEIGHT:
        for x in 0..VGA_WIDTH:
            vga_put_char(x, y, ' ' as u8, COLOR_WHITE_ON_BLACK)

# Halt the CPU
@naked
fn halt():
    asm:
        "cli"           # Disable interrupts
        ".loop:"
        "hlt"           # Halt CPU
        "jmp .loop"     # Loop forever
        options: [volatile, noreturn]

# Kernel main function (called from boot code)
fn kernel_main():
    # Clear screen
    vga_clear()

    # Print hello message
    vga_print(0, 0, "Hello, x86!")
    vga_print(0, 1, "Simple bare-metal kernel running in QEMU")
    vga_print(0, 2, "Press Ctrl+A then X to exit QEMU")

    # Halt
    halt()

# Multiboot header (required for GRUB/QEMU to boot)
@section(".multiboot")
struct MultibootHeader:
    magic: u32        # 0x1BADB002
    flags: u32        # 0
    checksum: u32     # -(magic + flags)

@section(".multiboot")
val MULTIBOOT_HEADER: MultibootHeader = MultibootHeader(
    magic: 0x1BADB002,
    flags: 0,
    checksum: 0 - (0x1BADB002 + 0)  # Will be computed at compile time
)

# Boot entry point
@section(".text.boot")
@naked
fn _start():
    asm:
        # Set up stack (16KB stack)
        "movl $(stack + 16384), %esp"

        # Push multiboot info pointer (in EBX)
        "pushl %ebx"

        # Push multiboot magic (in EAX)
        "pushl %eax"

        # Call kernel main
        "call kernel_main"

        # If kernel_main returns, halt
        "cli"
        ".halt:"
        "hlt"
        "jmp .halt"
        options: [volatile, noreturn]

# Stack space (16KB)
@section(".bss.stack")
var STACK: [u8; 16384] = [0; 16384]
