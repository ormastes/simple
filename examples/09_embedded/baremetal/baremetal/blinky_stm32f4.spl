# LED Blink for STM32F407 Discovery Board
#
# This example blinks the 4 LEDs on the STM32F407 Discovery board.
# LEDs are on GPIOD pins 12-15.
#
# Build: simple build examples/baremetal/blinky_stm32f4.spl --bare-metal --board=stm32f407_discovery -o blinky.elf
# Run: qemu-system-arm -machine lm3s6965evb -kernel blinky.elf -serial stdio -nographic

# ===========================================================================
# Hardware Definitions
# ===========================================================================

# RCC (Reset and Clock Control) registers
@address(0x40023800)
@volatile
struct RccRegs:
    cr: u32          # Clock control
    pllcfgr: u32     # PLL configuration
    cfgr: u32        # Clock configuration
    cir: u32         # Clock interrupt
    ahb1rstr: u32    # AHB1 peripheral reset
    ahb2rstr: u32    # AHB2 peripheral reset
    ahb3rstr: u32    # AHB3 peripheral reset
    _reserved0: u32
    apb1rstr: u32    # APB1 peripheral reset
    apb2rstr: u32    # APB2 peripheral reset
    _reserved1: [u32; 2]
    ahb1enr: u32     # AHB1 peripheral clock enable
    ahb2enr: u32     # AHB2 peripheral clock enable
    ahb3enr: u32     # AHB3 peripheral clock enable

val RCC: ptr<RccRegs> = 0x40023800 as ptr<RccRegs>

# GPIO registers
@repr(C)
struct GpioRegs:
    moder: u32       # Mode register
    otyper: u32      # Output type register
    ospeedr: u32     # Output speed register
    pupdr: u32       # Pull-up/pull-down register
    idr: u32         # Input data register
    odr: u32         # Output data register
    bsrr: u32        # Bit set/reset register
    lckr: u32        # Configuration lock register
    afrl: u32        # Alternate function low register
    afrh: u32        # Alternate function high register

@address(0x40020C00)
@volatile
val GPIOD: ptr<GpioRegs>

# LED pin definitions
val LED_GREEN: u32 = 12   # PD12
val LED_ORANGE: u32 = 13  # PD13
val LED_RED: u32 = 14     # PD14
val LED_BLUE: u32 = 15    # PD15

# ===========================================================================
# Delay Function
# ===========================================================================

fn delay_cycles(cycles: u32):
    var count = cycles
    while count > 0:
        count -= 1
        # Inline assembly to prevent optimization
        asm:
            "nop"
            options: [volatile]

fn delay_ms(ms: u32):
    # Assumes 168MHz clock, rough approximation
    delay_cycles(ms * 42000)

# ===========================================================================
# GPIO Functions
# ===========================================================================

fn gpio_init():
    unsafe:
        # Enable GPIOD clock (bit 3 in AHB1ENR)
        RCC.ahb1enr = RCC.ahb1enr | (1 << 3)

        # Configure PD12-15 as output (mode = 01)
        val moder = GPIOD.moder
        GPIOD.moder = (moder & 0x00FFFFFF) | 0x55000000

        # Set output speed to high (speed = 11)
        val ospeedr = GPIOD.ospeedr
        GPIOD.ospeedr = (ospeedr & 0x00FFFFFF) | 0xFF000000

        # Set output type to push-pull (default, bit = 0)
        # No pull-up/pull-down (default, bits = 00)

fn led_on(pin: u32):
    unsafe:
        # Set bit in ODR
        GPIOD.odr = GPIOD.odr | (1 << pin)

fn led_off(pin: u32):
    unsafe:
        # Clear bit in ODR
        GPIOD.odr = GPIOD.odr & !(1 << pin)

fn led_toggle(pin: u32):
    unsafe:
        # Toggle bit in ODR
        GPIOD.odr = GPIOD.odr xor (1 << pin)

# ===========================================================================
# Main Function
# ===========================================================================

fn main():
    # Initialize GPIO
    gpio_init()

    # Blink pattern: rotate through LEDs
    var led = LED_GREEN

    loop:
        # Turn on current LED
        led_on(led)
        delay_ms(200)

        # Turn off current LED
        led_off(led)
        delay_ms(50)

        # Move to next LED
        led += 1
        if led > LED_BLUE:
            led = LED_GREEN

# ===========================================================================
# Interrupt Handlers
# ===========================================================================

@interrupt
fn reset_handler():
    # Call main
    main()

    # If main returns, halt
    loop:
        asm:
            "wfi"  # Wait for interrupt
            options: [volatile]

@interrupt
fn nmi_handler():
    loop:
        asm:
            "wfi"
            options: [volatile]

@interrupt
fn hard_fault_handler():
    loop:
        asm:
            "wfi"
            options: [volatile]

# ===========================================================================
# Vector Table
# ===========================================================================

@section(".vector_table")
@address(0x00000000)
val VECTOR_TABLE: [u32; 256] = [
    0x20020000,                    # 0: Initial stack pointer (128KB RAM)
    reset_handler as u32,          # 1: Reset
    nmi_handler as u32,            # 2: NMI
    hard_fault_handler as u32,     # 3: HardFault
    0,                             # 4: MemManage
    0,                             # 5: BusFault
    0,                             # 6: UsageFault
    0, 0, 0, 0,                    # 7-10: Reserved
    0,                             # 11: SVCall
    0,                             # 12: Debug Monitor
    0,                             # 13: Reserved
    0,                             # 14: PendSV
    0,                             # 15: SysTick
    # External interrupts (240 total for Cortex-M4)
    # ... (remaining entries default to 0)
]
