# Example: Strongly-Typed Mixins for Lean Verification
# This file demonstrates mixin features that should generate Lean proofs

# Basic mixin with fields
mixin Timestamp:
    var created_at: i64
    var updated_at: i64

    fn update_timestamp():
        self.updated_at = current_time()

# Generic mixin with type parameter
mixin Cache<T>:
    var cache: HashMap<String, T>

    fn get_cached(key: String) -> Option<T>:
        return self.cache.get(key)

    fn set_cache(key: String, value: T):
        self.cache.insert(key, value)

# Mixin with trait requirements
mixin Serializable where Self: Serialize + Deserialize:
    fn to_json() -> String:
        return serialize(self)

    fn from_json(json: String) -> Result<Self, Error>:
        return deserialize(json)

# Mixin with required methods (abstract methods)
mixin Repository<T, E>:
    required fn connection() -> DbConnection
    required fn table_name() -> String

    fn find_by_id(id: i64) -> Result<T, E>:
        let conn = self.connection()
        let table = self.table_name()
        return conn.query(table, id)

    fn save(entity: T) -> Result<(), E>:
        let conn = self.connection()
        let table = self.table_name()
        return conn.insert(table, entity)

# Class using mixins
class User:
    impl Serialize
    impl Deserialize

    var id: i64
    var name: String
    var email: String

# Service class with multiple mixins
class UserService:
    use Timestamp
    use Cache<User>
    use Serializable

    var users: Vec<User>

    fn get_user(id: i64) -> Option<User>:
        # Try cache first
        let key = id.to_string()
        if let Some(user) = self.get_cached(key):
            return Some(user)
        
        # Load from storage
        let user = self.load_user(id)?
        self.set_cache(key, user)
        return Some(user)

    fn load_user(id: i64) -> Option<User>:
        for user in self.users:
            if user.id == id:
                return Some(user)
        return None

# Repository implementation with mixin
class UserRepository:
    use Repository<User, DbError>
    use Timestamp

    var db: DbConnection

    # Implement required methods
    fn connection() -> DbConnection:
        return self.db

    fn table_name() -> String:
        return "users"

    # Additional methods
    fn find_by_email(email: String) -> Result<User, DbError>:
        let conn = self.connection()
        return conn.query_one("SELECT * FROM users WHERE email = ?", email)

# Verify properties with contracts
class AuditedDocument:
    use Timestamp

    var content: String
    var version: i64

    fn update_content(new_content: String):
        requires self.version >= 0
        ensures self.version == old(self.version) + 1
        ensures self.updated_at > old(self.updated_at)
        
        self.content = new_content
        self.version += 1
        self.update_timestamp()
