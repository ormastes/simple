# Result Type - Represents success or failure
# Core type for error handling

enum Result[T, E]:
    Ok(T)
    Err(E)

impl Result[T, E]:
    # Check result status
    fn is_ok() -> bool:
        match self:
            case Ok(_): return true
            case Err(_): return false

    fn is_err() -> bool:
        return not self.is_ok()

    # Unwrap with panic on Err
    fn unwrap() -> T:
        match self:
            case Ok(v): return v
            case Err(e): panic(f"called unwrap on Err: {e}")

    # Unwrap error with panic on Ok
    fn unwrap_err() -> E:
        match self:
            case Ok(v): panic(f"called unwrap_err on Ok: {v}")
            case Err(e): return e

    # Unwrap with default value
    fn unwrap_or(default: T) -> T:
        match self:
            case Ok(v): return v
            case Err(_): return default

    # Unwrap with lazy default
    fn unwrap_or_else(f: fn(E) -> T) -> T:
        match self:
            case Ok(v): return v
            case Err(e): return f(e)

    # Expect with custom message
    fn expect(msg: str) -> T:
        match self:
            case Ok(v): return v
            case Err(e): panic(f"{msg}: {e}")

    fn expect_err(msg: str) -> E:
        match self:
            case Ok(v): panic(f"{msg}: {v}")
            case Err(e): return e

    # Map the Ok value
    fn map[U](self, f: fn(T) -> U) -> Result[U, E]:
        match self:
            case Ok(v): return Ok(f(v))
            case Err(e): return Err(e)

    # Map the Err value
    fn map_err[F](self, f: fn(E) -> F) -> Result[T, F]:
        match self:
            case Ok(v): return Ok(v)
            case Err(e): return Err(f(e))

    # Flat map (and_then)
    fn and_then[U](self, f: fn(T) -> Result[U, E]) -> Result[U, E]:
        match self:
            case Ok(v): return f(v)
            case Err(e): return Err(e)

    # Or combinator
    fn or(other: Result[T, E]) -> Result[T, E]:
        match self:
            case Ok(_): return self
            case Err(_): return other

    # Or with lazy evaluation
    fn or_else[F](self, f: fn(E) -> Result[T, F]) -> Result[T, F]:
        match self:
            case Ok(v): return Ok(v)
            case Err(e): return f(e)

    # Convert Ok to Option
    fn ok() -> Option[T]:
        match self:
            case Ok(v): return Some(v)
            case Err(_): return None

    # Convert Err to Option
    fn err() -> Option[E]:
        match self:
            case Ok(_): return None
            case Err(e): return Some(e)

    # Get references
    fn as_ref() -> Result[&T, &E]:
        match self:
            case Ok(v): return Ok(&v)
            case Err(e): return Err(&e)

    # Transpose Result[Option[T], E] to Option[Result[T, E]]
    fn transpose(self: Result[Option[T], E]) -> Option[Result[T, E]]:
        match self:
            case Ok(Some(v)): return Some(Ok(v))
            case Ok(None): return None
            case Err(e): return Some(Err(e))

    # Flatten nested Result
    fn flatten(self: Result[Result[T, E], E]) -> Result[T, E]:
        match self:
            case Ok(inner): return inner
            case Err(e): return Err(e)

    # Check if Ok matches predicate
    fn is_ok_and(f: fn(&T) -> bool) -> bool:
        match self:
            case Ok(v): return f(&v)
            case Err(_): return false

    # Check if Err matches predicate
    fn is_err_and(f: fn(&E) -> bool) -> bool:
        match self:
            case Ok(_): return false
            case Err(e): return f(&e)

# Helper functions
fn ok[T, E](value: T) -> Result[T, E]:
    return Ok(value)

fn err[T, E](error: E) -> Result[T, E]:
    return Err(error)

# Try macro support - propagate errors with ?
# Usage: val value = risky_operation()?
# Expands to:
#   match risky_operation():
#       case Ok(v): v
#       case Err(e): return Err(e)
