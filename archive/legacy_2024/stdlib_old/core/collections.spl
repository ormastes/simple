# Collection Traits - Shared interfaces for List, Array, Slice, String
# Enables generic programming over sequential containers
# Similar to C#'s IList<T>, ICollection<T>, IEnumerable<T>

use core.traits.*

# ============================================
# Index Error Type
# ============================================

enum IndexError:
    OutOfBounds(index: usize, len: usize)

impl IndexError:
    fn message(self) -> str:
        match self:
            case OutOfBounds(i, l): f"index {i} out of bounds (len={l})"

impl Display for IndexError:
    fn fmt(self) -> str:
        self.message()

impl Error for IndexError

# ============================================
# Iterable - Base iteration trait
# ============================================

trait Iterable[T]:
    type Iter: Iterator[Item=T]

    fn iter(self) -> Self::Iter
    fn into_iter(self) -> Self::Iter

# ============================================
# Collection - Sized container with containment check
# ============================================

trait Collection[T]: Iterable[T] + Len:
    fn contains(self, item: &T) -> bool where T: Eq:
        for x in self.iter():
            if x.eq(item):
                return true
        false

    fn count_matching(self, predicate: fn(&T) -> bool) -> usize:
        var n: usize = 0
        for x in self.iter():
            if predicate(&x):
                n = n + 1
        n

# ============================================
# Sequence - Indexed read access
# ============================================

trait Sequence[T]: Collection[T]:
    # Safe indexed access - returns None if out of bounds
    fn get(self, idx: usize) -> Option[T]

    # First element
    fn first(self) -> Option[T]:
        self.get(0)

    # Last element
    fn last(self) -> Option[T]:
        if self.is_empty():
            None
        else:
            self.get(self.len() - 1)

    # Find first element matching predicate
    fn find(self, predicate: fn(&T) -> bool) -> Option[T]:
        for item in self.iter():
            if predicate(&item):
                return Some(item)
        None

    # Find index of first matching element
    fn find_index(self, predicate: fn(&T) -> bool) -> Option[usize]:
        var idx: usize = 0
        for item in self.iter():
            if predicate(&item):
                return Some(idx)
            idx = idx + 1
        None

    # Find position of item (alias for find_index with equality)
    fn position(self, item: &T) -> Option[usize] where T: Eq:
        self.find_index(|x| x.eq(item))

    # Get slice of range
    fn slice(self, start: usize, end: usize) -> Slice[T]

    # Get slice from start to end
    fn slice_from(self, start: usize) -> Slice[T]:
        self.slice(start, self.len())

    # Get slice from 0 to end
    fn slice_to(self, end: usize) -> Slice[T]:
        self.slice(0, end)

    # Iterate with index
    fn enumerate(self) -> Enumerate[Self::Iter]:
        Enumerate::new(self.iter())

    # Check if all elements match predicate
    fn all(self, predicate: fn(&T) -> bool) -> bool:
        for item in self.iter():
            if not predicate(&item):
                return false
        true

    # Check if any element matches predicate
    fn any(self, predicate: fn(&T) -> bool) -> bool:
        for item in self.iter():
            if predicate(&item):
                return true
        false

    # Fold/reduce from left
    fn fold[U](self, init: U, f: fn(U, T) -> U) -> U:
        var acc = init
        for item in self.iter():
            acc = f(acc, item)
        acc

    # Sum elements (requires Add and Default)
    fn sum(self) -> T where T: Add[Output=T] + Default:
        self.fold(T::default(), |acc, x| acc + x)

    # Product of elements (requires Mul and numeric one)
    fn product(self) -> T where T: Mul[Output=T] + Default:
        self.fold(T::default(), |acc, x| acc * x)

    # Maximum element
    fn max(self) -> Option[T] where T: Ord:
        if self.is_empty():
            return None
        var result = self.first().expect("not empty")
        for item in self.iter():
            if item.gt(&result):
                result = item
        Some(result)

    # Minimum element
    fn min(self) -> Option[T] where T: Ord:
        if self.is_empty():
            return None
        var result = self.first().expect("not empty")
        for item in self.iter():
            if item.lt(&result):
                result = item
        Some(result)

# ============================================
# MutSequence - Mutable indexed access
# ============================================

trait MutSequence[T]: Sequence[T]:
    # Mutable reference access
    fn get_mut(self, idx: usize) -> Option[&mut T]

    # Set value at index, returns error if out of bounds
    fn set(self, idx: usize, value: T) -> Result[(), IndexError]

    # Swap two elements
    fn swap(self, i: usize, j: usize) -> Result[(), IndexError]:
        if i >= self.len():
            return Err(IndexError::OutOfBounds(i, self.len()))
        if j >= self.len():
            return Err(IndexError::OutOfBounds(j, self.len()))
        if i != j:
            let tmp = self.get(i).expect("bounds checked")
            self.set(i, self.get(j).expect("bounds checked"))?
            self.set(j, tmp)?
        Ok(())

    # Fill all elements with value
    fn fill(self, value: T) where T: Clone:
        for i in 0..self.len():
            self.set(i, value.clone()).expect("valid index")

    # Fill with values from function
    fn fill_with(self, f: fn(usize) -> T):
        for i in 0..self.len():
            self.set(i, f(i)).expect("valid index")

    # In-place sort (requires Ord)
    fn sort(self) where T: Ord

    # In-place reverse
    fn reverse(self):
        if self.len() < 2:
            return
        var left: usize = 0
        var right = self.len() - 1
        while left < right:
            self.swap(left, right).expect("valid indices")
            left = left + 1
            right = right - 1

    # Retain only elements matching predicate
    fn retain(self, predicate: fn(&T) -> bool)

    # Get mutable slice
    fn as_mut_slice(self) -> MutSlice[T]

# ============================================
# ImmutSequence - Functional update operations (return new)
# ============================================

trait ImmutSequence[T]: Sequence[T]:
    type Output: Sequence[T]

    # Return new sequence with updated index
    fn with_index(self, idx: usize, value: T) -> Option[Self::Output]

    # Return new sorted sequence
    fn sorted(self) -> Self::Output where T: Ord

    # Return new reversed sequence
    fn reversed(self) -> Self::Output

    # Return new filtered sequence (elements matching predicate)
    fn filtered(self, predicate: fn(&T) -> bool) -> Self::Output

    # Return new mapped sequence
    fn mapped[U](self, f: fn(T) -> U) -> Self::Output

    # Return new sequence with element appended
    fn appended(self, item: T) -> Self::Output

    # Return new sequence with element prepended
    fn prepended(self, item: T) -> Self::Output

    # Take first n elements
    fn taken(self, n: usize) -> Self::Output

    # Drop first n elements
    fn dropped(self, n: usize) -> Self::Output

    # Take while predicate is true
    fn taken_while(self, predicate: fn(&T) -> bool) -> Self::Output

    # Drop while predicate is true
    fn dropped_while(self, predicate: fn(&T) -> bool) -> Self::Output

# ============================================
# Growable - Can add/remove elements dynamically
# ============================================

trait Growable[T]: MutSequence[T]:
    # Add element to end
    fn push(self, item: T)

    # Remove and return last element
    fn pop(self) -> Option[T]

    # Add element to front
    fn push_front(self, item: T)

    # Remove and return first element
    fn pop_front(self) -> Option[T]

    # Insert element at index
    fn insert(self, idx: usize, item: T) -> Result[(), IndexError]

    # Remove element at index
    fn remove(self, idx: usize) -> Option[T]

    # Remove all elements
    fn clear(self)

    # Extend with elements from iterator
    fn extend[I: IntoIterator[Item=T]](self, iter: I):
        for item in iter:
            self.push(item)

    # Append all elements from another collection
    fn append[C: Sequence[T]](self, other: C) where T: Clone:
        for item in other.iter():
            self.push(item.clone())

    # Truncate to length
    fn truncate(self, len: usize):
        while self.len() > len:
            self.pop()

    # Resize to length, filling with value if needed
    fn resize(self, new_len: usize, value: T) where T: Clone:
        if new_len < self.len():
            self.truncate(new_len)
        else:
            while self.len() < new_len:
                self.push(value.clone())

# ============================================
# Sliceable - Can create slice views
# ============================================

trait Sliceable[T]:
    fn as_slice(self) -> Slice[T]

# ============================================
# MutSliceable - Can create mutable slice views
# ============================================

trait MutSliceable[T]: Sliceable[T]:
    fn as_mut_slice(self) -> MutSlice[T]

# ============================================
# Enumerate Iterator Wrapper
# ============================================

struct Enumerate[I]:
    iter: I
    index: usize

impl Enumerate[I]:
    fn new(iter: I) -> Enumerate[I]:
        Enumerate { iter: iter, index: 0 }

impl Iterator for Enumerate[I] where I: Iterator:
    type Item = (usize, I::Item)

    fn next(self) -> Option[Self::Item]:
        match self.iter.next():
            case Some(item):
                let idx = self.index
                self.index = self.index + 1
                Some((idx, item))
            case None:
                None

# ============================================
# Slice Type - Borrowed view into a sequence
# ============================================

struct Slice[T]:
    ptr: *T
    len: usize

impl Slice[T]:
    fn new(ptr: *T, len: usize) -> Slice[T]:
        Slice { ptr: ptr, len: len }

    fn empty() -> Slice[T]:
        Slice { ptr: nil, len: 0 }

impl Len for Slice[T]:
    fn len(self) -> usize:
        self.len

impl Iterable[T] for Slice[T]:
    type Iter = SliceIter[T]

    fn iter(self) -> Self::Iter:
        SliceIter { slice: self, index: 0 }

    fn into_iter(self) -> Self::Iter:
        self.iter()

impl Collection[T] for Slice[T]

impl Sequence[T] for Slice[T]:
    fn get(self, idx: usize) -> Option[T]:
        if idx < self.len:
            danger:
                Some(self.ptr.offset(idx as isize).read())
        else:
            None

    fn slice(self, start: usize, end: usize) -> Slice[T]:
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.ptr.offset(start as isize), end - start)

impl Sliceable[T] for Slice[T]:
    fn as_slice(self) -> Slice[T]:
        self

# Slice iterator
struct SliceIter[T]:
    slice: Slice[T]
    index: usize

impl Iterator for SliceIter[T]:
    type Item = T

    fn next(self) -> Option[Self::Item]:
        if self.index < self.slice.len:
            let item = self.slice.get(self.index).expect("valid index")
            self.index = self.index + 1
            Some(item)
        else:
            None

impl ExactSizeIterator for SliceIter[T]:
    fn len(self) -> usize:
        self.slice.len - self.index

# ============================================
# MutSlice Type - Mutable borrowed view
# ============================================

struct MutSlice[T]:
    ptr: *mut T
    len: usize

impl MutSlice[T]:
    fn new(ptr: *mut T, len: usize) -> MutSlice[T]:
        MutSlice { ptr: ptr, len: len }

impl Len for MutSlice[T]:
    fn len(self) -> usize:
        self.len

impl Iterable[T] for MutSlice[T]:
    type Iter = MutSliceIter[T]

    fn iter(self) -> Self::Iter:
        MutSliceIter { slice: self, index: 0 }

    fn into_iter(self) -> Self::Iter:
        self.iter()

impl Collection[T] for MutSlice[T]

impl Sequence[T] for MutSlice[T]:
    fn get(self, idx: usize) -> Option[T]:
        if idx < self.len:
            danger:
                Some(self.ptr.offset(idx as isize).read())
        else:
            None

    fn slice(self, start: usize, end: usize) -> Slice[T]:
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.ptr.offset(start as isize) as *T, end - start)

impl MutSequence[T] for MutSlice[T]:
    fn get_mut(self, idx: usize) -> Option[&mut T]:
        if idx < self.len:
            danger:
                Some(&mut *self.ptr.offset(idx as isize))
        else:
            None

    fn set(self, idx: usize, value: T) -> Result[(), IndexError]:
        if idx >= self.len:
            return Err(IndexError::OutOfBounds(idx, self.len))
        danger:
            self.ptr.offset(idx as isize).write(value)
        Ok(())

    fn sort(self) where T: Ord:
        # Insertion sort for simplicity
        for i in 1..self.len:
            var j = i
            while j > 0:
                let curr = self.get(j).expect("valid")
                let prev = self.get(j - 1).expect("valid")
                if curr.lt(&prev):
                    self.swap(j, j - 1).expect("valid")
                    j = j - 1
                else:
                    break

    fn retain(self, predicate: fn(&T) -> bool):
        # MutSlice cannot change size, this is a no-op placeholder
        pass

    fn as_mut_slice(self) -> MutSlice[T]:
        self

impl Sliceable[T] for MutSlice[T]:
    fn as_slice(self) -> Slice[T]:
        danger:
            Slice::new(self.ptr as *T, self.len)

impl MutSliceable[T] for MutSlice[T]:
    fn as_mut_slice(self) -> MutSlice[T]:
        self

# MutSlice iterator
struct MutSliceIter[T]:
    slice: MutSlice[T]
    index: usize

impl Iterator for MutSliceIter[T]:
    type Item = T

    fn next(self) -> Option[Self::Item]:
        if self.index < self.slice.len:
            let item = self.slice.get(self.index).expect("valid index")
            self.index = self.index + 1
            Some(item)
        else:
            None
