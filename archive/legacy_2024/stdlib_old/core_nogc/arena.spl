# Arena Allocator - Region-based memory allocation
# All allocations are freed together when the arena is dropped

use units.size.*

# Arena allocator for bulk allocations
pub struct Arena:
    chunks: Array<ArenaChunk>
    current_chunk: u64
    offset: u64
    default_chunk_size: ByteCount

# Internal chunk storage
struct ArenaChunk:
    data: *mut u8
    size: ByteCount
    used: ByteCount

impl Arena:
    # Create new arena with default chunk size (64 KiB)
    pub fn new() -> Arena:
        return Arena::with_chunk_size(64_kib.to_bytes())

    # Create arena with custom chunk size
    pub fn with_chunk_size(size: ByteCount) -> Arena:
        val arena = Arena {
            chunks: [],
            current_chunk: 0,
            offset: 0,
            default_chunk_size: size
        }
        arena.grow(size)
        return arena

    # Allocate memory from arena
    pub fn alloc(self, size: ByteCount, align: u64) -> *mut u8:
        val aligned_offset = self.align_offset(align)
        val required = aligned_offset + (size as u64)

        # Check if current chunk has space
        if self.current_chunk < self.chunks.len():
            val chunk = &self.chunks[self.current_chunk]
            if required <= (chunk.size as u64):
                val ptr = chunk.data.offset(aligned_offset as isize)
                self.offset = required
                return ptr

        # Need new chunk
        val chunk_size = size.max(self.default_chunk_size)
        self.grow(chunk_size)
        return self.alloc(size, align)

    # Allocate and zero memory
    pub fn alloc_zeroed(self, size: ByteCount, align: u64) -> *mut u8:
        val ptr = self.alloc(size, align)
        native_memset(ptr, 0, size as u64)
        return ptr

    # Allocate typed value
    pub fn alloc_val<T>(self) -> *mut T:
        val size = size_of<T>()_bytes
        val align = align_of<T>()
        return self.alloc(size, align) as *mut T

    # Allocate array of typed values
    pub fn alloc_array<T>(self, count: u64) -> *mut T:
        val size = (size_of<T>() * count)_bytes
        val align = align_of<T>()
        return self.alloc(size, align) as *mut T

    # Allocate and copy value
    pub fn alloc_copy<T: Copy>(self, value: &T) -> *mut T:
        val ptr = self.alloc_val<T>()
        *ptr = *value
        return ptr

    # Allocate string
    pub fn alloc_str(self, s: &str) -> ArenaStr:
        val len = s.len()
        val ptr = self.alloc((len + 1)_bytes, 1)
        native_memcpy(ptr, s.as_ptr(), len)
        ptr.offset(len as isize).write(0_u8)  # null terminator
        return ArenaStr { ptr: ptr, len: len }

    # Reset arena (reuse memory without freeing)
    pub fn reset(self):
        self.current_chunk = 0
        self.offset = 0
        for chunk in &mut self.chunks:
            chunk.used = 0_bytes

    # Get total allocated bytes
    pub fn allocated(self) -> ByteCount:
        var total: u64 = 0
        for chunk in &self.chunks:
            total = total + (chunk.size as u64)
        return total_bytes

    # Get used bytes
    pub fn used(self) -> ByteCount:
        var total: u64 = 0
        for i in 0..self.current_chunk:
            total = total + (self.chunks[i].used as u64)
        total = total + self.offset
        return total_bytes

    # Internal: grow arena with new chunk
    fn grow(min_size: ByteCount):
        val size = min_size.max(self.default_chunk_size)
        val data = native_alloc(size as u64, 16)
        val chunk = ArenaChunk {
            data: data,
            size: size,
            used: 0_bytes
        }
        self.chunks.push(chunk)
        self.current_chunk = self.chunks.len() - 1
        self.offset = 0

    # Internal: align offset
    fn align_offset(align: u64) -> u64:
        val mask = align - 1
        return (self.offset + mask) & ~mask

    # Drop - free all chunks
    fn drop():
        for chunk in &self.chunks:
            native_free(chunk.data)

# Arena-allocated string (null-terminated)
pub struct ArenaStr:
    ptr: *const u8
    len: u64

impl ArenaStr:
    pub fn as_str(self) -> &str:
        return str::from_raw_parts(self.ptr, self.len)

    pub fn len(self) -> u64:
        return self.len

    pub fn is_empty(self) -> bool:
        return self.len == 0

    pub fn as_ptr(self) -> *const u8:
        return self.ptr

# Typed arena for single type allocations
pub struct TypedArena<T>:
    arena: Arena
    count: u64

impl TypedArena<T>:
    pub fn new() -> TypedArena<T>:
        return TypedArena {
            arena: Arena::new(),
            count: 0
        }

    pub fn with_capacity(capacity: u64) -> TypedArena<T>:
        val size = (size_of<T>() * capacity)_bytes
        return TypedArena {
            arena: Arena::with_chunk_size(size),
            count: 0
        }

    pub fn alloc(self) -> *mut T:
        self.count = self.count + 1
        return self.arena.alloc_val<T>()

    pub fn alloc_copy(self, value: &T) -> *mut T where T: Copy:
        self.count = self.count + 1
        return self.arena.alloc_copy(value)

    pub fn len(self) -> u64:
        return self.count

    pub fn reset(self):
        self.arena.reset()
        self.count = 0

# Scoped arena - automatically resets on scope exit
pub struct ScopedArena:
    arena: &mut Arena
    saved_chunk: u64
    saved_offset: u64

impl ScopedArena:
    pub fn new(arena: &mut Arena) -> ScopedArena:
        return ScopedArena {
            arena: arena,
            saved_chunk: arena.current_chunk,
            saved_offset: arena.offset
        }

    pub fn alloc(self, size: ByteCount, align: u64) -> *mut u8:
        return self.arena.alloc(size, align)

    pub fn alloc_val<T>(self) -> *mut T:
        return self.arena.alloc_val<T>()

    fn drop():
        # Restore arena state
        self.arena.current_chunk = self.saved_chunk
        self.arena.offset = self.saved_offset

# Native function declarations
extern fn native_alloc(size: u64, align: u64) -> *mut u8
extern fn native_free(ptr: *mut u8)
extern fn native_memset(ptr: *mut u8, value: u8, size: u64)
extern fn native_memcpy(dst: *mut u8, src: *const u8, size: u64)
extern fn size_of<T>() -> u64
extern fn align_of<T>() -> u64
