# UDP Networking - Async UDP sockets

use units.net.*
use units.size.*
use units.time.*
use host.common.io.error.IoError

# UDP Socket
pub struct UdpSocket:
    handle: i64
    local_addr: SocketAddr

impl UdpSocket:
    # Bind to address
    pub async fn bind(addr: SocketAddr) -> Result<UdpSocket, IoError>:
        val handle = native_udp_bind(addr)?
        return Ok(UdpSocket {
            handle: handle,
            local_addr: addr
        })

    # Bind to IP and port
    pub async fn bind_to(ip: IpAddr, port: Port) -> Result<UdpSocket, IoError>:
        return UdpSocket::bind(SocketAddr::new(ip, port))

    # Bind to any available port
    pub async fn bind_any() -> Result<UdpSocket, IoError>:
        return UdpSocket::bind("0.0.0.0:0"_sock)

    # Connect to remote (filters incoming and sets default destination)
    pub async fn connect(self, addr: SocketAddr) -> Result<(), IoError>:
        return native_udp_connect(self.handle, addr)

    # Receive data with source address
    pub async fn recv_from(self, buf: &mut Bytes) -> Result<(ByteCount, SocketAddr), IoError>:
        return native_udp_recv_from(self.handle, buf)

    # Receive data (connected socket only)
    pub async fn recv(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return native_udp_recv(self.handle, buf)

    # Send data to specific address
    pub async fn send_to(self, data: &Bytes, addr: SocketAddr) -> Result<ByteCount, IoError>:
        return native_udp_send_to(self.handle, data, addr)

    # Send data (connected socket only)
    pub async fn send(self, data: &Bytes) -> Result<ByteCount, IoError>:
        return native_udp_send(self.handle, data)

    # Peek data without consuming
    pub async fn peek_from(self, buf: &mut Bytes) -> Result<(ByteCount, SocketAddr), IoError>:
        return native_udp_peek_from(self.handle, buf)

    pub async fn peek(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return native_udp_peek(self.handle, buf)

    # Get addresses
    pub fn local_addr(self) -> SocketAddr:
        return self.local_addr

    pub fn peer_addr(self) -> Result<SocketAddr, IoError>:
        return native_udp_peer_addr(self.handle)

    # Set options
    pub fn set_broadcast(self, broadcast: bool) -> Result<(), IoError>:
        return native_udp_set_broadcast(self.handle, broadcast)

    pub fn set_multicast_loop(self, on: bool) -> Result<(), IoError>:
        return native_udp_set_multicast_loop(self.handle, on)

    pub fn set_multicast_ttl(self, ttl: u32) -> Result<(), IoError>:
        return native_udp_set_multicast_ttl(self.handle, ttl)

    pub fn set_ttl(self, ttl: u32) -> Result<(), IoError>:
        return native_udp_set_ttl(self.handle, ttl)

    pub fn set_read_timeout(self, timeout: Option<Duration>) -> Result<(), IoError>:
        return native_udp_set_read_timeout(self.handle, timeout)

    pub fn set_write_timeout(self, timeout: Option<Duration>) -> Result<(), IoError>:
        return native_udp_set_write_timeout(self.handle, timeout)

    # Get options
    pub fn broadcast(self) -> Result<bool, IoError>:
        return native_udp_get_broadcast(self.handle)

    pub fn ttl(self) -> Result<u32, IoError>:
        return native_udp_get_ttl(self.handle)

    # Multicast
    pub fn join_multicast_v4(self, multiaddr: Ipv4Addr, interface: Ipv4Addr) -> Result<(), IoError>:
        return native_udp_join_multicast_v4(self.handle, multiaddr, interface)

    pub fn leave_multicast_v4(self, multiaddr: Ipv4Addr, interface: Ipv4Addr) -> Result<(), IoError>:
        return native_udp_leave_multicast_v4(self.handle, multiaddr, interface)

    pub fn join_multicast_v6(self, multiaddr: Ipv6Addr, interface: u32) -> Result<(), IoError>:
        return native_udp_join_multicast_v6(self.handle, multiaddr, interface)

    pub fn leave_multicast_v6(self, multiaddr: Ipv6Addr, interface: u32) -> Result<(), IoError>:
        return native_udp_leave_multicast_v6(self.handle, multiaddr, interface)

    # Close socket
    pub async fn close(self) -> Result<(), IoError>:
        return native_udp_close(self.handle)

# Native function declarations
extern fn native_udp_bind(addr: SocketAddr) -> Result<i64, IoError>
extern fn native_udp_connect(handle: i64, addr: SocketAddr) -> Result<(), IoError>
extern fn native_udp_recv_from(handle: i64, buf: &mut Bytes) -> Result<(ByteCount, SocketAddr), IoError>
extern fn native_udp_recv(handle: i64, buf: &mut Bytes) -> Result<ByteCount, IoError>
extern fn native_udp_send_to(handle: i64, data: &Bytes, addr: SocketAddr) -> Result<ByteCount, IoError>
extern fn native_udp_send(handle: i64, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_udp_peek_from(handle: i64, buf: &mut Bytes) -> Result<(ByteCount, SocketAddr), IoError>
extern fn native_udp_peek(handle: i64, buf: &mut Bytes) -> Result<ByteCount, IoError>
extern fn native_udp_peer_addr(handle: i64) -> Result<SocketAddr, IoError>
extern fn native_udp_set_broadcast(handle: i64, broadcast: bool) -> Result<(), IoError>
extern fn native_udp_set_multicast_loop(handle: i64, on: bool) -> Result<(), IoError>
extern fn native_udp_set_multicast_ttl(handle: i64, ttl: u32) -> Result<(), IoError>
extern fn native_udp_set_ttl(handle: i64, ttl: u32) -> Result<(), IoError>
extern fn native_udp_set_read_timeout(handle: i64, timeout: Option<Duration>) -> Result<(), IoError>
extern fn native_udp_set_write_timeout(handle: i64, timeout: Option<Duration>) -> Result<(), IoError>
extern fn native_udp_get_broadcast(handle: i64) -> Result<bool, IoError>
extern fn native_udp_get_ttl(handle: i64) -> Result<u32, IoError>
extern fn native_udp_join_multicast_v4(handle: i64, multiaddr: Ipv4Addr, interface: Ipv4Addr) -> Result<(), IoError>
extern fn native_udp_leave_multicast_v4(handle: i64, multiaddr: Ipv4Addr, interface: Ipv4Addr) -> Result<(), IoError>
extern fn native_udp_join_multicast_v6(handle: i64, multiaddr: Ipv6Addr, interface: u32) -> Result<(), IoError>
extern fn native_udp_leave_multicast_v6(handle: i64, multiaddr: Ipv6Addr, interface: u32) -> Result<(), IoError>
extern fn native_udp_close(handle: i64) -> Result<(), IoError>

# ============================================
# Trait Implementations
# ============================================

use core.traits.*

# Note: UDP is connectionless, so Read/Write traits apply to connected sockets
# For unconnected sockets, use recv_from/send_to directly

impl Drop for UdpSocket:
    fn drop():
        native_udp_close(self.handle)
