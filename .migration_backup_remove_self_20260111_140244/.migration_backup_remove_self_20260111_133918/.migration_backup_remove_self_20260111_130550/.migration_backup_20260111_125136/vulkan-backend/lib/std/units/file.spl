# File System Unit Types
# Cross-platform file path handling with mingw-style drive letter support

# FilePath - platform-aware file path
# Supports both Unix (/path/to/file) and Windows (C:/path/to/file) paths
unit FilePath: str as file

# FilePath components
unit FileName: str as filename
unit FileExt: str as ext
unit DirPath: str as dir

# Drive letter for Windows (optional, e.g., "C", "D")
unit DriveLetter: str as drive

# File permissions (Unix-style octal)
unit FileMode: u32 as mode

# Error type for path operations
enum PathError:
    InvalidPath
    InvalidCharacter
    PathTooLong
    EmptyPath
    InvalidDriveLetter

# FilePath implementation
impl FilePath:
    # Construction
    fn from_str(s: str) -> Result<FilePath, PathError>:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        return Ok(s_file)

    fn from_parts(dir: DirPath, name: FileName, ext: Option<FileExt>) -> FilePath:
        let base = (dir as str) + "/" + (name as str)
        match ext:
            case Some(e): return (base + "." + (e as str))_file
            case None: return base_file

    # Components extraction
    fn dir(self) -> Option<DirPath>:
        let s = self as str
        let last_sep = s.rfind("/")
        match last_sep:
            case Some(idx):
                if idx == 0:
                    return Some("/"_dir)
                return Some(s.slice(0, idx)_dir)
            case None:
                return None

    fn file_name(self) -> Option<FileName>:
        let s = self as str
        let last_sep = s.rfind("/")
        match last_sep:
            case Some(idx):
                let name = s.slice(idx + 1, s.len())
                if name.is_empty():
                    return None
                return Some(name_filename)
            case None:
                return Some(s_filename)

    fn extension(self) -> Option<FileExt>:
        let s = self as str
        let last_dot = s.rfind(".")
        let last_sep = s.rfind("/")
        match last_dot:
            case Some(dot_idx):
                # Ensure dot is after last separator
                match last_sep:
                    case Some(sep_idx):
                        if dot_idx > sep_idx:
                            return Some(s.slice(dot_idx + 1, s.len())_ext)
                        return None
                    case None:
                        return Some(s.slice(dot_idx + 1, s.len())_ext)
            case None:
                return None

    fn drive(self) -> Option<DriveLetter>:
        # Check for mingw-style drive letter: C:/path
        let s = self as str
        if s.len() >= 2:
            let first = s.char_at(0)
            let second = s.char_at(1)
            if second == ':' and ((first >= 'A' and first <= 'Z') or (first >= 'a' and first <= 'z')):
                return Some(s.slice(0, 1).to_upper()_drive)
        return None

    # Operations
    fn join(self, child: FilePath) -> FilePath:
        let parent = self as str
        let child_str = child as str

        # Handle absolute child path
        if child_str.starts_with("/") or (child_str.len() >= 2 and child_str.char_at(1) == ':'):
            return child

        # Join with separator
        if parent.ends_with("/"):
            return (parent + child_str)_file
        return (parent + "/" + child_str)_file

    fn parent(self) -> Option<FilePath>:
        match self.dir():
            case Some(d): return Some((d as str)_file)
            case None: return None

    fn with_extension(self, ext: FileExt) -> FilePath:
        let s = self as str
        let current_ext = self.extension()
        match current_ext:
            case Some(e):
                let dot_pos = s.len() - (e as str).len() - 1
                return (s.slice(0, dot_pos) + "." + (ext as str))_file
            case None:
                return (s + "." + (ext as str))_file

    # Normalization
    fn normalize(self) -> FilePath:
        # TODO: Resolve . and .. components
        return self

    fn is_absolute(self) -> bool:
        let s = self as str
        # Unix absolute path
        if s.starts_with("/"):
            return true
        # Windows absolute path (C:/)
        if s.len() >= 3 and s.char_at(1) == ':' and s.char_at(2) == '/':
            return true
        return false

    # Platform conversion
    fn to_native(self) -> str:
        # Returns platform-native format
        # On Windows: backslashes, on Unix: forward slashes
        # For now, return as-is (mingw style works everywhere)
        return self as str

    fn to_posix(self) -> str:
        # Convert to POSIX style (forward slashes, /c/path for drives)
        let s = self as str
        match self.drive():
            case Some(d):
                let rest = s.slice(2, s.len())
                return "/" + (d as str).to_lower() + rest
            case None:
                return s

    fn to_mingw(self) -> str:
        # Return mingw style (C:/path)
        return self as str

# DirPath implementation
impl DirPath:
    fn from_str(s: str) -> Result<DirPath, PathError>:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        return Ok(s_dir)

    fn join(self, child: DirPath) -> DirPath:
        let parent = self as str
        let child_str = child as str
        if parent.ends_with("/"):
            return (parent + child_str)_dir
        return (parent + "/" + child_str)_dir

    fn to_file_path(self) -> FilePath:
        return (self as str)_file

# FileName implementation
impl FileName:
    fn from_str(s: str) -> Result<FileName, PathError>:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        if s.contains("/") or s.contains("\\"):
            return Err(PathError::InvalidCharacter)
        return Ok(s_filename)

    fn with_extension(self, ext: FileExt) -> FileName:
        return ((self as str) + "." + (ext as str))_filename

# FileExt implementation
impl FileExt:
    fn from_str(s: str) -> Result<FileExt, PathError>:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        if s.contains("."):
            return Err(PathError::InvalidCharacter)
        return Ok(s_ext)

# FileMode implementation (Unix permissions)
impl FileMode:
    fn readable() -> FileMode:
        return 0o644_mode

    fn executable() -> FileMode:
        return 0o755_mode

    fn readonly() -> FileMode:
        return 0o444_mode

    fn is_readable(self) -> bool:
        return ((self as u32) & 0o400) != 0

    fn is_writable(self) -> bool:
        return ((self as u32) & 0o200) != 0

    fn is_executable(self) -> bool:
        return ((self as u32) & 0o100) != 0
