# Architecture Testing DSL for Simple
# Provides ArchUnit-style layer validation and dependency rules
#
# Features:
# - #942: @arch_test decorator for architecture test functions
# - #943: Layer definition DSL with glob patterns
# - Layer access rules: may_only_access, may_not_access, etc.
# - No-mock-in-production validation
# - Skip-layer prevention

# ============================================================================
# Layer Definition
# ============================================================================

# Layer represents a named group of modules matching glob patterns
struct Layer:
    name: String
    patterns: List<String>

    # Create a new layer with name and patterns
    static fn new(name: String, patterns: List<String>) -> Layer:
        return Layer { name: name, patterns: patterns }

    # Check if a module path matches this layer
    fn contains(self, module_path: String) -> Bool:
        for pattern in self.patterns:
            if glob_match(pattern, module_path):
                return true
        return false

# LayerRef is a builder for layer access rules
struct LayerRef:
    layer_name: String
    rules: List<AccessRule>

    static fn new(name: String) -> LayerRef:
        return LayerRef { layer_name: name, rules: [] }

    # Layer may only access the specified layers
    fn may_only_access(self, targets: List<String>) -> LayerRef:
        self.rules.push(AccessRule.MayOnlyAccess(self.layer_name, targets))
        return self

    # Layer may not access the specified layers
    fn may_not_access(self, targets: List<String>) -> LayerRef:
        self.rules.push(AccessRule.MayNotAccess(self.layer_name, targets))
        return self

    # Layer may not be accessed by the specified layers
    fn may_not_be_accessed_by(self, sources: List<String>) -> LayerRef:
        self.rules.push(AccessRule.MayNotBeAccessedBy(self.layer_name, sources))
        return self

    # Layer may only be accessed by the specified layers
    fn may_only_be_accessed_by(self, sources: List<String>) -> LayerRef:
        self.rules.push(AccessRule.MayOnlyBeAccessedBy(self.layer_name, sources))
        return self

    # Check the rules against the architecture
    fn check(self) -> ArchCheckResult:
        return current_arch.check_rules(self.rules)

# Create a layer reference for building rules
export fn layer(name: String) -> LayerRef:
    return LayerRef.new(name)

# ============================================================================
# Access Rules
# ============================================================================

enum AccessRule:
    MayOnlyAccess(source: String, targets: List<String>)
    MayNotAccess(source: String, targets: List<String>)
    MayNotBeAccessedBy(target: String, sources: List<String>)
    MayOnlyBeAccessedBy(target: String, sources: List<String>)

# ============================================================================
# Architecture Definition
# ============================================================================

# Current architecture being validated (set by arch_test decorator)
let current_arch: Option<Architecture> = None

struct Architecture:
    layers: Dict<String, Layer>
    dependencies: Dict<String, List<String>>  # module -> list of imported modules
    file_contents: Dict<String, String>       # module -> file content

    static fn new() -> Architecture:
        return Architecture {
            layers: {},
            dependencies: {},
            file_contents: {}
        }

    # Define a layer with glob patterns
    fn layer(self, name: String, patterns: List<String>) -> Architecture:
        self.layers[name] = Layer.new(name, patterns)
        return self

    # Get layer by name
    fn get_layer(self, name: String) -> Option<Layer>:
        return self.layers.get(name)

    # Find which layer a module belongs to
    fn layer_of(self, module_path: String) -> Option<String>:
        for name, layer in self.layers:
            if layer.contains(module_path):
                return Some(name)
        return None

    # Check a list of rules against this architecture
    fn check_rules(self, rules: List<AccessRule>) -> ArchCheckResult:
        let violations: List<Violation> = []

        for rule in rules:
            match rule:
                case AccessRule.MayOnlyAccess(source, targets):
                    violations.extend(self.check_may_only_access(source, targets))
                case AccessRule.MayNotAccess(source, targets):
                    violations.extend(self.check_may_not_access(source, targets))
                case AccessRule.MayNotBeAccessedBy(target, sources):
                    violations.extend(self.check_may_not_be_accessed_by(target, sources))
                case AccessRule.MayOnlyBeAccessedBy(target, sources):
                    violations.extend(self.check_may_only_be_accessed_by(target, sources))

        if violations.is_empty():
            return ArchCheckResult.Pass
        else:
            return ArchCheckResult.Fail(violations)

    fn check_may_only_access(self, source_layer: String, allowed: List<String>) -> List<Violation>:
        let violations: List<Violation> = []
        let source = self.get_layer(source_layer)

        match source:
            case Some(src_layer):
                for module, deps in self.dependencies:
                    if src_layer.contains(module):
                        for dep in deps:
                            let dep_layer = self.layer_of(dep)
                            match dep_layer:
                                case Some(target_layer_name):
                                    if target_layer_name != source_layer and not allowed.contains(target_layer_name):
                                        violations.push(Violation {
                                            rule: "MayOnlyAccess",
                                            message: f"Layer '{source_layer}' accessed '{target_layer_name}' which is not in allowed list",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                                case None:
                                    pass  # External dependency, skip
            case None:
                pass

        return violations

    fn check_may_not_access(self, source_layer: String, forbidden: List<String>) -> List<Violation>:
        let violations: List<Violation> = []
        let source = self.get_layer(source_layer)

        match source:
            case Some(src_layer):
                for module, deps in self.dependencies:
                    if src_layer.contains(module):
                        for dep in deps:
                            let dep_layer = self.layer_of(dep)
                            match dep_layer:
                                case Some(target_layer_name):
                                    if forbidden.contains(target_layer_name):
                                        violations.push(Violation {
                                            rule: "MayNotAccess",
                                            message: f"Layer '{source_layer}' accessed forbidden layer '{target_layer_name}'",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                                case None:
                                    pass
            case None:
                pass

        return violations

    fn check_may_not_be_accessed_by(self, target_layer: String, forbidden_sources: List<String>) -> List<Violation>:
        let violations: List<Violation> = []
        let target = self.get_layer(target_layer)

        match target:
            case Some(tgt_layer):
                for module, deps in self.dependencies:
                    let src_layer = self.layer_of(module)
                    match src_layer:
                        case Some(source_layer_name):
                            if forbidden_sources.contains(source_layer_name):
                                for dep in deps:
                                    if tgt_layer.contains(dep):
                                        violations.push(Violation {
                                            rule: "MayNotBeAccessedBy",
                                            message: f"Layer '{target_layer}' was accessed by forbidden layer '{source_layer_name}'",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                        case None:
                            pass
            case None:
                pass

        return violations

    fn check_may_only_be_accessed_by(self, target_layer: String, allowed_sources: List<String>) -> List<Violation>:
        let violations: List<Violation> = []
        let target = self.get_layer(target_layer)

        match target:
            case Some(tgt_layer):
                for module, deps in self.dependencies:
                    let src_layer = self.layer_of(module)
                    match src_layer:
                        case Some(source_layer_name):
                            if source_layer_name != target_layer and not allowed_sources.contains(source_layer_name):
                                for dep in deps:
                                    if tgt_layer.contains(dep):
                                        violations.push(Violation {
                                            rule: "MayOnlyBeAccessedBy",
                                            message: f"Layer '{target_layer}' was accessed by non-allowed layer '{source_layer_name}'",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                        case None:
                            pass
            case None:
                pass

        return violations

# ============================================================================
# Validation Results
# ============================================================================

struct Violation:
    rule: String
    message: String
    source: Option<String>
    target: Option<String>

    fn to_string(self) -> String:
        let s = f"[{self.rule}] {self.message}"
        match self.source:
            case Some(src):
                s = s + f" (from: {src})"
            case None:
                pass
        match self.target:
            case Some(tgt):
                s = s + f" (to: {tgt})"
            case None:
                pass
        return s

enum ArchCheckResult:
    Pass
    Fail(violations: List<Violation>)

    fn is_ok(self) -> Bool:
        match self:
            case ArchCheckResult.Pass:
                return true
            case ArchCheckResult.Fail(_):
                return false

    fn violations(self) -> List<Violation>:
        match self:
            case ArchCheckResult.Pass:
                return []
            case ArchCheckResult.Fail(v):
                return v

# ============================================================================
# Special Checks
# ============================================================================

# Check that no mock annotations exist in production code
export fn no_mock_in_production(prod_patterns: List<String>) -> ArchCheckResult:
    let violations: List<Violation> = []

    match current_arch:
        case Some(arch):
            for module, content in arch.file_contents:
                # Check if module matches production patterns
                let is_prod = false
                for pattern in prod_patterns:
                    if glob_match(pattern, module):
                        is_prod = true
                        break

                if is_prod:
                    # Check for mock annotations
                    if content.contains("@mock") or content.contains("#[mock]"):
                        violations.push(Violation {
                            rule: "NoMockInProduction",
                            message: f"Mock annotation found in production code",
                            source: Some(module),
                            target: None
                        })
        case None:
            pass

    if violations.is_empty():
        return ArchCheckResult.Pass
    else:
        return ArchCheckResult.Fail(violations)

# Check for circular dependencies between layers
export fn no_layer_cycles() -> ArchCheckResult:
    let violations: List<Violation> = []

    match current_arch:
        case Some(arch):
            # Build layer dependency graph
            let layer_deps: Dict<String, Set<String>> = {}

            for name, _ in arch.layers:
                layer_deps[name] = Set.new()

            for module, deps in arch.dependencies:
                let src_layer = arch.layer_of(module)
                match src_layer:
                    case Some(src):
                        for dep in deps:
                            let tgt_layer = arch.layer_of(dep)
                            match tgt_layer:
                                case Some(tgt):
                                    if src != tgt:
                                        layer_deps[src].add(tgt)
                                case None:
                                    pass
                    case None:
                        pass

            # Detect cycles using DFS
            let visited: Set<String> = Set.new()
            let rec_stack: Set<String> = Set.new()

            fn has_cycle(node: String) -> Option<List<String>>:
                visited.add(node)
                rec_stack.add(node)

                match layer_deps.get(node):
                    case Some(neighbors):
                        for neighbor in neighbors:
                            if not visited.contains(neighbor):
                                match has_cycle(neighbor):
                                    case Some(path):
                                        path.insert(0, node)
                                        return Some(path)
                                    case None:
                                        pass
                            elif rec_stack.contains(neighbor):
                                return Some([node, neighbor])
                    case None:
                        pass

                rec_stack.remove(node)
                return None

            for name, _ in arch.layers:
                if not visited.contains(name):
                    match has_cycle(name):
                        case Some(cycle):
                            violations.push(Violation {
                                rule: "NoLayerCycles",
                                message: f"Circular dependency detected: {cycle.join(' -> ')}",
                                source: None,
                                target: None
                            })
                        case None:
                            pass
        case None:
            pass

    if violations.is_empty():
        return ArchCheckResult.Pass
    else:
        return ArchCheckResult.Fail(violations)

# Check that no layer is skipped (e.g., UI -> DB without going through Service)
export fn no_skip_layer(layer_order: List<String>) -> ArchCheckResult:
    let violations: List<Violation> = []

    match current_arch:
        case Some(arch):
            for module, deps in arch.dependencies:
                let src_layer = arch.layer_of(module)
                match src_layer:
                    case Some(src):
                        let src_idx = layer_order.index_of(src)
                        match src_idx:
                            case Some(si):
                                for dep in deps:
                                    let tgt_layer = arch.layer_of(dep)
                                    match tgt_layer:
                                        case Some(tgt):
                                            let tgt_idx = layer_order.index_of(tgt)
                                            match tgt_idx:
                                                case Some(ti):
                                                    # Check if skipping more than one layer
                                                    if ti > si + 1:
                                                        let skipped = layer_order[si + 1:ti]
                                                        violations.push(Violation {
                                                            rule: "NoSkipLayer",
                                                            message: f"Layer '{src}' skipped layers {skipped} to access '{tgt}'",
                                                            source: Some(module),
                                                            target: Some(dep)
                                                        })
                                                case None:
                                                    pass
                                        case None:
                                            pass
                            case None:
                                pass
                    case None:
                        pass
        case None:
            pass

    if violations.is_empty():
        return ArchCheckResult.Pass
    else:
        return ArchCheckResult.Fail(violations)

# ============================================================================
# @arch_test Decorator (#942)
# ============================================================================

# Decorator to mark a function as an architecture test
# Sets up the architecture context before running the test
export macro arch_test(layers_block: Any) -> ():
    emit result:
        return nil

# Helper for defining layers within @arch_test
export macro layers(definitions: Any) -> ():
    emit result:
        return nil

# ============================================================================
# Glob Pattern Matching (simplified)
# ============================================================================

fn glob_match(pattern: String, path: String) -> Bool:
    # Simplified glob matching for ** and *
    if pattern == "**":
        return true

    if pattern.ends_with("/**"):
        let prefix = pattern[0:-3]
        return path.starts_with(prefix)

    if pattern.contains("*"):
        # Simple wildcard matching
        let parts = pattern.split("*")
        if parts.len() == 2:
            return path.starts_with(parts[0]) and path.ends_with(parts[1])

    return pattern == path

# ============================================================================
# Exports
# ============================================================================

export Layer, LayerRef, AccessRule, Architecture, Violation, ArchCheckResult
export layer, no_mock_in_production, no_layer_cycles, no_skip_layer
export arch_test, layers
