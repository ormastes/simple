# Main Evaluation Loop
#
# Core interpreter evaluation logic.

from environment import {Environment}
from value import {Value, RuntimeValue}
import ..expr.{eval_expr}
import ..control.{eval_control}

export Interpreter, eval_statement, eval_expression

# Main interpreter struct
struct Interpreter:
    env: Environment
    debug: bool

impl Interpreter:
    fn new() -> Interpreter:
        return Interpreter {
            env: Environment::new(),
            debug: false
        }

    fn with_debug(debug: bool) -> Interpreter:
        return Interpreter {
            env: Environment::new(),
            debug: debug
        }

    # Evaluate a statement
    fn eval_stmt(self, stmt: &Statement) -> Result<Value, InterpreterError>:
        if self.debug:
            print("Evaluating: {stmt}")

        match stmt:
            case Statement::Let(binding):
                return self.eval_let(binding)

            case Statement::Return(expr):
                return self.eval_return(expr)

            case Statement::If(cond, then_block, else_block):
                return eval_control::eval_if(self, cond, then_block, else_block)

            case Statement::Match(value, cases):
                return eval_control::eval_match(self, value, cases)

            case Statement::For(pattern, iterable, body):
                return eval_control::eval_for(self, pattern, iterable, body)

            case Statement::While(cond, body):
                return eval_control::eval_while(self, cond, body)

            case Statement::Expression(expr):
                return self.eval_expr(expr)

            case _:
                return Err(InterpreterError::NotImplemented(stmt.to_string()))

    # Evaluate an expression
    fn eval_expr(self, expr: &Expr) -> Result<Value, InterpreterError>:
        return eval_expr::evaluate(self, expr)

    # Evaluate let binding
    fn eval_let(self, binding: &LetBinding) -> Result<Value, InterpreterError>:
        let value = self.eval_expr(&binding.value)?
        self.env.define(binding.name.clone(), value.clone())
        return Ok(Value::nil())

    # Evaluate return statement
    fn eval_return(self, expr: &Option<Expr>) -> Result<Value, InterpreterError>:
        match expr:
            case Some(e):
                let value = self.eval_expr(&e)?
                return Err(InterpreterError::Return(value))
            case None:
                return Err(InterpreterError::Return(Value::nil()))

# Convenience functions
fn eval_statement(interp: &Interpreter, stmt: &Statement) -> Result<Value, InterpreterError>:
    return interp.eval_stmt(stmt)

fn eval_expression(interp: &Interpreter, expr: &Expr) -> Result<Value, InterpreterError>:
    return interp.eval_expr(expr)

# Error type
enum InterpreterError:
    Return(Value)              # Control flow for return
    Break                      # Control flow for break
    Continue                   # Control flow for continue
    NameError(String)          # Undefined variable
    TypeError(String)          # Type mismatch
    ValueError(String)         # Invalid value
    IndexError(String)         # Index out of bounds
    IoError(String)            # I/O error
    NotImplemented(String)     # Feature not implemented
