# Simple Language Linter
# Semantic lints for code quality and safety
# Usage: simple_lint <file.spl> [--deny-all] [--warn-all]

# Native file I/O functions
extern fn native_fs_read_string(path: String) -> Any
extern fn native_fs_exists(path: String) -> Bool
extern fn sys_get_args() -> List<String>

# Async file I/O wrapper
async fn read_file(path: String) -> Result<String, String>:
    let file_content = native_fs_read_string(path)
    match file_content:
        case Ok(content):
            return Ok(content)
        case Err(e):
            return Err("Failed to read: " + e.to_string())

# Lint levels
enum LintLevel:
    Allow
    Warn
    Deny

# Lint categories
enum LintCategory:
    Safety      # Memory safety, null checks
    Correctness # Logic errors, type mismatches
    Warning     # Potential issues
    Style       # Code style recommendations
    Concurrency # Concurrency-related issues

class Lint:
    code: String
    level: LintLevel
    category: LintCategory
    message: String
    fix_hint: Option<String>
    
    fn new(code: String, level: LintLevel, category: LintCategory, message: String) -> Lint:
        Lint(
            code: code,
            level: level,
            category: category,
            message: message,
            fix_hint: None
        )
    
    fn with_fix(self, hint: String) -> Lint:
        Lint(
            code: self.code,
            level: self.level,
            category: self.category,
            message: self.message,
            fix_hint: Some(hint)
        )

class LintResult:
    file_path: String
    line: Int
    column: Int
    lint: Lint
    
    fn new(file_path: String, line: Int, column: Int, lint: Lint) -> LintResult:
        LintResult(
            file_path: file_path,
            line: line,
            column: column,
            lint: lint
        )
    
    fn format(self) -> String:
        let mut level_str = "unknown"
        match self.lint.level:
            case Allow:
                level_str = "allow"
            case Warn:
                level_str = "warning"
            case Deny:
                level_str = "error"

        let mut output = self.file_path + ":" + self.line.to_string() + ":" + self.column.to_string() + ": " + level_str + "[" + self.lint.code + "]: " + self.lint.message

        match self.lint.fix_hint:
            case Some(hint):
                output = output + "\n  hint: " + hint
            case None:
                let _ = 0

        return output

class Linter:
    lints: List<Lint>
    results: List<LintResult>
    
    fn new() -> Linter:
        let mut lints = []
        
        # Safety lints
        lints.push(Lint.new("S001", LintLevel.Deny, LintCategory.Safety, 
            "Unused Result type (must use .unwrap(), .expect(), or match)"))
        lints.push(Lint.new("S002", LintLevel.Deny, LintCategory.Safety,
            "Potential null pointer dereference"))
        lints.push(Lint.new("S003", LintLevel.Warn, LintCategory.Safety,
            "Unsafe block without safety comment"))
        
        # Correctness lints
        lints.push(Lint.new("C001", LintLevel.Deny, LintCategory.Correctness,
            "Unreachable code after return/break/continue"))
        lints.push(Lint.new("C002", LintLevel.Warn, LintCategory.Correctness,
            "Non-exhaustive match (add catch-all case)"))
        lints.push(Lint.new("C003", LintLevel.Warn, LintCategory.Correctness,
            "Comparison of incompatible types"))
        
        # Warning lints
        lints.push(Lint.new("W001", LintLevel.Warn, LintCategory.Warning,
            "Unused variable (prefix with _ to silence)"))
        lints.push(Lint.new("W002", LintLevel.Warn, LintCategory.Warning,
            "Unused import"))
        lints.push(Lint.new("W003", LintLevel.Warn, LintCategory.Warning,
            "Dead code"))
        
        # Style lints
        lints.push(Lint.new("ST001", LintLevel.Allow, LintCategory.Style,
            "Function name should be snake_case"))
        lints.push(Lint.new("ST002", LintLevel.Allow, LintCategory.Style,
            "Class name should be PascalCase"))
        lints.push(Lint.new("ST003", LintLevel.Allow, LintCategory.Style,
            "Constant should be UPPER_SNAKE_CASE"))
        
        # Concurrency lints
        lints.push(Lint.new("CC001", LintLevel.Deny, LintCategory.Concurrency,
            "Shared mutable state without synchronization"))
        lints.push(Lint.new("CC002", LintLevel.Warn, LintCategory.Concurrency,
            "Send type used without thread safety guarantee"))

        # TODO/FIXME format lints (T00x rules)
        lints.push(Lint.new("T001", LintLevel.Warn, LintCategory.Style,
            "TODO/FIXME missing [area][priority] format"))
        lints.push(Lint.new("T002", LintLevel.Warn, LintCategory.Style,
            "TODO/FIXME has invalid area"))
        lints.push(Lint.new("T003", LintLevel.Warn, LintCategory.Style,
            "TODO/FIXME has invalid priority"))
        lints.push(Lint.new("T004", LintLevel.Deny, LintCategory.Style,
            "P0/critical TODO must have issue number"))

        Linter(lints: lints, results: [])
    
    async fn lint_file(self, path: String) -> Result<List<LintResult>, String>:
        # Read file using async file I/O
        let file_content = await read_file(path)
        match file_content:
            case Err(e):
                return Err(e)
            case Ok(content):
                # Run simple pattern-based lints
                # TODO: [stdlib][P3] Use AST-based linting when compiler integration is available
                let lines = content.split("\n")
                let mut line_num = 1

                for line in lines:
                    self.check_line(path, line_num, line)
                    line_num = line_num + 1

                return Ok(self.results)
    
    fn check_line(self, path: String, line_num: Int, line: String):
        let trimmed = line.trim()
        
        # Check for unused variables (simple heuristic)
        if trimmed.starts_with("let ") and not trimmed.contains("="):
            let lint = Lint.new("W001", LintLevel.Warn, LintCategory.Warning,
                "Variable declared but never assigned")
                .with_fix("Remove declaration or assign a value")
            self.results.push(LintResult.new(path, line_num, 0, lint))
        
        # Check for unreachable code
        if trimmed.starts_with("return "):
            # Next non-empty line after return is potentially unreachable
            # (This is oversimplified - needs proper control flow analysis)
            let _ = 0
        
        # Check naming conventions (if enabled)
        if trimmed.starts_with("fn "):
            let fn_name = self.extract_function_name(trimmed)
            if not self.is_snake_case(fn_name):
                let lint = Lint.new("ST001", LintLevel.Allow, LintCategory.Style,
                    "Function name '{fn_name}' should be snake_case")
                    .with_fix("Rename to '{self.to_snake_case(fn_name)}'")
                self.results.push(LintResult.new(path, line_num, 0, lint))
        
        if trimmed.starts_with("class "):
            let class_name = self.extract_class_name(trimmed)
            if not self.is_pascal_case(class_name):
                let lint = Lint.new("ST002", LintLevel.Allow, LintCategory.Style,
                    "Class name '{class_name}' should be PascalCase")
                self.results.push(LintResult.new(path, line_num, 0, lint))

        # Check TODO/FIXME format
        self.check_todo_format(path, line_num, trimmed)
    
    fn extract_function_name(self, line: String) -> String:
        # Extract function name from "fn name(...)" pattern
        let parts = line.split("(")
        if parts.len() > 0:
            let name_part = parts[0].replace("fn ", "").trim()
            return name_part
        ""
    
    fn extract_class_name(self, line: String) -> String:
        # Extract class name from "class Name:" pattern
        let parts = line.replace("class ", "").split(":")
        if parts.len() > 0:
            return parts[0].trim()
        ""
    
    fn is_snake_case(self, name: String) -> Bool:
        # Simple check: lowercase with underscores
        name == name.to_lowercase() and not name.contains("-")
    
    fn is_pascal_case(self, name: String) -> Bool:
        # Simple check: starts with uppercase
        if name.is_empty():
            return false
        let first_char = name.chars().first()
        match first_char:
            case Some(c): c.is_uppercase()
            case None: false
    
    fn to_snake_case(self, name: String) -> String:
        # Convert to snake_case (simplified)
        name.to_lowercase()

    # Valid TODO areas and priorities
    let TODO_AREAS = ["runtime", "codegen", "compiler", "parser", "type",
                      "stdlib", "gpu", "ui", "test", "driver", "loader", "pkg", "sdn"]
    let TODO_PRIORITIES = ["P0", "P1", "P2", "P3", "critical", "high", "medium", "low"]

    fn check_todo_format(self, path: String, line_num: Int, line: String):
        # Check if line contains TODO or FIXME
        let has_todo = line.contains("TODO")
        let has_fixme = line.contains("FIXME")

        if not has_todo and not has_fixme:
            return

        let keyword = if has_todo then "TODO" else "FIXME"
        let idx = line.find(keyword)
        let after_keyword = line.slice(idx + keyword.len()).strip()

        # Check if it starts with : (standard format)
        if not after_keyword.starts_with(":"):
            return  # Not a standard comment format

        let content = after_keyword.slice(1).strip()

        # Check for new format: [area][priority]
        if not content.starts_with("["):
            # Missing format
            let lint = Lint.new("T001", LintLevel.Warn, LintCategory.Style,
                "TODO/FIXME missing [area][priority] format")
                .with_fix("Use: {keyword}: [area][P0-P3] description")
            self.results.push(LintResult.new(path, line_num, idx, lint))
            return

        # Parse [area][priority]
        let first_close = content.find("]")
        if first_close < 0:
            let lint = Lint.new("T001", LintLevel.Warn, LintCategory.Style,
                "TODO/FIXME has malformed [area] tag")
            self.results.push(LintResult.new(path, line_num, idx, lint))
            return

        let area = content.slice(1, first_close)

        # Validate area
        if not self.TODO_AREAS.contains(area):
            let lint = Lint.new("T002", LintLevel.Warn, LintCategory.Style,
                "TODO/FIXME has invalid area '{area}'")
                .with_fix("Valid areas: runtime, codegen, compiler, parser, type, stdlib, gpu, ui, test, driver, loader, pkg, sdn")
            self.results.push(LintResult.new(path, line_num, idx, lint))

        # Check for priority
        let after_area = content.slice(first_close + 1).strip()
        if not after_area.starts_with("["):
            let lint = Lint.new("T001", LintLevel.Warn, LintCategory.Style,
                "TODO/FIXME missing [priority] after [area]")
                .with_fix("Use: {keyword}: [{area}][P0-P3] description")
            self.results.push(LintResult.new(path, line_num, idx, lint))
            return

        let second_close = after_area.find("]")
        if second_close < 0:
            let lint = Lint.new("T001", LintLevel.Warn, LintCategory.Style,
                "TODO/FIXME has malformed [priority] tag")
            self.results.push(LintResult.new(path, line_num, idx, lint))
            return

        let priority = after_area.slice(1, second_close)

        # Validate priority
        if not self.TODO_PRIORITIES.contains(priority):
            let lint = Lint.new("T003", LintLevel.Warn, LintCategory.Style,
                "TODO/FIXME has invalid priority '{priority}'")
                .with_fix("Valid priorities: P0/critical, P1/high, P2/medium, P3/low")
            self.results.push(LintResult.new(path, line_num, idx, lint))

        # Check P0/critical requires issue number
        if priority == "P0" or priority == "critical":
            let rest = after_area.slice(second_close + 1)
            if not rest.contains("[#"):
                let lint = Lint.new("T004", LintLevel.Deny, LintCategory.Style,
                    "P0/critical TODO must have issue number")
                    .with_fix("Add issue: {keyword}: [{area}][{priority}] description [#123]")
                self.results.push(LintResult.new(path, line_num, idx, lint))

async fn main() -> Int:
    let args = sys_get_args()

    if args.len() < 2:
        print("Usage: simple_lint <file.spl> [options]")
        print("")
        print("Options:")
        print("  --deny-all   Treat all warnings as errors")
        print("  --warn-all   Enable all style lints")
        print("  --json       Output in JSON format")
        print("")
        print("Lint categories:")
        print("  Safety (S): Memory safety and null checks")
        print("  Correctness (C): Logic errors")
        print("  Warning (W): Potential issues")
        print("  Style (ST): Code style")
        print("  Concurrency (CC): Thread safety")
        print("  TODO (T): TODO/FIXME format [area][priority]")
        return 1

    let file_path = args[1]
    let deny_all = args.contains("--deny-all")

    # Verify file exists
    if not native_fs_exists(file_path):
        print("Error: File not found: " + file_path)
        return 1

    # Run linter
    let linter = Linter.new()

    let lint_result = await linter.lint_file(file_path)
    match lint_result:
        case Ok(results):
            if results.is_empty():
                print("No issues found in " + file_path)
                return 0
            else:
                let mut error_count = 0
                let mut warning_count = 0

                for lint_item in results:
                    print(lint_item.format())

                    match lint_item.lint.level:
                        case Deny:
                            error_count = error_count + 1
                        case Warn:
                            warning_count = warning_count + 1
                            if deny_all:
                                error_count = error_count + 1
                        case Allow:
                            let _ = 0

                print("")
                print("Found " + error_count.to_string() + " error(s) and " + warning_count.to_string() + " warning(s)")

                if error_count > 0:
                    return 1
                else:
                    return 0

        case Err(error):
            print("Error: " + error)
            return 1

    return 0
