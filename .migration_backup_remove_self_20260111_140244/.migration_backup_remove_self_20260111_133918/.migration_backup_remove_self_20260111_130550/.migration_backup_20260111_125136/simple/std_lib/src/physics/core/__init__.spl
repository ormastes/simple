# Physics Core - Vector and Matrix Math
#
# GPU-accelerated vector and matrix operations using PyTorch tensors.
#
# ## Classes
# - `Vector2`: 2D vector
# - `Vector3`: 3D vector
# - `Matrix3`: 3x3 matrix for 2D transformations
# - `Matrix4`: 4x4 matrix for 3D transformations
# - `Quaternion`: Rotation quaternion
#
# ## Example
# ```simple
# import physics.core as core
#
# let v1 = core.Vector3(1.0, 2.0, 3.0)
# let v2 = core.Vector3(4.0, 5.0, 6.0)
#
# let dot = v1.dot(v2)
# let cross = v1.cross(v2)
# let length = v1.magnitude()
# ```

export Vector2, Vector3, Matrix3, Matrix4, Quaternion

import ml.torch as torch


# ============================================================================
# Vector2 - 2D Vector
# ============================================================================

class Vector2:
    """2D vector with GPU acceleration.

    Attributes:
        x: X component
        y: Y component
    """
    x: f64
    y: f64

    fn __init__(self, x: f64, y: f64):
        """Initialize 2D vector.

        Args:
            x: X component
            y: Y component
        """
        self.x = x
        self.y = y

    fn add(self, other: Vector2) -> Vector2:
        """Add two vectors."""
        return Vector2(self.x + other.x, self.y + other.y)

    fn sub(self, other: Vector2) -> Vector2:
        """Subtract two vectors."""
        return Vector2(self.x - other.x, self.y - other.y)

    fn scale(self, scalar: f64) -> Vector2:
        """Multiply vector by scalar."""
        return Vector2(self.x * scalar, self.y * scalar)

    fn dot(self, other: Vector2) -> f64:
        """Dot product."""
        return self.x * other.x + self.y * other.y

    fn magnitude(self) -> f64:
        """Vector length."""
        return (self.x * self.x + self.y * self.y).sqrt()

    fn normalize(self) -> Vector2:
        """Unit vector in same direction."""
        let mag = self.magnitude()
        if mag > 0:
            return self.scale(1.0 / mag)
        return Vector2(0.0, 0.0)

    fn distance(self, other: Vector2) -> f64:
        """Distance to another vector."""
        return self.sub(other).magnitude()


# ============================================================================
# Vector3 - 3D Vector
# ============================================================================

class Vector3:
    """3D vector with GPU acceleration.

    Attributes:
        x: X component
        y: Y component
        z: Z component

    Example:
        ```simple
        let v1 = Vector3(1.0, 0.0, 0.0)
        let v2 = Vector3(0.0, 1.0, 0.0)
        let cross = v1.cross(v2)  # (0, 0, 1)
        ```
    """
    x: f64
    y: f64
    z: f64

    fn __init__(self, x: f64, y: f64, z: f64):
        """Initialize 3D vector.

        Args:
            x: X component
            y: Y component
            z: Z component
        """
        self.x = x
        self.y = y
        self.z = z

    fn add(self, other: Vector3) -> Vector3:
        """Add two vectors."""
        return Vector3(
            self.x + other.x,
            self.y + other.y,
            self.z + other.z
        )

    fn sub(self, other: Vector3) -> Vector3:
        """Subtract two vectors."""
        return Vector3(
            self.x - other.x,
            self.y - other.y,
            self.z - other.z
        )

    fn scale(self, scalar: f64) -> Vector3:
        """Multiply vector by scalar."""
        return Vector3(
            self.x * scalar,
            self.y * scalar,
            self.z * scalar
        )

    fn dot(self, other: Vector3) -> f64:
        """Dot product."""
        return self.x * other.x + self.y * other.y + self.z * other.z

    fn cross(self, other: Vector3) -> Vector3:
        """Cross product."""
        return Vector3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

    fn magnitude(self) -> f64:
        """Vector length."""
        return (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn normalize(self) -> Vector3:
        """Unit vector in same direction."""
        let mag = self.magnitude()
        if mag > 0:
            return self.scale(1.0 / mag)
        return Vector3(0.0, 0.0, 0.0)

    fn distance(self, other: Vector3) -> f64:
        """Distance to another vector."""
        return self.sub(other).magnitude()

    @staticmethod
    fn zero() -> Vector3:
        """Zero vector."""
        return Vector3(0.0, 0.0, 0.0)

    @staticmethod
    fn one() -> Vector3:
        """One vector."""
        return Vector3(1.0, 1.0, 1.0)

    @staticmethod
    fn up() -> Vector3:
        """Up vector (Y-axis)."""
        return Vector3(0.0, 1.0, 0.0)

    @staticmethod
    fn down() -> Vector3:
        """Down vector (-Y-axis)."""
        return Vector3(0.0, -1.0, 0.0)

    @staticmethod
    fn left() -> Vector3:
        """Left vector (-X-axis)."""
        return Vector3(-1.0, 0.0, 0.0)

    @staticmethod
    fn right() -> Vector3:
        """Right vector (X-axis)."""
        return Vector3(1.0, 0.0, 0.0)

    @staticmethod
    fn forward() -> Vector3:
        """Forward vector (Z-axis)."""
        return Vector3(0.0, 0.0, 1.0)

    @staticmethod
    fn back() -> Vector3:
        """Back vector (-Z-axis)."""
        return Vector3(0.0, 0.0, -1.0)


# ============================================================================
# Matrix3 - 3x3 Matrix
# ============================================================================

class Matrix3:
    """3x3 matrix for 2D transformations.

    Stored in row-major order.
    """
    data: [f64; 9]

    fn __init__(self, data: [f64; 9]):
        """Initialize matrix from array.

        Args:
            data: 9 elements in row-major order
        """
        self.data = data

    @staticmethod
    fn identity() -> Matrix3:
        """Create identity matrix."""
        return Matrix3([
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
        ])

    @staticmethod
    fn rotation_z(angle: f64) -> Matrix3:
        """Create rotation matrix around Z-axis.

        Args:
            angle: Rotation angle in radians

        Returns:
            Rotation matrix
        """
        let c = angle.cos()
        let s = angle.sin()
        return Matrix3([
            c, -s, 0.0,
            s,  c, 0.0,
            0.0, 0.0, 1.0
        ])

    @staticmethod
    fn scale(sx: f64, sy: f64) -> Matrix3:
        """Create scale matrix.

        Args:
            sx: X-axis scale
            sy: Y-axis scale

        Returns:
            Scale matrix
        """
        return Matrix3([
            sx, 0.0, 0.0,
            0.0, sy, 0.0,
            0.0, 0.0, 1.0
        ])


# ============================================================================
# Matrix4 - 4x4 Matrix
# ============================================================================

class Matrix4:
    """4x4 matrix for 3D transformations.

    Stored in row-major order.
    """
    data: [f64; 16]

    fn __init__(self, data: [f64; 16]):
        """Initialize matrix from array.

        Args:
            data: 16 elements in row-major order
        """
        self.data = data

    @staticmethod
    fn identity() -> Matrix4:
        """Create identity matrix."""
        return Matrix4([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    @staticmethod
    fn translation(x: f64, y: f64, z: f64) -> Matrix4:
        """Create translation matrix.

        Args:
            x: X translation
            y: Y translation
            z: Z translation

        Returns:
            Translation matrix
        """
        return Matrix4([
            1.0, 0.0, 0.0, x,
            0.0, 1.0, 0.0, y,
            0.0, 0.0, 1.0, z,
            0.0, 0.0, 0.0, 1.0
        ])

    @staticmethod
    fn rotation_x(angle: f64) -> Matrix4:
        """Create rotation matrix around X-axis.

        Args:
            angle: Rotation angle in radians

        Returns:
            Rotation matrix
        """
        let c = angle.cos()
        let s = angle.sin()
        return Matrix4([
            1.0, 0.0, 0.0, 0.0,
            0.0, c, -s, 0.0,
            0.0, s,  c, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    @staticmethod
    fn rotation_y(angle: f64) -> Matrix4:
        """Create rotation matrix around Y-axis.

        Args:
            angle: Rotation angle in radians

        Returns:
            Rotation matrix
        """
        let c = angle.cos()
        let s = angle.sin()
        return Matrix4([
             c, 0.0, s, 0.0,
            0.0, 1.0, 0.0, 0.0,
            -s, 0.0, c, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    @staticmethod
    fn rotation_z(angle: f64) -> Matrix4:
        """Create rotation matrix around Z-axis.

        Args:
            angle: Rotation angle in radians

        Returns:
            Rotation matrix
        """
        let c = angle.cos()
        let s = angle.sin()
        return Matrix4([
            c, -s, 0.0, 0.0,
            s,  c, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    @staticmethod
    fn scale(sx: f64, sy: f64, sz: f64) -> Matrix4:
        """Create scale matrix.

        Args:
            sx: X-axis scale
            sy: Y-axis scale
            sz: Z-axis scale

        Returns:
            Scale matrix
        """
        return Matrix4([
            sx, 0.0, 0.0, 0.0,
            0.0, sy, 0.0, 0.0,
            0.0, 0.0, sz, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])


# ============================================================================
# Quaternion - Rotation Quaternion
# ============================================================================

class Quaternion:
    """Quaternion for 3D rotations.

    Quaternions avoid gimbal lock and interpolate smoothly.

    Attributes:
        w: Scalar component
        x: X component of vector part
        y: Y component of vector part
        z: Z component of vector part
    """
    w: f64
    x: f64
    y: f64
    z: f64

    fn __init__(self, w: f64, x: f64, y: f64, z: f64):
        """Initialize quaternion.

        Args:
            w: Scalar component
            x: X component
            y: Y component
            z: Z component
        """
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    @staticmethod
    fn identity() -> Quaternion:
        """Create identity quaternion (no rotation)."""
        return Quaternion(1.0, 0.0, 0.0, 0.0)

    @staticmethod
    fn from_axis_angle(axis: Vector3, angle: f64) -> Quaternion:
        """Create quaternion from axis and angle.

        Args:
            axis: Rotation axis (should be normalized)
            angle: Rotation angle in radians

        Returns:
            Rotation quaternion
        """
        let half_angle = angle * 0.5
        let s = half_angle.sin()
        let c = half_angle.cos()

        let normalized_axis = axis.normalize()
        return Quaternion(
            c,
            normalized_axis.x * s,
            normalized_axis.y * s,
            normalized_axis.z * s
        )

    fn magnitude(self) -> f64:
        """Quaternion magnitude."""
        return (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn normalize(self) -> Quaternion:
        """Normalize quaternion."""
        let mag = self.magnitude()
        if mag > 0:
            return Quaternion(
                self.w / mag,
                self.x / mag,
                self.y / mag,
                self.z / mag
            )
        return Quaternion::identity()

    fn conjugate(self) -> Quaternion:
        """Conjugate quaternion."""
        return Quaternion(self.w, -self.x, -self.y, -self.z)

    fn rotate_vector(self, v: Vector3) -> Vector3:
        """Rotate vector by quaternion.

        Args:
            v: Vector to rotate

        Returns:
            Rotated vector
        """
        # q * v * q^-1 (using quaternion multiplication)
        let qv = Vector3(self.x, self.y, self.z)
        let t = qv.cross(v).scale(2.0)
        let rotated = v.add(t.scale(self.w)).add(qv.cross(t))
        return rotated
