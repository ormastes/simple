# NoGC Compile Model
#
# Formal model for no-GC (manual memory) compilation mode.
# Mirrors: verification/nogc_compile/src/NogcCompile.lean
#
# In NoGC mode:
#   - No garbage collection
#   - Explicit allocation/deallocation
#   - Stack allocation preferred
#   - Ownership tracking required

# Allocation mode
enum AllocMode:
    Stack
    Heap
    Static

    fn is_stack(self) -> Bool:
        """Check if this is Stack allocation mode.
        Returns: true for Stack
        Example: AllocMode.Stack.is_stack()  # → true
        """
        match self:
            case Stack: true
            case _: false

    fn is_heap(self) -> Bool:
        """Check if this is Heap allocation mode.
        Returns: true for Heap
        Example: AllocMode.Heap.is_heap()  # → true
        """
        match self:
            case Heap: true
            case _: false

    fn is_static(self) -> Bool:
        """Check if this is Static allocation mode.
        Returns: true for Static
        Example: AllocMode.Static.is_static()  # → true
        """
        match self:
            case Static: true
            case _: false

    fn requires_manual_free(self) -> Bool:
        """Check if this allocation requires manual freeing.
        Returns: true for Heap (stack and static are auto-managed)
        Example: AllocMode.Heap.requires_manual_free()  # → true
        """
        match self:
            case Heap: true
            case _: false

    fn is_scoped(self) -> Bool:
        """Check if this allocation is scope-bound.
        Returns: true for Stack (freed on scope exit)
        Example: AllocMode.Stack.is_scoped()  # → true
        """
        match self:
            case Stack: true
            case _: false

    fn has_fixed_lifetime(self) -> Bool:
        """Check if this allocation has fixed lifetime.
        Returns: true for Static (lives for program duration)
        Example: AllocMode.Static.has_fixed_lifetime()  # → true
        """
        match self:
            case Static: true
            case _: false

    fn is_gc_managed(self) -> Bool:
        """Check if this would be GC-managed in GC mode.
        In NoGC mode, nothing is GC-managed, but this indicates
        whether the allocation would be GC-managed if GC were enabled.
        Returns: false for all (NoGC mode)
        Example: AllocMode.Heap.is_gc_managed()  # → false
        """
        false

    fn to_string(self) -> String:
        """Convert AllocMode to string representation.
        Returns: lowercase string name
        Example: AllocMode.Stack.to_string()  # → "stack"
        """
        match self:
            case Stack: "stack"
            case Heap: "heap"
            case Static: "static"

    fn description(self) -> String:
        """Get human-readable description of the allocation mode.
        Returns: descriptive explanation
        Example: AllocMode.Stack.description()  # → "Stack allocation (scope-bound)"
        """
        match self:
            case Stack: "Stack allocation (scope-bound)"
            case Heap: "Heap allocation (manual free required)"
            case Static: "Static allocation (program lifetime)"

    fn summary(self) -> String:
        """Get comprehensive summary of the allocation mode.
        Returns: summary with name, description, and lifetime properties
        Example: AllocMode.Heap.summary()
                # → "AllocMode: heap (Heap allocation (manual free required), requires manual free)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut props = []

        if self.requires_manual_free():
            props.push("requires manual free")
        if self.is_scoped():
            props.push("scoped")
        if self.has_fixed_lifetime():
            props.push("fixed lifetime")

        let props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "AllocMode: {name} ({desc}{props_str})"

    fn to_lean(self) -> String:
        """Convert to Lean 4 representation.
        Returns: Lean syntax for this allocation mode
        Example: AllocMode.Stack.to_lean()  # → "AllocMode.stack"
        """
        match self:
            case Stack: return "AllocMode.stack"
            case Heap: return "AllocMode.heap"
            case Static: return "AllocMode.static"

# Ownership state
enum Ownership:
    Owned
    Borrowed
    Moved

    fn is_owned(self) -> Bool:
        """Check if this is Owned state.
        Returns: true for Owned
        Example: Ownership.Owned.is_owned()  # → true
        """
        match self:
            case Owned: true
            case _: false

    fn is_borrowed(self) -> Bool:
        """Check if this is Borrowed state.
        Returns: true for Borrowed
        Example: Ownership.Borrowed.is_borrowed()  # → true
        """
        match self:
            case Borrowed: true
            case _: false

    fn is_moved(self) -> Bool:
        """Check if this is Moved state.
        Returns: true for Moved
        Example: Ownership.Moved.is_moved()  # → true
        """
        match self:
            case Moved: true
            case _: false

    fn is_valid(self) -> Bool:
        """Check if ownership allows access.
        Moved values cannot be accessed.
        Returns: false for Moved, true otherwise
        Example: Ownership.Moved.is_valid()  # → false
        """
        match self:
            case Moved: false
            case _: true

    fn allows_mutation(self) -> Bool:
        """Check if ownership allows mutation.
        Returns: true for Owned
        Example: Ownership.Owned.allows_mutation()  # → true
        """
        match self:
            case Owned: true
            case _: false

    fn allows_read(self) -> Bool:
        """Check if ownership allows reading.
        Returns: true for Owned or Borrowed
        Example: Ownership.Borrowed.allows_read()  # → true
        """
        match self:
            case Owned: true
            case Borrowed: true
            case Moved: false

    fn allows_move(self) -> Bool:
        """Check if ownership allows moving value.
        Returns: true for Owned
        Example: Ownership.Owned.allows_move()  # → true
        """
        match self:
            case Owned: true
            case _: false

    fn can_create_borrow(self) -> Bool:
        """Check if can create borrow from this ownership.
        Returns: true for Owned or Borrowed
        Example: Ownership.Owned.can_create_borrow()  # → true
        """
        match self:
            case Owned: true
            case Borrowed: true
            case Moved: false

    fn to_string(self) -> String:
        """Convert Ownership to string representation.
        Returns: lowercase string name
        Example: Ownership.Owned.to_string()  # → "owned"
        """
        match self:
            case Owned: "owned"
            case Borrowed: "borrowed"
            case Moved: "moved"

    fn description(self) -> String:
        """Get human-readable description of the ownership state.
        Returns: descriptive explanation
        Example: Ownership.Borrowed.description()  # → "Borrowed (temporary reference)"
        """
        match self:
            case Owned: "Owned (full ownership)"
            case Borrowed: "Borrowed (temporary reference)"
            case Moved: "Moved (invalidated)"

    fn summary(self) -> String:
        """Get comprehensive summary of the ownership state.
        Returns: summary with name, description, and access permissions
        Example: Ownership.Owned.summary()
                # → "Ownership: owned (Owned (full ownership), allows mutation, allows read, allows move)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut perms = []

        if self.allows_mutation():
            perms.push("allows mutation")
        if self.allows_read():
            perms.push("allows read")
        if self.allows_move():
            perms.push("allows move")
        if self.can_create_borrow():
            perms.push("can borrow")
        if not self.is_valid():
            perms.push("invalid")

        let perms_str = if perms.len() > 0:
            ", " + perms.join(", ")
        else:
            ""

        "Ownership: {name} ({desc}{perms_str})"

    fn to_lean(self) -> String:
        """Convert to Lean 4 representation.
        Returns: Lean syntax for this ownership state
        Example: Ownership.Owned.to_lean()  # → "Ownership.owned"
        """
        match self:
            case Owned: return "Ownership.owned"
            case Borrowed: return "Ownership.borrowed"
            case Moved: return "Ownership.moved"

# Memory region
class MemRegion:
    id: Int
    alloc_mode: AllocMode
    size: Int
    is_freed: Bool

    fn create(id: Int, mode: AllocMode, size: Int) -> MemRegion:
        return MemRegion(id, mode, size, False)

    fn to_lean(self) -> String:
        freed = "false"
        if self.is_freed:
            freed = "true"
        return "{{ id := " + str(self.id) + ", allocMode := " + self.alloc_mode.to_lean() + ", size := " + str(self.size) + ", isFreed := " + freed + " }}"

# Variable with ownership tracking
class VarState:
    name: String
    region: MemRegion | None
    ownership: Ownership

    fn create(name: String) -> VarState:
        return VarState(name, None, Ownership.Owned)

    fn with_region(self, region: MemRegion) -> VarState:
        return VarState(self.name, region, self.ownership)

    fn is_valid(self) -> Bool:
        if self.ownership == Ownership.Moved:
            return False
        if self.region is not None and self.region.is_freed:
            return False
        return True

# NoGC context for compilation
class NoGcContext:
    regions: List<MemRegion>
    variables: List<VarState>
    next_region_id: Int
    stack_depth: Int

    fn create() -> NoGcContext:
        return NoGcContext([], [], 0, 0)

    fn alloc_stack(self, size: Int) -> (NoGcContext, MemRegion):
        region = MemRegion.create(self.next_region_id, AllocMode.Stack, size)
        new_regions = self.regions.append(region)
        return (NoGcContext(new_regions, self.variables, self.next_region_id + 1, self.stack_depth), region)

    fn alloc_heap(self, size: Int) -> (NoGcContext, MemRegion):
        region = MemRegion.create(self.next_region_id, AllocMode.Heap, size)
        new_regions = self.regions.append(region)
        return (NoGcContext(new_regions, self.variables, self.next_region_id + 1, self.stack_depth), region)

    fn free_region(self, region_id: Int) -> NoGcContext:
        new_regions = []
        for r in self.regions:
            if r.id == region_id:
                new_regions.append(MemRegion(r.id, r.alloc_mode, r.size, True))
            else:
                new_regions.append(r)
        return NoGcContext(new_regions, self.variables, self.next_region_id, self.stack_depth)

    fn enter_scope(self) -> NoGcContext:
        return NoGcContext(self.regions, self.variables, self.next_region_id, self.stack_depth + 1)

    fn exit_scope(self) -> NoGcContext:
        # Free all stack allocations at current depth
        # Simplified - would track scope per region
        return NoGcContext(self.regions, self.variables, self.next_region_id, self.stack_depth - 1)

# Check for use-after-free
fn check_use_after_free(ctx: NoGcContext, region_id: Int) -> Bool:
    for r in ctx.regions:
        if r.id == region_id:
            return r.is_freed
    return True  # Region not found = invalid

# Check for double-free
fn check_double_free(ctx: NoGcContext, region_id: Int) -> Bool:
    for r in ctx.regions:
        if r.id == region_id:
            return r.is_freed
    return False

# Specification functions

fn no_use_after_free_spec() -> String:
    return "theorem no_use_after_free : ∀ ctx var, valid_access ctx var → ¬is_freed ctx (region_of var)"

fn no_double_free_spec() -> String:
    return "theorem no_double_free : ∀ ctx region, free ctx region → ¬is_freed ctx region"

fn stack_lifetime_spec() -> String:
    return "theorem stack_lifetime : ∀ ctx var, alloc_mode var = stack → scope_of var ⊆ lifetime_of var"
