# VS Code Renderer - Extension Webview Backend
#
# Renders UI in VS Code extension webviews using VS Code Toolkit components.
# Provides native VS Code look-and-feel while maintaining compatibility with
# the unified RenderBackend trait.
#
# Key Features:
#   - VS Code Toolkit web components (vscode-button, vscode-text-field, etc.)
#   - Native VS Code theming (automatically follows VS Code theme)
#   - Message passing between webview and extension host
#   - CSP (Content Security Policy) compliant
#   - Codicons for icons
#   - VS Code-specific widgets (data-grid, panels, tree)

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*

# =============================================================================
# VS Code Async Renderer (Webview-based)
# =============================================================================

pub struct VscodeRenderer:
    # Webview state
    webview_id: String

    # Element tracking (similar to Browser renderer)
    dom_node_map: Dict<u64, VscodeNodeHandle>
    event_handlers: Dict<u64, EventCallback>

    # VS Code integration
    message_queue: Array<VscodeMessage>
    extension_state: Dict<String, Any>

    # CSP nonce for inline scripts
    csp_nonce: String

    # State
    initialized: bool
    width: u32
    height: u32
    current_tree: Option<ElementTree>

impl VscodeRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized."""
        self.initialized

    pub fn has_dom_nodes(self) -> bool:
        """Check if any DOM nodes are tracked."""
        self.dom_node_map.len() > 0

    pub fn has_event_handlers(self) -> bool:
        """Check if any event handlers are registered."""
        self.event_handlers.len() > 0

    pub fn has_pending_messages(self) -> bool:
        """Check if there are pending messages."""
        self.message_queue.len() > 0

    pub fn has_extension_state(self) -> bool:
        """Check if any extension state exists."""
        self.extension_state.len() > 0

    pub fn has_current_tree(self) -> bool:
        """Check if current tree exists."""
        match self.current_tree:
            case Some(_): true
            case None: false

    pub fn dom_node_count(self) -> usize:
        """Get number of tracked DOM nodes."""
        self.dom_node_map.len()

    pub fn event_handler_count(self) -> usize:
        """Get number of registered event handlers."""
        self.event_handlers.len()

    pub fn pending_message_count(self) -> usize:
        """Get number of pending messages."""
        self.message_queue.len()

    pub fn extension_state_count(self) -> usize:
        """Get number of extension state entries."""
        self.extension_state.len()

    pub fn get_width(self) -> u32:
        """Get webview width."""
        self.width

    pub fn get_height(self) -> u32:
        """Get webview height."""
        self.height

    pub fn aspect_ratio(self) -> f64:
        """Calculate webview aspect ratio."""
        if self.height > 0:
            (self.width as f64) / (self.height as f64)
        else:
            0.0

    pub fn is_landscape(self) -> bool:
        """Check if webview is landscape orientation."""
        self.width > self.height

    pub fn is_portrait(self) -> bool:
        """Check if webview is portrait orientation."""
        self.height > self.width

    pub fn is_square(self) -> bool:
        """Check if webview is square."""
        self.width == self.height

    pub fn summary(self) -> String:
        """Get summary of VS Code renderer state."""
        let status = if self.initialized: "initialized" else: "uninitialized"
        return "VscodeRenderer: id='{self.webview_id}', {self.width}x{self.height} ({status}), {self.dom_node_count()} nodes, {self.pending_message_count()} pending messages"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new VS Code renderer
    pub fn new(webview_id: &str) -> Result<VscodeRenderer, RenderError>:
        return Ok(VscodeRenderer {
            webview_id: webview_id.to_string(),
            dom_node_map: Dict::new(),
            event_handlers: Dict::new(),
            message_queue: Array::new(),
            extension_state: Dict::new(),
            csp_nonce: generate_csp_nonce(),
            initialized: false,
            width: 0,
            height: 0,
            current_tree: None
        })

# =============================================================================
# Async RenderBackend Implementation
# =============================================================================

impl RenderBackend for VscodeRenderer:
    async fn init(self) -> Future<Result<(), RenderError>>:
        if self.initialized:
            return Future::ready(Err(RenderError::AlreadyInitialized))

        # Check if running in VS Code webview
        let is_vscode = await vscode_is_available()
        if not is_vscode:
            return Future::ready(Err(RenderError::IoError(
                "Not running in VS Code webview"
            )))

        # Load VS Code Toolkit
        await self.load_toolkit()

        # Set up message passing
        await self.setup_message_passing()

        # Get initial dimensions
        let (width, height) = await vscode_get_webview_size()
        self.width = width
        self.height = height

        # Notify extension that webview is ready
        await self.send_message(VscodeMessage::Ready {
            webview_id: self.webview_id.clone()
        })

        self.initialized = true
        return Future::ready(Ok(()))

    async fn shutdown(self) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Notify extension of shutdown
        await self.send_message(VscodeMessage::Shutdown {
            webview_id: self.webview_id.clone()
        })

        # Clear DOM
        await vscode_clear_webview()

        # Remove event listeners
        for (_, callback) in &self.event_handlers:
            # TODO: [ui][P3] Remove event listeners
            pass

        self.dom_node_map.clear()
        self.event_handlers.clear()
        self.initialized = false

        return Future::ready(Ok(()))

    fn dimensions(self) -> (u16, u16):
        return (self.width as u16, self.height as u16)

    async fn render(self, tree: &ElementTree) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Check if we have a previous tree for diffing
        match &self.current_tree:
            case Some(old_tree):
                # Incremental update via patches
                let patches = diff(old_tree.root(), tree.root())
                await self.apply_patches_internal(&patches)
            case None:
                # Initial render - build entire DOM tree
                await self.render_initial(tree)

        # Store current tree for next diff
        self.current_tree = Some(tree.clone())

        return Future::ready(Ok(()))

    async fn apply_patches(self, patches: &PatchSet) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        await self.apply_patches_internal(patches)

        return Future::ready(Ok(()))

    async fn clear(self) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        await vscode_clear_webview()
        self.dom_node_map.clear()
        self.current_tree = None

        return Future::ready(Ok(()))

    async fn flush(self) -> Future<Result<(), RenderError>>:
        # Webview automatically flushes
        return Future::ready(Ok(()))

    async fn poll_event(self, timeout_ms: u64) -> Future<Result<Option<Event>, RenderError>>:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Check message queue first
        if not self.message_queue.is_empty():
            let msg = self.message_queue.remove(0)
            return Future::ready(Ok(Some(self.message_to_event(msg))))

        # Wait for messages from extension
        await sleep_async(timeout_ms)
        return Future::ready(Ok(None))

    async fn read_event(self) -> Future<Result<Event, RenderError>>:
        loop:
            match await self.poll_event(1000):
                case Ok(Some(event)): return Future::ready(Ok(event))
                case Ok(None): pass
                case Err(e): return Future::ready(Err(e))

# =============================================================================
# VS Code Toolkit Integration
# =============================================================================

impl VscodeRenderer:
    # Load VS Code Toolkit
    async fn load_toolkit(self) -> Future<()>:
        # Inject VS Code Toolkit script with CSP nonce
        await vscode_inject_toolkit(self.csp_nonce.as_str())
        return Future::ready(())

    # Initial render - build entire VS Code DOM tree
    async fn render_initial(self, tree: &ElementTree) -> Future<()>:
        # Clear webview
        await vscode_clear_webview()

        # Render root element and children
        let root_node = await self.render_element_to_vscode(tree.root(), None)

        # Append to webview body
        await vscode_append_to_body(root_node)

        return Future::ready(())

    # Render single element to VS Code Toolkit component
    async fn render_element_to_vscode(self, elem: &Element, parent_handle: Option<VscodeNodeHandle>)
        -> Future<VscodeNodeHandle>:
        # Map element type to VS Code Toolkit component
        let tag_name = self.map_element_to_vscode_component(elem.kind)
        let node_handle = await vscode_create_element(tag_name)

        # Store mapping
        self.dom_node_map.set(elem.id.value(), node_handle)

        # Set ID attribute
        await vscode_set_attribute(node_handle, "id", &"sui-{elem.id.value()}")

        # Set data attribute for tracking
        await vscode_set_attribute(node_handle, "data-sui-id", &elem.id.value().to_string())

        # Set key if present
        if let Some(key) = &elem.key:
            await vscode_set_attribute(node_handle, "data-key", key)

        # Apply VS Code-specific attributes based on element type
        await self.apply_vscode_attributes(node_handle, elem)

        # Set attributes
        for (name, value) in &elem.attrs:
            await vscode_set_attribute(node_handle, name, value)

        # Apply styles (converted to CSS custom properties)
        if not elem.styles.is_empty():
            let style_str = elem.styles.iter()
                .map(|(k, v)| "{k}: {v}")
                .join("; ")
            await vscode_set_attribute(node_handle, "style", &style_str)

        # Set text content
        if let Some(text) = &elem.text:
            await vscode_set_text_content(node_handle, text)

        # Add event listeners
        for (event_name, handler_id) in &elem.events:
            await self.add_vscode_event_listener(node_handle, elem.id, event_name, handler_id)

        # Render children
        for child in &elem.children:
            let child_node = await self.render_element_to_vscode(child, Some(node_handle))
            await vscode_append_child(node_handle, child_node)

        return Future::ready(node_handle)

    # Map Element kind to VS Code Toolkit component
    fn map_element_to_vscode_component(self, kind: ElementKind) -> String:
        match kind:
            case ElementKind::Button: return "vscode-button"
            case ElementKind::Input: return "vscode-text-field"
            case ElementKind::TextArea: return "vscode-text-area"
            case ElementKind::Checkbox: return "vscode-checkbox"
            case ElementKind::Radio: return "vscode-radio"
            case ElementKind::Select: return "vscode-dropdown"
            case ElementKind::Link: return "vscode-link"
            case ElementKind::Badge: return "vscode-badge"
            case ElementKind::Tag: return "vscode-tag"
            case ElementKind::Divider: return "vscode-divider"
            case ElementKind::ProgressBar: return "vscode-progress-ring"
            case ElementKind::Panel: return "vscode-panel-view"
            case ElementKind::Tabs: return "vscode-panels"
            case ElementKind::DataGrid: return "vscode-data-grid"
            case _: return "div"  # Fallback to div

    # Apply VS Code-specific attributes
    async fn apply_vscode_attributes(self, handle: VscodeNodeHandle, elem: &Element) -> Future<()>:
        match elem.kind:
            case ElementKind::Button:
                # Map button variants to VS Code appearances
                if elem.classes.contains("primary"):
                    await vscode_set_attribute(handle, "appearance", "primary")
                elif elem.classes.contains("secondary"):
                    await vscode_set_attribute(handle, "appearance", "secondary")
                elif elem.classes.contains("icon"):
                    await vscode_set_attribute(handle, "appearance", "icon")

            case ElementKind::Input | ElementKind::TextArea:
                # Set placeholder from attrs
                if let Some(placeholder) = elem.attrs.get("placeholder"):
                    await vscode_set_attribute(handle, "placeholder", placeholder)

            case ElementKind::Checkbox | ElementKind::Radio:
                # Set checked state
                if elem.attrs.get("checked").is_some():
                    await vscode_set_attribute(handle, "checked", "")

            case _:
                pass

        return Future::ready(())

    # Apply patch set to VS Code DOM
    async fn apply_patches_internal(self, patches: &PatchSet) -> Future<()>:
        for patch in patches.iter():
            match patch:
                case PatchOp::SetText { node_id, text }:
                    if let Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await vscode_set_text_content(handle, &text)

                case PatchOp::SetAttr { node_id, name, value }:
                    if let Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await vscode_set_attribute(handle, &name, &value)

                case PatchOp::RemoveAttr { node_id, name }:
                    if let Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await vscode_remove_attribute(handle, &name)

                case PatchOp::AddClass { node_id, class }:
                    if let Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await vscode_add_class(handle, &class)

                case PatchOp::RemoveClass { node_id, class }:
                    if let Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await vscode_remove_class(handle, &class)

                case PatchOp::InsertChild { parent_id, index, element }:
                    if let Some(parent_handle) = self.dom_node_map.get(&parent_id.value()):
                        let child_node = await self.render_element_to_vscode(&element, Some(parent_handle))
                        await vscode_insert_child_at(parent_handle, child_node, index)

                case PatchOp::RemoveChild { parent_id, child_id }:
                    if let Some(child_handle) = self.dom_node_map.get(&child_id.value()):
                        await vscode_remove_child(child_handle)
                        self.dom_node_map.remove(&child_id.value())

                case _:
                    # Other patch operations
                    pass

        return Future::ready(())

    # Add event listener to VS Code element
    async fn add_vscode_event_listener(self, node_handle: VscodeNodeHandle, node_id: NodeId,
                                        event_name: &str, handler_id: u64) -> Future<()>:
        # VS Code webview uses message passing for events
        let callback = |event: VscodeEvent| {
            # Send event to extension host
            self.send_message(VscodeMessage::Event {
                webview_id: self.webview_id.clone(),
                node_id: node_id,
                event_name: event_name.to_string(),
                handler_id: handler_id,
                data: event.data
            })
        }

        # Register with VS Code webview
        await vscode_add_event_listener(node_handle, event_name, callback)

        # Store callback for cleanup
        self.event_handlers.set(handler_id, callback)

        return Future::ready(())

# =============================================================================
# Message Passing (Webview ↔ Extension Host)
# =============================================================================

impl VscodeRenderer:
    # Set up bidirectional message passing
    async fn setup_message_passing(self) -> Future<()>:
        # Listen for messages from extension host
        await vscode_on_message(|msg| {
            self.handle_extension_message(msg)
        })

        return Future::ready(())

    # Send message to extension host
    async fn send_message(self, msg: VscodeMessage) -> Future<()>:
        await vscode_post_message(msg)
        return Future::ready(())

    # Handle message from extension host
    fn handle_extension_message(self, msg: VscodeMessage):
        match msg:
            case VscodeMessage::Command { command, args }:
                # Execute command from extension
                self.execute_command(&command, &args)
            case VscodeMessage::StateUpdate { key, value }:
                # Update state from extension
                self.extension_state.set(key, value)
            case _:
                # Queue other messages
                self.message_queue.push(msg)

    fn execute_command(self, command: &str, args: &Array<Any>):
        # TODO: [ui][P3] Execute extension commands
        pass

    fn message_to_event(self, msg: VscodeMessage) -> Event:
        match msg:
            case VscodeMessage::Event { node_id, event_name, data, .. }:
                # Convert VS Code event to unified Event
                return Event::Custom(event_name, data)
            case _:
                return Event::Key(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })

# =============================================================================
# VS Code Data Types
# =============================================================================

pub enum VscodeMessage:
    Ready { webview_id: String }
    Shutdown { webview_id: String }
    Event { webview_id: String, node_id: NodeId, event_name: String, handler_id: u64, data: Any }
    Command { command: String, args: Array<Any> }
    StateUpdate { key: String, value: Any }

impl VscodeMessage:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert to string representation."""
        match self:
            case Ready { webview_id }: return "Ready: {webview_id}"
            case Shutdown { webview_id }: return "Shutdown: {webview_id}"
            case Event { webview_id, event_name, .. }: return "Event: {webview_id}/{event_name}"
            case Command { command, .. }: return "Command: {command}"
            case StateUpdate { key, .. }: return "StateUpdate: {key}"

    pub fn description(self) -> String:
        """Get description of this message type."""
        match self:
            case Ready { .. }: return "Webview ready notification"
            case Shutdown { .. }: return "Webview shutdown notification"
            case Event { .. }: return "UI event from webview"
            case Command { .. }: return "Command from extension host"
            case StateUpdate { .. }: return "State update from extension"

    pub fn is_ready(self) -> bool:
        """Check if this is a ready message."""
        match self:
            case Ready { .. }: true
            case _: false

    pub fn is_shutdown(self) -> bool:
        """Check if this is a shutdown message."""
        match self:
            case Shutdown { .. }: true
            case _: false

    pub fn is_event(self) -> bool:
        """Check if this is an event message."""
        match self:
            case Event { .. }: true
            case _: false

    pub fn is_command(self) -> bool:
        """Check if this is a command message."""
        match self:
            case Command { .. }: true
            case _: false

    pub fn is_state_update(self) -> bool:
        """Check if this is a state update message."""
        match self:
            case StateUpdate { .. }: true
            case _: false

    pub fn is_lifecycle_message(self) -> bool:
        """Check if this is a lifecycle message (ready or shutdown)."""
        self.is_ready() or self.is_shutdown()

    pub fn summary(self) -> String:
        """Get VS Code message summary.

        Returns:
            Human-readable summary

        Example:
            VscodeMessage::Ready{webview_id: "main"}.summary()
            # → "VscodeMessage: Ready: main (Webview ready notification, lifecycle)"
        """
        let name = self.to_string()
        let desc = self.description()
        let category = if self.is_lifecycle_message():
            "lifecycle"
        elif self.is_event():
            "event"
        elif self.is_command():
            "command"
        else:
            "state"
        return "VscodeMessage: {name} ({desc}, {category})"

pub struct VscodeEvent:
    event_type: String
    data: Any

impl VscodeEvent:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_data(self) -> bool:
        """Check if event has data."""
        # Assuming Any type has some way to check if it's non-empty
        # For now, we'll assume it always has data
        true

    pub fn summary(self) -> String:
        """Get summary of VS Code event."""
        return "VscodeEvent: {self.event_type}"

# =============================================================================
# VS Code Webview API (FFI)
# =============================================================================

type VscodeNodeHandle = i64
type EventCallback = fn(VscodeEvent) -> ()

# Environment check
extern fn vscode_is_available() -> bool

# Toolkit loading
extern async fn vscode_inject_toolkit(nonce: &str) -> Future<()>

# Webview management
extern async fn vscode_get_webview_size() -> Future<(u32, u32)>
extern async fn vscode_clear_webview() -> Future<()>
extern async fn vscode_append_to_body(node: VscodeNodeHandle) -> Future<()>

# Element creation and manipulation
extern async fn vscode_create_element(tag_name: &str) -> Future<VscodeNodeHandle>
extern async fn vscode_set_attribute(handle: VscodeNodeHandle, name: &str, value: &str) -> Future<()>
extern async fn vscode_remove_attribute(handle: VscodeNodeHandle, name: &str) -> Future<()>
extern async fn vscode_set_text_content(handle: VscodeNodeHandle, text: &str) -> Future<()>
extern async fn vscode_append_child(parent: VscodeNodeHandle, child: VscodeNodeHandle) -> Future<()>
extern async fn vscode_insert_child_at(parent: VscodeNodeHandle, child: VscodeNodeHandle, index: u64) -> Future<()>
extern async fn vscode_remove_child(child: VscodeNodeHandle) -> Future<()>

# Classes
extern async fn vscode_add_class(handle: VscodeNodeHandle, class: &str) -> Future<()>
extern async fn vscode_remove_class(handle: VscodeNodeHandle, class: &str) -> Future<()>

# Events
extern async fn vscode_add_event_listener(handle: VscodeNodeHandle, event_name: &str, callback: EventCallback) -> Future<()>

# Message passing
extern async fn vscode_post_message(msg: VscodeMessage) -> Future<()>
extern async fn vscode_on_message(callback: fn(VscodeMessage)) -> Future<()>

# Utilities
fn generate_csp_nonce() -> String:
    # Generate random CSP nonce for inline scripts
    # TODO: [ui][P1] Implement secure random generation
    return "nonce-" + random_string(32)

fn random_string(len: usize) -> String:
    # TODO: [ui][P1] Implement secure random string generation
    return "abc123"
