# LineEditor Widget for Simple TUI Framework
#
# A multi-line text editor widget designed for REPL-style applications.
# Provides smart features like auto-indentation and smart backspace.
#
# Features:
#   - Smart backspace: Deletes 4 spaces at once in leading whitespace
#   - Auto-indent: Adds 4 spaces after lines ending with ':'
#   - Multiline mode: Continues accepting input until empty line or completion
#   - Submission callback: Notifies when input is complete
#   - Immediate-mode rendering with Ratatui
#
# Usage:
#   let editor = LineEditor::new(terminal)
#   editor.on_submit(fn(text: String):
#       print("Submitted: " + text)
#   )
#
#   while running:
#       editor.render(">>> ")
#       let event = read_event(100)
#       if event.event_type == EventType::Key:
#           editor.handle_event(event)

use ui.tui.backend.ratatui.*

## LineEditor widget for REPL-style input
pub struct LineEditor:
    terminal: TerminalHandle
    buffer: TextBufferHandle
    lines: Array<String>
    in_multiline: bool
    on_submit_callback: Option<fn(String)>
    prompt_normal: String
    prompt_continue: String

impl LineEditor:
    ## Create a new LineEditor
    ##
    ## Example:
    ##   let editor = LineEditor::new(terminal)
    pub fn new(terminal: TerminalHandle) -> LineEditor:
        let buffer = textbuffer_new()
        return LineEditor {
            terminal: terminal,
            buffer: buffer,
            lines: [],
            in_multiline: false,
            on_submit_callback: None,
            prompt_normal: ">>> ",
            prompt_continue: "... "
        }

    ## Set the submission callback
    ##
    ## Called when user completes input (Enter on single line, or empty line in multiline)
    ##
    ## Example:
    ##   editor.on_submit(fn(input: String):
    ##       execute_code(input)
    ##   )
    pub fn on_submit(self, callback: fn(String)):
        self.on_submit_callback = Some(callback)

    ## Set custom prompts
    ##
    ## Example:
    ##   editor.set_prompts("λ> ", ".. ")
    pub fn set_prompts(self, normal: String, continue_prompt: String):
        self.prompt_normal = normal
        self.prompt_continue = continue_prompt

    ## Get current multiline status
    pub fn is_multiline(self) -> bool:
        return self.in_multiline

    ## Render the editor
    ##
    ## Uses immediate-mode rendering - call every frame.
    ## Automatically selects prompt based on multiline status.
    ##
    ## Example:
    ##   editor.render()
    pub fn render(self):
        let prompt = if self.in_multiline:
            self.prompt_continue
        else:
            self.prompt_normal

        render_textbuffer(self.terminal, self.buffer, prompt)

    ## Render with custom prompt
    ##
    ## Example:
    ##   editor.render_with_prompt("custom> ")
    pub fn render_with_prompt(self, prompt: &str):
        render_textbuffer(self.terminal, self.buffer, prompt)

    ## Handle a keyboard event
    ##
    ## Processes special keys (Enter, Backspace, etc.) and printable characters.
    ##
    ## Example:
    ##   if event.event_type == EventType::Key:
    ##       editor.handle_event(event)
    pub fn handle_event(self, event: TuiEvent):
        if event.event_type != EventType::Key:
            return

        # Handle special keys
        if event.key_code == KEY_ENTER:
            self.handle_enter()
        else if event.key_code == KEY_BACKSPACE:
            self.handle_backspace()
        else if event.key_code == KEY_TAB:
            self.handle_tab()
        else if is_printable(event.key_code):
            # Insert printable character
            let ch = chr(event.char_value)
            textbuffer_insert_char(self.buffer, ch)

    ## Clear the current input
    pub fn clear(self):
        textbuffer_set_text(self.buffer, "")
        self.lines = []
        self.in_multiline = false

    ## Get the current line text
    pub fn get_current_line(self) -> String:
        return textbuffer_get_text(self.buffer)

    ## Get all lines (including current)
    pub fn get_all_lines(self) -> Array<String>:
        let current = self.get_current_line()
        if self.lines.len() > 0:
            let mut all = self.lines.clone()
            all.push(current)
            return all
        else:
            return [current]

    # ========================================================================
    # Private Methods
    # ========================================================================

    ## Handle Enter key
    fn handle_enter(self):
        let line = textbuffer_get_text(self.buffer)

        # Check if line ends with ':' (entering multiline mode)
        if line.trim_end().ends_with(':'):
            # Enter multiline mode
            self.lines.push(line)
            self.in_multiline = true

            # Auto-indent: add 4 spaces
            let indent = self.calculate_indent(&line) + 4
            let indent_str = " ".repeat(indent)
            textbuffer_set_text(self.buffer, &indent_str)

        else if self.in_multiline:
            # In multiline mode
            if line.trim().is_empty():
                # Empty line - complete multiline block
                let full_input = self.lines.join("\n")
                self.lines = []
                self.in_multiline = false
                textbuffer_set_text(self.buffer, "")

                # Call submission callback
                if let Some(callback) = self.on_submit_callback:
                    callback(full_input)
            else:
                # Continue multiline - add line and prepare next
                self.lines.push(line)

                # Calculate indent for next line
                let indent = self.calculate_indent(&line)
                let indent_str = " ".repeat(indent)
                textbuffer_set_text(self.buffer, &indent_str)
        else:
            # Single line mode - submit immediately
            if let Some(callback) = self.on_submit_callback:
                callback(line)

            textbuffer_set_text(self.buffer, "")

    ## Handle Backspace key with smart deletion
    fn handle_backspace(self):
        let text = textbuffer_get_text(self.buffer)

        if text.is_empty():
            return

        # Smart backspace: delete 4 spaces in leading whitespace
        let leading_spaces = text.chars().take_while(|c| c == ' ').count()
        let cursor_pos = text.len()  # Cursor at end of line

        if cursor_pos == leading_spaces and cursor_pos >= 4:
            # We're in leading whitespace with at least 4 spaces
            # Delete 4 spaces at once
            let new_text = &text[0..cursor_pos - 4]
            textbuffer_set_text(self.buffer, new_text)
        else:
            # Normal backspace - let buffer handle it
            textbuffer_backspace(self.buffer)

    ## Handle Tab key (insert 4 spaces)
    fn handle_tab(self):
        textbuffer_insert_char(self.buffer, ' ')
        textbuffer_insert_char(self.buffer, ' ')
        textbuffer_insert_char(self.buffer, ' ')
        textbuffer_insert_char(self.buffer, ' ')

    ## Calculate indentation level of a line
    fn calculate_indent(self, line: &str) -> usize:
        return line.chars().take_while(|c| c == ' ').count()

    ## Cleanup resources
    pub fn destroy(self):
        object_destroy(self.buffer)

# ============================================================================
# Example Usage
# ============================================================================

## Example: Simple REPL with LineEditor
##
## ```simple
## use ui.tui.backend.ratatui.*
## use ui.tui.widgets.line_editor.*
##
## fn main():
##     let term = terminal_new()
##     let editor = LineEditor::new(term)
##
##     editor.on_submit(fn(input: String):
##         print(">>> " + input)
##         # Execute the input...
##     )
##
##     let mut running = true
##     while running:
##         # Render current state
##         editor.render()
##
##         # Poll for events
##         let event = read_event(100)
##
##         # Handle event
##         if event.event_type == EventType::Key:
##             if event.key_code == KEY_ESCAPE:
##                 running = false
##             else:
##                 editor.handle_event(event)
##
##     # Cleanup
##     editor.destroy()
##     terminal_cleanup(term)
## ```

## Example: Multiline input
##
## ```simple
## # User types:
## if 1:         # Press Enter → auto-indents to 4 spaces
##     print(1)  # Press Enter → continues multiline
##               # Press Enter on empty line → submits block
##
## # Callback receives:
## "if 1:\n    print(1)"
## ```

## Example: Smart backspace
##
## ```simple
## # User types:
## "    " + "code"  # 4 spaces + code
## # Press Backspace while cursor in leading spaces
## # → Deletes all 4 spaces at once
## ```
