# Viewport - Screen and Viewport Management
#
# Platform-agnostic viewport and screen management for UI rendering.
# Handles window size, DPI scaling, orientation, and layout constraints.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.widget.*

# Viewport dimensions and properties
pub struct Viewport:
    # Physical dimensions (pixels)
    pub width: u32
    pub height: u32
    # Logical dimensions (DIP - device-independent pixels)
    pub logical_width: f64
    pub logical_height: f64
    # Device pixel ratio (physical pixels per logical pixel)
    pub dpr: f64
    # Safe area insets (for notched screens, etc.)
    pub safe_area: EdgeInsets
    # Viewport orientation
    pub orientation: Orientation

# Screen orientation
pub enum Orientation:
    Portrait
    Landscape
    PortraitReverse
    LandscapeReverse

impl Orientation:
    pub fn to_string(self) -> String:
        """Convert orientation to string."""
        match self:
            case Portrait: "portrait"
            case Landscape: "landscape"
            case PortraitReverse: "portrait-reverse"
            case LandscapeReverse: "landscape-reverse"

    pub fn description(self) -> String:
        """Get orientation description."""
        match self:
            case Portrait: "Portrait orientation (vertical)"
            case Landscape: "Landscape orientation (horizontal)"
            case PortraitReverse: "Portrait orientation reversed (upside down)"
            case LandscapeReverse: "Landscape orientation reversed (rotated 180Â°)"

    pub fn is_portrait(self) -> bool:
        match self:
            case Orientation::Portrait: return true
            case Orientation::PortraitReverse: return true
            case _: return false

    pub fn is_landscape(self) -> bool:
        return not self.is_portrait()

    pub fn is_reversed(self) -> bool:
        """Check if orientation is reversed."""
        match self:
            case PortraitReverse: true
            case LandscapeReverse: true
            case _: false

    pub fn is_normal(self) -> bool:
        """Check if orientation is normal (not reversed)."""
        return not self.is_reversed()

    pub fn summary(self) -> String:
        """Get orientation summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.is_portrait():
            props.push("vertical")
        else:
            props.push("horizontal")
        if self.is_reversed():
            props.push("reversed")
        let props_str = props.join(", ")
        return "Orientation: {name} ({desc}, {props_str})"

impl Viewport:
    # Create a viewport with physical dimensions
    pub fn new(width: u32, height: u32, dpr: f64) -> Viewport:
        return Viewport {
            width: width,
            height: height,
            logical_width: (width as f64) / dpr,
            logical_height: (height as f64) / dpr,
            dpr: dpr,
            safe_area: EdgeInsets::zero(),
            orientation: if width > height {
                Orientation::Landscape
            } else {
                Orientation::Portrait
            }
        }

    # Create from logical dimensions
    pub fn from_logical(logical_width: f64, logical_height: f64, dpr: f64) -> Viewport:
        return Viewport {
            width: (logical_width * dpr) as u32,
            height: (logical_height * dpr) as u32,
            logical_width: logical_width,
            logical_height: logical_height,
            dpr: dpr,
            safe_area: EdgeInsets::zero(),
            orientation: if logical_width > logical_height {
                Orientation::Landscape
            } else {
                Orientation::Portrait
            }
        }

    # Set safe area insets
    pub fn with_safe_area(self, insets: EdgeInsets) -> Viewport:
        self.safe_area = insets
        return self

    # Get aspect ratio
    pub fn aspect_ratio(self) -> f64:
        return self.logical_width / self.logical_height

    # Convert physical pixels to logical
    pub fn to_logical(self, physical: i32) -> f64:
        return (physical as f64) / self.dpr

    # Convert logical pixels to physical
    pub fn to_physical(self, logical: f64) -> i32:
        return (logical * self.dpr) as i32

    # Get usable area (excluding safe area)
    pub fn usable_width(self) -> f64:
        return self.logical_width - (self.safe_area.left as f64) - (self.safe_area.right as f64)

    pub fn usable_height(self) -> f64:
        return self.logical_height - (self.safe_area.top as f64) - (self.safe_area.bottom as f64)

# Viewport constraints for responsive layout
pub struct ViewportConstraints:
    pub min_width: Option<f64>
    pub max_width: Option<f64>
    pub min_height: Option<f64>
    pub max_height: Option<f64>

impl ViewportConstraints:
    pub fn unbounded() -> ViewportConstraints:
        return ViewportConstraints {
            min_width: None,
            max_width: None,
            min_height: None,
            max_height: None
        }

    pub fn tight(width: f64, height: f64) -> ViewportConstraints:
        return ViewportConstraints {
            min_width: Some(width),
            max_width: Some(width),
            min_height: Some(height),
            max_height: Some(height)
        }

    pub fn check_viewport(self, viewport: &Viewport) -> bool:
        if let Some(min_w) = self.min_width:
            if viewport.logical_width < min_w:
                return false

        if let Some(max_w) = self.max_width:
            if viewport.logical_width > max_w:
                return false

        if let Some(min_h) = self.min_height:
            if viewport.logical_height < min_h:
                return false

        if let Some(max_h) = self.max_height:
            if viewport.logical_height > max_h:
                return false

        return true

# Responsive breakpoints (common screen sizes)
pub struct Breakpoints:
    pub xs: f64   # Extra small (mobile portrait)
    pub sm: f64   # Small (mobile landscape, small tablets)
    pub md: f64   # Medium (tablets)
    pub lg: f64   # Large (desktop)
    pub xl: f64   # Extra large (large desktop)
    pub xxl: f64  # Extra extra large (ultra-wide)

impl Breakpoints:
    # Default breakpoints (based on common conventions)
    pub fn default() -> Breakpoints:
        return Breakpoints {
            xs: 0.0,
            sm: 640.0,
            md: 768.0,
            lg: 1024.0,
            xl: 1280.0,
            xxl: 1536.0
        }

    # Get current breakpoint for viewport
    pub fn current(self, viewport: &Viewport) -> BreakpointSize:
        let width = viewport.logical_width

        if width >= self.xxl:
            return BreakpointSize::XXL
        else if width >= self.xl:
            return BreakpointSize::XL
        else if width >= self.lg:
            return BreakpointSize::LG
        else if width >= self.md:
            return BreakpointSize::MD
        else if width >= self.sm:
            return BreakpointSize::SM
        else:
            return BreakpointSize::XS

pub enum BreakpointSize:
    XS
    SM
    MD
    LG
    XL
    XXL

impl BreakpointSize:
    pub fn to_string(self) -> String:
        """Convert breakpoint size to string."""
        match self:
            case XS: "xs"
            case SM: "sm"
            case MD: "md"
            case LG: "lg"
            case XL: "xl"
            case XXL: "xxl"

    pub fn description(self) -> String:
        """Get breakpoint size description."""
        match self:
            case XS: "Extra small (mobile portrait, <640px)"
            case SM: "Small (mobile landscape, small tablets, 640px+)"
            case MD: "Medium (tablets, 768px+)"
            case LG: "Large (desktop, 1024px+)"
            case XL: "Extra large (large desktop, 1280px+)"
            case XXL: "Extra extra large (ultra-wide, 1536px+)"

    pub fn is_xs(self) -> bool:
        """Check if size is XS."""
        match self:
            case XS: true
            case _: false

    pub fn is_sm(self) -> bool:
        """Check if size is SM."""
        match self:
            case SM: true
            case _: false

    pub fn is_md(self) -> bool:
        """Check if size is MD."""
        match self:
            case MD: true
            case _: false

    pub fn is_lg(self) -> bool:
        """Check if size is LG."""
        match self:
            case LG: true
            case _: false

    pub fn is_xl(self) -> bool:
        """Check if size is XL."""
        match self:
            case XL: true
            case _: false

    pub fn is_xxl(self) -> bool:
        """Check if size is XXL."""
        match self:
            case XXL: true
            case _: false

    pub fn is_mobile(self) -> bool:
        """Check if size is mobile (XS or SM)."""
        match self:
            case XS: true
            case SM: true
            case _: false

    pub fn is_tablet(self) -> bool:
        """Check if size is tablet (MD)."""
        match self:
            case MD: true
            case _: false

    pub fn is_desktop(self) -> bool:
        """Check if size is desktop (LG or larger)."""
        match self:
            case LG: true
            case XL: true
            case XXL: true
            case _: false

    pub fn summary(self) -> String:
        """Get breakpoint size summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut device_type = if self.is_mobile():
            "mobile"
        elif self.is_tablet():
            "tablet"
        else:
            "desktop"
        return "BreakpointSize: {name} ({desc}, {device_type})"

# Screen manager - tracks viewport changes
pub struct ScreenManager:
    viewport: Viewport
    breakpoints: Breakpoints
    listeners: Array<fn(&Viewport)>

impl ScreenManager:
    # Create a new screen manager
    pub fn new(viewport: Viewport) -> ScreenManager:
        return ScreenManager {
            viewport: viewport,
            breakpoints: Breakpoints::default(),
            listeners: []
        }

    # Get current viewport
    pub fn viewport(self) -> &Viewport:
        return &self.viewport

    # Update viewport (e.g., on window resize)
    pub fn update_viewport(self, new_viewport: Viewport):
        let old_breakpoint = self.breakpoints.current(&self.viewport)
        let new_breakpoint = self.breakpoints.current(&new_viewport)

        self.viewport = new_viewport

        # Notify listeners
        for listener in &self.listeners:
            listener(&self.viewport)

        # Check if breakpoint changed (for responsive layouts)
        if old_breakpoint != new_breakpoint:
            # Would trigger layout recalculation
            pass

    # Register a viewport change listener
    pub fn on_resize(self, listener: fn(&Viewport)):
        self.listeners.push(listener)

    # Get current breakpoint
    pub fn current_breakpoint(self) -> BreakpointSize:
        return self.breakpoints.current(&self.viewport)

    # Check if viewport matches constraints
    pub fn matches(self, constraints: &ViewportConstraints) -> bool:
        return constraints.check_viewport(&self.viewport)

# Responsive widget wrapper - adapts to viewport
pub struct Responsive:
    child: Box<dyn Widget>
    builder: fn(&Viewport) -> Box<dyn Widget>

impl Responsive:
    # Create responsive widget with builder
    pub fn new(builder: fn(&Viewport) -> Box<dyn Widget>) -> Responsive:
        return Responsive {
            child: Box::new(EmptyWidget::new()),  # Placeholder
            builder: builder
        }

    # Create with breakpoint-specific builders
    pub fn breakpoints(
        xs: Option<fn() -> Box<dyn Widget>>,
        sm: Option<fn() -> Box<dyn Widget>>,
        md: Option<fn() -> Box<dyn Widget>>,
        lg: Option<fn() -> Box<dyn Widget>>,
        xl: Option<fn() -> Box[dyn Widget>>
    ) -> Responsive:
        return Responsive::new(|viewport|:
            let size = Breakpoints::default().current(viewport)
            match size:
                case BreakpointSize::XS: return xs.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::SM: return sm.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::MD: return md.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::LG: return lg.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::XL: return xl.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::XXL: return xl.unwrap_or(|| Box::new(EmptyWidget::new()))()
        )

# Empty widget (placeholder)
pub struct EmptyWidget:
    pass

impl EmptyWidget:
    pub fn new() -> EmptyWidget:
        return EmptyWidget {}

impl Widget for EmptyWidget:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let elem = Element::new(id, ElementKind::Div)
        return WidgetNode::new(elem)

# MediaQuery - access viewport information in widget tree
pub struct MediaQuery:
    viewport: Viewport

impl MediaQuery:
    pub fn new(viewport: Viewport) -> MediaQuery:
        return MediaQuery { viewport: viewport }

    # Get viewport
    pub fn viewport(self) -> &Viewport:
        return &self.viewport

    # Get size
    pub fn size(self) -> (f64, f64):
        return (self.viewport.logical_width, self.viewport.logical_height)

    # Get orientation
    pub fn orientation(self) -> Orientation:
        return self.viewport.orientation

    # Check if portrait
    pub fn is_portrait(self) -> bool:
        return self.viewport.orientation.is_portrait()

    # Check if landscape
    pub fn is_landscape(self) -> bool:
        return self.viewport.orientation.is_landscape()

    # Get device pixel ratio
    pub fn device_pixel_ratio(self) -> f64:
        return self.viewport.dpr

    # Get platform-specific information
    pub fn platform_brightness(self) -> PlatformBrightness:
        # Would query platform theme
        return PlatformBrightness::Light

pub enum PlatformBrightness:
    Light
    Dark

impl PlatformBrightness:
    pub fn to_string(self) -> String:
        """Convert platform brightness to string."""
        match self:
            case Light: "light"
            case Dark: "dark"

    pub fn description(self) -> String:
        """Get platform brightness description."""
        match self:
            case Light: "Light theme (bright background)"
            case Dark: "Dark theme (dark background)"

    pub fn is_light(self) -> bool:
        """Check if brightness is Light."""
        match self:
            case Light: true
            case _: false

    pub fn is_dark(self) -> bool:
        """Check if brightness is Dark."""
        match self:
            case Dark: true
            case _: false

    pub fn summary(self) -> String:
        """Get platform brightness summary."""
        let name = self.to_string()
        let desc = self.description()
        return "PlatformBrightness: {name} ({desc})"

# Example usage:
#
# let screen = ScreenManager::new(Viewport::new(1920, 1080, 1.0))
#
# screen.on_resize(|viewport|:
#     print("Window resized: {viewport.logical_width}x{viewport.logical_height}")
# )
#
# # Responsive widget
# Responsive::breakpoints(
#     xs: Some(|| Box::new(Text::new("Mobile"))),
#     md: Some(|| Box::new(Text::new("Tablet"))),
#     lg: Some(|| Box::new(Text::new("Desktop")))
# )
