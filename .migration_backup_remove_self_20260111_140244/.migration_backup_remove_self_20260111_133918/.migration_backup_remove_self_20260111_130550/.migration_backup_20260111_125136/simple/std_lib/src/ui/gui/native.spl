# Native Renderer - Desktop Window GUI
#
# Renders UI elements to a native desktop window using a framebuffer.
# Uses minimal FFI for window creation and pixel manipulation.
# Backend agnostic - can be backed by minifb, SDL, or platform-specific APIs.

use core.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*

# Native window renderer
pub struct NativeRenderer:
    window: WindowHandle
    width: u32
    height: u32
    framebuffer: Array<u32>  # RGBA pixels
    layout_cache: LayoutCache
    font: FontHandle
    initialized: bool
    # Dirty rectangles for partial updates
    dirty_rects: Array<Rect>

impl NativeRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized."""
        self.initialized

    pub fn has_dirty_rects(self) -> bool:
        """Check if there are dirty rectangles."""
        self.dirty_rects.len() > 0

    pub fn dirty_rect_count(self) -> usize:
        """Get number of dirty rectangles."""
        self.dirty_rects.len()

    pub fn pixel_count(self) -> u64:
        """Get total number of pixels in framebuffer."""
        (self.width as u64) * (self.height as u64)

    pub fn framebuffer_size_bytes(self) -> u64:
        """Get framebuffer size in bytes."""
        self.pixel_count() * 4  # 4 bytes per pixel (RGBA)

    pub fn get_width(self) -> u32:
        """Get window width."""
        self.width

    pub fn get_height(self) -> u32:
        """Get window height."""
        self.height

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio."""
        if self.height > 0:
            (self.width as f64) / (self.height as f64)
        else:
            0.0

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation."""
        self.width > self.height

    pub fn is_portrait(self) -> bool:
        """Check if window is portrait orientation."""
        self.height > self.width

    pub fn is_square(self) -> bool:
        """Check if window is square."""
        self.width == self.height

    pub fn is_valid_coordinate(self, x: u32, y: u32) -> bool:
        """Check if coordinate is within window bounds."""
        x < self.width and y < self.height

    pub fn summary(self) -> String:
        """Get summary of native renderer state."""
        let status = if self.initialized: "initialized" else: "uninitialized"
        let pixels = self.pixel_count()
        let dirty = self.dirty_rect_count()
        return "NativeRenderer: {self.width}x{self.height} ({status}), {pixels} pixels, {dirty} dirty rects"

# Rectangle for dirty tracking
struct Rect:
    x: u32
    y: u32
    width: u32
    height: u32

impl Rect:
    fn new(x: u32, y: u32, w: u32, h: u32) -> Rect:
        return Rect { x: x, y: y, width: w, height: h }

    fn contains(self, px: u32, py: u32) -> bool:
        return px >= self.x and px < self.x + self.width
            and py >= self.y and py < self.y + self.height

    fn intersects(self, other: &Rect) -> bool:
        return not (self.x + self.width <= other.x
            or other.x + other.width <= self.x
            or self.y + self.height <= other.y
            or other.y + other.height <= self.y)

    fn union(self, other: &Rect) -> Rect:
        let x = self.x.min(other.x)
        let y = self.y.min(other.y)
        let x2 = (self.x + self.width).max(other.x + other.width)
        let y2 = (self.y + self.height).max(other.y + other.height)
        return Rect::new(x, y, x2 - x, y2 - y)

    pub fn is_empty(self) -> bool:
        """Check if rectangle has zero area.

        Returns:
            True if width or height is 0
        """
        self.width == 0 or self.height == 0

    pub fn area(self) -> u64:
        """Calculate rectangle area.

        Returns:
            Area in pixels
        """
        (self.width as u64) * (self.height as u64)

    pub fn is_point(self) -> bool:
        """Check if rectangle is a single point.

        Returns:
            True if both width and height are 1
        """
        self.width == 1 and self.height == 1

    pub fn center(self) -> (u32, u32):
        """Get rectangle center point.

        Returns:
            Tuple of (center_x, center_y)
        """
        let cx = self.x + self.width / 2
        let cy = self.y + self.height / 2
        return (cx, cy)

    pub fn is_square(self) -> bool:
        """Check if rectangle is square.

        Returns:
            True if width equals height
        """
        self.width == self.height

    pub fn summary(self) -> String:
        """Get rectangle summary.

        Returns:
            Human-readable summary
        """
        let area = self.area()
        return "Rect: ({self.x},{self.y}) {self.width}x{self.height} ({area} px)"

    pub fn aspect_ratio(self) -> f64:
        """Calculate aspect ratio.

        Returns:
            Width divided by height
        """
        if self.height > 0:
            (self.width as f64) / (self.height as f64)
        else:
            0.0

    pub fn is_landscape(self) -> bool:
        """Check if rectangle is landscape.

        Returns:
            True if width > height
        """
        self.width > self.height

    pub fn is_portrait(self) -> bool:
        """Check if rectangle is portrait.

        Returns:
            True if height > width
        """
        self.height > self.width

# Window handle (opaque FFI pointer)
type WindowHandle = i64

# Font handle (opaque FFI pointer)
type FontHandle = i64

impl NativeRenderer:
    # Create a new native renderer
    pub fn new(title: &str, width: u32, height: u32) -> Result<NativeRenderer, RenderError>:
        let window = native_window_create(title.as_ptr(), title.len() as u64, width, height)
        if window == 0:
            return Err(RenderError::IoError("Failed to create window".to_string()))

        let font = native_font_default()
        if font == 0:
            native_window_destroy(window)
            return Err(RenderError::IoError("Failed to load font".to_string()))

        let size = (width * height) as u64
        let mut framebuffer: Array<u32> = []
        for _ in 0..size:
            framebuffer.push(0xFFFFFFFF)  # White background

        return Ok(NativeRenderer {
            window: window,
            width: width,
            height: height,
            framebuffer: framebuffer,
            layout_cache: LayoutCache::new(),
            font: font,
            initialized: false,
            dirty_rects: []
        })

    # Clear the framebuffer
    pub fn clear_buffer(self, color: u32):
        for i in 0..self.framebuffer.len():
            self.framebuffer[i] = color
        self.mark_dirty(0, 0, self.width, self.height)

    # Set a pixel in the framebuffer
    pub fn set_pixel(self, x: u32, y: u32, color: u32):
        if x < self.width and y < self.height:
            let idx = (y * self.width + x) as u64
            self.framebuffer[idx] = color

    # Get a pixel from the framebuffer
    pub fn get_pixel(self, x: u32, y: u32) -> u32:
        if x < self.width and y < self.height:
            let idx = (y * self.width + x) as u64
            return self.framebuffer[idx]
        return 0

    # Draw a filled rectangle
    pub fn fill_rect(self, x: u32, y: u32, w: u32, h: u32, color: u32):
        let x2 = (x + w).min(self.width)
        let y2 = (y + h).min(self.height)

        for py in y..y2:
            for px in x..x2:
                self.set_pixel(px, py, color)

        self.mark_dirty(x, y, w, h)

    # Draw a rectangle outline
    pub fn draw_rect(self, x: u32, y: u32, w: u32, h: u32, color: u32):
        # Top and bottom edges
        for px in x..(x + w).min(self.width):
            self.set_pixel(px, y, color)
            if y + h - 1 < self.height:
                self.set_pixel(px, y + h - 1, color)

        # Left and right edges
        for py in y..(y + h).min(self.height):
            self.set_pixel(x, py, color)
            if x + w - 1 < self.width:
                self.set_pixel(x + w - 1, py, color)

        self.mark_dirty(x, y, w, h)

    # Draw a rounded rectangle
    pub fn draw_rounded_rect(self, x: u32, y: u32, w: u32, h: u32, radius: u32, color: u32):
        let r = radius.min(w / 2).min(h / 2)

        # Horizontal edges (excluding corners)
        for px in (x + r)..(x + w - r):
            self.set_pixel(px, y, color)
            self.set_pixel(px, y + h - 1, color)

        # Vertical edges (excluding corners)
        for py in (y + r)..(y + h - r):
            self.set_pixel(x, py, color)
            self.set_pixel(x + w - 1, py, color)

        # Corners (simple approximation)
        self.draw_corner(x + r, y + r, r, 0, color)  # Top-left
        self.draw_corner(x + w - r - 1, y + r, r, 1, color)  # Top-right
        self.draw_corner(x + r, y + h - r - 1, r, 2, color)  # Bottom-left
        self.draw_corner(x + w - r - 1, y + h - r - 1, r, 3, color)  # Bottom-right

        self.mark_dirty(x, y, w, h)

    # Draw a corner arc (simplified)
    fn draw_corner(self, cx: u32, cy: u32, r: u32, quadrant: u8, color: u32):
        # Simple circle approximation
        for i in 0..=r:
            let dx = i
            let dy = r - i  # Simplified - should use sqrt for proper circle

            match quadrant:
                case 0:  # Top-left
                    self.set_pixel(cx - dx, cy - dy, color)
                case 1:  # Top-right
                    self.set_pixel(cx + dx, cy - dy, color)
                case 2:  # Bottom-left
                    self.set_pixel(cx - dx, cy + dy, color)
                case 3:  # Bottom-right
                    self.set_pixel(cx + dx, cy + dy, color)

    # Draw text
    pub fn draw_text(self, x: u32, y: u32, text: &str, color: u32):
        native_draw_text(
            self.framebuffer.as_ptr() as i64,
            self.width,
            self.height,
            x,
            y,
            text.as_ptr(),
            text.len() as u64,
            color,
            self.font
        )
        # Estimate dirty rect (approximate text bounds)
        let w = (text.len() as u32) * 8  # Assuming 8px per character
        let h: u32 = 16  # Assuming 16px font height
        self.mark_dirty(x, y, w, h)

    # Draw text with background
    pub fn draw_text_bg(self, x: u32, y: u32, text: &str, fg: u32, bg: u32):
        let w = (text.len() as u32) * 8
        let h: u32 = 16
        self.fill_rect(x, y, w, h, bg)
        self.draw_text(x, y, text, fg)

    # Mark region as dirty
    fn mark_dirty(self, x: u32, y: u32, w: u32, h: u32):
        self.dirty_rects.push(Rect::new(x, y, w, h))

    # Flush framebuffer to window
    pub fn present(self) -> Result<(), RenderError>:
        let result = native_window_present(
            self.window,
            self.framebuffer.as_ptr() as i64,
            self.width,
            self.height
        )
        if result != 0:
            return Err(RenderError::IoError("Failed to present framebuffer".to_string()))
        self.dirty_rects.clear()
        return Ok(())

impl RenderBackend for NativeRenderer:
    fn init(self) -> Result<(), RenderError>:
        if self.initialized:
            return Err(RenderError::AlreadyInitialized)

        self.initialized = true
        self.clear_buffer(0xFFFFFFFF)  # White background
        return Ok(())

    fn shutdown(self) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        native_window_destroy(self.window)
        self.initialized = false
        return Ok(())

    fn dimensions(self) -> (u16, u16):
        return (self.width as u16, self.height as u16)

    fn render(self, tree: &ElementTree) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        self.layout_cache.clear()
        self.clear_buffer(0xFFFFFFFF)

        let root_layout = Layout::new(0, 0, self.width as u16, self.height as u16)
        self.render_element(tree.root(), root_layout)

        return self.present()

    fn apply_patches(self, patches: &PatchSet) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # For now, re-render affected areas
        for patch in patches.iter():
            if let Some(layout) = self.layout_cache.get(patch.target_id()):
                self.mark_dirty(
                    layout.x as u32,
                    layout.y as u32,
                    layout.width as u32,
                    layout.height as u32
                )

        return self.present()

    fn clear(self) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        self.clear_buffer(0xFFFFFFFF)
        return self.present()

    fn flush(self) -> Result<(), RenderError>:
        return self.present()

    fn poll_event(self, timeout_ms: u64) -> Result<Option<Event>, RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        let event_type = native_window_poll_event(self.window, timeout_ms)
        if event_type == 0:
            return Ok(None)

        return Ok(Some(self.decode_event(event_type)))

    fn read_event(self) -> Result<Event, RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        loop:
            let event_type = native_window_poll_event(self.window, 1000)
            if event_type != 0:
                return Ok(self.decode_event(event_type))

impl NativeRenderer:
    # Render a single element
    fn render_element(self, elem: &Element, layout: Layout):
        self.layout_cache.set(elem.id, layout)

        # Get colors
        let fg = self.color_to_argb(self.get_fg_color(elem))
        let bg = self.color_to_argb(self.get_bg_color(elem))

        # Render based on element kind
        match elem.kind:
            case ElementKind::Text:
                self.render_text_element(elem, layout, fg)
            case ElementKind::Box:
                self.render_box_element(elem, layout, fg, bg)
            case ElementKind::Button:
                self.render_button_element(elem, layout, fg, bg)
            case ElementKind::Input:
                self.render_input_element(elem, layout, fg, bg)
            case ElementKind::Div | ElementKind::Row | ElementKind::Column:
                self.render_container_element(elem, layout, bg)
            case _:
                self.render_container_element(elem, layout, bg)

    fn render_text_element(self, elem: &Element, layout: Layout, fg: u32):
        if let Some(text) = &elem.text:
            self.draw_text(layout.x as u32, layout.y as u32, text, fg)

    fn render_box_element(self, elem: &Element, layout: Layout, fg: u32, bg: u32):
        # Fill background
        self.fill_rect(layout.x as u32, layout.y as u32, layout.width as u32, layout.height as u32, bg)
        # Draw border
        self.draw_rounded_rect(layout.x as u32, layout.y as u32, layout.width as u32, layout.height as u32, 4, fg)

        # Render children
        let content_layout = Layout::new(
            layout.x + 4,
            layout.y + 4,
            if layout.width > 8 { layout.width - 8 } else { 0 },
            if layout.height > 8 { layout.height - 8 } else { 0 }
        )
        self.render_children(elem, content_layout)

    fn render_button_element(self, elem: &Element, layout: Layout, fg: u32, bg: u32):
        let button_bg = if elem.focused { 0xFF0066CC } else { bg }
        let button_fg = if elem.focused { 0xFFFFFFFF } else { fg }

        # Draw button background
        self.fill_rect(layout.x as u32, layout.y as u32, layout.width as u32, layout.height as u32, button_bg)
        # Draw border
        self.draw_rounded_rect(layout.x as u32, layout.y as u32, layout.width as u32, layout.height as u32, 4, 0xFF333333)

        # Draw label centered
        if let Some(text) = &elem.text:
            let text_w = (text.len() as u32) * 8
            let text_h: u32 = 16
            let tx = layout.x as u32 + (layout.width as u32 - text_w) / 2
            let ty = layout.y as u32 + (layout.height as u32 - text_h) / 2
            self.draw_text(tx, ty, text, button_fg)

    fn render_input_element(self, elem: &Element, layout: Layout, fg: u32, bg: u32):
        # Draw input background
        let input_bg = if elem.focused { 0xFFF0F0FF } else { bg }
        self.fill_rect(layout.x as u32, layout.y as u32, layout.width as u32, layout.height as u32, input_bg)
        # Draw border
        let border_color = if elem.focused { 0xFF0066CC } else { 0xFFCCCCCC }
        self.draw_rect(layout.x as u32, layout.y as u32, layout.width as u32, layout.height as u32, border_color)

        # Draw value
        let value = elem.attrs.get("value").unwrap_or(&"")
        if not value.is_empty():
            self.draw_text(layout.x as u32 + 4, layout.y as u32 + 4, value, fg)

    fn render_container_element(self, elem: &Element, layout: Layout, bg: u32):
        if bg != 0xFFFFFFFF:  # Not white (default)
            self.fill_rect(layout.x as u32, layout.y as u32, layout.width as u32, layout.height as u32, bg)
        self.render_children(elem, layout)

    fn render_children(self, elem: &Element, layout: Layout):
        if elem.children.is_empty():
            return

        let child_height = layout.height / (elem.children.len() as u16).max(1)
        let mut y = layout.y

        for child in &elem.children:
            if y >= layout.y + layout.height:
                break

            let child_layout = Layout::new(layout.x, y, layout.width, child_height)
            self.render_element(child, child_layout)

            y = y + child_height

    fn get_fg_color(self, elem: &Element) -> Color:
        if let Some(color) = elem.styles.get("color"):
            return parse_color_string(color)
        return Color::Black

    fn get_bg_color(self, elem: &Element) -> Color:
        if let Some(color) = elem.styles.get("background-color"):
            return parse_color_string(color)
        return Color::White

    fn color_to_argb(self, color: Color) -> u32:
        return 0xFF000000 | color.to_rgba()

    fn decode_event(self, event_type: i64) -> Event:
        # Simplified event decoding
        if event_type >= 32 and event_type < 127:
            return Event::Key(KeyEvent {
                code: KeyCode::Char(event_type as char),
                modifiers: KeyModifiers::none()
            })
        match event_type:
            case 1: return Event::Key(KeyEvent { code: KeyCode::Enter, modifiers: KeyModifiers::none() })
            case 2: return Event::Key(KeyEvent { code: KeyCode::Escape, modifiers: KeyModifiers::none() })
            case 3: return Event::Key(KeyEvent { code: KeyCode::Backspace, modifiers: KeyModifiers::none() })
            case 4: return Event::Key(KeyEvent { code: KeyCode::Tab, modifiers: KeyModifiers::none() })
            case 100: return Event::Key(KeyEvent { code: KeyCode::Up, modifiers: KeyModifiers::none() })
            case 101: return Event::Key(KeyEvent { code: KeyCode::Down, modifiers: KeyModifiers::none() })
            case 102: return Event::Key(KeyEvent { code: KeyCode::Left, modifiers: KeyModifiers::none() })
            case 103: return Event::Key(KeyEvent { code: KeyCode::Right, modifiers: KeyModifiers::none() })
            case _: return Event::Key(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })

# Parse color string
fn parse_color_string(s: &str) -> Color:
    match s.to_lowercase().as_str():
        case "black": return Color::Black
        case "red": return Color::Red
        case "green": return Color::Green
        case "yellow": return Color::Yellow
        case "blue": return Color::Blue
        case "magenta": return Color::Magenta
        case "cyan": return Color::Cyan
        case "white": return Color::White
        case _:
            if s.starts_with("#") and s.len() == 7:
                let hex = s[1..].parse_hex().unwrap_or(0)
                return Color::hex(hex as u32)
            return Color::Black

# Native FFI declarations
extern fn native_window_create(title_ptr: *const u8, title_len: u64, width: u32, height: u32) -> WindowHandle
extern fn native_window_destroy(window: WindowHandle)
extern fn native_window_present(window: WindowHandle, buffer_ptr: i64, width: u32, height: u32) -> i32
extern fn native_window_poll_event(window: WindowHandle, timeout_ms: u64) -> i64
extern fn native_font_default() -> FontHandle
extern fn native_draw_text(buffer_ptr: i64, buf_width: u32, buf_height: u32, x: u32, y: u32, text_ptr: *const u8, text_len: u64, color: u32, font: FontHandle)
