# HTML Renderer - Web/Browser GUI Output
#
# Renders UI elements to HTML/CSS for display in web browsers.
# Supports both static HTML generation (SSR) and dynamic updates
# via JavaScript hydration.

use core.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*

# HTML Renderer for web output
pub struct HtmlRenderer:
    # Generated HTML content
    html: String
    # Generated CSS styles
    css: String
    # JavaScript for event handlers
    js: String
    # Node ID counter for DOM mapping
    next_dom_id: u64
    # DOM ID mapping (NodeId -> "sui-{id}")
    dom_ids: Dict<u64, String>
    # Indent level for pretty printing
    indent: u64
    # Whether to minify output
    minify: bool

impl HtmlRenderer:
    # Create a new HTML renderer
    pub fn new() -> HtmlRenderer:
        return HtmlRenderer {
            html: String::new(),
            css: String::new(),
            js: String::new(),
            next_dom_id: 0,
            dom_ids: Dict::new(),
            indent: 0,
            minify: false
        }

    # Enable minified output
    pub fn minified(self) -> HtmlRenderer:
        self.minify = true
        return self

    # Render an element tree to complete HTML document
    pub fn render_document(self, tree: &ElementTree, title: &str) -> String:
        self.render_tree(tree)

        let nl = if self.minify { "" } else { "\n" }
        let indent = if self.minify { "" } else { "  " }

        return "<!DOCTYPE html>{nl}<html>{nl}<head>{nl}{indent}<meta charset=\"UTF-8\">{nl}{indent}<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">{nl}{indent}<title>{title}</title>{nl}{indent}<style>{nl}{self.css}{nl}{indent}</style>{nl}</head>{nl}<body>{nl}{self.html}{nl}<script>{nl}{self.js}{nl}</script>{nl}</body>{nl}</html>"

    # Render element tree to HTML fragment
    pub fn render_tree(self, tree: &ElementTree):
        self.html.clear()
        self.css.clear()
        self.js.clear()
        self.dom_ids.clear()

        # Generate base CSS
        self.generate_base_css()

        # Render root element
        self.render_element(tree.root())

        # Generate event handler JS
        self.generate_event_js()

    # Render a single element
    fn render_element(self, elem: &Element):
        let dom_id = self.alloc_dom_id(elem.id)
        let tag = elem.kind.tag_name()

        # Build opening tag
        self.write_indent()
        self.html.push('<')
        self.html.push_str(tag)

        # Add ID attribute
        self.html.push_str(&" id=\"{dom_id}\"")

        # Add data-sui-id for hydration
        self.html.push_str(&" data-sui-id=\"{elem.id.value()}\"")

        # Add key if present
        if let Some(key) = &elem.key:
            self.html.push_str(&" data-key=\"{self.escape_attr(key)}\"")

        # Add classes
        if not elem.classes.is_empty():
            self.html.push_str(" class=\"")
            self.html.push_str(&elem.classes.join(" "))
            self.html.push('"')

        # Add attributes
        for (name, value) in &elem.attrs:
            self.html.push(' ')
            self.html.push_str(name)
            self.html.push_str("=\"")
            self.html.push_str(&self.escape_attr(value))
            self.html.push('"')

        # Add inline styles
        if not elem.styles.is_empty():
            self.html.push_str(" style=\"")
            let mut first = true
            for (prop, value) in &elem.styles:
                if not first:
                    self.html.push_str("; ")
                self.html.push_str(prop)
                self.html.push_str(": ")
                self.html.push_str(value)
                first = false
            self.html.push('"')

        # Add tab index if focusable
        if let Some(idx) = elem.tab_index:
            self.html.push_str(&" tabindex=\"{idx}\"")

        # Add event handlers
        for (event, handler_id) in &elem.events:
            self.html.push_str(&" on{event}=\"suiEvent({elem.id.value()}, '{event}', {handler_id})\"")

        # Self-closing tags
        if self.is_void_element(tag):
            self.html.push_str(" />")
            self.write_newline()
            return

        self.html.push('>')

        # Text content
        if let Some(text) = &elem.text:
            self.html.push_str(&self.escape_html(text))

        # Children
        if not elem.children.is_empty():
            self.write_newline()
            self.indent = self.indent + 1
            for child in &elem.children:
                self.render_element(child)
            self.indent = self.indent - 1
            self.write_indent()

        # Closing tag
        self.html.push_str("</")
        self.html.push_str(tag)
        self.html.push('>')
        self.write_newline()

    # Allocate DOM ID for a node
    fn alloc_dom_id(self, node_id: NodeId) -> String:
        let dom_id = "sui-{self.next_dom_id}"
        self.next_dom_id = self.next_dom_id + 1
        self.dom_ids.set(node_id.value(), dom_id.clone())
        return dom_id

    # Get DOM ID for a node
    pub fn get_dom_id(self, node_id: NodeId) -> Option<&String>:
        return self.dom_ids.get(&node_id.value())

    # Generate base CSS styles
    fn generate_base_css(self):
        self.css.push_str("/* Simple UI Base Styles */\n")
        self.css.push_str("* { box-sizing: border-box; }\n")
        self.css.push_str("[data-sui-id] { position: relative; }\n")

        # Element type styles
        self.css.push_str(".sui-box { border: 1px solid #ccc; border-radius: 4px; padding: 8px; }\n")
        self.css.push_str(".sui-button { display: inline-block; padding: 8px 16px; border: 1px solid #333; border-radius: 4px; background: #f5f5f5; cursor: pointer; }\n")
        self.css.push_str(".sui-button:hover { background: #e5e5e5; }\n")
        self.css.push_str(".sui-button:focus { outline: 2px solid #0066cc; outline-offset: 2px; }\n")
        self.css.push_str(".sui-input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; }\n")
        self.css.push_str(".sui-input:focus { outline: 2px solid #0066cc; border-color: #0066cc; }\n")

        # Layout styles
        self.css.push_str(".sui-row { display: flex; flex-direction: row; }\n")
        self.css.push_str(".sui-column { display: flex; flex-direction: column; }\n")
        self.css.push_str(".sui-grid { display: grid; }\n")

        # Focus styles
        self.css.push_str("[data-focused='true'] { outline: 2px solid #0066cc; }\n")

    # Generate event handler JavaScript
    fn generate_event_js(self):
        self.js.push_str("// Simple UI Event Handlers\n")
        self.js.push_str("function suiEvent(nodeId, event, handlerId) {\n")
        self.js.push_str("  if (window.suiEventHandler) {\n")
        self.js.push_str("    window.suiEventHandler(nodeId, event, handlerId);\n")
        self.js.push_str("  }\n")
        self.js.push_str("}\n")

    # Check if element is void (self-closing)
    fn is_void_element(self, tag: &str) -> bool:
        match tag:
            case "area" | "base" | "br" | "col" | "embed" | "hr" | "img":
                return true
            case "input" | "link" | "meta" | "param" | "source" | "track" | "wbr":
                return true
            case _:
                return false

    # Escape HTML special characters
    fn escape_html(self, s: &str) -> String:
        let mut result = String::new()
        for ch in s.chars():
            match ch:
                case '<': result.push_str("&lt;")
                case '>': result.push_str("&gt;")
                case '&': result.push_str("&amp;")
                case '"': result.push_str("&quot;")
                case '\'': result.push_str("&#39;")
                case _: result.push(ch)
        return result

    # Escape attribute value
    fn escape_attr(self, s: &str) -> String:
        return self.escape_html(s)

    # Write indentation
    fn write_indent(self):
        if not self.minify:
            for _ in 0..self.indent:
                self.html.push_str("  ")

    # Write newline
    fn write_newline(self):
        if not self.minify:
            self.html.push('\n')

    # Get generated HTML
    pub fn html(self) -> &str:
        return &self.html

    # Get generated CSS
    pub fn css(self) -> &str:
        return &self.css

    # Get generated JavaScript
    pub fn js(self) -> &str:
        return &self.js

    pub fn is_minified(self) -> bool:
        """Check if output is minified.

        Returns:
            True if minify mode enabled
        """
        self.minify

    pub fn has_html(self) -> bool:
        """Check if HTML has been generated.

        Returns:
            True if html is not empty
        """
        not self.html.is_empty()

    pub fn has_css(self) -> bool:
        """Check if CSS has been generated.

        Returns:
            True if css is not empty
        """
        not self.css.is_empty()

    pub fn has_js(self) -> bool:
        """Check if JavaScript has been generated.

        Returns:
            True if js is not empty
        """
        not self.js.is_empty()

    pub fn total_size(self) -> u64:
        """Get total size of generated output.

        Returns:
            Combined size in bytes
        """
        (self.html.len() + self.css.len() + self.js.len()) as u64

    pub fn dom_id_count(self) -> u64:
        """Get number of allocated DOM IDs.

        Returns:
            Count of DOM elements
        """
        self.next_dom_id

    pub fn summary(self) -> String:
        """Get renderer summary.

        Returns:
            Human-readable summary
        """
        let mode = if self.minify: "minified" else: "pretty"
        let size = self.total_size()
        return "HtmlRenderer: {self.dom_id_count()} elements, {size} bytes ({mode})"

# Generate patches as JavaScript commands
pub fn patches_to_js(patches: &PatchSet, dom_ids: &Dict<u64, String>) -> String:
    let mut js = String::new()
    js.push_str("(function() {\n")

    for patch in patches.iter():
        match patch:
            case SetText { node_id, text }:
                if let Some(dom_id) = dom_ids.get(&node_id.value()):
                    js.push_str(&"  document.getElementById('{dom_id}').textContent = '{escape_js_string(text)}';\n")

            case SetAttr { node_id, name, value }:
                if let Some(dom_id) = dom_ids.get(&node_id.value()):
                    js.push_str(&"  document.getElementById('{dom_id}').setAttribute('{name}', '{escape_js_string(value)}');\n")

            case RemoveAttr { node_id, name }:
                if let Some(dom_id) = dom_ids.get(&node_id.value()):
                    js.push_str(&"  document.getElementById('{dom_id}').removeAttribute('{name}');\n")

            case AddClass { node_id, class }:
                if let Some(dom_id) = dom_ids.get(&node_id.value()):
                    js.push_str(&"  document.getElementById('{dom_id}').classList.add('{class}');\n")

            case RemoveClass { node_id, class }:
                if let Some(dom_id) = dom_ids.get(&node_id.value()):
                    js.push_str(&"  document.getElementById('{dom_id}').classList.remove('{class}');\n")

            case SetFocus { node_id }:
                if let Some(dom_id) = dom_ids.get(&node_id.value()):
                    js.push_str(&"  document.getElementById('{dom_id}').focus();\n")

            case _:
                # Complex operations like InsertChild need full element rendering
                js.push_str("  // Complex patch requires full render\n")

    js.push_str("})();\n")
    return js

# Escape string for JavaScript
fn escape_js_string(s: &str) -> String:
    let mut result = String::new()
    for ch in s.chars():
        match ch:
            case '\'': result.push_str("\\'")
            case '"': result.push_str("\\\"")
            case '\\': result.push_str("\\\\")
            case '\n': result.push_str("\\n")
            case '\r': result.push_str("\\r")
            case '\t': result.push_str("\\t")
            case _: result.push(ch)
    return result

# Hydration manifest for client-side reattachment
pub struct HydrationManifest:
    version: u32
    node_map: Dict<u64, String>  # NodeId -> DOM selector
    event_bindings: Array<EventBinding>
    initial_state: Dict<String, String>

pub struct EventBinding:
    node_id: u64
    event: String
    handler_id: u64

impl HydrationManifest:
    pub fn new() -> HydrationManifest:
        return HydrationManifest {
            version: 1,
            node_map: Dict::new(),
            event_bindings: [],
            initial_state: Dict::new()
        }

    pub fn add_node(self, node_id: NodeId, selector: &str):
        self.node_map.set(node_id.value(), selector.to_string())

    pub fn add_event(self, node_id: NodeId, event: &str, handler_id: u64):
        self.event_bindings.push(EventBinding {
            node_id: node_id.value(),
            event: event.to_string(),
            handler_id: handler_id
        })

    pub fn set_state(self, key: &str, value: &str):
        self.initial_state.set(key.to_string(), value.to_string())

    pub fn to_json(self) -> String:
        let mut json = String::new()
        json.push_str("{\n")
        json.push_str(&"  \"version\": {self.version},\n")

        # Node map
        json.push_str("  \"nodes\": {\n")
        let mut first = true
        for (id, selector) in &self.node_map:
            if not first:
                json.push_str(",\n")
            json.push_str(&"    \"{id}\": \"{selector}\"")
            first = false
        json.push_str("\n  },\n")

        # Event bindings
        json.push_str("  \"events\": [\n")
        first = true
        for binding in &self.event_bindings:
            if not first:
                json.push_str(",\n")
            json.push_str(&"    {{\"node\": {binding.node_id}, \"event\": \"{binding.event}\", \"handler\": {binding.handler_id}}}")
            first = false
        json.push_str("\n  ],\n")

        # Initial state
        json.push_str("  \"state\": {\n")
        first = true
        for (key, value) in &self.initial_state:
            if not first:
                json.push_str(",\n")
            json.push_str(&"    \"{key}\": \"{escape_js_string(value)}\"")
            first = false
        json.push_str("\n  }\n")

        json.push_str("}")
        return json

    pub fn node_count(self) -> u64:
        """Get number of nodes in manifest.

        Returns:
            Node count
        """
        self.node_map.len()

    pub fn event_count(self) -> u64:
        """Get number of event bindings.

        Returns:
            Event binding count
        """
        self.event_bindings.len()

    pub fn state_count(self) -> u64:
        """Get number of state entries.

        Returns:
            State entry count
        """
        self.initial_state.len()

    pub fn has_state(self) -> bool:
        """Check if manifest has initial state.

        Returns:
            True if state is not empty
        """
        self.state_count() > 0

    pub fn has_events(self) -> bool:
        """Check if manifest has event bindings.

        Returns:
            True if events exist
        """
        self.event_count() > 0

    pub fn is_empty(self) -> bool:
        """Check if manifest is empty.

        Returns:
            True if no nodes, events, or state
        """
        self.node_count() == 0 and self.event_count() == 0 and self.state_count() == 0

    pub fn summary(self) -> String:
        """Get manifest summary.

        Returns:
            Human-readable summary
        """
        return "HydrationManifest: v{self.version}, {self.node_count()} nodes, {self.event_count()} events, {self.state_count()} state"

impl EventBinding:
    pub fn get_node_id(self) -> u64:
        """Get node ID.

        Returns:
            Node ID
        """
        self.node_id

    pub fn get_event_name(self) -> &String:
        """Get event name.

        Returns:
            Event name
        """
        &self.event

    pub fn get_handler_id(self) -> u64:
        """Get handler ID.

        Returns:
            Handler ID
        """
        self.handler_id

    pub fn summary(self) -> String:
        """Get event binding summary.

        Returns:
            Human-readable summary
        """
        return "EventBinding: node {self.node_id} on{self.event} -> handler {self.handler_id}"
