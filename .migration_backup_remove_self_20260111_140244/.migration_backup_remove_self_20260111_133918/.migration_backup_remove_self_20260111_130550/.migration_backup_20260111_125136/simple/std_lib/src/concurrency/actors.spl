/**
Actor Utilities

Actors are concurrent entities that communicate via message passing.
Use `spawn` to create actors and `send`/`recv` for communication.

Basic Actor:
```sdoctest
>>> fn worker():
...     return 42
>>> let h = spawn worker()
```

The actor runs concurrently and can be communicated with via messages.
*/

/**
Actor state wrapper for stateful actors
*/
struct ActorState<T>:
    value: T

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn update(self, updater: fn(T) -> T):
        """Update state using a function."""
        self.value = updater(self.value)

    fn summary(self) -> String:
        """Get summary of actor state."""
        return "ActorState<T>: current value set"

    # =========================================================================
    # Existing Methods
    # =========================================================================

    fn get(self) -> T:
        return self.value

    fn set(self, new_value: T):
        self.value = new_value

/**
Create an actor that processes messages with a handler function

The handler receives (state, message) and returns new state.
*/
fn stateful_actor(initial_state, handler):
    let state = ActorState(value: initial_state)
    return spawn (\:
        while true:
            let msg = recv()
            state.set(handler(state.get(), msg))
    )()

/**
Supervisor pattern - restart actors on failure

Wraps an actor function with restart logic.
*/
struct Supervisor:
    child_fn: fn()
    max_restarts: Int
    restart_count: Int

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_restarts_remaining(self) -> Bool:
        """Check if supervisor can still restart child."""
        return self.restart_count < self.max_restarts

    fn is_exhausted(self) -> Bool:
        """Check if supervisor has exhausted all restarts."""
        return self.restart_count >= self.max_restarts

    fn get_restart_count(self) -> Int:
        """Get number of times child has been restarted."""
        return self.restart_count

    fn restarts_remaining(self) -> Int:
        """Get number of restarts remaining."""
        if self.restart_count >= self.max_restarts:
            return 0
        return self.max_restarts - self.restart_count

    fn utilization(self) -> f64:
        """Calculate restart utilization (0.0 to 1.0)."""
        if self.max_restarts > 0:
            return (self.restart_count as f64) / (self.max_restarts as f64)
        return 0.0

    fn reset(self):
        """Reset restart counter."""
        self.restart_count = 0

    fn summary(self) -> String:
        """Get summary of supervisor state."""
        let util = (self.utilization() * 100.0) as Int
        return "Supervisor: {self.restart_count}/{self.max_restarts} restarts ({util}% used)"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(child_fn, max_restarts: Int = 3) -> Supervisor:
        return Supervisor(
            child_fn: child_fn,
            max_restarts: max_restarts,
            restart_count: 0
        )

    fn start(self):
        return spawn (\:
            while self.restart_count < self.max_restarts:
                try:
                    return self.child_fn()
                catch e:
                    self.restart_count += 1
                    print("Actor crashed, restarting ({self.restart_count}/{self.max_restarts})")
        )()

/**
Simple one-shot request-response pattern

Sends a request to an actor and waits for response.
*/
fn ask(actor, message, timeout_ms: Int = 5000):
    send(actor, message)
    return recv()  # In full impl, would use reply channel

/**
Broadcast a message to multiple actors
*/
fn broadcast(actors: List, message):
    for actor in actors:
        send(actor, message)
