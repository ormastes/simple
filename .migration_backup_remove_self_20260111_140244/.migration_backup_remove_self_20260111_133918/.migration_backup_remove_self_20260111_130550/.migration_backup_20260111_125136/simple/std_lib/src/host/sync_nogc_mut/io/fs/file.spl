# File Handle - Sync NoGC Mutable Variant
#
# Synchronous (blocking) file operations with optional mmap staging.
# All operations block until complete.

use units.file.*
use units.size.*
use host.common.io.*

export File

# File handle for synchronous operations
pub struct File:
    handle: i64
    path: FilePath
    mode: OpenMode
    stage_state: Option<StageState>

impl File:
    # ===============================
    # File Opening Operations
    # ===============================

    # Open file with mode (sync, blocking)
    pub fn open(path: FilePath, mode: OpenMode) -> Result<File, IoError>:
        # Resolve relative paths to absolute paths
        let resolved_path = native_path_resolve(path)?

        # Check file existence for read mode
        if mode == OpenMode::Read:
            if not native_file_exists_sync(resolved_path):
                return Err(IoError::NotFound)

        # Open file handle
        let handle = native_fs_open(resolved_path, mode)?
        let file = File {
            handle: handle,
            path: resolved_path,
            mode: mode,
            stage_state: None
        }

        return Ok(file)

    # Convenience: open for reading
    pub fn open_read(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Read)

    # Convenience: open for writing (truncates)
    pub fn open_write(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Write)

    # Convenience: open for appending
    pub fn open_append(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Append)

    # Convenience: create new file (fails if exists)
    pub fn create(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Create)

    # Convenience: create or truncate
    pub fn create_or_truncate(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::CreateOrTruncate)

    # ===============================
    # Read Operations
    # ===============================

    # Read bytes into buffer (blocking)
    pub fn read(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return read_sync_with_staging(self.handle, buf, self.stage_state)

    # Read exact number of bytes (blocking)
    pub fn read_exact(self, buf: &mut Bytes) -> Result<(), IoError>:
        let mut read_total: u64 = 0
        let target = buf.len()
        while read_total < target:
            let slice = buf.slice_mut(read_total, target)
            let n = self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Read all remaining bytes (blocking)
    pub fn read_to_end(self) -> Result<Bytes, IoError>:
        let size = self.size()?
        let pos = self.position()?
        let remaining = (size as u64) - (pos as u64)
        let mut buf = Bytes::with_capacity(remaining)
        self.read_exact(&mut buf)?
        return Ok(buf)

    # Read entire file as string (blocking)
    pub fn read_to_string(self) -> Result<Text, IoError>:
        let bytes = self.read_to_end()?
        match bytes.to_utf8():
            case Ok(s): return Ok(s_text)
            case Err(_): return Err(IoError::InvalidData)

    # ===============================
    # Write Operations
    # ===============================

    # Write bytes (blocking)
    pub fn write(self, data: &Bytes) -> Result<ByteCount, IoError>:
        return native_file_write_sync(self.handle, data)

    # Write all bytes (blocking)
    pub fn write_all(self, data: &Bytes) -> Result<(), IoError>:
        return write_all_sync_impl(self.handle, data)

    # Flush buffers to OS (blocking)
    pub fn flush(self) -> Result<(), IoError>:
        return native_file_flush_sync(self.handle)

    # Sync all data and metadata to disk (blocking)
    pub fn sync_all(self) -> Result<(), IoError>:
        return native_file_sync_sync(self.handle)

    # ===============================
    # Seek Operations
    # ===============================

    # Seek to position (blocking)
    pub fn seek(self, pos: SeekFrom) -> Result<ByteCount, IoError>:
        return native_file_seek_sync(self.handle, pos)

    # Get current position
    pub fn position(self) -> Result<ByteCount, IoError>:
        return self.seek(SeekFrom::Current(0))

    # Get file size
    pub fn size(self) -> Result<ByteCount, IoError>:
        let current = self.position()?
        let end = self.seek(SeekFrom::End(0))?
        self.seek(SeekFrom::Start(current as u64))?
        return Ok(end)

    # ===============================
    # Positioned I/O (pread/pwrite)
    # ===============================

    # Read at offset without changing file position (thread-safe)
    pub fn pread(self, buf: &mut Bytes, offset: u64) -> Result<ByteCount, IoError>:
        return pread_with_staging(self.handle, buf, offset, self.stage_state)

    # Write at offset without changing file position (thread-safe)
    pub fn pwrite(self, data: &Bytes, offset: u64) -> Result<ByteCount, IoError>:
        return pwrite_impl(self.handle, data, offset)

    # ===============================
    # Staging Operations
    # ===============================

    # Stage file with mmap (private, copy-on-write)
    pub fn stage_mmap(self) -> Result<(), IoError>:
        let size = self.size()?
        self.stage_state = Some(stage_mmap_sync_impl(self.handle, size as u64)?)
        return Ok(())

    # Stage file with shared mmap (writes visible to other processes)
    pub fn stage_mmap_shared(self) -> Result<(), IoError>:
        let size = self.size()?
        self.stage_state = Some(stage_mmap_shared_sync_impl(self.handle, size as u64)?)
        return Ok(())

    # Stage file by prefetching entire content into buffer
    pub fn stage_prefetch(self) -> Result<(), IoError>:
        let size = self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            self.stage_state = Some(create_empty_staged_state(StageMode::Prefetch, false))
            return Ok(())

        self.seek(SeekFrom::Start(0))?
        let mut buffer = Bytes::with_capacity(size_u64)
        self.read_exact(&mut buffer)?
        self.seek(SeekFrom::Start(0))?

        self.stage_state = Some(create_staged_prefetch_state(buffer))
        native_fadvise_sequential(self.handle)
        return Ok(())

    # Unstage (release mmap or prefetch buffer)
    pub fn unstage(self) -> Result<(), IoError>:
        unstage_cleanup(self.stage_state)
        self.stage_state = None
        return Ok(())

    # Check if file is staged
    pub fn is_staged(self) -> bool:
        return is_staged(self.stage_state)

    # Get staging mode
    pub fn get_stage_mode(self) -> StageMode:
        return get_stage_mode(self.stage_state)

    # ===============================
    # Close Operation
    # ===============================

    # Close file (blocking)
    pub fn close(self) -> Result<(), IoError>:
        # Unstage first
        self.unstage()?
        return native_file_close(self.handle)

# Context manager implementation
impl ContextManager<File> for File:
    fn __enter__(self) -> File:
        return self

    fn __exit__(self, exc: Option<Exception>) -> bool:
        let _ = self.close()
        return false
