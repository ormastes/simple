# TCP Networking - Immutable Variant
# Functional style TCP with immutable connection state

use units.net.*
use units.size.*
use host.common.io.error.IoError

# TCP connection state (immutable)
struct TcpConnection:
    handle: i64
    local_addr: SocketAddr
    peer_addr: SocketAddr
    bytes_sent: ByteCount
    bytes_received: ByteCount

impl TcpConnection:
    # Connect to remote address
    pub async fn connect(addr: SocketAddr) -> Result<TcpConnection, IoError>:
        let handle = native_tcp_connect(addr)?
        let local = native_tcp_local_addr(handle)?
        return Ok(TcpConnection {
            handle: handle,
            local_addr: local,
            peer_addr: addr,
            bytes_sent: 0_bytes,
            bytes_received: 0_bytes
        })

    fn local_addr(self) -> SocketAddr:
        self.local_addr

    fn peer_addr(self) -> SocketAddr:
        self.peer_addr

    fn bytes_sent(self) -> ByteCount:
        self.bytes_sent

    fn bytes_received(self) -> ByteCount:
        self.bytes_received

    # Send data, return (bytes_sent, new_connection_state)
    pub async fn send(self, data: Bytes) -> Result<(ByteCount, TcpConnection), IoError>:
        let n = native_tcp_send(self.handle, &data)?
        return Ok((n, TcpConnection {
            handle: self.handle,
            local_addr: self.local_addr,
            peer_addr: self.peer_addr,
            bytes_sent: self.bytes_sent + n,
            bytes_received: self.bytes_received
        }))

    # Send all data
    pub async fn send_all(self, data: Bytes) -> Result<TcpConnection, IoError>:
        let mut conn = self
        let mut offset: u64 = 0
        let total = data.len()
        while offset < total:
            let slice = data.slice(offset, total)
            let (n, new_conn) = await conn.send(slice)?
            offset = offset + (n as u64)
            conn = new_conn
        return Ok(conn)

    # Receive data, return (data, new_connection_state)
    pub async fn recv(self, max_bytes: ByteCount) -> Result<(Bytes, TcpConnection), IoError>:
        let data = native_tcp_recv(self.handle, max_bytes)?
        let n = (data.len() as ByteCount)
        return Ok((data, TcpConnection {
            handle: self.handle,
            local_addr: self.local_addr,
            peer_addr: self.peer_addr,
            bytes_sent: self.bytes_sent,
            bytes_received: self.bytes_received + n
        }))

    # Receive until buffer is full or connection closes
    pub async fn recv_all(self, expected: ByteCount) -> Result<(Bytes, TcpConnection), IoError>:
        let mut result = Bytes::empty()
        let mut conn = self
        while (result.len() as ByteCount) < expected:
            let remaining = expected - (result.len() as ByteCount)
            let (chunk, new_conn) = await conn.recv(remaining)?
            if chunk.is_empty():
                break
            result = result.append(chunk)
            conn = new_conn
        return Ok((result, conn))

    # Close connection
    pub async fn close(self) -> Result<(), IoError>:
        return native_tcp_close(self.handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_handle(self) -> i64:
        """Get connection handle.

        Returns:
            Connection handle identifier

        Example:
            conn.get_handle()  # → 42
        """
        return self.handle

    fn get_local_addr(self) -> SocketAddr:
        """Get local socket address (alias for local_addr).

        Returns:
            Local socket address

        Example:
            conn.get_local_addr()
        """
        return self.local_addr()

    fn get_peer_addr(self) -> SocketAddr:
        """Get peer socket address (alias for peer_addr).

        Returns:
            Peer socket address

        Example:
            conn.get_peer_addr()
        """
        return self.peer_addr()

    fn total_bytes_sent(self) -> ByteCount:
        """Get total bytes sent (alias for bytes_sent).

        Returns:
            Total bytes sent

        Example:
            conn.total_bytes_sent()  # → 1024_bytes
        """
        return self.bytes_sent()

    fn total_bytes_received(self) -> ByteCount:
        """Get total bytes received (alias for bytes_received).

        Returns:
            Total bytes received

        Example:
            conn.total_bytes_received()  # → 2048_bytes
        """
        return self.bytes_received()

    fn has_sent_data(self) -> bool:
        """Check if connection has sent any data.

        Returns:
            true if bytes have been sent

        Example:
            conn.has_sent_data()  # → true
        """
        return self.bytes_sent > 0_bytes

    fn has_received_data(self) -> bool:
        """Check if connection has received any data.

        Returns:
            true if bytes have been received

        Example:
            conn.has_received_data()  # → true
        """
        return self.bytes_received > 0_bytes

    fn summary(self) -> String:
        """Get connection summary.

        Returns:
            Human-readable summary

        Example:
            conn.summary()
            # → "TcpConnection: local=127.0.0.1:8080, peer=127.0.0.1:12345, sent=1024 bytes, recv=2048 bytes"
        """
        return "TcpConnection: local={self.local_addr}, peer={self.peer_addr}, sent={self.bytes_sent}, recv={self.bytes_received}"

# TCP listener state (immutable)
struct TcpListener:
    handle: i64
    local_addr: SocketAddr
    accepted_count: u64

impl TcpListener:
    # Bind to address
    pub async fn bind(addr: SocketAddr) -> Result<TcpListener, IoError>:
        let handle = native_tcp_bind(addr)?
        return Ok(TcpListener {
            handle: handle,
            local_addr: addr,
            accepted_count: 0
        })

    fn local_addr(self) -> SocketAddr:
        self.local_addr

    fn accepted_count(self) -> u64:
        self.accepted_count

    # Accept connection, return (connection, new_listener_state)
    pub async fn accept(self) -> Result<(TcpConnection, TcpListener), IoError>:
        let (conn_handle, peer_addr) = native_tcp_accept(self.handle)?
        let conn = TcpConnection {
            handle: conn_handle,
            local_addr: self.local_addr,
            peer_addr: peer_addr,
            bytes_sent: 0_bytes,
            bytes_received: 0_bytes
        }
        let new_listener = TcpListener {
            handle: self.handle,
            local_addr: self.local_addr,
            accepted_count: self.accepted_count + 1
        }
        return Ok((conn, new_listener))

    # Close listener
    pub async fn close(self) -> Result<(), IoError>:
        return native_tcp_listener_close(self.handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_handle(self) -> i64:
        """Get listener handle.

        Returns:
            Listener handle identifier

        Example:
            listener.get_handle()  # → 42
        """
        return self.handle

    fn get_local_addr(self) -> SocketAddr:
        """Get local socket address (alias for local_addr).

        Returns:
            Local socket address

        Example:
            listener.get_local_addr()
        """
        return self.local_addr()

    fn get_accepted_count(self) -> u64:
        """Get number of accepted connections (alias for accepted_count).

        Returns:
            Number of connections accepted

        Example:
            listener.get_accepted_count()  # → 5
        """
        return self.accepted_count()

    fn has_accepted_connections(self) -> bool:
        """Check if listener has accepted any connections.

        Returns:
            true if connections have been accepted

        Example:
            listener.has_accepted_connections()  # → true
        """
        return self.accepted_count > 0

    fn summary(self) -> String:
        """Get listener summary.

        Returns:
            Human-readable summary

        Example:
            listener.summary()
            # → "TcpListener: listening on 0.0.0.0:8080, accepted 5 connections"
        """
        return "TcpListener: listening on {self.local_addr}, accepted {self.accepted_count} connections"

# ===============================
# Native function declarations
# ===============================

extern fn native_tcp_connect(addr: SocketAddr) -> Result<i64, IoError>
extern fn native_tcp_bind(addr: SocketAddr) -> Result<i64, IoError>
extern fn native_tcp_accept(handle: i64) -> Result<(i64, SocketAddr), IoError>
extern fn native_tcp_send(handle: i64, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_tcp_recv(handle: i64, max: ByteCount) -> Result<Bytes, IoError>
extern fn native_tcp_close(handle: i64) -> Result<(), IoError>
extern fn native_tcp_listener_close(handle: i64) -> Result<(), IoError>
extern fn native_tcp_local_addr(handle: i64) -> Result<SocketAddr, IoError>
