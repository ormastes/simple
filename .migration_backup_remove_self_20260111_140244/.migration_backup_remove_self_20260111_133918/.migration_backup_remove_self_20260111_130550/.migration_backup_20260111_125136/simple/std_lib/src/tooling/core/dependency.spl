# Dependency Tracking
# Track dependencies within and across languages

use tooling.core.project.{Language, ProjectContext}
use core.result.{Result, Ok, Err}

# Dependency edge in the graph
pub class Dependency:
    pub source: String
    pub target: String
    pub dep_type: DependencyType

    pub fn new(source: String, target: String, dep_type: DependencyType): Dependency =
        """Create dependency edge.

        Args:
            source: Source file
            target: Dependency file
            dep_type: Type of dependency

        Returns:
            Dependency edge
        """
        Dependency {
            source: source,
            target: target,
            dep_type: dep_type
        }

    pub fn is_code_dependency(self): bool =
        """Check if this is a code dependency.

        Returns:
            True if Import or FFI
        """
        self.dep_type.is_code_dependency()

    pub fn summary(self): String =
        """Get dependency summary.

        Returns:
            Human-readable summary

        Example:
            dep.summary()  # → "app.spl → lib.spl (import)"
        """
        "{self.source} → {self.target} ({self.dep_type.to_string()})"

# Dependency type
pub enum DependencyType:
    Import       # Language import/include
    FFI          # Foreign function interface
    Resource     # Resource file dependency
    Test         # Test dependency

    pub fn to_string(self): String =
        """Convert dependency type to string.

        Returns:
            Type name

        Example:
            DependencyType::Import.to_string()  # → "import"
        """
        match self:
            DependencyType::Import: "import"
            DependencyType::FFI: "ffi"
            DependencyType::Resource: "resource"
            DependencyType::Test: "test"

    pub fn is_code_dependency(self): bool =
        """Check if this is a code dependency.

        Returns:
            True if Import or FFI

        Example:
            DependencyType::Import.is_code_dependency()  # → true
            DependencyType::Resource.is_code_dependency()  # → false
        """
        match self:
            DependencyType::Import: true
            DependencyType::FFI: true
            DependencyType::Resource: false
            DependencyType::Test: false

    pub fn description(self): String =
        """Get dependency type description.

        Returns:
            Human-readable description

        Example:
            DependencyType::FFI.description()
            # → "Foreign function interface"
        """
        match self:
            DependencyType::Import: "Language import/include"
            DependencyType::FFI: "Foreign function interface"
            DependencyType::Resource: "Resource file dependency"
            DependencyType::Test: "Test dependency"

    pub fn is_resource_dependency(self): bool =
        """Check if this is a resource dependency.

        Returns:
            True if Resource type
        """
        match self:
            DependencyType::Import: false
            DependencyType::FFI: false
            DependencyType::Resource: true
            DependencyType::Test: false

    pub fn is_test_dependency(self): bool =
        """Check if this is a test dependency.

        Returns:
            True if Test type
        """
        match self:
            DependencyType::Import: false
            DependencyType::FFI: false
            DependencyType::Resource: false
            DependencyType::Test: true

    pub fn is_import(self): bool =
        """Check if this is an Import dependency.

        Returns:
            True if Import type

        Example:
            DependencyType::Import.is_import()  # → true
        """
        match self:
            DependencyType::Import: true
            _: false

    pub fn is_ffi(self): bool =
        """Check if this is an FFI dependency.

        Returns:
            True if FFI type

        Example:
            DependencyType::FFI.is_ffi()  # → true
        """
        match self:
            DependencyType::FFI: true
            _: false

    pub fn is_resource(self): bool =
        """Check if this is a Resource dependency.

        Returns:
            True if Resource type

        Example:
            DependencyType::Resource.is_resource()  # → true
        """
        match self:
            DependencyType::Resource: true
            _: false

    pub fn is_test(self): bool =
        """Check if this is a Test dependency.

        Returns:
            True if Test type

        Example:
            DependencyType::Test.is_test()  # → true
        """
        match self:
            DependencyType::Test: true
            _: false

    pub fn summary(self): String =
        """Get dependency type summary.

        Returns:
            Human-readable summary

        Example:
            DependencyType::Import.summary()
            # → "DependencyType: import (Language import/include, code dependency)"
        """
        let name = self.to_string()
        let desc = self.description()
        let category = if self.is_code_dependency():
            "code dependency"
        elif self.is_test_dependency():
            "test dependency"
        else:
            "resource dependency"
        return "DependencyType: {name} ({desc}, {category})"

# Dependency graph
pub class DependencyGraph:
    pub edges: List<Dependency>
    pub nodes: Dict<String, DependencyNode>

    pub fn new(): DependencyGraph =
        """Create empty dependency graph."""
        DependencyGraph {
            edges: [],
            nodes: {}
        }

    pub fn node_count(self): i32 =
        """Get number of nodes in graph.

        Returns:
            Node count
        """
        self.nodes.len()

    pub fn edge_count(self): i32 =
        """Get number of edges in graph.

        Returns:
            Edge count
        """
        self.edges.len()

    pub fn is_empty(self): bool =
        """Check if graph is empty.

        Returns:
            True if no nodes
        """
        self.nodes.len() == 0

    pub fn has_nodes(self): bool =
        """Check if graph has nodes.

        Returns:
            True if nodes exist
        """
        self.nodes.len() > 0

    pub fn has_edges(self): bool =
        """Check if graph has edges.

        Returns:
            True if edges exist
        """
        self.edges.len() > 0

    pub fn has_cycles(self): bool =
        """Check if graph contains cycles.

        Returns:
            True if circular dependencies exist

        Example:
            if graph.has_cycles():
                print("Warning: circular dependencies detected!")
        """
        self.detect_cycles().len() > 0

    pub fn summary(self): String =
        """Get graph summary.

        Returns:
            Human-readable summary

        Example:
            graph.summary()
            # → "DependencyGraph: 50 nodes, 120 edges"
        """
        "DependencyGraph: {self.node_count()} nodes, {self.edge_count()} edges"

    pub fn get_statistics(self): DependencyStatistics =
        """Get graph statistics.

        Returns:
            Dependency statistics

        Example:
            let stats = graph.get_statistics()
            print("Nodes: {stats.total_nodes}")
            print("Edges: {stats.total_edges}")
            print("Avg dependencies: {stats.avg_dependencies_per_node:.1f}")
        """
        let stats = DependencyStatistics.new()
        stats.total_nodes = self.node_count()
        stats.total_edges = self.edge_count()

        if stats.total_nodes > 0:
            stats.avg_dependencies_per_node = (stats.total_edges as f64) / (stats.total_nodes as f64)

        # Find max dependencies
        for (_, node) in self.nodes.items():
            let dep_count = node.dependencies.len()
            if dep_count > stats.max_dependencies:
                stats.max_dependencies = dep_count
                stats.most_dependent_file = node.file

        stats

    pub fn get_root_nodes(self): List<String> =
        """Get root nodes (files with no dependencies).

        Returns:
            List of root node file paths

        Example:
            let roots = graph.get_root_nodes()
            # → ["main.spl", "cli.spl"]
        """
        let roots: List<String> = []
        for (file, node) in self.nodes.items():
            if node.dependencies.len() == 0:
                roots.append(file)
        roots

    pub fn get_leaf_nodes(self): List<String> =
        """Get leaf nodes (files with no dependents).

        Returns:
            List of leaf node file paths

        Example:
            let leaves = graph.get_leaf_nodes()
            # → ["utils.spl", "constants.spl"]
        """
        let leaves: List<String> = []
        for (file, node) in self.nodes.items():
            if node.dependents.len() == 0:
                leaves.append(file)
        leaves

    pub fn add_node(self, file: String, language: Language):
        """Add node to graph.

        Args:
            file: File path
            language: Source language
        """
        if not self.nodes.contains_key(file):
            self.nodes[file] = DependencyNode.new(file, language)

    pub fn add_edge(
        self,
        source: String,
        target: String,
        dep_type: DependencyType
    ):
        """Add dependency edge.

        Args:
            source: Source file
            target: Target file
            dep_type: Dependency type

        Example:
            graph.add_node("app.spl", Language::Simple)
            graph.add_node("lib.spl", Language::Simple)
            graph.add_edge("app.spl", "lib.spl", DependencyType::Import)
        """
        let dep = Dependency.new(source, target, dep_type)
        self.edges.append(dep)

        # Add to node adjacency lists
        if self.nodes.contains_key(source):
            self.nodes[source].dependencies.append(target)

        if self.nodes.contains_key(target):
            self.nodes[target].dependents.append(source)

    pub fn get_dependencies(self, file: String): List<String> =
        """Get direct dependencies of file.

        Args:
            file: File to get dependencies for

        Returns:
            List of dependency files

        Example:
            let deps = graph.get_dependencies("app.spl")
            # → ["lib.spl", "core.spl"]
        """
        match self.nodes.get(file):
            some(node):
                node.dependencies.clone()
            none:
                []

    pub fn get_transitive_dependencies(self, file: String): List<String> =
        """Get all transitive dependencies of file.

        Args:
            file: File to get dependencies for

        Returns:
            List of all dependency files (recursive)

        Example:
            let deps = graph.get_transitive_dependencies("app.spl")
            # → ["lib.spl", "core.spl", "utils.spl"]
        """
        let visited: Dict<String, bool> = {}
        let result: List<String> = []

        self.collect_dependencies_recursive(file, visited, result)

        result

    fn collect_dependencies_recursive(
        self,
        file: String,
        visited: Dict<String, bool>,
        result: List<String>
    ):
        """Recursively collect dependencies.

        Args:
            file: Current file
            visited: Set of visited files
            result: Accumulated dependencies (output)
        """
        if visited.contains_key(file):
            return

        visited[file] = true

        let deps = self.get_dependencies(file)
        for dep in deps:
            result.append(dep)
            self.collect_dependencies_recursive(dep, visited, result)

    pub fn get_reverse_dependencies(self, file: String): List<String> =
        """Get files that depend on given file.

        Args:
            file: File to find dependents of

        Returns:
            List of dependent files

        Example:
            let rdeps = graph.get_reverse_dependencies("lib.spl")
            # → ["app.spl", "test.spl"]
        """
        match self.nodes.get(file):
            some(node):
                node.dependents.clone()
            none:
                []

    pub fn detect_cycles(self): List<List<String>> =
        """Detect circular dependencies.

        Returns:
            List of dependency cycles

        Algorithm: Tarjan's strongly connected components

        Example:
            let cycles = graph.detect_cycles()
            if cycles.len() > 0:
                print("Circular dependencies found!")
                for cycle in cycles:
                    print("  {cycle.join(' → ')}")
        """
        let cycles: List<List<String>> = []
        let visited: Dict<String, bool> = {}
        let stack: List<String> = []
        let in_stack: Dict<String, bool> = {}

        for (file, _) in self.nodes.items():
            if not visited.contains_key(file):
                self.find_cycles_dfs(
                    file,
                    visited,
                    stack,
                    in_stack,
                    cycles
                )

        cycles

    fn find_cycles_dfs(
        self,
        file: String,
        visited: Dict<String, bool>,
        stack: List<String>,
        in_stack: Dict<String, bool>,
        cycles: List<List<String>>
    ):
        """DFS for cycle detection.

        Args:
            file: Current file
            visited: Visited set
            stack: DFS stack
            in_stack: Files in current DFS path
            cycles: Found cycles (output)
        """
        visited[file] = true
        stack.append(file)
        in_stack[file] = true

        let deps = self.get_dependencies(file)
        for dep in deps:
            if not visited.contains_key(dep):
                self.find_cycles_dfs(dep, visited, stack, in_stack, cycles)
            else if in_stack.contains_key(dep):
                # Cycle found - extract cycle from stack
                let cycle = self.extract_cycle(stack, dep)
                cycles.append(cycle)

        stack.pop()
        in_stack.remove(file)

    fn extract_cycle(self, stack: List<String>, start: String): List<String> =
        """Extract cycle from DFS stack.

        Args:
            stack: DFS stack
            start: Start of cycle

        Returns:
            Files in cycle
        """
        let cycle: List<String> = []
        let found_start = false

        # Find start in stack and collect cycle
        for file in stack.iter().rev():
            cycle.insert(0, file)
            if file == start:
                found_start = true
                break

        cycle

    pub fn topological_sort(self): Result<List<String>, String> =
        """Compute topological ordering of files.

        Returns:
            Ok with ordered file list, or Err if cycle detected

        Example:
            match graph.topological_sort():
                Ok(order):
                    print("Build order: {order}")
                Err(msg):
                    print("Error: {msg}")
        """
        # Check for cycles first
        let cycles = self.detect_cycles()
        if cycles.len() > 0:
            return Err("Circular dependencies detected")

        # Kahn's algorithm
        let in_degree: Dict<String, i32> = {}
        let queue: List<String> = []
        let result: List<String> = []

        # Initialize in-degrees
        for (file, _) in self.nodes.items():
            in_degree[file] = 0

        for edge in self.edges:
            in_degree[edge.target] += 1

        # Find nodes with no incoming edges
        for (file, degree) in in_degree.items():
            if degree == 0:
                queue.append(file)

        # Process queue
        while queue.len() > 0:
            let file = queue.remove(0)
            result.append(file)

            let deps = self.get_dependencies(file)
            for dep in deps:
                in_degree[dep] -= 1
                if in_degree[dep] == 0:
                    queue.append(dep)

        Ok(result)

# Dependency node
pub class DependencyNode:
    pub file: String
    pub language: Language
    pub dependencies: List<String>    # Files this file depends on
    pub dependents: List<String>      # Files that depend on this file

    pub fn new(file: String, language: Language): DependencyNode =
        """Create dependency node.

        Args:
            file: File path
            language: Source language

        Returns:
            Dependency node
        """
        DependencyNode {
            file: file,
            language: language,
            dependencies: [],
            dependents: []
        }

    pub fn has_dependencies(self): bool =
        """Check if node has dependencies.

        Returns:
            True if dependencies exist
        """
        self.dependencies.len() > 0

    pub fn has_dependents(self): bool =
        """Check if node has dependents.

        Returns:
            True if dependents exist
        """
        self.dependents.len() > 0

    pub fn dependency_count(self): i32 =
        """Get number of dependencies.

        Returns:
            Dependency count
        """
        self.dependencies.len()

    pub fn dependent_count(self): i32 =
        """Get number of dependents.

        Returns:
            Dependent count
        """
        self.dependents.len()

    pub fn is_root(self): bool =
        """Check if this is a root node (no dependencies).

        Returns:
            True if no dependencies

        Example:
            if node.is_root():
                print("{node.file} is an entry point")
        """
        self.dependencies.len() == 0

    pub fn is_leaf(self): bool =
        """Check if this is a leaf node (no dependents).

        Returns:
            True if no dependents

        Example:
            if node.is_leaf():
                print("{node.file} is a utility module")
        """
        self.dependents.len() == 0

    pub fn summary(self): String =
        """Get node summary.

        Returns:
            Human-readable summary

        Example:
            node.summary()
            # → "app.spl (Simple): 3 dependencies, 0 dependents"
        """
        "{self.file} ({self.language.to_string()}): {self.dependency_count()} dependencies, {self.dependent_count()} dependents"

# Dependency tracker - builds and analyzes dependency graph
pub class DependencyTracker:
    pub root: String
    pub graph: DependencyGraph
    pub verbose: bool

    pub fn new(root: String): DependencyTracker =
        """Create dependency tracker.

        Args:
            root: Project root directory

        Returns:
            Tracker with empty graph

        Example:
            let tracker = DependencyTracker.new(".")
            tracker.analyze_all_languages()

            let deps = tracker.get_dependencies("app.spl")
            print("Dependencies: {deps}")
        """
        DependencyTracker {
            root: root,
            graph: DependencyGraph.new(),
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.verbose = enabled

    pub fn is_verbose(self): bool =
        """Check if verbose logging is enabled.

        Returns:
            True if verbose mode is on
        """
        self.verbose

    pub fn with_verbose(self, enabled: bool): DependencyTracker =
        """Set verbose logging (fluent API).

        Args:
            enabled: Verbose flag

        Returns:
            Self for chaining

        Example:
            let tracker = DependencyTracker.new(".").with_verbose(true)
        """
        self.verbose = enabled
        self

    pub fn has_graph(self): bool =
        """Check if tracker has built dependency graph.

        Returns:
            True if graph has nodes
        """
        self.graph.has_nodes()

    pub fn get_node_count(self): i32 =
        """Get number of nodes in graph.

        Returns:
            Node count
        """
        self.graph.node_count()

    pub fn get_edge_count(self): i32 =
        """Get number of edges in graph.

        Returns:
            Edge count
        """
        self.graph.edge_count()

    pub fn summary(self): String =
        """Get tracker summary.

        Returns:
            Human-readable summary

        Example:
            tracker.summary()
            # → "DependencyTracker: . (50 files, 120 dependencies, verbose: true)"
        """
        let verbose_str = if self.verbose: "true" else: "false"
        "DependencyTracker: {self.root} ({self.get_node_count()} files, {self.get_edge_count()} dependencies, verbose: {verbose_str})"

    pub fn analyze_all_languages(self):
        """Analyze dependencies for all languages in project.

        Builds complete dependency graph by parsing all source files.
        """
        # TODO: [stdlib][P1] Implement language-specific dependency extraction
        # - Simple: Parse import statements with Tree-sitter
        # - Rust: Parse use/mod statements
        # - Python: Parse import/from statements
        # - JavaScript: Parse import/require statements

        if self.verbose:
            print("Analyzing dependencies...")

    pub fn analyze_file(self, file: String, language: Language):
        """Analyze dependencies for single file.

        Args:
            file: File to analyze
            language: Source language
        """
        # Add node
        self.graph.add_node(file, language)

        # TODO: [stdlib][P2] Parse file and extract dependencies
        # For now, this is a stub
        let deps = self.extract_dependencies(file, language)

        for dep in deps:
            self.graph.add_node(dep, language)
            self.graph.add_edge(file, dep, DependencyType::Import)

    fn extract_dependencies(self, file: String, language: Language): List<String> =
        """Extract dependencies from source file.

        Args:
            file: File to parse
            language: Source language

        Returns:
            List of dependency files
        """
        # TODO: [stdlib][P2] Use Tree-sitter to parse imports/includes
        []

    pub fn get_dependencies(self, file: String): List<String> =
        """Get dependencies of file.

        Args:
            file: File path

        Returns:
            Direct dependencies
        """
        self.graph.get_dependencies(file)

    pub fn get_reverse_dependencies(self, file: String): List<String> =
        """Get reverse dependencies of file.

        Args:
            file: File path

        Returns:
            Files that depend on this file
        """
        self.graph.get_reverse_dependencies(file)

    pub fn detect_cycles(self): List<List<String>> =
        """Detect circular dependencies.

        Returns:
            List of dependency cycles
        """
        self.graph.detect_cycles()

    pub fn visualize(self): String =
        """Generate DOT graph visualization.

        Returns:
            DOT format graph

        Example:
            let dot = tracker.visualize()
            # Save to file for rendering with Graphviz
        """
        let mut output = "digraph dependencies {\n"

        for edge in self.graph.edges:
            output += "  \"{edge.source}\" -> \"{edge.target}\";\n"

        output += "}\n"
        output

# Dependency graph statistics
pub class DependencyStatistics:
    pub total_nodes: i32
    pub total_edges: i32
    pub avg_dependencies_per_node: f64
    pub max_dependencies: i32
    pub most_dependent_file: String

    pub fn new(): DependencyStatistics =
        """Create dependency statistics."""
        DependencyStatistics {
            total_nodes: 0,
            total_edges: 0,
            avg_dependencies_per_node: 0.0,
            max_dependencies: 0,
            most_dependent_file: ""
        }

    pub fn summary(self): String =
        """Get statistics summary.

        Returns:
            Human-readable summary

        Example:
            print(stats.summary())
            # → "50 files, 120 dependencies, avg 2.4 deps/file"
        """
        "{self.total_nodes} files, {self.total_edges} dependencies, avg {self.avg_dependencies_per_node:.1f} deps/file"

    pub fn has_data(self): bool =
        """Check if statistics have data.

        Returns:
            True if nodes exist
        """
        self.total_nodes > 0

    pub fn is_complex(self): bool =
        """Check if dependency graph is complex.

        Returns:
            True if avg dependencies per node > 3.0

        Example:
            if stats.is_complex():
                print("Warning: complex dependency structure")
        """
        self.avg_dependencies_per_node > 3.0

    pub fn has_hotspots(self): bool =
        """Check if there are dependency hotspots.

        Returns:
            True if max dependencies > 10
        """
        self.max_dependencies > 10
