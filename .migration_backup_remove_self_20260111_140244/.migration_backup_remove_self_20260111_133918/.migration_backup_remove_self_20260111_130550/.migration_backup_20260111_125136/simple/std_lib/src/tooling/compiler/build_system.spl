# Build System Integration
# Orchestrate builds across multiple languages

use tooling.core.project.{Language, ProjectContext, LanguageConfig}
use tooling.core.incremental.{IncrementalCompiler, IncrementalAnalysis}
use tooling.compiler.interface.{
    MultiLanguageCompiler,
    CompilationMode,
    CompilationResult,
    Artifact,
    CompilationError
}
use core.result.{Result, Ok, Err}

# Build configuration
pub class BuildConfig:
    pub mode: CompilationMode
    pub parallel: bool
    pub incremental: bool
    pub workers: i32
    pub optimization: OptimizationLevel
    pub verbose: bool

    pub fn new(): BuildConfig =
        """Create default build configuration.

        Returns:
            Default configuration
        """
        BuildConfig {
            mode: CompilationMode::Debug,
            parallel: false,
            incremental: false,
            workers: 4,
            optimization: OptimizationLevel::None,
            verbose: false
        }

    pub fn release(): BuildConfig =
        """Create release build configuration.

        Returns:
            Release configuration with optimizations
        """
        BuildConfig {
            mode: CompilationMode::Release,
            parallel: true,
            incremental: true,
            workers: 4,
            optimization: OptimizationLevel::Size,
            verbose: false
        }

    pub fn with_mode(self, mode: CompilationMode): BuildConfig =
        """Set compilation mode (fluent API).

        Args:
            mode: Compilation mode

        Returns:
            Modified config
        """
        self.mode = mode
        self

    pub fn with_parallel(self, enabled: bool): BuildConfig =
        """Set parallel compilation (fluent API).

        Args:
            enabled: True to enable

        Returns:
            Modified config
        """
        self.parallel = enabled
        self

    pub fn with_workers(self, count: i32): BuildConfig =
        """Set worker count (fluent API).

        Args:
            count: Number of workers

        Returns:
            Modified config
        """
        self.workers = count
        self

    pub fn with_optimization(self, level: OptimizationLevel): BuildConfig =
        """Set optimization level (fluent API).

        Args:
            level: Optimization level

        Returns:
            Modified config
        """
        self.optimization = level
        self

    pub fn is_release(self): bool =
        """Check if this is a release build.

        Returns:
            True if release mode
        """
        match self.mode:
            CompilationMode::Release: true
            _: false

# Optimization level
pub enum OptimizationLevel:
    None
    Speed
    Size
    Balanced

    pub fn to_string(self): String =
        """Convert optimization level to string.

        Returns:
            Level name

        Example:
            OptimizationLevel::Speed.to_string()  # → "speed"
        """
        match self:
            OptimizationLevel::None: "none"
            OptimizationLevel::Speed: "speed"
            OptimizationLevel::Size: "size"
            OptimizationLevel::Balanced: "balanced"

    pub fn description(self): String =
        """Get optimization description.

        Returns:
            Human-readable description

        Example:
            OptimizationLevel::Size.description()
            # → "Optimize for binary size"
        """
        match self:
            OptimizationLevel::None:
                "No optimizations (fastest builds)"
            OptimizationLevel::Speed:
                "Optimize for execution speed"
            OptimizationLevel::Size:
                "Optimize for binary size"
            OptimizationLevel::Balanced:
                "Balance speed and size"

    pub fn get_compiler_flags(self): List<String> =
        """Get compiler flags for this optimization level.

        Returns:
            Compiler flags

        Example:
            OptimizationLevel::Speed.get_compiler_flags()
            # → ["-O3", "-march=native"]
        """
        match self:
            OptimizationLevel::None:
                ["-O0"]
            OptimizationLevel::Speed:
                ["-O3", "-march=native"]
            OptimizationLevel::Size:
                ["-Os", "-flto"]
            OptimizationLevel::Balanced:
                ["-O2"]

    pub fn is_none(self): bool =
        """Check if optimization is disabled.

        Returns:
            True if None

        Example:
            OptimizationLevel::None.is_none()  # → true
        """
        match self:
            OptimizationLevel::None: true
            _: false

    pub fn is_speed(self): bool =
        """Check if optimizing for speed.

        Returns:
            True if Speed

        Example:
            OptimizationLevel::Speed.is_speed()  # → true
        """
        match self:
            OptimizationLevel::Speed: true
            _: false

    pub fn is_size(self): bool =
        """Check if optimizing for size.

        Returns:
            True if Size

        Example:
            OptimizationLevel::Size.is_size()  # → true
        """
        match self:
            OptimizationLevel::Size: true
            _: false

    pub fn is_balanced(self): bool =
        """Check if using balanced optimization.

        Returns:
            True if Balanced

        Example:
            OptimizationLevel::Balanced.is_balanced()  # → true
        """
        match self:
            OptimizationLevel::Balanced: true
            _: false

    pub fn is_optimized(self): bool =
        """Check if any optimization is enabled.

        Returns:
            False for None, true otherwise

        Example:
            OptimizationLevel::None.is_optimized()  # → false
            OptimizationLevel::Speed.is_optimized()  # → true
        """
        match self:
            OptimizationLevel::None: false
            _: true

    pub fn is_aggressive(self): bool =
        """Check if using aggressive optimization.

        Returns:
            True for Speed (most aggressive)

        Example:
            OptimizationLevel::Speed.is_aggressive()  # → true
        """
        match self:
            OptimizationLevel::Speed: true
            _: false

    pub fn summary(self): String =
        """Get optimization level summary.

        Returns:
            Human-readable summary

        Example:
            OptimizationLevel::Speed.summary()
            # → "OptimizationLevel: speed (Optimize for execution speed, optimized, aggressive)"
        """
        let name = self.to_string()
        let desc = self.description()
        let status = if self.is_optimized(): "optimized" else: "unoptimized"
        let mode = if self.is_aggressive():
            ", aggressive"
        elif self.is_balanced():
            ", balanced"
        else:
            ""
        return "OptimizationLevel: {name} ({desc}, {status}{mode})"

# Build result
pub class BuildResult:
    pub success: bool
    pub artifacts: List<Artifact>
    pub errors: List<CompilationError>
    pub warnings: List<CompilationError>
    pub duration_ms: i64
    pub files_built: i32
    pub files_skipped: i32

    pub fn new(): BuildResult =
        """Create empty build result."""
        BuildResult {
            success: true,
            artifacts: [],
            errors: [],
            warnings: [],
            duration_ms: 0,
            files_built: 0,
            files_skipped: 0
        }

    pub fn is_ok(self): bool =
        """Check if build succeeded.

        Returns:
            True if no errors
        """
        self.errors.len() == 0

    pub fn summary(self): String =
        """Get build summary string.

        Returns:
            Human-readable summary
        """
        if self.is_ok():
            "✓ Build succeeded: {self.artifacts.len()} artifacts in {self.duration_ms}ms"
        else:
            "✗ Build failed: {self.errors.len()} errors, {self.warnings.len()} warnings"

    pub fn total_files(self): i32 =
        """Get total files processed.

        Returns:
            Total files (built + skipped)
        """
        self.files_built + self.files_skipped

    pub fn duration_seconds(self): f64 =
        """Get build duration in seconds.

        Returns:
            Duration in seconds
        """
        (self.duration_ms as f64) / 1000.0

    pub fn artifact_count(self): i32 =
        """Get artifact count.

        Returns:
            Number of artifacts
        """
        self.artifacts.len()

    pub fn error_count(self): i32 =
        """Get error count.

        Returns:
            Number of errors
        """
        self.errors.len()

    pub fn warning_count(self): i32 =
        """Get warning count.

        Returns:
            Number of warnings
        """
        self.warnings.len()

    pub fn has_warnings(self): bool =
        """Check if build has warnings.

        Returns:
            True if warnings present
        """
        self.warnings.len() > 0

    pub fn get_artifacts_by_type(self, artifact_type: ArtifactType): List<Artifact> =
        """Get artifacts of specific type.

        Args:
            artifact_type: Type to filter by

        Returns:
            Filtered artifacts

        Example:
            let executables = result.get_artifacts_by_type(ArtifactType::Executable)
            for exe in executables:
                print("Built: {exe.path}")
        """
        let filtered: List<Artifact> = []
        for artifact in self.artifacts:
            if artifact.artifact_type == artifact_type:
                filtered.append(artifact)
        filtered

# Build system orchestrator
pub class BuildSystem:
    pub project: ProjectContext
    pub config: BuildConfig
    pub compiler: MultiLanguageCompiler
    pub incremental: Option<IncrementalCompiler>

    pub fn new(root: String): BuildSystem =
        """Create build system for project.

        Args:
            root: Project root directory

        Returns:
            Build system with auto-detected languages

        Example:
            let build = BuildSystem.new(".")
            build.set_mode(CompilationMode::Release)
            build.set_parallel(true)

            let result = build.execute()
            print(result.summary())
        """
        let project = ProjectContext.new(root)
        let compiler = MultiLanguageCompiler.new()

        BuildSystem {
            project: project,
            config: BuildConfig.new(),
            compiler: compiler,
            incremental: none
        }

    pub fn from_project(project: ProjectContext): BuildSystem =
        """Create build system from project context.

        Args:
            project: Project context

        Returns:
            Build system
        """
        let compiler = MultiLanguageCompiler.new()

        BuildSystem {
            project: project,
            config: BuildConfig.new(),
            compiler: compiler,
            incremental: none
        }

    pub fn set_mode(self, mode: CompilationMode):
        """Set compilation mode.

        Args:
            mode: Debug, Release, or Profile
        """
        self.config.mode = mode
        self.compiler.set_mode(mode)

    pub fn set_parallel(self, enabled: bool):
        """Enable/disable parallel compilation.

        Args:
            enabled: True to compile languages in parallel
        """
        self.config.parallel = enabled
        self.compiler.set_parallel(enabled)

    pub fn set_incremental(self, enabled: bool):
        """Enable/disable incremental compilation.

        Args:
            enabled: True for incremental builds
        """
        self.config.incremental = enabled
        self.compiler.set_incremental(enabled)

        if enabled:
            let cache_path = "{self.project.get_build_dir()}/.build_cache"
            self.incremental = some(IncrementalCompiler.new(cache_path))
        else:
            self.incremental = none

    pub fn set_optimization(self, level: OptimizationLevel):
        """Set optimization level.

        Args:
            level: Optimization strategy
        """
        self.config.optimization = level

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.config.verbose = enabled

    pub fn discover_languages(self): List<Language> =
        """Auto-detect languages in project.

        Returns:
            List of detected languages

        Example:
            let build = BuildSystem.new(".")
            let languages = build.discover_languages()
            for lang in languages:
                print("Found: {lang}")
        """
        let languages: List<Language> = []
        for lang_config in self.project.languages:
            languages.append(lang_config.language)
        languages

    pub fn execute(self): BuildResult =
        """Execute multi-language build.

        Returns:
            Build result with artifacts or errors

        Build phases:
        1. Discovery: Find all language roots
        2. Planning: Determine build order
        3. Compilation: Execute language-specific builds
        4. Linking: Combine artifacts (if needed)
        5. Post-processing: Apply optimizations
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        let result = BuildResult.new()
        let start_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds

        if self.config.verbose:
            print("Build system starting...")
            print("  Mode: {self.config.mode}")
            print("  Parallel: {self.config.parallel}")
            print("  Incremental: {self.config.incremental}")

        # Phase 1: Discovery (already done in project)
        let languages = self.discover_languages()
        if self.config.verbose:
            print("  Languages: {languages.len()}")

        # Phase 2: Planning - determine build order
        let build_order = self.plan_build_order(languages)

        # Phase 3: Compilation
        let compile_result = self.compile_languages(build_order)

        # Merge compilation results
        result.artifacts = compile_result.artifacts
        result.errors = compile_result.errors
        result.warnings = compile_result.warnings
        result.success = compile_result.success

        # Phase 4: Linking (if needed for FFI)
        # TODO: [stdlib][P1] Implement cross-language linking

        # Phase 5: Post-processing
        self.apply_optimizations(result.artifacts)

        let end_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds
        result.duration_ms = end_time - start_time

        if self.config.verbose:
            print(result.summary())

        result

    fn plan_build_order(self, languages: List<Language>): List<Language> =
        """Determine build order respecting dependencies.

        Args:
            languages: Languages to build

        Returns:
            Ordered list of languages

        Current implementation: Simple ordering
        # TODO: [stdlib][P1] Implement topological sort for inter-language deps
        """
        # Build order: C/C++ → Rust → Go → Simple → Python → JavaScript
        let order: List<Language> = []

        # Low-level languages first (for FFI)
        if languages.contains(Language::C):
            order.append(Language::C)
        if languages.contains(Language::Cpp):
            order.append(Language::Cpp)
        if languages.contains(Language::Rust):
            order.append(Language::Rust)
        if languages.contains(Language::Go):
            order.append(Language::Go)

        # High-level languages
        if languages.contains(Language::Simple):
            order.append(Language::Simple)
        if languages.contains(Language::Python):
            order.append(Language::Python)
        if languages.contains(Language::JavaScript):
            order.append(Language::JavaScript)
        if languages.contains(Language::TypeScript):
            order.append(Language::TypeScript)

        order

    fn compile_languages(
        self,
        languages: List<Language>
    ): CompilationResult =
        """Compile all languages.

        Args:
            languages: Languages in build order

        Returns:
            Combined compilation result
        """
        # Get language configs
        let configs: List<LanguageConfig> = []
        for lang in languages:
            match self.project.config.get_language_config(lang):
                some(config):
                    configs.append(config)
                none:
                    pass  # Skip missing config

        # Compile all languages
        self.compiler.compile_all(configs)

    fn apply_optimizations(self, artifacts: List<Artifact>):
        """Apply post-build optimizations.

        Args:
            artifacts: Build artifacts

        Optimizations:
        - Strip debug symbols (release mode)
        - Compress binaries (size optimization)
        - Link-time optimization
        """
        if self.config.mode != CompilationMode::Release:
            return

        match self.config.optimization:
            OptimizationLevel::None:
                pass
            OptimizationLevel::Speed:
                # TODO: [stdlib][P3] Apply speed optimizations
                pass
            OptimizationLevel::Size:
                # TODO: [stdlib][P3] Strip symbols, compress
                pass
            OptimizationLevel::Balanced:
                # TODO: [stdlib][P3] Apply balanced optimizations
                pass

    pub fn clean(self): Result<(), String> =
        """Clean build artifacts.

        Returns:
            Ok if successful

        Removes:
        - Build directory
        - Incremental cache
        - Temporary files
        """
        @extern("runtime", "rt_dir_remove")
        fn _rt_dir_remove(path_ptr: &u8, path_len: u64, recursive: bool) -> bool

        if self.config.verbose:
            print("Cleaning build artifacts...")

        # Get build directory path
        let build_dir = self.get_build_dir()

        # Remove build directory recursively
        let success = _rt_dir_remove(build_dir.ptr(), build_dir.len(), true)

        if success:
            if self.config.verbose:
                print("Removed: {build_dir}")
            Ok(())
        else:
            Err("Failed to remove build directory: {build_dir}")

    pub fn get_build_dir(self): String =
        """Get build output directory.

        Returns:
            Build directory path
        """
        self.project.get_build_dir()

    pub fn is_incremental_enabled(self): bool =
        """Check if incremental compilation is enabled.

        Returns:
            True if incremental
        """
        self.config.incremental

    pub fn is_parallel_enabled(self): bool =
        """Check if parallel compilation is enabled.

        Returns:
            True if parallel
        """
        self.config.parallel

    pub fn get_language_count(self): i32 =
        """Get number of languages in project.

        Returns:
            Language count
        """
        self.project.languages.len()

    pub fn has_language(self, language: Language): bool =
        """Check if project uses specific language.

        Args:
            language: Language to check

        Returns:
            True if language is used

        Example:
            if build.has_language(Language::Rust):
                print("Project uses Rust")
        """
        for lang_config in self.project.languages:
            if lang_config.language == language:
                return true
        false

    pub fn get_configuration_summary(self): String =
        """Get build configuration summary.

        Returns:
            Human-readable configuration

        Example:
            print(build.get_configuration_summary())
            # → "Release build (parallel, incremental, 4 workers, size optimization)"
        """
        let mut parts: List<String> = []

        # Mode
        parts.append(match self.config.mode:
            CompilationMode::Debug: "Debug"
            CompilationMode::Release: "Release"
            CompilationMode::Profile: "Profile"
        )

        parts.append("build")

        # Flags
        if self.config.parallel:
            parts.append("parallel")
        if self.config.incremental:
            parts.append("incremental")

        parts.append("{self.config.workers} workers")
        parts.append("{self.config.optimization.to_string()} optimization")

        parts.join(", ")
