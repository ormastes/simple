# Test Filtering & Selection
# Run subset of tests based on filters

use tooling.core.project.Language
use tooling.testing.discovery.TestSuite

# Test filter criteria
pub class TestFilter:
    pub pattern: String
    pub language: Option<Language>
    pub file_patterns: List<String>
    pub tag_filters: List<String>
    pub changed_files_only: bool

    pub fn new(): TestFilter =
        """Create empty test filter.

        Returns:
            Empty filter (matches all tests)

        Example:
            let filter = TestFilter.new()

            filter.by_pattern("integration")
            filter.by_language(Language::Rust)

            let filtered_tests = filter.apply(all_tests)
            print("Running {filtered_tests.len()} filtered tests")
        """
        TestFilter {
            pattern: "",
            language: none,
            file_patterns: [],
            tag_filters: [],
            changed_files_only: false
        }

    pub fn has_filters(self): bool =
        """Check if any filters are set.

        Returns:
            True if filters are active

        Example:
            if not filter.has_filters():
                print("Running all tests")
        """
        self.pattern != "" or
        self.language.is_some() or
        self.file_patterns.len() > 0 or
        self.tag_filters.len() > 0 or
        self.changed_files_only

    pub fn is_empty(self): bool =
        """Check if filter is empty (no filters set).

        Returns:
            True if no filters
        """
        not self.has_filters()

    pub fn summary(self): String =
        """Get filter summary.

        Returns:
            Human-readable summary

        Example:
            filter.summary()
            # â†’ "Filters: pattern='integration', language=Rust, 2 file patterns"
        """
        let mut parts: List<String> = []

        if self.pattern != "":
            parts.append("pattern='{self.pattern}'")

        match self.language:
            some(lang):
                parts.append("language={lang}")
            none:
                pass

        if self.file_patterns.len() > 0:
            parts.append("{self.file_patterns.len()} file patterns")

        if self.tag_filters.len() > 0:
            parts.append("{self.tag_filters.len()} tags")

        if self.changed_files_only:
            parts.append("changed files only")

        if parts.len() == 0:
            "No filters (all tests)"
        else:
            "Filters: {parts.join(', ')}"

    pub fn clear(self):
        """Clear all filters."""
        self.pattern = ""
        self.language = none
        self.file_patterns = []
        self.tag_filters = []
        self.changed_files_only = false

    pub fn by_pattern(self, pattern: String):
        """Filter by test name pattern.

        Args:
            pattern: Substring or regex pattern

        Example:
            filter.by_pattern("integration")
            # Matches: test_integration_api, integration_db_spec, etc.
        """
        self.pattern = pattern

    pub fn by_language(self, language: Language):
        """Filter by language.

        Args:
            language: Language to filter by

        Example:
            filter.by_language(Language::Rust)
            # Only run Rust tests
        """
        self.language = some(language)

    pub fn by_file(self, file_pattern: String):
        """Filter by file pattern.

        Args:
            file_pattern: Glob pattern for files

        Example:
            filter.by_file("api/**/*_spec.spl")
            # Only run tests in api directory
        """
        self.file_patterns.append(file_pattern)

    pub fn by_tag(self, tag: String):
        """Filter by test tag/marker.

        Args:
            tag: Tag to filter by

        Example:
            filter.by_tag("slow")
            # Only run tests marked as @slow
        """
        self.tag_filters.append(tag)

    pub fn by_changed_files(self, changed_files: List<String>):
        """Filter to tests affected by changed files.

        Args:
            changed_files: Files that changed

        Example:
            let changed = git.get_changed_files("HEAD~1")
            filter.by_changed_files(changed)
            # Only run tests covering changed code
        """
        self.changed_files_only = true
        # TODO: [stdlib][P3] Use dependency graph to find affected tests

    pub fn apply(self, suites: List<TestSuite>): List<TestSuite> =
        """Apply filter to test suites.

        Args:
            suites: All test suites

        Returns:
            Filtered test suites

        Example:
            let filter = TestFilter.new()
            filter.by_pattern("unit")
            filter.by_language(Language::Simple)

            let filtered = filter.apply(all_suites)
            # Only Simple unit tests
        """
        let mut filtered = suites

        # Apply language filter
        match self.language:
            some(lang):
                filtered = self.filter_by_language(filtered, lang)
            none:
                pass

        # Apply pattern filter
        if not self.pattern.is_empty():
            filtered = self.filter_by_pattern(filtered, self.pattern)

        # Apply file pattern filter
        if self.file_patterns.len() > 0:
            filtered = self.filter_by_file_patterns(filtered, self.file_patterns)

        filtered

    fn filter_by_language(
        self,
        suites: List<TestSuite>,
        language: Language
    ): List<TestSuite> =
        """Filter suites by language.

        Args:
            suites: Test suites
            language: Language to match

        Returns:
            Filtered suites
        """
        let filtered: List<TestSuite> = []

        for suite in suites:
            if suite.language == language:
                filtered.append(suite)

        filtered

    fn filter_by_pattern(
        self,
        suites: List<TestSuite>,
        pattern: String
    ): List<TestSuite> =
        """Filter suites by name pattern.

        Args:
            suites: Test suites
            pattern: Pattern to match

        Returns:
            Filtered suites
        """
        let filtered: List<TestSuite> = []

        for suite in suites:
            if self.matches_pattern(suite, pattern):
                filtered.append(suite)

        filtered

    fn filter_by_file_patterns(
        self,
        suites: List<TestSuite>,
        patterns: List<String>
    ): List<TestSuite> =
        """Filter suites by file patterns.

        Args:
            suites: Test suites
            patterns: Glob patterns

        Returns:
            Filtered suites
        """
        let filtered: List<TestSuite> = []

        for suite in suites:
            for pattern in patterns:
                if self.matches_file_pattern(suite, pattern):
                    filtered.append(suite)
                    break

        filtered

    fn matches_pattern(self, suite: TestSuite, pattern: String): bool =
        """Check if suite matches pattern.

        Args:
            suite: Test suite
            pattern: Pattern to match

        Returns:
            True if matches

        Supports:
        - Exact match: "app_test"
        - Wildcard: "*_test", "test_*", "*integration*"
        - Substring: "user" matches "user_test.spl"
        """
        # Simple wildcard matching
        if pattern.contains("*"):
            return self.matches_wildcard(suite.path, pattern)
        else:
            # Substring match
            return suite.path.contains(pattern)

    fn matches_wildcard(self, text: String, pattern: String): bool =
        """Check if text matches wildcard pattern.

        Args:
            text: Text to match
            pattern: Wildcard pattern (* matches anything)

        Returns:
            True if matches

        Examples:
        - "*_test" matches "app_test", "user_test"
        - "test_*" matches "test_app", "test_user"
        - "*integration*" matches "app_integration_test"
        """
        if pattern == "*":
            return true

        if pattern.starts_with("*") and pattern.ends_with("*"):
            # *substring*
            let substr = pattern[1:pattern.len()-1]
            return text.contains(substr)
        elif pattern.starts_with("*"):
            # *suffix
            let suffix = pattern[1:]
            return text.ends_with(suffix)
        elif pattern.ends_with("*"):
            # prefix*
            let prefix = pattern[0:pattern.len()-1]
            return text.starts_with(prefix)
        else:
            # No wildcards, exact match
            return text == pattern

    fn matches_file_pattern(self, suite: TestSuite, pattern: String): bool =
        """Check if suite matches file pattern.

        Args:
            suite: Test suite
            pattern: Glob pattern (simplified)

        Returns:
            True if matches

        Supports:
        - *.spl - Files ending with .spl
        - test_*.py - Files starting with test_ and ending with .py
        - **/*_spec.spl - Any _spec.spl file in any directory
        """
        # Extract filename from path
        let filename = self.get_filename(suite.path)

        # Match against pattern
        if pattern.starts_with("**/"):
            # Recursive pattern - match filename only
            let file_pattern = pattern[3:]
            return self.matches_glob_pattern(filename, file_pattern)
        else:
            # Direct pattern
            return self.matches_glob_pattern(filename, pattern)

    fn get_filename(self, path: String): String =
        """Extract filename from path.

        Args:
            path: File path

        Returns:
            Filename
        """
        let last_slash = path.rfind("/")
        if last_slash >= 0:
            path[last_slash+1:]
        else:
            path

    fn matches_glob_pattern(self, name: String, pattern: String): bool =
        """Check if name matches glob pattern.

        Args:
            name: Filename
            pattern: Glob pattern

        Returns:
            True if matches
        """
        if pattern.starts_with("*"):
            # Pattern: *.ext or *_suffix.ext
            let suffix = pattern[1:]
            name.ends_with(suffix)
        elif pattern.ends_with("*"):
            # Pattern: prefix_*
            let prefix = pattern[0:pattern.len()-1]
            name.starts_with(prefix)
        elif pattern.contains("*"):
            # Pattern: prefix_*.ext
            let star_idx = pattern.find("*")
            let prefix = pattern[0:star_idx]
            let suffix = pattern[star_idx+1:]
            name.starts_with(prefix) and name.ends_with(suffix)
        else:
            # Exact match
            name == pattern

# Smart test selection - select tests based on code changes
pub class SmartTestSelector:
    pub dependency_graph: Dict<String, List<String>>
    pub test_coverage: Dict<String, List<String>>

    pub fn new(): SmartTestSelector =
        """Create smart test selector.

        Returns:
            Smart selector

        Example:
            let selector = SmartTestSelector.new()
            selector.analyze_project(".")

            let changed_files = ["app.spl", "lib.spl"]
            let affected_tests = selector.select_tests(changed_files)

            print("Running {affected_tests.len()} affected tests")
            # 10x faster CI for small changes
        """
        SmartTestSelector {
            dependency_graph: {},
            test_coverage: {}
        }

    pub fn analyze_project(self, root: String):
        """Analyze project to build dependency graph and coverage.

        Args:
            root: Project root
        """
        # TODO: [stdlib][P3] Build dependency graph
        # TODO: [stdlib][P3] Analyze test coverage (which tests cover which files)
        pass

    pub fn select_tests(self, changed_files: List<String>): List<String> =
        """Select tests affected by changed files.

        Args:
            changed_files: Files that changed

        Returns:
            Test files to run

        Algorithm:
        1. Find files that directly changed
        2. Find files that depend on changed files (transitive)
        3. Find tests that cover those files
        4. Return unique set of tests
        """
        let affected: List<String> = []

        # Find tests covering changed files directly
        for file in changed_files:
            match self.test_coverage.get(file):
                some(tests):
                    affected.extend(tests)
                none:
                    pass

        # TODO: [stdlib][P3] Find tests covering transitive dependencies

        # Deduplicate
        self.deduplicate(affected)

    fn deduplicate(self, list: List<String>): List<String> =
        """Remove duplicates from list.

        Args:
            list: List with possible duplicates

        Returns:
            Unique list

        Algorithm:
        - Uses dict as set for O(n) deduplication
        - Preserves first occurrence order
        """
        let unique: List<String> = []
        let seen: Dict<String, bool> = {}

        for item in list:
            if not seen.contains_key(item):
                seen[item] = true
                unique.append(item)

        unique
