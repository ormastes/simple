# Primitive Type Extensions
# Feature #1387: Integer/Float/Bool object methods

"""
Extension methods for primitive types.

This module provides object-oriented methods for primitive types,
allowing syntax like `42.abs()` and `3.14.round()`.

These are implemented as extension methods that work with the
primitive types without boxing/wrapping.
"""

# ============================================
# Integer Extensions (i8, i16, i32, i64, u8, u16, u32, u64)
# ============================================

impl i64:
    """Integer extension methods"""

    fn abs(self) -> i64:
        """Absolute value"""
        if self < 0: -self else: self

    fn sign(self) -> i64:
        """Sign: -1, 0, or 1"""
        if self < 0: -1
        elif self > 0: 1
        else: 0

    fn pow(self, exp: u32) -> i64:
        """Raise to power"""
        var result = 1
        for _ in 0..exp:
            result *= self
        result

    fn min(self, other: i64) -> i64:
        """Minimum of two values"""
        if self < other: self else: other

    fn max(self, other: i64) -> i64:
        """Maximum of two values"""
        if self > other: self else: other

    fn clamp(self, min: i64, max: i64) -> i64:
        """Clamp value between min and max"""
        if self < min: min
        elif self > max: max
        else: self

    fn is_even(self) -> bool:
        """Check if even"""
        self % 2 == 0

    fn is_odd(self) -> bool:
        """Check if odd"""
        self % 2 != 0

    fn is_positive(self) -> bool:
        """Check if positive"""
        self > 0

    fn is_negative(self) -> bool:
        """Check if negative"""
        self < 0

    fn div_euclid(self, rhs: i64) -> i64:
        """Euclidean division (always non-negative remainder)"""
        let q = self / rhs
        let r = self % rhs
        if r < 0:
            if rhs > 0: q - 1 else: q + 1
        else:
            q

    fn rem_euclid(self, rhs: i64) -> i64:
        """Euclidean remainder (always non-negative)"""
        let r = self % rhs
        if r < 0:
            if rhs > 0: r + rhs else: r - rhs
        else:
            r

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_zero(self) -> bool:
        """Check if value is zero.

        Returns:
            true if value is 0

        Example:
            0.is_zero()  # → true
            5.is_zero()  # → false
        """
        self == 0

    fn is_power_of_two(self) -> bool:
        """Check if value is a power of two.

        Returns:
            true if value is power of 2

        Example:
            8.is_power_of_two()  # → true
            7.is_power_of_two()  # → false
        """
        self > 0 and (self & (self - 1)) == 0

    fn next_power_of_two(self) -> i64:
        """Get next power of two >= self.

        Returns:
            Next power of 2

        Example:
            5.next_power_of_two()  # → 8
            8.next_power_of_two()  # → 8
        """
        if self <= 1:
            return 1
        var n = self - 1
        n = n | (n >> 1)
        n = n | (n >> 2)
        n = n | (n >> 4)
        n = n | (n >> 8)
        n = n | (n >> 16)
        n = n | (n >> 32)
        n + 1

    fn checked_add(self, other: i64) -> Option<i64>:
        """Add with overflow checking.

        Args:
            other: Value to add

        Returns:
            Some(sum) or None if overflow

        Example:
            5.checked_add(10)  # → Some(15)
            i64::MAX.checked_add(1)  # → None
        """
        let result = self + other
        if (other > 0 and result < self) or (other < 0 and result > self):
            return None
        Some(result)

    fn checked_sub(self, other: i64) -> Option<i64>:
        """Subtract with overflow checking.

        Args:
            other: Value to subtract

        Returns:
            Some(difference) or None if overflow

        Example:
            10.checked_sub(5)  # → Some(5)
            i64::MIN.checked_sub(1)  # → None
        """
        let result = self - other
        if (other > 0 and result > self) or (other < 0 and result < self):
            return None
        Some(result)

    fn checked_mul(self, other: i64) -> Option<i64>:
        """Multiply with overflow checking.

        Args:
            other: Value to multiply

        Returns:
            Some(product) or None if overflow

        Example:
            5.checked_mul(10)  # → Some(50)
            i64::MAX.checked_mul(2)  # → None
        """
        if self == 0 or other == 0:
            return Some(0)
        let result = self * other
        if result / other != self:
            return None
        Some(result)

    fn saturating_add(self, other: i64) -> i64:
        """Add, saturating at bounds.

        Args:
            other: Value to add

        Returns:
            Sum, or i64::MAX/MIN if overflow

        Example:
            5.saturating_add(10)  # → 15
            i64::MAX.saturating_add(1)  # → i64::MAX
        """
        match self.checked_add(other):
            case Some(val): val
            case None: if other > 0: i64::MAX else: i64::MIN

    fn saturating_sub(self, other: i64) -> i64:
        """Subtract, saturating at bounds.

        Args:
            other: Value to subtract

        Returns:
            Difference, or i64::MAX/MIN if overflow

        Example:
            10.saturating_sub(5)  # → 5
            i64::MIN.saturating_sub(1)  # → i64::MIN
        """
        match self.checked_sub(other):
            case Some(val): val
            case None: if other > 0: i64::MIN else: i64::MAX

    fn saturating_mul(self, other: i64) -> i64:
        """Multiply, saturating at bounds.

        Args:
            other: Value to multiply

        Returns:
            Product, or i64::MAX/MIN if overflow

        Example:
            5.saturating_mul(10)  # → 50
            i64::MAX.saturating_mul(2)  # → i64::MAX
        """
        match self.checked_mul(other):
            case Some(val): val
            case None:
                if (self > 0 and other > 0) or (self < 0 and other < 0):
                    i64::MAX
                else:
                    i64::MIN

    fn wrapping_add(self, other: i64) -> i64:
        """Add with wrapping on overflow.

        Args:
            other: Value to add

        Returns:
            Sum with wrapping

        Example:
            5.wrapping_add(10)  # → 15
            i64::MAX.wrapping_add(1)  # → i64::MIN
        """
        self + other

    fn wrapping_sub(self, other: i64) -> i64:
        """Subtract with wrapping on overflow.

        Args:
            other: Value to subtract

        Returns:
            Difference with wrapping

        Example:
            10.wrapping_sub(5)  # → 5
            i64::MIN.wrapping_sub(1)  # → i64::MAX
        """
        self - other

    fn wrapping_mul(self, other: i64) -> i64:
        """Multiply with wrapping on overflow.

        Args:
            other: Value to multiply

        Returns:
            Product with wrapping

        Example:
            5.wrapping_mul(10)  # → 50
        """
        self * other

# ============================================
# Float Extensions (f32, f64)
# ============================================

impl f64:
    """Float extension methods"""

    fn abs(self) -> f64:
        """Absolute value"""
        if self < 0.0: -self else: self

    fn floor(self) -> f64:
        """Round down to integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_floor(self)

    fn ceil(self) -> f64:
        """Round up to integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_ceil(self)

    fn round(self) -> f64:
        """Round to nearest integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_round(self)

    fn trunc(self) -> f64:
        """Round toward zero"""
        if self >= 0.0: self.floor() else: self.ceil()

    fn sqrt(self) -> f64:
        """Square root"""
        __builtin_sqrt(self)

    fn powi(self, exp: i32) -> f64:
        """Raise to integer power"""
        __builtin_powi(self, exp)

    fn powf(self, exp: f64) -> f64:
        """Raise to float power"""
        __builtin_powf(self, exp)

    fn sin(self) -> f64:
        """Sine"""
        __builtin_sin(self)

    fn cos(self) -> f64:
        """Cosine"""
        __builtin_cos(self)

    fn tan(self) -> f64:
        """Tangent"""
        __builtin_tan(self)

    fn min(self, other: f64) -> f64:
        """Minimum of two values"""
        if self < other: self else: other

    fn max(self, other: f64) -> f64:
        """Maximum of two values"""
        if self > other: self else: other

    fn clamp(self, min: f64, max: f64) -> f64:
        """Clamp value between min and max"""
        if self < min: min
        elif self > max: max
        else: self

    fn is_nan(self) -> bool:
        """Check if NaN"""
        self != self

    fn is_infinite(self) -> bool:
        """Check if infinite"""
        self == f64::INFINITY or self == f64::NEG_INFINITY

    fn is_finite(self) -> bool:
        """Check if finite"""
        not self.is_infinite() and not self.is_nan()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_zero(self) -> bool:
        """Check if value is zero.

        Returns:
            true if value is 0.0

        Example:
            0.0.is_zero()  # → true
            0.1.is_zero()  # → false
        """
        self == 0.0

    fn is_positive(self) -> bool:
        """Check if value is positive.

        Returns:
            true if value > 0

        Example:
            5.0.is_positive()  # → true
            (-5.0).is_positive()  # → false
        """
        self > 0.0

    fn is_negative(self) -> bool:
        """Check if value is negative.

        Returns:
            true if value < 0

        Example:
            (-5.0).is_negative()  # → true
            5.0.is_negative()  # → false
        """
        self < 0.0

    fn signum(self) -> f64:
        """Get sign as -1.0, 0.0, or 1.0.

        Returns:
            Sign value

        Example:
            5.0.signum()  # → 1.0
            (-3.0).signum()  # → -1.0
            0.0.signum()  # → 0.0
        """
        if self > 0.0:
            1.0
        elif self < 0.0:
            -1.0
        else:
            0.0

    fn to_degrees(self) -> f64:
        """Convert radians to degrees.

        Returns:
            Value in degrees

        Example:
            f64::PI.to_degrees()  # → 180.0
        """
        self * (180.0 / f64::PI)

    fn to_radians(self) -> f64:
        """Convert degrees to radians.

        Returns:
            Value in radians

        Example:
            180.0.to_radians()  # → π
        """
        self * (f64::PI / 180.0)

    fn recip(self) -> f64:
        """Get reciprocal (1/x).

        Returns:
            Reciprocal

        Example:
            2.0.recip()  # → 0.5
            4.0.recip()  # → 0.25
        """
        1.0 / self

    fn exp(self) -> f64:
        """Exponential function (e^x).

        Returns:
            e raised to self

        Example:
            1.0.exp()  # → e
            2.0.exp()  # → e²
        """
        __builtin_exp(self)

    fn ln(self) -> f64:
        """Natural logarithm.

        Returns:
            ln(self)

        Example:
            f64::E.ln()  # → 1.0
        """
        __builtin_ln(self)

    fn log10(self) -> f64:
        """Base-10 logarithm.

        Returns:
            log₁₀(self)

        Example:
            100.0.log10()  # → 2.0
        """
        __builtin_log10(self)

    fn log2(self) -> f64:
        """Base-2 logarithm.

        Returns:
            log₂(self)

        Example:
            8.0.log2()  # → 3.0
        """
        __builtin_log2(self)

    fn fract(self) -> f64:
        """Get fractional part.

        Returns:
            Fractional component

        Example:
            3.75.fract()  # → 0.75
        """
        self - self.trunc()

    fn mul_add(self, a: f64, b: f64) -> f64:
        """Fused multiply-add: (self * a) + b.

        Args:
            a: Multiplier
            b: Addend

        Returns:
            (self * a) + b

        Example:
            2.0.mul_add(3.0, 4.0)  # → 10.0
        """
        (self * a) + b

# ============================================
# Bool Extensions
# ============================================

impl bool:
    """Boolean extension methods"""

    fn then<T>(self, value: T) -> Option<T>:
        """Return Some(value) if true, None if false"""
        if self: Some(value) else: None

    fn then_some<T>(self, f: fn() -> T) -> Option<T>:
        """Evaluate and return Some(result) if true"""
        if self: Some(f()) else: None

    fn to_int(self) -> i64:
        """Convert to integer (0 or 1)"""
        if self: 1 else: 0

    fn to_string(self) -> str:
        """Convert to string"""
        if self: "true" else: "false"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn not(self) -> bool:
        """Logical NOT.

        Returns:
            Negated value

        Example:
            true.not()  # → false
            false.not()  # → true
        """
        not self

    fn and(self, other: bool) -> bool:
        """Logical AND.

        Args:
            other: Other boolean

        Returns:
            self AND other

        Example:
            true.and(true)  # → true
            true.and(false)  # → false
        """
        self and other

    fn or(self, other: bool) -> bool:
        """Logical OR.

        Args:
            other: Other boolean

        Returns:
            self OR other

        Example:
            true.or(false)  # → true
            false.or(false)  # → false
        """
        self or other

    fn xor(self, other: bool) -> bool:
        """Logical XOR.

        Args:
            other: Other boolean

        Returns:
            self XOR other

        Example:
            true.xor(false)  # → true
            true.xor(true)  # → false
        """
        (self or other) and not (self and other)

    fn implies(self, other: bool) -> bool:
        """Logical implication (self → other).

        Args:
            other: Consequent

        Returns:
            true if self implies other

        Example:
            true.implies(false)  # → false
            false.implies(true)  # → true
        """
        not self or other

    fn to_option<T>(self, value: T) -> Option<T>:
        """Convert to Option (alias for then).

        Args:
            value: Value to wrap

        Returns:
            Some(value) if true, None otherwise

        Example:
            true.to_option(42)  # → Some(42)
            false.to_option(42)  # → None
        """
        if self: Some(value) else: None

# ============================================
# Constants
# ============================================

impl f64:
    const PI: f64 = 3.14159265358979323846
    const E: f64 = 2.71828182845904523536
    const INFINITY: f64 = 1.0 / 0.0
    const NEG_INFINITY: f64 = -1.0 / 0.0
    const NAN: f64 = 0.0 / 0.0

impl i64:
    const MIN: i64 = -9223372036854775808
    const MAX: i64 = 9223372036854775807

# ============================================
# Example Usage
# ============================================

"""
Example usage of primitive extensions:

    # Integer methods
    let x = -42
    assert x.abs() == 42
    assert x.is_negative()
    assert 10.pow(3) == 1000
    assert 5.min(10) == 5
    assert 7.clamp(0, 5) == 5

    # Float methods
    let y = 3.7
    assert y.floor() == 3.0
    assert y.ceil() == 4.0
    assert y.round() == 4.0
    assert 2.0.sqrt() == 1.414...
    assert 9.0.sqrt() == 3.0

    # Boolean methods
    let b = true
    assert b.to_int() == 1
    assert b.then(42) == Some(42)
    assert false.then(42) == None

    # Constants
    let circle_area = r * r * f64::PI
    assert f64::INFINITY.is_infinite()
"""
