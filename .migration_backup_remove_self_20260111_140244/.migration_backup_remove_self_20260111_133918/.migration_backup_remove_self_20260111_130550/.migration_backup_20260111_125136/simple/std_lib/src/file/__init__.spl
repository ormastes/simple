# File I/O Library - Async Memory-Mapped File Access
#
# High-performance async file I/O using memory-mapped files.
# Default mode is ASYNC with background loading.
#
# Quick Start:
#   use file
#
#   # Async loading (default)
#   async with await file.open("data.txt") as mmap:
#       let content = mmap.as_str()?
#       process(content)
#
#   # Sync loading (blocks until ready)
#   with file.open_sync("data.txt") as mmap:
#       let content = mmap.as_str()?
#       process(content)
#
# See also: cli.file for sync-only file validation

# Extern declarations for FFI
extern fn rt_file_exists(path: String) -> Bool
extern fn rt_file_open(path: String, mode: Int) -> Int
extern fn rt_file_get_size(fd: Int) -> Int
extern fn rt_file_close(fd: Int) -> Void
extern fn rt_file_mmap(addr: *void, length: Int, prot: Int, flags: Int, fd: Int, offset: Int) -> *u8
extern fn rt_file_munmap(addr: *u8, length: Int) -> Int
extern fn rt_file_madvise(addr: *u8, length: Int, advice: Int) -> Int

# Re-export public API
pub use file.mmap.*
pub use file.async_handle.*
pub use file.context.*

# Public API functions

# Async file opening (default) - returns immediately, loads in background
pub async fn open(path: String) -> Result<AsyncFileHandle, FileError>:
    let handle = AsyncFileHandle::new(path)
    handle.start_loading()
    return Ok(handle)

# Async file opening with options
pub async fn open_with(path: String, opts: OpenOptions) -> Result<AsyncFileHandle, FileError>:
    let handle = AsyncFileHandle::with_options(path, opts)
    handle.start_loading()
    return Ok(handle)

# Sync file opening - blocks until file is loaded
pub fn open_sync(path: String) -> Result<MmapRegion, FileError>:
    let opts = OpenOptions::new()
    return open_sync_with(path, opts)

# Sync file opening with options
pub fn open_sync_with(path: String, opts: OpenOptions) -> Result<MmapRegion, FileError>:
    # Validate path
    if not file_exists(path):
        return Err(FileError::NotFound(path))

    # Open file and mmap
    let fd = sys_open(path, OpenMode::ReadOnly)?
    let file_size = sys_file_size(fd)?

    # Create mmap
    let mmap_ptr = sys_mmap(
        addr: null,
        length: file_size,
        prot: opts.get_prot_flags(),
        flags: opts.get_map_flags(),
        fd: fd,
        offset: 0
    )?

    if mmap_ptr == null:
        sys_close(fd)
        return Err(FileError::MmapFailed("mmap returned null"))

    # Create region
    let region = MmapRegion {
        data: mmap_ptr,
        length: file_size,
        mode: opts.mode,
        fd: fd,
        path: path
    }

    # Apply advice if specified
    if opts.advice != MmapAdvice::Normal:
        region.advise(opts.advice)

    return Ok(region)

# Check if file exists (sync)
pub fn exists(path: String) -> bool:
    return file_exists(path)

# Get file size (sync)
pub fn size(path: String) -> Result<usize, FileError>:
    if not file_exists(path):
        return Err(FileError::NotFound(path))

    let fd = sys_open(path, OpenMode::ReadOnly)?
    let size = sys_file_size(fd)?
    sys_close(fd)
    return Ok(size)

# FFI Placeholders (to be implemented in Rust runtime)

# Check if file exists
fn file_exists(path: String) -> bool:
    return rt_file_exists(path)

# Open file and return file descriptor
fn sys_open(path: String, mode: OpenMode) -> Result<i32, FileError>:
    let mode_int = match mode:
        case ReadOnly: 0
        case ReadWrite: 1
        case WriteOnly: 2
    let fd = rt_file_open(path, mode_int)
    if fd == -1:
        return Err(FileError::OpenFailed)
    return Ok(fd)

# Get file size
fn sys_file_size(fd: i32) -> Result<usize, FileError>:
    let size = rt_file_get_size(fd)
    if size == 0:
        return Err(FileError::IoError("Failed to get file size"))
    return Ok(size as usize)

# Close file descriptor
fn sys_close(fd: i32):
    rt_file_close(fd)

# Memory map a file
fn sys_mmap(addr: *void, length: usize, prot: i32, flags: i32, fd: i32, offset: usize) -> Result<*u8, FileError>:
    let ptr = rt_file_mmap(addr, length as Int, prot, flags, fd, offset as Int)
    if ptr == null:
        return Err(FileError::MmapFailed("mmap failed"))
    return Ok(ptr)

# Unmap memory region
fn sys_munmap(addr: *u8, length: usize) -> Result<void, FileError>:
    let result = rt_file_munmap(addr, length as Int)
    if result == -1:
        return Err(FileError::IoError("munmap failed"))
    return Ok(void)

# Advise kernel on memory access pattern
fn sys_madvise(addr: *u8, length: usize, advice: i32) -> Result<void, FileError>:
    let result = rt_file_madvise(addr, length as Int, advice)
    if result == -1:
        return Err(FileError::IoError("madvise failed"))
    return Ok(void)

# File opening mode
enum OpenMode:
    ReadOnly
    ReadWrite
    WriteOnly

impl OpenMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_read_only(self) -> bool:
        """Check if this is ReadOnly mode.

        Returns:
            true for ReadOnly

        Example:
            OpenMode::ReadOnly.is_read_only()  # → true
        """
        match self:
            case ReadOnly: true
            case _: false

    fn is_read_write(self) -> bool:
        """Check if this is ReadWrite mode.

        Returns:
            true for ReadWrite

        Example:
            OpenMode::ReadWrite.is_read_write()  # → true
        """
        match self:
            case ReadWrite: true
            case _: false

    fn is_write_only(self) -> bool:
        """Check if this is WriteOnly mode.

        Returns:
            true for WriteOnly

        Example:
            OpenMode::WriteOnly.is_write_only()  # → true
        """
        match self:
            case WriteOnly: true
            case _: false

    fn can_read(self) -> bool:
        """Check if mode allows reading.

        Returns:
            true for ReadOnly and ReadWrite

        Example:
            OpenMode::ReadOnly.can_read()  # → true
            OpenMode::WriteOnly.can_read()  # → false
        """
        match self:
            case ReadOnly: true
            case ReadWrite: true
            case WriteOnly: false

    fn can_write(self) -> bool:
        """Check if mode allows writing.

        Returns:
            true for ReadWrite and WriteOnly

        Example:
            OpenMode::ReadWrite.can_write()  # → true
            OpenMode::ReadOnly.can_write()  # → false
        """
        match self:
            case ReadWrite: true
            case WriteOnly: true
            case ReadOnly: false

    fn is_mutable(self) -> bool:
        """Check if mode allows mutation (alias for can_write).

        Returns:
            true for ReadWrite and WriteOnly

        Example:
            OpenMode::ReadWrite.is_mutable()  # → true
        """
        return self.can_write()

    fn to_string(self) -> String:
        """Convert mode to string.

        Returns:
            Mode name

        Example:
            OpenMode::ReadOnly.to_string()  # → "read_only"
        """
        match self:
            case ReadOnly: "read_only"
            case ReadWrite: "read_write"
            case WriteOnly: "write_only"

    fn summary(self) -> String:
        """Get summary of open mode.

        Returns:
            Human-readable summary

        Example:
            OpenMode::ReadWrite.summary()
            # → "OpenMode: read_write (can read, can write)"
        """
        let name = self.to_string()
        let caps = if self.can_read() and self.can_write():
                       "can read, can write"
                   else if self.can_read():
                       "can read only"
                   else:
                       "can write only"
        return "OpenMode: {name} ({caps})"
