# Incremental Update Support for LMS
# Efficiently handles partial document updates and change tracking

import protocol
import workspace

# Text edit operation
pub class TextEdit:
    range: protocol.Range
    new_text: String

    pub fn new(range: protocol.Range, new_text: String) -> TextEdit:
        TextEdit {
            range: range,
            new_text: new_text
        }

# Document change event
pub class DocumentChange:
    uri: String
    version: Int
    edits: List<TextEdit>
    full_content: Option<String>  # For full document sync

    pub fn new_full(uri: String, version: Int, content: String) -> DocumentChange:
        DocumentChange {
            uri: uri,
            version: version,
            edits: [],
            full_content: Some(content)
        }

    pub fn new_incremental(uri: String, version: Int, edits: List<TextEdit>) -> DocumentChange:
        DocumentChange {
            uri: uri,
            version: version,
            edits: edits,
            full_content: None
        }

# Change buffer for batching updates
pub class ChangeBuffer:
    changes: Dict<String, List<DocumentChange>>  # uri -> changes
    max_buffer_size: Int
    flush_interval_ms: Int
    last_flush: Int

    pub fn new(max_buffer_size: Int, flush_interval_ms: Int) -> ChangeBuffer:
        ChangeBuffer {
            changes: {},
            max_buffer_size: max_buffer_size,
            flush_interval_ms: flush_interval_ms,
            last_flush: sys.time.now_ms()
        }

    # Add a change to the buffer
    pub fn add_change(mut self, change: DocumentChange):
        match self.changes.get_mut(change.uri):
            Some(change_list) ->
                change_list.push(change)
            None ->
                self.changes[change.uri] = [change]

    # Check if buffer should be flushed
    pub fn should_flush(self) -> Bool:
        # Flush if buffer is full
        let total_changes = 0
        for (uri, change_list) in self.changes:
            total_changes = total_changes + change_list.len()

        if total_changes >= self.max_buffer_size:
            return true

        # Flush if timeout exceeded
        let now = sys.time.now_ms()
        if now - self.last_flush >= self.flush_interval_ms:
            return true

        false

    # Flush all buffered changes
    pub fn flush(mut self) -> Dict<String, List<DocumentChange>>:
        let result = self.changes
        self.changes = {}
        self.last_flush = sys.time.now_ms()
        result

    # Get buffered changes for a specific file
    pub fn get_changes(self, uri: String) -> Option<List<DocumentChange>>:
        self.changes.get(uri)

# Incremental update manager
pub class IncrementalUpdateManager:
    workspace: workspace.WorkspaceManager
    change_buffer: ChangeBuffer
    version_map: Dict<String, Int>  # uri -> current version

    pub fn new(workspace: workspace.WorkspaceManager) -> IncrementalUpdateManager:
        IncrementalUpdateManager {
            workspace: workspace,
            change_buffer: ChangeBuffer.new(100, 500),  # Max 100 changes, flush every 500ms
            version_map: {}
        }

    # Handle a document change notification
    pub fn handle_change(mut self, change: DocumentChange) -> Result<Nil, String>:
        # Verify version sequence
        match self.version_map.get(change.uri):
            Some(current_version) ->
                if change.version <= current_version:
                    return Err("Version mismatch: expected > {current_version}, got {change.version}")
            None ->
                pass  # First change for this document

        # Update version
        self.version_map[change.uri] = change.version

        # Apply change
        match change.full_content:
            Some(content) ->
                # Full document sync
                self.workspace.add_file(change.uri, content, change.version)
            None ->
                # Incremental update
                self.apply_incremental_edits(change.uri, change.edits)?

        # Buffer the change
        self.change_buffer.add_change(change)

        # Flush if needed
        if self.change_buffer.should_flush():
            self.flush_changes()?

        Ok(nil)

    # Apply incremental edits to a document
    me apply_incremental_edits(self, uri: String, edits: List<TextEdit>) -> Result<Nil, String>:
        # Get current content
        let current_content = match self.workspace.get_content(uri):
            Some(content) ->
                content
            None ->
                return Err("Document not found: {uri}")

        # Apply edits in reverse order (to maintain positions)
        let mut new_content = current_content
        let mut sorted_edits = edits
        sorted_edits.reverse()

        for edit in sorted_edits:
            new_content = apply_edit(new_content, edit)?

        # Update workspace with new content
        let current_version = self.version_map[uri]
        self.workspace.add_file(uri, new_content, current_version)

        Ok(nil)

    # Flush buffered changes
    me flush_changes(self) -> Result<Nil, String>:
        let changes = self.change_buffer.flush()

        # Process flushed changes (e.g., trigger reanalysis)
        for (uri, change_list) in changes:
            # Get affected files
            let affected = self.workspace.get_affected_files(uri)

            # Here we would trigger reanalysis/recompilation
            # For now, just log
            transport.log_debug("Flushed {change_list.len()} changes for {uri}, {affected.len()} files affected")

        Ok(nil)

    # Get current version of a document
    pub fn get_version(self, uri: String) -> Option<Int>:
        self.version_map.get(uri)

    # Force flush all buffered changes
    pub fn force_flush(mut self) -> Result<Nil, String>:
        self.flush_changes()

# Apply a single text edit to content
fn apply_edit(content: String, edit: TextEdit) -> Result<String, String>:
    # Convert content to lines
    let lines = content.split("\n")

    # Extract range
    let start_line = edit.range.start.line
    let start_char = edit.range.start.character
    let end_line = edit.range.end.line
    let end_char = edit.range.end.character

    # Validate range
    if start_line >= lines.len():
        return Err("Start line {start_line} out of range")
    if end_line >= lines.len():
        return Err("End line {end_line} out of range")

    # Build new content
    let mut result = ""

    # Add lines before edit
    for i in 0..start_line:
        result = result + lines[i] + "\n"

    # Add start line prefix
    if start_char > 0:
        result = result + lines[start_line].substring(0, start_char)

    # Add new text
    result = result + edit.new_text

    # Add end line suffix
    if end_char < lines[end_line].len():
        result = result + lines[end_line].substring(end_char, lines[end_line].len())

    # Add lines after edit
    for i in (end_line + 1)..lines.len():
        result = result + "\n" + lines[i]

    Ok(result)
