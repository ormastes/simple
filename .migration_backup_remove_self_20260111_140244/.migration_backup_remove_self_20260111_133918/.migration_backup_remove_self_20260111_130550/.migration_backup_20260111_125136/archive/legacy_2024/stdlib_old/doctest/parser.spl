/// Doctest Example Parser
/// 
/// Extracts >>> examples from docstrings, Markdown, and .sdt files

/// Source location for error reporting
struct SourceLocation:
    file: String
    line: Int
    
    fn to_string(self) -> String:
        return "${self.file}:${self.line}"

/// Expected output type
enum Expected:
    /// Exact string match
    Output(String)
    /// Exception with type and optional message
    Exception(String, Option<String>)  # (type, message)
    /// Empty (no output expected)
    Empty

/// A single doctest example
struct DoctestExample:
    /// Original source (file or docstring)
    source: String
    /// Location in source
    location: SourceLocation
    /// Setup code (executed but output suppressed)
    setup: List<String>
    /// Main code to execute
    code: List<String>
    /// Expected output or exception
    expected: Expected
    /// Teardown code (executed but output suppressed)
    teardown: List<String>
    /// Tags for filtering
    tags: Set<String>
    /// Execution mode (inline or isolated)
    mode: String  # "inline" or "isolated"
    /// Timeout in milliseconds
    timeout_ms: Int
    
    fn to_string(self) -> String:
        return "DoctestExample(${self.location}, ${self.code.len} lines)"

/// Parse doctests from a string containing docstring content
/// 
/// Examples:
/// >>> examples = parse_docstring(">>> 1 + 1\n2\n")
/// >>> examples.len
/// 1
/// >>> examples[0].code
/// ["1 + 1"]
/// >>> examples[0].expected
/// Expected.Output("2")
fn parse_docstring(content: String, source: String = "<docstring>") -> List<DoctestExample>:
    examples = []
    lines = content.split("\n")
    i = 0
    line_num = 1
    
    # State machine for parsing
    current_code = []
    current_expected = []
    current_setup = []
    current_teardown = []
    in_setup = False
    in_teardown = False
    start_line = 0
    
    while i < lines.len:
        line = lines[i].strip()
        
        # Detect setup block
        if line == "Setup:":
            in_setup = True
            in_teardown = False
            i += 1
            line_num += 1
            continue
        
        # Detect teardown block
        if line == "Teardown:":
            in_teardown = True
            in_setup = False
            i += 1
            line_num += 1
            continue
        
        # Detect example block
        if line == "Example:" or line == "Examples:":
            in_setup = False
            in_teardown = False
            i += 1
            line_num += 1
            continue
        
        # Prompt line: >>> or ...
        if line.starts_with(">>>") or line.starts_with("..."):
            code_line = line[3:].strip()
            
            if in_setup:
                current_setup.push(code_line)
            elif in_teardown:
                current_teardown.push(code_line)
            else:
                if current_code.is_empty:
                    start_line = line_num
                current_code.push(code_line)
        
        # Expected output or exception
        elif not line.is_empty and not current_code.is_empty and not in_setup and not in_teardown:
            current_expected.push(line)
        
        # Blank line or end - finish current example
        elif (line.is_empty or i == lines.len - 1) and not current_code.is_empty:
            # Parse expected output
            expected = parse_expected(current_expected)
            
            examples.push(DoctestExample(
                source: source,
                location: SourceLocation(file: source, line: start_line),
                setup: current_setup.copy(),
                code: current_code,
                expected: expected,
                teardown: current_teardown.copy(),
                tags: Set.new(),
                mode: "inline",
                timeout_ms: 5000
            ))
            
            current_code = []
            current_expected = []
        
        i += 1
        line_num += 1
    
    return examples

/// Parse expected output from lines following >>>
fn parse_expected(lines: List<String>) -> Expected:
    if lines.is_empty:
        return Expected.Empty
    
    # Check if it's an exception
    first = lines[0]
    if first.starts_with("Error:"):
        # Parse "Error: ExceptionType" or "Error: ExceptionType: message"
        rest = first[6:].strip()
        parts = rest.split(":", limit: 2)
        exception_type = parts[0].strip()
        message = if parts.len > 1 then Option.Some(parts[1].strip()) else Option.None
        return Expected.Exception(exception_type, message)
    
    # Otherwise, it's output (join all lines)
    output = lines.join("\n")
    return Expected.Output(output)

/// Parse a standalone .sdt file
/// 
/// .sdt files contain pure doctest format (no docstring wrapping)
fn parse_sdt_file(path: String) -> List<DoctestExample>:
    content = read_file(path)
    # .sdt files are just unwrapped docstring content
    return parse_docstring(content, source: path)

/// Extract docstrings from Simple source file (.spl)
/// 
/// This is a simplified parser that looks for /// comment blocks
/// In production, this would use the AST
fn extract_docstrings(source_code: String, file_path: String) -> List<(String, Int)>:  # (content, line)
    docstrings = []
    lines = source_code.split("\n")
    current_docstring = []
    start_line = 0
    
    for i, line in lines.enumerate():
        trimmed = line.trim_start()
        if trimmed.starts_with("///"):
            if current_docstring.is_empty:
                start_line = i + 1
            # Remove /// prefix
            doc_line = trimmed[3:].trim_start()
            current_docstring.push(doc_line)
        elif not current_docstring.is_empty:
            # End of docstring block
            content = current_docstring.join("\n")
            docstrings.push((content, start_line))
            current_docstring = []
    
    # Handle docstring at end of file
    if not current_docstring.is_empty:
        content = current_docstring.join("\n")
        docstrings.push((content, start_line))
    
    return docstrings

/// Parse all doctests from a Simple source file
fn parse_spl_file(path: String) -> List<DoctestExample>:
    source_code = read_file(path)
    docstrings = extract_docstrings(source_code, path)
    
    examples = []
    for (content, line) in docstrings:
        file_examples = parse_docstring(content, source: path)
        # Update line numbers to account for docstring location
        for ex in file_examples:
            ex.location.line += line
        examples.extend(file_examples)
    
    return examples

# Helper to read file (placeholder - will use std.io in real implementation)
fn read_file(path: String) -> String:
    # TODO: Use std.io.read_text_file
    return ""
