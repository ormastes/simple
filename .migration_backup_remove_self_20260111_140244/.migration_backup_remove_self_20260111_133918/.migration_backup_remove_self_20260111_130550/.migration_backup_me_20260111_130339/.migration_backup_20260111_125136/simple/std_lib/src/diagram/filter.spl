# Diagram Filter Module
# Provides include/exclude filtering for diagram generation
#
# Supports:
# - Glob patterns (*, **, ?)
# - Exact string matching
# - Multiple patterns (comma-separated)
# - Exclude takes precedence over include

import core.{Option, List, regex}
import recorder.{CallEvent}

# Filter mode
enum FilterMode:
    Include  # Only include matching items
    Exclude  # Exclude matching items

impl FilterMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_include(self) -> bool:
        """Check if this is Include mode.

        Returns:
            true for Include

        Example:
            FilterMode::Include.is_include()  # → true
        """
        match self:
            case Include: true
            case _: false

    fn is_exclude(self) -> bool:
        """Check if this is Exclude mode.

        Returns:
            true for Exclude

        Example:
            FilterMode::Exclude.is_exclude()  # → true
        """
        match self:
            case Exclude: true
            case _: false

    fn is_whitelist(self) -> bool:
        """Check if mode is whitelist-style (include only matched).

        Returns:
            true for Include

        Example:
            FilterMode::Include.is_whitelist()  # → true
        """
        return self.is_include()

    fn is_blacklist(self) -> bool:
        """Check if mode is blacklist-style (exclude matched).

        Returns:
            true for Exclude

        Example:
            FilterMode::Exclude.is_blacklist()  # → true
        """
        return self.is_exclude()

    fn is_positive(self) -> bool:
        """Check if mode uses positive matching (include).

        Returns:
            true for Include

        Example:
            FilterMode::Include.is_positive()  # → true
        """
        return self.is_include()

    fn is_negative(self) -> bool:
        """Check if mode uses negative matching (exclude).

        Returns:
            true for Exclude

        Example:
            FilterMode::Exclude.is_negative()  # → true
        """
        return self.is_exclude()

    fn inverted(self) -> FilterMode:
        """Get opposite filter mode.

        Returns:
            Opposite mode (Include ↔ Exclude)

        Example:
            FilterMode::Include.inverted()  # → FilterMode::Exclude
            FilterMode::Exclude.inverted()  # → FilterMode::Include
        """
        match self:
            case Include: FilterMode::Exclude
            case Exclude: FilterMode::Include

    fn to_string(self) -> String:
        """Convert filter mode to string.

        Returns:
            Mode name

        Example:
            FilterMode::Include.to_string()  # → "include"
        """
        match self:
            case Include: "include"
            case Exclude: "exclude"

    fn description(self) -> String:
        """Get filter mode description.

        Returns:
            Human-readable description

        Example:
            FilterMode::Include.description()
            # → "Only include matching items"
        """
        match self:
            case Include: "Only include matching items"
            case Exclude: "Exclude matching items"

    fn summary(self) -> String:
        """Get summary of filter mode.

        Returns:
            Human-readable summary

        Example:
            FilterMode::Include.summary()
            # → "FilterMode: include (whitelist, positive matching)"
        """
        let name = self.to_string()
        let style = if self.is_whitelist(): "whitelist" else: "blacklist"
        let matching = if self.is_positive(): "positive matching" else: "negative matching"
        return "FilterMode: {name} ({style}, {matching})"

# Single pattern for matching
struct FilterPattern:
    raw: String           # Original pattern string
    regex: regex.Regex    # Compiled regex for matching
    mode: FilterMode      # Include or exclude

    # Create pattern from glob-style string
    fn from_glob(pattern: String, mode: FilterMode) -> FilterPattern:
        # Convert glob to regex
        let regex_str = glob_to_regex(pattern)
        return FilterPattern {
            raw: pattern,
            regex: regex.compile(regex_str),
            mode: mode,
        }

    # Check if a string matches this pattern
    fn matches(self, text: String) -> Bool:
        return self.regex.is_match(text)

# Convert glob pattern to regex
fn glob_to_regex(glob: String) -> String:
    let result = "^"
    let chars = glob.chars()
    let i = 0

    while i < chars.len():
        let c = chars[i]
        match c:
            case '*':
                # Check for **
                if i + 1 < chars.len() and chars[i + 1] == '*':
                    result = result + ".*"
                    i += 1
                else:
                    result = result + "[^.]*"
            case '?':
                result = result + "."
            case '.':
                result = result + "\\."
            case '(':
                result = result + "\\("
            case ')':
                result = result + "\\)"
            case '[':
                result = result + "\\["
            case ']':
                result = result + "\\]"
            case '{':
                result = result + "\\{"
            case '}':
                result = result + "\\}"
            case '^':
                result = result + "\\^"
            case '$':
                result = result + "\\$"
            case '|':
                result = result + "\\|"
            case '\\':
                result = result + "\\\\"
            case _:
                result = result + c
        i += 1

    return result + "$"

# Filter configuration
class DiagramFilter:
    include_patterns: List<FilterPattern>
    exclude_patterns: List<FilterPattern>

    fn new() -> DiagramFilter:
        return DiagramFilter {
            include_patterns: [],
            exclude_patterns: [],
        }

    # Add an include pattern
    me add_include(self, pattern: String) -> Void:
        self.include_patterns.push(FilterPattern.from_glob(pattern, FilterMode.Include))

    # Add multiple include patterns (comma-separated)
    me add_includes(self, patterns: String) -> Void:
        for pattern in patterns.split(","):
            let trimmed = pattern.trim()
            if not trimmed.is_empty():
                self.add_include(trimmed)

    # Add an exclude pattern
    me add_exclude(self, pattern: String) -> Void:
        self.exclude_patterns.push(FilterPattern.from_glob(pattern, FilterMode.Exclude))

    # Add multiple exclude patterns (comma-separated)
    me add_excludes(self, patterns: String) -> Void:
        for pattern in patterns.split(","):
            let trimmed = pattern.trim()
            if not trimmed.is_empty():
                self.add_exclude(trimmed)

    # Check if a name should be included
    # Rules:
    # 1. If excluded by any pattern -> false
    # 2. If no include patterns -> true (include all by default)
    # 3. If include patterns exist -> must match at least one
    fn should_include(self, name: String) -> Bool:
        # Check excludes first (they take precedence)
        for pattern in self.exclude_patterns:
            if pattern.matches(name):
                return false

        # If no include patterns, include everything
        if self.include_patterns.is_empty():
            return true

        # Must match at least one include pattern
        for pattern in self.include_patterns:
            if pattern.matches(name):
                return true

        return false

    # Filter a call event based on caller and callee
    fn should_include_event(self, event: CallEvent) -> Bool:
        let caller = event.get_caller_participant()
        let callee = event.get_callee_participant()

        # Both caller and callee must pass filter
        return self.should_include(caller) and self.should_include(callee)

    # Filter a list of events
    fn filter_events(self, events: List<CallEvent>) -> List<CallEvent>:
        let result: List<CallEvent> = []
        for event in events:
            if self.should_include_event(event):
                result.push(event)
        return result

    # Check if filter has any patterns
    fn is_empty(self) -> Bool:
        return self.include_patterns.is_empty() and self.exclude_patterns.is_empty()

    # Get pattern count
    fn pattern_count(self) -> u32:
        return (self.include_patterns.len() + self.exclude_patterns.len()) as u32

# Builder pattern for filter creation
fn filter() -> DiagramFilter:
    return DiagramFilter.new()

fn include(pattern: String) -> DiagramFilter:
    let f = DiagramFilter.new()
    f.add_include(pattern)
    return f

fn exclude(pattern: String) -> DiagramFilter:
    let f = DiagramFilter.new()
    f.add_exclude(pattern)
    return f

# Exports
export FilterMode, FilterPattern, DiagramFilter
export glob_to_regex, filter, include, exclude
