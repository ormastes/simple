# Unit tests for BDD Matchers
# Tests all matcher types: core, comparison, collection, boolean, string, type, error

import spec.{describe, context, it, expect, before_each}
import spec.matchers.{eq, be, be_nil}
import spec.matchers.{gt, lt, gte, lte}
import spec.matchers.{include, be_empty, have_length, have_size}
import spec.matchers.{be_true, be_false, be_truthy, be_falsy}
import spec.matchers.{include_string, start_with, end_with, be_blank}
import spec.matchers.{be_option, be_result, be_instance_of, be_a, be_an}
import spec.matchers.{raise_error}
import spec.matchers.{Matcher, MatchResult}
import spec.registry.{reset_registry}

describe "BDD Matchers":
    before_each:
        reset_registry()

    context "MatchResult":
        it "creates a successful match result":
            val result = MatchResult.success()
            expect(result.matched).to eq(true)
            expect(result.is_success()).to eq(true)
            expect(result.is_failure()).to eq(false)

        it "creates a failure match result":
            val result = MatchResult.failure("error message")
            expect(result.matched).to eq(false)
            expect(result.is_success()).to eq(false)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to eq("error message")

        it "can create with custom messages":
            val result = MatchResult.new(false, "fail msg", "negated fail msg")
            expect(result.failure_message).to eq("fail msg")
            expect(result.negated_failure_message).to eq("negated fail msg")

        it "has_failure_message returns true when message is set":
            val result = MatchResult.failure("error")
            expect(result.has_failure_message()).to eq(true)

        it "has_failure_message returns false for empty message":
            val result = MatchResult.success()
            expect(result.has_failure_message()).to eq(false)

        it "get_message returns appropriate message based on negation":
            val result = MatchResult.new(false, "fail", "negated fail")
            expect(result.get_message(false)).to eq("fail")
            expect(result.get_message(true)).to eq("negated fail")

        it "with_failure_message creates new result with updated message":
            val result = MatchResult.success().with_failure_message("new fail")
            expect(result.failure_message).to eq("new fail")

        it "with_negated_message creates new result with updated negated message":
            val result = MatchResult.success().with_negated_message("new negated")
            expect(result.negated_failure_message).to eq("new negated")

        it "negate inverts the match result":
            val result = MatchResult.success().negate()
            expect(result.matched).to eq(false)

        it "summary provides readable description":
            val success = MatchResult.success()
            expect(success.summary()).to include_string("success")

            val failure = MatchResult.failure("test error")
            val summary = failure.summary()
            expect(summary).to include_string("failure")
            expect(summary).to include_string("test error")

    context "Core Matchers - eq":
        it "matches equal integers":
            val matcher = eq(42)
            val result = matcher.matches(42)
            expect(result.is_success()).to eq(true)

        it "fails for unequal integers":
            val matcher = eq(42)
            val result = matcher.matches(10)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("Expected")

        it "matches equal strings":
            val matcher = eq("hello")
            val result = matcher.matches("hello")
            expect(result.is_success()).to eq(true)

        it "fails for unequal strings":
            val matcher = eq("hello")
            val result = matcher.matches("world")
            expect(result.is_failure()).to eq(true)

    context "Core Matchers - be":
        it "matches identical values (identity check)":
            val obj = [1, 2, 3]
            val matcher = be(obj)
            val result = matcher.matches(obj)
            expect(result.is_success()).to eq(true)

        it "fails for different objects with same value":
            val obj1 = [1, 2, 3]
            val obj2 = [1, 2, 3]
            val matcher = be(obj1)
            val result = matcher.matches(obj2)
            # Identity check - different objects
            expect(result.is_failure()).to eq(true)

    context "Core Matchers - be_nil":
        it "matches None value":
            val matcher = be_nil()
            val result = matcher.matches(None)
            expect(result.is_success()).to eq(true)

        it "fails for Some value":
            val matcher = be_nil()
            val result = matcher.matches(Some(42))
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("Expected None")

    context "Comparison Matchers - gt":
        it "matches when actual > expected":
            val matcher = gt(5)
            val result = matcher.matches(10)
            expect(result.is_success()).to eq(true)

        it "fails when actual <= expected":
            val matcher = gt(5)
            val result = matcher.matches(3)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("greater than")

    context "Comparison Matchers - lt":
        it "matches when actual < expected":
            val matcher = lt(10)
            val result = matcher.matches(5)
            expect(result.is_success()).to eq(true)

        it "fails when actual >= expected":
            val matcher = lt(5)
            val result = matcher.matches(10)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("less than")

    context "Comparison Matchers - gte":
        it "matches when actual > expected":
            val matcher = gte(5)
            val result = matcher.matches(10)
            expect(result.is_success()).to eq(true)

        it "matches when actual == expected":
            val matcher = gte(5)
            val result = matcher.matches(5)
            expect(result.is_success()).to eq(true)

        it "fails when actual < expected":
            val matcher = gte(10)
            val result = matcher.matches(5)
            expect(result.is_failure()).to eq(true)

    context "Comparison Matchers - lte":
        it "matches when actual < expected":
            val matcher = lte(10)
            val result = matcher.matches(5)
            expect(result.is_success()).to eq(true)

        it "matches when actual == expected":
            val matcher = lte(5)
            val result = matcher.matches(5)
            expect(result.is_success()).to eq(true)

        it "fails when actual > expected":
            val matcher = lte(5)
            val result = matcher.matches(10)
            expect(result.is_failure()).to eq(true)

    context "Collection Matchers - include":
        it "matches when array contains element":
            val matcher = include(2)
            val result = matcher.matches([1, 2, 3])
            expect(result.is_success()).to eq(true)

        it "fails when array does not contain element":
            val matcher = include(5)
            val result = matcher.matches([1, 2, 3])
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("include")

    context "Collection Matchers - be_empty":
        it "matches empty array":
            val matcher = be_empty()
            val result = matcher.matches([])
            expect(result.is_success()).to eq(true)

        it "fails for non-empty array":
            val matcher = be_empty()
            val result = matcher.matches([1, 2, 3])
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("empty")

    context "Collection Matchers - have_length":
        it "matches when length equals expected":
            val matcher = have_length(3)
            val result = matcher.matches([1, 2, 3])
            expect(result.is_success()).to eq(true)

        it "fails when length does not match":
            val matcher = have_length(5)
            val result = matcher.matches([1, 2, 3])
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("length")

    context "Collection Matchers - have_size":
        it "is an alias for have_length":
            val matcher = have_size(2)
            val result = matcher.matches([1, 2])
            expect(result.is_success()).to eq(true)

    context "Boolean Matchers - be_true":
        it "matches true value":
            val matcher = be_true()
            val result = matcher.matches(true)
            expect(result.is_success()).to eq(true)

        it "fails for false value":
            val matcher = be_true()
            val result = matcher.matches(false)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("true")

    context "Boolean Matchers - be_false":
        it "matches false value":
            val matcher = be_false()
            val result = matcher.matches(false)
            expect(result.is_success()).to eq(true)

        it "fails for true value":
            val matcher = be_false()
            val result = matcher.matches(true)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("false")

    context "Boolean Matchers - be_truthy":
        it "matches Some value":
            val matcher = be_truthy()
            val result = matcher.matches(Some(42))
            expect(result.is_success()).to eq(true)

        it "fails for None value":
            val matcher = be_truthy()
            val result = matcher.matches(None)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("Some")

    context "Boolean Matchers - be_falsy":
        it "matches None value":
            val matcher = be_falsy()
            val result = matcher.matches(None)
            expect(result.is_success()).to eq(true)

        it "fails for Some value":
            val matcher = be_falsy()
            val result = matcher.matches(Some(42))
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("None")

    context "String Matchers - include_string":
        it "matches when string contains substring":
            val matcher = include_string("world")
            val result = matcher.matches("hello world")
            expect(result.is_success()).to eq(true)

        it "fails when string does not contain substring":
            val matcher = include_string("foo")
            val result = matcher.matches("hello world")
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("include")

    context "String Matchers - start_with":
        it "matches when string starts with prefix":
            val matcher = start_with("hello")
            val result = matcher.matches("hello world")
            expect(result.is_success()).to eq(true)

        it "fails when string does not start with prefix":
            val matcher = start_with("world")
            val result = matcher.matches("hello world")
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("start with")

    context "String Matchers - end_with":
        it "matches when string ends with suffix":
            val matcher = end_with("world")
            val result = matcher.matches("hello world")
            expect(result.is_success()).to eq(true)

        it "fails when string does not end with suffix":
            val matcher = end_with("hello")
            val result = matcher.matches("hello world")
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("end with")

    context "String Matchers - be_blank":
        it "matches empty string":
            val matcher = be_blank()
            val result = matcher.matches("")
            expect(result.is_success()).to eq(true)

        it "matches whitespace-only string":
            val matcher = be_blank()
            val result = matcher.matches("   ")
            expect(result.is_success()).to eq(true)

        it "fails for non-blank string":
            val matcher = be_blank()
            val result = matcher.matches("hello")
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("blank")

    context "Type Matchers - be_option":
        it "matches Option type (Some)":
            val matcher = be_option()
            val result = matcher.matches(Some(42))
            expect(result.is_success()).to eq(true)

        it "matches Option type (None)":
            val matcher = be_option()
            val result = matcher.matches(None)
            expect(result.is_success()).to eq(true)

    context "Type Matchers - be_result":
        it "matches Result type (Ok)":
            val matcher = be_result()
            val result = matcher.matches(Ok(42))
            expect(result.is_success()).to eq(true)

        it "matches Result type (Err)":
            val matcher = be_result()
            val result = matcher.matches(Err("error"))
            expect(result.is_success()).to eq(true)

    context "Type Matchers - be_instance_of":
        it "creates a matcher for type checking":
            val matcher = be_instance_of("String")
            # Actual type checking depends on interpreter support
            # This test verifies the matcher can be created
            expect(matcher.type_name).to eq("type")

    context "Type Matchers - be_a and be_an":
        it "be_a is an alias for be_instance_of":
            val matcher = be_a("Array")
            expect(matcher.type_name).to eq("Array")

        it "be_an is an alias for be_instance_of":
            val matcher = be_an("Option")
            expect(matcher.type_name).to eq("Option")

    context "Error Matchers - raise_error":
        it "creates an error matcher with type":
            val matcher = raise_error(Some(ValueError), None)
            # Error matching depends on exception support
            # This verifies the matcher can be created
            expect(matcher.expected_type.is_some()).to eq(true)

        it "creates an error matcher with message":
            val matcher = raise_error(None, Some("error message"))
            expect(matcher.expected_message).to eq(Some("error message"))

        it "matches when error is provided":
            val matcher = raise_error(None, None)
            val error = Error { type: "TestError", message: "test" }
            val result = matcher.matches(Some(error))
            expect(result.is_success()).to eq(true)

        it "fails when no error is provided":
            val matcher = raise_error(None, None)
            val result = matcher.matches(None)
            expect(result.is_failure()).to eq(true)
            expect(result.failure_message).to include_string("Expected an error")
