# SSpec: Diagnostic Severity Levels
#
# Comprehensive behavioral specification for severity.spl
# Tests enum behavior, color codes, sorting, and parsing

import sspec
import std_lib.tooling.compiler.severity

Feature "Diagnostic Severity Levels":

    Scenario "Get severity name":
        Given "an Error severity"
        val error = Severity.Error
        When "getting the name"
        val name = error.name()
        Then "it should return 'error'"
        sspec.expect(name).to_equal("error")

    Scenario "Get severity color for Error":
        Given "an Error severity"
        val error = Severity.Error
        When "getting the color code"
        val color = error.color()
        Then "it should return bold red ANSI code"
        sspec.expect(color).to_equal("\x1b[1;31m")

    Scenario "Get severity color for Warning":
        Given "a Warning severity"
        val warning = Severity.Warning
        When "getting the color code"
        val color = warning.color()
        Then "it should return bold yellow ANSI code"
        sspec.expect(color).to_equal("\x1b[1;33m")

    Scenario "Get severity color for Note":
        Given "a Note severity"
        val note = Severity.Note
        When "getting the color code"
        val color = note.color()
        Then "it should return bold cyan ANSI code"
        sspec.expect(color).to_equal("\x1b[1;36m")

    Scenario "Get severity color for Help":
        Given "a Help severity"
        val help = Severity.Help
        When "getting the color code"
        val color = help.color()
        Then "it should return bold green ANSI code"
        sspec.expect(color).to_equal("\x1b[1;32m")

    Scenario "Get severity color for Info":
        Given "an Info severity"
        val info = Severity.Info
        When "getting the color code"
        val color = info.color()
        Then "it should return bold blue ANSI code"
        sspec.expect(color).to_equal("\x1b[1;34m")

    Scenario "Get reset color code":
        When "getting the reset color code"
        val reset = Severity.reset_color()
        Then "it should return ANSI reset code"
        sspec.expect(reset).to_equal("\x1b[0m")

    Scenario "Format colored severity":
        Given "a Warning severity"
        val warning = Severity.Warning
        When "formatting with color"
        val colored = warning.colored()
        Then "it should include color codes and name"
        sspec.expect(colored).to_equal("\x1b[1;33mwarning\x1b[0m")

    Scenario "Check if Error is an error":
        Given "an Error severity"
        val error = Severity.Error
        When "checking if it's an error"
        val result = error.is_error()
        Then "it should return true"
        sspec.expect(result).to_be_true()

    Scenario "Check if Warning is an error":
        Given "a Warning severity"
        val warning = Severity.Warning
        When "checking if it's an error"
        val result = warning.is_error()
        Then "it should return false"
        sspec.expect(result).to_be_false()

    Scenario "Check if Warning is a warning":
        Given "a Warning severity"
        val warning = Severity.Warning
        When "checking if it's a warning"
        val result = warning.is_warning()
        Then "it should return true"
        sspec.expect(result).to_be_true()

    Scenario "Check if Error blocks compilation":
        Given "an Error severity"
        val error = Severity.Error
        When "checking if it blocks compilation"
        val blocks = error.blocks_compilation()
        Then "it should return true"
        sspec.expect(blocks).to_be_true()

    Scenario "Check if Warning blocks compilation":
        Given "a Warning severity"
        val warning = Severity.Warning
        When "checking if it blocks compilation"
        val blocks = warning.blocks_compilation()
        Then "it should return false"
        sspec.expect(blocks).to_be_false()

    Scenario "Get severity order for Error":
        Given "an Error severity"
        val error = Severity.Error
        When "getting the order"
        val order = error.order()
        Then "it should return 0 (most severe)"
        sspec.expect(order).to_equal(0)

    Scenario "Get severity order for Warning":
        Given "a Warning severity"
        val warning = Severity.Warning
        When "getting the order"
        val order = warning.order()
        Then "it should return 1"
        sspec.expect(order).to_equal(1)

    Scenario "Get severity order for Info":
        Given "an Info severity"
        val info = Severity.Info
        When "getting the order"
        val order = info.order()
        Then "it should return 4 (least severe)"
        sspec.expect(order).to_equal(4)

    Scenario "Parse 'error' string to severity":
        Given "the string 'error'"
        val name = "error"
        When "parsing to severity"
        val result = Severity.from_name(name)
        Then "it should return Some(Error)"
        sspec.expect(result.is_some()).to_be_true()
        sspec.expect(result.unwrap().is_error()).to_be_true()

    Scenario "Parse 'warning' string to severity":
        Given "the string 'warning'"
        val name = "warning"
        When "parsing to severity"
        val result = Severity.from_name(name)
        Then "it should return Some(Warning)"
        sspec.expect(result.is_some()).to_be_true()
        sspec.expect(result.unwrap().is_warning()).to_be_true()

    Scenario "Parse invalid string to severity":
        Given "an invalid string 'invalid'"
        val name = "invalid"
        When "parsing to severity"
        val result = Severity.from_name(name)
        Then "it should return None"
        sspec.expect(result.is_none()).to_be_true()

    Scenario "Get all severity levels":
        When "getting all severity levels"
        val all = Severity.all()
        Then "it should return array of 5 severities in order"
        sspec.expect(all.length()).to_equal(5)
        sspec.expect(all[0].is_error()).to_be_true()
        sspec.expect(all[1].is_warning()).to_be_true()

    Scenario "Severity ordering for sorting":
        Given "multiple severities"
        val error = Severity.Error
        val warning = Severity.Warning
        val info = Severity.Info
        When "comparing their orders"
        Then "Error should come before Warning"
        sspec.expect(error.order() < warning.order()).to_be_true()
        And "Warning should come before Info"
        sspec.expect(warning.order() < info.order()).to_be_true()

    Scenario "All names are unique":
        When "getting all severity names"
        val all = Severity.all()
        val names = [for s in all: s.name()]
        Then "all names should be unique"
        sspec.expect(names.length()).to_equal(5)
        # Each name should appear exactly once
        sspec.expect(names.filter(\n: n == "error").length()).to_equal(1)
        sspec.expect(names.filter(\n: n == "warning").length()).to_equal(1)
        sspec.expect(names.filter(\n: n == "note").length()).to_equal(1)
        sspec.expect(names.filter(\n: n == "help").length()).to_equal(1)
        sspec.expect(names.filter(\n: n == "info").length()).to_equal(1)

    Scenario "Parse round-trip for all severities":
        Given "all severity levels"
        val all = Severity.all()
        When "converting to names and parsing back"
        Then "all should round-trip correctly"
        for severity in all:
            val name = severity.name()
            val parsed = Severity.from_name(name)
            sspec.expect(parsed.is_some()).to_be_true()
            sspec.expect(parsed.unwrap().name()).to_equal(name)
