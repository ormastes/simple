# SSpec: MIR Supporting Types
#
# Comprehensive tests for MIR enum types and utilities
# Tests all variants, predicates, and helper methods

import sspec
import std_lib.tooling.compiler.mir_types

Feature "ParallelBackend":

    Scenario "Get name of Cpu backend":
        Given "a Cpu backend"
        val backend = ParallelBackend.Cpu
        When "getting the name"
        val name = backend.name()
        Then "it should return 'cpu'"
        sspec.expect(name).to_equal("cpu")

    Scenario "Check if GPU is GPU backend":
        Given "a Gpu backend"
        val backend = ParallelBackend.Gpu
        When "checking if GPU"
        val is_gpu = backend.is_gpu()
        Then "it should return true"
        sspec.expect(is_gpu).to_be_true()

    Scenario "Check if Simd is CPU backend":
        Given "a Simd backend"
        val backend = ParallelBackend.Simd
        When "checking if CPU"
        val is_cpu = backend.is_cpu()
        Then "it should return true"
        sspec.expect(is_cpu).to_be_true()

Feature "ContractKind":

    Scenario "Get name of Precondition":
        Given "a Precondition contract"
        val kind = ContractKind.Precondition
        When "getting the name"
        val name = kind.name()
        Then "it should return 'precondition'"
        sspec.expect(name).to_equal("precondition")

    Scenario "Check if Precondition is precondition":
        Given "a Precondition contract"
        val kind = ContractKind.Precondition
        When "checking if precondition"
        val is_pre = kind.is_precondition()
        Then "it should return true"
        sspec.expect(is_pre).to_be_true()

    Scenario "Check if Postcondition is postcondition":
        Given "a Postcondition contract"
        val kind = ContractKind.Postcondition
        When "checking if postcondition"
        val is_post = kind.is_postcondition()
        Then "it should return true"
        sspec.expect(is_post).to_be_true()

    Scenario "Check if InvariantEntry is invariant":
        Given "an InvariantEntry contract"
        val kind = ContractKind.InvariantEntry
        When "checking if invariant"
        val is_inv = kind.is_invariant()
        Then "it should return true"
        sspec.expect(is_inv).to_be_true()

    Scenario "Check if Precondition is checked at entry":
        Given "a Precondition contract"
        val kind = ContractKind.Precondition
        When "checking if checked at entry"
        val at_entry = kind.checked_at_entry()
        Then "it should return true"
        sspec.expect(at_entry).to_be_true()

    Scenario "Check if Postcondition is checked at exit":
        Given "a Postcondition contract"
        val kind = ContractKind.Postcondition
        When "checking if checked at exit"
        val at_exit = kind.checked_at_exit()
        Then "it should return true"
        sspec.expect(at_exit).to_be_true()

Feature "UnitOverflowBehavior":

    Scenario "Get name of Saturate":
        Given "a Saturate behavior"
        val behavior = UnitOverflowBehavior.Saturate
        When "getting the name"
        val name = behavior.name()
        Then "it should return 'saturate'"
        sspec.expect(name).to_equal("saturate")

    Scenario "Check if Default is default":
        Given "a Default behavior"
        val behavior = UnitOverflowBehavior.Default
        When "checking if default"
        val is_def = behavior.is_default()
        Then "it should return true"
        sspec.expect(is_def).to_be_true()

    Scenario "Check if Checked is checked":
        Given "a Checked behavior"
        val behavior = UnitOverflowBehavior.Checked
        When "checking if checked"
        val is_checked = behavior.is_checked()
        Then "it should return true"
        sspec.expect(is_checked).to_be_true()

Feature "GpuMemoryScope":

    Scenario "Get name of WorkGroup":
        Given "a WorkGroup scope"
        val scope = GpuMemoryScope.WorkGroup
        When "getting the name"
        val name = scope.name()
        Then "it should return 'workgroup'"
        sspec.expect(name).to_equal("workgroup")

    Scenario "Check if All includes workgroup":
        Given "an All scope"
        val scope = GpuMemoryScope.All
        When "checking if includes workgroup"
        val includes = scope.includes_workgroup()
        Then "it should return true"
        sspec.expect(includes).to_be_true()

    Scenario "Check if Device includes device":
        Given "a Device scope"
        val scope = GpuMemoryScope.Device
        When "checking if includes device"
        val includes = scope.includes_device()
        Then "it should return true"
        sspec.expect(includes).to_be_true()

Feature "GpuAtomicOp":

    Scenario "Get name of Add":
        Given "an Add atomic op"
        val op = GpuAtomicOp.Add
        When "getting the name"
        val name = op.name()
        Then "it should return 'add'"
        sspec.expect(name).to_equal("add")

    Scenario "Check if Add is arithmetic":
        Given "an Add atomic op"
        val op = GpuAtomicOp.Add
        When "checking if arithmetic"
        val is_arith = op.is_arithmetic()
        Then "it should return true"
        sspec.expect(is_arith).to_be_true()

    Scenario "Check if Min is comparison":
        Given "a Min atomic op"
        val op = GpuAtomicOp.Min
        When "checking if comparison"
        val is_cmp = op.is_comparison()
        Then "it should return true"
        sspec.expect(is_cmp).to_be_true()

    Scenario "Check if And is bitwise":
        Given "an And atomic op"
        val op = GpuAtomicOp.And
        When "checking if bitwise"
        val is_bitwise = op.is_bitwise()
        Then "it should return true"
        sspec.expect(is_bitwise).to_be_true()

Feature "CaptureMode":

    Scenario "Get name of ByValue":
        Given "a ByValue capture mode"
        val mode = CaptureMode.ByValue
        When "getting the name"
        val name = mode.name()
        Then "it should return 'by_value'"
        sspec.expect(name).to_equal("by_value")

    Scenario "Check if ByValue is by value":
        Given "a ByValue capture mode"
        val mode = CaptureMode.ByValue
        When "checking if by value"
        val is_val = mode.is_by_value()
        Then "it should return true"
        sspec.expect(is_val).to_be_true()

    Scenario "Check if ByRef is reference":
        Given "a ByRef capture mode"
        val mode = CaptureMode.ByRef
        When "checking if reference"
        val is_ref = mode.is_reference()
        Then "it should return true"
        sspec.expect(is_ref).to_be_true()

    Scenario "Check if ByMutRef is mutable":
        Given "a ByMutRef capture mode"
        val mode = CaptureMode.ByMutRef
        When "checking if mutable"
        val is_mut = mode.is_mutable()
        Then "it should return true"
        sspec.expect(is_mut).to_be_true()

Feature "MirLiteral":

    Scenario "Get type name of Int":
        Given "an Int literal"
        val lit = MirLiteral.Int(42)
        When "getting type name"
        val type_name = lit.type_name()
        Then "it should return 'int'"
        sspec.expect(type_name).to_equal("int")

    Scenario "Check if Int is number":
        Given "an Int literal"
        val lit = MirLiteral.Int(42)
        When "checking if number"
        val is_num = lit.is_number()
        Then "it should return true"
        sspec.expect(is_num).to_be_true()

    Scenario "Check if Nil is nil":
        Given "a Nil literal"
        val lit = MirLiteral.Nil
        When "checking if nil"
        val is_nil = lit.is_nil()
        Then "it should return true"
        sspec.expect(is_nil).to_be_true()

    Scenario "Convert true Bool to bool":
        Given "a Bool(true) literal"
        val lit = MirLiteral.Bool(true)
        When "converting to bool"
        val b = lit.to_bool()
        Then "it should return true"
        sspec.expect(b).to_be_true()

    Scenario "Convert Nil to bool":
        Given "a Nil literal"
        val lit = MirLiteral.Nil
        When "converting to bool"
        val b = lit.to_bool()
        Then "it should return false"
        sspec.expect(b).to_be_false()

    Scenario "Convert Int(0) to bool":
        Given "an Int(0) literal"
        val lit = MirLiteral.Int(0)
        When "converting to bool"
        val b = lit.to_bool()
        Then "it should return false"
        sspec.expect(b).to_be_false()

    Scenario "Convert Int(42) to bool":
        Given "an Int(42) literal"
        val lit = MirLiteral.Int(42)
        When "converting to bool"
        val b = lit.to_bool()
        Then "it should return true"
        sspec.expect(b).to_be_true()

Feature "BindingStep":

    Scenario "Convert TupleIndex to string":
        Given "a TupleIndex(2)"
        val step = BindingStep.TupleIndex(2)
        When "converting to string"
        val s = step.to_string()
        Then "it should return '.2'"
        sspec.expect(s).to_equal(".2")

    Scenario "Convert FieldName to string":
        Given "a FieldName('x')"
        val step = BindingStep.FieldName("x")
        When "converting to string"
        val s = step.to_string()
        Then "it should return '.x'"
        sspec.expect(s).to_equal(".x")

    Scenario "Check if TupleIndex is tuple index":
        Given "a TupleIndex"
        val step = BindingStep.TupleIndex(0)
        When "checking if tuple index"
        val is_tuple = step.is_tuple_index()
        Then "it should return true"
        sspec.expect(is_tuple).to_be_true()

    Scenario "Check if FieldName is field":
        Given "a FieldName"
        val step = BindingStep.FieldName("field")
        When "checking if field"
        val is_field = step.is_field()
        Then "it should return true"
        sspec.expect(is_field).to_be_true()

Feature "PatternBinding":

    Scenario "Create new binding":
        Given "a binding name 'x'"
        val name = "x"
        When "creating new binding"
        val binding = PatternBinding.new(name)
        Then "it should have empty path"
        sspec.expect(binding.path.length()).to_equal(0)
        And "name should be 'x'"
        sspec.expect(binding.name).to_equal("x")

    Scenario "Add step to binding":
        Given "a binding"
        var binding = PatternBinding.new("x")
        When "adding a field step"
        binding.add_step(BindingStep.FieldName("y"))
        Then "path should have 1 step"
        sspec.expect(binding.path.length()).to_equal(1)

    Scenario "Get path string":
        Given "a binding with steps"
        var binding = PatternBinding.new("point")
        binding.add_step(BindingStep.FieldName("x"))
        binding.add_step(BindingStep.TupleIndex(0))
        When "getting path string"
        val path = binding.path_string()
        Then "it should be 'point.x.0'"
        sspec.expect(path).to_equal("point.x.0")

    Scenario "Get path depth":
        Given "a binding with 3 steps"
        var binding = PatternBinding.new("data")
        binding.add_step(BindingStep.FieldName("nested"))
        binding.add_step(BindingStep.FieldName("value"))
        binding.add_step(BindingStep.TupleIndex(1))
        When "getting depth"
        val depth = binding.depth()
        Then "it should be 3"
        sspec.expect(depth).to_equal(3)

Feature "FStringPart":

    Scenario "Check if Literal is literal":
        Given "a Literal part"
        val part = FStringPart.Literal("hello")
        When "checking if literal"
        val is_lit = part.is_literal()
        Then "it should return true"
        sspec.expect(is_lit).to_be_true()

    Scenario "Check if Expr is expression":
        Given "an Expr part"
        val part = FStringPart.Expr(5)
        When "checking if expression"
        val is_expr = part.is_expr()
        Then "it should return true"
        sspec.expect(is_expr).to_be_true()

    Scenario "Calculate total literal length":
        Given "an f-string with mixed parts"
        val parts = [
            FStringPart.Literal("Hello "),
            FStringPart.Expr(0),
            FStringPart.Literal(", you are "),
            FStringPart.Expr(1),
            FStringPart.Literal(" years old")
        ]
        When "calculating total literal length"
        val length = FStringPart.total_literal_length(parts)
        Then "it should be 27 (6 + 11 + 10)"
        sspec.expect(length).to_equal(27)

    Scenario "Count expressions in parts":
        Given "an f-string with mixed parts"
        val parts = [
            FStringPart.Literal("Result: "),
            FStringPart.Expr(0),
            FStringPart.Literal(" + "),
            FStringPart.Expr(1),
            FStringPart.Literal(" = "),
            FStringPart.Expr(2)
        ]
        When "counting expressions"
        val count = FStringPart.count_expressions(parts)
        Then "it should be 3"
        sspec.expect(count).to_equal(3)

    Scenario "Total literal length with no literals":
        Given "only expression parts"
        val parts = [FStringPart.Expr(0), FStringPart.Expr(1)]
        When "calculating literal length"
        val length = FStringPart.total_literal_length(parts)
        Then "it should be 0"
        sspec.expect(length).to_equal(0)

    Scenario "Count expressions with no expressions":
        Given "only literal parts"
        val parts = [FStringPart.Literal("hello"), FStringPart.Literal(" world")]
        When "counting expressions"
        val count = FStringPart.count_expressions(parts)
        Then "it should be 0"
        sspec.expect(count).to_equal(0)
