# SSpec: Symbol Hashing Utilities
#
# Comprehensive behavioral specification for symbol_hash.spl
# Tests hash computation, collision detection, and type tagging

import sspec
import std_lib.tooling.compiler.symbol_hash

Feature "Symbol Hashing":

    Scenario "Hash empty symbol":
        Given "an empty string"
        val symbol = ""
        When "hashing the symbol"
        val hash = hash_symbol(symbol)
        Then "it should have symbol type bit set"
        sspec.expect(is_symbol_hash(hash)).to_be_true()

    Scenario "Hash single character symbol":
        Given "a single character symbol 'a'"
        val symbol = "a"
        When "hashing the symbol"
        val hash = hash_symbol(symbol)
        Then "it should be non-zero and tagged"
        sspec.expect(hash != 0).to_be_true()
        sspec.expect(is_symbol_hash(hash)).to_be_true()

    Scenario "Hash multi-character symbol":
        Given "a multi-character symbol 'hello'"
        val symbol = "hello"
        When "hashing the symbol"
        val hash = hash_symbol(symbol)
        Then "it should be non-zero and tagged"
        sspec.expect(hash != 0).to_be_true()
        sspec.expect(is_symbol_hash(hash)).to_be_true()

    Scenario "Same symbol produces same hash":
        Given "two identical symbols"
        val s1 = "test"
        val s2 = "test"
        When "hashing both symbols"
        val h1 = hash_symbol(s1)
        val h2 = hash_symbol(s2)
        Then "they should produce the same hash"
        sspec.expect(h1).to_equal(h2)

    Scenario "Different symbols produce different hashes":
        Given "two different symbols"
        val s1 = "foo"
        val s2 = "bar"
        When "hashing both symbols"
        val h1 = hash_symbol(s1)
        val h2 = hash_symbol(s2)
        Then "they should produce different hashes"
        sspec.expect(h1 != h2).to_be_true()

    Scenario "Check symbol type bit":
        Given "a hashed symbol"
        val hash = hash_symbol("test")
        When "checking the type bit"
        val has_type_bit = is_symbol_hash(hash)
        Then "it should return true"
        sspec.expect(has_type_bit).to_be_true()

    Scenario "Check non-symbol hash":
        Given "a regular integer without type tag"
        val hash: i64 = 12345
        When "checking if it's a symbol hash"
        val is_symbol = is_symbol_hash(hash)
        Then "it should return false"
        sspec.expect(is_symbol).to_be_false()

    Scenario "Untag symbol hash":
        Given "a tagged symbol hash"
        val symbol = "example"
        val tagged = hash_symbol(symbol)
        When "removing the tag"
        val untagged = untag_symbol_hash(tagged)
        Then "the type bit should be removed"
        sspec.expect(is_symbol_hash(untagged)).to_be_false()
        And "it should equal the raw hash"
        val raw = get_raw_hash(symbol)
        sspec.expect(untagged).to_equal(raw)

    Scenario "Get raw hash matches untagged hash":
        Given "a symbol"
        val symbol = "test_symbol"
        When "computing raw hash and untagging hashed symbol"
        val raw = get_raw_hash(symbol)
        val untagged = untag_symbol_hash(hash_symbol(symbol))
        Then "they should be equal"
        sspec.expect(raw).to_equal(untagged)

    Scenario "Hash multiple symbols":
        Given "an array of symbols"
        val symbols = ["foo", "bar", "baz"]
        When "hashing all symbols"
        val hashes = hash_symbols(symbols)
        Then "it should return array of same length"
        sspec.expect(hashes.length()).to_equal(3)
        And "all hashes should be tagged"
        for h in hashes:
            sspec.expect(is_symbol_hash(h)).to_be_true()

    Scenario "Detect no collision for different symbols":
        Given "two different symbols"
        val s1 = "apple"
        val s2 = "orange"
        When "checking for collision"
        val collision = has_collision(s1, s2)
        Then "it should return false"
        sspec.expect(collision).to_be_false()

    Scenario "Detect no collision for same symbol":
        Given "the same symbol twice"
        val s1 = "banana"
        val s2 = "banana"
        When "checking for collision"
        val collision = has_collision(s1, s2)
        Then "it should return false (same string, not a collision)"
        sspec.expect(collision).to_be_false()

    Scenario "Polynomial hash is deterministic":
        Given "a symbol"
        val symbol = "deterministic"
        When "computing poly hash multiple times"
        val h1 = poly_hash(symbol)
        val h2 = poly_hash(symbol)
        val h3 = poly_hash(symbol)
        Then "all should be equal"
        sspec.expect(h1).to_equal(h2)
        sspec.expect(h2).to_equal(h3)

    Scenario "Empty string has zero raw hash":
        Given "an empty string"
        val symbol = ""
        When "computing raw hash"
        val hash = poly_hash(symbol)
        Then "it should be zero"
        sspec.expect(hash).to_equal(0)

    Scenario "Hash includes all characters":
        Given "symbols differing in one position"
        val s1 = "test1"
        val s2 = "test2"
        When "hashing both"
        val h1 = hash_symbol(s1)
        val h2 = hash_symbol(s2)
        Then "they should have different hashes"
        sspec.expect(h1 != h2).to_be_true()

    Scenario "Hash is order-dependent":
        Given "symbols with same characters in different order"
        val s1 = "abc"
        val s2 = "bca"
        When "hashing both"
        val h1 = hash_symbol(s1)
        val h2 = hash_symbol(s2)
        Then "they should have different hashes"
        sspec.expect(h1 != h2).to_be_true()

    Scenario "Check all symbols unique":
        Given "an array of unique symbols"
        val symbols = ["alpha", "beta", "gamma", "delta"]
        When "checking if all hashes are unique"
        val all_unique = all_unique_hashes(symbols)
        Then "it should return true"
        sspec.expect(all_unique).to_be_true()

    Scenario "Detect duplicate hashes":
        Given "an array with duplicate symbols"
        val symbols = ["alpha", "beta", "alpha"]
        When "checking if all hashes are unique"
        val all_unique = all_unique_hashes(symbols)
        Then "it should return false"
        sspec.expect(all_unique).to_be_false()

    Scenario "Tagging and untagging round-trip":
        Given "a raw hash value"
        val symbol = "roundtrip"
        val raw = get_raw_hash(symbol)
        When "tagging then untagging"
        val tagged = raw | SYMBOL_TYPE_BIT
        val untagged = untag_symbol_hash(tagged)
        Then "it should return the original value"
        sspec.expect(untagged).to_equal(raw)

    Scenario "Symbol type bit position":
        Given "the symbol type bit constant"
        val bit = SYMBOL_TYPE_BIT
        When "checking the bit value"
        Then "it should equal 2^62"
        sspec.expect(bit).to_equal(4611686018427387904)

    Scenario "Hash base is 31":
        Given "the hash base constant"
        val base = HASH_BASE
        When "checking the value"
        Then "it should equal 31"
        sspec.expect(base).to_equal(31)

    Scenario "Collision probability increases with more symbols":
        Given "different numbers of symbols"
        val p10 = collision_probability(10)
        val p100 = collision_probability(100)
        val p1000 = collision_probability(1000)
        When "comparing probabilities"
        Then "probability should increase with more symbols"
        sspec.expect(p100 > p10).to_be_true()
        sspec.expect(p1000 > p100).to_be_true()

    Scenario "Collision probability is very small for few symbols":
        Given "a small number of symbols"
        val n = 100
        When "computing collision probability"
        val prob = collision_probability(n)
        Then "it should be extremely small (< 0.0001)"
        sspec.expect(prob < 0.0001).to_be_true()

    Scenario "Hash distribution for common symbols":
        Given "an array of common symbols"
        val symbols = ["if", "else", "while", "for", "match", "fn"]
        When "computing hash distribution"
        val dist = hash_distribution(symbols)
        Then "each symbol should have count of 1"
        sspec.expect(dist.size()).to_equal(6)

    Scenario "Hash wrapping arithmetic":
        Given "a very long symbol that would overflow"
        val symbol = "a" * 100  # 100 'a' characters
        When "hashing the symbol"
        val hash = hash_symbol(symbol)
        Then "it should not panic and produce a valid hash"
        sspec.expect(is_symbol_hash(hash)).to_be_true()
