# SSpec: Lean Auto-Generation (Phase 7)
#
# Tests for auto-generation of Lean scaffolding:
# - Structure generation from Simple classes
# - Lookup function generation for registries
# - BEq instance generation for inductives
# - Theorem generation (determinism, reflexivity)
#
# Key principle: No sorry or axiom in generated code

import sspec
import verification.lean.structure_gen as structure_gen
import verification.lean.lookup_gen as lookup_gen
import verification.lean.instantiation_gen as instantiation_gen
import verification.lean.beq_gen as beq_gen
import verification.lean.theorem_gen as theorem_gen
import verification.lean.auto_gen as auto_gen

Feature "AutoLeanMode - mode predicates":

    Scenario "Full mode generates structures":
        Given "Full auto-lean mode"
        val mode = structure_gen.AutoLeanMode.Full
        When "checking generates_structures"
        val result = mode.generates_structures()
        Then "it should return true"
        sspec.expect(result).to_be_true()

    Scenario "Full mode generates lookups":
        Given "Full auto-lean mode"
        val mode = structure_gen.AutoLeanMode.Full
        When "checking generates_lookups"
        val result = mode.generates_lookups()
        Then "it should return true"
        sspec.expect(result).to_be_true()

    Scenario "StructureOnly mode generates structures only":
        Given "StructureOnly auto-lean mode"
        val mode = structure_gen.AutoLeanMode.StructureOnly
        When "checking generates_structures"
        val structs = mode.generates_structures()
        And "checking generates_lookups"
        val lookups = mode.generates_lookups()
        Then "it should generate structures"
        sspec.expect(structs).to_be_true()
        And "it should not generate lookups"
        sspec.expect(lookups).to_be_false()

    Scenario "Skip mode generates nothing":
        Given "Skip auto-lean mode"
        val mode = structure_gen.AutoLeanMode.Skip
        When "checking all generation flags"
        val structs = mode.generates_structures()
        val lookups = mode.generates_lookups()
        val beq = mode.generates_beq()
        Then "all should return false"
        sspec.expect(structs).to_be_false()
        sspec.expect(lookups).to_be_false()
        sspec.expect(beq).to_be_false()

Feature "StructureGenerator - simple class":

    Scenario "Generate structure from class with fields":
        Given "a SimpleClassDef with two fields"
        var class_def = structure_gen.SimpleClassDef.new("TraitDef")
        val name_field = structure_gen.SimpleFieldDef.new("name", "text")
        val methods_field = structure_gen.SimpleFieldDef.new("methods", "TraitMethod")
                .with_list()
        class_def = class_def.add_field(name_field)
        class_def = class_def.add_field(methods_field)

        When "generating structure"
        var gen = structure_gen.StructureGenerator.new()
        val output = gen.generate_structure(class_def)

        Then "output should contain structure keyword"
        sspec.expect(output.contains("structure TraitDef")).to_be_true()
        And "output should contain name field"
        sspec.expect(output.contains("name : String")).to_be_true()
        And "output should contain methods field as List"
        sspec.expect(output.contains("methods : List TraitMethod")).to_be_true()
        And "output should have deriving clause"
        sspec.expect(output.contains("deriving")).to_be_true()

    Scenario "Generate structure with Skip mode":
        Given "a SimpleClassDef with Skip mode"
        var class_def = structure_gen.SimpleClassDef.new("Internal")
        class_def = class_def.with_mode(structure_gen.AutoLeanMode.Skip)

        When "generating structure"
        var gen = structure_gen.StructureGenerator.new()
        val output = gen.generate_structure(class_def)

        Then "output should be empty"
        sspec.expect(output.len()).to_equal(0)

Feature "StructureGenerator - enum/inductive":

    Scenario "Generate inductive from simple enum":
        Given "a SimpleEnumDef with unit variants"
        var enum_def = structure_gen.SimpleEnumDef.new("Effect")
        enum_def = enum_def.add_variant(structure_gen.SimpleEnumVariant.unit("Pure"))
        enum_def = enum_def.add_variant(structure_gen.SimpleEnumVariant.unit("Io"))
        enum_def = enum_def.add_variant(structure_gen.SimpleEnumVariant.unit("Async"))

        When "generating inductive"
        var gen = structure_gen.StructureGenerator.new()
        val output = gen.generate_inductive(enum_def)

        Then "output should contain inductive keyword"
        sspec.expect(output.contains("inductive Effect")).to_be_true()
        And "output should contain all variants"
        sspec.expect(output.contains("| pure")).to_be_true()
        sspec.expect(output.contains("| io")).to_be_true()
        sspec.expect(output.contains("| async")).to_be_true()

    Scenario "Generate inductive with parameterized variants":
        Given "a SimpleEnumDef with parameterized variants"
        var enum_def = structure_gen.SimpleEnumDef.new("Ty")
        enum_def = enum_def.add_variant(structure_gen.SimpleEnumVariant.unit("Int"))
        var named_variant = structure_gen.SimpleEnumVariant.new("Named")
        named_variant = named_variant.add_param("name", "text")
        enum_def = enum_def.add_variant(named_variant)

        When "generating inductive"
        var gen = structure_gen.StructureGenerator.new()
        val output = gen.generate_inductive(enum_def)

        Then "output should contain Int variant without arrow"
        sspec.expect(output.contains("| int")).to_be_true()
        And "output should contain Named variant with arrow"
        sspec.expect(output.contains("| named : String -> Ty")).to_be_true()

Feature "LookupGenerator - environment types":

    Scenario "Generate environment type alias":
        Given "a RegistryDef for Trait"
        val registry = lookup_gen.RegistryDef.new("Trait")

        When "generating env type"
        var gen = lookup_gen.LookupGenerator.new()
        val output = gen.generate_env_type(registry)

        Then "output should define TraitEnv"
        sspec.expect(output.contains("def TraitEnv")).to_be_true()
        And "output should use List pair type"
        sspec.expect(output.contains("List (String x TraitDef)")).to_be_true()

    Scenario "Generate lookup function":
        Given "a RegistryDef for Class"
        val registry = lookup_gen.RegistryDef.new("Class")

        When "generating lookup"
        var gen = lookup_gen.LookupGenerator.new()
        val output = gen.generate_lookup(registry)

        Then "output should define lookupClass"
        sspec.expect(output.contains("def lookupClass")).to_be_true()
        And "output should return Option ClassDef"
        sspec.expect(output.contains("Option ClassDef")).to_be_true()
        And "output should use find?"
        sspec.expect(output.contains("find?")).to_be_true()

    Scenario "Generate contains function":
        Given "a RegistryDef for Impl"
        val registry = lookup_gen.RegistryDef.new("Impl")

        When "generating contains"
        var gen = lookup_gen.LookupGenerator.new()
        val output = gen.generate_contains(registry)

        Then "output should define containsImpl"
        sspec.expect(output.contains("def containsImpl")).to_be_true()
        And "output should return Bool"
        sspec.expect(output.contains(": Bool")).to_be_true()
        And "output should use isSome"
        sspec.expect(output.contains("isSome")).to_be_true()

Feature "BeqGenerator - BEq instances":

    Scenario "Generate BEq for simple enum":
        Given "a BeqTypeDef with unit variants"
        var def = beq_gen.BeqTypeDef.new("Effect")
        def = def.add_variant(beq_gen.BeqVariant.new("Pure", []))
        def = def.add_variant(beq_gen.BeqVariant.new("Io", []))

        When "generating BEq function"
        var gen = beq_gen.BeqGenerator.new()
        val output = gen.generate_beq_function(def)

        Then "output should define Effect.beq"
        sspec.expect(output.contains("def Effect.beq")).to_be_true()
        And "output should have matching cases"
        sspec.expect(output.contains(".pure, .pure => true")).to_be_true()
        sspec.expect(output.contains(".io, .io => true")).to_be_true()
        And "output should have default false case"
        sspec.expect(output.contains("_, _ => false")).to_be_true()

    Scenario "Generate BEq instance":
        Given "a BeqTypeDef"
        val def = beq_gen.BeqTypeDef.new("DispatchMode")

        When "generating BEq instance"
        var gen = beq_gen.BeqGenerator.new()
        val output = gen.generate_beq_instance(def)

        Then "output should have instance declaration"
        sspec.expect(output.contains("instance : BEq DispatchMode")).to_be_true()
        And "output should use generated beq"
        sspec.expect(output.contains("beq := DispatchMode.beq")).to_be_true()

Feature "BeqGenerator - reflexivity proofs":

    Scenario "Generate reflexivity for simple enum":
        Given "a BeqTypeDef with unit variants"
        var def = beq_gen.BeqTypeDef.new("Effect")
        def = def.add_variant(beq_gen.BeqVariant.new("Pure", []))
        def = def.add_variant(beq_gen.BeqVariant.new("Io", []))

        When "generating reflexivity proof"
        var gen = beq_gen.BeqGenerator.new()
        val output = gen.generate_reflexivity_proof(def)

        Then "output should be a theorem"
        sspec.expect(output.contains("theorem effect_beq_refl")).to_be_true()
        And "output should state (e == e) = true"
        sspec.expect(output.contains("(effect == effect) = true")).to_be_true()
        And "output should use cases tactic"
        sspec.expect(output.contains("cases")).to_be_true()
        And "output should use rfl"
        sspec.expect(output.contains("rfl")).to_be_true()

    Scenario "Reflexivity proof has no sorry":
        Given "any BeqTypeDef"
        var def = beq_gen.BeqTypeDef.new("TestType")
        def = def.add_variant(beq_gen.BeqVariant.new("A", []))

        When "generating reflexivity proof"
        var gen = beq_gen.BeqGenerator.new()
        val output = gen.generate_reflexivity_proof(def)

        Then "output should not contain sorry"
        sspec.expect(output.contains("sorry")).to_be_false()
        And "output should not contain axiom"
        sspec.expect(output.contains("axiom")).to_be_false()

Feature "TheoremGenerator - determinism theorems":

    Scenario "Generate determinism theorem":
        Given "a function returning Option"
        var func = theorem_gen.FunctionDef.new("lookupTrait")
        func = func.add_param(theorem_gen.TheoremParam.explicit("env", "TraitEnv"))
        func = func.add_param(theorem_gen.TheoremParam.explicit("name", "String"))
        func = func.with_option_return("TraitDef")

        When "generating determinism theorem"
        var gen = theorem_gen.TheoremGenerator.new()
        val output = gen.generate_determinism(func)

        Then "output should be a theorem"
        sspec.expect(output.contains("theorem lookupTrait_deterministic")).to_be_true()
        And "output should have r1 r2 result params"
        sspec.expect(output.contains("r1 r2 : TraitDef")).to_be_true()
        And "output should have = some premises"
        sspec.expect(output.contains("= some r1")).to_be_true()
        sspec.expect(output.contains("= some r2")).to_be_true()
        And "output should conclude r1 = r2"
        sspec.expect(output.contains("r1 = r2")).to_be_true()

    Scenario "Determinism proof has no sorry":
        Given "a function returning Option"
        var func = theorem_gen.FunctionDef.new("findImpl")
        func = func.with_option_return("ImplDef")

        When "generating determinism theorem"
        var gen = theorem_gen.TheoremGenerator.new()
        val output = gen.generate_determinism(func)

        Then "output should not contain sorry"
        sspec.expect(output.contains("sorry")).to_be_false()
        And "proof should use intro h1 h2"
        sspec.expect(output.contains("intro h1 h2")).to_be_true()
        And "proof should use rw"
        sspec.expect(output.contains("rw")).to_be_true()

Feature "TheoremGenerator - lookup empty theorems":

    Scenario "Generate lookup empty theorem":
        Given "a type name"
        val type_name = "Trait"

        When "generating lookup empty theorem"
        var gen = theorem_gen.TheoremGenerator.new()
        val output = gen.generate_lookup_empty(type_name)

        Then "output should be a theorem"
        sspec.expect(output.contains("theorem lookupTrait_empty")).to_be_true()
        And "output should use empty list"
        sspec.expect(output.contains("lookupTrait []")).to_be_true()
        And "output should conclude none"
        sspec.expect(output.contains("= none")).to_be_true()
        And "proof should be rfl"
        sspec.expect(output.contains("rfl")).to_be_true()

Feature "AutoGenBuilder - integration":

    Scenario "Build and generate complete scaffolding":
        Given "an AutoGenBuilder with classes and enums"
        var builder = auto_gen.AutoGenBuilder.new("build/test_lean", "TestModule")
        builder = builder.add_class("TraitDef", [
            ("name", "text"),
            ("type_params", "TyVar")
        ])
        builder = builder.add_enum("Effect", [
            ("Pure", []),
            ("Io", []),
            ("Async", [])
        ])

        When "generating all files"
        val files = builder.generate()

        Then "it should generate 4 files"
        sspec.expect(files.len()).to_equal(4)

    Scenario "Generated files have correct names":
        Given "an AutoGenBuilder"
        var builder = auto_gen.AutoGenBuilder.new("build/test_lean", "TestModule")
        builder = builder.add_class("Simple", [("x", "i32")])

        When "generating all files"
        val files = builder.generate()

        Then "first file should be Generated_Types.lean"
        val (name1, _) = files[0]
        sspec.expect(name1).to_equal("Generated_Types.lean")

    Scenario "Generated types file has no sorry":
        Given "an AutoGenBuilder with a class"
        var builder = auto_gen.AutoGenBuilder.new("build/test_lean", "TestModule")
        builder = builder.add_class("Point", [("x", "i32"), ("y", "i32")])

        When "generating files"
        val files = builder.generate()

        Then "types file should not contain sorry"
        val (_, content) = files[0]
        sspec.expect(content.contains("sorry")).to_be_false()
        And "types file should not contain axiom"
        sspec.expect(content.contains("axiom")).to_be_false()

Feature "Type translation":

    Scenario "Translate i32 to Int":
        Given "type name i32"
        val type_name = "i32"

        When "translating to Lean"
        val lean_type = structure_gen.translate_type_to_lean(type_name, false, false)

        Then "it should be Int"
        sspec.expect(lean_type).to_equal("Int")

    Scenario "Translate text to String":
        Given "type name text"
        val type_name = "text"

        When "translating to Lean"
        val lean_type = structure_gen.translate_type_to_lean(type_name, false, false)

        Then "it should be String"
        sspec.expect(lean_type).to_equal("String")

    Scenario "Translate optional type":
        Given "type name with optional flag"
        val type_name = "Ty"

        When "translating with is_optional=true"
        val lean_type = structure_gen.translate_type_to_lean(type_name, true, false)

        Then "it should be Option (Ty)"
        sspec.expect(lean_type).to_equal("Option (Ty)")

    Scenario "Translate list type":
        Given "type name with list flag"
        val type_name = "FieldDef"

        When "translating with is_list=true"
        val lean_type = structure_gen.translate_type_to_lean(type_name, false, true)

        Then "it should be List FieldDef"
        sspec.expect(lean_type).to_equal("List FieldDef")

    Scenario "Translate optional list type":
        Given "type name with both flags"
        val type_name = "Method"

        When "translating with both flags"
        val lean_type = structure_gen.translate_type_to_lean(type_name, true, true)

        Then "it should be Option (List Method)"
        sspec.expect(lean_type).to_equal("Option (List Method)")

Feature "Convenience functions":

    Scenario "generate_structure_from_fields convenience":
        Given "field specifications"
        val fields = [("name", "text"), ("age", "i32")]

        When "using generate_structure_from_fields"
        val output = structure_gen.generate_structure_from_fields("Person", fields)

        Then "output should contain structure Person"
        sspec.expect(output.contains("structure Person")).to_be_true()
        And "output should contain both fields"
        sspec.expect(output.contains("name : String")).to_be_true()
        sspec.expect(output.contains("age : Int")).to_be_true()

    Scenario "generate_standard_lookups convenience":
        Given "a type name"
        val type_name = "User"

        When "using generate_standard_lookups"
        val output = lookup_gen.generate_standard_lookups(type_name)

        Then "output should contain UserEnv"
        sspec.expect(output.contains("def UserEnv")).to_be_true()
        And "output should contain lookupUser"
        sspec.expect(output.contains("def lookupUser")).to_be_true()
        And "output should contain containsUser"
        sspec.expect(output.contains("def containsUser")).to_be_true()

    Scenario "generate_determinism_theorem convenience":
        Given "function signature"
        val params = [("env", "Env"), ("key", "String")]

        When "using generate_determinism_theorem"
        val output = theorem_gen.generate_determinism_theorem("lookup", params, "Value")

        Then "output should be a valid theorem"
        sspec.expect(output.contains("theorem lookup_deterministic")).to_be_true()
        And "output should have no sorry"
        sspec.expect(output.contains("sorry")).to_be_false()

Feature "Generated code is Lean-syntax compliant":

    Scenario "Structure uses 'where' syntax":
        Given "a class definition"
        var class_def = structure_gen.SimpleClassDef.new("Config")
        class_def = class_def.add_field(structure_gen.SimpleFieldDef.new("debug", "bool"))

        When "generating"
        var gen = structure_gen.StructureGenerator.new()
        val output = gen.generate_structure(class_def)

        Then "output should use where keyword"
        sspec.expect(output.contains("where")).to_be_true()

    Scenario "Inductive uses pipe syntax":
        Given "an enum definition"
        var enum_def = structure_gen.SimpleEnumDef.new("Color")
        enum_def = enum_def.add_variant(structure_gen.SimpleEnumVariant.unit("Red"))
        enum_def = enum_def.add_variant(structure_gen.SimpleEnumVariant.unit("Green"))

        When "generating"
        var gen = structure_gen.StructureGenerator.new()
        val output = gen.generate_inductive(enum_def)

        Then "output should use pipe syntax"
        sspec.expect(output.contains("| red")).to_be_true()
        sspec.expect(output.contains("| green")).to_be_true()

    Scenario "Theorem uses := by syntax":
        Given "a function definition"
        var func = theorem_gen.FunctionDef.new("get")
        func = func.with_option_return("Item")

        When "generating determinism"
        var gen = theorem_gen.TheoremGenerator.new()
        val output = gen.generate_determinism(func)

        Then "output should use := by syntax"
        sspec.expect(output.contains(":= by")).to_be_true()
