# SSpec: Symbol Analysis Types
#
# Comprehensive behavioral specification for symbol_analysis.spl
# Tests symbol visibility, reference tracking, and analysis statistics

import sspec
import std_lib.tooling.compiler.symbol_analysis

Feature "Reference Kind":

    Scenario "Get name of Call reference":
        Given "a Call reference kind"
        val kind = RefKind.Call
        When "getting the name"
        val name = kind.name()
        Then "it should return 'call'"
        sspec.expect(name).to_equal("call")

    Scenario "Check if Call is code reference":
        Given "a Call reference kind"
        val kind = RefKind.Call
        When "checking if it's a code reference"
        val is_code = kind.is_code_reference()
        Then "it should return true"
        sspec.expect(is_code).to_be_true()

    Scenario "Check if Data is data reference":
        Given "a Data reference kind"
        val kind = RefKind.Data
        When "checking if it's a data reference"
        val is_data = kind.is_data_reference()
        Then "it should return true"
        sspec.expect(is_data).to_be_true()

    Scenario "Check if Call is data reference":
        Given "a Call reference kind"
        val kind = RefKind.Call
        When "checking if it's a data reference"
        val is_data = kind.is_data_reference()
        Then "it should return false"
        sspec.expect(is_data).to_be_false()

Feature "Symbol Visibility":

    Scenario "Get name of Export visibility":
        Given "an Export visibility"
        val vis = SymbolVisibility.Export
        When "getting the name"
        val name = vis.name()
        Then "it should return 'export'"
        sspec.expect(name).to_equal("export")

    Scenario "Check if Export is external":
        Given "an Export visibility"
        val vis = SymbolVisibility.Export
        When "checking if it's external"
        val is_ext = vis.is_external()
        Then "it should return true"
        sspec.expect(is_ext).to_be_true()

    Scenario "Check if Local is external":
        Given "a Local visibility"
        val vis = SymbolVisibility.Local
        When "checking if it's external"
        val is_ext = vis.is_external()
        Then "it should return false"
        sspec.expect(is_ext).to_be_false()

    Scenario "Check if Local is internal":
        Given "a Local visibility"
        val vis = SymbolVisibility.Local
        When "checking if it's internal"
        val is_int = vis.is_internal()
        Then "it should return true"
        sspec.expect(is_int).to_be_true()

    Scenario "Visibility ordering":
        Given "different visibility levels"
        val export = SymbolVisibility.Export
        val import = SymbolVisibility.Import
        val local = SymbolVisibility.Local
        When "comparing their orders"
        Then "Export should come first"
        sspec.expect(export.order() < import.order()).to_be_true()
        sspec.expect(import.order() < local.order()).to_be_true()

Feature "Analyzed Symbol Creation":

    Scenario "Create new exported symbol":
        Given "a symbol name and Export visibility"
        val name = "my_function"
        val vis = SymbolVisibility.Export
        When "creating a new analyzed symbol"
        val sym = AnalyzedSymbol.new(name, vis)
        Then "it should have correct properties"
        sspec.expect(sym.name).to_equal(name)
        sspec.expect(sym.is_exported()).to_be_true()
        sspec.expect(sym.size).to_equal(0)
        sspec.expect(sym.reference_count()).to_equal(0)
        sspec.expect(sym.is_reachable).to_be_false()
        sspec.expect(sym.section).to_equal(".text")

    Scenario "Create new local symbol":
        Given "a symbol name and Local visibility"
        val name = "helper"
        val vis = SymbolVisibility.Local
        When "creating a new analyzed symbol"
        val sym = AnalyzedSymbol.new(name, vis)
        Then "it should be local"
        sspec.expect(sym.is_local()).to_be_true()
        sspec.expect(sym.is_exported()).to_be_false()

Feature "Symbol Reference Tracking":

    Scenario "Add reference to symbol":
        Given "a symbol"
        var sym = AnalyzedSymbol.new("main", SymbolVisibility.Export)
        When "adding a call reference"
        sym.add_reference("helper", RefKind.Call)
        Then "it should track the reference"
        sspec.expect(sym.reference_count()).to_equal(1)
        sspec.expect(sym.references_symbol("helper")).to_be_true()

    Scenario "Add multiple references":
        Given "a symbol"
        var sym = AnalyzedSymbol.new("main", SymbolVisibility.Export)
        When "adding multiple references"
        sym.add_reference("foo", RefKind.Call)
        sym.add_reference("bar", RefKind.Data)
        sym.add_reference("baz", RefKind.Type)
        Then "it should track all references"
        sspec.expect(sym.reference_count()).to_equal(3)
        sspec.expect(sym.references_symbol("foo")).to_be_true()
        sspec.expect(sym.references_symbol("bar")).to_be_true()
        sspec.expect(sym.references_symbol("baz")).to_be_true()

    Scenario "Get reference kind":
        Given "a symbol with references"
        var sym = AnalyzedSymbol.new("main", SymbolVisibility.Export)
        sym.add_reference("helper", RefKind.Call)
        When "getting reference kind"
        val kind = sym.get_ref_kind("helper")
        Then "it should return the correct kind"
        sspec.expect(kind.is_some()).to_be_true()
        sspec.expect(kind.unwrap().is_code_reference()).to_be_true()

    Scenario "Get reference kind for non-existent symbol":
        Given "a symbol with no references"
        val sym = AnalyzedSymbol.new("main", SymbolVisibility.Export)
        When "getting reference kind for unknown symbol"
        val kind = sym.get_ref_kind("unknown")
        Then "it should return None"
        sspec.expect(kind.is_none()).to_be_true()

Feature "Symbol Reference Analysis":

    Scenario "Check for code references":
        Given "a symbol with call reference"
        var sym = AnalyzedSymbol.new("main", SymbolVisibility.Export)
        sym.add_reference("helper", RefKind.Call)
        When "checking for code references"
        val has_code = sym.has_code_references()
        Then "it should return true"
        sspec.expect(has_code).to_be_true()

    Scenario "Check for data references":
        Given "a symbol with data reference"
        var sym = AnalyzedSymbol.new("main", SymbolVisibility.Export)
        sym.add_reference("global_var", RefKind.Data)
        When "checking for data references"
        val has_data = sym.has_data_references()
        Then "it should return true"
        sspec.expect(has_data).to_be_true()

    Scenario "No code references":
        Given "a symbol with only data references"
        var sym = AnalyzedSymbol.new("main", SymbolVisibility.Export)
        sym.add_reference("data", RefKind.Data)
        When "checking for code references"
        val has_code = sym.has_code_references()
        Then "it should return false"
        sspec.expect(has_code).to_be_false()

Feature "Symbol Section Analysis":

    Scenario "Symbol in text section":
        Given "a new symbol"
        val sym = AnalyzedSymbol.new("func", SymbolVisibility.Export)
        When "checking if in text section"
        val in_text = sym.in_text_section()
        Then "it should return true (default section)"
        sspec.expect(in_text).to_be_true()

    Scenario "Check specific section":
        Given "a symbol"
        var sym = AnalyzedSymbol.new("data", SymbolVisibility.Export)
        sym.section = ".data"
        When "checking if in data section"
        val in_data = sym.in_data_section()
        Then "it should return true"
        sspec.expect(in_data).to_be_true()

Feature "Symbol Visibility Predicates":

    Scenario "Check exported symbol":
        Given "an exported symbol"
        val sym = AnalyzedSymbol.new("public_fn", SymbolVisibility.Export)
        When "checking visibility"
        Then "it should be exported"
        sspec.expect(sym.is_exported()).to_be_true()
        sspec.expect(sym.is_imported()).to_be_false()
        sspec.expect(sym.is_local()).to_be_false()
        sspec.expect(sym.is_hidden()).to_be_false()

    Scenario "Check imported symbol":
        Given "an imported symbol"
        val sym = AnalyzedSymbol.new("extern_fn", SymbolVisibility.Import)
        When "checking visibility"
        Then "it should be imported"
        sspec.expect(sym.is_imported()).to_be_true()
        sspec.expect(sym.is_exported()).to_be_false()

    Scenario "Check hidden symbol":
        Given "a hidden symbol"
        val sym = AnalyzedSymbol.new("internal", SymbolVisibility.Hidden)
        When "checking visibility"
        Then "it should be hidden"
        sspec.expect(sym.is_hidden()).to_be_true()
        sspec.expect(sym.is_local()).to_be_false()

Feature "Symbol Analysis Statistics":

    Scenario "Create empty statistics":
        When "creating new statistics"
        val stats = SymbolAnalysisStats.new()
        Then "all counts should be zero"
        sspec.expect(stats.total_symbols).to_equal(0)
        sspec.expect(stats.exported_symbols).to_equal(0)
        sspec.expect(stats.imported_symbols).to_equal(0)
        sspec.expect(stats.local_symbols).to_equal(0)

    Scenario "Compute statistics from symbols":
        Given "a list of symbols"
        val symbols = [
            AnalyzedSymbol.new("pub1", SymbolVisibility.Export),
            AnalyzedSymbol.new("pub2", SymbolVisibility.Export),
            AnalyzedSymbol.new("priv1", SymbolVisibility.Local),
            AnalyzedSymbol.new("ext1", SymbolVisibility.Import)
        ]
        When "computing statistics"
        val stats = SymbolAnalysisStats.from_symbols(symbols)
        Then "counts should be correct"
        sspec.expect(stats.total_symbols).to_equal(4)
        sspec.expect(stats.exported_symbols).to_equal(2)
        sspec.expect(stats.local_symbols).to_equal(1)
        sspec.expect(stats.imported_symbols).to_equal(1)

    Scenario "Calculate export ratio":
        Given "statistics with 2 exported out of 4 total"
        val symbols = [
            AnalyzedSymbol.new("pub1", SymbolVisibility.Export),
            AnalyzedSymbol.new("pub2", SymbolVisibility.Export),
            AnalyzedSymbol.new("priv1", SymbolVisibility.Local),
            AnalyzedSymbol.new("priv2", SymbolVisibility.Local)
        ]
        val stats = SymbolAnalysisStats.from_symbols(symbols)
        When "calculating export ratio"
        val ratio = stats.export_ratio()
        Then "it should be 0.5"
        sspec.expect(ratio).to_equal(0.5)

    Scenario "Export ratio for empty statistics":
        Given "empty statistics"
        val stats = SymbolAnalysisStats.new()
        When "calculating export ratio"
        val ratio = stats.export_ratio()
        Then "it should be 0.0"
        sspec.expect(ratio).to_equal(0.0)

    Scenario "Calculate local ratio":
        Given "statistics with 3 local out of 4 total"
        val symbols = [
            AnalyzedSymbol.new("pub1", SymbolVisibility.Export),
            AnalyzedSymbol.new("priv1", SymbolVisibility.Local),
            AnalyzedSymbol.new("priv2", SymbolVisibility.Local),
            AnalyzedSymbol.new("priv3", SymbolVisibility.Local)
        ]
        val stats = SymbolAnalysisStats.from_symbols(symbols)
        When "calculating local ratio"
        val ratio = stats.local_ratio()
        Then "it should be 0.75"
        sspec.expect(ratio).to_equal(0.75)
