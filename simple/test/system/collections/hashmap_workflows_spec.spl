# HashMap System Integration Tests
"""
## System Test: HashMap Real-World Workflows

**Integration Scope:** HashMap + Collections + String Processing
**Complexity:** Medium
**Coverage Impact:** hashmap.rs (0%â†’80%), collections FFI

Tests end-to-end workflows that exercise HashMap through realistic
use cases: word counting, caching, data aggregation, and performance.
"""

import std.spec
import collections.{HashMap}

describe "HashMap real-world workflows":
    """
    ### Word Frequency Counter

    Classic HashMap use case: counting word occurrences in text.
    Exercises: new, insert, get, key presence checking.
    """

    context "Word frequency counter":
        it "counts words from text input":
            val text = "hello world hello simple world"
            val freq = HashMap.new()

            for word in text.split(" "):
                var count = 0
                if freq.contains_key(word):
                    count = freq.get(word)
                freq.insert(word, count + 1)

            expect(freq.get("hello")).to(eq(2))
            expect(freq.get("world")).to(eq(2))
            expect(freq.get("simple")).to(eq(1))
            expect(freq.len()).to(eq(3))

        it "handles empty text input":
            val text = ""
            val freq = HashMap.new()

            for word in text.split(" "):
                if word.len() > 0:
                    var count = 0
                    if freq.contains_key(word):
                        count = freq.get(word)
                    freq.insert(word, count + 1)

            expect(freq.len()).to(eq(0))
            expect(freq.is_empty()).to(be_true())

        it "counts words from multiline text":
            val text = "line one\nline two\nline one"
            val freq = HashMap.new()

            for line in text.split("\n"):
                for word in line.split(" "):
                    var count = 0
                    if freq.contains_key(word):
                        count = freq.get(word)
                    freq.insert(word, count + 1)

            expect(freq.get("line")).to(eq(3))
            expect(freq.get("one")).to(eq(2))
            expect(freq.get("two")).to(eq(1))

    """
    ### Cache Implementation

    Using HashMap as a simple key-value cache.
    Exercises: insert, get, contains_key, update operations.
    """

    context "Cache implementation":
        it "implements simple cache with HashMap":
            val cache = HashMap.new()

            # Cache miss - compute and store
            if not cache.contains_key("user:123"):
                cache.insert("user:123", "Alice")

            # Cache hit
            val user = cache.get("user:123")
            expect(user).to(eq("Alice"))
            expect(cache.len()).to(eq(1))

        it "updates cached values":
            val cache = HashMap.new()
            cache.insert("session:abc", "active")

            # Update existing value
            cache.insert("session:abc", "expired")

            expect(cache.get("session:abc")).to(eq("expired"))
            expect(cache.len()).to(eq(1))

        it "implements LRU-style eviction logic":
            val cache = HashMap.new()
            val max_size = 3

            # Fill cache
            cache.insert("key1", "value1")
            cache.insert("key2", "value2")
            cache.insert("key3", "value3")

            # Simulate LRU eviction (remove oldest if full)
            if cache.len() >= max_size:
                cache.remove("key1")

            cache.insert("key4", "value4")

            expect(cache.contains_key("key1")).to(be_false())
            expect(cache.contains_key("key4")).to(be_true())
            expect(cache.len()).to(eq(3))

    """
    ### Data Aggregation

    Grouping and aggregating data by key.
    Exercises: each, map_values, filter, keys, values.
    """

    context "Data aggregation":
        # TODO: Fix parse error in this test
        # it "groups records by key":
        #     val groups = HashMap.new()

        #     # Simulate grouping user actions by user_id
        #     val actions = [
        #         ("user1", "login"),
        #         ("user2", "logout"),
        #         ("user1", "click"),
        #         ("user1", "purchase")
        #     ]

        #     for (user_id, action) in actions:
        #         var user_actions = []
        #         if groups.contains_key(user_id):
        #             user_actions = groups.get(user_id)
        #         val updated_actions = user_actions + [action]
        #         groups.insert(user_id, updated_actions)

        #     val user1_actions = groups.get("user1")
        #     expect(user1_actions.len()).to(eq(3))
        #     expect(user1_actions).to(include("login"))
        #     expect(user1_actions).to(include("click"))

        it "aggregates numeric values by key":
            val sales = HashMap.new()

            # Aggregate sales by product
            sales.insert("product_a", 100)
            sales.insert("product_b", 200)
            sales.insert("product_c", 150)

            # Calculate total
            var total = 0
            sales.each(\key, value: total = total + value)

            expect(total).to(eq(450))

        it "filters entries by condition":
            val scores = HashMap.new()
            scores.insert("alice", 95)
            scores.insert("bob", 72)
            scores.insert("carol", 88)
            scores.insert("dave", 65)

            # Filter passing scores (>= 70)
            val passing = scores.filter(\key, value: value >= 70)

            expect(passing.len()).to(eq(3))
            expect(passing.contains_key("alice")).to(be_true())
            expect(passing.contains_key("dave")).to(be_false())

        it "transforms values with map_values":
            val prices = HashMap.new()
            prices.insert("apple", 100)
            prices.insert("banana", 50)
            prices.insert("orange", 75)

            # Apply 10% discount
            val discounted = prices.map_values(\price: price * 0.9)

            expect(discounted.get("apple")).to(eq(90))
            expect(discounted.get("banana")).to(eq(45))
            expect(discounted.get("orange")).to(eq(67.5))

    """
    ### Collection Operations

    Working with keys, values, and entries.
    Exercises: keys(), values(), entries(), clear().
    """

    context "Collection operations":
        it "retrieves all keys as array":
            val map = HashMap.new()
            map.insert("a", 1)
            map.insert("b", 2)
            map.insert("c", 3)

            val keys = map.keys()

            expect(keys.len()).to(eq(3))
            expect(keys).to(include("a"))
            expect(keys).to(include("b"))
            expect(keys).to(include("c"))

        it "retrieves all values as array":
            val map = HashMap.new()
            map.insert("a", 1)
            map.insert("b", 2)
            map.insert("c", 3)

            val values = map.values()

            expect(values.len()).to(eq(3))
            expect(values).to(include(1))
            expect(values).to(include(2))
            expect(values).to(include(3))

        it "retrieves all entries as key-value pairs":
            val map = HashMap.new()
            map.insert("x", 10)
            map.insert("y", 20)

            val entries = map.entries()

            expect(entries.len()).to(eq(2))
            # Entries should contain tuples (key, value)

        it "clears all entries from map":
            val map = HashMap.new()
            map.insert("a", 1)
            map.insert("b", 2)
            map.insert("c", 3)

            expect(map.len()).to(eq(3))
            map.clear()

            expect(map.len()).to(eq(0))
            expect(map.is_empty()).to(be_true())
            expect(map.contains_key("a")).to(be_false())

    """
    ### Performance and Scale

    HashMap should handle large datasets efficiently.
    Exercises: bulk insertions, large key sets.
    """

    context "Performance benchmarking":
        it "handles 1000 insertions efficiently":
            val map = HashMap.new()

            for i in 0..1000:
                map.insert("key_{i}", i)

            expect(map.len()).to(eq(1000))
            expect(map.get("key_0")).to(eq(0))
            expect(map.get("key_999")).to(eq(999))

        it "handles repeated updates efficiently":
            val map = HashMap.new()
            map.insert("counter", 0)

            for i in 0..100:
                val current = map.get("counter")
                map.insert("counter", current + 1)

            expect(map.get("counter")).to(eq(100))

        it "maintains correct size after mixed operations":
            val map = HashMap.new()

            # Insert 100 items
            for i in 0..100:
                map.insert("key_{i}", i)

            expect(map.len()).to(eq(100))

            # Remove 50 items
            for i in 0..50:
                map.remove("key_{i}")

            expect(map.len()).to(eq(50))

            # Insert 25 new items
            for i in 100..125:
                map.insert("key_{i}", i)

            expect(map.len()).to(eq(75))

    """
    ### Edge Cases

    HashMap behavior with edge cases and error conditions.
    """

    context "Edge cases":
        it "handles nil values correctly":
            val map = HashMap.new()
            map.insert("key", nil)

            expect(map.contains_key("key")).to(be_true())
            expect(map.get("key")).to(eq(nil))

        it "get returns nil for missing keys":
            val map = HashMap.new()
            map.insert("exists", "value")

            val missing = map.get("missing")
            expect(missing).to(eq(nil))

        it "remove returns removed value":
            val map = HashMap.new()
            map.insert("key", "value")

            val removed = map.remove("key")

            expect(removed).to(eq("value"))
            expect(map.contains_key("key")).to(be_false())

        it "remove returns nil for missing keys":
            val map = HashMap.new()

            val removed = map.remove("missing")
            expect(removed).to(eq(nil))
