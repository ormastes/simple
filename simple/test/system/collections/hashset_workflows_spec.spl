# HashSet System Integration Tests
"""
## System Test: HashSet Real-World Workflows

**Integration Scope:** HashSet + Collections + Set Operations
**Complexity:** Medium
**Coverage Impact:** hashset.rs (0%â†’75%)

Tests end-to-end workflows using HashSet for deduplication,
membership checking, and set operations.
"""

import std.spec
import collections.hashset as HashSet

describe "HashSet real-world workflows":
    """
    ### Deduplication

    Remove duplicate items from collections.
    Exercises: new, add, to_array, len.
    """

    context "Deduplication":
        it "removes duplicate items from list":
            val items = [1, 2, 3, 2, 1, 4, 3, 5]
            val unique = HashSet.new()

            for item in items:
                unique.add(item)

            val result = unique.to_array()
            expect(result.len()).to(eq(5))
            expect(unique.contains(1)).to(be_true())
            expect(unique.contains(5)).to(be_true())

        it "deduplicates string list":
            val words = ["hello", "world", "hello", "simple", "world"]
            val unique_words = HashSet.new()

            for word in words:
                unique_words.add(word)

            expect(unique_words.len()).to(eq(3))
            expect(unique_words.contains("hello")).to(be_true())
            expect(unique_words.contains("world")).to(be_true())
            expect(unique_words.contains("simple")).to(be_true())

        it "handles already unique list":
            val items = [1, 2, 3, 4, 5]
            val set = HashSet.new()

            for item in items:
                set.add(item)

            expect(set.len()).to(eq(5))

        it "handles empty list":
            val items = []
            val set = HashSet.new()

            for item in items:
                set.add(item)

            expect(set.len()).to(eq(0))
            expect(set.is_empty()).to(be_true())

    """
    ### Set Operations for Permissions

    Using HashSet for permission/access control.
    Exercises: contains, intersection, union, difference.
    """

    context "Set operations for permissions":
        it "checks user permissions with contains":
            val user_perms = HashSet.new()
            user_perms.add("read")
            user_perms.add("write")

            expect(user_perms.contains("read")).to(be_true())
            expect(user_perms.contains("write")).to(be_true())
            expect(user_perms.contains("delete")).to(be_false())

        it "finds common permissions with intersection":
            val user_perms = HashSet.new()
            user_perms.add("read")
            user_perms.add("write")

            val required_perms = HashSet.new()
            required_perms.add("read")
            required_perms.add("execute")

            val common = user_perms.intersection(required_perms)

            expect(common.contains("read")).to(be_true())
            expect(common.contains("write")).to(be_false())
            expect(common.contains("execute")).to(be_false())
            expect(common.len()).to(eq(1))

        it "combines permissions with union":
            val admin_perms = HashSet.new()
            admin_perms.add("read")
            admin_perms.add("write")
            admin_perms.add("delete")

            val user_perms = HashSet.new()
            user_perms.add("read")
            user_perms.add("execute")

            val all_perms = admin_perms.union(user_perms)

            expect(all_perms.len()).to(eq(4))
            expect(all_perms.contains("read")).to(be_true())
            expect(all_perms.contains("write")).to(be_true())
            expect(all_perms.contains("delete")).to(be_true())
            expect(all_perms.contains("execute")).to(be_true())

        it "finds unique permissions with difference":
            val all_perms = HashSet.new()
            all_perms.add("read")
            all_perms.add("write")
            all_perms.add("delete")

            val user_perms = HashSet.new()
            user_perms.add("read")

            val missing = all_perms.difference(user_perms)

            expect(missing.len()).to(eq(2))
            expect(missing.contains("write")).to(be_true())
            expect(missing.contains("delete")).to(be_true())
            expect(missing.contains("read")).to(be_false())

    """
    ### Unique Visitor Tracking

    Track unique visitors/users efficiently.
    Exercises: add, contains, len, clear.
    """

    context "Unique visitor tracking":
        it "tracks unique visitors efficiently":
            val visitors = HashSet.new()

            # Simulate visitor IDs
            visitors.add("visitor_123")
            visitors.add("visitor_456")
            visitors.add("visitor_123")  # Duplicate
            visitors.add("visitor_789")

            expect(visitors.len()).to(eq(3))

        it "checks if visitor already seen":
            val seen_visitors = HashSet.new()

            val visitor_id = "user_abc"

            if seen_visitors.contains(visitor_id):
                # Already seen
                pass
            else:
                # First time
                seen_visitors.add(visitor_id)

            expect(seen_visitors.contains(visitor_id)).to(be_true())
            expect(seen_visitors.len()).to(eq(1))

        it "resets visitor tracking":
            val daily_visitors = HashSet.new()

            daily_visitors.add("user1")
            daily_visitors.add("user2")
            daily_visitors.add("user3")

            expect(daily_visitors.len()).to(eq(3))

            # Reset at end of day
            daily_visitors.clear()

            expect(daily_visitors.len()).to(eq(0))
            expect(daily_visitors.is_empty()).to(be_true())

    """
    ### Collection Operations

    Working with HashSet elements.
    Exercises: each, filter, map, to_array.
    """

    context "Collection operations":
        it "iterates over elements with each":
            val set = HashSet.new()
            set.add(1)
            set.add(2)
            set.add(3)

            var sum = 0
            set.each(\item: sum = sum + item)

            expect(sum).to(eq(6))

        it "filters elements by condition":
            val numbers = HashSet.new()
            for i in 0..10:
                numbers.add(i)

            val evens = numbers.filter(\n: n % 2 == 0)

            expect(evens.len()).to(eq(5))
            expect(evens.contains(0)).to(be_true())
            expect(evens.contains(2)).to(be_true())
            expect(evens.contains(1)).to(be_false())

        it "transforms elements with map":
            val numbers = HashSet.new()
            numbers.add(1)
            numbers.add(2)
            numbers.add(3)

            val doubled = numbers.map(\n: n * 2)

            expect(doubled.len()).to(eq(3))
            expect(doubled.contains(2)).to(be_true())
            expect(doubled.contains(4)).to(be_true())
            expect(doubled.contains(6)).to(be_true())

        it "converts to array":
            val set = HashSet.new()
            set.add("apple")
            set.add("banana")
            set.add("orange")

            val array = set.to_array()

            expect(array.len()).to(eq(3))
            expect(array).to(include("apple"))
            expect(array).to(include("banana"))
            expect(array).to(include("orange"))

    """
    ### Performance and Scale

    HashSet should handle large datasets efficiently.
    """

    context "Performance benchmarking":
        it "handles 1000 additions efficiently":
            val set = HashSet.new()

            for i in 0..1000:
                set.add(i)

            expect(set.len()).to(eq(1000))
            expect(set.contains(0)).to(be_true())
            expect(set.contains(999)).to(be_true())

        it "handles repeated additions idempotently":
            val set = HashSet.new()

            for i in 0..100:
                set.add("item")

            # Should still have only 1 element
            expect(set.len()).to(eq(1))
            expect(set.contains("item")).to(be_true())

        it "maintains correct size after mixed operations":
            val set = HashSet.new()

            # Add 100 items
            for i in 0..100:
                set.add(i)

            expect(set.len()).to(eq(100))

            # Remove 50 items
            for i in 0..50:
                set.remove(i)

            expect(set.len()).to(eq(50))

            # Add 25 new items
            for i in 100..125:
                set.add(i)

            expect(set.len()).to(eq(75))

    """
    ### Edge Cases

    HashSet behavior with edge cases.
    """

    context "Edge cases":
        it "remove returns true if element existed":
            val set = HashSet.new()
            set.add("item")

            val removed = set.remove("item")

            expect(removed).to(be_true())
            expect(set.contains("item")).to(be_false())

        it "remove returns false if element missing":
            val set = HashSet.new()

            val removed = set.remove("missing")

            expect(removed).to(be_false())

        it "handles nil values if supported":
            val set = HashSet.new()
            set.add(nil)

            expect(set.contains(nil)).to(be_true())
            expect(set.len()).to(eq(1))

        it "is_empty returns true for empty set":
            val set = HashSet.new()

            expect(set.is_empty()).to(be_true())

            set.add("item")
            expect(set.is_empty()).to(be_false())

            set.remove("item")
            expect(set.is_empty()).to(be_true())
