# BTreeMap/BTreeSet System Integration Tests
"""
## System Test: BTree Ordered Collection Workflows

**Integration Scope:** BTreeMap + BTreeSet + Sorted Collections
**Complexity:** Medium
**Coverage Impact:** btreemap.rs (0%→70%), btreeset.rs (0%→70%)

Tests end-to-end workflows using BTreeMap/BTreeSet for ordered
data operations: time-series, leaderboards, range queries.
"""

import std.spec
import collections.btreemap as BTreeMap
import collections.btreeset as BTreeSet

describe "BTreeMap ordered operations":
    """
    ### Time-Series Data

    BTreeMap maintains insertion order for chronological data.
    Exercises: new, insert, keys, ordered iteration.
    """

    context "Time-series data":
        it "maintains chronological order for events":
            val events = BTreeMap.new()

            # Insert events with timestamps (out of order)
            events.insert(1704070800, "Event C")
            events.insert(1704067200, "Event A")
            events.insert(1704069000, "Event B")

            val chronological = events.keys()

            # Keys should be sorted
            expect(chronological[0]).to(eq(1704067200))
            expect(chronological[1]).to(eq(1704069000))
            expect(chronological[2]).to(eq(1704070800))

        it "retrieves events in sorted order":
            val log = BTreeMap.new()

            log.insert(5, "Error at 5s")
            log.insert(2, "Warning at 2s")
            log.insert(8, "Info at 8s")
            log.insert(1, "Start at 1s")

            val timestamps = log.keys()

            expect(timestamps[0]).to(eq(1))
            expect(timestamps[1]).to(eq(2))
            expect(timestamps[2]).to(eq(5))
            expect(timestamps[3]).to(eq(8))

        it "appends recent events while maintaining order":
            val timeline = BTreeMap.new()

            # Add initial events
            timeline.insert(100, "Event 1")
            timeline.insert(200, "Event 2")

            # Add newer event
            timeline.insert(300, "Event 3")

            # Add older event (out of order)
            timeline.insert(150, "Event 1.5")

            val times = timeline.keys()
            expect(times[0]).to(eq(100))
            expect(times[1]).to(eq(150))
            expect(times[2]).to(eq(200))
            expect(times[3]).to(eq(300))

    """
    ### Range Queries

    BTreeMap supports efficient range queries.
    Exercises: range(), first_key(), last_key().
    """

    context "Range queries":
        it "queries events in time range":
            val events = BTreeMap.new()

            for i in 0..100:
                events.insert(i, "Event {i}")

            # Query events from 20 to 30
            val subset = events.range(20, 30)

            expect(subset.len()).to(eq(10))
            expect(subset.first_key()).to(eq(20))
            expect(subset.last_key()).to(eq(29))

        it "gets first and last keys":
            val map = BTreeMap.new()

            map.insert(50, "Middle")
            map.insert(10, "First")
            map.insert(90, "Last")

            expect(map.first_key()).to(eq(10))
            expect(map.last_key()).to(eq(90))

        it "handles range with no matching keys":
            val map = BTreeMap.new()

            map.insert(10, "A")
            map.insert(20, "B")
            map.insert(30, "C")

            val subset = events.range(40, 50)

            expect(subset.len()).to(eq(0))
            expect(subset.is_empty()).to(be_true())

    """
    ### Leaderboard Ranking

    BTreeSet maintains sorted scores for rankings.
    Exercises: add, first(), last(), ordered iteration.
    """

    context "Leaderboard ranking":
        it "maintains sorted scores with BTreeSet":
            val scores = BTreeSet.new()

            # Add scores (out of order)
            scores.add(850)
            scores.add(920)
            scores.add(780)
            scores.add(900)

            val sorted_scores = scores.to_array()

            # Should be in ascending order
            expect(sorted_scores[0]).to(eq(780))
            expect(sorted_scores[1]).to(eq(850))
            expect(sorted_scores[2]).to(eq(900))
            expect(sorted_scores[3]).to(eq(920))

        it "gets top score with last()":
            val scores = BTreeSet.new()

            scores.add(100)
            scores.add(250)
            scores.add(175)

            val top_score = scores.last()

            expect(top_score).to(eq(250))

        it "gets lowest score with first()":
            val scores = BTreeSet.new()

            scores.add(100)
            scores.add(250)
            scores.add(175)

            val lowest = scores.first()

            expect(lowest).to(eq(100))

        it "maintains unique scores (no duplicates)":
            val scores = BTreeSet.new()

            scores.add(100)
            scores.add(200)
            scores.add(100)  # Duplicate
            scores.add(200)  # Duplicate

            expect(scores.len()).to(eq(2))

    """
    ### Sorted Dictionary Operations

    BTreeMap for sorted key-value operations.
    Exercises: get, insert, remove, iteration.
    """

    context "Sorted dictionary operations":
        it "retrieves values by key":
            val map = BTreeMap.new()

            map.insert("apple", 1.20)
            map.insert("banana", 0.50)
            map.insert("orange", 0.80)

            expect(map.get("banana")).to(eq(0.50))
            expect(map.get("apple")).to(eq(1.20))

        it "iterates in key order":
            val map = BTreeMap.new()

            map.insert("charlie", 3)
            map.insert("alice", 1)
            map.insert("bob", 2)

            val keys = map.keys()

            # Alphabetical order
            expect(keys[0]).to(eq("alice"))
            expect(keys[1]).to(eq("bob"))
            expect(keys[2]).to(eq("charlie"))

        it "updates values while maintaining order":
            val map = BTreeMap.new()

            map.insert(3, "three")
            map.insert(1, "one")
            map.insert(2, "two")

            # Update middle value
            map.insert(2, "TWO")

            val keys = map.keys()
            expect(keys[0]).to(eq(1))
            expect(keys[1]).to(eq(2))
            expect(keys[2]).to(eq(3))

            expect(map.get(2)).to(eq("TWO"))

        it "removes entries while maintaining order":
            val map = BTreeMap.new()

            for i in 0..10:
                map.insert(i, "value {i}")

            map.remove(5)

            val keys = map.keys()
            expect(keys.len()).to(eq(9))
            expect(keys).not_to(include(5))
            expect(keys[5]).to(eq(6))  # Next key after removed

    """
    ### Performance and Scale

    BTree collections should handle large sorted datasets.
    """

    context "Performance benchmarking":
        it "handles 1000 insertions maintaining order":
            val map = BTreeMap.new()

            # Insert in random order
            for i in 0..1000:
                val key = (i * 7) % 1000  # Pseudo-random
                map.insert(key, i)

            val keys = map.keys()

            # Verify sorted
            for i in 0..999:
                expect(keys[i]).to(be_less_than(keys[i + 1]))

        it "BTreeSet maintains sorted order at scale":
            val set = BTreeSet.new()

            for i in 0..500:
                set.add(500 - i)  # Insert in reverse order

            val sorted = set.to_array()

            # Should be in ascending order
            for i in 0..499:
                expect(sorted[i]).to(eq(i + 1))

    """
    ### Comparison with HashMap/HashSet

    BTree provides ordering guarantees that Hash collections don't.
    """

    context "Ordered vs unordered comparison":
        it "BTreeMap provides ordered iteration":
            val btree = BTreeMap.new()

            btree.insert("z", 26)
            btree.insert("a", 1)
            btree.insert("m", 13)

            val keys = btree.keys()

            # BTreeMap: always sorted
            expect(keys[0]).to(eq("a"))
            expect(keys[1]).to(eq("m"))
            expect(keys[2]).to(eq("z"))

        it "BTreeSet enables range-based operations":
            val set = BTreeSet.new()

            for i in 0..100:
                set.add(i)

            # Get elements in range 40-50
            val range_subset = set.range(40, 50)

            expect(range_subset.len()).to(eq(10))
            expect(range_subset.first()).to(eq(40))
            expect(range_subset.last()).to(eq(49))

    """
    ### Edge Cases

    BTree behavior with edge cases.
    """

    context "Edge cases":
        it "handles empty BTreeMap":
            val map = BTreeMap.new()

            expect(map.is_empty()).to(be_true())
            expect(map.len()).to(eq(0))
            expect(map.first_key()).to(eq(nil))
            expect(map.last_key()).to(eq(nil))

        it "handles single element BTreeMap":
            val map = BTreeMap.new()
            map.insert(42, "answer")

            expect(map.first_key()).to(eq(42))
            expect(map.last_key()).to(eq(42))
            expect(map.len()).to(eq(1))

        it "handles empty BTreeSet":
            val set = BTreeSet.new()

            expect(set.is_empty()).to(be_true())
            expect(set.len()).to(eq(0))
            expect(set.first()).to(eq(nil))
            expect(set.last()).to(eq(nil))

        it "BTreeMap range with inclusive bounds":
            val map = BTreeMap.new()

            for i in 0..10:
                map.insert(i, "value {i}")

            val subset = map.range_inclusive(3, 7)

            expect(subset.len()).to(eq(5))
            expect(subset.first_key()).to(eq(3))
            expect(subset.last_key()).to(eq(7))
