# Mixin Composition System Tests
"""
## System Test: Mixin Composition in Real Classes

**Integration Scope:** Mixin system + Type checking + Method dispatch
**Complexity:** High
**Coverage Impact:** mixin_checker.rs (0%→75%), dispatch_checker.rs (0%→60%)

Tests end-to-end mixin composition workflows: combining multiple mixins,
field merging, method resolution, and real-world mixin patterns.
"""

import std.spec

describe "Mixin composition in real classes":
    """
    ### Basic Mixin Application

    Apply single mixin to class.
    Exercises: mixin application, method availability.
    """

    context "Single mixin application":
        it "applies mixin to class":
            mixin Greetable:
                fn greet() -> text:
                    "Hello from {self.name}"

            class Person:
                name: text

                include Greetable

            val person = Person(name: "Alice")
            val greeting = person.greet()

            expect(greeting).to(eq("Hello from Alice"))

        it "mixin methods access class fields":
            mixin Describable:
                fn describe() -> text:
                    "This is {self.name}, age {self.age}"

            class User:
                name: text
                age: i32

                include Describable

            val user = User(name: "Bob", age: 30)
            val description = user.describe()

            expect(description).to(include("Bob"))
            expect(description).to(include("30"))

        it "class can override mixin methods":
            mixin DefaultFormatter:
                fn format() -> text:
                    "Default: {self.value}"

            class CustomValue:
                value: i32

                include DefaultFormatter

                fn format() -> text:
                    "Custom: {self.value * 2}"

            val obj = CustomValue(value: 10)
            val formatted = obj.format()

            expect(formatted).to(eq("Custom: 20"))

    """
    ### Multiple Mixin Combination

    Combine multiple mixins in one class.
    Exercises: multi-mixin composition, method ordering.
    """

    context "Multiple mixin combination":
        it "combines Serializable + Validatable mixins":
            mixin Serializable:
                fn to_json() -> text:
                    '{"name": "{self.name}", "email": "{self.email}"}'

            mixin Validatable:
                fn validate() -> bool:
                    self.email.includes("@")

            class User:
                name: text
                email: text

                include Serializable
                include Validatable

            val user = User(name: "Alice", email: "alice@test.com")

            expect(user.validate()).to(be_true())
            expect(user.to_json()).to(include("Alice"))
            expect(user.to_json()).to(include("alice@test.com"))

        it "combines three mixins with different responsibilities":
            mixin Timestamped:
                created_at: i64

                fn set_timestamp():
                    self.created_at = time.now()

            mixin Identifiable:
                id: text

                fn generate_id():
                    self.id = "id_{random.int(1000, 9999)}"

            mixin Loggable:
                fn log_action(action: text):
                    print "[{self.id}] {action} at {self.created_at}"

            class Entity:
                name: text

                include Timestamped
                include Identifiable
                include Loggable

            val entity = Entity(name: "Test Entity")
            entity.generate_id()
            entity.set_timestamp()

            expect(entity.id).not_to(be_nil())
            expect(entity.created_at).to(be_greater_than(0))

        it "mixins can call methods from other mixins":
            mixin LogFormatter:
                fn format_log(msg: text) -> text:
                    "[{time.now()}] {msg}"

            mixin Logger:
                include LogFormatter

                fn log(msg: text):
                    print self.format_log(msg)

            class Service:
                name: text

                include Logger

            val service = Service(name: "API")
            # log method available from Logger mixin
            # which uses format_log from LogFormatter mixin

    """
    ### Field Merging and Conflicts

    Handle field definitions across mixins and classes.
    Exercises: field merging, conflict detection.
    """

    context "Field merging":
        it "combines mixin and class fields":
            mixin Auditable:
                created_by: text
                modified_by: text

            class Document:
                title: text
                content: text

                include Auditable

            val doc = Document(
                title: "Report",
                content: "Content here",
                created_by: "Alice",
                modified_by: "Bob"
            )

            expect(doc.title).to(eq("Report"))
            expect(doc.created_by).to(eq("Alice"))

        it "detects field name conflicts":
            mixin WithId:
                id: i32

            class AlsoWithId:
                id: text  # Conflict!

                include WithId

            # This should produce a compile error or warning
            # Testing that conflict detection works

        it "multiple mixins can add non-conflicting fields":
            mixin Metadata:
                version: i32
                tags: List<text>

            mixin Permissions:
                owner: text
                public: bool

            class Resource:
                name: text

                include Metadata
                include Permissions

            val resource = Resource(
                name: "File.txt",
                version: 1,
                tags: ["important"],
                owner: "Alice",
                public: false
            )

            expect(resource.version).to(eq(1))
            expect(resource.owner).to(eq("Alice"))

    """
    ### Generic Mixins

    Mixins with type parameters.
    Exercises: generic mixin instantiation, type inference.
    """

    context "Generic mixins":
        it "applies generic mixin to class":
            mixin Container<T>:
                items: List<T>

                fn add(item: T):
                    self.items.append(item)

                fn count() -> i32:
                    self.items.len()

            class IntBox:
                include Container<i32>

            val box = IntBox(items: [])
            box.add(10)
            box.add(20)

            expect(box.count()).to(eq(2))

        it "generic mixin infers type from class usage":
            mixin Comparable<T>:
                fn equals(other: T) -> bool:
                    self.value == other.value

            class Point:
                value: i32

                include Comparable<Point>

            val p1 = Point(value: 5)
            val p2 = Point(value: 5)
            val p3 = Point(value: 10)

            expect(p1.equals(p2)).to(be_true())
            expect(p1.equals(p3)).to(be_false())

    """
    ### Mixin Composition Patterns

    Real-world mixin patterns.
    Exercises: builder pattern, repository pattern via mixins.
    """

    context "Mixin composition patterns":
        it "implements builder pattern with mixins":
            mixin Buildable:
                fn build() -> Self:
                    # Validate and return built object
                    self

            mixin FluentSetter:
                fn with_name(name: text) -> Self:
                    self.name = name
                    self

                fn with_age(age: i32) -> Self:
                    self.age = age
                    self

            class PersonBuilder:
                name: text
                age: i32

                include FluentSetter
                include Buildable

            val person = PersonBuilder()
                .with_name("Alice")
                .with_age(30)
                .build()

            expect(person.name).to(eq("Alice"))
            expect(person.age).to(eq(30))

        it "implements repository pattern with CRUD mixins":
            mixin Creatable:
                fn create(data: HashMap):
                    # Create new record
                    self.data = data

            mixin Readable:
                fn find_by_id(id: i32) -> Option<Self>:
                    # Read from storage
                    nil  # Simplified

            mixin Updatable:
                fn update(changes: HashMap):
                    # Update record
                    self.data.merge(changes)

            mixin Deletable:
                fn delete():
                    # Delete record
                    self.data = nil

            class UserRepository:
                data: HashMap

                include Creatable
                include Readable
                include Updatable
                include Deletable

            # All CRUD methods available

    """
    ### Mixin Method Resolution

    Test method lookup and dispatch.
    Exercises: method resolution order, override handling.
    """

    context "Method resolution":
        it "resolves methods from mixin before class":
            mixin Priority:
                fn action() -> text:
                    "Mixin action"

            class WithAction:
                include Priority

                fn other_action() -> text:
                    "Class action"

            val obj = WithAction()

            expect(obj.action()).to(eq("Mixin action"))

        it "class methods override mixin methods":
            mixin DefaultBehavior:
                fn process() -> text:
                    "Default processing"

            class CustomProcessor:
                include DefaultBehavior

                fn process() -> text:
                    "Custom processing"

            val processor = CustomProcessor()

            expect(processor.process()).to(eq("Custom processing"))

        it "later mixins override earlier mixins":
            mixin First:
                fn value() -> i32:
                    1

            mixin Second:
                fn value() -> i32:
                    2

            class Multi:
                include First
                include Second  # This overrides First

            val obj = Multi()

            expect(obj.value()).to(eq(2))

    """
    ### Real-World Mixin Usage

    Practical mixin applications.
    """

    context "Real-world usage":
        it "implements ActiveRecord-style model with mixins":
            mixin Persistence:
                fn save():
                    # Save to database
                    print "Saving {self.to_json()}"

                fn reload():
                    # Reload from database
                    print "Reloading"

            mixin Validation:
                fn is_valid() -> bool:
                    self.name.len() > 0

            mixin JsonSerializable:
                fn to_json() -> text:
                    '{"name": "{self.name}"}'

            class Model:
                name: text

                include Persistence
                include Validation
                include JsonSerializable

            val model = Model(name: "Test")

            expect(model.is_valid()).to(be_true())
            expect(model.to_json()).to(include("Test"))

        it "implements event emitter with mixin":
            mixin EventEmitter:
                listeners: HashMap

                fn on(event: text, callback: fn()):
                    self.listeners.insert(event, callback)

                fn emit(event: text):
                    val callback = self.listeners.get(event)
                    if callback:
                        callback()

            class Button:
                label: text

                include EventEmitter

            val button = Button(label: "Click Me", listeners: HashMap.new())

            var clicked = false
            button.on("click", \: clicked = true)
            button.emit("click")

            expect(clicked).to(be_true())

    """
    ### Edge Cases

    Mixin edge cases and error conditions.
    """

    context "Edge cases":
        it "handles empty mixin":
            mixin EmptyMixin:
                # No fields or methods

            class WithEmpty:
                value: i32

                include EmptyMixin

            val obj = WithEmpty(value: 42)

            expect(obj.value).to(eq(42))

        it "mixin with only fields, no methods":
            mixin DataOnly:
                x: i32
                y: i32

            class Point:
                include DataOnly

                fn distance() -> f64:
                    math.sqrt(self.x * self.x + self.y * self.y)

            val point = Point(x: 3, y: 4)

            expect(point.distance()).to(eq(5.0))

        it "deeply nested mixin hierarchy":
            mixin A:
                fn a() -> text:
                    "A"

            mixin B:
                include A

                fn b() -> text:
                    "B"

            mixin C:
                include B

                fn c() -> text:
                    "C"

            class Multi:
                include C

            val obj = Multi()

            expect(obj.a()).to(eq("A"))
            expect(obj.b()).to(eq("B"))
            expect(obj.c()).to(eq("C"))
