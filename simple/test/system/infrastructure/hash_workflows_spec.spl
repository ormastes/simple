# Hash Function Workflow Tests
"""
## System Test: Hash Function Workflows

**Integration Scope:** Hash functions + Data integrity + Cryptography
**Complexity:** Medium
**Coverage Impact:** hash.rs (0%â†’70%), crypto utilities

Tests end-to-end hash function workflows: checksums, data integrity
verification, password hashing, and hash-based operations.
"""

import std.spec
import crypto.hash as hash
import io.file as file

describe "Hash function workflows":
    """
    ### Data Integrity Verification

    Use hash functions for data checksums and integrity.
    Exercises: SHA-256, hash computation, verification.
    """

    context "Data integrity verification":
        it "computes SHA-256 checksum for data":
            val data = "Important data content"

            val hasher = hash.sha256()
            hasher.update(data)
            val checksum = hasher.finalize()

            expect(checksum).not_to(be_nil())
            expect(checksum.len()).to(eq(64))  # 256 bits = 64 hex chars

        it "produces consistent hashes":
            val data = "test data"

            val hash1 = hash.sha256().update(data).finalize()
            val hash2 = hash.sha256().update(data).finalize()

            expect(hash1).to(eq(hash2))

        it "different inputs produce different hashes":
            val data1 = "first data"
            val data2 = "second data"

            val hash1 = hash.sha256().update(data1).finalize()
            val hash2 = hash.sha256().update(data2).finalize()

            expect(hash1).not_to(eq(hash2))

        it "verifies data integrity with checksum":
            val original_data = "Original content"
            val expected_hash = hash.sha256().update(original_data).finalize()

            # Simulate receiving data
            val received_data = "Original content"
            val received_hash = hash.sha256().update(received_data).finalize()

            expect(received_hash).to(eq(expected_hash))

        it "detects data corruption":
            val original = "Original content"
            val original_hash = hash.sha256().update(original).finalize()

            # Corrupted data
            val corrupted = "Modified content"
            val corrupted_hash = hash.sha256().update(corrupted).finalize()

            expect(corrupted_hash).not_to(eq(original_hash))

    """
    ### File Checksums

    Compute checksums for file contents.
    Exercises: file I/O + hash integration.
    """

    context "File checksums":
        it "computes checksum for file contents":
            # Create test file
            file.write("/tmp/test_file.txt", "File content for hashing")

            # Read and hash
            val content = file.read("/tmp/test_file.txt")
            val checksum = hash.sha256().update(content).finalize()

            expect(checksum).not_to(be_nil())

            # Cleanup
            fs.remove_file("/tmp/test_file.txt")

        it "verifies file integrity":
            val original_content = "Important file data"
            file.write("/tmp/original.dat", original_content)

            # Compute original checksum
            val content1 = file.read("/tmp/original.dat")
            val checksum1 = hash.sha256().update(content1).finalize()

            # Copy file
            file.copy("/tmp/original.dat", "/tmp/copy.dat")

            # Verify copy
            val content2 = file.read("/tmp/copy.dat")
            val checksum2 = hash.sha256().update(content2).finalize()

            expect(checksum2).to(eq(checksum1))

            # Cleanup
            fs.remove_file("/tmp/original.dat")
            fs.remove_file("/tmp/copy.dat")

        it "detects file modifications":
            file.write("/tmp/modified.txt", "Original content")

            val original_content = file.read("/tmp/modified.txt")
            val original_hash = hash.sha256().update(original_content).finalize()

            # Modify file
            file.write("/tmp/modified.txt", "Changed content")

            val modified_content = file.read("/tmp/modified.txt")
            val modified_hash = hash.sha256().update(modified_content).finalize()

            expect(modified_hash).not_to(eq(original_hash))

            fs.remove_file("/tmp/modified.txt")

    """
    ### Fast Hashing (Non-Cryptographic)

    XxHash for fast, non-cryptographic hashing.
    Exercises: XxHash, seeded hashing, performance.
    """

    context "Fast hashing for HashMap":
        it "uses XxHash for non-cryptographic hashing":
            val data = "key_data"

            val hasher = hash.xxhash(seed: 42)
            hasher.update(data)
            val hash_value = hasher.finalize()

            expect(hash_value).to(be_greater_than(0))

        it "XxHash with different seeds produces different hashes":
            val data = "same data"

            val hash1 = hash.xxhash(seed: 1).update(data).finalize()
            val hash2 = hash.xxhash(seed: 2).update(data).finalize()

            expect(hash1).not_to(eq(hash2))

        it "XxHash is deterministic with same seed":
            val data = "test"

            val hash1 = hash.xxhash(seed: 0).update(data).finalize()
            val hash2 = hash.xxhash(seed: 0).update(data).finalize()

            expect(hash1).to(eq(hash2))

        it "hashes keys for HashMap efficiently":
            val keys = ["key1", "key2", "key3", "key4", "key5"]
            val hashes = []

            for key in keys:
                val h = hash.xxhash(seed: 0).update(key).finalize()
                hashes.append(h)

            # All hashes should be unique
            expect(hashes.len()).to(eq(5))

    """
    ### SHA-1 Hashing

    SHA-1 for legacy compatibility.
    Exercises: SHA-1 computation.
    """

    context "SHA-1 hashing":
        it "computes SHA-1 hash":
            val data = "test data"

            val hasher = hash.sha1()
            hasher.update(data)
            val hash_value = hasher.finalize()

            expect(hash_value).not_to(be_nil())
            expect(hash_value.len()).to(eq(40))  # 160 bits = 40 hex chars

        it "SHA-1 produces consistent results":
            val data = "consistent"

            val hash1 = hash.sha1().update(data).finalize()
            val hash2 = hash.sha1().update(data).finalize()

            expect(hash1).to(eq(hash2))

    """
    ### Hash Updates (Streaming)

    Update hash incrementally.
    Exercises: incremental hashing, streaming data.
    """

    context "Incremental hashing":
        it "updates hash incrementally":
            val hasher = hash.sha256()

            hasher.update("part1")
            hasher.update("part2")
            hasher.update("part3")

            val final_hash = hasher.finalize()

            # Should equal hashing all at once
            val combined_hash = hash.sha256().update("part1part2part3").finalize()

            expect(final_hash).to(eq(combined_hash))

        it "processes large data in chunks":
            val hasher = hash.sha256()

            # Simulate streaming large file
            for i in 0..100:
                hasher.update("chunk{i}")

            val hash_value = hasher.finalize()

            expect(hash_value).not_to(be_nil())

        it "resets hasher for reuse":
            val hasher = hash.sha256()

            hasher.update("first")
            val hash1 = hasher.finalize()

            hasher.reset()
            hasher.update("second")
            val hash2 = hasher.finalize()

            expect(hash1).not_to(eq(hash2))

    """
    ### Hash-Based Operations

    Use hashes for various operations.
    Exercises: hash comparison, hash storage.
    """

    context "Hash-based operations":
        it "stores hashes in HashMap for deduplication":
            val seen_hashes = HashMap.new()
            val data_items = ["item1", "item2", "item1", "item3"]

            for item in data_items:
                val item_hash = hash.sha256().update(item).finalize()

                if not seen_hashes.contains_key(item_hash):
                    seen_hashes.insert(item_hash, item)

            # Should have 3 unique items
            expect(seen_hashes.len()).to(eq(3))

        it "compares hashes for equality":
            val hash1 = hash.sha256().update("data").finalize()
            val hash2 = hash.sha256().update("data").finalize()
            val hash3 = hash.sha256().update("different").finalize()

            expect(hash1 == hash2).to(be_true())
            expect(hash1 == hash3).to(be_false())

        it "uses hash as cache key":
            val cache = HashMap.new()

            val data = "cacheable data"
            val cache_key = hash.sha256().update(data).finalize()

            # Store in cache
            cache.insert(cache_key, "cached result")

            # Retrieve from cache
            val cached = cache.get(cache_key)
            expect(cached).to(eq("cached result"))

    """
    ### FNV Hash

    FNV-1a hash for simple non-cryptographic hashing.
    Exercises: FNV hash computation.
    """

    context "FNV hashing":
        it "computes FNV hash":
            val data = "test"

            val hash_value = hash.fnv1a(data)

            expect(hash_value).to(be_greater_than(0))

        it "FNV is deterministic":
            val data = "same data"

            val hash1 = hash.fnv1a(data)
            val hash2 = hash.fnv1a(data)

            expect(hash1).to(eq(hash2))

        it "different inputs produce different FNV hashes":
            val hash1 = hash.fnv1a("input1")
            val hash2 = hash.fnv1a("input2")

            expect(hash1).not_to(eq(hash2))

    """
    ### Edge Cases

    Hash function edge cases.
    """

    context "Edge cases":
        it "hashes empty string":
            val hasher = hash.sha256()
            hasher.update("")
            val hash_value = hasher.finalize()

            expect(hash_value).not_to(be_nil())

        it "hashes very long string":
            val long_data = "x" * 10000

            val hash_value = hash.sha256().update(long_data).finalize()

            expect(hash_value).not_to(be_nil())

        it "handles binary data":
            val binary_data = [0x00, 0xFF, 0xAB, 0xCD]

            val hash_value = hash.sha256().update(binary_data).finalize()

            expect(hash_value).not_to(be_nil())

    """
    ### Performance

    Hash function performance characteristics.
    """

    context "Performance":
        it "hashes 1000 items efficiently":
            for i in 0..1000:
                val hash_value = hash.sha256().update("item{i}").finalize()
                expect(hash_value).not_to(be_nil())

        it "XxHash is faster than SHA-256 for non-crypto use":
            # This is more of a documentation test
            val data = "performance test data"

            # XxHash (fast)
            val xx_hash = hash.xxhash(seed: 0).update(data).finalize()

            # SHA-256 (secure but slower)
            val sha_hash = hash.sha256().update(data).finalize()

            # Both should work
            expect(xx_hash).not_to(be_nil())
            expect(sha_hash).not_to(be_nil())
