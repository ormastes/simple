# SSpec: Tensor Broadcasting Utilities
#
# Comprehensive tests for NumPy-style tensor broadcasting
# Tests shape computation, stride calculation, and compatibility checks

import sspec
import std_lib.tooling.math.tensor_broadcast

Feature "Stride Computation":

    Scenario "Compute strides for 1D shape":
        Given "a 1D shape [5]"
        val shape = [5]
        When "computing strides"
        val strides = compute_strides(shape)
        Then "strides should be [1]"
        sspec.expect(strides).to_equal([1])

    Scenario "Compute strides for 2D shape":
        Given "a 2D shape [3, 4]"
        val shape = [3, 4]
        When "computing strides"
        val strides = compute_strides(shape)
        Then "strides should be [4, 1]"
        sspec.expect(strides).to_equal([4, 1])

    Scenario "Compute strides for 3D shape":
        Given "a 3D shape [2, 3, 4]"
        val shape = [2, 3, 4]
        When "computing strides"
        val strides = compute_strides(shape)
        Then "strides should be [12, 4, 1]"
        sspec.expect(strides).to_equal([12, 4, 1])

    Scenario "Compute strides for empty shape":
        Given "an empty shape"
        val shape = []
        When "computing strides"
        val strides = compute_strides(shape)
        Then "strides should be empty"
        sspec.expect(strides.length()).to_equal(0)

Feature "Dimension Alignment":

    Scenario "Get dimension within bounds":
        Given "a shape [3, 4, 5] and max_len 3"
        val shape = [3, 4, 5]
        When "getting dimension at index 2"
        val dim = get_dim_aligned(shape, 2, max_len: 3)
        Then "it should return 5"
        sspec.expect(dim).to_equal(5)

    Scenario "Get dimension with left padding":
        Given "a shape [4, 5] and max_len 3"
        val shape = [4, 5]
        When "getting dimension at index 0 (left pad)"
        val dim = get_dim_aligned(shape, 0, max_len: 3)
        Then "it should return 1 (padding)"
        sspec.expect(dim).to_equal(1)

Feature "Dimension Compatibility":

    Scenario "Equal dimensions are compatible":
        Given "two equal dimensions"
        val a = 5
        val b = 5
        When "checking compatibility"
        val compat = dims_compatible(a, b)
        Then "they should be compatible"
        sspec.expect(compat).to_be_true()

    Scenario "Dimension 1 is compatible with any":
        Given "dimension 1 and dimension 5"
        val a = 1
        val b = 5
        When "checking compatibility"
        val compat = dims_compatible(a, b)
        Then "they should be compatible"
        sspec.expect(compat).to_be_true()

    Scenario "Incompatible different dimensions":
        Given "dimensions 3 and 5"
        val a = 3
        val b = 5
        When "checking compatibility"
        val compat = dims_compatible(a, b)
        Then "they should not be compatible"
        sspec.expect(compat).to_be_false()

Feature "Broadcast Dimension":

    Scenario "Broadcast equal dimensions":
        Given "two equal dimensions 5"
        val a = 5
        val b = 5
        When "broadcasting"
        val result = broadcast_dim(a, b)
        Then "result should be 5"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal(5)

    Scenario "Broadcast 1 with larger dimension":
        Given "dimensions 1 and 7"
        val a = 1
        val b = 7
        When "broadcasting"
        val result = broadcast_dim(a, b)
        Then "result should be 7"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal(7)

    Scenario "Broadcast incompatible dimensions":
        Given "dimensions 3 and 5"
        val a = 3
        val b = 5
        When "broadcasting"
        val result = broadcast_dim(a, b)
        Then "it should return error"
        sspec.expect(result.is_err()).to_be_true()

Feature "Broadcast Shapes":

    Scenario "Broadcast equal shapes":
        Given "two equal shapes [3, 4, 5]"
        val a = [3, 4, 5]
        val b = [3, 4, 5]
        When "broadcasting shapes"
        val result = broadcast_shapes(a, b)
        Then "result should be [3, 4, 5]"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([3, 4, 5])

    Scenario "Broadcast with scalar (empty shape)":
        Given "shapes [3, 4] and []"
        val a = [3, 4]
        val b = []
        When "broadcasting shapes"
        val result = broadcast_shapes(a, b)
        Then "result should be [3, 4]"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([3, 4])

    Scenario "Broadcast different lengths - compatible":
        Given "shapes [3, 1, 5] and [4, 5]"
        val a = [3, 1, 5]
        val b = [4, 5]
        When "broadcasting shapes"
        val result = broadcast_shapes(a, b)
        Then "result should be [3, 4, 5]"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([3, 4, 5])

    Scenario "Broadcast with 1s":
        Given "shapes [1, 3, 1] and [2, 1, 4]"
        val a = [1, 3, 1]
        val b = [2, 1, 4]
        When "broadcasting shapes"
        val result = broadcast_shapes(a, b)
        Then "result should be [2, 3, 4]"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([2, 3, 4])

    Scenario "Broadcast incompatible shapes":
        Given "shapes [3, 4] and [5]"
        val a = [3, 4]
        val b = [5]
        When "broadcasting shapes"
        val result = broadcast_shapes(a, b)
        Then "it should return error"
        sspec.expect(result.is_err()).to_be_true()

    Scenario "Broadcast [256, 256, 3] and [3]":
        Given "image shape and color channel"
        val a = [256, 256, 3]
        val b = [3]
        When "broadcasting shapes"
        val result = broadcast_shapes(a, b)
        Then "result should be [256, 256, 3]"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([256, 256, 3])

Feature "Broadcast Strides":

    Scenario "Compute broadcast strides - same shape":
        Given "shape [3, 4] broadcasting to [3, 4]"
        val shape = [3, 4]
        val target = [3, 4]
        When "computing broadcast strides"
        val strides = compute_broadcast_strides(shape, target)
        Then "strides should be [4, 1] (normal)"
        sspec.expect(strides).to_equal([4, 1])

    Scenario "Compute broadcast strides - with broadcasting":
        Given "shape [1, 4] broadcasting to [3, 4]"
        val shape = [1, 4]
        val target = [3, 4]
        When "computing broadcast strides"
        val strides = compute_broadcast_strides(shape, target)
        Then "first stride should be 0 (broadcast)"
        sspec.expect(strides[0]).to_equal(0)
        And "second stride should be 1"
        sspec.expect(strides[1]).to_equal(1)

    Scenario "Compute broadcast strides - scalar to vector":
        Given "shape [] broadcasting to [5]"
        val shape = []
        val target = [5]
        When "computing broadcast strides"
        val strides = compute_broadcast_strides(shape, target)
        Then "stride should be [0] (broadcast all)"
        sspec.expect(strides).to_equal([0])

Feature "Can Broadcast To":

    Scenario "Can broadcast smaller to larger":
        Given "shape [1, 5] and target [3, 5]"
        val shape = [1, 5]
        val target = [3, 5]
        When "checking if can broadcast"
        val can = can_broadcast_to(shape, target)
        Then "it should return true"
        sspec.expect(can).to_be_true()

    Scenario "Cannot broadcast incompatible":
        Given "shape [3, 4] and target [3, 5]"
        val shape = [3, 4]
        val target = [3, 5]
        When "checking if can broadcast"
        val can = can_broadcast_to(shape, target)
        Then "it should return false"
        sspec.expect(can).to_be_false()

    Scenario "Can broadcast scalar to anything":
        Given "empty shape and target [2, 3, 4]"
        val shape = []
        val target = [2, 3, 4]
        When "checking if can broadcast"
        val can = can_broadcast_to(shape, target)
        Then "it should return true"
        sspec.expect(can).to_be_true()

Feature "Shape Properties":

    Scenario "Compute shape size":
        Given "a shape [2, 3, 4]"
        val shape = [2, 3, 4]
        When "computing size"
        val size = shape_size(shape)
        Then "size should be 24"
        sspec.expect(size).to_equal(24)

    Scenario "Empty shape is scalar":
        Given "an empty shape"
        val shape = []
        When "checking if scalar"
        val scalar = is_scalar(shape)
        Then "it should be scalar"
        sspec.expect(scalar).to_be_true()

    Scenario "1D shape is vector":
        Given "a 1D shape [5]"
        val shape = [5]
        When "checking if vector"
        val vec = is_vector(shape)
        Then "it should be vector"
        sspec.expect(vec).to_be_true()

    Scenario "2D shape is matrix":
        Given "a 2D shape [3, 4]"
        val shape = [3, 4]
        When "checking if matrix"
        val mat = is_matrix(shape)
        Then "it should be matrix"
        sspec.expect(mat).to_be_true()

    Scenario "Get number of dimensions":
        Given "a 3D shape [2, 3, 4]"
        val shape = [2, 3, 4]
        When "getting ndim"
        val nd = ndim(shape)
        Then "it should be 3"
        sspec.expect(nd).to_equal(3)

Feature "Broadcast Multiple Shapes":

    Scenario "Broadcast empty list":
        Given "an empty list of shapes"
        val shapes = []
        When "broadcasting many"
        val result = broadcast_shapes_many(shapes)
        Then "result should be empty shape"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([])

    Scenario "Broadcast single shape":
        Given "a single shape [3, 4]"
        val shapes = [[3, 4]]
        When "broadcasting many"
        val result = broadcast_shapes_many(shapes)
        Then "result should be [3, 4]"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([3, 4])

    Scenario "Broadcast three compatible shapes":
        Given "shapes [3, 1, 5], [1, 4, 5], [3, 4, 1]"
        val shapes = [[3, 1, 5], [1, 4, 5], [3, 4, 1]]
        When "broadcasting many"
        val result = broadcast_shapes_many(shapes)
        Then "result should be [3, 4, 5]"
        sspec.expect(result.is_ok()).to_be_true()
        sspec.expect(result.unwrap()).to_equal([3, 4, 5])

    Scenario "Broadcast incompatible shapes":
        Given "shapes [3, 4] and [5, 6]"
        val shapes = [[3, 4], [5, 6]]
        When "broadcasting many"
        val result = broadcast_shapes_many(shapes)
        Then "it should return error"
        sspec.expect(result.is_err()).to_be_true()

    Scenario "Check all compatible - true":
        Given "compatible shapes"
        val shapes = [[1, 5], [3, 1], [3, 5]]
        When "checking all compatible"
        val compat = all_broadcast_compatible(shapes)
        Then "it should return true"
        sspec.expect(compat).to_be_true()

    Scenario "Check all compatible - false":
        Given "incompatible shapes"
        val shapes = [[3, 4], [5, 6]]
        When "checking all compatible"
        val compat = all_broadcast_compatible(shapes)
        Then "it should return false"
        sspec.expect(compat).to_be_false()

Feature "Index Operations":

    Scenario "Ravel 2D index":
        Given "indices [1, 2] and strides [4, 1]"
        val indices = [1, 2]
        val strides = [4, 1]
        When "raveling to flat index"
        val flat = ravel_index(indices, strides)
        Then "flat index should be 6 (1*4 + 2*1)"
        sspec.expect(flat).to_equal(6)

    Scenario "Ravel 3D index":
        Given "indices [1, 2, 3] and strides [12, 4, 1]"
        val indices = [1, 2, 3]
        val strides = [12, 4, 1]
        When "raveling to flat index"
        val flat = ravel_index(indices, strides)
        Then "flat index should be 23 (1*12 + 2*4 + 3*1)"
        sspec.expect(flat).to_equal(23)

    Scenario "Unravel flat index":
        Given "flat index 23 and strides [12, 4, 1]"
        val flat = 23
        val strides = [12, 4, 1]
        When "unraveling to multi-dimensional"
        val indices = unravel_index(flat, strides)
        Then "indices should be [1, 2, 3]"
        sspec.expect(indices).to_equal([1, 2, 3])

    Scenario "Ravel and unravel round-trip":
        Given "original indices [2, 1, 3] and strides [12, 4, 1]"
        val original = [2, 1, 3]
        val strides = [12, 4, 1]
        When "raveling then unraveling"
        val flat = ravel_index(original, strides)
        val recovered = unravel_index(flat, strides)
        Then "should recover original indices"
        sspec.expect(recovered).to_equal(original)
