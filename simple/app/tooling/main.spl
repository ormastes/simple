# Multi-Language Tooling CLI
# Build, test, and deploy multi-language projects
#
# Usage:
#   simple tooling build [options]
#   simple tooling test [options]
#   simple tooling deploy [options]
#   simple tooling watch [options]

use std.io
use std.args
use std.sys
use tooling.*
use tooling.compiler.{LanguageCompiler, CompilationMode}
use tooling.testing.{TestRunner, TestConfig}
use tooling.deployment.{DeploymentPipeline, Environment}
use tooling.watch.{Watcher, HMRServer}

# Main entry point
fn main():
    args = args.get_args()

    if args.len() < 2:
        print_usage()
        sys.exit(1)

    command = args[1]

    match command:
        "build" -> handle_build(args[2:])
        "test" -> handle_test(args[2:])
        "deploy" -> handle_deploy(args[2:])
        "watch" -> handle_watch(args[2:])
        "help" -> print_usage()
        _ ->
            io.eprintln("Unknown command: {command}")
            print_usage()
            sys.exit(1)

# Handle build command
fn handle_build(args: List[String]):
    """Build multi-language project.

    Options:
      --incremental    Use incremental compilation
      --parallel       Build in parallel
      --release        Build in release mode
      --language LANG  Build specific language only
      --verbose        Verbose output
    """
    # Parse options
    incremental = "--incremental" in args
    parallel = "--parallel" in args
    release = "--release" in args
    verbose = "--verbose" in args

    # Get language filter if specified
    language_filter = None
    if "--language" in args:
        idx = args.index("--language")
        if idx + 1 < args.len():
            language_filter = args[idx + 1]

    # Detect project
    project = ProjectDetector.detect_from_cwd()
    match project:
        Ok(proj) ->
            io.println("Building {proj.name}...")
            io.println("Languages: {', '.join([lang.to_string() for lang in proj.languages])}")

            # Create build system
            build_system = BuildSystem.new(proj)

            # Configure compilation
            mode = CompilationMode.Release if release else CompilationMode.Debug

            # Filter languages if specified
            languages = proj.languages
            if language_filter:
                languages = [lang for lang in languages if lang.to_string() == language_filter]

            # Build each language
            results = []
            for lang in languages:
                io.println("\nBuilding {lang.to_string()}...")

                config = proj.get_language_config(lang)
                compiler = build_system.get_compiler(lang)

                result = compiler.compile(config, mode, incremental)
                results.append(result)

                match result.status:
                    "success" ->
                        io.println("✓ {lang.to_string()} built successfully")
                        if verbose:
                            io.println("  Output: {result.output_path}")
                            io.println("  Duration: {result.duration_ms}ms")
                    "error" ->
                        io.eprintln("✗ {lang.to_string()} build failed:")
                        for error in result.errors:
                            io.eprintln("  {error}")
                    _ ->
                        io.println("⚠ {lang.to_string()} build skipped")

            # Summary
            success_count = sum([1 for r in results if r.status == "success"])
            total = results.len()

            io.println("\nBuild Summary: {success_count}/{total} succeeded")

            if success_count < total:
                sys.exit(1)

        Err(error) ->
            io.eprintln("Failed to detect project: {error}")
            sys.exit(1)

# Handle test command
fn handle_test(args: List[String]):
    """Run tests across all languages.

    Options:
      --parallel       Run tests in parallel
      --fail-fast      Stop on first failure
      --verbose        Verbose output
      --coverage       Generate coverage report
      --filter PATTERN Filter tests by pattern
      --timeout SECS   Test timeout in seconds
    """
    # Parse options
    parallel = "--parallel" in args
    fail_fast = "--fail-fast" in args
    verbose = "--verbose" in args
    coverage = "--coverage" in args

    # Get filter pattern if specified
    filter_pattern = ""
    if "--filter" in args:
        idx = args.index("--filter")
        if idx + 1 < args.len():
            filter_pattern = args[idx + 1]

    # Get timeout if specified
    timeout = 300  # Default 5 minutes
    if "--timeout" in args:
        idx = args.index("--timeout")
        if idx + 1 < args.len():
            timeout = int(args[idx + 1])

    # Detect project
    project = ProjectDetector.detect_from_cwd()
    match project:
        Ok(proj) ->
            io.println("Running tests for {proj.name}...")

            # Create test runner
            runner = TestRunner.new(proj)

            # Configure test run
            config = TestConfig {
                parallel: parallel,
                fail_fast: fail_fast,
                verbose: verbose,
                coverage: coverage,
                timeout_seconds: timeout,
                filter_pattern: filter_pattern
            }

            # Discover tests
            io.println("Discovering tests...")
            discovery = runner.discover()
            io.println("Found {discovery.total_tests} tests across {discovery.suites.len()} suites")

            # Run tests
            io.println("\nRunning tests...")
            result = runner.run_with_config(config)

            # Display results
            io.println("\n{result.summary()}")

            if verbose and result.failures.len() > 0:
                io.println("\nFailures:")
                for failure in result.failures:
                    io.println("\n  {failure.test_name} ({failure.language.to_string()}):")
                    io.println("    {failure.file}:{failure.line}")
                    io.println("    {failure.error_message}")

            # Generate coverage report if requested
            if coverage:
                io.println("\nGenerating coverage report...")
                coverage_report = runner.get_coverage()
                io.println("Coverage: {coverage_report.percentage}%")
                io.println("Report saved to: {coverage_report.output_path}")

            if not result.is_success():
                sys.exit(1)

        Err(error) ->
            io.eprintln("Failed to detect project: {error}")
            sys.exit(1)

# Handle deploy command
fn handle_deploy(args: List[String]):
    """Deploy multi-language project.

    Options:
      --env ENV        Deployment environment (dev/staging/prod)
      --strategy STRAT Deployment strategy (blue-green/canary/rolling)
      --dry-run        Show what would be deployed
      --verbose        Verbose output
    """
    # Parse options
    dry_run = "--dry-run" in args
    verbose = "--verbose" in args

    # Get environment
    env = Environment.Production
    if "--env" in args:
        idx = args.index("--env")
        if idx + 1 < args.len():
            env_str = args[idx + 1]
            env = match env_str:
                "dev" -> Environment.Development
                "staging" -> Environment.Staging
                "prod" -> Environment.Production
                _ -> Environment.Custom(env_str)

    # Detect project
    project = ProjectDetector.detect_from_cwd()
    match project:
        Ok(proj) ->
            io.println("Deploying {proj.name} to {env.to_string()}...")

            if dry_run:
                io.println("DRY RUN - No actual deployment will occur")

            # Create deployment pipeline
            pipeline = DeploymentPipeline.new(proj, env)

            # Add standard stages
            pipeline.add_stage("build", () -> {
                io.println("  Building artifacts...")
                Ok(())
            })

            pipeline.add_stage("test", () -> {
                io.println("  Running tests...")
                Ok(())
            })

            pipeline.add_stage("package", () -> {
                io.println("  Packaging artifacts...")
                Ok(())
            })

            pipeline.add_stage("deploy", () -> {
                if dry_run:
                    io.println("  [DRY RUN] Would deploy artifacts")
                    Ok(())
                else:
                    io.println("  Deploying artifacts...")
                    Ok(())
            })

            # Execute pipeline
            result = pipeline.execute()

            # Display result
            if result.success:
                io.println("\n✓ Deployment completed successfully in {result.duration_ms}ms")
                io.println("  Stages completed: {result.stages_completed}")
            else:
                io.eprintln("\n✗ Deployment failed: {result.error_message}")
                io.eprintln("  Stages completed: {result.stages_completed}")
                io.eprintln("  Stages failed: {result.stages_failed}")
                sys.exit(1)

        Err(error) ->
            io.eprintln("Failed to detect project: {error}")
            sys.exit(1)

# Handle watch command
fn handle_watch(args: List[String]):
    """Watch for changes and rebuild/test automatically.

    Options:
      --test           Run tests after rebuild
      --hot-reload     Enable hot module replacement
      --port PORT      HMR server port (default: 5173)
      --verbose        Verbose output
    """
    # Parse options
    run_tests = "--test" in args
    hot_reload = "--hot-reload" in args
    verbose = "--verbose" in args

    # Get HMR port
    hmr_port = 5173
    if "--port" in args:
        idx = args.index("--port")
        if idx + 1 < args.len():
            hmr_port = int(args[idx + 1])

    # Detect project
    project = ProjectDetector.detect_from_cwd()
    match project:
        Ok(proj) ->
            io.println("Watching {proj.name} for changes...")
            io.println("Press Ctrl+C to stop")

            # Create watcher
            watcher = Watcher.new(proj.root_path)

            # Start HMR server if requested
            hmr_server = None
            if hot_reload:
                io.println("Starting HMR server on port {hmr_port}...")
                hmr_server = HMRServer.new(hmr_port)
                hmr_server.start()

            # Set up change handler
            watcher.on_change((changed_files) -> {
                io.println("\nDetected changes in {changed_files.len()} file(s)")

                # Rebuild
                io.println("Rebuilding...")
                build_system = BuildSystem.new(proj)

                # Build affected languages only
                affected_languages = build_system.get_affected_languages(changed_files)

                all_success = true
                for lang in affected_languages:
                    config = proj.get_language_config(lang)
                    compiler = build_system.get_compiler(lang)
                    result = compiler.compile(config, CompilationMode.Debug, true)

                    if result.status == "success":
                        io.println("✓ {lang.to_string()} rebuilt")
                    else:
                        io.eprintln("✗ {lang.to_string()} build failed")
                        all_success = false

                # Run tests if requested and build succeeded
                if run_tests and all_success:
                    io.println("\nRunning tests...")
                    runner = TestRunner.new(proj)
                    config = TestConfig.new()
                    result = runner.run_with_config(config)
                    io.println(result.summary())

                # Notify HMR clients if enabled
                if hot_reload and all_success and hmr_server:
                    hmr_server.notify_clients(changed_files)
                    io.println("Hot reload triggered")
            })

            # Start watching
            watcher.start()

        Err(error) ->
            io.eprintln("Failed to detect project: {error}")
            sys.exit(1)

# Print usage information
fn print_usage():
    io.println("""
Simple Multi-Language Tooling CLI

USAGE:
    simple tooling <COMMAND> [OPTIONS]

COMMANDS:
    build     Build multi-language project
    test      Run tests across all languages
    deploy    Deploy multi-language project
    watch     Watch for changes and rebuild
    help      Show this help message

BUILD OPTIONS:
    --incremental       Use incremental compilation
    --parallel          Build in parallel
    --release           Build in release mode
    --language LANG     Build specific language only
    --verbose           Verbose output

TEST OPTIONS:
    --parallel          Run tests in parallel
    --fail-fast         Stop on first failure
    --verbose           Verbose output
    --coverage          Generate coverage report
    --filter PATTERN    Filter tests by pattern
    --timeout SECS      Test timeout in seconds

DEPLOY OPTIONS:
    --env ENV           Deployment environment (dev/staging/prod)
    --strategy STRAT    Deployment strategy
    --dry-run           Show what would be deployed
    --verbose           Verbose output

WATCH OPTIONS:
    --test              Run tests after rebuild
    --hot-reload        Enable hot module replacement
    --port PORT         HMR server port (default: 5173)
    --verbose           Verbose output

EXAMPLES:
    # Build all languages incrementally
    simple tooling build --incremental --parallel

    # Run tests with coverage
    simple tooling test --coverage --verbose

    # Deploy to staging
    simple tooling deploy --env staging

    # Watch and test on changes
    simple tooling watch --test --verbose

For more information, see: doc/plans/MULTI_LANGUAGE_TOOLING_PLAN.md
""")
