# Language Model Server (LMS) - Main Entry Point
# Provides MCP (Model Context Protocol) server for AI assistants

import std.args
import web.http.server.{HttpServer, HttpRequest, HttpResponse, HttpHandler}
import core.json.{Json, JsonValue}

# Server configuration
val DEFAULT_PORT: u16 = 8765
val SERVER_NAME = "Simple LMS"
val SERVER_VERSION = "0.1.0"

fn print_help():
    print("Simple Language Model Server (LMS)")
    print("Usage: lms [OPTIONS]")
    print("")
    print("Options:")
    print("  --help         Show this help message")
    print("  --version      Show version information")
    print("  --port <PORT>  Set server port (default: {DEFAULT_PORT})")
    print("")
    print("The LMS server provides MCP protocol support for:")
    print("  - Code completion and analysis")
    print("  - Symbol lookup and navigation")
    print("  - Documentation generation")

fn print_version():
    print("{SERVER_NAME} v{SERVER_VERSION}")

# MCP Protocol handler
class McpHandler:
    fn handle_request(request: HttpRequest) -> HttpResponse:
        val method = request.method
        val path = request.path

        # Health check endpoint
        if path == "/health":
            return HttpResponse::ok()
                .json(Json::object([
                    ("status", Json::string("ok")),
                    ("server", Json::string(SERVER_NAME)),
                    ("version", Json::string(SERVER_VERSION))
                ]))

        # MCP initialize endpoint
        if path == "/mcp/initialize" and method == "POST":
            return handle_initialize(request)

        # MCP tools/list endpoint
        if path == "/mcp/tools/list":
            return handle_tools_list()

        # MCP tools/call endpoint
        if path == "/mcp/tools/call" and method == "POST":
            return handle_tool_call(request)

        # MCP resources/list endpoint
        if path == "/mcp/resources/list":
            return handle_resources_list()

        # Not found
        return HttpResponse::not_found()
            .json(Json::object([
                ("error", Json::string("Not found")),
                ("path", Json::string(path))
            ]))

fn handle_initialize(request: HttpRequest) -> HttpResponse:
    # Parse client capabilities from request body
    val body = request.body_json()

    # Return server capabilities
    return HttpResponse::ok()
        .json(Json::object([
            ("protocolVersion", Json::string("2024-11-05")),
            ("serverInfo", Json::object([
                ("name", Json::string(SERVER_NAME)),
                ("version", Json::string(SERVER_VERSION))
            ])),
            ("capabilities", Json::object([
                ("tools", Json::object([])),
                ("resources", Json::object([
                    ("subscribe", Json::bool(false)),
                    ("listChanged", Json::bool(false))
                ]))
            ]))
        ]))

fn handle_tools_list() -> HttpResponse:
    # Return available tools
    val tools = [
        Json::object([
            ("name", Json::string("analyze_code")),
            ("description", Json::string("Analyze Simple language code for errors and suggestions")),
            ("inputSchema", Json::object([
                ("type", Json::string("object")),
                ("properties", Json::object([
                    ("code", Json::object([
                        ("type", Json::string("string")),
                        ("description", Json::string("The code to analyze"))
                    ]))
                ])),
                ("required", Json::array([Json::string("code")]))
            ]))
        ]),
        Json::object([
            ("name", Json::string("get_symbols")),
            ("description", Json::string("Get symbols defined in a file")),
            ("inputSchema", Json::object([
                ("type", Json::string("object")),
                ("properties", Json::object([
                    ("path", Json::object([
                        ("type", Json::string("string")),
                        ("description", Json::string("Path to the file"))
                    ]))
                ])),
                ("required", Json::array([Json::string("path")]))
            ]))
        ])
    ]

    return HttpResponse::ok()
        .json(Json::object([
            ("tools", Json::array(tools))
        ]))

fn handle_tool_call(request: HttpRequest) -> HttpResponse:
    val body = request.body_json()

    match body.get("name"):
        case Some(Json::String(name)):
            val args = body.get("arguments").unwrap_or(Json::object([]))

            if name == "analyze_code":
                return call_analyze_code(args)
            else if name == "get_symbols":
                return call_get_symbols(args)
            else:
                return HttpResponse::bad_request()
                    .json(Json::object([
                        ("error", Json::string("Unknown tool: {name}"))
                    ]))
        case _:
            return HttpResponse::bad_request()
                .json(Json::object([
                    ("error", Json::string("Missing tool name"))
                ]))

fn call_analyze_code(args: JsonValue) -> HttpResponse:
    val code = match args.get("code"):
        case Some(Json::String(c)): c
        case _: return HttpResponse::bad_request()
            .json(Json::object([("error", Json::string("Missing 'code' argument"))]))

    # Simple analysis - check for common issues
    var issues: List<JsonValue> = []

    if code.contains("var ") and not code.contains("val "):
        issues.push(Json::object([
            ("type", Json::string("suggestion")),
            ("message", Json::string("Consider using 'val' for immutable bindings"))
        ]))

    if code.contains("TODO"):
        issues.push(Json::object([
            ("type", Json::string("info")),
            ("message", Json::string("Found TODO comment"))
        ]))

    return HttpResponse::ok()
        .json(Json::object([
            ("content", Json::array([
                Json::object([
                    ("type", Json::string("text")),
                    ("text", Json::string("Analysis complete. Found {issues.len()} items."))
                ])
            ])),
            ("issues", Json::array(issues))
        ]))

fn call_get_symbols(args: JsonValue) -> HttpResponse:
    val path = match args.get("path"):
        case Some(Json::String(p)): p
        case _: return HttpResponse::bad_request()
            .json(Json::object([("error", Json::string("Missing 'path' argument"))]))

    # Return placeholder symbols
    return HttpResponse::ok()
        .json(Json::object([
            ("content", Json::array([
                Json::object([
                    ("type", Json::string("text")),
                    ("text", Json::string("Symbols in {path}"))
                ])
            ])),
            ("symbols", Json::array([]))
        ]))

fn handle_resources_list() -> HttpResponse:
    return HttpResponse::ok()
        .json(Json::object([
            ("resources", Json::array([]))
        ]))

fn main():
    val argv = args.get_args()
    var port = DEFAULT_PORT

    # Parse arguments
    var i = 0
    while i < argv.len():
        val arg = argv[i]
        if arg == "--help":
            print_help()
            return
        else if arg == "--version":
            print_version()
            return
        else if arg == "--port":
            if i + 1 < argv.len():
                i = i + 1
                port = argv[i].parse_int().unwrap_or(DEFAULT_PORT) as u16
            else:
                print("Error: --port requires a value")
                return
        i = i + 1

    # Create and start server
    print("{SERVER_NAME} v{SERVER_VERSION}")
    print("Starting server on port {port}...")

    val handler = McpHandler()
    val server = HttpServer::localhost(port)
        .handler(|req| handler.handle_request(req))

    print("Server running at http://localhost:{port}")
    print("Press Ctrl+C to stop")

    server.run()
