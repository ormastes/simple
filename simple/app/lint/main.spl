# Simple Language Linter
# Semantic lints for code quality and safety
# Usage: simple_lint <file.spl> [--deny-all] [--warn-all]

# Native file I/O functions
extern fn native_fs_read_string(path: String) -> Any
extern fn native_fs_exists(path: String) -> Bool
extern fn sys_get_args() -> List[String]

# Async file I/O wrapper
async fn read_file(path: String) -> Result[String, String]:
    let file_content = native_fs_read_string(path)
    match file_content:
        case Ok(content):
            return Ok(content)
        case Err(e):
            return Err("Failed to read: " + e.to_string())

# Lint levels
enum LintLevel:
    Allow
    Warn
    Deny

# Lint categories
enum LintCategory:
    Safety      # Memory safety, null checks
    Correctness # Logic errors, type mismatches
    Warning     # Potential issues
    Style       # Code style recommendations
    Concurrency # Concurrency-related issues

class Lint:
    code: String
    level: LintLevel
    category: LintCategory
    message: String
    fix_hint: Option[String]
    
    fn new(code: String, level: LintLevel, category: LintCategory, message: String) -> Lint:
        Lint(
            code: code,
            level: level,
            category: category,
            message: message,
            fix_hint: None
        )
    
    fn with_fix(self, hint: String) -> Lint:
        Lint(
            code: self.code,
            level: self.level,
            category: self.category,
            message: self.message,
            fix_hint: Some(hint)
        )

class LintResult:
    file_path: String
    line: Int
    column: Int
    lint: Lint
    
    fn new(file_path: String, line: Int, column: Int, lint: Lint) -> LintResult:
        LintResult(
            file_path: file_path,
            line: line,
            column: column,
            lint: lint
        )
    
    fn format(self) -> String:
        let mut level_str = "unknown"
        match self.lint.level:
            case Allow:
                level_str = "allow"
            case Warn:
                level_str = "warning"
            case Deny:
                level_str = "error"

        let mut output = self.file_path + ":" + self.line.to_string() + ":" + self.column.to_string() + ": " + level_str + "[" + self.lint.code + "]: " + self.lint.message

        match self.lint.fix_hint:
            case Some(hint):
                output = output + "\n  hint: " + hint
            case None:
                let _ = 0

        return output

class Linter:
    lints: List[Lint]
    results: List[LintResult]
    
    fn new() -> Linter:
        let mut lints = []
        
        # Safety lints
        lints.push(Lint.new("S001", LintLevel.Deny, LintCategory.Safety, 
            "Unused Result type (must use .unwrap(), .expect(), or match)"))
        lints.push(Lint.new("S002", LintLevel.Deny, LintCategory.Safety,
            "Potential null pointer dereference"))
        lints.push(Lint.new("S003", LintLevel.Warn, LintCategory.Safety,
            "Unsafe block without safety comment"))
        
        # Correctness lints
        lints.push(Lint.new("C001", LintLevel.Deny, LintCategory.Correctness,
            "Unreachable code after return/break/continue"))
        lints.push(Lint.new("C002", LintLevel.Warn, LintCategory.Correctness,
            "Non-exhaustive match (add catch-all case)"))
        lints.push(Lint.new("C003", LintLevel.Warn, LintCategory.Correctness,
            "Comparison of incompatible types"))
        
        # Warning lints
        lints.push(Lint.new("W001", LintLevel.Warn, LintCategory.Warning,
            "Unused variable (prefix with _ to silence)"))
        lints.push(Lint.new("W002", LintLevel.Warn, LintCategory.Warning,
            "Unused import"))
        lints.push(Lint.new("W003", LintLevel.Warn, LintCategory.Warning,
            "Dead code"))
        
        # Style lints
        lints.push(Lint.new("ST001", LintLevel.Allow, LintCategory.Style,
            "Function name should be snake_case"))
        lints.push(Lint.new("ST002", LintLevel.Allow, LintCategory.Style,
            "Class name should be PascalCase"))
        lints.push(Lint.new("ST003", LintLevel.Allow, LintCategory.Style,
            "Constant should be UPPER_SNAKE_CASE"))
        
        # Concurrency lints
        lints.push(Lint.new("CC001", LintLevel.Deny, LintCategory.Concurrency,
            "Shared mutable state without synchronization"))
        lints.push(Lint.new("CC002", LintLevel.Warn, LintCategory.Concurrency,
            "Send type used without thread safety guarantee"))
        
        Linter(lints: lints, results: [])
    
    async fn lint_file(self, path: String) -> Result[List[LintResult], String]:
        # Read file using async file I/O
        let file_content = await read_file(path)
        match file_content:
            case Err(e):
                return Err(e)
            case Ok(content):
                # Run simple pattern-based lints
                # TODO: Use AST-based linting when compiler integration is available
                let lines = content.split("\n")
                let mut line_num = 1

                for line in lines:
                    self.check_line(path, line_num, line)
                    line_num = line_num + 1

                return Ok(self.results)
    
    fn check_line(self, path: String, line_num: Int, line: String):
        let trimmed = line.trim()
        
        # Check for unused variables (simple heuristic)
        if trimmed.starts_with("let ") and not trimmed.contains("="):
            let lint = Lint.new("W001", LintLevel.Warn, LintCategory.Warning,
                "Variable declared but never assigned")
                .with_fix("Remove declaration or assign a value")
            self.results.push(LintResult.new(path, line_num, 0, lint))
        
        # Check for unreachable code
        if trimmed.starts_with("return "):
            # Next non-empty line after return is potentially unreachable
            # (This is oversimplified - needs proper control flow analysis)
            let _ = 0
        
        # Check naming conventions (if enabled)
        if trimmed.starts_with("fn "):
            let fn_name = self.extract_function_name(trimmed)
            if not self.is_snake_case(fn_name):
                let lint = Lint.new("ST001", LintLevel.Allow, LintCategory.Style,
                    "Function name '{fn_name}' should be snake_case")
                    .with_fix("Rename to '{self.to_snake_case(fn_name)}'")
                self.results.push(LintResult.new(path, line_num, 0, lint))
        
        if trimmed.starts_with("class "):
            let class_name = self.extract_class_name(trimmed)
            if not self.is_pascal_case(class_name):
                let lint = Lint.new("ST002", LintLevel.Allow, LintCategory.Style,
                    "Class name '{class_name}' should be PascalCase")
                self.results.push(LintResult.new(path, line_num, 0, lint))
    
    fn extract_function_name(self, line: String) -> String:
        # Extract function name from "fn name(...)" pattern
        let parts = line.split("(")
        if parts.len() > 0:
            let name_part = parts[0].replace("fn ", "").trim()
            return name_part
        ""
    
    fn extract_class_name(self, line: String) -> String:
        # Extract class name from "class Name:" pattern
        let parts = line.replace("class ", "").split(":")
        if parts.len() > 0:
            return parts[0].trim()
        ""
    
    fn is_snake_case(self, name: String) -> Bool:
        # Simple check: lowercase with underscores
        name == name.to_lowercase() and not name.contains("-")
    
    fn is_pascal_case(self, name: String) -> Bool:
        # Simple check: starts with uppercase
        if name.is_empty():
            return false
        let first_char = name.chars().first()
        match first_char:
            case Some(c): c.is_uppercase()
            case None: false
    
    fn to_snake_case(self, name: String) -> String:
        # Convert to snake_case (simplified)
        name.to_lowercase()

async fn main() -> Int:
    let args = sys_get_args()

    if args.len() < 2:
        print("Usage: simple_lint <file.spl> [options]")
        print("")
        print("Options:")
        print("  --deny-all   Treat all warnings as errors")
        print("  --warn-all   Enable all style lints")
        print("  --json       Output in JSON format")
        print("")
        print("Lint categories:")
        print("  Safety (S): Memory safety and null checks")
        print("  Correctness (C): Logic errors")
        print("  Warning (W): Potential issues")
        print("  Style (ST): Code style")
        print("  Concurrency (CC): Thread safety")
        return 1

    let file_path = args[1]
    let deny_all = args.contains("--deny-all")

    # Verify file exists
    if not native_fs_exists(file_path):
        print("Error: File not found: " + file_path)
        return 1

    # Run linter
    let linter = Linter.new()

    let lint_result = await linter.lint_file(file_path)
    match lint_result:
        case Ok(results):
            if results.is_empty():
                print("No issues found in " + file_path)
                return 0
            else:
                let mut error_count = 0
                let mut warning_count = 0

                for lint_item in results:
                    print(lint_item.format())

                    match lint_item.lint.level:
                        case Deny:
                            error_count = error_count + 1
                        case Warn:
                            warning_count = warning_count + 1
                            if deny_all:
                                error_count = error_count + 1
                        case Allow:
                            let _ = 0

                print("")
                print("Found " + error_count.to_string() + " error(s) and " + warning_count.to_string() + " warning(s)")

                if error_count > 0:
                    return 1
                else:
                    return 0

        case Err(error):
            print("Error: " + error)
            return 1

    return 0
