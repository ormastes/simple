# Dependency Graph Generator - Directory Scanner Module
# Scans directories for .spl files and identifies child modules

# Native file system functions
extern fn native_fs_read_dir(path: String) -> Any
extern fn native_fs_exists(path: String) -> Bool

# Helper to check if path is a directory
# A path is a directory if read_dir succeeds on it
fn is_directory(path: String) -> Bool:
    let result = native_fs_read_dir(path)
    match result:
        case Ok(_):
            return true
        case Err(_):
            return false

# Helper to join paths
fn path_join(base: String, child: String) -> String:
    if base.ends_with("/"):
        return base + child
    return base + "/" + child

# File info structure
class FileInfo:
    path: String
    name: String
    is_directory: Bool

    fn new(path: String, name: String, is_directory: Bool) -> FileInfo:
        return FileInfo(path: path, name: name, is_directory: is_directory)

# Scan result structure
class ScanResult:
    directory: String
    spl_files: List[String]
    child_dirs: List[String]
    has_init: Bool

    fn new(directory: String) -> ScanResult:
        return ScanResult(
            directory: directory,
            spl_files: [],
            child_dirs: [],
            has_init: false
        )

# Check if file is a valid .spl source file (not generated)
fn is_source_file(name: String) -> Bool:
    # Must end with .spl
    if not name.ends_with(".spl"):
        return false
    # Exclude dot-prefixed files (generated)
    if name.starts_with("."):
        return false
    # Exclude __init__.spl (manifest, not module)
    if name == "__init__.spl":
        return false
    return true

# Check if directory is a valid module directory
fn is_module_dir(dir_path: String) -> Bool:
    let init_path = path_join(dir_path, "__init__.spl")
    return native_fs_exists(init_path)

# Get module name from file name (strip .spl extension)
pub fn get_module_name(file_name: String) -> String:
    if file_name.ends_with(".spl"):
        return file_name.substring(0, file_name.len() - 4)
    return file_name

# Scan a single directory for .spl files and child directories
pub fn scan_directory(dir_path: String, recursive: Bool) -> Result[ScanResult, String]:
    if not native_fs_exists(dir_path):
        return Err("Directory not found: {dir_path}")

    if not is_directory(dir_path):
        return Err("Not a directory: {dir_path}")

    # Check if this directory has __init__.spl
    let init_path = path_join(dir_path, "__init__.spl")
    let has_init = native_fs_exists(init_path)

    # Use local lists for collecting results
    let mut spl_files: List[String] = []
    let mut child_dirs: List[String] = []

    # Read directory contents
    let entries = native_fs_read_dir(dir_path)
    match entries:
        case Err(e):
            return Err("Failed to read directory: {e}")
        case Ok(dir_result):
            for entry in dir_result.entries:
                let name = entry.name
                let full_path = path_join(dir_path, name)

                # Check if entry is a directory by trying to read it
                if is_directory(full_path):
                    # Check if child directory is a module
                    if is_module_dir(full_path):
                        child_dirs.push(name)
                else:
                    # Check if it's a source .spl file
                    if is_source_file(name):
                        spl_files.push(name)

    # Construct result - use the same pattern as new()
    let mut result = ScanResult.new(dir_path)
    result.spl_files = spl_files
    result.child_dirs = child_dirs
    result.has_init = has_init
    return Ok(result)

# Scan directory tree recursively
pub fn scan_tree(dir_path: String) -> Result[List[ScanResult], String]:
    let results: List[ScanResult] = []

    # Scan root directory
    let root_result = scan_directory(dir_path, true)
    match root_result:
        case Err(e):
            return Err(e)
        case Ok(result):
            results.push(result)

            # Recursively scan child directories
            for child in result.child_dirs:
                let child_path = path_join(dir_path, child)
                let child_results = scan_tree(child_path)
                match child_results:
                    case Err(e):
                        # Log error but continue
                        print("[WARN] Failed to scan {child_path}: {e}")
                    case Ok(sub_results):
                        for sub in sub_results:
                            results.push(sub)

    return Ok(results)

# Get list of module names from scan result
pub fn get_module_names(scan: ScanResult) -> List[String]:
    let modules: List[String] = []
    for file in scan.spl_files:
        modules.push(get_module_name(file))
    return modules
