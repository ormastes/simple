# Dependency Graph Generator - Import Parser Module
# Extracts imports from .spl source files

extern fn native_fs_read_string(path: String) -> Any

# Import types
enum ImportKind:
    Use           # Regular use
    ExportUse     # export use (re-export)
    CommonUse     # common use (directory prelude)
    TypeUse       # use type (type-only import)

# Single import entry
class ImportEntry:
    path: String           # Full import path e.g. "std.io"
    alias: Option[String]  # Optional alias e.g. "io"
    kind: ImportKind       # Type of import
    is_glob: Bool          # Is this a glob import (*)
    line_number: Int       # Source line number

    fn new(path: String, kind: ImportKind) -> ImportEntry:
        return ImportEntry(
            path: path,
            alias: None,
            kind: kind,
            is_glob: false,
            line_number: 0
        )

    fn with_alias(self, alias: String) -> ImportEntry:
        return ImportEntry(
            path: self.path,
            alias: Some(alias),
            kind: self.kind,
            is_glob: self.is_glob,
            line_number: self.line_number
        )

    fn with_glob(self) -> ImportEntry:
        return ImportEntry(
            path: self.path,
            alias: self.alias,
            kind: self.kind,
            is_glob: true,
            line_number: self.line_number
        )

    fn with_line(self, line: Int) -> ImportEntry:
        return ImportEntry(
            path: self.path,
            alias: self.alias,
            kind: self.kind,
            is_glob: self.is_glob,
            line_number: line
        )

# Module declaration entry
class ModDeclEntry:
    name: String
    is_public: Bool
    line_number: Int

    fn new(name: String, is_public: Bool) -> ModDeclEntry:
        return ModDeclEntry(name: name, is_public: is_public, line_number: 0)

# Auto import entry (for macros)
class AutoImportEntry:
    path: String
    macro_name: String
    line_number: Int

    fn new(path: String, macro_name: String) -> AutoImportEntry:
        return AutoImportEntry(path: path, macro_name: macro_name, line_number: 0)

# Parse result for a file
class ParseResult:
    file_path: String
    imports: List[ImportEntry]
    exports: List[ImportEntry]
    common_uses: List[ImportEntry]
    mod_decls: List[ModDeclEntry]
    auto_imports: List[AutoImportEntry]
    errors: List[String]

    fn new(file_path: String) -> ParseResult:
        return ParseResult(
            file_path: file_path,
            imports: [],
            exports: [],
            common_uses: [],
            mod_decls: [],
            auto_imports: [],
            errors: []
        )

# Parse a single line for import statement
fn parse_import_line(line: String, line_number: Int) -> Option[ImportEntry]:
    let trimmed = line.trim()

    # Skip empty lines and comments
    if trimmed.is_empty() or trimmed.starts_with("#"):
        return None

    # Check for different import types
    if trimmed.starts_with("use type "):
        let path = trimmed.substring(9, trimmed.len()).trim()
        return Some(parse_import_path(path, ImportKind.TypeUse, line_number))

    if trimmed.starts_with("use "):
        let path = trimmed.substring(4, trimmed.len()).trim()
        return Some(parse_import_path(path, ImportKind.Use, line_number))

    if trimmed.starts_with("export use "):
        let path = trimmed.substring(11, trimmed.len()).trim()
        return Some(parse_import_path(path, ImportKind.ExportUse, line_number))

    if trimmed.starts_with("common use "):
        let path = trimmed.substring(11, trimmed.len()).trim()
        return Some(parse_import_path(path, ImportKind.CommonUse, line_number))

    return None

# Parse import path handling aliases and globs
fn parse_import_path(path: String, kind: ImportKind, line_number: Int) -> ImportEntry:
    let mut entry = ImportEntry.new(path, kind).with_line(line_number)

    # Check for glob
    if path.ends_with(".*"):
        entry = entry.with_glob()
        entry.path = path.substring(0, path.len() - 2)

    # Check for alias (use foo as bar)
    if path.contains(" as "):
        let parts = path.split(" as ")
        if parts.len() == 2:
            entry.path = parts[0].trim()
            entry = entry.with_alias(parts[1].trim())

    return entry

# Parse a line for mod declaration
fn parse_mod_decl(line: String, line_number: Int) -> Option[ModDeclEntry]:
    let trimmed = line.trim()

    # Skip empty lines and comments
    if trimmed.is_empty() or trimmed.starts_with("#"):
        return None

    # Check for pub mod
    if trimmed.starts_with("pub mod "):
        let name = trimmed.substring(8, trimmed.len()).trim()
        let entry = ModDeclEntry.new(name, true)
        entry.line_number = line_number
        return Some(entry)

    # Check for mod (private)
    if trimmed.starts_with("mod "):
        let name = trimmed.substring(4, trimmed.len()).trim()
        let entry = ModDeclEntry.new(name, false)
        entry.line_number = line_number
        return Some(entry)

    return None

# Parse a line for auto import
fn parse_auto_import(line: String, line_number: Int) -> Option[AutoImportEntry]:
    let trimmed = line.trim()

    if trimmed.starts_with("auto import "):
        let path = trimmed.substring(12, trimmed.len()).trim()
        # Extract macro name from path (last segment)
        let parts = path.split(".")
        let macro_name = parts[parts.len() - 1]
        let entry = AutoImportEntry.new(path, macro_name)
        entry.line_number = line_number
        return Some(entry)

    return None

# Parse a source file and extract all imports
pub fn parse_file(file_path: String) -> Result[ParseResult, String]:
    let content = native_fs_read_string(file_path)
    match content:
        case Err(e):
            return Err("Failed to read file: {file_path}: {e}")
        case Ok(source):
            return Ok(parse_source(file_path, source))

# Parse source code string
pub fn parse_source(file_path: String, source: String) -> ParseResult:
    # Use local lists - Simple doesn't mutate class fields in place
    let mut imports: List[ImportEntry] = []
    let mut exports: List[ImportEntry] = []
    let mut common_uses: List[ImportEntry] = []
    let mut mod_decls: List[ModDeclEntry] = []
    let mut auto_imports: List[AutoImportEntry] = []

    let lines = source.split("\n")

    let mut line_number = 0
    for line in lines:
        line_number = line_number + 1

        # Try parsing as import
        let import_opt = parse_import_line(line, line_number)
        match import_opt:
            case Some(entry):
                match entry.kind:
                    case ImportKind.Use:
                        imports.push(entry)
                    case ImportKind.TypeUse:
                        imports.push(entry)
                    case ImportKind.ExportUse:
                        exports.push(entry)
                    case ImportKind.CommonUse:
                        common_uses.push(entry)
            case None:
                0  # No-op

        # Try parsing as mod declaration
        let mod_opt = parse_mod_decl(line, line_number)
        match mod_opt:
            case Some(entry):
                mod_decls.push(entry)
            case None:
                0  # No-op

        # Try parsing as auto import
        let auto_opt = parse_auto_import(line, line_number)
        match auto_opt:
            case Some(entry):
                auto_imports.push(entry)
            case None:
                0  # No-op

    # Construct result
    let mut result = ParseResult.new(file_path)
    result.imports = imports
    result.exports = exports
    result.common_uses = common_uses
    result.mod_decls = mod_decls
    result.auto_imports = auto_imports
    return result

# Get all import paths from parse result
pub fn get_all_import_paths(result: ParseResult) -> List[String]:
    let paths: List[String] = []
    for entry in result.imports:
        paths.push(entry.path)
    return paths

# Get all export paths from parse result
pub fn get_all_export_paths(result: ParseResult) -> List[String]:
    let paths: List[String] = []
    for entry in result.exports:
        paths.push(entry.path)
    return paths

# Get public mod names from parse result
pub fn get_public_mods(result: ParseResult) -> List[String]:
    let mods: List[String] = []
    for entry in result.mod_decls:
        if entry.is_public:
            mods.push(entry.name)
    return mods

# Get private mod names from parse result
pub fn get_private_mods(result: ParseResult) -> List[String]:
    let mods: List[String] = []
    for entry in result.mod_decls:
        if not entry.is_public:
            mods.push(entry.name)
    return mods
