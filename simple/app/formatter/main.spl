# Simple Language Formatter
# Canonical formatter with zero configuration
# Usage: simple_fmt <file.spl> [--check] [--write]

import sys
import io.fs as fs

# Formatting rules
const INDENT_SIZE = 4
const MAX_LINE_LENGTH = 100
const CONTINUATION_INDENT = 8

class FormatConfig:
    indent_size: Int
    max_line_length: Int
    use_tabs: Bool
    
    fn new() -> FormatConfig:
        FormatConfig(
            indent_size: INDENT_SIZE,
            max_line_length: MAX_LINE_LENGTH,
            use_tabs: false
        )

class Formatter:
    config: FormatConfig
    indent_level: Int
    
    fn new(config: FormatConfig) -> Formatter:
        Formatter(config: config, indent_level: 0)
    
    fn format_file(self, path: String) -> Result[String, String]:
        # Read file
        let content = fs.read_to_string(path)?

        # Parse and format
        let formatted = self.format_source(content)?

        Ok(formatted)

    fn format_source(self, source: String) -> Result[String, String]:
        # Simple line-by-line formatter for now
        # TODO: Use AST-based formatting when parser is available
        
        let lines = source.split("\n")
        let mut result = []
        let mut current_indent = 0
        
        for line in lines:
            let trimmed = line.trim()
            
            # Skip empty lines
            if trimmed.is_empty():
                result.push("")
                continue
            
            # Adjust indent for closing brackets/keywords
            if self.is_dedent_line(trimmed):
                current_indent = max(0, current_indent - 1)
            
            # Format line with current indent
            let indent_str = " ".repeat(current_indent * self.config.indent_size)
            let formatted_line = indent_str + trimmed
            result.push(formatted_line)
            
            # Adjust indent for opening brackets/keywords
            if self.is_indent_line(trimmed):
                current_indent = current_indent + 1
        
        Ok(result.join("\n"))
    
    fn is_indent_line(self, line: String) -> Bool:
        # Check if line should increase indent level
        return line.ends_with(":") or line.ends_with("{") or line.ends_with("(") or line.ends_with("[")
    
    fn is_dedent_line(self, line: String) -> Bool:
        # Check if line should decrease indent level
        return line.starts_with("}") or line.starts_with(")") or line.starts_with("]") or line.starts_with("else") or line.starts_with("elif") or line.starts_with("except") or line.starts_with("finally")

fn format_file_inplace(path: String) -> Result[Nil, String]:
    let config = FormatConfig.new()
    let formatter = Formatter.new(config)
    
    let formatted = formatter.format_file(path)?
    
    fs.write(path, formatted)?
    
    Ok(nil)

fn check_formatting(path: String) -> Result[Bool, String]:
    let config = FormatConfig.new()
    let formatter = Formatter.new(config)
    
    let original = fs.read_to_string(path)?
    let formatted = formatter.format_source(original)?
    
    Ok(original == formatted)

fn main():
    let args = sys.args()
    
    if args.len() < 2:
        print("Usage: simple_fmt <file.spl> [--check] [--write]")
        print("")
        print("Options:")
        print("  --check    Check if file is formatted (exit 1 if not)")
        print("  --write    Format file in place")
        print("")
        print("Without options, prints formatted output to stdout")
        sys.exit(1)
    
    let file_path = args[1]
    let check_mode = args.contains("--check")
    let write_mode = args.contains("--write")
    
    # Verify file exists
    if not fs.exists(file_path):
        print("Error: File not found: " + file_path)
        sys.exit(1)
    
    if check_mode:
        # Check mode: verify formatting
        match check_formatting(file_path):
            case Ok(is_formatted):
                if is_formatted:
                    print("✓ " + file_path + " is formatted")
                    sys.exit(0)
                else:
                    print("✗ " + file_path + " needs formatting")
                    sys.exit(1)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)
    
    elif write_mode:
        # Write mode: format in place
        match format_file_inplace(file_path):
            case Ok(_):
                print("✓ Formatted " + file_path)
                sys.exit(0)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)
    
    else:
        # Default: print to stdout
        let config = FormatConfig.new()
        let formatter = Formatter.new(config)
        
        match formatter.format_file(file_path):
            case Ok(formatted):
                print(formatted)
                sys.exit(0)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)
