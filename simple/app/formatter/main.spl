# Simple Language Canonical Formatter
# Complete formatter with intelligent line breaking and method chaining
# Usage: simple_fmt <file.spl> [--check] [--write] [--diff]

import sys
import io.fs as fs

# Formatting rules
const INDENT_SIZE = 4
const MAX_LINE_LENGTH = 100
const CONTINUATION_INDENT = 8
const BLANK_LINES_BETWEEN_ITEMS = 2

class FormatConfig:
    indent_size: Int
    max_line_length: Int
    use_tabs: Bool
    blank_lines_between_items: Int
    continuation_indent: Int

    fn new() -> FormatConfig:
        FormatConfig(
            indent_size: INDENT_SIZE,
            max_line_length: MAX_LINE_LENGTH,
            use_tabs: false,
            blank_lines_between_items: BLANK_LINES_BETWEEN_ITEMS,
            continuation_indent: CONTINUATION_INDENT
        )

class Formatter:
    config: FormatConfig
    indent_level: Int

    fn new(config: FormatConfig) -> Formatter:
        Formatter(config: config, indent_level: 0)

    async fn format_file(self, path: String) -> Result[String, String]:
        # Read file using new io.fs API
        let path_fp = FilePath::from(path)
        let content = await fs.read_text(path_fp)?

        # Parse and format
        let formatted = self.format_source(content)?

        Ok(formatted)

    fn format_source(self, source: String) -> Result[String, String]:
        let lines = source.split("\n")

        # Separate imports from other content
        let mut imports = []
        let mut other_lines = []
        let mut in_import_section = true

        for line in lines:
            let trimmed = line.trim()

            if trimmed.starts_with("import "):
                imports.push(trimmed)
            elif trimmed.is_empty() and in_import_section:
                # Skip blank lines in import section
                continue
            else:
                if not trimmed.is_empty():
                    in_import_section = false
                other_lines.push(line)

        # Sort imports alphabetically
        imports.sort()

        # Format non-import code
        let formatted_code = self.format_code_lines(other_lines)?

        # Combine sorted imports + blank lines + formatted code
        let mut result = []

        if imports.len() > 0:
            for imp in imports:
                result.push(imp)

            # Add blank lines between imports and code
            if other_lines.len() > 0:
                for _ in 0..self.config.blank_lines_between_items:
                    result.push("")

        result.extend(formatted_code)

        Ok(result.join("\n"))

    fn format_code_lines(self, lines: List[String]) -> Result[List[String], String]:
        let mut result = []
        let mut current_indent = 0
        let mut last_was_def = false
        let mut blank_line_count = 0

        for line in lines:
            let trimmed = line.trim()

            # Skip empty lines but track them
            if trimmed.is_empty():
                blank_line_count = blank_line_count + 1
                if blank_line_count <= self.config.blank_lines_between_items:
                    result.push("")
                continue

            # Reset blank line counter
            blank_line_count = 0

            # Add blank lines before top-level definitions
            if current_indent == 0 and self.is_definition(trimmed) and last_was_def:
                for _ in 0..self.config.blank_lines_between_items:
                    result.push("")

            # Adjust indent for closing brackets/keywords
            if self.is_dedent_line(trimmed):
                current_indent = max(0, current_indent - 1)

            # Format line with current indent and proper spacing
            let formatted_lines = self.format_line(trimmed, current_indent)

            # Add all formatted lines (may be multiple if line breaking occurred)
            for fmt_line in formatted_lines:
                result.push(fmt_line)

            # Track if this was a definition
            last_was_def = current_indent == 0 and self.is_definition(trimmed)

            # Adjust indent for opening brackets/keywords
            if self.is_indent_line(trimmed):
                current_indent = current_indent + 1

        Ok(result)

    fn is_definition(self, line: String) -> Bool:
        return line.starts_with("fn ") or line.starts_with("class ") or line.starts_with("struct ") or line.starts_with("enum ") or line.starts_with("trait ") or line.starts_with("impl ")

    fn format_line(self, line: String, indent: Int) -> List[String]:
        # Apply indentation
        let indent_str = " ".repeat(indent * self.config.indent_size)

        # Apply expression spacing
        let spaced = self.add_expression_spacing(line)

        # Check if line needs breaking
        let full_line = indent_str + spaced

        if full_line.len() > self.config.max_line_length:
            # Line too long - apply intelligent breaking
            return self.break_long_line(spaced, indent)
        else:
            return [full_line]

    fn break_long_line(self, line: String, base_indent: Int) -> List[String]:
        let indent_str = " ".repeat(base_indent * self.config.indent_size)
        let continuation_str = " ".repeat((base_indent * self.config.indent_size) + self.config.continuation_indent)

        # Check for method chaining (contains multiple dots)
        if self.is_method_chain(line):
            return self.break_method_chain(line, indent_str, continuation_str)

        # Check for function signature (contains "fn " and "->")
        if line.starts_with("fn ") and line.contains("->"):
            return self.break_function_signature(line, indent_str, continuation_str)

        # Check for function call with many arguments
        if line.contains("(") and line.contains(")"):
            return self.break_function_call(line, indent_str, continuation_str)

        # Check for list/dict literal
        if (line.contains("[") or line.contains("{")) and (line.contains("]") or line.contains("}")):
            return self.break_collection(line, indent_str, continuation_str)

        # Default: break at logical operators
        return self.break_at_operators(line, indent_str, continuation_str)

    fn is_method_chain(self, line: String) -> Bool:
        # Check if line has multiple dots (method chaining)
        let dot_count = 0
        for char in line:
            if char == '.':
                dot_count = dot_count + 1

        return dot_count >= 2

    fn break_method_chain(self, line: String, indent_str: String, continuation_str: String) -> List[String]:
        # Break method chains so each method call is on its own line
        # Example: obj.method1().method2().method3()
        # Becomes:
        #     obj
        #         .method1()
        #         .method2()
        #         .method3()

        let mut result = []
        let parts = line.split(".")
        let mut first = true

        for part in parts:
            if first:
                result.push(indent_str + part)
                first = false
            else:
                result.push(continuation_str + "." + part.trim())

        return result

    fn break_function_signature(self, line: String, indent_str: String, continuation_str: String) -> List[String]:
        # Break function signature at parameter list
        # Example: fn long_function(param1: Type1, param2: Type2, param3: Type3) -> ReturnType:
        # Becomes:
        #     fn long_function(
        #         param1: Type1,
        #         param2: Type2,
        #         param3: Type3
        #     ) -> ReturnType:

        if not line.contains("(") or not line.contains(")"):
            return [indent_str + line]

        let paren_start = line.index_of("(")
        let paren_end = line.index_of(")")

        let before_params = line[0..paren_start + 1]  # "fn name("
        let params_str = line[paren_start + 1..paren_end]  # "param1: Type1, param2: Type2"
        let after_params = line[paren_end..]  # ") -> ReturnType:"

        # Check if parameters fit on one line
        let params_line = indent_str + before_params + params_str + after_params
        if params_line.len() <= self.config.max_line_length:
            return [params_line]

        # Break parameters across multiple lines
        let mut result = []
        result.push(indent_str + before_params)

        let params = params_str.split(",")
        for param in params:
            result.push(continuation_str + param.trim() + ",")

        # Remove trailing comma from last parameter
        if result.len() > 1:
            let last_idx = result.len() - 1
            let last_line = result[last_idx]
            if last_line.ends_with(","):
                result[last_idx] = last_line[0..last_line.len() - 1]

        result.push(indent_str + after_params)

        return result

    fn break_function_call(self, line: String, indent_str: String, continuation_str: String) -> List[String]:
        # Break long function calls across multiple lines
        # Similar to function signature breaking

        if not line.contains("("):
            return [indent_str + line]

        let paren_start = line.index_of("(")
        let paren_end = line.rindex_of(")")

        if paren_end < paren_start:
            return [indent_str + line]

        let before_args = line[0..paren_start + 1]
        let args_str = line[paren_start + 1..paren_end]
        let after_args = line[paren_end..]

        # Check if it fits on one line
        let one_line = indent_str + before_args + args_str + after_args
        if one_line.len() <= self.config.max_line_length:
            return [one_line]

        # Break arguments
        let mut result = []
        result.push(indent_str + before_args)

        let args = args_str.split(",")
        for arg in args:
            let trimmed = arg.trim()
            if not trimmed.is_empty():
                result.push(continuation_str + trimmed + ",")

        # Remove trailing comma
        if result.len() > 1:
            let last_idx = result.len() - 1
            let last_line = result[last_idx]
            if last_line.ends_with(","):
                result[last_idx] = last_line[0..last_line.len() - 1]

        result.push(indent_str + after_args)

        return result

    fn break_collection(self, line: String, indent_str: String, continuation_str: String) -> List[String]:
        # Break collections (lists, dicts, arrays) across multiple lines
        # Example: [1, 2, 3, 4, 5]
        # Becomes:
        #     [
        #         1,
        #         2,
        #         3,
        #         4,
        #         5
        #     ]

        let open_bracket = if line.contains("[") then "[" else "{"
        let close_bracket = if line.contains("]") then "]" else "}"

        let bracket_start = line.index_of(open_bracket)
        let bracket_end = line.rindex_of(close_bracket)

        if bracket_end < bracket_start:
            return [indent_str + line]

        let before = line[0..bracket_start + 1]
        let content = line[bracket_start + 1..bracket_end]
        let after = line[bracket_end..]

        # Check if it fits
        let one_line = indent_str + before + content + after
        if one_line.len() <= self.config.max_line_length:
            return [one_line]

        # Break items
        let mut result = []
        result.push(indent_str + before)

        let items = content.split(",")
        for item in items:
            let trimmed = item.trim()
            if not trimmed.is_empty():
                result.push(continuation_str + trimmed + ",")

        # Remove trailing comma
        if result.len() > 1:
            let last_idx = result.len() - 1
            let last_line = result[last_idx]
            if last_line.ends_with(","):
                result[last_idx] = last_line[0..last_line.len() - 1]

        result.push(indent_str + close_bracket + after)

        return result

    fn break_at_operators(self, line: String, indent_str: String, continuation_str: String) -> List[String]:
        # Default line breaking: break at logical operators (and, or)
        # or at comparison operators if line is still too long

        let operators = [" and ", " or ", " + ", " - ", " * ", " / "]
        let mut best_break = -1
        let mut best_op = ""

        for op in operators:
            if line.contains(op):
                let idx = line.rindex_of(op)  # Break at rightmost operator
                if idx > best_break:
                    best_break = idx
                    best_op = op

        if best_break > 0:
            let first_part = line[0..best_break]
            let second_part = line[best_break + best_op.len()..]

            return [
                indent_str + first_part + best_op,
                continuation_str + second_part
            ]

        # No good break point found - return as is
        return [indent_str + line]

    fn add_expression_spacing(self, line: String) -> String:
        # Add spaces around binary operators
        let mut result = line

        # Operators that need spacing
        let operators = ["+", "-", "*", "/", "%", "==", "!=", "<=", ">=", "<", ">", "and", "or", "in", "not in"]

        for op in operators:
            # Add spaces around operator if not already present
            result = result.replace(op, " " + op + " ")

            # Clean up multiple spaces
            while result.contains("  "):
                result = result.replace("  ", " ")

        # Clean up spaces in specific contexts
        result = result.replace("( ", "(")      # No space after opening paren
        result = result.replace(" )", ")")      # No space before closing paren
        result = result.replace("[ ", "[")      # No space after opening bracket
        result = result.replace(" ]", "]")      # No space before closing bracket
        result = result.replace(" ,", ",")      # No space before comma
        result = result.replace(",", ", ")      # Space after comma

        # Clean up function signatures
        result = result.replace(" :", ":")      # No space before colon
        result = result.replace("->", " -> ")   # Spaces around arrow
        result = result.replace("=>", " => ")   # Spaces around fat arrow

        # Clean up dots (no spaces around dots in method calls)
        result = result.replace(" .", ".")
        result = result.replace(". ", ".")

        result.trim()

    fn is_indent_line(self, line: String) -> Bool:
        # Check if line should increase indent level
        return line.ends_with(":") or line.ends_with("{") or line.ends_with("(") or line.ends_with("[")

    fn is_dedent_line(self, line: String) -> Bool:
        # Check if line should decrease indent level
        return line.starts_with("}") or line.starts_with(")") or line.starts_with("]") or line.starts_with("else") or line.starts_with("elif") or line.starts_with("except") or line.starts_with("finally")

async fn format_file_inplace(path: String) -> Result[Nil, String]:
    let config = FormatConfig.new()
    let formatter = Formatter.new(config)

    let formatted = await formatter.format_file(path)?

    let path_fp = FilePath::from(path)
    await fs.write_text(path_fp, formatted)?

    Ok(nil)

async fn check_formatting(path: String) -> Result[Bool, String]:
    let config = FormatConfig.new()
    let formatter = Formatter.new(config)

    let path_fp = FilePath::from(path)
    let original = await fs.read_text(path_fp)?
    let formatted = formatter.format_source(original)?

    Ok(original == formatted)

async fn main():
    let args = sys.args()

    if args.len() < 2:
        print("Simple Language Canonical Formatter")
        print("=====================================")
        print("")
        print("Usage: simple_fmt <file.spl> [OPTIONS]")
        print("")
        print("Options:")
        print("  --check     Check if file is formatted (exit 1 if not)")
        print("  --write     Format file in place")
        print("  --diff      Show formatting diff")
        print("  --stdout    Print formatted output to stdout (default)")
        print("")
        print("Features:")
        print("  ✓ Automatic import sorting (alphabetical)")
        print("  ✓ Expression spacing (x + y, not x+y)")
        print("  ✓ Blank lines between definitions (2 lines)")
        print("  ✓ Consistent indentation (4 spaces)")
        print("  ✓ Intelligent line breaking (100 char limit)")
        print("  ✓ Method chaining alignment")
        print("  ✓ Function signature formatting")
        print("  ✓ Collection formatting (arrays, dicts)")
        print("")
        print("Examples:")
        print("  simple_fmt app.spl            # Print formatted to stdout")
        print("  simple_fmt app.spl --write    # Format in-place")
        print("  simple_fmt app.spl --check    # Check formatting (CI)")
        print("  simple_fmt app.spl --diff     # Show diff")
        print("")
        print("Formatting Rules:")
        print("  - Max line length: 100 characters")
        print("  - Indentation: 4 spaces (no tabs)")
        print("  - Continuation indent: 8 spaces")
        print("  - Blank lines: 2 between top-level items")
        sys.exit(1)

    let file_path = args[1]
    let check_mode = args.contains("--check")
    let write_mode = args.contains("--write")
    let diff_mode = args.contains("--diff")
    let stdout_mode = args.contains("--stdout") or (!check_mode and !write_mode and !diff_mode)

    # Verify file exists
    let file_path_fp = FilePath::from(file_path)
    if not await fs.exists(file_path_fp):
        print("Error: File not found: " + file_path)
        sys.exit(1)

    if check_mode:
        # Check mode: verify formatting
        match await check_formatting(file_path):
            case Ok(is_formatted):
                if is_formatted:
                    print("✓ " + file_path + " is formatted")
                    sys.exit(0)
                else:
                    print("✗ " + file_path + " needs formatting")
                    sys.exit(1)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

    elif write_mode:
        # Write mode: format in place
        match await format_file_inplace(file_path):
            case Ok(_):
                print("✓ Formatted " + file_path)
                sys.exit(0)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

    elif diff_mode:
        # Diff mode: show formatting diff
        let config = FormatConfig.new()
        let formatter = Formatter.new(config)

        match await formatter.format_file(file_path):
            case Ok(formatted):
                match await fs.read_text(file_path_fp):
                    case Ok(original):
                        if original == formatted:
                            print("✓ " + file_path + " is correctly formatted")
                            sys.exit(0)
                        else:
                            print_diff(original, formatted, file_path)
                            sys.exit(1)
                    case Err(error):
                        print("Error reading file: " + error.to_string())
                        sys.exit(1)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

    else:
        # Default/stdout mode: print to stdout
        let config = FormatConfig.new()
        let formatter = Formatter.new(config)

        match await formatter.format_file(file_path):
            case Ok(formatted):
                print(formatted)
                sys.exit(0)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

fn print_diff(original: String, formatted: String, file_path: String):
    """Print unified diff between original and formatted code"""
    print("--- " + file_path + " (original)")
    print("+++ " + file_path + " (formatted)")
    print("")

    let orig_lines = original.split("\n")
    let fmt_lines = formatted.split("\n")

    # Simple line-by-line diff
    for i in 0..max(orig_lines.len(), fmt_lines.len()):
        if i < orig_lines.len() and i < fmt_lines.len():
            if orig_lines[i] != fmt_lines[i]:
                print("@@ Line {i + 1} @@")
                print("-{orig_lines[i]}")
                print("+{fmt_lines[i]}")
        elif i < orig_lines.len():
            print("@@ Line {i + 1} @@")
            print("-{orig_lines[i]}")
        else:
            print("@@ Line {i + 1} @@")
            print("+{fmt_lines[i]}")
