# Hover Handler
# Provides hover information (documentation, type info) for symbols

import lsp.protocol as protocol
import lsp.transport as transport
import parser.treesitter.{Tree, Node, NodeId, Span}

# Find node at specific position
fn find_node_at_position(tree: Tree, line: Int, column: Int) -> Option<Node>:
    # Helper function to check if position is in span
    fn position_in_span(span: Span, line: Int, column: Int) -> Bool:
        if line < span.start_line or line > span.end_line:
            return false

        if line == span.start_line and column < span.start_column:
            return false

        if line == span.end_line and column > span.end_column:
            return false

        true

    # Traverse tree to find deepest node containing position
    fn traverse(node_id: NodeId, best: Option<Node>) -> Option<Node>:
        match tree.arena.get(node_id):
            case None:
                best
            case Some(node):
                # Check if position is in this node
                if not position_in_span(node.span, line, column):
                    return best

                # This node contains the position
                let mut new_best = Some(node)

                # Check children for a more specific match
                for child_id in node.children:
                    new_best = traverse(child_id, new_best)

                new_best

    traverse(tree.root_node, None)

# Get hover content for a node
fn get_hover_content(node: Node, source: String) -> Option<String>:
    # Provide hover information based on node kind
    match node.kind:
        case "function_def":
            # Function definition - show signature
            Some(f"function {node.text}")

        case "identifier":
            # Identifier - show name and basic info
            Some(f"identifier: {node.text}")

        case "type_identifier":
            # Type identifier
            Some(f"type: {node.text}")

        case "keyword":
            # Keyword - show documentation
            match node.text:
                case "fn":
                    Some("**fn** - Function definition keyword")
                case "let":
                    Some("**let** - Variable declaration keyword")
                case "mut":
                    Some("**mut** - Mutable binding modifier")
                case "return":
                    Some("**return** - Return statement keyword")
                case "if":
                    Some("**if** - Conditional expression keyword")
                case "else":
                    Some("**else** - Alternative branch keyword")
                case "match":
                    Some("**match** - Pattern matching keyword")
                case "case":
                    Some("**case** - Match arm keyword")
                case "for":
                    Some("**for** - For loop keyword")
                case "while":
                    Some("**while** - While loop keyword")
                case "loop":
                    Some("**loop** - Infinite loop keyword")
                case "break":
                    Some("**break** - Loop break keyword")
                case "continue":
                    Some("**continue** - Loop continue keyword")
                case _:
                    Some(f"keyword: {node.text}")

        case "integer":
            Some(f"integer literal: {node.text}")

        case "float":
            Some(f"float literal: {node.text}")

        case "string":
            Some(f"string literal")

        case "binary_op":
            Some(f"binary operation")

        case "call":
            # Function call - try to show signature
            Some(f"function call")

        case _:
            # Unknown or not interesting
            None

# Handle textDocument/hover request
fn handle_hover(tree: Tree, source: String, line: Int, column: Int) -> Result<Option<Dict>, String>:
    # Find node at cursor position
    match find_node_at_position(tree, line, column):
        case None:
            # No node at position - return null (no hover)
            Ok(None)

        case Some(node):
            # Get hover content for this node
            match get_hover_content(node, source):
                case None:
                    Ok(None)

                case Some(content):
                    # Create hover response
                    let range = {
                        "start": {
                            "line": node.span.start_line,
                            "character": node.span.start_column
                        },
                        "end": {
                            "line": node.span.end_line,
                            "character": node.span.end_column
                        }
                    }

                    let hover = {
                        "contents": {
                            "kind": "markdown",
                            "value": content
                        },
                        "range": range
                    }

                    Ok(Some(hover))

# Get documentation for built-in types
fn get_type_documentation(type_name: String) -> Option<String>:
    match type_name:
        case "Int":
            Some("**Int** - 64-bit signed integer type")
        case "Float":
            Some("**Float** - 64-bit floating point type")
        case "String":
            Some("**String** - UTF-8 string type")
        case "Bool":
            Some("**Bool** - Boolean type (true/false)")
        case "List":
            Some("**List[T]** - Dynamic array type")
        case "Dict":
            Some("**Dict[K, V]** - Hash map type")
        case "Option":
            Some("**Option[T]** - Optional value type (Some/None)")
        case "Result":
            Some("**Result[T, E]** - Result type (Ok/Err)")
        case _:
            None
