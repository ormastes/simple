# LSP Server Implementation
# Handles LSP requests and maintains server state

import sys
import io.fs as fs
import core.collections as collections
import lsp.protocol as protocol
import lsp.transport as transport

# Server state
enum ServerState:
    Uninitialized
    Initialized
    ShuttingDown

# Document cache entry
class DocumentInfo:
    uri: String
    version: Int
    text: String

    fn new(uri: String, version: Int, text: String) -> DocumentInfo:
        DocumentInfo(uri: uri, version: version, text: text)

# LSP Server
class LspServer:
    state: ServerState
    documents: Dict<String, DocumentInfo>  # uri -> DocumentInfo

    fn new() -> LspServer:
        LspServer(
            state: ServerState.Uninitialized,
            documents: {}
        )

    # Handle initialize request
    fn handle_initialize(self, id: Int, params: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling initialize request")

        # Update state
        self.state = ServerState.Initialized

        # Build initialize result
        let result = protocol.InitializeResult.new()
        let response_data = result.to_json()

        # Send response
        transport.write_response(id, response_data)?

        Ok(nil)

    # Handle initialized notification
    fn handle_initialized(self) -> Result<Nil, String>:
        transport.log_debug("Received initialized notification")
        Ok(nil)

    # Handle shutdown request
    fn handle_shutdown(self, id: Int) -> Result<Nil, String>:
        transport.log_debug("Handling shutdown request")

        # Update state
        self.state = ServerState.ShuttingDown

        # Send null result
        transport.write_response(id, {})?

        Ok(nil)

    # Handle exit notification
    fn handle_exit(self) -> Result<Nil, String>:
        transport.log_debug("Handling exit notification")

        # Exit with appropriate code
        match self.state:
            case ShuttingDown:
                sys.exit(0)
            case _:
                sys.exit(1)

        Ok(nil)

    # Handle textDocument/didOpen notification
    fn handle_did_open(self, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for didOpen")
            case Some(p):
                # Extract text document
                let text_document_data = p.get("textDocument")?
                let doc = protocol.TextDocumentItem.from_json(text_document_data)?

                # Cache document
                let doc_info = DocumentInfo.new(doc.uri, doc.version, doc.text)
                self.documents[doc.uri] = doc_info

                transport.log_debug(f"Opened document: {doc.uri}")

                # Run diagnostics
                self.publish_diagnostics(doc.uri, doc.text)?

                Ok(nil)

    # Handle textDocument/didChange notification
    fn handle_did_change(self, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for didChange")
            case Some(p):
                # Extract versioned document
                let text_document_data = p.get("textDocument")?
                let versioned_doc = protocol.VersionedTextDocumentIdentifier.from_json(text_document_data)?

                # Extract content changes
                let content_changes = p.get("contentChanges")?
                if content_changes.is_empty():
                    return Err("No content changes")

                # Get first change (we use full sync)
                let change_data = content_changes[0]
                let change = protocol.TextDocumentContentChangeEvent.from_json(change_data)?

                # Update cached document
                let doc_info = DocumentInfo.new(
                    versioned_doc.uri,
                    versioned_doc.version,
                    change.text
                )
                self.documents[versioned_doc.uri] = doc_info

                transport.log_debug(f"Changed document: {versioned_doc.uri}")

                # Run diagnostics
                self.publish_diagnostics(versioned_doc.uri, change.text)?

                Ok(nil)

    # Handle textDocument/didClose notification
    fn handle_did_close(self, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for didClose")
            case Some(p):
                let text_document_data = p.get("textDocument")?
                let doc = protocol.TextDocumentIdentifier.from_json(text_document_data)?

                # Remove from cache
                self.documents.remove(doc.uri)

                transport.log_debug(f"Closed document: {doc.uri}")

                Ok(nil)

    # Publish diagnostics for a document
    fn publish_diagnostics(self, uri: String, text: String) -> Result<Nil, String>:
        # Simple parser integration would go here
        # For now, we'll just send empty diagnostics

        let diagnostics: List<Dict> = []

        # TODO: Parse the document and collect errors
        # For now, check for simple syntax errors (example)
        let lines = text.split("\n")
        for (line_num, line) in lines.enumerate():
            # Check for unmatched parentheses (simple example)
            let open_parens = line.count("(")
            let close_parens = line.count(")")
            if open_parens > close_parens:
                let range = protocol.Range.new(
                    protocol.Position.new(line_num, 0),
                    protocol.Position.new(line_num, line.len())
                )
                let diagnostic = protocol.Diagnostic.new(
                    range,
                    protocol.DiagnosticSeverity.Warning,
                    "Possible unmatched opening parenthesis"
                )
                    .with_source("simple-lsp")

                diagnostics.push(diagnostic.to_json())

        # Send publishDiagnostics notification
        let params = {
            "uri": uri,
            "diagnostics": diagnostics
        }

        transport.write_notification("textDocument/publishDiagnostics", params)?

        Ok(nil)

    # Main request dispatcher
    fn handle_request(self, request: protocol.JsonRpcRequest) -> Result<Nil, String>:
        match request.method:
            case "initialize":
                self.handle_initialize(request.id, request.params)
            case "shutdown":
                self.handle_shutdown(request.id)
            case _:
                # Unknown method
                transport.write_error(
                    request.id,
                    protocol.ERROR_METHOD_NOT_FOUND,
                    f"Method not found: {request.method}"
                )?
                Ok(nil)

    # Main notification dispatcher
    fn handle_notification(self, notification: protocol.JsonRpcNotification) -> Result<Nil, String>:
        match notification.method:
            case "initialized":
                self.handle_initialized()
            case "exit":
                self.handle_exit()
            case "textDocument/didOpen":
                self.handle_did_open(notification.params)
            case "textDocument/didChange":
                self.handle_did_change(notification.params)
            case "textDocument/didClose":
                self.handle_did_close(notification.params)
            case _:
                # Unknown notification - ignore (LSP spec allows this)
                transport.log_debug(f"Ignoring unknown notification: {notification.method}")
                Ok(nil)

    # Main server loop
    fn run(self) -> Result<Nil, String>:
        transport.log_debug("LSP server starting")

        loop:
            # Read next message
            let message = match transport.read_message():
                case Ok(msg):
                    msg
                case Err(e):
                    # EOF or error - exit gracefully
                    transport.log_debug(f"Read error: {e}")
                    return Ok(nil)

            # Determine message type
            let msg_type = transport.parse_message_type(message)?

            # Dispatch based on type
            match msg_type:
                case "request":
                    let request = protocol.JsonRpcRequest.from_json(message)?
                    self.handle_request(request)?
                case "notification":
                    let notification = protocol.JsonRpcNotification.from_json(message)?
                    self.handle_notification(notification)?
                case "response":
                    # We don't expect responses (we're the server)
                    transport.log_debug("Ignoring unexpected response message")
                case _:
                    transport.log_error(f"Unknown message type: {msg_type}")

        Ok(nil)
