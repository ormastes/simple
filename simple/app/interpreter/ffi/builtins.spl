# Built-in Functions
#
# Core built-in functions available in all Simple programs.

import ..core.{Value, InterpreterError}
from bridge import {register_native, NativeFunction}

export register_builtins, BUILTIN_FUNCTIONS

# List of built-in function names
const BUILTIN_FUNCTIONS: Array<String> = [
    "print",
    "println",
    "input",
    "len",
    "type",
    "str",
    "int",
    "float",
    "bool",
    "range",
    "enumerate",
    "zip",
    "map",
    "filter",
    "reduce",
    "sorted",
    "reversed",
    "min",
    "max",
    "sum",
    "abs",
    "round",
    "floor",
    "ceil",
    "sqrt",
    "pow",
    "log",
    "sin",
    "cos",
    "tan",
    "assert",
    "panic",
    "exit",
]

# Register all built-in functions
fn register_builtins():
    register_native("print".to_string(), builtin_print)
    register_native("println".to_string(), builtin_println)
    register_native("input".to_string(), builtin_input)
    register_native("len".to_string(), builtin_len)
    register_native("type".to_string(), builtin_type)
    register_native("str".to_string(), builtin_str)
    register_native("int".to_string(), builtin_int)
    register_native("float".to_string(), builtin_float)
    register_native("bool".to_string(), builtin_bool)
    register_native("range".to_string(), builtin_range)
    register_native("abs".to_string(), builtin_abs)
    register_native("min".to_string(), builtin_min)
    register_native("max".to_string(), builtin_max)
    register_native("sum".to_string(), builtin_sum)
    register_native("assert".to_string(), builtin_assert)
    register_native("panic".to_string(), builtin_panic)
    register_native("exit".to_string(), builtin_exit)

# Print without newline
fn builtin_print(args: Array<Value>) -> Result<Value, InterpreterError>:
    for arg in args:
        io::print(arg.to_string())
    return Ok(Value::nil())

# Print with newline
fn builtin_println(args: Array<Value>) -> Result<Value, InterpreterError>:
    for arg in args:
        io::print(arg.to_string())
    io::println("")
    return Ok(Value::nil())

# Read input
fn builtin_input(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() > 0:
        io::print(args[0].to_string())
    val line = io::read_line()
    return Ok(Value::string(line.trim().to_string()))

# Get length
fn builtin_len(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })

    match args[0].data:
        case RuntimeValue::String(s):
            return Ok(Value::int(s.len() as i64))
        case RuntimeValue::Array(arr):
            return Ok(Value::int(arr.len() as i64))
        case RuntimeValue::Dict(d):
            return Ok(Value::int(d.len() as i64))
        case RuntimeValue::Tuple(t):
            return Ok(Value::int(t.len() as i64))
        case _:
            return Err(InterpreterError::TypeError("len requires sized type".to_string()))

# Get type name
fn builtin_type(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })

    val type_name = match args[0].kind:
        case ValueKind::Nil: "nil"
        case ValueKind::Bool: "bool"
        case ValueKind::Int: "int"
        case ValueKind::Float: "float"
        case ValueKind::String: "string"
        case ValueKind::Array: "array"
        case ValueKind::Dict: "dict"
        case ValueKind::Tuple: "tuple"
        case ValueKind::Struct: "struct"
        case ValueKind::Enum: "enum"
        case ValueKind::Function: "function"
        case ValueKind::Closure: "closure"
        case ValueKind::Object: "object"

    return Ok(Value::string(type_name.to_string()))

# Convert to string
fn builtin_str(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
    return Ok(Value::string(args[0].to_string()))

# Convert to int
fn builtin_int(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })

    match args[0].data:
        case RuntimeValue::Int(n):
            return Ok(Value::int(n))
        case RuntimeValue::Float(f):
            return Ok(Value::int(f as i64))
        case RuntimeValue::String(s):
            match s.parse::<i64>():
                case Ok(n): return Ok(Value::int(n))
                case Err(_): return Err(InterpreterError::ValueError("invalid int: {s}".to_string()))
        case RuntimeValue::Bool(b):
            return Ok(Value::int(if b: 1 else: 0))
        case _:
            return Err(InterpreterError::TypeError("cannot convert to int".to_string()))

# Convert to float
fn builtin_float(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })

    match args[0].data:
        case RuntimeValue::Float(f):
            return Ok(Value::float(f))
        case RuntimeValue::Int(n):
            return Ok(Value::float(n as f64))
        case RuntimeValue::String(s):
            match s.parse::<f64>():
                case Ok(f): return Ok(Value::float(f))
                case Err(_): return Err(InterpreterError::ValueError("invalid float: {s}".to_string()))
        case _:
            return Err(InterpreterError::TypeError("cannot convert to float".to_string()))

# Convert to bool
fn builtin_bool(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })
    return Ok(Value::bool(args[0].is_truthy()))

# Create a range
fn builtin_range(args: Array<Value>) -> Result<Value, InterpreterError>:
    match args.len():
        case 1:
            # range(end)
            match args[0].as_int():
                case Some(end):
                    val arr: Array<Value> = (0..end).map(|i| Value::int(i)).collect()
                    return Ok(Value::array(arr))
                case None:
                    return Err(InterpreterError::TypeError("range requires int".to_string()))

        case 2:
            # range(start, end)
            match (args[0].as_int(), args[1].as_int()):
                case (Some(start), Some(end)):
                    val arr: Array<Value> = (start..end).map(|i| Value::int(i)).collect()
                    return Ok(Value::array(arr))
                case _:
                    return Err(InterpreterError::TypeError("range requires ints".to_string()))

        case 3:
            # range(start, end, step)
            match (args[0].as_int(), args[1].as_int(), args[2].as_int()):
                case (Some(start), Some(end), Some(step)):
                    if step == 0:
                        return Err(InterpreterError::ValueError("step cannot be zero".to_string()))
                    val arr: Array<Value> = []
                    val i = start
                    if step > 0:
                        while i < end:
                            arr.push(Value::int(i))
                            i += step
                    else:
                        while i > end:
                            arr.push(Value::int(i))
                            i += step
                    return Ok(Value::array(arr))
                case _:
                    return Err(InterpreterError::TypeError("range requires ints".to_string()))

        case _:
            return Err(InterpreterError::ArityError { expected: 1, got: args.len() })

# Absolute value
fn builtin_abs(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })

    match args[0].data:
        case RuntimeValue::Int(n):
            return Ok(Value::int(n.abs()))
        case RuntimeValue::Float(f):
            return Ok(Value::float(f.abs()))
        case _:
            return Err(InterpreterError::TypeError("abs requires number".to_string()))

# Minimum
fn builtin_min(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.is_empty():
        return Err(InterpreterError::ValueError("min requires at least one argument".to_string()))

    val min_val = args[0].clone()
    for arg in args[1..]:
        # TODO: [stdlib][P1] Implement proper comparison
        pass
    return Ok(min_val)

# Maximum
fn builtin_max(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.is_empty():
        return Err(InterpreterError::ValueError("max requires at least one argument".to_string()))

    val max_val = args[0].clone()
    for arg in args[1..]:
        # TODO: [stdlib][P1] Implement proper comparison
        pass
    return Ok(max_val)

# Sum
fn builtin_sum(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError::ArityError { expected: 1, got: args.len() })

    match args[0].as_array():
        case Some(arr):
            val total = 0
            for val in arr:
                match val.as_int():
                    case Some(n): total += n
                    case None: return Err(InterpreterError::TypeError("sum requires numbers".to_string()))
            return Ok(Value::int(total))
        case None:
            return Err(InterpreterError::TypeError("sum requires array".to_string()))

# Assert
fn builtin_assert(args: Array<Value>) -> Result<Value, InterpreterError>:
    if args.is_empty():
        return Err(InterpreterError::ArityError { expected: 1, got: 0 })

    if not args[0].is_truthy():
        val msg = if args.len() > 1:
            args[1].to_string()
        else:
            "assertion failed".to_string()
        return Err(InterpreterError::AssertionError(msg))

    return Ok(Value::nil())

# Panic
fn builtin_panic(args: Array<Value>) -> Result<Value, InterpreterError>:
    val msg = if args.len() > 0:
        args[0].to_string()
    else:
        "panic".to_string()
    return Err(InterpreterError::Panic(msg))

# Exit
fn builtin_exit(args: Array<Value>) -> Result<Value, InterpreterError>:
    val code = if args.len() > 0:
        match args[0].as_int():
            case Some(n): n as i32
            case None: 1
    else:
        0
    return Err(InterpreterError::Exit(code))
