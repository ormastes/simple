# External Library Loading
#
# Dynamic loading of external native libraries.

import ..core.{Value, InterpreterError}

export load_library, resolve_symbol, ExternLib, Symbol

# A loaded external library
struct ExternLib:
    path: String
    handle: RawPtr
    symbols: Dict<String, Symbol>

impl ExternLib:
    fn new(path: &str) -> Result<ExternLib, String>:
        # Load the library
        match dlopen(path):
            case Ok(handle):
                return Ok(ExternLib {
                    path: path.to_string(),
                    handle: handle,
                    symbols: Dict::new()
                })
            case Err(e):
                return Err(e)

    fn close():
        dlclose(self.handle)

    fn get_symbol(name: &str) -> Result<Symbol, String>:
        # Check cache
        if val Some(sym) = self.symbols.get(name):
            return Ok(sym.clone())

        # Resolve symbol
        match dlsym(self.handle, name):
            case Ok(ptr):
                val sym = Symbol { name: name.to_string(), ptr: ptr }
                self.symbols.set(name.to_string(), sym.clone())
                return Ok(sym)
            case Err(e):
                return Err(e)

# A resolved symbol
struct Symbol:
    name: String
    ptr: RawPtr

impl Symbol:
    fn call(args: Array<Value>) -> Result<Value, InterpreterError>:
        # TODO: [stdlib][P3] FFI call with argument marshalling
        # Requires:
        # - libffi integration or similar FFI library
        # - Type signature parsing from symbol metadata
        # - Calling convention handling (cdecl, stdcall, etc.)
        # - Conversion between Value types and C types (already implemented below)
        # This is a substantial undertaking requiring external library integration.
        return Err(InterpreterError::NotImplemented("extern call requires libffi integration".to_string()))

# Registry of loaded libraries
static mut EXTERN_LIBS: Option<Dict<String, ExternLib>> = None

fn init_libs():
    unsafe:
        if EXTERN_LIBS.is_none():
            EXTERN_LIBS = Some(Dict::new())

# Load an external library
fn load_library(path: &str) -> Result<ExternLib, InterpreterError>:
    init_libs()

    # Check if already loaded
    unsafe:
        if val Some(ref libs) = EXTERN_LIBS:
            if val Some(lib) = libs.get(path):
                return Ok(lib.clone())

    # Load new library
    match ExternLib::new(path):
        case Ok(lib):
            unsafe:
                if val Some(ref mut libs) = EXTERN_LIBS:
                    libs.set(path.to_string(), lib.clone())
            return Ok(lib)
        case Err(e):
            return Err(InterpreterError::LoadError(e))

# Resolve a symbol from a library
fn resolve_symbol(lib: &ExternLib, name: &str) -> Result<Symbol, InterpreterError>:
    match lib.get_symbol(name):
        case Ok(sym):
            return Ok(sym)
        case Err(e):
            return Err(InterpreterError::SymbolError(e))

# Unload a library
fn unload_library(path: &str):
    unsafe:
        if val Some(ref mut libs) = EXTERN_LIBS:
            if val Some(lib) = libs.remove(path):
                lib.close()

# Platform-specific dynamic loading
#[cfg(target_os = "linux")]
extern fn dlopen(path: &str) -> Result<RawPtr, String>
extern fn dlclose(handle: RawPtr)
extern fn dlsym(handle: RawPtr, name: &str) -> Result<RawPtr, String>

#[cfg(target_os = "macos")]
extern fn dlopen(path: &str) -> Result<RawPtr, String>
extern fn dlclose(handle: RawPtr)
extern fn dlsym(handle: RawPtr, name: &str) -> Result<RawPtr, String>

#[cfg(target_os = "windows")]
extern fn LoadLibraryA(path: &str) -> Result<RawPtr, String>
extern fn FreeLibrary(handle: RawPtr)
extern fn GetProcAddress(handle: RawPtr, name: &str) -> Result<RawPtr, String>

# Windows compatibility shims
#[cfg(target_os = "windows")]
fn dlopen(path: &str) -> Result<RawPtr, String>:
    return LoadLibraryA(path)

#[cfg(target_os = "windows")]
fn dlclose(handle: RawPtr):
    FreeLibrary(handle)

#[cfg(target_os = "windows")]
fn dlsym(handle: RawPtr, name: &str) -> Result<RawPtr, String>:
    return GetProcAddress(handle, name)

# Type definitions for FFI
type RawPtr = u64  # Or platform-appropriate size

# C type mappings
enum CType:
    Void
    Bool
    Char
    Short
    Int
    Long
    LongLong
    Float
    Double
    Pointer(Box<CType>)
    Array(Box<CType>, usize)
    Struct(Array<(String, CType)>)

# Convert Simple value to C type
fn value_to_c(val: &Value, ctype: &CType) -> Result<Array<u8>, String>:
    match (val.data.clone(), ctype):
        case (RuntimeValue::Bool(b), CType::Bool):
            return Ok([if b: 1u8 else: 0u8])

        case (RuntimeValue::Int(n), CType::Char):
            return Ok([(n as u8)])

        case (RuntimeValue::Int(n), CType::Short):
            val bytes = (n as i16).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue::Int(n), CType::Int):
            val bytes = (n as i32).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue::Int(n), CType::Long):
            val bytes = (n as i64).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue::Int(n), CType::LongLong):
            val bytes = (n as i64).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue::Float(f), CType::Float):
            val bytes = (f as f32).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue::Float(f), CType::Double):
            val bytes = f.to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue::Int(n), CType::Pointer(_)):
            val bytes = (n as u64).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue::Nil, CType::Pointer(_)):
            val bytes = 0u64.to_le_bytes()
            return Ok(bytes.to_vec())

        case _:
            return Err("cannot convert value to C type".to_string())

# Convert C data to Simple value
fn c_to_value(data: &Array<u8>, ctype: &CType) -> Result<Value, String>:
    match ctype:
        case CType::Void:
            return Ok(Value::nil())

        case CType::Bool:
            if data.len() < 1:
                return Err("insufficient data for bool".to_string())
            return Ok(Value::bool(data[0] != 0))

        case CType::Char:
            if data.len() < 1:
                return Err("insufficient data for char".to_string())
            return Ok(Value::int(data[0] as i64))

        case CType::Short:
            if data.len() < 2:
                return Err("insufficient data for short".to_string())
            val bytes: [u8; 2] = [data[0], data[1]]
            val n = i16::from_le_bytes(bytes)
            return Ok(Value::int(n as i64))

        case CType::Int:
            if data.len() < 4:
                return Err("insufficient data for int".to_string())
            val bytes: [u8; 4] = [data[0], data[1], data[2], data[3]]
            val n = i32::from_le_bytes(bytes)
            return Ok(Value::int(n as i64))

        case CType::Long:
            if data.len() < 8:
                return Err("insufficient data for long".to_string())
            val bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            val n = i64::from_le_bytes(bytes)
            return Ok(Value::int(n))

        case CType::LongLong:
            if data.len() < 8:
                return Err("insufficient data for long long".to_string())
            val bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            val n = i64::from_le_bytes(bytes)
            return Ok(Value::int(n))

        case CType::Float:
            if data.len() < 4:
                return Err("insufficient data for float".to_string())
            val bytes: [u8; 4] = [data[0], data[1], data[2], data[3]]
            val f = f32::from_le_bytes(bytes)
            return Ok(Value::float(f as f64))

        case CType::Double:
            if data.len() < 8:
                return Err("insufficient data for double".to_string())
            val bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            val f = f64::from_le_bytes(bytes)
            return Ok(Value::float(f))

        case CType::Pointer(_):
            if data.len() < 8:
                return Err("insufficient data for pointer".to_string())
            val bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            val ptr = u64::from_le_bytes(bytes)
            return Ok(Value::int(ptr as i64))

        case _:
            return Err("cannot convert C type to value".to_string())
