# Pattern Matching
#
# match expression and case clause evaluation.

import ..core.{Interpreter, Value, InterpreterError}
import ..expr.{evaluate}

export eval_match, eval_case

# Evaluate a match expression
fn eval_match(interp: &Interpreter, scrutinee: &Expr, arms: &Array[MatchArm]) -> Result[Value, InterpreterError]:
    # Evaluate the value being matched
    let val = evaluate(interp, scrutinee)?

    # Try each arm
    for arm in arms:
        if let Some(result) = try_match_arm(interp, &val, arm)?:
            return Ok(result)

    # No arm matched - this should be caught by exhaustiveness checker
    return Err(InterpreterError::MatchError("non-exhaustive match".to_string()))

# Evaluate a single case clause
fn eval_case(interp: &Interpreter, val: &Value, pattern: &Pattern, guard: Option[&Expr], body: &Expr) -> Result[Option[Value], InterpreterError]:
    # Try to match the pattern
    let bindings = match_pattern(val, pattern)?

    match bindings:
        case Some(binds):
            # Pattern matched, check guard
            if let Some(guard_expr) = guard:
                # Temporarily bind pattern variables
                interp.env.push_scope()
                for (name, bound_val) in binds:
                    interp.env.define(name, bound_val)

                let guard_result = evaluate(interp, guard_expr)?
                if not guard_result.is_truthy():
                    interp.env.pop_scope()
                    return Ok(None)  # Guard failed

                # Guard passed, evaluate body
                let result = evaluate(interp, body)?
                interp.env.pop_scope()
                return Ok(Some(result))
            else:
                # No guard, evaluate body with bindings
                interp.env.push_scope()
                for (name, bound_val) in binds:
                    interp.env.define(name, bound_val)

                let result = evaluate(interp, body)?
                interp.env.pop_scope()
                return Ok(Some(result))

        case None:
            return Ok(None)  # Pattern didn't match

# Try to match a single arm
fn try_match_arm(interp: &Interpreter, val: &Value, arm: &MatchArm) -> Result[Option[Value], InterpreterError]:
    return eval_case(interp, val, &arm.pattern, arm.guard.as_ref(), &arm.body)

# Pattern matching returns bindings if successful
fn match_pattern(val: &Value, pattern: &Pattern) -> Result[Option[Array[(String, Value)]], InterpreterError]:
    match pattern:
        case Pattern::Wildcard:
            return Ok(Some([]))

        case Pattern::Identifier(name):
            return Ok(Some([(name.clone(), val.clone())]))

        case Pattern::Literal(lit):
            if matches_literal(val, lit):
                return Ok(Some([]))
            return Ok(None)

        case Pattern::Tuple(patterns):
            return match_tuple(val, patterns)

        case Pattern::Struct { name, fields }:
            return match_struct(val, name, fields)

        case Pattern::Enum { variant, data }:
            return match_enum(val, variant, data)

        case Pattern::Or(left, right):
            if let Some(binds) = match_pattern(val, left)?:
                return Ok(Some(binds))
            return match_pattern(val, right)

        case _:
            return Err(InterpreterError::NotImplemented("pattern".to_string()))

# Check if value matches literal pattern
fn matches_literal(val: &Value, lit: &Literal) -> bool:
    match (val.data.clone(), lit):
        case (RuntimeValue::Int(n), Literal::Int(m)):
            return n == *m
        case (RuntimeValue::Float(f), Literal::Float(g)):
            return f == *g
        case (RuntimeValue::Bool(b), Literal::Bool(c)):
            return b == *c
        case (RuntimeValue::String(s), Literal::String(t)):
            return s == *t
        case (RuntimeValue::Nil, Literal::Nil):
            return true
        case _:
            return false

# Match tuple pattern
fn match_tuple(val: &Value, patterns: &Array[Pattern]) -> Result[Option[Array[(String, Value)]], InterpreterError]:
    match val.as_array():
        case Some(arr):
            if arr.len() != patterns.len():
                return Ok(None)

            let all_bindings: Array[(String, Value)] = []
            for i in 0..patterns.len():
                match match_pattern(&arr[i], &patterns[i])?:
                    case Some(binds):
                        all_bindings.extend(binds)
                    case None:
                        return Ok(None)

            return Ok(Some(all_bindings))

        case None:
            return Ok(None)

# Match struct pattern
fn match_struct(val: &Value, name: &str, field_patterns: &Array[(String, Pattern)]) -> Result[Option[Array[(String, Value)]], InterpreterError]:
    # TODO: [stdlib][P1] Implement struct pattern matching
    return Err(InterpreterError::NotImplemented("struct pattern".to_string()))

# Match enum pattern
fn match_enum(val: &Value, variant: &str, data_pattern: Option[&Pattern]) -> Result[Option[Array[(String, Value)]], InterpreterError]:
    match val.data.clone():
        case RuntimeValue::Enum { variant: v, data }:
            if v != variant:
                return Ok(None)

            match (data_pattern, data):
                case (Some(pat), Some(d)):
                    return match_pattern(&*d, pat)
                case (None, None):
                    return Ok(Some([]))
                case _:
                    return Ok(None)

        case _:
            return Ok(None)
