# Runtime Values
#
# Value representation for the interpreter.

export Value, ValueKind, RuntimeValue

# Value kinds
enum ValueKind:
    Nil
    Bool
    Int
    Float
    String
    Array
    Dict
    Tuple
    Struct
    Enum
    Function
    Closure
    Object

# Main value type
struct Value:
    kind: ValueKind
    data: RuntimeValue

# Runtime value variants
enum RuntimeValue:
    Nil
    Bool(bool)
    Int(i64)
    Float(f64)
    String(String)
    Array(Array[Value])
    Dict(Dict[Value, Value])
    Tuple(Array[Value])
    Struct { name: String, fields: Dict[String, Value] }
    Enum { variant: String, data: Option[Box[Value]] }
    Function { name: String, params: Array[String], body: Box[Block] }
    Closure { func: Box[RuntimeValue], env: Box[Environment] }
    Object { class: String, fields: Dict[String, Value] }

impl Value:
    # Constructors
    fn nil() -> Value:
        return Value { kind: ValueKind::Nil, data: RuntimeValue::Nil }

    fn bool(b: bool) -> Value:
        return Value { kind: ValueKind::Bool, data: RuntimeValue::Bool(b) }

    fn int(n: i64) -> Value:
        return Value { kind: ValueKind::Int, data: RuntimeValue::Int(n) }

    fn float(f: f64) -> Value:
        return Value { kind: ValueKind::Float, data: RuntimeValue::Float(f) }

    fn string(s: String) -> Value:
        return Value { kind: ValueKind::String, data: RuntimeValue::String(s) }

    fn array(arr: Array[Value]) -> Value:
        return Value { kind: ValueKind::Array, data: RuntimeValue::Array(arr) }

    fn dict(d: Dict[Value, Value]) -> Value:
        return Value { kind: ValueKind::Dict, data: RuntimeValue::Dict(d) }

    fn tuple(items: Array[Value]) -> Value:
        return Value { kind: ValueKind::Tuple, data: RuntimeValue::Tuple(items) }

    # Type checks
    fn is_nil(self) -> bool:
        return self.kind == ValueKind::Nil

    fn is_bool(self) -> bool:
        return self.kind == ValueKind::Bool

    fn is_int(self) -> bool:
        return self.kind == ValueKind::Int

    fn is_float(self) -> bool:
        return self.kind == ValueKind::Float

    fn is_string(self) -> bool:
        return self.kind == ValueKind::String

    fn is_array(self) -> bool:
        return self.kind == ValueKind::Array

    fn is_truthy(self) -> bool:
        match self.data:
            case RuntimeValue::Nil: return false
            case RuntimeValue::Bool(b): return b
            case RuntimeValue::Int(n): return n != 0
            case RuntimeValue::Float(f): return f != 0.0
            case RuntimeValue::String(s): return not s.is_empty()
            case RuntimeValue::Array(arr): return not arr.is_empty()
            case _: return true

    # Type conversions
    fn as_bool(self) -> Option[bool]:
        match self.data:
            case RuntimeValue::Bool(b): return Some(b)
            case _: return None

    fn as_int(self) -> Option[i64]:
        match self.data:
            case RuntimeValue::Int(n): return Some(n)
            case _: return None

    fn as_float(self) -> Option[f64]:
        match self.data:
            case RuntimeValue::Float(f): return Some(f)
            case RuntimeValue::Int(n): return Some(n as f64)
            case _: return None

    fn as_string(self) -> Option[&String]:
        match self.data:
            case RuntimeValue::String(ref s): return Some(s)
            case _: return None

    fn as_array(self) -> Option[&Array[Value]]:
        match self.data:
            case RuntimeValue::Array(ref arr): return Some(arr)
            case _: return None

impl Clone for Value:
    fn clone(self) -> Value:
        # TODO: Deep clone for complex types
        return Value { kind: self.kind, data: self.data.clone() }

impl Display for Value:
    fn fmt(self) -> String:
        match self.data:
            case RuntimeValue::Nil: return "nil".to_string()
            case RuntimeValue::Bool(b): return "{b}".to_string()
            case RuntimeValue::Int(n): return "{n}".to_string()
            case RuntimeValue::Float(f): return "{f}".to_string()
            case RuntimeValue::String(s): return "\"{s}\"".to_string()
            case RuntimeValue::Array(arr): return "[...]".to_string()
            case RuntimeValue::Dict(d): return "{{...}}".to_string()
            case _: return "<value>".to_string()
