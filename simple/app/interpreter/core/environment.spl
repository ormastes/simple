# Environment - Variable Bindings
#
# Manages variable scopes and bindings.

from value import {Value}

export Environment, Scope, Binding

# A single variable binding
struct Binding:
    name: String
    value: Value
    mutable: bool

# A single scope (lexical block)
struct Scope:
    bindings: Dict[String, Binding]
    parent: Option[&Scope]

impl Scope:
    static fn new() -> Scope:
        return Scope {
            bindings: Dict::new(),
            parent: None
        }

    fn with_parent(parent: &Scope) -> Scope:
        return Scope {
            bindings: Dict::new(),
            parent: Some(parent)
        }

    fn define(name: String, value: Value, mutable: bool):
        self.bindings.set(name.clone(), Binding {
            name: name,
            value: value,
            mutable: mutable
        })

    fn get(name: &str) -> Option[&Binding]:
        if val Some(binding) = self.bindings.get(name):
            return Some(binding)
        if val Some(parent) = self.parent:
            return parent.get(name)
        return None

    fn set(name: &str, value: Value) -> Result[(), String]:
        if val Some(binding) = self.bindings.get_mut(name):
            if not binding.mutable:
                return Err("Cannot assign to immutable variable: {name}".to_string())
            binding.value = value
            return Ok(())
        if val Some(parent) = self.parent:
            return parent.set(name, value)
        return Err("Undefined variable: {name}".to_string())

# The environment (stack of scopes)
struct Environment:
    scopes: Array[Scope]
    globals: Scope

impl Environment:
    static fn new() -> Environment:
        return Environment {
            scopes: [Scope::new()],
            globals: Scope::new()
        }

    # Enter a new scope
    fn push_scope():
        val parent = self.current_scope()
        self.scopes.push(Scope::with_parent(parent))

    # Exit current scope
    fn pop_scope():
        if self.scopes.len() > 1:
            self.scopes.pop()

    # Get current scope
    fn current_scope() -> &Scope:
        return &self.scopes[self.scopes.len() - 1]

    fn current_scope_mut() -> &mut Scope:
        val idx = self.scopes.len() - 1
        return &mut self.scopes[idx]

    # Define a variable in current scope
    fn define(name: String, value: Value):
        self.current_scope_mut().define(name, value, true)

    fn define_const(name: String, value: Value):
        self.current_scope_mut().define(name, value, false)

    # Get a variable
    fn get(name: &str) -> Option[Value]:
        if val Some(binding) = self.current_scope().get(name):
            return Some(binding.value.clone())
        if val Some(binding) = self.globals.get(name):
            return Some(binding.value.clone())
        return None

    # Set a variable
    fn set(name: &str, value: Value) -> Result[(), String]:
        return self.current_scope_mut().set(name, value)

    # Define a global
    fn define_global(name: String, value: Value):
        self.globals.define(name, value, true)
