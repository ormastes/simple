# Actor System
#
# Lightweight actors with message passing.

import ..core.{Interpreter, Value, InterpreterError}

export eval_spawn, eval_send, eval_receive, Actor, ActorRef, Message

# A message sent between actors
struct Message:
    sender: Option<ActorRef>
    payload: Value

# Reference to an actor
struct ActorRef:
    id: u64
    mailbox: Channel<Message>

impl ActorRef:
    fn send(msg: Value):
        self.mailbox.send(Message { sender: None, payload: msg })

    fn send_from(sender: ActorRef, msg: Value):
        self.mailbox.send(Message { sender: Some(sender), payload: msg })

# An actor instance
struct Actor:
    id: u64
    mailbox: Channel<Message>
    handler: Box<Fn(Message) -> Result<(), InterpreterError>>

impl Actor:
    fn new(id: u64, handler: Fn(Message) -> Result<(), InterpreterError>) -> Actor:
        return Actor {
            id: id,
            mailbox: Channel::new(),
            handler: Box::new(handler)
        }

    fn get_ref() -> ActorRef:
        return ActorRef {
            id: self.id,
            mailbox: self.mailbox.clone()
        }

    fn receive() -> Option<Message>:
        return self.mailbox.try_recv()

    fn receive_blocking() -> Message:
        return self.mailbox.recv()

# Global actor ID counter
static mut NEXT_ACTOR_ID: u64 = 0

# Spawn a new actor
fn eval_spawn(interp: &Interpreter, handler: &Expr) -> Result<Value, InterpreterError>:
    # Get next actor ID
    val id = unsafe {
        val id = NEXT_ACTOR_ID
        NEXT_ACTOR_ID += 1
        id
    }

    # Evaluate the handler function
    val handler_val = interp.evaluate(handler)?

    # Create actor
    match handler_val.as_function():
        case Some(func):
            # Capture the interpreter and function for handler invocation
            val captured_interp = interp.clone()
            val captured_func = func.clone()

            val actor = Actor::new(id, |msg| {
                # Invoke the handler function with the message
                match call_handler(&captured_interp, &captured_func, msg.payload):
                    case Ok(_): Ok(())
                    case Err(e): Err(e)
            })

            val actor_ref = actor.get_ref()

            # TODO: [stdlib][P3] Register actor with runtime and start processing
            # For now, just return the reference

            return Ok(Value::actor_ref(actor_ref))

        case None:
            return Err(InterpreterError::TypeError("spawn requires function".to_string()))

# Helper to invoke handler function
fn call_handler(interp: &Interpreter, func: &Value, msg: Value) -> Result<Value, InterpreterError>:
    import ..expr.calls.{call_value}
    return call_value(interp, func.clone(), [msg])

# Send a message to an actor
fn eval_send(interp: &Interpreter, target: &Expr, message: &Expr) -> Result<Value, InterpreterError>:
    val target_val = interp.evaluate(target)?
    val msg_val = interp.evaluate(message)?

    match target_val.as_actor_ref():
        case Some(actor_ref):
            actor_ref.send(msg_val)
            return Ok(Value::nil())

        case None:
            return Err(InterpreterError::TypeError("send target must be actor ref".to_string()))

# Receive a message (blocking)
fn eval_receive(interp: &Interpreter, timeout: Option<&Expr>) -> Result<Value, InterpreterError>:
    # Get current actor context
    match interp.current_actor():
        case Some(actor):
            match timeout:
                case Some(timeout_expr):
                    val timeout_val = interp.evaluate(timeout_expr)?
                    match timeout_val.as_int():
                        case Some(ms):
                            match actor.mailbox.recv_timeout(Duration::from_millis(ms as u64)):
                                case Some(msg): return Ok(msg.payload)
                                case None: return Ok(Value::nil())
                        case None:
                            return Err(InterpreterError::TypeError("timeout must be integer".to_string()))

                case None:
                    val msg = actor.receive_blocking()
                    return Ok(msg.payload)

        case None:
            return Err(InterpreterError::RuntimeError("receive called outside actor".to_string()))

# Receive with pattern matching
fn eval_receive_match(interp: &Interpreter, patterns: &Array<MatchArm>) -> Result<Value, InterpreterError>:
    match interp.current_actor():
        case Some(actor):
            # Stash for messages that don't match (selective receive)
            val stash: Array<Message> = []

            # Keep receiving until we get a matching message
            loop:
                val msg = actor.receive_blocking()

                # Try to match against patterns
                for arm in patterns:
                    if val Some(result) = try_match_message(interp, &msg.payload, arm)?:
                        # Requeue stashed messages before returning
                        for stashed_msg in stash.iter().rev():
                            actor.mailbox.send_front(stashed_msg.clone())
                        return Ok(result)

                # No match, stash the message for later
                stash.push(msg)

                # Safety limit to prevent infinite loops
                if stash.len() > 10000:
                    for stashed_msg in stash.iter().rev():
                        actor.mailbox.send_front(stashed_msg.clone())
                    return Err(InterpreterError::RuntimeError("receive stash overflow".to_string()))

        case None:
            return Err(InterpreterError::RuntimeError("receive called outside actor".to_string()))

# Helper to try matching a message
fn try_match_message(interp: &Interpreter, msg: &Value, arm: &MatchArm) -> Result<Option<Value>, InterpreterError>:
    import ..control.match.{match_pattern}

    # Try to match the message against the pattern
    match match_pattern(msg, &arm.pattern)?:
        case Some(bindings):
            # Pattern matched, check guard if present
            if val Some(guard) = arm.guard.as_ref():
                interp.env.push_scope()
                for (name, val) in bindings:
                    interp.env.define(name, val)

                val guard_result = interp.evaluate(guard)?
                if not guard_result.is_truthy():
                    interp.env.pop_scope()
                    return Ok(None)

                val result = interp.evaluate(&arm.body)?
                interp.env.pop_scope()
                return Ok(Some(result))
            else:
                interp.env.push_scope()
                for (name, val) in bindings:
                    interp.env.define(name, val)

                val result = interp.evaluate(&arm.body)?
                interp.env.pop_scope()
                return Ok(Some(result))

        case None:
            return Ok(None)

# Self reference - get current actor's ref
fn eval_self(interp: &Interpreter) -> Result<Value, InterpreterError>:
    match interp.current_actor():
        case Some(actor):
            return Ok(Value::actor_ref(actor.get_ref()))
        case None:
            return Err(InterpreterError::RuntimeError("self called outside actor".to_string()))
