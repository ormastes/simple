# Futures and Async/Await
#
# Async function execution and await handling.

import ..core.{Interpreter, Value, InterpreterError}

export eval_async, eval_await, Future, FutureState

# Future states
enum FutureState:
    Pending
    Ready(Value)
    Failed(InterpreterError)

# A future representing an async computation
struct Future:
    state: FutureState
    body: Option<Box<Expr>>
    result: Option<Value>

impl Future:
    fn new(body: &Expr) -> Future:
        return Future {
            state: FutureState::Pending,
            body: Some(Box::new(body.clone())),
            result: None
        }

    fn is_ready() -> bool:
        match self.state:
            case FutureState::Ready(_): return true
            case _: return false

    fn is_pending() -> bool:
        match self.state:
            case FutureState::Pending: return true
            case _: return false

    fn get_result() -> Option<Value>:
        match self.state:
            case FutureState::Ready(val): return Some(val)
            case _: return None

# Evaluate an async expression - creates a future
fn eval_async(interp: &Interpreter, body: &Expr) -> Result<Value, InterpreterError>:
    val future = Future::new(body)
    return Ok(Value::future(future))

# Await a future - blocks until ready
fn eval_await(interp: &Interpreter, future_expr: &Expr) -> Result<Value, InterpreterError>:
    val future_val = interp.evaluate(future_expr)?

    match future_val.as_future():
        case Some(future):
            return await_future(interp, future)
        case None:
            return Err(InterpreterError::TypeError("cannot await non-future".to_string()))

# Actually await the future
fn await_future(interp: &Interpreter, future: &mut Future) -> Result<Value, InterpreterError>:
    # If already ready, return result
    if val Some(result) = future.get_result():
        return Ok(result)

    # Otherwise, execute the body
    match future.body.take():
        case Some(body):
            match interp.evaluate(&*body):
                case Ok(val):
                    future.state = FutureState::Ready(val.clone())
                    return Ok(val)
                case Err(e):
                    future.state = FutureState::Failed(e.clone())
                    return Err(e)

        case None:
            return Err(InterpreterError::RuntimeError("future already consumed".to_string()))

# Poll a future without blocking
fn poll_future(future: &mut Future) -> FutureState:
    return future.state.clone()

# Create a completed future
fn completed_future(val: Value) -> Future:
    return Future {
        state: FutureState::Ready(val),
        body: None,
        result: None
    }

# Create a failed future
fn failed_future(err: InterpreterError) -> Future:
    return Future {
        state: FutureState::Failed(err),
        body: None,
        result: None
    }

# Join multiple futures
fn join_all(interp: &Interpreter, futures: Array<Future>) -> Result<Array<Value>, InterpreterError>:
    val results: Array<Value> = []

    for mut future in futures:
        val result = await_future(interp, &mut future)?
        results.push(result)

    return Ok(results)

# Select first completed future
fn select_first(interp: &Interpreter, futures: Array<Future>) -> Result<(usize, Value), InterpreterError>:
    # Simple implementation: try each in order
    # TODO: [stdlib][P1] Real implementation would use proper polling
    for (idx, mut future) in futures.iter_mut().enumerate():
        if future.is_ready():
            val val = future.get_result().unwrap()
            return Ok((idx, val))

    # None ready, await first
    var first = futures[0]
    val val = await_future(interp, &mut first)?
    return Ok((0, val))
