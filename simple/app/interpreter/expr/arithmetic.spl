# Arithmetic Operations
#
# Binary operators: +, -, *, /, %, **
# Unary operators: -, +, not

import ..core.{Value, InterpreterError}

export eval_binary_op, eval_unary_op

# Binary operation evaluation
fn eval_binary_op(op: &BinOp, left: Value, right: Value) -> Result<Value, InterpreterError>:
    match op:
        case BinOp::Add:
            return eval_add(left, right)
        case BinOp::Sub:
            return eval_sub(left, right)
        case BinOp::Mul:
            return eval_mul(left, right)
        case BinOp::Div:
            return eval_div(left, right)
        case BinOp::Mod:
            return eval_mod(left, right)
        case BinOp::Pow:
            return eval_pow(left, right)
        case BinOp::Eq:
            return eval_eq(left, right)
        case BinOp::Ne:
            return eval_ne(left, right)
        case BinOp::Lt:
            return eval_lt(left, right)
        case BinOp::Le:
            return eval_le(left, right)
        case BinOp::Gt:
            return eval_gt(left, right)
        case BinOp::Ge:
            return eval_ge(left, right)
        case BinOp::And:
            return eval_and(left, right)
        case BinOp::Or:
            return eval_or(left, right)
        case _:
            return Err(InterpreterError::NotImplemented("binary op".to_string()))

# Unary operation evaluation
fn eval_unary_op(op: &UnaryOp, val: Value) -> Result<Value, InterpreterError>:
    match op:
        case UnaryOp::Neg:
            return eval_neg(val)
        case UnaryOp::Not:
            return eval_not(val)
        case UnaryOp::Pos:
            return Ok(val)
        case UnaryOp::Move:
            # Move is a semantic marker for explicit ownership transfer
            # In the interpreter, it's a no-op - ownership tracking happens elsewhere
            return Ok(val)
        case _:
            return Err(InterpreterError::NotImplemented("unary op".to_string()))

# Addition
fn eval_add(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::int(l + r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l + r))
        case _:
            pass

    match (left.as_string(), right.as_string()):
        case (Some(l), Some(r)):
            return Ok(Value::string(l.clone() + r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot add these types".to_string()))

# Subtraction
fn eval_sub(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::int(l - r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l - r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot subtract these types".to_string()))

# Multiplication
fn eval_mul(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::int(l * r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l * r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot multiply these types".to_string()))

# Division
fn eval_div(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            if r == 0:
                return Err(InterpreterError::DivisionByZero)
            return Ok(Value::int(l / r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            if r == 0.0:
                return Err(InterpreterError::DivisionByZero)
            return Ok(Value::float(l / r))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot divide these types".to_string()))

# Modulo
fn eval_mod(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            if r == 0:
                return Err(InterpreterError::DivisionByZero)
            return Ok(Value::int(l % r))
        case _:
            return Err(InterpreterError::TypeError("modulo requires integers".to_string()))

# Power
fn eval_pow(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::float(l.pow(r)))
        case _:
            return Err(InterpreterError::TypeError("power requires numbers".to_string()))

# Negation
fn eval_neg(val: Value) -> Result<Value, InterpreterError>:
    match val.as_int():
        case Some(n):
            return Ok(Value::int(-n))
        case _:
            pass

    match val.as_float():
        case Some(f):
            return Ok(Value::float(-f))
        case _:
            pass

    return Err(InterpreterError::TypeError("cannot negate this type".to_string()))

# Logical not
fn eval_not(val: Value) -> Result<Value, InterpreterError>:
    return Ok(Value::bool(not val.is_truthy()))

# Comparison operations
fn eval_eq(left: Value, right: Value) -> Result<Value, InterpreterError>:
    # Deep equality comparison for all value types
    val is_equal = values_equal(left, right)
    return Ok(Value::bool(is_equal))

# Deep equality helper
fn values_equal(left: Value, right: Value) -> bool:
    # Different kinds are not equal
    if left.kind != right.kind:
        return false

    match (left.data, right.data):
        # Nil
        case (RuntimeValue::Nil, RuntimeValue::Nil):
            return true

        # Bool
        case (RuntimeValue::Bool(l), RuntimeValue::Bool(r)):
            return l == r

        # Int
        case (RuntimeValue::Int(l), RuntimeValue::Int(r)):
            return l == r

        # Float
        case (RuntimeValue::Float(l), RuntimeValue::Float(r)):
            return l == r

        # String
        case (RuntimeValue::String(l), RuntimeValue::String(r)):
            return l == r

        # Array - deep comparison
        case (RuntimeValue::Array(l_arr), RuntimeValue::Array(r_arr)):
            if l_arr.len() != r_arr.len():
                return false
            var i = 0
            while i < l_arr.len():
                if not values_equal(l_arr[i], r_arr[i]):
                    return false
                i = i + 1
            return true

        # Tuple - deep comparison
        case (RuntimeValue::Tuple(l_items), RuntimeValue::Tuple(r_items)):
            if l_items.len() != r_items.len():
                return false
            var i = 0
            while i < l_items.len():
                if not values_equal(l_items[i], r_items[i]):
                    return false
                i = i + 1
            return true

        # Struct - compare name and fields
        case (RuntimeValue::Struct{name: l_name, fields: l_fields},
              RuntimeValue::Struct{name: r_name, fields: r_fields}):
            if l_name != r_name:
                return false
            if l_fields.len() != r_fields.len():
                return false
            # Compare all fields
            for (key, l_val) in l_fields:
                match r_fields.get(key):
                    case Some(r_val):
                        if not values_equal(l_val, r_val):
                            return false
                    case None:
                        return false
            return true

        # Enum - compare variant and data
        case (RuntimeValue::Enum{variant: l_var, data: l_data},
              RuntimeValue::Enum{variant: r_var, data: r_data}):
            if l_var != r_var:
                return false
            match (l_data, r_data):
                case (Some(l_box), Some(r_box)):
                    return values_equal(*l_box, *r_box)
                case (None, None):
                    return true
                case _:
                    return false

        # Function - compare by name (reference equality)
        case (RuntimeValue::Function{name: l_name, ..},
              RuntimeValue::Function{name: r_name, ..}):
            return l_name == r_name

        # Object - compare class and fields
        case (RuntimeValue::Object{class: l_class, fields: l_fields},
              RuntimeValue::Object{class: r_class, fields: r_fields}):
            if l_class != r_class:
                return false
            if l_fields.len() != r_fields.len():
                return false
            for (key, l_val) in l_fields:
                match r_fields.get(key):
                    case Some(r_val):
                        if not values_equal(l_val, r_val):
                            return false
                    case None:
                        return false
            return true

        # Dict - deep comparison of key-value pairs
        case (RuntimeValue::Dict(l_dict), RuntimeValue::Dict(r_dict)):
            if l_dict.len() != r_dict.len():
                return false
            # Note: This is a simplified comparison
            # Full dict comparison would need to compare keys and values
            # For now, we compare string representations
            return l_dict.to_string() == r_dict.to_string()

        # Closure - compare by reference (not deep equality)
        case (RuntimeValue::Closure{..}, RuntimeValue::Closure{..}):
            # Closures are compared by reference, not value
            return false

        # Default: not equal
        case _:
            return false

fn eval_ne(left: Value, right: Value) -> Result<Value, InterpreterError>:
    val eq = eval_eq(left, right)?
    return eval_not(eq)

fn eval_lt(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l < r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l < r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

fn eval_le(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l <= r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l <= r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

fn eval_gt(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l > r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l > r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

fn eval_ge(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l >= r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value::bool(l >= r))
        case _:
            pass
    return Err(InterpreterError::TypeError("cannot compare these types".to_string()))

# Logical operations
fn eval_and(left: Value, right: Value) -> Result<Value, InterpreterError>:
    if not left.is_truthy():
        return Ok(left)
    return Ok(right)

fn eval_or(left: Value, right: Value) -> Result<Value, InterpreterError>:
    if left.is_truthy():
        return Ok(left)
    return Ok(right)
