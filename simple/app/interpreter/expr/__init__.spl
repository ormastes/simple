# Expression Evaluation
#
# All expression evaluation logic.

from literals import {eval_literal}
from arithmetic import {eval_binary_op, eval_unary_op}
from collections import {eval_array, eval_dict, eval_tuple}
from calls import {eval_call, eval_method_call}

export eval_expr, evaluate
export eval_literal, eval_binary_op, eval_unary_op
export eval_array, eval_dict, eval_tuple
export eval_call, eval_method_call

import ..core.{Interpreter, Value, InterpreterError}

# Main expression evaluator
fn evaluate(interp: &Interpreter, expr: &Expr) -> Result[Value, InterpreterError]:
    match expr:
        case Expr::Literal(lit):
            return eval_literal(lit)

        case Expr::Identifier(name):
            match interp.env.get(name):
                case Some(val): return Ok(val)
                case None: return Err(InterpreterError::NameError(name.clone()))

        case Expr::Binary(op, left, right):
            let l = evaluate(interp, left)?
            let r = evaluate(interp, right)?
            return eval_binary_op(op, l, r)

        case Expr::Unary(op, operand):
            let val = evaluate(interp, operand)?
            return eval_unary_op(op, val)

        case Expr::Call(callee, args):
            return eval_call(interp, callee, args)

        case Expr::MethodCall(obj, method, args):
            return eval_method_call(interp, obj, method, args)

        case Expr::Index(collection, index):
            let coll = evaluate(interp, collection)?
            let idx = evaluate(interp, index)?
            return eval_index(coll, idx)

        case Expr::Field(obj, field):
            let o = evaluate(interp, obj)?
            return eval_field(o, field)

        case Expr::Array(elements):
            return eval_array(interp, elements)

        case Expr::Dict(pairs):
            return eval_dict(interp, pairs)

        case Expr::Tuple(elements):
            return eval_tuple(interp, elements)

        case Expr::Lambda(params, body):
            return eval_lambda(interp, params, body)

        case _:
            return Err(InterpreterError::NotImplemented(expr.to_string()))

fn eval_index(coll: Value, idx: Value) -> Result[Value, InterpreterError]:
    # TODO: Implement indexing
    return Err(InterpreterError::NotImplemented("indexing".to_string()))

fn eval_field(obj: Value, field: &str) -> Result[Value, InterpreterError]:
    # TODO: Implement field access
    return Err(InterpreterError::NotImplemented("field access".to_string()))

fn eval_lambda(interp: &Interpreter, params: &Array[String], body: &Expr) -> Result[Value, InterpreterError]:
    # TODO: Implement lambda creation
    return Err(InterpreterError::NotImplemented("lambda".to_string()))

# Alias for main entry point
fn eval_expr(interp: &Interpreter, expr: &Expr) -> Result[Value, InterpreterError]:
    return evaluate(interp, expr)
