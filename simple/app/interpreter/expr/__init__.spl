# Expression Evaluation
#
# All expression evaluation logic.

from literals import {eval_literal}
from arithmetic import {eval_binary_op, eval_unary_op}
from collections import {eval_array, eval_dict, eval_tuple}
from calls import {eval_call, eval_method_call}

export eval_expr, evaluate
export eval_literal, eval_binary_op, eval_unary_op
export eval_array, eval_dict, eval_tuple
export eval_call, eval_method_call

import ..core.{Interpreter, Value, InterpreterError, RuntimeValue, Closure}

# Main expression evaluator
fn evaluate(interp: &Interpreter, expr: &Expr) -> Result<Value, InterpreterError>:
    match expr:
        case Expr::Literal(lit):
            return eval_literal(lit)

        case Expr::Identifier(name):
            match interp.env.get(name):
                case Some(val): return Ok(val)
                case None: return Err(InterpreterError::NameError(name.clone()))

        case Expr::Binary(op, left, right):
            val l = evaluate(interp, left)?
            val r = evaluate(interp, right)?
            return eval_binary_op(op, l, r)

        case Expr::Unary(op, operand):
            val val = evaluate(interp, operand)?
            return eval_unary_op(op, val)

        case Expr::Call(callee, args):
            return eval_call(interp, callee, args)

        case Expr::MethodCall(obj, method, args):
            return eval_method_call(interp, obj, method, args)

        case Expr::Index(collection, index):
            val coll = evaluate(interp, collection)?
            val idx = evaluate(interp, index)?
            return eval_index(coll, idx)

        case Expr::Field(obj, field):
            val o = evaluate(interp, obj)?
            return eval_field(o, field)

        case Expr::Array(elements):
            return eval_array(interp, elements)

        case Expr::Dict(pairs):
            return eval_dict(interp, pairs)

        case Expr::Tuple(elements):
            return eval_tuple(interp, elements)

        case Expr::Lambda(params, body):
            return eval_lambda(interp, params, body)

        case _:
            return Err(InterpreterError::NotImplemented(expr.to_string()))

fn eval_index(coll: Value, idx: Value) -> Result<Value, InterpreterError>:
    match coll.data:
        case RuntimeValue::Array(arr):
            match idx.as_int():
                case Some(i):
                    val index = if i < 0: arr.len() as i64 + i else: i
                    if index >= 0 and index < arr.len() as i64:
                        return Ok(arr[index as usize].clone())
                    else:
                        return Err(InterpreterError::IndexError(i, arr.len()))
                case None:
                    return Err(InterpreterError::TypeError("array index must be int".to_string()))

        case RuntimeValue::String(s):
            match idx.as_int():
                case Some(i):
                    val index = if i < 0: s.len() as i64 + i else: i
                    if index >= 0 and index < s.len() as i64:
                        val ch = s.chars().nth(index as usize).unwrap()
                        return Ok(Value::string(ch.to_string()))
                    else:
                        return Err(InterpreterError::IndexError(i, s.len()))
                case None:
                    return Err(InterpreterError::TypeError("string index must be int".to_string()))

        case RuntimeValue::Dict(d):
            match d.get(&idx):
                case Some(v): return Ok(v.clone())
                case None: return Err(InterpreterError::KeyError(idx.to_string()))

        case RuntimeValue::Tuple(t):
            match idx.as_int():
                case Some(i):
                    val index = if i < 0: t.len() as i64 + i else: i
                    if index >= 0 and index < t.len() as i64:
                        return Ok(t[index as usize].clone())
                    else:
                        return Err(InterpreterError::IndexError(i, t.len()))
                case None:
                    return Err(InterpreterError::TypeError("tuple index must be int".to_string()))

        case _:
            return Err(InterpreterError::TypeError("value is not indexable".to_string()))

fn eval_field(obj: Value, field: &str) -> Result<Value, InterpreterError>:
    match obj.data:
        case RuntimeValue::Struct(name, fields):
            match fields.get(field):
                case Some(v): return Ok(v.clone())
                case None: return Err(InterpreterError::AttributeError(name.clone(), field.to_string()))

        case RuntimeValue::Object(class_name, fields, _methods):
            match fields.get(field):
                case Some(v): return Ok(v.clone())
                case None: return Err(InterpreterError::AttributeError(class_name.clone(), field.to_string()))

        case RuntimeValue::Dict(d):
            val key = Value::string(field.to_string())
            match d.get(&key):
                case Some(v): return Ok(v.clone())
                case None: return Err(InterpreterError::KeyError(field.to_string()))

        case _:
            return Err(InterpreterError::TypeError("value has no fields".to_string()))

fn eval_lambda(interp: &Interpreter, params: &Array<String>, body: &Expr) -> Result<Value, InterpreterError>:
    # Capture the current environment for closure
    val captured_env = interp.env.clone()
    val closure = Closure {
        params: params.clone(),
        body: body.clone(),
        env: captured_env,
    }
    return Ok(Value::closure(closure))

# Alias for main entry point
fn eval_expr(interp: &Interpreter, expr: &Expr) -> Result<Value, InterpreterError>:
    return evaluate(interp, expr)
