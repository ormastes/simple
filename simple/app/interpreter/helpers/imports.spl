# Import Resolution
#
# Module loading and import handling.

import ..core.{Interpreter, Value, InterpreterError}
import std.fs
import std.path

export resolve_import, ImportResolver, ModuleCache, Module

# A loaded module
struct Module:
    path: String
    name: String
    exports: Dict<String, Value>
    is_loaded: bool

impl Module:
    fn new(path: &str, name: &str) -> Module:
        return Module {
            path: path.to_string(),
            name: name.to_string(),
            exports: Dict::new(),
            is_loaded: false
        }

    fn get_export(name: &str) -> Option<&Value>:
        return self.exports.get(name)

    fn has_export(name: &str) -> bool:
        return self.exports.contains_key(name)

# Module cache
struct ModuleCache:
    modules: Dict<String, Module>
    search_paths: Array<String>

impl ModuleCache:
    static fn new() -> ModuleCache:
        return ModuleCache {
            modules: Dict::new(),
            search_paths: [
                ".".to_string(),
                "./lib".to_string(),
                "./simple/std_lib/src".to_string()
            ]
        }

    fn add_search_path(path: String):
        self.search_paths.push(path)

    fn get_module(name: &str) -> Option<&Module>:
        return self.modules.get(name)

    fn has_module(name: &str) -> bool:
        return self.modules.contains_key(name)

    fn add_module(module: Module):
        self.modules.set(module.name.clone(), module)

# Import resolver
struct ImportResolver:
    cache: ModuleCache
    current_path: String

impl ImportResolver:
    static fn new() -> ImportResolver:
        return ImportResolver {
            cache: ModuleCache::new(),
            current_path: ".".to_string()
        }

    fn set_current_path(path: String):
        self.current_path = path

# Resolve an import statement
fn resolve_import(resolver: &mut ImportResolver, import: &ImportStmt) -> Result<Dict<String, Value>, InterpreterError>:
    match import:
        case ImportStmt::Simple { path, alias }:
            return resolve_simple_import(resolver, path, alias)

        case ImportStmt::From { path, items }:
            return resolve_from_import(resolver, path, items)

        case ImportStmt::Wildcard { path }:
            return resolve_wildcard_import(resolver, path)

# Resolve a simple import: import foo.bar
fn resolve_simple_import(resolver: &mut ImportResolver, path: &ModulePath, alias: Option<&str>) -> Result<Dict<String, Value>, InterpreterError>:
    val module = load_module(resolver, path)?

    val name = match alias:
        case Some(a): a.to_string()
        case None: path.last().to_string()

    val result: Dict<String, Value> = Dict::new()
    result.set(name, Value::module(module.clone()))
    return Ok(result)

# Resolve a from import: from foo.bar import {x, y}
fn resolve_from_import(resolver: &mut ImportResolver, path: &ModulePath, items: &Array<ImportItem>) -> Result<Dict<String, Value>, InterpreterError>:
    val module = load_module(resolver, path)?

    val result: Dict<String, Value> = Dict::new()

    for item in items:
        val export_name = &item.name
        val local_name = match item.alias:
            case Some(a): a.clone()
            case None: export_name.clone()

        match module.get_export(export_name):
            case Some(val):
                result.set(local_name, val.clone())
            case None:
                return Err(InterpreterError::ImportError(
                    "cannot import '{export_name}' from '{path}'".to_string()
                ))

    return Ok(result)

# Resolve a wildcard import: from foo.bar import *
fn resolve_wildcard_import(resolver: &mut ImportResolver, path: &ModulePath) -> Result<Dict<String, Value>, InterpreterError>:
    val module = load_module(resolver, path)?

    val result: Dict<String, Value> = Dict::new()
    for (name, val) in module.exports:
        # Skip private names (starting with _)
        if not name.starts_with("_"):
            result.set(name.clone(), val.clone())

    return Ok(result)

# Load a module by path
fn load_module(resolver: &mut ImportResolver, path: &ModulePath) -> Result<&Module, InterpreterError>:
    val module_name = path.to_string()

    # Check cache
    if resolver.cache.has_module(&module_name):
        return Ok(resolver.cache.get_module(&module_name).unwrap())

    # Find module file
    val file_path = find_module_file(resolver, path)?

    # Load and execute module
    val module = execute_module(resolver, &file_path, &module_name)?

    # Cache and return
    resolver.cache.add_module(module)
    return Ok(resolver.cache.get_module(&module_name).unwrap())

# Find the file for a module path
fn find_module_file(resolver: &ImportResolver, path: &ModulePath) -> Result<String, InterpreterError>:
    val relative_path = path.segments.join("/")

    for search_path in resolver.cache.search_paths:
        # Try as directory with __init__.spl
        val dir_path = path::join(&search_path, &relative_path)
        val init_path = path::join(&dir_path, "__init__.spl")
        if fs::exists(&init_path):
            return Ok(init_path)

        # Try as .spl file
        val file_path = path::join(&search_path, "{relative_path}.spl")
        if fs::exists(&file_path):
            return Ok(file_path)

    return Err(InterpreterError::ImportError("module not found: {path}".to_string()))

# Execute a module file and extract exports
fn execute_module(resolver: &mut ImportResolver, file_path: &str, module_name: &str) -> Result<Module, InterpreterError>:
    # Read file
    val source = match fs::read_string(file_path):
        case Ok(s): s
        case Err(e): return Err(InterpreterError::IOError(e.to_string()))

    # Parse file
    val ast = match parse(source):
        case Ok(a): a
        case Err(e): return Err(InterpreterError::ParseError(e.to_string()))

    # Create module
    var module = Module::new(file_path, module_name)

    # Create interpreter for module
    var interp = Interpreter::new()
    interp.set_current_module(&module)

    # Execute statements
    for stmt in ast.statements:
        match stmt:
            case Statement::Export { names }:
                # Record exports
                for name in names:
                    if val Some(val) = interp.env.get(&name):
                        module.exports.set(name.clone(), val.clone())

            case _:
                interp.eval_statement(&stmt)?

    module.is_loaded = true
    return Ok(module)

# Module path representation
struct ModulePath:
    segments: Array<String>
    is_relative: bool

impl ModulePath:
    fn from_string(s: &str) -> ModulePath:
        val is_relative = s.starts_with(".")
        val segments: Array<String> = s.split(".").map(|s| s.to_string()).collect()
        return ModulePath { segments, is_relative }

    fn to_string() -> String:
        return self.segments.join(".")

    fn last() -> &String:
        return &self.segments[self.segments.len() - 1]

# Import item (name with optional alias)
struct ImportItem:
    name: String
    alias: Option<String>
