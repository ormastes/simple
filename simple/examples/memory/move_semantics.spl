# Move Semantics in Simple
#
# The `move` keyword explicitly transfers ownership of a unique pointer,
# preventing implicit copies that could violate memory safety.
#
# Simple's Memory Model:
# - Shared pointers (*T): Automatic COW, can be copied freely
# - Unique pointers (&T): Exclusive ownership, move-only by default
# - Mutable borrows (&mut T): Exclusive access, cannot be copied
#
# Use `move` to:
# 1. Satisfy the compiler when transferring unique pointer ownership
# 2. Make ownership transfer explicit and clear in code
# 3. Avoid the W1002 "implicit unique copy" warning

# ============================================================================
# Example 1: Basic Move Semantics
# ============================================================================

fn example_basic_move():
    print("\n=== Example 1: Basic Move ===")

    # Create a unique pointer
    val data = UniqueData(42)
    print("Created unique data: {data.value}")

    # ERROR: This would trigger W1002 warning (implicit copy)
    # val copy = data

    # OK: Explicit move transfers ownership
    val moved = move data
    print("Moved ownership, new value: {moved.value}")

    # Note: `data` is now moved and cannot be used
    # Using `data` here would be a compile error

# ============================================================================
# Example 2: Move in Function Calls
# ============================================================================

fn example_move_to_function():
    print("\n=== Example 2: Move to Function ===")

    val resource = Resource("database connection")
    print("Created resource: {resource.name}")

    # Pass ownership to function using explicit move
    consume_resource(move resource)

    # `resource` cannot be used here anymore

fn consume_resource(r: Resource):
    print("Consuming resource: {r.name}")
    # Resource is automatically cleaned up when function ends

# ============================================================================
# Example 3: Move in Collections
# ============================================================================

fn example_move_into_collection():
    print("\n=== Example 3: Move into Collection ===")

    val item1 = UniqueData(1)
    val item2 = UniqueData(2)
    val item3 = UniqueData(3)

    # Build collection by moving ownership of each item
    val collection = [
        move item1,
        move item2,
        move item3
    ]

    print("Collection size: {collection.len()}")
    # Items are now owned by the collection

# ============================================================================
# Example 4: Move vs Clone
# ============================================================================

fn example_move_vs_clone():
    print("\n=== Example 4: Move vs Clone ===")

    val original = UniqueData(100)

    # Move: Transfer ownership (no copy)
    val moved = move original
    print("Moved (no copy): {moved.value}")

    # Clone: Explicit deep copy
    val cloned = moved.clone()
    print("Cloned (explicit copy): {cloned.value}")

    # Both `moved` and `cloned` can be used
    print("Original moved value still accessible: {moved.value}")

# ============================================================================
# Example 5: Move in Pattern Matching
# ============================================================================

fn example_move_in_match():
    print("\n=== Example 5: Move in Match ===")

    val maybe_data = Some(UniqueData(999))

    match maybe_data:
        case Some(move data):
            print("Got data by move: {data.value}")
            # `data` is owned by this branch
        case None:
            print("No data")

# ============================================================================
# Example 6: Returning Moved Values
# ============================================================================

fn create_and_move() -> UniqueData:
    val data = UniqueData(777)
    # Explicit move when returning
    return move data

fn example_return_move():
    print("\n=== Example 6: Return with Move ===")

    val result = create_and_move()
    print("Received moved value: {result.value}")

# ============================================================================
# Helper Types
# ============================================================================

struct UniqueData:
    value: i64

    impl:
        fn clone() -> UniqueData:
            # Explicit clone implementation
            return UniqueData(self.value)

struct Resource:
    name: String

# ============================================================================
# Main - Run All Examples
# ============================================================================

fn main():
    print("==============================================")
    print("  Simple Language: Move Semantics Examples")
    print("==============================================")

    example_basic_move()
    example_move_to_function()
    example_move_into_collection()
    example_move_vs_clone()
    example_move_in_match()
    example_return_move()

    print("\n==============================================")
    print("  All examples completed successfully!")
    print("==============================================")

# Run if executed directly
if __name__ == "__main__":
    main()
