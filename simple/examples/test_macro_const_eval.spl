# Test macro const-eval loops and conditionals in intro specs

# Test 1: Generate multiple functions using for loop
# NOTE: We manually define each function in emit block to match intro declarations
macro gen_three_getters() -> (
    intro getters: for i in 0..3: enclosing.module.fn "get_value_{i}"() -> Int
):
    emit getters:
        fn get_value_0() -> Int:
            return 0
        fn get_value_1() -> Int:
            return 10
        fn get_value_2() -> Int:
            return 20

# Generate get_value_0, get_value_1, get_value_2
gen_three_getters!()

# Test 2: Conditional function generation
# Create function only when condition is true
macro gen_when_true() -> (
    intro maybe_func:
        if 1 == 1:
            enclosing.module.fn "conditional_func"() -> Str
):
    emit maybe_func:
        fn conditional_func() -> Str:
            return "Function was created!"

# Test with false condition - no function generated
macro gen_when_false() -> (
    intro nothing:
        if 0 == 1:
            enclosing.module.fn "should_not_exist"() -> Str
):
    emit nothing:
        # Empty block - would emit nothing when condition is false
        let _ = 0

gen_when_true!()
gen_when_false!()

fn main():
    # Test generated functions from loop
    let val0 = get_value_0()
    let val1 = get_value_1()
    let val2 = get_value_2()

    println!("Value 0: ", val0)
    println!("Value 1: ", val1)
    println!("Value 2: ", val2)

    assert_eq!(val0, 0)
    assert_eq!(val1, 10)
    assert_eq!(val2, 20)

    # Test conditional generation
    let msg = conditional_func()
    println!("Conditional: ", msg)
    assert_eq!(msg, "Function was created!")

    println!("All const-eval tests passed!")
