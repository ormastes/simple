# Basic Vulkan Window Example
#
# Demonstrates creating a window, handling events, and basic event-driven rendering.
# This example shows the minimal code needed for a Simple+Vulkan application.

use ui.gui.vulkan_window.*
use core.*

fn main():
    print("Creating Vulkan window...")

    # Create window (1280x720)
    let window = match Window::new(1280, 720, "Simple Vulkan Window"):
        case Ok(w): w
        case Err(e):
            print("ERROR: Failed to create window: " + e)
            return

    print("Window created successfully!")
    print("Press ESC to exit, F11 to toggle fullscreen")

    # Main event loop
    let mut running = true
    let mut frame_count = 0
    let mut is_fullscreen = false

    while running:
        # Poll all available events
        while true:
            let event = window.poll_event()
            match event:
                case None:
                    break  # No more events

                case Some(WindowEvent::CloseRequested):
                    print("Close requested by user")
                    running = false

                case Some(WindowEvent::Resized(width, height)):
                    print("Window resized to " + str(width) + "x" + str(height))

                case Some(WindowEvent::Focused(focused)):
                    if focused:
                        print("Window gained focus")
                    else:
                        print("Window lost focus")

                case Some(WindowEvent::MouseMoved(x, y)):
                    # Uncomment to see mouse movement (very verbose!)
                    # print("Mouse moved to (" + str(x) + ", " + str(y) + ")")
                    pass

                case Some(WindowEvent::MouseButton(button, pressed)):
                    if pressed:
                        print("Mouse button " + str(button) + " pressed")
                    else:
                        print("Mouse button " + str(button) + " released")

                case Some(WindowEvent::KeyEvent(key_code, pressed)):
                    if pressed:
                        handle_key_press(key_code, &mut running, &window, &mut is_fullscreen)

                case Some(WindowEvent::Moved(x, y)):
                    print("Window moved to (" + str(x) + ", " + str(y) + ")")

                case Some(WindowEvent::Unknown):
                    print("WARNING: Unknown event type received")

        # Render frame (placeholder)
        render_frame(frame_count)
        frame_count += 1

        # Sleep a bit to avoid busy-waiting (16ms â‰ˆ 60 FPS)
        # In real application, use wait_event() or proper frame pacing
        sleep_ms(16)

    print("Shutting down...")
    print("Total frames rendered: " + str(frame_count))

# Handle keyboard input
fn handle_key_press(key_code: u32, running: &mut bool, window: &Window, is_fullscreen: &mut bool):
    match key_code:
        case 27:  # ESC key
            print("ESC pressed - exiting")
            *running = false

        case 122:  # F11 key
            *is_fullscreen = !*is_fullscreen
            let mode = if *is_fullscreen:
                print("Entering fullscreen mode")
                FullscreenMode::Borderless
            else:
                print("Entering windowed mode")
                FullscreenMode::Windowed

            match window.set_fullscreen(mode):
                case Ok(_):
                    print("Fullscreen mode changed successfully")
                case Err(e):
                    print("ERROR: Failed to change fullscreen mode: " + e)

        case _:
            print("Key pressed: " + str(key_code))

# Placeholder render function
fn render_frame(frame_count: i32):
    # In a real application, this would:
    # 1. Acquire next swapchain image
    # 2. Record rendering commands
    # 3. Submit commands to GPU
    # 4. Present to screen

    # For this basic example, just print frame count every 60 frames
    if frame_count % 60 == 0:
        print("Frame " + str(frame_count))

# Sleep for specified milliseconds
fn sleep_ms(ms: u64):
    # TODO: Replace with actual sleep implementation from stdlib
    # For now, busy wait (not ideal!)
    let start = get_time_ms()
    while get_time_ms() - start < ms:
        pass

# Get current time in milliseconds
fn get_time_ms() -> u64:
    # TODO: Replace with actual time implementation from stdlib
    # Placeholder: return monotonic increasing value
    return 0
