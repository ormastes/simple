# Simple Godot Game Example
#
# Demonstrates using Simple language with Godot Engine:
# - Custom node classes
# - Signal connections
# - Input handling
# - Transform manipulations
# - Game logic in Simple
#
# Based on: Godot 4.3+ with Simple GDExtension

use godot.*
use godot.core.*
use godot.variant.*
use godot.node.*
use godot.signal.*
use graphics.math.*

# =============================================================================
# PlayerController - Player movement and camera control
# =============================================================================

pub class PlayerController extends Node3D:
    # Movement parameters
    move_speed: f32 = 5.0
    jump_force: f32 = 10.0
    mouse_sensitivity: f32 = 0.002
    gravity: f32 = -20.0

    # State
    velocity: Vec3 = Vec3::zero()
    is_on_ground: bool = false

    # Input state
    input_forward: f32 = 0.0
    input_right: f32 = 0.0
    input_jump: bool = false

    # Initialize
    pub fn ready(self):
        self.base.set_physics_process(true)

        io.println("PlayerController initialized")
        io.println("  Speed: " + self.move_speed.to_string())
        io.println("  Jump Force: " + self.jump_force.to_string())

    # Physics update (60 Hz)
    pub fn physics_process(self, delta: f32):
        # Get input
        self.handle_input()

        # Apply gravity
        if not self.is_on_ground:
            self.velocity.y = self.velocity.y + self.gravity * delta

        # Calculate movement direction
        let forward = self.get_forward_direction()
        let right = self.get_right_direction()

        let move_dir = (forward * self.input_forward + right * self.input_right).normalize()

        # Apply movement
        self.velocity.x = move_dir.x * self.move_speed
        self.velocity.z = move_dir.z * self.move_speed

        # Jump
        if self.input_jump and self.is_on_ground:
            self.velocity.y = self.jump_force
            self.is_on_ground = false

        # Update position
        let new_pos = self.get_position() + self.velocity * delta
        self.set_position(new_pos)

        # Ground check (simplified - would use physics raycast in real game)
        if new_pos.y <= 0.0:
            self.velocity.y = 0.0
            self.is_on_ground = true
            new_pos.y = 0.0
            self.set_position(new_pos)

    # Input handling
    fn handle_input(mut self):
        # In real game, would use Godot's Input singleton
        # For now, placeholder
        self.input_forward = 0.0
        self.input_right = 0.0
        self.input_jump = false

    # Get forward direction in XZ plane
    fn get_forward_direction(self) -> Vec3:
        let rotation = self.get_rotation()
        let yaw = rotation.y
        return Vec3::new(-sin(yaw), 0.0, -cos(yaw))

    # Get right direction in XZ plane
    fn get_right_direction(self) -> Vec3:
        let rotation = self.get_rotation()
        let yaw = rotation.y
        return Vec3::new(cos(yaw), 0.0, -sin(yaw))

    # Handle mouse look
    pub fn on_mouse_motion(mut self, relative_x: f32, relative_y: f32):
        let mut rotation = self.get_rotation()
        rotation.y = rotation.y - relative_x * self.mouse_sensitivity
        rotation.x = rotation.x - relative_y * self.mouse_sensitivity

        # Clamp pitch to prevent flipping
        rotation.x = clamp(rotation.x, -1.5, 1.5)

        self.set_rotation(rotation)

# =============================================================================
# Collectible - Rotating coin/pickup
# =============================================================================

pub class Collectible extends Node3D:
    rotation_speed: f32 = 2.0
    collected: bool = false

    pub fn ready(self):
        self.base.set_process(true)

        # Connect to player detection signal
        signal_body_entered(self.base.object_id).connect(
            self.base.object_id,
            "on_body_entered"
        )

    pub fn process(self, delta: f32):
        if not self.collected:
            # Rotate collectible
            self.rotate_y(self.rotation_speed * delta)

            # Bob up and down
            let time = get_physics_time()
            let bob_offset = sin(time * 3.0) * 0.2
            let mut pos = self.get_position()
            pos.y = 1.0 + bob_offset
            self.set_position(pos)

    pub fn on_body_entered(self, body: Node):
        if not self.collected:
            # Check if it's the player
            let body_name = body.get_name()
            if body_name == "Player":
                self.collect()

    fn collect(mut self):
        self.collected = true

        # Emit collected signal
        let args = Array::new()
        self.base.emit_signal("collected", args)

        # Play collection effect
        io.println("Collectible collected!")

        # Queue for deletion
        self.base.queue_free()

# =============================================================================
# GameManager - Game state and score tracking
# =============================================================================

pub class GameManager extends Node:
    score: i32 = 0
    collectibles_total: i32 = 0
    collectibles_collected: i32 = 0

    pub fn ready(self):
        # Find all collectibles in scene
        self.count_collectibles()

        # Connect to all collectible signals
        self.connect_collectibles()

        io.println("GameManager ready")
        io.println("  Total collectibles: " + self.collectibles_total.to_string())

    fn count_collectibles(mut self):
        # Would use scene tree traversal in real implementation
        self.collectibles_total = 10  # Placeholder

    fn connect_collectibles(self):
        # Would iterate through collectibles and connect signals
        # Placeholder for example
        pass

    pub fn on_collectible_collected(mut self, collectible: Node):
        self.collectibles_collected = self.collectibles_collected + 1
        self.score = self.score + 100

        io.println("Score: " + self.score.to_string())
        io.println("Collected: " + self.collectibles_collected.to_string() +
                  "/" + self.collectibles_total.to_string())

        # Check win condition
        if self.collectibles_collected >= self.collectibles_total:
            self.on_game_won()

    fn on_game_won(self):
        io.println("=== LEVEL COMPLETE ===")
        io.println("Final Score: " + self.score.to_string())

        # Would show victory screen or load next level
        # For now just print message

# =============================================================================
# Helper Functions
# =============================================================================

fn get_physics_time() -> f32:
    # Would get actual physics time from Godot
    return 0.0  # Placeholder

fn clamp(value: f32, min: f32, max: f32) -> f32:
    if value < min:
        return min
    if value > max:
        return max
    return value

fn sin(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn cos(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

# =============================================================================
# Main Entry Point (for testing outside Godot)
# =============================================================================

fn main():
    io.println("Simple-Godot Integration Example")
    io.println("This code is designed to run as a Godot GDExtension")
    io.println("Load it in Godot 4.3+ to see it in action!")
