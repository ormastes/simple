# Event-Driven Vulkan Rendering Example
#
# Demonstrates advanced event handling with wait_event() for efficient rendering.
# This pattern is ideal for tools, editors, and applications that render on-demand.

use ui.gui.vulkan_window.*
use core.*

fn main():
    print("Event-Driven Rendering Demo")
    print("=============================")

    # Create window
    let window = match Window::new(1600, 900, "Event-Driven Rendering"):
        case Ok(w): w
        case Err(e):
            print("ERROR: " + e)
            return

    print("Window created!")
    print("")
    print("Controls:")
    print("  ESC - Exit")
    print("  F11 - Toggle fullscreen")
    print("  F5  - Force redraw")
    print("")

    # Application state
    let mut app_state = AppState {
        running: true,
        needs_redraw: true,
        frame_count: 0,
        is_fullscreen: false,
        mouse_x: 0.0,
        mouse_y: 0.0,
        fps: 0.0,
        last_fps_update: 0
    }

    # Main event loop (event-driven, not continuous rendering)
    while app_state.running:
        # Wait for event or timeout
        # 16ms timeout = 60 FPS max when redrawing continuously
        # Increase timeout for tools that only redraw on input
        let timeout_ms = if app_state.needs_redraw { 16 } else { 1000 }

        match window.wait_event(timeout_ms):
            case Some(event):
                handle_event(event, &window, &mut app_state)

            case None:
                # Timeout - redraw if needed
                if app_state.needs_redraw:
                    render_frame(&mut app_state)
                    app_state.needs_redraw = false

    print("")
    print("Final Statistics:")
    print("  Total frames: " + str(app_state.frame_count))
    print("  Average FPS: " + str(app_state.fps))

# Application state
struct AppState:
    running: bool
    needs_redraw: bool
    frame_count: i32
    is_fullscreen: bool
    mouse_x: f64
    mouse_y: f64
    fps: f64
    last_fps_update: i32

# Handle window events
fn handle_event(event: WindowEvent, window: &Window, state: &mut AppState):
    match event:
        case WindowEvent::CloseRequested:
            print("Closing application...")
            state.running = false

        case WindowEvent::Resized(width, height):
            print("Resized to " + str(width) + "x" + str(height))
            state.needs_redraw = true
            # In real app: recreate swapchain

        case WindowEvent::Focused(focused):
            if focused:
                print("Window focused - resuming rendering")
                state.needs_redraw = true
            else:
                print("Window unfocused - pausing rendering")
                state.needs_redraw = false

        case WindowEvent::MouseMoved(x, y):
            state.mouse_x = x
            state.mouse_y = y
            # Only redraw if interactive (e.g., drawing tool)
            # state.needs_redraw = true

        case WindowEvent::MouseButton(button, pressed):
            if pressed:
                print("Mouse button " + str(button) + " at (" +
                      str(state.mouse_x) + ", " + str(state.mouse_y) + ")")
                state.needs_redraw = true

        case WindowEvent::KeyEvent(key_code, pressed):
            if pressed:
                handle_key(key_code, window, state)

        case WindowEvent::Moved(x, y):
            # Window movement usually doesn't require redraw
            pass

        case WindowEvent::Unknown:
            print("WARNING: Unknown event")

# Handle keyboard input
fn handle_key(key_code: u32, window: &Window, state: &mut AppState):
    match key_code:
        case 27:  # ESC
            state.running = false

        case 122:  # F11
            state.is_fullscreen = !state.is_fullscreen
            let mode = if state.is_fullscreen {
                FullscreenMode::Borderless
            } else {
                FullscreenMode::Windowed
            }

            match window.set_fullscreen(mode):
                case Ok(_):
                    print("Fullscreen: " + str(state.is_fullscreen))
                    state.needs_redraw = true
                case Err(e):
                    print("ERROR: " + e)

        case 116:  # F5
            print("Force redraw")
            state.needs_redraw = true

        case _:
            # Any other key triggers redraw (for demo purposes)
            state.needs_redraw = true

# Render a frame
fn render_frame(state: &mut AppState):
    state.frame_count += 1

    # Calculate FPS every 60 frames
    if state.frame_count % 60 == 0:
        # Simplified FPS calculation
        # In real app: use actual time delta
        state.fps = 60.0  # Approximate

        print("Frame " + str(state.frame_count) +
              " | FPS: " + str(state.fps) +
              " | Mouse: (" + str(state.mouse_x as i32) +
              ", " + str(state.mouse_y as i32) + ")")

    # Actual rendering would go here:
    # 1. Acquire swapchain image
    # 2. Record command buffer
    # 3. Submit to GPU
    # 4. Present

# Benefits of Event-Driven Rendering:
#
# 1. **Energy Efficiency**: CPU/GPU idle when no input
#    - Perfect for tools, editors, viewers
#    - Laptop battery friendly
#
# 2. **Responsive**: Immediate reaction to user input
#    - No frame delay for clicks/keys
#    - Better than fixed 60 FPS for some apps
#
# 3. **Adaptive Frame Rate**: Render only when needed
#    - 60 FPS during animation
#    - 0 FPS when idle
#    - Dynamic based on activity
#
# 4. **Lower Latency**: Direct event â†’ render path
#    - No polling delay
#    - Minimal input lag
#
# When to use:
# - Tools & Editors (IDE, image editor, CAD)
# - Viewers (document, image, video player when paused)
# - Strategic games (turn-based, no animations)
# - Form-based applications
#
# When NOT to use:
# - Games with continuous animation (use continuous rendering)
# - Real-time simulations
# - Video playback
# - Screen savers / visualizations
