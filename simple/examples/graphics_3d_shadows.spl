# 3D Graphics with Shadows Example
#
# Demonstrates shadow mapping with cascaded shadow maps (CSM)
# for directional lights and soft shadows with PCF filtering.
#
# Features:
# - Directional light with 4-cascade shadows
# - Point light with cubemap shadows
# - PCF filtering for soft shadow edges
# - Shadow atlas visualization
# - Real-time cascade debugging

use graphics.*
use graphics.math.*
use graphics.scene.*
use graphics.render.*
use ui.*
use core.*

# =============================================================================
# Main Application
# =============================================================================

fn main():
    io.println("=== 3D Graphics Shadow Mapping Demo ===")

    # Create shadow configuration
    let shadow_config = ShadowMapConfig::high_quality()
    io.println("Shadow Config:")
    io.println("  Cascade Resolution: " + shadow_config.cascade_resolution.to_string())
    io.println("  Num Cascades: " + shadow_config.num_cascades.to_string())
    io.println("  PCF Kernel: " + shadow_config.pcf_kernel_size.to_string() + "x" + shadow_config.pcf_kernel_size.to_string())

    # Create shadow manager
    let mut csm_manager = CSMManager::new(shadow_config)
    csm_manager.init_atlas()

    # Create test scene
    let scene = create_shadow_test_scene()

    # Create camera (FPS-style)
    let camera = create_fps_camera()

    # Setup directional light (sun)
    let sun_direction = Vec3::new(-1.0, -2.0, -1.0).normalize()
    let sun_color = Vec3::new(1.0, 0.95, 0.8)
    let sun_intensity = 1.2

    # Create scene AABB for shadow bounds
    let scene_bounds = AABB::new(
        Vec3::new(-50.0, -5.0, -50.0),
        Vec3::new( 50.0, 20.0,  50.0)
    )

    # Update CSM for directional light
    csm_manager.update_directional_light(sun_direction, camera, scene_bounds)

    io.println("\nCascade Split Distances:")
    for i in 0..shadow_config.num_cascades:
        let near = csm_manager.cascade_splits[i]
        let far = csm_manager.cascade_splits[i + 1]
        io.println("  Cascade " + i.to_string() + ": " + near.to_string() + " - " + far.to_string())

    # Render shadow maps
    io.println("\nRendering shadow maps...")
    csm_manager.render_shadows(scene)
    io.println("  Shadow atlas rendered")

    # Create point light with shadows
    let point_light_pos = Vec3::new(5.0, 3.0, 0.0)
    let point_light_range = 15.0
    let point_shadow = PointLightShadow::new(
        point_light_pos,
        point_light_range,
        shadow_config.point_light_resolution
    )

    io.println("\nPoint Light Shadow:")
    io.println("  Position: " + point_light_pos.to_string())
    io.println("  Range: " + point_light_range.to_string())
    io.println("  Cubemap Resolution: " + shadow_config.point_light_resolution.to_string())

    # Render point light shadows
    point_shadow.render_shadows(scene)

    # Render final scene with shadows
    io.println("\n=== Rendering Final Scene with Shadows ===")
    render_scene_with_shadows(
        scene,
        camera,
        sun_direction,
        sun_color,
        sun_intensity,
        csm_manager,
        point_shadow
    )

    # Shadow statistics
    print_shadow_statistics(csm_manager, point_shadow)

    io.println("\n=== Shadow Demo Complete ===")

# =============================================================================
# Scene Creation
# =============================================================================

fn create_shadow_test_scene() -> Scene:
    let scene = Scene::new("Shadow Test Scene")

    # Ground plane (shadow receiver)
    let ground_material = Material::new_pbr(
        Vec3::new(0.8, 0.8, 0.8),  # Albedo (light gray)
        0.0,                        # Metallic
        0.8                         # Roughness
    )

    let ground_mesh = Mesh::create_plane(50.0, 50.0)
    let ground_node = scene.create_node("Ground")
    ground_node.add_component(MeshRenderer::new(ground_mesh, ground_material))
    ground_node.set_receive_shadows(true)
    ground_node.set_cast_shadows(false)  # Ground doesn't cast shadows

    # Pillars (shadow casters)
    let pillar_material = Material::new_pbr(
        Vec3::new(0.9, 0.7, 0.4),  # Stone color
        0.0,
        0.6
    )

    let positions = [
        Vec3::new(-8.0, 0.0, -8.0),
        Vec3::new( 8.0, 0.0, -8.0),
        Vec3::new(-8.0, 0.0,  8.0),
        Vec3::new( 8.0, 0.0,  8.0),
        Vec3::new( 0.0, 0.0,  0.0)
    ]

    let heights = [4.0, 6.0, 3.0, 5.0, 8.0]

    for i in 0..5:
        let pillar_mesh = Mesh::create_cylinder(0.5, heights[i], 16)
        let pillar_node = scene.create_node("Pillar_" + i.to_string())
        pillar_node.set_position(positions[i] + Vec3::new(0.0, heights[i] / 2.0, 0.0))
        pillar_node.add_component(MeshRenderer::new(pillar_mesh, pillar_material))
        pillar_node.set_cast_shadows(true)
        pillar_node.set_receive_shadows(true)

    # Floating spheres (demonstrate point light shadows)
    let sphere_material = Material::new_pbr(
        Vec3::new(0.2, 0.6, 0.9),  # Blue
        0.3,
        0.4
    )

    for x in -2..3:
        for z in -1..2:
            let sphere_pos = Vec3::new(x as f32 * 3.0, 1.5, z as f32 * 3.0 + 15.0)
            let sphere_mesh = Mesh::create_sphere(0.4, 16, 16)
            let sphere_node = scene.create_node("Sphere_" + x.to_string() + "_" + z.to_string())
            sphere_node.set_position(sphere_pos)
            sphere_node.add_component(MeshRenderer::new(sphere_mesh, sphere_material))
            sphere_node.set_cast_shadows(true)
            sphere_node.set_receive_shadows(true)

    io.println("Scene created:")
    io.println("  1 ground plane (receiver)")
    io.println("  5 pillars (casters)")
    io.println("  15 floating spheres")

    return scene

# =============================================================================
# Camera Setup
# =============================================================================

fn create_fps_camera() -> Camera:
    let mut camera = Camera::new_perspective(
        70.0_deg,      # FOV
        16.0 / 9.0,    # Aspect ratio
        0.1,           # Near plane
        200.0          # Far plane (covers all cascades)
    )

    # Position camera to view scene
    camera.set_position(Vec3::new(0.0, 5.0, 20.0))
    camera.look_at(Vec3::new(0.0, 2.0, 0.0))

    return camera

# =============================================================================
# Rendering with Shadows
# =============================================================================

fn render_scene_with_shadows(
    scene: Scene,
    camera: Camera,
    sun_direction: Vec3,
    sun_color: Vec3,
    sun_intensity: f32,
    csm_manager: CSMManager,
    point_shadow: PointLightShadow
):
    # In a real implementation, this would:
    # 1. Bind shadow atlas texture to shader
    # 2. Pass cascade matrices to shader
    # 3. Render scene with shadow sampling in fragment shader

    # For demonstration, print what would happen
    io.println("Rendering scene with shadows:")

    # Sample a test position
    let test_pos = Vec3::new(0.0, 1.0, 0.0)
    let cascade_idx = csm_manager.get_cascade_index(test_pos, camera.get_position())

    io.println("  Test position: " + test_pos.to_string())
    io.println("  Selected cascade: " + cascade_idx.to_string())

    let cascade = csm_manager.cascades[cascade_idx]
    let light_space_pos = cascade.view_proj_matrix.transform_point(test_pos)

    io.println("  Light space position: " + light_space_pos.to_string())

    # Simulate shadow sampling
    let shadow_coord = Vec3::new(
        light_space_pos.x * 0.5 + 0.5,
        light_space_pos.y * 0.5 + 0.5,
        light_space_pos.z
    )

    io.println("  Shadow coord (UV + depth): " + shadow_coord.to_string())

    # In real rendering:
    # let shadow_factor = sample_shadow_map_pcf(
    #     cascade.depth_texture_id,
    #     shadow_coord,
    #     cascade.get_atlas_uv_transform(),
    #     csm_manager.config.pcf_kernel_size,
    #     csm_manager.config.pcf_radius
    # )
    let shadow_factor = 0.7  # Placeholder (70% lit)

    io.println("  Shadow factor: " + shadow_factor.to_string() + " (1.0 = fully lit, 0.0 = fully shadowed)")

# =============================================================================
# Statistics
# =============================================================================

fn print_shadow_statistics(
    csm_manager: CSMManager,
    point_shadow: PointLightShadow
):
    io.println("\n=== Shadow Statistics ===")

    # CSM memory usage
    let cascade_pixels = csm_manager.config.cascade_resolution * csm_manager.config.cascade_resolution
    let cascade_bytes = cascade_pixels * 4 * csm_manager.config.num_cascades  # 4 bytes per pixel (D32F)
    let atlas_mb = cascade_bytes as f32 / (1024.0 * 1024.0)

    io.println("Cascaded Shadow Maps:")
    io.println("  Cascades: " + csm_manager.config.num_cascades.to_string())
    io.println("  Resolution per cascade: " + csm_manager.config.cascade_resolution.to_string())
    io.println("  Atlas size: 4096x4096")
    io.println("  Memory: " + atlas_mb.to_string() + " MB")

    # Point light memory
    let point_pixels = point_shadow.cubemap_resolution * point_shadow.cubemap_resolution * 6
    let point_bytes = point_pixels * 4
    let point_mb = point_bytes as f32 / (1024.0 * 1024.0)

    io.println("\nPoint Light Shadows:")
    io.println("  Cubemap resolution: " + point_shadow.cubemap_resolution.to_string())
    io.println("  Memory: " + point_mb.to_string() + " MB")

    io.println("\nTotal Shadow Memory: " + (atlas_mb + point_mb).to_string() + " MB")

    # Performance estimates
    io.println("\nPerformance Estimates:")
    io.println("  CSM render passes: " + csm_manager.config.num_cascades.to_string())
    io.println("  Point light render passes: 6 (cubemap faces)")
    io.println("  PCF samples per pixel: " + (csm_manager.config.pcf_kernel_size * csm_manager.config.pcf_kernel_size).to_string())

# =============================================================================
# Debug Visualization
# =============================================================================

fn visualize_cascade_splits(csm_manager: CSMManager, camera: Camera):
    io.println("\n=== Cascade Coverage Visualization ===")

    # Test distances from camera
    let test_distances = [1.0, 5.0, 10.0, 20.0, 50.0, 100.0, 150.0]

    for distance in test_distances:
        let test_pos = camera.get_position() + camera.get_forward() * distance
        let cascade_idx = csm_manager.get_cascade_index(test_pos, camera.get_position())

        io.println("  Distance " + distance.to_string() + "m -> Cascade " + cascade_idx.to_string())
