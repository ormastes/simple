# ML + Physics Integration Example: Trajectory Prediction
#
# This example demonstrates integrating machine learning with physics simulation.
# We use physics simulation to generate training data, then train a neural network
# to predict projectile trajectories.

import ml.torch as torch
import ml.torch.nn as nn
import ml.torch.optim as optim
import physics.core as core
import physics.dynamics as dynamics

# ============================================================================
# Neural Network Model
# ============================================================================

class TrajectoryPredictor(nn.Module):
    """Neural network that predicts projectile trajectory.

    Input: [initial_x, initial_y, velocity_x, velocity_y, time]
    Output: [final_x, final_y]
    """
    fc1: nn.Linear
    bn1: nn.BatchNorm1d
    fc2: nn.Linear
    bn2: nn.BatchNorm1d
    fc3: nn.Linear

    fn __init__(self):
        """Initialize the trajectory prediction network."""
        super().__init__()
        self.fc1 = nn.Linear(5, 64)     # 5 inputs
        self.bn1 = nn.BatchNorm1d(64)
        self.fc2 = nn.Linear(64, 32)
        self.bn2 = nn.BatchNorm1d(32)
        self.fc3 = nn.Linear(32, 2)     # 2 outputs (x, y)

    fn forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass through the network."""
        x = self.fc1(x)
        x = self.bn1(x)
        x = nn.relu(x)

        x = self.fc2(x)
        x = self.bn2(x)
        x = nn.relu(x)

        x = self.fc3(x)
        return x


# ============================================================================
# Physics Simulation for Training Data
# ============================================================================

fn simulate_trajectory(
    initial_pos: core.Vector3,
    initial_vel: core.Vector3,
    time: f64,
    dt: f64 = 0.01
) -> core.Vector3:
    """Simulate projectile trajectory using physics engine.

    Args:
        initial_pos: Initial position
        initial_vel: Initial velocity
        time: Total simulation time
        dt: Time step for integration

    Returns:
        Final position after simulation
    """
    # Create rigid body for projectile
    let body = dynamics.RigidBody(
        mass=1.0,
        position=initial_pos,
        velocity=initial_vel
    )

    # Simulate with gravity
    let gravity = core.Vector3(0.0, -9.81, 0.0)
    let steps = (time / dt) as i32

    for _ in range(steps):
        body.add_force(gravity.scale(body.mass))
        body.integrate(dt)

    return body.position


fn generate_training_data(num_samples: i32, device: torch.Device) -> (torch.Tensor, torch.Tensor):
    """Generate training data using physics simulation.

    Args:
        num_samples: Number of training samples to generate
        device: Device to store tensors on

    Returns:
        Tuple of (inputs, targets) tensors
    """
    print(f"Generating {num_samples} training samples using physics simulation...")

    # Create arrays for data
    let mut inputs = []
    let mut targets = []

    for i in range(num_samples):
        # Random initial conditions
        let x0 = (rand() * 20.0) - 10.0       # -10 to 10
        let y0 = rand() * 10.0 + 5.0          # 5 to 15
        let vx = (rand() * 10.0) - 5.0        # -5 to 5
        let vy = rand() * 10.0                # 0 to 10
        let t = rand() * 2.0 + 0.5            # 0.5 to 2.5 seconds

        # Simulate trajectory
        let initial_pos = core.Vector3(x0, y0, 0.0)
        let initial_vel = core.Vector3(vx, vy, 0.0)
        let final_pos = simulate_trajectory(initial_pos, initial_vel, t)

        # Store input/output pair
        inputs.append([x0, y0, vx, vy, t])
        targets.append([final_pos.x, final_pos.y])

        if (i + 1) % 100 == 0:
            print(f"  Generated {i + 1}/{num_samples} samples")

    # Convert to tensors
    let input_tensor = torch.from_data(inputs, device=device)
    let target_tensor = torch.from_data(targets, device=device)

    print("Training data generation complete!")
    return (input_tensor, target_tensor)


# ============================================================================
# Training Loop
# ============================================================================

fn train_model(
    model: TrajectoryPredictor,
    inputs: torch.Tensor,
    targets: torch.Tensor,
    epochs: i32 = 100,
    learning_rate: f64 = 0.001
):
    """Train the trajectory prediction model.

    Args:
        model: Neural network model
        inputs: Input tensor
        targets: Target tensor
        epochs: Number of training epochs
        learning_rate: Learning rate for optimizer
    """
    print(f"\nTraining model for {epochs} epochs...")
    print(f"Learning rate: {learning_rate}")

    # Create optimizer
    let params = model.parameters()
    let optimizer = optim.Adam(params, lr=learning_rate)

    # Create parameter tracker
    let tracker = torch.ParameterTracker()
    tracker.track_named_parameters([
        ("fc1.weight", params[0]),
        ("fc2.weight", params[2]),
        ("fc3.weight", params[4])
    ], "initial")

    # Training loop
    model.train()

    for epoch in range(epochs):
        # Forward pass
        let predictions = model.forward(inputs)

        # Compute loss (Mean Squared Error)
        let loss = ((predictions - targets) ** 2).mean()

        # Backward pass
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        # Log progress
        if (epoch + 1) % 10 == 0 or epoch == 0:
            print(f"Epoch {epoch + 1}/{epochs}, Loss: {loss.item():.6f}")

        # Track parameters at key epochs
        if epoch == epochs / 2:
            tracker.track_named_parameters([
                ("fc1.weight", params[0]),
                ("fc2.weight", params[2]),
                ("fc3.weight", params[4])
            ], "mid")

    # Track final parameters
    tracker.track_named_parameters([
        ("fc1.weight", params[0]),
        ("fc2.weight", params[2]),
        ("fc3.weight", params[4])
    ], "final")

    print("\nTraining complete!")

    # Print parameter statistics
    tracker.print_summary()

    # Check for issues
    let warnings = tracker.check_for_issues()
    if warnings.len() > 0:
        print("\nWarnings:")
        for warning in warnings:
            print(f"  {warning}")


# ============================================================================
# Evaluation
# ============================================================================

fn evaluate_model(model: TrajectoryPredictor):
    """Evaluate the trained model on test cases.

    Args:
        model: Trained neural network model
    """
    print("\n" + "=" * 80)
    print("Model Evaluation")
    print("=" * 80)

    model.eval()

    # Test case 1: Horizontal launch
    print("\nTest 1: Horizontal launch")
    let x0 = 0.0
    let y0 = 10.0
    let vx = 5.0
    let vy = 0.0
    let t = 1.0

    let physics_result = simulate_trajectory(
        core.Vector3(x0, y0, 0.0),
        core.Vector3(vx, vy, 0.0),
        t
    )

    let input = torch.from_data([[x0, y0, vx, vy, t]])
    let nn_result = model.forward(input)

    print(f"  Initial: ({x0:.2f}, {y0:.2f}), Velocity: ({vx:.2f}, {vy:.2f})")
    print(f"  Physics: ({physics_result.x:.2f}, {physics_result.y:.2f})")
    print(f"  Neural Net: ({nn_result[0, 0]:.2f}, {nn_result[0, 1]:.2f})")
    print(f"  Error: {((physics_result.x - nn_result[0, 0])**2 + (physics_result.y - nn_result[0, 1])**2)**0.5:.4f}")

    # Test case 2: Upward launch
    print("\nTest 2: Upward launch")
    x0 = 0.0
    y0 = 5.0
    vx = 3.0
    vy = 10.0
    t = 1.5

    physics_result = simulate_trajectory(
        core.Vector3(x0, y0, 0.0),
        core.Vector3(vx, vy, 0.0),
        t
    )

    input = torch.from_data([[x0, y0, vx, vy, t]])
    nn_result = model.forward(input)

    print(f"  Initial: ({x0:.2f}, {y0:.2f}), Velocity: ({vx:.2f}, {vy:.2f})")
    print(f"  Physics: ({physics_result.x:.2f}, {physics_result.y:.2f})")
    print(f"  Neural Net: ({nn_result[0, 0]:.2f}, {nn_result[0, 1]:.2f})")
    print(f"  Error: {((physics_result.x - nn_result[0, 0])**2 + (physics_result.y - nn_result[0, 1])**2)**0.5:.4f}")


# ============================================================================
# Main Program
# ============================================================================

fn main():
    """Main program entry point."""
    print("=" * 80)
    print("ML + Physics Integration: Trajectory Prediction")
    print("=" * 80)

    # Check device availability
    let device = if torch.cuda_available():
        print(f"\nCUDA available! Using GPU with {torch.cuda_device_count()} device(s)")
        torch.Device::CUDA(0)
    else:
        print("\nCUDA not available, using CPU")
        torch.Device::CPU

    # Generate training data using physics simulation
    let (inputs, targets) = generate_training_data(1000, device)

    # Create and train model
    let model = TrajectoryPredictor()
    model.to(device)
    train_model(model, inputs, targets, epochs=100)

    # Evaluate model
    evaluate_model(model)

    print("\n" + "=" * 80)
    print("Complete!")
    print("=" * 80)


# Run the example
main()
