# VSCode Debug Adapter Protocol (DAP) Integration
# Enable debugging Simple code in VSCode

use core.result.{Result, Ok, Err}
use core.json.{JsonBuilder, JsonValue, stringify}

# External FFI declarations
extern fn vscode_debug_start_session(config: text): i64
extern fn vscode_debug_set_breakpoint(file: text, line: i32): i64
extern fn vscode_debug_continue(session_id: i64): void
extern fn vscode_debug_step_over(session_id: i64): void
extern fn vscode_debug_step_into(session_id: i64): void
extern fn vscode_debug_step_out(session_id: i64): void
extern fn vscode_debug_pause(session_id: i64): void
extern fn vscode_debug_stop(session_id: i64): void
extern fn vscode_debug_evaluate(session_id: i64, expression: text): text
extern fn vscode_debug_register_adapter(debug_type: text, callback_id: i64): void

# Adapter factory callback storage
var _adapter_factories: Dict<i64, fn(DebugSession): DebugAdapter> = {}
var _next_adapter_callback_id: i64 = 0

# Debug session
pub class DebugSession:
    pub session_id: i64
    pub configuration: DebugConfiguration
    pub state: DebugState

    pub fn new(config: DebugConfiguration): DebugSession =
        """Create debug session.

        Args:
            config: Debug configuration

        Returns:
            Debug session

        Example:
            val config = DebugConfiguration.new("simple")
            config.set_program("app.spl")
            val session = DebugSession.new(config)
            session.start()
        """
        DebugSession {
            session_id: 0,
            configuration: config,
            state: DebugState::Stopped
        }

    pub fn start(self):
        """Start debug session."""
        val config_json = self.configuration.to_json()
        self.session_id = vscode_debug_start_session(config_json)
        self.state = DebugState::Running

    pub fn continue_execution(self):
        """Continue execution."""
        vscode_debug_continue(self.session_id)
        self.state = DebugState::Running

    pub fn step_over(self):
        """Step over current line."""
        vscode_debug_step_over(self.session_id)

    pub fn step_into(self):
        """Step into function."""
        vscode_debug_step_into(self.session_id)

    pub fn step_out(self):
        """Step out of function."""
        vscode_debug_step_out(self.session_id)

    pub fn pause(self):
        """Pause execution."""
        vscode_debug_pause(self.session_id)
        self.state = DebugState::Paused

    pub fn stop(self):
        """Stop debug session."""
        vscode_debug_stop(self.session_id)
        self.state = DebugState::Stopped

    pub fn evaluate(self, expression: text): text =
        """Evaluate expression in current context.

        Args:
            expression: Expression to evaluate

        Returns:
            Evaluation result

        Example:
            val result = session.evaluate("x + y")
            print("Result: {result}")
        """
        vscode_debug_evaluate(self.session_id, expression)

# Debug configuration
pub class DebugConfiguration:
    pub debug_type: text
    pub name: text
    pub request: text
    pub program: text
    pub args: List<text>
    pub cwd: text
    pub env: Dict<text, text>
    pub stop_on_entry: bool

    pub fn new(debug_type: text): DebugConfiguration =
        """Create debug configuration.

        Args:
            debug_type: Debug type (e.g., "simple")

        Returns:
            Configuration with defaults
        """
        DebugConfiguration {
            debug_type: debug_type,
            name: "Debug Simple",
            request: "launch",
            program: "",
            args: [],
            cwd: "${workspaceFolder}",
            env: {},
            stop_on_entry: false
        }

    pub fn set_program(self, program: text):
        """Set program to debug.

        Args:
            program: Path to program file
        """
        self.program = program

    pub fn add_arg(self, arg: text):
        """Add program argument.

        Args:
            arg: Argument to add
        """
        self.args.append(arg)

    pub fn set_env(self, key: text, value: text):
        """Set environment variable.

        Args:
            key: Variable name
            value: Variable value
        """
        self.env[key] = value

    pub fn to_json(): text =
        """Convert to JSON string.

        Returns:
            JSON representation with proper escaping
        """
        var builder = JsonBuilder.new()
        builder = builder.set_string("type", self.debug_type)
        builder = builder.set_string("name", self.name)
        builder = builder.set_string("request", self.request)
        builder = builder.set_string("program", self.program)
        builder = builder.set_string("cwd", self.cwd)
        builder = builder.set_bool("stopOnEntry", self.stop_on_entry)

        # Add args array
        var args_values: List<JsonValue> = []
        for arg in self.args:
            args_values.push(JsonValue.text(arg))
        builder = builder.set_array("args", args_values)

        # Add env object
        var env_dict: Dict<text, JsonValue> = {}
        for (key, value) in self.env.items():
            env_dict[key] = JsonValue.text(value)
        builder = builder.set_object("env", env_dict)

        stringify(builder.build())

# Debug state
pub enum DebugState:
    Stopped
    Running
    Paused
    Terminated

impl DebugState:
    pub fn to_string(self) -> text:
        """Convert debug state to string."""
        match self:
            case Stopped: "stopped"
            case Running: "running"
            case Paused: "paused"
            case Terminated: "terminated"

    pub fn description(self) -> text:
        """Get debug state description."""
        match self:
            case Stopped: "Debugger stopped at breakpoint"
            case Running: "Program executing"
            case Paused: "Execution paused by user"
            case Terminated: "Program terminated"

    pub fn is_stopped(self) -> bool:
        """Check if state is Stopped."""
        match self:
            case Stopped: true
            case _: false

    pub fn is_running(self) -> bool:
        """Check if state is Running."""
        match self:
            case Running: true
            case _: false

    pub fn is_paused(self) -> bool:
        """Check if state is Paused."""
        match self:
            case Paused: true
            case _: false

    pub fn is_terminated(self) -> bool:
        """Check if state is Terminated."""
        match self:
            case Terminated: true
            case _: false

    pub fn is_active(self) -> bool:
        """Check if program is active (not terminated)."""
        match self:
            case Terminated: false
            case _: true

    pub fn is_halted(self) -> bool:
        """Check if execution is halted (stopped or paused)."""
        match self:
            case Stopped: true
            case Paused: true
            case _: false

    pub fn can_continue(self) -> bool:
        """Check if can continue execution."""
        return self.is_halted()

    pub fn summary(self) -> text:
        """Get debug state summary."""
        val name = self.to_string()
        val desc = self.description()
        val status = if self.is_active():
            if self.is_halted(): "halted" else: "executing"
        else:
            "terminated"
        return "DebugState: {name} ({desc}, {status})"

# Breakpoint
pub class Breakpoint:
    pub file: text
    pub line: i32
    pub condition: text
    pub hit_count: i32
    pub enabled: bool
    pub breakpoint_id: i64

    pub fn new(file: text, line: i32): Breakpoint =
        """Create breakpoint.

        Args:
            file: Source file
            line: Line number (1-indexed)

        Returns:
            Breakpoint

        Example:
            val bp = Breakpoint.new("app.spl", 10)
            bp.set_condition("x > 5")
            bp.set()
        """
        Breakpoint {
            file: file,
            line: line,
            condition: "",
            hit_count: 0,
            enabled: true,
            breakpoint_id: 0
        }

    pub fn set_condition(self, condition: text):
        """Set breakpoint condition.

        Args:
            condition: Condition expression

        Example:
            bp.set_condition("x > 10 and y < 20")
        """
        self.condition = condition

    pub fn set(self):
        """Set breakpoint."""
        self.breakpoint_id = vscode_debug_set_breakpoint(self.file, self.line)

    pub fn enable(self):
        """Enable breakpoint."""
        self.enabled = true

    pub fn disable(self):
        """Disable breakpoint."""
        self.enabled = false

    pub fn toggle(self):
        """Toggle breakpoint enabled state."""
        self.enabled = not self.enabled

# Variable
pub class Variable:
    pub name: text
    pub value: text
    pub variable_type: text
    pub children: List<Variable>

    pub fn new(name: text, value: text, var_type: text): Variable =
        """Create variable representation.

        Args:
            name: Variable name
            value: Variable value
            var_type: Variable type

        Returns:
            Variable
        """
        Variable {
            name: name,
            value: value,
            variable_type: var_type,
            children: []
        }

    pub fn add_child(self, child: Variable):
        """Add child variable (for structs/objects).

        Args:
            child: Child variable
        """
        self.children.append(child)

# Stack frame
pub class StackFrame:
    pub name: text
    pub file: text
    pub line: i32
    pub column: i32
    pub variables: List<Variable>

    pub fn new(name: text, file: text, line: i32): StackFrame =
        """Create stack frame.

        Args:
            name: Function name
            file: Source file
            line: Line number

        Returns:
            Stack frame
        """
        StackFrame {
            name: name,
            file: file,
            line: line,
            column: 0,
            variables: []
        }

    pub fn add_variable(self, variable: Variable):
        """Add local variable.

        Args:
            variable: Variable to add
        """
        self.variables.append(variable)

# Debug adapter
pub class DebugAdapter:
    pub sessions: Dict<i64, DebugSession>
    pub breakpoints: List<Breakpoint>

    pub fn new(): DebugAdapter =
        """Create debug adapter."""
        DebugAdapter {
            sessions: {},
            breakpoints: []
        }

    pub fn start_session(self, config: DebugConfiguration): DebugSession =
        """Start new debug session.

        Args:
            config: Debug configuration

        Returns:
            Started session

        Example:
            val adapter = DebugAdapter.new()
            val config = DebugConfiguration.new("simple")
            config.set_program("app.spl")
            val session = adapter.start_session(config)
        """
        val session = DebugSession.new(config)
        session.start()
        self.sessions[session.session_id] = session
        session

    pub fn add_breakpoint(self, file: text, line: i32): Breakpoint =
        """Add breakpoint.

        Args:
            file: Source file
            line: Line number

        Returns:
            Created breakpoint
        """
        val bp = Breakpoint.new(file, line)
        bp.set()
        self.breakpoints.append(bp)
        bp

    pub fn remove_breakpoint(self, breakpoint: Breakpoint):
        """Remove breakpoint.

        Args:
            breakpoint: Breakpoint to remove
        """
        # Filter out the breakpoint to remove
        var new_breakpoints: List<Breakpoint> = []
        for bp in self.breakpoints:
            # TODO: [runtime][P2] Assumes Breakpoint has identity comparison
            # In practice, might need to compare by URI+line
            if bp != breakpoint:
                new_breakpoints.push(bp)

        self.breakpoints = new_breakpoints

    pub fn get_session(self, session_id: i64): Option<DebugSession> =
        """Get debug session by ID.

        Args:
            session_id: Session ID

        Returns:
            Session if found
        """
        self.sessions.get(session_id)

# Helper: Register debug adapter
pub fn register_debug_adapter(
    debug_type: text,
    adapter_factory: fn(session: DebugSession): DebugAdapter
):
    """Register debug adapter for language.

    Args:
        debug_type: Debug type (e.g., "simple")
        adapter_factory: Factory function to create adapter

    Example:
        register_debug_adapter("simple", fn(session):
            val adapter = DebugAdapter.new()
            # Configure adapter
            adapter
        )
    """
    # Register with VSCode
    val callback_id = _next_adapter_callback_id
    _next_adapter_callback_id = _next_adapter_callback_id + 1
    _adapter_factories[callback_id] = adapter_factory
    vscode_debug_register_adapter(debug_type, callback_id)

# Helper: Create simple debug configuration
pub fn create_debug_config(program: text): DebugConfiguration =
    """Create simple debug configuration.

    Args:
        program: Program to debug

    Returns:
        Debug configuration

    Example:
        val config = create_debug_config("app.spl")
        config.stop_on_entry = true
        val session = DebugSession.new(config)
        session.start()
    """
    val config = DebugConfiguration.new("simple")
    config.set_program(program)
    config
