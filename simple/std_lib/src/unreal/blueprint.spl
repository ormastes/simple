# Unreal Blueprint Integration
#
# Runtime support for Blueprint-Simple interop
#
# Features:
# - Call Simple functions from Blueprint
# - Call Blueprint functions from Simple
# - Property synchronization (UPROPERTY)
# - Event dispatching and handling
# - Blueprint implementable events
#
# Based on: https://docs.unrealengine.org/5.4/en-US/blueprints-visual-scripting-in-unreal-engine/

import sys.ffi
import unreal.actor

mod blueprint

# PropertyValue
# Runtime value for Blueprint properties
pub enum PropertyValue:
    Bool(bool)
    Int(i32)
    Float(f32)
    String(String)
    Object(ffi.VoidPtr)
    Vector(f64, f64, f64)
    Rotator(f64, f64, f64)

impl PropertyValue:
    # Extract bool value
    pub fn as_bool(self) -> bool:
        if self is PropertyValue::Bool(value):
            return value
        else:
            return false

    # Extract int value
    pub fn as_int(self) -> i32:
        if self is PropertyValue::Int(value):
            return value
        else:
            return 0

    # Extract float value
    pub fn as_float(self) -> f32:
        if self is PropertyValue::Float(value):
            return value
        else:
            return 0.0

    # Extract string value
    pub fn as_string(self) -> String:
        if self is PropertyValue::String(value):
            return value
        else:
            return ""

    # Extract object pointer
    pub fn as_object(self) -> ffi.VoidPtr:
        if self is PropertyValue::Object(ptr):
            return ptr
        else:
            return ffi.null_ptr()


# BlueprintFunctionCall
# Represents a call to a Blueprint function
pub struct BlueprintFunctionCall:
    object_ptr: ffi.VoidPtr
    function_name: String
    parameters: Vec[PropertyValue]

impl BlueprintFunctionCall:
    # Create new function call
    pub fn new(object_ptr: ffi.VoidPtr, function_name: String) -> BlueprintFunctionCall:
        return BlueprintFunctionCall(
            object_ptr: object_ptr,
            function_name: function_name,
            parameters: [],
        )

    # Add boolean parameter
    pub fn with_bool(mut self, value: bool) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue::Bool(value))
        return self

    # Add integer parameter
    pub fn with_int(mut self, value: i32) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue::Int(value))
        return self

    # Add float parameter
    pub fn with_float(mut self, value: f32) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue::Float(value))
        return self

    # Add string parameter
    pub fn with_string(mut self, value: String) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue::String(value))
        return self

    # Add object parameter
    pub fn with_object(mut self, value: ffi.VoidPtr) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue::Object(value))
        return self

    # Execute the function call
    pub fn execute(self) -> PropertyValue:
        # Marshal parameters to FFI
        let param_count = self.parameters.len()
        let param_types = ffi.alloc_array_i32(param_count)
        let param_values = ffi.alloc_array_ptr(param_count)

        for i in 0..param_count:
            let param = self.parameters[i]

            # Set parameter type and value based on variant
            if param is PropertyValue::Bool(value):
                ffi.write_array_i32(param_types, i, 0)  # Type: Bool
                let bool_ptr = ffi.alloc_bool()
                ffi.write_bool(bool_ptr, value)
                ffi.write_array_ptr(param_values, i, bool_ptr)
            elif param is PropertyValue::Int(value):
                ffi.write_array_i32(param_types, i, 1)  # Type: Int
                let int_ptr = ffi.alloc_i32()
                ffi.write_i32(int_ptr, value)
                ffi.write_array_ptr(param_values, i, int_ptr)
            elif param is PropertyValue::Float(value):
                ffi.write_array_i32(param_types, i, 2)  # Type: Float
                let float_ptr = ffi.alloc_f32()
                ffi.write_f32(float_ptr, value)
                ffi.write_array_ptr(param_values, i, float_ptr)
            elif param is PropertyValue::String(value):
                ffi.write_array_i32(param_types, i, 3)  # Type: String
                let str_ptr = ffi.string_to_ptr(value)
                ffi.write_array_ptr(param_values, i, str_ptr)
            elif param is PropertyValue::Object(ptr):
                ffi.write_array_i32(param_types, i, 4)  # Type: Object
                ffi.write_array_ptr(param_values, i, ptr)

        # Call the Blueprint function via FFI
        let result_type = ffi.alloc_i32()
        let result_value = ffi.alloc_ptr()

        unreal_blueprint_call_function(
            self.object_ptr,
            self.function_name,
            param_count as i32,
            param_types,
            param_values,
            result_type,
            result_value
        )

        # Parse result
        let ret_type = ffi.read_i32(result_type)
        let ret_val = ffi.read_ptr(result_value)

        let result = if ret_type == 0:
            PropertyValue::Bool(ffi.read_bool(ret_val))
        elif ret_type == 1:
            PropertyValue::Int(ffi.read_i32(ret_val))
        elif ret_type == 2:
            PropertyValue::Float(ffi.read_f32(ret_val))
        elif ret_type == 3:
            PropertyValue::String(ffi.string_from_ptr(ret_val))
        elif ret_type == 4:
            PropertyValue::Object(ret_val)
        else:
            PropertyValue::Bool(false)

        # Cleanup
        for i in 0..param_count:
            let param_ptr = ffi.read_array_ptr(param_values, i)
            ffi.free(param_ptr)

        ffi.free(param_types)
        ffi.free(param_values)
        ffi.free(result_type)
        ffi.free(result_value)

        return result


# BlueprintProperty
# Access Blueprint properties from Simple
pub struct BlueprintProperty:
    object_ptr: ffi.VoidPtr
    property_name: String

impl BlueprintProperty:
    pub fn new(object_ptr: ffi.VoidPtr, property_name: String) -> BlueprintProperty:
        return BlueprintProperty(
            object_ptr: object_ptr,
            property_name: property_name,
        )

    # Get property value
    pub fn get(self) -> PropertyValue:
        let value_type = ffi.alloc_i32()
        let value_ptr = ffi.alloc_ptr()

        unreal_blueprint_get_property(
            self.object_ptr,
            self.property_name,
            value_type,
            value_ptr
        )

        let prop_type = ffi.read_i32(value_type)
        let prop_val = ffi.read_ptr(value_ptr)

        let result = if prop_type == 0:
            PropertyValue::Bool(ffi.read_bool(prop_val))
        elif prop_type == 1:
            PropertyValue::Int(ffi.read_i32(prop_val))
        elif prop_type == 2:
            PropertyValue::Float(ffi.read_f32(prop_val))
        elif prop_type == 3:
            PropertyValue::String(ffi.string_from_ptr(prop_val))
        elif prop_type == 4:
            PropertyValue::Object(prop_val)
        else:
            PropertyValue::Bool(false)

        ffi.free(value_type)
        ffi.free(value_ptr)

        return result

    # Set property value
    pub fn set(mut self, value: PropertyValue):
        let value_type: i32
        let value_ptr: ffi.VoidPtr

        if value is PropertyValue::Bool(v):
            value_type = 0
            let bool_ptr = ffi.alloc_bool()
            ffi.write_bool(bool_ptr, v)
            value_ptr = bool_ptr
        elif value is PropertyValue::Int(v):
            value_type = 1
            let int_ptr = ffi.alloc_i32()
            ffi.write_i32(int_ptr, v)
            value_ptr = int_ptr
        elif value is PropertyValue::Float(v):
            value_type = 2
            let float_ptr = ffi.alloc_f32()
            ffi.write_f32(float_ptr, v)
            value_ptr = float_ptr
        elif value is PropertyValue::String(v):
            value_type = 3
            value_ptr = ffi.string_to_ptr(v)
        elif value is PropertyValue::Object(ptr):
            value_type = 4
            value_ptr = ptr
        else:
            value_type = 0
            value_ptr = ffi.null_ptr()

        unreal_blueprint_set_property(
            self.object_ptr,
            self.property_name,
            value_type,
            value_ptr
        )

        ffi.free(value_ptr)


# BlueprintEvent
# Dispatch events to Blueprint
pub struct BlueprintEvent:
    dispatcher_ptr: ffi.VoidPtr

impl BlueprintEvent:
    pub fn new(object_ptr: ffi.VoidPtr, event_name: String) -> BlueprintEvent:
        let dispatcher_ptr = unreal_blueprint_get_event_dispatcher(object_ptr, event_name)
        return BlueprintEvent(dispatcher_ptr: dispatcher_ptr)

    # Broadcast event with no parameters
    pub fn broadcast(self):
        unreal_blueprint_broadcast_event(self.dispatcher_ptr, 0, ffi.null_ptr(), ffi.null_ptr())

    # Broadcast event with parameters
    pub fn broadcast_with_params(self, params: Vec[PropertyValue]):
        let param_count = params.len()
        let param_types = ffi.alloc_array_i32(param_count)
        let param_values = ffi.alloc_array_ptr(param_count)

        for i in 0..param_count:
            let param = params[i]

            if param is PropertyValue::Bool(value):
                ffi.write_array_i32(param_types, i, 0)
                let bool_ptr = ffi.alloc_bool()
                ffi.write_bool(bool_ptr, value)
                ffi.write_array_ptr(param_values, i, bool_ptr)
            elif param is PropertyValue::Int(value):
                ffi.write_array_i32(param_types, i, 1)
                let int_ptr = ffi.alloc_i32()
                ffi.write_i32(int_ptr, value)
                ffi.write_array_ptr(param_values, i, int_ptr)
            elif param is PropertyValue::Float(value):
                ffi.write_array_i32(param_types, i, 2)
                let float_ptr = ffi.alloc_f32()
                ffi.write_f32(float_ptr, value)
                ffi.write_array_ptr(param_values, i, float_ptr)
            elif param is PropertyValue::String(value):
                ffi.write_array_i32(param_types, i, 3)
                let str_ptr = ffi.string_to_ptr(value)
                ffi.write_array_ptr(param_values, i, str_ptr)
            elif param is PropertyValue::Object(ptr):
                ffi.write_array_i32(param_types, i, 4)
                ffi.write_array_ptr(param_values, i, ptr)

        unreal_blueprint_broadcast_event(self.dispatcher_ptr, param_count as i32, param_types, param_values)

        # Cleanup
        for i in 0..param_count:
            let param_ptr = ffi.read_array_ptr(param_values, i)
            ffi.free(param_ptr)

        ffi.free(param_types)
        ffi.free(param_values)


# Helper functions

# Call Blueprint function on actor
pub fn call_blueprint_function(actor: actor.AActor, function_name: String) -> PropertyValue:
    return BlueprintFunctionCall::new(actor.as_ptr(), function_name).execute()

# Get Blueprint property from actor
pub fn get_blueprint_property(actor: actor.AActor, property_name: String) -> PropertyValue:
    return BlueprintProperty::new(actor.as_ptr(), property_name).get()

# Set Blueprint property on actor
pub fn set_blueprint_property(actor: actor.AActor, property_name: String, value: PropertyValue):
    BlueprintProperty::new(actor.as_ptr(), property_name).set(value)


# FFI function declarations

extern "C":
    fn unreal_blueprint_call_function(
        object: ffi.VoidPtr,
        function_name: String,
        param_count: i32,
        param_types: ffi.VoidPtr,
        param_values: ffi.VoidPtr,
        result_type: ffi.VoidPtr,
        result_value: ffi.VoidPtr
    )

    fn unreal_blueprint_get_property(
        object: ffi.VoidPtr,
        property_name: String,
        value_type: ffi.VoidPtr,
        value_ptr: ffi.VoidPtr
    )

    fn unreal_blueprint_set_property(
        object: ffi.VoidPtr,
        property_name: String,
        value_type: i32,
        value_ptr: ffi.VoidPtr
    )

    fn unreal_blueprint_get_event_dispatcher(
        object: ffi.VoidPtr,
        event_name: String
    ) -> ffi.VoidPtr

    fn unreal_blueprint_broadcast_event(
        dispatcher: ffi.VoidPtr,
        param_count: i32,
        param_types: ffi.VoidPtr,
        param_values: ffi.VoidPtr
    )
