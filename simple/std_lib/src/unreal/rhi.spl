# Unreal RHI (Rendering Hardware Interface)
#
# Low-level rendering abstraction for Unreal Engine
#
# Features:
# - RHI resource management (textures, buffers, shaders)
# - Command list recording and submission
# - Graphics pipeline state objects
# - Render target and viewport management
# - Vulkan backend access
#
# Based on: https://docs.unrealengine.com/5.4/en-US/API/Runtime/RHI/

import sys.ffi

mod rhi

# PixelFormat
# Texture pixel formats
pub enum PixelFormat:
    Unknown = 0
    R8G8B8A8_UNORM = 1
    B8G8R8A8_UNORM = 2
    R16G16B16A16_FLOAT = 3
    R32G32B32A32_FLOAT = 4
    D24_UNORM_S8_UINT = 5
    D32_FLOAT = 6
    R8_UNORM = 7
    BC1_UNORM = 8
    BC2_UNORM = 9
    BC3_UNORM = 10

impl PixelFormat:
    pub fn to_int(self) -> i32:
        if self == PixelFormat::Unknown:
            return 0
        elif self == PixelFormat::R8G8B8A8_UNORM:
            return 1
        elif self == PixelFormat::B8G8R8A8_UNORM:
            return 2
        elif self == PixelFormat::R16G16B16A16_FLOAT:
            return 3
        elif self == PixelFormat::R32G32B32A32_FLOAT:
            return 4
        elif self == PixelFormat::D24_UNORM_S8_UINT:
            return 5
        elif self == PixelFormat::D32_FLOAT:
            return 6
        elif self == PixelFormat::R8_UNORM:
            return 7
        elif self == PixelFormat::BC1_UNORM:
            return 8
        elif self == PixelFormat::BC2_UNORM:
            return 9
        else:
            return 10

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert pixel format to string.

        Returns:
            Format name

        Example:
            PixelFormat::R8G8B8A8_UNORM.to_string()  # → "R8G8B8A8_UNORM"
        """
        if self == PixelFormat::Unknown:
            return "Unknown"
        elif self == PixelFormat::R8G8B8A8_UNORM:
            return "R8G8B8A8_UNORM"
        elif self == PixelFormat::B8G8R8A8_UNORM:
            return "B8G8R8A8_UNORM"
        elif self == PixelFormat::R16G16B16A16_FLOAT:
            return "R16G16B16A16_FLOAT"
        elif self == PixelFormat::R32G32B32A32_FLOAT:
            return "R32G32B32A32_FLOAT"
        elif self == PixelFormat::D24_UNORM_S8_UINT:
            return "D24_UNORM_S8_UINT"
        elif self == PixelFormat::D32_FLOAT:
            return "D32_FLOAT"
        elif self == PixelFormat::R8_UNORM:
            return "R8_UNORM"
        elif self == PixelFormat::BC1_UNORM:
            return "BC1_UNORM"
        elif self == PixelFormat::BC2_UNORM:
            return "BC2_UNORM"
        else:
            return "BC3_UNORM"

    pub fn description(self) -> text:
        """Get pixel format description.

        Returns:
            Human-readable description

        Example:
            PixelFormat::R8G8B8A8_UNORM.description()
            # → "8-bit RGBA unsigned normalized"
        """
        if self == PixelFormat::Unknown:
            return "Unknown pixel format"
        elif self == PixelFormat::R8G8B8A8_UNORM:
            return "8-bit RGBA unsigned normalized"
        elif self == PixelFormat::B8G8R8A8_UNORM:
            return "8-bit BGRA unsigned normalized"
        elif self == PixelFormat::R16G16B16A16_FLOAT:
            return "16-bit RGBA f32 (half precision)"
        elif self == PixelFormat::R32G32B32A32_FLOAT:
            return "32-bit RGBA f32 (full precision)"
        elif self == PixelFormat::D24_UNORM_S8_UINT:
            return "24-bit depth + 8-bit stencil"
        elif self == PixelFormat::D32_FLOAT:
            return "32-bit depth f32"
        elif self == PixelFormat::R8_UNORM:
            return "8-bit single channel unsigned normalized"
        elif self == PixelFormat::BC1_UNORM:
            return "BC1 block compression (DXT1)"
        elif self == PixelFormat::BC2_UNORM:
            return "BC2 block compression (DXT3)"
        else:
            return "BC3 block compression (DXT5)"

    pub fn is_unknown(self) -> bool:
        """Check if format is Unknown.

        Returns:
            True if Unknown
        """
        return self == PixelFormat::Unknown

    pub fn is_r8g8b8a8_unorm(self) -> bool:
        """Check if format is R8G8B8A8_UNORM.

        Returns:
            True if R8G8B8A8_UNORM
        """
        return self == PixelFormat::R8G8B8A8_UNORM

    pub fn is_b8g8r8a8_unorm(self) -> bool:
        """Check if format is B8G8R8A8_UNORM.

        Returns:
            True if B8G8R8A8_UNORM
        """
        return self == PixelFormat::B8G8R8A8_UNORM

    pub fn is_r16g16b16a16_float(self) -> bool:
        """Check if format is R16G16B16A16_FLOAT.

        Returns:
            True if R16G16B16A16_FLOAT
        """
        return self == PixelFormat::R16G16B16A16_FLOAT

    pub fn is_r32g32b32a32_float(self) -> bool:
        """Check if format is R32G32B32A32_FLOAT.

        Returns:
            True if R32G32B32A32_FLOAT
        """
        return self == PixelFormat::R32G32B32A32_FLOAT

    pub fn is_d24_unorm_s8_uint(self) -> bool:
        """Check if format is D24_UNORM_S8_UINT.

        Returns:
            True if D24_UNORM_S8_UINT
        """
        return self == PixelFormat::D24_UNORM_S8_UINT

    pub fn is_d32_float(self) -> bool:
        """Check if format is D32_FLOAT.

        Returns:
            True if D32_FLOAT
        """
        return self == PixelFormat::D32_FLOAT

    pub fn is_r8_unorm(self) -> bool:
        """Check if format is R8_UNORM.

        Returns:
            True if R8_UNORM
        """
        return self == PixelFormat::R8_UNORM

    pub fn is_bc1_unorm(self) -> bool:
        """Check if format is BC1_UNORM.

        Returns:
            True if BC1_UNORM
        """
        return self == PixelFormat::BC1_UNORM

    pub fn is_bc2_unorm(self) -> bool:
        """Check if format is BC2_UNORM.

        Returns:
            True if BC2_UNORM
        """
        return self == PixelFormat::BC2_UNORM

    pub fn is_bc3_unorm(self) -> bool:
        """Check if format is BC3_UNORM.

        Returns:
            True if BC3_UNORM
        """
        return self == PixelFormat::BC3_UNORM

    pub fn is_depth_format(self) -> bool:
        """Check if format is depth/stencil format.

        Returns:
            True for depth or depth-stencil formats

        Example:
            PixelFormat::D24_UNORM_S8_UINT.is_depth_format()  # → true
        """
        return self == PixelFormat::D24_UNORM_S8_UINT or self == PixelFormat::D32_FLOAT

    pub fn is_color_format(self) -> bool:
        """Check if format is color format.

        Returns:
            True for color formats (not depth/stencil)

        Example:
            PixelFormat::R8G8B8A8_UNORM.is_color_format()  # → true
        """
        return not self.is_depth_format() and not self.is_unknown()

    pub fn is_compressed(self) -> bool:
        """Check if format uses block compression.

        Returns:
            True for BC1/BC2/BC3 formats

        Example:
            PixelFormat::BC1_UNORM.is_compressed()  # → true
        """
        return self == PixelFormat::BC1_UNORM or self == PixelFormat::BC2_UNORM or self == PixelFormat::BC3_UNORM

    pub fn is_float_format(self) -> bool:
        """Check if format uses floating point.

        Returns:
            True for f32 formats

        Example:
            PixelFormat::R32G32B32A32_FLOAT.is_float_format()  # → true
        """
        return self == PixelFormat::R16G16B16A16_FLOAT or self == PixelFormat::R32G32B32A32_FLOAT or self == PixelFormat::D32_FLOAT

    pub fn is_hdr(self) -> bool:
        """Check if format supports HDR (high dynamic range).

        Returns:
            True for HDR-capable formats

        Example:
            PixelFormat::R16G16B16A16_FLOAT.is_hdr()  # → true
        """
        return self == PixelFormat::R16G16B16A16_FLOAT or self == PixelFormat::R32G32B32A32_FLOAT

    pub fn bytes_per_pixel(self) -> i32:
        """Get bytes per pixel (uncompressed formats only).

        Returns:
            Bytes per pixel, or 0 for compressed/unknown

        Example:
            PixelFormat::R8G8B8A8_UNORM.bytes_per_pixel()  # → 4
        """
        if self == PixelFormat::R8G8B8A8_UNORM or self == PixelFormat::B8G8R8A8_UNORM:
            return 4
        elif self == PixelFormat::R16G16B16A16_FLOAT:
            return 8
        elif self == PixelFormat::R32G32B32A32_FLOAT:
            return 16
        elif self == PixelFormat::D24_UNORM_S8_UINT:
            return 4
        elif self == PixelFormat::D32_FLOAT:
            return 4
        elif self == PixelFormat::R8_UNORM:
            return 1
        else:
            return 0

    pub fn summary(self) -> text:
        """Get pixel format summary.

        Returns:
            Human-readable summary

        Example:
            PixelFormat::R8G8B8A8_UNORM.summary()
            # → "PixelFormat: R8G8B8A8_UNORM (8-bit RGBA unsigned normalized, color, 4 bytes/pixel)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_color_format():
            props.push("color")
        if self.is_depth_format():
            props.push("depth")
        if self.is_compressed():
            props.push("compressed")
        if self.is_float_format():
            props.push("f32")
        if self.is_hdr():
            props.push("HDR")

        val bpp = self.bytes_per_pixel()
        if bpp > 0:
            props.push("{bpp} bytes/pixel")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "PixelFormat: {name} ({desc}, {props_str})"
        else:
            return "PixelFormat: {name} ({desc})"

# TextureUsage
# Texture usage flags
pub enum TextureUsage:
    None = 0
    RenderTargetable = 1
    DepthStencil = 2
    ShaderResource = 4
    UAV = 8

impl TextureUsage:
    pub fn to_int(self) -> i32:
        if self == TextureUsage::None:
            return 0
        elif self == TextureUsage::RenderTargetable:
            return 1
        elif self == TextureUsage::DepthStencil:
            return 2
        elif self == TextureUsage::ShaderResource:
            return 4
        else:
            return 8

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert texture usage to string.

        Returns:
            Usage name

        Example:
            TextureUsage::RenderTargetable.to_string()  # → "RenderTargetable"
        """
        if self == TextureUsage::None:
            return "None"
        elif self == TextureUsage::RenderTargetable:
            return "RenderTargetable"
        elif self == TextureUsage::DepthStencil:
            return "DepthStencil"
        elif self == TextureUsage::ShaderResource:
            return "ShaderResource"
        else:
            return "UAV"

    pub fn description(self) -> text:
        """Get texture usage description.

        Returns:
            Human-readable description

        Example:
            TextureUsage::RenderTargetable.description()
            # → "Can be used as render target"
        """
        if self == TextureUsage::None:
            return "No special usage"
        elif self == TextureUsage::RenderTargetable:
            return "Can be used as render target"
        elif self == TextureUsage::DepthStencil:
            return "Can be used as depth/stencil buffer"
        elif self == TextureUsage::ShaderResource:
            return "Can be read in shaders"
        else:
            return "Unordered access view (read/write in compute)"

    pub fn is_none(self) -> bool:
        """Check if usage is None.

        Returns:
            True if None
        """
        return self == TextureUsage::None

    pub fn is_render_targetable(self) -> bool:
        """Check if usage is RenderTargetable.

        Returns:
            True if RenderTargetable
        """
        return self == TextureUsage::RenderTargetable

    pub fn is_depth_stencil(self) -> bool:
        """Check if usage is DepthStencil.

        Returns:
            True if DepthStencil
        """
        return self == TextureUsage::DepthStencil

    pub fn is_shader_resource(self) -> bool:
        """Check if usage is ShaderResource.

        Returns:
            True if ShaderResource
        """
        return self == TextureUsage::ShaderResource

    pub fn is_uav(self) -> bool:
        """Check if usage is UAV.

        Returns:
            True if UAV
        """
        return self == TextureUsage::UAV

    pub fn is_writable(self) -> bool:
        """Check if texture can be written to.

        Returns:
            True for RenderTargetable, DepthStencil, or UAV

        Example:
            TextureUsage::UAV.is_writable()  # → true
            TextureUsage::ShaderResource.is_writable()  # → false
        """
        return self == TextureUsage::RenderTargetable or self == TextureUsage::DepthStencil or self == TextureUsage::UAV

    pub fn is_readable(self) -> bool:
        """Check if texture can be read from.

        Returns:
            True for ShaderResource or UAV

        Example:
            TextureUsage::ShaderResource.is_readable()  # → true
        """
        return self == TextureUsage::ShaderResource or self == TextureUsage::UAV

    pub fn requires_render_target_support(self) -> bool:
        """Check if usage requires render target support.

        Returns:
            True for RenderTargetable or DepthStencil

        Example:
            TextureUsage::RenderTargetable.requires_render_target_support()  # → true
        """
        return self == TextureUsage::RenderTargetable or self == TextureUsage::DepthStencil

    pub fn summary(self) -> text:
        """Get texture usage summary.

        Returns:
            Human-readable summary

        Example:
            TextureUsage::UAV.summary()
            # → "TextureUsage: UAV (Unordered access view (read/write in compute), writable, readable)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_writable():
            props.push("writable")
        if self.is_readable():
            props.push("readable")
        if self.requires_render_target_support():
            props.push("requires RT support")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "TextureUsage: {name} ({desc}, {props_str})"
        else:
            return "TextureUsage: {name} ({desc})"

# RHITexture
# GPU texture resource
pub struct RHITexture:
    texture_ptr: ffi.VoidPtr

impl RHITexture:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHITexture:
        return RHITexture(texture_ptr: ptr)

    # Get texture dimensions
    pub fn get_size(self) -> (i32, i32, i32):
        val width = ffi.alloc_i32()
        val height = ffi.alloc_i32()
        val depth = ffi.alloc_i32()

        unreal_rhi_texture_get_size(self.texture_ptr, width, height, depth)

        val result = (ffi.read_i32(width), ffi.read_i32(height), ffi.read_i32(depth))

        ffi.free(width)
        ffi.free(height)
        ffi.free(depth)

        return result

    # Get pixel format
    pub fn get_format(self) -> PixelFormat:
        val format = unreal_rhi_texture_get_format(self.texture_ptr)
        # Map i32 back to enum (simplified)
        if format == 1:
            return PixelFormat::R8G8B8A8_UNORM
        elif format == 2:
            return PixelFormat::B8G8R8A8_UNORM
        else:
            return PixelFormat::Unknown

    # Get mip count
    pub fn get_num_mips(self) -> i32:
        return unreal_rhi_texture_get_num_mips(self.texture_ptr)

    # Update texture data
    pub fn update_texture_2d(mut self, mip_level: i32, data: ffi.VoidPtr, data_size: i32):
        unreal_rhi_update_texture_2d(self.texture_ptr, mip_level, data, data_size)

    # Get native pointer
    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.texture_ptr


# RHIBuffer
# GPU buffer resource
pub struct RHIBuffer:
    buffer_ptr: ffi.VoidPtr

impl RHIBuffer:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHIBuffer:
        return RHIBuffer(buffer_ptr: ptr)

    # Get buffer size
    pub fn get_size(self) -> i32:
        return unreal_rhi_buffer_get_size(self.buffer_ptr)

    # Update buffer data
    pub fn update_buffer(mut self, data: ffi.VoidPtr, data_size: i32, offset: i32 = 0):
        unreal_rhi_update_buffer(self.buffer_ptr, data, data_size, offset)

    # Lock buffer for CPU access
    pub fn lock_buffer(mut self, offset: i32, size: i32) -> ffi.VoidPtr:
        return unreal_rhi_lock_buffer(self.buffer_ptr, offset, size)

    # Unlock buffer
    pub fn unlock_buffer(mut self):
        unreal_rhi_unlock_buffer(self.buffer_ptr)

    # Get native pointer
    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.buffer_ptr


# ShaderType
# Shader stage types
pub enum ShaderType:
    Vertex = 0
    Pixel = 1
    Geometry = 2
    Compute = 3
    Hull = 4
    Domain = 5

impl ShaderType:
    pub fn to_int(self) -> i32:
        if self == ShaderType::Vertex:
            return 0
        elif self == ShaderType::Pixel:
            return 1
        elif self == ShaderType::Geometry:
            return 2
        elif self == ShaderType::Compute:
            return 3
        elif self == ShaderType::Hull:
            return 4
        else:
            return 5

    pub fn to_string(self) -> text:
        """Convert shader type to string."""
        match self:
            case Vertex: "Vertex"
            case Pixel: "Pixel"
            case Geometry: "Geometry"
            case Compute: "Compute"
            case Hull: "Hull"
            case Domain: "Domain"

    pub fn description(self) -> text:
        """Get shader type description."""
        match self:
            case Vertex: "Vertex shader (processes vertices)"
            case Pixel: "Pixel/Fragment shader (processes pixels)"
            case Geometry: "Geometry shader (generates primitives)"
            case Compute: "Compute shader (general GPU computation)"
            case Hull: "Hull/Tessellation control shader"
            case Domain: "Domain/Tessellation evaluation shader"

    pub fn is_vertex(self) -> bool:
        """Check if shader type is Vertex."""
        match self:
            case Vertex: true
            case _: false

    pub fn is_pixel(self) -> bool:
        """Check if shader type is Pixel."""
        match self:
            case Pixel: true
            case _: false

    pub fn is_geometry(self) -> bool:
        """Check if shader type is Geometry."""
        match self:
            case Geometry: true
            case _: false

    pub fn is_compute(self) -> bool:
        """Check if shader type is Compute."""
        match self:
            case Compute: true
            case _: false

    pub fn is_hull(self) -> bool:
        """Check if shader type is Hull."""
        match self:
            case Hull: true
            case _: false

    pub fn is_domain(self) -> bool:
        """Check if shader type is Domain."""
        match self:
            case Domain: true
            case _: false

    pub fn is_graphics_stage(self) -> bool:
        """Check if shader is a graphics pipeline stage."""
        match self:
            case Vertex: true
            case Pixel: true
            case Geometry: true
            case Hull: true
            case Domain: true
            case _: false

    pub fn is_tessellation_stage(self) -> bool:
        """Check if shader is a tessellation stage."""
        match self:
            case Hull: true
            case Domain: true
            case _: false

    pub fn is_rasterization_stage(self) -> bool:
        """Check if shader participates in rasterization."""
        match self:
            case Vertex: true
            case Geometry: true
            case Pixel: true
            case _: false

    pub fn summary(self) -> text:
        """Get comprehensive shader type summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_graphics_stage():
            props.push("graphics")
        if self.is_compute():
            props.push("compute")
        if self.is_tessellation_stage():
            props.push("tessellation")
        if self.is_rasterization_stage():
            props.push("rasterization")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ShaderType: {name} ({desc}, {props_str})"
        else:
            return "ShaderType: {name} ({desc})"

# RHIShader
# Compiled shader
pub struct RHIShader:
    shader_ptr: ffi.VoidPtr
    shader_type: ShaderType

impl RHIShader:
    pub fn from_ptr(ptr: ffi.VoidPtr, shader_type: ShaderType) -> RHIShader:
        return RHIShader(shader_ptr: ptr, shader_type: shader_type)

    pub fn get_type(self) -> ShaderType:
        return self.shader_type

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.shader_ptr


# RHIRenderTargetView
# Render target view
pub struct RHIRenderTargetView:
    rtv_ptr: ffi.VoidPtr

impl RHIRenderTargetView:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHIRenderTargetView:
        return RHIRenderTargetView(rtv_ptr: ptr)

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.rtv_ptr


# RHIDepthStencilView
# Depth stencil view
pub struct RHIDepthStencilView:
    dsv_ptr: ffi.VoidPtr

impl RHIDepthStencilView:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHIDepthStencilView:
        return RHIDepthStencilView(dsv_ptr: ptr)

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.dsv_ptr


# RHICommandList
# Command list for recording rendering commands
pub struct RHICommandList:
    cmd_list_ptr: ffi.VoidPtr

impl RHICommandList:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHICommandList:
        return RHICommandList(cmd_list_ptr: ptr)

    # Clear render target
    pub fn clear_render_target(mut self, rtv: RHIRenderTargetView, r: f32, g: f32, b: f32, a: f32):
        unreal_rhi_clear_render_target(self.cmd_list_ptr, rtv.as_ptr(), r, g, b, a)

    # Clear depth stencil
    pub fn clear_depth_stencil(mut self, dsv: RHIDepthStencilView, depth: f32, stencil: i32):
        unreal_rhi_clear_depth_stencil(self.cmd_list_ptr, dsv.as_ptr(), depth, stencil)

    # Set render targets
    pub fn set_render_targets(mut self, rtvs: Vec<RHIRenderTargetView>, dsv: Option<RHIDepthStencilView>):
        val num_rtvs = rtvs.len()
        val rtv_array = ffi.alloc_array_ptr(num_rtvs)

        for i in 0..num_rtvs:
            ffi.write_array_ptr(rtv_array, i, rtvs[i].as_ptr())

        val dsv_ptr = if dsv.is_some():
            dsv.unwrap().as_ptr()
        else:
            ffi.null_ptr()

        unreal_rhi_set_render_targets(self.cmd_list_ptr, num_rtvs as i32, rtv_array, dsv_ptr)
        ffi.free(rtv_array)

    # Set viewport
    pub fn set_viewport(mut self, x: f32, y: f32, width: f32, height: f32, min_depth: f32 = 0.0, max_depth: f32 = 1.0):
        unreal_rhi_set_viewport(self.cmd_list_ptr, x, y, width, height, min_depth, max_depth)

    # Set scissor rect
    pub fn set_scissor_rect(mut self, x: i32, y: i32, width: i32, height: i32):
        unreal_rhi_set_scissor_rect(self.cmd_list_ptr, x, y, width, height)

    # Draw primitives
    pub fn draw_primitive(mut self, vertex_count: i32, instance_count: i32 = 1, start_vertex: i32 = 0, start_instance: i32 = 0):
        unreal_rhi_draw_primitive(self.cmd_list_ptr, vertex_count, instance_count, start_vertex, start_instance)

    # Draw indexed primitives
    pub fn draw_indexed_primitive(mut self, index_count: i32, instance_count: i32 = 1, start_index: i32 = 0, base_vertex: i32 = 0, start_instance: i32 = 0):
        unreal_rhi_draw_indexed_primitive(self.cmd_list_ptr, index_count, instance_count, start_index, base_vertex, start_instance)

    # Submit command list
    pub fn submit(mut self):
        unreal_rhi_submit_command_list(self.cmd_list_ptr)

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.cmd_list_ptr


# Vulkan-specific backend access

# VulkanDevice
# Access to Vulkan device
pub struct VulkanDevice:
    device_ptr: ffi.VoidPtr

impl VulkanDevice:
    pub fn get_instance() -> VulkanDevice:
        val ptr = unreal_vulkan_get_device()
        return VulkanDevice(device_ptr: ptr)

    # Get native VkDevice handle
    pub fn get_vk_device(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_vk_device(self.device_ptr)

    # Get native VkPhysicalDevice handle
    pub fn get_vk_physical_device(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_vk_physical_device(self.device_ptr)

    # Get native VkInstance handle
    pub fn get_vk_instance(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_vk_instance(self.device_ptr)

    # Get graphics queue
    pub fn get_graphics_queue(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_graphics_queue(self.device_ptr)

    # Get compute queue
    pub fn get_compute_queue(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_compute_queue(self.device_ptr)

    # Get transfer queue
    pub fn get_transfer_queue(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_transfer_queue(self.device_ptr)


# VulkanTexture
# Vulkan-specific texture access
pub struct VulkanTexture:
    base: RHITexture

impl VulkanTexture:
    pub fn from_rhi_texture(texture: RHITexture) -> VulkanTexture:
        return VulkanTexture(base: texture)

    # Get native VkImage handle
    pub fn get_vk_image(self) -> ffi.VoidPtr:
        return unreal_vulkan_texture_get_vk_image(self.base.as_ptr())

    # Get native VkImageView handle
    pub fn get_vk_image_view(self) -> ffi.VoidPtr:
        return unreal_vulkan_texture_get_vk_image_view(self.base.as_ptr())

    # Get VkFormat
    pub fn get_vk_format(self) -> i32:
        return unreal_vulkan_texture_get_vk_format(self.base.as_ptr())


# VulkanBuffer
# Vulkan-specific buffer access
pub struct VulkanBuffer:
    base: RHIBuffer

impl VulkanBuffer:
    pub fn from_rhi_buffer(buffer: RHIBuffer) -> VulkanBuffer:
        return VulkanBuffer(base: buffer)

    # Get native VkBuffer handle
    pub fn get_vk_buffer(self) -> ffi.VoidPtr:
        return unreal_vulkan_buffer_get_vk_buffer(self.base.as_ptr())

    # Get VkDeviceMemory handle
    pub fn get_vk_device_memory(self) -> ffi.VoidPtr:
        return unreal_vulkan_buffer_get_vk_device_memory(self.base.as_ptr())


# Resource creation functions

# Create 2D texture
pub fn create_texture_2d(width: i32, height: i32, format: PixelFormat, usage: TextureUsage, num_mips: i32 = 1) -> RHITexture:
    val ptr = unreal_rhi_create_texture_2d(width, height, format.to_int(), usage.to_int(), num_mips)
    return RHITexture::from_ptr(ptr)

# Create render target
pub fn create_render_target(width: i32, height: i32, format: PixelFormat) -> RHITexture:
    val usage_flags = TextureUsage::RenderTargetable.to_int() | TextureUsage::ShaderResource.to_int()
    val ptr = unreal_rhi_create_texture_2d(width, height, format.to_int(), usage_flags, 1)
    return RHITexture::from_ptr(ptr)

# Create depth stencil target
pub fn create_depth_stencil_target(width: i32, height: i32) -> RHITexture:
    val format = PixelFormat::D24_UNORM_S8_UINT
    val usage_flags = TextureUsage::DepthStencil.to_int() | TextureUsage::ShaderResource.to_int()
    val ptr = unreal_rhi_create_texture_2d(width, height, format.to_int(), usage_flags, 1)
    return RHITexture::from_ptr(ptr)

# Create vertex buffer
pub fn create_vertex_buffer(size: i32, data: ffi.VoidPtr = ffi.null_ptr()) -> RHIBuffer:
    val ptr = unreal_rhi_create_vertex_buffer(size, data)
    return RHIBuffer::from_ptr(ptr)

# Create index buffer
pub fn create_index_buffer(size: i32, data: ffi.VoidPtr = ffi.null_ptr()) -> RHIBuffer:
    val ptr = unreal_rhi_create_index_buffer(size, data)
    return RHIBuffer::from_ptr(ptr)

# Create uniform buffer
pub fn create_uniform_buffer(size: i32, data: ffi.VoidPtr = ffi.null_ptr()) -> RHIBuffer:
    val ptr = unreal_rhi_create_uniform_buffer(size, data)
    return RHIBuffer::from_ptr(ptr)

# Get immediate command list for quick commands
pub fn get_immediate_command_list() -> RHICommandList:
    val ptr = unreal_rhi_get_immediate_command_list()
    return RHICommandList::from_ptr(ptr)


# FFI function declarations

extern "C":
    # Texture functions
    fn unreal_rhi_create_texture_2d(width: i32, height: i32, format: i32, usage: i32, num_mips: i32) -> ffi.VoidPtr
    fn unreal_rhi_texture_get_size(texture: ffi.VoidPtr, width: ffi.VoidPtr, height: ffi.VoidPtr, depth: ffi.VoidPtr)
    fn unreal_rhi_texture_get_format(texture: ffi.VoidPtr) -> i32
    fn unreal_rhi_texture_get_num_mips(texture: ffi.VoidPtr) -> i32
    fn unreal_rhi_update_texture_2d(texture: ffi.VoidPtr, mip_level: i32, data: ffi.VoidPtr, data_size: i32)

    # Buffer functions
    fn unreal_rhi_create_vertex_buffer(size: i32, data: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_rhi_create_index_buffer(size: i32, data: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_rhi_create_uniform_buffer(size: i32, data: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_rhi_buffer_get_size(buffer: ffi.VoidPtr) -> i32
    fn unreal_rhi_update_buffer(buffer: ffi.VoidPtr, data: ffi.VoidPtr, data_size: i32, offset: i32)
    fn unreal_rhi_lock_buffer(buffer: ffi.VoidPtr, offset: i32, size: i32) -> ffi.VoidPtr
    fn unreal_rhi_unlock_buffer(buffer: ffi.VoidPtr)

    # Command list functions
    fn unreal_rhi_get_immediate_command_list() -> ffi.VoidPtr
    fn unreal_rhi_clear_render_target(cmd_list: ffi.VoidPtr, rtv: ffi.VoidPtr, r: f32, g: f32, b: f32, a: f32)
    fn unreal_rhi_clear_depth_stencil(cmd_list: ffi.VoidPtr, dsv: ffi.VoidPtr, depth: f32, stencil: i32)
    fn unreal_rhi_set_render_targets(cmd_list: ffi.VoidPtr, num_rtvs: i32, rtvs: ffi.VoidPtr, dsv: ffi.VoidPtr)
    fn unreal_rhi_set_viewport(cmd_list: ffi.VoidPtr, x: f32, y: f32, width: f32, height: f32, min_depth: f32, max_depth: f32)
    fn unreal_rhi_set_scissor_rect(cmd_list: ffi.VoidPtr, x: i32, y: i32, width: i32, height: i32)
    fn unreal_rhi_draw_primitive(cmd_list: ffi.VoidPtr, vertex_count: i32, instance_count: i32, start_vertex: i32, start_instance: i32)
    fn unreal_rhi_draw_indexed_primitive(cmd_list: ffi.VoidPtr, index_count: i32, instance_count: i32, start_index: i32, base_vertex: i32, start_instance: i32)
    fn unreal_rhi_submit_command_list(cmd_list: ffi.VoidPtr)

    # Vulkan backend functions
    fn unreal_vulkan_get_device() -> ffi.VoidPtr
    fn unreal_vulkan_get_vk_device(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_vk_physical_device(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_vk_instance(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_graphics_queue(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_compute_queue(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_transfer_queue(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_texture_get_vk_image(texture: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_texture_get_vk_image_view(texture: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_texture_get_vk_format(texture: ffi.VoidPtr) -> i32
    fn unreal_vulkan_buffer_get_vk_buffer(buffer: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_buffer_get_vk_device_memory(buffer: ffi.VoidPtr) -> ffi.VoidPtr


# Example usage:
#
# # Create render target
# val rt = create_render_target(1920, 1080, PixelFormat::R8G8B8A8_UNORM)
# val ds = create_depth_stencil_target(1920, 1080)
#
# # Get command list
# var cmd_list = get_immediate_command_list()
#
# # Clear and draw
# val rtv = RHIRenderTargetView::from_ptr(unreal_rhi_get_render_target_view(rt.as_ptr()))
# val dsv = RHIDepthStencilView::from_ptr(unreal_rhi_get_depth_stencil_view(ds.as_ptr()))
#
# cmd_list.set_render_targets([rtv], Some(dsv))
# cmd_list.set_viewport(0.0, 0.0, 1920.0, 1080.0)
# cmd_list.clear_render_target(rtv, 0.0, 0.0, 0.0, 1.0)
# cmd_list.clear_depth_stencil(dsv, 1.0, 0)
# cmd_list.draw_primitive(3, 1, 0, 0)
# cmd_list.submit()
#
# # Vulkan-specific access
# val vk_device = VulkanDevice::get_instance()
# val vk_handle = vk_device.get_vk_device()
# val vk_tex = VulkanTexture::from_rhi_texture(rt)
# val vk_image = vk_tex.get_vk_image()
