# Build.cs Generation
#
# Generates C# Build.cs files for Unreal Build Tool
#
# Features:
# - Module descriptor generation
# - Dependency management
# - Include path configuration
# - Preprocessor definitions
#
# Based on: https://docs.unrealengine.com/5.4/en-US/build-configuration-for-unreal-engine/

import sys.io
import sys.path

mod build_cs

# ModuleType
# Type of Unreal module
pub enum ModuleType:
    Runtime = 0         # Runtime module (game code)
    Editor = 1          # Editor-only module
    Developer = 2       # Developer tools
    ThirdParty = 3      # Third-party library
    Plugin = 4          # Plugin module

impl ModuleType:
    pub fn to_string(self) -> String:
        if self == ModuleType::Runtime:
            return "ModuleType.Runtime"
        elif self == ModuleType::Editor:
            return "ModuleType.Editor"
        elif self == ModuleType::Developer:
            return "ModuleType.Developer"
        elif self == ModuleType::ThirdParty:
            return "ModuleType.ThirdParty"
        else:
            return "ModuleType.Plugin"


# LoadingPhase
# When the module should be loaded
pub enum LoadingPhase:
    Default = 0         # Default loading
    PostConfigInit = 1  # After config initialization
    PreDefault = 2      # Before default modules
    PreLoadingScreen = 3  # Before loading screen

impl LoadingPhase:
    pub fn to_string(self) -> String:
        if self == LoadingPhase::PostConfigInit:
            return "LoadingPhase.PostConfigInit"
        elif self == LoadingPhase::PreDefault:
            return "LoadingPhase.PreDefault"
        elif self == LoadingPhase::PreLoadingScreen:
            return "LoadingPhase.PreLoadingScreen"
        else:
            return "LoadingPhase.Default"


# BuildCsGenerator
# Builder for generating .Build.cs files
pub struct BuildCsGenerator:
    module_name: String
    module_type: ModuleType
    loading_phase: LoadingPhase
    public_dependencies: Vec[String]
    private_dependencies: Vec[String]
    public_include_paths: Vec[String]
    private_include_paths: Vec[String]
    definitions: Vec[String]

impl BuildCsGenerator:
    # Create new generator
    pub fn new(module_name: String) -> BuildCsGenerator:
        return BuildCsGenerator(
            module_name: module_name,
            module_type: ModuleType::Runtime,
            loading_phase: LoadingPhase::Default,
            public_dependencies: [],
            private_dependencies: [],
            public_include_paths: [],
            private_include_paths: [],
            definitions: [],
        )

    # Set module type
    pub fn module_type(mut self, module_type: ModuleType) -> BuildCsGenerator:
        self.module_type = module_type
        return self

    # Set loading phase
    pub fn loading_phase(mut self, phase: LoadingPhase) -> BuildCsGenerator:
        self.loading_phase = phase
        return self

    # Add public dependency
    pub fn public_dependency(mut self, dep: String) -> BuildCsGenerator:
        self.public_dependencies.push(dep)
        return self

    # Add private dependency
    pub fn private_dependency(mut self, dep: String) -> BuildCsGenerator:
        self.private_dependencies.push(dep)
        return self

    # Add core dependencies (Core, CoreUObject, Engine)
    pub fn with_core_dependencies(mut self) -> BuildCsGenerator:
        return self
            .public_dependency("Core")
            .public_dependency("CoreUObject")
            .public_dependency("Engine")

    # Add public include path
    pub fn public_include_path(mut self, path: String) -> BuildCsGenerator:
        self.public_include_paths.push(path)
        return self

    # Add private include path
    pub fn private_include_path(mut self, path: String) -> BuildCsGenerator:
        self.private_include_paths.push(path)
        return self

    # Add preprocessor definition
    pub fn definition(mut self, def: String) -> BuildCsGenerator:
        self.definitions.push(def)
        return self

    # Generate the .Build.cs file content
    pub fn generate(self) -> String:
        let mut content = ""

        # Header
        content = content + "// Auto-generated Build.cs for " + self.module_name + "\n"
        content = content + "// Generated by Simple Unreal Integration\n\n"

        # Using statements
        content = content + "using UnrealBuildTool;\n\n"

        # Class definition
        content = content + "public class " + self.module_name + " : ModuleRules\n"
        content = content + "{\n"
        content = content + "\tpublic " + self.module_name + "(ReadOnlyTargetRules Target) : base(Target)\n"
        content = content + "\t{\n"

        # Module type
        content = content + "\t\tType = " + self.module_type.to_string() + ";\n\n"

        # Loading phase
        if self.loading_phase != LoadingPhase::Default:
            content = content + "\t\tLoadingPhase = " + self.loading_phase.to_string() + ";\n\n"

        # Public dependencies
        if self.public_dependencies.len() > 0:
            content = content + "\t\tPublicDependencyModuleNames.AddRange(new string[]\n"
            content = content + "\t\t{\n"
            for i in 0..self.public_dependencies.len():
                let dep = self.public_dependencies[i]
                content = content + "\t\t\t\"" + dep + "\""
                if i < self.public_dependencies.len() - 1:
                    content = content + ","
                content = content + "\n"
            content = content + "\t\t});\n\n"

        # Private dependencies
        if self.private_dependencies.len() > 0:
            content = content + "\t\tPrivateDependencyModuleNames.AddRange(new string[]\n"
            content = content + "\t\t{\n"
            for i in 0..self.private_dependencies.len():
                let dep = self.private_dependencies[i]
                content = content + "\t\t\t\"" + dep + "\""
                if i < self.private_dependencies.len() - 1:
                    content = content + ","
                content = content + "\n"
            content = content + "\t\t});\n\n"

        # Public include paths
        if self.public_include_paths.len() > 0:
            content = content + "\t\tPublicIncludePaths.AddRange(new string[]\n"
            content = content + "\t\t{\n"
            for i in 0..self.public_include_paths.len():
                let path_str = self.public_include_paths[i]
                content = content + "\t\t\t\"" + path_str + "\""
                if i < self.public_include_paths.len() - 1:
                    content = content + ","
                content = content + "\n"
            content = content + "\t\t});\n\n"

        # Private include paths
        if self.private_include_paths.len() > 0:
            content = content + "\t\tPrivateIncludePaths.AddRange(new string[]\n"
            content = content + "\t\t{\n"
            for i in 0..self.private_include_paths.len():
                let path_str = self.private_include_paths[i]
                content = content + "\t\t\t\"" + path_str + "\""
                if i < self.private_include_paths.len() - 1:
                    content = content + ","
                content = content + "\n"
            content = content + "\t\t});\n\n"

        # Preprocessor definitions
        if self.definitions.len() > 0:
            content = content + "\t\tPublicDefinitions.AddRange(new string[]\n"
            content = content + "\t\t{\n"
            for i in 0..self.definitions.len():
                let def = self.definitions[i]
                content = content + "\t\t\t\"" + def + "\""
                if i < self.definitions.len() - 1:
                    content = content + ","
                content = content + "\n"
            content = content + "\t\t});\n\n"

        # Close constructor and class
        content = content + "\t}\n"
        content = content + "}\n"

        return content

    # Write to file
    pub fn write_to_file(self, output_path: String) -> bool:
        let content = self.generate()
        return io.write_file(output_path, content)


# Preset generators

# Generate a basic game module Build.cs
pub fn generate_game_module(module_name: String) -> String:
    return BuildCsGenerator::new(module_name)
        .with_core_dependencies()
        .private_dependency("InputCore")
        .private_dependency("Slate")
        .private_dependency("SlateCore")
        .generate()

# Generate an editor module Build.cs
pub fn generate_editor_module(module_name: String, game_module: String) -> String:
    return BuildCsGenerator::new(module_name)
        .module_type(ModuleType::Editor)
        .with_core_dependencies()
        .public_dependency(game_module)
        .private_dependency("UnrealEd")
        .private_dependency("EditorStyle")
        .private_dependency("Slate")
        .private_dependency("SlateCore")
        .generate()

# Generate a plugin module Build.cs
pub fn generate_plugin_module(module_name: String) -> String:
    return BuildCsGenerator::new(module_name)
        .module_type(ModuleType::Plugin)
        .with_core_dependencies()
        .private_dependency("Projects")
        .generate()

# Generate a third-party library Build.cs
pub fn generate_thirdparty_module(module_name: String, lib_path: String) -> String:
    let mut gen = BuildCsGenerator::new(module_name)
        .module_type(ModuleType::ThirdParty)

    gen = gen.public_include_path(lib_path + "/Include")

    return gen.generate()
