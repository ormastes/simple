# Diagram Filter Module
# Provides include/exclude filtering for diagram generation
#
# Supports:
# - Glob patterns (*, **, ?)
# - Exact string matching
# - Multiple patterns (comma-separated)
# - Exclude takes precedence over include

import core.{Option, List, regex}
import recorder.{CallEvent}

# Filter mode
enum FilterMode:
    Include  # Only include matching items
    Exclude  # Exclude matching items

# Single pattern for matching
struct FilterPattern:
    raw: String           # Original pattern string
    regex: regex.Regex    # Compiled regex for matching
    mode: FilterMode      # Include or exclude

    # Create pattern from glob-style string
    fn from_glob(pattern: String, mode: FilterMode) -> FilterPattern:
        # Convert glob to regex
        let regex_str = glob_to_regex(pattern)
        return FilterPattern {
            raw: pattern,
            regex: regex.compile(regex_str),
            mode: mode,
        }

    # Check if a string matches this pattern
    fn matches(self, text: String) -> Bool:
        return self.regex.is_match(text)

# Convert glob pattern to regex
fn glob_to_regex(glob: String) -> String:
    let result = "^"
    let chars = glob.chars()
    let i = 0

    while i < chars.len():
        let c = chars[i]
        match c:
            case '*':
                # Check for **
                if i + 1 < chars.len() and chars[i + 1] == '*':
                    result = result + ".*"
                    i += 1
                else:
                    result = result + "[^.]*"
            case '?':
                result = result + "."
            case '.':
                result = result + "\\."
            case '(':
                result = result + "\\("
            case ')':
                result = result + "\\)"
            case '[':
                result = result + "\\["
            case ']':
                result = result + "\\]"
            case '{':
                result = result + "\\{"
            case '}':
                result = result + "\\}"
            case '^':
                result = result + "\\^"
            case '$':
                result = result + "\\$"
            case '|':
                result = result + "\\|"
            case '\\':
                result = result + "\\\\"
            case _:
                result = result + c
        i += 1

    return result + "$"

# Filter configuration
class DiagramFilter:
    include_patterns: List[FilterPattern]
    exclude_patterns: List[FilterPattern]

    fn new() -> DiagramFilter:
        return DiagramFilter {
            include_patterns: [],
            exclude_patterns: [],
        }

    # Add an include pattern
    fn add_include(mut self, pattern: String) -> Void:
        self.include_patterns.push(FilterPattern.from_glob(pattern, FilterMode.Include))

    # Add multiple include patterns (comma-separated)
    fn add_includes(mut self, patterns: String) -> Void:
        for pattern in patterns.split(","):
            let trimmed = pattern.trim()
            if not trimmed.is_empty():
                self.add_include(trimmed)

    # Add an exclude pattern
    fn add_exclude(mut self, pattern: String) -> Void:
        self.exclude_patterns.push(FilterPattern.from_glob(pattern, FilterMode.Exclude))

    # Add multiple exclude patterns (comma-separated)
    fn add_excludes(mut self, patterns: String) -> Void:
        for pattern in patterns.split(","):
            let trimmed = pattern.trim()
            if not trimmed.is_empty():
                self.add_exclude(trimmed)

    # Check if a name should be included
    # Rules:
    # 1. If excluded by any pattern -> false
    # 2. If no include patterns -> true (include all by default)
    # 3. If include patterns exist -> must match at least one
    fn should_include(self, name: String) -> Bool:
        # Check excludes first (they take precedence)
        for pattern in self.exclude_patterns:
            if pattern.matches(name):
                return false

        # If no include patterns, include everything
        if self.include_patterns.is_empty():
            return true

        # Must match at least one include pattern
        for pattern in self.include_patterns:
            if pattern.matches(name):
                return true

        return false

    # Filter a call event based on caller and callee
    fn should_include_event(self, event: CallEvent) -> Bool:
        let caller = event.get_caller_participant()
        let callee = event.get_callee_participant()

        # Both caller and callee must pass filter
        return self.should_include(caller) and self.should_include(callee)

    # Filter a list of events
    fn filter_events(self, events: List[CallEvent]) -> List[CallEvent]:
        let result: List[CallEvent] = []
        for event in events:
            if self.should_include_event(event):
                result.push(event)
        return result

    # Check if filter has any patterns
    fn is_empty(self) -> Bool:
        return self.include_patterns.is_empty() and self.exclude_patterns.is_empty()

    # Get pattern count
    fn pattern_count(self) -> u32:
        return (self.include_patterns.len() + self.exclude_patterns.len()) as u32

# Builder pattern for filter creation
fn filter() -> DiagramFilter:
    return DiagramFilter.new()

fn include(pattern: String) -> DiagramFilter:
    let f = DiagramFilter.new()
    f.add_include(pattern)
    return f

fn exclude(pattern: String) -> DiagramFilter:
    let f = DiagramFilter.new()
    f.add_exclude(pattern)
    return f

# Exports
export FilterMode, FilterPattern, DiagramFilter
export glob_to_regex, filter, include, exclude
