# Call Event Recorder
# Records function calls during test execution for diagram generation
#
# Features:
# - Ordered event log with sequence numbers
# - Timestamp tracking (microseconds from test start)
# - Caller/callee relationships with class context
# - Argument and return value capture
# - Call stack depth tracking

import core.{time, Option, List, Dict, Set}

# Call type enumeration
enum CallType:
    Direct      # Direct function call
    Method      # Method call on object
    FFI         # Foreign function interface call
    Closure     # Closure/lambda invocation
    Constructor # Constructor call (new)

# Single call event in the execution trace
struct CallEvent:
    sequence_num: u64       # Global ordering within test
    timestamp_us: u64       # Microseconds from recording start
    caller: String          # Caller function/method name
    callee: String          # Called function/method name
    caller_class: Option[String]  # Caller's class if method
    callee_class: Option[String]  # Callee's class if method
    arguments: List[String]       # Argument values as strings
    return_value: Option[String]  # Return value as string (set on return)
    call_type: CallType           # Type of call
    depth: u32                    # Call stack depth
    is_return: Bool               # True if this is a return event

    # Create a call entry event
    fn new_call(seq: u64, ts: u64, caller: String, callee: String,
                caller_cls: Option[String], callee_cls: Option[String],
                args: List[String], call_type: CallType, depth: u32) -> CallEvent:
        return CallEvent {
            sequence_num: seq,
            timestamp_us: ts,
            caller: caller,
            callee: callee,
            caller_class: caller_cls,
            callee_class: callee_cls,
            arguments: args,
            return_value: None,
            call_type: call_type,
            depth: depth,
            is_return: false,
        }

    # Create a return event
    fn new_return(seq: u64, ts: u64, caller: String, callee: String,
                  caller_cls: Option[String], callee_cls: Option[String],
                  ret_val: Option[String], depth: u32) -> CallEvent:
        return CallEvent {
            sequence_num: seq,
            timestamp_us: ts,
            caller: caller,
            callee: callee,
            caller_class: caller_cls,
            callee_class: callee_cls,
            arguments: [],
            return_value: ret_val,
            call_type: CallType.Direct,
            depth: depth,
            is_return: true,
        }

    # Get participant name for sequence diagram (class.method or just function)
    fn get_caller_participant(self) -> String:
        match self.caller_class:
            case Some(cls):
                return cls
            case None:
                return self.caller

    fn get_callee_participant(self) -> String:
        match self.callee_class:
            case Some(cls):
                return cls
            case None:
                return self.callee

    # Format call for display
    fn format_call(self) -> String:
        let args_str = self.arguments.join(", ")
        match self.callee_class:
            case Some(cls):
                return "${cls}.${self.callee}(${args_str})"
            case None:
                return "${self.callee}(${args_str})"

    fn format_return(self) -> String:
        match self.return_value:
            case Some(val):
                return val
            case None:
                return "(void)"

# Stack frame for tracking call depth
struct StackFrame:
    function_name: String
    class_name: Option[String]
    entry_time_us: u64

# Call event recorder - collects events during test execution
class CallEventRecorder:
    test_name: String
    events: List[CallEvent]
    call_stack: List[StackFrame]
    sequence_counter: u64
    start_time_us: u64
    classes_seen: Set[String]
    architectural_entities: Set[String]
    is_recording: Bool

    fn new(test_name: String) -> CallEventRecorder:
        return CallEventRecorder {
            test_name: test_name,
            events: [],
            call_stack: [],
            sequence_counter: 0,
            start_time_us: time.now_us(),
            classes_seen: Set.new(),
            architectural_entities: Set.new(),
            is_recording: true,
        }

    # Start recording (resets state)
    fn start(mut self) -> Void:
        self.events = []
        self.call_stack = []
        self.sequence_counter = 0
        self.start_time_us = time.now_us()
        self.classes_seen = Set.new()
        self.architectural_entities = Set.new()
        self.is_recording = true

    # Stop recording
    fn stop(mut self) -> Void:
        self.is_recording = false

    # Get elapsed time in microseconds
    fn elapsed_us(self) -> u64:
        return time.now_us() - self.start_time_us

    # Get current call stack depth
    fn current_depth(self) -> u32:
        return self.call_stack.len() as u32

    # Get current caller (top of stack)
    fn current_caller(self) -> Option[StackFrame]:
        if self.call_stack.is_empty():
            return None
        return Some(self.call_stack.last())

    # Record a function call entry
    fn record_call(mut self, callee: String, callee_class: Option[String],
                   args: List[String], call_type: CallType) -> Void:
        if not self.is_recording:
            return

        let ts = self.elapsed_us()
        let depth = self.current_depth()

        # Get caller info from stack
        let (caller, caller_class) = match self.current_caller():
            case Some(frame):
                (frame.function_name, frame.class_name)
            case None:
                ("(test)", None)

        # Track classes
        match callee_class:
            case Some(cls):
                self.classes_seen.insert(cls)
            case None:
                pass
        match caller_class:
            case Some(cls):
                self.classes_seen.insert(cls)
            case None:
                pass

        # Create and store event
        let event = CallEvent.new_call(
            self.sequence_counter,
            ts,
            caller,
            callee,
            caller_class,
            callee_class,
            args,
            call_type,
            depth
        )
        self.events.push(event)
        self.sequence_counter += 1

        # Push onto call stack
        let frame = StackFrame {
            function_name: callee,
            class_name: callee_class,
            entry_time_us: ts,
        }
        self.call_stack.push(frame)

    # Record a function return
    fn record_return(mut self, return_value: Option[String]) -> Void:
        if not self.is_recording:
            return
        if self.call_stack.is_empty():
            return

        let ts = self.elapsed_us()
        let frame = self.call_stack.pop()
        let depth = self.current_depth()

        # Get caller info (now the top of stack after pop)
        let (caller, caller_class) = match self.current_caller():
            case Some(f):
                (f.function_name, f.class_name)
            case None:
                ("(test)", None)

        let event = CallEvent.new_return(
            self.sequence_counter,
            ts,
            caller,
            frame.function_name,
            caller_class,
            frame.class_name,
            return_value,
            depth
        )
        self.events.push(event)
        self.sequence_counter += 1

    # Mark an entity as architectural
    fn mark_architectural(mut self, entity: String) -> Void:
        self.architectural_entities.insert(entity)

    # Check if entity is architectural
    fn is_architectural(self, entity: String) -> Bool:
        return self.architectural_entities.contains(entity)

    # Get all recorded events
    fn get_events(self) -> List[CallEvent]:
        return self.events

    # Get all classes seen in the trace
    fn get_classes(self) -> Set[String]:
        return self.classes_seen

    # Get architectural entities
    fn get_architectural_entities(self) -> Set[String]:
        return self.architectural_entities

    # Get event count
    fn event_count(self) -> u64:
        return self.events.len() as u64

    # Clear all recorded events
    fn clear(mut self) -> Void:
        self.events = []
        self.call_stack = []
        self.sequence_counter = 0
        self.classes_seen = Set.new()

# Global recorder instance (per-test context)
let _current_recorder: Option[CallEventRecorder] = None

# Get or create recorder for current test
fn get_recorder() -> CallEventRecorder:
    match _current_recorder:
        case Some(rec):
            return rec
        case None:
            let rec = CallEventRecorder.new("(unnamed)")
            _current_recorder = Some(rec)
            return rec

# Set recorder for a specific test
fn set_recorder(recorder: CallEventRecorder) -> Void:
    _current_recorder = Some(recorder)

# Clear current recorder
fn clear_recorder() -> Void:
    _current_recorder = None

# Convenience functions for recording
fn record_call(callee: String, args: List[String]) -> Void:
    get_recorder().record_call(callee, None, args, CallType.Direct)

fn record_method_call(class_name: String, method: String, args: List[String]) -> Void:
    get_recorder().record_call(method, Some(class_name), args, CallType.Method)

fn record_return(value: Option[String]) -> Void:
    get_recorder().record_return(value)

fn record_ffi_call(callee: String, args: List[String]) -> Void:
    get_recorder().record_call(callee, None, args, CallType.FFI)
