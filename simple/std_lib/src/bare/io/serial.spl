# Serial - Serial I/O abstraction
#
# Provides a high-level serial I/O interface built on UART.

use bare.hal.uart.{Uart, UartConfig}

# Line ending modes
enum LineEnding:
    LF       # \n (Unix)
    CRLF     # \r\n (Windows)
    CR       # \r (old Mac)

# Serial port wrapper
struct Serial:
    uart: Uart
    line_ending: LineEnding
    echo: bool

    static fn new(uart: Uart) -> Serial:
        return Serial(
            uart: uart,
            line_ending: LineEnding.LF,
            echo: false
        )

    static fn with_config(uart: Uart, config: UartConfig) -> Serial:
        uart.init(config)
        return Serial.new(uart)

    me set_line_ending(ending: LineEnding):
        self.line_ending = ending

    me set_echo(echo: bool):
        self.echo = echo

    # Write a single character
    me write_char(c: char):
        self.uart.write_byte(c as u8)

    # Write a string
    me write(s: text):
        self.uart.write_str(s)

    # Write a string with line ending
    me writeln(s: text):
        self.write(s)
        match self.line_ending:
            LineEnding.LF:
                self.write_char('\n')
            LineEnding.CRLF:
                self.write_char('\r')
                self.write_char('\n')
            LineEnding.CR:
                self.write_char('\r')

    # Read a single character (blocking)
    fn read_char() -> char:
        val byte = self.uart.read_byte()
        if self.echo:
            self.uart.write_byte(byte)
        return byte as char

    # Try to read a character (non-blocking)
    fn try_read_char() -> Option<char>:
        match self.uart.try_read_byte():
            Option.Some(byte):
                if self.echo:
                    self.uart.write_byte(byte)
                return Option.some(byte as char)
            Option.None:
                return Option.none()

    # Read a line (blocking, until newline)
    fn read_line() -> text:
        var buffer: List<char> = []
        while true:
            val c = self.read_char()
            if c == '\n' or c == '\r':
                if self.echo:
                    self.write_char('\n')
                break
            if c == '\x7F' or c == '\x08':  # Backspace
                if buffer.len() > 0:
                    buffer.pop()
                    if self.echo:
                        self.write("\x08 \x08")  # Erase character
                continue
            buffer.push(c)
        return buffer.to_string()

    # Read up to n characters
    fn read_n(n: usize) -> text:
        var buffer: List<char> = []
        for i in 0..n:
            buffer.push(self.read_char())
        return buffer.to_string()

    # Check if data available
    fn is_available() -> bool:
        return self.uart.is_readable()

    # Flush output
    me flush():
        self.uart.flush()

# Print functions using a global serial port
static var global_serial: Option<Serial> = Option.none()

fn set_global_serial(serial: Serial):
    global_serial = Option.some(serial)

fn print(s: text):
    match global_serial:
        Option.Some(serial):
            serial.write(s)
        Option.None:
            pass

fn println(s: text):
    match global_serial:
        Option.Some(serial):
            serial.writeln(s)
        Option.None:
            pass

export LineEnding, Serial
export set_global_serial, print, println
