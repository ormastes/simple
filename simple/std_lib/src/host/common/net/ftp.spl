# FTP Client - Async FTP client

use units.net.*
use units.url.*
use units.file.*
use units.size.*
use units.time.*
use io.fs.IoError

# FTP transfer mode
enum TransferMode:
    Binary
    Ascii

impl TransferMode:
    fn to_cmd() -> str:
        match self:
            case Binary: return "TYPE I"
            case Ascii: return "TYPE A"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_binary() -> bool:
        """Check if transfer mode is binary."""
        match self:
            case Binary: true
            case _: false

    fn is_ascii() -> bool:
        """Check if transfer mode is ASCII/text."""
        match self:
            case Ascii: true
            case _: false

    fn is_text() -> bool:
        """Alias for is_ascii() - check if text mode."""
        return self.is_ascii()

    fn preserves_bytes() -> bool:
        """Check if mode preserves exact bytes (binary does)."""
        match self:
            case Binary: true
            case Ascii: false

    fn converts_line_endings() -> bool:
        """Check if mode converts line endings (ASCII does)."""
        match self:
            case Ascii: true
            case Binary: false

    fn name() -> str:
        """Get mode name."""
        match self:
            case Binary: "binary"
            case Ascii: "ascii"

    fn to_string() -> String:
        """Convert transfer mode to string.

        Returns:
            Mode name

        Example:
            TransferMode::Binary.to_string()  # → "binary"
        """
        match self:
            case Binary: "binary"
            case Ascii: "ascii"

    fn description() -> String:
        """Get transfer mode description.

        Returns:
            Human-readable description

        Example:
            TransferMode::Ascii.description()
            # → "ASCII mode (converts line endings)"
        """
        match self:
            case Binary: "Binary mode (preserves exact bytes)"
            case Ascii: "ASCII mode (converts line endings)"

    fn summary() -> str:
        """Get summary of transfer mode."""
        val name = self.name()
        val preserves = if self.preserves_bytes(): "preserves bytes" else: "converts line endings"
        return "TransferMode: {name} ({preserves})"

# FTP file type
enum FtpFileType:
    File
    Directory
    Link
    Other

impl FtpFileType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_file() -> bool:
        """Check if this is a regular file."""
        match self:
            case File: true
            case _: false

    fn is_directory() -> bool:
        """Check if this is a directory."""
        match self:
            case Directory: true
            case _: false

    fn is_link() -> bool:
        """Check if this is a symbolic link."""
        match self:
            case Link: true
            case _: false

    fn is_other() -> bool:
        """Check if this is an unknown/other type."""
        match self:
            case Other: true
            case _: false

    fn can_contain_files() -> bool:
        """Check if type can contain other files."""
        match self:
            case Directory: true
            case _: false

    fn to_string() -> String:
        """Convert file type to string.

        Returns:
            Type name

        Example:
            FtpFileType::Directory.to_string()  # → "directory"
        """
        match self:
            case File: "file"
            case Directory: "directory"
            case Link: "link"
            case Other: "other"

    fn description() -> String:
        """Get file type description.

        Returns:
            Human-readable description

        Example:
            FtpFileType::Directory.description()
            # → "Directory (can contain files)"
        """
        match self:
            case File: "Regular file"
            case Directory: "Directory (can contain files)"
            case Link: "Symbolic link"
            case Other: "Unknown file type"

    fn summary() -> str:
        """Get summary of file type."""
        match self:
            case File: "FtpFileType: file"
            case Directory: "FtpFileType: directory"
            case Link: "FtpFileType: link"
            case Other: "FtpFileType: other"

# FTP error type
enum FtpError:
    ConnectionFailed(IoError)
    LoginFailed
    NotFound
    PermissionDenied
    AlreadyExists
    NotADirectory
    NotAFile
    InvalidResponse(str)
    TransferFailed
    Timeout
    Disconnected
    Other(str)

impl FtpError:
    fn message() -> str:
        match self:
            case ConnectionFailed(e): return "connection failed: {e.message()}"
            case LoginFailed: return "login failed"
            case NotFound: return "file or directory not found"
            case PermissionDenied: return "permission denied"
            case AlreadyExists: return "file or directory already exists"
            case NotADirectory: return "not a directory"
            case NotAFile: return "not a file"
            case InvalidResponse(msg): return "invalid response: {msg}"
            case TransferFailed: return "transfer failed"
            case Timeout: return "operation timed out"
            case Disconnected: return "disconnected from server"
            case Other(msg): return msg

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_connection_failed() -> bool:
        """Check if error is connection failure."""
        match self:
            case ConnectionFailed(_): true
            case _: false

    fn is_login_failed() -> bool:
        """Check if error is login failure."""
        match self:
            case LoginFailed: true
            case _: false

    fn is_not_found() -> bool:
        """Check if error is file/directory not found."""
        match self:
            case NotFound: true
            case _: false

    fn is_permission_denied() -> bool:
        """Check if error is permission denied."""
        match self:
            case PermissionDenied: true
            case _: false

    fn is_already_exists() -> bool:
        """Check if error is file/directory already exists."""
        match self:
            case AlreadyExists: true
            case _: false

    fn is_not_a_directory() -> bool:
        """Check if error is not a directory."""
        match self:
            case NotADirectory: true
            case _: false

    fn is_not_a_file() -> bool:
        """Check if error is not a file."""
        match self:
            case NotAFile: true
            case _: false

    fn is_invalid_response() -> bool:
        """Check if error is invalid server response."""
        match self:
            case InvalidResponse(_): true
            case _: false

    fn is_transfer_failed() -> bool:
        """Check if error is transfer failure."""
        match self:
            case TransferFailed: true
            case _: false

    fn is_timeout() -> bool:
        """Check if error is timeout."""
        match self:
            case Timeout: true
            case _: false

    fn is_disconnected() -> bool:
        """Check if error is disconnection."""
        match self:
            case Disconnected: true
            case _: false

    fn is_recoverable() -> bool:
        """Check if error might be recoverable with retry."""
        match self:
            case ConnectionFailed(_): true
            case Timeout: true
            case Disconnected: true
            case TransferFailed: true
            case _: false

    fn is_authentication_error() -> bool:
        """Check if error is authentication related."""
        match self:
            case LoginFailed: true
            case PermissionDenied: true
            case _: false

    fn is_file_system_error() -> bool:
        """Check if error is file system related."""
        match self:
            case NotFound: true
            case AlreadyExists: true
            case NotADirectory: true
            case NotAFile: true
            case _: false

    fn to_string() -> String:
        """Convert FTP error to string.

        Returns:
            Error type name

        Example:
            FtpError::Timeout.to_string()  # → "timeout"
        """
        match self:
            case ConnectionFailed(_): "connection-failed"
            case LoginFailed: "login-failed"
            case NotFound: "not-found"
            case PermissionDenied: "permission-denied"
            case AlreadyExists: "already-exists"
            case NotADirectory: "not-a-directory"
            case NotAFile: "not-a-file"
            case InvalidResponse(_): "invalid-response"
            case TransferFailed: "transfer-failed"
            case Timeout: "timeout"
            case Disconnected: "disconnected"
            case Other(_): "other"

    fn description() -> String:
        """Get FTP error description.

        Returns:
            Human-readable description

        Example:
            FtpError::LoginFailed.description()
            # → "FTP login authentication failed"
        """
        match self:
            case ConnectionFailed(_): "Failed to connect to FTP server"
            case LoginFailed: "FTP login authentication failed"
            case NotFound: "File or directory not found on FTP server"
            case PermissionDenied: "FTP operation permission denied"
            case AlreadyExists: "File or directory already exists on FTP server"
            case NotADirectory: "Path is not a directory on FTP server"
            case NotAFile: "Path is not a file on FTP server"
            case InvalidResponse(_): "Invalid response from FTP server"
            case TransferFailed: "FTP file transfer operation failed"
            case Timeout: "FTP operation timed out"
            case Disconnected: "Disconnected from FTP server"
            case Other(_): "Other FTP error occurred"

    fn summary() -> str:
        """Get summary of error with type."""
        val msg = self.message()
        match self:
            case ConnectionFailed(_): return "FtpError: connection ({msg})"
            case LoginFailed: return "FtpError: authentication ({msg})"
            case PermissionDenied: return "FtpError: authentication ({msg})"
            case Timeout: return "FtpError: recoverable ({msg})"
            case _: return "FtpError: {msg}"

# FTP directory entry
pub struct FtpEntry:
    name: FileName
    file_type: FtpFileType
    size: Option[ByteCount]
    modified: Option[Timestamp]
    permissions: Option[str]

impl FtpEntry:
    pub fn name(self) -> FileName:
        return self.name

    pub fn file_type(self) -> FtpFileType:
        return self.file_type

    pub fn size(self) -> Option[ByteCount]:
        return self.size

    pub fn modified(self) -> Option[Timestamp]:
        return self.modified

    pub fn permissions(self) -> Option[str]:
        return self.permissions

    pub fn is_file(self) -> bool:
        return self.file_type == FtpFileType::File

    pub fn is_directory(self) -> bool:
        return self.file_type == FtpFileType::Directory

# FTP Client
pub struct FtpClient:
    handle: i64
    host: Host
    port: Port
    connected: bool
    transfer_mode: TransferMode
    passive: bool

impl FtpClient:
    # Connect to FTP server from URL
    pub async fn connect(url: FtpUrl) -> Result[FtpClient, FtpError]:
        val host = url.host()
        val port = url.port()

        val username = url.username().unwrap_or("anonymous")
        val password = url.password().unwrap_or("anonymous@")

        return FtpClient::connect_with_creds(host, port, username, password)

    # Connect with explicit credentials
    pub async fn connect_with_creds(
        host: Host,
        port: Port,
        username: str,
        password: str
    ) -> Result[FtpClient, FtpError]:
        val handle = native_ftp_connect(host, port)?
        val client = FtpClient {
            handle: handle,
            host: host,
            port: port,
            connected: true,
            transfer_mode: TransferMode::Binary,
            passive: true
        }

        # Login
        native_ftp_login(handle, username, password)?

        return Ok(client)

    # Connect to host on default port
    pub async fn connect_to(host: Host) -> Result[FtpClient, FtpError]:
        return FtpClient::connect_with_creds(host, 21_port, "anonymous", "anonymous@")

    # ===============================
    # Navigation
    # ===============================

    # Print working directory
    pub async fn pwd(self) -> Result[UrlPath, FtpError]:
        return native_ftp_pwd(self.handle)

    # Change directory
    pub async fn cd(self, path: UrlPath) -> Result[(), FtpError]:
        return native_ftp_cwd(self.handle, path)

    # Change to parent directory
    pub async fn cdup(self) -> Result[(), FtpError]:
        return native_ftp_cdup(self.handle)

    # List directory contents
    pub async fn list(self) -> Result[Array[FtpEntry], FtpError]:
        return native_ftp_list(self.handle)

    # List directory at path
    pub async fn list_path(self, path: UrlPath) -> Result[Array[FtpEntry], FtpError]:
        return native_ftp_list_path(self.handle, path)

    # Get file/directory info
    pub async fn stat(self, path: UrlPath) -> Result[FtpEntry, FtpError]:
        return native_ftp_stat(self.handle, path)

    # ===============================
    # Transfer Operations
    # ===============================

    # Download file to local path
    pub async fn download(self, remote: UrlPath, local: FilePath) -> Result[ByteCount, FtpError]:
        return native_ftp_download(self.handle, remote, local, self.transfer_mode)

    # Upload local file to remote path
    pub async fn upload(self, local: FilePath, remote: UrlPath) -> Result[ByteCount, FtpError]:
        return native_ftp_upload(self.handle, local, remote, self.transfer_mode)

    # Download file to bytes
    pub async fn download_bytes(self, remote: UrlPath) -> Result[Bytes, FtpError]:
        return native_ftp_download_bytes(self.handle, remote, self.transfer_mode)

    # Upload bytes to remote path
    pub async fn upload_bytes(self, data: &Bytes, remote: UrlPath) -> Result[ByteCount, FtpError]:
        return native_ftp_upload_bytes(self.handle, data, remote, self.transfer_mode)

    # Resume download from offset
    pub async fn resume_download(self, remote: UrlPath, local: FilePath, offset: ByteCount) -> Result[ByteCount, FtpError]:
        return native_ftp_resume_download(self.handle, remote, local, offset, self.transfer_mode)

    # ===============================
    # File Operations
    # ===============================

    # Delete file
    pub async fn delete(self, path: UrlPath) -> Result[(), FtpError]:
        return native_ftp_delete(self.handle, path)

    # Create directory
    pub async fn mkdir(self, path: UrlPath) -> Result[(), FtpError]:
        return native_ftp_mkdir(self.handle, path)

    # Remove directory
    pub async fn rmdir(self, path: UrlPath) -> Result[(), FtpError]:
        return native_ftp_rmdir(self.handle, path)

    # Rename file or directory
    pub async fn rename(self, from: UrlPath, to: UrlPath) -> Result[(), FtpError]:
        return native_ftp_rename(self.handle, from, to)

    # Get file size
    pub async fn size(self, path: UrlPath) -> Result[ByteCount, FtpError]:
        return native_ftp_size(self.handle, path)

    # Get modification time
    pub async fn modified(self, path: UrlPath) -> Result[Timestamp, FtpError]:
        return native_ftp_mdtm(self.handle, path)

    # ===============================
    # Settings
    # ===============================

    # Set transfer mode
    pub fn set_transfer_mode(self, mode: TransferMode) -> FtpClient:
        self.transfer_mode = mode
        return self

    # Set passive mode
    pub fn set_passive(self, passive: bool) -> FtpClient:
        self.passive = passive
        return self

    # ===============================
    # Connection Management
    # ===============================

    # Send NOOP to keep connection alive
    pub async fn noop(self) -> Result[(), FtpError]:
        return native_ftp_noop(self.handle)

    # Check if connected
    pub fn is_connected(self) -> bool:
        return self.connected

    # Get server features
    pub async fn features(self) -> Result[Array[str], FtpError]:
        return native_ftp_feat(self.handle)

    # Send raw FTP command
    pub async fn raw_command(self, cmd: str) -> Result[str, FtpError]:
        return native_ftp_raw(self.handle, cmd)

    # Disconnect from server
    pub async fn quit(self) -> Result[(), FtpError]:
        if self.connected:
            native_ftp_quit(self.handle)?
            self.connected = false
        return Ok(())

# Native function declarations
extern fn native_ftp_connect(host: Host, port: Port) -> Result[i64, FtpError]
extern fn native_ftp_login(handle: i64, username: str, password: str) -> Result[(), FtpError]
extern fn native_ftp_pwd(handle: i64) -> Result[UrlPath, FtpError]
extern fn native_ftp_cwd(handle: i64, path: UrlPath) -> Result[(), FtpError]
extern fn native_ftp_cdup(handle: i64) -> Result[(), FtpError]
extern fn native_ftp_list(handle: i64) -> Result[Array[FtpEntry], FtpError]
extern fn native_ftp_list_path(handle: i64, path: UrlPath) -> Result[Array[FtpEntry], FtpError]
extern fn native_ftp_stat(handle: i64, path: UrlPath) -> Result[FtpEntry, FtpError]
extern fn native_ftp_download(handle: i64, remote: UrlPath, local: FilePath, mode: TransferMode) -> Result[ByteCount, FtpError]
extern fn native_ftp_upload(handle: i64, local: FilePath, remote: UrlPath, mode: TransferMode) -> Result[ByteCount, FtpError]
extern fn native_ftp_download_bytes(handle: i64, remote: UrlPath, mode: TransferMode) -> Result[Bytes, FtpError]
extern fn native_ftp_upload_bytes(handle: i64, data: &Bytes, remote: UrlPath, mode: TransferMode) -> Result[ByteCount, FtpError]
extern fn native_ftp_resume_download(handle: i64, remote: UrlPath, local: FilePath, offset: ByteCount, mode: TransferMode) -> Result[ByteCount, FtpError]
extern fn native_ftp_delete(handle: i64, path: UrlPath) -> Result[(), FtpError]
extern fn native_ftp_mkdir(handle: i64, path: UrlPath) -> Result[(), FtpError]
extern fn native_ftp_rmdir(handle: i64, path: UrlPath) -> Result[(), FtpError]
extern fn native_ftp_rename(handle: i64, from: UrlPath, to: UrlPath) -> Result[(), FtpError]
extern fn native_ftp_size(handle: i64, path: UrlPath) -> Result[ByteCount, FtpError]
extern fn native_ftp_mdtm(handle: i64, path: UrlPath) -> Result[Timestamp, FtpError]
extern fn native_ftp_noop(handle: i64) -> Result[(), FtpError]
extern fn native_ftp_feat(handle: i64) -> Result[Array[str], FtpError]
extern fn native_ftp_raw(handle: i64, cmd: str) -> Result[str, FtpError]
extern fn native_ftp_quit(handle: i64) -> Result[(), FtpError]
