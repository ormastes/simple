# TCP Networking - Common Implementation
# Unified async TCP with monoio runtime
# Shared across all host variants
#
# Features:
# - Monoio-based async I/O (thread-per-core, io_uring)
# - String convenience API for quick scripts
# - Semantic type API for type safety
# - Context manager support (with...as syntax)
#
# Quick Start:
#   use host.common.net as net
#
#   # String convenience API
#   async with await net.TcpStream::connect_str("127.0.0.1:8080") as stream:
#       await stream.write_all(data)?
#
#   # Semantic type API
#   let addr = SocketAddr::new(IpAddr::v4(127, 0, 0, 1), Port(8080))
#   async with await net.TcpStream::connect(addr) as stream:
#       await stream.write_all(data)?

use units.net.*
use units.size.*
use units.time.*
use host.common.io.error.IoError
use host.common.net.types.Shutdown

# TCP Listener - accepts incoming connections
pub struct TcpListener:
    handle: i64
    local_addr: SocketAddr

impl TcpListener:
    # Bind to address and start listening (semantic types)
    pub async fn bind(addr: SocketAddr) -> Result[TcpListener, IoError]:
        let handle = native_tcp_bind(addr)?
        return Ok(TcpListener {
            handle: handle,
            local_addr: addr
        })

    # Bind using string address (convenience)
    # Example: TcpListener::bind_str("127.0.0.1:8080")
    pub async fn bind_str(addr: String) -> Result[TcpListener, IoError]:
        # Parse string to SocketAddr
        let socket_addr = parse_socket_addr(addr)?
        return TcpListener::bind(socket_addr)

    # Bind to IP and port
    pub async fn bind_to(ip: IpAddr, port: Port) -> Result[TcpListener, IoError]:
        return TcpListener::bind(SocketAddr::new(ip, port))

    # Accept incoming connection
    pub async fn accept(self) -> Result[(TcpStream, SocketAddr), IoError]:
        let (stream_handle, peer_addr) = native_tcp_accept(self.handle)?
        let stream = TcpStream {
            handle: stream_handle,
            peer_addr: peer_addr,
            local_addr: self.local_addr
        }
        return Ok((stream, peer_addr))

    # Get local address
    pub fn local_addr(self) -> SocketAddr:
        return self.local_addr

    # Set connection backlog
    pub fn set_backlog(self, backlog: u32) -> Result[(), IoError]:
        return native_tcp_set_backlog(self.handle, backlog)

    # Close listener
    pub async fn close(self) -> Result[(), IoError]:
        return native_tcp_close(self.handle)

# TCP Stream - bidirectional connection
pub struct TcpStream:
    handle: i64
    peer_addr: SocketAddr
    local_addr: SocketAddr

impl TcpStream:
    # Connect to remote address (semantic types)
    pub async fn connect(addr: SocketAddr) -> Result[TcpStream, IoError]:
        let (handle, local) = native_tcp_connect(addr)?
        return Ok(TcpStream {
            handle: handle,
            peer_addr: addr,
            local_addr: local
        })

    # Connect using string address (convenience)
    # Example: TcpStream::connect_str("127.0.0.1:8080")
    pub async fn connect_str(addr: String) -> Result[TcpStream, IoError]:
        let socket_addr = parse_socket_addr(addr)?
        return TcpStream::connect(socket_addr)

    # Connect to IP and port
    pub async fn connect_to(ip: IpAddr, port: Port) -> Result[TcpStream, IoError]:
        return TcpStream::connect(SocketAddr::new(ip, port))

    # Connect with timeout
    pub async fn connect_timeout(addr: SocketAddr, timeout: Duration) -> Result[TcpStream, IoError]:
        let (handle, local) = native_tcp_connect_timeout(addr, timeout)?
        return Ok(TcpStream {
            handle: handle,
            peer_addr: addr,
            local_addr: local
        })

    # Read data
    pub async fn read(self, buf: &mut Bytes) -> Result[ByteCount, IoError]:
        return native_tcp_read(self.handle, buf)

    # Read exact number of bytes
    pub async fn read_exact(self, buf: &mut Bytes) -> Result[(), IoError]:
        let mut read_total: u64 = 0
        let target = buf.len()
        while read_total < target:
            let slice = buf.slice_mut(read_total, target)
            let n = await self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write data
    pub async fn write(self, data: &Bytes) -> Result[ByteCount, IoError]:
        return native_tcp_write(self.handle, data)

    # Write all data
    pub async fn write_all(self, data: &Bytes) -> Result[(), IoError]:
        let mut written: u64 = 0
        while written < data.len():
            let n = await self.write(&data.slice(written, data.len()))?
            written = written + (n as u64)
        return Ok(())

    # Flush output buffer
    pub async fn flush(self) -> Result[(), IoError]:
        return native_tcp_flush(self.handle)

    # Shutdown connection
    pub async fn shutdown(self, how: Shutdown) -> Result[(), IoError]:
        return native_tcp_shutdown(self.handle, how)

    # Close connection
    pub async fn close(self) -> Result[(), IoError]:
        return native_tcp_close(self.handle)

    # Get peer address
    pub fn peer_addr(self) -> SocketAddr:
        return self.peer_addr

    # Get local address
    pub fn local_addr(self) -> SocketAddr:
        return self.local_addr

    # Set options
    pub fn set_nodelay(self, nodelay: bool) -> Result[(), IoError]:
        return native_tcp_set_nodelay(self.handle, nodelay)

    pub fn set_keepalive(self, keepalive: Option[Duration]) -> Result[(), IoError]:
        return native_tcp_set_keepalive(self.handle, keepalive)

    pub fn set_read_timeout(self, timeout: Option[Duration]) -> Result[(), IoError]:
        return native_tcp_set_read_timeout(self.handle, timeout)

    pub fn set_write_timeout(self, timeout: Option[Duration]) -> Result[(), IoError]:
        return native_tcp_set_write_timeout(self.handle, timeout)

    # Get options
    pub fn nodelay(self) -> Result[bool, IoError]:
        return native_tcp_get_nodelay(self.handle)

    # Peek data without consuming
    pub async fn peek(self, buf: &mut Bytes) -> Result[ByteCount, IoError]:
        return native_tcp_peek(self.handle, buf)

# Native function declarations
extern fn native_tcp_bind(addr: SocketAddr) -> Result[i64, IoError]
extern fn native_tcp_accept(handle: i64) -> Result[(i64, SocketAddr), IoError]
extern fn native_tcp_connect(addr: SocketAddr) -> Result[(i64, SocketAddr), IoError]
extern fn native_tcp_connect_timeout(addr: SocketAddr, timeout: Duration) -> Result[(i64, SocketAddr), IoError]
extern fn native_tcp_read(handle: i64, buf: &mut Bytes) -> Result[ByteCount, IoError]
extern fn native_tcp_write(handle: i64, data: &Bytes) -> Result[ByteCount, IoError]
extern fn native_tcp_flush(handle: i64) -> Result[(), IoError]
extern fn native_tcp_shutdown(handle: i64, how: Shutdown) -> Result[(), IoError]
extern fn native_tcp_close(handle: i64) -> Result[(), IoError]
extern fn native_tcp_set_backlog(handle: i64, backlog: u32) -> Result[(), IoError]
extern fn native_tcp_set_nodelay(handle: i64, nodelay: bool) -> Result[(), IoError]
extern fn native_tcp_set_keepalive(handle: i64, keepalive: Option[Duration]) -> Result[(), IoError]
extern fn native_tcp_set_read_timeout(handle: i64, timeout: Option[Duration]) -> Result[(), IoError]
extern fn native_tcp_set_write_timeout(handle: i64, timeout: Option[Duration]) -> Result[(), IoError]
extern fn native_tcp_get_nodelay(handle: i64) -> Result[bool, IoError]
extern fn native_tcp_peek(handle: i64, buf: &mut Bytes) -> Result[ByteCount, IoError]

# ============================================
# Trait Implementations
# ============================================

use core.traits.*

impl Read for TcpStream:
    fn read(self, buf: &mut [u8]) -> Result[usize, IoError]:
        let mut bytes = Bytes::from_slice(buf)
        match native_tcp_read(self.handle, &mut bytes):
            case Ok(count):
                buf.copy_from_slice(&bytes.as_slice())
                Ok(count as usize)
            case Err(e): Err(e)

impl Write for TcpStream:
    fn write(self, buf: &[u8]) -> Result[usize, IoError]:
        let bytes = Bytes::from_slice(buf)
        match native_tcp_write(self.handle, &bytes):
            case Ok(count): Ok(count as usize)
            case Err(e): Err(e)

    fn flush(self) -> Result[(), IoError]:
        native_tcp_flush(self.handle)

impl Drop for TcpStream:
    fn drop(self):
        native_tcp_close(self.handle)

impl Drop for TcpListener:
    fn drop(self):
        native_tcp_close(self.handle)

# ===============================
# Context Manager Support (with...as syntax)
# ===============================

# Async context manager trait
pub trait AsyncContextManager[T]:
    async fn __aenter__(self) -> T
    async fn __aexit__(self, exc: Option[Exception]) -> bool

# Context manager for TcpStream
# Usage: async with await TcpStream::connect_str("127.0.0.1:8080") as stream:
impl AsyncContextManager[TcpStream] for TcpStream:
    async fn __aenter__(self) -> TcpStream:
        return self

    async fn __aexit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: close connection
        let _ = await self.close()
        return false  # Don't suppress exceptions

# Context manager for TcpListener
# Usage: async with await TcpListener::bind_str("127.0.0.1:8080") as listener:
impl AsyncContextManager[TcpListener] for TcpListener:
    async fn __aenter__(self) -> TcpListener:
        return self

    async fn __aexit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: close listener
        let _ = await self.close()
        return false  # Don't suppress exceptions

# Exception type for context managers
pub struct Exception:
    message: String

impl Exception:
    pub fn new(message: String) -> Exception:
        return Exception { message: message }

# ===============================
# Helper Functions
# ===============================

# Parse string address to SocketAddr
# Format: "IP:PORT" e.g., "127.0.0.1:8080"
fn parse_socket_addr(addr: String) -> Result[SocketAddr, IoError]:
    # TODO: [stdlib][P1] Implement actual parsing
    # For now, return error
    return Err(IoError::InvalidArgument)

