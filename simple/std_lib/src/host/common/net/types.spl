# Common Network Types
# Shared across all host variants (async_nogc_mut, async_gc_immut, etc.)

use core.traits.*

# Shutdown modes for TCP connections
pub enum Shutdown:
    Read
    Write
    Both

impl Display for Shutdown:
    fn fmt(self) -> str:
        match self:
            case Read: "read"
            case Write: "write"
            case Both: "both"

# HTTP Methods
pub enum HttpMethod:
    Get
    Post
    Put
    Delete
    Patch
    Head
    Options
    Connect
    Trace

impl HttpMethod:
    pub fn as_str(self) -> &str:
        match self:
            case Get: "GET"
            case Post: "POST"
            case Put: "PUT"
            case Delete: "DELETE"
            case Patch: "PATCH"
            case Head: "HEAD"
            case Options: "OPTIONS"
            case Connect: "CONNECT"
            case Trace: "TRACE"

impl Display for HttpMethod:
    fn fmt(self) -> str:
        match self:
            case Get: "GET"
            case Post: "POST"
            case Put: "PUT"
            case Delete: "DELETE"
            case Patch: "PATCH"
            case Head: "HEAD"
            case Options: "OPTIONS"
            case Connect: "CONNECT"
            case Trace: "TRACE"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_get(self) -> bool:
        """Check if method is GET.

        Returns:
            True if GET
        """
        match self:
            case Get: true
            case _: false

    pub fn is_post(self) -> bool:
        """Check if method is POST.

        Returns:
            True if POST
        """
        match self:
            case Post: true
            case _: false

    pub fn is_put(self) -> bool:
        """Check if method is PUT.

        Returns:
            True if PUT
        """
        match self:
            case Put: true
            case _: false

    pub fn is_delete(self) -> bool:
        """Check if method is DELETE.

        Returns:
            True if DELETE
        """
        match self:
            case Delete: true
            case _: false

    pub fn is_patch(self) -> bool:
        """Check if method is PATCH.

        Returns:
            True if PATCH
        """
        match self:
            case Patch: true
            case _: false

    pub fn is_head(self) -> bool:
        """Check if method is HEAD.

        Returns:
            True if HEAD
        """
        match self:
            case Head: true
            case _: false

    pub fn is_safe(self) -> bool:
        """Check if method is safe (GET, HEAD, OPTIONS, TRACE).

        Returns:
            True if safe method
        """
        match self:
            case Get: true
            case Head: true
            case Options: true
            case Trace: true
            case _: false

    pub fn is_idempotent(self) -> bool:
        """Check if method is idempotent (GET, HEAD, PUT, DELETE, OPTIONS, TRACE).

        Returns:
            True if idempotent method
        """
        match self:
            case Get: true
            case Head: true
            case Put: true
            case Delete: true
            case Options: true
            case Trace: true
            case _: false

    pub fn has_request_body(self) -> bool:
        """Check if method typically has a request body.

        Returns:
            True if POST, PUT, or PATCH
        """
        match self:
            case Post: true
            case Put: true
            case Patch: true
            case _: false

    pub fn summary(self) -> str:
        """Get summary of HTTP method.

        Returns:
            Human-readable summary

        Example:
            HttpMethod::Get.summary()
            # → "HttpMethod: GET (safe, idempotent)"
        """
        let name = self.as_str()
        let props = []
        if self.is_safe():
            props.push("safe")
        if self.is_idempotent():
            props.push("idempotent")
        if self.has_request_body():
            props.push("has body")
        let props_str = if props.len() > 0: " ({props.join(\", \")})" else: ""
        return "HttpMethod: {name}{props_str}"

# HTTP status code
pub unit StatusCode: u16 as status

impl StatusCode:
    pub fn from_u16(code: u16) -> StatusCode:
        return code_status

    pub fn as_u16(self) -> u16:
        return self as u16

    pub fn is_informational(self) -> bool:
        let code = self as u16
        return code >= 100 and code < 200

    pub fn is_success(self) -> bool:
        let code = self as u16
        return code >= 200 and code < 300

    pub fn is_redirect(self) -> bool:
        let code = self as u16
        return code >= 300 and code < 400

    pub fn is_client_error(self) -> bool:
        let code = self as u16
        return code >= 400 and code < 500

    pub fn is_server_error(self) -> bool:
        let code = self as u16
        return code >= 500 and code < 600

    pub fn reason_phrase(self) -> str:
        match self as u16:
            case 200: return "OK"
            case 201: return "Created"
            case 204: return "No Content"
            case 301: return "Moved Permanently"
            case 302: return "Found"
            case 304: return "Not Modified"
            case 400: return "Bad Request"
            case 401: return "Unauthorized"
            case 403: return "Forbidden"
            case 404: return "Not Found"
            case 405: return "Method Not Allowed"
            case 408: return "Request Timeout"
            case 429: return "Too Many Requests"
            case 500: return "Internal Server Error"
            case 502: return "Bad Gateway"
            case 503: return "Service Unavailable"
            case 504: return "Gateway Timeout"
            case _: return "Unknown"

    # Common status codes
    pub fn ok() -> StatusCode:
        return 200_status

    pub fn created() -> StatusCode:
        return 201_status

    pub fn no_content() -> StatusCode:
        return 204_status

    pub fn bad_request() -> StatusCode:
        return 400_status

    pub fn unauthorized() -> StatusCode:
        return 401_status

    pub fn forbidden() -> StatusCode:
        return 403_status

    pub fn not_found() -> StatusCode:
        return 404_status

    pub fn internal_server_error() -> StatusCode:
        return 500_status

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_error(self) -> bool:
        """Check if status is an error (4xx or 5xx).

        Returns:
            True if client or server error
        """
        return self.is_client_error() or self.is_server_error()

    pub fn is_ok(self) -> bool:
        """Check if status is 200 OK.

        Returns:
            True if 200
        """
        return (self as u16) == 200

    pub fn is_created(self) -> bool:
        """Check if status is 201 Created.

        Returns:
            True if 201
        """
        return (self as u16) == 201

    pub fn is_not_found(self) -> bool:
        """Check if status is 404 Not Found.

        Returns:
            True if 404
        """
        return (self as u16) == 404

    pub fn is_unauthorized(self) -> bool:
        """Check if status is 401 Unauthorized.

        Returns:
            True if 401
        """
        return (self as u16) == 401

    pub fn is_forbidden(self) -> bool:
        """Check if status is 403 Forbidden.

        Returns:
            True if 403
        """
        return (self as u16) == 403

    pub fn allows_body(self) -> bool:
        """Check if status code typically has a response body.

        Returns:
            True if status usually includes body (not 1xx, 204, 304)
        """
        let code = self as u16
        return not (self.is_informational() or code == 204 or code == 304)

    pub fn requires_location_header(self) -> bool:
        """Check if status requires Location header.

        Returns:
            True for 201, 301, 302, 303, 307, 308
        """
        let code = self as u16
        match code:
            case 201: true
            case 301: true
            case 302: true
            case 303: true
            case 307: true
            case 308: true
            case _: false

    pub fn is_cacheable(self) -> bool:
        """Check if response is cacheable by default.

        Returns:
            True for 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501
        """
        let code = self as u16
        match code:
            case 200: true
            case 203: true
            case 204: true
            case 206: true
            case 300: true
            case 301: true
            case 404: true
            case 405: true
            case 410: true
            case 414: true
            case 501: true
            case _: false

    pub fn summary(self) -> str:
        """Get summary of status code.

        Returns:
            Human-readable summary

        Example:
            StatusCode::ok().summary()
            # → "StatusCode: 200 OK (success, cacheable)"
        """
        let code = self as u16
        let phrase = self.reason_phrase()
        let category = if self.is_informational(): "informational"
                       else if self.is_success(): "success"
                       else if self.is_redirect(): "redirect"
                       else if self.is_client_error(): "client error"
                       else if self.is_server_error(): "server error"
                       else: "unknown"
        let props = []
        if self.is_cacheable():
            props.push("cacheable")
        if not self.allows_body():
            props.push("no body")
        let props_str = if props.len() > 0: ", {props.join(\", \")}" else: ""
        return "StatusCode: {code} {phrase} ({category}{props_str})"

impl Display for StatusCode:
    fn fmt(self) -> str:
        "{self as u16} {self.reason_phrase()}"

# HTTP header name (case-insensitive)
pub unit HeaderName: str as header

impl HeaderName:
    pub fn from_str(s: str) -> HeaderName:
        return s.to_lower()_header

    # Common headers
    pub fn content_type() -> HeaderName:
        return "content-type"_header

    pub fn content_length() -> HeaderName:
        return "content-length"_header

    pub fn authorization() -> HeaderName:
        return "authorization"_header

    pub fn user_agent() -> HeaderName:
        return "user-agent"_header

    pub fn accept() -> HeaderName:
        return "accept"_header

    pub fn host() -> HeaderName:
        return "host"_header

    pub fn connection() -> HeaderName:
        return "connection"_header

    pub fn cache_control() -> HeaderName:
        return "cache-control"_header

    pub fn cookie() -> HeaderName:
        return "cookie"_header

    pub fn set_cookie() -> HeaderName:
        return "set-cookie"_header

impl Display for HeaderName:
    fn fmt(self) -> str:
        self as str

# HTTP header value
pub unit HeaderValue: str as hval

impl HeaderValue:
    pub fn from_str(s: str) -> HeaderValue:
        return s_hval

    # Common content types
    pub fn json() -> HeaderValue:
        return "application/json"_hval

    pub fn form() -> HeaderValue:
        return "application/x-www-form-urlencoded"_hval

    pub fn multipart() -> HeaderValue:
        return "multipart/form-data"_hval

    pub fn text() -> HeaderValue:
        return "text/plain"_hval

    pub fn html() -> HeaderValue:
        return "text/html"_hval

    pub fn xml() -> HeaderValue:
        return "application/xml"_hval

impl Display for HeaderValue:
    fn fmt(self) -> str:
        self as str

# HTTP error type
pub enum HttpError:
    ConnectionFailed(IoError)
    Timeout
    InvalidUrl
    TooManyRedirects
    InvalidResponse
    InvalidHeader
    BodyTooLarge
    Cancelled
    TlsError(str)
    Other(str)

use host.common.io.error.IoError

impl HttpError:
    pub fn message(self) -> str:
        match self:
            case ConnectionFailed(e): return "connection failed: {e.message()}"
            case Timeout: return "request timed out"
            case InvalidUrl: return "invalid URL"
            case TooManyRedirects: return "too many redirects"
            case InvalidResponse: return "invalid response"
            case InvalidHeader: return "invalid header"
            case BodyTooLarge: return "response body too large"
            case Cancelled: return "request cancelled"
            case TlsError(msg): return "TLS error: {msg}"
            case Other(msg): return msg

impl Display for HttpError:
    fn fmt(self) -> str:
        self.message()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_connection_failed(self) -> bool:
        """Check if error is ConnectionFailed.

        Returns:
            True if ConnectionFailed
        """
        match self:
            case ConnectionFailed(_): true
            case _: false

    pub fn is_timeout(self) -> bool:
        """Check if error is Timeout.

        Returns:
            True if Timeout
        """
        match self:
            case Timeout: true
            case _: false

    pub fn is_invalid_url(self) -> bool:
        """Check if error is InvalidUrl.

        Returns:
            True if InvalidUrl
        """
        match self:
            case InvalidUrl: true
            case _: false

    pub fn is_tls_error(self) -> bool:
        """Check if error is TlsError.

        Returns:
            True if TlsError
        """
        match self:
            case TlsError(_): true
            case _: false

    pub fn is_network_error(self) -> bool:
        """Check if error is network-related.

        Returns:
            True if ConnectionFailed, Timeout, or TlsError
        """
        match self:
            case ConnectionFailed(_): true
            case Timeout: true
            case TlsError(_): true
            case _: false

    pub fn is_protocol_error(self) -> bool:
        """Check if error is protocol-related.

        Returns:
            True if InvalidResponse, InvalidHeader, BodyTooLarge
        """
        match self:
            case InvalidResponse: true
            case InvalidHeader: true
            case BodyTooLarge: true
            case _: false

    pub fn is_retryable(self) -> bool:
        """Check if error might be retryable.

        Returns:
            True if Timeout or ConnectionFailed
        """
        match self:
            case Timeout: true
            case ConnectionFailed(_): true
            case _: false

    pub fn summary(self) -> str:
        """Get summary of HTTP error.

        Returns:
            Human-readable summary

        Example:
            HttpError::Timeout.summary()
            # → "HttpError: request timed out (retryable)"
        """
        let msg = self.message()
        let props = []
        if self.is_retryable():
            props.push("retryable")
        if self.is_network_error():
            props.push("network")
        if self.is_protocol_error():
            props.push("protocol")
        let props_str = if props.len() > 0: " ({props.join(\", \")})" else: ""
        return "HttpError: {msg}{props_str}"

impl Error for HttpError

# Network error types
pub enum NetError:
    IoError(message: String)
    AddrParseError(message: String)
    ConnectionRefused
    ConnectionReset
    TimedOut
    WouldBlock
    NotConnected
    AlreadyConnected
    InvalidData
    PermissionDenied

impl NetError:
    # Convert from error code
    pub fn from_code(code: i64) -> NetError:
        match code:
            case -1: return NetError::IoError("I/O operation failed")
            case -2: return NetError::ConnectionRefused
            case -3: return NetError::ConnectionReset
            case -4: return NetError::TimedOut
            case -5: return NetError::WouldBlock
            case -6: return NetError::NotConnected
            case -7: return NetError::AlreadyConnected
            case -8: return NetError::InvalidData
            case -9: return NetError::PermissionDenied
            case _: return NetError::IoError("Unknown error")

    # Convert to string message
    pub fn to_string(self) -> String:
        match self:
            case NetError::IoError(msg): return msg
            case NetError::AddrParseError(msg): return "Address parse error: {msg}"
            case NetError::ConnectionRefused: return "Connection refused"
            case NetError::ConnectionReset: return "Connection reset"
            case NetError::TimedOut: return "Operation timed out"
            case NetError::WouldBlock: return "Operation would block"
            case NetError::NotConnected: return "Not connected"
            case NetError::AlreadyConnected: return "Already connected"
            case NetError::InvalidData: return "Invalid data"
            case NetError::PermissionDenied: return "Permission denied"

impl Display for NetError:
    fn fmt(self) -> str:
        self.to_string()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_io_error(self) -> bool:
        """Check if error is IoError.

        Returns:
            True if IoError
        """
        match self:
            case IoError(_): true
            case _: false

    pub fn is_connection_refused(self) -> bool:
        """Check if error is ConnectionRefused.

        Returns:
            True if ConnectionRefused
        """
        match self:
            case ConnectionRefused: true
            case _: false

    pub fn is_connection_reset(self) -> bool:
        """Check if error is ConnectionReset.

        Returns:
            True if ConnectionReset
        """
        match self:
            case ConnectionReset: true
            case _: false

    pub fn is_timed_out(self) -> bool:
        """Check if error is TimedOut.

        Returns:
            True if TimedOut
        """
        match self:
            case TimedOut: true
            case _: false

    pub fn is_would_block(self) -> bool:
        """Check if error is WouldBlock.

        Returns:
            True if WouldBlock
        """
        match self:
            case WouldBlock: true
            case _: false

    pub fn is_not_connected(self) -> bool:
        """Check if error is NotConnected.

        Returns:
            True if NotConnected
        """
        match self:
            case NotConnected: true
            case _: false

    pub fn is_permission_denied(self) -> bool:
        """Check if error is PermissionDenied.

        Returns:
            True if PermissionDenied
        """
        match self:
            case PermissionDenied: true
            case _: false

    pub fn is_connection_error(self) -> bool:
        """Check if error is connection-related.

        Returns:
            True if ConnectionRefused, ConnectionReset, or NotConnected
        """
        match self:
            case ConnectionRefused: true
            case ConnectionReset: true
            case NotConnected: true
            case _: false

    pub fn is_transient(self) -> bool:
        """Check if error is transient (temporary).

        Returns:
            True if WouldBlock or TimedOut
        """
        match self:
            case WouldBlock: true
            case TimedOut: true
            case _: false

    pub fn is_retryable(self) -> bool:
        """Check if error might be retryable.

        Returns:
            True if transient or ConnectionRefused
        """
        match self:
            case WouldBlock: true
            case TimedOut: true
            case ConnectionRefused: true
            case _: false

    pub fn is_fatal(self) -> bool:
        """Check if error is likely fatal (non-retryable).

        Returns:
            True if PermissionDenied or InvalidData
        """
        match self:
            case PermissionDenied: true
            case InvalidData: true
            case _: false

    pub fn summary(self) -> String:
        """Get summary of network error.

        Returns:
            Human-readable summary

        Example:
            NetError::TimedOut.summary()
            # → "NetError: Operation timed out (transient, retryable)"
        """
        let msg = self.to_string()
        let props = []
        if self.is_transient():
            props.push("transient")
        if self.is_retryable():
            props.push("retryable")
        if self.is_fatal():
            props.push("fatal")
        if self.is_connection_error():
            props.push("connection")
        let props_str = if props.len() > 0: " ({props.join(\", \")})" else: ""
        return "NetError: {msg}{props_str}"

impl Error for NetError
