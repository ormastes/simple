# Common File System Types
# Shared across all host variants (async_nogc_mut, async_gc_mut, etc.)

use units.file.*
use units.size.*
use host.common.io.types.*
use host.common.io.error.IoError

export MmapMode, MmapAdvice, StageMode, StagingStatus, StageState
export ProcessHandle, ContextManager, AsyncContextManager, Exception

# Memory map mode
pub enum MmapMode:
    ReadOnly        # MAP_PRIVATE | PROT_READ
    ReadWrite       # MAP_SHARED | PROT_READ | PROT_WRITE
    CopyOnWrite     # MAP_PRIVATE | PROT_READ | PROT_WRITE

impl MmapMode:
    # Get mmap protection flags (for sys_mmap)
    pub fn get_prot_flags(self) -> i32:
        # PROT_READ = 1, PROT_WRITE = 2
        match self:
            case MmapMode::ReadOnly:
                return 1  # PROT_READ
            case MmapMode::ReadWrite:
                return 3  # PROT_READ | PROT_WRITE
            case MmapMode::CopyOnWrite:
                return 3  # PROT_READ | PROT_WRITE

    # Get mmap flags (for sys_mmap)
    pub fn get_map_flags(self) -> i32:
        # MAP_SHARED = 1, MAP_PRIVATE = 2
        match self:
            case MmapMode::ReadOnly:
                return 2  # MAP_PRIVATE
            case MmapMode::ReadWrite:
                return 1  # MAP_SHARED
            case MmapMode::CopyOnWrite:
                return 2  # MAP_PRIVATE

    pub fn to_string(self) -> String:
        """Convert mode to string.

        Returns:
            Mode name
        """
        match self:
            case MmapMode::ReadOnly: "read-only"
            case MmapMode::ReadWrite: "read-write"
            case MmapMode::CopyOnWrite: "copy-on-write"

    pub fn description(self) -> String:
        """Get mode description.

        Returns:
            Human-readable description
        """
        match self:
            case MmapMode::ReadOnly:
                "Private read-only mapping"
            case MmapMode::ReadWrite:
                "Shared read-write mapping"
            case MmapMode::CopyOnWrite:
                "Private copy-on-write mapping"

    pub fn is_writable(self) -> bool:
        """Check if mode allows writing.

        Returns:
            True for writable modes
        """
        match self:
            case MmapMode::ReadOnly: false
            case MmapMode::ReadWrite: true
            case MmapMode::CopyOnWrite: true

    pub fn is_shared(self) -> bool:
        """Check if mode uses shared mapping.

        Returns:
            True for shared mapping
        """
        match self:
            case MmapMode::ReadOnly: false
            case MmapMode::ReadWrite: true
            case MmapMode::CopyOnWrite: false

    pub fn is_copy_on_write(self) -> bool:
        """Check if this is copy-on-write mode.

        Returns:
            True for CoW
        """
        match self:
            case MmapMode::CopyOnWrite: true
            case _: false

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_read_only(self) -> bool:
        """Check if mode is read-only.

        Returns:
            True for ReadOnly
        """
        match self:
            case MmapMode::ReadOnly: true
            case _: false

    pub fn is_read_write(self) -> bool:
        """Check if mode is read-write.

        Returns:
            True for ReadWrite
        """
        match self:
            case MmapMode::ReadWrite: true
            case _: false

    pub fn is_private(self) -> bool:
        """Check if mode uses private mapping.

        Returns:
            True for ReadOnly or CopyOnWrite
        """
        match self:
            case MmapMode::ReadOnly: true
            case MmapMode::CopyOnWrite: true
            case _: false

    pub fn allows_modification(self) -> bool:
        """Check if modifications are allowed.

        Returns:
            True if writable
        """
        return self.is_writable()

    pub fn affects_file(self) -> bool:
        """Check if writes affect the underlying file.

        Returns:
            True only for ReadWrite (shared mapping)
        """
        return self.is_shared()

    pub fn summary(self) -> String:
        """Get summary of mmap mode.

        Returns:
            Human-readable summary

        Example:
            MmapMode::ReadWrite.summary()
            # â†’ "MmapMode: read-write (shared, writable)"
        """
        let name = self.to_string()
        let props = []
        if self.is_shared():
            props.push("shared")
        else:
            props.push("private")
        if self.is_writable():
            props.push("writable")
        else:
            props.push("read-only")
        let props_str = props.join(", ")
        return "MmapMode: {name} ({props_str})"

# Memory access advice for madvise(2)
pub enum MmapAdvice:
    Normal          # MADV_NORMAL - No specific advice
    Sequential      # MADV_SEQUENTIAL - Expect sequential access
    Random          # MADV_RANDOM - Expect random access
    WillNeed        # MADV_WILLNEED - Expect to access soon (prefault)
    DontNeed        # MADV_DONTNEED - Don't expect to access soon

impl MmapAdvice:
    pub fn to_string(self) -> String:
        """Convert advice to string.

        Returns:
            Advice name
        """
        match self:
            case MmapAdvice::Normal: "normal"
            case MmapAdvice::Sequential: "sequential"
            case MmapAdvice::Random: "random"
            case MmapAdvice::WillNeed: "will-need"
            case MmapAdvice::DontNeed: "dont-need"

    pub fn description(self) -> String:
        """Get advice description.

        Returns:
            Human-readable description
        """
        match self:
            case MmapAdvice::Normal:
                "No specific access pattern advice"
            case MmapAdvice::Sequential:
                "Expect sequential access (readahead)"
            case MmapAdvice::Random:
                "Expect random access (no readahead)"
            case MmapAdvice::WillNeed:
                "Expect to access soon (prefault pages)"
            case MmapAdvice::DontNeed:
                "Don't expect to access soon (can discard)"

    pub fn is_prefetch(self) -> bool:
        """Check if advice triggers prefetching.

        Returns:
            True for Sequential or WillNeed
        """
        match self:
            case MmapAdvice::Sequential: true
            case MmapAdvice::WillNeed: true
            case _: false

    pub fn is_discard(self) -> bool:
        """Check if advice allows discarding pages.

        Returns:
            True for DontNeed
        """
        match self:
            case MmapAdvice::DontNeed: true
            case _: false

# Staging mode for file operations
pub enum StageMode:
    # No staging - standard buffered I/O
    None
    # Memory-mapped file - fast random access (process-private)
    Mmap
    # Memory-mapped file - shared across processes
    MmapShared
    # Prefetch entire file into memory
    Prefetch
    # Adaptive - choose based on file size
    Adaptive

impl StageMode:
    pub fn to_string(self) -> String:
        """Convert mode to string.

        Returns:
            Mode name
        """
        match self:
            case StageMode::None: "none"
            case StageMode::Mmap: "mmap"
            case StageMode::MmapShared: "mmap-shared"
            case StageMode::Prefetch: "prefetch"
            case StageMode::Adaptive: "adaptive"

    pub fn description(self) -> String:
        """Get mode description.

        Returns:
            Human-readable description
        """
        match self:
            case StageMode::None:
                "No staging - standard buffered I/O"
            case StageMode::Mmap:
                "Memory-mapped file (private)"
            case StageMode::MmapShared:
                "Memory-mapped file (shared)"
            case StageMode::Prefetch:
                "Prefetch entire file into memory"
            case StageMode::Adaptive:
                "Adaptive mode based on file size"

    pub fn is_mmap(self) -> bool:
        """Check if mode uses memory mapping.

        Returns:
            True for mmap modes
        """
        match self:
            case StageMode::Mmap: true
            case StageMode::MmapShared: true
            case _: false

    pub fn uses_memory(self) -> bool:
        """Check if mode stages data in memory.

        Returns:
            True for memory-based modes
        """
        match self:
            case StageMode::None: false
            case _: true

    pub fn is_adaptive(self) -> bool:
        """Check if this is adaptive mode.

        Returns:
            True for adaptive
        """
        match self:
            case StageMode::Adaptive: true
            case _: false

# Staging status for lifecycle tracking
pub enum StagingStatus:
    NotStaged    # No staging operation
    Staging      # Staging in progress (async)
    Staged       # Staging complete

impl StagingStatus:
    pub fn to_string(self) -> String:
        """Convert status to string.

        Returns:
            Status name
        """
        match self:
            case StagingStatus::NotStaged: "not-staged"
            case StagingStatus::Staging: "staging"
            case StagingStatus::Staged: "staged"

    pub fn description(self) -> String:
        """Get status description.

        Returns:
            Human-readable description
        """
        match self:
            case StagingStatus::NotStaged:
                "No staging operation active"
            case StagingStatus::Staging:
                "Staging in progress (async)"
            case StagingStatus::Staged:
                "Staging complete and ready"

    pub fn is_active(self) -> bool:
        """Check if staging is in progress.

        Returns:
            True for Staging
        """
        match self:
            case StagingStatus::Staging: true
            case _: false

    pub fn is_complete(self) -> bool:
        """Check if staging is complete.

        Returns:
            True for Staged
        """
        match self:
            case StagingStatus::Staged: true
            case _: false

    pub fn is_not_staged(self) -> bool:
        """Check if not staged.

        Returns:
            True for NotStaged
        """
        match self:
            case StagingStatus::NotStaged: true
            case _: false

# File staging state
pub struct StageState:
    mode: StageMode
    status: StagingStatus  # Current staging status
    mmap_ptr: i64        # Memory-mapped region pointer
    mmap_size: u64       # Size of mapped region
    is_shared: bool      # True if mmap is shared across processes
    prefetch_buf: Option[Bytes]  # Prefetched data
    staged_files: Array[FilePath]  # Files staged together

impl StageState:
    pub fn has_mmap(self) -> bool:
        """Check if mmap is active.

        Returns:
            True if mmap_ptr is valid
        """
        self.mmap_ptr != 0

    pub fn is_staged(self) -> bool:
        """Check if staging is complete.

        Returns:
            True if status is Staged
        """
        self.status.is_complete()

    pub fn is_staging(self) -> bool:
        """Check if staging is in progress.

        Returns:
            True if status is Staging
        """
        self.status.is_active()

    pub fn file_count(self) -> u64:
        """Get number of staged files.

        Returns:
            Staged file count
        """
        self.staged_files.len()

    pub fn has_prefetch_buffer(self) -> bool:
        """Check if has prefetch buffer.

        Returns:
            True if prefetch_buf is Some
        """
        match self.prefetch_buf:
            case Some(_): true
            case None: false

    pub fn get_mode(self) -> StageMode:
        """Get staging mode.

        Returns:
            Stage mode
        """
        self.mode

    pub fn summary(self) -> String:
        """Get staging state summary.

        Returns:
            Human-readable summary
        """
        let mode_str = self.mode.to_string()
        let status_str = self.status.to_string()
        let shared_str = if self.is_shared: "shared" else: "private"
        return "StageState: {mode_str} ({status_str}, {shared_str}, {self.file_count()} files)"

# Process handle for worker processes
pub struct ProcessHandle:
    pid: i64
    staged_files: Array[FilePath]

impl ProcessHandle:
    # Wait for process to complete
    pub async fn join(self) -> Result[i64, IoError]:
        return native_process_wait(self.pid)

    # Check if process is still running
    pub fn is_alive(self) -> bool:
        return native_process_is_alive(self.pid)

    # Terminate process
    pub fn kill(self) -> Result[(), IoError]:
        return native_process_kill(self.pid)

    pub fn get_pid(self) -> i64:
        """Get process ID.

        Returns:
            Process ID
        """
        self.pid

    pub fn file_count(self) -> u64:
        """Get number of staged files.

        Returns:
            Staged file count
        """
        self.staged_files.len()

    pub fn has_files(self) -> bool:
        """Check if process has staged files.

        Returns:
            True if has files
        """
        self.file_count() > 0

    pub fn summary(self) -> String:
        """Get process handle summary.

        Returns:
            Human-readable summary
        """
        let alive_str = if self.is_alive(): "alive" else: "dead"
        return "ProcessHandle: PID {self.pid} ({alive_str}, {self.file_count()} files)"

# Context manager traits for with...as syntax

# Sync context manager trait
pub trait ContextManager[T]:
    fn __enter__(self) -> T
    fn __exit__(self, exc: Option[Exception]) -> bool

# Async context manager trait
pub trait AsyncContextManager[T]:
    async fn __aenter__(self) -> T
    async fn __aexit__(self, exc: Option[Exception]) -> bool

# Exception type for context managers
pub struct Exception:
    message: String

impl Exception:
    pub fn new(message: String) -> Exception:
        return Exception { message: message }

    pub fn get_message(self) -> String:
        """Get exception message.

        Returns:
            Error message
        """
        self.message

    pub fn is_empty(self) -> bool:
        """Check if message is empty.

        Returns:
            True if no message
        """
        self.message.is_empty()

    pub fn summary(self) -> String:
        """Get exception summary.

        Returns:
            Human-readable summary
        """
        if self.is_empty():
            return "Exception: (no message)"
        return "Exception: {self.message}"

# Native process management declarations
extern fn native_process_wait(pid: i64) -> Result[i64, IoError]
extern fn native_process_is_alive(pid: i64) -> bool
extern fn native_process_kill(pid: i64) -> Result[(), IoError]
