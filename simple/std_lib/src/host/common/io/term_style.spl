# Terminal Styling - ANSI colors, styles, and formatting
# Cross-platform terminal text formatting

# ANSI color codes
pub enum Color:
    Black
    Red
    Green
    Yellow
    Blue
    Magenta
    Cyan
    White
    BrightBlack
    BrightRed
    BrightGreen
    BrightYellow
    BrightBlue
    BrightMagenta
    BrightCyan
    BrightWhite
    Rgb(u8, u8, u8)
    Ansi256(u8)

impl Color:
    # Get ANSI foreground code
    pub fn fg_code(self) -> u8:
        match self:
            case Black: return 30
            case Red: return 31
            case Green: return 32
            case Yellow: return 33
            case Blue: return 34
            case Magenta: return 35
            case Cyan: return 36
            case White: return 37
            case BrightBlack: return 90
            case BrightRed: return 91
            case BrightGreen: return 92
            case BrightYellow: return 93
            case BrightBlue: return 94
            case BrightMagenta: return 95
            case BrightCyan: return 96
            case BrightWhite: return 97
            case Rgb(_, _, _): return 38
            case Ansi256(_): return 38

    # Get ANSI background code
    pub fn bg_code(self) -> u8:
        match self:
            case Black: return 40
            case Red: return 41
            case Green: return 42
            case Yellow: return 43
            case Blue: return 44
            case Magenta: return 45
            case Cyan: return 46
            case White: return 47
            case BrightBlack: return 100
            case BrightRed: return 101
            case BrightGreen: return 102
            case BrightYellow: return 103
            case BrightBlue: return 104
            case BrightMagenta: return 105
            case BrightCyan: return 106
            case BrightWhite: return 107
            case Rgb(_, _, _): return 48
            case Ansi256(_): return 48

    pub fn to_string(self) -> String:
        """Convert color to string.

        Returns:
            Color name

        Example:
            Color::Red.to_string()  # → "red"
            Color::Rgb(255, 0, 0).to_string()  # → "rgb(255,0,0)"
        """
        match self:
            case Black: return "black"
            case Red: return "red"
            case Green: return "green"
            case Yellow: return "yellow"
            case Blue: return "blue"
            case Magenta: return "magenta"
            case Cyan: return "cyan"
            case White: return "white"
            case BrightBlack: return "bright-black"
            case BrightRed: return "bright-red"
            case BrightGreen: return "bright-green"
            case BrightYellow: return "bright-yellow"
            case BrightBlue: return "bright-blue"
            case BrightMagenta: return "bright-magenta"
            case BrightCyan: return "bright-cyan"
            case BrightWhite: return "bright-white"
            case Rgb(r, g, b): return "rgb({r},{g},{b})"
            case Ansi256(n): return "ansi256({n})"

    pub fn description(self) -> String:
        """Get color description.

        Returns:
            Human-readable description
        """
        match self:
            case Black: return "Basic black color"
            case Red: return "Basic red color"
            case Green: return "Basic green color"
            case Yellow: return "Basic yellow color"
            case Blue: return "Basic blue color"
            case Magenta: return "Basic magenta color"
            case Cyan: return "Basic cyan color"
            case White: return "Basic white color"
            case BrightBlack: return "Bright black (gray)"
            case BrightRed: return "Bright red"
            case BrightGreen: return "Bright green"
            case BrightYellow: return "Bright yellow"
            case BrightBlue: return "Bright blue"
            case BrightMagenta: return "Bright magenta"
            case BrightCyan: return "Bright cyan"
            case BrightWhite: return "Bright white"
            case Rgb(r, g, b): return "24-bit RGB color ({r},{g},{b})"
            case Ansi256(n): return "256-color palette index {n}"

    pub fn is_basic(self) -> bool:
        """Check if this is a basic 8-color.

        Returns:
            True for basic colors (not bright/rgb/ansi256)
        """
        match self:
            case Black: return true
            case Red: return true
            case Green: return true
            case Yellow: return true
            case Blue: return true
            case Magenta: return true
            case Cyan: return true
            case White: return true
            case _: return false

    pub fn is_bright(self) -> bool:
        """Check if this is a bright color variant.

        Returns:
            True for bright colors
        """
        match self:
            case BrightBlack: return true
            case BrightRed: return true
            case BrightGreen: return true
            case BrightYellow: return true
            case BrightBlue: return true
            case BrightMagenta: return true
            case BrightCyan: return true
            case BrightWhite: return true
            case _: return false

    pub fn is_rgb(self) -> bool:
        """Check if this is a 24-bit RGB color.

        Returns:
            True for RGB colors
        """
        match self:
            case Rgb(_, _, _): return true
            case _: return false

    pub fn is_ansi256(self) -> bool:
        """Check if this is a 256-color palette index.

        Returns:
            True for ANSI 256 colors
        """
        match self:
            case Ansi256(_): return true
            case _: return false

    pub fn is_truecolor(self) -> bool:
        """Check if this supports true color (24-bit).

        Returns:
            True for RGB colors
        """
        self.is_rgb()

    pub fn summary(self) -> String:
        """Get color summary.

        Returns:
            Human-readable summary

        Example:
            Color::BrightRed.summary()
            # → "Color: bright-red (Bright red, bright)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_basic():
            props.push("basic")
        if self.is_bright():
            props.push("bright")
        if self.is_rgb():
            props.push("truecolor")
        if self.is_ansi256():
            props.push("256-color")
        val props_str = if props.len() > 0: ", {props.join(', ')}" else: ""
        return "Color: {name} ({desc}{props_str})"

# Text style attributes
pub struct Style:
    fg: Option[Color]
    bg: Option[Color]
    bold: bool
    dim: bool
    italic: bool
    underline: bool
    blink: bool
    reverse: bool
    hidden: bool
    strikethrough: bool

impl Style:
    # Create default style (no formatting)
    pub fn new() -> Style:
        return Style {
            fg: None,
            bg: None,
            bold: false,
            dim: false,
            italic: false,
            underline: false,
            blink: false,
            reverse: false,
            hidden: false,
            strikethrough: false
        }

    # Set foreground color
    pub fn fg(self, color: Color) -> Style:
        self.fg = Some(color)
        return self

    # Set background color
    pub fn bg(self, color: Color) -> Style:
        self.bg = Some(color)
        return self

    # Enable bold
    pub fn bold(self) -> Style:
        self.bold = true
        return self

    # Enable dim
    pub fn dim(self) -> Style:
        self.dim = true
        return self

    # Enable italic
    pub fn italic(self) -> Style:
        self.italic = true
        return self

    # Enable underline
    pub fn underline(self) -> Style:
        self.underline = true
        return self

    # Enable blink
    pub fn blink(self) -> Style:
        self.blink = true
        return self

    # Enable reverse video
    pub fn reverse(self) -> Style:
        self.reverse = true
        return self

    # Enable hidden
    pub fn hidden(self) -> Style:
        self.hidden = true
        return self

    # Enable strikethrough
    pub fn strikethrough(self) -> Style:
        self.strikethrough = true
        return self

    # Generate ANSI escape sequence
    pub fn to_ansi(self) -> String:
        var codes: Array[String] = []

        if self.bold:
            codes.push("1")
        if self.dim:
            codes.push("2")
        if self.italic:
            codes.push("3")
        if self.underline:
            codes.push("4")
        if self.blink:
            codes.push("5")
        if self.reverse:
            codes.push("7")
        if self.hidden:
            codes.push("8")
        if self.strikethrough:
            codes.push("9")

        match self.fg:
            case Some(color):
                match color:
                    case Rgb(r, g, b):
                        codes.push("38;2;{r};{g};{b}")
                    case Ansi256(n):
                        codes.push("38;5;{n}")
                    case _:
                        codes.push("{color.fg_code()}")
            case None: pass

        match self.bg:
            case Some(color):
                match color:
                    case Rgb(r, g, b):
                        codes.push("48;2;{r};{g};{b}")
                    case Ansi256(n):
                        codes.push("48;5;{n}")
                    case _:
                        codes.push("{color.bg_code()}")
            case None: pass

        if codes.is_empty():
            return ""

        return "\x1b[{codes.join(';')}m"

    # Apply style to text and return styled string
    pub fn apply(self, text: &str) -> String:
        val prefix = self.to_ansi()
        if prefix.is_empty():
            return text.to_string()
        return "{prefix}{text}\x1b[0m"

    pub fn has_fg(self) -> bool:
        """Check if foreground color is set.

        Returns:
            True if fg color is configured
        """
        match self.fg:
            case Some(_): return true
            case None: return false

    pub fn has_bg(self) -> bool:
        """Check if background color is set.

        Returns:
            True if bg color is configured
        """
        match self.bg:
            case Some(_): return true
            case None: return false

    pub fn has_any_style(self) -> bool:
        """Check if any styling is configured.

        Returns:
            True if any attribute is set
        """
        return self.has_fg() or self.has_bg() or
               self.bold or self.dim or self.italic or
               self.underline or self.blink or self.reverse or
               self.hidden or self.strikethrough

    pub fn is_plain(self) -> bool:
        """Check if this is plain (no styling).

        Returns:
            True if no attributes are set
        """
        return not self.has_any_style()

    pub fn count_attributes(self) -> u8:
        """Count number of active style attributes.

        Returns:
            Number of enabled attributes
        """
        var count: u8 = 0
        if self.has_fg():
            count = count + 1
        if self.has_bg():
            count = count + 1
        if self.bold:
            count = count + 1
        if self.dim:
            count = count + 1
        if self.italic:
            count = count + 1
        if self.underline:
            count = count + 1
        if self.blink:
            count = count + 1
        if self.reverse:
            count = count + 1
        if self.hidden:
            count = count + 1
        if self.strikethrough:
            count = count + 1
        return count

    pub fn summary(self) -> String:
        """Get style summary.

        Returns:
            Human-readable summary

        Example:
            style.summary()  # → "Style: red fg, bold, underline (3 attrs)"
        """
        if self.is_plain():
            return "Style: plain (0 attrs)"

        var attrs: Array[String] = []
        match self.fg:
            case Some(color):
                attrs.push("{color.to_string()} fg")
            case None: pass

        match self.bg:
            case Some(color):
                attrs.push("{color.to_string()} bg")
            case None: pass

        if self.bold:
            attrs.push("bold")
        if self.dim:
            attrs.push("dim")
        if self.italic:
            attrs.push("italic")
        if self.underline:
            attrs.push("underline")
        if self.blink:
            attrs.push("blink")
        if self.reverse:
            attrs.push("reverse")
        if self.hidden:
            attrs.push("hidden")
        if self.strikethrough:
            attrs.push("strikethrough")

        val count = self.count_attributes()
        return "Style: {attrs.join(', ')} ({count} attrs)"

# Reset all formatting
pub fn reset() -> String:
    return "\x1b[0m"

# Convenience functions for common styles
pub fn red(text: &str) -> String:
    return Style::new().fg(Color::Red).apply(text)

pub fn green(text: &str) -> String:
    return Style::new().fg(Color::Green).apply(text)

pub fn yellow(text: &str) -> String:
    return Style::new().fg(Color::Yellow).apply(text)

pub fn blue(text: &str) -> String:
    return Style::new().fg(Color::Blue).apply(text)

pub fn magenta(text: &str) -> String:
    return Style::new().fg(Color::Magenta).apply(text)

pub fn cyan(text: &str) -> String:
    return Style::new().fg(Color::Cyan).apply(text)

pub fn white(text: &str) -> String:
    return Style::new().fg(Color::White).apply(text)

pub fn bold(text: &str) -> String:
    return Style::new().bold().apply(text)

pub fn dim(text: &str) -> String:
    return Style::new().dim().apply(text)

pub fn italic(text: &str) -> String:
    return Style::new().italic().apply(text)

pub fn underline(text: &str) -> String:
    return Style::new().underline().apply(text)

pub fn strikethrough(text: &str) -> String:
    return Style::new().strikethrough().apply(text)

# Error styling (red + bold)
pub fn error(text: &str) -> String:
    return Style::new().fg(Color::Red).bold().apply(text)

# Warning styling (yellow + bold)
pub fn warning(text: &str) -> String:
    return Style::new().fg(Color::Yellow).bold().apply(text)

# Success styling (green + bold)
pub fn success(text: &str) -> String:
    return Style::new().fg(Color::Green).bold().apply(text)

# Info styling (cyan)
pub fn info(text: &str) -> String:
    return Style::new().fg(Color::Cyan).apply(text)

# Styled string builder for complex formatting
pub struct StyledString:
    parts: Array[String]

impl StyledString:
    pub fn new() -> StyledString:
        return StyledString { parts: [] }

    pub fn push(self, text: &str) -> &mut StyledString:
        self.parts.push(text.to_string())
        return self

    pub fn push_styled(self, text: &str, style: Style) -> &mut StyledString:
        self.parts.push(style.apply(text))
        return self

    pub fn red(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Red))

    pub fn green(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Green))

    pub fn yellow(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Yellow))

    pub fn blue(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Blue))

    pub fn cyan(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Cyan))

    pub fn bold(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().bold())

    pub fn to_string(self) -> String:
        return self.parts.join("")

    pub fn part_count(self) -> u64:
        """Get number of parts in styled string.

        Returns:
            Number of parts
        """
        return self.parts.len()

    pub fn is_empty(self) -> bool:
        """Check if styled string is empty.

        Returns:
            True if no parts
        """
        return self.part_count() == 0

    pub fn summary(self) -> String:
        """Get styled string summary.

        Returns:
            Summary with part count
        """
        return "StyledString: {self.part_count()} parts"

# Progress bar styling
pub struct ProgressStyle:
    filled: char
    empty: char
    left_bracket: char
    right_bracket: char
    width: u16

impl ProgressStyle:
    pub fn default() -> ProgressStyle:
        return ProgressStyle {
            filled: '#',
            empty: '-',
            left_bracket: '[',
            right_bracket: ']',
            width: 40
        }

    pub fn unicode() -> ProgressStyle:
        return ProgressStyle {
            filled: '\u2588',  # Full block
            empty: '\u2591',   # Light shade
            left_bracket: '\u2595',  # Right one eighth block
            right_bracket: '\u258F', # Left one eighth block
            width: 40
        }

    pub fn render(self, progress: f64) -> String:
        val clamped = progress.clamp(0.0, 1.0)
        val filled_count = ((clamped * (self.width as f64)) as u16)
        val empty_count = self.width - filled_count

        var result = String::new()
        result.push(self.left_bracket)

        for _ in 0..filled_count:
            result.push(self.filled)
        for _ in 0..empty_count:
            result.push(self.empty)

        result.push(self.right_bracket)
        return result

    pub fn render_with_percent(self, progress: f64) -> String:
        val bar = self.render(progress)
        val percent = ((progress * 100.0) as i32)
        return "{bar} {percent}%"

    pub fn is_unicode(self) -> bool:
        """Check if using Unicode block characters.

        Returns:
            True if filled char is Unicode block
        """
        return self.filled == '\u2588'

    pub fn is_ascii(self) -> bool:
        """Check if using ASCII characters.

        Returns:
            True if not using Unicode
        """
        return not self.is_unicode()

    pub fn get_width(self) -> u16:
        """Get progress bar width.

        Returns:
            Width in characters
        """
        return self.width

    pub fn with_width(self, width: u16) -> ProgressStyle:
        """Set progress bar width (fluent API).

        Args:
            width: New width

        Returns:
            Modified style
        """
        self.width = width
        return self

    pub fn summary(self) -> String:
        """Get progress style summary.

        Returns:
            Human-readable summary
        """
        val style_type = if self.is_unicode(): "unicode" else: "ascii"
        return "ProgressStyle: {style_type}, width {self.width}"

# Spinner animation frames
pub struct Spinner:
    frames: Array[&str]
    current: u64

impl Spinner:
    pub fn dots() -> Spinner:
        return Spinner {
            frames: [".", "..", "...", ".."],
            current: 0
        }

    pub fn line() -> Spinner:
        return Spinner {
            frames: ["-", "\\", "|", "/"],
            current: 0
        }

    pub fn braille() -> Spinner:
        return Spinner {
            frames: ["\u2801", "\u2802", "\u2804", "\u2840", "\u2880", "\u2820", "\u2810", "\u2808"],
            current: 0
        }

    pub fn next(self) -> &str:
        val frame = self.frames[self.current]
        self.current = (self.current + 1) % self.frames.len()
        return frame

    pub fn reset(self):
        self.current = 0

    pub fn frame_count(self) -> u64:
        """Get number of animation frames.

        Returns:
            Frame count
        """
        return self.frames.len()

    pub fn is_unicode(self) -> bool:
        """Check if using Unicode characters.

        Returns:
            True for braille/Unicode spinners
        """
        if self.frame_count() == 0:
            return false
        val first = self.frames[0]
        return first.contains("\u")

    pub fn is_ascii(self) -> bool:
        """Check if using ASCII characters.

        Returns:
            True for ASCII spinners
        """
        return not self.is_unicode()

    pub fn get_current_index(self) -> u64:
        """Get current frame index.

        Returns:
            Current animation frame index
        """
        return self.current

    pub fn summary(self) -> String:
        """Get spinner summary.

        Returns:
            Summary with frame count and type
        """
        val style = if self.is_unicode(): "unicode" else: "ascii"
        return "Spinner: {self.frame_count()} frames ({style})"

# Box drawing characters for TUI
pub struct BoxChars:
    top_left: char
    top_right: char
    bottom_left: char
    bottom_right: char
    horizontal: char
    vertical: char
    t_down: char
    t_up: char
    t_right: char
    t_left: char
    cross: char

impl BoxChars:
    pub fn ascii() -> BoxChars:
        return BoxChars {
            top_left: '+',
            top_right: '+',
            bottom_left: '+',
            bottom_right: '+',
            horizontal: '-',
            vertical: '|',
            t_down: '+',
            t_up: '+',
            t_right: '+',
            t_left: '+',
            cross: '+'
        }

    pub fn single() -> BoxChars:
        return BoxChars {
            top_left: '\u250C',
            top_right: '\u2510',
            bottom_left: '\u2514',
            bottom_right: '\u2518',
            horizontal: '\u2500',
            vertical: '\u2502',
            t_down: '\u252C',
            t_up: '\u2534',
            t_right: '\u251C',
            t_left: '\u2524',
            cross: '\u253C'
        }

    pub fn double() -> BoxChars:
        return BoxChars {
            top_left: '\u2554',
            top_right: '\u2557',
            bottom_left: '\u255A',
            bottom_right: '\u255D',
            horizontal: '\u2550',
            vertical: '\u2551',
            t_down: '\u2566',
            t_up: '\u2569',
            t_right: '\u2560',
            t_left: '\u2563',
            cross: '\u256C'
        }

    pub fn rounded() -> BoxChars:
        return BoxChars {
            top_left: '\u256D',
            top_right: '\u256E',
            bottom_left: '\u2570',
            bottom_right: '\u256F',
            horizontal: '\u2500',
            vertical: '\u2502',
            t_down: '\u252C',
            t_up: '\u2534',
            t_right: '\u251C',
            t_left: '\u2524',
            cross: '\u253C'
        }

    # Draw a horizontal line
    pub fn h_line(self, width: u16) -> String:
        var s = String::new()
        for _ in 0..width:
            s.push(self.horizontal)
        return s

    # Draw a vertical line
    pub fn v_line(self, height: u16) -> String:
        var lines: Array[String] = []
        for _ in 0..height:
            lines.push(self.vertical.to_string())
        return lines.join("\n")

    # Draw a box
    pub fn box_frame(self, width: u16, height: u16) -> String:
        val inner_width = width - 2
        var lines: Array[String] = []

        # Top border
        var top = String::new()
        top.push(self.top_left)
        top.push_str(&self.h_line(inner_width))
        top.push(self.top_right)
        lines.push(top)

        # Middle rows
        for _ in 1..(height - 1):
            var mid = String::new()
            mid.push(self.vertical)
            for _ in 0..inner_width:
                mid.push(' ')
            mid.push(self.vertical)
            lines.push(mid)

        # Bottom border
        var bottom = String::new()
        bottom.push(self.bottom_left)
        bottom.push_str(&self.h_line(inner_width))
        bottom.push(self.bottom_right)
        lines.push(bottom)

        return lines.join("\n")

    pub fn is_ascii(self) -> bool:
        """Check if using ASCII box characters.

        Returns:
            True for ASCII style
        """
        return self.top_left == '+'

    pub fn is_single(self) -> bool:
        """Check if using single-line Unicode.

        Returns:
            True for single-line style
        """
        return self.top_left == '\u250C'

    pub fn is_double(self) -> bool:
        """Check if using double-line Unicode.

        Returns:
            True for double-line style
        """
        return self.top_left == '\u2554'

    pub fn is_rounded(self) -> bool:
        """Check if using rounded corners.

        Returns:
            True for rounded style
        """
        return self.top_left == '\u256D'

    pub fn is_unicode(self) -> bool:
        """Check if using any Unicode style.

        Returns:
            True for any Unicode style
        """
        return not self.is_ascii()

    pub fn summary(self) -> String:
        """Get box characters summary.

        Returns:
            Style description
        """
        if self.is_ascii():
            return "BoxChars: ascii"
        else if self.is_single():
            return "BoxChars: single-line unicode"
        else if self.is_double():
            return "BoxChars: double-line unicode"
        else if self.is_rounded():
            return "BoxChars: rounded unicode"
        else:
            return "BoxChars: custom"
