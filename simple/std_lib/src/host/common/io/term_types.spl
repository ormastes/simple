# Common Terminal Types
# Shared across all host variants (async_nogc_mut, async_gc_immut, etc.)

use core.traits.*

export TermSize, CursorPos, TermError, KeyEvent, KeyCode, KeyModifiers

# Terminal size
pub struct TermSize:
    rows: u16
    cols: u16

impl TermSize:
    pub fn new(rows: u16, cols: u16) -> TermSize:
        TermSize { rows: rows, cols: cols }

    pub fn rows(self) -> u16:
        self.rows

    pub fn cols(self) -> u16:
        self.cols

    pub fn area(self) -> u32:
        (self.rows as u32) * (self.cols as u32)

impl Display for TermSize:
    fn fmt(self) -> str:
        "{self.cols}x{self.rows}"

impl Eq for TermSize:
    fn eq(self, other: &Self) -> bool:
        self.rows == other.rows and self.cols == other.cols

# Cursor position
pub struct CursorPos:
    row: u16
    col: u16

impl CursorPos:
    pub fn new(row: u16, col: u16) -> CursorPos:
        CursorPos { row: row, col: col }

    pub fn row(self) -> u16:
        self.row

    pub fn col(self) -> u16:
        self.col

impl Display for CursorPos:
    fn fmt(self) -> str:
        "({self.row}, {self.col})"

impl Eq for CursorPos:
    fn eq(self, other: &Self) -> bool:
        self.row == other.row and self.col == other.col

# Terminal error type
pub enum TermError:
    Io(i32)
    NotTty
    InvalidResponse
    Eof
    Timeout
    Interrupted
    Unknown

impl TermError:
    pub fn from_code(code: i32) -> TermError:
        match code:
            case -1: TermError::Eof
            case -2: TermError::NotTty
            case -3: TermError::Timeout
            case -4: TermError::Interrupted
            case _: TermError::Io(code)

    pub fn message(self) -> str:
        match self:
            case Io(code): "I/O error: {code}"
            case NotTty: "not a tty"
            case InvalidResponse: "invalid terminal response"
            case Eof: "end of file"
            case Timeout: "operation timed out"
            case Interrupted: "operation interrupted"
            case Unknown: "unknown error"

impl Display for TermError:
    fn fmt(self) -> str:
        self.message()

impl Error for TermError

# Key event
pub struct KeyEvent:
    code: KeyCode
    modifiers: KeyModifiers

impl KeyEvent:
    pub fn new(code: KeyCode, modifiers: KeyModifiers) -> KeyEvent:
        KeyEvent { code: code, modifiers: modifiers }

# Key codes
pub enum KeyCode:
    Char(char)
    Enter
    Escape
    Backspace
    Tab
    Delete
    Insert
    Home
    End
    PageUp
    PageDown
    Up
    Down
    Left
    Right
    F(u8)
    Null

impl Display for KeyCode:
    fn fmt(self) -> str:
        match self:
            case Char(c): "'{c}'"
            case Enter: "Enter"
            case Escape: "Escape"
            case Backspace: "Backspace"
            case Tab: "Tab"
            case Delete: "Delete"
            case Insert: "Insert"
            case Home: "Home"
            case End: "End"
            case PageUp: "PageUp"
            case PageDown: "PageDown"
            case Up: "Up"
            case Down: "Down"
            case Left: "Left"
            case Right: "Right"
            case F(n): "F{n}"
            case Null: "Null"

# Key modifiers
pub struct KeyModifiers:
    shift: bool
    ctrl: bool
    alt: bool

impl KeyModifiers:
    pub fn none() -> KeyModifiers:
        KeyModifiers { shift: false, ctrl: false, alt: false }

    pub fn shift() -> KeyModifiers:
        KeyModifiers { shift: true, ctrl: false, alt: false }

    pub fn ctrl() -> KeyModifiers:
        KeyModifiers { shift: false, ctrl: true, alt: false }

    pub fn alt() -> KeyModifiers:
        KeyModifiers { shift: false, ctrl: false, alt: true }

    pub fn has_shift(self) -> bool:
        self.shift

    pub fn has_ctrl(self) -> bool:
        self.ctrl

    pub fn has_alt(self) -> bool:
        self.alt

impl Default for KeyModifiers:
    fn default() -> Self:
        KeyModifiers::none()

impl Eq for KeyModifiers:
    fn eq(self, other: &Self) -> bool:
        self.shift == other.shift and self.ctrl == other.ctrl and self.alt == other.alt
