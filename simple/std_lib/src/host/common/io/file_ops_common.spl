# Common File Operation Implementations
#
# Shared file I/O helpers used across all host variants (async_nogc_mut, async_gc_mut, sync_nogc_mut).
# These are pure functions that work on file handles and don't depend on async/sync.

use units.file.*
use units.size.*
use host.common.io.types.*
use host.common.io.fs_types.*
use host.common.io.error.*
use host.common.io.fs_ffi.*

# ===============================
# Positioned I/O Implementation
# ===============================

# Read at offset using mmap if staged, otherwise use native pread
# This is thread-safe and doesn't change the file position
pub fn pread_with_staging(
    handle: i64,
    buf: &mut Bytes,
    offset: u64,
    stage_state: Option[StageState]
) -> Result[ByteCount, IoError]:
    if let Some(state) = stage_state:
        if state.status == StagingStatus::Staged:
            match state.mode:
                case StageMode::Mmap | StageMode::MmapShared:
                    let to_read = buf.len().min(state.mmap_size - offset)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, offset, buf, to_read)
                    return Ok(to_read_bytes)
                case _:
                    pass

    return native_file_pread(handle, buf, offset)

# Write at offset without changing file position (thread-safe)
pub fn pwrite_impl(handle: i64, data: &Bytes, offset: u64) -> Result[ByteCount, IoError]:
    return native_file_pwrite(handle, data, offset)

# ===============================
# Size Calculation
# ===============================

# Get file size using seek (sync version)
pub fn file_size_sync(handle: i64) -> Result[ByteCount, IoError]:
    let current = native_file_seek_sync(handle, SeekFrom::Current(0))?
    let end = native_file_seek_sync(handle, SeekFrom::End(0))?
    native_file_seek_sync(handle, SeekFrom::Start(current as u64))?
    return Ok(end)

# ===============================
# Staging Helper Functions
# ===============================

# Create initial staging state
pub fn create_stage_state(mode: StageMode, is_shared: bool) -> StageState:
    return StageState {
        mode: mode,
        status: StagingStatus::Staging,
        mmap_ptr: 0,
        mmap_size: 0,
        is_shared: is_shared,
        prefetch_buf: None,
        staged_files: Array[FilePath]::new()
    }

# Create completed staging state with mmap
pub fn create_staged_mmap_state(mode: StageMode, mmap_ptr: i64, mmap_size: u64, is_shared: bool) -> StageState:
    return StageState {
        mode: mode,
        status: StagingStatus::Staged,
        mmap_ptr: mmap_ptr,
        mmap_size: mmap_size,
        is_shared: is_shared,
        prefetch_buf: None,
        staged_files: Array[FilePath]::new()
    }

# Create completed staging state with prefetch buffer
pub fn create_staged_prefetch_state(buffer: Bytes) -> StageState:
    return StageState {
        mode: StageMode::Prefetch,
        status: StagingStatus::Staged,
        mmap_ptr: 0,
        mmap_size: 0,
        is_shared: false,
        prefetch_buf: Some(buffer),
        staged_files: Array[FilePath]::new()
    }

# Create empty staged state (for zero-size files)
pub fn create_empty_staged_state(mode: StageMode, is_shared: bool) -> StageState:
    return StageState {
        mode: mode,
        status: StagingStatus::Staged,
        mmap_ptr: 0,
        mmap_size: 0,
        is_shared: is_shared,
        prefetch_buf: None,
        staged_files: Array[FilePath]::new()
    }

# ===============================
# Staging Queries
# ===============================

# Check if staging state indicates file is staged
pub fn is_staged(state: Option[StageState]) -> bool:
    return state.is_some()

# Get staging mode from state
pub fn get_stage_mode(state: Option[StageState]) -> StageMode:
    match state:
        case Some(s): return s.mode
        case None: return StageMode::None

# ===============================
# Unstage Helper
# ===============================

# Clean up staging resources
pub fn unstage_cleanup(state: Option[StageState]):
    if let Some(s) = state:
        match s.mode:
            case StageMode::Mmap | StageMode::MmapShared:
                if s.mmap_ptr != 0:
                    native_mmap_unmap(s.mmap_ptr, s.mmap_size)
            case _:
                pass

# ===============================
# Mmap Read Helper
# ===============================

# Read from mmap or prefetch buffer for staged reads (sync)
pub fn read_from_staged_sync(
    handle: i64,
    buf: &mut Bytes,
    state: StageState
) -> Option[Result[ByteCount, IoError]]:
    if state.status == StagingStatus::Staged:
        match state.mode:
            case StageMode::Mmap | StageMode::MmapShared:
                let pos = native_file_seek_sync(handle, SeekFrom::Current(0))
                match pos:
                    case Ok(p):
                        let pos_u64 = p as u64
                        let to_read = buf.len().min(state.mmap_size - pos_u64)
                        if to_read > 0:
                            native_mmap_read(state.mmap_ptr, pos_u64, buf, to_read)
                            native_file_seek_sync(handle, SeekFrom::Current(to_read as i64))
                        return Some(Ok(to_read_bytes))
                    case Err(e):
                        return Some(Err(e))
            case StageMode::Prefetch:
                if let Some(prefetch_buf) = state.prefetch_buf:
                    let pos = native_file_seek_sync(handle, SeekFrom::Current(0))
                    match pos:
                        case Ok(p):
                            let pos_u64 = p as u64
                            let to_read = buf.len().min(prefetch_buf.len() - pos_u64)
                            if to_read > 0:
                                buf.copy_from(prefetch_buf.slice(pos_u64, pos_u64 + to_read))
                                native_file_seek_sync(handle, SeekFrom::Current(to_read as i64))
                            return Some(Ok(to_read_bytes))
                        case Err(e):
                            return Some(Err(e))
            case _:
                pass
    return None

# ===============================
# Sync Staging Operations
# ===============================

# Stage file with mmap (sync) - common implementation
pub fn stage_mmap_sync_impl(handle: i64, size_u64: u64) -> Result[StageState, IoError]:
    if size_u64 == 0:
        return Ok(create_empty_staged_state(StageMode::Mmap, false))

    let mmap_ptr = native_mmap_create(handle, size_u64)?
    return Ok(create_staged_mmap_state(StageMode::Mmap, mmap_ptr, size_u64, false))

# Stage file with shared mmap (sync) - common implementation
pub fn stage_mmap_shared_sync_impl(handle: i64, size_u64: u64) -> Result[StageState, IoError]:
    if size_u64 == 0:
        return Ok(create_empty_staged_state(StageMode::MmapShared, true))

    let mmap_ptr = native_mmap_create_shared(handle, size_u64)?
    return Ok(create_staged_mmap_state(StageMode::MmapShared, mmap_ptr, size_u64, true))

# ===============================
# File Close Helper
# ===============================

# Close file with staging cleanup
pub fn close_with_staging(handle: i64, stage_state: Option[StageState]) -> Result[(), IoError]:
    if let Some(state) = stage_state:
        if state.mode == StageMode::Mmap and state.mmap_ptr != 0:
            native_mmap_unmap(state.mmap_ptr, state.mmap_size)
    return native_file_close(handle)

# ===============================
# File Existence Check
# ===============================

# Sync file existence check
pub fn file_exists_sync(path: FilePath) -> bool:
    return native_file_exists_sync(path)

