# Memory-Mapped File Types
#
# Zero-copy memory-mapped file I/O with kernel optimization hints.

use units.file.*
use host.common.io.*

export MmapRegion
export open_mmap, open_mmap_with, open_mmap_sync, open_mmap_sync_with

import file.exists

# Re-export MmapRegion from common module
pub use host.common.io.mmap_common.MmapRegion

# ===============================
# Async Mmap Convenience Functions
# ===============================

# Open file as memory-mapped region (async, returns immediately)
pub async fn open_mmap(path: FilePath) -> Result[MmapRegion, IoError]:
    return open_mmap_with(path, MmapMode::ReadOnly, MmapAdvice::Normal)

# Open file as memory-mapped region with mode and advice (async)
pub async fn open_mmap_with(path: FilePath, mode: MmapMode, advice: MmapAdvice) -> Result[MmapRegion, IoError]:
    # Resolve path
    let resolved_path = native_path_resolve(path)?

    # Check file existence (async)
    if not await exists(resolved_path):
        return Err(IoError::NotFound)

    # Open file
    let open_mode = mmap_mode_to_open_mode(mode)
    let fd = native_fs_open(resolved_path, open_mode)?

    # Get file size
    let size = native_file_get_size(fd)?

    # Create memory mapping
    let mmap_ptr = create_mmap_ptr(fd, size, mode)?

    # Create region
    let region = create_mmap_region(mmap_ptr, size, mode, fd, resolved_path)

    # Apply advice
    if advice != MmapAdvice::Normal:
        region.advise(advice)?

    return Ok(region)

# ===============================
# Sync Mmap Convenience Functions
# ===============================

# Open file as memory-mapped region (sync, blocks until ready)
pub fn open_mmap_sync(path: FilePath) -> Result[MmapRegion, IoError]:
    return open_mmap_sync_with(path, MmapMode::ReadOnly, MmapAdvice::Normal)

# Open file as memory-mapped region (sync) with mode and advice
pub fn open_mmap_sync_with(path: FilePath, mode: MmapMode, advice: MmapAdvice) -> Result[MmapRegion, IoError]:
    return open_mmap_impl(path, mode, advice)

