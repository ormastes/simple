# File System API - Async file operations (Mutable Variant)
# All functions use semantic types - no bare strings!

use units.file.*
use units.size.*
use units.time.*
use host.common.io.error.IoError
use host.common.io.types.*
use core.traits.*

# Directory entries iterator (mutable variant)
struct DirEntries:
    entries: Array[DirEntry]
    index: u64

impl DirEntries:
    fn next(self) -> Option[DirEntry]:
        if self.index >= self.entries.len():
            return None
        let entry = self.entries[self.index]
        self.index = self.index + 1
        return Some(entry)

# ===============================
# Process Management with Staged Files
# ===============================

# Process handle for worker processes
struct ProcessHandle:
    pid: i64
    staged_files: Array[FilePath]

impl ProcessHandle:
    # Wait for process to complete
    pub async fn join(self) -> Result[i64, IoError]:
        return native_process_wait(self.pid)

    # Check if process is still running
    pub fn is_alive(self) -> bool:
        return native_process_is_alive(self.pid)

    # Terminate process
    pub fn kill(self) -> Result[(), IoError]:
        return native_process_kill(self.pid)

# Spawn worker process with pre-staged files (mold-style)
#
# This pre-stages files in the parent process, then spawns a child
# that inherits the memory mappings for zero-copy access.
#
# # Arguments
# * `files` - Files to stage before spawning
# * `mode` - Staging mode (typically MmapShared)
# * `worker_fn` - Function to run in child process
#
# # Returns
# Process handle
pub async fn spawn_worker_with_staging(
    files: Array[FilePath],
    mode: StageMode,
    worker_fn: fn() -> i64
) -> Result[ProcessHandle, IoError]:
    # Stage all files in parent process with SHARED mapping
    let mut staged_handles: Array[i64] = []
    for path in files:
        let file = await File::open_read(path)?

        match mode:
            case StageMode::MmapShared:
                await file.stage_mmap_shared()?
            case StageMode::Mmap:
                # Upgrade to shared for cross-process use
                await file.stage_mmap_shared()?
            case _:
                # Only mmap modes work for cross-process
                return Err(IoError::InvalidArgument)

        # Keep file open so mapping stays alive
        if let Some(state) = file.stage_state:
            staged_handles.push(state.mmap_ptr)

    # Spawn child process - inherits all mmap regions
    let pid = native_spawn_worker(worker_fn)?

    return Ok(ProcessHandle {
        pid: pid,
        staged_files: files
    })

# Spawn multiple workers with same staged files (parallel compilation)
#
# # Example
# ```simple
# let files = ["a.spl"_filepath, "b.spl"_filepath, "c.spl"_filepath]
# let workers = await spawn_workers_with_staging(files, StageMode::MmapShared, 4, compile_worker)?
#
# for worker in workers:
#     await worker.join()?
# ```
pub async fn spawn_workers_with_staging(
    files: Array[FilePath],
    mode: StageMode,
    num_workers: u64,
    worker_fn: fn() -> i64
) -> Result[Array[ProcessHandle], IoError]:
    # Stage all files ONCE in parent
    for path in files:
        let file = await File::open_read(path)?
        await file.stage_mmap_shared()?

    # Spawn N workers - all share the same mappings
    let mut workers: Array[ProcessHandle] = []
    for i in range(num_workers):
        let pid = native_spawn_worker(worker_fn)?
        workers.push(ProcessHandle {
            pid: pid,
            staged_files: files.clone()
        })

    return Ok(workers)

# ===============================
# File Staging Operations
# ===============================

# Stage multiple files with same strategy (module-level function)
#
# This is the simple API - stage a set of files with one call
#
# # Arguments
# * `mode` - Staging mode (Mmap, MmapShared, Prefetch, Adaptive)
# * `files` - Variable number of file paths to stage
#
# # Example
# ```simple
# # Stage files for fast access
# await stage(StageMode::MmapShared,
#     "main.spl"_filepath,
#     "parser.spl"_filepath,
#     "codegen.spl"_filepath)?
# ```
pub async fn stage(mode: StageMode, ...files: FilePath) -> Result[(), IoError]:
    # Stage all files with the specified mode
    for path in files:
        let file = await File::open_read(path)?

        match mode:
            case StageMode::None:
                file.unstage()
            case StageMode::Mmap:
                await file.stage_mmap()?
            case StageMode::MmapShared:
                await file.stage_mmap_shared()?
            case StageMode::Prefetch:
                await file.stage_prefetch()?
            case StageMode::Adaptive:
                await file.stage_auto()?

        # Keep file open so staging remains active
        # Files will be unstaged when they go out of scope

    return Ok(())

# ===============================
# File System Operations
# ===============================

# Read entire file as bytes
pub async fn read(path: FilePath) -> Result[Bytes, IoError]:
    return native_fs_read(path)

# Read entire file as text (UTF-8)
pub async fn read_text(path: FilePath) -> Result[Text, IoError]:
    let bytes = await read(path)?
    match bytes.to_utf8():
        case Ok(s): return Ok(s_text)
        case Err(_): return Err(IoError::InvalidData)

# Write bytes to file (creates or overwrites)
pub async fn write(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]:
    return native_fs_write(path, data)

# Write text to file (UTF-8)
pub async fn write_text(path: FilePath, text: &Text) -> Result[ByteCount, IoError]:
    let bytes = (text as str).to_bytes()
    return await write(path, &bytes)

# Append bytes to file
pub async fn append(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]:
    return native_fs_append(path, data)

# Append text to file
pub async fn append_text(path: FilePath, text: &Text) -> Result[ByteCount, IoError]:
    let bytes = (text as str).to_bytes()
    return await append(path, &bytes)

# ===============================
# Directory Operations
# ===============================

# Create directory
pub async fn create_dir(path: DirPath) -> Result[(), IoError]:
    return native_fs_create_dir(path, false)

# Create directory and all parent directories
pub async fn create_dir_all(path: DirPath) -> Result[(), IoError]:
    return native_fs_create_dir(path, true)

# Remove file
pub async fn remove(path: FilePath) -> Result[(), IoError]:
    return native_fs_remove_file(path)

# Remove empty directory
pub async fn remove_dir(path: DirPath) -> Result[(), IoError]:
    return native_fs_remove_dir(path, false)

# Remove directory and all contents
pub async fn remove_dir_all(path: DirPath) -> Result[(), IoError]:
    return native_fs_remove_dir(path, true)

# Rename file or directory
pub async fn rename(src: FilePath, dst: FilePath) -> Result[(), IoError]:
    return native_fs_rename(src, dst)

# Copy file (standard method)
pub async fn copy(src: FilePath, dst: FilePath) -> Result[ByteCount, IoError]:
    return native_fs_copy(src, dst)

# Zero-copy file transfer using sendfile (Linux/Unix optimization)
pub async fn copy_zero(src: FilePath, dst: FilePath) -> Result[ByteCount, IoError]:
    let src_file = await File::open_read(src)?
    let dst_file = await File::open_write(dst)?

    let size = await src_file.size()?
    let result = native_sendfile(dst_file.handle, src_file.handle, 0, size as u64)?

    await src_file.close()?
    await dst_file.close()?

    return Ok(result)

# ===============================
# Metadata Operations
# ===============================

# Check if path exists
pub async fn exists(path: FilePath) -> bool:
    match native_fs_metadata(path):
        case Ok(_): return true
        case Err(_): return false

# Get file metadata
pub async fn metadata(path: FilePath) -> Result[FileMetadata, IoError]:
    return native_fs_metadata(path)

# List directory contents
pub async fn read_dir(path: DirPath) -> Result[DirEntries, IoError]:
    return native_fs_read_dir(path)

# ===============================
# File Handle Operations
# ===============================

# Staging mode for file operations
enum StageMode:
    # No staging - standard buffered I/O
    None
    # Memory-mapped file - fast random access (process-private)
    Mmap
    # Memory-mapped file - shared across processes
    MmapShared
    # Prefetch entire file into memory
    Prefetch
    # Adaptive - choose based on file size
    Adaptive

# Staging status for lifecycle tracking
enum StagingStatus:
    NotStaged    # No staging operation
    Staging      # Staging in progress (async)
    Staged       # Staging complete

# File staging state
struct StageState:
    mode: StageMode
    status: StagingStatus  # Current staging status
    mmap_ptr: i64        # Memory-mapped region pointer
    mmap_size: u64       # Size of mapped region
    is_shared: bool      # True if mmap is shared across processes
    prefetch_buf: Option[Bytes]  # Prefetched data
    staged_files: Array[FilePath]  # Files staged together

# File handle for streaming operations with staging support
struct File:
    handle: i64
    path: FilePath
    mode: OpenMode
    stage_state: Option[StageState]  # Staging state

impl File:
    # Open file with mode (auto-staging enabled by default)
    pub async fn open(path: FilePath, mode: OpenMode) -> Result[File, IoError]:
        # Resolve relative paths to absolute paths
        let resolved_path = native_path_resolve(path)?

        # Check file existence for read/write modes
        if mode == OpenMode::Read or mode == OpenMode::Write:
            let file_exists = await exists(resolved_path)
            if not file_exists and mode == OpenMode::Read:
                return Err(IoError::NotFound)

        # Open file handle
        let handle = native_fs_open(resolved_path, mode)?
        let mut file = File {
            handle: handle,
            path: resolved_path,
            mode: mode,
            stage_state: None
        }

        # Auto-stage on read mode for performance
        # This is async but we await completion before returning
        if mode == OpenMode::Read:
            await file.stage_auto()?

        return Ok(file)

    # Read convenience methods
    pub async fn open_read(path: FilePath) -> Result[File, IoError]:
        return File::open(path, OpenMode::Read)

    pub async fn open_write(path: FilePath) -> Result[File, IoError]:
        return File::open(path, OpenMode::Write)

    pub async fn create(path: FilePath) -> Result[File, IoError]:
        return File::open(path, OpenMode::Create)

    # Wait for staging to complete if in progress
    # This ensures I/O operations don't start until staging is done
    async fn wait_for_staging(self):
        if let Some(state) = self.stage_state:
            # Busy-wait if staging is in progress
            # In a real implementation, this would use async condition variables
            while state.status == StagingStatus::Staging:
                # Yield to allow staging operation to progress
                await async_yield()

    # Read up to `buf.len()` bytes (optimized with staging)
    pub async fn read(self, buf: &mut Bytes) -> Result[ByteCount, IoError]:
        # Wait for staging to complete if in progress
        await self.wait_for_staging()
        # Use staged data if available
        if let Some(state) = self.stage_state:
            match state.mode:
                case StageMode::Mmap:
                    # Zero-copy read from memory-mapped region (private)
                    let pos_result = await self.position()?
                    let pos = pos_result as u64
                    let to_read = buf.len().min(state.mmap_size - pos)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, pos, buf, to_read)
                        await self.seek(SeekFrom::Current(to_read as i64))?
                    return Ok(to_read_bytes)

                case StageMode::MmapShared:
                    # Zero-copy read from SHARED memory-mapped region
                    let pos_result = await self.position()?
                    let pos = pos_result as u64
                    let to_read = buf.len().min(state.mmap_size - pos)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, pos, buf, to_read)
                        await self.seek(SeekFrom::Current(to_read as i64))?
                    return Ok(to_read_bytes)

                case StageMode::Prefetch:
                    # Read from prefetched buffer
                    if let Some(prefetch) = state.prefetch_buf:
                        let pos_result = await self.position()?
                        let pos = pos_result as u64
                        let to_read = buf.len().min(prefetch.len() - pos)
                        if to_read > 0:
                            buf.copy_from(&prefetch.slice(pos, pos + to_read), 0, to_read)
                            await self.seek(SeekFrom::Current(to_read as i64))?
                        return Ok(to_read_bytes)

                case _:
                    pass  # Fall through to normal read

        # Normal buffered read
        return native_file_read(self.handle, buf)

    # Read exact number of bytes
    pub async fn read_exact(self, buf: &mut Bytes) -> Result[(), IoError]:
        let mut read_total: u64 = 0
        let target = buf.len()
        while read_total < target:
            let remaining = target - read_total
            let slice = buf.slice_mut(read_total, target)
            let n = await self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write bytes
    pub async fn write(self, data: &Bytes) -> Result[ByteCount, IoError]:
        # Wait for staging to complete if in progress
        await self.wait_for_staging()
        return native_file_write(self.handle, data)

    # Write all bytes
    pub async fn write_all(self, data: &Bytes) -> Result[(), IoError]:
        let mut written: u64 = 0
        let total = data.len()
        while written < total:
            let slice = data.slice(written, total)
            let n = await self.write(&slice)?
            written = written + (n as u64)
        return Ok(())

    # Flush buffers
    pub async fn flush(self) -> Result[(), IoError]:
        return native_file_flush(self.handle)

    # Seek position
    pub async fn seek(self, pos: SeekFrom) -> Result[ByteCount, IoError]:
        # Wait for staging to complete if in progress
        await self.wait_for_staging()
        return native_file_seek(self.handle, pos)

    # Get current position
    pub async fn position(self) -> Result[ByteCount, IoError]:
        return self.seek(SeekFrom::Current(0))

    # Get file size
    pub async fn size(self) -> Result[ByteCount, IoError]:
        let current = await self.position()?
        let end = await self.seek(SeekFrom::End(0))?
        await self.seek(SeekFrom::Start(current as u64))?
        return Ok(end)

    # Sync to disk
    pub async fn sync_all(self) -> Result[(), IoError]:
        return native_file_sync(self.handle)

    # Close file
    pub async fn close(self) -> Result[(), IoError]:
        # Clean up staging resources
        if let Some(state) = self.stage_state:
            if state.mode == StageMode::Mmap and state.mmap_ptr != 0:
                native_mmap_unmap(state.mmap_ptr, state.mmap_size)

        return native_file_close(self.handle)

    # ===============================
    # Staging API - Mold-inspired optimizations
    # ===============================

    # Auto-stage file based on size (adaptive strategy)
    pub async fn stage_auto(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::Adaptive,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        # Use mmap for large files (> 1MB), prefetch for small files
        if size_u64 > 1_048_576:  # 1MB threshold
            return self.stage_mmap()
        elif size_u64 > 0:
            return self.stage_prefetch()
        else:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

    # Stage with varargs - stage multiple files with same strategy
    # Usage: file.stage(StageMode::Mmap, file1, file2, file3)
    pub async fn stage(self, mode: StageMode, ...files: FilePath) -> Result[(), IoError]:
        # Mark this file's staging as in progress
        self.stage_state = Some(StageState {
            mode: mode,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        # Stage this file
        match mode:
            case StageMode::None:
                self.unstage()
            case StageMode::Mmap:
                await self.stage_mmap()?
            case StageMode::MmapShared:
                await self.stage_mmap_shared()?
            case StageMode::Prefetch:
                await self.stage_prefetch()?
            case StageMode::Adaptive:
                await self.stage_auto()?

        # Create or update stage state with fileset
        let mut file_paths = Array[FilePath]::new()
        for path in files:
            file_paths.push(path)

        if let Some(state) = self.stage_state:
            state.staged_files = file_paths

        # Stage related files
        for path in files:
            let related = await File::open(path, self.mode)?
            match mode:
                case StageMode::Mmap:
                    await related.stage_mmap()?
                case StageMode::MmapShared:
                    await related.stage_mmap_shared()?
                case StageMode::Prefetch:
                    await related.stage_prefetch()?
                case StageMode::Adaptive:
                    await related.stage_auto()?
                case StageMode::None:
                    related.unstage()
            await related.close()?

        # Mark as fully staged
        if let Some(state) = self.stage_state:
            state.status = StagingStatus::Staged

        return Ok(())

    # Memory-map the file for fast random access (process-private)
    pub async fn stage_mmap(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        # Create memory mapping (private)
        let mmap_ptr = native_mmap_create(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staged,  # Mark as complete
            mmap_ptr: mmap_ptr,
            mmap_size: size_u64,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        return Ok(())

    # Memory-map the file for fast random access (SHARED across processes)
    pub async fn stage_mmap_shared(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: true,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        # Create SHARED memory mapping
        let mmap_ptr = native_mmap_create_shared(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staged,  # Mark as complete
            mmap_ptr: mmap_ptr,
            mmap_size: size_u64,
            is_shared: true,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        return Ok(())

    # Prefetch entire file into memory
    pub async fn stage_prefetch(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        # Read entire file into buffer
        await self.seek(SeekFrom::Start(0))?
        let mut buffer = Bytes::with_capacity(size_u64)
        await self.read_exact(&mut buffer)?
        await self.seek(SeekFrom::Start(0))?  # Reset position

        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staged,  # Mark as complete
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: Some(buffer),
            staged_files: Array[FilePath]::new()
        })

        # Hint to OS for sequential access
        native_fadvise_sequential(self.handle)

        return Ok(())

    # Remove staging (fallback to normal I/O)
    pub fn unstage(self):
        if let Some(state) = self.stage_state:
            if state.mode == StageMode::Mmap and state.mmap_ptr != 0:
                native_mmap_unmap(state.mmap_ptr, state.mmap_size)
        self.stage_state = None

    # Check if file is staged
    pub fn is_staged(self) -> bool:
        return self.stage_state.is_some()

    # Get staging mode
    pub fn stage_mode(self) -> StageMode:
        match self.stage_state:
            case Some(state): return state.mode
            case None: return StageMode::None

# ===============================
# Native function declarations
# ===============================

# Path resolution
extern fn native_path_resolve(path: FilePath) -> Result[FilePath, IoError]

# Async primitives
extern fn async_yield()

# Standard file system operations
extern fn native_fs_read(path: FilePath) -> Result[Bytes, IoError]
extern fn native_fs_write(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]
extern fn native_fs_append(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]
extern fn native_fs_create_dir(path: DirPath, recursive: bool) -> Result[(), IoError]
extern fn native_fs_remove_file(path: FilePath) -> Result[(), IoError]
extern fn native_fs_remove_dir(path: DirPath, recursive: bool) -> Result[(), IoError]
extern fn native_fs_rename(src: FilePath, dst: FilePath) -> Result[(), IoError]
extern fn native_fs_copy(src: FilePath, dst: FilePath) -> Result[ByteCount, IoError]
extern fn native_fs_metadata(path: FilePath) -> Result[FileMetadata, IoError]
extern fn native_fs_read_dir(path: DirPath) -> Result[DirEntries, IoError]

# File handle operations
extern fn native_fs_open(path: FilePath, mode: OpenMode) -> Result[i64, IoError]
extern fn native_file_read(handle: i64, buf: &mut Bytes) -> Result[ByteCount, IoError]
extern fn native_file_write(handle: i64, data: &Bytes) -> Result[ByteCount, IoError]
extern fn native_file_flush(handle: i64) -> Result[(), IoError]
extern fn native_file_seek(handle: i64, pos: SeekFrom) -> Result[ByteCount, IoError]
extern fn native_file_sync(handle: i64) -> Result[(), IoError]
extern fn native_file_close(handle: i64) -> Result[(), IoError]

# Mold-inspired optimizations
# Memory-mapped file operations
extern fn native_mmap_create(handle: i64, size: u64) -> Result[i64, IoError]
extern fn native_mmap_create_shared(handle: i64, size: u64) -> Result[i64, IoError]
extern fn native_mmap_read(ptr: i64, offset: u64, buf: &mut Bytes, len: u64)
extern fn native_mmap_unmap(ptr: i64, size: u64)

# File I/O hints and optimizations
extern fn native_fadvise_sequential(handle: i64)     # Hint for sequential access
extern fn native_fadvise_random(handle: i64)         # Hint for random access
extern fn native_fadvise_willneed(handle: i64)       # Prefetch hint
extern fn native_fadvise_dontneed(handle: i64)       # Cache eviction hint

# Zero-copy operations
extern fn native_sendfile(out_fd: i64, in_fd: i64, offset: u64, count: u64) -> Result[ByteCount, IoError]
extern fn native_copy_file_range(in_fd: i64, out_fd: i64, len: u64) -> Result[ByteCount, IoError]

# Process management with staged files
extern fn native_spawn_worker(worker_fn: fn() -> i64) -> Result[i64, IoError]
extern fn native_process_wait(pid: i64) -> Result[i64, IoError]
extern fn native_process_is_alive(pid: i64) -> bool
extern fn native_process_kill(pid: i64) -> Result[(), IoError]

# ============================================
# Trait Implementations
# ============================================

impl Read for File:
    fn read(self, buf: &mut [u8]) -> Result[usize, IoError]:
        let mut bytes = Bytes::from_slice(buf)
        match native_file_read(self.handle, &mut bytes):
            case Ok(count):
                buf.copy_from_slice(&bytes.as_slice())
                Ok(count as usize)
            case Err(e): Err(e)

impl Write for File:
    fn write(self, buf: &[u8]) -> Result[usize, IoError]:
        let bytes = Bytes::from_slice(buf)
        match native_file_write(self.handle, &bytes):
            case Ok(count): Ok(count as usize)
            case Err(e): Err(e)

    fn flush(self) -> Result[(), IoError]:
        native_file_flush(self.handle)

impl Seek for File:
    fn seek(self, pos: core.traits.SeekFrom) -> Result[u64, IoError]:
        let local_pos = match pos:
            case core.traits.SeekFrom::Start(n): SeekFrom::Start(n)
            case core.traits.SeekFrom::End(n): SeekFrom::End(n)
            case core.traits.SeekFrom::Current(n): SeekFrom::Current(n)
        match native_file_seek(self.handle, local_pos):
            case Ok(count): Ok(count as u64)
            case Err(e): Err(e)

impl Drop for File:
    fn drop(self):
        native_file_close(self.handle)

# DirEntries implements Iterator
impl Iterator for DirEntries:
    type Item = DirEntry
    fn next(self) -> Option[Self::Item]:
        if self.index >= self.entries.len() as u64:
            return None
        let entry = self.entries[self.index as usize]
        self.index = self.index + 1
        return Some(entry)
