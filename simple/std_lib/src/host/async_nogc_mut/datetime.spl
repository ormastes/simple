# DateTime - Date and time types for Simple
# Provides DateTime, Date, Time, and Duration types for temporal operations

# Extern declarations for datetime FFI
extern fn rt_time_now_unix_micros() -> Int
extern fn rt_timestamp_get_year(micros: Int) -> Int
extern fn rt_timestamp_get_month(micros: Int) -> Int
extern fn rt_timestamp_get_day(micros: Int) -> Int
extern fn rt_timestamp_get_hour(micros: Int) -> Int
extern fn rt_timestamp_get_minute(micros: Int) -> Int
extern fn rt_timestamp_get_second(micros: Int) -> Int
extern fn rt_timestamp_get_microsecond(micros: Int) -> Int
extern fn rt_timestamp_from_components(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, microsecond: Int) -> Int
extern fn rt_timestamp_add_days(micros: Int, days: Int) -> Int
extern fn rt_timestamp_diff_days(micros1: Int, micros2: Int) -> Int

# Duration - represents a time span
pub class Duration:
    days: Int
    seconds: Int
    microseconds: Int

    pub fn new(days: Int = 0, hours: Int = 0, minutes: Int = 0,
               seconds: Int = 0, milliseconds: Int = 0, microseconds: Int = 0) -> Duration:
        # Normalize all values to days, seconds, microseconds
        let total_seconds = hours * 3600 + minutes * 60 + seconds
        let total_microseconds = milliseconds * 1000 + microseconds

        # Normalize microseconds to seconds
        let extra_seconds = total_microseconds / 1_000_000
        let final_microseconds = total_microseconds % 1_000_000

        # Normalize seconds to days
        let final_total_seconds = total_seconds + extra_seconds
        let extra_days = final_total_seconds / 86400
        let final_seconds = final_total_seconds % 86400

        return Duration {
            days: days + extra_days,
            seconds: final_seconds,
            microseconds: final_microseconds
        }

    pub fn total_seconds(self) -> Int:
        return self.days * 86400 + self.seconds

    pub fn total_microseconds(self) -> Int:
        return (self.days * 86400 + self.seconds) * 1_000_000 + self.microseconds

    pub fn add(self, other: Duration) -> Duration:
        return Duration.new(
            days=self.days + other.days,
            seconds=self.seconds + other.seconds,
            microseconds=self.microseconds + other.microseconds
        )

    pub fn subtract(self, other: Duration) -> Duration:
        let total_us = self.total_microseconds() - other.total_microseconds()
        let days = total_us / (86400 * 1_000_000)
        let remaining = total_us % (86400 * 1_000_000)
        let seconds = remaining / 1_000_000
        let microseconds = remaining % 1_000_000

        return Duration {
            days: days,
            seconds: seconds,
            microseconds: microseconds
        }

    pub fn multiply(self, scalar: Int) -> Duration:
        let total_us = self.total_microseconds() * scalar
        let days = total_us / (86400 * 1_000_000)
        let remaining = total_us % (86400 * 1_000_000)
        let seconds = remaining / 1_000_000
        let microseconds = remaining % 1_000_000

        return Duration {
            days: days,
            seconds: seconds,
            microseconds: microseconds
        }

    pub fn to_string(self) -> String:
        if self.days != 0:
            return self.days + " days, " + self.seconds + " seconds"
        elif self.seconds != 0:
            return self.seconds + " seconds"
        else:
            return self.microseconds + " microseconds"

# Time - represents time of day (no date component)
pub class Time:
    hour: Int        # 0-23
    minute: Int      # 0-59
    second: Int      # 0-59
    microsecond: Int # 0-999999

    pub fn new(hour: Int = 0, minute: Int = 0, second: Int = 0, microsecond: Int = 0) -> Time:
        # Validate ranges
        if hour < 0 or hour > 23:
            print("Error: hour must be 0-23")
            return Time { hour: 0, minute: 0, second: 0, microsecond: 0 }
        if minute < 0 or minute > 59:
            print("Error: minute must be 0-59")
            return Time { hour: 0, minute: 0, second: 0, microsecond: 0 }
        if second < 0 or second > 59:
            print("Error: second must be 0-59")
            return Time { hour: 0, minute: 0, second: 0, microsecond: 0 }
        if microsecond < 0 or microsecond > 999999:
            print("Error: microsecond must be 0-999999")
            return Time { hour: 0, minute: 0, second: 0, microsecond: 0 }

        return Time {
            hour: hour,
            minute: minute,
            second: second,
            microsecond: microsecond
        }

    pub fn now() -> Time:
        let micros = rt_time_now_unix_micros()
        return Time.new(
            hour=rt_timestamp_get_hour(micros),
            minute=rt_timestamp_get_minute(micros),
            second=rt_timestamp_get_second(micros),
            microsecond=rt_timestamp_get_microsecond(micros)
        )

    pub fn to_seconds(self) -> Int:
        return self.hour * 3600 + self.minute * 60 + self.second

    pub fn to_string(self) -> String:
        let h = if self.hour < 10: "0" + self.hour else: self.hour
        let m = if self.minute < 10: "0" + self.minute else: self.minute
        let s = if self.second < 10: "0" + self.second else: self.second
        return h + ":" + m + ":" + s

    pub fn to_iso_format(self) -> String:
        let h = if self.hour < 10: "0" + self.hour else: self.hour
        let m = if self.minute < 10: "0" + self.minute else: self.minute
        let s = if self.second < 10: "0" + self.second else: self.second
        let us = self.microsecond
        return h + ":" + m + ":" + s + "." + us

# Date - represents a calendar date (no time component)
pub class Date:
    year: Int
    month: Int  # 1-12
    day: Int    # 1-31

    pub fn new(year: Int, month: Int, day: Int) -> Date:
        # Basic validation
        if month < 1 or month > 12:
            print("Error: month must be 1-12")
            return Date { year: 1970, month: 1, day: 1 }
        if day < 1 or day > 31:
            print("Error: day must be 1-31")
            return Date { year: 1970, month: 1, day: 1 }

        return Date {
            year: year,
            month: month,
            day: day
        }

    pub fn today() -> Date:
        let micros = rt_time_now_unix_micros()
        return Date.new(
            rt_timestamp_get_year(micros),
            rt_timestamp_get_month(micros),
            rt_timestamp_get_day(micros)
        )

    pub fn is_leap_year(year: Int) -> Bool:
        if year % 400 == 0:
            return True
        if year % 100 == 0:
            return False
        if year % 4 == 0:
            return True
        return False

    pub fn days_in_month(self) -> Int:
        if self.month == 2:
            if Date.is_leap_year(self.year):
                return 29
            else:
                return 28
        elif self.month in [4, 6, 9, 11]:
            return 30
        else:
            return 31

    pub fn weekday(self) -> Int:
        # Zeller's congruence algorithm
        # Returns 0=Monday, 1=Tuesday, ..., 6=Sunday
        let mut y = self.year
        let mut m = self.month

        if m < 3:
            m = m + 12
            y = y - 1

        let k = y % 100
        let j = y / 100

        let h = (self.day + ((13 * (m + 1)) / 5) + k + (k / 4) + (j / 4) - (2 * j)) % 7

        # Convert to Monday=0 format
        return (h + 5) % 7

    pub fn weekday_name(self) -> String:
        let day = self.weekday()
        if day == 0:
            return "Monday"
        elif day == 1:
            return "Tuesday"
        elif day == 2:
            return "Wednesday"
        elif day == 3:
            return "Thursday"
        elif day == 4:
            return "Friday"
        elif day == 5:
            return "Saturday"
        else:
            return "Sunday"

    pub fn to_string(self) -> String:
        return self.year + "-" + self.month + "-" + self.day

    pub fn to_iso_format(self) -> String:
        let m = if self.month < 10: "0" + self.month else: self.month
        let d = if self.day < 10: "0" + self.day else: self.day
        return self.year + "-" + m + "-" + d

    pub fn add_days(self, days: Int) -> Date:
        # Convert to timestamp, add days, convert back
        let micros = rt_timestamp_from_components(self.year, self.month, self.day, 0, 0, 0, 0)
        let new_micros = rt_timestamp_add_days(micros, days)
        return Date.new(
            rt_timestamp_get_year(new_micros),
            rt_timestamp_get_month(new_micros),
            rt_timestamp_get_day(new_micros)
        )

    pub fn subtract(self, other: Date) -> Int:
        # Return difference in days
        let micros1 = rt_timestamp_from_components(self.year, self.month, self.day, 0, 0, 0, 0)
        let micros2 = rt_timestamp_from_components(other.year, other.month, other.day, 0, 0, 0, 0)
        return rt_timestamp_diff_days(micros1, micros2)

# DateTime - represents a specific point in time
pub class DateTime:
    year: Int
    month: Int
    day: Int
    hour: Int
    minute: Int
    second: Int
    microsecond: Int

    pub fn new(year: Int, month: Int, day: Int,
               hour: Int = 0, minute: Int = 0, second: Int = 0,
               microsecond: Int = 0) -> DateTime:
        return DateTime {
            year: year,
            month: month,
            day: day,
            hour: hour,
            minute: minute,
            second: second,
            microsecond: microsecond
        }

    pub fn now() -> DateTime:
        let micros = rt_time_now_unix_micros()
        return DateTime.new(
            rt_timestamp_get_year(micros),
            rt_timestamp_get_month(micros),
            rt_timestamp_get_day(micros),
            rt_timestamp_get_hour(micros),
            rt_timestamp_get_minute(micros),
            rt_timestamp_get_second(micros),
            rt_timestamp_get_microsecond(micros)
        )

    pub fn from_timestamp(timestamp: Int) -> DateTime:
        # Convert Unix timestamp (microseconds) to DateTime
        return DateTime.new(
            rt_timestamp_get_year(timestamp),
            rt_timestamp_get_month(timestamp),
            rt_timestamp_get_day(timestamp),
            rt_timestamp_get_hour(timestamp),
            rt_timestamp_get_minute(timestamp),
            rt_timestamp_get_second(timestamp),
            rt_timestamp_get_microsecond(timestamp)
        )

    pub fn timestamp(self) -> Int:
        # Convert to Unix timestamp (microseconds)
        return rt_timestamp_from_components(
            self.year, self.month, self.day,
            self.hour, self.minute, self.second, self.microsecond
        )

    pub fn date(self) -> Date:
        return Date.new(self.year, self.month, self.day)

    pub fn time(self) -> Time:
        return Time.new(self.hour, self.minute, self.second, self.microsecond)

    pub fn add(self, duration: Duration) -> DateTime:
        # Add duration to datetime with proper overflow handling
        let current_micros = self.timestamp()
        let duration_micros = duration.total_microseconds()
        let new_micros = current_micros + duration_micros
        return DateTime.from_timestamp(new_micros)

    pub fn subtract_duration(self, duration: Duration) -> DateTime:
        # Subtract duration from datetime with proper underflow handling
        let current_micros = self.timestamp()
        let duration_micros = duration.total_microseconds()
        let new_micros = current_micros - duration_micros
        return DateTime.from_timestamp(new_micros)

    pub fn subtract_datetime(self, other: DateTime) -> Duration:
        # Calculate difference between two datetimes
        let micros1 = self.timestamp()
        let micros2 = other.timestamp()
        let diff_micros = micros1 - micros2

        # Convert microseconds to days, seconds, microseconds
        let days = diff_micros / (86400 * 1_000_000)
        let remaining = diff_micros % (86400 * 1_000_000)
        let seconds = remaining / 1_000_000
        let microseconds = remaining % 1_000_000

        return Duration {
            days: days,
            seconds: seconds,
            microseconds: microseconds
        }

    pub fn to_string(self) -> String:
        return self.year + "-" + self.month + "-" + self.day + " " +
               self.hour + ":" + self.minute + ":" + self.second

    pub fn to_iso_format(self) -> String:
        # ISO 8601 format: YYYY-MM-DDTHH:MM:SS.mmmmmm
        let m = if self.month < 10: "0" + self.month else: self.month
        let d = if self.day < 10: "0" + self.day else: self.day
        let h = if self.hour < 10: "0" + self.hour else: self.hour
        let min = if self.minute < 10: "0" + self.minute else: self.minute
        let s = if self.second < 10: "0" + self.second else: self.second

        return self.year + "-" + m + "-" + d + "T" + h + ":" + min + ":" + s

    pub fn format(self, fmt: String) -> String:
        # Format datetime according to format string
        # Supported codes:
        # %Y - year (4 digits)
        # %m - month (01-12)
        # %d - day (01-31)
        # %H - hour (00-23)
        # %M - minute (00-59)
        # %S - second (00-59)
        # TODO: [stdlib][P1] Implement full strftime format support

        let mut result = fmt
        result = result.replace("%Y", self.year)
        result = result.replace("%m", if self.month < 10: "0" + self.month else: self.month)
        result = result.replace("%d", if self.day < 10: "0" + self.day else: self.day)
        result = result.replace("%H", if self.hour < 10: "0" + self.hour else: self.hour)
        result = result.replace("%M", if self.minute < 10: "0" + self.minute else: self.minute)
        result = result.replace("%S", if self.second < 10: "0" + self.second else: self.second)

        return result

# Parse ISO 8601 date string (YYYY-MM-DD)
pub fn parse_date(s: String) -> Option[Date]:
    # Simple parser for ISO format
    let parts = s.split("-")
    if parts.len() != 3:
        return None

    # TODO: [stdlib][P3] Add proper integer parsing
    # For now, return None
    return None

# Parse ISO 8601 datetime string (YYYY-MM-DDTHH:MM:SS)
pub fn parse_datetime(s: String) -> Option[DateTime]:
    # Simple parser for ISO format
    # TODO: [stdlib][P1] Implement proper ISO 8601 parsing
    return None

# Export all types and functions
export Duration
export Time
export Date
export DateTime
export parse_date
export parse_datetime
