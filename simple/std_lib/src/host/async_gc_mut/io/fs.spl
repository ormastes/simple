# File System API - Async file operations (GC Mutable Variant - DEFAULT)
# Comprehensive file I/O with mmap support and mold-inspired staging
#
# This is the DEFAULT async GC variant - automatic memory management!
#
# Features:
# - Memory-mapped file I/O (zero-copy)
# - Async file handles with background loading
# - File staging for parallel processing
# - Context manager support (with...as syntax)
# - Semantic types (FilePath, DirPath, ByteCount)
# - GC-managed buffers (no manual cleanup needed!)
#
# Quick Start:
#   use host.async_gc_mut.io.fs as fs
#   # OR via top-level API:
#   use io.fs as fs  # Automatically gets this GC version
#
#   # Simple mmap (zero-copy read)
#   async with await fs.open_mmap("data.txt"_filepath) as mmap:
#       let content = mmap.as_str()?
#       # GC handles cleanup automatically!
#
#   # Full file handle with staging
#   let file = await File::open_read("large.bin"_filepath)?
#   await file.stage_mmap()?
#   let buffer = Bytes::with_capacity(4096)  # GC-allocated
#   let n = await file.read(&mut buffer)?
#   # No manual cleanup needed!
#
# GC vs NoGC:
# - GC version: Buffers are automatically managed, no defer/free needed
# - NoGC version: Manual buffer management with defer/free for performance-critical code

use units.file.*
use units.size.*
use units.time.*
use host.common.io.error.IoError
use host.common.io.types.*
use core.traits.*

# ===============================
# Memory-Mapped File Types
# ===============================

# Memory-mapped region - represents a file mapped into memory (zero-copy)
pub struct MmapRegion:
    data: *u8              # Pointer to mapped memory
    length: usize          # Size of mapped region in bytes
    mode: MmapMode         # Access mode (read-only, read-write, etc.)
    fd: i64                # File descriptor
    path: FilePath         # Original file path (for debugging)

impl MmapRegion:
    # Get the mapped data as a byte slice
    pub fn as_bytes(self) -> &[u8]:
        # TODO: Implement via FFI - slice_from_raw_parts
        return []

    # Get the mapped data as a string (UTF-8 validated)
    pub fn as_str(self) -> Result[Text, IoError]:
        let bytes = self.as_bytes()
        match bytes.to_utf8():
            case Ok(s): return Ok(s_text)
            case Err(_): return Err(IoError::InvalidData)

    # Advise kernel on memory access pattern
    pub fn advise(self, advice: MmapAdvice) -> Result[(), IoError]:
        return native_madvise(self.data, self.length, advice)

    # Get the length of the mapped region
    pub fn len(self) -> usize:
        return self.length

    # Check if the region is empty
    pub fn is_empty(self) -> bool:
        return self.length == 0

    # Get a slice of the mapped region
    pub fn slice(self, start: usize, end: usize) -> Result[&[u8], IoError]:
        if start > self.length or end > self.length or start > end:
            return Err(IoError::InvalidArgument)
        # TODO: Return slice
        return Ok([])

    # Close and unmap the region
    pub fn close(self) -> Result[(), IoError]:
        if self.data != null:
            native_mmap_unmap(self.data as i64, self.length as u64)
            native_file_close(self.fd)
        return Ok(())

# Memory map mode
pub enum MmapMode:
    ReadOnly        # MAP_PRIVATE | PROT_READ
    ReadWrite       # MAP_SHARED | PROT_READ | PROT_WRITE
    CopyOnWrite     # MAP_PRIVATE | PROT_READ | PROT_WRITE

impl MmapMode:
    # Get mmap protection flags (for sys_mmap)
    fn get_prot_flags(self) -> i32:
        # PROT_READ = 1, PROT_WRITE = 2
        match self:
            case MmapMode::ReadOnly:
                return 1  # PROT_READ
            case MmapMode::ReadWrite:
                return 3  # PROT_READ | PROT_WRITE
            case MmapMode::CopyOnWrite:
                return 3  # PROT_READ | PROT_WRITE

    # Get mmap flags (for sys_mmap)
    fn get_map_flags(self) -> i32:
        # MAP_SHARED = 1, MAP_PRIVATE = 2
        match self:
            case MmapMode::ReadOnly:
                return 2  # MAP_PRIVATE
            case MmapMode::ReadWrite:
                return 1  # MAP_SHARED
            case MmapMode::CopyOnWrite:
                return 2  # MAP_PRIVATE

# Memory access advice for madvise(2)
pub enum MmapAdvice:
    Normal          # MADV_NORMAL - No specific advice
    Sequential      # MADV_SEQUENTIAL - Expect sequential access
    Random          # MADV_RANDOM - Expect random access
    WillNeed        # MADV_WILLNEED - Expect to access soon (prefault)
    DontNeed        # MADV_DONTNEED - Don't expect to access soon

# ===============================
# Simple Mmap Convenience Functions
# ===============================

# Open file as memory-mapped region (async, returns immediately)
pub async fn open_mmap(path: FilePath) -> Result[MmapRegion, IoError]:
    return open_mmap_with(path, MmapMode::ReadOnly, MmapAdvice::Normal)

# Open file as memory-mapped region with mode and advice
pub async fn open_mmap_with(path: FilePath, mode: MmapMode, advice: MmapAdvice) -> Result[MmapRegion, IoError]:
    # Resolve path
    let resolved_path = native_path_resolve(path)?

    # Check file existence
    if not await exists(resolved_path):
        return Err(IoError::NotFound)

    # Open file
    let open_mode = match mode:
        case MmapMode::ReadOnly: OpenMode::Read
        case MmapMode::ReadWrite: OpenMode::Write
        case MmapMode::CopyOnWrite: OpenMode::Read

    let fd = native_fs_open(resolved_path, open_mode)?

    # Get file size
    let size = native_file_get_size(fd)?

    # Create memory mapping
    let mmap_ptr = match mode:
        case MmapMode::ReadWrite:
            native_mmap_create_shared(fd, size)?  # Shared for read-write
        case _:
            native_mmap_create(fd, size)?  # Private for read-only/COW

    # Create region
    let region = MmapRegion {
        data: mmap_ptr as *u8,
        length: size as usize,
        mode: mode,
        fd: fd,
        path: resolved_path
    }

    # Apply advice
    if advice != MmapAdvice::Normal:
        region.advise(advice)?

    return Ok(region)

# Open file as memory-mapped region (sync, blocks until ready)
pub fn open_mmap_sync(path: FilePath) -> Result[MmapRegion, IoError]:
    return open_mmap_sync_with(path, MmapMode::ReadOnly, MmapAdvice::Normal)

# Open file as memory-mapped region (sync) with mode and advice
pub fn open_mmap_sync_with(path: FilePath, mode: MmapMode, advice: MmapAdvice) -> Result[MmapRegion, IoError]:
    # Resolve path
    let resolved_path = native_path_resolve(path)?

    # Check file existence (sync version)
    let file_exists = native_file_exists_sync(resolved_path)
    if not file_exists:
        return Err(IoError::NotFound)

    # Open file
    let open_mode = match mode:
        case MmapMode::ReadOnly: OpenMode::Read
        case MmapMode::ReadWrite: OpenMode::Write
        case MmapMode::CopyOnWrite: OpenMode::Read

    let fd = native_fs_open(resolved_path, open_mode)?

    # Get file size
    let size = native_file_get_size(fd)?

    # Create memory mapping
    let mmap_ptr = match mode:
        case MmapMode::ReadWrite:
            native_mmap_create_shared(fd, size)?
        case _:
            native_mmap_create(fd, size)?

    # Create region
    let region = MmapRegion {
        data: mmap_ptr as *u8,
        length: size as usize,
        mode: mode,
        fd: fd,
        path: resolved_path
    }

    # Apply advice
    if advice != MmapAdvice::Normal:
        region.advise(advice)?

    return Ok(region)

# ===============================
# Existing Types
# ===============================

# Directory entries iterator (mutable variant)
struct DirEntries:
    entries: Array[DirEntry]
    index: u64

impl DirEntries:
    fn next(self) -> Option[DirEntry]:
        if self.index >= self.entries.len():
            return None
        let entry = self.entries[self.index]
        self.index = self.index + 1
        return Some(entry)

# ===============================
# Process Management with Staged Files
# ===============================

# Process handle for worker processes
struct ProcessHandle:
    pid: i64
    staged_files: Array[FilePath]

impl ProcessHandle:
    # Wait for process to complete
    pub async fn join(self) -> Result[i64, IoError]:
        return native_process_wait(self.pid)

    # Check if process is still running
    pub fn is_alive(self) -> bool:
        return native_process_is_alive(self.pid)

    # Terminate process
    pub fn kill(self) -> Result[(), IoError]:
        return native_process_kill(self.pid)

# Spawn worker process with pre-staged files (mold-style)
#
# This pre-stages files in the parent process, then spawns a child
# that inherits the memory mappings for zero-copy access.
#
# # Arguments
# * `files` - Files to stage before spawning
# * `mode` - Staging mode (typically MmapShared)
# * `worker_fn` - Function to run in child process
#
# # Returns
# Process handle
pub async fn spawn_worker_with_staging(
    files: Array[FilePath],
    mode: StageMode,
    worker_fn: fn() -> i64
) -> Result[ProcessHandle, IoError]:
    # Stage all files in parent process with SHARED mapping
    let mut staged_handles: Array[i64] = []
    for path in files:
        let file = await File::open_read(path)?

        match mode:
            case StageMode::MmapShared:
                await file.stage_mmap_shared()?
            case StageMode::Mmap:
                # Upgrade to shared for cross-process use
                await file.stage_mmap_shared()?
            case _:
                # Only mmap modes work for cross-process
                return Err(IoError::InvalidArgument)

        # Keep file open so mapping stays alive
        if let Some(state) = file.stage_state:
            staged_handles.push(state.mmap_ptr)

    # Spawn child process - inherits all mmap regions
    let pid = native_spawn_worker(worker_fn)?

    return Ok(ProcessHandle {
        pid: pid,
        staged_files: files
    })

# Spawn multiple workers with same staged files (parallel compilation)
#
# # Example
# ```simple
# let files = ["a.spl"_filepath, "b.spl"_filepath, "c.spl"_filepath]
# let workers = await spawn_workers_with_staging(files, StageMode::MmapShared, 4, compile_worker)?
#
# for worker in workers:
#     await worker.join()?
# ```
pub async fn spawn_workers_with_staging(
    files: Array[FilePath],
    mode: StageMode,
    num_workers: u64,
    worker_fn: fn() -> i64
) -> Result[Array[ProcessHandle], IoError]:
    # Stage all files ONCE in parent
    for path in files:
        let file = await File::open_read(path)?
        await file.stage_mmap_shared()?

    # Spawn N workers - all share the same mappings
    let mut workers: Array[ProcessHandle] = []
    for i in range(num_workers):
        let pid = native_spawn_worker(worker_fn)?
        workers.push(ProcessHandle {
            pid: pid,
            staged_files: files.clone()
        })

    return Ok(workers)

# ===============================
# File Staging Operations
# ===============================

# Stage multiple files with same strategy (module-level function)
#
# This is the simple API - stage a set of files with one call
#
# # Arguments
# * `mode` - Staging mode (Mmap, MmapShared, Prefetch, Adaptive)
# * `files` - Variable number of file paths to stage
#
# # Example
# ```simple
# # Stage files for fast access
# await stage(StageMode::MmapShared,
#     "main.spl"_filepath,
#     "parser.spl"_filepath,
#     "codegen.spl"_filepath)?
# ```
pub async fn stage(mode: StageMode, ...files: FilePath) -> Result[(), IoError]:
    # Stage all files with the specified mode
    for path in files:
        let file = await File::open_read(path)?

        match mode:
            case StageMode::None:
                file.unstage()
            case StageMode::Mmap:
                await file.stage_mmap()?
            case StageMode::MmapShared:
                await file.stage_mmap_shared()?
            case StageMode::Prefetch:
                await file.stage_prefetch()?
            case StageMode::Adaptive:
                await file.stage_auto()?

        # Keep file open so staging remains active
        # Files will be unstaged when they go out of scope

    return Ok(())

# ===============================
# File System Operations
# ===============================

# Read entire file as bytes
pub async fn read(path: FilePath) -> Result[Bytes, IoError]:
    return native_fs_read(path)

# Read entire file as text (UTF-8)
pub async fn read_text(path: FilePath) -> Result[Text, IoError]:
    let bytes = await read(path)?
    match bytes.to_utf8():
        case Ok(s): return Ok(s_text)
        case Err(_): return Err(IoError::InvalidData)

# Write bytes to file (creates or overwrites)
pub async fn write(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]:
    return native_fs_write(path, data)

# Write text to file (UTF-8)
pub async fn write_text(path: FilePath, text: &Text) -> Result[ByteCount, IoError]:
    let bytes = (text as str).to_bytes()
    return await write(path, &bytes)

# Append bytes to file
pub async fn append(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]:
    return native_fs_append(path, data)

# Append text to file
pub async fn append_text(path: FilePath, text: &Text) -> Result[ByteCount, IoError]:
    let bytes = (text as str).to_bytes()
    return await append(path, &bytes)

# ===============================
# Directory Operations
# ===============================

# Create directory
pub async fn create_dir(path: DirPath) -> Result[(), IoError]:
    return native_fs_create_dir(path, false)

# Create directory and all parent directories
pub async fn create_dir_all(path: DirPath) -> Result[(), IoError]:
    return native_fs_create_dir(path, true)

# Remove file
pub async fn remove(path: FilePath) -> Result[(), IoError]:
    return native_fs_remove_file(path)

# Remove empty directory
pub async fn remove_dir(path: DirPath) -> Result[(), IoError]:
    return native_fs_remove_dir(path, false)

# Remove directory and all contents
pub async fn remove_dir_all(path: DirPath) -> Result[(), IoError]:
    return native_fs_remove_dir(path, true)

# Rename file or directory
pub async fn rename(src: FilePath, dst: FilePath) -> Result[(), IoError]:
    return native_fs_rename(src, dst)

# Copy file (standard method)
pub async fn copy(src: FilePath, dst: FilePath) -> Result[ByteCount, IoError]:
    return native_fs_copy(src, dst)

# Zero-copy file transfer using sendfile (Linux/Unix optimization)
pub async fn copy_zero(src: FilePath, dst: FilePath) -> Result[ByteCount, IoError]:
    let src_file = await File::open_read(src)?
    let dst_file = await File::open_write(dst)?

    let size = await src_file.size()?
    let result = native_sendfile(dst_file.handle, src_file.handle, 0, size as u64)?

    await src_file.close()?
    await dst_file.close()?

    return Ok(result)

# ===============================
# Metadata Operations
# ===============================

# Check if path exists
pub async fn exists(path: FilePath) -> bool:
    match native_fs_metadata(path):
        case Ok(_): return true
        case Err(_): return false

# Get file metadata
pub async fn metadata(path: FilePath) -> Result[FileMetadata, IoError]:
    return native_fs_metadata(path)

# List directory contents
pub async fn read_dir(path: DirPath) -> Result[DirEntries, IoError]:
    return native_fs_read_dir(path)

# ===============================
# File Handle Operations
# ===============================

# Staging mode for file operations
enum StageMode:
    # No staging - standard buffered I/O
    None
    # Memory-mapped file - fast random access (process-private)
    Mmap
    # Memory-mapped file - shared across processes
    MmapShared
    # Prefetch entire file into memory
    Prefetch
    # Adaptive - choose based on file size
    Adaptive

# Staging status for lifecycle tracking
enum StagingStatus:
    NotStaged    # No staging operation
    Staging      # Staging in progress (async)
    Staged       # Staging complete

# File staging state
struct StageState:
    mode: StageMode
    status: StagingStatus  # Current staging status
    mmap_ptr: i64        # Memory-mapped region pointer
    mmap_size: u64       # Size of mapped region
    is_shared: bool      # True if mmap is shared across processes
    prefetch_buf: Option[Bytes]  # Prefetched data
    staged_files: Array[FilePath]  # Files staged together

# File handle for streaming operations with staging support
struct File:
    handle: i64
    path: FilePath
    mode: OpenMode
    stage_state: Option[StageState]  # Staging state

impl File:
    # Open file with mode (auto-staging enabled by default)
    pub async fn open(path: FilePath, mode: OpenMode) -> Result[File, IoError]:
        # Resolve relative paths to absolute paths
        let resolved_path = native_path_resolve(path)?

        # Check file existence for read/write modes
        if mode == OpenMode::Read or mode == OpenMode::Write:
            let file_exists = await exists(resolved_path)
            if not file_exists and mode == OpenMode::Read:
                return Err(IoError::NotFound)

        # Open file handle
        let handle = native_fs_open(resolved_path, mode)?
        let mut file = File {
            handle: handle,
            path: resolved_path,
            mode: mode,
            stage_state: None
        }

        # Auto-stage on read mode for performance
        # This is async but we await completion before returning
        if mode == OpenMode::Read:
            await file.stage_auto()?

        return Ok(file)

    # Read convenience methods
    pub async fn open_read(path: FilePath) -> Result[File, IoError]:
        return File::open(path, OpenMode::Read)

    pub async fn open_write(path: FilePath) -> Result[File, IoError]:
        return File::open(path, OpenMode::Write)

    pub async fn create(path: FilePath) -> Result[File, IoError]:
        return File::open(path, OpenMode::Create)

    # Wait for staging to complete if in progress
    # This ensures I/O operations don't start until staging is done
    async fn wait_for_staging(self):
        if let Some(state) = self.stage_state:
            # Busy-wait if staging is in progress
            # In a real implementation, this would use async condition variables
            while state.status == StagingStatus::Staging:
                # Yield to allow staging operation to progress
                await async_yield()

    # Read up to `buf.len()` bytes (optimized with staging)
    pub async fn read(self, buf: &mut Bytes) -> Result[ByteCount, IoError]:
        # Wait for staging to complete if in progress
        await self.wait_for_staging()
        # Use staged data if available
        if let Some(state) = self.stage_state:
            match state.mode:
                case StageMode::Mmap:
                    # Zero-copy read from memory-mapped region (private)
                    let pos_result = await self.position()?
                    let pos = pos_result as u64
                    let to_read = buf.len().min(state.mmap_size - pos)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, pos, buf, to_read)
                        await self.seek(SeekFrom::Current(to_read as i64))?
                    return Ok(to_read_bytes)

                case StageMode::MmapShared:
                    # Zero-copy read from SHARED memory-mapped region
                    let pos_result = await self.position()?
                    let pos = pos_result as u64
                    let to_read = buf.len().min(state.mmap_size - pos)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, pos, buf, to_read)
                        await self.seek(SeekFrom::Current(to_read as i64))?
                    return Ok(to_read_bytes)

                case StageMode::Prefetch:
                    # Read from prefetched buffer
                    if let Some(prefetch) = state.prefetch_buf:
                        let pos_result = await self.position()?
                        let pos = pos_result as u64
                        let to_read = buf.len().min(prefetch.len() - pos)
                        if to_read > 0:
                            buf.copy_from(&prefetch.slice(pos, pos + to_read), 0, to_read)
                            await self.seek(SeekFrom::Current(to_read as i64))?
                        return Ok(to_read_bytes)

                case _:
                    pass  # Fall through to normal read

        # Normal buffered read
        return native_file_read(self.handle, buf)

    # Read exact number of bytes
    pub async fn read_exact(self, buf: &mut Bytes) -> Result[(), IoError]:
        let mut read_total: u64 = 0
        let target = buf.len()
        while read_total < target:
            let remaining = target - read_total
            let slice = buf.slice_mut(read_total, target)
            let n = await self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write bytes
    pub async fn write(self, data: &Bytes) -> Result[ByteCount, IoError]:
        # Wait for staging to complete if in progress
        await self.wait_for_staging()
        return native_file_write(self.handle, data)

    # Write all bytes
    pub async fn write_all(self, data: &Bytes) -> Result[(), IoError]:
        let mut written: u64 = 0
        let total = data.len()
        while written < total:
            let slice = data.slice(written, total)
            let n = await self.write(&slice)?
            written = written + (n as u64)
        return Ok(())

    # Flush buffers
    pub async fn flush(self) -> Result[(), IoError]:
        return native_file_flush(self.handle)

    # Seek position
    pub async fn seek(self, pos: SeekFrom) -> Result[ByteCount, IoError]:
        # Wait for staging to complete if in progress
        await self.wait_for_staging()
        return native_file_seek(self.handle, pos)

    # Get current position
    pub async fn position(self) -> Result[ByteCount, IoError]:
        return self.seek(SeekFrom::Current(0))

    # Get file size
    pub async fn size(self) -> Result[ByteCount, IoError]:
        let current = await self.position()?
        let end = await self.seek(SeekFrom::End(0))?
        await self.seek(SeekFrom::Start(current as u64))?
        return Ok(end)

    # Sync to disk
    pub async fn sync_all(self) -> Result[(), IoError]:
        return native_file_sync(self.handle)

    # Close file
    pub async fn close(self) -> Result[(), IoError]:
        # Clean up staging resources
        if let Some(state) = self.stage_state:
            if state.mode == StageMode::Mmap and state.mmap_ptr != 0:
                native_mmap_unmap(state.mmap_ptr, state.mmap_size)

        return native_file_close(self.handle)

    # ===============================
    # Staging API - Mold-inspired optimizations
    # ===============================

    # Auto-stage file based on size (adaptive strategy)
    pub async fn stage_auto(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::Adaptive,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        # Use mmap for large files (> 1MB), prefetch for small files
        if size_u64 > 1_048_576:  # 1MB threshold
            return self.stage_mmap()
        elif size_u64 > 0:
            return self.stage_prefetch()
        else:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

    # Stage with varargs - stage multiple files with same strategy
    # Usage: file.stage(StageMode::Mmap, file1, file2, file3)
    pub async fn stage(self, mode: StageMode, ...files: FilePath) -> Result[(), IoError]:
        # Mark this file's staging as in progress
        self.stage_state = Some(StageState {
            mode: mode,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        # Stage this file
        match mode:
            case StageMode::None:
                self.unstage()
            case StageMode::Mmap:
                await self.stage_mmap()?
            case StageMode::MmapShared:
                await self.stage_mmap_shared()?
            case StageMode::Prefetch:
                await self.stage_prefetch()?
            case StageMode::Adaptive:
                await self.stage_auto()?

        # Create or update stage state with fileset
        let mut file_paths = Array[FilePath]::new()
        for path in files:
            file_paths.push(path)

        if let Some(state) = self.stage_state:
            state.staged_files = file_paths

        # Stage related files
        for path in files:
            let related = await File::open(path, self.mode)?
            match mode:
                case StageMode::Mmap:
                    await related.stage_mmap()?
                case StageMode::MmapShared:
                    await related.stage_mmap_shared()?
                case StageMode::Prefetch:
                    await related.stage_prefetch()?
                case StageMode::Adaptive:
                    await related.stage_auto()?
                case StageMode::None:
                    related.unstage()
            await related.close()?

        # Mark as fully staged
        if let Some(state) = self.stage_state:
            state.status = StagingStatus::Staged

        return Ok(())

    # Memory-map the file for fast random access (process-private)
    pub async fn stage_mmap(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        # Create memory mapping (private)
        let mmap_ptr = native_mmap_create(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staged,  # Mark as complete
            mmap_ptr: mmap_ptr,
            mmap_size: size_u64,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        return Ok(())

    # Memory-map the file for fast random access (SHARED across processes)
    pub async fn stage_mmap_shared(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: true,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        # Create SHARED memory mapping
        let mmap_ptr = native_mmap_create_shared(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staged,  # Mark as complete
            mmap_ptr: mmap_ptr,
            mmap_size: size_u64,
            is_shared: true,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        return Ok(())

    # Prefetch entire file into memory
    pub async fn stage_prefetch(self) -> Result[(), IoError]:
        # Mark staging as in progress
        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: None,
            staged_files: Array[FilePath]::new()
        })

        let size = await self.size()?
        let size_u64 = size as u64

        if size_u64 == 0:
            # Mark as staged (nothing to do for empty files)
            if let Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        # Read entire file into buffer
        await self.seek(SeekFrom::Start(0))?
        let mut buffer = Bytes::with_capacity(size_u64)
        await self.read_exact(&mut buffer)?
        await self.seek(SeekFrom::Start(0))?  # Reset position

        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staged,  # Mark as complete
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: Some(buffer),
            staged_files: Array[FilePath]::new()
        })

        # Hint to OS for sequential access
        native_fadvise_sequential(self.handle)

        return Ok(())

    # Remove staging (fallback to normal I/O)
    pub fn unstage(self):
        if let Some(state) = self.stage_state:
            if state.mode == StageMode::Mmap and state.mmap_ptr != 0:
                native_mmap_unmap(state.mmap_ptr, state.mmap_size)
        self.stage_state = None

    # Check if file is staged
    pub fn is_staged(self) -> bool:
        return self.stage_state.is_some()

    # Get staging mode
    pub fn stage_mode(self) -> StageMode:
        match self.stage_state:
            case Some(state): return state.mode
            case None: return StageMode::None

# ===============================
# Native function declarations
# ===============================

# Path resolution
extern fn native_path_resolve(path: FilePath) -> Result[FilePath, IoError]

# Async primitives
extern fn async_yield()

# Standard file system operations
extern fn native_fs_read(path: FilePath) -> Result[Bytes, IoError]
extern fn native_fs_write(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]
extern fn native_fs_append(path: FilePath, data: &Bytes) -> Result[ByteCount, IoError]
extern fn native_fs_create_dir(path: DirPath, recursive: bool) -> Result[(), IoError]
extern fn native_fs_remove_file(path: FilePath) -> Result[(), IoError]
extern fn native_fs_remove_dir(path: DirPath, recursive: bool) -> Result[(), IoError]
extern fn native_fs_rename(src: FilePath, dst: FilePath) -> Result[(), IoError]
extern fn native_fs_copy(src: FilePath, dst: FilePath) -> Result[ByteCount, IoError]
extern fn native_fs_metadata(path: FilePath) -> Result[FileMetadata, IoError]
extern fn native_fs_read_dir(path: DirPath) -> Result[DirEntries, IoError]

# File handle operations
extern fn native_fs_open(path: FilePath, mode: OpenMode) -> Result[i64, IoError]
extern fn native_file_read(handle: i64, buf: &mut Bytes) -> Result[ByteCount, IoError]
extern fn native_file_write(handle: i64, data: &Bytes) -> Result[ByteCount, IoError]
extern fn native_file_flush(handle: i64) -> Result[(), IoError]
extern fn native_file_seek(handle: i64, pos: SeekFrom) -> Result[ByteCount, IoError]
extern fn native_file_sync(handle: i64) -> Result[(), IoError]
extern fn native_file_close(handle: i64) -> Result[(), IoError]

# Mold-inspired optimizations
# Memory-mapped file operations
extern fn native_mmap_create(handle: i64, size: u64) -> Result[i64, IoError]
extern fn native_mmap_create_shared(handle: i64, size: u64) -> Result[i64, IoError]
extern fn native_mmap_read(ptr: i64, offset: u64, buf: &mut Bytes, len: u64)
extern fn native_mmap_unmap(ptr: i64, size: u64)

# File I/O hints and optimizations
extern fn native_fadvise_sequential(handle: i64)     # Hint for sequential access
extern fn native_fadvise_random(handle: i64)         # Hint for random access
extern fn native_fadvise_willneed(handle: i64)       # Prefetch hint
extern fn native_fadvise_dontneed(handle: i64)       # Cache eviction hint

# Zero-copy operations
extern fn native_sendfile(out_fd: i64, in_fd: i64, offset: u64, count: u64) -> Result[ByteCount, IoError]
extern fn native_copy_file_range(in_fd: i64, out_fd: i64, len: u64) -> Result[ByteCount, IoError]

# Process management with staged files
extern fn native_spawn_worker(worker_fn: fn() -> i64) -> Result[i64, IoError]
extern fn native_process_wait(pid: i64) -> Result[i64, IoError]
extern fn native_process_is_alive(pid: i64) -> bool
extern fn native_process_kill(pid: i64) -> Result[(), IoError]

# Mmap-specific operations
extern fn native_madvise(addr: *u8, length: usize, advice: MmapAdvice) -> Result[(), IoError]
extern fn native_file_get_size(fd: i64) -> Result[u64, IoError]
extern fn native_file_exists_sync(path: FilePath) -> bool

# ============================================
# Trait Implementations
# ============================================

impl Read for File:
    fn read(self, buf: &mut [u8]) -> Result[usize, IoError]:
        let mut bytes = Bytes::from_slice(buf)
        match native_file_read(self.handle, &mut bytes):
            case Ok(count):
                buf.copy_from_slice(&bytes.as_slice())
                Ok(count as usize)
            case Err(e): Err(e)

impl Write for File:
    fn write(self, buf: &[u8]) -> Result[usize, IoError]:
        let bytes = Bytes::from_slice(buf)
        match native_file_write(self.handle, &bytes):
            case Ok(count): Ok(count as usize)
            case Err(e): Err(e)

    fn flush(self) -> Result[(), IoError]:
        native_file_flush(self.handle)

impl Seek for File:
    fn seek(self, pos: core.traits.SeekFrom) -> Result[u64, IoError]:
        let local_pos = match pos:
            case core.traits.SeekFrom::Start(n): SeekFrom::Start(n)
            case core.traits.SeekFrom::End(n): SeekFrom::End(n)
            case core.traits.SeekFrom::Current(n): SeekFrom::Current(n)
        match native_file_seek(self.handle, local_pos):
            case Ok(count): Ok(count as u64)
            case Err(e): Err(e)

impl Drop for File:
    fn drop(self):
        native_file_close(self.handle)

# DirEntries implements Iterator
impl Iterator for DirEntries:
    type Item = DirEntry
    fn next(self) -> Option[Self::Item]:
        if self.index >= self.entries.len() as u64:
            return None
        let entry = self.entries[self.index as usize]
        self.index = self.index + 1
        return Some(entry)

# ===============================
# Context Manager Support (with...as syntax)
# ===============================

# Sync context manager trait
pub trait ContextManager[T]:
    fn __enter__(self) -> T
    fn __exit__(self, exc: Option[Exception]) -> bool

# Async context manager trait
pub trait AsyncContextManager[T]:
    async fn __aenter__(self) -> T
    async fn __aexit__(self, exc: Option[Exception]) -> bool

# Context manager for MmapRegion (sync)
# Usage: with open_mmap_sync("data.txt"_filepath) as mmap:
impl ContextManager[MmapRegion] for MmapRegion:
    fn __enter__(self) -> MmapRegion:
        return self

    fn __exit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: unmap the memory region
        let _ = self.close()
        return false  # Don't suppress exceptions

# Async context manager for MmapRegion
# Usage: async with await open_mmap("data.txt"_filepath) as mmap:
impl AsyncContextManager[MmapRegion] for MmapRegion:
    async fn __aenter__(self) -> MmapRegion:
        return self

    async fn __aexit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: unmap the memory region
        let _ = self.close()
        return false  # Don't suppress exceptions

# Async context manager for File
# Usage: async with await File::open_read("data.txt"_filepath) as file:
impl AsyncContextManager[File] for File:
    async fn __aenter__(self) -> File:
        return self

    async fn __aexit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: close file and clean up staging resources
        let _ = await self.close()
        return false  # Don't suppress exceptions

# Exception type for context managers
# (Should be defined in core error system, this is placeholder)
pub struct Exception:
    message: String

impl Exception:
    pub fn new(message: String) -> Exception:
        return Exception { message: message }
