# ============================================================================
# Call Tracking
# ============================================================================

struct CallRecord:
    args: List<text>
    timestamp: i64
    call_number: i32

# ============================================================================
# Mock Function Tracker
# ============================================================================

class MockFunction:
    name: text
    calls: List<CallRecord>
    return_values: List<text>
    return_index: i32
    should_panic: bool
    panic_message: text
    expectations: List<Expectation>

    static fn new(name: text) -> MockFunction:
        MockFunction(
            name: name,
            calls: [],
            return_values: [],
            return_index: 0,
            should_panic: false,
            panic_message: "",
            expectations: []
        )

    me record_call(args: List<text>):
        val record = CallRecord(
            args: args,
            timestamp: 0,
            call_number: self.calls.len() as i32
        )
        self.calls.append(record)

    me set_return_values(values: List<text>):
        self.return_values = values
        self.return_index = 0

    me set_panic(message: text):
        self.should_panic = true
        self.panic_message = message

    fn next_return_value() -> Option<text>:
        if self.return_index >= self.return_values.len() as i32:
            return nil
        val value = self.return_values[self.return_index as usize]
        self.return_index = self.return_index + 1
        Some(value)

    fn call_count() -> i32:
        self.calls.len() as i32

    fn was_called() -> bool:
        self.calls.len() > 0

    fn was_called_with(expected_args: List<text>) -> bool:
        for call in self.calls:
            if call.args.len() == expected_args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != expected_args[i]:
                        matches = false
                        break
                if matches:
                    return true
        false

    fn was_called_n_times(times: i32) -> bool:
        self.call_count() == times

    fn get_call(index: i32) -> Option<CallRecord>:
        if index >= 0 and index < self.calls.len() as i32:
            Some(self.calls[index as usize])
        else:
            nil

    fn get_last_call() -> Option<CallRecord>:
        if self.calls.len() > 0:
            Some(self.calls[self.calls.len() - 1])
        else:
            nil

    me reset():
        self.calls = []
        self.return_values = []
        self.return_index = 0
        self.should_panic = false
        self.panic_message = ""
        self.expectations = []

    fn verify() -> VerificationResult:
        for expectation in self.expectations:
            if expectation.expected_times == 0:
                match expectation.expected_args:
                    Some(args):
                        if not self.was_called_with(args):
                            val msg = "Expected '{self.name}' to be called with {args}, but was not"
                            return VerificationResult.failure(msg)
                    nil: true
            else:
                if not self.was_called_n_times(expectation.expected_times):
                    val msg = "Expected '{self.name}' to be called {expectation.expected_times} times, but was called {self.call_count()} times"
                    return VerificationResult.failure(msg)
            match expectation.expected_args:
                Some(args):
                    if not self.was_called_with(args):
                        val msg = "Expected '{self.name}' to be called with {args}, but was not"
                        return VerificationResult.failure(msg)
                nil: true

        VerificationResult.success()

    me expect_call(times: i32):
        self.expectations.append(Expectation(
            method_name: self.name,
            expected_times: times,
            expected_args: nil
        ))

    me expect_call_with(args: List<text>):
        self.expectations.append(Expectation(
            method_name: self.name,
            expected_times: 0,
            expected_args: Some(args)
        ))

    fn summary() -> text:
        if self.calls.len() == 0:
            return "Mock '{self.name}': not called"
        var result = "Mock '{self.name}': called {self.call_count()} time(s)\n"
        for call in self.calls:
            result = result + "  {call.args}\n"
        result

# ============================================================================
# Verification System
# ============================================================================

struct Expectation:
    method_name: text
    expected_times: i32
    expected_args: Option<List<text>>

class VerificationResult:
    passed: bool
    error_message: text

    static fn success() -> VerificationResult:
        VerificationResult(passed: true, error_message: "")

    static fn failure(message: text) -> VerificationResult:
        VerificationResult(passed: false, error_message: message)

    fn is_ok() -> bool:
        self.passed

    fn is_err() -> bool:
        not self.passed

    fn unwrap_err() -> text:
        self.error_message

class Matcher:
    matches_fn: fn(text) -> bool

    static fn any() -> Matcher:
        Matcher(matches_fn: \arg: true)

    static fn eq(value: text) -> Matcher:
        Matcher(matches_fn: \arg: arg == value)

    static fn gt(n: i32) -> Matcher:
        Matcher(matches_fn: \arg:
            match arg.parse_i32():
                Some(v): v > n
                nil: false
        )

    static fn lt(n: i32) -> Matcher:
        Matcher(matches_fn: \arg:
            match arg.parse_i32():
                Some(v): v < n
                nil: false
        )

    static fn gte(n: i32) -> Matcher:
        Matcher(matches_fn: \arg:
            match arg.parse_i32():
                Some(v): v >= n
                nil: false
        )

    static fn lte(n: i32) -> Matcher:
        Matcher(matches_fn: \arg:
            match arg.parse_i32():
                Some(v): v <= n
                nil: false
        )

    static fn contains(substring: text) -> Matcher:
        Matcher(matches_fn: \arg: arg.contains(substring))

    static fn starts_with(prefix: text) -> Matcher:
        Matcher(matches_fn: \arg: arg.starts_with(prefix))

    static fn ends_with(suffix: text) -> Matcher:
        Matcher(matches_fn: \arg: arg.ends_with(suffix))

    static fn and_matcher(m1: Matcher, m2: Matcher) -> Matcher:
        Matcher(matches_fn: \arg: m1.matches(arg) and m2.matches(arg))

    static fn or_matcher(m1: Matcher, m2: Matcher) -> Matcher:
        Matcher(matches_fn: \arg: m1.matches(arg) or m2.matches(arg))

    static fn not_matcher(m: Matcher) -> Matcher:
        Matcher(matches_fn: \arg: not m.matches(arg))

    static fn predicate(fn_pred: fn(text) -> bool) -> Matcher:
        Matcher(matches_fn: fn_pred)

    fn matches(arg: text) -> bool:
        self.matches_fn(arg)

# ============================================================================
# Phase 3: Advanced Features
# ============================================================================

class CallAnalyzer:
    mockfn: MockFunction

    static fn new(mockfn: MockFunction) -> CallAnalyzer:
        CallAnalyzer(mockfn: mockfn)

    fn count_calls_with(args: List<text>) -> i32:
        var count = 0
        for call in self.mockfn.calls:
            if call.args.len() == args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != args[i]:
                        matches = false
                        break
                if matches:
                    count = count + 1
        count

    fn get_calls_matching(matcher_fn: fn(CallRecord) -> bool) -> List<CallRecord>:
        var result = []
        for call in self.mockfn.calls:
            if matcher_fn(call):
                result.append(call)
        result

    fn get_first_call() -> Option<CallRecord>:
        if self.mockfn.calls.len() == 0:
            return nil
        Some(self.mockfn.calls[0])

    fn get_calls_between(start_idx: i32, end_idx: i32) -> List<CallRecord>:
        var result = []
        for i in start_idx..end_idx:
            if i >= 0 and i < self.mockfn.calls.len() as i32:
                result.append(self.mockfn.calls[i as usize])
        result

struct ReturnValue:
    value: text
    times: i32

class SequentialReturns:
    returns: List<ReturnValue>
    current_idx: i32

    static fn new() -> SequentialReturns:
        SequentialReturns(returns: [], current_idx: 0)

    me add_return(value: text, times: i32):
        self.returns.append(ReturnValue(value: value, times: times))

    me add_return_once(value: text):
        self.add_return(value, 1)

    fn next_value() -> Option<text>:
        if self.current_idx >= self.returns.len() as i32:
            return nil
        val current = self.returns[self.current_idx as usize]
        current.times = current.times - 1
        if current.times == 0:
            self.current_idx = self.current_idx + 1
        Some(current.value)

    me reset():
        self.current_idx = 0

class Spy:
    name: text
    calls: List<CallRecord>
    call_count_value: i32

    static fn new(name: text) -> Spy:
        Spy(
            name: name,
            calls: [],
            call_count_value: 0
        )

    me record_call(method: text, args: List<text>):
        val full_args = [method].merge(args)
        val record = CallRecord(
            args: full_args,
            timestamp: 0,
            call_number: self.calls.len() as i32
        )
        self.calls.append(record)
        self.call_count_value = self.call_count_value + 1

    fn get_calls(method: text) -> List<CallRecord>:
        var result = []
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                result.append(call)
        result

    fn method_called(method: text) -> bool:
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                return true
        false

    fn method_call_count(method: text) -> i32:
        var count = 0
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                count = count + 1
        count

    fn total_calls() -> i32:
        self.call_count_value

    fn summary() -> text:
        var result = "Spy '{self.name}': {self.total_calls()} call(s)\n"
        for call in self.calls:
            result = result + "  {call.args}\n"
        result

# ============================================================================
# Mock Builder
# ============================================================================

struct MockBuilder:
    name: text

    static fn new(name: text) -> MockBuilder:
        MockBuilder(name: name)

    fn returns(values: List<text>) -> MockFunction:
        val result = MockFunction.new(self.name)
        result.set_return_values(values)
        result

    fn panics(message: text) -> MockFunction:
        val result = MockFunction.new(self.name)
        result.set_panic(message)
        result

    fn build() -> MockFunction:
        MockFunction.new(self.name)

# ============================================================================
# Mock Registry
# ============================================================================

struct RegistryEntry:
    key: text
    mockfn: MockFunction

class MockRegistry:
    entries: List<RegistryEntry>

    static fn new() -> MockRegistry:
        MockRegistry(entries: [])

    me register(key: text, mockfn: MockFunction):
        self.entries.append(RegistryEntry(key: key, mockfn: mockfn))

    fn get(key: text) -> Option<MockFunction>:
        for entry in self.entries:
            if entry.key == key:
                return Some(entry.mockfn)
        nil

    me reset_all():
        for entry in self.entries:
            entry.mockfn.reset()

    fn verify_all() -> bool:
        true

    fn summary() -> text:
        var result = "Mock Registry:\n"
        for entry in self.entries:
            result = result + "  " + entry.mockfn.summary() + "\n"
        result

# ============================================================================
# Helper Functions
# ============================================================================

pub fn create_mock(name: text) -> MockFunction:
    MockFunction.new(name)

pub fn verify_called(mockfn: MockFunction, times: i32) -> bool:
    mockfn.was_called_n_times(times)

pub fn verify_called_with(mockfn: MockFunction, args: List<text>) -> bool:
    mockfn.was_called_with(args)

# ============================================================================
# Mock Policy System
# ============================================================================

class MockPolicy:
    mode: text
    hal_patterns: List<text>

    static fn new() -> MockPolicy:
        MockPolicy(
            mode: "all",
            hal_patterns: ["hal", "hardware", "drivers", "io"]
        )

    me set_mode(newmode: text):
        self.mode = newmode

    fn is_enabled() -> bool:
        self.mode != "disabled"

    fn is_allowed_in(layer: text) -> bool:
        match self.mode:
            "disabled": false
            "all": true
            "hal_only": self.matches_hal(layer)
            _: false

    fn matches_hal(layer: text) -> bool:
        for pattern in self.hal_patterns:
            if layer.contains(pattern):
                return true
        false

val _global_mock_policy = MockPolicy.new()

pub fn mock_policy_init(mode: text):
    _global_mock_policy.set_mode(mode)

pub fn mock_policy_is_enabled() -> bool:
    _global_mock_policy.is_enabled()

pub fn mock_policy_allow_in_layer(layer: text) -> bool:
    _global_mock_policy.is_allowed_in(layer)

pub fn mock_policy_disable():
    _global_mock_policy.set_mode("disabled")

pub fn mock_policy_reset():
    _global_mock_policy.set_mode("all")

# ============================================================================
# Phase 4: Advanced Patterns (Workarounds without trait objects)
# ============================================================================

struct ConditionalReturn:
    condition: fn(List<text>) -> bool
    value: text

class ConditionalReturns:
    conditions: List<ConditionalReturn>
    default_value: text

    static fn new() -> ConditionalReturns:
        ConditionalReturns(conditions: [], default_value: "")

    me add_condition(condition: fn(List<text>) -> bool, value: text):
        self.conditions.append(ConditionalReturn(condition: condition, value: value))

    me set_default(value: text):
        self.default_value = value

    fn evaluate(args: List<text>) -> text:
        for cond_return in self.conditions:
            if cond_return.condition(args):
                return cond_return.value
        self.default_value

struct CallChain:
    parent_id: i32
    call_record: CallRecord
    child_ids: List<i32>

class CallChainTracker:
    chains: List<CallChain>
    next_id: i32

    static fn new() -> CallChainTracker:
        CallChainTracker(chains: [], next_id: 0)

    me start_chain(parent_id: i32, call: CallRecord) -> i32:
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.chains.append(CallChain(
            parent_id: parent_id,
            call_record: call,
            child_ids: []
        ))
        id

    me add_child(parent_id: i32, child_id: i32):
        for chain in self.chains:
            if chain.parent_id == parent_id:
                chain.child_ids.append(child_id)

    fn get_chain(id: i32) -> Option<CallChain>:
        for chain in self.chains:
            if chain.parent_id == id:
                return Some(chain)
        nil

    fn get_all_chains() -> List<CallChain>:
        self.chains

struct BehaviorState:
    state_name: text
    return_value: text
    next_state: Option<text>

class BehaviorSequence:
    states: List<BehaviorState>
    current_state: text

    static fn new(initial: text) -> BehaviorSequence:
        BehaviorSequence(states: [], current_state: initial)

    me add_state(name: text, return_value: text, next_state: Option<text>):
        self.states.append(BehaviorState(
            state_name: name,
            return_value: return_value,
            next_state: next_state
        ))

    fn transition() -> Option<text>:
        for state in self.states:
            if state.state_name == self.current_state:
                match state.next_state:
                    Some(next): self.current_state = next
                    nil: true
                return Some(state.return_value)
        nil

    fn get_current_state() -> text:
        self.current_state

    me reset_to(state: text):
        self.current_state = state

class MockSnapshot:
    timestamp: i64
    call_count: i32
    last_args: List<text>
    expectations_met: bool

    static fn from_mock(mockfn: MockFunction) -> MockSnapshot:
        var last_args = []
        match mockfn.get_last_call():
            Some(call): last_args = call.args
            nil: true
        MockSnapshot(
            timestamp: 0,
            call_count: mockfn.call_count(),
            last_args: last_args,
            expectations_met: mockfn.verify().is_ok()
        )

    fn summary() -> text:
        "Snapshot: {self.call_count} calls, expectations_met={self.expectations_met}"

class MockComposition:
    mocks: List<MockFunction>

    static fn new() -> MockComposition:
        MockComposition(mocks: [])

    me add_mock(mockfn: MockFunction):
        self.mocks.append(mockfn)

    fn verify_all() -> bool:
        for mockfn in self.mocks:
            val result = mockfn.verify()
            if result.is_err():
                return false
        true

    fn get_total_calls() -> i32:
        var total = 0
        for mockfn in self.mocks:
            total = total + mockfn.call_count()
        total

    fn reset_all():
        for mockfn in self.mocks:
            mockfn.reset()

    fn summary() -> text:
        var result = "MockComposition: {self.mocks.len()} mocks, {self.get_total_calls()} total calls\n"
        for mockfn in self.mocks:
            result = result + "  " + mockfn.summary() + "\n"
        result

# ============================================================================
# Phase 5: Trait-Based Mocking (Using Generics Workaround)
# ============================================================================

struct MethodSignature:
    method_name: text
    arg_types: List<text>
    return_type: text

class FluentExpectation:
    mockfn: MockFunction
    when_args: Option<List<text>>

    static fn new(mockfn: MockFunction) -> FluentExpectation:
        FluentExpectation(mockfn: mockfn, when_args: nil)

    me when_called_with(args: List<text>) -> FluentExpectation:
        self.when_args = Some(args)
        self

    me returns(value: text):
        match self.when_args:
            Some(args):
                var existing_values = []
                for call in self.mockfn.calls:
                    if call.args.len() == args.len():
                        var matches = true
                        for i in 0..call.args.len():
                            if call.args[i] != args[i]:
                                matches = false
                                break
                        if matches:
                            return
                self.mockfn.set_return_values([value])
            nil:
                self.mockfn.set_return_values([value])

class WhenBuilder:
    mockfn: MockFunction
    condition: fn(List<text>) -> bool

    static fn new(mockfn: MockFunction) -> WhenBuilder:
        WhenBuilder(
            mockfn: mockfn,
            condition: \args: true
        )

    me when(predicate: fn(List<text>) -> bool) -> WhenBuilder:
        self.condition = predicate
        self

    me returns(value: text):
        val cond_returns = ConditionalReturns.new()
        cond_returns.add_condition(self.condition, value)
        cond_returns.set_default("")

struct MethodCall:
    method_name: text
    arguments: List<text>
    return_value: text
    call_time: i64

class ProtocolMock:
    method_mocks: List<MethodCall>
    recorded_calls: List<MethodCall>

    static fn new() -> ProtocolMock:
        ProtocolMock(method_mocks: [], recorded_calls: [])

    me mock_method(name: text, args: List<text>, return_value: text):
        self.method_mocks.append(MethodCall(
            method_name: name,
            arguments: args,
            return_value: return_value,
            call_time: 0
        ))

    me record_method_call(name: text, args: List<text>) -> text:
        for method_mock in self.method_mocks:
            if method_mock.method_name == name:
                if method_mock.arguments.len() == args.len():
                    var matches = true
                    for i in 0..method_mock.arguments.len():
                        if method_mock.arguments[i] != args[i]:
                            matches = false
                            break
                    if matches:
                        self.recorded_calls.append(MethodCall(
                            method_name: name,
                            arguments: args,
                            return_value: method_mock.return_value,
                            call_time: 0
                        ))
                        return method_mock.return_value
        ""

    fn verify_method_called(name: text) -> bool:
        for call in self.recorded_calls:
            if call.method_name == name:
                return true
        false

    fn get_method_calls(name: text) -> List<MethodCall>:
        var result = []
        for call in self.recorded_calls:
            if call.method_name == name:
                result.append(call)
        result

    fn reset():
        self.method_mocks = []
        self.recorded_calls = []

class AutoMock:
    name: text
    properties: List<text>
    methods: List<MethodCall>

    static fn new(name: text) -> AutoMock:
        AutoMock(name: name, properties: [], methods: [])

    me add_property(prop_name: text):
        self.properties.append(prop_name)

    me setup_method(method_name: text, args: List<text>, return_value: text):
        self.methods.append(MethodCall(
            method_name: method_name,
            arguments: args,
            return_value: return_value,
            call_time: 0
        ))

    fn call_method(method_name: text, args: List<text>) -> text:
        for method in self.methods:
            if method.method_name == method_name:
                if method.arguments.len() == args.len():
                    var matches = true
                    for i in 0..method.arguments.len():
                        if method.arguments[i] != args[i]:
                            matches = false
                            break
                    if matches:
                        return method.return_value
        ""

    fn get_properties() -> List<text>:
        self.properties

    fn get_methods() -> List<MethodCall>:
        self.methods

    fn summary() -> text:
        var result = "AutoMock '{self.name}':\n"
        result = result + "  Properties: {self.properties.len()}\n"
        result = result + "  Methods: {self.methods.len()}\n"
        result

# ============================================================================
# Phase 6: Async/Await Mocking
# ============================================================================

struct AsyncCallRecord:
    args: List<text>
    timestamp: i64
    call_number: i32
    completion_time: i64
    result: Option<text>
    error: Option<text>
    delay_ms: i32

class AsyncMock:
    name: text
    calls: List<AsyncCallRecord>
    return_values: List<text>
    return_index: i32
    default_delay_ms: i32
    error_mode: bool
    error_message: text

    static fn new(name: text) -> AsyncMock:
        AsyncMock(
            name: name,
            calls: [],
            return_values: [],
            return_index: 0,
            default_delay_ms: 0,
            error_mode: false,
            error_message: ""
        )

    me set_delay(delay_ms: i32):
        self.default_delay_ms = delay_ms

    me set_return_values(values: List<text>):
        self.return_values = values
        self.return_index = 0

    me set_error(message: text):
        self.error_mode = true
        self.error_message = message

    me clear_error():
        self.error_mode = false
        self.error_message = ""

    me record_async_call(args: List<text>) -> text:
        val call_num = self.calls.len() as i32
        var result_value: Option<text> = nil
        var error_value: Option<text> = nil

        if self.error_mode:
            error_value = Some(self.error_message)
        else if self.return_index < self.return_values.len() as i32:
            result_value = Some(self.return_values[self.return_index as usize])
            self.return_index = self.return_index + 1

        val record = AsyncCallRecord(
            args: args,
            timestamp: 0,
            call_number: call_num,
            completion_time: self.default_delay_ms as i64,
            result: result_value,
            error: error_value,
            delay_ms: self.default_delay_ms
        )
        self.calls.append(record)

        match result_value:
            Some(v): v
            nil: ""

    fn call_count() -> i32:
        self.calls.len() as i32

    fn was_called() -> bool:
        self.calls.len() > 0

    fn was_called_with(expected_args: List<text>) -> bool:
        for call in self.calls:
            if call.args.len() == expected_args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != expected_args[i]:
                        matches = false
                        break
                if matches:
                    return true
        false

    fn get_call(index: i32) -> Option<AsyncCallRecord>:
        if index >= 0 and index < self.calls.len() as i32:
            Some(self.calls[index as usize])
        else:
            nil

    fn get_last_call() -> Option<AsyncCallRecord>:
        if self.calls.len() > 0:
            Some(self.calls[self.calls.len() - 1])
        else:
            nil

    fn get_total_delay() -> i32:
        var total = 0
        for call in self.calls:
            total = total + call.delay_ms
        total

    fn get_calls_with_errors() -> List<AsyncCallRecord>:
        var result = []
        for call in self.calls:
            match call.error:
                Some(_): result.append(call)
                nil: true
        result

    me reset():
        self.calls = []
        self.return_values = []
        self.return_index = 0
        self.error_mode = false
        self.error_message = ""

    fn summary() -> text:
        var result = "AsyncMock '{self.name}': {self.call_count()} call(s), total delay: {self.get_total_delay()}ms\n"
        for call in self.calls:
            match call.error:
                Some(err): result = result + "  [ERR] {call.args} -> {err}\n"
                nil:
                    match call.result:
                        Some(r): result = result + "  {call.args} -> {r} ({call.delay_ms}ms)\n"
                        nil: result = result + "  {call.args} -> (no result)\n"
        result

struct PromiseReturn:
    value: text
    delay_ms: i32
    is_error: bool

class PromiseSequence:
    promises: List<PromiseReturn>
    current_idx: i32

    static fn new() -> PromiseSequence:
        PromiseSequence(promises: [], current_idx: 0)

    me add_promise(value: text, delay_ms: i32):
        self.promises.append(PromiseReturn(
            value: value,
            delay_ms: delay_ms,
            is_error: false
        ))

    me add_promise_error(error: text, delay_ms: i32):
        self.promises.append(PromiseReturn(
            value: error,
            delay_ms: delay_ms,
            is_error: true
        ))

    fn next_promise() -> Option<PromiseReturn>:
        if self.current_idx >= self.promises.len() as i32:
            return nil
        val promise = self.promises[self.current_idx as usize]
        self.current_idx = self.current_idx + 1
        Some(promise)

    fn peek_next() -> Option<PromiseReturn>:
        if self.current_idx >= self.promises.len() as i32:
            return nil
        Some(self.promises[self.current_idx as usize])

    fn remaining() -> i32:
        (self.promises.len() as i32) - self.current_idx

    fn total_delay() -> i32:
        var total = 0
        for promise in self.promises:
            total = total + promise.delay_ms
        total

    me reset():
        self.current_idx = 0

struct TimingStats:
    min_ms: i32
    max_ms: i32
    avg_ms: i32
    total_ms: i32
    count: i32

class AsyncSpy:
    name: text
    calls: List<AsyncCallRecord>

    static fn new(name: text) -> AsyncSpy:
        AsyncSpy(name: name, calls: [])

    me record_async_call(method: text, args: List<text>, duration_ms: i32):
        val full_args = [method].merge(args)
        val record = AsyncCallRecord(
            args: full_args,
            timestamp: 0,
            call_number: self.calls.len() as i32,
            completion_time: duration_ms as i64,
            result: nil,
            error: nil,
            delay_ms: duration_ms
        )
        self.calls.append(record)

    fn get_async_calls(method: text) -> List<AsyncCallRecord>:
        var result = []
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                result.append(call)
        result

    fn method_called(method: text) -> bool:
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                return true
        false

    fn get_call_timing_stats(method: text) -> TimingStats:
        var min_val = 999999
        var max_val = 0
        var total = 0
        var count = 0
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                if call.delay_ms < min_val:
                    min_val = call.delay_ms
                if call.delay_ms > max_val:
                    max_val = call.delay_ms
                total = total + call.delay_ms
                count = count + 1
        val avg = if count > 0: total / count else: 0
        TimingStats(
            min_ms: if count > 0: min_val else: 0,
            max_ms: max_val,
            avg_ms: avg,
            total_ms: total,
            count: count
        )

    fn total_calls() -> i32:
        self.calls.len() as i32

    fn summary() -> text:
        var result = "AsyncSpy '{self.name}': {self.total_calls()} call(s)\n"
        for call in self.calls:
            result = result + "  {call.args} ({call.delay_ms}ms)\n"
        result

struct AsyncMethodMock:
    method_name: text
    arguments: List<text>
    return_value: text
    delay_ms: i32

class AsyncProtocolMock:
    method_mocks: List<AsyncMethodMock>
    recorded_calls: List<AsyncCallRecord>

    static fn new() -> AsyncProtocolMock:
        AsyncProtocolMock(method_mocks: [], recorded_calls: [])

    me mock_async_method(name: text, args: List<text>, delay_ms: i32, return_value: text):
        self.method_mocks.append(AsyncMethodMock(
            method_name: name,
            arguments: args,
            return_value: return_value,
            delay_ms: delay_ms
        ))

    me record_async_method_call(name: text, args: List<text>) -> text:
        for method_mock in self.method_mocks:
            if method_mock.method_name == name:
                if method_mock.arguments.len() == args.len():
                    var matches = true
                    for i in 0..method_mock.arguments.len():
                        if method_mock.arguments[i] != args[i]:
                            matches = false
                            break
                    if matches:
                        self.recorded_calls.append(AsyncCallRecord(
                            args: [name].merge(args),
                            timestamp: 0,
                            call_number: self.recorded_calls.len() as i32,
                            completion_time: method_mock.delay_ms as i64,
                            result: Some(method_mock.return_value),
                            error: nil,
                            delay_ms: method_mock.delay_ms
                        ))
                        return method_mock.return_value
        ""

    fn verify_async_method_called(name: text) -> bool:
        for call in self.recorded_calls:
            if call.args.len() > 0 and call.args[0] == name:
                return true
        false

    fn get_async_method_calls(name: text) -> List<AsyncCallRecord>:
        var result = []
        for call in self.recorded_calls:
            if call.args.len() > 0 and call.args[0] == name:
                result.append(call)
        result

    fn get_async_method_timing(name: text) -> List<i32>:
        var result = []
        for call in self.recorded_calls:
            if call.args.len() > 0 and call.args[0] == name:
                result.append(call.delay_ms)
        result

    fn get_total_delay() -> i32:
        var total = 0
        for call in self.recorded_calls:
            total = total + call.delay_ms
        total

    fn reset():
        self.method_mocks = []
        self.recorded_calls = []

struct AsyncMockEntry:
    name: text
    mock_instance: AsyncMock

class AsyncMockComposition:
    mocks: List<AsyncMockEntry>

    static fn new() -> AsyncMockComposition:
        AsyncMockComposition(mocks: [])

    me add_async_mock(name: text, async_mock: AsyncMock):
        self.mocks.append(AsyncMockEntry(name: name, mock_instance: async_mock))

    fn get_mock(name: text) -> Option<AsyncMock>:
        for entry in self.mocks:
            if entry.name == name:
                return Some(entry.mock_instance)
        nil

    fn verify_all_called() -> bool:
        for entry in self.mocks:
            if not entry.mock_instance.was_called():
                return false
        true

    fn get_total_calls() -> i32:
        var total = 0
        for entry in self.mocks:
            total = total + entry.mock_instance.call_count()
        total

    fn get_total_delay() -> i32:
        var total = 0
        for entry in self.mocks:
            total = total + entry.mock_instance.get_total_delay()
        total

    fn get_concurrent_call_count() -> i32:
        self.mocks.len() as i32

    fn reset_all():
        for entry in self.mocks:
            entry.mock_instance.reset()

    fn summary() -> text:
        var result = "AsyncMockComposition: {self.mocks.len()} mocks, {self.get_total_calls()} total calls, {self.get_total_delay()}ms total delay\n"
        for entry in self.mocks:
            result = result + "  [{entry.name}] " + entry.mock_instance.summary()
        result

class AsyncTimingMatcher:
    check_fn: fn(i32) -> bool
    description: text

    static fn within_ms(duration: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual <= duration,
            description: "within {duration}ms"
        )

    static fn at_least_ms(duration: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual >= duration,
            description: "at least {duration}ms"
        )

    static fn between_ms(min_ms: i32, max_ms: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual >= min_ms and actual <= max_ms,
            description: "between {min_ms}ms and {max_ms}ms"
        )

    static fn exactly_ms(duration: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual == duration,
            description: "exactly {duration}ms"
        )

    fn matches(actual_ms: i32) -> bool:
        self.check_fn(actual_ms)

    fn get_description() -> text:
        self.description

fn verify_async_timing(async_mock: AsyncMock, matcher: AsyncTimingMatcher) -> bool:
    val total_delay = async_mock.get_total_delay()
    matcher.matches(total_delay)

fn verify_call_timing(call: AsyncCallRecord, matcher: AsyncTimingMatcher) -> bool:
    matcher.matches(call.delay_ms)

# ============================================================================
# Phase 7: Advanced Scheduling
# ============================================================================

enum TaskPriority:
    Critical
    High
    Normal
    Low
    Background

struct ScheduledTask:
    id: i32
    name: text
    priority: TaskPriority
    delay_ms: i32
    executed: bool
    execution_time: i32
    result: Option<text>

class TaskScheduler:
    tasks: List<ScheduledTask>
    next_id: i32
    current_time: i32
    executed_order: List<i32>

    static fn new() -> TaskScheduler:
        TaskScheduler(
            tasks: [],
            next_id: 0,
            current_time: 0,
            executed_order: []
        )

    me schedule(name: text, priority: TaskPriority, delay_ms: i32) -> i32:
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.tasks.append(ScheduledTask(
            id: id,
            name: name,
            priority: priority,
            delay_ms: delay_ms,
            executed: false,
            execution_time: 0,
            result: nil
        ))
        id

    me schedule_immediate(name: text) -> i32:
        self.schedule(name, TaskPriority.High, 0)

    me schedule_delayed(name: text, delay_ms: i32) -> i32:
        self.schedule(name, TaskPriority.Normal, delay_ms)

    me schedule_background(name: text, delay_ms: i32) -> i32:
        self.schedule(name, TaskPriority.Background, delay_ms)

    fn get_priority_value(priority: TaskPriority) -> i32:
        match priority:
            TaskPriority.Critical: 0
            TaskPriority.High: 1
            TaskPriority.Normal: 2
            TaskPriority.Low: 3
            TaskPriority.Background: 4

    me execute_next() -> Option<ScheduledTask>:
        var best_idx: Option<i32> = nil
        var best_priority = 999
        var idx = 0
        for task in self.tasks:
            if not task.executed:
                val priority_val = self.get_priority_value(task.priority)
                if priority_val < best_priority:
                    best_priority = priority_val
                    best_idx = Some(idx)
                else if priority_val == best_priority:
                    match best_idx:
                        Some(bi):
                            if task.delay_ms < self.tasks[bi as usize].delay_ms:
                                best_idx = Some(idx)
                        nil: best_idx = Some(idx)
            idx = idx + 1

        match best_idx:
            Some(i):
                self.tasks[i as usize].executed = true
                self.tasks[i as usize].execution_time = self.current_time
                self.current_time = self.current_time + self.tasks[i as usize].delay_ms
                self.executed_order.append(self.tasks[i as usize].id)
                Some(self.tasks[i as usize])
            nil: nil

    me execute_all():
        var has_pending = true
        while has_pending:
            match self.execute_next():
                Some(_): true
                nil: has_pending = false

    fn get_executed_order() -> List<i32>:
        self.executed_order

    fn get_pending_count() -> i32:
        var count = 0
        for task in self.tasks:
            if not task.executed:
                count = count + 1
        count

    fn get_task(id: i32) -> Option<ScheduledTask>:
        for task in self.tasks:
            if task.id == id:
                return Some(task)
        nil

    fn verify_execution_order(expected: List<i32>) -> bool:
        if self.executed_order.len() != expected.len():
            return false
        for i in 0..expected.len():
            if self.executed_order[i] != expected[i]:
                return false
        true

    me reset():
        self.tasks = []
        self.next_id = 0
        self.current_time = 0
        self.executed_order = []

enum BackoffStrategy:
    NoBackoff
    Linear
    Exponential
    Fixed

struct RetryAttempt:
    attempt_number: i32
    delay_ms: i32
    success: bool
    error: Option<text>

class RetryPolicy:
    max_attempts: i32
    base_delay_ms: i32
    max_delay_ms: i32
    backoff: BackoffStrategy
    attempts: List<RetryAttempt>

    static fn new(max_attempts: i32) -> RetryPolicy:
        RetryPolicy(
            max_attempts: max_attempts,
            base_delay_ms: 100,
            max_delay_ms: 5000,
            backoff: BackoffStrategy.Exponential,
            attempts: []
        )

    static fn no_retry() -> RetryPolicy:
        RetryPolicy(
            max_attempts: 1,
            base_delay_ms: 0,
            max_delay_ms: 0,
            backoff: BackoffStrategy.NoBackoff,
            attempts: []
        )

    static fn with_linear_backoff(max_attempts: i32, delay_ms: i32) -> RetryPolicy:
        RetryPolicy(
            max_attempts: max_attempts,
            base_delay_ms: delay_ms,
            max_delay_ms: delay_ms * max_attempts,
            backoff: BackoffStrategy.Linear,
            attempts: []
        )

    static fn with_exponential_backoff(max_attempts: i32, base_delay_ms: i32) -> RetryPolicy:
        RetryPolicy(
            max_attempts: max_attempts,
            base_delay_ms: base_delay_ms,
            max_delay_ms: base_delay_ms * 32,
            backoff: BackoffStrategy.Exponential,
            attempts: []
        )

    me set_max_delay(max_ms: i32):
        self.max_delay_ms = max_ms

    fn calculate_delay(attempt: i32) -> i32:
        val delay = match self.backoff:
            BackoffStrategy.NoBackoff: 0
            BackoffStrategy.Fixed: self.base_delay_ms
            BackoffStrategy.Linear: self.base_delay_ms * attempt
            BackoffStrategy.Exponential:
                var result = self.base_delay_ms
                for _ in 1..attempt:
                    result = result * 2
                result
        if delay > self.max_delay_ms:
            self.max_delay_ms
        else:
            delay

    me record_attempt(success: bool, error: Option<text>):
        val attempt_num = self.attempts.len() as i32 + 1
        val delay = self.calculate_delay(attempt_num)
        self.attempts.append(RetryAttempt(
            attempt_number: attempt_num,
            delay_ms: delay,
            success: success,
            error: error
        ))

    fn should_retry() -> bool:
        if self.attempts.len() == 0:
            return true
        if self.attempts.len() as i32 >= self.max_attempts:
            return false
        val last = self.attempts[self.attempts.len() - 1]
        not last.success

    fn get_attempt_count() -> i32:
        self.attempts.len() as i32

    fn get_total_delay() -> i32:
        var total = 0
        for attempt in self.attempts:
            total = total + attempt.delay_ms
        total

    fn was_successful() -> bool:
        if self.attempts.len() == 0:
            return false
        self.attempts[self.attempts.len() - 1].success

    me reset():
        self.attempts = []

class RateLimiter:
    max_requests: i32
    window_ms: i32
    requests: List<i32>
    current_time: i32

    static fn new(max_requests: i32, window_ms: i32) -> RateLimiter:
        RateLimiter(
            max_requests: max_requests,
            window_ms: window_ms,
            requests: [],
            current_time: 0
        )

    static fn per_second(max_requests: i32) -> RateLimiter:
        RateLimiter.new(max_requests, 1000)

    static fn per_minute(max_requests: i32) -> RateLimiter:
        RateLimiter.new(max_requests, 60000)

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms
        self.cleanup_old_requests()

    me cleanup_old_requests():
        var new_requests = []
        val window_start = self.current_time - self.window_ms
        for req_time in self.requests:
            if req_time >= window_start:
                new_requests.append(req_time)
        self.requests = new_requests

    fn can_proceed() -> bool:
        self.cleanup_old_requests()
        (self.requests.len() as i32) < self.max_requests

    me try_acquire() -> bool:
        if not self.can_proceed():
            return false
        self.requests.append(self.current_time)
        true

    fn get_wait_time() -> i32:
        if self.can_proceed():
            return 0
        if self.requests.len() == 0:
            return 0
        val oldest = self.requests[0]
        val wait = (oldest + self.window_ms) - self.current_time
        if wait > 0: wait else: 0

    fn get_remaining_requests() -> i32:
        self.cleanup_old_requests()
        self.max_requests - (self.requests.len() as i32)

    me reset():
        self.requests = []
        self.current_time = 0

struct TimeoutResult:
    completed: bool
    timed_out: bool
    duration_ms: i32
    result: Option<text>

class TimeoutController:
    timeout_ms: i32
    elapsed_ms: i32
    is_running: bool
    is_timed_out: bool

    static fn new(timeout_ms: i32) -> TimeoutController:
        TimeoutController(
            timeout_ms: timeout_ms,
            elapsed_ms: 0,
            is_running: false,
            is_timed_out: false
        )

    me start():
        self.is_running = true
        self.elapsed_ms = 0
        self.is_timed_out = false

    me advance(ms: i32):
        if self.is_running:
            self.elapsed_ms = self.elapsed_ms + ms
            if self.elapsed_ms >= self.timeout_ms:
                self.is_timed_out = true
                self.is_running = false

    me complete() -> TimeoutResult:
        self.is_running = false
        TimeoutResult(
            completed: not self.is_timed_out,
            timed_out: self.is_timed_out,
            duration_ms: self.elapsed_ms,
            result: if self.is_timed_out: nil else: Some("completed")
        )

    fn has_timed_out() -> bool:
        self.is_timed_out

    fn remaining_time() -> i32:
        val remaining = self.timeout_ms - self.elapsed_ms
        if remaining > 0: remaining else: 0

    me reset():
        self.elapsed_ms = 0
        self.is_running = false
        self.is_timed_out = false

struct ExecutionEvent:
    task_name: text
    timestamp: i32
    event_type: text

class ExecutionOrderTracker:
    events: List<ExecutionEvent>
    current_time: i32

    static fn new() -> ExecutionOrderTracker:
        ExecutionOrderTracker(events: [], current_time: 0)

    me record_start(name: text):
        self.events.append(ExecutionEvent(
            task_name: name,
            timestamp: self.current_time,
            event_type: "start"
        ))

    me record_end(name: text):
        self.events.append(ExecutionEvent(
            task_name: name,
            timestamp: self.current_time,
            event_type: "end"
        ))

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms

    fn get_start_order() -> List<text>:
        var result = []
        for event in self.events:
            if event.event_type == "start":
                result.append(event.task_name)
        result

    fn get_end_order() -> List<text>:
        var result = []
        for event in self.events:
            if event.event_type == "end":
                result.append(event.task_name)
        result

    fn verify_started_before(first: text, second: text) -> bool:
        var first_time: Option<i32> = nil
        var second_time: Option<i32> = nil
        for event in self.events:
            if event.event_type == "start":
                if event.task_name == first and first_time.is_none():
                    first_time = Some(event.timestamp)
                if event.task_name == second and second_time.is_none():
                    second_time = Some(event.timestamp)
        match first_time:
            Some(ft):
                match second_time:
                    Some(st): ft < st
                    nil: true
            nil: false

    fn verify_completed_before(first: text, second: text) -> bool:
        var first_time: Option<i32> = nil
        var second_time: Option<i32> = nil
        for event in self.events:
            if event.event_type == "end":
                if event.task_name == first and first_time.is_none():
                    first_time = Some(event.timestamp)
                if event.task_name == second and second_time.is_none():
                    second_time = Some(event.timestamp)
        match first_time:
            Some(ft):
                match second_time:
                    Some(st): ft < st
                    nil: true
            nil: false

    fn get_concurrent_at(time: i32) -> List<text>:
        var running = []
        for event in self.events:
            if event.timestamp <= time:
                if event.event_type == "start":
                    running.append(event.task_name)
                else if event.event_type == "end":
                    var new_running = []
                    for name in running:
                        if name != event.task_name:
                            new_running.append(name)
                    running = new_running
        running

    me reset():
        self.events = []
        self.current_time = 0

class ConcurrencyController:
    max_concurrent: i32
    active_count: i32
    waiting_queue: List<text>
    active_tasks: List<text>
    completed_tasks: List<text>

    static fn new(max_concurrent: i32) -> ConcurrencyController:
        ConcurrencyController(
            max_concurrent: max_concurrent,
            active_count: 0,
            waiting_queue: [],
            active_tasks: [],
            completed_tasks: []
        )

    fn can_start() -> bool:
        self.active_count < self.max_concurrent

    me try_start(name: text) -> bool:
        if not self.can_start():
            self.waiting_queue.append(name)
            return false
        self.active_count = self.active_count + 1
        self.active_tasks.append(name)
        true

    me complete(name: text):
        var new_active = []
        for task in self.active_tasks:
            if task != name:
                new_active.append(task)
        self.active_tasks = new_active
        self.active_count = self.active_count - 1
        self.completed_tasks.append(name)
        self.try_start_waiting()

    me try_start_waiting():
        if self.waiting_queue.len() > 0 and self.can_start():
            val next = self.waiting_queue[0]
            var new_queue = []
            for i in 1..self.waiting_queue.len():
                new_queue.append(self.waiting_queue[i])
            self.waiting_queue = new_queue
            self.active_count = self.active_count + 1
            self.active_tasks.append(next)

    fn get_active_count() -> i32:
        self.active_count

    fn get_waiting_count() -> i32:
        self.waiting_queue.len() as i32

    fn get_completed_count() -> i32:
        self.completed_tasks.len() as i32

    fn get_active_tasks() -> List<text>:
        self.active_tasks

    me reset():
        self.active_count = 0
        self.waiting_queue = []
        self.active_tasks = []
        self.completed_tasks = []

class Debouncer:
    delay_ms: i32
    last_call_time: i32
    pending_value: Option<text>
    executed_values: List<text>
    current_time: i32

    static fn new(delay_ms: i32) -> Debouncer:
        Debouncer(
            delay_ms: delay_ms,
            last_call_time: -999999,
            pending_value: nil,
            executed_values: [],
            current_time: 0
        )

    me call(value: text):
        self.pending_value = Some(value)
        self.last_call_time = self.current_time

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms
        match self.pending_value:
            Some(v):
                if self.current_time - self.last_call_time >= self.delay_ms:
                    self.executed_values.append(v)
                    self.pending_value = nil
            nil: true

    fn get_executed_values() -> List<text>:
        self.executed_values

    fn get_execution_count() -> i32:
        self.executed_values.len() as i32

    fn has_pending() -> bool:
        self.pending_value.is_some()

    me reset():
        self.last_call_time = -999999
        self.pending_value = nil
        self.executed_values = []
        self.current_time = 0

class Throttler:
    interval_ms: i32
    last_execution_time: i32
    dropped_count: i32
    executed_values: List<text>
    current_time: i32

    static fn new(interval_ms: i32) -> Throttler:
        Throttler(
            interval_ms: interval_ms,
            last_execution_time: -999999,
            dropped_count: 0,
            executed_values: [],
            current_time: 0
        )

    me call(value: text) -> bool:
        if self.current_time - self.last_execution_time >= self.interval_ms:
            self.executed_values.append(value)
            self.last_execution_time = self.current_time
            true
        else:
            self.dropped_count = self.dropped_count + 1
            false

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms

    fn get_executed_values() -> List<text>:
        self.executed_values

    fn get_execution_count() -> i32:
        self.executed_values.len() as i32

    fn get_dropped_count() -> i32:
        self.dropped_count

    me reset():
        self.last_execution_time = -999999
        self.dropped_count = 0
        self.executed_values = []
        self.current_time = 0

# ============================================================================
# All Exports (Phases 1-7)
# ============================================================================

# Phase 1: Core Types
export CallRecord
export MockFunction
export MockBuilder
export RegistryEntry
export MockRegistry
export create_mock
export verify_called
export verify_called_with

# Phase 2: Verification System
export Expectation
export VerificationResult
export Matcher

# Phase 3: Advanced Features
export CallAnalyzer
export ReturnValue
export SequentialReturns
export Spy

# Policy System
export MockPolicy
export mock_policy_init
export mock_policy_is_enabled
export mock_policy_allow_in_layer
export mock_policy_disable
export mock_policy_reset

# Phase 4: Advanced Patterns
export ConditionalReturn
export ConditionalReturns
export CallChain
export CallChainTracker
export BehaviorState
export BehaviorSequence
export MockSnapshot
export MockComposition

# Phase 5: Trait-Based Mocking (Generics Workaround)
export MethodSignature
export FluentExpectation
export WhenBuilder
export MethodCall
export ProtocolMock
export AutoMock

# Phase 6: Async/Await Mocking
export AsyncCallRecord
export AsyncMock
export PromiseReturn
export PromiseSequence
export TimingStats
export AsyncSpy
export AsyncMethodMock
export AsyncProtocolMock
export AsyncMockEntry
export AsyncMockComposition
export AsyncTimingMatcher
export verify_async_timing
export verify_call_timing

# Phase 7: Advanced Scheduling
export TaskPriority
export ScheduledTask
export TaskScheduler
export BackoffStrategy
export RetryAttempt
export RetryPolicy
export RateLimiter
export TimeoutResult
export TimeoutController
export ExecutionEvent
export ExecutionOrderTracker
export ConcurrencyController
export Debouncer
export Throttler
