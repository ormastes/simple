# I/O Library - Unified File System and Networking API
#
# This is the main entry point for all I/O operations in Simple.
# It automatically selects the right variant based on module context.
#
# DEFAULT: Async GC variant (automatic memory management)
#
# Quick Start:
#   use io.fs as fs
#   use io.net as net
#
#   # File I/O
#   async with await fs.open_mmap("data.txt"_filepath) as mmap:
#       val content = mmap.as_str()?
#
#   # Networking
#   val listener = await net.TcpListener::bind("127.0.0.1:8080")?
#
# Module Structure:
#   - io.fs - File system operations (files, directories, mmap)
#   - io.net - Networking (TCP, UDP, runtime)
#   - io.stdio - Standard I/O (stdin, stdout, stderr)
#
# Variant Selection:
#   The io module automatically selects the appropriate variant:
#   - Default (GC): host.async_gc_mut.io
#   - NoGC context (#[no_gc]): host.async_nogc_mut.io
#   - Immutable context: Falls back to appropriate variant
#   - Bare metal: bare.io (minimal)

# Re-export file system API
pub use io.fs

# Re-export networking API
pub use io.net

# Re-export standard I/O
pub use io.stdio

# Standard I/O module for stdin, stdout, stderr operations
mod stdio:
    """Standard I/O streams.

    Provides access to standard input, output, and error streams.

    Example:
        ```simple
        use io.stdio as stdio

        # Read line from stdin
        val line = await stdio.stdin.read_line()?

        # Write to stdout
        stdio.stdout.write("Hello, World!\n")

        # Write to stderr
        stdio.stderr.write("Error: something went wrong\n")
        ```
    """

    # Standard input stream
    pub struct Stdin:
        """Standard input stream."""
        _handle: i64

    impl Stdin:
        pub fn new() -> Stdin:
            return Stdin { _handle: 0 }

        pub async fn read_line(self) -> Result<text, text>:
            """Read a line from stdin.

            Returns:
                Line without trailing newline, or error
            """
            val result = rt_stdin_read_line()
            if result == "":
                return Err("EOF")
            return Ok(result)

        pub async fn read_all(self) -> Result<text, text>:
            """Read all available input.

            Returns:
                All input text, or error
            """
            return Ok(rt_stdin_read_all())


    # Standard output stream
    pub struct Stdout:
        """Standard output stream."""
        _handle: i64

    impl Stdout:
        pub fn new() -> Stdout:
            return Stdout { _handle: 1 }

        pub fn write(self, s: text):
            """Write text to stdout."""
            rt_stdout_write(s)

        pub fn writeln(self, s: text):
            """Write text with newline to stdout."""
            rt_stdout_write(s)
            rt_stdout_write("\n")

        pub fn flush(self):
            """Flush stdout buffer."""
            rt_stdout_flush()


    # Standard error stream
    pub struct Stderr:
        """Standard error stream."""
        _handle: i64

    impl Stderr:
        pub fn new() -> Stderr:
            return Stderr { _handle: 2 }

        pub fn write(self, s: text):
            """Write text to stderr."""
            rt_stderr_write(s)

        pub fn writeln(self, s: text):
            """Write text with newline to stderr."""
            rt_stderr_write(s)
            rt_stderr_write("\n")

        pub fn flush(self):
            """Flush stderr buffer."""
            rt_stderr_flush()


    # Global stream instances
    pub val stdin: Stdin = Stdin::new()
    pub val stdout: Stdout = Stdout::new()
    pub val stderr: Stderr = Stderr::new()


    # FFI declarations
    extern fn rt_stdin_read_line() -> text
    extern fn rt_stdin_read_all() -> text
    extern fn rt_stdout_write(s: text)
    extern fn rt_stdout_flush()
    extern fn rt_stderr_write(s: text)
    extern fn rt_stderr_flush()
