# File System API - Top-level module with variant selection
#
# This is the main file system API that users import.
# It automatically selects the right variant based on module context.
#
# DEFAULT: Async GC variant (host.async_gc_mut.io.fs)
#
# Quick Start:
#   use io.fs as fs
#
#   # Simple mmap (zero-copy read)
#   async with await fs.open_mmap("data.txt"_filepath) as mmap:
#       val content = mmap.as_str()?
#
#   # Full file operations
#   val content = await fs.read_text("config.toml"_filepath)?
#   await fs.write_text("output.txt"_filepath, "Hello!"_text)?
#
#   # Context manager (with...as syntax sugar)
#   async with await File::open_read("data.bin"_filepath) as file:
#       val buffer = Bytes::with_capacity(4096)
#       val n = await file.read(&mut buffer)?
#
# Variant Selection:
#   The fs module uses #[variant(...)] to select the implementation:
#   - Default/GC: host.async_gc_mut.io.fs (automatic memory)
#   - NoGC (#[no_gc]): host.async_nogc_mut.io.fs (manual memory)
#   - Bare metal: bare.io.minimal (embedded systems)

# Variant selection - automatically picks based on module context
# Variant attributes are ready for when parser supports them.
# For now, we provide direct FFI implementations.
# #[variant(default_impl: "host.async_gc_mut.io.fs")]
# #[variant(nogc: "host.async_nogc_mut.io.fs")]
# #[variant(bare: "bare.io.minimal")]
# pub use variant::*

# FFI declarations
extern fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool
extern fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text
extern fn _rt_file_write(path_ptr: &u8, path_len: u64, data_ptr: &u8, data_len: u64) -> bool
extern fn _rt_dir_create(path_ptr: &u8, path_len: u64) -> bool
extern fn _rt_dir_create_all(path_ptr: &u8, path_len: u64) -> bool

# File system operations with FFI implementations
# These serve as the default implementations until variant selection is supported

fn exists(path: text) -> bool:
    """Check if a file or directory exists.

    Args:
        path: Path to check

    Returns:
        true if path exists
    """
    return _rt_file_exists(path.ptr(), path.len())

fn read_text(path: text) -> text:
    """Read file contents as text.

    Args:
        path: Path to file

    Returns:
        File contents as text, empty string on error
    """
    return _rt_file_read_text(path.ptr(), path.len())

fn write_text(path: text, content: text) -> bool:
    """Write text content to file.

    Args:
        path: Path to file
        content: Text content to write

    Returns:
        true on success
    """
    return _rt_file_write(path.ptr(), path.len(), content.ptr(), content.len())

fn create_dir(path: text) -> bool:
    """Create a directory.

    Args:
        path: Directory path

    Returns:
        true on success
    """
    return _rt_dir_create(path.ptr(), path.len())

fn create_dir_all(path: text) -> bool:
    """Create directory and all parent directories.

    Args:
        path: Directory path

    Returns:
        true on success
    """
    return _rt_dir_create_all(path.ptr(), path.len())

# Note: Context manager implementations are provided by the variant modules
# Usage:
#   with open_mmap_sync("data.txt"_filepath) as mmap:
#   async with await open_mmap("data.txt"_filepath) as mmap:
#   async with await File::open_read("data.bin"_filepath) as file:
