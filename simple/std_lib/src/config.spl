# Config Module - Configuration loading and management
#
# Loads configuration from SDN files and provides typed access.
# Supports log configuration, DI profiles, and application modes.

# FFI declarations
extern fn rt_file_read(path_ptr: i64, path_len: i64) -> text
extern fn rt_file_exists(path_ptr: i64, path_len: i64) -> bool
extern fn rt_sdn_parse(content_ptr: i64, content_len: i64) -> SdnValue

# ============================================================================
# Configuration Structures
# ============================================================================

struct LogConfig:
    """Logging configuration."""
    global_level: i64       # Default log level (0-10)
    scopes: Dict<text, i64> # Per-scope log levels
    timestamps: bool        # Include timestamps
    format: text            # Output format: "text" or "json"

struct DiConfig:
    """Dependency injection configuration."""
    profile: text           # Profile name: test, dev, prod, sdn
    bindings: Dict<text, text>  # Type -> implementation bindings

struct ParserConfig:
    """Parser configuration."""
    mode: text              # "outline" or "full"
    error_recovery: bool    # Enable error recovery
    max_errors: i64         # Maximum errors before abort

struct AopConfig:
    """AOP configuration."""
    enabled: bool           # Enable AOP weaving
    log_calls: bool         # Log function calls
    log_errors: bool        # Log errors
    log_level: i64          # AOP logging level

struct ExecutionConfig:
    """Execution mode configuration."""
    mode: text              # "interpret", "jit", or "aot"
    debug: bool             # Enable debug mode
    optimize: i64           # Optimization level (0-3)
    gc_threshold: i64       # GC collection threshold

struct AppConfig:
    """Complete application configuration."""
    log: LogConfig
    di: DiConfig
    parser: ParserConfig
    aop: AopConfig
    execution: ExecutionConfig

# ============================================================================
# Default Configurations
# ============================================================================

impl LogConfig:
    static fn default() -> LogConfig:
        LogConfig(
            global_level: 4,    # INFO
            scopes: {},
            timestamps: true,
            format: "text"
        )

    static fn testing() -> LogConfig:
        """Testing: Debug level, no timestamps."""
        LogConfig(
            global_level: 5,    # DEBUG
            scopes: {},
            timestamps: false,
            format: "text"
        )

    static fn development() -> LogConfig:
        """Development: Debug level with timestamps."""
        LogConfig(
            global_level: 5,    # DEBUG
            scopes: {},
            timestamps: true,
            format: "text"
        )

    static fn production() -> LogConfig:
        """Production: Warn level, JSON format."""
        LogConfig(
            global_level: 3,    # WARN
            scopes: {},
            timestamps: true,
            format: "json"
        )

    static fn sdn() -> LogConfig:
        """SDN parsing: Error level only."""
        LogConfig(
            global_level: 2,    # ERROR
            scopes: {},
            timestamps: false,
            format: "text"
        )

impl DiConfig:
    static fn default() -> DiConfig:
        DiConfig(
            profile: "dev",
            bindings: {}
        )

    static fn with_profile(profile: text) -> DiConfig:
        DiConfig(
            profile: profile,
            bindings: {}
        )

impl ParserConfig:
    static fn default() -> ParserConfig:
        ParserConfig(
            mode: "full",
            error_recovery: true,
            max_errors: 100
        )

    static fn outline() -> ParserConfig:
        """Outline mode for quick parsing (TreeSitter compatible)."""
        ParserConfig(
            mode: "outline",
            error_recovery: true,
            max_errors: 1000
        )

impl AopConfig:
    static fn default() -> AopConfig:
        AopConfig(
            enabled: true,
            log_calls: false,
            log_errors: true,
            log_level: 5  # DEBUG
        )

    static fn disabled() -> AopConfig:
        AopConfig(
            enabled: false,
            log_calls: false,
            log_errors: false,
            log_level: 0
        )

impl ExecutionConfig:
    static fn default() -> ExecutionConfig:
        ExecutionConfig(
            mode: "interpret",
            debug: false,
            optimize: 1,
            gc_threshold: 1000000
        )

    static fn interpret() -> ExecutionConfig:
        ExecutionConfig(
            mode: "interpret",
            debug: true,
            optimize: 0,
            gc_threshold: 100000
        )

    static fn jit() -> ExecutionConfig:
        ExecutionConfig(
            mode: "jit",
            debug: false,
            optimize: 2,
            gc_threshold: 1000000
        )

    static fn aot() -> ExecutionConfig:
        ExecutionConfig(
            mode: "aot",
            debug: false,
            optimize: 3,
            gc_threshold: 10000000
        )

impl AppConfig:
    static fn default() -> AppConfig:
        AppConfig(
            log: LogConfig.default(),
            di: DiConfig.default(),
            parser: ParserConfig.default(),
            aop: AopConfig.default(),
            execution: ExecutionConfig.default()
        )

    static fn for_interpreter() -> AppConfig:
        """Configuration optimized for interpreter mode."""
        AppConfig(
            log: LogConfig.development(),
            di: DiConfig.with_profile("dev"),
            parser: ParserConfig.default(),
            aop: AopConfig.default(),
            execution: ExecutionConfig.interpret()
        )

    static fn for_compiler() -> AppConfig:
        """Configuration optimized for compilation."""
        AppConfig(
            log: LogConfig.production(),
            di: DiConfig.with_profile("prod"),
            parser: ParserConfig.default(),
            aop: AopConfig.disabled(),
            execution: ExecutionConfig.aot()
        )

    static fn for_sdn() -> AppConfig:
        """Configuration for SDN parsing (no code execution)."""
        AppConfig(
            log: LogConfig.sdn(),
            di: DiConfig.with_profile("sdn"),
            parser: ParserConfig.outline(),
            aop: AopConfig.disabled(),
            execution: ExecutionConfig(
                mode: "none",
                debug: false,
                optimize: 0,
                gc_threshold: 0
            )
        )

    static fn for_testing() -> AppConfig:
        """Configuration for test execution."""
        AppConfig(
            log: LogConfig.testing(),
            di: DiConfig.with_profile("test"),
            parser: ParserConfig.default(),
            aop: AopConfig.default(),
            execution: ExecutionConfig.interpret()
        )

# ============================================================================
# Configuration Loading
# ============================================================================

pub fn load_config(path: text) -> Result<AppConfig, text>:
    """Load configuration from SDN file."""
    if not file_exists(path):
        return Err("Config file not found: {path}")

    val content = file_read(path)
    val sdn = parse_sdn(content)

    if sdn.is_err():
        return Err("Failed to parse config: {sdn.unwrap_err()}")

    val data = sdn.unwrap()
    parse_app_config(data)

fn parse_app_config(data: SdnValue) -> Result<AppConfig, text>:
    """Parse AppConfig from SDN data."""
    Ok(AppConfig(
        log: parse_log_config(data["log"]),
        di: parse_di_config(data["di"]),
        parser: parse_parser_config(data["parser"]),
        aop: parse_aop_config(data["aop"]),
        execution: parse_execution_config(data["execution"])
    ))

fn parse_log_config(data: SdnValue?) -> LogConfig:
    """Parse LogConfig from SDN data."""
    if data.is_none():
        return LogConfig.default()

    val d = data.unwrap()
    LogConfig(
        global_level: d["global_level"] as i64 ?? 4,
        scopes: parse_scopes(d["scopes"]),
        timestamps: d["timestamps"] as bool ?? true,
        format: d["format"] as text ?? "text"
    )

fn parse_scopes(data: SdnValue?) -> Dict<text, i64>:
    """Parse scope levels from SDN data."""
    var result: Dict<text, i64> = {}
    if data.is_none():
        return result

    val d = data.unwrap()
    for key in d.keys():
        result[key] = d[key] as i64 ?? 4
    result

fn parse_di_config(data: SdnValue?) -> DiConfig:
    """Parse DiConfig from SDN data."""
    if data.is_none():
        return DiConfig.default()

    val d = data.unwrap()
    DiConfig(
        profile: d["profile"] as text ?? "dev",
        bindings: parse_bindings(d["bindings"])
    )

fn parse_bindings(data: SdnValue?) -> Dict<text, text>:
    """Parse DI bindings from SDN data."""
    var result: Dict<text, text> = {}
    if data.is_none():
        return result

    val d = data.unwrap()
    for key in d.keys():
        result[key] = d[key] as text ?? ""
    result

fn parse_parser_config(data: SdnValue?) -> ParserConfig:
    """Parse ParserConfig from SDN data."""
    if data.is_none():
        return ParserConfig.default()

    val d = data.unwrap()
    ParserConfig(
        mode: d["mode"] as text ?? "full",
        error_recovery: d["error_recovery"] as bool ?? true,
        max_errors: d["max_errors"] as i64 ?? 100
    )

fn parse_aop_config(data: SdnValue?) -> AopConfig:
    """Parse AopConfig from SDN data."""
    if data.is_none():
        return AopConfig.default()

    val d = data.unwrap()
    AopConfig(
        enabled: d["enabled"] as bool ?? true,
        log_calls: d["log_calls"] as bool ?? false,
        log_errors: d["log_errors"] as bool ?? true,
        log_level: d["log_level"] as i64 ?? 5
    )

fn parse_execution_config(data: SdnValue?) -> ExecutionConfig:
    """Parse ExecutionConfig from SDN data."""
    if data.is_none():
        return ExecutionConfig.default()

    val d = data.unwrap()
    ExecutionConfig(
        mode: d["mode"] as text ?? "interpret",
        debug: d["debug"] as bool ?? false,
        optimize: d["optimize"] as i64 ?? 1,
        gc_threshold: d["gc_threshold"] as i64 ?? 1000000
    )

# ============================================================================
# Helper Functions
# ============================================================================

fn file_exists(path: text) -> bool:
    """Check if file exists."""
    # TODO: Use FFI when available
    true

fn file_read(path: text) -> text:
    """Read file contents."""
    # TODO: Use FFI when available
    ""

fn parse_sdn(content: text) -> Result<SdnValue, text>:
    """Parse SDN content."""
    # TODO: Use FFI when available
    Ok(SdnValue.empty())

# ============================================================================
# Exports
# ============================================================================

export LogConfig, DiConfig, ParserConfig, AopConfig, ExecutionConfig, AppConfig
export load_config
