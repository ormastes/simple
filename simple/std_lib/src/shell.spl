# Shell API - Process execution
# Provides APIs for running shell commands and capturing output

# Extern declarations for file system FFI
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_copy(src: text, dest: text) -> bool
extern fn rt_file_remove(path: text) -> bool
extern fn rt_file_rename(old_path: text, new_path: text) -> bool
extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_dir_list(path: text) -> List<text>
extern fn rt_dir_remove(path: text, recursive: bool) -> bool
extern fn rt_env_get(name: text) -> text
extern fn rt_env_set(name: text, value: text) -> bool
extern fn rt_env_cwd() -> text

# Extern declarations for process execution FFI
extern fn rt_process_run(cmd: text, args: List<text>) -> (text, text, i32)
extern fn rt_process_spawn(cmd: text, args: List<text>) -> i32
extern fn rt_process_execute(cmd: text, args: List<text>) -> i32

# Extern declarations for path manipulation FFI
extern fn rt_path_basename(path: text) -> text
extern fn rt_path_dirname(path: text) -> text
extern fn rt_path_ext(path: text) -> text
extern fn rt_path_absolute(path: text) -> text
extern fn rt_path_separator() -> text
extern fn rt_platform_name() -> text

# Extern declarations for file/directory search FFI
extern fn rt_file_find(dir: text, pattern: text, recursive: bool) -> List<text>
extern fn rt_dir_glob(dir: text, pattern: text) -> List<text>

# Result type for command execution
class CommandResult:
    stdout: text
    stderr: text
    exit_code: i64
    
    fn is_ok() -> bool:
        return self.exit_code == 0

    fn is_err() -> bool:
        return self.exit_code != 0

# Shell command execution module
mod shell:
    # Run a command and capture output
    # Args can be a string or list of strings
    fn run(cmd: text, args: List<text> = []) -> CommandResult:
        val (stdout, stderr, exit_code) = rt_process_run(cmd, args)
        return CommandResult(
            stdout: stdout,
            stderr: stderr,
            exit_code: exit_code
        )
    
    # Pipe multiple commands together
    # Note: True stdin piping not yet supported - runs commands sequentially
    fn pipe(commands: List<List<text>>) -> CommandResult:
        if commands.len() == 0:
            return CommandResult(stdout: "", stderr: "", exit_code: 0)

        # Run first command
        val first_cmd = commands[0]
        if first_cmd.len() == 0:
            return CommandResult(stdout: "", stderr: "Empty command", exit_code: -1)

        val result = run(first_cmd[0], first_cmd[1:])
        if commands.len() == 1:
            return result

        # Run subsequent commands
        var current_stdout = result.stdout
        var all_stderr = result.stderr
        var final_exit_code = result.exit_code

        for i in 1..commands.len():
            val next_cmd = commands[i]
            if next_cmd.len() == 0:
                continue

            val next_result = run(next_cmd[0], next_cmd[1:])
            current_stdout = next_result.stdout
            all_stderr = all_stderr + next_result.stderr
            final_exit_code = next_result.exit_code

            if final_exit_code != 0:
                break

        return CommandResult(stdout: current_stdout, stderr: all_stderr, exit_code: final_exit_code)

# File operations module
mod file:
    # Read entire file as text
    fn read_text(path: text) -> text:
        return rt_file_read_text(path)

    # Write text to file
    fn write_text(path: text, content: text):
        rt_file_write_text(path, content)

    # Append text to file
    fn append_text(path: text, content: text):
        # Read existing content, append, and write back
        val existing = rt_file_read_text(path)
        rt_file_write_text(path, existing + content)

    # Check if file exists
    fn exists(path: text) -> bool:
        return rt_file_exists(path)

    # Copy file
    fn copy(src: text, dest: text):
        rt_file_copy(src, dest)

    # Move/rename file
    fn rename(src: text, dest: text):
        rt_file_rename(src, dest)

    # Delete/remove file
    fn remove(path: text):
        rt_file_remove(path)

    # Find files matching pattern
    fn find(dir: text, pattern: text = "*", recursive: bool = false) -> List<text>:
        return rt_file_find(dir, pattern, recursive)

# Directory operations module
mod dir:
    # List directory entries
    fn list(path: text) -> List<text>:
        return rt_dir_list(path)

    # List files matching glob pattern
    fn glob(path: text, pattern: text) -> List<text>:
        return rt_dir_glob(path, pattern)

    # Create directory
    fn create(path: text, recursive: bool = false):
        rt_dir_create(path, recursive)

    # Remove directory
    fn remove(path: text, recursive: bool = false):
        rt_dir_remove(path, recursive)

    # Check if directory exists
    fn exists(path: text) -> bool:
        return rt_file_exists(path)

# Path manipulation module
mod path:
    # Join path components with platform-specific separator
    fn join(parts: ...text) -> text:
        # Implemented in Simple - join with appropriate separator
        if parts.len() == 0:
            return ""

        # Get platform-specific path separator
        val separator = rt_path_separator()

        # Join all parts
        var result = parts[0]
        for i in 1..parts.len():
            # Don't add separator if part already starts with one
            val part = parts[i]
            if not result.ends_with(separator) and not part.starts_with(separator):
                result = result + separator + part
            else:
                result = result + part

        return result

    # Get basename (filename from path)
    fn basename(path: text) -> text:
        return rt_path_basename(path)

    # Get dirname (directory from path)
    fn dirname(path: text) -> text:
        return rt_path_dirname(path)

    # Get extension (file extension)
    fn ext(path: text) -> text:
        return rt_path_ext(path)

    # Convert to absolute path
    fn absolute(path: text) -> text:
        return rt_path_absolute(path)

# Environment variable module
mod env:
    # Get environment variable with default
    fn get(name: text, default: text = "") -> text:
        val result = rt_env_get(name)
        if result == "":
            return default
        return result

    # Set environment variable
    fn set(name: text, value: text):
        rt_env_set(name, value)

    # Get current working directory
    fn cwd() -> text:
        return rt_env_cwd()

# Export all modules for element-level imports
export shell, file, dir, path, env
