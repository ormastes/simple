///
Module: sdn.token

SDN token types for lexical analysis.

Provides:
- TokenKind: Token type enumeration
- Token: Token with kind, span, and lexeme
///

import error.Span

# Public exports
export TokenKind, Token

/// SDN token kinds
enum TokenKind:
    # Literals
    Integer(Int)
    Float(Float)
    String(String)
    Bool(Bool)
    Null

    # Identifiers
    Identifier(String)

    # Keywords
    Table

    # Operators and punctuation
    Colon        # :
    Equals       # =
    Pipe         # |
    Comma        # ,
    LBrace       # {
    RBrace       # }
    LBracket     # [
    RBracket     # ]
    LParen       # (
    RParen       # )

    # Whitespace-significant
    Newline
    Indent
    Dedent

    # End of file
    Eof

impl TokenKind:
    fn name() -> String:
        """Get the display name of this token kind"""
        match self:
            case Integer(_):
                return "integer"
            case Float(_):
                return "float"
            case String(_):
                return "string"
            case Bool(_):
                return "bool"
            case Null:
                return "null"
            case Identifier(_):
                return "identifier"
            case Table:
                return "table"
            case Colon:
                return ":"
            case Equals:
                return "="
            case Pipe:
                return "|"
            case Comma:
                return ","
            case LBrace:
                return "{"
            case RBrace:
                return "}"
            case LBracket:
                return "["
            case RBracket:
                return "]"
            case LParen:
                return "("
            case RParen:
                return ")"
            case Newline:
                return "newline"
            case Indent:
                return "INDENT"
            case Dedent:
                return "DEDENT"
            case Eof:
                return "EOF"

    fn to_string() -> String:
        return self.name()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_integer() -> bool:
        """Check if this is an Integer token."""
        match self:
            case Integer(_): true
            case _: false

    fn is_float() -> bool:
        """Check if this is a Float token."""
        match self:
            case Float(_): true
            case _: false

    fn is_string() -> bool:
        """Check if this is a String token."""
        match self:
            case String(_): true
            case _: false

    fn is_bool() -> bool:
        """Check if this is a Bool token."""
        match self:
            case Bool(_): true
            case _: false

    fn is_null() -> bool:
        """Check if this is Null token."""
        match self:
            case Null: true
            case _: false

    fn is_identifier() -> bool:
        """Check if this is an Identifier token."""
        match self:
            case Identifier(_): true
            case _: false

    fn is_table() -> bool:
        """Check if this is Table keyword."""
        match self:
            case Table: true
            case _: false

    fn is_literal() -> bool:
        """Check if this is a literal token (integer, float, string, bool, null)."""
        match self:
            case Integer(_): true
            case Float(_): true
            case String(_): true
            case Bool(_): true
            case Null: true
            case _: false

    fn is_keyword() -> bool:
        """Check if this is a keyword."""
        match self:
            case Table: true
            case _: false

    fn is_operator() -> bool:
        """Check if this is an operator or punctuation."""
        match self:
            case Colon: true
            case Equals: true
            case Pipe: true
            case Comma: true
            case _: false

    fn is_bracket() -> bool:
        """Check if this is a bracket (brace, bracket, or paren)."""
        match self:
            case LBrace: true
            case RBrace: true
            case LBracket: true
            case RBracket: true
            case LParen: true
            case RParen: true
            case _: false

    fn is_left_bracket() -> bool:
        """Check if this is a left/opening bracket."""
        match self:
            case LBrace: true
            case LBracket: true
            case LParen: true
            case _: false

    fn is_right_bracket() -> bool:
        """Check if this is a right/closing bracket."""
        match self:
            case RBrace: true
            case RBracket: true
            case RParen: true
            case _: false

    fn is_whitespace() -> bool:
        """Check if this is whitespace token (newline, indent, dedent)."""
        match self:
            case Newline: true
            case Indent: true
            case Dedent: true
            case _: false

    fn is_eof() -> bool:
        """Check if this is EOF token."""
        match self:
            case Eof: true
            case _: false

    fn is_structural() -> bool:
        """Check if this is a structural token (colon, equals, brackets, etc)."""
        match self:
            case Colon: true
            case Equals: true
            case LBrace: true
            case RBrace: true
            case LBracket: true
            case RBracket: true
            case LParen: true
            case RParen: true
            case _: false

/// SDN token with kind and source location
struct Token:
    kind: TokenKind
    span: Span
    lexeme: String

    fn new(kind: TokenKind, span: Span, lexeme: String) -> Token:
        return Token(
            kind: kind,
            span: span,
            lexeme: lexeme
        )

    fn to_string() -> String:
        return "${self.kind.name()} at ${self.span.to_string()}"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_literal() -> bool:
        """Check if token is a literal."""
        return self.kind.is_literal()

    fn is_identifier() -> bool:
        """Check if token is an identifier."""
        return self.kind.is_identifier()

    fn is_keyword() -> bool:
        """Check if token is a keyword."""
        return self.kind.is_keyword()

    fn is_operator() -> bool:
        """Check if token is an operator."""
        return self.kind.is_operator()

    fn is_bracket() -> bool:
        """Check if token is a bracket."""
        return self.kind.is_bracket()

    fn is_whitespace() -> bool:
        """Check if token is whitespace."""
        return self.kind.is_whitespace()

    fn is_eof() -> bool:
        """Check if token is EOF."""
        return self.kind.is_eof()

    fn is_structural() -> bool:
        """Check if token is structural."""
        return self.kind.is_structural()

    fn has_lexeme() -> bool:
        """Check if token has non-empty lexeme."""
        return not self.lexeme.is_empty()

    fn lexeme_len() -> Int:
        """Get length of lexeme."""
        return self.lexeme.len()

    fn matches_lexeme(expected: String) -> bool:
        """Check if lexeme matches expected string."""
        return self.lexeme == expected

    fn summary() -> String:
        """Get summary of token."""
        val kind_name = self.kind.name()
        val loc = self.span.to_string()
        return "Token: {kind_name} '{self.lexeme}' at {loc}"
