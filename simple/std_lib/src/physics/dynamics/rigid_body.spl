# Physics Dynamics - Rigid Body
#
# Rigid body with mass, velocity, forces, rotation, and damping.

export RigidBody

import ..core as core
import ml.torch as torch


# ============================================================================
# Rigid Body
# ============================================================================

class RigidBody:
    """Rigid body with mass, velocity, forces, rotation, and damping.

    Attributes:
        mass: Body mass (0 = infinite mass, static)
        position: Position vector (geometric center)
        velocity: Linear velocity
        acceleration: Linear acceleration
        force: Accumulated force
        radius: Collision radius (simple sphere for now)
        rotation: Orientation quaternion
        angular_velocity: Angular velocity vector (axis * angular_speed)
        angular_acceleration: Angular acceleration
        torque: Accumulated torque
        inertia: Moment of inertia (scalar for sphere: I = 2/5 * m * r^2)
        linear_damping: Linear velocity damping coefficient (0-1)
        angular_damping: Angular velocity damping coefficient (0-1)
        center_of_mass_offset: Offset from position to center of mass in local space
        is_awake: Whether body is active (false = sleeping for optimization)
        sleep_threshold: Velocity magnitude squared below which body can sleep
        sleep_timer: Time body has been below sleep threshold

    Example:
        ```simple
        let body = RigidBody(
            mass=1.0,
            position=Vector3(0, 10, 0),
            velocity=Vector3(0, 0, 0)
        )

        body.add_force(Vector3(0, -9.81, 0))  # Apply gravity
        body.integrate(0.016)  # Step physics

        print("Position: {body.position}")
        print("Velocity: {body.velocity}")
        ```
    """
    mass: f64
    position: core.Vector3
    velocity: core.Vector3
    acceleration: core.Vector3
    force: core.Vector3
    radius: f64
    rotation: core.Quaternion
    angular_velocity: core.Vector3
    angular_acceleration: core.Vector3
    torque: core.Vector3
    inertia: f64
    linear_damping: f64
    angular_damping: f64
    center_of_mass_offset: core.Vector3
    is_awake: bool
    sleep_threshold: f64
    sleep_timer: f64

    fn __init__(
        self,
        mass: f64,
        position: core.Vector3 = core.Vector3::zero(),
        velocity: core.Vector3 = core.Vector3::zero(),
        radius: f64 = 0.5,
        rotation: core.Quaternion = core.Quaternion::identity(),
        angular_velocity: core.Vector3 = core.Vector3::zero(),
        linear_damping: f64 = 0.01,
        angular_damping: f64 = 0.01,
        center_of_mass_offset: core.Vector3 = core.Vector3::zero()
    ):
        """Initialize rigid body.

        Args:
            mass: Body mass (0 for static/infinite mass)
            position: Initial position (geometric center, default: origin)
            velocity: Initial velocity (default: zero)
            radius: Collision radius (default: 0.5)
            rotation: Initial orientation (default: identity)
            angular_velocity: Initial angular velocity (default: zero)
            linear_damping: Linear velocity damping (default: 0.01, range: 0-1)
            angular_damping: Angular velocity damping (default: 0.01, range: 0-1)
            center_of_mass_offset: Offset from position to COM in local space (default: zero)
        """
        self.mass = mass
        self.position = position
        self.velocity = velocity
        self.acceleration = core.Vector3::zero()
        self.force = core.Vector3::zero()
        self.radius = radius

        # Rotation properties
        self.rotation = rotation
        self.angular_velocity = angular_velocity
        self.angular_acceleration = core.Vector3::zero()
        self.torque = core.Vector3::zero()

        # Damping (energy loss over time)
        self.linear_damping = linear_damping
        self.angular_damping = angular_damping

        # Center of mass offset
        self.center_of_mass_offset = center_of_mass_offset

        # Sleep/wake system for optimization
        self.is_awake = true  # Start awake
        self.sleep_threshold = 0.01  # Velocity squared threshold (0.1 m/s)
        self.sleep_timer = 0.0

        # Moment of inertia for sphere: I = (2/5) * m * r^2
        if mass > 0:
            self.inertia = 0.4 * mass * radius * radius
        else:
            self.inertia = 0.0  # Static body

    fn add_force(self, f: core.Vector3):
        """Add force to body.

        Args:
            f: Force vector to add
        """
        self.force = self.force.add(f)

    fn get_center_of_mass(self) -> core.Vector3:
        """Get world-space center of mass.

        Returns:
            World-space position of center of mass

        Example:
            ```simple
            # Hammer with heavy head
            let hammer = RigidBody(
                mass=2.0,
                position=core.Vector3(0, 0, 0),
                center_of_mass_offset=core.Vector3(0, 0.3, 0)  # COM shifted toward head
            )

            let com = hammer.get_center_of_mass()
            # COM is at (0, 0.3, 0) if rotation is identity
            ```
        """
        # Transform local COM offset to world space using rotation
        let world_offset = self.rotation.rotate_vector(self.center_of_mass_offset)
        return self.position.add(world_offset)

    fn add_force_at_point(self, f: core.Vector3, point: core.Vector3):
        """Add force at a specific point (generates torque).

        Args:
            f: Force vector
            point: Point of application in world space

        Example:
            ```simple
            # Apply force to tip of hammer (generates large torque)
            let hammer = RigidBody(
                mass=2.0,
                position=core.Vector3(0, 0, 0),
                center_of_mass_offset=core.Vector3(0, 0.3, 0)  # Heavy head
            )

            # Hit at the tip (far from COM)
            let tip = core.Vector3(0, 0.8, 0)
            hammer.add_force_at_point(core.Vector3(10, 0, 0), tip)
            # Generates large torque due to long lever arm from COM
            ```
        """
        # Add linear force
        self.force = self.force.add(f)

        # Calculate torque: τ = r × F
        # Use center of mass, not geometric center, for physically accurate rotation
        let com = self.get_center_of_mass()
        let r = point.sub(com)  # Vector from COM to point
        let torque = r.cross(f)
        self.add_torque(torque)

    fn add_torque(self, t: core.Vector3):
        """Add torque to body.

        Args:
            t: Torque vector to add
        """
        self.torque = self.torque.add(t)

    fn clear_forces(self):
        """Clear accumulated forces and torques."""
        self.force = core.Vector3::zero()
        self.torque = core.Vector3::zero()

    fn sleep(self):
        """Put body to sleep (disable physics updates).

        Sleeping bodies don't participate in physics simulation until woken.
        Used for optimization - stationary objects don't need updating.

        Example:
            ```simple
            # Manually put resting objects to sleep
            if body.velocity.magnitude() < 0.01:
                body.sleep()
            ```
        """
        self.is_awake = false
        self.velocity = core.Vector3::zero()
        self.angular_velocity = core.Vector3::zero()
        self.force = core.Vector3::zero()
        self.torque = core.Vector3::zero()
        self.sleep_timer = 0.0

    fn wake(self):
        """Wake body from sleep (enable physics updates).

        Bodies should be woken when:
        - Force is applied
        - Collision occurs
        - External influence detected

        Example:
            ```simple
            # Wake object when player touches it
            if player_nearby:
                object.wake()
                object.add_force(push_force)
            ```
        """
        if not self.is_awake:
            self.is_awake = true
            self.sleep_timer = 0.0

    fn can_sleep(self) -> bool:
        """Check if body can be put to sleep.

        Returns:
            True if body is nearly stationary and can sleep

        Example:
            ```simple
            # Check if body has been stationary for 0.5 seconds
            if body.can_sleep() and body.sleep_timer > 0.5:
                body.sleep()
            ```
        """
        let velocity_sq = self.velocity.dot(self.velocity)
        let angular_velocity_sq = self.angular_velocity.dot(self.angular_velocity)

        return velocity_sq < self.sleep_threshold and angular_velocity_sq < self.sleep_threshold

    fn integrate(self, dt: f64):
        """Integrate physics using semi-implicit Euler with sleep/wake optimization.

        Semi-implicit Euler is more stable than explicit Euler:
        1. v = v + a * dt
        2. x = x + v * dt
        3. ω = ω + α * dt
        4. q = q + (ω * q) * dt / 2

        Automatically handles sleep/wake:
        - Skips sleeping bodies for performance
        - Tracks stationary time and auto-sleeps after 0.5 seconds
        - Wakes body if force is applied

        Args:
            dt: Time step in seconds
        """
        if self.mass <= 0:
            # Static body (infinite mass), don't integrate
            return

        # Skip sleeping bodies for optimization
        if not self.is_awake:
            return

        # Wake up if external force is applied
        let force_mag_sq = self.force.dot(self.force)
        let torque_mag_sq = self.torque.dot(self.torque)
        if force_mag_sq > 0.001 or torque_mag_sq > 0.001:
            self.wake()  # Ensure awake if forces present

        # Linear motion
        # Acceleration = Force / Mass (Newton's second law)
        self.acceleration = self.force.scale(1.0 / self.mass)

        # Update velocity: v = v + a * dt
        self.velocity = self.velocity.add(self.acceleration.scale(dt))

        # Apply linear damping: v = v * (1 - damping)^dt
        # Approximation: v ≈ v * (1 - damping * dt) for small dt
        let damping_factor = 1.0 - (self.linear_damping * dt)
        if damping_factor > 0:
            self.velocity = self.velocity.scale(damping_factor)

        # Update position: x = x + v * dt
        self.position = self.position.add(self.velocity.scale(dt))

        # Angular motion (if inertia > 0)
        if self.inertia > 0:
            # Angular acceleration: α = τ / I
            self.angular_acceleration = self.torque.scale(1.0 / self.inertia)

            # Update angular velocity: ω = ω + α * dt
            self.angular_velocity = self.angular_velocity.add(
                self.angular_acceleration.scale(dt)
            )

            # Apply angular damping: ω = ω * (1 - damping)^dt
            let angular_damping_factor = 1.0 - (self.angular_damping * dt)
            if angular_damping_factor > 0:
                self.angular_velocity = self.angular_velocity.scale(angular_damping_factor)

            # Update rotation quaternion
            # dq/dt = (1/2) * ω * q
            # q(t+dt) = q(t) + dq/dt * dt
            if self.angular_velocity.magnitude() > 0:
                let w_quat = core.Quaternion(
                    0.0,
                    self.angular_velocity.x,
                    self.angular_velocity.y,
                    self.angular_velocity.z
                )

                # Quaternion derivative: dq = 0.5 * w_quat * q
                let dq_w = 0.5 * (
                    -w_quat.x * self.rotation.x -
                    w_quat.y * self.rotation.y -
                    w_quat.z * self.rotation.z
                )
                let dq_x = 0.5 * (
                    w_quat.x * self.rotation.w +
                    w_quat.z * self.rotation.y -
                    w_quat.y * self.rotation.z
                )
                let dq_y = 0.5 * (
                    w_quat.y * self.rotation.w -
                    w_quat.z * self.rotation.x +
                    w_quat.x * self.rotation.z
                )
                let dq_z = 0.5 * (
                    w_quat.z * self.rotation.w +
                    w_quat.y * self.rotation.x -
                    w_quat.x * self.rotation.y
                )

                # Integrate quaternion
                self.rotation = core.Quaternion(
                    self.rotation.w + dq_w * dt,
                    self.rotation.x + dq_x * dt,
                    self.rotation.y + dq_y * dt,
                    self.rotation.z + dq_z * dt
                )

                # Normalize quaternion to prevent drift
                self.rotation = self.rotation.normalize()

        # Sleep detection for optimization
        if self.can_sleep():
            # Body is nearly stationary, increment timer
            self.sleep_timer = self.sleep_timer + dt

            # Auto-sleep after 0.5 seconds of being stationary
            if self.sleep_timer > 0.5:
                self.sleep()
        else:
            # Body is moving, reset timer
            self.sleep_timer = 0.0

        # Clear forces for next frame
        self.clear_forces()

    fn integrate_verlet(self, dt: f64, prev_position: core.Vector3):
        """Integrate using Verlet integration.

        Verlet is more stable and energy-conserving than Euler.
        x(t+dt) = 2*x(t) - x(t-dt) + a(t)*dt^2

        Args:
            dt: Time step
            prev_position: Position from previous frame
        """
        if self.mass <= 0:
            return

        # Acceleration = Force / Mass
        self.acceleration = self.force.scale(1.0 / self.mass)

        # Save current position
        let current_pos = self.position

        # Verlet integration
        let dt2 = dt * dt
        let pos_delta = self.position.sub(prev_position)
        let accel_delta = self.acceleration.scale(dt2)
        self.position = self.position.add(pos_delta).add(accel_delta)

        # Estimate velocity for next frame
        self.velocity = self.position.sub(current_pos).scale(1.0 / dt)

        # Clear forces
        self.clear_forces()

    fn apply_impulse(self, impulse: core.Vector3):
        """Apply instantaneous impulse (change in momentum).

        Args:
            impulse: Impulse vector (kg*m/s)
        """
        if self.mass > 0:
            self.velocity = self.velocity.add(impulse.scale(1.0 / self.mass))

    fn kinetic_energy(self) -> f64:
        """Calculate kinetic energy.

        KE = 0.5 * m * v^2

        Returns:
            Kinetic energy in Joules
        """
        if self.mass <= 0:
            return 0.0

        let v_squared = self.velocity.dot(self.velocity)
        return 0.5 * self.mass * v_squared

    fn potential_energy(self, gravity: core.Vector3) -> f64:
        """Calculate gravitational potential energy.

        PE = m * g * h

        Args:
            gravity: Gravitational acceleration vector

        Returns:
            Potential energy in Joules
        """
        if self.mass <= 0:
            return 0.0

        # Height is position dot gravity direction
        let g_mag = gravity.magnitude()
        if g_mag == 0:
            return 0.0

        let g_dir = gravity.normalize()
        let height = -self.position.dot(g_dir)  # Negative because gravity points down

        return self.mass * g_mag * height

    fn to_device(self, device: torch.Device):
        """Transfer body data to GPU device.

        For future GPU batch processing.

        Args:
            device: Target device
        """
        # TODO: Convert position, velocity, etc. to GPU tensors
        pass

    fn is_static(self) -> bool:
        """Check if body is static (infinite mass).

        Returns:
            True if body is static
        """
        return self.mass <= 0
