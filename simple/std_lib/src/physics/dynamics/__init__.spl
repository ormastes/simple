# Physics Dynamics - Rigid Body Physics
#
# Rigid body dynamics with forces, torques, integration, and force fields.
#
# ## Classes
# - `RigidBody`: Rigid body with mass, velocity, forces, rotation, damping
# - `Force`: Force application at a point
# - `Integrator`: Physics integration methods (Euler, RK4, Verlet)
# - `ForceField`: Base class for force fields
# - `GravityField`: Uniform gravitational field
# - `WindField`: Directional wind force
# - `DragField`: Velocity-dependent drag (air/fluid resistance)
# - `CustomField`: User-defined force field
#
# ## Example
# ```simple
# import physics.dynamics as dynamics
# import physics.core as core
#
# # Create rigid body with damping
# let body = dynamics.RigidBody(
#     mass=1.0,
#     position=core.Vector3(0, 10, 0),
#     velocity=core.Vector3(0, 0, 0),
#     linear_damping=0.01,
#     angular_damping=0.01
# )
#
# # Create force fields
# let gravity = dynamics.GravityField(core.Vector3(0, -9.81, 0))
# let drag = dynamics.DragField(coefficient=0.47, mode="quadratic")
#
# # Apply forces and integrate
# gravity.apply(body, dt=0.016)
# drag.apply(body, dt=0.016)
# body.integrate(dt=0.016)
# ```

export RigidBody, Force, Integrator, ForceField, GravityField, WindField, CustomField, DragField

import ..core as core
import ml.torch as torch


# ============================================================================
# Force
# ============================================================================

class Force:
    """Force applied to rigid body.

    Attributes:
        vector: Force vector
        application_point: Point where force is applied (for torque)
    """
    vector: core.Vector3
    application_point: core.Vector3

    fn __init__(self, vector: core.Vector3, application_point: core.Vector3 = core.Vector3::zero()):
        """Initialize force.

        Args:
            vector: Force vector
            application_point: Point of application (default: origin)
        """
        self.vector = vector
        self.application_point = application_point


# ============================================================================
# Rigid Body
# ============================================================================

class RigidBody:
    """Rigid body with mass, velocity, forces, rotation, and damping.

    Attributes:
        mass: Body mass (0 = infinite mass, static)
        position: Position vector (geometric center)
        velocity: Linear velocity
        acceleration: Linear acceleration
        force: Accumulated force
        radius: Collision radius (simple sphere for now)
        rotation: Orientation quaternion
        angular_velocity: Angular velocity vector (axis * angular_speed)
        angular_acceleration: Angular acceleration
        torque: Accumulated torque
        inertia: Moment of inertia (scalar for sphere: I = 2/5 * m * r^2)
        linear_damping: Linear velocity damping coefficient (0-1)
        angular_damping: Angular velocity damping coefficient (0-1)
        center_of_mass_offset: Offset from position to center of mass in local space
        is_awake: Whether body is active (false = sleeping for optimization)
        sleep_threshold: Velocity magnitude squared below which body can sleep
        sleep_timer: Time body has been below sleep threshold

    Example:
        ```simple
        let body = RigidBody(
            mass=1.0,
            position=Vector3(0, 10, 0),
            velocity=Vector3(0, 0, 0)
        )

        body.add_force(Vector3(0, -9.81, 0))  # Apply gravity
        body.integrate(0.016)  # Step physics

        print(f"Position: {body.position}")
        print(f"Velocity: {body.velocity}")
        ```
    """
    mass: f64
    position: core.Vector3
    velocity: core.Vector3
    acceleration: core.Vector3
    force: core.Vector3
    radius: f64
    rotation: core.Quaternion
    angular_velocity: core.Vector3
    angular_acceleration: core.Vector3
    torque: core.Vector3
    inertia: f64
    linear_damping: f64
    angular_damping: f64
    center_of_mass_offset: core.Vector3
    is_awake: bool
    sleep_threshold: f64
    sleep_timer: f64

    fn __init__(
        self,
        mass: f64,
        position: core.Vector3 = core.Vector3::zero(),
        velocity: core.Vector3 = core.Vector3::zero(),
        radius: f64 = 0.5,
        rotation: core.Quaternion = core.Quaternion::identity(),
        angular_velocity: core.Vector3 = core.Vector3::zero(),
        linear_damping: f64 = 0.01,
        angular_damping: f64 = 0.01,
        center_of_mass_offset: core.Vector3 = core.Vector3::zero()
    ):
        """Initialize rigid body.

        Args:
            mass: Body mass (0 for static/infinite mass)
            position: Initial position (geometric center, default: origin)
            velocity: Initial velocity (default: zero)
            radius: Collision radius (default: 0.5)
            rotation: Initial orientation (default: identity)
            angular_velocity: Initial angular velocity (default: zero)
            linear_damping: Linear velocity damping (default: 0.01, range: 0-1)
            angular_damping: Angular velocity damping (default: 0.01, range: 0-1)
            center_of_mass_offset: Offset from position to COM in local space (default: zero)
        """
        self.mass = mass
        self.position = position
        self.velocity = velocity
        self.acceleration = core.Vector3::zero()
        self.force = core.Vector3::zero()
        self.radius = radius

        # Rotation properties
        self.rotation = rotation
        self.angular_velocity = angular_velocity
        self.angular_acceleration = core.Vector3::zero()
        self.torque = core.Vector3::zero()

        # Damping (energy loss over time)
        self.linear_damping = linear_damping
        self.angular_damping = angular_damping

        # Center of mass offset
        self.center_of_mass_offset = center_of_mass_offset

        # Sleep/wake system for optimization
        self.is_awake = true  # Start awake
        self.sleep_threshold = 0.01  # Velocity squared threshold (0.1 m/s)
        self.sleep_timer = 0.0

        # Moment of inertia for sphere: I = (2/5) * m * r^2
        if mass > 0:
            self.inertia = 0.4 * mass * radius * radius
        else:
            self.inertia = 0.0  # Static body

    fn add_force(self, f: core.Vector3):
        """Add force to body.

        Args:
            f: Force vector to add
        """
        self.force = self.force.add(f)

    fn get_center_of_mass(self) -> core.Vector3:
        """Get world-space center of mass.

        Returns:
            World-space position of center of mass

        Example:
            ```simple
            # Hammer with heavy head
            let hammer = RigidBody(
                mass=2.0,
                position=core.Vector3(0, 0, 0),
                center_of_mass_offset=core.Vector3(0, 0.3, 0)  # COM shifted toward head
            )

            let com = hammer.get_center_of_mass()
            # COM is at (0, 0.3, 0) if rotation is identity
            ```
        """
        # Transform local COM offset to world space using rotation
        let world_offset = self.rotation.rotate_vector(self.center_of_mass_offset)
        return self.position.add(world_offset)

    fn add_force_at_point(self, f: core.Vector3, point: core.Vector3):
        """Add force at a specific point (generates torque).

        Args:
            f: Force vector
            point: Point of application in world space

        Example:
            ```simple
            # Apply force to tip of hammer (generates large torque)
            let hammer = RigidBody(
                mass=2.0,
                position=core.Vector3(0, 0, 0),
                center_of_mass_offset=core.Vector3(0, 0.3, 0)  # Heavy head
            )

            # Hit at the tip (far from COM)
            let tip = core.Vector3(0, 0.8, 0)
            hammer.add_force_at_point(core.Vector3(10, 0, 0), tip)
            # Generates large torque due to long lever arm from COM
            ```
        """
        # Add linear force
        self.force = self.force.add(f)

        # Calculate torque: τ = r × F
        # Use center of mass, not geometric center, for physically accurate rotation
        let com = self.get_center_of_mass()
        let r = point.sub(com)  # Vector from COM to point
        let torque = r.cross(f)
        self.add_torque(torque)

    fn add_torque(self, t: core.Vector3):
        """Add torque to body.

        Args:
            t: Torque vector to add
        """
        self.torque = self.torque.add(t)

    fn clear_forces(self):
        """Clear accumulated forces and torques."""
        self.force = core.Vector3::zero()
        self.torque = core.Vector3::zero()

    fn sleep(self):
        """Put body to sleep (disable physics updates).

        Sleeping bodies don't participate in physics simulation until woken.
        Used for optimization - stationary objects don't need updating.

        Example:
            ```simple
            # Manually put resting objects to sleep
            if body.velocity.magnitude() < 0.01:
                body.sleep()
            ```
        """
        self.is_awake = false
        self.velocity = core.Vector3::zero()
        self.angular_velocity = core.Vector3::zero()
        self.force = core.Vector3::zero()
        self.torque = core.Vector3::zero()
        self.sleep_timer = 0.0

    fn wake(self):
        """Wake body from sleep (enable physics updates).

        Bodies should be woken when:
        - Force is applied
        - Collision occurs
        - External influence detected

        Example:
            ```simple
            # Wake object when player touches it
            if player_nearby:
                object.wake()
                object.add_force(push_force)
            ```
        """
        if not self.is_awake:
            self.is_awake = true
            self.sleep_timer = 0.0

    fn can_sleep(self) -> bool:
        """Check if body can be put to sleep.

        Returns:
            True if body is nearly stationary and can sleep

        Example:
            ```simple
            # Check if body has been stationary for 0.5 seconds
            if body.can_sleep() and body.sleep_timer > 0.5:
                body.sleep()
            ```
        """
        let velocity_sq = self.velocity.dot(self.velocity)
        let angular_velocity_sq = self.angular_velocity.dot(self.angular_velocity)

        return velocity_sq < self.sleep_threshold and angular_velocity_sq < self.sleep_threshold

    fn integrate(self, dt: f64):
        """Integrate physics using semi-implicit Euler with sleep/wake optimization.

        Semi-implicit Euler is more stable than explicit Euler:
        1. v = v + a * dt
        2. x = x + v * dt
        3. ω = ω + α * dt
        4. q = q + (ω * q) * dt / 2

        Automatically handles sleep/wake:
        - Skips sleeping bodies for performance
        - Tracks stationary time and auto-sleeps after 0.5 seconds
        - Wakes body if force is applied

        Args:
            dt: Time step in seconds
        """
        if self.mass <= 0:
            # Static body (infinite mass), don't integrate
            return

        # Skip sleeping bodies for optimization
        if not self.is_awake:
            return

        # Wake up if external force is applied
        let force_mag_sq = self.force.dot(self.force)
        let torque_mag_sq = self.torque.dot(self.torque)
        if force_mag_sq > 0.001 or torque_mag_sq > 0.001:
            self.wake()  # Ensure awake if forces present

        # Linear motion
        # Acceleration = Force / Mass (Newton's second law)
        self.acceleration = self.force.scale(1.0 / self.mass)

        # Update velocity: v = v + a * dt
        self.velocity = self.velocity.add(self.acceleration.scale(dt))

        # Apply linear damping: v = v * (1 - damping)^dt
        # Approximation: v ≈ v * (1 - damping * dt) for small dt
        let damping_factor = 1.0 - (self.linear_damping * dt)
        if damping_factor > 0:
            self.velocity = self.velocity.scale(damping_factor)

        # Update position: x = x + v * dt
        self.position = self.position.add(self.velocity.scale(dt))

        # Angular motion (if inertia > 0)
        if self.inertia > 0:
            # Angular acceleration: α = τ / I
            self.angular_acceleration = self.torque.scale(1.0 / self.inertia)

            # Update angular velocity: ω = ω + α * dt
            self.angular_velocity = self.angular_velocity.add(
                self.angular_acceleration.scale(dt)
            )

            # Apply angular damping: ω = ω * (1 - damping)^dt
            let angular_damping_factor = 1.0 - (self.angular_damping * dt)
            if angular_damping_factor > 0:
                self.angular_velocity = self.angular_velocity.scale(angular_damping_factor)

            # Update rotation quaternion
            # dq/dt = (1/2) * ω * q
            # q(t+dt) = q(t) + dq/dt * dt
            if self.angular_velocity.magnitude() > 0:
                let w_quat = core.Quaternion(
                    0.0,
                    self.angular_velocity.x,
                    self.angular_velocity.y,
                    self.angular_velocity.z
                )

                # Quaternion derivative: dq = 0.5 * w_quat * q
                let dq_w = 0.5 * (
                    -w_quat.x * self.rotation.x -
                    w_quat.y * self.rotation.y -
                    w_quat.z * self.rotation.z
                )
                let dq_x = 0.5 * (
                    w_quat.x * self.rotation.w +
                    w_quat.z * self.rotation.y -
                    w_quat.y * self.rotation.z
                )
                let dq_y = 0.5 * (
                    w_quat.y * self.rotation.w -
                    w_quat.z * self.rotation.x +
                    w_quat.x * self.rotation.z
                )
                let dq_z = 0.5 * (
                    w_quat.z * self.rotation.w +
                    w_quat.y * self.rotation.x -
                    w_quat.x * self.rotation.y
                )

                # Integrate quaternion
                self.rotation = core.Quaternion(
                    self.rotation.w + dq_w * dt,
                    self.rotation.x + dq_x * dt,
                    self.rotation.y + dq_y * dt,
                    self.rotation.z + dq_z * dt
                )

                # Normalize quaternion to prevent drift
                self.rotation = self.rotation.normalize()

        # Sleep detection for optimization
        if self.can_sleep():
            # Body is nearly stationary, increment timer
            self.sleep_timer = self.sleep_timer + dt

            # Auto-sleep after 0.5 seconds of being stationary
            if self.sleep_timer > 0.5:
                self.sleep()
        else:
            # Body is moving, reset timer
            self.sleep_timer = 0.0

        # Clear forces for next frame
        self.clear_forces()

    fn integrate_verlet(self, dt: f64, prev_position: core.Vector3):
        """Integrate using Verlet integration.

        Verlet is more stable and energy-conserving than Euler.
        x(t+dt) = 2*x(t) - x(t-dt) + a(t)*dt^2

        Args:
            dt: Time step
            prev_position: Position from previous frame
        """
        if self.mass <= 0:
            return

        # Acceleration = Force / Mass
        self.acceleration = self.force.scale(1.0 / self.mass)

        # Save current position
        let current_pos = self.position

        # Verlet integration
        let dt2 = dt * dt
        let pos_delta = self.position.sub(prev_position)
        let accel_delta = self.acceleration.scale(dt2)
        self.position = self.position.add(pos_delta).add(accel_delta)

        # Estimate velocity for next frame
        self.velocity = self.position.sub(current_pos).scale(1.0 / dt)

        # Clear forces
        self.clear_forces()

    fn apply_impulse(self, impulse: core.Vector3):
        """Apply instantaneous impulse (change in momentum).

        Args:
            impulse: Impulse vector (kg*m/s)
        """
        if self.mass > 0:
            self.velocity = self.velocity.add(impulse.scale(1.0 / self.mass))

    fn kinetic_energy(self) -> f64:
        """Calculate kinetic energy.

        KE = 0.5 * m * v^2

        Returns:
            Kinetic energy in Joules
        """
        if self.mass <= 0:
            return 0.0

        let v_squared = self.velocity.dot(self.velocity)
        return 0.5 * self.mass * v_squared

    fn potential_energy(self, gravity: core.Vector3) -> f64:
        """Calculate gravitational potential energy.

        PE = m * g * h

        Args:
            gravity: Gravitational acceleration vector

        Returns:
            Potential energy in Joules
        """
        if self.mass <= 0:
            return 0.0

        # Height is position dot gravity direction
        let g_mag = gravity.magnitude()
        if g_mag == 0:
            return 0.0

        let g_dir = gravity.normalize()
        let height = -self.position.dot(g_dir)  # Negative because gravity points down

        return self.mass * g_mag * height

    fn to_device(self, device: torch.Device):
        """Transfer body data to GPU device.

        For future GPU batch processing.

        Args:
            device: Target device
        """
        # TODO: Convert position, velocity, etc. to GPU tensors
        pass

    fn is_static(self) -> bool:
        """Check if body is static (infinite mass).

        Returns:
            True if body is static
        """
        return self.mass <= 0


# ============================================================================
# Integrator
# ============================================================================

class Integrator:
    """Physics integration methods.

    Provides different numerical integration schemes for physics simulation.
    """

    @staticmethod
    fn euler(bodies: [RigidBody], dt: f64):
        """Semi-implicit Euler integration.

        Simple and fast, but can accumulate energy errors.

        Args:
            bodies: List of rigid bodies
            dt: Time step
        """
        for body in bodies:
            body.integrate(dt)

    @staticmethod
    fn verlet(bodies: [RigidBody], prev_positions: [core.Vector3], dt: f64):
        """Verlet integration.

        More stable and energy-conserving than Euler.
        Requires previous positions.

        Args:
            bodies: List of rigid bodies
            prev_positions: Previous positions for each body
            dt: Time step
        """
        for i in range(bodies.len()):
            bodies[i].integrate_verlet(dt, prev_positions[i])

    @staticmethod
    fn rk4(body: RigidBody, dt: f64):
        """Runge-Kutta 4th order integration.

        Most accurate but more expensive integration method.
        Evaluates derivatives at 4 points per step for high accuracy.

        This method is ideal for:
        - High-precision physics simulations
        - Systems requiring energy conservation
        - Scenarios where timestep is relatively large

        Args:
            body: Rigid body to integrate
            dt: Time step

        Example:
            ```simple
            # High-precision simulation
            for body in bodies:
                Integrator.rk4(body, dt=0.016)
            ```

        Algorithm:
            For state y = [position, velocity, rotation, angular_velocity]:
            k1 = derivative(t, y)
            k2 = derivative(t + dt/2, y + k1*dt/2)
            k3 = derivative(t + dt/2, y + k2*dt/2)
            k4 = derivative(t + dt, y + k3*dt)
            y_new = y + (k1 + 2*k2 + 2*k3 + k4) * dt/6
        """
        if body.mass == 0:
            return  # Static body

        # Save initial state
        let p0 = body.position
        let v0 = body.velocity
        let r0 = body.rotation
        let w0 = body.angular_velocity

        # k1: Evaluate at current state
        let a1 = body.force.scale(1.0 / body.mass)  # Linear acceleration
        let alpha1 = body.torque.scale(1.0 / body.inertia)  # Angular acceleration
        let v1 = v0
        let w1 = w0

        # k2: Evaluate at t + dt/2 using k1
        let p_temp = p0.add(v1.scale(dt * 0.5))
        let v_temp = v0.add(a1.scale(dt * 0.5))
        let r_temp = r0  # Rotation update simplified for now
        let w_temp = w0.add(alpha1.scale(dt * 0.5))

        # Temporarily update body state for force evaluation
        body.position = p_temp
        body.velocity = v_temp
        body.rotation = r_temp
        body.angular_velocity = w_temp

        let a2 = body.force.scale(1.0 / body.mass)
        let alpha2 = body.torque.scale(1.0 / body.inertia)
        let v2 = v_temp
        let w2 = w_temp

        # k3: Evaluate at t + dt/2 using k2
        p_temp = p0.add(v2.scale(dt * 0.5))
        v_temp = v0.add(a2.scale(dt * 0.5))
        w_temp = w0.add(alpha2.scale(dt * 0.5))

        body.position = p_temp
        body.velocity = v_temp
        body.angular_velocity = w_temp

        let a3 = body.force.scale(1.0 / body.mass)
        let alpha3 = body.torque.scale(1.0 / body.inertia)
        let v3 = v_temp
        let w3 = w_temp

        # k4: Evaluate at t + dt using k3
        p_temp = p0.add(v3.scale(dt))
        v_temp = v0.add(a3.scale(dt))
        w_temp = w0.add(alpha3.scale(dt))

        body.position = p_temp
        body.velocity = v_temp
        body.angular_velocity = w_temp

        let a4 = body.force.scale(1.0 / body.mass)
        let alpha4 = body.torque.scale(1.0 / body.inertia)
        let v4 = v_temp
        let w4 = w_temp

        # Combine derivatives using RK4 formula: (k1 + 2*k2 + 2*k3 + k4) / 6
        let dv = a1.add(a2.scale(2.0)).add(a3.scale(2.0)).add(a4).scale(dt / 6.0)
        let dp = v1.add(v2.scale(2.0)).add(v3.scale(2.0)).add(v4).scale(dt / 6.0)
        let dw = alpha1.add(alpha2.scale(2.0)).add(alpha3.scale(2.0)).add(alpha4).scale(dt / 6.0)
        let dr = w1.add(w2.scale(2.0)).add(w3.scale(2.0)).add(w4).scale(dt / 6.0)

        # Update state with weighted average
        body.position = p0.add(dp)
        body.velocity = v0.add(dv)
        body.angular_velocity = w0.add(dw)

        # Update rotation (simplified - proper quaternion integration would be more complex)
        let rotation_delta = dr.scale(dt)
        let rotation_angle = rotation_delta.magnitude()
        if rotation_angle > 0.0001:
            let rotation_axis = rotation_delta.normalize()
            # Apply rotation (simplified - real implementation would use quaternion multiplication)
            body.rotation = body.rotation  # Placeholder - proper quaternion update needed

        # Clear forces and torques for next step
        body.clear_forces()


# ============================================================================
# Force Fields
# ============================================================================

class ForceField:
    """Base class for force fields.

    Force fields are regions of space that apply forces to rigid bodies.
    Subclasses implement different types of force fields (gravity, wind, etc.).

    Example:
        ```simple
        let gravity = GravityField(core.Vector3(0, -9.81, 0))
        let wind = WindField(core.Vector3(5, 0, 0), strength=2.0)

        # Apply to body
        gravity.apply(body, dt)
        wind.apply(body, dt)
        ```
    """

    fn apply(self, body: RigidBody, dt: f64):
        """Apply force field to a rigid body.

        Args:
            body: Rigid body to apply force to
            dt: Time step (may be used for time-varying fields)
        """
        pass


class GravityField(ForceField):
    """Uniform gravitational force field.

    Applies constant gravitational acceleration to all bodies with mass.

    Example:
        ```simple
        # Earth gravity
        let gravity = GravityField(core.Vector3(0, -9.81, 0))

        # Apply to all bodies in a list
        for body in bodies:
            gravity.apply(body, dt)
        ```
    """
    acceleration: core.Vector3

    fn __init__(self, acceleration: core.Vector3):
        """Initialize gravity field.

        Args:
            acceleration: Gravitational acceleration vector (m/s²)
        """
        self.acceleration = acceleration

    fn apply(self, body: RigidBody, dt: f64):
        """Apply gravitational force to body.

        Force = mass * acceleration (F = ma)

        Args:
            body: Rigid body
            dt: Time step (unused for constant gravity)
        """
        if body.mass > 0:  # Don't apply to static bodies
            body.add_force(self.acceleration.scale(body.mass))


class WindField(ForceField):
    """Directional wind force field.

    Applies a force in a specified direction with configurable strength.
    Force magnitude depends on body's cross-sectional area (radius²).

    Example:
        ```simple
        # Wind blowing east at 10 m/s
        let wind = WindField(
            direction=core.Vector3(1, 0, 0),
            strength=10.0
        )

        for body in bodies:
            wind.apply(body, dt)
        ```
    """
    direction: core.Vector3
    strength: f64

    fn __init__(self, direction: core.Vector3, strength: f64 = 1.0):
        """Initialize wind field.

        Args:
            direction: Wind direction (will be normalized)
            strength: Wind strength multiplier (default: 1.0)
        """
        self.direction = direction.normalize()
        self.strength = strength

    fn apply(self, body: RigidBody, dt: f64):
        """Apply wind force to body.

        Force depends on cross-sectional area: F = strength * π * r²

        Args:
            body: Rigid body
            dt: Time step (unused for constant wind)
        """
        if body.mass > 0:  # Don't apply to static bodies
            # Force proportional to cross-sectional area
            let area = 3.141592653589793 * body.radius * body.radius
            let force_magnitude = self.strength * area
            let force = self.direction.scale(force_magnitude)
            body.add_force(force)


class CustomField(ForceField):
    """Custom force field with user-defined force function.

    Allows arbitrary force calculations based on body properties and position.

    Example:
        ```simple
        # Radial force field (pushes away from origin)
        fn radial_force(body: RigidBody, dt: f64) -> core.Vector3:
            let direction = body.position.normalize()
            let distance = body.position.magnitude()
            let strength = 100.0 / (distance * distance)  # Inverse square
            return direction.scale(strength)

        let field = CustomField(radial_force)
        field.apply(body, dt)
        ```
    """
    force_fn: fn(RigidBody, f64) -> core.Vector3

    fn __init__(self, force_fn: fn(RigidBody, f64) -> core.Vector3):
        """Initialize custom force field.

        Args:
            force_fn: Function that computes force vector for a body
                     Signature: fn(body: RigidBody, dt: f64) -> Vector3
        """
        self.force_fn = force_fn

    fn apply(self, body: RigidBody, dt: f64):
        """Apply custom force to body.

        Args:
            body: Rigid body
            dt: Time step
        """
        if body.mass > 0:  # Don't apply to static bodies
            let force = self.force_fn(body, dt)
            body.add_force(force)


class DragField(ForceField):
    """Drag force field (air/fluid resistance).

    Applies velocity-dependent drag force that opposes motion.
    Supports both linear drag (F ∝ v) and quadratic drag (F ∝ v²).

    Linear drag:
        F = -k * v

    Quadratic drag (more realistic for high speeds):
        F = -½ * ρ * Cd * A * |v|² * v̂

    Example:
        ```simple
        # Linear drag (simple damping)
        let linear_drag = DragField(coefficient=0.1, mode="linear")

        # Quadratic drag (air resistance)
        let air_drag = DragField(
            coefficient=0.47,  # Drag coefficient for sphere
            fluid_density=1.225,  # Air density kg/m³
            mode="quadratic"
        )

        for body in bodies:
            air_drag.apply(body, dt)
        ```
    """
    coefficient: f64
    fluid_density: f64
    mode: str

    fn __init__(
        self,
        coefficient: f64 = 0.1,
        fluid_density: f64 = 1.225,
        mode: str = "quadratic"
    ):
        """Initialize drag field.

        Args:
            coefficient: Drag coefficient (Cd for quadratic, k for linear)
                        Sphere Cd ≈ 0.47, Streamlined ≈ 0.04
            fluid_density: Fluid density in kg/m³ (air: 1.225, water: 1000)
            mode: Drag mode - "linear" or "quadratic" (default: "quadratic")
        """
        self.coefficient = coefficient
        self.fluid_density = fluid_density
        self.mode = mode

    fn apply(self, body: RigidBody, dt: f64):
        """Apply drag force to body.

        Args:
            body: Rigid body
            dt: Time step
        """
        if body.mass <= 0:  # Don't apply to static bodies
            return

        let speed = body.velocity.magnitude()
        if speed < 0.001:  # Skip if nearly stationary
            return

        let velocity_dir = body.velocity.normalize()

        if self.mode == "linear":
            # Linear drag: F = -k * v
            let drag_magnitude = self.coefficient * speed
            let drag_force = velocity_dir.scale(-drag_magnitude)
            body.add_force(drag_force)
        else:
            # Quadratic drag: F = -½ * ρ * Cd * A * v² * v̂
            # Cross-sectional area for sphere: A = π * r²
            let area = 3.141592653589793 * body.radius * body.radius
            let drag_magnitude = 0.5 * self.fluid_density * self.coefficient * area * speed * speed
            let drag_force = velocity_dir.scale(-drag_magnitude)
            body.add_force(drag_force)
