# Physics Collision - Spatial Hashing
#
# Spatial hashing for efficient broad-phase collision detection.
# Divides space into a uniform grid to reduce collision checks from O(n²) to O(n).
#
# ## Classes
# - `SpatialHash`: Hash-based spatial partitioning for broad-phase optimization
# - `ConvexHull`: 3D convex hull generation using QuickHull algorithm
# - `SpatialHashGrid`: Test interface wrapper for spatial hash functionality
#
# ## Example
# ```simple
# import physics.collision as collision
# import physics.core as core
#
# # Create spatial hash with 2.0 unit cells
# let spatial_hash = collision.SpatialHash(cell_size=2.0)
#
# # Insert objects
# for i in range(bodies.len()):
#     spatial_hash.insert(i, bodies[i].position, bodies[i].radius)
#
# # Get potential collision pairs (broad phase)
# let pairs = spatial_hash.get_potential_pairs()
#
# # Only test these pairs for actual collision (narrow phase)
# for (i, j) in pairs:
#     if collision.Detector::sphere_sphere(bodies[i], bodies[j]):
#         # Handle collision
#         pass
#
# # Clear for next frame
# spatial_hash.clear()
# ```

export SpatialHash, ConvexHull, SpatialHashGrid

import ..core as core
from .aabb import AABB


# ============================================================================
# Spatial Hashing - Broad-Phase Collision Optimization
# ============================================================================

class SpatialHash:
    """Spatial hashing for efficient broad-phase collision detection.

    Divides space into a uniform grid and maps objects to grid cells.
    Only objects in the same or nearby cells are tested for collision,
    reducing collision checks from O(n²) to approximately O(n).

    Attributes:
        cell_size: Size of each grid cell
        grid: Hash map from grid cell to list of object indices
        object_positions: List of object positions
        object_radii: List of object bounding radii

    Example:
        ```simple
        # Create spatial hash with 2.0 unit cells
        let spatial_hash = SpatialHash(cell_size=2.0)

        # Insert objects
        for i in range(bodies.len()):
            spatial_hash.insert(i, bodies[i].position, bodies[i].radius)

        # Get potential collision pairs (broad phase)
        let pairs = spatial_hash.get_potential_pairs()

        # Only test these pairs for actual collision (narrow phase)
        for (i, j) in pairs:
            if Detector::sphere_sphere(bodies[i], bodies[j]):
                # Handle collision
                pass

        # Clear for next frame
        spatial_hash.clear()
        ```

    Performance:
        - Insert: O(1) average case
        - Query: O(k) where k = objects per cell (typically << n)
        - Total: O(n) instead of O(n²) for brute force
    """
    cell_size: f64
    grid: {i64: [i64]}  # Hash of cell coords -> object indices
    object_positions: [core.Vector3]
    object_radii: [f64]

    fn __init__(self, cell_size: f64 = 10.0):
        """Initialize spatial hash.

        Args:
            cell_size: Size of each grid cell (default: 10.0)
                      Should be ~2x the average object size for best performance
        """
        self.cell_size = cell_size
        self.grid = {}
        self.object_positions = []
        self.object_radii = []

    fn insert(self, object_id: i64, position: core.Vector3, radius: f64):
        """Insert object into spatial hash.

        Args:
            object_id: Unique identifier for the object
            position: Object position
            radius: Object bounding radius (for multi-cell insertion)
        """
        # Store object data
        if object_id >= self.object_positions.len() as i64:
            # Expand arrays if needed
            while self.object_positions.len() as i64 <= object_id:
                self.object_positions.append(core.Vector3::zero())
                self.object_radii.append(0.0)

        self.object_positions[object_id as usize] = position
        self.object_radii[object_id as usize] = radius

        # Calculate which cells this object occupies
        # Objects larger than a cell may span multiple cells
        let min_cell = self._position_to_cell(position.sub(core.Vector3(radius, radius, radius)))
        let max_cell = self._position_to_cell(position.add(core.Vector3(radius, radius, radius)))

        # Insert into all occupied cells
        for x in range(min_cell.x as i64, max_cell.x as i64 + 1):
            for y in range(min_cell.y as i64, max_cell.y as i64 + 1):
                for z in range(min_cell.z as i64, max_cell.z as i64 + 1):
                    let cell_hash = self._hash_cell(x, y, z)

                    # Add to cell's object list
                    if cell_hash not in self.grid:
                        self.grid[cell_hash] = []

                    self.grid[cell_hash].append(object_id)

    fn query_nearby(self, position: core.Vector3, radius: f64) -> [i64]:
        """Query objects near a position.

        Args:
            position: Query position
            radius: Query radius

        Returns:
            List of object IDs that might overlap with the query sphere
        """
        let result = []
        let visited = {}  # Track already-added objects

        # Get cells overlapping query sphere
        let min_cell = self._position_to_cell(position.sub(core.Vector3(radius, radius, radius)))
        let max_cell = self._position_to_cell(position.add(core.Vector3(radius, radius, radius)))

        # Check all cells in range
        for x in range(min_cell.x as i64, max_cell.x as i64 + 1):
            for y in range(min_cell.y as i64, max_cell.y as i64 + 1):
                for z in range(min_cell.z as i64, max_cell.z as i64 + 1):
                    let cell_hash = self._hash_cell(x, y, z)

                    if cell_hash in self.grid:
                        for obj_id in self.grid[cell_hash]:
                            if obj_id not in visited:
                                visited[obj_id] = true
                                result.append(obj_id)

        return result

    fn get_potential_pairs(self) -> [(i64, i64)]:
        """Get all potential collision pairs.

        Returns:
            List of (object_id1, object_id2) pairs that might be colliding
        """
        let pairs = []
        let tested = {}  # Track already-tested pairs

        # Check each cell
        for cell_hash in self.grid.keys():
            let objects = self.grid[cell_hash]

            # Test all pairs within this cell
            for i in range(objects.len()):
                for j in range(i + 1, objects.len()):
                    let id1 = objects[i]
                    let id2 = objects[j]

                    # Create unique pair key (smaller ID first)
                    let pair_key = if id1 < id2 {
                        (id1, id2)
                    } else {
                        (id2, id1)
                    }

                    # Only add each pair once
                    if pair_key not in tested:
                        tested[pair_key] = true
                        pairs.append(pair_key)

        return pairs

    fn clear(self):
        """Clear all objects from the spatial hash.

        Call this each frame before re-inserting objects.
        """
        self.grid = {}
        # Keep object data arrays allocated for reuse

    fn _position_to_cell(self, position: core.Vector3) -> core.Vector3:
        """Convert world position to grid cell coordinates.

        Args:
            position: World position

        Returns:
            Grid cell coordinates (may have fractional parts)
        """
        return core.Vector3(
            (position.x / self.cell_size).floor(),
            (position.y / self.cell_size).floor(),
            (position.z / self.cell_size).floor()
        )

    fn _hash_cell(self, x: i64, y: i64, z: i64) -> i64:
        """Hash 3D cell coordinates to a single integer.

        Uses a simple multiplicative hash for fast, reasonably distributed hashing.

        Args:
            x: Cell X coordinate
            y: Cell Y coordinate
            z: Cell Z coordinate

        Returns:
            Hash value
        """
        # Constants chosen for good distribution (large primes)
        let h = (x * 73856093) ^ (y * 19349663) ^ (z * 83492791)
        return h

    fn get_cell_count(self) -> i64:
        """Get number of occupied cells.

        Returns:
            Number of grid cells containing at least one object
        """
        return self.grid.keys().len() as i64

    fn get_max_objects_per_cell(self) -> i64:
        """Get maximum number of objects in any single cell.

        Useful for debugging and performance tuning.
        A very high value suggests cell_size is too large.

        Returns:
            Maximum objects in one cell
        """
        let max_count = 0

        for cell_hash in self.grid.keys():
            let count = self.grid[cell_hash].len() as i64
            if count > max_count:
                max_count = count

        return max_count

    fn get_average_objects_per_cell(self) -> f64:
        """Get average number of objects per occupied cell.

        Returns:
            Average objects per cell
        """
        if self.grid.keys().len() == 0:
            return 0.0

        let total = 0
        for cell_hash in self.grid.keys():
            total += self.grid[cell_hash].len()

        return total as f64 / self.grid.keys().len() as f64


# ============================================================================
# Convex Hull Generation
# ============================================================================

class ConvexHull:
    """3D Convex Hull - smallest convex shape containing a set of points.

    Uses QuickHull algorithm for efficient convex hull generation.
    Useful for creating collision shapes from point clouds.

    Attributes:
        vertices: List of vertex positions on the hull
        faces: List of triangular faces (each face = 3 vertex indices)
        normals: List of face normals (outward-facing)

    Example:
        ```simple
        # Generate hull from point cloud
        let points = [
            core.Vector3(0, 0, 0),
            core.Vector3(1, 0, 0),
            core.Vector3(0, 1, 0),
            core.Vector3(0, 0, 1),
            core.Vector3(0.5, 0.5, 0.5)
        ]

        let hull = ConvexHull::from_points(points)
        print(f"Hull has {hull.vertices.len()} vertices")
        print(f"Hull has {hull.faces.len()} faces")

        # Use for collision detection
        for face in hull.faces:
            let v0 = hull.vertices[face[0]]
            let v1 = hull.vertices[face[1]]
            let v2 = hull.vertices[face[2]]
            # Test collision with triangle...
        ```
    """
    vertices: [core.Vector3]
    faces: [[i64]]  # Each face is [v0_idx, v1_idx, v2_idx]
    normals: [core.Vector3]

    fn __init__(self, vertices: [core.Vector3], faces: [[i64]], normals: [core.Vector3]):
        """Initialize convex hull.

        Args:
            vertices: Hull vertex positions
            faces: Triangle face indices
            normals: Face normals (outward-facing)
        """
        self.vertices = vertices
        self.faces = faces
        self.normals = normals

    @staticmethod
    fn from_points(points: [core.Vector3]) -> ConvexHull:
        """Generate convex hull from point cloud using QuickHull algorithm.

        Args:
            points: Input point cloud

        Returns:
            Convex hull containing all points

        Algorithm:
            1. Find extremal points to form initial tetrahedron
            2. For each face, find furthest point outside
            3. Create new faces from that point
            4. Remove faces no longer visible from new point
            5. Repeat until no points remain outside
        """
        if points.len() < 4:
            # Degenerate case - need at least 4 points for 3D hull
            return ConvexHull::_build_degenerate_hull(points)

        # Find extremal points for initial tetrahedron
        let extremal = ConvexHull::_find_extremal_points(points)

        if extremal.len() < 4:
            return ConvexHull::_build_degenerate_hull(points)

        # Build initial tetrahedron
        let hull_vertices = [
            points[extremal[0]],
            points[extremal[1]],
            points[extremal[2]],
            points[extremal[3]]
        ]

        let hull_faces = [
            [0, 1, 2],
            [0, 2, 3],
            [0, 3, 1],
            [1, 3, 2]
        ]

        # Calculate initial normals
        let hull_normals = []
        for face in hull_faces:
            let v0 = hull_vertices[face[0]]
            let v1 = hull_vertices[face[1]]
            let v2 = hull_vertices[face[2]]
            let normal = ConvexHull::_compute_face_normal(v0, v1, v2)
            hull_normals.append(normal)

        # Track which points are inside/outside hull
        let remaining_points = []
        for i in range(points.len()):
            if i not in extremal:
                remaining_points.append(i)

        # Iteratively expand hull
        let mut changed = true
        while changed and remaining_points.len() > 0:
            changed = false

            # Find furthest point outside any face
            let furthest_point = -1
            let furthest_face = -1
            let max_distance = 0.0

            for point_idx in remaining_points:
                let point = points[point_idx]

                for face_idx in range(hull_faces.len()):
                    let face = hull_faces[face_idx]
                    let v0 = hull_vertices[face[0]]
                    let normal = hull_normals[face_idx]

                    # Distance from point to face plane
                    let distance = point.sub(v0).dot(normal)

                    if distance > max_distance:
                        max_distance = distance
                        furthest_point = point_idx
                        furthest_face = face_idx

            # If found point outside hull
            if furthest_point >= 0 and max_distance > 0.001:
                changed = true

                # Add new vertex
                let new_vertex_idx = hull_vertices.len() as i64
                hull_vertices.append(points[furthest_point])

                # Remove visible faces and create new ones
                let visible_faces = ConvexHull::_find_visible_faces(
                    hull_vertices,
                    hull_faces,
                    hull_normals,
                    points[furthest_point]
                )

                # Get horizon edges (boundary between visible and non-visible faces)
                let horizon_edges = ConvexHull::_get_horizon_edges(hull_faces, visible_faces)

                # Remove visible faces
                let new_faces = []
                let new_normals = []
                for i in range(hull_faces.len()):
                    if i not in visible_faces:
                        new_faces.append(hull_faces[i])
                        new_normals.append(hull_normals[i])

                # Create new faces from horizon edges to new vertex
                for edge in horizon_edges:
                    let new_face = [edge[0], edge[1], new_vertex_idx]
                    new_faces.append(new_face)

                    let v0 = hull_vertices[edge[0]]
                    let v1 = hull_vertices[edge[1]]
                    let v2 = hull_vertices[new_vertex_idx]
                    let normal = ConvexHull::_compute_face_normal(v0, v1, v2)
                    new_normals.append(normal)

                hull_faces = new_faces
                hull_normals = new_normals

                # Remove processed point
                remaining_points.remove(furthest_point)

        return ConvexHull(hull_vertices, hull_faces, hull_normals)

    @staticmethod
    fn _find_extremal_points(points: [core.Vector3]) -> [i64]:
        """Find 4 extremal points to form initial tetrahedron.

        Returns:
            Indices of extremal points
        """
        if points.len() == 0:
            return []

        # Find min/max along each axis
        let mut min_x = 0
        let mut max_x = 0
        let mut min_y = 0
        let mut max_y = 0
        let mut min_z = 0
        let mut max_z = 0

        for i in range(1, points.len()):
            if points[i].x < points[min_x].x:
                min_x = i
            if points[i].x > points[max_x].x:
                max_x = i
            if points[i].y < points[min_y].y:
                min_y = i
            if points[i].y > points[max_y].y:
                max_y = i
            if points[i].z < points[min_z].z:
                min_z = i
            if points[i].z > points[max_z].z:
                max_z = i

        # Pick 4 most spread out points
        # Simple heuristic: use extremal points along longest axis
        let dx = points[max_x].x - points[min_x].x
        let dy = points[max_y].y - points[min_y].y
        let dz = points[max_z].z - points[min_z].z

        if dx >= dy and dx >= dz:
            return [min_x, max_x, min_y, max_y]
        elif dy >= dz:
            return [min_y, max_y, min_z, max_z]
        else:
            return [min_z, max_z, min_x, max_x]

    @staticmethod
    fn _compute_face_normal(v0: core.Vector3, v1: core.Vector3, v2: core.Vector3) -> core.Vector3:
        """Compute outward-facing normal for a triangular face.

        Args:
            v0, v1, v2: Triangle vertices (counter-clockwise winding)

        Returns:
            Normalized face normal
        """
        let edge1 = v1.sub(v0)
        let edge2 = v2.sub(v0)
        let normal = edge1.cross(edge2)
        return normal.normalize()

    @staticmethod
    fn _find_visible_faces(
        vertices: [core.Vector3],
        faces: [[i64]],
        normals: [core.Vector3],
        point: core.Vector3
    ) -> [i64]:
        """Find all faces visible from a point.

        A face is visible if the point is in front of the face plane.

        Returns:
            List of visible face indices
        """
        let visible = []

        for i in range(faces.len()):
            let face = faces[i]
            let v0 = vertices[face[0]]
            let normal = normals[i]

            # Point is visible if it's in front of face (positive distance)
            let distance = point.sub(v0).dot(normal)
            if distance > 0.001:
                visible.append(i)

        return visible

    @staticmethod
    fn _get_horizon_edges(faces: [[i64]], visible_faces: [i64]) -> [[i64]]:
        """Get horizon edges between visible and non-visible faces.

        Returns:
            List of [v0_idx, v1_idx] edge pairs
        """
        let edges = []
        let visible_set = {}

        for idx in visible_faces:
            visible_set[idx] = true

        # For each visible face, check each edge
        for face_idx in visible_faces:
            let face = faces[face_idx]

            # Check all 3 edges of the triangle
            let edge_pairs = [
                [face[0], face[1]],
                [face[1], face[2]],
                [face[2], face[0]]
            ]

            for edge in edge_pairs:
                # Check if this edge is shared with a non-visible face
                let is_horizon = ConvexHull::_is_horizon_edge(edge, faces, visible_set)
                if is_horizon:
                    edges.append(edge)

        return edges

    @staticmethod
    fn _is_horizon_edge(edge: [i64], faces: [[i64]], visible_set: {i64: bool}) -> bool:
        """Check if an edge is on the horizon (boundary between visible/non-visible).

        Returns:
            True if edge borders visible and non-visible faces
        """
        # Count how many visible faces share this edge
        let visible_count = 0
        let total_count = 0

        for i in range(faces.len()):
            let face = faces[i]

            # Check if face contains this edge
            let has_edge = (
                (face[0] == edge[0] and face[1] == edge[1]) or
                (face[1] == edge[0] and face[2] == edge[1]) or
                (face[2] == edge[0] and face[0] == edge[1]) or
                (face[0] == edge[1] and face[1] == edge[0]) or
                (face[1] == edge[1] and face[2] == edge[0]) or
                (face[2] == edge[1] and face[0] == edge[0])
            )

            if has_edge:
                total_count += 1
                if i in visible_set:
                    visible_count += 1

        # Horizon edge: shared by visible and non-visible face
        return visible_count > 0 and visible_count < total_count

    @staticmethod
    fn _build_degenerate_hull(points: [core.Vector3]) -> ConvexHull:
        """Build degenerate hull for < 4 points.

        Returns:
            Minimal hull (triangle, line, or point)
        """
        if points.len() == 0:
            return ConvexHull([], [], [])

        if points.len() == 1:
            # Single point
            return ConvexHull([points[0]], [], [])

        if points.len() == 2:
            # Line segment - create degenerate triangle
            let midpoint = points[0].add(points[1]).scale(0.5)
            return ConvexHull(
                [points[0], points[1], midpoint],
                [[0, 1, 2]],
                [core.Vector3::zero()]
            )

        # 3 points - single triangle
        let v0 = points[0]
        let v1 = points[1]
        let v2 = points[2]
        let normal = ConvexHull::_compute_face_normal(v0, v1, v2)

        return ConvexHull(
            [v0, v1, v2],
            [[0, 1, 2]],
            [normal]
        )


# ============================================================================
# SpatialHashGrid - Test Interface
# ============================================================================

class SpatialHashGrid:
    """Spatial hash grid for broad-phase collision detection (test interface).

    Attributes:
        cell_size: Grid cell size
        objects: Map from object ID to AABB
    """
    cell_size: f64
    objects: {i64: AABB}

    fn __init__(self, cell_size: f64 = 1.0):
        """Initialize spatial hash grid.

        Args:
            cell_size: Size of each grid cell
        """
        self.cell_size = cell_size
        self.objects = {}

    fn num_objects(self) -> i64:
        """Get number of objects in grid."""
        return self.objects.len() as i64

    fn insert(self, object_id: i64, aabb: AABB):
        """Insert object with AABB.

        Args:
            object_id: Unique object identifier
            aabb: Axis-aligned bounding box
        """
        self.objects[object_id] = aabb

    fn remove(self, object_id: i64):
        """Remove object from grid.

        Args:
            object_id: Object identifier to remove
        """
        if object_id in self.objects:
            self.objects.pop(object_id)

    fn update(self, object_id: i64, aabb: AABB):
        """Update object's AABB.

        Args:
            object_id: Object identifier
            aabb: New AABB
        """
        self.objects[object_id] = aabb

    fn query(self, aabb: AABB) -> [i64]:
        """Query objects overlapping AABB.

        Args:
            aabb: Query bounding box

        Returns:
            List of object IDs that potentially overlap
        """
        let mut results = []

        for (obj_id, obj_aabb) in self.objects.items():
            if aabb.intersects(obj_aabb):
                results.append(obj_id)

        return results

    fn get_collision_pairs(self) -> [(i64, i64)]:
        """Get all potentially colliding pairs.

        Returns:
            List of (id1, id2) pairs that might be colliding
        """
        let mut pairs = []
        let ids = self.objects.keys()

        for i in range(ids.len()):
            for j in range(i + 1, ids.len()):
                let id1 = ids[i]
                let id2 = ids[j]
                let aabb1 = self.objects[id1]
                let aabb2 = self.objects[id2]

                if aabb1.intersects(aabb2):
                    pairs.append((id1, id2))

        return pairs
