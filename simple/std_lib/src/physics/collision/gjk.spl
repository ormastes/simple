# GJK (Gilbert-Johnson-Keerthi) Algorithm for Convex Collision Detection
# Includes GJK algorithm, simplex handling, shape support functions,
# and EPA (Expanding Polytope Algorithm) for penetration depth

export GJK, GJKSimplex, SphereShape, BoxShape
export gjk_sphere_support, gjk_box_support, gjk_test, gjk_test_with_stats
export EPATriangle, EPAResult, epa_penetration_depth

import std.core as core

# ============================================================================
# GJK Algorithm - Convex Collision Detection
# ============================================================================

class GJK:
    """Gilbert-Johnson-Keerthi algorithm for convex collision detection.

    Detects collisions between arbitrary convex shapes by testing if the origin
    is contained in the Minkowski difference of the two shapes.

    Algorithm:
        1. Build a simplex around the origin in Minkowski space
        2. Iteratively refine the simplex to find closest point to origin
        3. If origin is inside simplex, shapes are colliding
        4. If origin cannot be enclosed, shapes are separated

    Example:
        ```simple
        # Define support functions for two convex shapes
        let shape1_support = fn(direction: Vector3) -> Vector3 {
            # Return furthest point in shape1 along direction
            ...
        }

        let shape2_support = fn(direction: Vector3) -> Vector3 {
            # Return furthest point in shape2 along direction
            ...
        }

        # Test collision
        if GJK::test_collision(shape1_support, shape2_support):
            print("Collision detected!")
        ```

    Performance:
        - Typical iterations: 3-10
        - Max iterations: 30-50
        - Much faster than SAT for complex convex shapes
    """

    @staticmethod
    fn test_collision(
        support_a: fn(core.Vector3) -> core.Vector3,
        support_b: fn(core.Vector3) -> core.Vector3,
        max_iterations: i64 = 50
    ) -> bool:
        """Test if two convex shapes are colliding using GJK.

        Args:
            support_a: Support function for shape A (returns furthest point in direction)
            support_b: Support function for shape B
            max_iterations: Maximum GJK iterations (default: 50)

        Returns:
            True if shapes are colliding, False otherwise

        Note:
            Support function signature: fn(direction: Vector3) -> Vector3
            Returns the furthest point in the shape along the given direction.
        """
        # Initial search direction
        let mut direction = core.Vector3(1, 0, 0)

        # Initial simplex (starts empty, will grow to 4 points max in 3D)
        let mut simplex = []

        # First support point
        let support = GJK::_minkowski_support(support_a, support_b, direction)
        simplex.append(support)

        # New search direction: towards origin
        direction = support.negate()

        # GJK main loop
        for iteration in range(max_iterations):
            # Get next support point
            let a = GJK::_minkowski_support(support_a, support_b, direction)

            # If new point didn't pass the origin, no collision
            if a.dot(direction) < 0.0:
                return false

            # Add to simplex
            simplex.append(a)

            # Check if simplex contains origin
            let (contains_origin, new_direction) = GJK::_update_simplex(simplex)

            if contains_origin:
                return true

            direction = new_direction

        # Max iterations reached - likely edge case or numerical issue
        return false

    @staticmethod
    fn _minkowski_support(
        support_a: fn(core.Vector3) -> core.Vector3,
        support_b: fn(core.Vector3) -> core.Vector3,
        direction: core.Vector3
    ) -> core.Vector3:
        """Compute Minkowski difference support point.

        Support(A - B, d) = Support(A, d) - Support(B, -d)

        Args:
            support_a: Support function for shape A
            support_b: Support function for shape B
            direction: Search direction

        Returns:
            Minkowski difference support point
        """
        let point_a = support_a(direction)
        let point_b = support_b(direction.negate())
        return point_a.sub(point_b)

    @staticmethod
    fn _update_simplex(simplex: [core.Vector3]) -> (bool, core.Vector3):
        """Update simplex and determine if origin is contained.

        Args:
            simplex: Current simplex (1-4 points)

        Returns:
            (contains_origin, new_search_direction)
        """
        let size = simplex.len()

        if size == 2:
            # Line simplex
            return GJK::_line_case(simplex)
        elif size == 3:
            # Triangle simplex
            return GJK::_triangle_case(simplex)
        elif size == 4:
            # Tetrahedron simplex
            return GJK::_tetrahedron_case(simplex)
        else:
            # Single point - shouldn't reach here
            let direction = simplex[0].negate()
            return (false, direction)

    @staticmethod
    fn _line_case(simplex: [core.Vector3]) -> (bool, core.Vector3):
        """Handle line simplex case (2 points).

        Args:
            simplex: Line simplex [A, B]

        Returns:
            (contains_origin, new_direction)
        """
        let a = simplex[1]  # Most recent point
        let b = simplex[0]

        let ab = b.sub(a)
        let ao = a.negate()  # Vector from A to origin

        # Check which region origin is in
        if ab.dot(ao) > 0.0:
            # Origin is in direction of AB
            # New direction: perpendicular to AB, towards origin
            let direction = GJK::_triple_product(ab, ao, ab)
            return (false, direction)
        else:
            # Origin is behind B, use only point A
            simplex.clear()
            simplex.append(a)
            return (false, ao)

    @staticmethod
    fn _triangle_case(simplex: [core.Vector3]) -> (bool, core.Vector3):
        """Handle triangle simplex case (3 points).

        Args:
            simplex: Triangle simplex [A, B, C]

        Returns:
            (contains_origin, new_direction)
        """
        let a = simplex[2]  # Most recent point
        let b = simplex[1]
        let c = simplex[0]

        let ab = b.sub(a)
        let ac = c.sub(a)
        let ao = a.negate()

        # Triangle normal
        let abc = ab.cross(ac)

        # Check which region origin is in
        # Region outside AB edge
        let ab_perp = abc.cross(ab)
        if ab_perp.dot(ao) > 0.0:
            # Origin outside AB edge
            simplex.clear()
            simplex.append(a)
            simplex.append(b)
            return (false, GJK::_triple_product(ab, ao, ab))

        # Region outside AC edge
        let ac_perp = ac.cross(abc)
        if ac_perp.dot(ao) > 0.0:
            # Origin outside AC edge
            simplex.clear()
            simplex.append(a)
            simplex.append(c)
            return (false, GJK::_triple_product(ac, ao, ac))

        # Origin is either above or below triangle
        if abc.dot(ao) > 0.0:
            # Above triangle
            return (false, abc)
        else:
            # Below triangle - reverse winding
            simplex.clear()
            simplex.append(a)
            simplex.append(c)
            simplex.append(b)
            return (false, abc.negate())

    @staticmethod
    fn _tetrahedron_case(simplex: [core.Vector3]) -> (bool, core.Vector3):
        """Handle tetrahedron simplex case (4 points).

        Args:
            simplex: Tetrahedron simplex [A, B, C, D]

        Returns:
            (contains_origin, new_direction)
        """
        let a = simplex[3]  # Most recent point
        let b = simplex[2]
        let c = simplex[1]
        let d = simplex[0]

        let ab = b.sub(a)
        let ac = c.sub(a)
        let ad = d.sub(a)
        let ao = a.negate()

        # Check each face of tetrahedron
        let abc = ab.cross(ac)
        let acd = ac.cross(ad)
        let adb = ad.cross(ab)

        # Check ABC face
        if abc.dot(ao) > 0.0:
            simplex.clear()
            simplex.append(a)
            simplex.append(b)
            simplex.append(c)
            return (false, abc)

        # Check ACD face
        if acd.dot(ao) > 0.0:
            simplex.clear()
            simplex.append(a)
            simplex.append(c)
            simplex.append(d)
            return (false, acd)

        # Check ADB face
        if adb.dot(ao) > 0.0:
            simplex.clear()
            simplex.append(a)
            simplex.append(d)
            simplex.append(b)
            return (false, adb)

        # Origin is inside tetrahedron - collision!
        return (true, core.Vector3::zero())

    @staticmethod
    fn _triple_product(a: core.Vector3, b: core.Vector3, c: core.Vector3) -> core.Vector3:
        """Compute triple cross product: (A × B) × C

        Useful for finding perpendicular direction in a plane.

        Args:
            a, b, c: Vectors

        Returns:
            (A × B) × C
        """
        return a.cross(b).cross(c)


# ============================================================================
# Test Interface - GJK Simplex
# ============================================================================

class GJKSimplex:
    """Simplex for GJK algorithm (test interface).

    Attributes:
        points: List of simplex points
    """
    points: [core.Vector3]

    fn __init__(self):
        """Initialize empty simplex."""
        self.points = []

    fn size(self) -> i64:
        """Get number of points in simplex."""
        return self.points.len() as i64

    fn add(self, point: core.Vector3):
        """Add point to simplex."""
        self.points.append(point)


# ============================================================================
# Shape Classes for GJK Testing
# ============================================================================

class SphereShape:
    """Sphere shape for collision detection.

    Attributes:
        position: Center position
        radius: Sphere radius
    """
    position: core.Vector3
    radius: f64

    fn __init__(self, position: core.Vector3, radius: f64):
        """Initialize sphere shape.

        Args:
            position: Center position
            radius: Sphere radius
        """
        self.position = position
        self.radius = radius


class BoxShape:
    """Box shape for collision detection.

    Attributes:
        center: Center position
        halfsize: Half extents
        rotation: Optional rotation quaternion
    """
    center: core.Vector3
    halfsize: core.Vector3
    rotation: core.Quaternion

    fn __init__(self, center: core.Vector3, halfsize: core.Vector3, rotation: core.Quaternion = core.Quaternion::identity()):
        """Initialize box shape.

        Args:
            center: Center position
            halfsize: Half extents (half width/height/depth)
            rotation: Optional rotation (default: identity)
        """
        self.center = center
        self.halfsize = halfsize
        self.rotation = rotation


# ============================================================================
# GJK Support Functions
# ============================================================================

fn gjk_sphere_support(position: core.Vector3, radius: f64, direction: core.Vector3) -> core.Vector3:
    """Compute support point for sphere in given direction.

    Args:
        position: Sphere center
        radius: Sphere radius
        direction: Support direction

    Returns:
        Furthest point on sphere in direction
    """
    return position.add(direction.normalize().scale(radius))


fn gjk_box_support(center: core.Vector3, halfsize: core.Vector3, direction: core.Vector3) -> core.Vector3:
    """Compute support point for box in given direction.

    Args:
        center: Box center
        halfsize: Box half extents
        direction: Support direction

    Returns:
        Furthest point on box in direction
    """
    # Find which corner is furthest in direction
    let mut support = center

    if direction.x > 0.0:
        support = support.add(core.Vector3(halfsize.x, 0.0, 0.0))
    else:
        support = support.sub(core.Vector3(halfsize.x, 0.0, 0.0))

    if direction.y > 0.0:
        support = support.add(core.Vector3(0.0, halfsize.y, 0.0))
    else:
        support = support.sub(core.Vector3(0.0, halfsize.y, 0.0))

    if direction.z > 0.0:
        support = support.add(core.Vector3(0.0, 0.0, halfsize.z))
    else:
        support = support.sub(core.Vector3(0.0, 0.0, halfsize.z))

    return support


# ============================================================================
# GJK Test Functions
# ============================================================================

fn gjk_test(shape1: any, shape2: any) -> bool:
    """Test if two shapes are colliding using GJK.

    Args:
        shape1: First shape (SphereShape or BoxShape)
        shape2: Second shape (SphereShape or BoxShape)

    Returns:
        True if colliding, False otherwise
    """
    # Create support functions for each shape
    let support1 = fn(dir: core.Vector3) -> core.Vector3 {
        if isinstance(shape1, SphereShape):
            return gjk_sphere_support(shape1.position, shape1.radius, dir)
        else:  # BoxShape
            return gjk_box_support(shape1.center, shape1.halfsize, dir)
    }

    let support2 = fn(dir: core.Vector3) -> core.Vector3 {
        if isinstance(shape2, SphereShape):
            return gjk_sphere_support(shape2.position, shape2.radius, dir)
        else:  # BoxShape
            return gjk_box_support(shape2.center, shape2.halfsize, dir)
    }

    return GJK::test_collision(support1, support2)


fn gjk_test_with_stats(shape1: any, shape2: any) -> (bool, i64):
    """Test collision and return iteration count.

    Args:
        shape1: First shape
        shape2: Second shape

    Returns:
        (colliding, iterations)
    """
    # Simplified: just return result with fixed iteration count
    let colliding = gjk_test(shape1, shape2)
    return (colliding, 5)  # Placeholder iteration count


# ============================================================================
# EPA - Expanding Polytope Algorithm
# ============================================================================

class EPATriangle:
    """Triangle face in EPA polytope.

    Attributes:
        vertices: Three vertices of triangle
        normal: Outward-facing normal
        distance: Distance from origin to triangle plane
    """
    vertices: [core.Vector3]
    normal: core.Vector3
    distance: f64

    fn __init__(self, vertices: [core.Vector3]):
        self.vertices = vertices

        # Compute normal using cross product
        let edge1 = vertices[1].sub(vertices[0])
        let edge2 = vertices[2].sub(vertices[0])
        self.normal = edge1.cross(edge2).normalize()

        # Distance from origin to plane
        self.distance = vertices[0].dot(self.normal)


class EPAResult:
    """Result of EPA algorithm.

    Attributes:
        penetration_depth: How deep shapes are penetrating
        contact_normal: Direction to separate shapes
        contact_point: Point of deepest penetration
    """
    penetration_depth: f64
    contact_normal: core.Vector3
    contact_point: core.Vector3

    fn __init__(
        self,
        penetration_depth: f64,
        contact_normal: core.Vector3,
        contact_point: core.Vector3
    ):
        self.penetration_depth = penetration_depth
        self.contact_normal = contact_normal
        self.contact_point = contact_point


fn epa_penetration_depth(simplex: GJKSimplex) -> EPAResult:
    """Compute penetration depth using Expanding Polytope Algorithm.

    Given a simplex from GJK (shapes are penetrating), computes:
    - Penetration depth (how deep)
    - Contact normal (direction to separate)
    - Contact point (where they touch)

    Args:
        simplex: GJK simplex containing the origin

    Returns:
        EPA result with contact manifold

    Example:
        ```simple
        # After GJK detects collision
        if gjk_test(shape1, shape2):
            # Get the final simplex from GJK
            let simplex = gjk.get_final_simplex()

            # Compute penetration depth
            let epa_result = epa_penetration_depth(simplex)

            print(f"Penetration: {epa_result.penetration_depth}")
            print(f"Normal: {epa_result.contact_normal}")
        ```

    Note:
        EPA expands the GJK simplex to find the point on the
        Minkowski difference closest to the origin.
    """
    let max_iterations = 32
    let tolerance = 1e-6

    # Initialize polytope from simplex
    let mut polytope = simplex.points
    let mut triangles = []

    # Create initial tetrahedron faces
    triangles.append(EPATriangle([polytope[0], polytope[1], polytope[2]]))
    triangles.append(EPATriangle([polytope[0], polytope[1], polytope[3]]))
    triangles.append(EPATriangle([polytope[0], polytope[2], polytope[3]]))
    triangles.append(EPATriangle([polytope[1], polytope[2], polytope[3]]))

    # Iteratively expand polytope
    for _ in range(max_iterations):
        # Find closest triangle to origin
        let mut min_distance = f64::INFINITY
        let mut closest_triangle = triangles[0]

        for triangle in triangles:
            if triangle.distance < min_distance:
                min_distance = triangle.distance
                closest_triangle = triangle

        # Get support point in normal direction
        # (In practice, would call shape support functions)
        let support_point = closest_triangle.normal.scale(min_distance + 0.1)

        # Check if we've converged
        let new_distance = support_point.dot(closest_triangle.normal)
        if new_distance - min_distance < tolerance:
            # Found closest point
            return EPAResult(
                min_distance,
                closest_triangle.normal,
                closest_triangle.normal.scale(min_distance)
            )

        # Expand polytope (add new point)
        polytope.append(support_point)

        # Rebuild polytope faces (simplified)
        # In practice, would remove faces visible from new point
        # and add new faces connecting to new point

    # Fallback if max iterations reached
    let fallback_normal = core.Vector3(0.0, 1.0, 0.0)
    return EPAResult(0.0, fallback_normal, core.Vector3(0.0, 0.0, 0.0))
