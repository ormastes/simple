# MCP Generic Server Implementation
# Reusable server that can be extended for any language/tool

use core.*
use core.json.*
use mcp.core.protocol.*
use mcp.core.provider.*
use mcp.core.transport.*

# Generic MCP server
pub class McpServer:
    pub name: String
    pub version: String
    pub provider: ResourceProvider
    pub tools: Dict[String, ToolHandler]
    pub transport: Option[Transport]
    pub running: bool
    pub debug_mode: bool

    pub fn new(name: String, version: String, provider: ResourceProvider) -> McpServer:
        return McpServer:
            name: name
            version: version
            provider: provider
            tools: {}
            transport: None
            running: false
            debug_mode: false

    # Enable debug logging
    pub fn enable_debug(self):
        self.debug_mode = true

    # Register a tool handler
    pub fn register_tool(self, tool: Tool, handler: ToolHandler):
        self.tools.set(tool.name, handler)

    # Register a tool by name with a simple handler function
    pub fn register_simple_tool(self, name: String, description: String,
                                 handler: fn(Dict[String, Any]) -> String):
        tool = create_text_tool(name, description, handler)
        self.tools.set(name, tool)

    # Set the transport layer
    pub fn set_transport(self, transport: Transport):
        self.transport = Some(transport)

    # Run the server main loop with stdio transport
    pub fn run_stdio(self):
        transport = StdioTransport.new()
        if self.debug_mode:
            transport.enable_debug()
        self.transport = Some(transport)
        self.run()

    # Run the server main loop
    pub fn run(self):
        if self.transport.is_none():
            return

        transport = self.transport.unwrap()
        self.running = true

        self.log("Server starting: " + self.name + " v" + self.version)

        while self.running and transport.is_alive():
            # Read next message
            match transport.read_message():
                case Some(request):
                    self.log("Received: " + request.method)

                    # Handle the request
                    response = self.handle_request(request)

                    # Send response
                    transport.write_response(response)

                case None:
                    # No message or EOF
                    if not transport.is_alive():
                        self.log("Transport closed")
                        break

        self.log("Server stopped")

    # Stop the server
    pub fn stop(self):
        self.running = false

    # Log message (to stderr if debug mode)
    fn log(self, msg: String):
        if self.debug_mode:
            stderr_write("[" + self.name + "] " + msg + "\n")
            stderr_flush()

    # Handle incoming JSON-RPC request
    pub fn handle_request(self, request: JsonRpcRequest) -> JsonRpcResponse:
        method = request.method

        # Standard protocol methods
        if method == "initialize":
            return self.handle_initialize(request)
        elif method == "initialized":
            # Client acknowledgment - just return empty response
            return JsonRpcResponse.new(request.id, {})
        elif method == "ping":
            return self.handle_ping(request)
        elif method == "resources/list":
            return self.handle_list_resources(request)
        elif method == "resources/read":
            return self.handle_read_resource(request)
        elif method == "tools/list":
            return self.handle_list_tools(request)
        elif method == "tools/call":
            return self.handle_call_tool(request)
        elif method == "prompts/list":
            return self.handle_list_prompts(request)
        elif method == "prompts/get":
            return self.handle_get_prompt(request)
        elif method == "shutdown":
            self.running = false
            return JsonRpcResponse.new(request.id, {})
        else:
            # Unknown method
            error = ErrorObject.new(-32601, "Method not found: " + method)
            return JsonRpcError.new(request.id, error)

    # Handle initialize
    fn handle_initialize(self, request: JsonRpcRequest) -> JsonRpcResponse:
        # Build capabilities
        capabilities = {
            "resources": {
                "subscribe": false,
                "listChanged": false
            },
            "tools": {},
            "prompts": {
                "listChanged": false
            }
        }

        server_info = {
            "name": self.name,
            "version": self.version
        }

        result = {
            "protocolVersion": "2024-11-05",
            "capabilities": capabilities,
            "serverInfo": server_info
        }

        return JsonRpcResponse.new(request.id, result)

    # Handle ping
    fn handle_ping(self, request: JsonRpcRequest) -> JsonRpcResponse:
        return JsonRpcResponse.new(request.id, {})

    # Handle list resources
    fn handle_list_resources(self, request: JsonRpcRequest) -> JsonRpcResponse:
        resources = self.provider.list_resources()

        # Convert to JSON-serializable format
        resource_list = []
        for res in resources:
            resource_list.append({
                "uri": res.uri,
                "name": res.name,
                "description": res.description,
                "mimeType": res.mime_type
            })

        result = {"resources": resource_list}
        return JsonRpcResponse.new(request.id, result)

    # Handle read resource
    fn handle_read_resource(self, request: JsonRpcRequest) -> JsonRpcResponse:
        uri = ""
        if request.params.has_key("uri"):
            uri = request.params.get("uri") as String

        contents = self.provider.read_resource(uri)

        result = {
            "contents": [{
                "uri": contents.uri,
                "mimeType": contents.mime_type,
                "text": contents.text
            }]
        }
        return JsonRpcResponse.new(request.id, result)

    # Handle list tools
    fn handle_list_tools(self, request: JsonRpcRequest) -> JsonRpcResponse:
        tool_list = []
        for tool_name in self.tools.keys():
            handler = self.tools.get(tool_name)
            tool = handler.tool

            tool_info = {
                "name": tool.name,
                "description": tool.description,
                "inputSchema": {
                    "type": "object",
                    "properties": tool.input_schema
                }
            }
            tool_list.append(tool_info)

        result = {"tools": tool_list}
        return JsonRpcResponse.new(request.id, result)

    # Handle call tool
    fn handle_call_tool(self, request: JsonRpcRequest) -> JsonRpcResponse:
        tool_name = ""
        arguments = {}

        if request.params.has_key("name"):
            tool_name = request.params.get("name") as String
        if request.params.has_key("arguments"):
            arguments = request.params.get("arguments") as Dict[String, Any]

        if self.tools.has_key(tool_name):
            handler = self.tools.get(tool_name)
            tool_result = handler.execute(arguments)

            # Convert content blocks to JSON format
            content_list = []
            for block in tool_result.content:
                match block:
                    case ContentBlock.Text(text):
                        content_list.append({
                            "type": "text",
                            "text": text
                        })
                    case ContentBlock.Image(img):
                        content_list.append({
                            "type": "image",
                            "data": img.data,
                            "mimeType": img.mime_type
                        })
                    case ContentBlock.Resource(res):
                        content_list.append({
                            "type": "resource",
                            "resource": {
                                "uri": res.uri,
                                "mimeType": res.mime_type,
                                "text": res.text
                            }
                        })

            result = {
                "content": content_list,
                "isError": tool_result.is_error
            }
            return JsonRpcResponse.new(request.id, result)
        else:
            error = ErrorObject.new(-32602, "Tool not found: " + tool_name)
            return JsonRpcError.new(request.id, error)

    # Handle list prompts
    fn handle_list_prompts(self, request: JsonRpcRequest) -> JsonRpcResponse:
        # For now, return empty list - prompts can be added later
        result = {"prompts": []}
        return JsonRpcResponse.new(request.id, result)

    # Handle get prompt
    fn handle_get_prompt(self, request: JsonRpcRequest) -> JsonRpcResponse:
        error = ErrorObject.new(-32602, "Prompt not found")
        return JsonRpcError.new(request.id, error)

# Tool handler interface - implement this for each tool
pub class ToolHandler:
    pub tool: Tool
    pub execute_fn: fn(Dict[String, Any]) -> ToolResult

    pub fn new(tool: Tool, execute_fn: fn(Dict[String, Any]) -> ToolResult) -> ToolHandler:
        return ToolHandler:
            tool: tool
            execute_fn: execute_fn

    pub fn execute(self, arguments: Dict[String, Any]) -> ToolResult:
        return self.execute_fn(arguments)

# Text tool handler wrapper - wraps a string-returning handler
pub class TextToolWrapper:
    pub handler: fn(Dict[String, Any]) -> String

    pub fn new(handler: fn(Dict[String, Any]) -> String) -> TextToolWrapper:
        return TextToolWrapper:
            handler: handler

    pub fn execute(self, args: Dict[String, Any]) -> ToolResult:
        text = self.handler(args)
        return ToolResult.new(text)

# Helper to create a simple text tool
pub fn create_text_tool(name: String, description: String,
                        handler: fn(Dict[String, Any]) -> String) -> ToolHandler:
    tool = Tool.new(name, description)
    wrapper = TextToolWrapper.new(handler)
    # Use method reference instead of inline lambda
    return ToolHandler.new(tool, \args: wrapper.execute(args))

# Helper to create a tool with input schema
pub fn create_tool_with_schema(name: String, description: String,
                               schema: Dict[String, Any],
                               handler: fn(Dict[String, Any]) -> ToolResult) -> ToolHandler:
    tool = Tool.new(name, description)
    tool.input_schema = schema
    return ToolHandler.new(tool, handler)

# Extern functions for stdio (referenced from transport.spl)
extern fn stderr_write(s: String)
extern fn stderr_flush()
