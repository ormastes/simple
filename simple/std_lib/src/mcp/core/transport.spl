# MCP Transport Layer
# Abstracts communication channel (stdio, TCP, WebSocket, etc.)
# Implements proper MCP message framing with Content-Length headers

use core.*
use core.json.*
use mcp.core.protocol.*

# Transport interface
pub trait Transport:
    # Read a JSON-RPC message
    fn read_message() -> Option<JsonRpcRequest>

    # Write a JSON-RPC response
    fn write_response(response: JsonRpcResponse)

    # Write an error response
    fn write_error(id: i64, code: i64, message: text)

    # Check if transport is still alive
    fn is_alive() -> bool

# Stdio transport with MCP message framing (Content-Length headers)
# MCP uses HTTP-like message framing:
#   Content-Length: <length>\r\n
#   \r\n
#   <JSON body>
pub class StdioTransport:
    pub alive: bool
    pub buffer: text
    pub debug_mode: bool

    pub fn new() -> StdioTransport:
        return StdioTransport:
            alive: true
            buffer: ""
            debug_mode: false

    pub fn enable_debug(self):
        self.debug_mode = true

    # Read a line from stdin (blocking)
    fn read_line() -> Result<text, text>:
        # Use extern function for stdin reading
        line = ""
        while true:
            ch = stdin_read_char()
            if ch == "":
                if line == "":
                    return Err("EOF")
                return Ok(line)
            elif ch == "\n":
                return Ok(line)
            elif ch == "\r":
                # Skip carriage return
                continue
            else:
                line = line + ch

    # Read exactly n bytes from stdin
    fn read_exact(n: i64) -> Result<text, text>:
        result = ""
        remaining = n
        while remaining > 0:
            ch = stdin_read_char()
            if ch == "":
                return Err("EOF while reading body")
            result = result + ch
            remaining = remaining - 1
        return Ok(result)

    # Write to stdout with flush
    fn write_stdout(data: text):
        stdout_write(data)
        stdout_flush()

    # Write to stderr for debug logging
    fn log_debug(msg: text):
        if self.debug_mode:
            stderr_write("[MCP] " + msg + "\n")
            stderr_flush()

    # Parse Content-Length header
    fn parse_content_length(header: text) -> Option<i64>:
        # Header format: "Content-Length: <number>"
        if not header.starts_with("Content-Length:"):
            return None

        # Extract the number part
        value_part = header.substring(15, header.len()).trim()

        # Parse as integer
        length = 0
        for i in 0..value_part.len():
            ch = value_part.char_at(i)
            if ch >= "0" and ch <= "9":
                digit = ch.ord() - "0".ord()
                length = length * 10 + digit
            else:
                break

        return Some(length)

    # Parse JSON into JsonRpcRequest
    fn parse_request(json_str: text) -> Result<JsonRpcRequest, text>:
        match json.parse(json_str):
            case Ok(JsonValue.Object(obj)):
                # Extract fields
                id = 0
                method = ""
                params = {}

                if obj.has_key("id"):
                    match obj.get("id"):
                        case JsonValue.Integer(i):
                            id = i
                        case JsonValue.text(s):
                            # Some clients send string IDs
                            id = 0  # Use 0 for string IDs
                        case _:
                            pass

                if obj.has_key("method"):
                    match obj.get("method"):
                        case JsonValue.text(m):
                            method = m
                        case _:
                            return Err("method must be string")
                else:
                    return Err("missing method field")

                if obj.has_key("params"):
                    match obj.get("params"):
                        case JsonValue.Object(p):
                            params = json_object_to_dict(p)
                        case _:
                            pass

                return Ok(JsonRpcRequest.new(id, method, params))

            case Ok(_):
                return Err("request must be object")
            case Err(e):
                return Err("JSON parse error: " + e)

    # Serialize response to JSON
    fn serialize_response(response: JsonRpcResponse) -> text:
        builder = JsonBuilder.new()
        builder.set_string("jsonrpc", "2.0")
        builder.set_int("id", response.id)

        # Serialize result based on type
        result_json = any_to_json(response.result)
        builder.set("result", result_json)

        return json.stringify(builder.build())

    # Serialize error response to JSON
    fn serialize_error(id: i64, code: i64, message: text) -> text:
        error_obj = JsonBuilder.new()
        error_obj.set_int("code", code)
        error_obj.set_string("message", message)

        builder = JsonBuilder.new()
        builder.set_string("jsonrpc", "2.0")
        builder.set_int("id", id)
        builder.set("error", error_obj.build())

        return json.stringify(builder.build())

impl Transport for StdioTransport:
    fn read_message() -> Option<JsonRpcRequest>:
        self.log_debug("Waiting for message...")

        # Read headers until empty line
        content_length = 0

        while true:
            match self.read_line():
                case Ok(line):
                    if line == "" or line.trim() == "":
                        # Empty line = end of headers
                        break

                    # Parse Content-Length header
                    match self.parse_content_length(line):
                        case Some(len):
                            content_length = len
                            self.log_debug("Content-Length: " + len.to_string())
                        case None:
                            # Ignore other headers
                            pass

                case Err(e):
                    self.log_debug("Read error: " + e)
                    self.alive = false
                    return None

        if content_length == 0:
            self.log_debug("No content length specified")
            return None

        # Read body
        match self.read_exact(content_length):
            case Ok(body):
                self.log_debug("Received: " + body)

                match self.parse_request(body):
                    case Ok(request):
                        return Some(request)
                    case Err(e):
                        self.log_debug("Parse error: " + e)
                        return None

            case Err(e):
                self.log_debug("Body read error: " + e)
                self.alive = false
                return None

    fn write_response(response: JsonRpcResponse):
        body = self.serialize_response(response)
        self.log_debug("Sending: " + body)

        # Write with Content-Length header
        header = "Content-Length: " + body.len().to_string() + "\r\n\r\n"
        self.write_stdout(header + body)

    fn write_error(id: i64, code: i64, message: text):
        body = self.serialize_error(id, code, message)
        self.log_debug("Sending error: " + body)

        header = "Content-Length: " + body.len().to_string() + "\r\n\r\n"
        self.write_stdout(header + body)

    fn is_alive() -> bool:
        return self.alive

# TCP FFI imports
import net.tcp.{monoio_tcp_connect, monoio_tcp_read, monoio_tcp_write, monoio_tcp_close}

# TCP transport for MCP over network
pub class TcpTransport:
    pub host: text
    pub port: i64
    pub alive: bool
    pub stream_handle: i64
    pub buffer: text
    pub debug_mode: bool

    pub fn new(host: text, port: i64) -> TcpTransport:
        return TcpTransport:
            host: host
            port: port
            alive: false
            stream_handle: -1
            buffer: ""
            debug_mode: false

    pub fn connect() -> Result<(), text>:
        """Connect to the MCP server."""
        val addr = "{self.host}:{self.port}"
        val handle = monoio_tcp_connect(addr)
        if handle < 0:
            return Err("Failed to connect to {addr}")
        self.stream_handle = handle
        self.alive = true
        Ok(())

    pub fn enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            stderr_write("[MCP-TCP] " + msg + "\n")
            stderr_flush()

    fn read_line() -> Result<text, text>:
        """Read a line from the TCP stream."""
        var line = ""
        var read_buf: List<u8> = [0]

        while true:
            val bytes_read = monoio_tcp_read(self.stream_handle, read_buf, 1)
            if bytes_read <= 0:
                if line == "":
                    return Err("Connection closed")
                return Ok(line)

            val ch = read_buf[0] as char
            if ch == '\n':
                return Ok(line)
            elif ch == '\r':
                # Skip carriage return
                continue
            else:
                line = line + ch.to_string()

    fn read_exact(n: i64) -> Result<text, text>:
        """Read exactly n bytes from the TCP stream."""
        var result = ""
        var read_buf: List<u8> = []
        read_buf.resize(n as usize, 0)

        var remaining = n
        var offset = 0

        while remaining > 0:
            val bytes_read = monoio_tcp_read(self.stream_handle, read_buf, remaining)
            if bytes_read <= 0:
                return Err("Connection closed while reading body")

            # Convert bytes to string
            for i in offset..(offset + bytes_read):
                result = result + (read_buf[i as usize] as char).to_string()

            remaining = remaining - bytes_read
            offset = offset + bytes_read

        Ok(result)

    fn parse_content_length(header: text) -> Option<i64>:
        """Parse Content-Length header."""
        if not header.starts_with("Content-Length:"):
            return None

        val value_part = header.substring(15, header.len()).trim()
        var length: i64 = 0

        for ch in value_part.chars():
            if ch >= '0' and ch <= '9':
                val digit = (ch as i64) - ('0' as i64)
                length = length * 10 + digit
            else:
                break

        Some(length)

impl Transport for TcpTransport:
    fn read_message() -> Option<JsonRpcRequest>:
        """Read MCP-framed message from TCP stream."""
        if not self.alive:
            return None

        # Read Content-Length header
        match self.read_line():
            case Ok(header):
                match self.parse_content_length(header):
                    case Some(length):
                        # Skip empty line after header
                        match self.read_line():
                            case Ok(_):
                                pass
                            case Err(_):
                                self.alive = false
                                return None

                        # Read body
                        match self.read_exact(length):
                            case Ok(body):
                                self.log_debug("Received: " + body)
                                # Parse JSON-RPC request
                                match parse(body):
                                    case Ok(JsonValue.Object(obj)):
                                        return parse_json_rpc_request(obj)
                                    case _:
                                        return None
                            case Err(_):
                                self.alive = false
                                return None
                    case None:
                        return None
            case Err(_):
                self.alive = false
                return None

    fn write_response(response: JsonRpcResponse):
        """Write MCP-framed response to TCP stream."""
        if not self.alive:
            return

        val body = response.to_json()
        self.log_debug("Sending response: " + body)

        val header = "Content-Length: " + body.len().to_string() + "\r\n\r\n"
        val message = header + body

        val bytes = message.as_bytes()
        val written = monoio_tcp_write(self.stream_handle, bytes)
        if written < 0:
            self.alive = false

    fn write_error(id: i64, code: i64, message: text):
        """Write MCP-framed error response to TCP stream."""
        if not self.alive:
            return

        var builder = JsonBuilder.new()
        builder = builder.set_string("jsonrpc", "2.0")
        builder = builder.set_int("id", id)

        var error_obj: Dict<text, JsonValue> = {}
        error_obj["code"] = JsonValue.Integer(code)
        error_obj["message"] = JsonValue.text(message)
        builder = builder.set_object("error", error_obj)

        val body = stringify(builder.build())
        self.log_debug("Sending error: " + body)

        val header = "Content-Length: " + body.len().to_string() + "\r\n\r\n"
        val full_message = header + body

        val bytes = full_message.as_bytes()
        val written = monoio_tcp_write(self.stream_handle, bytes)
        if written < 0:
            self.alive = false

    fn is_alive() -> bool:
        return self.alive

# Helper to parse JSON-RPC request from object
fn parse_json_rpc_request(obj: Dict<text, JsonValue>) -> Option<JsonRpcRequest>:
    var id: i64 = 0
    var method = ""
    var params: Dict<text, Any> = {}

    match obj.get("id"):
        case Some(JsonValue.Integer(i)):
            id = i
        case _:
            pass

    match obj.get("method"):
        case Some(JsonValue.text(m)):
            method = m
        case _:
            return None

    match obj.get("params"):
        case Some(JsonValue.Object(p)):
            params = json_object_to_dict(p)
        case _:
            pass

    Some(JsonRpcRequest(id: id, method: method, params: params))

# Message-based transport (for testing)
pub class MockTransport:
    pub requests: List<JsonRpcRequest>
    pub responses: List<JsonRpcResponse>
    pub errors: List<Dict<text, Any>>
    pub current_index: i64

    pub fn new(requests: List<JsonRpcRequest>) -> MockTransport:
        return MockTransport:
            requests: requests
            responses: []
            errors: []
            current_index: 0

    pub fn add_request(self, request: JsonRpcRequest):
        self.requests.append(request)

    # Add request from JSON string (for easy testing)
    pub fn add_json_request(self, json_str: text) -> Result<(), text>:
        match json.parse(json_str):
            case Ok(JsonValue.Object(obj)):
                id = 0
                method = ""
                params = {}

                if obj.has_key("id"):
                    match obj.get("id"):
                        case JsonValue.Integer(i):
                            id = i
                        case _:
                            pass

                if obj.has_key("method"):
                    match obj.get("method"):
                        case JsonValue.text(m):
                            method = m
                        case _:
                            return Err("method must be string")

                if obj.has_key("params"):
                    match obj.get("params"):
                        case JsonValue.Object(p):
                            params = json_object_to_dict(p)
                        case _:
                            pass

                self.requests.append(JsonRpcRequest.new(id, method, params))
                return Ok(())

            case _:
                return Err("invalid JSON")

    pub fn get_responses(self) -> List<JsonRpcResponse>:
        return self.responses

impl Transport for MockTransport:
    fn read_message() -> Option<JsonRpcRequest>:
        if self.current_index < self.requests.len():
            request = self.requests[self.current_index]
            self.current_index = self.current_index + 1
            return Some(request)
        else:
            return None

    fn write_response(response: JsonRpcResponse):
        self.responses.append(response)

    fn write_error(id: i64, code: i64, message: text):
        self.errors.append({
            "id": id,
            "code": code,
            "message": message
        })

    fn is_alive() -> bool:
        return self.current_index < self.requests.len()

# Helper: Convert JsonValue object to Dict<text, Any>
fn json_object_to_dict(obj: Dict<text, JsonValue>) -> Dict<text, Any>:
    result = {}
    for key in obj.keys():
        result.set(key, json_value_to_any(obj.get(key)))
    return result

# Helper: Convert JsonValue to Any
fn json_value_to_any(value: JsonValue) -> Any:
    match value:
        case JsonValue.Null:
            return None
        case JsonValue.bool(b):
            return b
        case JsonValue.Integer(i):
            return i
        case JsonValue.Number(n):
            return n
        case JsonValue.text(s):
            return s
        case JsonValue.Array(arr):
            result = []
            for item in arr:
                result.append(json_value_to_any(item))
            return result
        case JsonValue.Object(obj):
            return json_object_to_dict(obj)

# Helper: Convert Any to JsonValue
fn any_to_json(value: Any) -> JsonValue:
    if value == None:
        return JsonValue.Null

    # Try to match common types
    # Note: This is a simplified implementation
    # In a full implementation, we'd use type reflection

    match value:
        case v if v is bool:
            return JsonValue.bool(v as bool)
        case v if v is i64:
            return JsonValue.Integer(v as i64)
        case v if v is f64:
            return JsonValue.Number(v as f64)
        case v if v is text:
            return JsonValue.text(v as text)
        case v if v is List:
            arr = []
            for item in v as List<Any>:
                arr.append(any_to_json(item))
            return JsonValue.Array(arr)
        case v if v is Dict:
            obj = {}
            for key in (v as Dict<text, Any>).keys():
                obj.set(key, any_to_json((v as Dict<text, Any>).get(key)))
            return JsonValue.Object(obj)
        case _:
            # Fallback: convert to string
            return JsonValue.text(value.to_string())

# Extern functions for stdio operations
extern fn stdin_read_char() -> text
extern fn stdout_write(s: text)
extern fn stdout_flush()
extern fn stderr_write(s: text)
extern fn stderr_flush()
