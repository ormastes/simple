# MCP Resource Provider Interface
# Implement this interface to create MCP support for any language/tool

use core.*
use mcp.core.protocol.*

# Resource provider interface - implement this for your language/tool
pub trait ResourceProvider:
    # List all available resources
    fn list_resources() -> List<Resource>
    
    # Read a specific resource by URI
    fn read_resource(uri: text) -> ResourceContents
    
    # Optional: Search for resources
    fn search_resources(query: text) -> List<Resource>:
        # Default: return empty list
        return []

# Base provider implementation with common functionality
pub class BaseProvider:
    pub resources: Dict<text, Resource>
    pub root_path: text
    
    pub fn new(root_path: text) -> BaseProvider:
        return BaseProvider:
            resources: {}
            root_path: root_path
    
    pub fn add_resource(self, resource: Resource):
        self.resources.set(resource.uri, resource)
    
    pub fn get_resource(self, uri: text) -> Option<Resource>:
        if self.resources.has_key(uri):
            return Some(self.resources.get(uri))
        else:
            return None

# File-based resource provider
pub class FileProvider:
    pub base: BaseProvider
    
    pub fn new(root_path: text) -> FileProvider:
        return FileProvider:
            base: BaseProvider.new(root_path)
    
    # Scan directory and register files
    pub fn scan_directory(self, pattern: text):
        # TODO: [stdlib][P3] Use file system API when available
        # For now, manual registration
        pass
    
    pub fn register_file(self, path: text, mime_type: text):
        """Register a file resource.

        Args:
            path: File path
            mime_type: MIME type
        """
        @extern("runtime", "rt_path_basename")
        fn _rt_path_basename(path_ptr: &u8, path_len: u64) -> text

        uri = "file://" + path
        name = _rt_path_basename(path.ptr(), path.len())
        resource = Resource.new(uri, name, mime_type)
        self.base.add_resource(resource)

impl ResourceProvider for FileProvider:
    fn list_resources() -> List<Resource>:
        result = []
        for uri in self.base.resources.keys():
            resource = self.base.resources.get(uri)
            result.append(resource)
        return result
    
    fn read_resource(uri: text) -> ResourceContents:
        # TODO: [stdlib][P3] Read actual file when file I/O available
        text = "# File: " + uri
        return ResourceContents.new(uri, "text/plain", text)

# Symbol-based provider for code navigation
pub class SymbolProvider:
    pub base: BaseProvider
    pub symbols: Dict<text, Symbol>
    
    pub fn new(root_path: text) -> SymbolProvider:
        return SymbolProvider:
            base: BaseProvider.new(root_path)
            symbols: {}
    
    pub fn register_symbol(self, symbol: Symbol):
        uri = "symbol://" + symbol.name
        name = symbol.name
        resource = Resource.new(uri, name, "text/x-symbol")
        self.base.add_resource(resource)
        self.symbols.set(uri, symbol)

# Symbol type (forward declaration - defined by language impl)
pub class Symbol:
    pub name: text
    pub kind: text
    pub signature: text
    
    pub fn new(name: text, kind: text, signature: text) -> Symbol:
        return Symbol:
            name: name
            kind: kind
            signature: signature
