# MCP Resource Provider Interface
# Implement this interface to create MCP support for any language/tool

use core.*
use mcp.core.protocol.*

# Resource provider interface - implement this for your language/tool
pub trait ResourceProvider:
    # List all available resources
    fn list_resources(self) -> List[Resource]
    
    # Read a specific resource by URI
    fn read_resource(self, uri: String) -> ResourceContents
    
    # Optional: Search for resources
    fn search_resources(self, query: String) -> List[Resource]:
        # Default: return empty list
        return []

# Base provider implementation with common functionality
pub class BaseProvider:
    pub resources: Dict[String, Resource]
    pub root_path: String
    
    pub fn new(root_path: String) -> BaseProvider:
        return BaseProvider:
            resources: {}
            root_path: root_path
    
    pub fn add_resource(self, resource: Resource):
        self.resources.set(resource.uri, resource)
    
    pub fn get_resource(self, uri: String) -> Option[Resource]:
        if self.resources.has_key(uri):
            return Some(self.resources.get(uri))
        else:
            return None

# File-based resource provider
pub class FileProvider:
    pub base: BaseProvider
    
    pub fn new(root_path: String) -> FileProvider:
        return FileProvider:
            base: BaseProvider.new(root_path)
    
    # Scan directory and register files
    pub fn scan_directory(self, pattern: String):
        # TODO: [stdlib][P3] Use file system API when available
        # For now, manual registration
        pass
    
    pub fn register_file(self, path: String, mime_type: String):
        uri = "file://" + path
        name = path  # TODO: [stdlib][P3] Extract filename
        resource = Resource.new(uri, name, mime_type)
        self.base.add_resource(resource)

impl ResourceProvider for FileProvider:
    fn list_resources(self) -> List[Resource]:
        result = []
        for uri in self.base.resources.keys():
            resource = self.base.resources.get(uri)
            result.append(resource)
        return result
    
    fn read_resource(self, uri: String) -> ResourceContents:
        # TODO: [stdlib][P3] Read actual file when file I/O available
        text = "# File: " + uri
        return ResourceContents.new(uri, "text/plain", text)

# Symbol-based provider for code navigation
pub class SymbolProvider:
    pub base: BaseProvider
    pub symbols: Dict[String, Symbol]
    
    pub fn new(root_path: String) -> SymbolProvider:
        return SymbolProvider:
            base: BaseProvider.new(root_path)
            symbols: {}
    
    pub fn register_symbol(self, symbol: Symbol):
        uri = "symbol://" + symbol.name
        name = symbol.name
        resource = Resource.new(uri, name, "text/x-symbol")
        self.base.add_resource(resource)
        self.symbols.set(uri, symbol)

# Symbol type (forward declaration - defined by language impl)
pub class Symbol:
    pub name: String
    pub kind: String
    pub signature: String
    
    pub fn new(name: String, kind: String, signature: String) -> Symbol:
        return Symbol:
            name: name
            kind: kind
            signature: signature
