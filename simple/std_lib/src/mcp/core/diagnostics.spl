# Diagnostic Grouping for MCP
# Groups compiler/linter diagnostics by file, severity, and category

use core.*

# Diagnostic severity
pub enum DiagnosticSeverity:
    Error
    Warning
    Info
    Hint

impl DiagnosticSeverity:
    pub fn to_string(self) -> String:
        """Convert diagnostic severity to string."""
        match self:
            case Error: "error"
            case Warning: "warning"
            case Info: "info"
            case Hint: "hint"

    pub fn description(self) -> String:
        """Get diagnostic severity description."""
        match self:
            case Error: "Compilation error (must fix)"
            case Warning: "Warning (should fix)"
            case Info: "Information message"
            case Hint: "Suggestion or hint"

    pub fn is_error(self) -> bool:
        """Check if severity is Error."""
        match self:
            case Error: true
            case _: false

    pub fn is_warning(self) -> bool:
        """Check if severity is Warning."""
        match self:
            case Warning: true
            case _: false

    pub fn is_info(self) -> bool:
        """Check if severity is Info."""
        match self:
            case Info: true
            case _: false

    pub fn is_hint(self) -> bool:
        """Check if severity is Hint."""
        match self:
            case Hint: true
            case _: false

    pub fn is_blocking(self) -> bool:
        """Check if this severity blocks compilation."""
        match self:
            case Error: true
            case _: false

    pub fn is_actionable(self) -> bool:
        """Check if this severity requires action (Error or Warning)."""
        match self:
            case Error: true
            case Warning: true
            case _: false

    pub fn severity_level(self) -> i32:
        """Get numeric severity level (higher = more severe)."""
        match self:
            case Error: 3
            case Warning: 2
            case Info: 1
            case Hint: 0

    pub fn summary(self) -> String:
        """Get diagnostic severity summary."""
        let name = self.to_string()
        let desc = self.description()
        let level = self.severity_level()
        let status = if self.is_blocking():
            "blocking"
        elif self.is_actionable():
            "actionable"
        else:
            "informational"
        return "DiagnosticSeverity: {name} ({desc}, level={level}, {status})"

# Diagnostic category
pub enum DiagnosticCategory:
    Syntax
    Type
    Lint
    Performance
    Security
    Style
    Deprecated

impl DiagnosticCategory:
    pub fn to_string(self) -> String:
        """Convert diagnostic category to string."""
        match self:
            case Syntax: "syntax"
            case Type: "type"
            case Lint: "lint"
            case Performance: "performance"
            case Security: "security"
            case Style: "style"
            case Deprecated: "deprecated"

    pub fn description(self) -> String:
        """Get diagnostic category description."""
        match self:
            case Syntax: "Syntax error in code"
            case Type: "Type checking error"
            case Lint: "Code quality issue"
            case Performance: "Performance issue"
            case Security: "Security vulnerability"
            case Style: "Code style violation"
            case Deprecated: "Use of deprecated feature"

    pub fn is_syntax(self) -> bool:
        """Check if category is Syntax."""
        match self:
            case Syntax: true
            case _: false

    pub fn is_type(self) -> bool:
        """Check if category is Type."""
        match self:
            case Type: true
            case _: false

    pub fn is_lint(self) -> bool:
        """Check if category is Lint."""
        match self:
            case Lint: true
            case _: false

    pub fn is_performance(self) -> bool:
        """Check if category is Performance."""
        match self:
            case Performance: true
            case _: false

    pub fn is_security(self) -> bool:
        """Check if category is Security."""
        match self:
            case Security: true
            case _: false

    pub fn is_style(self) -> bool:
        """Check if category is Style."""
        match self:
            case Style: true
            case _: false

    pub fn is_deprecated(self) -> bool:
        """Check if category is Deprecated."""
        match self:
            case Deprecated: true
            case _: false

    pub fn is_critical(self) -> bool:
        """Check if category is critical (Syntax, Type, or Security)."""
        match self:
            case Syntax: true
            case Type: true
            case Security: true
            case _: false

    pub fn is_code_quality(self) -> bool:
        """Check if category is code quality related (Lint, Style, Performance)."""
        match self:
            case Lint: true
            case Style: true
            case Performance: true
            case _: false

    pub fn priority(self) -> i32:
        """Get priority level (higher = more important)."""
        match self:
            case Syntax: 5
            case Type: 5
            case Security: 4
            case Performance: 3
            case Deprecated: 2
            case Lint: 1
            case Style: 1

    pub fn summary(self) -> String:
        """Get diagnostic category summary."""
        let name = self.to_string()
        let desc = self.description()
        let priority_level = self.priority()
        let group = if self.is_critical():
            "critical"
        elif self.is_code_quality():
            "quality"
        else:
            "deprecation"
        return "DiagnosticCategory: {name} ({desc}, priority={priority_level}, {group})"

# Diagnostic entry
pub class Diagnostic:
    pub file_path: String
    pub line: i64
    pub column: i64
    pub severity: DiagnosticSeverity
    pub category: DiagnosticCategory
    pub code: String
    pub message: String

# Diagnostic summary
pub class DiagnosticSummary:
    pub error_count: i64
    pub warning_count: i64
    pub info_count: i64
    pub hint_count: i64
    pub diagnostics: List[Diagnostic]
    pub by_file: Dict[String, List[Diagnostic]]
    pub by_category: Dict[String, List[Diagnostic]]

# Parse diagnostics from compiler/linter output
pub fn parse_diagnostics(source: String) -> DiagnosticSummary:
    lines = source.split("\n")
    diagnostics = []

    error_count = 0
    warning_count = 0
    info_count = 0
    hint_count = 0

    for line in lines:
        # Parse diagnostic format: file.spl:10:5: error: message
        if line.contains(": error:") or line.contains(": warning:") or line.contains(": info:") or line.contains(": hint:"):
            diag = parse_diagnostic_line(line)
            diagnostics.append(diag)

            if diag.severity == DiagnosticSeverity.Error:
                error_count = error_count + 1
            elif diag.severity == DiagnosticSeverity.Warning:
                warning_count = warning_count + 1
            elif diag.severity == DiagnosticSeverity.Info:
                info_count = info_count + 1
            else:
                hint_count = hint_count + 1

    # Group by file
    by_file = {}
    for diag in diagnostics:
        if not by_file.has_key(diag.file_path):
            by_file.set(diag.file_path, [])
        file_diags = by_file.get(diag.file_path)
        file_diags.append(diag)

    # Group by category
    by_category = {}
    for diag in diagnostics:
        cat_name = category_to_string(diag.category)
        if not by_category.has_key(cat_name):
            by_category.set(cat_name, [])
        cat_diags = by_category.get(cat_name)
        cat_diags.append(diag)

    return DiagnosticSummary:
        error_count: error_count
        warning_count: warning_count
        info_count: info_count
        hint_count: hint_count
        diagnostics: diagnostics
        by_file: by_file
        by_category: by_category

# Parse single diagnostic line
fn parse_diagnostic_line(line: String) -> Diagnostic:
    # Format: file.spl:10:5: error[E0001]: message

    # Extract file path
    file_end = line.find(":")
    file_path = ""
    if file_end >= 0:
        file_path = line[0:file_end]

    # Extract line number
    line_start = file_end + 1
    line_end = line.find(":", line_start)
    line_num = 0
    if line_end >= 0:
        line_str = line[line_start:line_end]
        # TODO: [stdlib][P3] Need to_i64()
        line_num = 0

    # Extract column number
    col_start = line_end + 1
    col_end = line.find(":", col_start)
    column = 0
    if col_end >= 0:
        col_str = line[col_start:col_end]
        # column = col_str.to_i64()
        column = 0

    # Extract severity and message
    severity_start = col_end + 1
    msg_start = line.find(":", severity_start)

    severity = DiagnosticSeverity.Info
    code = ""
    message = ""

    if msg_start >= 0:
        severity_part = line[severity_start:msg_start].strip()

        if severity_part.contains("error"):
            severity = DiagnosticSeverity.Error
        elif severity_part.contains("warning"):
            severity = DiagnosticSeverity.Warning
        elif severity_part.contains("hint"):
            severity = DiagnosticSeverity.Hint

        # Extract code if present [E0001]
        if severity_part.contains("["):
            code_start = severity_part.find("[")
            code_end = severity_part.find("]")
            if code_start >= 0 and code_end > code_start:
                code = severity_part[code_start+1:code_end]

        message = line[msg_start+1:].strip()

    # Detect category from code or message
    category = detect_category(code, message)

    return Diagnostic:
        file_path: file_path
        line: line_num
        column: column
        severity: severity
        category: category
        code: code
        message: message

# Detect diagnostic category
fn detect_category(code: String, message: String) -> DiagnosticCategory:
    msg_lower = message.to_lower()

    if code.starts_with("E") or msg_lower.contains("syntax"):
        return DiagnosticCategory.Syntax
    elif code.starts_with("T") or msg_lower.contains("type"):
        return DiagnosticCategory.Type
    elif code.starts_with("L") or msg_lower.contains("lint"):
        return DiagnosticCategory.Lint
    elif msg_lower.contains("performance") or msg_lower.contains("slow"):
        return DiagnosticCategory.Performance
    elif msg_lower.contains("security") or msg_lower.contains("unsafe"):
        return DiagnosticCategory.Security
    elif msg_lower.contains("style") or msg_lower.contains("format"):
        return DiagnosticCategory.Style
    elif msg_lower.contains("deprecated"):
        return DiagnosticCategory.Deprecated
    else:
        return DiagnosticCategory.Lint

# Format diagnostic summary for MCP
pub fn format_diagnostic_summary(summary: DiagnosticSummary) -> String:
    result = "DIAG> Diagnostic Summary {\n"
    result = result + "  Total: " + summary.diagnostics.len().to_string() + "\n"

    if summary.error_count > 0:
        result = result + "  Errors:   " + summary.error_count.to_string() + "\n"
    if summary.warning_count > 0:
        result = result + "  Warnings: " + summary.warning_count.to_string() + "\n"
    if summary.info_count > 0:
        result = result + "  Info:     " + summary.info_count.to_string() + "\n"
    if summary.hint_count > 0:
        result = result + "  Hints:    " + summary.hint_count.to_string() + "\n"

    result = result + "}\n"
    return result

# Format diagnostics grouped by file
pub fn format_by_file(summary: DiagnosticSummary) -> String:
    result = "DIAG> By File {\n"

    for file_path in summary.by_file.keys():
        diags = summary.by_file.get(file_path)
        result = result + "  " + file_path + ": " + diags.len().to_string() + " issues\n"

        for diag in diags:
            severity_str = severity_to_string(diag.severity)
            result = result + "    L" + diag.line.to_string() + ":" + diag.column.to_string()
            result = result + " [" + severity_str + "] " + diag.message + "\n"

    result = result + "}\n"
    return result

# Format diagnostics grouped by category
pub fn format_by_category(summary: DiagnosticSummary) -> String:
    result = "DIAG> By Category {\n"

    for category_name in summary.by_category.keys():
        diags = summary.by_category.get(category_name)
        result = result + "  " + category_name + ": " + diags.len().to_string() + " issues\n"

    result = result + "}\n"
    return result

# Convert severity to string
fn severity_to_string(severity: DiagnosticSeverity) -> String:
    if severity == DiagnosticSeverity.Error:
        return "ERROR"
    elif severity == DiagnosticSeverity.Warning:
        return "WARN"
    elif severity == DiagnosticSeverity.Info:
        return "INFO"
    else:
        return "HINT"

# Convert category to string
fn category_to_string(category: DiagnosticCategory) -> String:
    if category == DiagnosticCategory.Syntax:
        return "Syntax"
    elif category == DiagnosticCategory.Type:
        return "Type"
    elif category == DiagnosticCategory.Lint:
        return "Lint"
    elif category == DiagnosticCategory.Performance:
        return "Performance"
    elif category == DiagnosticCategory.Security:
        return "Security"
    elif category == DiagnosticCategory.Style:
        return "Style"
    else:
        return "Deprecated"

# Filter errors only
pub fn filter_errors_only(summary: DiagnosticSummary) -> List[Diagnostic]:
    errors = []
    for diag in summary.diagnostics:
        if diag.severity == DiagnosticSeverity.Error:
            errors.append(diag)
    return errors
