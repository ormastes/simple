# MCP-MCP Advanced Features
#
# Advanced optimization and extensibility features for MCP-MCP protocol.

use core.*
use mcp.core.protocol.*

# FFI for process execution
@extern("runtime", "rt_process_run")
fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

# Module-level storage for metadata overlays
# Key format: "{name}:{line}:{column}" -> Dict of overlay key-value pairs
var _metadata_overlays: Dict<text, Dict<text, text>> = {}

fn get_metadata_key(meta: &McpMetadata) -> text:
    return "{meta.name}:{meta.location.line}:{meta.location.column}"

# Advanced MCP features manager
pub struct McpAdvanced:
    cache: McpCache
    plugin_registry: PluginRegistry

# =============================================================================
# #1280: Coverage overlay integration
# =============================================================================

pub fn add_coverage_overlay(output: &mut McpOutput, coverage: &CoverageData) -> Result<(), McpError>:
    for item in &mut output.items:
        if val Some(cov) = coverage.get_coverage(&item.metadata.location):
            item.metadata.add_overlay("coverage", format!("{}%", cov.percentage))
    return Ok(())

struct CoverageData:
    file_coverage: Dict<text, FileCoverage>

impl CoverageData:
    fn get_coverage(loc: &SourceLocation) -> Option<Coverage>:
        return None

struct FileCoverage:
    lines: Dict<u32, Coverage>

struct Coverage:
    hits: u64
    percentage: f32

# =============================================================================
# #1281: Block guide markers
# =============================================================================

pub fn add_block_guides(output: &mut McpOutput) -> Result<(), McpError>:
    for item in &mut output.items:
        if not item.children.is_empty():
            # Add "end" marker
            val marker = match item.kind:
                case ItemKind::Function: "V• end"
                case ItemKind::Struct: "V• end"
                case ItemKind::Enum: "V• end"
                case _: ""

            if not marker.is_empty():
                item.children.push(McpItem {
                    kind: ItemKind::Marker,
                    line: marker.to_string(),
                    children: [],
                    metadata: McpMetadata::empty()
                })
    return Ok(())

# =============================================================================
# #1282: Line number formatting
# =============================================================================

pub fn format_with_line_numbers(output: &McpOutput, format: LineNumberFormat) -> text:
    var result = text::new()
    val width = match format:
        case LineNumberFormat::Plain: 0
        case LineNumberFormat::ZeroPadded(w): w

    for item in &output.items:
        val line_num = item.metadata.location.line
        val line_str = if width > 0:
            format!("{:0width$} ", line_num)
        else:
            format!("{} ", line_num)

        result.push_str(&line_str)
        result.push_str(&item.line)
        result.push('\n')

    return result

pub enum LineNumberFormat:
    Plain
    ZeroPadded(u8)

impl LineNumberFormat:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_plain() -> bool:
        """Check if format is Plain.

        Returns:
            true for Plain

        Example:
            LineNumberFormat::Plain.is_plain()  # → true
        """
        match self:
            case Plain: true
            case _: false

    fn is_zero_padded() -> bool:
        """Check if format is ZeroPadded.

        Returns:
            true for ZeroPadded

        Example:
            LineNumberFormat::ZeroPadded(4).is_zero_padded()  # → true
        """
        match self:
            case ZeroPadded(_): true
            case _: false

    fn get_width() -> u8:
        """Get padding width.

        Returns:
            Width for ZeroPadded, 0 for Plain

        Example:
            LineNumberFormat::ZeroPadded(4).get_width()  # → 4
            LineNumberFormat::Plain.get_width()  # → 0
        """
        match self:
            case ZeroPadded(w): w
            case Plain: 0

    fn uses_padding() -> bool:
        """Check if format uses zero padding.

        Returns:
            true for ZeroPadded

        Example:
            LineNumberFormat::ZeroPadded(4).uses_padding()  # → true
        """
        return self.is_zero_padded()

    fn to_string() -> text:
        """Convert format to string.

        Returns:
            Format name

        Example:
            LineNumberFormat::Plain.to_string()  # → "plain"
        """
        match self:
            case Plain: "plain"
            case ZeroPadded(_): "zero_padded"

    fn description() -> text:
        """Get format description.

        Returns:
            Human-readable description

        Example:
            LineNumberFormat::ZeroPadded(4).description()
            # → "Zero-padded with width 4"
        """
        match self:
            case Plain: "Plain line numbers"
            case ZeroPadded(w): "Zero-padded with width {w}"

    fn summary() -> text:
        """Get summary of line number format.

        Returns:
            Human-readable summary

        Example:
            LineNumberFormat::ZeroPadded(4).summary()
            # → "LineNumberFormat: zero_padded (width=4)"
        """
        val name = self.to_string()
        match self:
            case Plain:
                "LineNumberFormat: {name}"
            case ZeroPadded(w):
                "LineNumberFormat: {name} (width={w})"

# =============================================================================
# #1283: Context pack integration
# =============================================================================

pub fn extract_context_pack(output: &McpOutput, symbols: &Array<text>) -> ContextPack:
    var pack = ContextPack::new()

    for symbol in symbols:
        if val Some(item) = output.find_symbol(symbol):
            pack.add_symbol(item.clone())

    return pack

pub struct ContextPack:
    symbols: Array<McpItem>
    dependencies: Array<text>

impl ContextPack:
    static fn new() -> ContextPack:
        return ContextPack { symbols: [], dependencies: [] }

    fn add_symbol(symbol: McpItem):
        self.symbols.push(symbol)

# =============================================================================
# #1284: Dependency symbol extraction
# =============================================================================

pub fn extract_dependencies(output: &McpOutput) -> Array<Dependency>:
    var deps: Array<Dependency> = []

    for item in &output.items:
        if item.kind == ItemKind::Import:
            deps.push(Dependency {
                name: item.metadata.name.clone(),
                kind: DependencyKind::External
            })

    return deps

pub struct Dependency:
    pub name: text
    pub kind: DependencyKind

pub enum DependencyKind:
    External
    Internal

impl DependencyKind:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_external() -> bool:
        """Check if dependency is External.

        Returns:
            true for External

        Example:
            DependencyKind::External.is_external()  # → true
        """
        match self:
            case External: true
            case _: false

    fn is_internal() -> bool:
        """Check if dependency is Internal.

        Returns:
            true for Internal

        Example:
            DependencyKind::Internal.is_internal()  # → true
        """
        match self:
            case Internal: true
            case _: false

    fn is_local() -> bool:
        """Check if dependency is local (internal).

        Returns:
            true for Internal

        Example:
            DependencyKind::Internal.is_local()  # → true
        """
        return self.is_internal()

    fn requires_download() -> bool:
        """Check if dependency might require downloading.

        Returns:
            true for External

        Example:
            DependencyKind::External.requires_download()  # → true
            DependencyKind::Internal.requires_download()  # → false
        """
        match self:
            case External: true
            case Internal: false

    fn to_string() -> text:
        """Convert dependency kind to string.

        Returns:
            Kind name

        Example:
            DependencyKind::External.to_string()  # → "external"
        """
        match self:
            case External: "external"
            case Internal: "internal"

    fn description() -> text:
        """Get dependency kind description.

        Returns:
            Human-readable description

        Example:
            DependencyKind::External.description()
            # → "External dependency (third-party)"
        """
        match self:
            case External: "External dependency (third-party)"
            case Internal: "Internal dependency (local project)"

    fn summary() -> text:
        """Get summary of dependency kind.

        Returns:
            Human-readable summary

        Example:
            DependencyKind::External.summary()
            # → "DependencyKind: external (third-party, may require download)"
        """
        val name = self.to_string()
        match self:
            case External:
                "DependencyKind: {name} (third-party, may require download)"
            case Internal:
                "DependencyKind: {name} (local project)"

# =============================================================================
# #1285-1286: Minimal context bundling & Diff mode
# =============================================================================

pub fn minimal_bundle(output: &McpOutput, only_public: bool) -> McpOutput:
    var minimal = McpOutput::new()

    for item in &output.items:
        if only_public and item.metadata.visibility != "public":
            continue
        minimal.add_item(item.clone())

    return minimal

pub fn diff_mode(old_output: &McpOutput, new_output: &McpOutput) -> McpOutput:
    var diff = McpOutput::new()

    # Find changed symbols
    for new_item in &new_output.items:
        val changed = if val Some(old_item) = old_output.find_symbol(&new_item.metadata.name):
            old_item.line != new_item.line
        else:
            true  # New symbol

        if changed:
            diff.add_item(new_item.clone())

    return diff

# =============================================================================
# #1287-1288: Blame integration & Cross-reference inlining
# =============================================================================

pub fn add_blame_info(output: &mut McpOutput, git_repo: &str) -> Result<(), McpError>:
    for item in &mut output.items:
        # Get git blame info for each item's location
        val file_path = item.metadata.location.file
        val line = item.metadata.location.line

        val cmd = "git"
        val args = "-C {git_repo} blame -L {line},{line} --porcelain {file_path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0 and not stdout.is_empty():
            # Parse porcelain output
            var author = "unknown"
            var commit = "unknown"

            for blame_line in stdout.lines():
                if blame_line.starts_with("author "):
                    author = blame_line.substring(7, blame_line.len())
                elif blame_line.len() == 40 and not blame_line.contains(" "):
                    commit = blame_line.substring(0, 8)  # Short commit hash

            item.metadata.add_overlay("author", author)
            item.metadata.add_overlay("commit", commit)
        else:
            item.metadata.add_overlay("author", "unknown")
            item.metadata.add_overlay("commit", "unknown")
    return Ok(())

pub fn inline_call_sites(output: &mut McpOutput, call_graph: &CallGraph) -> Result<(), McpError>:
    for item in &mut output.items:
        if item.kind == ItemKind::Function:
            if val Some(callers) = call_graph.get_callers(&item.metadata.name):
                for caller in callers:
                    item.metadata.add_overlay("caller", caller)
    return Ok(())

pub struct CallGraph:
    edges: Dict<text, Array<text>>

impl CallGraph:
    fn get_callers(name: &str) -> Option<Array<text>>:
        return self.edges.get(name).cloned()

# =============================================================================
# #1289-1290: Binary format & Streaming
# =============================================================================

pub fn encode_protobuf(output: &McpOutput) -> Result<Array<u8>, McpError>:
    """Encode MCP output in protobuf-like binary format.

    Wire format:
    - Field 1 (items): repeated message
      - Each item: [tag][length][kind][line_len][line][children_count][children...][metadata]

    Uses varint encoding for integers and length-prefixed strings.
    """
    var bytes: Array<u8> = []

    # Header: magic bytes "MCP1"
    bytes.push(0x4D)  # 'M'
    bytes.push(0x43)  # 'C'
    bytes.push(0x50)  # 'P'
    bytes.push(0x31)  # '1'

    # Encode item count as varint
    encode_varint(&mut bytes, output.items.len() as u64)

    # Encode each item
    for item in output.items:
        encode_mcp_item(&mut bytes, item)?

    Ok(bytes)

fn encode_varint(bytes: &mut Array<u8>, value: u64):
    """Encode unsigned integer as varint."""
    var v = value
    while v >= 0x80:
        bytes.push(((v & 0x7F) | 0x80) as u8)
        v = v >> 7
    bytes.push((v & 0x7F) as u8)

fn encode_string(bytes: &mut Array<u8>, s: &str):
    """Encode string with length prefix."""
    val s_bytes = s.as_bytes()
    encode_varint(bytes, s_bytes.len() as u64)
    for b in s_bytes:
        bytes.push(b)

fn encode_item_kind(kind: &ItemKind) -> u8:
    """Map ItemKind to byte value."""
    match kind:
        case Function: 0
        case Struct: 1
        case Enum: 2
        case EnumVariant: 3
        case Trait: 4
        case Impl: 5
        case Module: 6
        case Import: 7
        case Field: 8
        case _: 255

fn encode_mcp_item(bytes: &mut Array<u8>, item: &McpItem) -> Result<(), McpError>:
    """Encode single MCP item."""
    # Kind (1 byte)
    bytes.push(encode_item_kind(&item.kind))

    # Line text
    encode_string(bytes, &item.line)

    # Children count and recursive encoding
    encode_varint(bytes, item.children.len() as u64)
    for child in item.children:
        encode_mcp_item(bytes, child)?

    # Metadata (simplified - just encode overlay count and key-value pairs)
    val overlays = item.metadata.get_overlays()
    encode_varint(bytes, overlays.len() as u64)
    for (key, value) in overlays:
        encode_string(bytes, key)
        encode_string(bytes, value)

    Ok(())

pub fn decode_protobuf(bytes: &Array<u8>) -> Result<McpOutput, McpError>:
    """Decode MCP output from protobuf-like binary format."""
    if bytes.len() < 4:
        return Err(McpError::ParseError("Invalid header"))

    # Check magic bytes
    if bytes[0] != 0x4D or bytes[1] != 0x43 or bytes[2] != 0x50 or bytes[3] != 0x31:
        return Err(McpError::ParseError("Invalid magic bytes"))

    var offset: usize = 4
    var output = McpOutput::new()

    # Decode item count
    val (item_count, new_offset) = decode_varint(bytes, offset)?
    offset = new_offset

    # Decode items
    for _ in 0..item_count:
        val (item, new_offset) = decode_mcp_item(bytes, offset)?
        output.add_item(item)
        offset = new_offset

    Ok(output)

fn decode_varint(bytes: &Array<u8>, offset: usize) -> Result<(u64, usize), McpError>:
    """Decode varint from bytes."""
    var value: u64 = 0
    var shift: u64 = 0
    var pos = offset

    while pos < bytes.len():
        val b = bytes[pos] as u64
        value = value | ((b & 0x7F) << shift)
        pos = pos + 1

        if (b & 0x80) == 0:
            return Ok((value, pos))

        shift = shift + 7
        if shift >= 64:
            return Err(McpError::ParseError("Varint overflow"))

    Err(McpError::ParseError("Unexpected end of varint"))

fn decode_string(bytes: &Array<u8>, offset: usize) -> Result<(text, usize), McpError>:
    """Decode length-prefixed string."""
    val (len, new_offset) = decode_varint(bytes, offset)?
    val end = new_offset + (len as usize)

    if end > bytes.len():
        return Err(McpError::ParseError("String extends past end"))

    var s = ""
    for i in new_offset..end:
        s = s + (bytes[i] as char).to_string()

    Ok((s, end))

fn decode_item_kind(b: u8) -> ItemKind:
    """Map byte to ItemKind."""
    match b:
        case 0: ItemKind::Function
        case 1: ItemKind::Struct
        case 2: ItemKind::Enum
        case 3: ItemKind::EnumVariant
        case 4: ItemKind::Trait
        case 5: ItemKind::Impl
        case 6: ItemKind::Module
        case 7: ItemKind::Import
        case 8: ItemKind::Field
        case _: ItemKind::Function  # Default

fn decode_mcp_item(bytes: &Array<u8>, offset: usize) -> Result<(McpItem, usize), McpError>:
    """Decode single MCP item."""
    var pos = offset

    # Kind
    if pos >= bytes.len():
        return Err(McpError::ParseError("Unexpected end"))
    val kind = decode_item_kind(bytes[pos])
    pos = pos + 1

    # Line text
    val (line, new_pos) = decode_string(bytes, pos)?
    pos = new_pos

    # Children
    val (child_count, new_pos2) = decode_varint(bytes, pos)?
    pos = new_pos2

    var children: Array<McpItem> = []
    for _ in 0..child_count:
        val (child, new_pos) = decode_mcp_item(bytes, pos)?
        children.push(child)
        pos = new_pos

    # Metadata
    val (overlay_count, new_pos3) = decode_varint(bytes, pos)?
    pos = new_pos3

    var metadata = McpMetadata::new()
    for _ in 0..overlay_count:
        val (key, new_pos) = decode_string(bytes, pos)?
        pos = new_pos
        val (value, new_pos2) = decode_string(bytes, pos)?
        pos = new_pos2
        metadata.add_overlay(key, value)

    Ok((McpItem { kind: kind, line: line, children: children, metadata: metadata }, pos))

pub fn stream_incremental(source: &str, chunk_size: u64) -> McpStream:
    return McpStream::new(source, chunk_size)

pub struct McpStream:
    source: text
    position: u64
    chunk_size: u64

impl McpStream:
    fn new(source: &str, chunk_size: u64) -> McpStream:
        return McpStream {
            source: source.to_string(),
            position: 0,
            chunk_size: chunk_size
        }

    pub fn next_chunk(self) -> Option<McpOutput>:
        # Check if we have more data to read
        if self.position >= self.source.len() as u64:
            return None

        # Calculate end position for this chunk
        val end_pos = min(self.position + self.chunk_size, self.source.len() as u64)

        # Extract chunk from source
        val chunk = self.source.substring(self.position as i32, end_pos as i32)

        # Create output for this chunk
        var output = McpOutput::new()
        output.content = chunk
        output.start_offset = self.position
        output.end_offset = end_pos

        # Advance position
        self.position = end_pos

        return Some(output)

# =============================================================================
# #1291-1294: Semantic highlighting, caching, indexing, filtering
# =============================================================================

pub fn add_semantic_tokens(output: &mut McpOutput) -> Result<(), McpError>:
    # Add semantic token information to the MCP output
    # Semantic tokens provide syntax highlighting hints for editors

    # Token types following LSP SemanticTokenTypes
    val token_types = [
        "namespace", "type", "class", "enum", "interface",
        "struct", "typeParameter", "parameter", "variable",
        "property", "enumMember", "function", "method",
        "keyword", "modifier", "comment", "string", "number", "operator"
    ]

    # Add semantic tokens legend to output metadata
    if output.items.len() > 0:
        for item in output.items:
            # Assign token type based on item kind
            val token_type = match item.kind:
                ItemKind::Function: "function"
                ItemKind::Struct: "struct"
                ItemKind::Enum: "enum"
                ItemKind::Import: "namespace"
                ItemKind::Marker: "comment"
                _: "variable"

            # Assign modifiers based on visibility
            var modifiers: Array<text> = []
            if item.metadata.visibility == "pub":
                modifiers.push("declaration")
            if item.metadata.visibility == "static":
                modifiers.push("static")

            # Store token info in item
            item.semantic_token_type = token_type
            item.semantic_token_modifiers = modifiers

    return Ok(())

pub struct McpCache:
    entries: Dict<text, CacheEntry>

struct CacheEntry:
    output: McpOutput
    timestamp: u64

impl McpCache:
    pub fn get(self, key: &str) -> Option<McpOutput>:
        if val Some(entry) = self.entries.get(key):
            return Some(entry.output.clone())
        return None

    pub fn set(self, key: &str, output: McpOutput):
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        self.entries.insert(key.to_string(), CacheEntry {
            output: output,
            timestamp: _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds
        })

pub struct SymbolIndex:
    symbols: Dict<text, Array<SymbolLocation>>

struct SymbolLocation:
    file: text
    location: SourceLocation

impl SymbolIndex:
    pub fn find(self, name: &str) -> Option<Array<SymbolLocation>>:
        return self.symbols.get(name).cloned()

pub fn filter_by_relevance(output: &McpOutput, query: &str) -> McpOutput:
    var filtered = McpOutput::new()

    for item in &output.items:
        val score = relevance_score(&item.metadata.name, query)
        if score > 0.5:
            filtered.add_item(item.clone())

    return filtered

fn relevance_score(name: &str, query: &str) -> f32:
    if name.contains(query):
        return 1.0
    return 0.0

# =============================================================================
# #1295-1299: Metadata, profiling, plugins, pipeline, formats
# =============================================================================

pub struct MetadataConfig:
    pub fields: Array<text>
    pub custom: Dict<text, text>

pub struct ProfileData:
    pub parse_time_ms: u64
    pub format_time_ms: u64
    pub total_time_ms: u64

pub struct PluginRegistry:
    plugins: Dict<text, Box<McpPlugin>>

pub trait McpPlugin:
    fn name() -> text
    fn transform(output: &mut McpOutput) -> Result<(), McpError>

pub struct TransformPipeline:
    stages: Array<Box<McpPlugin>>

impl TransformPipeline:
    pub fn apply(self, output: &mut McpOutput) -> Result<(), McpError>:
        for plugin in &self.stages:
            plugin.transform(output)?
        return Ok(())

pub enum OutputFormat:
    Json
    Markdown
    Plain
    Html
    Protobuf

impl OutputFormat:
    pub fn to_string(self) -> text:
        """Convert output format to string."""
        match self:
            case Json: "json"
            case Markdown: "markdown"
            case Plain: "plain"
            case Html: "html"
            case Protobuf: "protobuf"

    pub fn description(self) -> text:
        """Get output format description."""
        match self:
            case Json: "JSON structured output format"
            case Markdown: "Markdown documentation format"
            case Plain: "Plain text format"
            case Html: "HTML web format"
            case Protobuf: "Protocol Buffers binary format"

    pub fn is_json(self) -> bool:
        """Check if format is JSON."""
        match self:
            case Json: true
            case _: false

    pub fn is_markdown(self) -> bool:
        """Check if format is Markdown."""
        match self:
            case Markdown: true
            case _: false

    pub fn is_plain(self) -> bool:
        """Check if format is Plain."""
        match self:
            case Plain: true
            case _: false

    pub fn is_html(self) -> bool:
        """Check if format is HTML."""
        match self:
            case Html: true
            case _: false

    pub fn is_protobuf(self) -> bool:
        """Check if format is Protobuf."""
        match self:
            case Protobuf: true
            case _: false

    pub fn is_binary(self) -> bool:
        """Check if format is binary."""
        match self:
            case Protobuf: true
            case _: false

    pub fn is_text(self) -> bool:
        """Check if format is text-based."""
        match self:
            case Json: true
            case Markdown: true
            case Plain: true
            case Html: true
            case _: false

    pub fn is_structured(self) -> bool:
        """Check if format supports structured data."""
        match self:
            case Json: true
            case Protobuf: true
            case Html: true
            case _: false

    pub fn is_human_readable(self) -> bool:
        """Check if format is primarily human-readable."""
        match self:
            case Markdown: true
            case Plain: true
            case Html: true
            case _: false

    pub fn summary(self) -> text:
        """Get comprehensive output format summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_binary():
            props.push("binary")
        if self.is_text():
            props.push("text")
        if self.is_structured():
            props.push("structured")
        if self.is_human_readable():
            props.push("human-readable")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "OutputFormat: {name} ({desc}, {props_str})"
        else:
            return "OutputFormat: {name} ({desc})"

# Helper extensions
impl McpMetadata:
    fn empty() -> McpMetadata:
        return McpMetadata {
            visibility: "".to_string(),
            name: "".to_string(),
            location: SourceLocation { line: 0, column: 0, offset: 0 }
        }

    fn add_overlay(key: &str, value: &str):
        # Store overlay data in module-level storage
        val meta_key = get_metadata_key(&self)

        # Get or create overlay dict for this metadata
        if not _metadata_overlays.contains_key(meta_key):
            _metadata_overlays.insert(meta_key, {})

        # Store the overlay key-value pair
        _metadata_overlays.get_mut(meta_key).unwrap().insert(key.to_string(), value.to_string())

    fn get_overlay(key: &str) -> Option<text>:
        # Retrieve overlay data from module-level storage
        val meta_key = get_metadata_key(&self)

        if val Some(overlays) = _metadata_overlays.get(meta_key):
            return overlays.get(key).cloned()
        return None

    fn get_all_overlays() -> Dict<text, text>:
        # Get all overlays for this metadata
        val meta_key = get_metadata_key(&self)

        if val Some(overlays) = _metadata_overlays.get(meta_key):
            return overlays.clone()
        return {}

impl McpOutput:
    fn find_symbol(name: &str) -> Option<&McpItem>:
        for item in &self.items:
            if item.metadata.name == name:
                return Some(item)
        return None

enum ItemKind:
    Function
    Struct
    Enum
    Import
    Marker

impl ItemKind:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_function() -> bool:
        """Check if item is Function.

        Returns:
            true for Function

        Example:
            ItemKind::Function.is_function()  # → true
        """
        match self:
            case Function: true
            case _: false

    fn is_struct() -> bool:
        """Check if item is Struct.

        Returns:
            true for Struct

        Example:
            ItemKind::Struct.is_struct()  # → true
        """
        match self:
            case Struct: true
            case _: false

    fn is_enum() -> bool:
        """Check if item is Enum.

        Returns:
            true for Enum

        Example:
            ItemKind::Enum.is_enum()  # → true
        """
        match self:
            case Enum: true
            case _: false

    fn is_import() -> bool:
        """Check if item is Import.

        Returns:
            true for Import

        Example:
            ItemKind::Import.is_import()  # → true
        """
        match self:
            case Import: true
            case _: false

    fn is_marker() -> bool:
        """Check if item is Marker.

        Returns:
            true for Marker

        Example:
            ItemKind::Marker.is_marker()  # → true
        """
        match self:
            case Marker: true
            case _: false

    fn is_type_definition() -> bool:
        """Check if item is a type definition (Struct or Enum).

        Returns:
            true for Struct or Enum

        Example:
            ItemKind::Struct.is_type_definition()  # → true
            ItemKind::Function.is_type_definition()  # → false
        """
        match self:
            case Struct: true
            case Enum: true
            case _: false

    fn is_code() -> bool:
        """Check if item is executable code.

        Returns:
            true for Function

        Example:
            ItemKind::Function.is_code()  # → true
            ItemKind::Struct.is_code()  # → false
        """
        match self:
            case Function: true
            case _: false

    fn is_structural() -> bool:
        """Check if item is structural (not executable).

        Returns:
            true for Struct, Enum, Import, Marker

        Example:
            ItemKind::Struct.is_structural()  # → true
            ItemKind::Function.is_structural()  # → false
        """
        match self:
            case Function: false
            case _: true

    fn is_meta() -> bool:
        """Check if item is meta-information (Marker).

        Returns:
            true for Marker

        Example:
            ItemKind::Marker.is_meta()  # → true
        """
        return self.is_marker()

    fn to_string() -> text:
        """Convert item kind to string.

        Returns:
            Kind name

        Example:
            ItemKind::Function.to_string()  # → "function"
        """
        match self:
            case Function: "function"
            case Struct: "struct"
            case Enum: "enum"
            case Import: "import"
            case Marker: "marker"

    fn description() -> text:
        """Get item kind description.

        Returns:
            Human-readable description

        Example:
            ItemKind::Function.description()
            # → "Function definition"
        """
        match self:
            case Function: "Function definition"
            case Struct: "Structure definition"
            case Enum: "Enumeration definition"
            case Import: "Import statement"
            case Marker: "Block marker (guide)"

    fn summary() -> text:
        """Get summary of item kind.

        Returns:
            Human-readable summary

        Example:
            ItemKind::Function.summary()
            # → "ItemKind: function (code, executable)"
        """
        val name = self.to_string()
        val category = if self.is_code():
                           "code, executable"
                       else if self.is_type_definition():
                           "type definition"
                       else if self.is_meta():
                           "meta-information"
                       else:
                           "structural"
        return "ItemKind: {name} ({category})"

enum McpError:
    NotImplemented(text)
    ParseError(text)

impl McpError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_not_implemented() -> bool:
        """Check if error is NotImplemented.

        Returns:
            true for NotImplemented

        Example:
            McpError::NotImplemented("feature").is_not_implemented()  # → true
        """
        match self:
            case NotImplemented(_): true
            case _: false

    fn is_parse_error() -> bool:
        """Check if error is ParseError.

        Returns:
            true for ParseError

        Example:
            McpError::ParseError("syntax").is_parse_error()  # → true
        """
        match self:
            case ParseError(_): true
            case _: false

    fn get_message() -> text:
        """Get error message.

        Returns:
            Error message string

        Example:
            McpError::NotImplemented("caching").get_message()  # → "caching"
        """
        match self:
            case NotImplemented(msg): msg
            case ParseError(msg): msg

    fn is_recoverable() -> bool:
        """Check if error might be recoverable.

        Returns:
            true for ParseError (can retry), false for NotImplemented

        Example:
            McpError::ParseError("bad syntax").is_recoverable()  # → true
            McpError::NotImplemented("feature").is_recoverable()  # → false
        """
        match self:
            case ParseError(_): true
            case NotImplemented(_): false

    fn severity() -> text:
        """Get error severity level.

        Returns:
            Severity: "error" or "fatal"

        Example:
            McpError::ParseError("syntax").severity()  # → "error"
            McpError::NotImplemented("feature").severity()  # → "fatal"
        """
        match self:
            case ParseError(_): "error"
            case NotImplemented(_): "fatal"

    fn to_string() -> text:
        """Convert error to string.

        Returns:
            Error type name

        Example:
            McpError::ParseError("msg").to_string()  # → "parse_error"
        """
        match self:
            case NotImplemented(_): "not_implemented"
            case ParseError(_): "parse_error"

    fn description() -> text:
        """Get detailed error description.

        Returns:
            Human-readable description with message

        Example:
            McpError::NotImplemented("caching").description()
            # → "Feature not implemented: caching"
        """
        match self:
            case NotImplemented(msg): "Feature not implemented: {msg}"
            case ParseError(msg): "Parse error: {msg}"

    fn summary() -> text:
        """Get summary of MCP error.

        Returns:
            Human-readable summary

        Example:
            McpError::ParseError("syntax error").summary()
            # → "McpError: parse_error (error severity, recoverable)"
        """
        val name = self.to_string()
        val sev = self.severity()
        val recoverable = if self.is_recoverable(): "recoverable" else: "not recoverable"
        return "McpError: {name} ({sev} severity, {recoverable})"
