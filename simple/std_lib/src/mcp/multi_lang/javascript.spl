# JavaScript/TypeScript Language MCP-MCP Provider

use core.*
use mcp.core.protocol.*
use mcp.multi_lang.*

pub struct JavaScriptProvider:
    parser: TreeSitterParser

impl JavaScriptProvider:
    pub fn new() -> JavaScriptProvider:
        return JavaScriptProvider { parser: TreeSitterParser::new("javascript") }

impl LanguageProvider for JavaScriptProvider:
    fn name(self) -> String:
        return "javascript".to_string()

    fn extensions(self) -> Array[String]:
        return ["js".to_string(), "mjs".to_string(), "ts".to_string(), "tsx".to_string()]

    fn fold(self, source: &str, opts: &FoldOptions) -> Result[McpOutput, McpError]:
        let tree = self.parser.parse(source)?
        let mut output = McpOutput::new()

        for node in tree.root_node().children():
            match node.kind():
                case "function_declaration" | "arrow_function":
                    output.add_item(self.format_function(&node, source, opts))
                case "class_declaration":
                    output.add_item(self.format_class(&node, source, opts))
                case "import_statement":
                    if opts.show_imports:
                        output.add_item(self.format_import(&node, source))
                case _:
                    pass

        return Ok(output)

    fn get_symbols(self, source: &str) -> Result[Array[Symbol], McpError]:
        return Ok([])

    fn get_diagnostics(self, source: &str) -> Result[Array[Diagnostic], McpError]:
        return Ok([])

impl JavaScriptProvider:
    fn format_function(self, node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        let marker = if opts.use_markers { "F> " } else { "" }
        return McpItem {
            kind: ItemKind::Function,
            line: format!("{}function()", marker),
            children: [],
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: "function".to_string(),
                location: SourceLocation { line: 0, column: 0, offset: 0 }
            }
        }

    fn format_class(self, node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        let marker = if opts.use_markers { "C> " } else { "" }
        return McpItem {
            kind: ItemKind::Struct,
            line: format!("{}class", marker),
            children: [],
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: "class".to_string(),
                location: SourceLocation { line: 0, column: 0, offset: 0 }
            }
        }

    fn format_import(self, node: &TreeNode, source: &str) -> McpItem:
        return McpItem {
            kind: ItemKind::Import,
            line: "import".to_string(),
            children: [],
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: "import".to_string(),
                location: SourceLocation { line: 0, column: 0, offset: 0 }
            }
        }
