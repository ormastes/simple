# JavaScript/TypeScript Language MCP-MCP Provider

use core.*
use mcp.core.protocol.*
use mcp.multi_lang.*
use mcp.multi_lang.base_provider.*

pub struct JavaScriptProvider:
    parser: TreeSitterParser

impl JavaScriptProvider:
    pub fn new() -> JavaScriptProvider:
        return JavaScriptProvider { parser: create_parser("javascript") }

impl LanguageProvider for JavaScriptProvider:
    fn name() -> String:
        return "javascript".to_string()

    fn extensions() -> Array[String]:
        return ["js".to_string(), "mjs".to_string(), "ts".to_string(), "tsx".to_string()]

    fn fold(source: &str, opts: &FoldOptions) -> Result[McpOutput, McpError]:
        val tree = self.parser.parse(source)?
        var output = McpOutput::new()

        for node in tree.root_node().children():
            match node.kind():
                case "function_declaration" | "arrow_function":
                    val marker = get_marker(opts, ItemKind::Function)
                    output.add_item(make_function_item("function", "", &marker, "public"))
                case "class_declaration":
                    val marker = get_marker(opts, ItemKind::Struct)
                    output.add_item(make_class_item("class", &marker, "public"))
                case "import_statement":
                    if opts.show_imports:
                        output.add_item(make_import_item("import"))
                case _:
                    pass

        return Ok(output)

    fn get_symbols(source: &str) -> Result[Array[Symbol], McpError]:
        return default_get_symbols(source)

    fn get_diagnostics(source: &str) -> Result[Array[Diagnostic], McpError]:
        return default_get_diagnostics(source)
