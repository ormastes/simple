# Rust Language MCP-MCP Provider
#
# Provides MCP-MCP folding for Rust source code.
# Uses Tree-sitter for parsing and analysis.

use core.*
use mcp.core.protocol.*
use mcp.multi_lang.*

pub struct RustProvider:
    parser: TreeSitterParser

impl RustProvider:
    pub fn new() -> RustProvider:
        return RustProvider {
            parser: TreeSitterParser::new("rust")
        }

impl LanguageProvider for RustProvider:
    fn name() -> text:
        return "rust".to_string()

    fn extensions() -> Array<text>:
        return ["rs".to_string()]

    fn fold(source: &str, opts: &FoldOptions) -> Result<McpOutput, McpError>:
        val tree = self.parser.parse(source)?
        var output = McpOutput::new()

        # Process top-level items
        for node in tree.root_node().children():
            match node.kind():
                case "function_item":
                    output.add_item(self.format_function(&node, source, opts))
                case "struct_item":
                    output.add_item(self.format_struct(&node, source, opts))
                case "enum_item":
                    output.add_item(self.format_enum(&node, source, opts))
                case "impl_item":
                    output.add_item(self.format_impl(&node, source, opts))
                case "trait_item":
                    output.add_item(self.format_trait(&node, source, opts))
                case "mod_item":
                    output.add_item(self.format_module(&node, source, opts))
                case "use_declaration":
                    if opts.show_imports:
                        output.add_item(self.format_use(&node, source))
                case _:
                    pass  # Skip other nodes

        return Ok(output)

    fn get_symbols(source: &str) -> Result<Array<Symbol>, McpError>:
        val tree = self.parser.parse(source)?
        var symbols: Array<Symbol> = []

        for node in tree.root_node().children():
            if val Some(symbol) = self.node_to_symbol(&node, source):
                symbols.push(symbol)

        return Ok(symbols)

    fn get_diagnostics(source: &str) -> Result<Array<Diagnostic>, McpError>:
        # Rust diagnostics would come from rustc/clippy
        # This is a placeholder
        return Ok([])

impl RustProvider:
    fn format_function(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_function_name(node, source)
        val visibility = self.get_visibility(node, source)
        val signature = self.get_function_signature(node, source)

        val prefix = if visibility == "pub" { "pub " } else { "" }
        val marker = if opts.use_markers { "F> " } else { "" }

        return McpItem {
            kind: ItemKind::Function,
            line: format!("{}{}{}", marker, prefix, signature),
            children: if opts.collapse_bodies { [] } else {
                self.get_function_body_items(node, source, opts)
            },
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_struct(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_struct_name(node, source)
        val visibility = self.get_visibility(node, source)
        val generics = self.get_generics(node, source)

        val prefix = if visibility == "pub" { "pub " } else { "" }
        val gen_str = if generics.is_empty() { "" } else { format!("<{}>", generics) }
        val marker = if opts.use_markers { "T> " } else { "" }

        var children: Array<McpItem> = []
        if val Some(fields_node) = self.get_struct_fields(node):
            for field in fields_node.children():
                children.push(self.format_struct_field(&field, source, opts))

        return McpItem {
            kind: ItemKind::Struct,
            line: format!("{}{}struct {}{}", marker, prefix, name, gen_str),
            children: if opts.collapse_bodies { [] } else { children },
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_struct_field(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_field_name(node, source)
        val field_type = self.get_field_type(node, source)
        val visibility = self.get_visibility(node, source)

        val prefix = if visibility == "pub" { "pub " } else { "" }
        val marker = if opts.use_markers { "V• " } else { "  " }

        return McpItem {
            kind: ItemKind::Field,
            line: format!("{}{}{}: {}", marker, prefix, name, field_type),
            children: [],
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_enum(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_enum_name(node, source)
        val visibility = self.get_visibility(node, source)
        val marker = if opts.use_markers { "T> " } else { "" }

        var children: Array<McpItem> = []
        if val Some(variants) = self.get_enum_variants(node):
            for variant in variants.children():
                children.push(self.format_enum_variant(&variant, source, opts))

        return McpItem {
            kind: ItemKind::Enum,
            line: format!("{}{}enum {}", marker, if visibility == "pub" { "pub " } else { "" }, name),
            children: if opts.collapse_bodies { [] } else { children },
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_enum_variant(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_variant_name(node, source)
        val marker = if opts.use_markers { "V• " } else { "  " }

        return McpItem {
            kind: ItemKind::EnumVariant,
            line: format!("{}{}", marker, name),
            children: [],
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_impl(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val type_name = self.get_impl_type(node, source)
        val trait_name = self.get_impl_trait(node, source)
        val marker = if opts.use_markers { "I> " } else { "" }

        val header = if trait_name.is_empty():
            format("{}impl {}", marker, type_name)
        else:
            format("{}impl {} for {}", marker, trait_name, type_name)

        var children: Array<McpItem> = []
        for method in self.get_impl_methods(node):
            children.push(self.format_function(&method, source, opts))

        return McpItem {
            kind: ItemKind::Impl,
            line: header,
            children: if opts.collapse_bodies { [] } else { children },
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: type_name,
                location: self.get_location(node)
            }
        }

    fn format_trait(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_trait_name(node, source)
        val visibility = self.get_visibility(node, source)
        val marker = if opts.use_markers { "T> " } else { "" }

        return McpItem {
            kind: ItemKind::Trait,
            line: format("{}{}trait {}", marker, if visibility == "pub" { "pub " } else { "" }, name),
            children: self.extract_trait_methods(node, source, opts)
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_module(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_module_name(node, source)
        val visibility = self.get_visibility(node, source)
        val marker = if opts.use_markers { "M> " } else { "" }

        return McpItem {
            kind: ItemKind::Module,
            line: format("{}{}mod {}", marker, if visibility == "pub" { "pub " } else { "" }, name),
            children: [],
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_use(node: &TreeNode, source: &str) -> McpItem:
        val path = self.get_use_path(node, source)

        return McpItem {
            kind: ItemKind::Import,
            line: format("use {}", path),
            children: [],
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: path.clone(),
                location: self.get_location(node)
            }
        }

    # Helper methods for extracting information from tree-sitter nodes
    fn get_function_name(node: &TreeNode, source: &str) -> text:
        # Extract function name from tree-sitter node
        # Look for 'identifier' child node that follows 'fn' keyword
        for child in node.child_nodes:
            if child.kind_str == "identifier":
                return child.text_slice.clone()
        # Fallback: try to extract from source text
        val node_text = source[node.start_pos as usize..node.end_pos as usize]
        if val Some(fn_idx) = node_text.find("fn "):
            val after_fn = node_text[fn_idx + 3..]
            if val Some(paren_idx) = after_fn.find("("):
                return after_fn[..paren_idx].trim().to_string()
        return "unknown".to_string()

    fn get_function_signature(node: &TreeNode, source: &str) -> text:
        # Extract full function signature from tree-sitter node
        val node_text = source[node.start_pos as usize..node.end_pos as usize]

        # Find the signature (everything before the body '{')
        if val Some(brace_idx) = node_text.find("{"):
            return node_text[..brace_idx].trim().to_string()

        # If no brace, might be a declaration - return full text
        # But limit to first line for cleaner output
        if val Some(newline_idx) = node_text.find("\n"):
            return node_text[..newline_idx].trim().to_string()

        return node_text.trim().to_string()

    fn get_visibility(node: &TreeNode, source: &str) -> text:
        # Check for pub keyword in the node
        for child in node.child_nodes:
            if child.kind_str == "visibility_modifier":
                val vis_text = child.text_slice.trim()
                if vis_text.starts_with("pub"):
                    return "pub".to_string()
        # Also check the node text directly
        val node_text = source[node.start_pos as usize..node.end_pos as usize]
        if node_text.trim().starts_with("pub "):
            return "pub".to_string()
        return "private".to_string()

    fn get_generics(node: &TreeNode, source: &str) -> text:
        # Extract generic parameters from tree-sitter node
        for child in node.child_nodes:
            if child.kind_str == "type_parameters" or child.kind_str == "generic_parameters":
                return child.text_slice.clone()
        # Try to extract from source text
        val node_text = source[node.start_pos as usize..node.end_pos as usize]
        if val Some(lt_idx) = node_text.find("<"):
            var depth = 0
            var end_idx = lt_idx
            for (i, ch) in node_text[lt_idx..].chars().enumerate():
                if ch == '<':
                    depth += 1
                elif ch == '>':
                    depth -= 1
                    if depth == 0:
                        end_idx = lt_idx + i + 1
                        break
            if end_idx > lt_idx:
                return node_text[lt_idx..end_idx].to_string()
        return "".to_string()

    fn extract_trait_methods(node: &TreeNode, source: &str, opts: &FoldOptions) -> Array<McpItem>:
        # Extract methods from a trait definition
        var methods: Array<McpItem> = []

        for child in node.child_nodes:
            if child.kind_str == "declaration_list" or child.kind_str == "trait_body":
                for item in child.child_nodes:
                    if item.kind_str == "function_signature_item" or item.kind_str == "function_item":
                        val method_name = self.get_function_name(&item, source)
                        val signature = self.get_function_signature(&item, source)

                        methods.push(McpItem {
                            kind: ItemKind::Function,
                            line: format("  fn {}", method_name),
                            children: [],
                            metadata: McpMetadata {
                                visibility: "public".to_string(),
                                name: method_name,
                                location: self.get_location(&item)
                            }
                        })

        return methods

    fn get_struct_name(node: &TreeNode, source: &str) -> text:
        return "StructName".to_string()

    fn get_struct_fields(node: &TreeNode) -> Option<TreeNode>:
        return None

    fn get_field_name(node: &TreeNode, source: &str) -> text:
        return "field".to_string()

    fn get_field_type(node: &TreeNode, source: &str) -> text:
        return "Type".to_string()

    fn get_enum_name(node: &TreeNode, source: &str) -> text:
        return "EnumName".to_string()

    fn get_enum_variants(node: &TreeNode) -> Option<TreeNode>:
        return None

    fn get_variant_name(node: &TreeNode, source: &str) -> text:
        return "Variant".to_string()

    fn get_impl_type(node: &TreeNode, source: &str) -> text:
        return "Type".to_string()

    fn get_impl_trait(node: &TreeNode, source: &str) -> text:
        return "".to_string()

    fn get_impl_methods(node: &TreeNode) -> Array<TreeNode>:
        return []

    fn get_trait_name(node: &TreeNode, source: &str) -> text:
        return "TraitName".to_string()

    fn get_module_name(node: &TreeNode, source: &str) -> text:
        return "module_name".to_string()

    fn get_use_path(node: &TreeNode, source: &str) -> text:
        return "std::*".to_string()

    fn get_function_body_items(node: &TreeNode, source: &str, opts: &FoldOptions) -> Array<McpItem>:
        return []

    fn get_location(node: &TreeNode) -> SourceLocation:
        return SourceLocation {
            line: 0,
            column: 0,
            offset: 0
        }

    fn node_to_symbol(node: &TreeNode, source: &str) -> Option<Symbol>:
        match node.kind():
            case "function_item":
                return Some(Symbol {
                    name: self.get_function_name(node, source),
                    kind: SymbolKind::Function,
                    range: self.node_to_range(node),
                    signature: Some(self.get_function_signature(node, source)),
                    visibility: self.visibility_from_str(&self.get_visibility(node, source))
                })
            case _:
                return None

    fn node_to_range(node: &TreeNode) -> Range:
        return Range {
            start: Position { line: 0, column: 0 },
            end: Position { line: 0, column: 0 }
        }

    fn visibility_from_str(s: &str) -> Visibility:
        match s:
            case "pub": return Visibility::Public
            case _: return Visibility::Private

# Tree-sitter FFI declarations (requires tree-sitter runtime)
extern fn ts_parser_new() -> i64
extern fn ts_parser_set_language(parser: i64, lang_ptr: i64) -> bool
extern fn ts_parser_parse_string(parser: i64, old_tree: i64, source: *const u8, len: u64) -> i64
extern fn ts_tree_root_node(tree: i64) -> i64
extern fn ts_node_type(node: i64) -> *const u8
extern fn ts_node_child_count(node: i64) -> u32
extern fn ts_node_child(node: i64, index: u32) -> i64
extern fn ts_node_start_byte(node: i64) -> u32
extern fn ts_node_end_byte(node: i64) -> u32
extern fn ts_tree_delete(tree: i64)
extern fn ts_parser_delete(parser: i64)
extern fn tree_sitter_rust() -> i64

# Tree-sitter parser wrapper
struct TreeSitterParser:
    language: text
    parser_handle: i64
    lang_handle: i64

impl TreeSitterParser:
    fn new(lang: &str) -> TreeSitterParser:
        val parser_handle = ts_parser_new()
        val lang_handle = match lang:
            case "rust": tree_sitter_rust()
            case _: 0

        if parser_handle != 0 and lang_handle != 0:
            ts_parser_set_language(parser_handle, lang_handle)

        return TreeSitterParser {
            language: lang.to_string(),
            parser_handle: parser_handle,
            lang_handle: lang_handle
        }

    fn parse(source: &str) -> Result<Tree, McpError>:
        """Parse source code using tree-sitter.

        Falls back to regex-based parsing if tree-sitter is unavailable.
        """
        if self.parser_handle == 0 or self.lang_handle == 0:
            # Fallback to regex-based parsing for Rust
            return self.parse_regex_fallback(source)

        val tree_handle = ts_parser_parse_string(
            self.parser_handle,
            0,  # No old tree
            source.as_ptr(),
            source.len() as u64
        )

        if tree_handle == 0:
            return Err(McpError::ParseError("Tree-sitter parse failed"))

        val root_handle = ts_tree_root_node(tree_handle)
        val root = TreeNode::from_handle(root_handle, source)

        return Ok(Tree { root: root, tree_handle: tree_handle })

    fn parse_regex_fallback(source: &str) -> Result<Tree, McpError>:
        """Regex-based fallback parser for Rust."""
        var children: Array<TreeNode> = []

        # Find function definitions
        var lines = source.split("\n")
        for (line_num, line) in lines.enumerate():
            val trimmed = line.trim()

            # Match pub fn name(...) or fn name(...)
            if trimmed.contains("fn ") and trimmed.contains("("):
                val kind = if trimmed.starts_with("pub "): "function_item" else: "function_item"
                children.push(TreeNode {
                    kind_str: kind,
                    child_nodes: [],
                    start_pos: line_num as u32,
                    end_pos: line_num as u32,
                    text_slice: trimmed
                })

            # Match struct definitions
            elif trimmed.starts_with("struct ") or trimmed.starts_with("pub struct "):
                children.push(TreeNode {
                    kind_str: "struct_item",
                    child_nodes: [],
                    start_pos: line_num as u32,
                    end_pos: line_num as u32,
                    text_slice: trimmed
                })

            # Match impl blocks
            elif trimmed.starts_with("impl "):
                children.push(TreeNode {
                    kind_str: "impl_item",
                    child_nodes: [],
                    start_pos: line_num as u32,
                    end_pos: line_num as u32,
                    text_slice: trimmed
                })

        val root = TreeNode {
            kind_str: "source_file",
            child_nodes: children,
            start_pos: 0,
            end_pos: lines.len() as u32,
            text_slice: source
        }

        return Ok(Tree { root: root, tree_handle: 0 })

    fn close():
        """Clean up parser resources."""
        if self.parser_handle != 0:
            ts_parser_delete(self.parser_handle)

struct Tree:
    root: TreeNode
    tree_handle: i64

impl Tree:
    fn root_node() -> TreeNode:
        return self.root

    fn close():
        """Clean up tree resources."""
        if self.tree_handle != 0:
            ts_tree_delete(self.tree_handle)

struct TreeNode:
    kind_str: text
    child_nodes: Array<TreeNode>
    start_pos: u32
    end_pos: u32
    text_slice: text

impl TreeNode:
    fn from_handle(handle: i64, source: &str) -> TreeNode:
        """Create TreeNode from tree-sitter handle."""
        val type_ptr = ts_node_type(handle)
        val kind = text::from_c_str(type_ptr)
        val start = ts_node_start_byte(handle)
        val end = ts_node_end_byte(handle)

        var children: Array<TreeNode> = []
        val child_count = ts_node_child_count(handle)
        for i in 0..child_count:
            val child_handle = ts_node_child(handle, i)
            children.push(TreeNode::from_handle(child_handle, source))

        return TreeNode {
            kind_str: kind,
            child_nodes: children,
            start_pos: start,
            end_pos: end,
            text_slice: source.substring(start as usize, end as usize)
        }

    fn kind() -> &str:
        return &self.kind_str

    fn children() -> Array<TreeNode>:
        return self.child_nodes

    fn start_byte() -> u32:
        return self.start_pos

    fn end_byte() -> u32:
        return self.end_pos

    fn text() -> &str:
        return &self.text_slice

# MCP Output types
struct McpOutput:
    items: Array<McpItem>

impl McpOutput:
    static fn new() -> McpOutput:
        return McpOutput { items: [] }

    fn add_item(item: McpItem):
        self.items.push(item)

    fn merge(other: McpOutput):
        for item in other.items:
            self.items.push(item)

struct McpItem:
    kind: ItemKind
    line: text
    children: Array<McpItem>
    metadata: McpMetadata

enum ItemKind:
    Function
    Struct
    Enum
    EnumVariant
    Trait
    Impl
    Module
    Import
    Field

impl ItemKind:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_function() -> bool:
        """Check if item is Function.

        Returns:
            true for Function

        Example:
            ItemKind::Function.is_function()  # → true
        """
        match self:
            case Function: true
            case _: false

    fn is_struct() -> bool:
        """Check if item is Struct.

        Returns:
            true for Struct

        Example:
            ItemKind::Struct.is_struct()  # → true
        """
        match self:
            case Struct: true
            case _: false

    fn is_enum() -> bool:
        """Check if item is Enum.

        Returns:
            true for Enum

        Example:
            ItemKind::Enum.is_enum()  # → true
        """
        match self:
            case Enum: true
            case _: false

    fn is_enum_variant() -> bool:
        """Check if item is EnumVariant.

        Returns:
            true for EnumVariant

        Example:
            ItemKind::EnumVariant.is_enum_variant()  # → true
        """
        match self:
            case EnumVariant: true
            case _: false

    fn is_trait() -> bool:
        """Check if item is Trait.

        Returns:
            true for Trait

        Example:
            ItemKind::Trait.is_trait()  # → true
        """
        match self:
            case Trait: true
            case _: false

    fn is_impl() -> bool:
        """Check if item is Impl block.

        Returns:
            true for Impl

        Example:
            ItemKind::Impl.is_impl()  # → true
        """
        match self:
            case Impl: true
            case _: false

    fn is_module() -> bool:
        """Check if item is Module.

        Returns:
            true for Module

        Example:
            ItemKind::Module.is_module()  # → true
        """
        match self:
            case Module: true
            case _: false

    fn is_import() -> bool:
        """Check if item is Import.

        Returns:
            true for Import

        Example:
            ItemKind::Import.is_import()  # → true
        """
        match self:
            case Import: true
            case _: false

    fn is_field() -> bool:
        """Check if item is Field.

        Returns:
            true for Field

        Example:
            ItemKind::Field.is_field()  # → true
        """
        match self:
            case Field: true
            case _: false

    fn is_type_definition() -> bool:
        """Check if item is a type definition (Struct, Enum, or Trait).

        Returns:
            true for Struct, Enum, or Trait

        Example:
            ItemKind::Struct.is_type_definition()  # → true
            ItemKind::Function.is_type_definition()  # → false
        """
        match self:
            case Struct: true
            case Enum: true
            case Trait: true
            case _: false

    fn is_code() -> bool:
        """Check if item contains executable code.

        Returns:
            true for Function or Impl

        Example:
            ItemKind::Function.is_code()  # → true
            ItemKind::Struct.is_code()  # → false
        """
        match self:
            case Function: true
            case Impl: true
            case _: false

    fn is_container() -> bool:
        """Check if item can contain other items.

        Returns:
            true for Struct, Enum, Impl, Module

        Example:
            ItemKind::Module.is_container()  # → true
            ItemKind::Function.is_container()  # → false
        """
        match self:
            case Struct: true
            case Enum: true
            case Impl: true
            case Module: true
            case _: false

    fn is_nested() -> bool:
        """Check if item is typically nested inside another item.

        Returns:
            true for EnumVariant or Field

        Example:
            ItemKind::Field.is_nested()  # → true
            ItemKind::Struct.is_nested()  # → false
        """
        match self:
            case EnumVariant: true
            case Field: true
            case _: false

    fn is_declaration() -> bool:
        """Check if item is a declaration (not import).

        Returns:
            true for all except Import

        Example:
            ItemKind::Function.is_declaration()  # → true
            ItemKind::Import.is_declaration()  # → false
        """
        match self:
            case Import: false
            case _: true

    fn to_string() -> text:
        """Convert item kind to string.

        Returns:
            Item kind name

        Example:
            ItemKind::Function.to_string()  # → "function"
        """
        match self:
            case Function: "function"
            case Struct: "struct"
            case Enum: "enum"
            case EnumVariant: "enum_variant"
            case Trait: "trait"
            case Impl: "impl"
            case Module: "module"
            case Import: "import"
            case Field: "field"

    fn description() -> text:
        """Get item kind description.

        Returns:
            Human-readable description

        Example:
            ItemKind::Trait.description()
            # → "Trait definition"
        """
        match self:
            case Function: "Function definition"
            case Struct: "Struct type definition"
            case Enum: "Enum type definition"
            case EnumVariant: "Enum variant"
            case Trait: "Trait definition"
            case Impl: "Implementation block"
            case Module: "Module definition"
            case Import: "Import statement"
            case Field: "Struct or enum field"

    fn summary() -> text:
        """Get item kind summary.

        Returns:
            Human-readable summary

        Example:
            ItemKind::Struct.summary()
            # → "ItemKind: struct (Struct type definition, type definition, container)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_type_definition():
            props.push("type definition")
        elif self.is_code():
            props.push("code")
        elif self.is_import():
            props.push("import")

        if self.is_container():
            props.push("container")
        elif self.is_nested():
            props.push("nested")

        if props.len() > 0:
            val props_str = props.join(", ")
            "ItemKind: {name} ({desc}, {props_str})"
        else:
            "ItemKind: {name} ({desc})"

    fn marker_symbol() -> text:
        """Get marker symbol for this item kind.

        Returns:
            Marker string (F>, T>, etc.)

        Example:
            ItemKind::Function.marker_symbol()  # → "F>"
            ItemKind::Struct.marker_symbol()  # → "T>"
        """
        match self:
            case Function: "F>"
            case Struct: "T>"
            case Enum: "T>"
            case EnumVariant: "V•"
            case Trait: "T>"
            case Impl: "I>"
            case Module: "M>"
            case Import: "U>"
            case Field: "V•"

    fn to_string() -> text:
        """Convert item kind to string.

        Returns:
            Kind name

        Example:
            ItemKind::Function.to_string()  # → "function"
        """
        match self:
            case Function: "function"
            case Struct: "struct"
            case Enum: "enum"
            case EnumVariant: "enum_variant"
            case Trait: "trait"
            case Impl: "impl"
            case Module: "module"
            case Import: "import"
            case Field: "field"

    fn description() -> text:
        """Get item kind description.

        Returns:
            Human-readable description

        Example:
            ItemKind::Function.description()
            # → "Function definition"
        """
        match self:
            case Function: "Function definition"
            case Struct: "Structure definition"
            case Enum: "Enumeration definition"
            case EnumVariant: "Enum variant"
            case Trait: "Trait definition"
            case Impl: "Implementation block"
            case Module: "Module declaration"
            case Import: "Import statement"
            case Field: "Struct/enum field"

    fn summary() -> text:
        """Get summary of item kind.

        Returns:
            Human-readable summary

        Example:
            ItemKind::Function.summary()
            # → "ItemKind: function (code, F>)"
        """
        val name = self.to_string()
        val marker = self.marker_symbol()
        val category = if self.is_code():
                           "code"
                       else if self.is_type_definition():
                           "type definition"
                       else if self.is_container():
                           "container"
                       else if self.is_nested():
                           "nested"
                       else:
                           "declaration"
        return "ItemKind: {name} ({category}, {marker})"

struct McpMetadata:
    visibility: text
    name: text
    location: SourceLocation

struct SourceLocation:
    line: u32
    column: u32
    offset: u32

# Fold options
pub struct FoldOptions:
    pub collapse_bodies: bool
    pub show_imports: bool
    pub use_markers: bool
    pub show_private: bool
