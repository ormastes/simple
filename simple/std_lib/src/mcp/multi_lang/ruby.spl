# Ruby Language MCP-MCP Provider

use core.*
use mcp.core.protocol.*
use mcp.multi_lang.*
use mcp.multi_lang.base_provider.*

pub struct RubyProvider:
    parser: TreeSitterParser

impl RubyProvider:
    pub fn new() -> RubyProvider:
        return RubyProvider { parser: create_parser("ruby") }

impl LanguageProvider for RubyProvider:
    fn name() -> text:
        return "ruby".to_string()

    fn extensions() -> Array<text>:
        return ["rb".to_string()]

    fn fold(source: &str, opts: &FoldOptions) -> Result<McpOutput, McpError>:
        var output = McpOutput::new()

        # Parse Ruby code patterns for methods, classes, modules
        var current_line = 0
        for line in source.lines():
            current_line += 1
            val trimmed = line.trim()

            # Method: def method_name or def self.method_name
            if trimmed.starts_with("def "):
                val after_def = trimmed.substring(4, trimmed.len())
                val parts = after_def.split("(")
                val method_name = parts[0].trim()
                output.add_symbol(Symbol::new(method_name, SymbolKind::Method, current_line))

            # Class: class ClassName or class ClassName < Parent
            elif trimmed.starts_with("class "):
                val after_class = trimmed.substring(6, trimmed.len())
                val parts = after_class.split(" ")
                val class_name = parts[0].split("<")[0].trim()
                output.add_symbol(Symbol::new(class_name, SymbolKind::Class, current_line))

            # Module: module ModuleName
            elif trimmed.starts_with("module "):
                val module_name = trimmed.substring(7, trimmed.len()).trim()
                output.add_symbol(Symbol::new(module_name, SymbolKind::Module, current_line))

            # Constant: CONSTANT = value or Name = value (capitalized)
            elif trimmed.contains(" = ") and trimmed.split(" ")[0].chars().next().unwrap_or('a').is_uppercase():
                val const_name = trimmed.split(" ")[0].trim()
                output.add_symbol(Symbol::new(const_name, SymbolKind::Constant, current_line))

        return Ok(output)

    fn get_symbols(source: &str) -> Result<Array<Symbol>, McpError>:
        return default_get_symbols(source)

    fn get_diagnostics(source: &str) -> Result<Array<Diagnostic>, McpError>:
        return default_get_diagnostics(source)
