# Coverage Metric Overlays for Simple Language
# Displays test coverage, branch coverage, and condition coverage

use core.*
use mcp.simple_lang.types.*

# Coverage type
pub enum CoverageType:
    Line         # Line coverage
    Branch       # Branch coverage
    Condition    # Condition coverage
    Function     # Function coverage

impl CoverageType:
    pub fn is_line(self) -> bool:
        """Check if this is Line coverage.
        Returns: true for Line
        Example: CoverageType.Line.is_line()  # → true
        """
        match self:
            case Line: true
            case _: false

    pub fn is_branch(self) -> bool:
        """Check if this is Branch coverage.
        Returns: true for Branch
        Example: CoverageType.Branch.is_branch()  # → true
        """
        match self:
            case Branch: true
            case _: false

    pub fn is_condition(self) -> bool:
        """Check if this is Condition coverage.
        Returns: true for Condition
        Example: CoverageType.Condition.is_condition()  # → true
        """
        match self:
            case Condition: true
            case _: false

    pub fn is_function(self) -> bool:
        """Check if this is Function coverage.
        Returns: true for Function
        Example: CoverageType.Function.is_function()  # → true
        """
        match self:
            case Function: true
            case _: false

    pub fn is_detailed(self) -> bool:
        """Check if this is detailed coverage (branch or condition).
        Returns: true for Branch or Condition
        Example: CoverageType.Branch.is_detailed()  # → true
        """
        match self:
            case Branch: true
            case Condition: true
            case _: false

    pub fn is_basic(self) -> bool:
        """Check if this is basic coverage (line or function).
        Returns: true for Line or Function
        Example: CoverageType.Line.is_basic()  # → true
        """
        match self:
            case Line: true
            case Function: true
            case _: false

    pub fn to_string(self) -> String:
        """Convert CoverageType to string representation.
        Returns: lowercase coverage type name
        Example: CoverageType.Branch.to_string()  # → "branch"
        """
        match self:
            case Line: "line"
            case Branch: "branch"
            case Condition: "condition"
            case Function: "function"

    pub fn description(self) -> String:
        """Get human-readable description of the coverage type.
        Returns: descriptive explanation
        Example: CoverageType.Branch.description()  # → "Branch coverage (if/else paths)"
        """
        match self:
            case Line: "Line coverage (executed lines)"
            case Branch: "Branch coverage (if/else paths)"
            case Condition: "Condition coverage (boolean sub-expressions)"
            case Function: "Function coverage (called functions)"

    pub fn summary(self) -> String:
        """Get comprehensive summary of the coverage type.
        Returns: summary with name, description, and category
        Example: CoverageType.Branch.summary()
                # → "CoverageType: branch (Branch coverage (if/else paths), detailed)"
        """
        let name = self.to_string()
        let desc = self.description()
        let category = if self.is_detailed():
            "detailed"
        else:
            "basic"

        "CoverageType: {name} ({desc}, {category})"

# Coverage data for a symbol
pub class SymbolCoverage:
    pub symbol_name: String
    pub line_coverage: f64      # 0.0 - 1.0
    pub branch_coverage: f64    # 0.0 - 1.0
    pub condition_coverage: f64 # 0.0 - 1.0
    pub covered_lines: i64
    pub total_lines: i64
    pub covered_branches: i64
    pub total_branches: i64

# Coverage report
pub class CoverageReport:
    pub file_path: String
    pub overall_coverage: f64
    pub symbol_coverage: Dict[String, SymbolCoverage]
    pub uncovered_lines: List[i64]

# Parse coverage data (simplified - would integrate with actual coverage tool)
pub fn parse_coverage_data(coverage_json: String) -> CoverageReport:
    # TODO: [stdlib][P2] Parse actual coverage JSON format
    # This is a stub returning mock data

    symbol_coverage = {}

    # Mock data for demonstration
    main_cov = SymbolCoverage:
        symbol_name: "main"
        line_coverage: 0.85
        branch_coverage: 0.75
        condition_coverage: 0.80
        covered_lines: 17
        total_lines: 20
        covered_branches: 6
        total_branches: 8

    symbol_coverage.set("main", main_cov)

    return CoverageReport:
        file_path: ""
        overall_coverage: 0.82
        symbol_coverage: symbol_coverage
        uncovered_lines: [15, 23, 47]

# Format coverage overlay for MCP
pub fn format_coverage_overlay(symbols: List[Symbol], coverage: CoverageReport) -> String:
    result = ""

    for symbol in symbols:
        # Get coverage for this symbol
        cov_opt = None
        if coverage.symbol_coverage.has_key(symbol.name):
            cov_opt = Some(coverage.symbol_coverage.get(symbol.name))

        if cov_opt.is_some():
            cov = cov_opt.unwrap()
            result = result + format_symbol_with_coverage(symbol, cov) + "\n"
        else:
            # No coverage data - show symbol without coverage
            result = result + format_symbol_no_coverage(symbol) + "\n"

    return result

# Format symbol with coverage data
fn format_symbol_with_coverage(symbol: Symbol, coverage: SymbolCoverage) -> String:
    # Get coverage indicator
    indicator = get_coverage_indicator(coverage.line_coverage)

    # Format: C> pub class User { … } [85% ●]
    mark = get_block_mark_collapsed(symbol.kind)
    vis = get_visibility_prefix(symbol.visibility)

    result = mark + " " + vis + symbol.signature + " { … }"

    # Add coverage overlay
    coverage_pct = (coverage.line_coverage * 100.0).to_i64()
    result = result + " [" + coverage_pct.to_string() + "% " + indicator + "]"

    return result

# Format symbol without coverage
fn format_symbol_no_coverage(symbol: Symbol) -> String:
    mark = get_block_mark_collapsed(symbol.kind)
    vis = get_visibility_prefix(symbol.visibility)
    return mark + " " + vis + symbol.signature + " { … } [no coverage]"

# Get coverage indicator symbol
fn get_coverage_indicator(coverage: f64) -> String:
    if coverage >= 0.9:
        return "●"  # Full coverage (green)
    elif coverage >= 0.7:
        return "◐"  # Partial coverage (yellow)
    elif coverage >= 0.5:
        return "◑"  # Half coverage (orange)
    else:
        return "○"  # Low coverage (red)

# Format detailed coverage for expanded symbol
pub fn format_detailed_coverage(symbol: Symbol, coverage: SymbolCoverage) -> String:
    result = "Coverage Details for " + symbol.name + ":\n"

    line_pct = (coverage.line_coverage * 100.0).to_i64()
    branch_pct = (coverage.branch_coverage * 100.0).to_i64()
    condition_pct = (coverage.condition_coverage * 100.0).to_i64()

    result = result + "  Line Coverage:      " + line_pct.to_string() + "% "
    result = result + "(" + coverage.covered_lines.to_string() + "/" + coverage.total_lines.to_string() + ")\n"

    result = result + "  Branch Coverage:    " + branch_pct.to_string() + "% "
    result = result + "(" + coverage.covered_branches.to_string() + "/" + coverage.total_branches.to_string() + ")\n"

    result = result + "  Condition Coverage: " + condition_pct.to_string() + "%\n"

    return result

# Format coverage summary for entire file
pub fn format_coverage_summary(coverage: CoverageReport) -> String:
    overall_pct = (coverage.overall_coverage * 100.0).to_i64()
    indicator = get_coverage_indicator(coverage.overall_coverage)

    result = "COV> Coverage Summary " + indicator + " {\n"
    result = result + "  Overall: " + overall_pct.to_string() + "%\n"
    result = result + "  Symbols covered: " + coverage.symbol_coverage.len().to_string() + "\n"
    result = result + "  Uncovered lines: " + coverage.uncovered_lines.len().to_string() + "\n"

    if coverage.uncovered_lines.len() > 0 and coverage.uncovered_lines.len() < 10:
        result = result + "  Lines: "
        for i in range(coverage.uncovered_lines.len()):
            if i > 0:
                result = result + ", "
            result = result + coverage.uncovered_lines[i].to_string()
        result = result + "\n"

    result = result + "}\n"
    return result

# Helper: Get block mark for collapsed symbol
fn get_block_mark_collapsed(kind: SymbolKind) -> String:
    if kind == SymbolKind.Class:
        return "C>"
    elif kind == SymbolKind.Function:
        return "F>"
    elif kind == SymbolKind.Trait:
        return "T>"
    else:
        return "P>"

# Helper: Get visibility prefix
fn get_visibility_prefix(vis: Visibility) -> String:
    if vis == Visibility.Public:
        return "pub "
    else:
        return ""

# Find symbols with low coverage
pub fn find_low_coverage_symbols(coverage: CoverageReport, threshold: f64) -> List[String]:
    low_coverage = []

    for symbol_name in coverage.symbol_coverage.keys():
        cov = coverage.symbol_coverage.get(symbol_name)
        if cov.line_coverage < threshold:
            low_coverage.append(symbol_name)

    return low_coverage

# Calculate coverage by category
pub fn calculate_category_coverage(coverage: CoverageReport) -> Dict[String, f64]:
    # Categories: classes, functions, total
    categories = {}

    class_count = 0
    class_coverage_sum = 0.0
    func_count = 0
    func_coverage_sum = 0.0

    for symbol_name in coverage.symbol_coverage.keys():
        cov = coverage.symbol_coverage.get(symbol_name)

        # Heuristic: if name starts with uppercase, it's a class
        if symbol_name[0].is_upper():
            class_count = class_count + 1
            class_coverage_sum = class_coverage_sum + cov.line_coverage
        else:
            func_count = func_count + 1
            func_coverage_sum = func_coverage_sum + cov.line_coverage

    if class_count > 0:
        categories.set("classes", class_coverage_sum / class_count.to_f64())
    if func_count > 0:
        categories.set("functions", func_coverage_sum / func_count.to_f64())

    categories.set("overall", coverage.overall_coverage)

    return categories
