# Router - URL Pattern Matching
#
# Maps URL paths to handler functions with parameter extraction.
#
# ## Pattern Syntax
#
# - `/users` - Static path
# - `/users/:id` - Named parameter
# - `/files/*path` - Wildcard (catches rest of path)
#
# ## Example
#
# ```simple
# val router = Router::new()
#     .get("/", home_handler)
#     .get("/users", users_handler)
#     .get("/users/:id", user_detail_handler)
#     .post("/users", create_user_handler)
# ```

use web.http.request.*
use web.http.response.*

# Handler context with request and route params
pub struct Context:
    request: HttpRequest
    params: Dict[str, str]
    state: Dict[str, str]

impl Context:
    # Create context from request
    pub fn new(request: HttpRequest) -> Context:
        return Context {
            request: request,
            params: Dict::new(),
            state: Dict::new()
        }

    # Request access
    pub fn request(self) -> &HttpRequest:
        return &self.request

    pub fn method(self) -> HttpMethod:
        return self.request.method()

    pub fn path(self) -> &str:
        return self.request.path()

    # Route parameters
    pub fn param(self, name: &str) -> Option[&str]:
        return self.params.get(name)

    pub fn param_or(self, name: &str, default: &str) -> &str:
        return self.params.get(name).unwrap_or(default)

    pub fn param_u64(self, name: &str) -> Result[u64, HttpError]:
        match self.params.get(name):
            case Some(s): s.parse_u64().map_err(|_| HttpError::InvalidPath)
            case None: Err(HttpError::InvalidPath)

    pub fn param_i64(self, name: &str) -> Result[i64, HttpError]:
        match self.params.get(name):
            case Some(s): s.parse_i64().map_err(|_| HttpError::InvalidPath)
            case None: Err(HttpError::InvalidPath)

    # Query parameters
    pub fn query(self, name: &str) -> Option[&str]:
        return self.request.query_param(name)

    pub fn query_or(self, name: &str, default: &str) -> &str:
        return self.request.query_param(name).unwrap_or(default)

    # Headers
    pub fn header(self, name: &str) -> Option[&str]:
        return self.request.header(name)

    # Body
    pub fn body_text(self) -> Result[str, HttpError]:
        return self.request.body_text()

    # State management
    pub fn get_state(self, key: &str) -> Option[&str]:
        return self.state.get(key)

    pub fn set_state(self, key: &str, value: &str):
        self.state.insert(key.to_string(), value.to_string())

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_param(self, name: &str) -> bool:
        """Check if route parameter exists.

        Returns:
            true if parameter is present

        Example:
            ctx.has_param("id")  # → true
        """
        return self.params.contains_key(name)

    pub fn has_state(self, key: &str) -> bool:
        """Check if state key exists.

        Returns:
            true if state key is present

        Example:
            ctx.has_state("user_id")  # → true
        """
        return self.state.contains_key(key)

    pub fn param_count(self) -> u64:
        """Get number of route parameters.

        Returns:
            Count of parameters

        Example:
            ctx.param_count()  # → 2
        """
        return self.params.len()

    pub fn state_count(self) -> u64:
        """Get number of state entries.

        Returns:
            Count of state entries

        Example:
            ctx.state_count()  # → 1
        """
        return self.state.len()

    pub fn has_query(self, name: &str) -> bool:
        """Check if query parameter exists.

        Returns:
            true if query param is present

        Example:
            ctx.has_query("page")  # → true
        """
        return self.request.query_param(name).is_some()

    pub fn summary(self) -> String:
        """Get context summary.

        Returns:
            Human-readable summary

        Example:
            ctx.summary()
            # → "Context: GET /users/42, params=1, state=0"
        """
        val method = self.method()
        val path = self.path()
        val params = self.param_count()
        val state = self.state_count()
        return "Context: {method} {path}, params={params}, state={state}"

# Handler type
pub type Handler = fn(Context) -> async HttpResponse

# Route definition
pub struct Route:
    method: HttpMethod
    pattern: str
    handler: Handler
    segments: Array[RouteSegment]

# Route segment (parsed pattern)
pub enum RouteSegment:
    Static(str)      # Literal path segment
    Param(str)       # :name parameter
    Wildcard(str)    # *name wildcard

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_static(self) -> bool:
        """Check if segment is static.

        Returns:
            true if Static variant

        Example:
            seg.is_static()  # → true
        """
        match self:
            case Static { .. }: return true
            case _: return false

    pub fn is_param(self) -> bool:
        """Check if segment is a parameter.

        Returns:
            true if Param variant

        Example:
            seg.is_param()  # → false
        """
        match self:
            case Param { .. }: return true
            case _: return false

    pub fn is_wildcard(self) -> bool:
        """Check if segment is a wildcard.

        Returns:
            true if Wildcard variant

        Example:
            seg.is_wildcard()  # → false
        """
        match self:
            case Wildcard { .. }: return true
            case _: return false

    pub fn is_dynamic(self) -> bool:
        """Check if segment is dynamic (param or wildcard).

        Returns:
            true if not static

        Example:
            seg.is_dynamic()  # → true
        """
        return not self.is_static()

    pub fn to_string(self) -> String:
        """Convert segment to string representation.

        Returns:
            String representation

        Example:
            seg.to_string()  # → ":id" or "*path"
        """
        match self:
            case Static(s): return s
            case Param(name): return ":{name}"
            case Wildcard(name): return "*{name}"

    pub fn description(self) -> String:
        """Get segment description.

        Returns:
            Human-readable description

        Example:
            RouteSegment::Param("id").description()
            # → "Parameter segment (captures value)"
        """
        match self:
            case Static(_): return "Static path segment (exact match)"
            case Param(_): return "Parameter segment (captures value)"
            case Wildcard(_): return "Wildcard segment (captures remaining path)"

    pub fn summary(self) -> String:
        """Get segment summary.

        Returns:
            Human-readable summary

        Example:
            seg.summary()
            # → "Static: 'users'" or "Param: 'id'"
        """
        match self:
            case Static(s): return "Static: '{s}'"
            case Param(name): return "Param: '{name}'"
            case Wildcard(name): return "Wildcard: '{name}'"

# Route match result
pub struct RouteMatch:
    handler: Handler
    params: Dict[str, str]

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_params(self) -> bool:
        """Check if match has any parameters.

        Returns:
            true if parameters exist

        Example:
            match.has_params()  # → true
        """
        return not self.params.is_empty()

    pub fn param_count(self) -> u64:
        """Get number of parameters.

        Returns:
            Count of parameters

        Example:
            match.param_count()  # → 2
        """
        return self.params.len()

    pub fn summary(self) -> String:
        """Get match summary.

        Returns:
            Human-readable summary

        Example:
            match.summary()
            # → "RouteMatch: 2 params"
        """
        val count = self.param_count()
        return "RouteMatch: {count} params"

# Router
pub struct Router:
    routes: Array[Route]
    not_found_handler: Handler

impl Router:
    # Create new router
    pub fn new() -> Router:
        return Router {
            routes: [],
            not_found_handler: default_not_found
        }

    # Add GET route
    pub fn get(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Get, pattern, handler)

    # Add POST route
    pub fn post(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Post, pattern, handler)

    # Add PUT route
    pub fn put(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Put, pattern, handler)

    # Add DELETE route
    pub fn delete(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Delete, pattern, handler)

    # Add PATCH route
    pub fn patch(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Patch, pattern, handler)

    # Add route with method
    pub fn route(self, method: HttpMethod, pattern: &str, handler: Handler) -> Router:
        val segments = parse_pattern(pattern)
        self.routes.push(Route {
            method: method,
            pattern: pattern.to_string(),
            handler: handler,
            segments: segments
        })
        return self

    # Add route group with prefix
    pub fn group(self, prefix: &str, builder: fn(&mut Router)) -> Router:
        var sub_router = Router::new()
        builder(&mut sub_router)

        for route in sub_router.routes:
            val new_pattern = "{prefix}{route.pattern}"
            val segments = parse_pattern(&new_pattern)
            self.routes.push(Route {
                method: route.method,
                pattern: new_pattern,
                handler: route.handler,
                segments: segments
            })

        return self

    # Set 404 handler
    pub fn not_found(self, handler: Handler) -> Router:
        self.not_found_handler = handler
        return self

    # Match request to route
    pub fn match_route(self, request: &HttpRequest) -> RouteMatch:
        for route in &self.routes:
            if route.method != request.method():
                continue

            if val Some(params) = match_path(&route.segments, request.path()):
                return RouteMatch {
                    handler: route.handler,
                    params: params
                }

        return RouteMatch {
            handler: self.not_found_handler,
            params: Dict::new()
        }

    # Get all routes (for debugging)
    pub fn routes(self) -> &Array[Route]:
        return &self.routes

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_routes(self) -> bool:
        """Check if router has any routes.

        Returns:
            true if routes exist

        Example:
            router.has_routes()  # → true
        """
        return not self.routes.is_empty()

    pub fn route_count(self) -> u64:
        """Get number of registered routes.

        Returns:
            Count of routes

        Example:
            router.route_count()  # → 5
        """
        return self.routes.len()

    pub fn has_custom_not_found(self) -> bool:
        """Check if custom 404 handler is set.

        Returns:
            true if not using default handler

        Example:
            router.has_custom_not_found()  # → false
        """
        # Would need to compare function pointers in real impl
        return false  # Placeholder

    pub fn summary(self) -> String:
        """Get router summary.

        Returns:
            Human-readable summary

        Example:
            router.summary()
            # → "Router: 10 routes"
        """
        val count = self.route_count()
        return "Router: {count} routes"

# Parse route pattern into segments
fn parse_pattern(pattern: &str) -> Array[RouteSegment]:
    var segments: Array[RouteSegment] = []
    val parts = pattern.split('/')

    for part in parts:
        if part.is_empty():
            continue

        if part.starts_with(':'):
            val name = part.slice(1, part.len())
            segments.push(RouteSegment::Param(name.to_string()))
        else if part.starts_with('*'):
            val name = part.slice(1, part.len())
            segments.push(RouteSegment::Wildcard(name.to_string()))
        else:
            segments.push(RouteSegment::Static(part.to_string()))

    return segments

# Match path against pattern segments
fn match_path(segments: &Array[RouteSegment], path: &str) -> Option[Dict[str, str]]:
    var params: Dict[str, str] = Dict::new()
    val path_parts = path.split('/').filter(|p| not p.is_empty())
    var path_idx = 0

    for segment in segments:
        match segment:
            case Static(s):
                if path_idx >= path_parts.len():
                    return None
                if path_parts[path_idx] != *s:
                    return None
                path_idx = path_idx + 1

            case Param(name):
                if path_idx >= path_parts.len():
                    return None
                params.insert(name.clone(), path_parts[path_idx].to_string())
                path_idx = path_idx + 1

            case Wildcard(name):
                # Capture rest of path
                val rest = path_parts.slice(path_idx, path_parts.len()).join("/")
                params.insert(name.clone(), rest)
                path_idx = path_parts.len()

    # All path parts must be consumed (unless wildcard)
    if path_idx != path_parts.len():
        return None

    return Some(params)

# Default 404 handler
fn default_not_found(ctx: Context) -> async HttpResponse:
    return not_found_page(ctx.path())
