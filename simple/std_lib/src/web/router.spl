# Router - URL Pattern Matching
#
# Maps URL paths to handler functions with parameter extraction.
#
# ## Pattern Syntax
#
# - `/users` - Static path
# - `/users/:id` - Named parameter
# - `/files/*path` - Wildcard (catches rest of path)
#
# ## Example
#
# ```simple
# let router = Router::new()
#     .get("/", home_handler)
#     .get("/users", users_handler)
#     .get("/users/:id", user_detail_handler)
#     .post("/users", create_user_handler)
# ```

use web.http.request.*
use web.http.response.*

# Handler context with request and route params
pub struct Context:
    request: HttpRequest
    params: Dict[str, str]
    state: Dict[str, str]

impl Context:
    # Create context from request
    pub fn new(request: HttpRequest) -> Context:
        return Context {
            request: request,
            params: Dict::new(),
            state: Dict::new()
        }

    # Request access
    pub fn request(self) -> &HttpRequest:
        return &self.request

    pub fn method(self) -> HttpMethod:
        return self.request.method()

    pub fn path(self) -> &str:
        return self.request.path()

    # Route parameters
    pub fn param(self, name: &str) -> Option[&str]:
        return self.params.get(name)

    pub fn param_or(self, name: &str, default: &str) -> &str:
        return self.params.get(name).unwrap_or(default)

    pub fn param_u64(self, name: &str) -> Result[u64, HttpError]:
        match self.params.get(name):
            case Some(s): s.parse_u64().map_err(|_| HttpError::InvalidPath)
            case None: Err(HttpError::InvalidPath)

    pub fn param_i64(self, name: &str) -> Result[i64, HttpError]:
        match self.params.get(name):
            case Some(s): s.parse_i64().map_err(|_| HttpError::InvalidPath)
            case None: Err(HttpError::InvalidPath)

    # Query parameters
    pub fn query(self, name: &str) -> Option[&str]:
        return self.request.query_param(name)

    pub fn query_or(self, name: &str, default: &str) -> &str:
        return self.request.query_param(name).unwrap_or(default)

    # Headers
    pub fn header(self, name: &str) -> Option[&str]:
        return self.request.header(name)

    # Body
    pub fn body_text(self) -> Result[str, HttpError]:
        return self.request.body_text()

    # State management
    pub fn get_state(self, key: &str) -> Option[&str]:
        return self.state.get(key)

    pub fn set_state(self, key: &str, value: &str):
        self.state.insert(key.to_string(), value.to_string())

# Handler type
pub type Handler = fn(Context) -> async HttpResponse

# Route definition
pub struct Route:
    method: HttpMethod
    pattern: str
    handler: Handler
    segments: Array[RouteSegment]

# Route segment (parsed pattern)
pub enum RouteSegment:
    Static(str)      # Literal path segment
    Param(str)       # :name parameter
    Wildcard(str)    # *name wildcard

# Route match result
pub struct RouteMatch:
    handler: Handler
    params: Dict[str, str]

# Router
pub struct Router:
    routes: Array[Route]
    not_found_handler: Handler

impl Router:
    # Create new router
    pub fn new() -> Router:
        return Router {
            routes: [],
            not_found_handler: default_not_found
        }

    # Add GET route
    pub fn get(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Get, pattern, handler)

    # Add POST route
    pub fn post(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Post, pattern, handler)

    # Add PUT route
    pub fn put(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Put, pattern, handler)

    # Add DELETE route
    pub fn delete(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Delete, pattern, handler)

    # Add PATCH route
    pub fn patch(self, pattern: &str, handler: Handler) -> Router:
        return self.route(HttpMethod::Patch, pattern, handler)

    # Add route with method
    pub fn route(self, method: HttpMethod, pattern: &str, handler: Handler) -> Router:
        let segments = parse_pattern(pattern)
        self.routes.push(Route {
            method: method,
            pattern: pattern.to_string(),
            handler: handler,
            segments: segments
        })
        return self

    # Add route group with prefix
    pub fn group(self, prefix: &str, builder: fn(&mut Router)) -> Router:
        let mut sub_router = Router::new()
        builder(&mut sub_router)

        for route in sub_router.routes:
            let new_pattern = "{prefix}{route.pattern}"
            let segments = parse_pattern(&new_pattern)
            self.routes.push(Route {
                method: route.method,
                pattern: new_pattern,
                handler: route.handler,
                segments: segments
            })

        return self

    # Set 404 handler
    pub fn not_found(self, handler: Handler) -> Router:
        self.not_found_handler = handler
        return self

    # Match request to route
    pub fn match_route(self, request: &HttpRequest) -> RouteMatch:
        for route in &self.routes:
            if route.method != request.method():
                continue

            if let Some(params) = match_path(&route.segments, request.path()):
                return RouteMatch {
                    handler: route.handler,
                    params: params
                }

        return RouteMatch {
            handler: self.not_found_handler,
            params: Dict::new()
        }

    # Get all routes (for debugging)
    pub fn routes(self) -> &Array[Route]:
        return &self.routes

# Parse route pattern into segments
fn parse_pattern(pattern: &str) -> Array[RouteSegment]:
    let mut segments: Array[RouteSegment] = []
    let parts = pattern.split('/')

    for part in parts:
        if part.is_empty():
            continue

        if part.starts_with(':'):
            let name = part.slice(1, part.len())
            segments.push(RouteSegment::Param(name.to_string()))
        else if part.starts_with('*'):
            let name = part.slice(1, part.len())
            segments.push(RouteSegment::Wildcard(name.to_string()))
        else:
            segments.push(RouteSegment::Static(part.to_string()))

    return segments

# Match path against pattern segments
fn match_path(segments: &Array[RouteSegment], path: &str) -> Option[Dict[str, str]]:
    let mut params: Dict[str, str] = Dict::new()
    let path_parts = path.split('/').filter(|p| not p.is_empty())
    let mut path_idx = 0

    for segment in segments:
        match segment:
            case Static(s):
                if path_idx >= path_parts.len():
                    return None
                if path_parts[path_idx] != *s:
                    return None
                path_idx = path_idx + 1

            case Param(name):
                if path_idx >= path_parts.len():
                    return None
                params.insert(name.clone(), path_parts[path_idx].to_string())
                path_idx = path_idx + 1

            case Wildcard(name):
                # Capture rest of path
                let rest = path_parts.slice(path_idx, path_parts.len()).join("/")
                params.insert(name.clone(), rest)
                path_idx = path_parts.len()

    # All path parts must be consumed (unless wildcard)
    if path_idx != path_parts.len():
        return None

    return Some(params)

# Default 404 handler
fn default_not_found(ctx: Context) -> async HttpResponse:
    return not_found_page(ctx.path())
