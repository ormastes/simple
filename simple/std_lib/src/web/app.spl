# WebApp - Application Builder
#
# Main entry point for creating web applications with routing,
# middleware, and static file serving.
#
# ## Example
#
# ```simple
# use web.*
# use ui.*
#
# async fn home_handler(ctx: Context) -> HttpResponse:
#     val tree = ElementTree::new(ElementKind::Main)
#     tree.root_mut()
#         .with_class("container")
#         .with_child(Element::heading(1, "Welcome"))
#
#     return render_to_response(&tree, "Home")
#
# async fn main() -> i32:
#     val app = WebApp::new()
#         .port(3000)
#         .use_logger()
#         .use_cors()
#         .get("/", home_handler)
#         .get("/users/:id", user_handler)
#         .static_files("/assets", "public/")
#
#     await app.run()?
#     return 0
# ```

use units.net.*
use units.time.*
use host.common.io.error.IoError
use web.http.request.*
use web.http.response.*
use web.http.server.*
use web.router.*
use web.middleware.*
use web.static.*
use web.ssr.*

# Handler type alias
pub type AppHandler = fn(Context) -> async HttpResponse

# WebApp - Application builder
pub struct WebApp:
    config: ServerConfig
    router: Router
    middleware_chain: MiddlewareChain
    static_routes: Array[StaticRoute]
    error_handlers: ErrorHandlers

impl WebApp:
    # Create new web application
    pub fn new() -> WebApp:
        return WebApp {
            config: ServerConfig::bind_local(8080),
            router: Router::new(),
            middleware_chain: MiddlewareChain::new(),
            static_routes: [],
            error_handlers: ErrorHandlers::default()
        }

    # ========================================================================
    # Configuration
    # ========================================================================

    # Set port
    pub fn port(self, port: u16) -> WebApp:
        self.config = ServerConfig::bind_local(port)
        return self

    # Set full address
    pub fn bind(self, addr: SocketAddr) -> WebApp:
        self.config = ServerConfig::new(addr)
        return self

    # Set keep-alive
    pub fn keep_alive(self, enabled: bool) -> WebApp:
        self.config = self.config.with_keep_alive(enabled)
        return self

    # Set keep-alive timeout
    pub fn keep_alive_timeout(self, timeout: Duration) -> WebApp:
        self.config = self.config.with_keep_alive_timeout(timeout)
        return self

    # Set max connections
    pub fn max_connections(self, max: u32) -> WebApp:
        self.config = self.config.with_max_connections(max)
        return self

    # Set read timeout
    pub fn read_timeout(self, timeout: Duration) -> WebApp:
        self.config = self.config.with_read_timeout(timeout)
        return self

    # Set write timeout
    pub fn write_timeout(self, timeout: Duration) -> WebApp:
        self.config = self.config.with_write_timeout(timeout)
        return self

    # ========================================================================
    # Routing
    # ========================================================================

    # Add GET route
    pub fn get(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.get(pattern, handler)
        return self

    # Add POST route
    pub fn post(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.post(pattern, handler)
        return self

    # Add PUT route
    pub fn put(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.put(pattern, handler)
        return self

    # Add DELETE route
    pub fn delete(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.delete(pattern, handler)
        return self

    # Add PATCH route
    pub fn patch(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.patch(pattern, handler)
        return self

    # Add route with any method
    pub fn route(self, method: HttpMethod, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.route(method, pattern, handler)
        return self

    # Add route group with prefix
    pub fn group(self, prefix: &str, builder: fn(&mut Router)) -> WebApp:
        self.router = self.router.group(prefix, builder)
        return self

    # ========================================================================
    # Middleware
    # ========================================================================

    # Add middleware
    pub fn use_middleware(self, mw: Box[dyn Middleware]) -> WebApp:
        self.middleware_chain = self.middleware_chain.add(mw)
        return self

    # Add logger middleware (convenience)
    pub fn use_logger(self) -> WebApp:
        return self.use_middleware(Box::new(LoggerMiddleware::new()))

    # Add CORS middleware (convenience)
    pub fn use_cors(self) -> WebApp:
        return self.use_middleware(Box::new(CorsMiddleware::permissive()))

    # Add CORS with specific origin
    pub fn use_cors_origin(self, origin: &str) -> WebApp:
        return self.use_middleware(Box::new(CorsMiddleware::with_origin(origin)))

    # Add request ID middleware
    pub fn use_request_id(self) -> WebApp:
        return self.use_middleware(Box::new(RequestIdMiddleware::new()))

    # Add rate limiter
    pub fn use_rate_limit(self, max_requests: u32, window_seconds: u32) -> WebApp:
        return self.use_middleware(Box::new(RateLimitMiddleware::new(max_requests, window_seconds)))

    # Add compression middleware
    pub fn use_compression(self) -> WebApp:
        return self.use_middleware(Box::new(CompressionMiddleware::new()))

    # Add auth middleware
    pub fn use_auth(self, realm: &str, validator: fn(&str, &str) -> bool) -> WebApp:
        return self.use_middleware(Box::new(AuthMiddleware::new(realm, validator)))

    # ========================================================================
    # Static Files
    # ========================================================================

    # Serve static files from directory
    pub fn static_files(self, prefix: &str, root: &str) -> WebApp:
        self.static_routes.push(StaticRoute::new(prefix, root))
        return self

    # Serve static files with config
    pub fn static_files_config(self, prefix: &str, config: StaticFileConfig) -> WebApp:
        self.static_routes.push(StaticRoute::with_config(prefix, config))
        return self

    # ========================================================================
    # Error Handlers
    # ========================================================================

    # Set custom 404 handler
    pub fn not_found_handler(self, handler: AppHandler) -> WebApp:
        self.error_handlers.not_found = handler
        self.router = self.router.not_found(handler)
        return self

    # Set custom error handler
    pub fn error_handler(self, handler: fn(HttpError) -> HttpResponse) -> WebApp:
        self.error_handlers.error = handler
        return self

    # ========================================================================
    # Running
    # ========================================================================

    # Get the server address
    pub fn addr(self) -> SocketAddr:
        return self.config.addr

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_static_routes(self) -> bool:
        """Check if app has any static routes.

        Returns:
            true if static routes configured

        Example:
            app.has_static_routes()  # → true
        """
        return not self.static_routes.is_empty()

    pub fn static_route_count(self) -> u64:
        """Get number of static routes.

        Returns:
            Count of static routes

        Example:
            app.static_route_count()  # → 2
        """
        return self.static_routes.len()

    pub fn get_port(self) -> u16:
        """Get server port.

        Returns:
            Port number

        Example:
            app.get_port()  # → 3000
        """
        return self.config.addr.port()

    pub fn summary(self) -> String:
        """Get web app summary.

        Returns:
            Human-readable summary

        Example:
            app.summary()
            # → "WebApp: port=3000, static_routes=2"
        """
        val port = self.get_port()
        val static_count = self.static_route_count()
        return "WebApp: port={port}, static_routes={static_count}"

    # Run the application (blocking)
    pub async fn run(self) -> Result[(), IoError]:
        println("Starting server on http://{self.config.addr}")

        val server = HttpServer::new(self.config)
            .handler(self.create_handler())

        return await server.run()

    # Create the combined handler
    static fn create_handler() -> HttpHandler:
        val router = self.router
        val middleware = self.middleware_chain
        val static_routes = self.static_routes
        val error_handlers = self.error_handlers

        return async fn(request: HttpRequest) -> HttpResponse:
            # Create context
            var ctx = Context::new(request)

            # Run before middleware
            if val Some(response) = await middleware.run_before(&mut ctx):
                return response

            # Check static routes first
            val path = ctx.path()
            for static_route in &static_routes:
                if static_route.matches(path):
                    var response = await static_route.serve(path)
                    await middleware.run_after(&ctx, &mut response)
                    return response

            # Match route
            val route_match = router.match_route(ctx.request())

            # Set route params in context
            ctx.params = route_match.params

            # Call handler
            var response = await (route_match.handler)(ctx)

            # Run after middleware
            await middleware.run_after(&ctx, &mut response)

            return response

# Error handlers
pub struct ErrorHandlers:
    not_found: AppHandler
    error: fn(HttpError) -> HttpResponse

impl ErrorHandlers:
    pub fn default() -> ErrorHandlers:
        return ErrorHandlers {
            not_found: default_not_found_handler,
            error: default_error_handler
        }

fn default_not_found_handler(ctx: Context) -> async HttpResponse:
    return not_found_page(ctx.path())

fn default_error_handler(err: HttpError) -> HttpResponse:
    return server_error_page(&err.to_str())

# ============================================================================
# Quick Start Helpers
# ============================================================================

# Create and run a simple server
pub async fn serve(port: u16, handler: AppHandler) -> Result[(), IoError]:
    val app = WebApp::new()
        .port(port)
        .get("/", handler)
        .get("/*path", handler)

    return await app.run()

# Create a quick API server with common middleware
pub fn api_app(port: u16) -> WebApp:
    return WebApp::new()
        .port(port)
        .use_logger()
        .use_cors()
        .use_request_id()

# Create a quick web server with static files
pub fn web_app(port: u16, static_dir: &str) -> WebApp:
    return WebApp::new()
        .port(port)
        .use_logger()
        .static_files("/", static_dir)

# ============================================================================
# Route Builders (for complex routing)
# ============================================================================

# API route group builder
pub struct ApiBuilder:
    prefix: str
    routes: Router

impl ApiBuilder:
    pub fn new(prefix: &str) -> ApiBuilder:
        return ApiBuilder {
            prefix: prefix.to_string(),
            routes: Router::new()
        }

    pub fn get(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.get(pattern, handler)
        return self

    pub fn post(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.post(pattern, handler)
        return self

    pub fn put(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.put(pattern, handler)
        return self

    pub fn delete(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.delete(pattern, handler)
        return self

    pub fn build(self) -> fn(&mut Router):
        val routes = self.routes
        return fn(r: &mut Router):
            for route in routes.routes():
                r.route(route.method, &route.pattern, route.handler)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_prefix(self) -> &str:
        """Get API prefix.

        Returns:
            Prefix string

        Example:
            builder.get_prefix()  # → "/api/v1"
        """
        return &self.prefix

    pub fn route_count(self) -> u64:
        """Get number of routes.

        Returns:
            Count of routes

        Example:
            builder.route_count()  # → 5
        """
        return self.routes.routes().len()

    pub fn has_routes(self) -> bool:
        """Check if has any routes.

        Returns:
            true if routes exist

        Example:
            builder.has_routes()  # → true
        """
        return self.route_count() > 0

    pub fn summary(self) -> String:
        """Get API builder summary.

        Returns:
            Human-readable summary

        Example:
            builder.summary()
            # → "ApiBuilder: prefix='/api/v1', routes=5"
        """
        val count = self.route_count()
        return "ApiBuilder: prefix='{self.prefix}', routes={count}"

# Resource-style REST routes
pub struct Resource:
    name: str
    handlers: ResourceHandlers

pub struct ResourceHandlers:
    index: Option[AppHandler]    # GET /resources
    show: Option[AppHandler]     # GET /resources/:id
    create: Option[AppHandler]   # POST /resources
    update: Option[AppHandler]   # PUT /resources/:id
    delete: Option[AppHandler]   # DELETE /resources/:id

impl ResourceHandlers:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn count_handlers(self) -> u32:
        """Count how many handlers are set.

        Returns:
            Number of configured handlers

        Example:
            handlers.count_handlers()  # → 3
        """
        var count: u32 = 0
        if self.index.is_some(): count = count + 1
        if self.show.is_some(): count = count + 1
        if self.create.is_some(): count = count + 1
        if self.update.is_some(): count = count + 1
        if self.delete.is_some(): count = count + 1
        return count

    pub fn is_complete(self) -> bool:
        """Check if all handlers are set.

        Returns:
            true if all 5 handlers configured

        Example:
            handlers.is_complete()  # → false
        """
        return self.count_handlers() == 5

    pub fn is_read_only(self) -> bool:
        """Check if only read operations (index/show) are set.

        Returns:
            true if only index/show and no write ops

        Example:
            handlers.is_read_only()  # → true
        """
        val has_read = self.index.is_some() or self.show.is_some()
        val has_write = self.create.is_some() or self.update.is_some() or self.delete.is_some()
        return has_read and not has_write

    pub fn is_empty(self) -> bool:
        """Check if no handlers are set.

        Returns:
            true if no handlers configured

        Example:
            handlers.is_empty()  # → false
        """
        return self.count_handlers() == 0

    pub fn summary(self) -> String:
        """Get resource handlers summary.

        Returns:
            Human-readable summary

        Example:
            handlers.summary()
            # → "ResourceHandlers: 3/5 handlers (index, show, create)"
        """
        val count = self.count_handlers()
        var ops = []
        if self.index.is_some(): ops.push("index")
        if self.show.is_some(): ops.push("show")
        if self.create.is_some(): ops.push("create")
        if self.update.is_some(): ops.push("update")
        if self.delete.is_some(): ops.push("delete")
        val ops_str = ops.join(", ")
        return "ResourceHandlers: {count}/5 handlers ({ops_str})"

impl Resource:
    pub fn new(name: &str) -> Resource:
        return Resource {
            name: name.to_string(),
            handlers: ResourceHandlers {
                index: None,
                show: None,
                create: None,
                update: None,
                delete: None
            }
        }

    pub fn index(self, handler: AppHandler) -> Resource:
        self.handlers.index = Some(handler)
        return self

    pub fn show(self, handler: AppHandler) -> Resource:
        self.handlers.show = Some(handler)
        return self

    pub fn create(self, handler: AppHandler) -> Resource:
        self.handlers.create = Some(handler)
        return self

    pub fn update(self, handler: AppHandler) -> Resource:
        self.handlers.update = Some(handler)
        return self

    pub fn delete(self, handler: AppHandler) -> Resource:
        self.handlers.delete = Some(handler)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_name(self) -> &str:
        """Get resource name.

        Returns:
            Resource name

        Example:
            resource.get_name()  # → "users"
        """
        return &self.name

    pub fn handler_count(self) -> u32:
        """Get number of configured handlers.

        Returns:
            Count of handlers

        Example:
            resource.handler_count()  # → 3
        """
        return self.handlers.count_handlers()

    pub fn has_index(self) -> bool:
        """Check if index handler is set.

        Returns:
            true if index configured

        Example:
            resource.has_index()  # → true
        """
        return self.handlers.index.is_some()

    pub fn has_show(self) -> bool:
        """Check if show handler is set.

        Returns:
            true if show configured

        Example:
            resource.has_show()  # → true
        """
        return self.handlers.show.is_some()

    pub fn has_create(self) -> bool:
        """Check if create handler is set.

        Returns:
            true if create configured

        Example:
            resource.has_create()  # → true
        """
        return self.handlers.create.is_some()

    pub fn has_update(self) -> bool:
        """Check if update handler is set.

        Returns:
            true if update configured

        Example:
            resource.has_update()  # → false
        """
        return self.handlers.update.is_some()

    pub fn has_delete(self) -> bool:
        """Check if delete handler is set.

        Returns:
            true if delete configured

        Example:
            resource.has_delete()  # → false
        """
        return self.handlers.delete.is_some()

    pub fn is_complete(self) -> bool:
        """Check if all handlers are configured.

        Returns:
            true if all 5 handlers set

        Example:
            resource.is_complete()  # → false
        """
        return self.handlers.is_complete()

    pub fn is_read_only(self) -> bool:
        """Check if only read operations configured.

        Returns:
            true if only index/show set

        Example:
            resource.is_read_only()  # → true
        """
        return self.handlers.is_read_only()

    pub fn summary(self) -> String:
        """Get resource summary.

        Returns:
            Human-readable summary

        Example:
            resource.summary()
            # → "Resource: 'users', 3/5 handlers"
        """
        val count = self.handler_count()
        return "Resource: '{self.name}', {count}/5 handlers"

    # Apply resource routes to app
    pub fn apply(self, app: WebApp) -> WebApp:
        val base = "/{self.name}"
        val item = "/{self.name}/:id"

        var result = app

        if val Some(h) = self.handlers.index:
            result = result.get(&base, h)

        if val Some(h) = self.handlers.show:
            result = result.get(&item, h)

        if val Some(h) = self.handlers.create:
            result = result.post(&base, h)

        if val Some(h) = self.handlers.update:
            result = result.put(&item, h)

        if val Some(h) = self.handlers.delete:
            result = result.delete(&item, h)

        return result
