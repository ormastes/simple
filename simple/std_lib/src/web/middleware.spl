# Middleware - Request/Response Pipeline
#
# Middleware intercepts requests before handlers and responses after.
#
# ## Example
#
# ```simple
# let app = WebApp::new()
#     .use_middleware(LoggerMiddleware::new())
#     .use_middleware(CorsMiddleware::permissive())
#     .get("/", home_handler)
# ```

use web.http.request.*
use web.http.response.*
use web.router.Context

# Middleware result - continue or short-circuit
pub enum MiddlewareResult:
    Next                    # Continue to next middleware/handler
    Response(HttpResponse)  # Short-circuit with response

# Middleware trait
pub trait Middleware:
    # Called before handler
    async fn before(self, ctx: &mut Context) -> MiddlewareResult

    # Called after handler (optional override)
    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        pass  # Default: no-op

# Middleware chain executor
pub struct MiddlewareChain:
    middlewares: Array[Box[dyn Middleware]]

impl MiddlewareChain:
    pub fn new() -> MiddlewareChain:
        return MiddlewareChain {
            middlewares: []
        }

    pub fn add(self, mw: Box[dyn Middleware]) -> MiddlewareChain:
        self.middlewares.push(mw)
        return self

    # Execute before hooks, returns None if all pass
    pub async fn run_before(self, ctx: &mut Context) -> Option[HttpResponse]:
        for mw in &self.middlewares:
            match await mw.before(ctx):
                case Next: continue
                case Response(r): return Some(r)
        return None

    # Execute after hooks in reverse order
    pub async fn run_after(self, ctx: &Context, response: &mut HttpResponse):
        for mw in self.middlewares.iter().rev():
            await mw.after(ctx, response)

# ============================================================================
# Built-in Middlewares
# ============================================================================

# Logger Middleware - Logs request/response info
pub struct LoggerMiddleware:
    prefix: str

impl LoggerMiddleware:
    pub fn new() -> LoggerMiddleware:
        return LoggerMiddleware { prefix: "[HTTP]" }

    pub fn with_prefix(prefix: &str) -> LoggerMiddleware:
        return LoggerMiddleware { prefix: prefix.to_string() }

impl Middleware for LoggerMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        let method = ctx.method().to_str()
        let path = ctx.path()
        println("{self.prefix} --> {method} {path}")
        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        let status = response.get_status().code()
        let path = ctx.path()
        println("{self.prefix} <-- {status} {path}")

# CORS Middleware - Cross-Origin Resource Sharing
pub struct CorsMiddleware:
    allow_origin: str
    allow_methods: str
    allow_headers: str
    max_age: u32
    allow_credentials: bool

impl CorsMiddleware:
    # Create permissive CORS (allow all)
    pub fn permissive() -> CorsMiddleware:
        return CorsMiddleware {
            allow_origin: "*",
            allow_methods: "GET, POST, PUT, DELETE, PATCH, OPTIONS",
            allow_headers: "Content-Type, Authorization, X-Requested-With",
            max_age: 86400,
            allow_credentials: false
        }

    # Create with specific origin
    pub fn with_origin(origin: &str) -> CorsMiddleware:
        return CorsMiddleware {
            allow_origin: origin.to_string(),
            allow_methods: "GET, POST, PUT, DELETE, PATCH, OPTIONS",
            allow_headers: "Content-Type, Authorization",
            max_age: 3600,
            allow_credentials: true
        }

    # Builder methods
    pub fn allow_methods(self, methods: &str) -> CorsMiddleware:
        self.allow_methods = methods.to_string()
        return self

    pub fn allow_headers(self, headers: &str) -> CorsMiddleware:
        self.allow_headers = headers.to_string()
        return self

    pub fn max_age(self, seconds: u32) -> CorsMiddleware:
        self.max_age = seconds
        return self

    pub fn allow_credentials(self, allow: bool) -> CorsMiddleware:
        self.allow_credentials = allow
        return self

impl Middleware for CorsMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        # Handle preflight OPTIONS request
        if ctx.method() == HttpMethod::Options:
            let response = HttpResponse::no_content()
                .header("Access-Control-Allow-Origin", &self.allow_origin)
                .header("Access-Control-Allow-Methods", &self.allow_methods)
                .header("Access-Control-Allow-Headers", &self.allow_headers)
                .header("Access-Control-Max-Age", &self.max_age.to_str())

            if self.allow_credentials:
                response = response.header("Access-Control-Allow-Credentials", "true")

            return MiddlewareResult::Response(response)

        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        # Add CORS headers to all responses
        response.headers.insert("Access-Control-Allow-Origin".to_string(), self.allow_origin.clone())
        if self.allow_credentials:
            response.headers.insert("Access-Control-Allow-Credentials".to_string(), "true".to_string())

# Auth Middleware - Basic authentication check
pub struct AuthMiddleware:
    realm: str
    validator: fn(&str, &str) -> bool  # (username, password) -> valid

impl AuthMiddleware:
    pub fn new(realm: &str, validator: fn(&str, &str) -> bool) -> AuthMiddleware:
        return AuthMiddleware {
            realm: realm.to_string(),
            validator: validator
        }

    # Parse Basic auth header
    fn parse_basic_auth(header: &str) -> Option[(str, str)]:
        if not header.starts_with("Basic "):
            return None

        let encoded = header.slice(6, header.len())
        match base64_decode(encoded):
            case Ok(decoded):
                if let Some(idx) = decoded.find(':'):
                    let user = decoded.slice(0, idx)
                    let pass = decoded.slice(idx + 1, decoded.len())
                    return Some((user.to_string(), pass.to_string()))
                return None
            case Err(_):
                return None

impl Middleware for AuthMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        match ctx.header("authorization"):
            case Some(auth):
                match AuthMiddleware::parse_basic_auth(auth):
                    case Some((user, pass)):
                        if (self.validator)(&user, &pass):
                            ctx.set_state("auth_user", &user)
                            return MiddlewareResult::Next
                    case None:
                        pass
            case None:
                pass

        # Return 401 Unauthorized
        let response = HttpResponse::unauthorized()
            .header("WWW-Authenticate", &"Basic realm=\"{self.realm}\"")
            .text("Unauthorized")
        return MiddlewareResult::Response(response)

# Rate Limiter Middleware - Simple in-memory rate limiting
pub struct RateLimitMiddleware:
    max_requests: u32
    window_seconds: u32
    requests: Dict[str, (u32, u64)]  # ip -> (count, window_start)

impl RateLimitMiddleware:
    pub fn new(max_requests: u32, window_seconds: u32) -> RateLimitMiddleware:
        return RateLimitMiddleware {
            max_requests: max_requests,
            window_seconds: window_seconds,
            requests: Dict::new()
        }

    # Get client identifier (IP address)
    fn get_client_id(ctx: &Context) -> str:
        return ctx.request().remote_addr().to_str()

impl Middleware for RateLimitMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        let client_id = RateLimitMiddleware::get_client_id(ctx)
        let now = time::now_unix()
        let window_start = now - (now % self.window_seconds as u64)

        match self.requests.get(&client_id):
            case Some((count, start)):
                if *start == window_start:
                    if *count >= self.max_requests:
                        let response = HttpResponse::new(StatusCode::TooManyRequests)
                            .header("Retry-After", &self.window_seconds.to_str())
                            .text("Rate limit exceeded")
                        return MiddlewareResult::Response(response)
                    self.requests.insert(client_id, (*count + 1, window_start))
                else:
                    # New window
                    self.requests.insert(client_id, (1, window_start))
            case None:
                self.requests.insert(client_id, (1, window_start))

        return MiddlewareResult::Next

# Request ID Middleware - Adds unique request ID
pub struct RequestIdMiddleware:
    header_name: str

impl RequestIdMiddleware:
    pub fn new() -> RequestIdMiddleware:
        return RequestIdMiddleware {
            header_name: "X-Request-ID".to_string()
        }

    pub fn with_header(name: &str) -> RequestIdMiddleware:
        return RequestIdMiddleware {
            header_name: name.to_string()
        }

    fn generate_id() -> str:
        # Simple UUID-like ID
        return random::uuid_v4()

impl Middleware for RequestIdMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        let request_id = match ctx.header(&self.header_name):
            case Some(id): id.to_string()
            case None: RequestIdMiddleware::generate_id()

        ctx.set_state("request_id", &request_id)
        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        if let Some(id) = ctx.get_state("request_id"):
            response.headers.insert(self.header_name.clone(), id.to_string())

# Compression Middleware - Gzip compression (placeholder)
pub struct CompressionMiddleware:
    min_size: usize
    content_types: Array[str]

impl CompressionMiddleware:
    pub fn new() -> CompressionMiddleware:
        return CompressionMiddleware {
            min_size: 1024,  # Only compress responses > 1KB
            content_types: [
                "text/html",
                "text/css",
                "text/javascript",
                "application/javascript",
                "application/json"
            ]
        }

    pub fn min_size(self, size: usize) -> CompressionMiddleware:
        self.min_size = size
        return self

impl Middleware for CompressionMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        # Check if client accepts gzip
        if let Some(accept) = ctx.header("accept-encoding"):
            if accept.contains("gzip"):
                ctx.set_state("accept_gzip", "true")
        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        # TODO: Actual gzip compression when compression library available
        # For now, just a placeholder that would compress the response
        if ctx.get_state("accept_gzip").is_some():
            if let Some(body) = response.get_body():
                if body.len() >= self.min_size:
                    if let Some(ct) = response.get_header("Content-Type"):
                        for allowed in &self.content_types:
                            if ct.starts_with(allowed):
                                # Would compress here
                                # response.headers.insert("Content-Encoding", "gzip")
                                break

# Helper: Base64 decode (simplified)
fn base64_decode(s: &str) -> Result[str, ()]:
    # TODO: Implement proper base64 decoding
    # This is a placeholder that would decode base64
    return Err(())
