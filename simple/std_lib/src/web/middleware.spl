# Middleware - Request/Response Pipeline
#
# Middleware intercepts requests before handlers and responses after.
#
# ## Example
#
# ```simple
# val app = WebApp::new()
#     .use_middleware(LoggerMiddleware::new())
#     .use_middleware(CorsMiddleware::permissive())
#     .get("/", home_handler)
# ```

use web.http.request.*
use web.http.response.*
use web.router.Context

# Middleware result - continue or short-circuit
pub enum MiddlewareResult:
    Next                    # Continue to next middleware/handler
    Response(HttpResponse)  # Short-circuit with response

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_next(self) -> bool:
        """Check if result is Next.

        Returns:
            true if Next variant

        Example:
            result.is_next()  # → true
        """
        match self:
            case Next: return true
            case _: return false

    pub fn is_response(self) -> bool:
        """Check if result is Response (short-circuit).

        Returns:
            true if Response variant

        Example:
            result.is_response()  # → false
        """
        match self:
            case Response { .. }: return true
            case _: return false

    pub fn should_continue(self) -> bool:
        """Check if middleware should continue (alias for is_next).

        Returns:
            true if Next

        Example:
            result.should_continue()  # → true
        """
        return self.is_next()

    pub fn to_string(self) -> String:
        """Convert result to string.

        Returns:
            Result type name

        Example:
            MiddlewareResult::Next.to_string()  # → "next"
        """
        match self:
            case Next: return "next"
            case Response { .. }: return "response"

    pub fn description(self) -> String:
        """Get result description.

        Returns:
            Human-readable description

        Example:
            MiddlewareResult::Next.description()
            # → "Continue to next middleware in chain"
        """
        match self:
            case Next: return "Continue to next middleware in chain"
            case Response { .. }: return "Short-circuit with response (skip remaining middleware)"

    pub fn summary(self) -> String:
        """Get result summary.

        Returns:
            Human-readable summary

        Example:
            result.summary()
            # → "Next" or "Response: short-circuit"
        """
        match self:
            case Next: return "Next"
            case Response { .. }: return "Response: short-circuit"

# Middleware trait
pub trait Middleware:
    # Called before handler
    async fn before(self, ctx: &mut Context) -> MiddlewareResult

    # Called after handler (optional override)
    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        pass  # Default: no-op

# Middleware chain executor
pub struct MiddlewareChain:
    middlewares: Array[Box[dyn Middleware]]

impl MiddlewareChain:
    pub fn new() -> MiddlewareChain:
        return MiddlewareChain {
            middlewares: []
        }

    pub fn add(self, mw: Box[dyn Middleware]) -> MiddlewareChain:
        self.middlewares.push(mw)
        return self

    # Execute before hooks, returns None if all pass
    pub async fn run_before(self, ctx: &mut Context) -> Option[HttpResponse]:
        for mw in &self.middlewares:
            match await mw.before(ctx):
                case Next: continue
                case Response(r): return Some(r)
        return None

    # Execute after hooks in reverse order
    pub async fn run_after(self, ctx: &Context, response: &mut HttpResponse):
        for mw in self.middlewares.iter().rev():
            await mw.after(ctx, response)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_middlewares(self) -> bool:
        """Check if chain has any middlewares.

        Returns:
            true if middlewares exist

        Example:
            chain.has_middlewares()  # → true
        """
        return not self.middlewares.is_empty()

    pub fn middleware_count(self) -> u64:
        """Get number of middlewares in chain.

        Returns:
            Count of middlewares

        Example:
            chain.middleware_count()  # → 3
        """
        return self.middlewares.len()

    pub fn summary(self) -> String:
        """Get chain summary.

        Returns:
            Human-readable summary

        Example:
            chain.summary()
            # → "MiddlewareChain: 3 middlewares"
        """
        val count = self.middleware_count()
        return "MiddlewareChain: {count} middlewares"

# ============================================================================
# Built-in Middlewares
# ============================================================================

# Logger Middleware - Logs request/response info
pub struct LoggerMiddleware:
    prefix: str

impl LoggerMiddleware:
    pub fn new() -> LoggerMiddleware:
        return LoggerMiddleware { prefix: "[HTTP]" }

    pub fn with_prefix(prefix: &str) -> LoggerMiddleware:
        return LoggerMiddleware { prefix: prefix.to_string() }

impl Middleware for LoggerMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        val method = ctx.method().to_str()
        val path = ctx.path()
        println("{self.prefix} --> {method} {path}")
        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        val status = response.get_status().code()
        val path = ctx.path()
        println("{self.prefix} <-- {status} {path}")

# CORS Middleware - Cross-Origin Resource Sharing
pub struct CorsMiddleware:
    allow_origin: str
    allow_methods: str
    allow_headers: str
    max_age: u32
    allow_credentials: bool

impl CorsMiddleware:
    # Create permissive CORS (allow all)
    pub fn permissive() -> CorsMiddleware:
        return CorsMiddleware {
            allow_origin: "*",
            allow_methods: "GET, POST, PUT, DELETE, PATCH, OPTIONS",
            allow_headers: "Content-Type, Authorization, X-Requested-With",
            max_age: 86400,
            allow_credentials: false
        }

    # Create with specific origin
    pub fn with_origin(origin: &str) -> CorsMiddleware:
        return CorsMiddleware {
            allow_origin: origin.to_string(),
            allow_methods: "GET, POST, PUT, DELETE, PATCH, OPTIONS",
            allow_headers: "Content-Type, Authorization",
            max_age: 3600,
            allow_credentials: true
        }

    # Builder methods
    pub fn allow_methods(self, methods: &str) -> CorsMiddleware:
        self.allow_methods = methods.to_string()
        return self

    pub fn allow_headers(self, headers: &str) -> CorsMiddleware:
        self.allow_headers = headers.to_string()
        return self

    pub fn max_age(self, seconds: u32) -> CorsMiddleware:
        self.max_age = seconds
        return self

    pub fn allow_credentials(self, allow: bool) -> CorsMiddleware:
        self.allow_credentials = allow
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_permissive(self) -> bool:
        """Check if allowing all origins.

        Returns:
            true if allow_origin is "*"

        Example:
            cors.is_permissive()  # → true
        """
        return self.allow_origin == "*"

    pub fn has_credentials(self) -> bool:
        """Check if credentials are allowed.

        Returns:
            true if allow_credentials is true

        Example:
            cors.has_credentials()  # → false
        """
        return self.allow_credentials

    pub fn get_max_age(self) -> u32:
        """Get max age in seconds.

        Returns:
            Max age value

        Example:
            cors.get_max_age()  # → 86400
        """
        return self.max_age

    pub fn summary(self) -> String:
        """Get CORS middleware summary.

        Returns:
            Human-readable summary

        Example:
            cors.summary()
            # → "CorsMiddleware: origin=*, credentials=false"
        """
        val creds = if self.allow_credentials { "true" } else { "false" }
        return "CorsMiddleware: origin={self.allow_origin}, credentials={creds}"

impl Middleware for CorsMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        # Handle preflight OPTIONS request
        if ctx.method() == HttpMethod::Options:
            val response = HttpResponse::no_content()
                .header("Access-Control-Allow-Origin", &self.allow_origin)
                .header("Access-Control-Allow-Methods", &self.allow_methods)
                .header("Access-Control-Allow-Headers", &self.allow_headers)
                .header("Access-Control-Max-Age", &self.max_age.to_str())

            if self.allow_credentials:
                response = response.header("Access-Control-Allow-Credentials", "true")

            return MiddlewareResult::Response(response)

        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        # Add CORS headers to all responses
        response.headers.insert("Access-Control-Allow-Origin".to_string(), self.allow_origin.clone())
        if self.allow_credentials:
            response.headers.insert("Access-Control-Allow-Credentials".to_string(), "true".to_string())

# Auth Middleware - Basic authentication check
pub struct AuthMiddleware:
    realm: str
    validator: fn(&str, &str) -> bool  # (username, password) -> valid

impl AuthMiddleware:
    pub fn new(realm: &str, validator: fn(&str, &str) -> bool) -> AuthMiddleware:
        return AuthMiddleware {
            realm: realm.to_string(),
            validator: validator
        }

    # Parse Basic auth header
    fn parse_basic_auth(header: &str) -> Option[(str, str)]:
        if not header.starts_with("Basic "):
            return None

        val encoded = header.slice(6, header.len())
        match base64_decode(encoded):
            case Ok(decoded):
                if val Some(idx) = decoded.find(':'):
                    val user = decoded.slice(0, idx)
                    val pass = decoded.slice(idx + 1, decoded.len())
                    return Some((user.to_string(), pass.to_string()))
                return None
            case Err(_):
                return None

impl Middleware for AuthMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        match ctx.header("authorization"):
            case Some(auth):
                match AuthMiddleware::parse_basic_auth(auth):
                    case Some((user, pass)):
                        if (self.validator)(&user, &pass):
                            ctx.set_state("auth_user", &user)
                            return MiddlewareResult::Next
                    case None:
                        pass
            case None:
                pass

        # Return 401 Unauthorized
        val response = HttpResponse::unauthorized()
            .header("WWW-Authenticate", &"Basic realm=\"{self.realm}\"")
            .text("Unauthorized")
        return MiddlewareResult::Response(response)

# Rate Limiter Middleware - Simple in-memory rate limiting
pub struct RateLimitMiddleware:
    max_requests: u32
    window_seconds: u32
    requests: Dict[str, (u32, u64)]  # ip -> (count, window_start)

impl RateLimitMiddleware:
    pub fn new(max_requests: u32, window_seconds: u32) -> RateLimitMiddleware:
        return RateLimitMiddleware {
            max_requests: max_requests,
            window_seconds: window_seconds,
            requests: Dict::new()
        }

    # Get client identifier (IP address)
    fn get_client_id(ctx: &Context) -> str:
        return ctx.request().remote_addr().to_str()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_max_requests(self) -> u32:
        """Get max requests per window.

        Returns:
            Max request count

        Example:
            limiter.get_max_requests()  # → 100
        """
        return self.max_requests

    pub fn get_window_seconds(self) -> u32:
        """Get window size in seconds.

        Returns:
            Window duration

        Example:
            limiter.get_window_seconds()  # → 60
        """
        return self.window_seconds

    pub fn tracked_clients(self) -> u64:
        """Get number of tracked clients.

        Returns:
            Count of tracked IPs

        Example:
            limiter.tracked_clients()  # → 25
        """
        return self.requests.len()

    pub fn summary(self) -> String:
        """Get rate limiter summary.

        Returns:
            Human-readable summary

        Example:
            limiter.summary()
            # → "RateLimitMiddleware: 100 req/60s, tracking 25 clients"
        """
        val max = self.max_requests
        val window = self.window_seconds
        val tracked = self.tracked_clients()
        return "RateLimitMiddleware: {max} req/{window}s, tracking {tracked} clients"

impl Middleware for RateLimitMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        val client_id = RateLimitMiddleware::get_client_id(ctx)
        val now = time::now_unix()
        val window_start = now - (now % self.window_seconds as u64)

        match self.requests.get(&client_id):
            case Some((count, start)):
                if *start == window_start:
                    if *count >= self.max_requests:
                        val response = HttpResponse::new(StatusCode::TooManyRequests)
                            .header("Retry-After", &self.window_seconds.to_str())
                            .text("Rate limit exceeded")
                        return MiddlewareResult::Response(response)
                    self.requests.insert(client_id, (*count + 1, window_start))
                else:
                    # New window
                    self.requests.insert(client_id, (1, window_start))
            case None:
                self.requests.insert(client_id, (1, window_start))

        return MiddlewareResult::Next

# Request ID Middleware - Adds unique request ID
pub struct RequestIdMiddleware:
    header_name: str

impl RequestIdMiddleware:
    pub fn new() -> RequestIdMiddleware:
        return RequestIdMiddleware {
            header_name: "X-Request-ID".to_string()
        }

    pub fn with_header(name: &str) -> RequestIdMiddleware:
        return RequestIdMiddleware {
            header_name: name.to_string()
        }

    fn generate_id() -> str:
        # Simple UUID-like ID
        return random::uuid_v4()

impl Middleware for RequestIdMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        val request_id = match ctx.header(&self.header_name):
            case Some(id): id.to_string()
            case None: RequestIdMiddleware::generate_id()

        ctx.set_state("request_id", &request_id)
        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        if val Some(id) = ctx.get_state("request_id"):
            response.headers.insert(self.header_name.clone(), id.to_string())

# Compression Middleware - Gzip compression (placeholder)
pub struct CompressionMiddleware:
    min_size: usize
    content_types: Array[str]

impl CompressionMiddleware:
    pub fn new() -> CompressionMiddleware:
        return CompressionMiddleware {
            min_size: 1024,  # Only compress responses > 1KB
            content_types: [
                "text/html",
                "text/css",
                "text/javascript",
                "application/javascript",
                "application/json"
            ]
        }

    pub fn min_size(self, size: usize) -> CompressionMiddleware:
        self.min_size = size
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_min_size(self) -> usize:
        """Get minimum size for compression.

        Returns:
            Min size in bytes

        Example:
            comp.get_min_size()  # → 1024
        """
        return self.min_size

    pub fn allowed_types_count(self) -> u64:
        """Get number of allowed content types.

        Returns:
            Count of content types

        Example:
            comp.allowed_types_count()  # → 5
        """
        return self.content_types.len()

    pub fn supports_type(self, content_type: &str) -> bool:
        """Check if content type is supported.

        Args:
            content_type: Content type to check

        Returns:
            true if type is in allowed list

        Example:
            comp.supports_type("text/html")  # → true
        """
        for allowed in &self.content_types:
            if content_type.starts_with(allowed):
                return true
        return false

    pub fn summary(self) -> String:
        """Get compression middleware summary.

        Returns:
            Human-readable summary

        Example:
            comp.summary()
            # → "CompressionMiddleware: min=1024 bytes, 5 types"
        """
        val min = self.min_size
        val types = self.allowed_types_count()
        return "CompressionMiddleware: min={min} bytes, {types} types"

impl Middleware for CompressionMiddleware:
    async fn before(self, ctx: &mut Context) -> MiddlewareResult:
        # Check if client accepts gzip
        if val Some(accept) = ctx.header("accept-encoding"):
            if accept.contains("gzip"):
                ctx.set_state("accept_gzip", "true")
        return MiddlewareResult::Next

    async fn after(self, ctx: &Context, response: &mut HttpResponse):
        # TODO: [stdlib][P3] Actual gzip compression when compression library available
        # For now, just a placeholder that would compress the response
        if ctx.get_state("accept_gzip").is_some():
            if val Some(body) = response.get_body():
                if body.len() >= self.min_size:
                    if val Some(ct) = response.get_header("Content-Type"):
                        for allowed in &self.content_types:
                            if ct.starts_with(allowed):
                                # Would compress here
                                # response.headers.insert("Content-Encoding", "gzip")
                                break

# Extern declaration for base64 decoding
extern fn rt_base64_decode(s: String) -> String

# Helper: Base64 decode
fn base64_decode(s: &str) -> Result[str, ()]:
    result = rt_base64_decode(s)
    if result == "":
        return Err(())
    return Ok(result)
