# Ordered map using Rust std::collections::BTreeMap
#
# Provides O(log n) operations with deterministic iteration order.
# Keys are kept sorted, making this ideal for range queries and ordered iteration.
#
# Example:
#   val map = BTreeMap.new()
#   map.insert(3, "three")
#   map.insert(1, "one")
#   map.insert(2, "two")
#   val keys = map.keys()  # Returns [1, 2, 3] in sorted order

struct BTreeMap:
    handle: any  # RuntimeValue handle to Rust BTreeMap

impl BTreeMap:
    # Create a new empty BTreeMap
    static fn new() -> BTreeMap:
        val handle = __rt_btreemap_new()
        BTreeMap(handle)

    # Insert a key-value pair
    # Returns true if the key was newly inserted, false if it already existed
    me insert(key: any, value: any) -> bool:
        __rt_btreemap_insert(self.handle, key, value)

    # Get a value by key
    # Returns the value if found, nil otherwise
    fn get(key: any) -> any:
        __rt_btreemap_get(self.handle, key)

    # Check if a key exists
    fn contains_key(key: any) -> bool:
        __rt_btreemap_contains_key(self.handle, key)

    # Remove a key-value pair
    # Returns the value if found, nil otherwise
    me remove(key: any) -> any:
        __rt_btreemap_remove(self.handle, key)

    # Get the number of entries
    fn len() -> i64:
        __rt_btreemap_len(self.handle)

    # Check if the map is empty
    fn is_empty() -> bool:
        self.len() == 0

    # Clear all entries
    me clear():
        __rt_btreemap_clear(self.handle)

    # Get all keys as an array (in sorted order)
    fn keys() -> [any]:
        __rt_btreemap_keys(self.handle)

    # Get all values as an array (sorted by key order)
    fn values() -> [any]:
        __rt_btreemap_values(self.handle)

    # Get all entries as an array of [key, value] pairs (in sorted order)
    fn entries() -> [[any]]:
        __rt_btreemap_entries(self.handle)

    # Get the first (smallest) key
    fn first_key() -> any:
        __rt_btreemap_first_key(self.handle)

    # Get the last (largest) key
    fn last_key() -> any:
        __rt_btreemap_last_key(self.handle)

    # Iterate over key-value pairs (in sorted order)
    fn each(f: fn(any, any) -> void):
        val entries = self.entries()
        for entry in entries:
            if entry.len() == 2:
                f(entry[0], entry[1])

    # Map over values (returns new BTreeMap with same keys)
    fn map_values(f: fn(any) -> any) -> BTreeMap:
        val result = BTreeMap.new()
        val entries = self.entries()
        for entry in entries:
            if entry.len() == 2:
                result.insert(entry[0], f(entry[1]))
        result

    # Filter entries (returns new BTreeMap)
    fn filter(predicate: fn(any, any) -> bool) -> BTreeMap:
        val result = BTreeMap.new()
        val entries = self.entries()
        for entry in entries:
            if entry.len() == 2:
                if predicate(entry[0], entry[1]):
                    result.insert(entry[0], entry[1])
        result

# FFI declarations
extern fn __rt_btreemap_new() -> any
extern fn __rt_btreemap_insert(handle: any, key: any, value: any) -> bool
extern fn __rt_btreemap_get(handle: any, key: any) -> any
extern fn __rt_btreemap_contains_key(handle: any, key: any) -> bool
extern fn __rt_btreemap_remove(handle: any, key: any) -> any
extern fn __rt_btreemap_len(handle: any) -> i64
extern fn __rt_btreemap_clear(handle: any) -> bool
extern fn __rt_btreemap_keys(handle: any) -> [any]
extern fn __rt_btreemap_values(handle: any) -> [any]
extern fn __rt_btreemap_entries(handle: any) -> [[any]]
extern fn __rt_btreemap_first_key(handle: any) -> any
extern fn __rt_btreemap_last_key(handle: any) -> any
