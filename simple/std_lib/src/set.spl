# Set - Hash set type
# Unordered collection of unique elements

use map

# ============================================================================
# Set Type (implemented using Map)
# ============================================================================

struct Set<T>:
    map: Map<T, bool>

    static fn new() -> Set<T>:
        """Create a new empty set.

        Returns:
            Empty set with default capacity

        Example:
            val set = Set.new()
        """
        Set(map: Map.new())

    static fn with_capacity(capacity: i32) -> Set<T>:
        """Create a new set with specified capacity.

        Args:
            capacity: Initial capacity

        Returns:
            Empty set with specified capacity

        Example:
            val set = Set.with_capacity(32)
        """
        Set(map: Map.with_capacity(capacity))

    fn len() -> i32:
        """Get number of elements in set.

        Returns:
            Number of elements

        Example:
            print set.len()
        """
        self.map.len()

    fn is_empty() -> bool:
        """Check if set is empty.

        Returns:
            true if set has no elements

        Example:
            if set.is_empty():
                print "Empty set"
        """
        self.map.is_empty()

    me insert(value: T) -> bool:
        """Insert element into set.

        Args:
            value: Element to insert

        Returns:
            true if element was added, false if already existed

        Example:
            if set.insert("Alice"):
                print "Added"
        """
        self.map.insert_if_absent(value, true)

    fn has(value: T) -> bool:
        """Check if set contains element.

        Args:
            value: Element to check

        Returns:
            true if element exists

        Example:
            if set.has("Alice"):
                print "Found!"
        """
        self.map.has(value)

    @deprecated("Use 'has' instead of 'contains'")
    fn contains(value: T) -> bool:
        """Check if set contains element.

        Args:
            value: Element to check

        Returns:
            true if element exists

        Example:
            if set.contains("Alice"):
                print "Found!"
        """
        self.has(value)

    me remove(value: T) -> bool:
        """Remove element from set.

        Args:
            value: Element to remove

        Returns:
            true if element existed and was removed

        Example:
            if set.remove("Alice"):
                print "Removed"
        """
        match self.map.remove(value):
            Some(_): true
            nil: false

    me clear():
        """Remove all elements from set.

        Example:
            set.clear()
        """
        self.map.clear()

    fn to_list() -> List<T>:
        """Convert set to list.

        Returns:
            List of all elements

        Example:
            val items = set.to_list()
        """
        self.map.keys()

    fn for_each(action: fn(T)):
        """Execute action for each element.

        Args:
            action: Function to execute

        Example:
            set.for_each(\item: print item)
        """
        for item in self.to_list():
            action(item)

    fn union(other: Set<T>) -> Set<T>:
        """Create new set with elements from both sets.

        Args:
            other: Other set

        Returns:
            New set with union of elements

        Example:
            val combined = set1.union(set2)
        """
        val result = self.clone()
        for item in other.to_list():
            result.insert(item)
        result

    fn intersect(other: Set<T>) -> Set<T>:
        """Create new set with elements in both sets.

        Args:
            other: Other set

        Returns:
            New set with intersection of elements

        Example:
            val common = set1.intersect(set2)
        """
        val result = Set.new()
        for item in self.to_list():
            if other.has(item):
                result.insert(item)
        result

    @deprecated("Use 'intersect' instead of 'intersection'")
    fn intersection(other: Set<T>) -> Set<T>:
        """Create new set with elements in both sets.

        Args:
            other: Other set

        Returns:
            New set with intersection of elements

        Example:
            val common = set1.intersection(set2)
        """
        self.intersect(other)

    fn diff(other: Set<T>) -> Set<T>:
        """Create new set with elements in this set but not other.

        Args:
            other: Other set

        Returns:
            New set with difference

        Example:
            val unique = set1.diff(set2)
        """
        val result = Set.new()
        for item in self.to_list():
            if not other.has(item):
                result.insert(item)
        result

    @deprecated("Use 'diff' instead of 'difference'")
    fn difference(other: Set<T>) -> Set<T>:
        """Create new set with elements in this set but not other.

        Args:
            other: Other set

        Returns:
            New set with difference

        Example:
            val unique = set1.difference(set2)
        """
        self.diff(other)

    fn sym_diff(other: Set<T>) -> Set<T>:
        """Create new set with elements in either set but not both.

        Args:
            other: Other set

        Returns:
            New set with symmetric difference

        Example:
            val diff = set1.sym_diff(set2)
        """
        val result = Set.new()
        for item in self.to_list():
            if not other.has(item):
                result.insert(item)
        for item in other.to_list():
            if not self.has(item):
                result.insert(item)
        result

    @deprecated("Use 'sym_diff' instead of 'symmetric_difference'")
    fn symmetric_difference(other: Set<T>) -> Set<T>:
        """Create new set with elements in either set but not both.

        Args:
            other: Other set

        Returns:
            New set with symmetric difference

        Example:
            val diff = set1.symmetric_difference(set2)
        """
        self.sym_diff(other)

    fn is_subset(other: Set<T>) -> bool:
        """Check if this set is subset of other.

        Returns:
            true if all elements are in other set

        Example:
            if set1.is_subset(set2):
                print "set1 ⊆ set2"
        """
        for item in self.to_list():
            if not other.has(item):
                return false
        true

    fn is_superset(other: Set<T>) -> bool:
        """Check if this set is superset of other.

        Returns:
            true if other is subset of this

        Example:
            if set1.is_superset(set2):
                print "set1 ⊇ set2"
        """
        other.is_subset(self)

    fn is_disjoint(other: Set<T>) -> bool:
        """Check if sets have no common elements.

        Returns:
            true if no elements in common

        Example:
            if set1.is_disjoint(set2):
                print "No overlap"
        """
        for item in self.to_list():
            if other.has(item):
                return false
        true

    fn filter(predicate: fn(T) -> bool) -> Set<T>:
        """Create new set with elements matching predicate.

        Args:
            predicate: Function to test each element

        Returns:
            New set with filtered elements

        Example:
            val filtered = set.filter(\x: x > 10)
        """
        val result = Set.new()
        for item in self.to_list():
            if predicate(item):
                result.insert(item)
        result

    fn map<U>(mapper: fn(T) -> U) -> Set<U>:
        """Transform all elements.

        Args:
            mapper: Function to transform elements

        Returns:
            New set with transformed elements

        Example:
            val doubled = set.map(\x: x * 2)
        """
        val result = Set.new()
        for item in self.to_list():
            result.insert(mapper(item))
        result

    fn any(predicate: fn(T) -> bool) -> bool:
        """Check if any element matches predicate.

        Args:
            predicate: Function to test elements

        Returns:
            true if at least one element matches

        Example:
            if set.any(\x: x > 100):
                print "Has large value"
        """
        for item in self.to_list():
            if predicate(item):
                return true
        false

    fn all(predicate: fn(T) -> bool) -> bool:
        """Check if all elements match predicate.

        Args:
            predicate: Function to test elements

        Returns:
            true if all elements match

        Example:
            if set.all(\x: x > 0):
                print "All positive"
        """
        for item in self.to_list():
            if not predicate(item):
                return false
        true

    fn clone() -> Set<T>:
        """Create a shallow copy of the set.

        Returns:
            New set with same elements

        Example:
            val copy = set.clone()
        """
        # Clone the underlying map directly
        Set(map: self.map.clone())

    me extend(items: List<T>):
        """Add all items from list to set.

        Args:
            items: List of items to add

        Example:
            set.extend([1, 2, 3, 4, 5])
        """
        for item in items:
            self.insert(item)

# ============================================================================
# Helper Functions
# ============================================================================

pub fn set_from_list<T>(items: List<T>) -> Set<T>:
    """Create set from list of items.

    Args:
        items: List of items

    Returns:
        Set containing unique items

    Example:
        val set = set_from_list([1, 2, 2, 3, 3, 3])
        // set contains: {1, 2, 3}
    """
    val set = Set.with_capacity(items.len())
    for item in items:
        set.insert(item)
    set

pub fn intersect_all<T>(sets: List<Set<T>>) -> Set<T>:
    """Find intersection of multiple sets.

    Args:
        sets: List of sets

    Returns:
        Set with elements common to all sets

    Example:
        val common = intersect_all([set1, set2, set3])
    """
    if sets.len() == 0:
        return Set.new()

    var result = sets[0].clone()
    for i in 1..sets.len():
        result = result.intersect(sets[i])

    result

pub fn union_all<T>(sets: List<Set<T>>) -> Set<T>:
    """Find union of multiple sets.

    Args:
        sets: List of sets

    Returns:
        Set with all elements from all sets

    Example:
        val combined = union_all([set1, set2, set3])
    """
    val result = Set.new()
    for set in sets:
        for item in set.to_list():
            result.insert(item)
    result

# ============================================================================
# Export
# ============================================================================

export Set
export set_from_list
export intersect_all
export union_all
