# Godot Camera System
#
# Type-safe wrappers for Godot's camera system
#
# Features:
# - Camera2D (2D camera with follow, zoom, limits)
# - Camera3D (3D camera with projection modes)
# - Viewport (render target and camera management)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_camera2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.node3d

mod camera

# Camera2D
# 2D camera for viewport control
pub struct Camera2D extends godot.node2d.Node2D:

impl Camera2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera2D:
        return Camera2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set camera offset (screen center offset)
    pub fn set_offset(mut self, x: f64, y: f64):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # val offset_var = variant.Variant::from_vector2(x, y)
        # obj.call1("set_offset", offset_var)

    # Set zoom level (2.0 = 2x zoom)
    pub fn set_zoom(mut self, x: f64, y: f64):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # val zoom_var = variant.Variant::from_vector2(x, y)
        # obj.call1("set_zoom", zoom_var)

    # Set camera as current
    pub fn make_current(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("make_current")

    # Check if this is the current camera
    pub fn is_current(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_current")
        return result.as_bool()

    # Set position smoothing (for smooth follow)
    pub fn set_position_smoothing_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val smooth_var = variant.Variant::from_bool(enabled)
        obj.call1("set_position_smoothing_enabled", smooth_var)

    # Set smoothing speed
    pub fn set_position_smoothing_speed(mut self, speed: f64):
        val obj = self.base.as_node().as_object()
        val speed_var = variant.Variant::from_float(speed)
        obj.call1("set_position_smoothing_speed", speed_var)

    # Set rotation smoothing
    pub fn set_rotation_smoothing_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val smooth_var = variant.Variant::from_bool(enabled)
        obj.call1("set_rotation_smoothing_enabled", smooth_var)

    # Set rotation smoothing speed
    pub fn set_rotation_smoothing_speed(mut self, speed: f64):
        val obj = self.base.as_node().as_object()
        val speed_var = variant.Variant::from_float(speed)
        obj.call1("set_rotation_smoothing_speed", speed_var)

    # Set camera limits (min/max position)
    pub fn set_limit_left(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_right(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_top(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_bottom(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    # Set limit smoothing
    pub fn set_limit_smoothed(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val smooth_var = variant.Variant::from_bool(enabled)
        obj.call1("set_limit_smoothed", smooth_var)

    # Set drag margins (how far from edge before scrolling)
    pub fn set_drag_horizontal_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val drag_var = variant.Variant::from_bool(enabled)
        obj.call1("set_drag_horizontal_enabled", drag_var)

    pub fn set_drag_vertical_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val drag_var = variant.Variant::from_bool(enabled)
        obj.call1("set_drag_vertical_enabled", drag_var)

    pub fn set_drag_horizontal_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant::from_float(offset)
        obj.call1("set_drag_horizontal_offset", offset_var)

    pub fn set_drag_vertical_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant::from_float(offset)
        obj.call1("set_drag_vertical_offset", offset_var)

    # Set process callback (idle or physics)
    pub fn set_process_callback(mut self, mode: ProcessCallback):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_process_callback", mode_var)

    # Align camera to center
    pub fn align(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("align")

    # Reset smoothing (snap to target)
    pub fn reset_smoothing(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("reset_smoothing")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn activate(mut self):
        """Make this camera the current camera (alias for make_current).

        Example:
            camera.activate()
        """
        self.make_current()

    pub fn is_active(self) -> bool:
        """Check if this is the active camera (alias for is_current).

        Returns:
            true if current camera

        Example:
            camera.is_active()  # → true
        """
        return self.is_current()

    pub fn enable_smoothing(mut self):
        """Enable both position and rotation smoothing.

        Example:
            camera.enable_smoothing()
        """
        self.set_position_smoothing_enabled(true)
        self.set_rotation_smoothing_enabled(true)

    pub fn disable_smoothing(mut self):
        """Disable both position and rotation smoothing.

        Example:
            camera.disable_smoothing()
        """
        self.set_position_smoothing_enabled(false)
        self.set_rotation_smoothing_enabled(false)

    pub fn summary(self) -> String:
        """Get Camera2D summary.

        Returns:
            Human-readable summary

        Example:
            camera.summary()
            # → "Camera2D: current camera"
        """
        val status = if self.is_current() { "current camera" } else { "inactive" }
        return "Camera2D: {status}"


# Camera3D
# 3D camera with projection modes
pub struct Camera3D extends godot.node3d.Node3D:

impl Camera3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera3D:
        return Camera3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set camera as current
    pub fn make_current(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("make_current")

    # Check if this is the current camera
    pub fn is_current(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_current")
        return result.as_bool()

    # Set projection mode
    pub fn set_projection(mut self, mode: ProjectionMode):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_projection", mode_var)

    # Get projection mode
    pub fn get_projection(self) -> ProjectionMode:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_projection")
        val mode_int = result.as_int()
        if mode_int == 0:
            return ProjectionMode::Perspective
        else:
            return ProjectionMode::Orthogonal

    # Set field of view (in degrees, for perspective)
    pub fn set_fov(mut self, fov: f64):
        val obj = self.base.as_node().as_object()
        val fov_var = variant.Variant::from_float(fov)
        obj.call1("set_fov", fov_var)

    # Get field of view
    pub fn get_fov(self) -> f64:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_fov")
        return result.as_float()

    # Set orthogonal size (for orthogonal projection)
    pub fn set_size(mut self, size: f64):
        val obj = self.base.as_node().as_object()
        val size_var = variant.Variant::from_float(size)
        obj.call1("set_size", size_var)

    # Set near clip plane
    pub fn set_near(mut self, near: f64):
        val obj = self.base.as_node().as_object()
        val near_var = variant.Variant::from_float(near)
        obj.call1("set_near", near_var)

    # Set far clip plane
    pub fn set_far(mut self, far: f64):
        val obj = self.base.as_node().as_object()
        val far_var = variant.Variant::from_float(far)
        obj.call1("set_far", far_var)

    # Set H offset (horizontal offset for stereo/VR)
    pub fn set_h_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant::from_float(offset)
        obj.call1("set_h_offset", offset_var)

    # Set V offset (vertical offset)
    pub fn set_v_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant::from_float(offset)
        obj.call1("set_v_offset", offset_var)

    # Set keep aspect mode
    pub fn set_keep_aspect_mode(mut self, mode: KeepAspectMode):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_keep_aspect_mode", mode_var)

    # Set cull mask (layers to render)
    pub fn set_cull_mask(mut self, mask: u32):
        val obj = self.base.as_node().as_object()
        val mask_var = variant.Variant::from_int(mask as i64)
        obj.call1("set_cull_mask", mask_var)

    # Set environment
    pub fn set_environment(mut self, env: godot.resource.Resource):
        val obj = self.base.as_node().as_object()
        val env_var = variant.Variant::from_object(env.as_object())
        obj.call1("set_environment", env_var)

    # Project 3D position to 2D screen coordinates
    pub fn project_position(self, world_point_x: f64, world_point_y: f64, world_point_z: f64) -> (f64, f64):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector3 variant
        # val world_var = variant.Variant::from_vector3(world_point_x, world_point_y, world_point_z)
        # val result = obj.call1("project_position", world_var)
        # Parse Vector2 result
        return (0.0, 0.0)  # Placeholder

    # Project 2D screen coordinates to 3D ray
    pub fn project_ray_origin(self, screen_x: f64, screen_y: f64) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P2] Create Vector2 variant and parse Vector3
        return (0.0, 0.0, 0.0)  # Placeholder

    pub fn project_ray_normal(self, screen_x: f64, screen_y: f64) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P2] Create Vector2 variant and parse Vector3
        return (0.0, 0.0, 0.0)  # Placeholder

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn activate(mut self):
        """Make this camera the current camera (alias for make_current).

        Example:
            camera.activate()
        """
        self.make_current()

    pub fn is_active(self) -> bool:
        """Check if this is the active camera (alias for is_current).

        Returns:
            true if current camera

        Example:
            camera.is_active()  # → true
        """
        return self.is_current()

    pub fn is_perspective(self) -> bool:
        """Check if camera is in perspective mode.

        Returns:
            true if ProjectionMode::Perspective

        Example:
            camera.is_perspective()  # → true
        """
        return self.get_projection() == ProjectionMode::Perspective

    pub fn is_orthogonal(self) -> bool:
        """Check if camera is in orthogonal mode.

        Returns:
            true if ProjectionMode::Orthogonal

        Example:
            camera.is_orthogonal()  # → false
        """
        return self.get_projection() == ProjectionMode::Orthogonal

    pub fn use_perspective(mut self):
        """Switch to perspective projection.

        Example:
            camera.use_perspective()
        """
        self.set_projection(ProjectionMode::Perspective)

    pub fn use_orthogonal(mut self):
        """Switch to orthogonal projection.

        Example:
            camera.use_orthogonal()
        """
        self.set_projection(ProjectionMode::Orthogonal)

    pub fn summary(self) -> String:
        """Get Camera3D summary.

        Returns:
            Human-readable summary

        Example:
            camera.summary()
            # → "Camera3D: current, perspective, fov=70.0"
        """
        val status = if self.is_current() { "current" } else { "inactive" }
        val projection = if self.is_perspective() { "perspective" } else { "orthogonal" }
        val fov = self.get_fov()
        return "Camera3D: {status}, {projection}, fov={fov}"


# Viewport
# Render target and camera management
pub struct Viewport:
    ptr: ffi.GDExtensionObjectPtr

impl Viewport:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Viewport:
        return Viewport(ptr: ptr)

    # Get viewport size
    pub fn get_size(self) -> (i32, i32):
        val obj = variant.Object::from_ptr(self.ptr)
        val result = obj.call0("get_size")
        # TODO: [stdlib][P2] Parse Vector2i
        return (0, 0)  # Placeholder

    # Set viewport size
    pub fn set_size(mut self, width: i32, height: i32):
        val obj = variant.Object::from_ptr(self.ptr)
        # TODO: [stdlib][P3] Create Vector2i variant
        # val size_var = variant.Variant::from_vector2i(width, height)
        # obj.call1("set_size", size_var)

    # Get camera 2D
    pub fn get_camera_2d(self) -> Option[Camera2D]:
        val obj = variant.Object::from_ptr(self.ptr)
        val result = obj.call0("get_camera_2d")

        if result.is_null():
            return None
        else:
            return Some(Camera2D::from_ptr(result.as_object().ptr()))

    # Get camera 3D
    pub fn get_camera_3d(self) -> Option[Camera3D]:
        val obj = variant.Object::from_ptr(self.ptr)
        val result = obj.call0("get_camera_3d")

        if result.is_null():
            return None
        else:
            return Some(Camera3D::from_ptr(result.as_object().ptr()))

    # Set MSAA (anti-aliasing)
    pub fn set_msaa_3d(mut self, msaa: MSAA):
        val obj = variant.Object::from_ptr(self.ptr)
        val msaa_var = variant.Variant::from_int(msaa as i64)
        obj.call1("set_msaa_3d", msaa_var)

    # Set screen space AA
    pub fn set_screen_space_aa(mut self, aa: ScreenSpaceAA):
        val obj = variant.Object::from_ptr(self.ptr)
        val aa_var = variant.Variant::from_int(aa as i64)
        obj.call1("set_screen_space_aa", aa_var)

    # Set HDR
    pub fn set_use_hdr_2d(mut self, enabled: bool):
        val obj = variant.Object::from_ptr(self.ptr)
        val hdr_var = variant.Variant::from_bool(enabled)
        obj.call1("set_use_hdr_2d", hdr_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_camera_2d(self) -> bool:
        """Check if viewport has a 2D camera.

        Returns:
            true if camera exists

        Example:
            viewport.has_camera_2d()  # → true
        """
        return self.get_camera_2d().is_some()

    pub fn has_camera_3d(self) -> bool:
        """Check if viewport has a 3D camera.

        Returns:
            true if camera exists

        Example:
            viewport.has_camera_3d()  # → false
        """
        return self.get_camera_3d().is_some()

    pub fn has_camera(self) -> bool:
        """Check if viewport has any camera (2D or 3D).

        Returns:
            true if any camera exists

        Example:
            viewport.has_camera()  # → true
        """
        return self.has_camera_2d() or self.has_camera_3d()

    pub fn enable_hdr(mut self):
        """Enable HDR rendering.

        Example:
            viewport.enable_hdr()
        """
        self.set_use_hdr_2d(true)

    pub fn disable_hdr(mut self):
        """Disable HDR rendering.

        Example:
            viewport.disable_hdr()
        """
        self.set_use_hdr_2d(false)

    pub fn summary(self) -> String:
        """Get viewport summary.

        Returns:
            Human-readable summary

        Example:
            viewport.summary()
            # → "Viewport: has 2D camera"
        """
        if self.has_camera_2d():
            return "Viewport: has 2D camera"
        elif self.has_camera_3d():
            return "Viewport: has 3D camera"
        else:
            return "Viewport: no camera"


# Enums

pub enum ProcessCallback:
    Idle = 0       # Update during _process
    Physics = 1    # Update during _physics_process

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_idle(self) -> bool:
        """Check if callback is during idle.

        Returns:
            true if Idle variant

        Example:
            callback.is_idle()  # → true
        """
        match self:
            case Idle: return true
            case _: return false

    pub fn is_physics(self) -> bool:
        """Check if callback is during physics.

        Returns:
            true if Physics variant

        Example:
            callback.is_physics()  # → false
        """
        match self:
            case Physics: return true
            case _: return false

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            String representation

        Example:
            callback.to_string()  # → "Idle"
        """
        match self:
            case Idle: return "Idle"
            case Physics: return "Physics"

    fn description() -> String:
        """Get process callback description.

        Returns:
            Human-readable description

        Example:
            ProcessCallback::Idle.description()
            # → "Update during idle frame (_process)"
        """
        match self:
            case Idle: return "Update during idle frame (_process)"
            case Physics: return "Update during physics frame (_physics_process)"

    pub fn summary(self) -> String:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            callback.summary()
            # → "ProcessCallback: Idle"
        """
        val name = self.to_string()
        return "ProcessCallback: {name}"

pub enum ProjectionMode:
    Perspective = 0    # Perspective projection (3D)
    Orthogonal = 1     # Orthogonal projection (2D-like)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_perspective(self) -> bool:
        """Check if projection is perspective.

        Returns:
            true if Perspective variant

        Example:
            mode.is_perspective()  # → true
        """
        match self:
            case Perspective: return true
            case _: return false

    pub fn is_orthogonal(self) -> bool:
        """Check if projection is orthogonal.

        Returns:
            true if Orthogonal variant

        Example:
            mode.is_orthogonal()  # → false
        """
        match self:
            case Orthogonal: return true
            case _: return false

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            String representation

        Example:
            mode.to_string()  # → "Perspective"
        """
        match self:
            case Perspective: return "Perspective"
            case Orthogonal: return "Orthogonal"

    fn description() -> String:
        """Get projection mode description.

        Returns:
            Human-readable description

        Example:
            ProjectionMode::Perspective.description()
            # → "Perspective projection (3D depth perception)"
        """
        match self:
            case Perspective: return "Perspective projection (3D depth perception)"
            case Orthogonal: return "Orthogonal projection (2D-like, no depth distortion)"

    pub fn summary(self) -> String:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            mode.summary()
            # → "ProjectionMode: Perspective"
        """
        val name = self.to_string()
        return "ProjectionMode: {name}"

pub enum KeepAspectMode:
    Keep = 0       # Keep aspect ratio
    Cover = 1      # Cover viewport (crop if needed)
    Disabled = 2   # Stretch to fill

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_keep(self) -> bool:
        """Check if keeping aspect ratio.

        Returns:
            true if Keep variant

        Example:
            mode.is_keep()  # → true
        """
        match self:
            case Keep: return true
            case _: return false

    pub fn is_cover(self) -> bool:
        """Check if covering viewport.

        Returns:
            true if Cover variant

        Example:
            mode.is_cover()  # → false
        """
        match self:
            case Cover: return true
            case _: return false

    pub fn is_disabled(self) -> bool:
        """Check if aspect ratio is disabled (stretch).

        Returns:
            true if Disabled variant

        Example:
            mode.is_disabled()  # → false
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn preserves_aspect(self) -> bool:
        """Check if aspect ratio is preserved.

        Returns:
            true if Keep or Cover

        Example:
            mode.preserves_aspect()  # → true
        """
        match self:
            case Keep | Cover: return true
            case _: return false

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            String representation

        Example:
            mode.to_string()  # → "Keep"
        """
        match self:
            case Keep: return "Keep"
            case Cover: return "Cover"
            case Disabled: return "Disabled"

    fn description() -> String:
        """Get keep aspect mode description.

        Returns:
            Human-readable description

        Example:
            KeepAspectMode::Keep.description()
            # → "Keep aspect ratio (add black bars if needed)"
        """
        match self:
            case Keep: return "Keep aspect ratio (add black bars if needed)"
            case Cover: return "Cover viewport (crop content to fill, preserve aspect)"
            case Disabled: return "Stretch to fill viewport (distort aspect ratio)"

    pub fn summary(self) -> String:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            mode.summary()
            # → "KeepAspectMode: Keep"
        """
        val name = self.to_string()
        return "KeepAspectMode: {name}"

pub enum MSAA:
    Disabled = 0   # No MSAA
    X2 = 1         # 2x MSAA
    X4 = 2         # 4x MSAA
    X8 = 3         # 8x MSAA

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_disabled(self) -> bool:
        """Check if MSAA is disabled.

        Returns:
            true if Disabled variant

        Example:
            msaa.is_disabled()  # → false
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn is_enabled(self) -> bool:
        """Check if MSAA is enabled.

        Returns:
            true if not Disabled

        Example:
            msaa.is_enabled()  # → true
        """
        return not self.is_disabled()

    pub fn get_sample_count(self) -> i32:
        """Get MSAA sample count.

        Returns:
            Sample count (0, 2, 4, or 8)

        Example:
            msaa.get_sample_count()  # → 4
        """
        match self:
            case Disabled: return 0
            case X2: return 2
            case X4: return 4
            case X8: return 8

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            String representation

        Example:
            msaa.to_string()  # → "X4"
        """
        match self:
            case Disabled: return "Disabled"
            case X2: return "X2"
            case X4: return "X4"
            case X8: return "X8"

    fn description() -> String:
        """Get MSAA description.

        Returns:
            Human-readable description

        Example:
            MSAA::X4.description()
            # → "4x Multi-Sample Anti-Aliasing (4 samples per pixel)"
        """
        match self:
            case Disabled: return "No anti-aliasing (best performance)"
            case X2: return "2x Multi-Sample Anti-Aliasing (2 samples per pixel)"
            case X4: return "4x Multi-Sample Anti-Aliasing (4 samples per pixel)"
            case X8: return "8x Multi-Sample Anti-Aliasing (8 samples per pixel)"

    pub fn summary(self) -> String:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            msaa.summary()
            # → "MSAA: X4 (4 samples)"
        """
        val name = self.to_string()
        val samples = self.get_sample_count()
        return "MSAA: {name} ({samples} samples)"

pub enum ScreenSpaceAA:
    Disabled = 0   # No AA
    FXAA = 1       # Fast Approximate Anti-Aliasing

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_disabled(self) -> bool:
        """Check if screen space AA is disabled.

        Returns:
            true if Disabled variant

        Example:
            aa.is_disabled()  # → false
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn is_fxaa(self) -> bool:
        """Check if using FXAA.

        Returns:
            true if FXAA variant

        Example:
            aa.is_fxaa()  # → true
        """
        match self:
            case FXAA: return true
            case _: return false

    pub fn is_enabled(self) -> bool:
        """Check if screen space AA is enabled.

        Returns:
            true if not Disabled

        Example:
            aa.is_enabled()  # → true
        """
        return not self.is_disabled()

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            String representation

        Example:
            aa.to_string()  # → "FXAA"
        """
        match self:
            case Disabled: return "Disabled"
            case FXAA: return "FXAA"

    fn description() -> String:
        """Get screen space AA description.

        Returns:
            Human-readable description

        Example:
            ScreenSpaceAA::FXAA.description()
            # → "Fast Approximate Anti-Aliasing (post-process, cheaper than MSAA)"
        """
        match self:
            case Disabled: return "No screen-space anti-aliasing"
            case FXAA: return "Fast Approximate Anti-Aliasing (post-process, cheaper than MSAA)"

    pub fn summary(self) -> String:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            aa.summary()
            # → "ScreenSpaceAA: FXAA"
        """
        val name = self.to_string()
        return "ScreenSpaceAA: {name}"


# Camera utilities

# Create a basic 2D camera with common settings
pub fn create_2d_camera(smooth: bool = true, zoom: f64 = 1.0) -> Camera2D:
    val ptr = ffi.godot_new_object("Camera2D")
    var cam = Camera2D::from_ptr(ptr)

    if smooth:
        cam.set_position_smoothing_enabled(true)
        cam.set_position_smoothing_speed(5.0)

    cam.set_zoom(zoom, zoom)
    cam.make_current()

    return cam

# Create a basic 3D camera with common settings
pub fn create_3d_camera(fov: f64 = 75.0, near: f64 = 0.1, far: f64 = 1000.0) -> Camera3D:
    val ptr = ffi.godot_new_object("Camera3D")
    var cam = Camera3D::from_ptr(ptr)

    cam.set_projection(ProjectionMode::Perspective)
    cam.set_fov(fov)
    cam.set_near(near)
    cam.set_far(far)
    cam.make_current()

    return cam

# Create an orthogonal 3D camera (for 2.5D games)
pub fn create_orthogonal_camera(size: f64 = 10.0) -> Camera3D:
    val ptr = ffi.godot_new_object("Camera3D")
    var cam = Camera3D::from_ptr(ptr)

    cam.set_projection(ProjectionMode::Orthogonal)
    cam.set_size(size)
    cam.make_current()

    return cam
