# Godot Camera System
#
# Type-safe wrappers for Godot's camera system
#
# Features:
# - Camera2D (2D camera with follow, zoom, limits)
# - Camera3D (3D camera with projection modes)
# - Viewport (render target and camera management)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_camera2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.node3d

mod camera

# Camera2D
# 2D camera for viewport control
pub struct Camera2D extends godot.node2d.Node2D:

impl Camera2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera2D:
        return Camera2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set camera offset (screen center offset)
    pub fn set_offset(mut self, x: f64, y: f64):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # let offset_var = variant.Variant::from_vector2(x, y)
        # obj.call1("set_offset", offset_var)

    # Set zoom level (2.0 = 2x zoom)
    pub fn set_zoom(mut self, x: f64, y: f64):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # let zoom_var = variant.Variant::from_vector2(x, y)
        # obj.call1("set_zoom", zoom_var)

    # Set camera as current
    pub fn make_current(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("make_current")

    # Check if this is the current camera
    pub fn is_current(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_current")
        return result.as_bool()

    # Set position smoothing (for smooth follow)
    pub fn set_position_smoothing_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let smooth_var = variant.Variant::from_bool(enabled)
        obj.call1("set_position_smoothing_enabled", smooth_var)

    # Set smoothing speed
    pub fn set_position_smoothing_speed(mut self, speed: f64):
        let obj = self.base.as_node().as_object()
        let speed_var = variant.Variant::from_float(speed)
        obj.call1("set_position_smoothing_speed", speed_var)

    # Set rotation smoothing
    pub fn set_rotation_smoothing_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let smooth_var = variant.Variant::from_bool(enabled)
        obj.call1("set_rotation_smoothing_enabled", smooth_var)

    # Set rotation smoothing speed
    pub fn set_rotation_smoothing_speed(mut self, speed: f64):
        let obj = self.base.as_node().as_object()
        let speed_var = variant.Variant::from_float(speed)
        obj.call1("set_rotation_smoothing_speed", speed_var)

    # Set camera limits (min/max position)
    pub fn set_limit_left(mut self, limit: i32):
        let obj = self.base.as_node().as_object()
        let limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_right(mut self, limit: i32):
        let obj = self.base.as_node().as_object()
        let limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_top(mut self, limit: i32):
        let obj = self.base.as_node().as_object()
        let limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_bottom(mut self, limit: i32):
        let obj = self.base.as_node().as_object()
        let limit_var = variant.Variant::from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    # Set limit smoothing
    pub fn set_limit_smoothed(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let smooth_var = variant.Variant::from_bool(enabled)
        obj.call1("set_limit_smoothed", smooth_var)

    # Set drag margins (how far from edge before scrolling)
    pub fn set_drag_horizontal_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let drag_var = variant.Variant::from_bool(enabled)
        obj.call1("set_drag_horizontal_enabled", drag_var)

    pub fn set_drag_vertical_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let drag_var = variant.Variant::from_bool(enabled)
        obj.call1("set_drag_vertical_enabled", drag_var)

    pub fn set_drag_horizontal_offset(mut self, offset: f64):
        let obj = self.base.as_node().as_object()
        let offset_var = variant.Variant::from_float(offset)
        obj.call1("set_drag_horizontal_offset", offset_var)

    pub fn set_drag_vertical_offset(mut self, offset: f64):
        let obj = self.base.as_node().as_object()
        let offset_var = variant.Variant::from_float(offset)
        obj.call1("set_drag_vertical_offset", offset_var)

    # Set process callback (idle or physics)
    pub fn set_process_callback(mut self, mode: ProcessCallback):
        let obj = self.base.as_node().as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_process_callback", mode_var)

    # Align camera to center
    pub fn align(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("align")

    # Reset smoothing (snap to target)
    pub fn reset_smoothing(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("reset_smoothing")


# Camera3D
# 3D camera with projection modes
pub struct Camera3D extends godot.node3d.Node3D:

impl Camera3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera3D:
        return Camera3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set camera as current
    pub fn make_current(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("make_current")

    # Check if this is the current camera
    pub fn is_current(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_current")
        return result.as_bool()

    # Set projection mode
    pub fn set_projection(mut self, mode: ProjectionMode):
        let obj = self.base.as_node().as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_projection", mode_var)

    # Get projection mode
    pub fn get_projection(self) -> ProjectionMode:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_projection")
        let mode_int = result.as_int()
        if mode_int == 0:
            return ProjectionMode::Perspective
        else:
            return ProjectionMode::Orthogonal

    # Set field of view (in degrees, for perspective)
    pub fn set_fov(mut self, fov: f64):
        let obj = self.base.as_node().as_object()
        let fov_var = variant.Variant::from_float(fov)
        obj.call1("set_fov", fov_var)

    # Get field of view
    pub fn get_fov(self) -> f64:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_fov")
        return result.as_float()

    # Set orthogonal size (for orthogonal projection)
    pub fn set_size(mut self, size: f64):
        let obj = self.base.as_node().as_object()
        let size_var = variant.Variant::from_float(size)
        obj.call1("set_size", size_var)

    # Set near clip plane
    pub fn set_near(mut self, near: f64):
        let obj = self.base.as_node().as_object()
        let near_var = variant.Variant::from_float(near)
        obj.call1("set_near", near_var)

    # Set far clip plane
    pub fn set_far(mut self, far: f64):
        let obj = self.base.as_node().as_object()
        let far_var = variant.Variant::from_float(far)
        obj.call1("set_far", far_var)

    # Set H offset (horizontal offset for stereo/VR)
    pub fn set_h_offset(mut self, offset: f64):
        let obj = self.base.as_node().as_object()
        let offset_var = variant.Variant::from_float(offset)
        obj.call1("set_h_offset", offset_var)

    # Set V offset (vertical offset)
    pub fn set_v_offset(mut self, offset: f64):
        let obj = self.base.as_node().as_object()
        let offset_var = variant.Variant::from_float(offset)
        obj.call1("set_v_offset", offset_var)

    # Set keep aspect mode
    pub fn set_keep_aspect_mode(mut self, mode: KeepAspectMode):
        let obj = self.base.as_node().as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_keep_aspect_mode", mode_var)

    # Set cull mask (layers to render)
    pub fn set_cull_mask(mut self, mask: u32):
        let obj = self.base.as_node().as_object()
        let mask_var = variant.Variant::from_int(mask as i64)
        obj.call1("set_cull_mask", mask_var)

    # Set environment
    pub fn set_environment(mut self, env: godot.resource.Resource):
        let obj = self.base.as_node().as_object()
        let env_var = variant.Variant::from_object(env.as_object())
        obj.call1("set_environment", env_var)

    # Project 3D position to 2D screen coordinates
    pub fn project_position(self, world_point_x: f64, world_point_y: f64, world_point_z: f64) -> (f64, f64):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector3 variant
        # let world_var = variant.Variant::from_vector3(world_point_x, world_point_y, world_point_z)
        # let result = obj.call1("project_position", world_var)
        # Parse Vector2 result
        return (0.0, 0.0)  # Placeholder

    # Project 2D screen coordinates to 3D ray
    pub fn project_ray_origin(self, screen_x: f64, screen_y: f64) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P2] Create Vector2 variant and parse Vector3
        return (0.0, 0.0, 0.0)  # Placeholder

    pub fn project_ray_normal(self, screen_x: f64, screen_y: f64) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P2] Create Vector2 variant and parse Vector3
        return (0.0, 0.0, 0.0)  # Placeholder


# Viewport
# Render target and camera management
pub struct Viewport:
    ptr: ffi.GDExtensionObjectPtr

impl Viewport:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Viewport:
        return Viewport(ptr: ptr)

    # Get viewport size
    pub fn get_size(self) -> (i32, i32):
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_size")
        # TODO: [stdlib][P2] Parse Vector2i
        return (0, 0)  # Placeholder

    # Set viewport size
    pub fn set_size(mut self, width: i32, height: i32):
        let obj = variant.Object::from_ptr(self.ptr)
        # TODO: [stdlib][P3] Create Vector2i variant
        # let size_var = variant.Variant::from_vector2i(width, height)
        # obj.call1("set_size", size_var)

    # Get camera 2D
    pub fn get_camera_2d(self) -> Option[Camera2D]:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_camera_2d")

        if result.is_null():
            return None
        else:
            return Some(Camera2D::from_ptr(result.as_object().ptr()))

    # Get camera 3D
    pub fn get_camera_3d(self) -> Option[Camera3D]:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_camera_3d")

        if result.is_null():
            return None
        else:
            return Some(Camera3D::from_ptr(result.as_object().ptr()))

    # Set MSAA (anti-aliasing)
    pub fn set_msaa_3d(mut self, msaa: MSAA):
        let obj = variant.Object::from_ptr(self.ptr)
        let msaa_var = variant.Variant::from_int(msaa as i64)
        obj.call1("set_msaa_3d", msaa_var)

    # Set screen space AA
    pub fn set_screen_space_aa(mut self, aa: ScreenSpaceAA):
        let obj = variant.Object::from_ptr(self.ptr)
        let aa_var = variant.Variant::from_int(aa as i64)
        obj.call1("set_screen_space_aa", aa_var)

    # Set HDR
    pub fn set_use_hdr_2d(mut self, enabled: bool):
        let obj = variant.Object::from_ptr(self.ptr)
        let hdr_var = variant.Variant::from_bool(enabled)
        obj.call1("set_use_hdr_2d", hdr_var)


# Enums

pub enum ProcessCallback:
    Idle = 0       # Update during _process
    Physics = 1    # Update during _physics_process

pub enum ProjectionMode:
    Perspective = 0    # Perspective projection (3D)
    Orthogonal = 1     # Orthogonal projection (2D-like)

pub enum KeepAspectMode:
    Keep = 0       # Keep aspect ratio
    Cover = 1      # Cover viewport (crop if needed)
    Disabled = 2   # Stretch to fill

pub enum MSAA:
    Disabled = 0   # No MSAA
    X2 = 1         # 2x MSAA
    X4 = 2         # 4x MSAA
    X8 = 3         # 8x MSAA

pub enum ScreenSpaceAA:
    Disabled = 0   # No AA
    FXAA = 1       # Fast Approximate Anti-Aliasing


# Camera utilities

# Create a basic 2D camera with common settings
pub fn create_2d_camera(smooth: bool = true, zoom: f64 = 1.0) -> Camera2D:
    let ptr = ffi.godot_new_object("Camera2D")
    let mut cam = Camera2D::from_ptr(ptr)

    if smooth:
        cam.set_position_smoothing_enabled(true)
        cam.set_position_smoothing_speed(5.0)

    cam.set_zoom(zoom, zoom)
    cam.make_current()

    return cam

# Create a basic 3D camera with common settings
pub fn create_3d_camera(fov: f64 = 75.0, near: f64 = 0.1, far: f64 = 1000.0) -> Camera3D:
    let ptr = ffi.godot_new_object("Camera3D")
    let mut cam = Camera3D::from_ptr(ptr)

    cam.set_projection(ProjectionMode::Perspective)
    cam.set_fov(fov)
    cam.set_near(near)
    cam.set_far(far)
    cam.make_current()

    return cam

# Create an orthogonal 3D camera (for 2.5D games)
pub fn create_orthogonal_camera(size: f64 = 10.0) -> Camera3D:
    let ptr = ffi.godot_new_object("Camera3D")
    let mut cam = Camera3D::from_ptr(ptr)

    cam.set_projection(ProjectionMode::Orthogonal)
    cam.set_size(size)
    cam.make_current()

    return cam
