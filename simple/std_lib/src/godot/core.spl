# Godot Core - GDExtension FFI Core
#
# Provides the foundational GDExtension interface for Simple-Godot integration.
# Handles initialization, registration, and core GDExtension API bindings.
#
# Based on: Godot 4.3+ GDExtension API

use core.*

# =============================================================================
# GDExtensionInterface - Core GDExtension function table
# =============================================================================

pub struct GDExtensionInterface:
    get_godot_version: fn() -> GodotVersion
    mem_alloc: fn(size: u64) -> *u8
    mem_realloc: fn(ptr: *u8, size: u64) -> *u8
    mem_free: fn(ptr: *u8)
    print_error: fn(description: *u8, function: *u8, file: *u8, line: i32)
    print_warning: fn(description: *u8, function: *u8, file: *u8, line: i32)
    print_script_error: fn(description: *u8, function: *u8, file: *u8, line: i32)

impl GDExtensionInterface:
    # Initialize from Godot's function table
    pub fn from_godot_interface(interface_ptr: *GDExtensionInterface) -> GDExtensionInterface:
        # In real implementation, would populate from Godot's interface
        # For now, return placeholder
        return unsafe {
            *interface_ptr
        }

# =============================================================================
# GodotVersion - Version information
# =============================================================================

pub struct GodotVersion:
    major: u32
    minor: u32
    patch: u32
    string: String

impl GodotVersion:
    pub fn new(major: u32, minor: u32, patch: u32) -> GodotVersion:
        val version_string = major.to_string() + "." +
                           minor.to_string() + "." +
                           patch.to_string()
        return GodotVersion {
            major: major,
            minor: minor,
            patch: patch,
            string: version_string
        }

    pub fn to_string(self) -> String:
        return self.string

    pub fn is_compatible_with(self, required_major: u32, required_minor: u32) -> bool:
        if self.major != required_major:
            return false
        return self.minor >= required_minor

# =============================================================================
# GDExtensionClassLibraryPtr - Opaque pointer to Godot library
# =============================================================================

pub struct GDExtensionClassLibraryPtr:
    ptr: *u8

impl GDExtensionClassLibraryPtr:
    pub fn new(ptr: *u8) -> GDExtensionClassLibraryPtr:
        return GDExtensionClassLibraryPtr { ptr: ptr }

    pub fn is_null(self) -> bool:
        return self.ptr == null

# =============================================================================
# GDExtensionInitialization - Initialization configuration
# =============================================================================

pub struct GDExtensionInitialization:
    minimum_initialization_level: InitializationLevel
    initialize: fn(library: GDExtensionClassLibraryPtr, level: InitializationLevel)
    deinitialize: fn(library: GDExtensionClassLibraryPtr, level: InitializationLevel)

pub enum InitializationLevel:
    Core
    Servers
    Scene
    Editor

impl InitializationLevel:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert initialization level to string.

        Returns:
            Level name

        Example:
            InitializationLevel::Scene.to_string()  # → "scene"
        """
        match self:
            case Core: "core"
            case Servers: "servers"
            case Scene: "scene"
            case Editor: "editor"

    pub fn description(self) -> String:
        """Get initialization level description.

        Returns:
            Human-readable description

        Example:
            InitializationLevel::Scene.description()
            # → "Scene tree and node initialization"
        """
        match self:
            case Core: "Core engine initialization"
            case Servers: "Server systems initialization"
            case Scene: "Scene tree and node initialization"
            case Editor: "Editor-specific initialization"

    pub fn is_core(self) -> bool:
        """Check if level is Core."""
        match self:
            case Core: true
            case _: false

    pub fn is_servers(self) -> bool:
        """Check if level is Servers."""
        match self:
            case Servers: true
            case _: false

    pub fn is_scene(self) -> bool:
        """Check if level is Scene."""
        match self:
            case Scene: true
            case _: false

    pub fn is_editor(self) -> bool:
        """Check if level is Editor."""
        match self:
            case Editor: true
            case _: false

    pub fn is_runtime(self) -> bool:
        """Check if level is runtime (not editor).

        Returns:
            true for Core, Servers, or Scene

        Example:
            InitializationLevel::Scene.is_runtime()  # → true
            InitializationLevel::Editor.is_runtime()  # → false
        """
        match self:
            case Editor: false
            case _: true

    pub fn order(self) -> i32:
        """Get initialization order.

        Returns:
            Order value (lower = earlier)

        Example:
            InitializationLevel::Core.order()  # → 0
        """
        match self:
            case Core: 0
            case Servers: 1
            case Scene: 2
            case Editor: 3

    pub fn summary(self) -> String:
        """Get initialization level summary.

        Returns:
            Human-readable summary

        Example:
            InitializationLevel::Scene.summary()
            # → "InitializationLevel: scene (Scene tree and node initialization, runtime, order=2)"
        """
        val name = self.to_string()
        val desc = self.description()
        val order = self.order()
        val runtime = if self.is_runtime(): "runtime" else: "editor-only"
        return "InitializationLevel: {name} ({desc}, {runtime}, order={order})"

impl GDExtensionInitialization:
    pub fn new(
        level: InitializationLevel,
        init_fn: fn(GDExtensionClassLibraryPtr, InitializationLevel),
        deinit_fn: fn(GDExtensionClassLibraryPtr, InitializationLevel)
    ) -> GDExtensionInitialization:
        return GDExtensionInitialization {
            minimum_initialization_level: level,
            initialize: init_fn,
            deinitialize: deinit_fn
        }

# =============================================================================
# GDExtension Entry Point
# =============================================================================

# This is the main entry point called by Godot when loading the extension
#[export(name = "gdextension_init")]
pub fn gdextension_init(
    interface: *GDExtensionInterface,
    library: GDExtensionClassLibraryPtr,
    initialization: *GDExtensionInitialization
) -> bool:
    # Initialize the GDExtension interface
    val gd_interface = GDExtensionInterface::from_godot_interface(interface)

    # Check Godot version compatibility
    val version = gd_interface.get_godot_version()
    if not version.is_compatible_with(4, 3):
        gd_interface.print_error(
            "Simple-Godot requires Godot 4.3 or later".as_ptr(),
            "gdextension_init".as_ptr(),
            "core.spl".as_ptr(),
            0
        )
        return false

    # Set up initialization callbacks
    unsafe {
        (*initialization).minimum_initialization_level = InitializationLevel::Scene
        (*initialization).initialize = initialize_simple_godot
        (*initialization).deinitialize = deinitialize_simple_godot
    }

    return true

# =============================================================================
# Initialization Callbacks
# =============================================================================

fn initialize_simple_godot(
    library: GDExtensionClassLibraryPtr,
    level: InitializationLevel
):
    match level:
        case InitializationLevel::Scene:
            # Register Simple-based node classes
            register_simple_classes(library)
        case _:
            pass

fn deinitialize_simple_godot(
    library: GDExtensionClassLibraryPtr,
    level: InitializationLevel
):
    match level:
        case InitializationLevel::Scene:
            # Cleanup
            cleanup_simple_classes(library)
        case _:
            pass

fn register_simple_classes(library: GDExtensionClassLibraryPtr):
    # Register custom classes here
    # This will be populated as we add more node types
    io.println("Simple-Godot: Registering classes...")

fn cleanup_simple_classes(library: GDExtensionClassLibraryPtr):
    # Cleanup resources
    io.println("Simple-Godot: Cleaning up...")

# =============================================================================
# FFI Helper Functions
# =============================================================================

# Godot string conversion
pub fn string_to_godot(s: String) -> *u8:
    # In real implementation, would convert to Godot's String format
    return s.as_ptr()

pub fn string_from_godot(ptr: *u8) -> String:
    # In real implementation, would convert from Godot's String format
    return unsafe { String::from_c_str(ptr) }

# Memory management using Godot's allocator
pub fn godot_alloc(size: u64) -> *u8:
    # Would use GDExtensionInterface.mem_alloc
    return extern_godot_alloc(size)

pub fn godot_free(ptr: *u8):
    # Would use GDExtensionInterface.mem_free
    extern_godot_free(ptr)

# =============================================================================
# External FFI Functions (to be implemented in Rust runtime)
# =============================================================================

extern fn extern_godot_alloc(size: u64) -> *u8
extern fn extern_godot_free(ptr: *u8)
