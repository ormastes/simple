# Godot Animation System
#
# Type-safe wrappers for Godot's animation system
#
# Features:
# - AnimationPlayer (timeline-based animations)
# - AnimationTree (state machines and blending)
# - Animation resources
# - Track management (property, transform, method calls)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_animationplayer.html

import godot.ffi
import godot.variant
import godot.node
import godot.resource

mod animation

# Animation Resource
# Represents a single animation with tracks
pub struct Animation:
    resource: resource.Resource

impl Animation:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> Animation:
        return Animation(resource: res)

    # Create new empty animation
    pub fn new() -> Animation:
        let obj_ptr = ffi.godot_new_object("Animation")
        let res = resource.Resource::from_ptr(obj_ptr)
        return Animation::from_resource(res)

    # Get animation length in seconds
    pub fn get_length(self) -> f64:
        let obj = self.resource.as_object()
        let result = obj.call0("get_length")
        return result.as_float()

    # Set animation length
    pub fn set_length(mut self, time_sec: f64):
        let obj = self.resource.as_object()
        let time_var = variant.Variant::from_float(time_sec)
        obj.call1("set_length", time_var)

    # Get loop mode
    pub fn get_loop_mode(self) -> LoopMode:
        let obj = self.resource.as_object()
        let result = obj.call0("get_loop_mode")
        let mode_int = result.as_int()
        return loop_mode_from_int(mode_int as i32)

    # Set loop mode
    pub fn set_loop_mode(mut self, mode: LoopMode):
        let obj = self.resource.as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_loop_mode", mode_var)

    # Get number of tracks
    pub fn get_track_count(self) -> i32:
        let obj = self.resource.as_object()
        let result = obj.call0("get_track_count")
        return result.as_int() as i32

    # Add a property track (animate node properties)
    pub fn add_track(mut self, track_type: TrackType) -> i32:
        let obj = self.resource.as_object()
        let type_var = variant.Variant::from_int(track_type as i64)
        let result = obj.call1("add_track", type_var)
        return result.as_int() as i32

    # Remove a track
    pub fn remove_track(mut self, track_idx: i32):
        let obj = self.resource.as_object()
        let idx_var = variant.Variant::from_int(track_idx as i64)
        obj.call1("remove_track", idx_var)

    # Set track path (which node/property to animate)
    pub fn track_set_path(mut self, track_idx: i32, path: String):
        let obj = self.resource.as_object()
        let idx_var = variant.Variant::from_int(track_idx as i64)
        let path_var = variant.Variant::from_string(path)
        obj.call2("track_set_path", idx_var, path_var)

    # Insert a keyframe
    pub fn track_insert_key(mut self, track_idx: i32, time: f64, value: variant.Variant):
        let obj = self.resource.as_object()
        let idx_var = variant.Variant::from_int(track_idx as i64)
        let time_var = variant.Variant::from_float(time)
        obj.call3("track_insert_key", idx_var, time_var, value)


# Animation Player
# Controls playback of animations
pub struct AnimationPlayer extends godot.node.Node:
    # Overrides base to extend Node

impl AnimationPlayer:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AnimationPlayer:
        return AnimationPlayer(base: godot.node.Node::from_ptr(ptr))

    # Play an animation
    pub fn play(mut self, name: String = "", custom_blend: f64 = -1.0, custom_speed: f32 = 1.0, from_end: bool = false):
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        let blend_var = variant.Variant::from_float(custom_blend)
        let speed_var = variant.Variant::from_float(custom_speed as f64)
        let end_var = variant.Variant::from_bool(from_end)
        obj.call4("play", name_var, blend_var, speed_var, end_var)

    # Stop animation
    pub fn stop(mut self, keep_state: bool = false):
        let obj = self.base.as_object()
        let keep_var = variant.Variant::from_bool(keep_state)
        obj.call1("stop", keep_var)

    # Check if playing
    pub fn is_playing(self) -> bool:
        let obj = self.base.as_object()
        let result = obj.call0("is_playing")
        return result.as_bool()

    # Get current animation name
    pub fn get_current_animation(self) -> String:
        let obj = self.base.as_object()
        let result = obj.call0("get_current_animation")
        return result.as_string()

    # Set current animation position
    pub fn seek(mut self, seconds: f64, update: bool = false):
        let obj = self.base.as_object()
        let sec_var = variant.Variant::from_float(seconds)
        let update_var = variant.Variant::from_bool(update)
        obj.call2("seek", sec_var, update_var)

    # Get current position
    pub fn get_current_animation_position(self) -> f64:
        let obj = self.base.as_object()
        let result = obj.call0("get_current_animation_position")
        return result.as_float()

    # Get current animation length
    pub fn get_current_animation_length(self) -> f64:
        let obj = self.base.as_object()
        let result = obj.call0("get_current_animation_length")
        return result.as_float()

    # Queue animation to play after current
    pub fn queue(mut self, name: String):
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        obj.call1("queue", name_var)

    # Clear animation queue
    pub fn clear_queue(mut self):
        let obj = self.base.as_object()
        obj.call0("clear_queue")

    # Set playback speed scale
    pub fn set_speed_scale(mut self, speed: f32):
        let obj = self.base.as_object()
        let speed_var = variant.Variant::from_float(speed as f64)
        obj.call1("set_speed_scale", speed_var)

    # Get playback speed scale
    pub fn get_speed_scale(self) -> f32:
        let obj = self.base.as_object()
        let result = obj.call0("get_speed_scale")
        return result.as_float() as f32

    # Add animation to library
    pub fn add_animation(mut self, name: String, animation: Animation):
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        let anim_var = variant.Variant::from_object(animation.resource.as_object())
        obj.call2("add_animation", name_var, anim_var)

    # Remove animation from library
    pub fn remove_animation(mut self, name: String):
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        obj.call1("remove_animation", name_var)

    # Check if has animation
    pub fn has_animation(self, name: String) -> bool:
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        let result = obj.call1("has_animation", name_var)
        return result.as_bool()

    # Get animation
    pub fn get_animation(self, name: String) -> Option[Animation]:
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        let result = obj.call1("get_animation", name_var)

        if result.is_null():
            return None
        else:
            let res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(Animation::from_resource(res))


# Animation Tree
# State machine and blending for complex animations
pub struct AnimationTree extends godot.node.Node:

impl AnimationTree:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AnimationTree:
        return AnimationTree(base: godot.node.Node::from_ptr(ptr))

    # Set active (enable/disable tree)
    pub fn set_active(mut self, active: bool):
        let obj = self.base.as_object()
        let active_var = variant.Variant::from_bool(active)
        obj.call1("set_active", active_var)

    # Get active state
    pub fn is_active(self) -> bool:
        let obj = self.base.as_object()
        let result = obj.call0("is_active")
        return result.as_bool()

    # Set parameter value (for blend spaces, state machines)
    pub fn set_parameter(mut self, name: String, value: variant.Variant):
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        obj.call2("set", name_var, value)

    # Get parameter value
    pub fn get_parameter(self, name: String) -> variant.Variant:
        let obj = self.base.as_object()
        let name_var = variant.Variant::from_string(name)
        return obj.call1("get", name_var)

    # Advance animation (manual stepping)
    pub fn advance(mut self, delta: f64):
        let obj = self.base.as_object()
        let delta_var = variant.Variant::from_float(delta)
        obj.call1("advance", delta_var)


# Animation Loop Mode
pub enum LoopMode:
    None = 0      # No looping
    Linear = 1    # Loop from start to end
    Pingpong = 2  # Loop back and forth

# Animation Track Type
pub enum TrackType:
    Value = 0           # Property animation
    Position3D = 1      # 3D position track
    Rotation3D = 2      # 3D rotation track
    Scale3D = 3         # 3D scale track
    BlendShape = 4      # Blend shape track
    Method = 5          # Method call track
    Bezier = 6          # Bezier curve track
    Audio = 7           # Audio playback track
    Animation = 8       # Sub-animation track


# Helper functions
fn loop_mode_from_int(value: i32) -> LoopMode:
    if value == 0:
        return LoopMode::None
    elif value == 1:
        return LoopMode::Linear
    elif value == 2:
        return LoopMode::Pingpong
    else:
        return LoopMode::None


# Animation Builder Helper
# Fluent API for creating animations
pub struct AnimationBuilder:
    animation: Animation
    current_track: i32

impl AnimationBuilder:
    # Create new builder
    pub fn new(length: f64) -> AnimationBuilder:
        let mut anim = Animation::new()
        anim.set_length(length)
        return AnimationBuilder(animation: anim, current_track: -1)

    # Set loop mode
    pub fn loop_mode(mut self, mode: LoopMode) -> AnimationBuilder:
        self.animation.set_loop_mode(mode)
        return self

    # Add property track
    pub fn add_property_track(mut self, path: String) -> AnimationBuilder:
        let track_idx = self.animation.add_track(TrackType::Value)
        self.animation.track_set_path(track_idx, path)
        self.current_track = track_idx
        return self

    # Add keyframe to current track
    pub fn keyframe(mut self, time: f64, value: variant.Variant) -> AnimationBuilder:
        if self.current_track >= 0:
            self.animation.track_insert_key(self.current_track, time, value)
        return self

    # Build final animation
    pub fn build(self) -> Animation:
        return self.animation
