# Godot UI System
#
# Type-safe wrappers for Godot's UI system
#
# Features:
# - Control base class (UI foundation)
# - Common UI widgets (Button, Label, TextEdit, etc.)
# - Layout containers (VBox, HBox, Grid, etc.)
# - Theme system
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_control.html

import godot.ffi
import godot.variant
import godot.node
import godot.resource
import godot.signal

mod ui

# Control Base Class
# Foundation for all UI elements
pub struct Control extends godot.node.Node:

impl Control:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Control:
        return Control(base: godot.node.Node::from_ptr(ptr))

    # Set position
    pub fn set_position(mut self, x: f32, y: f32):
        let obj = self.base.as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # obj.call1("set_position", pos_var)

    # Get position
    pub fn get_position(self) -> (f32, f32):
        let obj = self.base.as_object()
        let result = obj.call0("get_position")
        # TODO: [stdlib][P2] Parse Vector2
        return (0.0, 0.0)  # Placeholder

    # Set size
    pub fn set_size(mut self, width: f32, height: f32):
        let obj = self.base.as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # obj.call1("set_size", size_var)

    # Get size
    pub fn get_size(self) -> (f32, f32):
        let obj = self.base.as_object()
        let result = obj.call0("get_size")
        return (0.0, 0.0)  # Placeholder

    # Set minimum size
    pub fn set_custom_minimum_size(mut self, width: f32, height: f32):
        let obj = self.base.as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # obj.call1("set_custom_minimum_size", size_var)

    # Set anchors (for responsive layout)
    pub fn set_anchor(mut self, side: Side, anchor: f32):
        let obj = self.base.as_object()
        let side_var = variant.Variant::from_int(side as i64)
        let anchor_var = variant.Variant::from_float(anchor as f64)
        obj.call2("set_anchor", side_var, anchor_var)

    # Set all anchors at once
    pub fn set_anchors_preset(mut self, preset: LayoutPreset):
        let obj = self.base.as_object()
        let preset_var = variant.Variant::from_int(preset as i64)
        obj.call1("set_anchors_preset", preset_var)

    # Set visibility
    pub fn set_visible(mut self, visible: bool):
        let obj = self.base.as_object()
        let vis_var = variant.Variant::from_bool(visible)
        obj.call1("set_visible", vis_var)

    # Check visibility
    pub fn is_visible(self) -> bool:
        let obj = self.base.as_object()
        let result = obj.call0("is_visible")
        return result.as_bool()

    # Set modulate (tint color)
    pub fn set_modulate(mut self, r: f32, g: f32, b: f32, a: f32):
        let obj = self.base.as_object()
        # TODO: [stdlib][P3] Create Color variant
        # obj.call1("set_modulate", color_var)

    # Grab focus
    pub fn grab_focus(mut self):
        let obj = self.base.as_object()
        obj.call0("grab_focus")

    # Check if has focus
    pub fn has_focus(self) -> bool:
        let obj = self.base.as_object()
        let result = obj.call0("has_focus")
        return result.as_bool()


# Button Widget
pub struct Button extends Control:

impl Button:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Button:
        return Button(base: Control::from_ptr(ptr))

    # Set button text
    pub fn set_text(mut self, text: String):
        let obj = self.base.base.as_object()
        let text_var = variant.Variant::from_string(text)
        obj.call1("set_text", text_var)

    # Get button text
    pub fn get_text(self) -> String:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_text")
        return result.as_string()

    # Set icon
    pub fn set_icon(mut self, texture: resource.Resource):
        let obj = self.base.base.as_object()
        let icon_var = variant.Variant::from_object(texture.as_object())
        obj.call1("set_icon", icon_var)

    # Set disabled state
    pub fn set_disabled(mut self, disabled: bool):
        let obj = self.base.base.as_object()
        let dis_var = variant.Variant::from_bool(disabled)
        obj.call1("set_disabled", dis_var)

    # Check if disabled
    pub fn is_disabled(self) -> bool:
        let obj = self.base.base.as_object()
        let result = obj.call0("is_disabled")
        return result.as_bool()

    # Check if pressed (toggle mode)
    pub fn is_pressed(self) -> bool:
        let obj = self.base.base.as_object()
        let result = obj.call0("is_pressed")
        return result.as_bool()

    # Set toggle mode
    pub fn set_toggle_mode(mut self, enabled: bool):
        let obj = self.base.base.as_object()
        let toggle_var = variant.Variant::from_bool(enabled)
        obj.call1("set_toggle_mode", toggle_var)

    # Connect pressed signal
    pub fn on_pressed(mut self, callback: fn()):
        # TODO: [stdlib][P3] Connect signal
        pass


# Label Widget
pub struct Label extends Control:

impl Label:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Label:
        return Label(base: Control::from_ptr(ptr))

    # Set label text
    pub fn set_text(mut self, text: String):
        let obj = self.base.base.as_object()
        let text_var = variant.Variant::from_string(text)
        obj.call1("set_text", text_var)

    # Get label text
    pub fn get_text(self) -> String:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_text")
        return result.as_string()

    # Set horizontal alignment
    pub fn set_horizontal_alignment(mut self, alignment: HorizontalAlignment):
        let obj = self.base.base.as_object()
        let align_var = variant.Variant::from_int(alignment as i64)
        obj.call1("set_horizontal_alignment", align_var)

    # Set vertical alignment
    pub fn set_vertical_alignment(mut self, alignment: VerticalAlignment):
        let obj = self.base.base.as_object()
        let align_var = variant.Variant::from_int(alignment as i64)
        obj.call1("set_vertical_alignment", align_var)

    # Set autowrap
    pub fn set_autowrap_mode(mut self, mode: AutowrapMode):
        let obj = self.base.base.as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_autowrap_mode", mode_var)


# TextEdit Widget
pub struct TextEdit extends Control:

impl TextEdit:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> TextEdit:
        return TextEdit(base: Control::from_ptr(ptr))

    # Set text
    pub fn set_text(mut self, text: String):
        let obj = self.base.base.as_object()
        let text_var = variant.Variant::from_string(text)
        obj.call1("set_text", text_var)

    # Get text
    pub fn get_text(self) -> String:
        let obj = self.base.base.as_object()
        let result = obj.call0("get_text")
        return result.as_string()

    # Set editable
    pub fn set_editable(mut self, enabled: bool):
        let obj = self.base.base.as_object()
        let edit_var = variant.Variant::from_bool(enabled)
        obj.call1("set_editable", edit_var)

    # Set placeholder
    pub fn set_placeholder(mut self, text: String):
        let obj = self.base.base.as_object()
        let text_var = variant.Variant::from_string(text)
        obj.call1("set_placeholder", text_var)

    # Clear text
    pub fn clear(mut self):
        let obj = self.base.base.as_object()
        obj.call0("clear")


# VBoxContainer (Vertical Layout)
pub struct VBoxContainer extends Control:

impl VBoxContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> VBoxContainer:
        return VBoxContainer(base: Control::from_ptr(ptr))

    # Set separation between children
    pub fn add_theme_constant_override(mut self, name: String, value: i32):
        let obj = self.base.base.as_object()
        let name_var = variant.Variant::from_string(name)
        let val_var = variant.Variant::from_int(value as i64)
        obj.call2("add_theme_constant_override", name_var, val_var)


# HBoxContainer (Horizontal Layout)
pub struct HBoxContainer extends Control:

impl HBoxContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> HBoxContainer:
        return HBoxContainer(base: Control::from_ptr(ptr))

    # Set separation between children
    pub fn add_theme_constant_override(mut self, name: String, value: i32):
        let obj = self.base.base.as_object()
        let name_var = variant.Variant::from_string(name)
        let val_var = variant.Variant::from_int(value as i64)
        obj.call2("add_theme_constant_override", name_var, val_var)


# GridContainer (Grid Layout)
pub struct GridContainer extends Control:

impl GridContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> GridContainer:
        return GridContainer(base: Control::from_ptr(ptr))

    # Set number of columns
    pub fn set_columns(mut self, columns: i32):
        let obj = self.base.base.as_object()
        let col_var = variant.Variant::from_int(columns as i64)
        obj.call1("set_columns", col_var)


# Enums

pub enum Side:
    Left = 0
    Top = 1
    Right = 2
    Bottom = 3

pub enum LayoutPreset:
    TopLeft = 0
    TopRight = 1
    BottomLeft = 2
    BottomRight = 3
    CenterLeft = 4
    CenterTop = 5
    CenterRight = 6
    CenterBottom = 7
    Center = 8
    LeftWide = 9
    TopWide = 10
    RightWide = 11
    BottomWide = 12
    VCenterWide = 13
    HCenterWide = 14
    FullRect = 15

pub enum HorizontalAlignment:
    Left = 0
    Center = 1
    Right = 2
    Fill = 3

pub enum VerticalAlignment:
    Top = 0
    Center = 1
    Bottom = 2
    Fill = 3

pub enum AutowrapMode:
    Off = 0
    Arbitrary = 1
    Word = 2
    WordSmart = 3


# UI Builder Helper
pub struct UIBuilder:
    root_type: String
    children: Array[UIElement]

impl UIBuilder:
    pub fn new(root_type: String) -> UIBuilder:
        return UIBuilder(root_type: root_type, children: [])

    pub fn button(mut self, text: String) -> UIBuilder:
        let element = UIElement(element_type: "Button", text: Some(text), children: [])
        self.children.push(element)
        return self

    pub fn label(mut self, text: String) -> UIBuilder:
        let element = UIElement(element_type: "Label", text: Some(text), children: [])
        self.children.push(element)
        return self

struct UIElement:
    element_type: String
    text: Option[String]
    children: Array[UIElement]

struct Array[T]:
    items: Vec[T]

impl[T] Array[T]:
    pub fn push(mut self, item: T):
        pass
