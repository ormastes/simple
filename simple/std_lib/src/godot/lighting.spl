# Godot Lighting System
#
# Type-safe wrappers for Godot's lighting system
#
# Features:
# - Light2D (2D lighting)
# - DirectionalLight3D (sun/moon lighting)
# - PointLight3D (omni-directional light)
# - SpotLight3D (cone-shaped light)
# - Environment (global lighting and effects)
# - WorldEnvironment (environment container)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_light2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.node3d
import godot.resource

mod lighting

# Light2D
# 2D lighting with shadows
pub struct Light2D extends godot.node2d.Node2D:

impl Light2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Light2D:
        return Light2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set enabled
    pub fn set_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let en_var = variant.Variant::from_bool(enabled)
        obj.call1("set_enabled", en_var)

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant
        # obj.call1("set_color", color_var)

    # Set energy (brightness)
    pub fn set_energy(mut self, energy: f32):
        let obj = self.base.as_node().as_object()
        let energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_energy", energy_var)

    # Set texture
    pub fn set_texture(mut self, texture: resource.Resource):
        let obj = self.base.as_node().as_object()
        let tex_var = variant.Variant::from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Set texture scale
    pub fn set_texture_scale(mut self, scale: f32):
        let obj = self.base.as_node().as_object()
        let scale_var = variant.Variant::from_float(scale as f64)
        obj.call1("set_texture_scale", scale_var)

    # Set shadow enabled
    pub fn set_shadow_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let shadow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_shadow_enabled", shadow_var)

    # Set shadow color
    pub fn set_shadow_color(mut self, r: f32, g: f32, b: f32, a: f32):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set blend mode
    pub fn set_blend_mode(mut self, mode: BlendMode):
        let obj = self.base.as_node().as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_blend_mode", mode_var)


# DirectionalLight3D
# Directional light (sun/moon)
pub struct DirectionalLight3D extends godot.node3d.Node3D:

impl DirectionalLight3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> DirectionalLight3D:
        return DirectionalLight3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set energy (brightness)
    pub fn set_energy(mut self, energy: f32):
        let obj = self.base.as_node().as_object()
        let energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_param", energy_var)

    # Set shadow enabled
    pub fn set_shadow_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let shadow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_shadow", shadow_var)

    # Set shadow bias
    pub fn set_shadow_bias(mut self, bias: f32):
        let obj = self.base.as_node().as_object()
        let bias_var = variant.Variant::from_float(bias as f64)
        # obj.call2("set_param", PARAM_SHADOW_BIAS, bias_var)

    # Set directional shadow mode
    pub fn set_directional_shadow_mode(mut self, mode: DirectionalShadowMode):
        let obj = self.base.as_node().as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_directional_shadow_mode", mode_var)


# PointLight3D
# Omni-directional point light
pub struct PointLight3D extends godot.node3d.Node3D:

impl PointLight3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> PointLight3D:
        return PointLight3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set energy
    pub fn set_energy(mut self, energy: f32):
        let obj = self.base.as_node().as_object()
        let energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_param", energy_var)

    # Set range
    pub fn set_range(mut self, range: f32):
        let obj = self.base.as_node().as_object()
        let range_var = variant.Variant::from_float(range as f64)
        # obj.call2("set_param", PARAM_RANGE, range_var)

    # Set attenuation
    pub fn set_attenuation(mut self, attenuation: f32):
        let obj = self.base.as_node().as_object()
        let atten_var = variant.Variant::from_float(attenuation as f64)
        # obj.call2("set_param", PARAM_ATTENUATION, atten_var)

    # Set shadow enabled
    pub fn set_shadow_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let shadow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_shadow", shadow_var)


# SpotLight3D
# Cone-shaped spotlight
pub struct SpotLight3D extends godot.node3d.Node3D:

impl SpotLight3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> SpotLight3D:
        return SpotLight3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set energy
    pub fn set_energy(mut self, energy: f32):
        let obj = self.base.as_node().as_object()
        let energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_param", energy_var)

    # Set range
    pub fn set_range(mut self, range: f32):
        let obj = self.base.as_node().as_object()
        let range_var = variant.Variant::from_float(range as f64)
        # obj.call2("set_param", PARAM_RANGE, range_var)

    # Set spot angle (in degrees)
    pub fn set_spot_angle(mut self, angle: f32):
        let obj = self.base.as_node().as_object()
        let angle_var = variant.Variant::from_float(angle as f64)
        # obj.call2("set_param", PARAM_SPOT_ANGLE, angle_var)

    # Set spot attenuation
    pub fn set_spot_attenuation(mut self, attenuation: f32):
        let obj = self.base.as_node().as_object()
        let atten_var = variant.Variant::from_float(attenuation as f64)
        # obj.call2("set_param", PARAM_SPOT_ATTENUATION, atten_var)


# Environment Resource
# Global lighting and post-processing effects
pub struct Environment:
    resource: resource.Resource

impl Environment:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> Environment:
        return Environment(resource: res)

    # Create new environment
    pub fn new() -> Environment:
        let ptr = ffi.godot_new_object("Environment")
        let res = resource.Resource::from_ptr(ptr)
        return Environment::from_resource(res)

    # Set background mode
    pub fn set_background(mut self, mode: BackgroundMode):
        let obj = self.resource.as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_background", mode_var)

    # Set background color
    pub fn set_bg_color(mut self, r: f32, g: f32, b: f32):
        let obj = self.resource.as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set background energy
    pub fn set_bg_energy(mut self, energy: f32):
        let obj = self.resource.as_object()
        let energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_bg_energy", energy_var)

    # Set ambient light color
    pub fn set_ambient_light_color(mut self, r: f32, g: f32, b: f32):
        let obj = self.resource.as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set ambient light energy
    pub fn set_ambient_light_energy(mut self, energy: f32):
        let obj = self.resource.as_object()
        let energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_ambient_light_energy", energy_var)

    # Set fog enabled
    pub fn set_fog_enabled(mut self, enabled: bool):
        let obj = self.resource.as_object()
        let fog_var = variant.Variant::from_bool(enabled)
        obj.call1("set_fog_enabled", fog_var)

    # Set fog light color
    pub fn set_fog_light_color(mut self, r: f32, g: f32, b: f32):
        let obj = self.resource.as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set fog density
    pub fn set_fog_density(mut self, density: f32):
        let obj = self.resource.as_object()
        let density_var = variant.Variant::from_float(density as f64)
        obj.call1("set_fog_density", density_var)

    # Set glow enabled (bloom)
    pub fn set_glow_enabled(mut self, enabled: bool):
        let obj = self.resource.as_object()
        let glow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_glow_enabled", glow_var)

    # Set tonemap mode
    pub fn set_tonemap_mode(mut self, mode: ToneMapper):
        let obj = self.resource.as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_tonemapper", mode_var)

    # Set exposure
    pub fn set_tonemap_exposure(mut self, exposure: f32):
        let obj = self.resource.as_object()
        let exp_var = variant.Variant::from_float(exposure as f64)
        obj.call1("set_tonemap_exposure", exp_var)


# WorldEnvironment Node
# Container for environment settings
pub struct WorldEnvironment extends godot.node3d.Node3D:

impl WorldEnvironment:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> WorldEnvironment:
        return WorldEnvironment(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set environment
    pub fn set_environment(mut self, env: Environment):
        let obj = self.base.as_node().as_object()
        let env_var = variant.Variant::from_object(env.resource.as_object())
        obj.call1("set_environment", env_var)

    # Get environment
    pub fn get_environment(self) -> Option[Environment]:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_environment")

        if result.is_null():
            return None
        else:
            let res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(Environment::from_resource(res))


# Enums

pub enum BlendMode:
    Add = 0       # Additive blending
    Sub = 1       # Subtractive blending
    Mix = 2       # Mix blending

impl BlendMode:
    pub fn to_string(self) -> String:
        """Convert blend mode to string."""
        match self:
            case Add: "Add"
            case Sub: "Sub"
            case Mix: "Mix"

    pub fn description(self) -> String:
        """Get blend mode description."""
        match self:
            case Add: "Additive blending (colors are added)"
            case Sub: "Subtractive blending (colors are subtracted)"
            case Mix: "Mix blending (standard alpha blending)"

    pub fn is_add(self) -> bool:
        """Check if blend mode is Add."""
        match self:
            case Add: true
            case _: false

    pub fn is_sub(self) -> bool:
        """Check if blend mode is Sub."""
        match self:
            case Sub: true
            case _: false

    pub fn is_mix(self) -> bool:
        """Check if blend mode is Mix."""
        match self:
            case Mix: true
            case _: false

    pub fn summary(self) -> String:
        """Get blend mode summary."""
        let name = self.to_string()
        let desc = self.description()
        return "BlendMode: {name} ({desc})"

pub enum DirectionalShadowMode:
    Orthogonal = 0       # Orthogonal shadows
    Parallel2Splits = 1  # 2-split parallel
    Parallel4Splits = 2  # 4-split parallel (CSM)

pub enum BackgroundMode:
    ClearColor = 0   # Solid color
    Color = 1        # Custom color
    Sky = 2          # Sky shader
    Canvas = 3       # Canvas layer
    Keep = 4         # Keep previous
    CameraNone = 5   # No background

pub enum ToneMapper:
    Linear = 0       # No tonemapping
    Reinhard = 1     # Reinhard
    Filmic = 2       # Filmic (ACES-like)
    Aces = 3         # ACES


# Preset environments

# Outdoor daytime
pub fn create_outdoor_environment() -> Environment:
    let mut env = Environment::new()
    env.set_background(BackgroundMode::Sky)
    env.set_bg_energy(1.0)
    env.set_ambient_light_color(0.4, 0.5, 0.6)
    env.set_ambient_light_energy(1.0)
    env.set_tonemap_mode(ToneMapper::Filmic)
    env.set_tonemap_exposure(1.0)
    return env

# Indoor with fog
pub fn create_indoor_environment() -> Environment:
    let mut env = Environment::new()
    env.set_background(BackgroundMode::Color)
    env.set_bg_color(0.1, 0.1, 0.1)
    env.set_ambient_light_color(0.3, 0.3, 0.3)
    env.set_ambient_light_energy(0.5)
    env.set_fog_enabled(true)
    env.set_fog_density(0.01)
    env.set_tonemap_mode(ToneMapper::Reinhard)
    return env

# Night scene
pub fn create_night_environment() -> Environment:
    let mut env = Environment::new()
    env.set_background(BackgroundMode::Color)
    env.set_bg_color(0.01, 0.01, 0.02)
    env.set_ambient_light_color(0.05, 0.05, 0.1)
    env.set_ambient_light_energy(0.2)
    env.set_glow_enabled(true)
    env.set_tonemap_mode(ToneMapper::Aces)
    return env
