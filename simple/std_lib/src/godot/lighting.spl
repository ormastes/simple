# Godot Lighting System
#
# Type-safe wrappers for Godot's lighting system
#
# Features:
# - Light2D (2D lighting)
# - DirectionalLight3D (sun/moon lighting)
# - PointLight3D (omni-directional light)
# - SpotLight3D (cone-shaped light)
# - Environment (global lighting and effects)
# - WorldEnvironment (environment container)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_light2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.node3d
import godot.resource

mod lighting

# Light2D
# 2D lighting with shadows
pub struct Light2D extends godot.node2d.Node2D:

impl Light2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Light2D:
        return Light2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set enabled
    pub fn set_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val en_var = variant.Variant::from_bool(enabled)
        obj.call1("set_enabled", en_var)

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant
        # obj.call1("set_color", color_var)

    # Set energy (brightness)
    pub fn set_energy(mut self, energy: f32):
        val obj = self.base.as_node().as_object()
        val energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_energy", energy_var)

    # Set texture
    pub fn set_texture(mut self, texture: resource.Resource):
        val obj = self.base.as_node().as_object()
        val tex_var = variant.Variant::from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Set texture scale
    pub fn set_texture_scale(mut self, scale: f32):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant::from_float(scale as f64)
        obj.call1("set_texture_scale", scale_var)

    # Set shadow enabled
    pub fn set_shadow_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val shadow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_shadow_enabled", shadow_var)

    # Set shadow color
    pub fn set_shadow_color(mut self, r: f32, g: f32, b: f32, a: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set blend mode
    pub fn set_blend_mode(mut self, mode: BlendMode):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_blend_mode", mode_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable(mut self):
        """Enable the light.

        Example:
            light.enable()
        """
        self.set_enabled(true)

    pub fn disable(mut self):
        """Disable the light.

        Example:
            light.disable()
        """
        self.set_enabled(false)

    pub fn enable_shadows(mut self):
        """Enable shadow casting.

        Example:
            light.enable_shadows()
        """
        self.set_shadow_enabled(true)

    pub fn disable_shadows(mut self):
        """Disable shadow casting.

        Example:
            light.disable_shadows()
        """
        self.set_shadow_enabled(false)

    pub fn summary(self) -> text:
        """Get Light2D summary.

        Returns:
            Human-readable summary

        Example:
            light.summary()
            # → "Light2D: enabled"
        """
        return "Light2D: enabled"


# DirectionalLight3D
# Directional light (sun/moon)
pub struct DirectionalLight3D extends godot.node3d.Node3D:

impl DirectionalLight3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> DirectionalLight3D:
        return DirectionalLight3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set energy (brightness)
    pub fn set_energy(mut self, energy: f32):
        val obj = self.base.as_node().as_object()
        val energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_param", energy_var)

    # Set shadow enabled
    pub fn set_shadow_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val shadow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_shadow", shadow_var)

    # Set shadow bias
    pub fn set_shadow_bias(mut self, bias: f32):
        val obj = self.base.as_node().as_object()
        val bias_var = variant.Variant::from_float(bias as f64)
        # obj.call2("set_param", PARAM_SHADOW_BIAS, bias_var)

    # Set directional shadow mode
    pub fn set_directional_shadow_mode(mut self, mode: DirectionalShadowMode):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_directional_shadow_mode", mode_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable_shadows(mut self):
        """Enable shadow casting.

        Example:
            light.enable_shadows()
        """
        self.set_shadow_enabled(true)

    pub fn disable_shadows(mut self):
        """Disable shadow casting.

        Example:
            light.disable_shadows()
        """
        self.set_shadow_enabled(false)

    pub fn summary(self) -> text:
        """Get DirectionalLight3D summary.

        Returns:
            Human-readable summary

        Example:
            light.summary()
            # → "DirectionalLight3D: directional light"
        """
        return "DirectionalLight3D: directional light"


# PointLight3D
# Omni-directional point light
pub struct PointLight3D extends godot.node3d.Node3D:

impl PointLight3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> PointLight3D:
        return PointLight3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set energy
    pub fn set_energy(mut self, energy: f32):
        val obj = self.base.as_node().as_object()
        val energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_param", energy_var)

    # Set range
    pub fn set_range(mut self, range: f32):
        val obj = self.base.as_node().as_object()
        val range_var = variant.Variant::from_float(range as f64)
        # obj.call2("set_param", PARAM_RANGE, range_var)

    # Set attenuation
    pub fn set_attenuation(mut self, attenuation: f32):
        val obj = self.base.as_node().as_object()
        val atten_var = variant.Variant::from_float(attenuation as f64)
        # obj.call2("set_param", PARAM_ATTENUATION, atten_var)

    # Set shadow enabled
    pub fn set_shadow_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val shadow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_shadow", shadow_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable_shadows(mut self):
        """Enable shadow casting.

        Example:
            light.enable_shadows()
        """
        self.set_shadow_enabled(true)

    pub fn disable_shadows(mut self):
        """Disable shadow casting.

        Example:
            light.disable_shadows()
        """
        self.set_shadow_enabled(false)

    pub fn summary(self) -> text:
        """Get PointLight3D summary.

        Returns:
            Human-readable summary

        Example:
            light.summary()
            # → "PointLight3D: omni-directional light"
        """
        return "PointLight3D: omni-directional light"


# SpotLight3D
# Cone-shaped spotlight
pub struct SpotLight3D extends godot.node3d.Node3D:

impl SpotLight3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> SpotLight3D:
        return SpotLight3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set energy
    pub fn set_energy(mut self, energy: f32):
        val obj = self.base.as_node().as_object()
        val energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_param", energy_var)

    # Set range
    pub fn set_range(mut self, range: f32):
        val obj = self.base.as_node().as_object()
        val range_var = variant.Variant::from_float(range as f64)
        # obj.call2("set_param", PARAM_RANGE, range_var)

    # Set spot angle (in degrees)
    pub fn set_spot_angle(mut self, angle: f32):
        val obj = self.base.as_node().as_object()
        val angle_var = variant.Variant::from_float(angle as f64)
        # obj.call2("set_param", PARAM_SPOT_ANGLE, angle_var)

    # Set spot attenuation
    pub fn set_spot_attenuation(mut self, attenuation: f32):
        val obj = self.base.as_node().as_object()
        val atten_var = variant.Variant::from_float(attenuation as f64)
        # obj.call2("set_param", PARAM_SPOT_ATTENUATION, atten_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn summary(self) -> text:
        """Get SpotLight3D summary.

        Returns:
            Human-readable summary

        Example:
            light.summary()
            # → "SpotLight3D: cone-shaped spotlight"
        """
        return "SpotLight3D: cone-shaped spotlight"


# Environment Resource
# Global lighting and post-processing effects
pub struct Environment:
    resource: resource.Resource

impl Environment:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> Environment:
        return Environment(resource: res)

    # Create new environment
    pub fn new() -> Environment:
        val ptr = ffi.godot_new_object("Environment")
        val res = resource.Resource::from_ptr(ptr)
        return Environment::from_resource(res)

    # Set background mode
    pub fn set_background(mut self, mode: BackgroundMode):
        val obj = self.resource.as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_background", mode_var)

    # Set background color
    pub fn set_bg_color(mut self, r: f32, g: f32, b: f32):
        val obj = self.resource.as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set background energy
    pub fn set_bg_energy(mut self, energy: f32):
        val obj = self.resource.as_object()
        val energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_bg_energy", energy_var)

    # Set ambient light color
    pub fn set_ambient_light_color(mut self, r: f32, g: f32, b: f32):
        val obj = self.resource.as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set ambient light energy
    pub fn set_ambient_light_energy(mut self, energy: f32):
        val obj = self.resource.as_object()
        val energy_var = variant.Variant::from_float(energy as f64)
        obj.call1("set_ambient_light_energy", energy_var)

    # Set fog enabled
    pub fn set_fog_enabled(mut self, enabled: bool):
        val obj = self.resource.as_object()
        val fog_var = variant.Variant::from_bool(enabled)
        obj.call1("set_fog_enabled", fog_var)

    # Set fog light color
    pub fn set_fog_light_color(mut self, r: f32, g: f32, b: f32):
        val obj = self.resource.as_object()
        # TODO: [stdlib][P3] Create Color variant

    # Set fog density
    pub fn set_fog_density(mut self, density: f32):
        val obj = self.resource.as_object()
        val density_var = variant.Variant::from_float(density as f64)
        obj.call1("set_fog_density", density_var)

    # Set glow enabled (bloom)
    pub fn set_glow_enabled(mut self, enabled: bool):
        val obj = self.resource.as_object()
        val glow_var = variant.Variant::from_bool(enabled)
        obj.call1("set_glow_enabled", glow_var)

    # Set tonemap mode
    pub fn set_tonemap_mode(mut self, mode: ToneMapper):
        val obj = self.resource.as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_tonemapper", mode_var)

    # Set exposure
    pub fn set_tonemap_exposure(mut self, exposure: f32):
        val obj = self.resource.as_object()
        val exp_var = variant.Variant::from_float(exposure as f64)
        obj.call1("set_tonemap_exposure", exp_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable_fog(mut self):
        """Enable fog effects.

        Example:
            env.enable_fog()
        """
        self.set_fog_enabled(true)

    pub fn disable_fog(mut self):
        """Disable fog effects.

        Example:
            env.disable_fog()
        """
        self.set_fog_enabled(false)

    pub fn enable_glow(mut self):
        """Enable glow/bloom effects.

        Example:
            env.enable_glow()
        """
        self.set_glow_enabled(true)

    pub fn disable_glow(mut self):
        """Disable glow/bloom effects.

        Example:
            env.disable_glow()
        """
        self.set_glow_enabled(false)

    pub fn summary(self) -> text:
        """Get environment summary.

        Returns:
            Human-readable summary

        Example:
            env.summary()
            # → "Environment: global lighting settings"
        """
        return "Environment: global lighting settings"


# WorldEnvironment Node
# Container for environment settings
pub struct WorldEnvironment extends godot.node3d.Node3D:

impl WorldEnvironment:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> WorldEnvironment:
        return WorldEnvironment(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set environment
    pub fn set_environment(mut self, env: Environment):
        val obj = self.base.as_node().as_object()
        val env_var = variant.Variant::from_object(env.resource.as_object())
        obj.call1("set_environment", env_var)

    # Get environment
    pub fn get_environment(self) -> Option<Environment>:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_environment")

        if result.is_null():
            return None
        else:
            val res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(Environment::from_resource(res))

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_environment(self) -> bool:
        """Check if has environment set.

        Returns:
            true if environment exists

        Example:
            world.has_environment()  # → true
        """
        return self.get_environment().is_some()

    pub fn summary(self) -> text:
        """Get world environment summary.

        Returns:
            Human-readable summary

        Example:
            world.summary()
            # → "WorldEnvironment: has environment"
        """
        val env_str = if self.has_environment() { "has environment" } else { "no environment" }
        return "WorldEnvironment: {env_str}"


# Enums

pub enum BlendMode:
    Add = 0       # Additive blending
    Sub = 1       # Subtractive blending
    Mix = 2       # Mix blending

impl BlendMode:
    pub fn to_string(self) -> text:
        """Convert blend mode to string."""
        match self:
            case Add: "Add"
            case Sub: "Sub"
            case Mix: "Mix"

    pub fn description(self) -> text:
        """Get blend mode description."""
        match self:
            case Add: "Additive blending (colors are added)"
            case Sub: "Subtractive blending (colors are subtracted)"
            case Mix: "Mix blending (standard alpha blending)"

    pub fn is_add(self) -> bool:
        """Check if blend mode is Add."""
        match self:
            case Add: true
            case _: false

    pub fn is_sub(self) -> bool:
        """Check if blend mode is Sub."""
        match self:
            case Sub: true
            case _: false

    pub fn is_mix(self) -> bool:
        """Check if blend mode is Mix."""
        match self:
            case Mix: true
            case _: false

    pub fn summary(self) -> text:
        """Get blend mode summary."""
        val name = self.to_string()
        val desc = self.description()
        return "BlendMode: {name} ({desc})"

pub enum DirectionalShadowMode:
    Orthogonal = 0       # Orthogonal shadows
    Parallel2Splits = 1  # 2-split parallel
    Parallel4Splits = 2  # 4-split parallel (CSM)

impl DirectionalShadowMode:
    pub fn to_string(self) -> text:
        """Convert shadow mode to string."""
        match self:
            case Orthogonal: "Orthogonal"
            case Parallel2Splits: "Parallel2Splits"
            case Parallel4Splits: "Parallel4Splits"

    pub fn description(self) -> text:
        """Get shadow mode description."""
        match self:
            case Orthogonal: "Simple orthogonal shadow projection"
            case Parallel2Splits: "Parallel split shadow maps (2 cascades)"
            case Parallel4Splits: "Parallel split shadow maps (4 cascades, CSM)"

    pub fn is_orthogonal(self) -> bool:
        """Check if shadow mode is Orthogonal."""
        match self:
            case Orthogonal: true
            case _: false

    pub fn is_parallel_2_splits(self) -> bool:
        """Check if shadow mode is Parallel2Splits."""
        match self:
            case Parallel2Splits: true
            case _: false

    pub fn is_parallel_4_splits(self) -> bool:
        """Check if shadow mode is Parallel4Splits."""
        match self:
            case Parallel4Splits: true
            case _: false

    pub fn is_cascaded(self) -> bool:
        """Check if shadow mode uses cascades."""
        match self:
            case Parallel2Splits: true
            case Parallel4Splits: true
            case _: false

    pub fn get_cascade_count(self) -> i32:
        """Get number of shadow cascades."""
        match self:
            case Orthogonal: 1
            case Parallel2Splits: 2
            case Parallel4Splits: 4

    pub fn summary(self) -> text:
        """Get shadow mode summary."""
        val name = self.to_string()
        val desc = self.description()
        val cascades = self.get_cascade_count()
        var props = []
        if self.is_cascaded():
            props.push("cascaded")
        props.push("{cascades} cascade(s)")
        val props_str = ", ".join(props)
        return "DirectionalShadowMode: {name} ({desc}, {props_str})"

pub enum BackgroundMode:
    ClearColor = 0   # Solid color
    Color = 1        # Custom color
    Sky = 2          # Sky shader
    Canvas = 3       # Canvas layer
    Keep = 4         # Keep previous
    CameraNone = 5   # No background

impl BackgroundMode:
    pub fn to_string(self) -> text:
        """Convert background mode to string."""
        match self:
            case ClearColor: "ClearColor"
            case Color: "Color"
            case Sky: "Sky"
            case Canvas: "Canvas"
            case Keep: "Keep"
            case CameraNone: "CameraNone"

    pub fn description(self) -> text:
        """Get background mode description."""
        match self:
            case ClearColor: "Solid clear color background"
            case Color: "Custom solid color background"
            case Sky: "Sky shader background"
            case Canvas: "Canvas layer as background"
            case Keep: "Keep previous frame's background"
            case CameraNone: "No background rendering"

    pub fn is_clear_color(self) -> bool:
        """Check if background mode is ClearColor."""
        match self:
            case ClearColor: true
            case _: false

    pub fn is_color(self) -> bool:
        """Check if background mode is Color."""
        match self:
            case Color: true
            case _: false

    pub fn is_sky(self) -> bool:
        """Check if background mode is Sky."""
        match self:
            case Sky: true
            case _: false

    pub fn is_canvas(self) -> bool:
        """Check if background mode is Canvas."""
        match self:
            case Canvas: true
            case _: false

    pub fn is_keep(self) -> bool:
        """Check if background mode is Keep."""
        match self:
            case Keep: true
            case _: false

    pub fn is_camera_none(self) -> bool:
        """Check if background mode is CameraNone."""
        match self:
            case CameraNone: true
            case _: false

    pub fn uses_color(self) -> bool:
        """Check if mode uses a solid color."""
        match self:
            case ClearColor: true
            case Color: true
            case _: false

    pub fn is_transparent(self) -> bool:
        """Check if mode allows transparency."""
        match self:
            case Keep: true
            case CameraNone: true
            case _: false

    pub fn summary(self) -> text:
        """Get background mode summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.uses_color():
            props.push("solid color")
        if self.is_transparent():
            props.push("transparent")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "BackgroundMode: {name} ({desc}, {props_str})"
        else:
            return "BackgroundMode: {name} ({desc})"

pub enum ToneMapper:
    Linear = 0       # No tonemapping
    Reinhard = 1     # Reinhard
    Filmic = 2       # Filmic (ACES-like)
    Aces = 3         # ACES

impl ToneMapper:
    pub fn to_string(self) -> text:
        """Convert tone mapper to string."""
        match self:
            case Linear: "Linear"
            case Reinhard: "Reinhard"
            case Filmic: "Filmic"
            case Aces: "Aces"

    pub fn description(self) -> text:
        """Get tone mapper description."""
        match self:
            case Linear: "No tonemapping (linear color space)"
            case Reinhard: "Reinhard tonemapping (simple HDR compression)"
            case Filmic: "Filmic tonemapping (ACES-like, cinematic)"
            case Aces: "ACES tonemapping (Academy Color Encoding System)"

    pub fn is_linear(self) -> bool:
        """Check if tone mapper is Linear."""
        match self:
            case Linear: true
            case _: false

    pub fn is_reinhard(self) -> bool:
        """Check if tone mapper is Reinhard."""
        match self:
            case Reinhard: true
            case _: false

    pub fn is_filmic(self) -> bool:
        """Check if tone mapper is Filmic."""
        match self:
            case Filmic: true
            case _: false

    pub fn is_aces(self) -> bool:
        """Check if tone mapper is Aces."""
        match self:
            case Aces: true
            case _: false

    pub fn uses_hdr_compression(self) -> bool:
        """Check if tone mapper performs HDR compression."""
        match self:
            case Linear: false
            case _: true

    pub fn is_cinematic(self) -> bool:
        """Check if tone mapper is cinematic-oriented."""
        match self:
            case Filmic: true
            case Aces: true
            case _: false

    pub fn summary(self) -> text:
        """Get tone mapper summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.uses_hdr_compression():
            props.push("HDR compression")
        if self.is_cinematic():
            props.push("cinematic")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ToneMapper: {name} ({desc}, {props_str})"
        else:
            return "ToneMapper: {name} ({desc})"


# Preset environments

# Outdoor daytime
pub fn create_outdoor_environment() -> Environment:
    var env = Environment::new()
    env.set_background(BackgroundMode::Sky)
    env.set_bg_energy(1.0)
    env.set_ambient_light_color(0.4, 0.5, 0.6)
    env.set_ambient_light_energy(1.0)
    env.set_tonemap_mode(ToneMapper::Filmic)
    env.set_tonemap_exposure(1.0)
    return env

# Indoor with fog
pub fn create_indoor_environment() -> Environment:
    var env = Environment::new()
    env.set_background(BackgroundMode::Color)
    env.set_bg_color(0.1, 0.1, 0.1)
    env.set_ambient_light_color(0.3, 0.3, 0.3)
    env.set_ambient_light_energy(0.5)
    env.set_fog_enabled(true)
    env.set_fog_density(0.01)
    env.set_tonemap_mode(ToneMapper::Reinhard)
    return env

# Night scene
pub fn create_night_environment() -> Environment:
    var env = Environment::new()
    env.set_background(BackgroundMode::Color)
    env.set_bg_color(0.01, 0.01, 0.02)
    env.set_ambient_light_color(0.05, 0.05, 0.1)
    env.set_ambient_light_energy(0.2)
    env.set_glow_enabled(true)
    env.set_tonemap_mode(ToneMapper::Aces)
    return env
