# Godot 3D Physics System
#
# Type-safe wrappers for Godot's 3D physics engine
#
# Features:
# - RigidBody3D (dynamic physics)
# - StaticBody3D (static colliders)
# - CharacterBody3D (kinematic control)
# - CollisionShape3D (shape definitions)
# - Area3D (trigger zones)
# - PhysicsServer3D (low-level physics API)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_rigidbody3d.html

import godot.ffi
import godot.variant
import godot.node3d

mod physics3d

# RigidBody3D
# Dynamic physics body with forces and collisions
pub struct RigidBody3D extends godot.node3d.Node3D:

impl RigidBody3D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody3D:
        return RigidBody3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Get linear velocity
    pub fn get_linear_velocity(self) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_linear_velocity")
        # TODO: Parse Vector3
        return (0.0, 0.0, 0.0)  # Placeholder

    # Set linear velocity
    pub fn set_linear_velocity(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant
        # obj.call1("set_linear_velocity", vel_var)

    # Get angular velocity
    pub fn get_angular_velocity(self) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_angular_velocity")
        return (0.0, 0.0, 0.0)  # Placeholder

    # Set angular velocity
    pub fn set_angular_velocity(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Apply central impulse (instant velocity change)
    pub fn apply_central_impulse(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Apply impulse at position
    pub fn apply_impulse(mut self, impulse_x: f64, impulse_y: f64, impulse_z: f64, position_x: f64, position_y: f64, position_z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variants for impulse and position

    # Apply torque impulse (rotational)
    pub fn apply_torque_impulse(mut self, torque_x: f64, torque_y: f64, torque_z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Apply central force (continuous)
    pub fn apply_central_force(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Apply force at position
    pub fn apply_force(mut self, force_x: f64, force_y: f64, force_z: f64, position_x: f64, position_y: f64, position_z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variants

    # Apply torque
    pub fn apply_torque(mut self, torque_x: f64, torque_y: f64, torque_z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Set mass
    pub fn set_mass(mut self, mass: f64):
        let obj = self.base.as_node().as_object()
        let mass_var = variant.Variant::from_float(mass)
        obj.call1("set_mass", mass_var)

    # Get mass
    pub fn get_mass(self) -> f64:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_mass")
        return result.as_float()

    # Set gravity scale
    pub fn set_gravity_scale(mut self, scale: f64):
        let obj = self.base.as_node().as_object()
        let scale_var = variant.Variant::from_float(scale)
        obj.call1("set_gravity_scale", scale_var)

    # Set continuous collision detection
    pub fn set_continuous_cd(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let cd_var = variant.Variant::from_bool(enabled)
        obj.call1("set_continuous_cd", cd_var)

    # Set whether body can sleep
    pub fn set_can_sleep(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let sleep_var = variant.Variant::from_bool(enabled)
        obj.call1("set_can_sleep", sleep_var)

    # Check if sleeping
    pub fn is_sleeping(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_sleeping")
        return result.as_bool()

    # Set freeze mode
    pub fn set_freeze_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let freeze_var = variant.Variant::from_bool(enabled)
        obj.call1("set_freeze_enabled", freeze_var)

    # Set lock axes (prevent movement/rotation on specific axes)
    pub fn set_axis_lock(mut self, axis: BodyAxis, lock: bool):
        let obj = self.base.as_node().as_object()
        let axis_var = variant.Variant::from_int(axis as i64)
        let lock_var = variant.Variant::from_bool(lock)
        obj.call2("set_axis_lock", axis_var, lock_var)


# StaticBody3D
# Static collider (doesn't move)
pub struct StaticBody3D extends godot.node3d.Node3D:

impl StaticBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> StaticBody3D:
        return StaticBody3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set constant linear velocity (for moving platforms)
    pub fn set_constant_linear_velocity(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Set constant angular velocity (for rotating platforms)
    pub fn set_constant_angular_velocity(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant


# CharacterBody3D
# Kinematic body for player/NPC control
pub struct CharacterBody3D extends godot.node3d.Node3D:

impl CharacterBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody3D:
        return CharacterBody3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set velocity
    pub fn set_velocity(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Get velocity
    pub fn get_velocity(self) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_velocity")
        return (0.0, 0.0, 0.0)  # Placeholder

    # Move and slide (kinematic movement with collision)
    pub fn move_and_slide(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("move_and_slide")

    # Check if on floor
    pub fn is_on_floor(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_on_floor")
        return result.as_bool()

    # Check if on ceiling
    pub fn is_on_ceiling(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_on_ceiling")
        return result.as_bool()

    # Check if on wall
    pub fn is_on_wall(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_on_wall")
        return result.as_bool()

    # Get floor normal
    pub fn get_floor_normal(self) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_floor_normal")
        return (0.0, 1.0, 0.0)  # Placeholder

    # Get wall normal
    pub fn get_wall_normal(self) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_wall_normal")
        return (0.0, 0.0, 0.0)  # Placeholder

    # Set up direction (for slope detection)
    pub fn set_up_direction(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant

    # Set floor max angle (in radians)
    pub fn set_floor_max_angle(mut self, angle: f64):
        let obj = self.base.as_node().as_object()
        let angle_var = variant.Variant::from_float(angle)
        obj.call1("set_floor_max_angle", angle_var)

    # Set floor snap length
    pub fn set_floor_snap_length(mut self, length: f64):
        let obj = self.base.as_node().as_object()
        let len_var = variant.Variant::from_float(length)
        obj.call1("set_floor_snap_length", len_var)

    # Get slide collision count
    pub fn get_slide_collision_count(self) -> i32:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_slide_collision_count")
        return result.as_int() as i32


# Area3D
# Trigger zone without physics
pub struct Area3D extends godot.node3d.Node3D:

impl Area3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Area3D:
        return Area3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set monitoring (detect overlaps)
    pub fn set_monitoring(mut self, enable: bool):
        let obj = self.base.as_node().as_object()
        let mon_var = variant.Variant::from_bool(enable)
        obj.call1("set_monitoring", mon_var)

    # Set monitorable (can be detected)
    pub fn set_monitorable(mut self, enable: bool):
        let obj = self.base.as_node().as_object()
        let mon_var = variant.Variant::from_bool(enable)
        obj.call1("set_monitorable", mon_var)

    # Get overlapping bodies
    pub fn get_overlapping_bodies(self) -> Array[RigidBody3D]:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_overlapping_bodies")
        # TODO: Parse Array[Node3D]
        return []  # Placeholder

    # Get overlapping areas
    pub fn get_overlapping_areas(self) -> Array[Area3D]:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_overlapping_areas")
        return []  # Placeholder

    # Check if overlaps body
    pub fn overlaps_body(self, body: RigidBody3D) -> bool:
        let obj = self.base.as_node().as_object()
        let body_var = variant.Variant::from_object(body.base.as_node().as_object())
        let result = obj.call1("overlaps_body", body_var)
        return result.as_bool()

    # Set gravity (area-specific gravity)
    pub fn set_gravity(mut self, gravity: f64):
        let obj = self.base.as_node().as_object()
        let grav_var = variant.Variant::from_float(gravity)
        obj.call1("set_gravity", grav_var)

    # Set gravity direction
    pub fn set_gravity_direction(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector3 variant


# CollisionShape3D
# Shape definition for physics bodies
pub struct CollisionShape3D extends godot.node3d.Node3D:

impl CollisionShape3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CollisionShape3D:
        return CollisionShape3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set shape resource
    pub fn set_shape(mut self, shape: Shape3D):
        let obj = self.base.as_node().as_object()
        let shape_var = variant.Variant::from_object(shape.resource.as_object())
        obj.call1("set_shape", shape_var)

    # Set disabled
    pub fn set_disabled(mut self, disabled: bool):
        let obj = self.base.as_node().as_object()
        let dis_var = variant.Variant::from_bool(disabled)
        obj.call1("set_disabled", dis_var)


# Shape3D Resource
pub struct Shape3D:
    resource: godot.resource.Resource

impl Shape3D:
    pub fn from_resource(res: godot.resource.Resource) -> Shape3D:
        return Shape3D(resource: res)


# Physics Server 3D
# Low-level physics API
pub struct PhysicsServer3D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl PhysicsServer3D:
    # Get singleton
    pub fn get_singleton() -> PhysicsServer3D:
        let ptr = ffi.godot_get_singleton("PhysicsServer3D")
        return PhysicsServer3D(singleton_ptr: ptr)

    # Set active (enable/disable physics)
    pub fn set_active(mut self, active: bool):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let active_var = variant.Variant::from_bool(active)
        obj.call1("set_active", active_var)

    # Step simulation manually
    pub fn step(mut self, delta: f64):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let delta_var = variant.Variant::from_float(delta)
        obj.call1("step", delta_var)

    # Flush queries (process collision detection)
    pub fn flush_queries(mut self):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        obj.call0("flush_queries")


# Enums

pub enum BodyAxis:
    LinearX = 1
    LinearY = 2
    LinearZ = 4
    AngularX = 8
    AngularY = 16
    AngularZ = 32


# Array placeholder
pub struct Array[T]:
    items: Vec[T]
