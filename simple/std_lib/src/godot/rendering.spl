# Godot Rendering System
#
# Sprite rendering, mesh instances, and camera control.
#
# Reference: https://docs.godotengine.org/en/stable/classes/class_sprite2d.html

import godot.ffi
import godot.variant
import godot.object
import godot.node
import godot.node2d
import godot.node3d
import godot.resource

# Sprite2D - 2D sprite rendering
pub struct Sprite2D:
    base: node2d.Node2D

impl Sprite2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Sprite2D:
        return Sprite2D(base: node2d.Node2D::from_ptr(ptr))

    # Texture
    pub fn set_texture(mut self, texture: resource.Resource):
        let texture_var = variant.Variant::from_object(texture.as_object().ptr())
        self.base.as_node().as_object().call1("set_texture", texture_var)

    pub fn get_texture(self) -> Option[resource.Resource]:
        let result = self.base.as_node().as_object().call0("get_texture")
        let ptr = result.as_object()
        if ptr == 0:
            return None
        return Some(resource.Resource::from_ptr(ptr))

    # Visibility
    pub fn set_visible(mut self, visible: bool):
        let visible_var = variant.Variant::from_bool(visible)
        self.base.as_node().as_object().call1("set_visible", visible_var)

    pub fn is_visible(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_visible")
        return result.as_bool()

    # Modulate (color tint)
    pub fn set_modulate(mut self, r: f32, g: f32, b: f32, a: f32):
        let color = variant.Variant::from_color(r, g, b, a)
        self.base.as_node().as_object().call1("set_modulate", color)

    # Flip
    pub fn set_flip_h(mut self, flip: bool):
        let flip_var = variant.Variant::from_bool(flip)
        self.base.as_node().as_object().call1("set_flip_h", flip_var)

    pub fn set_flip_v(mut self, flip: bool):
        let flip_var = variant.Variant::from_bool(flip)
        self.base.as_node().as_object().call1("set_flip_v", flip_var)

    # Region (sprite sheet)
    pub fn set_region_enabled(mut self, enabled: bool):
        let enabled_var = variant.Variant::from_bool(enabled)
        self.base.as_node().as_object().call1("set_region_enabled", enabled_var)

# MeshInstance3D - 3D mesh rendering
pub struct MeshInstance3D:
    base: node3d.Node3D

impl MeshInstance3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> MeshInstance3D:
        return MeshInstance3D(base: node3d.Node3D::from_ptr(ptr))

    # Mesh
    pub fn set_mesh(mut self, mesh: resource.Resource):
        let mesh_var = variant.Variant::from_object(mesh.as_object().ptr())
        self.base.as_node().as_object().call1("set_mesh", mesh_var)

    pub fn get_mesh(self) -> Option[resource.Resource]:
        let result = self.base.as_node().as_object().call0("get_mesh")
        let ptr = result.as_object()
        if ptr == 0:
            return None
        return Some(resource.Resource::from_ptr(ptr))

    # Material override
    pub fn set_material_override(mut self, material: resource.Resource):
        let mat_var = variant.Variant::from_object(material.as_object().ptr())
        self.base.as_node().as_object().call1("set_material_override", mat_var)

    # Visibility
    pub fn set_visible(mut self, visible: bool):
        let visible_var = variant.Variant::from_bool(visible)
        self.base.as_node().as_object().call1("set_visible", visible_var)

    # Cast shadows
    pub fn set_cast_shadows_setting(mut self, mode: ShadowCastMode):
        let mode_var = variant.Variant::from_int(mode as i64)
        self.base.as_node().as_object().call1("set_cast_shadows_setting", mode_var)

# Camera2D - 2D camera control
pub struct Camera2D:
    base: node2d.Node2D

impl Camera2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera2D:
        return Camera2D(base: node2d.Node2D::from_ptr(ptr))

    # Make this camera current
    pub fn make_current(mut self):
        self.base.as_node().as_object().call0("make_current")

    pub fn is_current(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_current")
        return result.as_bool()

    # Zoom
    pub fn get_zoom(self) -> (f64, f64):
        let result = self.base.as_node().as_object().call0("get_zoom")
        return result.as_vector2()

    pub fn set_zoom(mut self, x: f64, y: f64):
        let zoom = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_zoom", zoom)

    # Offset
    pub fn set_offset(mut self, x: f64, y: f64):
        let offset = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_offset", offset)

    # Smoothing
    pub fn set_position_smoothing_enabled(mut self, enabled: bool):
        let enabled_var = variant.Variant::from_bool(enabled)
        self.base.as_node().as_object().call1("set_position_smoothing_enabled", enabled_var)

    pub fn set_position_smoothing_speed(mut self, speed: f64):
        let speed_var = variant.Variant::from_float(speed)
        self.base.as_node().as_object().call1("set_position_smoothing_speed", speed_var)

    # Limits
    pub fn set_limit_left(mut self, limit: i32):
        let limit_var = variant.Variant::from_int(limit as i64)
        self.base.as_node().as_object().call1("set_limit", limit_var)

# Camera3D - 3D camera control
pub struct Camera3D:
    base: node3d.Node3D

impl Camera3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera3D:
        return Camera3D(base: node3d.Node3D::from_ptr(ptr))

    # Make this camera current
    pub fn make_current(mut self):
        self.base.as_node().as_object().call0("make_current")

    pub fn is_current(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_current")
        return result.as_bool()

    # Projection
    pub fn set_projection(mut self, mode: ProjectionMode):
        let mode_var = variant.Variant::from_int(mode as i64)
        self.base.as_node().as_object().call1("set_projection", mode_var)

    # Field of view
    pub fn get_fov(self) -> f64:
        let result = self.base.as_node().as_object().call0("get_fov")
        return result.as_float()

    pub fn set_fov(mut self, fov: f64):
        let fov_var = variant.Variant::from_float(fov)
        self.base.as_node().as_object().call1("set_fov", fov_var)

    # Near/far planes
    pub fn set_near(mut self, near: f64):
        let near_var = variant.Variant::from_float(near)
        self.base.as_node().as_object().call1("set_near", near_var)

    pub fn set_far(mut self, far: f64):
        let far_var = variant.Variant::from_float(far)
        self.base.as_node().as_object().call1("set_far", far_var)

    # Look at target
    pub fn look_at(mut self, target_x: f64, target_y: f64, target_z: f64):
        let target = variant.Variant::from_vector3(target_x, target_y, target_z)
        let up = variant.Variant::from_vector3(0.0, 1.0, 0.0)
        self.base.as_node().as_object().call2("look_at", target, up)

# Enums
pub enum ShadowCastMode:
    Off = 0
    On = 1
    DoubleSided = 2
    ShadowsOnly = 3

impl ShadowCastMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert shadow cast mode to string."""
        match self:
            case Off: "off"
            case On: "on"
            case DoubleSided: "double_sided"
            case ShadowsOnly: "shadows_only"

    pub fn description(self) -> String:
        """Get shadow cast mode description."""
        match self:
            case Off: "No shadow casting"
            case On: "Cast shadows (single-sided)"
            case DoubleSided: "Cast shadows from both sides"
            case ShadowsOnly: "Only visible in shadows"

    pub fn is_off(self) -> bool:
        """Check if shadow casting is off."""
        match self:
            case Off: true
            case _: false

    pub fn casts_shadows(self) -> bool:
        """Check if mode casts shadows."""
        match self:
            case Off: false
            case _: true

    pub fn summary(self) -> String:
        """Get shadow cast mode summary."""
        let name = self.to_string()
        let desc = self.description()
        let status = if self.casts_shadows(): "casts shadows" else: "no shadows"
        return "ShadowCastMode: {name} ({desc}, {status})"

pub enum ProjectionMode:
    Perspective = 0
    Orthogonal = 1
    Frustum = 2

impl ProjectionMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert projection mode to string."""
        match self:
            case Perspective: "perspective"
            case Orthogonal: "orthogonal"
            case Frustum: "frustum"

    pub fn description(self) -> String:
        """Get projection mode description."""
        match self:
            case Perspective: "Perspective projection with depth"
            case Orthogonal: "Orthogonal projection (parallel)"
            case Frustum: "Custom frustum projection"

    pub fn is_perspective(self) -> bool:
        """Check if mode is Perspective."""
        match self:
            case Perspective: true
            case _: false

    pub fn has_depth(self) -> bool:
        """Check if projection has depth perception."""
        match self:
            case Orthogonal: false
            case _: true

    pub fn summary(self) -> String:
        """Get projection mode summary."""
        let name = self.to_string()
        let desc = self.description()
        let depth = if self.has_depth(): "has depth" else: "no depth"
        return "ProjectionMode: {name} ({desc}, {depth})"
