# Godot Rendering System
#
# Sprite rendering, mesh instances, and camera control.
#
# Reference: https://docs.godotengine.org/en/stable/classes/class_sprite2d.html

import godot.ffi
import godot.variant
import godot.object
import godot.node
import godot.node2d
import godot.node3d
import godot.resource

# Sprite2D - 2D sprite rendering
pub struct Sprite2D:
    base: node2d.Node2D

impl Sprite2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Sprite2D:
        return Sprite2D(base: node2d.Node2D::from_ptr(ptr))

    # Texture
    pub fn set_texture(mut self, texture: resource.Resource):
        val texture_var = variant.Variant::from_object(texture.as_object().ptr())
        self.base.as_node().as_object().call1("set_texture", texture_var)

    pub fn get_texture(self) -> Option[resource.Resource]:
        val result = self.base.as_node().as_object().call0("get_texture")
        val ptr = result.as_object()
        if ptr == 0:
            return None
        return Some(resource.Resource::from_ptr(ptr))

    # Visibility
    pub fn set_visible(mut self, visible: bool):
        val visible_var = variant.Variant::from_bool(visible)
        self.base.as_node().as_object().call1("set_visible", visible_var)

    pub fn is_visible(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_visible")
        return result.as_bool()

    # Modulate (color tint)
    pub fn set_modulate(mut self, r: f32, g: f32, b: f32, a: f32):
        val color = variant.Variant::from_color(r, g, b, a)
        self.base.as_node().as_object().call1("set_modulate", color)

    # Flip
    pub fn set_flip_h(mut self, flip: bool):
        val flip_var = variant.Variant::from_bool(flip)
        self.base.as_node().as_object().call1("set_flip_h", flip_var)

    pub fn set_flip_v(mut self, flip: bool):
        val flip_var = variant.Variant::from_bool(flip)
        self.base.as_node().as_object().call1("set_flip_v", flip_var)

    # Region (sprite sheet)
    pub fn set_region_enabled(mut self, enabled: bool):
        val enabled_var = variant.Variant::from_bool(enabled)
        self.base.as_node().as_object().call1("set_region_enabled", enabled_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn show(mut self):
        """Show the sprite (set visible to true).

        Example:
            sprite.show()
        """
        self.set_visible(true)

    pub fn hide(mut self):
        """Hide the sprite (set visible to false).

        Example:
            sprite.hide()
        """
        self.set_visible(false)

    pub fn is_hidden(self) -> bool:
        """Check if sprite is hidden (not visible).

        Returns:
            true if not visible

        Example:
            sprite.is_hidden()  # → false
        """
        return not self.is_visible()

    pub fn has_texture(self) -> bool:
        """Check if sprite has a texture assigned.

        Returns:
            true if texture is set

        Example:
            sprite.has_texture()  # → true
        """
        return self.get_texture().is_some()

    pub fn flip_horizontal(mut self):
        """Flip sprite horizontally.

        Example:
            sprite.flip_horizontal()
        """
        self.set_flip_h(true)

    pub fn unflip_horizontal(mut self):
        """Remove horizontal flip.

        Example:
            sprite.unflip_horizontal()
        """
        self.set_flip_h(false)

    pub fn flip_vertical(mut self):
        """Flip sprite vertically.

        Example:
            sprite.flip_vertical()
        """
        self.set_flip_v(true)

    pub fn unflip_vertical(mut self):
        """Remove vertical flip.

        Example:
            sprite.unflip_vertical()
        """
        self.set_flip_v(false)

    pub fn enable_region(mut self):
        """Enable sprite sheet region.

        Example:
            sprite.enable_region()
        """
        self.set_region_enabled(true)

    pub fn disable_region(mut self):
        """Disable sprite sheet region.

        Example:
            sprite.disable_region()
        """
        self.set_region_enabled(false)

    pub fn summary(self) -> String:
        """Get sprite 2D summary.

        Returns:
            Human-readable summary

        Example:
            sprite.summary()
            # → "Sprite2D: visible, has texture"
        """
        val vis = if self.is_visible() { "visible" } else { "hidden" }
        val tex = if self.has_texture() { "has texture" } else { "no texture" }
        return "Sprite2D: {vis}, {tex}"

# MeshInstance3D - 3D mesh rendering
pub struct MeshInstance3D:
    base: node3d.Node3D

impl MeshInstance3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> MeshInstance3D:
        return MeshInstance3D(base: node3d.Node3D::from_ptr(ptr))

    # Mesh
    pub fn set_mesh(mut self, mesh: resource.Resource):
        val mesh_var = variant.Variant::from_object(mesh.as_object().ptr())
        self.base.as_node().as_object().call1("set_mesh", mesh_var)

    pub fn get_mesh(self) -> Option[resource.Resource]:
        val result = self.base.as_node().as_object().call0("get_mesh")
        val ptr = result.as_object()
        if ptr == 0:
            return None
        return Some(resource.Resource::from_ptr(ptr))

    # Material override
    pub fn set_material_override(mut self, material: resource.Resource):
        val mat_var = variant.Variant::from_object(material.as_object().ptr())
        self.base.as_node().as_object().call1("set_material_override", mat_var)

    # Visibility
    pub fn set_visible(mut self, visible: bool):
        val visible_var = variant.Variant::from_bool(visible)
        self.base.as_node().as_object().call1("set_visible", visible_var)

    # Cast shadows
    pub fn set_cast_shadows_setting(mut self, mode: ShadowCastMode):
        val mode_var = variant.Variant::from_int(mode as i64)
        self.base.as_node().as_object().call1("set_cast_shadows_setting", mode_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn show(mut self):
        """Show the mesh (set visible to true).

        Example:
            mesh.show()
        """
        self.set_visible(true)

    pub fn hide(mut self):
        """Hide the mesh (set visible to false).

        Example:
            mesh.hide()
        """
        self.set_visible(false)

    pub fn has_mesh(self) -> bool:
        """Check if mesh instance has a mesh assigned.

        Returns:
            true if mesh is set

        Example:
            mesh.has_mesh()  # → true
        """
        return self.get_mesh().is_some()

    pub fn enable_shadows(mut self):
        """Enable shadow casting (single-sided).

        Example:
            mesh.enable_shadows()
        """
        self.set_cast_shadows_setting(ShadowCastMode::On)

    pub fn disable_shadows(mut self):
        """Disable shadow casting.

        Example:
            mesh.disable_shadows()
        """
        self.set_cast_shadows_setting(ShadowCastMode::Off)

    pub fn enable_double_sided_shadows(mut self):
        """Enable double-sided shadow casting.

        Example:
            mesh.enable_double_sided_shadows()
        """
        self.set_cast_shadows_setting(ShadowCastMode::DoubleSided)

    pub fn summary(self) -> String:
        """Get mesh instance 3D summary.

        Returns:
            Human-readable summary

        Example:
            mesh.summary()
            # → "MeshInstance3D: visible, has mesh"
        """
        val vis = if self.has_mesh() { "has mesh" } else { "no mesh" }
        return "MeshInstance3D: visible, {vis}"

# Camera2D - 2D camera control
pub struct Camera2D:
    base: node2d.Node2D

impl Camera2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera2D:
        return Camera2D(base: node2d.Node2D::from_ptr(ptr))

    # Make this camera current
    pub fn make_current(mut self):
        self.base.as_node().as_object().call0("make_current")

    pub fn is_current(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_current")
        return result.as_bool()

    # Zoom
    pub fn get_zoom(self) -> (f64, f64):
        val result = self.base.as_node().as_object().call0("get_zoom")
        return result.as_vector2()

    pub fn set_zoom(mut self, x: f64, y: f64):
        val zoom = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_zoom", zoom)

    # Offset
    pub fn set_offset(mut self, x: f64, y: f64):
        val offset = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_offset", offset)

    # Smoothing
    pub fn set_position_smoothing_enabled(mut self, enabled: bool):
        val enabled_var = variant.Variant::from_bool(enabled)
        self.base.as_node().as_object().call1("set_position_smoothing_enabled", enabled_var)

    pub fn set_position_smoothing_speed(mut self, speed: f64):
        val speed_var = variant.Variant::from_float(speed)
        self.base.as_node().as_object().call1("set_position_smoothing_speed", speed_var)

    # Limits
    pub fn set_limit_left(mut self, limit: i32):
        val limit_var = variant.Variant::from_int(limit as i64)
        self.base.as_node().as_object().call1("set_limit", limit_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn activate(mut self):
        """Make this camera the active camera (alias for make_current).

        Example:
            camera.activate()
        """
        self.make_current()

    pub fn is_active(self) -> bool:
        """Check if this camera is active (alias for is_current).

        Returns:
            true if active

        Example:
            camera.is_active()  # → true
        """
        return self.is_current()

    pub fn is_inactive(self) -> bool:
        """Check if this camera is inactive (not current).

        Returns:
            true if not active

        Example:
            camera.is_inactive()  # → false
        """
        return not self.is_current()

    pub fn enable_smoothing(mut self):
        """Enable position smoothing.

        Example:
            camera.enable_smoothing()
        """
        self.set_position_smoothing_enabled(true)

    pub fn disable_smoothing(mut self):
        """Disable position smoothing.

        Example:
            camera.disable_smoothing()
        """
        self.set_position_smoothing_enabled(false)

    pub fn summary(self) -> String:
        """Get camera 2D summary.

        Returns:
            Human-readable summary

        Example:
            camera.summary()
            # → "Camera2D: active, zoom=(2.0, 2.0)"
        """
        val status = if self.is_current() { "active" } else { "inactive" }
        val (zx, zy) = self.get_zoom()
        return "Camera2D: {status}, zoom=({zx}, {zy})"

# Camera3D - 3D camera control
pub struct Camera3D:
    base: node3d.Node3D

impl Camera3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera3D:
        return Camera3D(base: node3d.Node3D::from_ptr(ptr))

    # Make this camera current
    pub fn make_current(mut self):
        self.base.as_node().as_object().call0("make_current")

    pub fn is_current(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_current")
        return result.as_bool()

    # Projection
    pub fn set_projection(mut self, mode: ProjectionMode):
        val mode_var = variant.Variant::from_int(mode as i64)
        self.base.as_node().as_object().call1("set_projection", mode_var)

    # Field of view
    pub fn get_fov(self) -> f64:
        val result = self.base.as_node().as_object().call0("get_fov")
        return result.as_float()

    pub fn set_fov(mut self, fov: f64):
        val fov_var = variant.Variant::from_float(fov)
        self.base.as_node().as_object().call1("set_fov", fov_var)

    # Near/far planes
    pub fn set_near(mut self, near: f64):
        val near_var = variant.Variant::from_float(near)
        self.base.as_node().as_object().call1("set_near", near_var)

    pub fn set_far(mut self, far: f64):
        val far_var = variant.Variant::from_float(far)
        self.base.as_node().as_object().call1("set_far", far_var)

    # Look at target
    pub fn look_at(mut self, target_x: f64, target_y: f64, target_z: f64):
        val target = variant.Variant::from_vector3(target_x, target_y, target_z)
        val up = variant.Variant::from_vector3(0.0, 1.0, 0.0)
        self.base.as_node().as_object().call2("look_at", target, up)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn activate(mut self):
        """Make this camera the active camera (alias for make_current).

        Example:
            camera.activate()
        """
        self.make_current()

    pub fn is_active(self) -> bool:
        """Check if this camera is active (alias for is_current).

        Returns:
            true if active

        Example:
            camera.is_active()  # → true
        """
        return self.is_current()

    pub fn is_inactive(self) -> bool:
        """Check if this camera is inactive (not current).

        Returns:
            true if not active

        Example:
            camera.is_inactive()  # → false
        """
        return not self.is_current()

    pub fn set_perspective_projection(mut self):
        """Set camera to perspective projection.

        Example:
            camera.set_perspective_projection()
        """
        self.set_projection(ProjectionMode::Perspective)

    pub fn set_orthogonal_projection(mut self):
        """Set camera to orthogonal projection.

        Example:
            camera.set_orthogonal_projection()
        """
        self.set_projection(ProjectionMode::Orthogonal)

    pub fn summary(self) -> String:
        """Get camera 3D summary.

        Returns:
            Human-readable summary

        Example:
            camera.summary()
            # → "Camera3D: active, fov=75.0"
        """
        val status = if self.is_current() { "active" } else { "inactive" }
        val fov = self.get_fov()
        return "Camera3D: {status}, fov={fov}"

# Enums
pub enum ShadowCastMode:
    Off = 0
    On = 1
    DoubleSided = 2
    ShadowsOnly = 3

impl ShadowCastMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert shadow cast mode to string."""
        match self:
            case Off: "off"
            case On: "on"
            case DoubleSided: "double_sided"
            case ShadowsOnly: "shadows_only"

    pub fn description(self) -> String:
        """Get shadow cast mode description."""
        match self:
            case Off: "No shadow casting"
            case On: "Cast shadows (single-sided)"
            case DoubleSided: "Cast shadows from both sides"
            case ShadowsOnly: "Only visible in shadows"

    pub fn is_off(self) -> bool:
        """Check if shadow casting is off."""
        match self:
            case Off: true
            case _: false

    pub fn casts_shadows(self) -> bool:
        """Check if mode casts shadows."""
        match self:
            case Off: false
            case _: true

    pub fn summary(self) -> String:
        """Get shadow cast mode summary."""
        val name = self.to_string()
        val desc = self.description()
        val status = if self.casts_shadows(): "casts shadows" else: "no shadows"
        return "ShadowCastMode: {name} ({desc}, {status})"

pub enum ProjectionMode:
    Perspective = 0
    Orthogonal = 1
    Frustum = 2

impl ProjectionMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert projection mode to string."""
        match self:
            case Perspective: "perspective"
            case Orthogonal: "orthogonal"
            case Frustum: "frustum"

    pub fn description(self) -> String:
        """Get projection mode description."""
        match self:
            case Perspective: "Perspective projection with depth"
            case Orthogonal: "Orthogonal projection (parallel)"
            case Frustum: "Custom frustum projection"

    pub fn is_perspective(self) -> bool:
        """Check if mode is Perspective."""
        match self:
            case Perspective: true
            case _: false

    pub fn has_depth(self) -> bool:
        """Check if projection has depth perception."""
        match self:
            case Orthogonal: false
            case _: true

    pub fn summary(self) -> String:
        """Get projection mode summary."""
        val name = self.to_string()
        val desc = self.description()
        val depth = if self.has_depth(): "has depth" else: "no depth"
        return "ProjectionMode: {name} ({desc}, {depth})"
