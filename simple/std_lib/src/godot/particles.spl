# Godot Particle Systems
#
# Type-safe wrappers for Godot's particle systems
#
# Features:
# - GPUParticles2D (GPU-accelerated 2D particles)
# - CPUParticles2D (CPU-based 2D particles)
# - ParticleMaterial (particle behavior)
# - Emission shapes and parameters
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_gpuparticles2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.resource

mod particles

# GPU Particles 2D
# Hardware-accelerated particle system
pub struct GPUParticles2D extends godot.node2d.Node2D:

impl GPUParticles2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> GPUParticles2D:
        return GPUParticles2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set emitting state
    pub fn set_emitting(mut self, emitting: bool):
        val obj = self.base.as_node().as_object()
        val emit_var = variant.Variant::from_bool(emitting)
        obj.call1("set_emitting", emit_var)

    # Check if emitting
    pub fn is_emitting(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_emitting")
        return result.as_bool()

    # Set number of particles
    pub fn set_amount(mut self, amount: i32):
        val obj = self.base.as_node().as_object()
        val amount_var = variant.Variant::from_int(amount as i64)
        obj.call1("set_amount", amount_var)

    # Get number of particles
    pub fn get_amount(self) -> i32:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_amount")
        return result.as_int() as i32

    # Set particle lifetime
    pub fn set_lifetime(mut self, seconds: f64):
        val obj = self.base.as_node().as_object()
        val time_var = variant.Variant::from_float(seconds)
        obj.call1("set_lifetime", time_var)

    # Get particle lifetime
    pub fn get_lifetime(self) -> f64:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_lifetime")
        return result.as_float()

    # Set one-shot mode
    pub fn set_one_shot(mut self, enable: bool):
        val obj = self.base.as_node().as_object()
        val enable_var = variant.Variant::from_bool(enable)
        obj.call1("set_one_shot", enable_var)

    # Get one-shot mode
    pub fn is_one_shot(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_one_shot")
        return result.as_bool()

    # Set preprocess time (simulation warmup)
    pub fn set_pre_process_time(mut self, seconds: f64):
        val obj = self.base.as_node().as_object()
        val time_var = variant.Variant::from_float(seconds)
        obj.call1("set_pre_process_time", time_var)

    # Set particle speed scale
    pub fn set_speed_scale(mut self, scale: f64):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant::from_float(scale)
        obj.call1("set_speed_scale", scale_var)

    # Set process material (ParticleMaterial)
    pub fn set_process_material(mut self, material: resource.Resource):
        val obj = self.base.as_node().as_object()
        val mat_var = variant.Variant::from_object(material.as_object())
        obj.call1("set_process_material", mat_var)

    # Set texture for particles
    pub fn set_texture(mut self, texture: resource.Resource):
        val obj = self.base.as_node().as_object()
        val tex_var = variant.Variant::from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Restart emission
    pub fn restart(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("restart")

    # Set fixed FPS (0 = variable)
    pub fn set_fixed_fps(mut self, fps: i32):
        val obj = self.base.as_node().as_object()
        val fps_var = variant.Variant::from_int(fps as i64)
        obj.call1("set_fixed_fps", fps_var)

    # Set draw order
    pub fn set_draw_order(mut self, order: DrawOrder):
        val obj = self.base.as_node().as_object()
        val order_var = variant.Variant::from_int(order as i64)
        obj.call1("set_draw_order", order_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn start(mut self):
        """Start emitting particles.

        Example:
            particles.start()
        """
        self.set_emitting(true)

    pub fn stop(mut self):
        """Stop emitting particles.

        Example:
            particles.stop()
        """
        self.set_emitting(false)

    pub fn is_stopped(self) -> bool:
        """Check if particles are stopped (not emitting).

        Returns:
            true if not emitting

        Example:
            particles.is_stopped()  # → false
        """
        return not self.is_emitting()

    pub fn get_particle_count(self) -> i32:
        """Get number of particles (alias for get_amount).

        Returns:
            Particle count

        Example:
            particles.get_particle_count()  # → 100
        """
        return self.get_amount()

    pub fn enable_one_shot(mut self):
        """Enable one-shot mode.

        Example:
            particles.enable_one_shot()
        """
        self.set_one_shot(true)

    pub fn disable_one_shot(mut self):
        """Disable one-shot mode.

        Example:
            particles.disable_one_shot()
        """
        self.set_one_shot(false)

    pub fn summary(self) -> String:
        """Get GPU particles 2D summary.

        Returns:
            Human-readable summary

        Example:
            particles.summary()
            # → "GPUParticles2D: emitting, 100 particles"
        """
        val state = if self.is_emitting() { "emitting" } else { "stopped" }
        val count = self.get_amount()
        return "GPUParticles2D: {state}, {count} particles"


# CPU Particles 2D
# CPU-based particle system (fallback/lightweight)
pub struct CPUParticles2D extends godot.node2d.Node2D:

impl CPUParticles2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CPUParticles2D:
        return CPUParticles2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set emitting state
    pub fn set_emitting(mut self, emitting: bool):
        val obj = self.base.as_node().as_object()
        val emit_var = variant.Variant::from_bool(emitting)
        obj.call1("set_emitting", emit_var)

    # Check if emitting
    pub fn is_emitting(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_emitting")
        return result.as_bool()

    # Set number of particles
    pub fn set_amount(mut self, amount: i32):
        val obj = self.base.as_node().as_object()
        val amount_var = variant.Variant::from_int(amount as i64)
        obj.call1("set_amount", amount_var)

    # Set particle lifetime
    pub fn set_lifetime(mut self, seconds: f64):
        val obj = self.base.as_node().as_object()
        val time_var = variant.Variant::from_float(seconds)
        obj.call1("set_lifetime", time_var)

    # Set one-shot mode
    pub fn set_one_shot(mut self, enable: bool):
        val obj = self.base.as_node().as_object()
        val enable_var = variant.Variant::from_bool(enable)
        obj.call1("set_one_shot", enable_var)

    # Set emission shape
    pub fn set_emission_shape(mut self, shape: EmissionShape):
        val obj = self.base.as_node().as_object()
        val shape_var = variant.Variant::from_int(shape as i64)
        obj.call1("set_emission_shape", shape_var)

    # Set emission sphere radius
    pub fn set_emission_sphere_radius(mut self, radius: f32):
        val obj = self.base.as_node().as_object()
        val radius_var = variant.Variant::from_float(radius as f64)
        obj.call1("set_emission_sphere_radius", radius_var)

    # Set emission rect extents
    pub fn set_emission_rect_extents(mut self, width: f32, height: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # obj.call1("set_emission_rect_extents", extents_var)

    # Set direction
    pub fn set_direction(mut self, x: f32, y: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # obj.call1("set_direction", dir_var)

    # Set spread (angle in degrees)
    pub fn set_spread(mut self, degrees: f32):
        val obj = self.base.as_node().as_object()
        val spread_var = variant.Variant::from_float(degrees as f64)
        obj.call1("set_param", spread_var)

    # Set gravity
    pub fn set_gravity(mut self, x: f32, y: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant
        # obj.call1("set_gravity", gravity_var)

    # Set initial velocity (min/max)
    pub fn set_initial_velocity_min(mut self, velocity: f32):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant::from_float(velocity as f64)
        obj.call1("set_param_min", vel_var)

    pub fn set_initial_velocity_max(mut self, velocity: f32):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant::from_float(velocity as f64)
        obj.call1("set_param_max", vel_var)

    # Set angular velocity (rotation speed)
    pub fn set_angular_velocity_min(mut self, degrees_per_sec: f32):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant::from_float(degrees_per_sec as f64)
        # obj.call2("set_param_min", param_type, vel_var)

    # Set scale (particle size)
    pub fn set_scale_amount_min(mut self, scale: f32):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant::from_float(scale as f64)
        # obj.call2("set_param_min", param_type, scale_var)

    pub fn set_scale_amount_max(mut self, scale: f32):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant::from_float(scale as f64)
        # obj.call2("set_param_max", param_type, scale_var)

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32, a: f32):
        val obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Color variant
        # obj.call1("set_color", color_var)

    # Set texture
    pub fn set_texture(mut self, texture: resource.Resource):
        val obj = self.base.as_node().as_object()
        val tex_var = variant.Variant::from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Restart emission
    pub fn restart(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("restart")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn start(mut self):
        """Start emitting particles.

        Example:
            particles.start()
        """
        self.set_emitting(true)

    pub fn stop(mut self):
        """Stop emitting particles.

        Example:
            particles.stop()
        """
        self.set_emitting(false)

    pub fn is_stopped(self) -> bool:
        """Check if particles are stopped (not emitting).

        Returns:
            true if not emitting

        Example:
            particles.is_stopped()  # → false
        """
        return not self.is_emitting()

    pub fn enable_one_shot(mut self):
        """Enable one-shot mode.

        Example:
            particles.enable_one_shot()
        """
        self.set_one_shot(true)

    pub fn disable_one_shot(mut self):
        """Disable one-shot mode.

        Example:
            particles.disable_one_shot()
        """
        self.set_one_shot(false)

    pub fn summary(self) -> String:
        """Get CPU particles 2D summary.

        Returns:
            Human-readable summary

        Example:
            particles.summary()
            # → "CPUParticles2D: emitting"
        """
        val state = if self.is_emitting() { "emitting" } else { "stopped" }
        return "CPUParticles2D: {state}"


# Draw Order
pub enum DrawOrder:
    Index = 0       # By index
    Lifetime = 1    # By remaining lifetime
    ReverseLifetime = 2  # By elapsed time

impl DrawOrder:
    pub fn to_string(self) -> String:
        """Convert draw order to string."""
        match self:
            case Index: "index"
            case Lifetime: "lifetime"
            case ReverseLifetime: "reverse-lifetime"

    pub fn description(self) -> String:
        """Get draw order description."""
        match self:
            case Index: "Draw particles by creation index"
            case Lifetime: "Draw by remaining lifetime (oldest last)"
            case ReverseLifetime: "Draw by elapsed time (newest last)"

    pub fn is_index(self) -> bool:
        """Check if draw order is Index."""
        match self:
            case Index: true
            case _: false

    pub fn is_lifetime(self) -> bool:
        """Check if draw order is Lifetime."""
        match self:
            case Lifetime: true
            case _: false

    pub fn is_reverse_lifetime(self) -> bool:
        """Check if draw order is ReverseLifetime."""
        match self:
            case ReverseLifetime: true
            case _: false

    pub fn is_time_based(self) -> bool:
        """Check if draw order is time-based."""
        match self:
            case Lifetime: true
            case ReverseLifetime: true
            case _: false

    pub fn summary(self) -> String:
        """Get draw order summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_time_based():
            props.push("time-based")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "DrawOrder: {name} ({desc}, {props_str})"
        else:
            return "DrawOrder: {name} ({desc})"

# Emission Shape
pub enum EmissionShape:
    Point = 0       # Single point
    Sphere = 1      # Sphere/circle
    Box = 2         # Rectangle/box
    Points = 3      # Custom point cloud
    DirectedPoints = 4  # Points with direction

impl EmissionShape:
    pub fn to_string(self) -> String:
        """Convert emission shape to string."""
        match self:
            case Point: "point"
            case Sphere: "sphere"
            case Box: "box"
            case Points: "points"
            case DirectedPoints: "directed-points"

    pub fn description(self) -> String:
        """Get emission shape description."""
        match self:
            case Point: "Emit from single point"
            case Sphere: "Emit from sphere/circle surface"
            case Box: "Emit from box/rectangle volume"
            case Points: "Emit from custom point cloud"
            case DirectedPoints: "Emit from points with directional vectors"

    pub fn is_point(self) -> bool:
        """Check if emission shape is Point."""
        match self:
            case Point: true
            case _: false

    pub fn is_sphere(self) -> bool:
        """Check if emission shape is Sphere."""
        match self:
            case Sphere: true
            case _: false

    pub fn is_box(self) -> bool:
        """Check if emission shape is Box."""
        match self:
            case Box: true
            case _: false

    pub fn is_points(self) -> bool:
        """Check if emission shape is Points."""
        match self:
            case Points: true
            case _: false

    pub fn is_directed_points(self) -> bool:
        """Check if emission shape is DirectedPoints."""
        match self:
            case DirectedPoints: true
            case _: false

    pub fn uses_custom_points(self) -> bool:
        """Check if shape uses custom point cloud."""
        match self:
            case Points: true
            case DirectedPoints: true
            case _: false

    pub fn is_volumetric(self) -> bool:
        """Check if shape emits from volume."""
        match self:
            case Sphere: true
            case Box: true
            case _: false

    pub fn summary(self) -> String:
        """Get emission shape summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.uses_custom_points():
            props.push("custom points")
        if self.is_volumetric():
            props.push("volumetric")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "EmissionShape: {name} ({desc}, {props_str})"
        else:
            return "EmissionShape: {name} ({desc})"


# Particle Builder Helper
# Fluent API for creating particle systems
pub struct ParticleBuilder:
    particle_type: ParticleType
    amount: i32
    lifetime: f64
    one_shot: bool
    emission_shape: EmissionShape
    velocity_min: f32
    velocity_max: f32
    scale_min: f32
    scale_max: f32

impl ParticleBuilder:
    # Create new builder
    pub fn new(particle_type: ParticleType) -> ParticleBuilder:
        return ParticleBuilder(
            particle_type: particle_type,
            amount: 100,
            lifetime: 1.0,
            one_shot: false,
            emission_shape: EmissionShape::Point,
            velocity_min: 50.0,
            velocity_max: 100.0,
            scale_min: 1.0,
            scale_max: 1.0
        )

    # Set particle count
    pub fn with_amount(mut self, amount: i32) -> ParticleBuilder:
        self.amount = amount
        return self

    # Set lifetime
    pub fn with_lifetime(mut self, seconds: f64) -> ParticleBuilder:
        self.lifetime = seconds
        return self

    # Set one-shot mode
    pub fn one_shot(mut self) -> ParticleBuilder:
        self.one_shot = true
        return self

    # Set emission shape
    pub fn with_shape(mut self, shape: EmissionShape) -> ParticleBuilder:
        self.emission_shape = shape
        return self

    # Set velocity range
    pub fn with_velocity(mut self, min: f32, max: f32) -> ParticleBuilder:
        self.velocity_min = min
        self.velocity_max = max
        return self

    # Set scale range
    pub fn with_scale(mut self, min: f32, max: f32) -> ParticleBuilder:
        self.scale_min = min
        self.scale_max = max
        return self

    # Build and configure particle system
    pub fn apply_to_gpu(self, mut particles: GPUParticles2D):
        particles.set_amount(self.amount)
        particles.set_lifetime(self.lifetime)
        particles.set_one_shot(self.one_shot)
        particles.set_emitting(true)

    pub fn apply_to_cpu(self, mut particles: CPUParticles2D):
        particles.set_amount(self.amount)
        particles.set_lifetime(self.lifetime)
        particles.set_one_shot(self.one_shot)
        particles.set_emission_shape(self.emission_shape)
        particles.set_initial_velocity_min(self.velocity_min)
        particles.set_initial_velocity_max(self.velocity_max)
        particles.set_scale_amount_min(self.scale_min)
        particles.set_scale_amount_max(self.scale_max)
        particles.set_emitting(true)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_amount(self) -> i32:
        """Get particle count.

        Returns:
            Particle count

        Example:
            builder.get_amount()  # → 100
        """
        return self.amount

    pub fn get_lifetime(self) -> f64:
        """Get particle lifetime in seconds.

        Returns:
            Lifetime in seconds

        Example:
            builder.get_lifetime()  # → 1.0
        """
        return self.lifetime

    pub fn get_emission_shape(self) -> EmissionShape:
        """Get emission shape.

        Returns:
            Emission shape

        Example:
            builder.get_emission_shape()  # → EmissionShape::Point
        """
        return self.emission_shape

    pub fn get_velocity_range(self) -> (f32, f32):
        """Get velocity range (min, max).

        Returns:
            Tuple of (min, max) velocity

        Example:
            builder.get_velocity_range()  # → (50.0, 100.0)
        """
        return (self.velocity_min, self.velocity_max)

    pub fn get_scale_range(self) -> (f32, f32):
        """Get scale range (min, max).

        Returns:
            Tuple of (min, max) scale

        Example:
            builder.get_scale_range()  # → (1.0, 1.0)
        """
        return (self.scale_min, self.scale_max)

    pub fn is_one_shot(self) -> bool:
        """Check if one-shot mode is enabled.

        Returns:
            true if one-shot mode

        Example:
            builder.is_one_shot()  # → false
        """
        return self.one_shot

    pub fn is_continuous(self) -> bool:
        """Check if continuous emission mode.

        Returns:
            true if not one-shot

        Example:
            builder.is_continuous()  # → true
        """
        return not self.one_shot

    pub fn is_gpu(self) -> bool:
        """Check if GPU particle type.

        Returns:
            true if GPU type

        Example:
            builder.is_gpu()  # → true
        """
        return self.particle_type.is_gpu()

    pub fn is_cpu(self) -> bool:
        """Check if CPU particle type.

        Returns:
            true if CPU type

        Example:
            builder.is_cpu()  # → false
        """
        return self.particle_type.is_cpu()

    pub fn has_velocity_variation(self) -> bool:
        """Check if velocity has variation (min != max).

        Returns:
            true if velocity varies

        Example:
            builder.has_velocity_variation()  # → true
        """
        return self.velocity_min != self.velocity_max

    pub fn has_scale_variation(self) -> bool:
        """Check if scale has variation (min != max).

        Returns:
            true if scale varies

        Example:
            builder.has_scale_variation()  # → false
        """
        return self.scale_min != self.scale_max

    pub fn summary(self) -> String:
        """Get particle builder summary.

        Returns:
            Human-readable summary

        Example:
            builder.summary()
            # → "ParticleBuilder: GPU, 100 particles, 1.0s lifetime, continuous, point emission"
        """
        val ptype = self.particle_type.to_string()
        val mode = if self.one_shot { "one-shot" } else { "continuous" }
        val shape = self.emission_shape.to_string()
        return "ParticleBuilder: {ptype}, {self.amount} particles, {self.lifetime}s lifetime, {mode}, {shape} emission"


# Particle type selector
pub enum ParticleType:
    GPU
    CPU

impl ParticleType:
    pub fn to_string(self) -> String:
        """Convert particle type to string."""
        match self:
            case GPU: "GPU"
            case CPU: "CPU"

    pub fn description(self) -> String:
        """Get particle type description."""
        match self:
            case GPU: "GPU-accelerated particles (fast, many particles)"
            case CPU: "CPU-simulated particles (flexible, fewer particles)"

    pub fn is_gpu(self) -> bool:
        """Check if particle type is GPU."""
        match self:
            case GPU: true
            case _: false

    pub fn is_cpu(self) -> bool:
        """Check if particle type is CPU."""
        match self:
            case CPU: true
            case _: false

    pub fn is_hardware_accelerated(self) -> bool:
        """Check if type uses hardware acceleration."""
        match self:
            case GPU: true
            case _: false

    pub fn summary(self) -> String:
        """Get particle type summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_hardware_accelerated():
            props.push("hardware accelerated")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ParticleType: {name} ({desc}, {props_str})"
        else:
            return "ParticleType: {name} ({desc})"


# Preset particle effects

# Explosion effect
pub fn create_explosion() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::GPU)
        .with_amount(200)
        .with_lifetime(0.8)
        .one_shot()
        .with_shape(EmissionShape::Sphere)
        .with_velocity(150.0, 300.0)
        .with_scale(0.5, 1.5)

# Fire effect
pub fn create_fire() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::GPU)
        .with_amount(50)
        .with_lifetime(1.2)
        .with_shape(EmissionShape::Point)
        .with_velocity(20.0, 50.0)
        .with_scale(0.8, 1.2)

# Smoke effect
pub fn create_smoke() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::CPU)
        .with_amount(30)
        .with_lifetime(2.0)
        .with_shape(EmissionShape::Sphere)
        .with_velocity(10.0, 30.0)
        .with_scale(1.0, 2.0)

# Rain effect
pub fn create_rain() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::GPU)
        .with_amount(500)
        .with_lifetime(3.0)
        .with_shape(EmissionShape::Box)
        .with_velocity(200.0, 250.0)
        .with_scale(0.1, 0.3)

# Snow effect
pub fn create_snow() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::CPU)
        .with_amount(300)
        .with_lifetime(5.0)
        .with_shape(EmissionShape::Box)
        .with_velocity(20.0, 40.0)
        .with_scale(0.3, 0.7)
