# Godot Particle Systems
#
# Type-safe wrappers for Godot's particle systems
#
# Features:
# - GPUParticles2D (GPU-accelerated 2D particles)
# - CPUParticles2D (CPU-based 2D particles)
# - ParticleMaterial (particle behavior)
# - Emission shapes and parameters
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_gpuparticles2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.resource

mod particles

# GPU Particles 2D
# Hardware-accelerated particle system
pub struct GPUParticles2D extends godot.node2d.Node2D:

impl GPUParticles2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> GPUParticles2D:
        return GPUParticles2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set emitting state
    pub fn set_emitting(mut self, emitting: bool):
        let obj = self.base.as_node().as_object()
        let emit_var = variant.Variant::from_bool(emitting)
        obj.call1("set_emitting", emit_var)

    # Check if emitting
    pub fn is_emitting(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_emitting")
        return result.as_bool()

    # Set number of particles
    pub fn set_amount(mut self, amount: i32):
        let obj = self.base.as_node().as_object()
        let amount_var = variant.Variant::from_int(amount as i64)
        obj.call1("set_amount", amount_var)

    # Get number of particles
    pub fn get_amount(self) -> i32:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_amount")
        return result.as_int() as i32

    # Set particle lifetime
    pub fn set_lifetime(mut self, seconds: f64):
        let obj = self.base.as_node().as_object()
        let time_var = variant.Variant::from_float(seconds)
        obj.call1("set_lifetime", time_var)

    # Get particle lifetime
    pub fn get_lifetime(self) -> f64:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_lifetime")
        return result.as_float()

    # Set one-shot mode
    pub fn set_one_shot(mut self, enable: bool):
        let obj = self.base.as_node().as_object()
        let enable_var = variant.Variant::from_bool(enable)
        obj.call1("set_one_shot", enable_var)

    # Get one-shot mode
    pub fn is_one_shot(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_one_shot")
        return result.as_bool()

    # Set preprocess time (simulation warmup)
    pub fn set_pre_process_time(mut self, seconds: f64):
        let obj = self.base.as_node().as_object()
        let time_var = variant.Variant::from_float(seconds)
        obj.call1("set_pre_process_time", time_var)

    # Set particle speed scale
    pub fn set_speed_scale(mut self, scale: f64):
        let obj = self.base.as_node().as_object()
        let scale_var = variant.Variant::from_float(scale)
        obj.call1("set_speed_scale", scale_var)

    # Set process material (ParticleMaterial)
    pub fn set_process_material(mut self, material: resource.Resource):
        let obj = self.base.as_node().as_object()
        let mat_var = variant.Variant::from_object(material.as_object())
        obj.call1("set_process_material", mat_var)

    # Set texture for particles
    pub fn set_texture(mut self, texture: resource.Resource):
        let obj = self.base.as_node().as_object()
        let tex_var = variant.Variant::from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Restart emission
    pub fn restart(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("restart")

    # Set fixed FPS (0 = variable)
    pub fn set_fixed_fps(mut self, fps: i32):
        let obj = self.base.as_node().as_object()
        let fps_var = variant.Variant::from_int(fps as i64)
        obj.call1("set_fixed_fps", fps_var)

    # Set draw order
    pub fn set_draw_order(mut self, order: DrawOrder):
        let obj = self.base.as_node().as_object()
        let order_var = variant.Variant::from_int(order as i64)
        obj.call1("set_draw_order", order_var)


# CPU Particles 2D
# CPU-based particle system (fallback/lightweight)
pub struct CPUParticles2D extends godot.node2d.Node2D:

impl CPUParticles2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CPUParticles2D:
        return CPUParticles2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set emitting state
    pub fn set_emitting(mut self, emitting: bool):
        let obj = self.base.as_node().as_object()
        let emit_var = variant.Variant::from_bool(emitting)
        obj.call1("set_emitting", emit_var)

    # Check if emitting
    pub fn is_emitting(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_emitting")
        return result.as_bool()

    # Set number of particles
    pub fn set_amount(mut self, amount: i32):
        let obj = self.base.as_node().as_object()
        let amount_var = variant.Variant::from_int(amount as i64)
        obj.call1("set_amount", amount_var)

    # Set particle lifetime
    pub fn set_lifetime(mut self, seconds: f64):
        let obj = self.base.as_node().as_object()
        let time_var = variant.Variant::from_float(seconds)
        obj.call1("set_lifetime", time_var)

    # Set one-shot mode
    pub fn set_one_shot(mut self, enable: bool):
        let obj = self.base.as_node().as_object()
        let enable_var = variant.Variant::from_bool(enable)
        obj.call1("set_one_shot", enable_var)

    # Set emission shape
    pub fn set_emission_shape(mut self, shape: EmissionShape):
        let obj = self.base.as_node().as_object()
        let shape_var = variant.Variant::from_int(shape as i64)
        obj.call1("set_emission_shape", shape_var)

    # Set emission sphere radius
    pub fn set_emission_sphere_radius(mut self, radius: f32):
        let obj = self.base.as_node().as_object()
        let radius_var = variant.Variant::from_float(radius as f64)
        obj.call1("set_emission_sphere_radius", radius_var)

    # Set emission rect extents
    pub fn set_emission_rect_extents(mut self, width: f32, height: f32):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector2 variant
        # obj.call1("set_emission_rect_extents", extents_var)

    # Set direction
    pub fn set_direction(mut self, x: f32, y: f32):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector2 variant
        # obj.call1("set_direction", dir_var)

    # Set spread (angle in degrees)
    pub fn set_spread(mut self, degrees: f32):
        let obj = self.base.as_node().as_object()
        let spread_var = variant.Variant::from_float(degrees as f64)
        obj.call1("set_param", spread_var)

    # Set gravity
    pub fn set_gravity(mut self, x: f32, y: f32):
        let obj = self.base.as_node().as_object()
        # TODO: Create Vector2 variant
        # obj.call1("set_gravity", gravity_var)

    # Set initial velocity (min/max)
    pub fn set_initial_velocity_min(mut self, velocity: f32):
        let obj = self.base.as_node().as_object()
        let vel_var = variant.Variant::from_float(velocity as f64)
        obj.call1("set_param_min", vel_var)

    pub fn set_initial_velocity_max(mut self, velocity: f32):
        let obj = self.base.as_node().as_object()
        let vel_var = variant.Variant::from_float(velocity as f64)
        obj.call1("set_param_max", vel_var)

    # Set angular velocity (rotation speed)
    pub fn set_angular_velocity_min(mut self, degrees_per_sec: f32):
        let obj = self.base.as_node().as_object()
        let vel_var = variant.Variant::from_float(degrees_per_sec as f64)
        # obj.call2("set_param_min", param_type, vel_var)

    # Set scale (particle size)
    pub fn set_scale_amount_min(mut self, scale: f32):
        let obj = self.base.as_node().as_object()
        let scale_var = variant.Variant::from_float(scale as f64)
        # obj.call2("set_param_min", param_type, scale_var)

    pub fn set_scale_amount_max(mut self, scale: f32):
        let obj = self.base.as_node().as_object()
        let scale_var = variant.Variant::from_float(scale as f64)
        # obj.call2("set_param_max", param_type, scale_var)

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32, a: f32):
        let obj = self.base.as_node().as_object()
        # TODO: Create Color variant
        # obj.call1("set_color", color_var)

    # Set texture
    pub fn set_texture(mut self, texture: resource.Resource):
        let obj = self.base.as_node().as_object()
        let tex_var = variant.Variant::from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Restart emission
    pub fn restart(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("restart")


# Draw Order
pub enum DrawOrder:
    Index = 0       # By index
    Lifetime = 1    # By remaining lifetime
    ReverseLifetime = 2  # By elapsed time

# Emission Shape
pub enum EmissionShape:
    Point = 0       # Single point
    Sphere = 1      # Sphere/circle
    Box = 2         # Rectangle/box
    Points = 3      # Custom point cloud
    DirectedPoints = 4  # Points with direction


# Particle Builder Helper
# Fluent API for creating particle systems
pub struct ParticleBuilder:
    particle_type: ParticleType
    amount: i32
    lifetime: f64
    one_shot: bool
    emission_shape: EmissionShape
    velocity_min: f32
    velocity_max: f32
    scale_min: f32
    scale_max: f32

impl ParticleBuilder:
    # Create new builder
    pub fn new(particle_type: ParticleType) -> ParticleBuilder:
        return ParticleBuilder(
            particle_type: particle_type,
            amount: 100,
            lifetime: 1.0,
            one_shot: false,
            emission_shape: EmissionShape::Point,
            velocity_min: 50.0,
            velocity_max: 100.0,
            scale_min: 1.0,
            scale_max: 1.0
        )

    # Set particle count
    pub fn with_amount(mut self, amount: i32) -> ParticleBuilder:
        self.amount = amount
        return self

    # Set lifetime
    pub fn with_lifetime(mut self, seconds: f64) -> ParticleBuilder:
        self.lifetime = seconds
        return self

    # Set one-shot mode
    pub fn one_shot(mut self) -> ParticleBuilder:
        self.one_shot = true
        return self

    # Set emission shape
    pub fn with_shape(mut self, shape: EmissionShape) -> ParticleBuilder:
        self.emission_shape = shape
        return self

    # Set velocity range
    pub fn with_velocity(mut self, min: f32, max: f32) -> ParticleBuilder:
        self.velocity_min = min
        self.velocity_max = max
        return self

    # Set scale range
    pub fn with_scale(mut self, min: f32, max: f32) -> ParticleBuilder:
        self.scale_min = min
        self.scale_max = max
        return self

    # Build and configure particle system
    pub fn apply_to_gpu(self, mut particles: GPUParticles2D):
        particles.set_amount(self.amount)
        particles.set_lifetime(self.lifetime)
        particles.set_one_shot(self.one_shot)
        particles.set_emitting(true)

    pub fn apply_to_cpu(self, mut particles: CPUParticles2D):
        particles.set_amount(self.amount)
        particles.set_lifetime(self.lifetime)
        particles.set_one_shot(self.one_shot)
        particles.set_emission_shape(self.emission_shape)
        particles.set_initial_velocity_min(self.velocity_min)
        particles.set_initial_velocity_max(self.velocity_max)
        particles.set_scale_amount_min(self.scale_min)
        particles.set_scale_amount_max(self.scale_max)
        particles.set_emitting(true)


# Particle type selector
pub enum ParticleType:
    GPU
    CPU


# Preset particle effects

# Explosion effect
pub fn create_explosion() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::GPU)
        .with_amount(200)
        .with_lifetime(0.8)
        .one_shot()
        .with_shape(EmissionShape::Sphere)
        .with_velocity(150.0, 300.0)
        .with_scale(0.5, 1.5)

# Fire effect
pub fn create_fire() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::GPU)
        .with_amount(50)
        .with_lifetime(1.2)
        .with_shape(EmissionShape::Point)
        .with_velocity(20.0, 50.0)
        .with_scale(0.8, 1.2)

# Smoke effect
pub fn create_smoke() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::CPU)
        .with_amount(30)
        .with_lifetime(2.0)
        .with_shape(EmissionShape::Sphere)
        .with_velocity(10.0, 30.0)
        .with_scale(1.0, 2.0)

# Rain effect
pub fn create_rain() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::GPU)
        .with_amount(500)
        .with_lifetime(3.0)
        .with_shape(EmissionShape::Box)
        .with_velocity(200.0, 250.0)
        .with_scale(0.1, 0.3)

# Snow effect
pub fn create_snow() -> ParticleBuilder:
    return ParticleBuilder::new(ParticleType::CPU)
        .with_amount(300)
        .with_lifetime(5.0)
        .with_shape(EmissionShape::Box)
        .with_velocity(20.0, 40.0)
        .with_scale(0.3, 0.7)
