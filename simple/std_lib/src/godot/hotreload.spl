# Godot Hot-Reload Support
#
# Live code and resource reloading without restarting the game
#
# Features:
# - File watching and change detection
# - Simple script recompilation
# - Resource hot-reloading
# - State preservation during reload
# - Development mode controls
#
# Based on: Simple's watch system + Godot's resource system

import godot.ffi
import godot.variant
import godot.node
import godot.scene
import godot.resource
import sys.fs
import sys.time

mod hotreload

# Hot Reload Watcher
# Monitors files and triggers reloads on changes
pub struct HotReloadWatcher:
    watched_files: Dict[String, f64]  # path -> last_modified_time
    reload_callbacks: Array[fn(String)]  # Callbacks to call on reload
    enabled: bool
    check_interval: f64  # Seconds between checks
    last_check: f64      # Last check timestamp

impl HotReloadWatcher:
    # Create new watcher
    pub fn new(check_interval: f64 = 0.5) -> HotReloadWatcher:
        return HotReloadWatcher(
            watched_files: {},
            reload_callbacks: [],
            enabled: true,
            check_interval: check_interval,
            last_check: 0.0
        )

    # Watch a file for changes
    pub fn watch_file(mut self, path: String):
        # Get current modification time
        let mod_time = get_file_modified_time(path)
        self.watched_files[path] = mod_time
        
        println(f"Watching file: {path}")

    # Watch a directory recursively
    pub fn watch_directory(mut self, dir_path: String, extension: String = ".spl"):
        # Get all files in directory with extension
        let files = get_files_recursive(dir_path, extension)
        
        for file in files:
            self.watch_file(file)

    # Add reload callback
    pub fn on_reload(mut self, callback: fn(String)):
        self.reload_callbacks.push(callback)

    # Check for file changes (call from _process)
    pub fn check_for_changes(mut self, current_time: f64):
        if not self.enabled:
            return

        # Rate limiting
        if current_time - self.last_check < self.check_interval:
            return

        self.last_check = current_time

        # Check each watched file
        for (path, last_time) in self.watched_files.items():
            let current_mod_time = get_file_modified_time(path)

            if current_mod_time > last_time:
                # File was modified
                println(f"File changed: {path}")
                
                # Update stored time
                self.watched_files[path] = current_mod_time

                # Trigger reload
                self.trigger_reload(path)

    # Trigger reload for a file
    fn trigger_reload(mut self, path: String):
        println(f"Hot-reloading: {path}")

        # Call all callbacks
        for callback in self.reload_callbacks:
            callback(path)

    # Enable/disable watching
    pub fn set_enabled(mut self, enabled: bool):
        self.enabled = enabled
        
        if enabled:
            println("Hot-reload enabled")
        else:
            println("Hot-reload disabled")

    # Clear all watched files
    pub fn clear(mut self):
        self.watched_files.clear()
        println("Cleared watch list")


# Hot Reload Manager for Godot
# Integrates file watching with Godot's scene tree
pub struct HotReloadManager extends godot.node.Node:
    watcher: HotReloadWatcher
    simple_compiler_path: String  # Path to Simple compiler
    scene_tree: godot.scene.SceneTree

    # State preservation
    preserve_state: bool
    saved_state: Dict[String, variant.Variant]

    pub fn _ready(mut self):
        println("Hot-Reload Manager ready!")

        # Initialize watcher
        self.watcher = HotReloadWatcher::new(0.5)
        self.scene_tree = godot.scene.SceneTree::get_singleton()
        self.preserve_state = true
        self.saved_state = {}

        # Set up reload callback
        self.watcher.on_reload(|path| {
            self.on_file_changed(path)
        })

        # Watch project directories
        self.watch_project_directories()

        println("Hot-reload enabled. Watching for file changes...")

    # Watch common project directories
    fn watch_project_directories(mut self):
        # Watch Simple scripts
        self.watcher.watch_directory("res://scripts", ".spl")
        
        # Watch scenes (for resource reloading)
        self.watcher.watch_directory("res://scenes", ".tscn")

        println(f"Watching {self.watcher.watched_files.len()} files")

    # Called every frame
    pub fn _process(mut self, delta: f64):
        # Check for file changes
        let current_time = get_current_time()
        self.watcher.check_for_changes(current_time)

    # Handle file change event
    fn on_file_changed(mut self, path: String):
        if path.ends_with(".spl"):
            # Simple script changed - recompile
            self.reload_simple_script(path)
        elif path.ends_with(".tscn") or path.ends_with(".tres"):
            # Scene or resource changed - reload
            self.reload_godot_resource(path)

    # Recompile and reload Simple script
    fn reload_simple_script(mut self, script_path: String):
        println(f"Recompiling Simple script: {script_path}")

        # Save current state if enabled
        if self.preserve_state:
            self.save_scene_state()

        # Recompile using Simple compiler
        let compile_result = self.compile_simple_script(script_path)

        if compile_result.is_ok():
            println(f"Successfully recompiled: {script_path}")

            # Reload current scene to use new script
            let reload_result = self.scene_tree.reload_current_scene()

            if reload_result.is_ok():
                # Restore state after reload
                if self.preserve_state:
                    self.restore_scene_state()

                println("Scene reloaded with new script")
            else:
                println(f"Error reloading scene: {reload_result.unwrap_err()}")
        else:
            println(f"Compilation error: {compile_result.unwrap_err()}")

    # Compile Simple script
    fn compile_simple_script(self, script_path: String) -> Result[(), String]:
        # TODO: Call Simple compiler
        # For now, just simulate compilation
        
        # In real implementation:
        # 1. Call `simple build --hot-reload script_path`
        # 2. Compiler generates .smf in build/
        # 3. Return Ok if successful, Err with message if failed

        # Simulate compilation delay
        # await sleep(0.1)

        return Ok(())

    # Reload Godot resource (scene, texture, etc.)
    fn reload_godot_resource(mut self, resource_path: String):
        println(f"Reloading Godot resource: {resource_path}")

        # Force Godot to reload the resource from disk
        let loader = godot.resource.ResourceLoader::get_singleton()
        
        # Clear from cache
        # loader.clear_cache(resource_path)  # TODO: Add to ResourceLoader

        # If it's the current scene, reload it
        if resource_path.ends_with(".tscn"):
            if self.preserve_state:
                self.save_scene_state()

            let result = self.scene_tree.reload_current_scene()

            if result.is_ok():
                if self.preserve_state:
                    self.restore_scene_state()
                println("Scene hot-reloaded")
            else:
                println(f"Error reloading scene: {result.unwrap_err()}")

    # Save current scene state (for state preservation)
    fn save_scene_state(mut self):
        println("Saving scene state...")

        # Get current scene root
        let current = self.scene_tree.get_current_scene()

        if current.is_none():
            return

        let root = current.unwrap()

        # TODO: Walk scene tree and save state
        # For now, just save a simple marker
        self.saved_state["scene_loaded"] = variant.Variant::from_bool(true)

        println("State saved")

    # Restore scene state (after reload)
    fn restore_scene_state(mut self):
        println("Restoring scene state...")

        # TODO: Restore saved state to scene nodes
        
        println("State restored")

    # Enable/disable hot-reload
    pub fn set_enabled(mut self, enabled: bool):
        self.watcher.set_enabled(enabled)

    # Toggle state preservation
    pub fn set_preserve_state(mut self, preserve: bool):
        self.preserve_state = preserve

        if preserve:
            println("State preservation enabled")
        else:
            println("State preservation disabled")


# Helper functions (placeholders)

fn get_file_modified_time(path: String) -> f64:
    # TODO: Implement actual file stat
    # For now, return current time as placeholder
    return get_current_time()

fn get_files_recursive(dir: String, ext: String) -> Array[String]:
    # TODO: Implement recursive directory traversal
    # For now, return empty array
    return []

fn get_current_time() -> f64:
    # TODO: Use actual time API
    # For now, return placeholder
    return 0.0

fn sleep(seconds: f64):
    # TODO: Implement actual sleep
    pass


# Dict and Array placeholders
pub struct Dict[K, V]:
    dummy: i32

impl[K, V] Dict[K, V]:
    pub fn clear(mut self):
        pass

    pub fn len(self) -> i32:
        return 0

    pub fn items(self) -> Array[(K, V)]:
        return []

pub struct Array[T]:
    items: Vec[T]

impl[T] Array[T]:
    pub fn push(mut self, item: T):
        pass
