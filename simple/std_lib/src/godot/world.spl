# Godot World System
#
# Type-safe wrappers for Godot's world resources
#
# Features:
# - World2D (2D physics and rendering space)
# - World3D (3D physics and rendering space)
# - RenderingServer integration
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_world3d.html

import godot.ffi
import godot.variant
import godot.resource

mod world

# World2D
# 2D physics and rendering space
pub struct World2D:
    resource: resource.Resource

impl World2D:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> World2D:
        return World2D(resource: res)

    # Create new world
    pub fn new() -> World2D:
        let ptr = ffi.godot_new_object("World2D")
        let res = resource.Resource::from_ptr(ptr)
        return World2D::from_resource(res)

    # Get canvas RID (for low-level rendering)
    pub fn get_canvas(self) -> RID:
        let obj = self.resource.as_object()
        let result = obj.call0("get_canvas")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get space RID (for physics queries)
    pub fn get_space(self) -> RID:
        let obj = self.resource.as_object()
        let result = obj.call0("get_space")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder


# World3D
# 3D physics and rendering space
pub struct World3D:
    resource: resource.Resource

impl World3D:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> World3D:
        return World3D(resource: res)

    # Create new world
    pub fn new() -> World3D:
        let ptr = ffi.godot_new_object("World3D")
        let res = resource.Resource::from_ptr(ptr)
        return World3D::from_resource(res)

    # Get scenario RID (for rendering)
    pub fn get_scenario(self) -> RID:
        let obj = self.resource.as_object()
        let result = obj.call0("get_scenario")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get space RID (for physics queries)
    pub fn get_space(self) -> RID:
        let obj = self.resource.as_object()
        let result = obj.call0("get_space")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get environment
    pub fn get_environment(self) -> Option[godot.resource.Resource]:
        let obj = self.resource.as_object()
        let result = obj.call0("get_environment")

        if result.is_null():
            return None
        else:
            let res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(res)

    # Set environment
    pub fn set_environment(mut self, env: godot.resource.Resource):
        let obj = self.resource.as_object()
        let env_var = variant.Variant::from_object(env.as_object())
        obj.call1("set_environment", env_var)

    # Get fallback environment
    pub fn get_fallback_environment(self) -> Option[godot.resource.Resource]:
        let obj = self.resource.as_object()
        let result = obj.call0("get_fallback_environment")

        if result.is_null():
            return None
        else:
            let res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(res)

    # Set fallback environment
    pub fn set_fallback_environment(mut self, env: godot.resource.Resource):
        let obj = self.resource.as_object()
        let env_var = variant.Variant::from_object(env.as_object())
        obj.call1("set_fallback_environment", env_var)

    # Get camera effects
    pub fn get_camera_attributes(self) -> Option[godot.resource.Resource]:
        let obj = self.resource.as_object()
        let result = obj.call0("get_camera_attributes")

        if result.is_null():
            return None
        else:
            let res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(res)

    # Set camera effects
    pub fn set_camera_attributes(mut self, attributes: godot.resource.Resource):
        let obj = self.resource.as_object()
        let attr_var = variant.Variant::from_object(attributes.as_object())
        obj.call1("set_camera_attributes", attr_var)


# RID (Resource ID)
# Opaque handle to low-level Godot resource
pub struct RID:
    id: u64

impl RID:
    # Create from ID
    pub fn from_id(id: u64) -> RID:
        return RID(id: id)

    # Get ID
    pub fn get_id(self) -> u64:
        return self.id

    # Check if valid
    pub fn is_valid(self) -> bool:
        return self.id != 0


# RenderingServer
# Low-level rendering API (singleton)
pub struct RenderingServer:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl RenderingServer:
    # Get singleton
    pub fn get_singleton() -> RenderingServer:
        let ptr = ffi.godot_get_singleton("RenderingServer")
        return RenderingServer(singleton_ptr: ptr)

    # Get white texture (useful for debugging)
    pub fn get_white_texture(self) -> RID:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_white_texture")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get test texture (checkerboard pattern)
    pub fn get_test_texture(self) -> RID:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_test_texture")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Force draw (useful for debugging/profiling)
    pub fn force_draw(mut self, swap_buffers: bool = true):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let swap_var = variant.Variant::from_bool(swap_buffers)
        obj.call1("force_draw", swap_var)

    # Get rendering info
    pub fn get_rendering_info(self, info: RenderingInfo) -> i64:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let info_var = variant.Variant::from_int(info as i64)
        let result = obj.call1("get_rendering_info", info_var)
        return result.as_int()


# PhysicsServer3D
# Low-level 3D physics API (singleton)
pub struct PhysicsServer3D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl PhysicsServer3D:
    # Get singleton
    pub fn get_singleton() -> PhysicsServer3D:
        let ptr = ffi.godot_get_singleton("PhysicsServer3D")
        return PhysicsServer3D(singleton_ptr: ptr)

    # Set active (enable/disable physics)
    pub fn set_active(mut self, active: bool):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let active_var = variant.Variant::from_bool(active)
        obj.call1("set_active", active_var)

    # Get process info
    pub fn get_process_info(self, info: ProcessInfo) -> i32:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let info_var = variant.Variant::from_int(info as i64)
        let result = obj.call1("get_process_info", info_var)
        return result.as_int() as i32


# Enums

pub enum RenderingInfo:
    TotalObjectsInFrame = 0      # Total visible objects
    TotalPrimitivesInFrame = 1   # Total primitives drawn
    TotalDrawCallsInFrame = 2    # Total draw calls
    ShaderChangesInFrame = 3     # Shader switches
    MaterialChangesInFrame = 4   # Material changes
    SurfaceChangesInFrame = 5    # Surface changes
    DrawCallsInFrame = 6         # Draw calls this frame
    VideoMemUsed = 7             # VRAM usage (bytes)
    TextureMemUsed = 8           # Texture memory (bytes)
    BufferMemUsed = 9            # Buffer memory (bytes)

pub enum ProcessInfo:
    ActiveObjects = 0      # Active physics bodies
    CollisionPairs = 1     # Active collision pairs
    IslandCount = 2        # Physics islands


# Utility functions

# Create a world with default settings
pub fn create_world_3d() -> World3D:
    return World3D::new()

# Get rendering statistics
pub fn get_render_stats() -> RenderStats:
    let server = RenderingServer::get_singleton()

    let objects = server.get_rendering_info(RenderingInfo::TotalObjectsInFrame)
    let draw_calls = server.get_rendering_info(RenderingInfo::TotalDrawCallsInFrame)
    let vram = server.get_rendering_info(RenderingInfo::VideoMemUsed)

    return RenderStats(
        total_objects: objects,
        draw_calls: draw_calls,
        vram_used_bytes: vram,
    )

# Get physics statistics
pub fn get_physics_stats() -> PhysicsStats:
    let server = PhysicsServer3D::get_singleton()

    let active = server.get_process_info(ProcessInfo::ActiveObjects)
    let pairs = server.get_process_info(ProcessInfo::CollisionPairs)
    let islands = server.get_process_info(ProcessInfo::IslandCount)

    return PhysicsStats(
        active_bodies: active,
        collision_pairs: pairs,
        island_count: islands,
    )


# Stats structures

pub struct RenderStats:
    total_objects: i64
    draw_calls: i64
    vram_used_bytes: i64

pub struct PhysicsStats:
    active_bodies: i32
    collision_pairs: i32
    island_count: i32
