# Godot World System
#
# Type-safe wrappers for Godot's world resources
#
# Features:
# - World2D (2D physics and rendering space)
# - World3D (3D physics and rendering space)
# - RenderingServer integration
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_world3d.html

import godot.ffi
import godot.variant
import godot.resource

mod world

# World2D
# 2D physics and rendering space
pub struct World2D:
    resource: resource.Resource

impl World2D:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> World2D:
        return World2D(resource: res)

    # Create new world
    pub fn new() -> World2D:
        val ptr = ffi.godot_new_object("World2D")
        val res = resource.Resource::from_ptr(ptr)
        return World2D::from_resource(res)

    # Get canvas RID (for low-level rendering)
    pub fn get_canvas(self) -> RID:
        val obj = self.resource.as_object()
        val result = obj.call0("get_canvas")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get space RID (for physics queries)
    pub fn get_space(self) -> RID:
        val obj = self.resource.as_object()
        val result = obj.call0("get_space")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder


# World3D
# 3D physics and rendering space
pub struct World3D:
    resource: resource.Resource

impl World3D:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> World3D:
        return World3D(resource: res)

    # Create new world
    pub fn new() -> World3D:
        val ptr = ffi.godot_new_object("World3D")
        val res = resource.Resource::from_ptr(ptr)
        return World3D::from_resource(res)

    # Get scenario RID (for rendering)
    pub fn get_scenario(self) -> RID:
        val obj = self.resource.as_object()
        val result = obj.call0("get_scenario")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get space RID (for physics queries)
    pub fn get_space(self) -> RID:
        val obj = self.resource.as_object()
        val result = obj.call0("get_space")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get environment
    pub fn get_environment(self) -> Option[godot.resource.Resource]:
        val obj = self.resource.as_object()
        val result = obj.call0("get_environment")

        if result.is_null():
            return None
        else:
            val res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(res)

    # Set environment
    pub fn set_environment(mut self, env: godot.resource.Resource):
        val obj = self.resource.as_object()
        val env_var = variant.Variant::from_object(env.as_object())
        obj.call1("set_environment", env_var)

    # Get fallback environment
    pub fn get_fallback_environment(self) -> Option[godot.resource.Resource]:
        val obj = self.resource.as_object()
        val result = obj.call0("get_fallback_environment")

        if result.is_null():
            return None
        else:
            val res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(res)

    # Set fallback environment
    pub fn set_fallback_environment(mut self, env: godot.resource.Resource):
        val obj = self.resource.as_object()
        val env_var = variant.Variant::from_object(env.as_object())
        obj.call1("set_fallback_environment", env_var)

    # Get camera effects
    pub fn get_camera_attributes(self) -> Option[godot.resource.Resource]:
        val obj = self.resource.as_object()
        val result = obj.call0("get_camera_attributes")

        if result.is_null():
            return None
        else:
            val res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(res)

    # Set camera effects
    pub fn set_camera_attributes(mut self, attributes: godot.resource.Resource):
        val obj = self.resource.as_object()
        val attr_var = variant.Variant::from_object(attributes.as_object())
        obj.call1("set_camera_attributes", attr_var)


# RID (Resource ID)
# Opaque handle to low-level Godot resource
pub struct RID:
    id: u64

impl RID:
    # Create from ID
    pub fn from_id(id: u64) -> RID:
        return RID(id: id)

    # Get ID
    pub fn get_id(self) -> u64:
        return self.id

    # Check if valid
    pub fn is_valid(self) -> bool:
        return self.id != 0


# RenderingServer
# Low-level rendering API (singleton)
pub struct RenderingServer:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl RenderingServer:
    # Get singleton
    pub fn get_singleton() -> RenderingServer:
        val ptr = ffi.godot_get_singleton("RenderingServer")
        return RenderingServer(singleton_ptr: ptr)

    # Get white texture (useful for debugging)
    pub fn get_white_texture(self) -> RID:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val result = obj.call0("get_white_texture")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Get test texture (checkerboard pattern)
    pub fn get_test_texture(self) -> RID:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val result = obj.call0("get_test_texture")
        # TODO: [stdlib][P2] Parse RID
        return RID(id: 0)  # Placeholder

    # Force draw (useful for debugging/profiling)
    pub fn force_draw(mut self, swap_buffers: bool = true):
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val swap_var = variant.Variant::from_bool(swap_buffers)
        obj.call1("force_draw", swap_var)

    # Get rendering info
    pub fn get_rendering_info(self, info: RenderingInfo) -> i64:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val info_var = variant.Variant::from_int(info as i64)
        val result = obj.call1("get_rendering_info", info_var)
        return result.as_int()


# PhysicsServer3D
# Low-level 3D physics API (singleton)
pub struct PhysicsServer3D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl PhysicsServer3D:
    # Get singleton
    pub fn get_singleton() -> PhysicsServer3D:
        val ptr = ffi.godot_get_singleton("PhysicsServer3D")
        return PhysicsServer3D(singleton_ptr: ptr)

    # Set active (enable/disable physics)
    pub fn set_active(mut self, active: bool):
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val active_var = variant.Variant::from_bool(active)
        obj.call1("set_active", active_var)

    # Get process info
    pub fn get_process_info(self, info: ProcessInfo) -> i32:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val info_var = variant.Variant::from_int(info as i64)
        val result = obj.call1("get_process_info", info_var)
        return result.as_int() as i32


# Enums

pub enum RenderingInfo:
    TotalObjectsInFrame = 0      # Total visible objects
    TotalPrimitivesInFrame = 1   # Total primitives drawn
    TotalDrawCallsInFrame = 2    # Total draw calls
    ShaderChangesInFrame = 3     # Shader switches
    MaterialChangesInFrame = 4   # Material changes
    SurfaceChangesInFrame = 5    # Surface changes
    DrawCallsInFrame = 6         # Draw calls this frame
    VideoMemUsed = 7             # VRAM usage (bytes)
    TextureMemUsed = 8           # Texture memory (bytes)
    BufferMemUsed = 9            # Buffer memory (bytes)

impl RenderingInfo:
    pub fn to_string(self) -> String:
        """Convert rendering info to string."""
        match self:
            case TotalObjectsInFrame: "TotalObjectsInFrame"
            case TotalPrimitivesInFrame: "TotalPrimitivesInFrame"
            case TotalDrawCallsInFrame: "TotalDrawCallsInFrame"
            case ShaderChangesInFrame: "ShaderChangesInFrame"
            case MaterialChangesInFrame: "MaterialChangesInFrame"
            case SurfaceChangesInFrame: "SurfaceChangesInFrame"
            case DrawCallsInFrame: "DrawCallsInFrame"
            case VideoMemUsed: "VideoMemUsed"
            case TextureMemUsed: "TextureMemUsed"
            case BufferMemUsed: "BufferMemUsed"

    pub fn description(self) -> String:
        """Get rendering info description."""
        match self:
            case TotalObjectsInFrame: "Total visible objects in frame"
            case TotalPrimitivesInFrame: "Total primitives drawn in frame"
            case TotalDrawCallsInFrame: "Total draw calls issued in frame"
            case ShaderChangesInFrame: "Shader program switches in frame"
            case MaterialChangesInFrame: "Material changes in frame"
            case SurfaceChangesInFrame: "Surface changes in frame"
            case DrawCallsInFrame: "Draw calls in current frame"
            case VideoMemUsed: "Total VRAM usage in bytes"
            case TextureMemUsed: "Texture memory usage in bytes"
            case BufferMemUsed: "Buffer memory usage in bytes"

    pub fn is_total_objects_in_frame(self) -> bool:
        """Check if info is TotalObjectsInFrame."""
        match self:
            case TotalObjectsInFrame: true
            case _: false

    pub fn is_total_primitives_in_frame(self) -> bool:
        """Check if info is TotalPrimitivesInFrame."""
        match self:
            case TotalPrimitivesInFrame: true
            case _: false

    pub fn is_total_draw_calls_in_frame(self) -> bool:
        """Check if info is TotalDrawCallsInFrame."""
        match self:
            case TotalDrawCallsInFrame: true
            case _: false

    pub fn is_shader_changes_in_frame(self) -> bool:
        """Check if info is ShaderChangesInFrame."""
        match self:
            case ShaderChangesInFrame: true
            case _: false

    pub fn is_material_changes_in_frame(self) -> bool:
        """Check if info is MaterialChangesInFrame."""
        match self:
            case MaterialChangesInFrame: true
            case _: false

    pub fn is_surface_changes_in_frame(self) -> bool:
        """Check if info is SurfaceChangesInFrame."""
        match self:
            case SurfaceChangesInFrame: true
            case _: false

    pub fn is_draw_calls_in_frame(self) -> bool:
        """Check if info is DrawCallsInFrame."""
        match self:
            case DrawCallsInFrame: true
            case _: false

    pub fn is_video_mem_used(self) -> bool:
        """Check if info is VideoMemUsed."""
        match self:
            case VideoMemUsed: true
            case _: false

    pub fn is_texture_mem_used(self) -> bool:
        """Check if info is TextureMemUsed."""
        match self:
            case TextureMemUsed: true
            case _: false

    pub fn is_buffer_mem_used(self) -> bool:
        """Check if info is BufferMemUsed."""
        match self:
            case BufferMemUsed: true
            case _: false

    pub fn is_frame_stat(self) -> bool:
        """Check if info is per-frame statistic."""
        match self:
            case TotalObjectsInFrame: true
            case TotalPrimitivesInFrame: true
            case TotalDrawCallsInFrame: true
            case ShaderChangesInFrame: true
            case MaterialChangesInFrame: true
            case SurfaceChangesInFrame: true
            case DrawCallsInFrame: true
            case _: false

    pub fn is_memory_stat(self) -> bool:
        """Check if info is memory usage statistic."""
        match self:
            case VideoMemUsed: true
            case TextureMemUsed: true
            case BufferMemUsed: true
            case _: false

    pub fn is_state_change_stat(self) -> bool:
        """Check if info tracks rendering state changes."""
        match self:
            case ShaderChangesInFrame: true
            case MaterialChangesInFrame: true
            case SurfaceChangesInFrame: true
            case _: false

    pub fn info_value(self) -> i32:
        """Get the numeric value for RenderingServer API."""
        match self:
            case TotalObjectsInFrame: 0
            case TotalPrimitivesInFrame: 1
            case TotalDrawCallsInFrame: 2
            case ShaderChangesInFrame: 3
            case MaterialChangesInFrame: 4
            case SurfaceChangesInFrame: 5
            case DrawCallsInFrame: 6
            case VideoMemUsed: 7
            case TextureMemUsed: 8
            case BufferMemUsed: 9

    pub fn summary(self) -> String:
        """Get rendering info summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_frame_stat():
            props.push("frame-stat")
        if self.is_memory_stat():
            props.push("memory-stat")
        if self.is_state_change_stat():
            props.push("state-change")
        val value = self.info_value()
        props.push("value={value}")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "RenderingInfo: {name} ({desc}, {props_str})"
        else:
            return "RenderingInfo: {name} ({desc})"

pub enum ProcessInfo:
    ActiveObjects = 0      # Active physics bodies
    CollisionPairs = 1     # Active collision pairs
    IslandCount = 2        # Physics islands

impl ProcessInfo:
    pub fn to_string(self) -> String:
        """Convert process info to string."""
        match self:
            case ActiveObjects: "ActiveObjects"
            case CollisionPairs: "CollisionPairs"
            case IslandCount: "IslandCount"

    pub fn description(self) -> String:
        """Get process info description."""
        match self:
            case ActiveObjects: "Number of active physics bodies"
            case CollisionPairs: "Number of active collision pairs"
            case IslandCount: "Number of physics simulation islands"

    pub fn is_active_objects(self) -> bool:
        """Check if info is ActiveObjects."""
        match self:
            case ActiveObjects: true
            case _: false

    pub fn is_collision_pairs(self) -> bool:
        """Check if info is CollisionPairs."""
        match self:
            case CollisionPairs: true
            case _: false

    pub fn is_island_count(self) -> bool:
        """Check if info is IslandCount."""
        match self:
            case IslandCount: true
            case _: false

    pub fn is_collision_related(self) -> bool:
        """Check if info is collision-related."""
        match self:
            case CollisionPairs: true
            case _: false

    pub fn is_simulation_stat(self) -> bool:
        """Check if info is simulation statistic."""
        match self:
            case ActiveObjects: true
            case IslandCount: true
            case _: false

    pub fn info_value(self) -> i32:
        """Get the numeric value for PhysicsServer3D API."""
        match self:
            case ActiveObjects: 0
            case CollisionPairs: 1
            case IslandCount: 2

    pub fn summary(self) -> String:
        """Get process info summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_collision_related():
            props.push("collision")
        if self.is_simulation_stat():
            props.push("simulation")
        val value = self.info_value()
        props.push("value={value}")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ProcessInfo: {name} ({desc}, {props_str})"
        else:
            return "ProcessInfo: {name} ({desc})"


# Utility functions

# Create a world with default settings
pub fn create_world_3d() -> World3D:
    return World3D::new()

# Get rendering statistics
pub fn get_render_stats() -> RenderStats:
    val server = RenderingServer::get_singleton()

    val objects = server.get_rendering_info(RenderingInfo::TotalObjectsInFrame)
    val draw_calls = server.get_rendering_info(RenderingInfo::TotalDrawCallsInFrame)
    val vram = server.get_rendering_info(RenderingInfo::VideoMemUsed)

    return RenderStats(
        total_objects: objects,
        draw_calls: draw_calls,
        vram_used_bytes: vram,
    )

# Get physics statistics
pub fn get_physics_stats() -> PhysicsStats:
    val server = PhysicsServer3D::get_singleton()

    val active = server.get_process_info(ProcessInfo::ActiveObjects)
    val pairs = server.get_process_info(ProcessInfo::CollisionPairs)
    val islands = server.get_process_info(ProcessInfo::IslandCount)

    return PhysicsStats(
        active_bodies: active,
        collision_pairs: pairs,
        island_count: islands,
    )


# Stats structures

pub struct RenderStats:
    total_objects: i64
    draw_calls: i64
    vram_used_bytes: i64

pub struct PhysicsStats:
    active_bodies: i32
    collision_pairs: i32
    island_count: i32
