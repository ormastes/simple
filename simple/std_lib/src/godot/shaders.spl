# Godot Shader System
#
# Type-safe wrappers for Godot's shader system
#
# Features:
# - Shader resource (GLSL-like shaders)
# - ShaderMaterial (material with custom shader)
# - Shader parameters
# - Built-in shader types (canvas, spatial, particles)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_shader.html

import godot.ffi
import godot.variant
import godot.resource

mod shaders

# Shader Resource
# Custom shader code (vertex, fragment, light)
pub struct Shader:
    resource: resource.Resource

impl Shader:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> Shader:
        return Shader(resource: res)

    # Create new shader
    pub fn new() -> Shader:
        val ptr = ffi.godot_new_object("Shader")
        val res = resource.Resource::from_ptr(ptr)
        return Shader::from_resource(res)

    # Load shader from file
    pub fn load(path: String) -> Result[Shader, String]:
        val loader = resource.ResourceLoader::get_singleton()
        val result = loader.load(path)

        if result.is_ok():
            return Ok(Shader::from_resource(result.unwrap()))
        else:
            return Err(result.unwrap_err())

    # Set shader code
    pub fn set_code(mut self, code: String):
        val obj = self.resource.as_object()
        val code_var = variant.Variant::from_string(code)
        obj.call1("set_code", code_var)

    # Get shader code
    pub fn get_code(self) -> String:
        val obj = self.resource.as_object()
        val result = obj.call0("get_code")
        return result.as_string()

    # Get shader mode
    pub fn get_mode(self) -> ShaderMode:
        val obj = self.resource.as_object()
        val result = obj.call0("get_mode")
        val mode_int = result.as_int()
        return shader_mode_from_int(mode_int as i32)

    # Check if shader has parameter
    pub fn has_parameter(self, name: String) -> bool:
        val obj = self.resource.as_object()
        val name_var = variant.Variant::from_string(name)
        val result = obj.call1("has_parameter", name_var)
        return result.as_bool()


# Shader Material
# Material using a custom shader
pub struct ShaderMaterial:
    resource: resource.Resource

impl ShaderMaterial:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> ShaderMaterial:
        return ShaderMaterial(resource: res)

    # Create new shader material
    pub fn new() -> ShaderMaterial:
        val ptr = ffi.godot_new_object("ShaderMaterial")
        val res = resource.Resource::from_ptr(ptr)
        return ShaderMaterial::from_resource(res)

    # Set shader
    pub fn set_shader(mut self, shader: Shader):
        val obj = self.resource.as_object()
        val shader_var = variant.Variant::from_object(shader.resource.as_object())
        obj.call1("set_shader", shader_var)

    # Get shader
    pub fn get_shader(self) -> Option[Shader]:
        val obj = self.resource.as_object()
        val result = obj.call0("get_shader")

        if result.is_null():
            return None
        else:
            val res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(Shader::from_resource(res))

    # Set shader parameter
    pub fn set_shader_parameter(mut self, param_name: String, value: variant.Variant):
        val obj = self.resource.as_object()
        val name_var = variant.Variant::from_string(param_name)
        obj.call2("set_shader_parameter", name_var, value)

    # Get shader parameter
    pub fn get_shader_parameter(self, param_name: String) -> variant.Variant:
        val obj = self.resource.as_object()
        val name_var = variant.Variant::from_string(param_name)
        return obj.call1("get_shader_parameter", name_var)


# Shader Mode
pub enum ShaderMode:
    Spatial = 0      # 3D shaders
    CanvasItem = 1   # 2D shaders
    Particles = 2    # Particle shaders
    Sky = 3          # Sky shaders
    Fog = 4          # Fog shaders

impl ShaderMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_spatial(self) -> bool:
        """Check if this is Spatial shader mode.

        Returns:
            true for Spatial

        Example:
            ShaderMode::Spatial.is_spatial()  # → true
        """
        self == ShaderMode::Spatial

    pub fn is_canvas_item(self) -> bool:
        """Check if this is CanvasItem shader mode.

        Returns:
            true for CanvasItem

        Example:
            ShaderMode::CanvasItem.is_canvas_item()  # → true
        """
        self == ShaderMode::CanvasItem

    pub fn is_particles(self) -> bool:
        """Check if this is Particles shader mode.

        Returns:
            true for Particles

        Example:
            ShaderMode::Particles.is_particles()  # → true
        """
        self == ShaderMode::Particles

    pub fn is_sky(self) -> bool:
        """Check if this is Sky shader mode.

        Returns:
            true for Sky

        Example:
            ShaderMode::Sky.is_sky()  # → true
        """
        self == ShaderMode::Sky

    pub fn is_fog(self) -> bool:
        """Check if this is Fog shader mode.

        Returns:
            true for Fog

        Example:
            ShaderMode::Fog.is_fog()  # → true
        """
        self == ShaderMode::Fog

    pub fn is_3d(self) -> bool:
        """Check if this is 3D shader mode.

        Returns:
            true for Spatial, Sky, or Fog

        Example:
            ShaderMode::Spatial.is_3d()  # → true
            ShaderMode::CanvasItem.is_3d()  # → false
        """
        self == ShaderMode::Spatial or self == ShaderMode::Sky or self == ShaderMode::Fog

    pub fn is_2d(self) -> bool:
        """Check if this is 2D shader mode.

        Returns:
            true for CanvasItem

        Example:
            ShaderMode::CanvasItem.is_2d()  # → true
        """
        self == ShaderMode::CanvasItem

    pub fn supports_vertex_shader(self) -> bool:
        """Check if mode supports vertex shader.

        Returns:
            true for all modes

        Example:
            ShaderMode::Spatial.supports_vertex_shader()  # → true
        """
        true

    pub fn supports_fragment_shader(self) -> bool:
        """Check if mode supports fragment shader.

        Returns:
            true for all modes

        Example:
            ShaderMode::Spatial.supports_fragment_shader()  # → true
        """
        true

    pub fn supports_light_shader(self) -> bool:
        """Check if mode supports light shader.

        Returns:
            true for Spatial and CanvasItem

        Example:
            ShaderMode::Spatial.supports_light_shader()  # → true
            ShaderMode::Particles.supports_light_shader()  # → false
        """
        self == ShaderMode::Spatial or self == ShaderMode::CanvasItem

    pub fn to_string(self) -> String:
        """Convert shader mode to string.

        Returns:
            Mode name as used in shader code

        Example:
            ShaderMode::Spatial.to_string()  # → "spatial"
        """
        shader_mode_to_string(self)

    pub fn description(self) -> String:
        """Get shader mode description.

        Returns:
            Human-readable description

        Example:
            ShaderMode::Spatial.description()
            # → "3D shaders for spatial rendering"
        """
        if self == ShaderMode::Spatial:
            "3D shaders for spatial rendering"
        elif self == ShaderMode::CanvasItem:
            "2D shaders for canvas items"
        elif self == ShaderMode::Particles:
            "Particle system shaders"
        elif self == ShaderMode::Sky:
            "Sky and atmosphere shaders"
        elif self == ShaderMode::Fog:
            "Volumetric fog shaders"
        else:
            "Unknown shader mode"

    pub fn summary(self) -> String:
        """Get summary of shader mode.

        Returns:
            Human-readable summary

        Example:
            ShaderMode::Spatial.summary()
            # → "ShaderMode: spatial (3D, vertex+fragment+light)"
        """
        val name = self.to_string()
        var attrs: Array[String] = []

        if self.is_3d():
            attrs.push("3D")
        if self.is_2d():
            attrs.push("2D")

        var shaders: Array[String] = []
        if self.supports_vertex_shader():
            shaders.push("vertex")
        if self.supports_fragment_shader():
            shaders.push("fragment")
        if self.supports_light_shader():
            shaders.push("light")

        val shader_str = shaders.join("+")
        attrs.push(shader_str)

        val attrs_str = attrs.join(", ")
        return "ShaderMode: {name} ({attrs_str})"


# Shader Builder
# Fluent API for creating shaders
pub struct ShaderBuilder:
    mode: ShaderMode
    vertex_code: String
    fragment_code: String
    light_code: String
    uniforms: Array[ShaderUniform]

impl ShaderBuilder:
    # Create new builder
    pub fn new(mode: ShaderMode) -> ShaderBuilder:
        return ShaderBuilder(
            mode: mode,
            vertex_code: "",
            fragment_code: "",
            light_code: "",
            uniforms: []
        )

    # Add uniform parameter
    pub fn uniform(mut self, name: String, uniform_type: UniformType, default_value: String = "") -> ShaderBuilder:
        val uniform = ShaderUniform(
            name: name,
            uniform_type: uniform_type,
            default_value: default_value
        )
        self.uniforms.push(uniform)
        return self

    # Set vertex shader code
    pub fn vertex(mut self, code: String) -> ShaderBuilder:
        self.vertex_code = code
        return self

    # Set fragment shader code
    pub fn fragment(mut self, code: String) -> ShaderBuilder:
        self.fragment_code = code
        return self

    # Set light shader code (for lit materials)
    pub fn light(mut self, code: String) -> ShaderBuilder:
        self.light_code = code
        return self

    # Build final shader
    pub fn build(self) -> Shader:
        var shader = Shader::new()

        # Build shader code
        var code = "shader_type {shader_mode_to_string(self.mode)};\n\n"

        # Add uniforms
        for uniform in self.uniforms:
            code += "uniform {uniform_type_to_string(uniform.uniform_type)} {uniform.name}"
            if uniform.default_value != "":
                code += " = {uniform.default_value}"
            code += ";\n"

        code += "\n"

        # Add vertex shader
        if self.vertex_code != "":
            code += "void vertex() {\n"
            code += self.vertex_code
            code += "\n}\n\n"

        # Add fragment shader
        if self.fragment_code != "":
            code += "void fragment() {\n"
            code += self.fragment_code
            code += "\n}\n\n"

        # Add light shader
        if self.light_code != "":
            code += "void light() {\n"
            code += self.light_code
            code += "\n}\n"

        shader.set_code(code)
        return shader


# Shader Uniform
struct ShaderUniform:
    name: String
    uniform_type: UniformType
    default_value: String


# Uniform Types
pub enum UniformType:
    Float
    Vec2
    Vec3
    Vec4
    Color
    Int
    UInt
    Bool
    Sampler2D
    Sampler3D
    SamplerCube
    Mat2
    Mat3
    Mat4

impl UniformType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_float(self) -> bool:
        """Check if this is Float type.

        Returns:
            true for Float

        Example:
            UniformType::Float.is_float()  # → true
        """
        self == UniformType::Float

    pub fn is_vec2(self) -> bool:
        """Check if this is Vec2 type.

        Returns:
            true for Vec2

        Example:
            UniformType::Vec2.is_vec2()  # → true
        """
        self == UniformType::Vec2

    pub fn is_vec3(self) -> bool:
        """Check if this is Vec3 type.

        Returns:
            true for Vec3

        Example:
            UniformType::Vec3.is_vec3()  # → true
        """
        self == UniformType::Vec3

    pub fn is_vec4(self) -> bool:
        """Check if this is Vec4 type.

        Returns:
            true for Vec4

        Example:
            UniformType::Vec4.is_vec4()  # → true
        """
        self == UniformType::Vec4

    pub fn is_color(self) -> bool:
        """Check if this is Color type.

        Returns:
            true for Color

        Example:
            UniformType::Color.is_color()  # → true
        """
        self == UniformType::Color

    pub fn is_int(self) -> bool:
        """Check if this is Int type.

        Returns:
            true for Int

        Example:
            UniformType::Int.is_int()  # → true
        """
        self == UniformType::Int

    pub fn is_uint(self) -> bool:
        """Check if this is UInt type.

        Returns:
            true for UInt

        Example:
            UniformType::UInt.is_uint()  # → true
        """
        self == UniformType::UInt

    pub fn is_bool(self) -> bool:
        """Check if this is Bool type.

        Returns:
            true for Bool

        Example:
            UniformType::Bool.is_bool()  # → true
        """
        self == UniformType::Bool

    pub fn is_sampler2d(self) -> bool:
        """Check if this is Sampler2D type.

        Returns:
            true for Sampler2D

        Example:
            UniformType::Sampler2D.is_sampler2d()  # → true
        """
        self == UniformType::Sampler2D

    pub fn is_sampler3d(self) -> bool:
        """Check if this is Sampler3D type.

        Returns:
            true for Sampler3D

        Example:
            UniformType::Sampler3D.is_sampler3d()  # → true
        """
        self == UniformType::Sampler3D

    pub fn is_sampler_cube(self) -> bool:
        """Check if this is SamplerCube type.

        Returns:
            true for SamplerCube

        Example:
            UniformType::SamplerCube.is_sampler_cube()  # → true
        """
        self == UniformType::SamplerCube

    pub fn is_mat2(self) -> bool:
        """Check if this is Mat2 type.

        Returns:
            true for Mat2

        Example:
            UniformType::Mat2.is_mat2()  # → true
        """
        self == UniformType::Mat2

    pub fn is_mat3(self) -> bool:
        """Check if this is Mat3 type.

        Returns:
            true for Mat3

        Example:
            UniformType::Mat3.is_mat3()  # → true
        """
        self == UniformType::Mat3

    pub fn is_mat4(self) -> bool:
        """Check if this is Mat4 type.

        Returns:
            true for Mat4

        Example:
            UniformType::Mat4.is_mat4()  # → true
        """
        self == UniformType::Mat4

    pub fn is_scalar(self) -> bool:
        """Check if type is scalar.

        Returns:
            true for Float, Int, UInt, Bool

        Example:
            UniformType::Float.is_scalar()  # → true
            UniformType::Vec3.is_scalar()  # → false
        """
        self == UniformType::Float or self == UniformType::Int or
        self == UniformType::UInt or self == UniformType::Bool

    pub fn is_vector(self) -> bool:
        """Check if type is vector.

        Returns:
            true for Vec2, Vec3, Vec4, Color

        Example:
            UniformType::Vec3.is_vector()  # → true
        """
        self == UniformType::Vec2 or self == UniformType::Vec3 or
        self == UniformType::Vec4 or self == UniformType::Color

    pub fn is_matrix(self) -> bool:
        """Check if type is matrix.

        Returns:
            true for Mat2, Mat3, Mat4

        Example:
            UniformType::Mat4.is_matrix()  # → true
        """
        self == UniformType::Mat2 or self == UniformType::Mat3 or self == UniformType::Mat4

    pub fn is_sampler(self) -> bool:
        """Check if type is texture sampler.

        Returns:
            true for Sampler2D, Sampler3D, SamplerCube

        Example:
            UniformType::Sampler2D.is_sampler()  # → true
        """
        self == UniformType::Sampler2D or self == UniformType::Sampler3D or
        self == UniformType::SamplerCube

    pub fn is_numeric(self) -> bool:
        """Check if type is numeric.

        Returns:
            true for scalar, vector, or matrix types

        Example:
            UniformType::Vec3.is_numeric()  # → true
            UniformType::Sampler2D.is_numeric()  # → false
        """
        self.is_scalar() or self.is_vector() or self.is_matrix()

    pub fn component_count(self) -> i32:
        """Get number of components.

        Returns:
            Component count

        Example:
            UniformType::Vec3.component_count()  # → 3
            UniformType::Mat4.component_count()  # → 16
        """
        if self == UniformType::Float or self == UniformType::Int or
           self == UniformType::UInt or self == UniformType::Bool:
            1
        elif self == UniformType::Vec2:
            2
        elif self == UniformType::Vec3:
            3
        elif self == UniformType::Vec4 or self == UniformType::Color:
            4
        elif self == UniformType::Mat2:
            4
        elif self == UniformType::Mat3:
            9
        elif self == UniformType::Mat4:
            16
        else:
            0

    pub fn to_string(self) -> String:
        """Convert uniform type to string.

        Returns:
            GLSL type name

        Example:
            UniformType::Vec3.to_string()  # → "vec3"
        """
        uniform_type_to_string(self)

    pub fn description(self) -> String:
        """Get uniform type description.

        Returns:
            Human-readable description

        Example:
            UniformType::Sampler2D.description()
            # → "2D texture sampler"
        """
        if self == UniformType::Float:
            "Single precision floating point"
        elif self == UniformType::Vec2:
            "2D vector (x, y)"
        elif self == UniformType::Vec3:
            "3D vector (x, y, z)"
        elif self == UniformType::Vec4:
            "4D vector (x, y, z, w)"
        elif self == UniformType::Color:
            "Color (r, g, b, a)"
        elif self == UniformType::Int:
            "Signed integer"
        elif self == UniformType::UInt:
            "Unsigned integer"
        elif self == UniformType::Bool:
            "Boolean value"
        elif self == UniformType::Sampler2D:
            "2D texture sampler"
        elif self == UniformType::Sampler3D:
            "3D texture sampler"
        elif self == UniformType::SamplerCube:
            "Cubemap texture sampler"
        elif self == UniformType::Mat2:
            "2x2 matrix"
        elif self == UniformType::Mat3:
            "3x3 matrix"
        elif self == UniformType::Mat4:
            "4x4 matrix"
        else:
            "Unknown type"

    pub fn summary(self) -> String:
        """Get summary of uniform type.

        Returns:
            Human-readable summary

        Example:
            UniformType::Vec3.summary()
            # → "UniformType: vec3 (vector, numeric, 3 components)"
        """
        val name = self.to_string()
        var attrs: Array[String] = []

        if self.is_scalar():
            attrs.push("scalar")
        if self.is_vector():
            attrs.push("vector")
        if self.is_matrix():
            attrs.push("matrix")
        if self.is_sampler():
            attrs.push("sampler")
        if self.is_numeric():
            attrs.push("numeric")

        val components = self.component_count()
        if components > 0:
            attrs.push("{components} components")

        val attrs_str = attrs.join(", ")
        return "UniformType: {name} ({attrs_str})"


# Helper functions

fn shader_mode_from_int(value: i32) -> ShaderMode:
    if value == 0:
        return ShaderMode::Spatial
    elif value == 1:
        return ShaderMode::CanvasItem
    elif value == 2:
        return ShaderMode::Particles
    elif value == 3:
        return ShaderMode::Sky
    elif value == 4:
        return ShaderMode::Fog
    else:
        return ShaderMode::Spatial

fn shader_mode_to_string(mode: ShaderMode) -> String:
    if mode == ShaderMode::Spatial:
        return "spatial"
    elif mode == ShaderMode::CanvasItem:
        return "canvas_item"
    elif mode == ShaderMode::Particles:
        return "particles"
    elif mode == ShaderMode::Sky:
        return "sky"
    elif mode == ShaderMode::Fog:
        return "fog"
    else:
        return "spatial"

fn uniform_type_to_string(uniform_type: UniformType) -> String:
    if uniform_type == UniformType::Float:
        return "float"
    elif uniform_type == UniformType::Vec2:
        return "vec2"
    elif uniform_type == UniformType::Vec3:
        return "vec3"
    elif uniform_type == UniformType::Vec4:
        return "vec4"
    elif uniform_type == UniformType::Color:
        return "vec4"
    elif uniform_type == UniformType::Int:
        return "int"
    elif uniform_type == UniformType::UInt:
        return "uint"
    elif uniform_type == UniformType::Bool:
        return "bool"
    elif uniform_type == UniformType::Sampler2D:
        return "sampler2D"
    elif uniform_type == UniformType::Sampler3D:
        return "sampler3D"
    elif uniform_type == UniformType::SamplerCube:
        return "samplerCube"
    elif uniform_type == UniformType::Mat2:
        return "mat2"
    elif uniform_type == UniformType::Mat3:
        return "mat3"
    elif uniform_type == UniformType::Mat4:
        return "mat4"
    else:
        return "float"


# Preset Shaders

# Simple color shader
pub fn create_color_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("albedo", UniformType::Color, "vec4(1.0, 1.0, 1.0, 1.0)")
        .fragment("    ALBEDO = albedo.rgb;")
        .build()

# Texture shader with UV scrolling
pub fn create_scrolling_texture_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::CanvasItem)
        .uniform("texture_albedo", UniformType::Sampler2D)
        .uniform("scroll_speed", UniformType::Vec2, "vec2(0.1, 0.0)")
        .fragment(
            "    vec2 uv = UV + scroll_speed * TIME;\n" +
            "    COLOR = texture(texture_albedo, uv);"
        )
        .build()

# Dissolve shader
pub fn create_dissolve_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("dissolve_texture", UniformType::Sampler2D)
        .uniform("dissolve_amount", UniformType::Float, "0.0")
        .fragment(
            "    float dissolve = texture(dissolve_texture, UV).r;\n" +
            "    if (dissolve < dissolve_amount) {\n" +
            "        discard;\n" +
            "    }\n" +
            "    ALBEDO = vec3(1.0);"
        )
        .build()

# Outline shader
pub fn create_outline_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("outline_color", UniformType::Color, "vec4(0.0, 0.0, 0.0, 1.0)")
        .uniform("outline_width", UniformType::Float, "0.03")
        .vertex(
            "    VERTEX += NORMAL * outline_width;"
        )
        .fragment(
            "    ALBEDO = outline_color.rgb;\n" +
            "    ALPHA = outline_color.a;"
        )
        .build()

# Hologram shader
pub fn create_hologram_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("hologram_color", UniformType::Color, "vec4(0.0, 1.0, 1.0, 0.5)")
        .uniform("scan_speed", UniformType::Float, "2.0")
        .uniform("scan_width", UniformType::Float, "0.1")
        .fragment(
            "    float scan = sin(UV.y * 20.0 - TIME * scan_speed);\n" +
            "    float scan_line = step(1.0 - scan_width, scan);\n" +
            "    vec3 color = hologram_color.rgb + scan_line * 0.5;\n" +
            "    ALBEDO = color;\n" +
            "    ALPHA = hologram_color.a;\n" +
            "    EMISSION = color * 0.5;"
        )
        .build()


# Array placeholder
pub struct Array[T]:
    items: Vec[T]

impl[T] Array[T]:
    pub fn push(mut self, item: T):
        pass
