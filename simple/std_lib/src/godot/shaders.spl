# Godot Shader System
#
# Type-safe wrappers for Godot's shader system
#
# Features:
# - Shader resource (GLSL-like shaders)
# - ShaderMaterial (material with custom shader)
# - Shader parameters
# - Built-in shader types (canvas, spatial, particles)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_shader.html

import godot.ffi
import godot.variant
import godot.resource

mod shaders

# Shader Resource
# Custom shader code (vertex, fragment, light)
pub struct Shader:
    resource: resource.Resource

impl Shader:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> Shader:
        return Shader(resource: res)

    # Create new shader
    pub fn new() -> Shader:
        let ptr = ffi.godot_new_object("Shader")
        let res = resource.Resource::from_ptr(ptr)
        return Shader::from_resource(res)

    # Load shader from file
    pub fn load(path: String) -> Result[Shader, String]:
        let loader = resource.ResourceLoader::get_singleton()
        let result = loader.load(path)

        if result.is_ok():
            return Ok(Shader::from_resource(result.unwrap()))
        else:
            return Err(result.unwrap_err())

    # Set shader code
    pub fn set_code(mut self, code: String):
        let obj = self.resource.as_object()
        let code_var = variant.Variant::from_string(code)
        obj.call1("set_code", code_var)

    # Get shader code
    pub fn get_code(self) -> String:
        let obj = self.resource.as_object()
        let result = obj.call0("get_code")
        return result.as_string()

    # Get shader mode
    pub fn get_mode(self) -> ShaderMode:
        let obj = self.resource.as_object()
        let result = obj.call0("get_mode")
        let mode_int = result.as_int()
        return shader_mode_from_int(mode_int as i32)

    # Check if shader has parameter
    pub fn has_parameter(self, name: String) -> bool:
        let obj = self.resource.as_object()
        let name_var = variant.Variant::from_string(name)
        let result = obj.call1("has_parameter", name_var)
        return result.as_bool()


# Shader Material
# Material using a custom shader
pub struct ShaderMaterial:
    resource: resource.Resource

impl ShaderMaterial:
    # Create from resource
    pub fn from_resource(res: resource.Resource) -> ShaderMaterial:
        return ShaderMaterial(resource: res)

    # Create new shader material
    pub fn new() -> ShaderMaterial:
        let ptr = ffi.godot_new_object("ShaderMaterial")
        let res = resource.Resource::from_ptr(ptr)
        return ShaderMaterial::from_resource(res)

    # Set shader
    pub fn set_shader(mut self, shader: Shader):
        let obj = self.resource.as_object()
        let shader_var = variant.Variant::from_object(shader.resource.as_object())
        obj.call1("set_shader", shader_var)

    # Get shader
    pub fn get_shader(self) -> Option[Shader]:
        let obj = self.resource.as_object()
        let result = obj.call0("get_shader")

        if result.is_null():
            return None
        else:
            let res = resource.Resource::from_ptr(result.as_object().ptr())
            return Some(Shader::from_resource(res))

    # Set shader parameter
    pub fn set_shader_parameter(mut self, param_name: String, value: variant.Variant):
        let obj = self.resource.as_object()
        let name_var = variant.Variant::from_string(param_name)
        obj.call2("set_shader_parameter", name_var, value)

    # Get shader parameter
    pub fn get_shader_parameter(self, param_name: String) -> variant.Variant:
        let obj = self.resource.as_object()
        let name_var = variant.Variant::from_string(param_name)
        return obj.call1("get_shader_parameter", name_var)


# Shader Mode
pub enum ShaderMode:
    Spatial = 0      # 3D shaders
    CanvasItem = 1   # 2D shaders
    Particles = 2    # Particle shaders
    Sky = 3          # Sky shaders
    Fog = 4          # Fog shaders


# Shader Builder
# Fluent API for creating shaders
pub struct ShaderBuilder:
    mode: ShaderMode
    vertex_code: String
    fragment_code: String
    light_code: String
    uniforms: Array[ShaderUniform]

impl ShaderBuilder:
    # Create new builder
    pub fn new(mode: ShaderMode) -> ShaderBuilder:
        return ShaderBuilder(
            mode: mode,
            vertex_code: "",
            fragment_code: "",
            light_code: "",
            uniforms: []
        )

    # Add uniform parameter
    pub fn uniform(mut self, name: String, uniform_type: UniformType, default_value: String = "") -> ShaderBuilder:
        let uniform = ShaderUniform(
            name: name,
            uniform_type: uniform_type,
            default_value: default_value
        )
        self.uniforms.push(uniform)
        return self

    # Set vertex shader code
    pub fn vertex(mut self, code: String) -> ShaderBuilder:
        self.vertex_code = code
        return self

    # Set fragment shader code
    pub fn fragment(mut self, code: String) -> ShaderBuilder:
        self.fragment_code = code
        return self

    # Set light shader code (for lit materials)
    pub fn light(mut self, code: String) -> ShaderBuilder:
        self.light_code = code
        return self

    # Build final shader
    pub fn build(self) -> Shader:
        let mut shader = Shader::new()

        # Build shader code
        let mut code = "shader_type {shader_mode_to_string(self.mode)};\n\n"

        # Add uniforms
        for uniform in self.uniforms:
            code += "uniform {uniform_type_to_string(uniform.uniform_type)} {uniform.name}"
            if uniform.default_value != "":
                code += " = {uniform.default_value}"
            code += ";\n"

        code += "\n"

        # Add vertex shader
        if self.vertex_code != "":
            code += "void vertex() {\n"
            code += self.vertex_code
            code += "\n}\n\n"

        # Add fragment shader
        if self.fragment_code != "":
            code += "void fragment() {\n"
            code += self.fragment_code
            code += "\n}\n\n"

        # Add light shader
        if self.light_code != "":
            code += "void light() {\n"
            code += self.light_code
            code += "\n}\n"

        shader.set_code(code)
        return shader


# Shader Uniform
struct ShaderUniform:
    name: String
    uniform_type: UniformType
    default_value: String


# Uniform Types
pub enum UniformType:
    Float
    Vec2
    Vec3
    Vec4
    Color
    Int
    UInt
    Bool
    Sampler2D
    Sampler3D
    SamplerCube
    Mat2
    Mat3
    Mat4


# Helper functions

fn shader_mode_from_int(value: i32) -> ShaderMode:
    if value == 0:
        return ShaderMode::Spatial
    elif value == 1:
        return ShaderMode::CanvasItem
    elif value == 2:
        return ShaderMode::Particles
    elif value == 3:
        return ShaderMode::Sky
    elif value == 4:
        return ShaderMode::Fog
    else:
        return ShaderMode::Spatial

fn shader_mode_to_string(mode: ShaderMode) -> String:
    if mode == ShaderMode::Spatial:
        return "spatial"
    elif mode == ShaderMode::CanvasItem:
        return "canvas_item"
    elif mode == ShaderMode::Particles:
        return "particles"
    elif mode == ShaderMode::Sky:
        return "sky"
    elif mode == ShaderMode::Fog:
        return "fog"
    else:
        return "spatial"

fn uniform_type_to_string(uniform_type: UniformType) -> String:
    if uniform_type == UniformType::Float:
        return "float"
    elif uniform_type == UniformType::Vec2:
        return "vec2"
    elif uniform_type == UniformType::Vec3:
        return "vec3"
    elif uniform_type == UniformType::Vec4:
        return "vec4"
    elif uniform_type == UniformType::Color:
        return "vec4"
    elif uniform_type == UniformType::Int:
        return "int"
    elif uniform_type == UniformType::UInt:
        return "uint"
    elif uniform_type == UniformType::Bool:
        return "bool"
    elif uniform_type == UniformType::Sampler2D:
        return "sampler2D"
    elif uniform_type == UniformType::Sampler3D:
        return "sampler3D"
    elif uniform_type == UniformType::SamplerCube:
        return "samplerCube"
    elif uniform_type == UniformType::Mat2:
        return "mat2"
    elif uniform_type == UniformType::Mat3:
        return "mat3"
    elif uniform_type == UniformType::Mat4:
        return "mat4"
    else:
        return "float"


# Preset Shaders

# Simple color shader
pub fn create_color_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("albedo", UniformType::Color, "vec4(1.0, 1.0, 1.0, 1.0)")
        .fragment("    ALBEDO = albedo.rgb;")
        .build()

# Texture shader with UV scrolling
pub fn create_scrolling_texture_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::CanvasItem)
        .uniform("texture_albedo", UniformType::Sampler2D)
        .uniform("scroll_speed", UniformType::Vec2, "vec2(0.1, 0.0)")
        .fragment(
            "    vec2 uv = UV + scroll_speed * TIME;\n" +
            "    COLOR = texture(texture_albedo, uv);"
        )
        .build()

# Dissolve shader
pub fn create_dissolve_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("dissolve_texture", UniformType::Sampler2D)
        .uniform("dissolve_amount", UniformType::Float, "0.0")
        .fragment(
            "    float dissolve = texture(dissolve_texture, UV).r;\n" +
            "    if (dissolve < dissolve_amount) {\n" +
            "        discard;\n" +
            "    }\n" +
            "    ALBEDO = vec3(1.0);"
        )
        .build()

# Outline shader
pub fn create_outline_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("outline_color", UniformType::Color, "vec4(0.0, 0.0, 0.0, 1.0)")
        .uniform("outline_width", UniformType::Float, "0.03")
        .vertex(
            "    VERTEX += NORMAL * outline_width;"
        )
        .fragment(
            "    ALBEDO = outline_color.rgb;\n" +
            "    ALPHA = outline_color.a;"
        )
        .build()

# Hologram shader
pub fn create_hologram_shader() -> Shader:
    return ShaderBuilder::new(ShaderMode::Spatial)
        .uniform("hologram_color", UniformType::Color, "vec4(0.0, 1.0, 1.0, 0.5)")
        .uniform("scan_speed", UniformType::Float, "2.0")
        .uniform("scan_width", UniformType::Float, "0.1")
        .fragment(
            "    float scan = sin(UV.y * 20.0 - TIME * scan_speed);\n" +
            "    float scan_line = step(1.0 - scan_width, scan);\n" +
            "    vec3 color = hologram_color.rgb + scan_line * 0.5;\n" +
            "    ALBEDO = color;\n" +
            "    ALPHA = hologram_color.a;\n" +
            "    EMISSION = color * 0.5;"
        )
        .build()


# Array placeholder
pub struct Array[T]:
    items: Vec[T]

impl[T] Array[T]:
    pub fn push(mut self, item: T):
        pass
