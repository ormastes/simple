# Godot Audio System
#
# Type-safe wrappers for Godot's audio playback system
#
# Features:
# - AudioStreamPlayer (2D positional audio)
# - AudioStreamPlayer2D (2D spatial audio)
# - AudioStreamPlayer3D (3D spatial audio)
# - AudioBus management
# - Volume control and effects
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_audiostreamplayer.html

import godot.ffi
import godot.variant
import godot.node
import godot.node2d
import godot.node3d
import godot.resource

mod audio

# Audio Stream Player (Non-spatial)
# For UI sounds, music, and global audio
pub struct AudioStreamPlayer:
    base: node.Node

impl AudioStreamPlayer:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AudioStreamPlayer:
        return AudioStreamPlayer(base: node.Node::from_ptr(ptr))

    # Set the audio stream to play
    pub fn set_stream(mut self, stream: resource.Resource):
        let obj = self.base.as_object()
        let stream_var = variant.Variant::from_object(stream.as_object())
        obj.call1("set_stream", stream_var)

    # Start playing the audio
    pub fn play(mut self, from_position: f64 = 0.0):
        let obj = self.base.as_object()
        let pos_var = variant.Variant::from_float(from_position)
        obj.call1("play", pos_var)

    # Stop playing
    pub fn stop(mut self):
        let obj = self.base.as_object()
        obj.call0("stop")

    # Check if playing
    pub fn is_playing(self) -> bool:
        let obj = self.base.as_object()
        let result = obj.call0("is_playing")
        return result.as_bool()

    # Set volume in decibels (-80.0 to 24.0)
    pub fn set_volume_db(mut self, volume_db: f32):
        let obj = self.base.as_object()
        let vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call1("set_volume_db", vol_var)

    # Get volume in decibels
    pub fn get_volume_db(self) -> f32:
        let obj = self.base.as_object()
        let result = obj.call0("get_volume_db")
        return result.as_float() as f32

    # Set pitch scale (0.01 to 4.0, 1.0 = normal)
    pub fn set_pitch_scale(mut self, pitch: f32):
        let obj = self.base.as_object()
        let pitch_var = variant.Variant::from_float(pitch as f64)
        obj.call1("set_pitch_scale", pitch_var)

    # Enable/disable autoplay
    pub fn set_autoplay(mut self, enabled: bool):
        let obj = self.base.as_object()
        let auto_var = variant.Variant::from_bool(enabled)
        obj.call1("set_autoplay", auto_var)

    # Get playback position in seconds
    pub fn get_playback_position(self) -> f64:
        let obj = self.base.as_object()
        let result = obj.call0("get_playback_position")
        return result.as_float()

    # Seek to position in seconds
    pub fn seek(mut self, to_position: f64):
        let obj = self.base.as_object()
        let pos_var = variant.Variant::from_float(to_position)
        obj.call1("seek", pos_var)

    # Set audio bus (default: "Master")
    pub fn set_bus(mut self, bus: String):
        let obj = self.base.as_object()
        let bus_var = variant.Variant::from_string(bus)
        obj.call1("set_bus", bus_var)


# Audio Stream Player 2D (2D Spatial Audio)
# For positional sound effects in 2D games
pub struct AudioStreamPlayer2D:
    base: node2d.Node2D

impl AudioStreamPlayer2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AudioStreamPlayer2D:
        return AudioStreamPlayer2D(base: node2d.Node2D::from_ptr(ptr))

    pub fn set_stream(mut self, stream: resource.Resource):
        let obj = self.base.as_node().as_object()
        let stream_var = variant.Variant::from_object(stream.as_object())
        obj.call1("set_stream", stream_var)

    pub fn play(mut self, from_position: f64 = 0.0):
        let obj = self.base.as_node().as_object()
        let pos_var = variant.Variant::from_float(from_position)
        obj.call1("play", pos_var)

    pub fn stop(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("stop")

    pub fn is_playing(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_playing")
        return result.as_bool()

    pub fn set_volume_db(mut self, volume_db: f32):
        let obj = self.base.as_node().as_object()
        let vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call1("set_volume_db", vol_var)

    # Set maximum distance for attenuation
    pub fn set_max_distance(mut self, pixels: f32):
        let obj = self.base.as_node().as_object()
        let dist_var = variant.Variant::from_float(pixels as f64)
        obj.call1("set_max_distance", dist_var)

    # Set attenuation curve (0.0 = linear, >1.0 = exponential)
    pub fn set_attenuation(mut self, curve: f32):
        let obj = self.base.as_node().as_object()
        let curve_var = variant.Variant::from_float(curve as f64)
        obj.call1("set_attenuation", curve_var)


# Audio Stream Player 3D (3D Spatial Audio)
# For positional sound effects in 3D games
pub struct AudioStreamPlayer3D:
    base: node3d.Node3D

impl AudioStreamPlayer3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AudioStreamPlayer3D:
        return AudioStreamPlayer3D(base: node3d.Node3D::from_ptr(ptr))

    pub fn set_stream(mut self, stream: resource.Resource):
        let obj = self.base.as_node().as_object()
        let stream_var = variant.Variant::from_object(stream.as_object())
        obj.call1("set_stream", stream_var)

    pub fn play(mut self, from_position: f64 = 0.0):
        let obj = self.base.as_node().as_object()
        let pos_var = variant.Variant::from_float(from_position)
        obj.call1("play", pos_var)

    pub fn stop(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("stop")

    pub fn is_playing(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_playing")
        return result.as_bool()

    pub fn set_volume_db(mut self, volume_db: f32):
        let obj = self.base.as_node().as_object()
        let vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call1("set_volume_db", vol_var)

    # Set unit size (default: 10.0)
    pub fn set_unit_size(mut self, size: f32):
        let obj = self.base.as_node().as_object()
        let size_var = variant.Variant::from_float(size as f64)
        obj.call1("set_unit_size", size_var)

    # Set maximum distance for attenuation
    pub fn set_max_distance(mut self, meters: f32):
        let obj = self.base.as_node().as_object()
        let dist_var = variant.Variant::from_float(meters as f64)
        obj.call1("set_max_distance", dist_var)

    # Set attenuation model
    pub fn set_attenuation_model(mut self, model: AttenuationModel):
        let obj = self.base.as_node().as_object()
        let model_var = variant.Variant::from_int(model as i64)
        obj.call1("set_attenuation_model", model_var)

    # Enable/disable Doppler effect
    pub fn set_doppler_tracking(mut self, mode: DopplerTracking):
        let obj = self.base.as_node().as_object()
        let mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_doppler_tracking", mode_var)


# Attenuation models for 3D audio
pub enum AttenuationModel:
    InverseDistance = 0       # Realistic, inverse square law
    InverseSquareDistance = 1 # More realistic, inverse square law
    Logarithmic = 2           # Smooth falloff
    Disabled = 3              # No distance attenuation

# Doppler tracking modes
pub enum DopplerTracking:
    Disabled = 0              # No Doppler effect
    IdleStep = 1              # Update during idle
    PhysicsStep = 2           # Update during physics


# Audio Bus Manager
# For managing audio buses and effects
pub struct AudioServer:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl AudioServer:
    # Get AudioServer singleton
    pub fn get_singleton() -> AudioServer:
        let ptr = ffi.godot_get_singleton("AudioServer")
        return AudioServer(singleton_ptr: ptr)

    # Set bus volume in decibels
    pub fn set_bus_volume_db(mut self, bus_idx: i32, volume_db: f32):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let idx_var = variant.Variant::from_int(bus_idx as i64)
        let vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call2("set_bus_volume_db", idx_var, vol_var)

    # Get bus volume in decibels
    pub fn get_bus_volume_db(self, bus_idx: i32) -> f32:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let idx_var = variant.Variant::from_int(bus_idx as i64)
        let result = obj.call1("get_bus_volume_db", idx_var)
        return result.as_float() as f32

    # Mute/unmute a bus
    pub fn set_bus_mute(mut self, bus_idx: i32, enable: bool):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let idx_var = variant.Variant::from_int(bus_idx as i64)
        let mute_var = variant.Variant::from_bool(enable)
        obj.call2("set_bus_mute", idx_var, mute_var)

    # Check if bus is muted
    pub fn is_bus_mute(self, bus_idx: i32) -> bool:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let idx_var = variant.Variant::from_int(bus_idx as i64)
        let result = obj.call1("is_bus_mute", idx_var)
        return result.as_bool()

    # Get bus index by name
    pub fn get_bus_index(self, bus_name: String) -> i32:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let name_var = variant.Variant::from_string(bus_name)
        let result = obj.call1("get_bus_index", name_var)
        return result.as_int() as i32

    # Get number of buses
    pub fn get_bus_count(self) -> i32:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_bus_count")
        return result.as_int() as i32


# Helper functions for common audio operations

# Convert linear volume (0.0 to 1.0) to decibels
pub fn linear_to_db(linear: f32) -> f32:
    if linear <= 0.0:
        return -80.0  # Effectively muted
    return 20.0 * log10(linear)

# Convert decibels to linear volume
pub fn db_to_linear(db: f32) -> f32:
    return pow(10.0, db / 20.0)

# Helper for logarithm base 10
fn log10(x: f32) -> f32:
    # ln(x) / ln(10)
    return log(x) / 2.302585

# Helper for natural logarithm (placeholder)
fn log(x: f32) -> f32:
    # TODO: Implement proper logarithm
    # For now, use approximation or external function
    return 0.0  # Placeholder

# Helper for power function (placeholder)
fn pow(base: f32, exp: f32) -> f32:
    # TODO: Implement proper power function
    return 1.0  # Placeholder
