# Godot Audio System
#
# Type-safe wrappers for Godot's audio playback system
#
# Features:
# - AudioStreamPlayer (2D positional audio)
# - AudioStreamPlayer2D (2D spatial audio)
# - AudioStreamPlayer3D (3D spatial audio)
# - AudioBus management
# - Volume control and effects
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_audiostreamplayer.html

import godot.ffi
import godot.variant
import godot.node
import godot.node2d
import godot.node3d
import godot.resource
import core.math

mod audio

# Audio Stream Player (Non-spatial)
# For UI sounds, music, and global audio
pub struct AudioStreamPlayer:
    base: node.Node

impl AudioStreamPlayer:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AudioStreamPlayer:
        return AudioStreamPlayer(base: node.Node::from_ptr(ptr))

    # Set the audio stream to play
    pub fn set_stream(mut self, stream: resource.Resource):
        val obj = self.base.as_object()
        val stream_var = variant.Variant::from_object(stream.as_object())
        obj.call1("set_stream", stream_var)

    # Start playing the audio
    pub fn play(mut self, from_position: f64 = 0.0):
        val obj = self.base.as_object()
        val pos_var = variant.Variant::from_float(from_position)
        obj.call1("play", pos_var)

    # Stop playing
    pub fn stop(mut self):
        val obj = self.base.as_object()
        obj.call0("stop")

    # Check if playing
    pub fn is_playing(self) -> bool:
        val obj = self.base.as_object()
        val result = obj.call0("is_playing")
        return result.as_bool()

    # Set volume in decibels (-80.0 to 24.0)
    pub fn set_volume_db(mut self, volume_db: f32):
        val obj = self.base.as_object()
        val vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call1("set_volume_db", vol_var)

    # Get volume in decibels
    pub fn get_volume_db(self) -> f32:
        val obj = self.base.as_object()
        val result = obj.call0("get_volume_db")
        return result.as_float() as f32

    # Set pitch scale (0.01 to 4.0, 1.0 = normal)
    pub fn set_pitch_scale(mut self, pitch: f32):
        val obj = self.base.as_object()
        val pitch_var = variant.Variant::from_float(pitch as f64)
        obj.call1("set_pitch_scale", pitch_var)

    # Enable/disable autoplay
    pub fn set_autoplay(mut self, enabled: bool):
        val obj = self.base.as_object()
        val auto_var = variant.Variant::from_bool(enabled)
        obj.call1("set_autoplay", auto_var)

    # Get playback position in seconds
    pub fn get_playback_position(self) -> f64:
        val obj = self.base.as_object()
        val result = obj.call0("get_playback_position")
        return result.as_float()

    # Seek to position in seconds
    pub fn seek(mut self, to_position: f64):
        val obj = self.base.as_object()
        val pos_var = variant.Variant::from_float(to_position)
        obj.call1("seek", pos_var)

    # Set audio bus (default: "Master")
    pub fn set_bus(mut self, bus: String):
        val obj = self.base.as_object()
        val bus_var = variant.Variant::from_string(bus)
        obj.call1("set_bus", bus_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_stopped() -> bool:
        """Check if audio is stopped (not playing).

        Returns:
            true if not playing

        Example:
            player.is_stopped()  # → false
        """
        return not self.is_playing()

    fn get_position() -> f64:
        """Get playback position (alias for get_playback_position).

        Returns:
            Position in seconds

        Example:
            player.get_position()  # → 1.5
        """
        return self.get_playback_position()

    var fn restart():
        """Restart audio from beginning.

        Example:
            player.restart()
        """
        self.stop()
        self.play(0.0)

    pub fn set_volume_linear(mut self, volume: f32):
        """Set volume using linear scale (0.0 to 1.0).

        Args:
            volume: Linear volume (0.0 = silent, 1.0 = full)

        Example:
            player.set_volume_linear(0.5)
        """
        val db = core.math.linear_to_db(volume)
        self.set_volume_db(db)

    fn summary() -> String:
        """Get audio stream player summary.

        Returns:
            Human-readable summary

        Example:
            player.summary()
            # → "AudioStreamPlayer: playing at 1.5s, volume=-6.0db"
        """
        val state = if self.is_playing() { "playing" } else { "stopped" }
        val pos = self.get_position()
        val vol = self.get_volume_db()
        return "AudioStreamPlayer: {state} at {pos}s, volume={vol}db"


# Audio Stream Player 2D (2D Spatial Audio)
# For positional sound effects in 2D games
pub struct AudioStreamPlayer2D:
    base: node2d.Node2D

impl AudioStreamPlayer2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AudioStreamPlayer2D:
        return AudioStreamPlayer2D(base: node2d.Node2D::from_ptr(ptr))

    pub fn set_stream(mut self, stream: resource.Resource):
        val obj = self.base.as_node().as_object()
        val stream_var = variant.Variant::from_object(stream.as_object())
        obj.call1("set_stream", stream_var)

    pub fn play(mut self, from_position: f64 = 0.0):
        val obj = self.base.as_node().as_object()
        val pos_var = variant.Variant::from_float(from_position)
        obj.call1("play", pos_var)

    pub fn stop(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("stop")

    pub fn is_playing(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_playing")
        return result.as_bool()

    pub fn set_volume_db(mut self, volume_db: f32):
        val obj = self.base.as_node().as_object()
        val vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call1("set_volume_db", vol_var)

    # Set maximum distance for attenuation
    pub fn set_max_distance(mut self, pixels: f32):
        val obj = self.base.as_node().as_object()
        val dist_var = variant.Variant::from_float(pixels as f64)
        obj.call1("set_max_distance", dist_var)

    # Set attenuation curve (0.0 = linear, >1.0 = exponential)
    pub fn set_attenuation(mut self, curve: f32):
        val obj = self.base.as_node().as_object()
        val curve_var = variant.Variant::from_float(curve as f64)
        obj.call1("set_attenuation", curve_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_stopped() -> bool:
        """Check if audio is stopped (not playing).

        Returns:
            true if not playing

        Example:
            player.is_stopped()  # → false
        """
        return not self.is_playing()

    var fn restart():
        """Restart audio from beginning.

        Example:
            player.restart()
        """
        self.stop()
        self.play(0.0)

    pub fn set_volume_linear(mut self, volume: f32):
        """Set volume using linear scale (0.0 to 1.0).

        Args:
            volume: Linear volume (0.0 = silent, 1.0 = full)

        Example:
            player.set_volume_linear(0.5)
        """
        val db = core.math.linear_to_db(volume)
        self.set_volume_db(db)

    fn summary() -> String:
        """Get audio stream player 2D summary.

        Returns:
            Human-readable summary

        Example:
            player.summary()
            # → "AudioStreamPlayer2D: playing"
        """
        val state = if self.is_playing() { "playing" } else { "stopped" }
        return "AudioStreamPlayer2D: {state}"


# Audio Stream Player 3D (3D Spatial Audio)
# For positional sound effects in 3D games
pub struct AudioStreamPlayer3D:
    base: node3d.Node3D

impl AudioStreamPlayer3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> AudioStreamPlayer3D:
        return AudioStreamPlayer3D(base: node3d.Node3D::from_ptr(ptr))

    pub fn set_stream(mut self, stream: resource.Resource):
        val obj = self.base.as_node().as_object()
        val stream_var = variant.Variant::from_object(stream.as_object())
        obj.call1("set_stream", stream_var)

    pub fn play(mut self, from_position: f64 = 0.0):
        val obj = self.base.as_node().as_object()
        val pos_var = variant.Variant::from_float(from_position)
        obj.call1("play", pos_var)

    pub fn stop(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("stop")

    pub fn is_playing(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_playing")
        return result.as_bool()

    pub fn set_volume_db(mut self, volume_db: f32):
        val obj = self.base.as_node().as_object()
        val vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call1("set_volume_db", vol_var)

    # Set unit size (default: 10.0)
    pub fn set_unit_size(mut self, size: f32):
        val obj = self.base.as_node().as_object()
        val size_var = variant.Variant::from_float(size as f64)
        obj.call1("set_unit_size", size_var)

    # Set maximum distance for attenuation
    pub fn set_max_distance(mut self, meters: f32):
        val obj = self.base.as_node().as_object()
        val dist_var = variant.Variant::from_float(meters as f64)
        obj.call1("set_max_distance", dist_var)

    # Set attenuation model
    pub fn set_attenuation_model(mut self, model: AttenuationModel):
        val obj = self.base.as_node().as_object()
        val model_var = variant.Variant::from_int(model as i64)
        obj.call1("set_attenuation_model", model_var)

    # Enable/disable Doppler effect
    pub fn set_doppler_tracking(mut self, mode: DopplerTracking):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant::from_int(mode as i64)
        obj.call1("set_doppler_tracking", mode_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_stopped() -> bool:
        """Check if audio is stopped (not playing).

        Returns:
            true if not playing

        Example:
            player.is_stopped()  # → false
        """
        return not self.is_playing()

    var fn restart():
        """Restart audio from beginning.

        Example:
            player.restart()
        """
        self.stop()
        self.play(0.0)

    pub fn set_volume_linear(mut self, volume: f32):
        """Set volume using linear scale (0.0 to 1.0).

        Args:
            volume: Linear volume (0.0 = silent, 1.0 = full)

        Example:
            player.set_volume_linear(0.5)
        """
        val db = core.math.linear_to_db(volume)
        self.set_volume_db(db)

    fn summary() -> String:
        """Get audio stream player 3D summary.

        Returns:
            Human-readable summary

        Example:
            player.summary()
            # → "AudioStreamPlayer3D: playing"
        """
        val state = if self.is_playing() { "playing" } else { "stopped" }
        return "AudioStreamPlayer3D: {state}"


# Attenuation models for 3D audio
pub enum AttenuationModel:
    InverseDistance = 0       # Realistic, inverse square law
    InverseSquareDistance = 1 # More realistic, inverse square law
    Logarithmic = 2           # Smooth falloff
    Disabled = 3              # No distance attenuation

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_inverse_distance(self) -> bool:
        """Check if model is InverseDistance.

        Returns:
            true if InverseDistance variant

        Example:
            model.is_inverse_distance()  # → true
        """
        match self:
            case InverseDistance: return true
            case _: return false

    pub fn is_inverse_square_distance(self) -> bool:
        """Check if model is InverseSquareDistance.

        Returns:
            true if InverseSquareDistance variant

        Example:
            model.is_inverse_square_distance()  # → false
        """
        match self:
            case InverseSquareDistance: return true
            case _: return false

    pub fn is_logarithmic(self) -> bool:
        """Check if model is Logarithmic.

        Returns:
            true if Logarithmic variant

        Example:
            model.is_logarithmic()  # → false
        """
        match self:
            case Logarithmic: return true
            case _: return false

    pub fn is_disabled(self) -> bool:
        """Check if attenuation is disabled.

        Returns:
            true if Disabled variant

        Example:
            model.is_disabled()  # → false
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn is_realistic(self) -> bool:
        """Check if model is realistic (inverse distance-based).

        Returns:
            true if InverseDistance or InverseSquareDistance

        Example:
            model.is_realistic()  # → true
        """
        match self:
            case InverseDistance | InverseSquareDistance: return true
            case _: return false

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            String representation

        Example:
            model.to_string()  # → "InverseDistance"
        """
        match self:
            case InverseDistance: return "InverseDistance"
            case InverseSquareDistance: return "InverseSquareDistance"
            case Logarithmic: return "Logarithmic"
            case Disabled: return "Disabled"

    fn description() -> String:
        """Get attenuation model description.

        Returns:
            Human-readable description

        Example:
            AttenuationModel::InverseDistance.description()
            # → "Volume decreases proportional to 1/distance"
        """
        match self:
            case InverseDistance: return "Volume decreases proportional to 1/distance"
            case InverseSquareDistance: return "Volume decreases proportional to 1/(distance²)"
            case Logarithmic: return "Logarithmic attenuation (more gradual)"
            case Disabled: return "No distance-based attenuation"

    fn summary() -> String:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            model.summary()
            # → "AttenuationModel: InverseDistance"
        """
        val name = self.to_string()
        return "AttenuationModel: {name}"

# Doppler tracking modes
pub enum DopplerTracking:
    Disabled = 0              # No Doppler effect
    IdleStep = 1              # Update during idle
    PhysicsStep = 2           # Update during physics

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_disabled(self) -> bool:
        """Check if Doppler tracking is disabled.

        Returns:
            true if Disabled variant

        Example:
            mode.is_disabled()  # → true
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn is_idle_step(self) -> bool:
        """Check if tracking during idle step.

        Returns:
            true if IdleStep variant

        Example:
            mode.is_idle_step()  # → false
        """
        match self:
            case IdleStep: return true
            case _: return false

    pub fn is_physics_step(self) -> bool:
        """Check if tracking during physics step.

        Returns:
            true if PhysicsStep variant

        Example:
            mode.is_physics_step()  # → false
        """
        match self:
            case PhysicsStep: return true
            case _: return false

    pub fn is_enabled(self) -> bool:
        """Check if Doppler tracking is enabled.

        Returns:
            true if not Disabled

        Example:
            mode.is_enabled()  # → false
        """
        return not self.is_disabled()

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            String representation

        Example:
            mode.to_string()  # → "PhysicsStep"
        """
        match self:
            case Disabled: return "Disabled"
            case IdleStep: return "IdleStep"
            case PhysicsStep: return "PhysicsStep"

    fn description() -> String:
        """Get Doppler tracking description.

        Returns:
            Human-readable description

        Example:
            DopplerTracking::IdleStep.description()
            # → "Track Doppler effect during idle step (every frame)"
        """
        match self:
            case Disabled: return "Doppler effect disabled (no pitch shift)"
            case IdleStep: return "Track Doppler effect during idle step (every frame)"
            case PhysicsStep: return "Track Doppler effect during physics step (fixed rate)"

    fn summary() -> String:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            mode.summary()
            # → "DopplerTracking: PhysicsStep"
        """
        val name = self.to_string()
        return "DopplerTracking: {name}"


# Audio Bus Manager
# For managing audio buses and effects
pub struct AudioServer:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl AudioServer:
    # Get AudioServer singleton
    pub fn get_singleton() -> AudioServer:
        val ptr = ffi.godot_get_singleton("AudioServer")
        return AudioServer(singleton_ptr: ptr)

    # Set bus volume in decibels
    pub fn set_bus_volume_db(mut self, bus_idx: i32, volume_db: f32):
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val idx_var = variant.Variant::from_int(bus_idx as i64)
        val vol_var = variant.Variant::from_float(volume_db as f64)
        obj.call2("set_bus_volume_db", idx_var, vol_var)

    # Get bus volume in decibels
    pub fn get_bus_volume_db(self, bus_idx: i32) -> f32:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val idx_var = variant.Variant::from_int(bus_idx as i64)
        val result = obj.call1("get_bus_volume_db", idx_var)
        return result.as_float() as f32

    # Mute/unmute a bus
    pub fn set_bus_mute(mut self, bus_idx: i32, enable: bool):
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val idx_var = variant.Variant::from_int(bus_idx as i64)
        val mute_var = variant.Variant::from_bool(enable)
        obj.call2("set_bus_mute", idx_var, mute_var)

    # Check if bus is muted
    pub fn is_bus_mute(self, bus_idx: i32) -> bool:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val idx_var = variant.Variant::from_int(bus_idx as i64)
        val result = obj.call1("is_bus_mute", idx_var)
        return result.as_bool()

    # Get bus index by name
    pub fn get_bus_index(self, bus_name: String) -> i32:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val name_var = variant.Variant::from_string(bus_name)
        val result = obj.call1("get_bus_index", name_var)
        return result.as_int() as i32

    # Get number of buses
    pub fn get_bus_count(self) -> i32:
        val obj = variant.Object::from_ptr(self.singleton_ptr)
        val result = obj.call0("get_bus_count")
        return result.as_int() as i32

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn mute_bus(mut self, bus_idx: i32):
        """Mute a bus.

        Args:
            bus_idx: Bus index

        Example:
            audio.mute_bus(0)
        """
        self.set_bus_mute(bus_idx, true)

    pub fn unmute_bus(mut self, bus_idx: i32):
        """Unmute a bus.

        Args:
            bus_idx: Bus index

        Example:
            audio.unmute_bus(0)
        """
        self.set_bus_mute(bus_idx, false)

    pub fn toggle_bus_mute(mut self, bus_idx: i32):
        """Toggle bus mute state.

        Args:
            bus_idx: Bus index

        Example:
            audio.toggle_bus_mute(0)
        """
        val current = self.is_bus_mute(bus_idx)
        self.set_bus_mute(bus_idx, not current)

    pub fn has_buses(self) -> bool:
        """Check if any audio buses exist.

        Returns:
            true if bus count > 0

        Example:
            audio.has_buses()  # → true
        """
        return self.get_bus_count() > 0

    fn summary() -> String:
        """Get audio server summary.

        Returns:
            Human-readable summary

        Example:
            audio.summary()
            # → "AudioServer: 5 buses"
        """
        val count = self.get_bus_count()
        return "AudioServer: {count} buses"


# Helper functions for common audio operations

# Convert linear volume (0.0 to 1.0) to decibels
pub fn linear_to_db(linear: f32) -> f32:
    if linear <= 0.0:
        return -80.0  # Effectively muted
    return 20.0 * log10(linear)

# Convert decibels to linear volume
pub fn db_to_linear(db: f32) -> f32:
    return pow(10.0, db / 20.0)

# Helper for logarithm base 10
fn log10(x: f32) -> f32:
    # ln(x) / ln(10)
    return log(x) / 2.302585

# Helper for natural logarithm
fn log(x: f32) -> f32:
    """Natural logarithm using core math library."""
    return math.log(x as f64) as f32

# Helper for power function
fn pow(base: f32, exp: f32) -> f32:
    """Power function using core math library."""
    return math.pow(base as f64, exp as f64) as f32
