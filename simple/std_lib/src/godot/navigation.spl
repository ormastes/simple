# Godot Navigation System
#
# Type-safe wrappers for Godot's navigation and pathfinding
#
# Features:
# - NavigationRegion2D/3D (navigation meshes)
# - NavigationAgent2D/3D (AI pathfinding)
# - NavigationObstacle2D/3D (dynamic obstacles)
# - NavigationServer2D/3D (low-level API)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_navigationagent2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.node3d
import godot.resource

mod navigation

# NavigationRegion2D
# 2D navigation mesh region
pub struct NavigationRegion2D extends godot.node2d.Node2D:

impl NavigationRegion2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationRegion2D:
        return NavigationRegion2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set navigation polygon
    pub fn set_navigation_polygon(mut self, navpoly: resource.Resource):
        let obj = self.base.as_node().as_object()
        let nav_var = variant.Variant::from_object(navpoly.as_object())
        obj.call1("set_navigation_polygon", nav_var)

    # Set enabled
    pub fn set_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let en_var = variant.Variant::from_bool(enabled)
        obj.call1("set_enabled", en_var)


# NavigationAgent2D
# 2D AI agent with pathfinding
pub struct NavigationAgent2D extends godot.node2d.Node2D:

impl NavigationAgent2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationAgent2D:
        return NavigationAgent2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set target position
    pub fn set_target_position(mut self, x: f64, y: f64):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector2 variant

    # Get next path position
    pub fn get_next_path_position(self) -> (f64, f64):
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_next_path_position")
        # TODO: [stdlib][P2] Parse Vector2
        return (0.0, 0.0)  # Placeholder

    # Check if target reached
    pub fn is_target_reached(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_target_reached")
        return result.as_bool()

    # Check if target reachable
    pub fn is_target_reachable(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_target_reachable")
        return result.as_bool()

    # Check if navigation finished
    pub fn is_navigation_finished(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_navigation_finished")
        return result.as_bool()

    # Get distance to target
    pub fn distance_to_target(self) -> f64:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("distance_to_target")
        return result.as_float()

    # Set max speed
    pub fn set_max_speed(mut self, speed: f64):
        let obj = self.base.as_node().as_object()
        let speed_var = variant.Variant::from_float(speed)
        obj.call1("set_max_speed", speed_var)

    # Set path desired distance (how close to get to waypoint)
    pub fn set_path_desired_distance(mut self, distance: f64):
        let obj = self.base.as_node().as_object()
        let dist_var = variant.Variant::from_float(distance)
        obj.call1("set_path_desired_distance", dist_var)

    # Set target desired distance (how close to get to final target)
    pub fn set_target_desired_distance(mut self, distance: f64):
        let obj = self.base.as_node().as_object()
        let dist_var = variant.Variant::from_float(distance)
        obj.call1("set_target_desired_distance", dist_var)

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        let obj = self.base.as_node().as_object()
        let radius_var = variant.Variant::from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let avoid_var = variant.Variant::from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)


# NavigationRegion3D
# 3D navigation mesh region
pub struct NavigationRegion3D extends godot.node3d.Node3D:

impl NavigationRegion3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationRegion3D:
        return NavigationRegion3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set navigation mesh
    pub fn set_navigation_mesh(mut self, navmesh: resource.Resource):
        let obj = self.base.as_node().as_object()
        let nav_var = variant.Variant::from_object(navmesh.as_object())
        obj.call1("set_navigation_mesh", nav_var)

    # Set enabled
    pub fn set_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let en_var = variant.Variant::from_bool(enabled)
        obj.call1("set_enabled", en_var)

    # Bake navigation mesh
    pub fn bake_navigation_mesh(mut self):
        let obj = self.base.as_node().as_object()
        obj.call0("bake_navigation_mesh")


# NavigationAgent3D
# 3D AI agent with pathfinding
pub struct NavigationAgent3D extends godot.node3d.Node3D:

impl NavigationAgent3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationAgent3D:
        return NavigationAgent3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set target position
    pub fn set_target_position(mut self, x: f64, y: f64, z: f64):
        let obj = self.base.as_node().as_object()
        # TODO: [stdlib][P3] Create Vector3 variant

    # Get next path position
    pub fn get_next_path_position(self) -> (f64, f64, f64):
        let obj = self.base.as_node().as_object()
        let result = obj.call0("get_next_path_position")
        # TODO: [stdlib][P2] Parse Vector3
        return (0.0, 0.0, 0.0)  # Placeholder

    # Check if target reached
    pub fn is_target_reached(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_target_reached")
        return result.as_bool()

    # Check if target reachable
    pub fn is_target_reachable(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_target_reachable")
        return result.as_bool()

    # Check if navigation finished
    pub fn is_navigation_finished(self) -> bool:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("is_navigation_finished")
        return result.as_bool()

    # Get distance to target
    pub fn distance_to_target(self) -> f64:
        let obj = self.base.as_node().as_object()
        let result = obj.call0("distance_to_target")
        return result.as_float()

    # Set max speed
    pub fn set_max_speed(mut self, speed: f64):
        let obj = self.base.as_node().as_object()
        let speed_var = variant.Variant::from_float(speed)
        obj.call1("set_max_speed", speed_var)

    # Set path desired distance
    pub fn set_path_desired_distance(mut self, distance: f64):
        let obj = self.base.as_node().as_object()
        let dist_var = variant.Variant::from_float(distance)
        obj.call1("set_path_desired_distance", dist_var)

    # Set target desired distance
    pub fn set_target_desired_distance(mut self, distance: f64):
        let obj = self.base.as_node().as_object()
        let dist_var = variant.Variant::from_float(distance)
        obj.call1("set_target_desired_distance", dist_var)

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        let obj = self.base.as_node().as_object()
        let radius_var = variant.Variant::from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let avoid_var = variant.Variant::from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)

    # Set height offset
    pub fn set_path_height_offset(mut self, offset: f64):
        let obj = self.base.as_node().as_object()
        let offset_var = variant.Variant::from_float(offset)
        obj.call1("set_path_height_offset", offset_var)


# NavigationObstacle2D
# Dynamic obstacle for avoidance
pub struct NavigationObstacle2D extends godot.node2d.Node2D:

impl NavigationObstacle2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationObstacle2D:
        return NavigationObstacle2D(base: godot.node2d.Node2D::from_ptr(ptr))

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        let obj = self.base.as_node().as_object()
        let radius_var = variant.Variant::from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let avoid_var = variant.Variant::from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)


# NavigationObstacle3D
# Dynamic obstacle for 3D avoidance
pub struct NavigationObstacle3D extends godot.node3d.Node3D:

impl NavigationObstacle3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationObstacle3D:
        return NavigationObstacle3D(base: godot.node3d.Node3D::from_ptr(ptr))

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        let obj = self.base.as_node().as_object()
        let radius_var = variant.Variant::from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set height
    pub fn set_height(mut self, height: f64):
        let obj = self.base.as_node().as_object()
        let height_var = variant.Variant::from_float(height)
        obj.call1("set_height", height_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        let obj = self.base.as_node().as_object()
        let avoid_var = variant.Variant::from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)


# NavigationServer2D
# Low-level 2D navigation API
pub struct NavigationServer2D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl NavigationServer2D:
    # Get singleton
    pub fn get_singleton() -> NavigationServer2D:
        let ptr = ffi.godot_get_singleton("NavigationServer2D")
        return NavigationServer2D(singleton_ptr: ptr)

    # Get simple path (A* pathfinding)
    pub fn get_simple_path(self, start_x: f64, start_y: f64, end_x: f64, end_y: f64) -> Array[(f64, f64)]:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        # TODO: [stdlib][P2] Create Vector2 variants and parse result
        return []  # Placeholder


# NavigationServer3D
# Low-level 3D navigation API
pub struct NavigationServer3D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl NavigationServer3D:
    # Get singleton
    pub fn get_singleton() -> NavigationServer3D:
        let ptr = ffi.godot_get_singleton("NavigationServer3D")
        return NavigationServer3D(singleton_ptr: ptr)

    # Get simple path (A* pathfinding)
    pub fn get_simple_path(self, start_x: f64, start_y: f64, start_z: f64, end_x: f64, end_y: f64, end_z: f64) -> Array[(f64, f64, f64)]:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        # TODO: [stdlib][P2] Create Vector3 variants and parse result
        return []  # Placeholder


# Array placeholder
pub struct Array[T]:
    items: Vec[T]
