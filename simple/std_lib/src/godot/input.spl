# Godot Input System
#
# Input handling for keyboard, mouse, and gamepad.
# Uses Godot's Input singleton for cross-platform input.
#
# Reference: https://docs.godotengine.org/en/stable/classes/class_input.html

import godot.ffi
import godot.variant
import godot.object

# Input singleton wrapper
pub struct Input:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl Input:
    # Get the Input singleton
    pub fn get_singleton() -> Input:
        let ptr = godot_get_singleton("Input")
        return Input(singleton_ptr: ptr)

    # Keyboard input
    pub fn is_key_pressed(self, keycode: KeyCode) -> bool:
        let key_var = variant.Variant::from_int(keycode as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("is_key_pressed", key_var)
        return result.as_bool()

    pub fn is_key_just_pressed(self, keycode: KeyCode) -> bool:
        # Check if key was just pressed this frame
        let key_var = variant.Variant::from_int(keycode as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("is_key_just_pressed", key_var)
        return result.as_bool()

    pub fn is_key_just_released(self, keycode: KeyCode) -> bool:
        let key_var = variant.Variant::from_int(keycode as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("is_key_just_released", key_var)
        return result.as_bool()

    # Action-based input (configured in project settings)
    pub fn is_action_pressed(self, action: String) -> bool:
        let action_var = variant.Variant::from_string(action)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("is_action_pressed", action_var)
        return result.as_bool()

    pub fn is_action_just_pressed(self, action: String) -> bool:
        let action_var = variant.Variant::from_string(action)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("is_action_just_pressed", action_var)
        return result.as_bool()

    pub fn is_action_just_released(self, action: String) -> bool:
        let action_var = variant.Variant::from_string(action)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("is_action_just_released", action_var)
        return result.as_bool()

    pub fn get_action_strength(self, action: String) -> f64:
        let action_var = variant.Variant::from_string(action)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("get_action_strength", action_var)
        return result.as_float()

    # Mouse input
    pub fn get_mouse_position(self) -> (f64, f64):
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_mouse_position")
        return result.as_vector2()

    pub fn is_mouse_button_pressed(self, button: MouseButton) -> bool:
        let button_var = variant.Variant::from_int(button as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call1("is_mouse_button_pressed", button_var)
        return result.as_bool()

    # Mouse mode (visible, captured, hidden, etc.)
    pub fn set_mouse_mode(mut self, mode: MouseMode):
        let mode_var = variant.Variant::from_int(mode as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        obj.call1("set_mouse_mode", mode_var)

    pub fn get_mouse_mode(self) -> MouseMode:
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_mouse_mode")
        return result.as_int() as MouseMode

    # Gamepad/Joypad input
    pub fn is_joy_button_pressed(self, device: i32, button: JoyButton) -> bool:
        let device_var = variant.Variant::from_int(device as i64)
        let button_var = variant.Variant::from_int(button as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call2("is_joy_button_pressed", device_var, button_var)
        return result.as_bool()

    pub fn get_joy_axis(self, device: i32, axis: JoyAxis) -> f64:
        let device_var = variant.Variant::from_int(device as i64)
        let axis_var = variant.Variant::from_int(axis as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call2("get_joy_axis", device_var, axis_var)
        return result.as_float()

    pub fn get_connected_joypads(self) -> Array[i32]:
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_connected_joypads")
        # TODO: [stdlib][P3] Convert array variant to Array[i32]
        return Array[i32]::new()

    # Vibration (gamepad rumble)
    pub fn start_joy_vibration(mut self, device: i32, weak: f64, strong: f64, duration: f64):
        let device_var = variant.Variant::from_int(device as i64)
        let weak_var = variant.Variant::from_float(weak)
        let strong_var = variant.Variant::from_float(strong)
        let duration_var = variant.Variant::from_float(duration)
        
        let obj = object.Object::from_ptr(self.singleton_ptr)
        let mut args = Array[variant.Variant]::new()
        args.push(device_var)
        args.push(weak_var)
        args.push(strong_var)
        args.push(duration_var)
        obj.call("start_joy_vibration", args)

    pub fn stop_joy_vibration(mut self, device: i32):
        let device_var = variant.Variant::from_int(device as i64)
        let obj = object.Object::from_ptr(self.singleton_ptr)
        obj.call1("stop_joy_vibration", device_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn hide_mouse(mut self):
        """Hide mouse cursor.

        Example:
            input.hide_mouse()
        """
        self.set_mouse_mode(MouseMode::Hidden)

    pub fn show_mouse(mut self):
        """Show mouse cursor.

        Example:
            input.show_mouse()
        """
        self.set_mouse_mode(MouseMode::Visible)

    pub fn capture_mouse(mut self):
        """Capture mouse (confine to window).

        Example:
            input.capture_mouse()
        """
        self.set_mouse_mode(MouseMode::Captured)

    pub fn is_mouse_visible(self) -> bool:
        """Check if mouse is visible.

        Returns:
            true if MouseMode::Visible

        Example:
            input.is_mouse_visible()  # → true
        """
        return self.get_mouse_mode() == MouseMode::Visible

    pub fn is_mouse_hidden(self) -> bool:
        """Check if mouse is hidden.

        Returns:
            true if MouseMode::Hidden

        Example:
            input.is_mouse_hidden()  # → false
        """
        return self.get_mouse_mode() == MouseMode::Hidden

    pub fn is_mouse_captured(self) -> bool:
        """Check if mouse is captured.

        Returns:
            true if MouseMode::Captured

        Example:
            input.is_mouse_captured()  # → false
        """
        return self.get_mouse_mode() == MouseMode::Captured

    pub fn vibrate_gamepad(mut self, device: i32, intensity: f64, duration: f64):
        """Vibrate gamepad with uniform intensity.

        Args:
            device: Gamepad device index
            intensity: Vibration intensity (0.0-1.0)
            duration: Duration in seconds

        Example:
            input.vibrate_gamepad(0, 0.5, 0.2)
        """
        self.start_joy_vibration(device, intensity, intensity, duration)

    pub fn summary(self) -> String:
        """Get input system summary.

        Returns:
            Human-readable summary

        Example:
            input.summary()
            # → "Input: mouse visible"
        """
        let mouse_mode = if self.is_mouse_visible() {
            "mouse visible"
        } elif self.is_mouse_hidden() {
            "mouse hidden"
        } elif self.is_mouse_captured() {
            "mouse captured"
        } else {
            "mouse mode unknown"
        }
        return "Input: {mouse_mode}"

# Key codes (subset of common keys)
pub enum KeyCode:
    Space = 32
    A = 65
    B = 66
    C = 67
    D = 68
    E = 69
    F = 70
    G = 71
    H = 72
    I = 73
    J = 74
    K = 75
    L = 76
    M = 77
    N = 78
    O = 79
    P = 80
    Q = 81
    R = 82
    S = 83
    T = 84
    U = 85
    V = 86
    W = 87
    X = 88
    Y = 89
    Z = 90
    Escape = 4194305
    Enter = 4194309
    Tab = 4194306
    Backspace = 4194308
    Left = 4194319
    Right = 4194321
    Up = 4194320
    Down = 4194322
    Shift = 4194325
    Ctrl = 4194326
    Alt = 4194328

impl KeyCode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_letter(self) -> bool:
        """Check if key is a letter (A-Z).

        Returns:
            true for letter keys

        Example:
            KeyCode::A.is_letter()  # → true
            KeyCode::Enter.is_letter()  # → false
        """
        let code = self as i32
        code >= 65 and code <= 90

    pub fn is_arrow(self) -> bool:
        """Check if key is an arrow key.

        Returns:
            true for arrow keys

        Example:
            KeyCode::Up.is_arrow()  # → true
        """
        self == KeyCode::Left or self == KeyCode::Right or
        self == KeyCode::Up or self == KeyCode::Down

    pub fn is_modifier(self) -> bool:
        """Check if key is a modifier (Shift, Ctrl, Alt).

        Returns:
            true for modifier keys

        Example:
            KeyCode::Ctrl.is_modifier()  # → true
        """
        self == KeyCode::Shift or self == KeyCode::Ctrl or self == KeyCode::Alt

    pub fn is_special(self) -> bool:
        """Check if key is a special key (not letter/modifier).

        Returns:
            true for special keys

        Example:
            KeyCode::Escape.is_special()  # → true
        """
        not (self.is_letter() or self.is_modifier())

    pub fn to_string(self) -> String:
        """Convert key code to string.

        Returns:
            Key name

        Example:
            KeyCode::Enter.to_string()  # → "enter"
        """
        if self == KeyCode::Space: "space"
        elif self.is_letter():
            let code = self as i32
            let offset = code - 65
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
             "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"][offset]
        elif self == KeyCode::Escape: "escape"
        elif self == KeyCode::Enter: "enter"
        elif self == KeyCode::Tab: "tab"
        elif self == KeyCode::Backspace: "backspace"
        elif self == KeyCode::Left: "left"
        elif self == KeyCode::Right: "right"
        elif self == KeyCode::Up: "up"
        elif self == KeyCode::Down: "down"
        elif self == KeyCode::Shift: "shift"
        elif self == KeyCode::Ctrl: "ctrl"
        elif self == KeyCode::Alt: "alt"
        else: "unknown"

    pub fn summary(self) -> String:
        """Get summary of key code.

        Returns:
            Human-readable summary

        Example:
            KeyCode::A.summary()
            # → "KeyCode: a (letter)"
        """
        let name = self.to_string()
        let mut attrs: Array[String] = []

        if self.is_letter():
            attrs.push("letter")
        if self.is_arrow():
            attrs.push("arrow")
        if self.is_modifier():
            attrs.push("modifier")
        if self.is_special():
            attrs.push("special")

        let attrs_str = attrs.join(", ")
        return "KeyCode: {name} ({attrs_str})"

# Mouse buttons
pub enum MouseButton:
    Left = 1
    Right = 2
    Middle = 3
    WheelUp = 4
    WheelDown = 5
    WheelLeft = 6
    WheelRight = 7
    Extra1 = 8
    Extra2 = 9

impl MouseButton:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_click_button(self) -> bool:
        """Check if button is a click button (Left, Right, Middle).

        Returns:
            true for click buttons

        Example:
            MouseButton::Left.is_click_button()  # → true
            MouseButton::WheelUp.is_click_button()  # → false
        """
        self == MouseButton::Left or self == MouseButton::Right or self == MouseButton::Middle

    pub fn is_wheel(self) -> bool:
        """Check if button is a wheel event.

        Returns:
            true for wheel events

        Example:
            MouseButton::WheelUp.is_wheel()  # → true
        """
        self == MouseButton::WheelUp or self == MouseButton::WheelDown or
        self == MouseButton::WheelLeft or self == MouseButton::WheelRight

    pub fn is_extra(self) -> bool:
        """Check if button is an extra button.

        Returns:
            true for Extra1 or Extra2

        Example:
            MouseButton::Extra1.is_extra()  # → true
        """
        self == MouseButton::Extra1 or self == MouseButton::Extra2

    pub fn to_string(self) -> String:
        """Convert mouse button to string.

        Returns:
            Button name

        Example:
            MouseButton::Left.to_string()  # → "left"
        """
        if self == MouseButton::Left: "left"
        elif self == MouseButton::Right: "right"
        elif self == MouseButton::Middle: "middle"
        elif self == MouseButton::WheelUp: "wheel-up"
        elif self == MouseButton::WheelDown: "wheel-down"
        elif self == MouseButton::WheelLeft: "wheel-left"
        elif self == MouseButton::WheelRight: "wheel-right"
        elif self == MouseButton::Extra1: "extra1"
        elif self == MouseButton::Extra2: "extra2"
        else: "unknown"

    pub fn summary(self) -> String:
        """Get summary of mouse button.

        Returns:
            Human-readable summary

        Example:
            MouseButton::WheelUp.summary()
            # → "MouseButton: wheel-up (wheel)"
        """
        let name = self.to_string()
        let mut attrs: Array[String] = []

        if self.is_click_button():
            attrs.push("click")
        if self.is_wheel():
            attrs.push("wheel")
        if self.is_extra():
            attrs.push("extra")

        let attrs_str = attrs.join(", ")
        return "MouseButton: {name} ({attrs_str})"

# Mouse modes
pub enum MouseMode:
    Visible = 0
    Hidden = 1
    Captured = 2
    Confined = 3

impl MouseMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn allows_movement(self) -> bool:
        """Check if mode allows free mouse movement.

        Returns:
            true if mouse can move freely

        Example:
            MouseMode::Visible.allows_movement()  # → true
            MouseMode::Captured.allows_movement()  # → false
        """
        self == MouseMode::Visible or self == MouseMode::Hidden

    pub fn is_locked(self) -> bool:
        """Check if mouse is locked/captured.

        Returns:
            true for Captured or Confined

        Example:
            MouseMode::Captured.is_locked()  # → true
        """
        self == MouseMode::Captured or self == MouseMode::Confined

    pub fn is_visible(self) -> bool:
        """Check if cursor is visible.

        Returns:
            true if cursor is shown

        Example:
            MouseMode::Visible.is_visible()  # → true
            MouseMode::Hidden.is_visible()  # → false
        """
        self == MouseMode::Visible or self == MouseMode::Confined

    pub fn to_string(self) -> String:
        """Convert mouse mode to string.

        Returns:
            Mode name

        Example:
            MouseMode::Captured.to_string()  # → "captured"
        """
        if self == MouseMode::Visible: "visible"
        elif self == MouseMode::Hidden: "hidden"
        elif self == MouseMode::Captured: "captured"
        elif self == MouseMode::Confined: "confined"
        else: "unknown"

    pub fn summary(self) -> String:
        """Get summary of mouse mode.

        Returns:
            Human-readable summary

        Example:
            MouseMode::Captured.summary()
            # → "MouseMode: captured (locked, hidden)"
        """
        let name = self.to_string()
        let mut attrs: Array[String] = []

        if self.allows_movement():
            attrs.push("free movement")
        if self.is_locked():
            attrs.push("locked")
        if self.is_visible():
            attrs.push("visible")
        else:
            attrs.push("hidden")

        let attrs_str = attrs.join(", ")
        return "MouseMode: {name} ({attrs_str})"

# Joypad buttons (Xbox/PlayStation layout)
pub enum JoyButton:
    A = 0           # Xbox A / PlayStation X
    B = 1           # Xbox B / PlayStation Circle
    X = 2           # Xbox X / PlayStation Square
    Y = 3           # Xbox Y / PlayStation Triangle
    LeftShoulder = 4
    RightShoulder = 5
    LeftTrigger = 6
    RightTrigger = 7
    Select = 8
    Start = 9
    LeftStick = 10
    RightStick = 11
    DPadUp = 12
    DPadDown = 13
    DPadLeft = 14
    DPadRight = 15

impl JoyButton:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_face_button(self) -> bool:
        """Check if button is a face button (A, B, X, Y).

        Returns:
            true for face buttons

        Example:
            JoyButton::A.is_face_button()  # → true
        """
        self == JoyButton::A or self == JoyButton::B or
        self == JoyButton::X or self == JoyButton::Y

    pub fn is_shoulder(self) -> bool:
        """Check if button is a shoulder button.

        Returns:
            true for shoulder buttons

        Example:
            JoyButton::LeftShoulder.is_shoulder()  # → true
        """
        self == JoyButton::LeftShoulder or self == JoyButton::RightShoulder

    pub fn is_trigger(self) -> bool:
        """Check if button is a trigger.

        Returns:
            true for triggers

        Example:
            JoyButton::LeftTrigger.is_trigger()  # → true
        """
        self == JoyButton::LeftTrigger or self == JoyButton::RightTrigger

    pub fn is_menu_button(self) -> bool:
        """Check if button is a menu button (Select, Start).

        Returns:
            true for menu buttons

        Example:
            JoyButton::Start.is_menu_button()  # → true
        """
        self == JoyButton::Select or self == JoyButton::Start

    pub fn is_stick_button(self) -> bool:
        """Check if button is a stick click.

        Returns:
            true for stick buttons

        Example:
            JoyButton::LeftStick.is_stick_button()  # → true
        """
        self == JoyButton::LeftStick or self == JoyButton::RightStick

    pub fn is_dpad(self) -> bool:
        """Check if button is a D-Pad button.

        Returns:
            true for D-Pad

        Example:
            JoyButton::DPadUp.is_dpad()  # → true
        """
        self == JoyButton::DPadUp or self == JoyButton::DPadDown or
        self == JoyButton::DPadLeft or self == JoyButton::DPadRight

    pub fn to_string(self) -> String:
        """Convert joy button to string.

        Returns:
            Button name

        Example:
            JoyButton::A.to_string()  # → "a"
        """
        if self == JoyButton::A: "a"
        elif self == JoyButton::B: "b"
        elif self == JoyButton::X: "x"
        elif self == JoyButton::Y: "y"
        elif self == JoyButton::LeftShoulder: "left-shoulder"
        elif self == JoyButton::RightShoulder: "right-shoulder"
        elif self == JoyButton::LeftTrigger: "left-trigger"
        elif self == JoyButton::RightTrigger: "right-trigger"
        elif self == JoyButton::Select: "select"
        elif self == JoyButton::Start: "start"
        elif self == JoyButton::LeftStick: "left-stick"
        elif self == JoyButton::RightStick: "right-stick"
        elif self == JoyButton::DPadUp: "dpad-up"
        elif self == JoyButton::DPadDown: "dpad-down"
        elif self == JoyButton::DPadLeft: "dpad-left"
        elif self == JoyButton::DPadRight: "dpad-right"
        else: "unknown"

    pub fn summary(self) -> String:
        """Get summary of joy button.

        Returns:
            Human-readable summary

        Example:
            JoyButton::A.summary()
            # → "JoyButton: a (face button)"
        """
        let name = self.to_string()
        let mut attrs: Array[String] = []

        if self.is_face_button():
            attrs.push("face button")
        if self.is_shoulder():
            attrs.push("shoulder")
        if self.is_trigger():
            attrs.push("trigger")
        if self.is_menu_button():
            attrs.push("menu")
        if self.is_stick_button():
            attrs.push("stick")
        if self.is_dpad():
            attrs.push("dpad")

        let attrs_str = attrs.join(", ")
        return "JoyButton: {name} ({attrs_str})"

# Joypad axes
pub enum JoyAxis:
    LeftX = 0
    LeftY = 1
    RightX = 2
    RightY = 3
    TriggerLeft = 4
    TriggerRight = 5

impl JoyAxis:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_stick_axis(self) -> bool:
        """Check if axis is a stick axis.

        Returns:
            true for stick axes

        Example:
            JoyAxis::LeftX.is_stick_axis()  # → true
            JoyAxis::TriggerLeft.is_stick_axis()  # → false
        """
        self == JoyAxis::LeftX or self == JoyAxis::LeftY or
        self == JoyAxis::RightX or self == JoyAxis::RightY

    pub fn is_trigger_axis(self) -> bool:
        """Check if axis is a trigger axis.

        Returns:
            true for trigger axes

        Example:
            JoyAxis::TriggerLeft.is_trigger_axis()  # → true
        """
        self == JoyAxis::TriggerLeft or self == JoyAxis::TriggerRight

    pub fn is_horizontal(self) -> bool:
        """Check if axis is horizontal.

        Returns:
            true for X axes

        Example:
            JoyAxis::LeftX.is_horizontal()  # → true
        """
        self == JoyAxis::LeftX or self == JoyAxis::RightX

    pub fn is_vertical(self) -> bool:
        """Check if axis is vertical.

        Returns:
            true for Y axes

        Example:
            JoyAxis::LeftY.is_vertical()  # → true
        """
        self == JoyAxis::LeftY or self == JoyAxis::RightY

    pub fn is_left_stick(self) -> bool:
        """Check if axis is on left stick.

        Returns:
            true for LeftX or LeftY

        Example:
            JoyAxis::LeftX.is_left_stick()  # → true
        """
        self == JoyAxis::LeftX or self == JoyAxis::LeftY

    pub fn is_right_stick(self) -> bool:
        """Check if axis is on right stick.

        Returns:
            true for RightX or RightY

        Example:
            JoyAxis::RightX.is_right_stick()  # → true
        """
        self == JoyAxis::RightX or self == JoyAxis::RightY

    pub fn to_string(self) -> String:
        """Convert joy axis to string.

        Returns:
            Axis name

        Example:
            JoyAxis::LeftX.to_string()  # → "left-x"
        """
        if self == JoyAxis::LeftX: "left-x"
        elif self == JoyAxis::LeftY: "left-y"
        elif self == JoyAxis::RightX: "right-x"
        elif self == JoyAxis::RightY: "right-y"
        elif self == JoyAxis::TriggerLeft: "trigger-left"
        elif self == JoyAxis::TriggerRight: "trigger-right"
        else: "unknown"

    pub fn summary(self) -> String:
        """Get summary of joy axis.

        Returns:
            Human-readable summary

        Example:
            JoyAxis::LeftX.summary()
            # → "JoyAxis: left-x (stick, horizontal, left stick)"
        """
        let name = self.to_string()
        let mut attrs: Array[String] = []

        if self.is_stick_axis():
            attrs.push("stick")
        if self.is_trigger_axis():
            attrs.push("trigger")
        if self.is_horizontal():
            attrs.push("horizontal")
        if self.is_vertical():
            attrs.push("vertical")
        if self.is_left_stick():
            attrs.push("left stick")
        if self.is_right_stick():
            attrs.push("right stick")

        let attrs_str = attrs.join(", ")
        return "JoyAxis: {name} ({attrs_str})"

extern "C" fn godot_get_singleton(name: String) -> ffi.GDExtensionObjectPtr
