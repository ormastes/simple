# Godot Save/Load System
#
# Type-safe wrappers for Godot's file I/O and configuration
#
# Features:
# - ConfigFile (INI-style save files)
# - FileAccess (binary and text file I/O)
# - Save game management
# - Settings persistence
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_configfile.html

import godot.ffi
import godot.variant

mod saveload

# Config File
# INI-style configuration and save files
pub struct ConfigFile:
    ptr: ffi.GDExtensionObjectPtr

impl ConfigFile:
    # Create new config file
    pub fn new() -> ConfigFile:
        let ptr = ffi.godot_new_object("ConfigFile")
        return ConfigFile(ptr: ptr)

    # Load from file
    pub fn load(path: String) -> Result[ConfigFile, String]:
        let mut config = ConfigFile::new()
        let result = config.load_file(path)

        if result.is_ok():
            return Ok(config)
        else:
            return Err(result.unwrap_err())

    # Load file (instance method)
    fn load_file(mut self, path: String) -> Result[(), String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let path_var = variant.Variant::from_string(path)
        let result = obj.call1("load", path_var)

        let error_code = result.as_int()
        if error_code == 0:  # OK
            return Ok(())
        else:
            return Err("Failed to load config: error {error_code}")

    # Save to file
    pub fn save(self, path: String) -> Result[(), String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let path_var = variant.Variant::from_string(path)
        let result = obj.call1("save", path_var)

        let error_code = result.as_int()
        if error_code == 0:
            return Ok(())
        else:
            return Err("Failed to save config: error {error_code}")

    # Set value
    pub fn set_value(mut self, section: String, key: String, value: variant.Variant):
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        obj.call3("set_value", section_var, key_var, value)

    # Get value
    pub fn get_value(self, section: String, key: String, default: variant.Variant) -> variant.Variant:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        return obj.call3("get_value", section_var, key_var, default)

    # Check if has section
    pub fn has_section(self, section: String) -> bool:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let result = obj.call1("has_section", section_var)
        return result.as_bool()

    # Check if has key
    pub fn has_section_key(self, section: String, key: String) -> bool:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        let result = obj.call2("has_section_key", section_var, key_var)
        return result.as_bool()

    # Erase section
    pub fn erase_section(mut self, section: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        obj.call1("erase_section", section_var)

    # Erase key
    pub fn erase_section_key(mut self, section: String, key: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let key_var = variant.Variant::from_string(key)
        obj.call2("erase_section_key", section_var, key_var)

    # Get all sections
    pub fn get_sections(self) -> Array[String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_sections")
        # TODO: [stdlib][P2] Parse PackedStringArray
        return []  # Placeholder

    # Get all keys in section
    pub fn get_section_keys(self, section: String) -> Array[String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let section_var = variant.Variant::from_string(section)
        let result = obj.call1("get_section_keys", section_var)
        # TODO: [stdlib][P2] Parse PackedStringArray
        return []  # Placeholder

    # Clear all data
    pub fn clear(mut self):
        let obj = variant.Object::from_ptr(self.ptr)
        obj.call0("clear")


# File Access
# Low-level file I/O
pub struct FileAccess:
    ptr: ffi.GDExtensionObjectPtr

impl FileAccess:
    # Open file for reading
    pub fn open_read(path: String) -> Result[FileAccess, String]:
        return FileAccess::open(path, ModeFlags::Read)

    # Open file for writing
    pub fn open_write(path: String) -> Result[FileAccess, String]:
        return FileAccess::open(path, ModeFlags::Write)

    # Open file with mode
    pub fn open(path: String, mode: ModeFlags) -> Result[FileAccess, String]:
        let path_var = variant.Variant::from_string(path)
        let mode_var = variant.Variant::from_int(mode as i64)
        
        # TODO: [stdlib][P3] Call FileAccess::open static method
        # let result = call_static("FileAccess", "open", path_var, mode_var)

        # For now, create dummy instance
        let ptr = ffi.godot_new_object("FileAccess")
        return Ok(FileAccess(ptr: ptr))

    # Check if file exists
    pub fn file_exists(path: String) -> bool:
        let path_var = variant.Variant::from_string(path)
        # TODO: [stdlib][P3] Call FileAccess::file_exists static method
        return false  # Placeholder

    # Read entire file as string
    pub fn get_as_text(self) -> String:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_as_text")
        return result.as_string()

    # Store string to file
    pub fn store_string(mut self, text: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let text_var = variant.Variant::from_string(text)
        obj.call1("store_string", text_var)

    # Read line
    pub fn get_line(self) -> String:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_line")
        return result.as_string()

    # Store line
    pub fn store_line(mut self, line: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let line_var = variant.Variant::from_string(line)
        obj.call1("store_line", line_var)

    # Read 32-bit integer
    pub fn get_32(self) -> i32:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_32")
        return result.as_int() as i32

    # Store 32-bit integer
    pub fn store_32(mut self, value: i32):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_int(value as i64)
        obj.call1("store_32", val_var)

    # Read 64-bit integer
    pub fn get_64(self) -> i64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_64")
        return result.as_int()

    # Store 64-bit integer
    pub fn store_64(mut self, value: i64):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_int(value)
        obj.call1("store_64", val_var)

    # Read float
    pub fn get_float(self) -> f32:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_float")
        return result.as_float() as f32

    # Store float
    pub fn store_float(mut self, value: f32):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_float(value as f64)
        obj.call1("store_float", val_var)

    # Read double
    pub fn get_double(self) -> f64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_double")
        return result.as_float()

    # Store double
    pub fn store_double(mut self, value: f64):
        let obj = variant.Object::from_ptr(self.ptr)
        let val_var = variant.Variant::from_float(value)
        obj.call1("store_double", val_var)

    # Check if at end of file
    pub fn eof_reached(self) -> bool:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("eof_reached")
        return result.as_bool()

    # Get file position
    pub fn get_position(self) -> i64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_position")
        return result.as_int()

    # Seek to position
    pub fn seek(mut self, position: i64):
        let obj = variant.Object::from_ptr(self.ptr)
        let pos_var = variant.Variant::from_int(position)
        obj.call1("seek", pos_var)

    # Get file length
    pub fn get_length(self) -> i64:
        let obj = variant.Object::from_ptr(self.ptr)
        let result = obj.call0("get_length")
        return result.as_int()

    # Close file
    pub fn close(mut self):
        let obj = variant.Object::from_ptr(self.ptr)
        obj.call0("close")


# File Mode Flags
pub enum ModeFlags:
    Read = 1
    Write = 2
    ReadWrite = 3
    WriteRead = 7

impl ModeFlags:
    pub fn to_string(self) -> String:
        """Convert mode flags to string."""
        match self:
            case Read: "Read"
            case Write: "Write"
            case ReadWrite: "ReadWrite"
            case WriteRead: "WriteRead"

    pub fn description(self) -> String:
        """Get mode flags description."""
        match self:
            case Read: "Read-only file access"
            case Write: "Write-only file access (creates/truncates file)"
            case ReadWrite: "Read and write file access"
            case WriteRead: "Write and read file access with creation"

    pub fn is_read(self) -> bool:
        """Check if mode is Read."""
        match self:
            case Read: true
            case _: false

    pub fn is_write(self) -> bool:
        """Check if mode is Write."""
        match self:
            case Write: true
            case _: false

    pub fn is_read_write(self) -> bool:
        """Check if mode is ReadWrite."""
        match self:
            case ReadWrite: true
            case _: false

    pub fn is_write_read(self) -> bool:
        """Check if mode is WriteRead."""
        match self:
            case WriteRead: true
            case _: false

    pub fn can_read(self) -> bool:
        """Check if mode allows reading."""
        match self:
            case Read: true
            case ReadWrite: true
            case WriteRead: true
            case _: false

    pub fn can_write(self) -> bool:
        """Check if mode allows writing."""
        match self:
            case Write: true
            case ReadWrite: true
            case WriteRead: true
            case _: false

    pub fn is_read_only(self) -> bool:
        """Check if mode is read-only (cannot write)."""
        match self:
            case Read: true
            case _: false

    pub fn is_write_only(self) -> bool:
        """Check if mode is write-only (cannot read)."""
        match self:
            case Write: true
            case _: false

    pub fn flag_value(self) -> i32:
        """Get the numeric flag value for Godot FileAccess API."""
        match self:
            case Read: 1
            case Write: 2
            case ReadWrite: 3
            case WriteRead: 7

    pub fn summary(self) -> String:
        """Get mode flags summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.can_read():
            props.push("read")
        if self.can_write():
            props.push("write")
        if self.is_read_only():
            props.push("read-only")
        if self.is_write_only():
            props.push("write-only")
        let flag = self.flag_value()
        props.push("flag={flag}")
        if props.len() > 0:
            let props_str = ", ".join(props)
            return "ModeFlags: {name} ({desc}, {props_str})"
        else:
            return "ModeFlags: {name} ({desc})"


# Save Game Manager
# High-level save/load API
pub struct SaveGameManager:
    save_dir: String
    current_slot: i32

impl SaveGameManager:
    # Create new save manager
    pub fn new(save_dir: String = "user://saves/") -> SaveGameManager:
        return SaveGameManager(save_dir: save_dir, current_slot: 0)

    # Get save file path
    fn get_save_path(self, slot: i32) -> String:
        return "{self.save_dir}save_{slot}.cfg"

    # Save game state
    pub fn save_game(mut self, slot: i32, data: SaveData) -> Result[(), String]:
        let mut config = ConfigFile::new()

        # Player data
        config.set_value("player", "name", variant.Variant::from_string(data.player_name))
        config.set_value("player", "level", variant.Variant::from_int(data.player_level as i64))
        config.set_value("player", "health", variant.Variant::from_int(data.player_health as i64))
        config.set_value("player", "position_x", variant.Variant::from_float(data.position_x))
        config.set_value("player", "position_y", variant.Variant::from_float(data.position_y))

        # Game progress
        config.set_value("progress", "current_scene", variant.Variant::from_string(data.current_scene))
        config.set_value("progress", "playtime", variant.Variant::from_float(data.playtime))

        # Save to file
        let path = self.get_save_path(slot)
        let result = config.save(path)

        if result.is_ok():
            self.current_slot = slot
            println("Game saved to slot {slot}")
            return Ok(())
        else:
            return Err(result.unwrap_err())

    # Load game state
    pub fn load_game(mut self, slot: i32) -> Result[SaveData, String]:
        let path = self.get_save_path(slot)
        let result = ConfigFile::load(path)

        if result.is_err():
            return Err(result.unwrap_err())

        let config = result.unwrap()

        # Load player data
        let default_str = variant.Variant::from_string("")
        let default_int = variant.Variant::from_int(0)
        let default_float = variant.Variant::from_float(0.0)

        let name = config.get_value("player", "name", default_str).as_string()
        let level = config.get_value("player", "level", default_int).as_int() as i32
        let health = config.get_value("player", "health", default_int).as_int() as i32
        let pos_x = config.get_value("player", "position_x", default_float).as_float()
        let pos_y = config.get_value("player", "position_y", default_float).as_float()

        # Load progress
        let scene = config.get_value("progress", "current_scene", default_str).as_string()
        let playtime = config.get_value("progress", "playtime", default_float).as_float()

        let data = SaveData(
            player_name: name,
            player_level: level,
            player_health: health,
            position_x: pos_x,
            position_y: pos_y,
            current_scene: scene,
            playtime: playtime
        )

        self.current_slot = slot
        println("Game loaded from slot {slot}")

        return Ok(data)

    # Check if save exists
    pub fn has_save(self, slot: i32) -> bool:
        let path = self.get_save_path(slot)
        return FileAccess::file_exists(path)

    # Delete save
    pub fn delete_save(mut self, slot: i32) -> Result[(), String]:
        """Delete a save file.

        Args:
            slot: Save slot number

        Returns:
            Ok if successful, Err with message if failed
        """
        @extern("runtime", "rt_file_remove")
        fn _rt_file_remove(path_ptr: &u8, path_len: u64) -> bool

        let path = self.get_save_path(slot)
        let success = _rt_file_remove(path.ptr(), path.len())

        if success:
            return Ok(())
        else:
            return Err("Failed to delete save file: {path}")

    # Get all save slots
    pub fn get_save_slots(self) -> Array[i32]:
        let mut slots: Array[i32] = []
        
        for i in range(0, 10):
            if self.has_save(i):
                slots.push(i)

        return slots


# Save Data Structure
pub struct SaveData:
    # Player data
    player_name: String
    player_level: i32
    player_health: i32
    position_x: f64
    position_y: f64

    # Game progress
    current_scene: String
    playtime: f64


# Settings Manager
# Persistent game settings
pub struct SettingsManager:
    config: ConfigFile
    config_path: String

impl SettingsManager:
    # Create new settings manager
    pub fn new(config_path: String = "user://settings.cfg") -> SettingsManager:
        let mut config = ConfigFile::new()
        let _ = config.load_file(config_path)  # Ignore error if file doesn't exist

        return SettingsManager(config: config, config_path: config_path)

    # Get setting
    pub fn get_setting(self, key: String, default: variant.Variant) -> variant.Variant:
        return self.config.get_value("settings", key, default)

    # Set setting
    pub fn set_setting(mut self, key: String, value: variant.Variant):
        self.config.set_value("settings", key, value)

    # Save settings
    pub fn save(self) -> Result[(), String]:
        return self.config.save(self.config_path)


# Array placeholder
pub struct Array[T]:
    items: Vec[T]

impl[T] Array[T]:
    pub fn push(mut self, item: T):
        pass
