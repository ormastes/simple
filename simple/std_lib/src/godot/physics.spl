# Godot Physics System
#
# Physics bodies and collision detection for 2D and 3D.
# Includes RigidBody, CharacterBody, and collision shapes.
#
# Reference: https://docs.godotengine.org/en/stable/classes/class_physicsbody2d.html

import godot.ffi
import godot.variant
import godot.object
import godot.node
import godot.node2d
import godot.node3d

# RigidBody2D - Dynamic physics body
pub struct RigidBody2D:
    base: node2d.Node2D

impl RigidBody2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody2D:
        return RigidBody2D(base: node2d.Node2D::from_ptr(ptr))

    # Velocity
    pub fn get_linear_velocity(self) -> (f64, f64):
        let result = self.base.as_node().as_object().call0("get_linear_velocity")
        return result.as_vector2()

    pub fn set_linear_velocity(mut self, x: f64, y: f64):
        let vel = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_linear_velocity", vel)

    # Angular velocity
    pub fn get_angular_velocity(self) -> f64:
        let result = self.base.as_node().as_object().call0("get_angular_velocity")
        return result.as_float()

    pub fn set_angular_velocity(mut self, vel: f64):
        let vel_var = variant.Variant::from_float(vel)
        self.base.as_node().as_object().call1("set_angular_velocity", vel_var)

    # Mass and physics properties
    pub fn get_mass(self) -> f64:
        let result = self.base.as_node().as_object().call0("get_mass")
        return result.as_float()

    pub fn set_mass(mut self, mass: f64):
        let mass_var = variant.Variant::from_float(mass)
        self.base.as_node().as_object().call1("set_mass", mass_var)

    # Apply forces
    pub fn apply_central_impulse(mut self, impulse_x: f64, impulse_y: f64):
        let impulse = variant.Variant::from_vector2(impulse_x, impulse_y)
        self.base.as_node().as_object().call1("apply_central_impulse", impulse)

    pub fn apply_impulse(mut self, impulse_x: f64, impulse_y: f64, position_x: f64, position_y: f64):
        let impulse = variant.Variant::from_vector2(impulse_x, impulse_y)
        let position = variant.Variant::from_vector2(position_x, position_y)
        self.base.as_node().as_object().call2("apply_impulse", impulse, position)

    pub fn apply_force(mut self, force_x: f64, force_y: f64):
        let force = variant.Variant::from_vector2(force_x, force_y)
        self.base.as_node().as_object().call1("apply_central_force", force)

    # Gravity scale
    pub fn set_gravity_scale(mut self, scale: f64):
        let scale_var = variant.Variant::from_float(scale)
        self.base.as_node().as_object().call1("set_gravity_scale", scale_var)

# CharacterBody2D - Kinematic body for player control
pub struct CharacterBody2D:
    base: node2d.Node2D

impl CharacterBody2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody2D:
        return CharacterBody2D(base: node2d.Node2D::from_ptr(ptr))

    # Velocity
    pub fn get_velocity(self) -> (f64, f64):
        let result = self.base.as_node().as_object().call0("get_velocity")
        return result.as_vector2()

    pub fn set_velocity(mut self, x: f64, y: f64):
        let vel = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_velocity", vel)

    # Move and collide
    pub fn move_and_slide(mut self):
        self.base.as_node().as_object().call0("move_and_slide")

    # Collision detection
    pub fn is_on_floor(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_floor")
        return result.as_bool()

    pub fn is_on_ceiling(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_ceiling")
        return result.as_bool()

    pub fn is_on_wall(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_wall")
        return result.as_bool()

    pub fn get_floor_normal(self) -> (f64, f64):
        let result = self.base.as_node().as_object().call0("get_floor_normal")
        return result.as_vector2()

    # Collision count
    pub fn get_slide_collision_count(self) -> i64:
        let result = self.base.as_node().as_object().call0("get_slide_collision_count")
        return result.as_int()

# RigidBody3D - 3D dynamic physics
pub struct RigidBody3D:
    base: node3d.Node3D

impl RigidBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody3D:
        return RigidBody3D(base: node3d.Node3D::from_ptr(ptr))

    # Linear velocity
    pub fn get_linear_velocity(self) -> (f64, f64, f64):
        let result = self.base.as_node().as_object().call0("get_linear_velocity")
        return result.as_vector3()

    pub fn set_linear_velocity(mut self, x: f64, y: f64, z: f64):
        let vel = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_linear_velocity", vel)

    # Angular velocity
    pub fn get_angular_velocity(self) -> (f64, f64, f64):
        let result = self.base.as_node().as_object().call0("get_angular_velocity")
        return result.as_vector3()

    pub fn set_angular_velocity(mut self, x: f64, y: f64, z: f64):
        let vel = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_angular_velocity", vel)

    # Mass
    pub fn get_mass(self) -> f64:
        let result = self.base.as_node().as_object().call0("get_mass")
        return result.as_float()

    pub fn set_mass(mut self, mass: f64):
        let mass_var = variant.Variant::from_float(mass)
        self.base.as_node().as_object().call1("set_mass", mass_var)

    # Apply forces (3D)
    pub fn apply_central_impulse(mut self, x: f64, y: f64, z: f64):
        let impulse = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("apply_central_impulse", impulse)

    pub fn apply_force(mut self, force_x: f64, force_y: f64, force_z: f64):
        let force = variant.Variant::from_vector3(force_x, force_y, force_z)
        self.base.as_node().as_object().call1("apply_central_force", force)

# CharacterBody3D - 3D kinematic body
pub struct CharacterBody3D:
    base: node3d.Node3D

impl CharacterBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody3D:
        return CharacterBody3D(base: node3d.Node3D::from_ptr(ptr))

    # Velocity
    pub fn get_velocity(self) -> (f64, f64, f64):
        let result = self.base.as_node().as_object().call0("get_velocity")
        return result.as_vector3()

    pub fn set_velocity(mut self, x: f64, y: f64, z: f64):
        let vel = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_velocity", vel)

    # Move and collide
    pub fn move_and_slide(mut self):
        self.base.as_node().as_object().call0("move_and_slide")

    # Collision checks
    pub fn is_on_floor(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_floor")
        return result.as_bool()

    pub fn is_on_ceiling(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_ceiling")
        return result.as_bool()

    pub fn is_on_wall(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_wall")
        return result.as_bool()

# Area2D - Collision detection without physics
pub struct Area2D:
    base: node2d.Node2D

impl Area2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Area2D:
        return Area2D(base: node2d.Node2D::from_ptr(ptr))

    # Overlapping bodies
    pub fn get_overlapping_bodies(self) -> Array[node.Node]:
        let result = self.base.as_node().as_object().call0("get_overlapping_bodies")
        # TODO: Convert array variant to Array[Node]
        return Array[node.Node]::new()

    pub fn overlaps_body(self, body: node.Node) -> bool:
        let body_var = variant.Variant::from_object(body.ptr())
        let result = self.base.as_node().as_object().call1("overlaps_body", body_var)
        return result.as_bool()

    # Monitoring
    pub fn set_monitoring(mut self, enable: bool):
        let enable_var = variant.Variant::from_bool(enable)
        self.base.as_node().as_object().call1("set_monitoring", enable_var)

# Collision shape helper
pub struct CollisionShape2D:
    base: node2d.Node2D

impl CollisionShape2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CollisionShape2D:
        return CollisionShape2D(base: node2d.Node2D::from_ptr(ptr))

    # Set shape (requires Shape2D resource)
    pub fn set_shape(mut self, shape_ptr: ffi.GDExtensionObjectPtr):
        let shape_var = variant.Variant::from_object(shape_ptr)
        self.base.as_node().as_object().call1("set_shape", shape_var)

    # Disable shape
    pub fn set_disabled(mut self, disabled: bool):
        let disabled_var = variant.Variant::from_bool(disabled)
        self.base.as_node().as_object().call1("set_disabled", disabled_var)
