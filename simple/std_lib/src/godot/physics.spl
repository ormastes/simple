# Godot Physics System
#
# Physics bodies and collision detection for 2D and 3D.
# Includes RigidBody, CharacterBody, and collision shapes.
#
# Reference: https://docs.godotengine.org/en/stable/classes/class_physicsbody2d.html

import godot.ffi
import godot.variant
import godot.object
import godot.node
import godot.node2d
import godot.node3d

# RigidBody2D - Dynamic physics body
pub struct RigidBody2D:
    base: node2d.Node2D

impl RigidBody2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody2D:
        return RigidBody2D(base: node2d.Node2D::from_ptr(ptr))

    # Velocity
    pub fn get_linear_velocity(self) -> (f64, f64):
        let result = self.base.as_node().as_object().call0("get_linear_velocity")
        return result.as_vector2()

    pub fn set_linear_velocity(mut self, x: f64, y: f64):
        let vel = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_linear_velocity", vel)

    # Angular velocity
    pub fn get_angular_velocity(self) -> f64:
        let result = self.base.as_node().as_object().call0("get_angular_velocity")
        return result.as_float()

    pub fn set_angular_velocity(mut self, vel: f64):
        let vel_var = variant.Variant::from_float(vel)
        self.base.as_node().as_object().call1("set_angular_velocity", vel_var)

    # Mass and physics properties
    pub fn get_mass(self) -> f64:
        let result = self.base.as_node().as_object().call0("get_mass")
        return result.as_float()

    pub fn set_mass(mut self, mass: f64):
        let mass_var = variant.Variant::from_float(mass)
        self.base.as_node().as_object().call1("set_mass", mass_var)

    # Apply forces
    pub fn apply_central_impulse(mut self, impulse_x: f64, impulse_y: f64):
        let impulse = variant.Variant::from_vector2(impulse_x, impulse_y)
        self.base.as_node().as_object().call1("apply_central_impulse", impulse)

    pub fn apply_impulse(mut self, impulse_x: f64, impulse_y: f64, position_x: f64, position_y: f64):
        let impulse = variant.Variant::from_vector2(impulse_x, impulse_y)
        let position = variant.Variant::from_vector2(position_x, position_y)
        self.base.as_node().as_object().call2("apply_impulse", impulse, position)

    pub fn apply_force(mut self, force_x: f64, force_y: f64):
        let force = variant.Variant::from_vector2(force_x, force_y)
        self.base.as_node().as_object().call1("apply_central_force", force)

    # Gravity scale
    pub fn set_gravity_scale(mut self, scale: f64):
        let scale_var = variant.Variant::from_float(scale)
        self.base.as_node().as_object().call1("set_gravity_scale", scale_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_speed(self) -> f64:
        """Get current speed (magnitude of velocity).

        Returns:
            Speed in pixels/second

        Example:
            body.get_speed()  # → 150.5
        """
        let (vx, vy) = self.get_linear_velocity()
        return (vx * vx + vy * vy).sqrt()

    pub fn is_moving(self) -> bool:
        """Check if body is moving.

        Returns:
            true if speed > 0.01

        Example:
            body.is_moving()  # → true
        """
        return self.get_speed() > 0.01

    pub fn is_stationary(self) -> bool:
        """Check if body is stationary (not moving).

        Returns:
            true if speed <= 0.01

        Example:
            body.is_stationary()  # → false
        """
        return not self.is_moving()

    pub fn is_rotating(self) -> bool:
        """Check if body is rotating.

        Returns:
            true if angular velocity != 0

        Example:
            body.is_rotating()  # → false
        """
        let av = self.get_angular_velocity()
        return av.abs() > 0.01

    pub fn stop(mut self):
        """Stop all motion (zero velocity).

        Example:
            body.stop()
        """
        self.set_linear_velocity(0.0, 0.0)
        self.set_angular_velocity(0.0)

    pub fn apply_push(mut self, x: f64, y: f64):
        """Apply push impulse (convenience for apply_central_impulse).

        Args:
            x: Impulse x component
            y: Impulse y component

        Example:
            body.apply_push(100.0, -50.0)
        """
        self.apply_central_impulse(x, y)

    pub fn summary(self) -> String:
        """Get rigid body 2D summary.

        Returns:
            Human-readable summary

        Example:
            body.summary()
            # → "RigidBody2D: moving, speed=150.5, mass=10.0"
        """
        let state = if self.is_moving() { "moving" } else { "stationary" }
        let speed = self.get_speed()
        let mass = self.get_mass()
        return "RigidBody2D: {state}, speed={speed}, mass={mass}"

# CharacterBody2D - Kinematic body for player control
pub struct CharacterBody2D:
    base: node2d.Node2D

impl CharacterBody2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody2D:
        return CharacterBody2D(base: node2d.Node2D::from_ptr(ptr))

    # Velocity
    pub fn get_velocity(self) -> (f64, f64):
        let result = self.base.as_node().as_object().call0("get_velocity")
        return result.as_vector2()

    pub fn set_velocity(mut self, x: f64, y: f64):
        let vel = variant.Variant::from_vector2(x, y)
        self.base.as_node().as_object().call1("set_velocity", vel)

    # Move and collide
    pub fn move_and_slide(mut self):
        self.base.as_node().as_object().call0("move_and_slide")

    # Collision detection
    pub fn is_on_floor(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_floor")
        return result.as_bool()

    pub fn is_on_ceiling(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_ceiling")
        return result.as_bool()

    pub fn is_on_wall(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_wall")
        return result.as_bool()

    pub fn get_floor_normal(self) -> (f64, f64):
        let result = self.base.as_node().as_object().call0("get_floor_normal")
        return result.as_vector2()

    # Collision count
    pub fn get_slide_collision_count(self) -> i64:
        let result = self.base.as_node().as_object().call0("get_slide_collision_count")
        return result.as_int()

# RigidBody3D - 3D dynamic physics
pub struct RigidBody3D:
    base: node3d.Node3D

impl RigidBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody3D:
        return RigidBody3D(base: node3d.Node3D::from_ptr(ptr))

    # Linear velocity
    pub fn get_linear_velocity(self) -> (f64, f64, f64):
        let result = self.base.as_node().as_object().call0("get_linear_velocity")
        return result.as_vector3()

    pub fn set_linear_velocity(mut self, x: f64, y: f64, z: f64):
        let vel = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_linear_velocity", vel)

    # Angular velocity
    pub fn get_angular_velocity(self) -> (f64, f64, f64):
        let result = self.base.as_node().as_object().call0("get_angular_velocity")
        return result.as_vector3()

    pub fn set_angular_velocity(mut self, x: f64, y: f64, z: f64):
        let vel = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_angular_velocity", vel)

    # Mass
    pub fn get_mass(self) -> f64:
        let result = self.base.as_node().as_object().call0("get_mass")
        return result.as_float()

    pub fn set_mass(mut self, mass: f64):
        let mass_var = variant.Variant::from_float(mass)
        self.base.as_node().as_object().call1("set_mass", mass_var)

    # Apply forces (3D)
    pub fn apply_central_impulse(mut self, x: f64, y: f64, z: f64):
        let impulse = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("apply_central_impulse", impulse)

    pub fn apply_force(mut self, force_x: f64, force_y: f64, force_z: f64):
        let force = variant.Variant::from_vector3(force_x, force_y, force_z)
        self.base.as_node().as_object().call1("apply_central_force", force)

# CharacterBody3D - 3D kinematic body
pub struct CharacterBody3D:
    base: node3d.Node3D

impl CharacterBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody3D:
        return CharacterBody3D(base: node3d.Node3D::from_ptr(ptr))

    # Velocity
    pub fn get_velocity(self) -> (f64, f64, f64):
        let result = self.base.as_node().as_object().call0("get_velocity")
        return result.as_vector3()

    pub fn set_velocity(mut self, x: f64, y: f64, z: f64):
        let vel = variant.Variant::from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_velocity", vel)

    # Move and collide
    pub fn move_and_slide(mut self):
        self.base.as_node().as_object().call0("move_and_slide")

    # Collision checks
    pub fn is_on_floor(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_floor")
        return result.as_bool()

    pub fn is_on_ceiling(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_ceiling")
        return result.as_bool()

    pub fn is_on_wall(self) -> bool:
        let result = self.base.as_node().as_object().call0("is_on_wall")
        return result.as_bool()

# Area2D - Collision detection without physics
pub struct Area2D:
    base: node2d.Node2D

impl Area2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Area2D:
        return Area2D(base: node2d.Node2D::from_ptr(ptr))

    # Overlapping bodies
    pub fn get_overlapping_bodies(self) -> Array[node.Node]:
        let result = self.base.as_node().as_object().call0("get_overlapping_bodies")
        # TODO: [stdlib][P3] Convert array variant to Array[Node]
        return Array[node.Node]::new()

    pub fn overlaps_body(self, body: node.Node) -> bool:
        let body_var = variant.Variant::from_object(body.ptr())
        let result = self.base.as_node().as_object().call1("overlaps_body", body_var)
        return result.as_bool()

    # Monitoring
    pub fn set_monitoring(mut self, enable: bool):
        let enable_var = variant.Variant::from_bool(enable)
        self.base.as_node().as_object().call1("set_monitoring", enable_var)

# Collision shape helper
pub struct CollisionShape2D:
    base: node2d.Node2D

impl CollisionShape2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CollisionShape2D:
        return CollisionShape2D(base: node2d.Node2D::from_ptr(ptr))

    # Set shape (requires Shape2D resource)
    pub fn set_shape(mut self, shape_ptr: ffi.GDExtensionObjectPtr):
        let shape_var = variant.Variant::from_object(shape_ptr)
        self.base.as_node().as_object().call1("set_shape", shape_var)

    # Disable shape
    pub fn set_disabled(mut self, disabled: bool):
        let disabled_var = variant.Variant::from_bool(disabled)
        self.base.as_node().as_object().call1("set_disabled", disabled_var)
