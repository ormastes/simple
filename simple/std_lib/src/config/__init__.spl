# Configuration System
# Hierarchical configuration management using SDN format

export Config, from_dict, merge

class Config:
    """Configuration wrapper around dictionary data."""
    _data: any

    fn __init__(data: any):
        self._data = data

    fn get(path: str) -> any:
        """Get value at dotted path like 'train.epochs'"""
        if "." in path:
            val parts = path.split(".")
            var current = self._data
            for part in parts:
                if part in current:
                    current = current[part]
                else:
                    return 0  # TODO: proper null handling
            return current
        else:
            if path in self._data:
                return self._data[path]
            return 0  # TODO: proper null handling


# ============================================================================
# Module-level functions
# ============================================================================

fn from_dict(data: any) -> Config:
    """Create config from dictionary.

    Args:
        data: Dictionary to convert

    Returns:
        Config object

    Example:
        val cfg = from_dict({"epochs": 10, "lr": 0.001})
        print(cfg.get("epochs"))
    """
    return Config(data)


fn merge(base: Config, overlay: Config) -> Config:
    """Merge two configs (overlay overrides base).

    Args:
        base: Base config
        overlay: Override config

    Returns:
        Merged config

    Example:
        val base = from_dict({"a": 1, "b": 2})
        val over = from_dict({"b": 3, "c": 4})
        val merged = merge(base, over)  # {a: 1, b: 3, c: 4}
    """
    var merged = {}

    # Copy base
    for (key, val) in base._data.items():
        merged.set(key, val)

    # Overlay second config
    for (key, val) in overlay._data.items():
        merged.set(key, val)

    return Config(merged)
