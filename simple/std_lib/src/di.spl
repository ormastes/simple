# DI Module - Dependency Injection Container
#
# Provides dependency injection with profiles for different execution modes:
# - test: Mock implementations for testing
# - dev: Full implementations with debug logging
# - prod: Optimized implementations
# - sdn: No-op instruction module (data-only parsing)

# ============================================================================
# Core Types
# ============================================================================

trait Injectable:
    """Marker trait for injectable types."""
    fn type_name() -> text

struct Binding:
    """A binding from interface to implementation."""
    interface_name: text
    factory: fn() -> Any
    singleton: bool
    instance: Any?

struct Container:
    """Dependency injection container."""
    profile: text
    bindings: Dict<text, Binding>
    instances: Dict<text, Any>

# ============================================================================
# Profile Presets
# ============================================================================

enum Profile:
    Test        # Mock implementations
    Dev         # Development with debug
    Prod        # Production optimized
    Sdn         # SDN parsing (no code execution)
    Custom(text) # Custom profile name

impl Profile:
    fn name() -> text:
        match self:
            case Test: "test"
            case Dev: "dev"
            case Prod: "prod"
            case Sdn: "sdn"
            case Custom(n): n

    static fn from_text(name: text) -> Profile:
        match name:
            case "test": Profile.Test
            case "dev": Profile.Dev
            case "prod": Profile.Prod
            case "sdn": Profile.Sdn
            case _: Profile.Custom(name)

# ============================================================================
# Container Implementation
# ============================================================================

impl Container:
    static fn empty() -> Container:
        """Create empty container."""
        Container(
            profile: "dev",
            bindings: {},
            instances: {}
        )

    static fn with_profile(profile: text) -> Container:
        """Create container with profile and default bindings."""
        var container = Container(
            profile: profile,
            bindings: {},
            instances: {}
        )
        container.register_defaults()
        container

    static fn for_test() -> Container:
        """Create container for testing."""
        Container.with_profile("test")

    static fn for_dev() -> Container:
        """Create container for development."""
        Container.with_profile("dev")

    static fn for_prod() -> Container:
        """Create container for production."""
        Container.with_profile("prod")

    static fn for_sdn() -> Container:
        """Create container for SDN parsing."""
        Container.with_profile("sdn")

    me register_defaults():
        """Register default bindings based on profile."""
        # Register instruction modules
        match self.profile:
            case "test":
                self.register_test_bindings()
            case "dev":
                self.register_dev_bindings()
            case "prod":
                self.register_prod_bindings()
            case "sdn":
                self.register_sdn_bindings()
            case _:
                self.register_dev_bindings()

        # Register backends
        self.register_backends_for_profile()

    me register_test_bindings():
        """Register test profile bindings."""
        # InstructionModule -> Mock (allows all, returns defaults)
        self.bind("InstructionModule", \: MockInstructionModule(), true)
        # LogConfig -> Testing (debug, no timestamps)
        self.bind("LogConfig", \: LogConfig.testing(), true)
        # ExecutionConfig -> Interpret with debug
        self.bind("ExecutionConfig", \: ExecutionConfig.interpret(), true)

    me register_dev_bindings():
        """Register development profile bindings."""
        # InstructionModule -> Full implementation
        self.bind("InstructionModule", \: FullInstructionModule(), true)
        # LogConfig -> Development
        self.bind("LogConfig", \: LogConfig.development(), true)
        # ExecutionConfig -> JIT with optimization
        self.bind("ExecutionConfig", \: ExecutionConfig.jit(), true)

    me register_prod_bindings():
        """Register production profile bindings."""
        # InstructionModule -> Optimized implementation
        self.bind("InstructionModule", \: OptInstructionModule(), true)
        # LogConfig -> Production (warn only)
        self.bind("LogConfig", \: LogConfig.production(), true)
        # ExecutionConfig -> AOT with full optimization
        self.bind("ExecutionConfig", \: ExecutionConfig.aot(), true)

    me register_sdn_bindings():
        """Register SDN profile bindings (no code execution)."""
        # InstructionModule -> NoOp (blocks code execution)
        self.bind("InstructionModule", \: NoOpInstructionModule(), true)
        # LogConfig -> SDN (errors only)
        self.bind("LogConfig", \: LogConfig.sdn(), true)
        # ExecutionConfig -> None (no execution)
        self.bind("ExecutionConfig", \: ExecutionConfig(
            mode: "none",
            debug: false,
            optimize: 0,
            gc_threshold: 0
        ), true)

    me bind(name: text, factory: fn() -> Any, singleton: bool):
        """Register a binding."""
        self.bindings[name] = Binding(
            interface_name: name,
            factory: factory,
            singleton: singleton,
            instance: nil
        )

    me bind_instance(name: text, instance: Any):
        """Register a pre-created instance."""
        self.bindings[name] = Binding(
            interface_name: name,
            factory: \: instance,
            singleton: true,
            instance: Some(instance)
        )

    fn resolve<T>(name: text) -> Result<T, text>:
        """Resolve a dependency by name."""
        val binding = self.bindings[name]
        if binding.is_none():
            return Err("No binding for: {name}")

        val b = binding.unwrap()

        # Return cached instance for singletons
        if b.singleton and b.instance.is_some():
            return Ok(b.instance.unwrap() as T)

        # Create new instance
        val instance = b.factory()

        # Cache singleton instances
        if b.singleton:
            self.instances[name] = instance

        Ok(instance as T)

    fn has(name: text) -> bool:
        """Check if a binding exists."""
        self.bindings[name].is_some()

    fn profile_name() -> text:
        """Get current profile name."""
        self.profile

# ============================================================================
# Backend Trait (Core DI Component for HIR Processing)
# ============================================================================

trait Backend:
    """Interface for HIR processing backends.

    Different backends connect shared HIR to different execution strategies:
    - InterpreterBackend: Tree-walking, Value enum, direct execution
    - CompilerBackend: HIR -> MIR -> Cranelift/LLVM codegen
    - SdnBackend: No-op, blocks all code execution for data-only parsing
    """
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>
    fn is_instruction_allowed(inst: HirInstruction) -> bool
    fn name() -> text
    fn kind() -> BackendKind

enum BackendKind:
    """Type of backend."""
    Interpreter   # Tree-walking execution
    Compiler      # Compiled execution
    Sdn           # No-op (data only)
    Custom(text)  # Custom backend

struct BackendContext:
    """Context passed to backends during processing."""
    config: BackendConfig
    env: Dict<text, Any>

struct BackendConfig:
    """Backend-specific configuration."""
    mode: text              # "interpret", "jit", "aot", "sdn"
    optimize: i64           # Optimization level
    debug: bool             # Debug mode
    features: [text]        # Enabled features

enum BackendOutput:
    """Result of backend processing."""
    Interpreted(value: Value)                    # Interpreter result
    Compiled(binary: [u8], symbols: DiSymbolTable) # Compiled binary
    SdnData(data: SdnValue)                      # SDN data result
    Custom(Any)                                  # Custom result

struct DiSymbolTable:
    """Symbol table from compilation."""
    entries: Dict<text, SymbolEntry>

struct SymbolEntry:
    address: i64
    size: i64
    kind: text

struct DiHirModule:
    """HIR module representation."""
    name: text
    items: [HirItem]

enum HirItem:
    Function(FunctionDef)
    Struct(StructDef)
    Enum(EnumDef)
    Import(ImportDef)
    Export(ExportDef)

struct FunctionDef:
    name: text
    params: [ParamDef]
    body: [HirInstruction]
    return_type: text?

struct StructDef:
    name: text
    fields: [FieldDef]

struct EnumDef:
    name: text
    variants: [VariantDef]

struct ParamDef:
    name: text
    typ: text

struct FieldDef:
    name: text
    typ: text

struct VariantDef:
    name: text
    payload: text?

struct ImportDef:
    module: text
    items: [text]

struct ExportDef:
    items: [text]

# ============================================================================
# Backend Implementations
# ============================================================================

struct InterpreterBackend:
    """Tree-walking interpreter backend."""

impl Backend for InterpreterBackend:
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>:
        # Delegate to interpreter instruction module
        val instruction_module = get_container().resolve<InstructionModule>("InstructionModule")
        if instruction_module.is_err():
            return Err("Failed to resolve instruction module")

        # TODO: Execute HIR via instruction module
        Ok(BackendOutput.Interpreted(Value.none()))

    fn is_instruction_allowed(inst: HirInstruction) -> bool:
        # Interpreter allows all instructions
        true

    fn name() -> text:
        "InterpreterBackend"

    fn kind() -> BackendKind:
        BackendKind.Interpreter

struct CompilerBackend:
    """Compiling backend (HIR -> MIR -> codegen)."""

impl Backend for CompilerBackend:
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>:
        # Lower HIR to MIR, then to native code
        # TODO: Implement via FFI to Rust codegen
        Ok(BackendOutput.Compiled([], DiSymbolTable(entries: {})))

    fn is_instruction_allowed(inst: HirInstruction) -> bool:
        # Compiler allows all instructions
        true

    fn name() -> text:
        "CompilerBackend"

    fn kind() -> BackendKind:
        BackendKind.Compiler

struct SdnBackend:
    """No-op backend for SDN parsing (data only).

    Blocks ALL code execution. Only allows:
    - Data construction (arrays, dicts, literals)
    - No function calls, no control flow, no side effects
    """

impl Backend for SdnBackend:
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>:
        # Only process data construction, block everything else
        val instruction_module = NoOpInstructionModule()

        for item in hir.items:
            match item:
                case Function(_):
                    return Err("Functions not allowed in SDN mode")
                case _:
                    pass  # Structs, enums, imports/exports OK

        Ok(BackendOutput.SdnData(SdnValue.empty()))

    fn is_instruction_allowed(inst: HirInstruction) -> bool:
        match inst:
            case LoadConst(_) | ArrayNew(_) | DictNew(_):
                true
            case _:
                false

    fn name() -> text:
        "SdnBackend"

    fn kind() -> BackendKind:
        BackendKind.Sdn

# ============================================================================
# Backend Registration
# ============================================================================

impl Container:
    me register_backend(backend: Backend):
        """Register a backend with the container."""
        self.bind("Backend", \: backend, true)

    me register_backends_for_profile():
        """Register backends based on current profile."""
        match self.profile:
            case "test":
                self.register_backend(InterpreterBackend())
            case "dev":
                self.register_backend(InterpreterBackend())
            case "prod":
                self.register_backend(CompilerBackend())
            case "sdn":
                self.register_backend(SdnBackend())
            case _:
                self.register_backend(InterpreterBackend())

# ============================================================================
# Instruction Modules (DI Components)
# ============================================================================

trait InstructionModule:
    """Interface for instruction execution modules."""
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>
    fn is_allowed(inst: HirInstruction) -> bool
    fn name() -> text

struct MockInstructionModule:
    """Mock instruction module for testing."""

impl InstructionModule for MockInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        # Mock execution - return default values
        Ok(Value.none())

    fn is_allowed(inst: HirInstruction) -> bool:
        # Allow everything in mock
        true

    fn name() -> text:
        "MockInstructionModule"

struct FullInstructionModule:
    """Full instruction module with all features."""

impl InstructionModule for FullInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        # Full execution - delegate to Rust FFI
        # TODO: Implement via FFI
        Ok(Value.none())

    fn is_allowed(inst: HirInstruction) -> bool:
        # Allow all instructions
        true

    fn name() -> text:
        "FullInstructionModule"

struct OptInstructionModule:
    """Optimized instruction module for production."""

impl InstructionModule for OptInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        # Optimized execution - minimal checks
        # TODO: Implement via FFI
        Ok(Value.none())

    fn is_allowed(inst: HirInstruction) -> bool:
        true

    fn name() -> text:
        "OptInstructionModule"

struct NoOpInstructionModule:
    """No-operation instruction module for SDN parsing.

    Only allows data construction:
    - LoadConst: Load literal values
    - ArrayNew: Create arrays
    - DictNew: Create dictionaries

    All other instructions are blocked to prevent code execution in SDN.
    """

impl InstructionModule for NoOpInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        match inst:
            case LoadConst(value):
                Ok(value)
            case ArrayNew(elements):
                val results = elements.map(\e: self.execute(e, ctx))
                if results.any(\r: r.is_err()):
                    return Err("Failed to construct array")
                Ok(Value.array(results.map(\r: r.unwrap())))
            case DictNew(pairs):
                var dict: Dict<Value, Value> = {}
                for pair in pairs:
                    val key = self.execute(pair.0, ctx)
                    val value = self.execute(pair.1, ctx)
                    if key.is_err() or value.is_err():
                        return Err("Failed to construct dict")
                    dict[key.unwrap()] = value.unwrap()
                Ok(Value.dict(dict))
            case _:
                Err("Code execution not allowed in SDN mode: {inst.kind()}")

    fn is_allowed(inst: HirInstruction) -> bool:
        match inst:
            case LoadConst(_) | ArrayNew(_) | DictNew(_):
                true
            case _:
                false

    fn name() -> text:
        "NoOpInstructionModule"

# ============================================================================
# Placeholder Types (to be replaced with real implementations)
# ============================================================================

# These are placeholder types - actual definitions in instruction.spl
enum HirInstruction:
    LoadConst(value: Value)
    LoadLocal(slot: i64)
    StoreLocal(slot: i64)
    BinOp(op: BinOpKind, left: HirInstruction, right: HirInstruction)
    Call(func: text, args: [HirInstruction])
    ArrayNew(elements: [HirInstruction])
    DictNew(pairs: [(HirInstruction, HirInstruction)])
    Return(value: HirInstruction?)
    Other

impl HirInstruction:
    fn kind() -> text:
        match self:
            case LoadConst(_): "LoadConst"
            case LoadLocal(_): "LoadLocal"
            case StoreLocal(_): "StoreLocal"
            case BinOp(_, _, _): "BinOp"
            case Call(_, _): "Call"
            case ArrayNew(_): "ArrayNew"
            case DictNew(_): "DictNew"
            case Return(_): "Return"
            case Other: "Other"

enum BinOpKind:
    Add, Sub, Mul, Div, Mod
    Eq, Ne, Lt, Le, Gt, Ge
    And, Or

struct ExecutionContext:
    locals: Dict<i64, Value>
    globals: Dict<text, Value>

enum Value:
    None
    Int(i64)
    Float(f64)
    Bool(bool)
    String(text)
    Array([Value])
    Dict(Dict<Value, Value>)

impl Value:
    static fn none() -> Value:
        Value.None

    static fn int(n: i64) -> Value:
        Value.Int(n)

    static fn array(elements: [Value]) -> Value:
        Value.Array(elements)

    static fn dict(pairs: Dict<Value, Value>) -> Value:
        Value.Dict(pairs)

# Import config types (forward declaration)
# These will be properly imported when modules are linked
struct LogConfig:
    global_level: i64
    scopes: Dict<text, i64>
    timestamps: bool
    format: text

impl LogConfig:
    static fn testing() -> LogConfig:
        LogConfig(global_level: 5, scopes: {}, timestamps: false, format: "text")

    static fn development() -> LogConfig:
        LogConfig(global_level: 5, scopes: {}, timestamps: true, format: "text")

    static fn production() -> LogConfig:
        LogConfig(global_level: 3, scopes: {}, timestamps: true, format: "json")

    static fn sdn() -> LogConfig:
        LogConfig(global_level: 2, scopes: {}, timestamps: false, format: "text")

struct ExecutionConfig:
    mode: text
    debug: bool
    optimize: i64
    gc_threshold: i64

impl ExecutionConfig:
    static fn interpret() -> ExecutionConfig:
        ExecutionConfig(mode: "interpret", debug: true, optimize: 0, gc_threshold: 100000)

    static fn jit() -> ExecutionConfig:
        ExecutionConfig(mode: "jit", debug: false, optimize: 2, gc_threshold: 1000000)

    static fn aot() -> ExecutionConfig:
        ExecutionConfig(mode: "aot", debug: false, optimize: 3, gc_threshold: 10000000)

# ============================================================================
# Global Container (singleton pattern)
# ============================================================================

var global_container: Container? = nil

pub fn init_container(profile: text):
    """Initialize global container with profile."""
    global_container = Some(Container.with_profile(profile))

pub fn get_container() -> Container:
    """Get the global container (creates dev container if not initialized)."""
    if global_container.is_none():
        global_container = Some(Container.for_dev())
    global_container.unwrap()

pub fn resolve<T>(name: text) -> Result<T, text>:
    """Resolve dependency from global container."""
    get_container().resolve(name)

# ============================================================================
# Exports
# ============================================================================

export Container, Profile, Binding, Injectable
export InstructionModule, MockInstructionModule, FullInstructionModule
export OptInstructionModule, NoOpInstructionModule
export Backend, BackendKind, BackendContext, BackendConfig, BackendOutput
export InterpreterBackend, CompilerBackend, SdnBackend
export DiHirModule, HirItem, HirInstruction, BinOpKind, ExecutionContext, Value
export FunctionDef, StructDef, EnumDef, ParamDef, FieldDef, VariantDef
export ImportDef, ExportDef, DiSymbolTable, SymbolEntry
export init_container, get_container, resolve
