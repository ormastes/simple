# Display - Display Widgets (Text, Icon, Image, Badge, ProgressBar)
#
# Provides display-only widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Text style configuration
pub struct TextStyle:
    font_size: Option[i32]
    font_weight: Option[String]
    font_family: Option[String]
    color: Option[Color]
    line_height: Option[f64]
    text_align: Option[TextAlign]
    text_decoration: Option[TextDecoration]

pub enum TextAlign:
    Left
    Center
    Right
    Justify

pub enum TextDecoration:
    None
    Underline
    Overline
    LineThrough

impl TextStyle:
    # Create default body text style
    pub fn body() -> TextStyle:
        return TextStyle {
            font_size: Some(16),
            font_weight: Some("400".to_string()),
            font_family: None,
            color: None,
            line_height: Some(1.5),
            text_align: None,
            text_decoration: None
        }

    # Create heading styles
    pub fn h1() -> TextStyle:
        return TextStyle::body()
            .font_size(32)
            .font_weight("700")

    pub fn h2() -> TextStyle:
        return TextStyle::body()
            .font_size(24)
            .font_weight("600")

    pub fn h3() -> TextStyle:
        return TextStyle::body()
            .font_size(20)
            .font_weight("600")

    pub fn caption() -> TextStyle:
        return TextStyle::body()
            .font_size(12)

    # Builder methods
    pub fn font_size(mut self, size: i32) -> TextStyle:
        self.font_size = Some(size)
        return self

    pub fn font_weight(mut self, weight: &str) -> TextStyle:
        self.font_weight = Some(weight.to_string())
        return self

    pub fn font_family(mut self, family: &str) -> TextStyle:
        self.font_family = Some(family.to_string())
        return self

    pub fn color(mut self, color: Color) -> TextStyle:
        self.color = Some(color)
        return self

    pub fn line_height(mut self, height: f64) -> TextStyle:
        self.line_height = Some(height)
        return self

    pub fn text_align(mut self, align: TextAlign) -> TextStyle:
        self.text_align = Some(align)
        return self

    pub fn underline(mut self) -> TextStyle:
        self.text_decoration = Some(TextDecoration::Underline)
        return self

    pub fn bold(mut self) -> TextStyle:
        self.font_weight = Some("700".to_string())
        return self

    pub fn italic(self) -> TextStyle:
        # Would need font-style property in full implementation
        return self

# Text - Display text widget
pub struct Text:
    content: String
    style: TextStyle

impl Text:
    # Create a new text widget
    pub fn new(content: &str) -> Text:
        return Text {
            content: content.to_string(),
            style: TextStyle::body()
        }

    # Set text style
    pub fn style(mut self, style: TextStyle) -> Text:
        self.style = style
        return self

impl Widget for Text:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::text(id, &self.content)
            .with_class("text")

        # Apply font size
        if let Some(size) = self.style.font_size:
            elem = elem.with_style("font-size", &f"{size}px")

        # Apply font weight
        if let Some(weight) = &self.style.font_weight:
            elem = elem.with_style("font-weight", weight)

        # Apply font family
        if let Some(family) = &self.style.font_family:
            elem = elem.with_style("font-family", family)

        # Apply color
        if let Some(color) = &self.style.color:
            elem = elem.with_style("color", &color.to_css())

        # Apply line height
        if let Some(height) = self.style.line_height:
            elem = elem.with_style("line-height", &height.to_string())

        # Apply text align
        if let Some(align) = &self.style.text_align:
            let align_str = match align:
                case TextAlign::Left: "left"
                case TextAlign::Center: "center"
                case TextAlign::Right: "right"
                case TextAlign::Justify: "justify"
            elem = elem.with_style("text-align", align_str)

        # Apply text decoration
        if let Some(decoration) = &self.style.text_decoration:
            let decoration_str = match decoration:
                case TextDecoration::None: "none"
                case TextDecoration::Underline: "underline"
                case TextDecoration::Overline: "overline"
                case TextDecoration::LineThrough: "line-through"
            elem = elem.with_style("text-decoration", decoration_str)

        return WidgetNode::new(elem)

# Icon - Display icon widget
pub struct Icon:
    name: String
    size: i32
    color: Option[Color]

impl Icon:
    # Create a new icon
    pub fn new(name: &str) -> Icon:
        return Icon {
            name: name.to_string(),
            size: 24,
            color: None
        }

    # Set icon size
    pub fn size(mut self, size: i32) -> Icon:
        self.size = size
        return self

    # Set icon color
    pub fn color(mut self, color: Color) -> Icon:
        self.color = Some(color)
        return self

impl Widget for Icon:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Span)
            .with_class("icon")
            .with_class(&f"icon-{self.name}")
            .with_style("display", "inline-flex")
            .with_style("width", &f"{self.size}px")
            .with_style("height", &f"{self.size}px")

        # Apply color
        if let Some(color) = &self.color:
            elem = elem.with_style("color", &color.to_css())

        return WidgetNode::new(elem)

# Image fit modes
pub enum ImageFit:
    Contain  # Maintain aspect ratio, fit within bounds
    Cover    # Maintain aspect ratio, cover bounds
    Fill     # Stretch to fill bounds
    None     # Original size
    ScaleDown # Like contain, but don't upscale

# Image - Display image widget
pub struct Image:
    src: String
    alt: String
    width: Option[i32]
    height: Option[i32]
    fit: ImageFit

impl Image:
    # Create a new image
    pub fn new(src: &str) -> Image:
        return Image {
            src: src.to_string(),
            alt: String::new(),
            width: None,
            height: None,
            fit: ImageFit::Contain
        }

    # Set alt text
    pub fn alt(mut self, alt: &str) -> Image:
        self.alt = alt.to_string()
        return self

    # Set width
    pub fn width(mut self, width: i32) -> Image:
        self.width = Some(width)
        return self

    # Set height
    pub fn height(mut self, height: i32) -> Image:
        self.height = Some(height)
        return self

    # Set fit mode
    pub fn fit(mut self, fit: ImageFit) -> Image:
        self.fit = fit
        return self

impl Widget for Image:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Div)
            .with_class("image")
            .with_attr("src", &self.src)
            .with_attr("alt", &self.alt)

        # Apply dimensions
        if let Some(w) = self.width:
            elem = elem.with_style("width", &f"{w}px")
        if let Some(h) = self.height:
            elem = elem.with_style("height", &f"{h}px")

        # Apply fit mode
        let fit_str = match self.fit:
            case ImageFit::Contain: "contain"
            case ImageFit::Cover: "cover"
            case ImageFit::Fill: "fill"
            case ImageFit::None: "none"
            case ImageFit::ScaleDown: "scale-down"
        elem = elem.with_style("object-fit", fit_str)

        return WidgetNode::new(elem)

# Badge variant
pub enum BadgeVariant:
    Default
    Primary
    Secondary
    Success
    Warning
    Error

# Badge - Small status indicator
pub struct Badge:
    content: String
    variant: BadgeVariant

impl Badge:
    # Create a new badge
    pub fn new(content: &str) -> Badge:
        return Badge {
            content: content.to_string(),
            variant: BadgeVariant::Default
        }

    # Create a count badge
    pub fn count(count: u32) -> Badge:
        return Badge::new(&count.to_string())

    # Set variant to primary
    pub fn primary(mut self) -> Badge:
        self.variant = BadgeVariant::Primary
        return self

    # Set variant to success
    pub fn success(mut self) -> Badge:
        self.variant = BadgeVariant::Success
        return self

    # Set variant to warning
    pub fn warning(mut self) -> Badge:
        self.variant = BadgeVariant::Warning
        return self

    # Set variant to error
    pub fn error(mut self) -> Badge:
        self.variant = BadgeVariant::Error
        return self

impl Widget for Badge:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let variant_class = match self.variant:
            case BadgeVariant::Default: "badge-default"
            case BadgeVariant::Primary: "badge-primary"
            case BadgeVariant::Secondary: "badge-secondary"
            case BadgeVariant::Success: "badge-success"
            case BadgeVariant::Warning: "badge-warning"
            case BadgeVariant::Error: "badge-error"

        let elem = Element::new(id, ElementKind::Span)
            .with_class("badge")
            .with_class(variant_class)
            .with_text(&self.content)
            .with_style("display", "inline-flex")
            .with_style("align-items", "center")
            .with_style("justify-content", "center")
            .with_style("padding", "2px 8px")
            .with_style("border-radius", "12px")
            .with_style("font-size", "12px")
            .with_style("font-weight", "500")

        return WidgetNode::new(elem)

# ProgressBar - Progress indicator
pub struct ProgressBar:
    value: f64  # 0.0 to 1.0
    indeterminate: bool
    show_label: bool
    color: Option[Color]

impl ProgressBar:
    # Create a new progress bar
    pub fn new(value: f64) -> ProgressBar:
        return ProgressBar {
            value: value.clamp(0.0, 1.0),
            indeterminate: false,
            show_label: false,
            color: None
        }

    # Create indeterminate progress bar
    pub fn indeterminate() -> ProgressBar:
        return ProgressBar {
            value: 0.0,
            indeterminate: true,
            show_label: false,
            color: None
        }

    # Show percentage label
    pub fn show_label(mut self) -> ProgressBar:
        self.show_label = true
        return self

    # Set progress color
    pub fn color(mut self, color: Color) -> ProgressBar:
        self.color = Some(color)
        return self

impl Widget for ProgressBar:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut container = Element::new(id, ElementKind::Div)
            .with_class("progress-bar")
            .with_style("width", "100%")
            .with_style("height", "4px")
            .with_style("background-color", "#e0e0e0")
            .with_style("border-radius", "2px")
            .with_style("overflow", "hidden")

        # Create progress fill
        let fill_id = ctx.alloc_id()
        let mut fill = Element::new(fill_id, ElementKind::Div)
            .with_class("progress-fill")
            .with_style("height", "100%")
            .with_style("transition", "width 0.3s ease")

        if self.indeterminate:
            fill = fill
                .with_class("progress-indeterminate")
                .with_style("width", "30%")
                # Would add animation in CSS
        else:
            let percent = (self.value * 100.0) as i32
            fill = fill.with_style("width", &f"{percent}%")

        # Apply color
        if let Some(color) = &self.color:
            fill = fill.with_style("background-color", &color.to_css())
        else:
            fill = fill.with_style("background-color", "#2196f3")

        container = container.with_child(fill)

        # Add label if requested
        if self.show_label and not self.indeterminate:
            let percent = (self.value * 100.0) as i32
            let label = Element::text(ctx.alloc_id(), &f"{percent}%")
                .with_class("progress-label")
                .with_style("font-size", "12px")
                .with_style("margin-top", "4px")

            # Wrap in column to stack label below
            let wrapper_id = ctx.alloc_id()
            let wrapper = Element::new(wrapper_id, ElementKind::Div)
                .with_class("progress-wrapper")
                .with_child(container)
                .with_child(label)

            return WidgetNode::new(wrapper)

        return WidgetNode::new(container)

# Divider - Visual separator
pub struct Divider:
    orientation: DividerOrientation
    thickness: i32
    color: Option[Color]

pub enum DividerOrientation:
    Horizontal
    Vertical

impl Divider:
    # Create horizontal divider
    pub fn horizontal() -> Divider:
        return Divider {
            orientation: DividerOrientation::Horizontal,
            thickness: 1,
            color: None
        }

    # Create vertical divider
    pub fn vertical() -> Divider:
        return Divider {
            orientation: DividerOrientation::Vertical,
            thickness: 1,
            color: None
        }

    # Set thickness
    pub fn thickness(mut self, thickness: i32) -> Divider:
        self.thickness = thickness
        return self

    # Set color
    pub fn color(mut self, color: Color) -> Divider:
        self.color = Some(color)
        return self

impl Widget for Divider:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Div)
            .with_class("divider")

        match self.orientation:
            case DividerOrientation::Horizontal:
                elem = elem
                    .with_style("width", "100%")
                    .with_style("height", &f"{self.thickness}px")
            case DividerOrientation::Vertical:
                elem = elem
                    .with_style("width", &f"{self.thickness}px")
                    .with_style("height", "100%")
                    .with_style("align-self", "stretch")

        # Apply color
        let color = self.color.unwrap_or(Color::hex("#e0e0e0").unwrap())
        elem = elem.with_style("background-color", &color.to_css())

        return WidgetNode::new(elem)
