# Attrs - UI Attribute and Styling Types
#
# This module defines attribute and styling types that are shared
# between TUI and GUI renderers. Styles are translated to the
# appropriate representation for each platform.

use core.*

# Layout direction for flex containers
pub enum FlexDirection:
    Row
    RowReverse
    Column
    ColumnReverse

impl FlexDirection:
    pub fn is_horizontal(self) -> bool:
        match self:
            case Row | RowReverse => true
            case _ => false

    pub fn is_vertical(self) -> bool:
        return not self.is_horizontal()

    pub fn is_reversed(self) -> bool:
        match self:
            case RowReverse | ColumnReverse => true
            case _ => false

# Flex alignment on main axis
pub enum JustifyContent:
    Start
    End
    Center
    SpaceBetween
    SpaceAround
    SpaceEvenly

impl JustifyContent:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert justify content to string.

        Returns:
            Variant name

        Example:
            JustifyContent::Center.to_string()  # → "center"
        """
        match self:
            case Start: "start"
            case End: "end"
            case Center: "center"
            case SpaceBetween: "space-between"
            case SpaceAround: "space-around"
            case SpaceEvenly: "space-evenly"

    pub fn is_start(self) -> Bool:
        """Check if start alignment.

        Returns:
            true for Start variant

        Example:
            JustifyContent::Start.is_start()  # → true
        """
        match self:
            case Start: True
            case _: False

    pub fn is_end(self) -> Bool:
        """Check if end alignment.

        Returns:
            true for End variant

        Example:
            JustifyContent::End.is_end()  # → true
        """
        match self:
            case End: True
            case _: False

    pub fn is_center(self) -> Bool:
        """Check if center alignment.

        Returns:
            true for Center variant

        Example:
            JustifyContent::Center.is_center()  # → true
        """
        match self:
            case Center: True
            case _: False

    pub fn is_spaced(self) -> Bool:
        """Check if uses spacing distribution.

        Returns:
            true for SpaceBetween/SpaceAround/SpaceEvenly

        Example:
            JustifyContent::SpaceBetween.is_spaced()  # → true
        """
        match self:
            case SpaceBetween: True
            case SpaceAround: True
            case SpaceEvenly: True
            case _: False

    pub fn distributes_space(self) -> Bool:
        """Check if distributes space between items.

        Returns:
            true if not Start/End

        Example:
            JustifyContent::Center.distributes_space()  # → true
        """
        match self:
            case Start: False
            case End: False
            case _: True

    pub fn summary(self) -> String:
        """Get justify content summary.

        Returns:
            Human-readable summary

        Example:
            JustifyContent::Center.summary()  # → "JustifyContent: center"
        """
        let name = self.to_string()
        return "JustifyContent: {name}"

# Flex alignment on cross axis
pub enum AlignItems:
    Start
    End
    Center
    Stretch
    Baseline

impl AlignItems:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert align items to string.

        Returns:
            Variant name

        Example:
            AlignItems::Center.to_string()  # → "center"
        """
        match self:
            case Start: "start"
            case End: "end"
            case Center: "center"
            case Stretch: "stretch"
            case Baseline: "baseline"

    pub fn is_start(self) -> Bool:
        """Check if start alignment.

        Returns:
            true for Start variant

        Example:
            AlignItems::Start.is_start()  # → true
        """
        match self:
            case Start: True
            case _: False

    pub fn is_end(self) -> Bool:
        """Check if end alignment.

        Returns:
            true for End variant

        Example:
            AlignItems::End.is_end()  # → true
        """
        match self:
            case End: True
            case _: False

    pub fn is_center(self) -> Bool:
        """Check if center alignment.

        Returns:
            true for Center variant

        Example:
            AlignItems::Center.is_center()  # → true
        """
        match self:
            case Center: True
            case _: False

    pub fn is_stretch(self) -> Bool:
        """Check if stretch alignment.

        Returns:
            true for Stretch variant

        Example:
            AlignItems::Stretch.is_stretch()  # → true
        """
        match self:
            case Stretch: True
            case _: False

    pub fn is_baseline(self) -> Bool:
        """Check if baseline alignment.

        Returns:
            true for Baseline variant

        Example:
            AlignItems::Baseline.is_baseline()  # → true
        """
        match self:
            case Baseline: True
            case _: False

    pub fn summary(self) -> String:
        """Get align items summary.

        Returns:
            Human-readable summary

        Example:
            AlignItems::Center.summary()  # → "AlignItems: center"
        """
        let name = self.to_string()
        return "AlignItems: {name}"

# Text alignment
pub enum TextAlign:
    Left
    Center
    Right
    Justify

impl TextAlign:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert text align to string.

        Returns:
            Variant name

        Example:
            TextAlign::Center.to_string()  # → "center"
        """
        match self:
            case Left: "left"
            case Center: "center"
            case Right: "right"
            case Justify: "justify"

    pub fn is_left(self) -> Bool:
        """Check if left alignment.

        Returns:
            true for Left variant

        Example:
            TextAlign::Left.is_left()  # → true
        """
        match self:
            case Left: True
            case _: False

    pub fn is_center(self) -> Bool:
        """Check if center alignment.

        Returns:
            true for Center variant

        Example:
            TextAlign::Center.is_center()  # → true
        """
        match self:
            case Center: True
            case _: False

    pub fn is_right(self) -> Bool:
        """Check if right alignment.

        Returns:
            true for Right variant

        Example:
            TextAlign::Right.is_right()  # → true
        """
        match self:
            case Right: True
            case _: False

    pub fn is_justify(self) -> Bool:
        """Check if justify alignment.

        Returns:
            true for Justify variant

        Example:
            TextAlign::Justify.is_justify()  # → true
        """
        match self:
            case Justify: True
            case _: False

    pub fn summary(self) -> String:
        """Get text align summary.

        Returns:
            Human-readable summary

        Example:
            TextAlign::Center.summary()  # → "TextAlign: center"
        """
        let name = self.to_string()
        return "TextAlign: {name}"

# Vertical alignment
pub enum VerticalAlign:
    Top
    Middle
    Bottom

impl VerticalAlign:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert vertical align to string.

        Returns:
            Variant name

        Example:
            VerticalAlign::Middle.to_string()  # → "middle"
        """
        match self:
            case Top: "top"
            case Middle: "middle"
            case Bottom: "bottom"

    pub fn is_top(self) -> Bool:
        """Check if top alignment.

        Returns:
            true for Top variant

        Example:
            VerticalAlign::Top.is_top()  # → true
        """
        match self:
            case Top: True
            case _: False

    pub fn is_middle(self) -> Bool:
        """Check if middle alignment.

        Returns:
            true for Middle variant

        Example:
            VerticalAlign::Middle.is_middle()  # → true
        """
        match self:
            case Middle: True
            case _: False

    pub fn is_bottom(self) -> Bool:
        """Check if bottom alignment.

        Returns:
            true for Bottom variant

        Example:
            VerticalAlign::Bottom.is_bottom()  # → true
        """
        match self:
            case Bottom: True
            case _: False

    pub fn summary(self) -> String:
        """Get vertical align summary.

        Returns:
            Human-readable summary

        Example:
            VerticalAlign::Middle.summary()  # → "VerticalAlign: middle"
        """
        let name = self.to_string()
        return "VerticalAlign: {name}"

# Border style (for Box elements)
pub enum BorderStyle:
    None
    Solid
    Dashed
    Dotted
    Double
    Rounded  # TUI: rounded box-drawing corners

impl BorderStyle:
    # Check if border should be rendered
    pub fn is_visible(self) -> bool:
        return self != BorderStyle::None

# Color representation (platform-agnostic)
pub enum Color:
    # Named colors (ANSI-compatible)
    Black
    Red
    Green
    Yellow
    Blue
    Magenta
    Cyan
    White
    BrightBlack
    BrightRed
    BrightGreen
    BrightYellow
    BrightBlue
    BrightMagenta
    BrightCyan
    BrightWhite
    # RGB color (24-bit)
    Rgb(u8, u8, u8)
    # ANSI 256-color palette
    Ansi256(u8)
    # Default/inherit color
    Default

impl Color:
    # Create RGB color
    pub fn rgb(r: u8, g: u8, b: u8) -> Color:
        return Color::Rgb(r, g, b)

    # Create from hex value (0xRRGGBB)
    pub fn hex(value: u32) -> Color:
        let r = ((value >> 16) & 0xFF) as u8
        let g = ((value >> 8) & 0xFF) as u8
        let b = (value & 0xFF) as u8
        return Color::Rgb(r, g, b)

    # Convert to RGBA u32 (for FFI)
    pub fn to_rgba(self) -> u32:
        match self:
            case Black => 0x000000
            case Red => 0xCC0000
            case Green => 0x00CC00
            case Yellow => 0xCCCC00
            case Blue => 0x0000CC
            case Magenta => 0xCC00CC
            case Cyan => 0x00CCCC
            case White => 0xCCCCCC
            case BrightBlack => 0x555555
            case BrightRed => 0xFF5555
            case BrightGreen => 0x55FF55
            case BrightYellow => 0xFFFF55
            case BrightBlue => 0x5555FF
            case BrightMagenta => 0xFF55FF
            case BrightCyan => 0x55FFFF
            case BrightWhite => 0xFFFFFF
            case Rgb(r, g, b) => ((r as u32) << 16) | ((g as u32) << 8) | (b as u32)
            case Ansi256(n) => ansi256_to_rgb(n)
            case Default => 0

# Convert ANSI 256-color index to RGB
fn ansi256_to_rgb(n: u8) -> u32:
    # Standard colors 0-15
    if n < 16:
        let colors: [u32; 16] = [
            0x000000, 0xCC0000, 0x00CC00, 0xCCCC00,
            0x0000CC, 0xCC00CC, 0x00CCCC, 0xCCCCCC,
            0x555555, 0xFF5555, 0x55FF55, 0xFFFF55,
            0x5555FF, 0xFF55FF, 0x55FFFF, 0xFFFFFF
        ]
        return colors[n as u64]
    # 216-color cube (16-231)
    if n < 232:
        let idx = n - 16
        let r = ((idx / 36) % 6) * 51
        let g = ((idx / 6) % 6) * 51
        let b = (idx % 6) * 51
        return ((r as u32) << 16) | ((g as u32) << 8) | (b as u32)
    # Grayscale (232-255)
    let gray = ((n - 232) * 10 + 8) as u32
    return (gray << 16) | (gray << 8) | gray

# Text style flags
pub struct TextStyle:
    bold: bool
    dim: bool
    italic: bool
    underline: bool
    blink: bool
    reverse: bool
    hidden: bool
    strikethrough: bool

impl TextStyle:
    # Create default (no styling)
    pub fn new() -> TextStyle:
        return TextStyle {
            bold: false,
            dim: false,
            italic: false,
            underline: false,
            blink: false,
            reverse: false,
            hidden: false,
            strikethrough: false
        }

    # Builder methods
    pub fn bold(self) -> TextStyle:
        self.bold = true
        return self

    pub fn dim(self) -> TextStyle:
        self.dim = true
        return self

    pub fn italic(self) -> TextStyle:
        self.italic = true
        return self

    pub fn underline(self) -> TextStyle:
        self.underline = true
        return self

    pub fn blink(self) -> TextStyle:
        self.blink = true
        return self

    pub fn reverse(self) -> TextStyle:
        self.reverse = true
        return self

    pub fn hidden(self) -> TextStyle:
        self.hidden = true
        return self

    pub fn strikethrough(self) -> TextStyle:
        self.strikethrough = true
        return self

    # Convert to FFI flags byte
    pub fn to_flags(self) -> u8:
        let mut flags: u8 = 0
        if self.bold: flags = flags | 1
        if self.dim: flags = flags | 2
        if self.italic: flags = flags | 4
        if self.underline: flags = flags | 8
        if self.blink: flags = flags | 16
        if self.reverse: flags = flags | 32
        if self.hidden: flags = flags | 64
        if self.strikethrough: flags = flags | 128
        return flags

# Complete style specification
pub struct Style:
    # Colors
    fg: Option[Color]
    bg: Option[Color]
    # Text styling
    text_style: TextStyle
    # Border
    border_style: BorderStyle
    border_color: Option[Color]
    # Layout
    width: Option[u16]
    height: Option[u16]
    min_width: Option[u16]
    min_height: Option[u16]
    max_width: Option[u16]
    max_height: Option[u16]
    # Padding (top, right, bottom, left)
    padding: (u16, u16, u16, u16)
    # Margin (top, right, bottom, left)
    margin: (u16, u16, u16, u16)
    # Flex layout
    flex_direction: Option[FlexDirection]
    justify_content: Option[JustifyContent]
    align_items: Option[AlignItems]
    flex_grow: f32
    flex_shrink: f32
    # Text
    text_align: Option[TextAlign]
    vertical_align: Option[VerticalAlign]

impl Style:
    # Create default style
    pub fn new() -> Style:
        return Style {
            fg: None,
            bg: None,
            text_style: TextStyle::new(),
            border_style: BorderStyle::None,
            border_color: None,
            width: None,
            height: None,
            min_width: None,
            min_height: None,
            max_width: None,
            max_height: None,
            padding: (0, 0, 0, 0),
            margin: (0, 0, 0, 0),
            flex_direction: None,
            justify_content: None,
            align_items: None,
            flex_grow: 0.0,
            flex_shrink: 1.0,
            text_align: None,
            vertical_align: None
        }

    # Builder: set foreground color
    pub fn fg(self, color: Color) -> Style:
        self.fg = Some(color)
        return self

    # Builder: set background color
    pub fn bg(self, color: Color) -> Style:
        self.bg = Some(color)
        return self

    # Builder: set text style
    pub fn bold(self) -> Style:
        self.text_style = self.text_style.bold()
        return self

    pub fn dim(self) -> Style:
        self.text_style = self.text_style.dim()
        return self

    pub fn italic(self) -> Style:
        self.text_style = self.text_style.italic()
        return self

    pub fn underline(self) -> Style:
        self.text_style = self.text_style.underline()
        return self

    # Builder: set border
    pub fn border(self, style: BorderStyle) -> Style:
        self.border_style = style
        return self

    pub fn border_color(self, color: Color) -> Style:
        self.border_color = Some(color)
        return self

    # Builder: set dimensions
    pub fn width(self, w: u16) -> Style:
        self.width = Some(w)
        return self

    pub fn height(self, h: u16) -> Style:
        self.height = Some(h)
        return self

    pub fn size(self, w: u16, h: u16) -> Style:
        self.width = Some(w)
        self.height = Some(h)
        return self

    # Builder: set padding (all sides)
    pub fn padding_all(self, p: u16) -> Style:
        self.padding = (p, p, p, p)
        return self

    # Builder: set padding (vertical, horizontal)
    pub fn padding_vh(self, v: u16, h: u16) -> Style:
        self.padding = (v, h, v, h)
        return self

    # Builder: set padding (top, right, bottom, left)
    pub fn padding_trbl(self, t: u16, r: u16, b: u16, l: u16) -> Style:
        self.padding = (t, r, b, l)
        return self

    # Builder: set margin (all sides)
    pub fn margin_all(self, m: u16) -> Style:
        self.margin = (m, m, m, m)
        return self

    # Builder: set flex direction
    pub fn flex_row(self) -> Style:
        self.flex_direction = Some(FlexDirection::Row)
        return self

    pub fn flex_column(self) -> Style:
        self.flex_direction = Some(FlexDirection::Column)
        return self

    # Builder: set flex grow
    pub fn grow(self, factor: f32) -> Style:
        self.flex_grow = factor
        return self

    # Builder: set text alignment
    pub fn text_left(self) -> Style:
        self.text_align = Some(TextAlign::Left)
        return self

    pub fn text_center(self) -> Style:
        self.text_align = Some(TextAlign::Center)
        return self

    pub fn text_right(self) -> Style:
        self.text_align = Some(TextAlign::Right)
        return self

    # Merge another style (other takes precedence)
    pub fn merge(self, other: &Style) -> Style:
        if other.fg.is_some(): self.fg = other.fg
        if other.bg.is_some(): self.bg = other.bg
        if other.border_style != BorderStyle::None:
            self.border_style = other.border_style
        if other.border_color.is_some(): self.border_color = other.border_color
        if other.width.is_some(): self.width = other.width
        if other.height.is_some(): self.height = other.height
        if other.flex_direction.is_some(): self.flex_direction = other.flex_direction
        if other.text_align.is_some(): self.text_align = other.text_align
        return self
