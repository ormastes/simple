# Vulkan Types - Supporting types and FFI declarations
#
# All shared types and FFI bindings for Vulkan async renderer.

use ui.element.*
use ui.attrs.*

export Frame, FrameData, BoxConstraints, LayoutResult, Rect
export DrawList, Vertex, DrawCall, PipelineType, VertexBuilder
export Buffer, Image, DirtyRegion, GpuSubmitResult
export VkSubmitInfo, VkPresentInfo, SwapchainError, LayoutCache

# ============================================================================
# FFI Declarations
# ============================================================================

extern fn vulkan_create_window(title_ptr: *const u8, title_len: u64, width: u32, height: u32) -> i64
extern fn vulkan_poll_event_async(window: i64, timeout_ms: u64) -> Future[Result[Option[Event], String]]

# ============================================================================
# Frame Types
# ============================================================================

struct Frame:
    image_index: u32
    buffer_index: usize
    command_buffer: i64

struct FrameData:
    command_buffer: i64
    fence: i64
    image_available: i64
    render_finished: i64

# ============================================================================
# Layout Types
# ============================================================================

struct BoxConstraints:
    min_width: u32
    min_height: u32
    max_width: u32
    max_height: u32

impl BoxConstraints:
    fn new(min_w: u32, min_h: u32, max_w: u32, max_h: u32) -> BoxConstraints:
        return BoxConstraints {
            min_width: min_w,
            min_height: min_h,
            max_width: max_w,
            max_height: max_h
        }

struct LayoutResult:
    bounds: Dict[u64, Rect]    # NodeId -> Rect

impl LayoutResult:
    fn default() -> LayoutResult:
        return LayoutResult { bounds: Dict::new() }

    fn get_bounds(self, node_id: NodeId) -> Rect:
        match self.bounds.get(&node_id.value()):
            case Some(rect): return rect
            case None: return Rect::zero()

struct Rect:
    x: f32
    y: f32
    width: f32
    height: f32

impl Rect:
    fn zero() -> Rect:
        return Rect { x: 0.0, y: 0.0, width: 0.0, height: 0.0 }

struct DirtyRegion:
    bounds: Rect

struct LayoutCache:
    # TODO: [ui][P1] Implement layout caching
    pass

impl LayoutCache:
    fn new() -> LayoutCache:
        return LayoutCache {}

    fn get(self, id: u64) -> Option[CachedLayout]:
        return None

    fn set(self, id: u64, constraints: BoxConstraints, result: LayoutResult):
        pass

struct CachedLayout:
    constraints: BoxConstraints
    result: LayoutResult

# ============================================================================
# Draw Types
# ============================================================================

struct DrawList:
    vertices: Array[Vertex]
    indices: Array[u32]
    draw_calls: Array[DrawCall]

impl DrawList:
    fn new() -> DrawList:
        return DrawList {
            vertices: [],
            indices: [],
            draw_calls: []
        }

    fn clear(self):
        self.vertices.clear()
        self.indices.clear()
        self.draw_calls.clear()

struct Vertex:
    position: (f32, f32)
    uv: (f32, f32)
    color: u32

struct DrawCall:
    pipeline_type: PipelineType
    vertex_offset: u32
    vertex_count: u32
    index_offset: u32
    index_count: u32
    texture_id: Option[u64]
    scissor: Option[Rect]

enum PipelineType:
    SolidColor
    RoundedRect
    Text
    Textured
    Gradient
    Shadow

struct VertexBuilder:
    vertices: Array[Vertex]
    indices: Array[u32]

impl VertexBuilder:
    fn new() -> VertexBuilder:
        return VertexBuilder { vertices: [], indices: [] }

    fn clear(self):
        self.vertices.clear()
        self.indices.clear()

# ============================================================================
# GPU Types
# ============================================================================

struct Buffer:
    handle: i64                # VkBuffer
    allocation: i64            # VmaAllocation
    size: u64

struct Image:
    handle: i64                # VkImage
    view: i64                  # VkImageView
    allocation: i64            # VmaAllocation
    width: u32
    height: u32
    format: u32

struct GpuSubmitResult:
    success: bool

struct VkSubmitInfo:
    wait_semaphores: Array[i64]
    wait_stages: Array[u32]
    command_buffers: Array[i64]
    signal_semaphores: Array[i64]
    fence: i64

struct VkPresentInfo:
    wait_semaphores: Array[i64]
    swapchains: Array[i64]
    image_indices: Array[u32]

enum SwapchainError:
    OutOfDate
    DeviceLost
