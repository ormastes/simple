# Vulkan Types - Supporting types and FFI declarations
#
# All shared types and FFI bindings for Vulkan async renderer.

use ui.element.*
use ui.attrs.*

export Frame, FrameData, BoxConstraints, LayoutResult, Rect
export DrawList, Vertex, DrawCall, PipelineType, VertexBuilder
export Buffer, Image, DirtyRegion, GpuSubmitResult
export VkSubmitInfo, VkPresentInfo, SwapchainError, LayoutCache

# ============================================================================
# FFI Declarations
# ============================================================================

extern fn vulkan_create_window(title_ptr: *const u8, title_len: u64, width: u32, height: u32) -> i64
extern fn vulkan_poll_event_async(window: i64, timeout_ms: u64) -> Future[Result[Option[Event], String]]

# ============================================================================
# Frame Types
# ============================================================================

struct Frame:
    image_index: u32
    buffer_index: usize
    command_buffer: i64

struct FrameData:
    command_buffer: i64
    fence: i64
    image_available: i64
    render_finished: i64

# ============================================================================
# Layout Types
# ============================================================================

struct BoxConstraints:
    min_width: u32
    min_height: u32
    max_width: u32
    max_height: u32

impl BoxConstraints:
    fn new(min_w: u32, min_h: u32, max_w: u32, max_h: u32) -> BoxConstraints:
        return BoxConstraints {
            min_width: min_w,
            min_height: min_h,
            max_width: max_w,
            max_height: max_h
        }

struct LayoutResult:
    bounds: Dict[u64, Rect]    # NodeId -> Rect

impl LayoutResult:
    static fn default() -> LayoutResult:
        return LayoutResult { bounds: Dict::new() }

    fn get_bounds(node_id: NodeId) -> Rect:
        match self.bounds.get(&node_id.value()):
            case Some(rect): return rect
            case None: return Rect::zero()

struct Rect:
    x: f32
    y: f32
    width: f32
    height: f32

impl Rect:
    fn zero() -> Rect:
        return Rect { x: 0.0, y: 0.0, width: 0.0, height: 0.0 }

struct DirtyRegion:
    bounds: Rect

struct LayoutCache:
    # TODO: [ui][P1] Implement layout caching
    pass

impl LayoutCache:
    static fn new() -> LayoutCache:
        return LayoutCache {}

    fn get(id: u64) -> Option[CachedLayout]:
        return None

    fn set(id: u64, constraints: BoxConstraints, result: LayoutResult):
        pass

struct CachedLayout:
    constraints: BoxConstraints
    result: LayoutResult

# ============================================================================
# Draw Types
# ============================================================================

struct DrawList:
    vertices: Array[Vertex]
    indices: Array[u32]
    draw_calls: Array[DrawCall]

impl DrawList:
    static fn new() -> DrawList:
        return DrawList {
            vertices: [],
            indices: [],
            draw_calls: []
        }

    fn clear():
        self.vertices.clear()
        self.indices.clear()
        self.draw_calls.clear()

struct Vertex:
    position: (f32, f32)
    uv: (f32, f32)
    color: u32

struct DrawCall:
    pipeline_type: PipelineType
    vertex_offset: u32
    vertex_count: u32
    index_offset: u32
    index_count: u32
    texture_id: Option[u64]
    scissor: Option[Rect]

enum PipelineType:
    SolidColor
    RoundedRect
    Text
    Textured
    Gradient
    Shadow

impl PipelineType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string() -> String:
        """Convert pipeline type to string.

        Returns:
            Type name
        """
        match self:
            case SolidColor: "SolidColor"
            case RoundedRect: "RoundedRect"
            case Text: "Text"
            case Textured: "Textured"
            case Gradient: "Gradient"
            case Shadow: "Shadow"

    fn is_solid_color() -> bool:
        """Check if this is SolidColor pipeline."""
        match self:
            case SolidColor: true
            case _: false

    fn is_rounded_rect() -> bool:
        """Check if this is RoundedRect pipeline."""
        match self:
            case RoundedRect: true
            case _: false

    fn is_text() -> bool:
        """Check if this is Text pipeline."""
        match self:
            case Text: true
            case _: false

    fn is_textured() -> bool:
        """Check if this is Textured pipeline."""
        match self:
            case Textured: true
            case _: false

    fn is_gradient() -> bool:
        """Check if this is Gradient pipeline."""
        match self:
            case Gradient: true
            case _: false

    fn is_shadow() -> bool:
        """Check if this is Shadow pipeline."""
        match self:
            case Shadow: true
            case _: false

    fn requires_texture() -> bool:
        """Check if pipeline requires texture binding.

        Returns:
            true for Textured or Text
        """
        match self:
            case Textured: true
            case Text: true
            case _: false

    fn supports_alpha() -> bool:
        """Check if pipeline supports alpha blending.

        Returns:
            true for most types except Shadow
        """
        match self:
            case Shadow: false
            case _: true

    fn summary() -> String:
        """Get summary of pipeline type.

        Returns:
            Human-readable summary

        Example:
            PipelineType::Text.summary()
            # → "PipelineType: Text (requires texture, supports alpha)"
        """
        val name = self.to_string()
        val texture = if self.requires_texture(): "requires texture" else: "no texture"
        val alpha = if self.supports_alpha(): "supports alpha" else: "no alpha"
        return "PipelineType: {name} ({texture}, {alpha})"

struct VertexBuilder:
    vertices: Array[Vertex]
    indices: Array[u32]

impl VertexBuilder:
    static fn new() -> VertexBuilder:
        return VertexBuilder { vertices: [], indices: [] }

    fn clear():
        self.vertices.clear()
        self.indices.clear()

# ============================================================================
# GPU Types
# ============================================================================

struct Buffer:
    handle: i64                # VkBuffer
    allocation: i64            # VmaAllocation
    size: u64

struct Image:
    handle: i64                # VkImage
    view: i64                  # VkImageView
    allocation: i64            # VmaAllocation
    width: u32
    height: u32
    format: u32

struct GpuSubmitResult:
    success: bool

struct VkSubmitInfo:
    wait_semaphores: Array[i64]
    wait_stages: Array[u32]
    command_buffers: Array[i64]
    signal_semaphores: Array[i64]
    fence: i64

struct VkPresentInfo:
    wait_semaphores: Array[i64]
    swapchains: Array[i64]
    image_indices: Array[u32]

enum SwapchainError:
    OutOfDate
    DeviceLost

impl SwapchainError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_out_of_date() -> bool:
        """Check if swapchain is out of date.

        Returns:
            true for OutOfDate

        Example:
            SwapchainError::OutOfDate.is_out_of_date()  # → true
        """
        match self:
            case OutOfDate: true
            case _: false

    fn is_device_lost() -> bool:
        """Check if device was lost.

        Returns:
            true for DeviceLost

        Example:
            SwapchainError::DeviceLost.is_device_lost()  # → true
        """
        match self:
            case DeviceLost: true
            case _: false

    fn is_recoverable() -> bool:
        """Check if error is recoverable.

        Returns:
            true for OutOfDate (can recreate swapchain)

        Example:
            SwapchainError::OutOfDate.is_recoverable()  # → true
            SwapchainError::DeviceLost.is_recoverable()  # → false
        """
        match self:
            case OutOfDate: true
            case DeviceLost: false

    fn to_string() -> String:
        """Convert error to string.

        Returns:
            Error name
        """
        match self:
            case OutOfDate: "OutOfDate"
            case DeviceLost: "DeviceLost"

    fn description() -> String:
        """Get error description.

        Returns:
            Human-readable description
        """
        match self:
            case OutOfDate: "Swapchain is out of date (window resized or display changed)"
            case DeviceLost: "GPU device was lost"

    fn summary() -> String:
        """Get summary of swapchain error.

        Returns:
            Human-readable summary

        Example:
            SwapchainError::OutOfDate.summary()
            # → "SwapchainError: OutOfDate (Swapchain is out of date, recoverable)"
        """
        val name = self.to_string()
        val desc = self.description()
        val recoverable = if self.is_recoverable(): "recoverable" else: "fatal"
        return "SwapchainError: {name} ({desc}, {recoverable})"

    fn requires_recreation() -> bool:
        """Check if error requires swapchain recreation.

        Returns:
            true for OutOfDate

        Example:
            SwapchainError::OutOfDate.requires_recreation()  # → true
        """
        match self:
            case OutOfDate: true
            case _: false

    fn is_fatal() -> bool:
        """Check if error is fatal.

        Returns:
            true for DeviceLost

        Example:
            SwapchainError::DeviceLost.is_fatal()  # → true
        """
        match self:
            case DeviceLost: true
            case _: false

    fn to_string() -> String:
        """Convert error to string.

        Returns:
            Error name

        Example:
            SwapchainError::OutOfDate.to_string()  # → "out_of_date"
        """
        match self:
            case OutOfDate: "out_of_date"
            case DeviceLost: "device_lost"

    fn description() -> String:
        """Get detailed error description.

        Returns:
            Human-readable description

        Example:
            SwapchainError::OutOfDate.description()
            # → "Swapchain is out of date and must be recreated"
        """
        match self:
            case OutOfDate: "Swapchain is out of date and must be recreated"
            case DeviceLost: "Vulkan device was lost (fatal error)"

    fn summary() -> String:
        """Get summary of error.

        Returns:
            Summary string

        Example:
            SwapchainError::OutOfDate.summary()
            # → "SwapchainError: out_of_date (recoverable)"
        """
        val name = self.to_string()
        val recoverable = if self.is_recoverable(): "recoverable" else: "fatal"
        return "SwapchainError: {name} ({recoverable})"
