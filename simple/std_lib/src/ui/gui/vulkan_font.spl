# Vulkan Font Atlas - Text Rendering
#
# Implements GPU-accelerated text rendering using a texture atlas approach.
# Rasterizes font glyphs to a GPU texture and renders text as textured quads.
#
# Architecture:
#   TTF Font → Glyph Rasterization → Atlas Texture → GPU Upload
#   Text text → Glyph Lookup → Quad Generation → Batch Rendering
#
# Features:
#   - TTF/OTF font loading
#   - Dynamic atlas generation (512x512 or 1024x1024)
#   - Glyph caching and metrics
#   - Kerning support
#   - Multiple font sizes
#   - Unicode support (Basic Multilingual Plane)

use core.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_buffers.*

# =============================================================================
# Font Atlas - Main Structure
# =============================================================================

pub struct FontAtlas:
    device: VulkanDevice
    atlas_texture: VkTexture
    atlas_size: u32
    font_size: u32

    # Glyph cache
    glyph_map: Dict<char, GlyphInfo>

    # Atlas packing state
    current_x: u32
    current_y: u32
    row_height: u32

    # Font metrics
    ascent: f32
    descent: f32
    line_gap: f32

pub struct GlyphInfo:
    # Atlas texture coordinates (normalized 0..1)
    atlas_x: f32
    atlas_y: f32
    atlas_w: f32
    atlas_h: f32

    # Glyph metrics (in pixels)
    width: f32
    height: f32
    bearing_x: f32  # Horizontal bearing
    bearing_y: f32  # Vertical bearing
    advance: f32    # Horizontal advance

impl GlyphInfo:
    pub fn get_atlas_coords(self) -> (f32, f32, f32, f32):
        """Get atlas texture coordinates.

        Returns:
            (x, y, width, height) in normalized 0..1 range

        Example:
            val glyph = atlas.glyph_map.get(&'A')?
            val (x, y, w, h) = glyph.get_atlas_coords()
        """
        (self.atlas_x, self.atlas_y, self.atlas_w, self.atlas_h)

    pub fn get_dimensions(self) -> (f32, f32):
        """Get glyph pixel dimensions.

        Returns:
            (width, height) in pixels

        Example:
            val glyph = atlas.glyph_map.get(&'A')?
            val (w, h) = glyph.get_dimensions()
        """
        (self.width, self.height)

    pub fn get_bearing(self) -> (f32, f32):
        """Get glyph bearing offsets.

        Returns:
            (bearing_x, bearing_y) in pixels

        Example:
            val glyph = atlas.glyph_map.get(&'A')?
            val (bx, by) = glyph.get_bearing()
        """
        (self.bearing_x, self.bearing_y)

    pub fn get_advance(self) -> f32:
        """Get horizontal advance.

        Returns:
            Advance in pixels

        Example:
            val glyph = atlas.glyph_map.get(&'A')?
            val adv = glyph.get_advance()
        """
        self.advance

    pub fn is_empty(self) -> bool:
        """Check if glyph has zero size.

        Returns:
            True if width or height is zero

        Example:
            val glyph = atlas.glyph_map.get(&' ')?
            if glyph.is_empty():
                print("Space character")
        """
        self.width == 0.0 or self.height == 0.0

    pub fn aspect_ratio(self) -> f32:
        """Calculate glyph aspect ratio.

        Returns:
            Width / height ratio

        Example:
            val glyph = atlas.glyph_map.get(&'W')?
            val ratio = glyph.aspect_ratio()
        """
        if self.height == 0.0:
            return 0.0
        self.width / self.height

    pub fn is_wide(self) -> bool:
        """Check if glyph is wider than tall.

        Returns:
            True if aspect ratio > 1

        Example:
            val glyph = atlas.glyph_map.get(&'W')?
            if glyph.is_wide():
                print("Wide glyph")
        """
        self.aspect_ratio() > 1.0

    pub fn is_tall(self) -> bool:
        """Check if glyph is taller than wide.

        Returns:
            True if aspect ratio < 1

        Example:
            val glyph = atlas.glyph_map.get(&'I')?
            if glyph.is_tall():
                print("Tall glyph")
        """
        self.aspect_ratio() < 1.0

    pub fn summary(self) -> text:
        """Get glyph info summary.

        Returns:
            Human-readable summary

        Example:
            val glyph = atlas.glyph_map.get(&'A')?
            print(glyph.summary())
        """
        return "GlyphInfo: {self.width}x{self.height}px, advance={self.advance}, atlas=({self.atlas_x:.3}, {self.atlas_y:.3})"

impl FontAtlas:
    # Create font atlas from TTF file
    pub async fn new(
        device: &VulkanDevice,
        font_path: &str,
        font_size: u32
    ) -> Result<FontAtlas, text>:
        # Load TTF font file
        val font_data = await load_font_file(font_path)?

        # Create atlas texture (512x512 RGBA)
        val atlas_size = 512u32
        val atlas_texture = vulkan_create_texture(
            device.device,
            atlas_size,
            atlas_size,
            VK_FORMAT_R8G8B8A8_UNORM
        )?

        # Initialize with transparent pixels
        var atlas_data: Array<u8> = Array::with_capacity((atlas_size * atlas_size * 4) as usize)
        for _ in 0..(atlas_size * atlas_size * 4):
            atlas_data.push(0)

        # Upload initial empty texture
        vulkan_upload_texture(device.device, atlas_texture, &atlas_data)?

        # Get font metrics
        val metrics = parse_font_metrics(&font_data, font_size)?

        var atlas = FontAtlas {
            device: device.clone(),
            atlas_texture: atlas_texture,
            atlas_size: atlas_size,
            font_size: font_size,
            glyph_map: Dict::new(),
            current_x: 0,
            current_y: 0,
            row_height: 0,
            ascent: metrics.ascent,
            descent: metrics.descent,
            line_gap: metrics.line_gap,
        }

        # Pre-rasterize common ASCII characters (32-126)
        await atlas.rasterize_ascii_set(&font_data)?

        Ok(atlas)

    # Pre-rasterize ASCII character set
    async fn rasterize_ascii_set(&mut self, font_data: &Array<u8>) -> Result<(), text>:
        # Common ASCII printable characters
        val ascii_chars = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

        for ch in ascii_chars.chars():
            await self.rasterize_glyph(font_data, ch)?

        Ok(())

    # Rasterize a single glyph and add to atlas
    async fn rasterize_glyph(&mut self, font_data: &Array<u8>, ch: char) -> Result<(), text>:
        # Check if already cached
        if self.glyph_map.contains_key(&ch):
            return Ok(())

        # Rasterize glyph using font data
        val glyph_bitmap = rasterize_char(font_data, ch, self.font_size)?

        # Check if we need to advance to next row
        if self.current_x + glyph_bitmap.width > self.atlas_size:
            self.current_x = 0
            self.current_y += self.row_height
            self.row_height = 0

        # Check if atlas is full
        if self.current_y + glyph_bitmap.height > self.atlas_size:
            return Err("Font atlas full - need to resize or use multiple atlases")

        # Upload glyph bitmap to atlas texture
        await self.upload_glyph_region(
            &glyph_bitmap.pixels,
            self.current_x,
            self.current_y,
            glyph_bitmap.width,
            glyph_bitmap.height
        )?

        # Store glyph info (normalized coordinates)
        val atlas_size_f = self.atlas_size as f32
        val glyph_info = GlyphInfo {
            atlas_x: self.current_x as f32 / atlas_size_f,
            atlas_y: self.current_y as f32 / atlas_size_f,
            atlas_w: glyph_bitmap.width as f32 / atlas_size_f,
            atlas_h: glyph_bitmap.height as f32 / atlas_size_f,
            width: glyph_bitmap.width as f32,
            height: glyph_bitmap.height as f32,
            bearing_x: glyph_bitmap.bearing_x,
            bearing_y: glyph_bitmap.bearing_y,
            advance: glyph_bitmap.advance,
        }

        self.glyph_map.insert(ch, glyph_info)

        # Update packing state
        self.current_x += glyph_bitmap.width
        if glyph_bitmap.height > self.row_height:
            self.row_height = glyph_bitmap.height

        Ok(())

    # Upload glyph bitmap region to atlas texture
    async fn upload_glyph_region(
        &mut self,
        pixels: &Array<u8>,
        x: u32,
        y: u32,
        width: u32,
        height: u32
    ) -> Result<(), text>:
        vulkan_upload_texture_region(
            self.device.device,
            self.atlas_texture,
            pixels,
            x,
            y,
            width,
            height
        )

    # Add text to vertex cache with proper glyph positioning
    pub async fn add_text(
        &mut self,
        cache: &mut VertexCache,
        text: &str,
        x: f32,
        y: f32,
        color: [f32; 4]
    ) -> Result<(), text>:
        var cursor_x = x
        val cursor_y = y + self.ascent  # Baseline position

        for ch in text.chars():
            # Get or rasterize glyph
            if !self.glyph_map.contains_key(&ch):
                # Dynamically rasterize if not cached
                # TODO: [ui][P3] Load font data from somewhere
                // await self.rasterize_glyph(&font_data, ch)?
                continue

            val glyph = self.glyph_map.get(&ch).unwrap()

            # Calculate glyph position
            val glyph_x = cursor_x + glyph.bearing_x
            val glyph_y = cursor_y - glyph.bearing_y

            # Add textured quad to vertex cache
            cache.add_textured_rect(
                glyph_x,
                glyph_y,
                glyph.width,
                glyph.height,
                glyph.atlas_x,
                glyph.atlas_y,
                glyph.atlas_w,
                glyph.atlas_h,
                color
            )

            # Advance cursor
            cursor_x += glyph.advance

        Ok(())

    # Measure text width for layout
    pub fn measure_text(&self, text: &str) -> f32:
        var width = 0.0f32

        for ch in text.chars():
            if val Some(glyph) = self.glyph_map.get(&ch):
                width += glyph.advance

        width

    # Get line height
    pub fn line_height(&self) -> f32:
        self.ascent - self.descent + self.line_gap

    # Cleanup
    pub async fn destroy(&mut self):
        await vulkan_destroy_texture_async(self.device.device, self.atlas_texture)

    pub fn get_atlas_size(self) -> u32:
        """Get atlas texture size.

        Returns:
            Atlas size in pixels

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            assert(atlas.get_atlas_size() >= 512)
        """
        self.atlas_size

    pub fn get_font_size(self) -> u32:
        """Get font size in pixels.

        Returns:
            Font size

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            assert(atlas.get_font_size() == 16)
        """
        self.font_size

    pub fn glyph_count(self) -> usize:
        """Get number of cached glyphs.

        Returns:
            Number of glyphs in cache

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            val count = atlas.glyph_count()
        """
        self.glyph_map.len()

    pub fn has_glyph(self, ch: char) -> bool:
        """Check if glyph is cached.

        Returns:
            True if glyph is in cache

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            assert(atlas.has_glyph('A'))
        """
        self.glyph_map.contains_key(&ch)

    pub fn atlas_utilization(self) -> f32:
        """Calculate atlas texture utilization.

        Returns:
            Percentage of atlas filled (0.0-1.0)

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            val usage = atlas.atlas_utilization()
        """
        val filled_height = self.current_y + self.row_height
        (filled_height as f32) / (self.atlas_size as f32)

    pub fn is_atlas_full(self) -> bool:
        """Check if atlas is nearly full (>90%).

        Returns:
            True if atlas utilization > 0.9

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            if atlas.is_atlas_full():
                print("Atlas needs expansion")
        """
        self.atlas_utilization() > 0.9

    pub fn get_ascent(self) -> f32:
        """Get font ascent (baseline to top).

        Returns:
            Ascent in pixels

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            val ascent = atlas.get_ascent()
        """
        self.ascent

    pub fn get_descent(self) -> f32:
        """Get font descent (baseline to bottom).

        Returns:
            Descent in pixels (negative)

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            val descent = atlas.get_descent()
        """
        self.descent

    pub fn summary(self) -> text:
        """Get font atlas summary.

        Returns:
            Human-readable summary

        Example:
            val atlas = FontAtlas::new(&device, "font.ttf", 16).await?
            print(atlas.summary())
        """
        val util = self.atlas_utilization() * 100.0
        return "FontAtlas: {self.atlas_size}x{self.atlas_size}, {self.font_size}px, {self.glyph_count()} glyphs, {util:.1}% used"
    }

# =============================================================================
# Glyph Bitmap - Rasterized Character Data
# =============================================================================

struct GlyphBitmap:
    pixels: Array<u8>      # RGBA pixel data
    width: u32
    height: u32
    bearing_x: f32         # Horizontal bearing (offset from cursor)
    bearing_y: f32         # Vertical bearing (offset from baseline)
    advance: f32           # How far to advance cursor

# =============================================================================
# Font Metrics
# =============================================================================

struct FontMetrics:
    ascent: f32            # Distance from baseline to top
    descent: f32           # Distance from baseline to bottom (negative)
    line_gap: f32          # Recommended line spacing

# =============================================================================
# Font Loading and Rasterization (FFI)
# =============================================================================

# Load TTF/OTF font file
async fn load_font_file(path: &str) -> Result<Array<u8>, text>:
    # Read font file bytes
    val bytes = await read_file_async(path)?
    Ok(bytes)

# Parse font metrics from font data
fn parse_font_metrics(font_data: &Array<u8>, font_size: u32) -> Result<FontMetrics, text>:
    # Call FFI to parse TTF header and get metrics
    vulkan_parse_font_metrics(font_data, font_size)
}

# Rasterize a character to a bitmap
fn rasterize_char(font_data: &Array<u8>, ch: char, font_size: u32) -> Result<GlyphBitmap, text>:
    # Call FFI to rasterize character using FreeType or similar
    vulkan_rasterize_char(font_data, ch, font_size)
}

# =============================================================================
# Vertex Cache Extension for Textured Rendering
# =============================================================================

# Already implemented in vulkan_renderer.spl:
# impl VertexCache:
#     pub fn add_textured_rect(...)

# =============================================================================
# FFI Declarations - Font Operations
# =============================================================================

extern fn read_file_async(path: &str) -> Future<Result<Array<u8>, text>>
extern fn vulkan_parse_font_metrics(font_data: &Array<u8>, font_size: u32) -> Result<FontMetrics, text>
extern fn vulkan_rasterize_char(font_data: &Array<u8>, ch: char, font_size: u32) -> Result<GlyphBitmap, text>

# =============================================================================
# FFI Declarations - Texture Operations
# =============================================================================

extern fn vulkan_create_texture(device: VkDevice, width: u32, height: u32, format: VkFormat) -> Result<VkTexture, text>
extern fn vulkan_upload_texture(device: VkDevice, texture: VkTexture, data: &Array<u8>) -> Result<(), text>
extern fn vulkan_upload_texture_region(device: VkDevice, texture: VkTexture, data: &Array<u8>, x: u32, y: u32, width: u32, height: u32) -> Result<(), text>
extern fn vulkan_destroy_texture_async(device: VkDevice, texture: VkTexture) -> Future<Result<(), text>>

# =============================================================================
# Vulkan Constants
# =============================================================================

pub type VkTexture = i64
pub type VkFormat = u32

pub const VK_FORMAT_R8G8B8A8_UNORM: u32 = 37  # Standard RGBA format

# =============================================================================
# Default Font Fallback
# =============================================================================

impl FontAtlas:
    # Create font atlas with embedded default font
    pub async fn default(device: &VulkanDevice) -> Result<FontAtlas, text>:
        # Use embedded DejaVu Sans or similar free font
        # For now, try to load system font
        val font_paths = [
            "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",  # Linux
            "C:\\Windows\\Fonts\\arial.ttf",                     # Windows
            "/System/Library/Fonts/Helvetica.ttc",              # macOS
            "/usr/share/fonts/TTF/DejaVuSans.ttf",              # Arch Linux
        ]

        for path in &font_paths:
            match Self::new(device, path, 16).await:
                case Ok(atlas): return Ok(atlas)
                case Err(_): continue

        Err("No default font found - please provide font path explicitly")
    }

# =============================================================================
# Text Layout Helpers
# =============================================================================

impl FontAtlas:
    # Layout multi-line text
    pub fn layout_text(&self, text: &str, max_width: f32) -> Array<TextLine>:
        var lines: Array<TextLine> = Array::new()
        var current_line = text::new()
        var current_width = 0.0f32

        for word in text.split(' '):
            val word_width = self.measure_text(word) + self.measure_text(" ")

            if current_width + word_width > max_width and !current_line.is_empty():
                # Start new line
                lines.push(TextLine {
                    text: current_line.clone(),
                    width: current_width,
                })
                current_line = text::new()
                current_width = 0.0

            current_line.push_str(word)
            current_line.push(' ')
            current_width += word_width

        # Add last line
        if !current_line.is_empty():
            lines.push(TextLine {
                text: current_line,
                width: current_width,
            })

        lines

    # Center text horizontally
    pub fn center_text(&self, text: &str, container_width: f32) -> f32:
        val text_width = self.measure_text(text)
        (container_width - text_width) / 2.0

    # Align text right
    pub fn align_right(&self, text: &str, container_width: f32) -> f32:
        val text_width = self.measure_text(text)
        container_width - text_width

pub struct TextLine:
    text: text
    width: f32

impl TextLine:
    pub fn get_text(self) -> &text:
        """Get line text.

        Returns:
            Text content

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            assert(line.get_text() == "Hello")
        """
        &self.text

    pub fn get_width(self) -> f32:
        """Get line width in pixels.

        Returns:
            Width in pixels

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            assert(line.get_width() == 50.0)
        """
        self.width

    pub fn is_empty(self) -> bool:
        """Check if line is empty.

        Returns:
            True if text is empty

        Example:
            val line = TextLine { text: "".to_string(), width: 0.0 }
            assert(line.is_empty())
        """
        self.text.is_empty()

    pub fn char_count(self) -> usize:
        """Get number of characters.

        Returns:
            Character count

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            assert(line.char_count() == 5)
        """
        self.text.len()

    pub fn summary(self) -> text:
        """Get text line summary.

        Returns:
            Human-readable summary

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            print(line.summary())
        """
        return "TextLine: '{self.text}' ({self.width}px)"

# =============================================================================
# Advanced Font Features (TODO)
# =============================================================================

impl FontAtlas:
    # TODO: [ui][P3] Kerning support
    pub fn get_kerning(&self, left: char, right: char) -> f32:
        # Would need kerning table from TTF file
        0.0

    # TODO: [ui][P3] Bold/italic variants
    pub fn set_font_weight(&mut self, weight: FontWeight):
        # Would need to load different font file or apply transformations
        pass

    # TODO: [ui][P3] Sub-pixel rendering
    pub fn enable_subpixel_rendering(&mut self):
        # Would need RGB sub-pixel layout and special shader
        pass

    # TODO: [ui][P3] SDF (Signed Distance Field) rendering for scalable text
    pub fn enable_sdf_rendering(&mut self):
        # Would generate SDF atlas instead of bitmap atlas
        pass

pub enum FontWeight:
    Thin
    Light
    Regular
    Medium
    Bold
    Black

impl FontWeight:
    pub fn to_string(self) -> text:
        """Convert font weight to string.

        Returns:
            text representation

        Example:
            val weight = FontWeight::Bold
            assert(weight.to_string() == "bold")
        """
        match self:
            case Thin: return "thin"
            case Light: return "light"
            case Regular: return "regular"
            case Medium: return "medium"
            case Bold: return "bold"
            case Black: return "black"

    pub fn description(self) -> text:
        """Get detailed description of weight.

        Returns:
            Human-readable description

        Example:
            val weight = FontWeight::Bold
            assert(weight.description().contains("Bold"))
        """
        match self:
            case Thin: return "Thin weight (100)"
            case Light: return "Light weight (300)"
            case Regular: return "Regular weight (400)"
            case Medium: return "Medium weight (500)"
            case Bold: return "Bold weight (700)"
            case Black: return "Black weight (900)"

    pub fn to_weight_value(self) -> u16:
        """Get numeric weight value.

        Returns:
            Weight value (100-900)

        Example:
            assert(FontWeight::Bold.to_weight_value() == 700)
            assert(FontWeight::Regular.to_weight_value() == 400)
        """
        match self:
            case Thin: return 100
            case Light: return 300
            case Regular: return 400
            case Medium: return 500
            case Bold: return 700
            case Black: return 900

    pub fn is_light(self) -> bool:
        """Check if this is a light weight.

        Returns:
            True if thin or light

        Example:
            assert(FontWeight::Thin.is_light())
            assert(not FontWeight::Bold.is_light())
        """
        match self:
            case Thin: return true
            case Light: return true
            case _: return false

    pub fn is_heavy(self) -> bool:
        """Check if this is a heavy weight.

        Returns:
            True if bold or black

        Example:
            assert(FontWeight::Bold.is_heavy())
            assert(not FontWeight::Light.is_heavy())
        """
        match self:
            case Bold: return true
            case Black: return true
            case _: return false

    pub fn is_normal(self) -> bool:
        """Check if this is normal/regular weight.

        Returns:
            True if regular

        Example:
            assert(FontWeight::Regular.is_normal())
            assert(not FontWeight::Bold.is_normal())
        """
        match self:
            case Regular: return true
            case _: return false

    pub fn is_heavier_than(self, other: FontWeight) -> bool:
        """Check if this weight is heavier than another.

        Returns:
            True if weight value is greater

        Example:
            assert(FontWeight::Bold.is_heavier_than(FontWeight::Regular))
            assert(not FontWeight::Light.is_heavier_than(FontWeight::Bold))
        """
        self.to_weight_value() > other.to_weight_value()
