# Vulkan Renderer - GPU-Accelerated UI Backend
#
# High-performance UI rendering using Vulkan for GPU acceleration.
# Implements the RenderBackend trait with Vulkan-specific optimizations.
#
# Architecture:
#   CPU Layer: Layout, element processing, command recording
#   GPU Layer: Vertex shading, rasterization, fragment shading, composition
#
# Key Features:
#   - SDF (Signed Distance Field) text rendering
#   - Rounded corners and shadows via shaders
#   - Draw call batching and instancing
#   - Triple buffering for smooth rendering
#   - Dirty rectangle tracking for incremental updates

use core.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.vulkan.types.*

# =============================================================================
# Main Vulkan Renderer
# =============================================================================

pub struct VulkanRenderer:
    # Core Vulkan components
    device: VulkanDevice
    swapchain: Swapchain
    render_pass: RenderPass

    # CPU-side processing
    layout_engine: LayoutEngine
    element_processor: ElementProcessor
    resource_manager: ResourceManager

    # GPU-side management
    buffer_manager: BufferManager
    text_renderer: TextRenderer

    # Frame management (triple buffering)
    frame_data: Array<FrameData>  # Size 3
    frame_index: usize

    # State
    initialized: bool
    window_width: u32
    window_height: u32

impl VulkanRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized."""
        self.initialized

    pub fn is_triple_buffered(self) -> bool:
        """Check if using triple buffering (3 frame buffers)."""
        self.frame_data.len() == 3

    pub fn current_frame_index(self) -> usize:
        """Get current frame index."""
        self.frame_index

    pub fn width(self) -> u32:
        """Get window width."""
        self.window_width

    pub fn height(self) -> u32:
        """Get window height."""
        self.window_height

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio."""
        (self.window_width as f64) / (self.window_height as f64)

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation."""
        self.window_width > self.window_height

    pub fn is_portrait(self) -> bool:
        """Check if window is portrait orientation."""
        self.window_height > self.window_width

    pub fn is_square(self) -> bool:
        """Check if window is square."""
        self.window_width == self.window_height

    pub fn summary(self) -> text:
        val status = if self.initialized: "initialized" else: "uninitialized"
        val buffering = if self.is_triple_buffered(): "triple" else: "unknown"
        return "VulkanRenderer: {self.window_width}x{self.window_height} ({status}, {buffering} buffering, frame {self.frame_index})"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new Vulkan renderer
    pub fn new(window_title: &str, width: u32, height: u32) -> Result<VulkanRenderer, RenderError>:
        # Create window handle using platform-specific windowing system
        # On Linux: X11 or Wayland, Windows: Win32, macOS: Cocoa
        val window_handle = vulkan_create_window(window_title, width, height)
        if window_handle == 0:
            return Err(RenderError::IoError("Failed to create window".to_string()))

        # TODO: [ui][P3] Initialize Vulkan device
        val device = match VulkanDevice::new(window_handle):
            case Ok(dev): dev
            case Err(e): return Err(RenderError::IoError(e))

        # TODO: [ui][P3] Create swapchain
        val swapchain = match Swapchain::new(&device, width, height):
            case Ok(sc): sc
            case Err(e): return Err(RenderError::IoError(e))

        # TODO: [ui][P3] Create render pass
        val render_pass = match RenderPass::new(&device, &swapchain):
            case Ok(rp): rp
            case Err(e): return Err(RenderError::IoError(e))

        # Initialize CPU-side components
        val layout_engine = LayoutEngine::new()
        val element_processor = ElementProcessor::new()
        val resource_manager = ResourceManager::new(&device)

        # Initialize GPU-side components
        val buffer_manager = BufferManager::new(&device)
        val text_renderer = TextRenderer::new(&device)

        # Create frame data for triple buffering
        var frame_data: Array<FrameData> = []
        for _ in 0..3:
            frame_data.push(FrameData::new(&device))

        return Ok(VulkanRenderer {
            device: device,
            swapchain: swapchain,
            render_pass: render_pass,
            layout_engine: layout_engine,
            element_processor: element_processor,
            resource_manager: resource_manager,
            buffer_manager: buffer_manager,
            text_renderer: text_renderer,
            frame_data: frame_data,
            frame_index: 0,
            initialized: false,
            window_width: width,
            window_height: height
        })

impl RenderBackend for VulkanRenderer:
    fn init() -> Result<(), RenderError>:
        if self.initialized:
            return Err(RenderError::AlreadyInitialized)

        # TODO: [ui][P3] Initialize Vulkan resources
        # - Create descriptor pools
        # - Compile shaders
        # - Create graphics pipelines
        # - Load default font atlas

        self.initialized = true
        return Ok(())

    fn shutdown() -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # TODO: [ui][P3] Cleanup Vulkan resources
        # - Wait for device idle
        # - Destroy pipelines
        # - Destroy descriptor pools
        # - Destroy frame resources
        # - Destroy render pass
        # - Destroy swapchain
        # - Destroy device

        self.initialized = false
        return Ok(())

    fn dimensions() -> (u16, u16):
        return (self.window_width as u16, self.window_height as u16)

    fn render(tree: &ElementTree) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # 1. Begin frame
        val frame = match self.begin_frame():
            case Ok(f): f
            case Err(e): return Err(e)

        # 2. Compute layout (CPU)
        val constraints = BoxConstraints::new(
            0, 0,
            self.window_width, self.window_height
        )
        val layout_result = self.layout_engine.compute_layout(
            tree.root(),
            constraints
        )

        # 3. Process elements into draw list (CPU)
        val draw_list = self.element_processor.process_tree(
            tree,
            &layout_result
        )

        # 4. Upload geometry to GPU
        self.buffer_manager.upload_draw_list(&draw_list, frame.buffer_index)

        # 5. Record rendering commands (CPU → GPU)
        self.record_commands(&frame, &draw_list)

        # 6. End frame and present
        return self.end_frame(frame)

    fn apply_patches(patches: &PatchSet) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Incremental update implementation:
        # 1. Identify affected elements from patches
        var dirty_nodes: Set<NodeId> = Set::new()
        for patch in patches.iter():
            dirty_nodes.insert(patch.target_node())

        # 2. Mark dirty regions in the layout cache
        for node_id in dirty_nodes:
            self.layout_engine.invalidate(node_id)

        # 3. Recompute layout only for affected subtrees
        for node_id in dirty_nodes:
            if val Some(elem) = self.element_map.get(&node_id):
                val constraints = self.get_constraints_for(elem)
                self.layout_engine.compute(elem, constraints)

        # 4. Regenerate draw list only for dirty regions
        var dirty_draw_commands: Array<DrawCommand> = []
        for node_id in dirty_nodes:
            if val Some(layout) = self.layout_engine.get_cached(node_id):
                if val Some(elem) = self.element_map.get(&node_id):
                    val commands = self.element_processor.process(elem, layout)
                    dirty_draw_commands.extend(commands)

        # 5. Update GPU buffers with new draw commands
        self.buffer_manager.update_draw_commands(&dirty_draw_commands)

        return Ok(())

    fn clear() -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Begin frame and clear to background color
        val frame = match self.begin_frame():
            case Ok(f): f
            case Err(e): return Err(e)

        # TODO: [ui][P3] Clear framebuffer
        # - Begin render pass with clear color
        # - End render pass
        # - Submit command buffer

        return self.end_frame(frame)

    fn flush() -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # TODO: [ui][P3] Wait for GPU to finish pending work
        # vkDeviceWaitIdle(device)

        return Ok(())

    fn poll_event(timeout_ms: u64) -> Result<Option<Event>, RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # TODO: [ui][P3] Poll window events (platform-specific)
        # - Check for window resize
        # - Check for input events (keyboard, mouse)
        # - Return None if no events within timeout

        return Ok(None)

    fn read_event() -> Result<Event, RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # TODO: [ui][P3] Block until next event arrives
        loop:
            match self.poll_event(1000):
                case Ok(Some(event)): return Ok(event)
                case Ok(None): pass  # Continue waiting
                case Err(e): return Err(e)

impl VulkanRenderer:
    # Begin a new frame
    fn begin_frame() -> Result<Frame, RenderError>:
        # TODO: [ui][P3] Acquire next swapchain image
        # - Call vkAcquireNextImageKHR
        # - Wait for frame fence (triple buffering)
        # - Reset command buffer
        # - Begin command buffer recording

        val image_index = 0  # TODO: [ui][P3] Get from vkAcquireNextImageKHR

        return Ok(Frame {
            image_index: image_index,
            buffer_index: self.frame_index,
            command_buffer: self.frame_data[self.frame_index].command_buffer
        })

    # Record rendering commands
    fn record_commands(frame: &Frame, draw_list: &DrawList):
        val cmd_buf = frame.command_buffer

        # TODO: [ui][P3] Begin render pass
        # vkCmdBeginRenderPass(cmd_buf, &render_pass_begin_info, ...)

        # TODO: [ui][P3] Set viewport and scissor
        # vkCmdSetViewport(cmd_buf, 0, 1, &viewport)
        # vkCmdSetScissor(cmd_buf, 0, 1, &scissor)

        # Process each draw call
        for draw_call in draw_list.draw_calls:
            # TODO: [ui][P3] Bind pipeline for this draw call type
            # val pipeline = self.resource_manager.get_pipeline(draw_call.pipeline_type)
            # vkCmdBindPipeline(cmd_buf, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline)

            # TODO: [ui][P3] Bind descriptor sets (textures, uniforms)
            # vkCmdBindDescriptorSets(cmd_buf, ...)

            # TODO: [ui][P3] Push constants (transforms, colors)
            # vkCmdPushConstants(cmd_buf, pipeline_layout, ...)

            # TODO: [ui][P3] Bind vertex/index buffers
            # vkCmdBindVertexBuffers(cmd_buf, 0, 1, &vertex_buffer, &offset)
            # vkCmdBindIndexBuffer(cmd_buf, index_buffer, 0, VK_INDEX_TYPE_UINT32)

            # TODO: [ui][P3] Set scissor if specified
            # if val Some(scissor) = draw_call.scissor:
            #     vkCmdSetScissor(cmd_buf, 0, 1, &scissor)

            # TODO: [ui][P3] Draw
            # vkCmdDrawIndexed(cmd_buf, draw_call.index_count, 1,
            #                  draw_call.index_offset, draw_call.vertex_offset, 0)

        # TODO: [ui][P3] End render pass
        # vkCmdEndRenderPass(cmd_buf)

    # End frame and present
    fn end_frame(frame: Frame) -> Result<(), RenderError>:
        # TODO: [ui][P3] End command buffer recording
        # vkEndCommandBuffer(frame.command_buffer)

        # TODO: [ui][P3] Submit command buffer to queue
        # vkQueueSubmit(graphics_queue, &submit_info, frame_fence)

        # TODO: [ui][P3] Present swapchain image
        # vkQueuePresentKHR(present_queue, &present_info)

        # Advance frame index for triple buffering
        self.frame_index = (self.frame_index + 1) % 3

        return Ok(())

# =============================================================================
# Vulkan Device Management
# =============================================================================

struct VulkanDevice:
    instance: i64          # VkInstance
    physical_device: i64   # VkPhysicalDevice
    device: i64            # VkDevice
    graphics_queue: i64    # VkQueue
    present_queue: i64     # VkQueue
    command_pool: i64      # VkCommandPool
    allocator: i64         # VmaAllocator

impl VulkanDevice:
    fn new(window_handle: i64) -> Result<VulkanDevice, text>:
        # TODO: [ui][P3] Create Vulkan instance
        # - vkCreateInstance with validation layers (debug builds)
        # - vkCreateSurface for window

        # TODO: [ui][P3] Select physical device
        # - vkEnumeratePhysicalDevices
        # - Pick discrete GPU if available, otherwise integrated

        # TODO: [ui][P3] Find queue families
        # - Graphics queue family
        # - Present queue family (may be same as graphics)

        # TODO: [ui][P3] Create logical device
        # - vkCreateDevice with required extensions (VK_KHR_swapchain)

        # TODO: [ui][P3] Get queues
        # - vkGetDeviceQueue for graphics and present

        # TODO: [ui][P3] Create command pool
        # - vkCreateCommandPool with VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT

        # TODO: [ui][P3] Create VMA allocator
        # - vmaCreateAllocator for efficient memory management

        return Ok(VulkanDevice {
            instance: 0,          # TODO: [ui][P3] Set from vkCreateInstance
            physical_device: 0,   # TODO: [ui][P3] Set from physical device selection
            device: 0,            # TODO: [ui][P3] Set from vkCreateDevice
            graphics_queue: 0,    # TODO: [ui][P3] Set from vkGetDeviceQueue
            present_queue: 0,     # TODO: [ui][P3] Set from vkGetDeviceQueue
            command_pool: 0,      # TODO: [ui][P3] Set from vkCreateCommandPool
            allocator: 0          # TODO: [ui][P3] Set from vmaCreateAllocator
        })

    fn create_buffer(size: u64, usage: u32, memory_usage: u32) -> Result<Buffer, text>:
        # Create buffer using VMA (Vulkan Memory Allocator)
        val buffer_info = VkBufferCreateInfo {
            size: size,
            usage: usage,
            sharing_mode: VK_SHARING_MODE_EXCLUSIVE
        }

        val alloc_info = VmaAllocationCreateInfo {
            usage: memory_usage,
            flags: 0
        }

        val (buffer_handle, allocation_handle) = vma_create_buffer(
            self.allocator,
            &buffer_info,
            &alloc_info
        )?

        return Ok(Buffer {
            handle: buffer_handle,
            allocation: allocation_handle,
            size: size
        })

    fn create_image(width: u32, height: u32, format: u32, usage: u32) -> Result<Image, text>:
        # Create image using VMA (Vulkan Memory Allocator)
        val image_info = VkImageCreateInfo {
            image_type: VK_IMAGE_TYPE_2D,
            format: format,
            extent: VkExtent3D { width: width, height: height, depth: 1 },
            mip_levels: 1,
            array_layers: 1,
            samples: VK_SAMPLE_COUNT_1_BIT,
            tiling: VK_IMAGE_TILING_OPTIMAL,
            usage: usage,
            sharing_mode: VK_SHARING_MODE_EXCLUSIVE,
            initial_layout: VK_IMAGE_LAYOUT_UNDEFINED
        }

        val alloc_info = VmaAllocationCreateInfo {
            usage: VMA_MEMORY_USAGE_GPU_ONLY,
            flags: 0
        }

        val (image_handle, allocation_handle) = vma_create_image(
            self.allocator,
            &image_info,
            &alloc_info
        )?

        # Create image view for accessing the image in shaders
        val view_info = VkImageViewCreateInfo {
            image: image_handle,
            view_type: VK_IMAGE_VIEW_TYPE_2D,
            format: format,
            components: VkComponentMapping::identity(),
            subresource_range: VkImageSubresourceRange {
                aspect_mask: VK_IMAGE_ASPECT_COLOR_BIT,
                base_mip_level: 0,
                level_count: 1,
                base_array_layer: 0,
                layer_count: 1
            }
        }

        val image_view = vk_create_image_view(self.device, &view_info)?

        return Ok(Image {
            handle: image_handle,
            view: image_view,
            allocation: allocation_handle,
            width: width,
            height: height,
            format: format
        })

# =============================================================================
# Swapchain Management
# =============================================================================

struct Swapchain:
    swapchain: i64             # VkSwapchainKHR
    images: Array<Image>       # Swapchain images
    extent: (u32, u32)         # Width, height
    format: u32                # VkFormat

impl Swapchain:
    fn new(device: &VulkanDevice, width: u32, height: u32) -> Result<Swapchain, text>:
        # TODO: [ui][P3] Query surface capabilities
        # vkGetPhysicalDeviceSurfaceCapabilitiesKHR

        # TODO: [ui][P3] Query surface formats
        # vkGetPhysicalDeviceSurfaceFormatsKHR
        # Prefer VK_FORMAT_B8G8R8A8_SRGB

        # TODO: [ui][P3] Query present modes
        # vkGetPhysicalDeviceSurfacePresentModesKHR
        # Prefer VK_PRESENT_MODE_MAILBOX_KHR (triple buffering)

        # TODO: [ui][P3] Create swapchain
        # vkCreateSwapchainKHR

        # TODO: [ui][P3] Get swapchain images
        # vkGetSwapchainImagesKHR
        # Create image views for each image

        var images: Array<Image> = []
        # TODO: [ui][P3] Populate images array

        return Ok(Swapchain {
            swapchain: 0,      # TODO: [ui][P3] Set from vkCreateSwapchainKHR
            images: images,
            extent: (width, height),
            format: 0          # TODO: [ui][P3] Set from chosen surface format
        })

# =============================================================================
# Render Pass
# =============================================================================

struct RenderPass:
    render_pass: i64               # VkRenderPass
    framebuffers: Array<i64>       # VkFramebuffer for each swapchain image

impl RenderPass:
    fn new(device: &VulkanDevice, swapchain: &Swapchain) -> Result<RenderPass, text>:
        # TODO: [ui][P3] Create render pass
        # - Color attachment with swapchain format
        # - Load op: CLEAR, Store op: STORE
        # - Initial layout: UNDEFINED, Final layout: PRESENT_SRC_KHR
        # vkCreateRenderPass

        # TODO: [ui][P3] Create framebuffer for each swapchain image
        # vkCreateFramebuffer with swapchain image views

        var framebuffers: Array<i64> = []
        # TODO: [ui][P3] Populate framebuffers array

        return Ok(RenderPass {
            render_pass: 0,        # TODO: [ui][P3] Set from vkCreateRenderPass
            framebuffers: framebuffers
        })

# =============================================================================
# Layout Engine (CPU)
# =============================================================================

struct LayoutEngine:
    cache: LayoutCache

impl LayoutEngine:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_cache(self) -> bool:
        """Check if layout cache exists."""
        # Assuming LayoutCache has a method to check if it's non-empty
        true  # Cache always exists as it's a value type

    pub fn summary(self) -> text:
        """Get summary of layout engine state."""
        return "LayoutEngine: cache active"

    # =========================================================================
    # Constructor
    # =========================================================================

    static fn new() -> LayoutEngine:
        return LayoutEngine {
            cache: LayoutCache::new()
        }

    fn compute_layout(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Check cache first
        if val Some(cached) = self.cache.get(elem.id):
            if cached.constraints == constraints:
                return cached.result

        # Compute layout based on element type
        val result = match elem.kind:
            case ElementKind::Row | ElementKind::Column:
                self.layout_flexbox(elem, constraints)
            case ElementKind::Grid:
                self.layout_grid(elem, constraints)
            case _:
                self.layout_block(elem, constraints)

        # Cache result
        self.cache.set(elem.id, constraints, result)

        return result

    fn layout_flexbox(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Flexbox layout algorithm implementation
        val is_row = elem.kind == ElementKind::Row
        val main_axis = if is_row: Axis::Horizontal else: Axis::Vertical
        val cross_axis = if is_row: Axis::Vertical else: Axis::Horizontal

        val children = elem.children
        val child_count = children.len()
        if child_count == 0:
            return LayoutResult {
                size: Size { width: 0.0, height: 0.0 },
                children: []
            }

        # Phase 1: Calculate base sizes and flex factors
        var total_flex: f32 = 0.0
        var total_fixed_size: f32 = 0.0
        var child_infos: Array<FlexChildInfo> = []

        for child in children:
            val flex = child.style.flex_grow.unwrap_or(0.0)
            val base_size = self.measure_child_base_size(child, constraints, main_axis)
            total_flex += flex
            if flex == 0.0:
                total_fixed_size += base_size
            child_infos.push(FlexChildInfo { flex: flex, base_size: base_size })

        # Phase 2: Distribute remaining space
        val available_main = if is_row: constraints.max_width else: constraints.max_height
        val remaining_space = (available_main - total_fixed_size).max(0.0)
        val space_per_flex = if total_flex > 0.0: remaining_space / total_flex else: 0.0

        # Phase 3: Calculate final child sizes and positions
        var child_layouts: Array<ChildLayout> = []
        var main_offset: f32 = 0.0

        for (i, child) in children.iter().enumerate():
            val info = child_infos[i]
            val main_size = if info.flex > 0.0:
                info.base_size + (space_per_flex * info.flex)
            else:
                info.base_size

            val child_constraints = if is_row:
                BoxConstraints { min_width: main_size, max_width: main_size,
                                 min_height: 0.0, max_height: constraints.max_height }
            else:
                BoxConstraints { min_width: 0.0, max_width: constraints.max_width,
                                 min_height: main_size, max_height: main_size }

            val child_result = self.compute_layout(child, child_constraints)

            val position = if is_row:
                Point { x: main_offset, y: 0.0 }
            else:
                Point { x: 0.0, y: main_offset }

            child_layouts.push(ChildLayout {
                id: child.id,
                position: position,
                size: child_result.size
            })

            main_offset += main_size

        val final_size = if is_row:
            Size { width: main_offset, height: constraints.max_height }
        else:
            Size { width: constraints.max_width, height: main_offset }

        return LayoutResult { size: final_size, children: child_layouts }

    fn layout_grid(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # CSS Grid layout algorithm implementation
        val style = elem.style
        val columns = style.grid_template_columns.unwrap_or([TrackSize::Fr(1.0)])
        val rows = style.grid_template_rows.unwrap_or([TrackSize::Auto])
        val gap = style.gap.unwrap_or(0.0)

        val col_count = columns.len()
        val row_count = rows.len().max((elem.children.len() + col_count - 1) / col_count)

        # Calculate column widths
        val available_width = constraints.max_width - (gap * (col_count - 1) as f32)
        var total_fr: f32 = 0.0
        var fixed_width: f32 = 0.0
        for col in columns:
            match col:
                case TrackSize::Fr(fr): total_fr += fr
                case TrackSize::Px(px): fixed_width += px
                case TrackSize::Auto: pass  # Will be calculated later

        val fr_unit = if total_fr > 0.0: (available_width - fixed_width) / total_fr else: 0.0
        var col_widths: Array<f32> = []
        for col in columns:
            match col:
                case TrackSize::Fr(fr): col_widths.push(fr * fr_unit)
                case TrackSize::Px(px): col_widths.push(px)
                case TrackSize::Auto: col_widths.push(available_width / col_count as f32)

        # Calculate row heights (simplified: equal distribution)
        val available_height = constraints.max_height - (gap * (row_count - 1) as f32)
        val row_height = available_height / row_count as f32

        # Place children in grid cells
        var child_layouts: Array<ChildLayout> = []
        for (i, child) in elem.children.iter().enumerate():
            val col = i % col_count
            val row = i / col_count

            var x: f32 = 0.0
            for c in 0..col:
                x += col_widths[c] + gap

            val y = row as f32 * (row_height + gap)

            val child_constraints = BoxConstraints {
                min_width: col_widths[col], max_width: col_widths[col],
                min_height: row_height, max_height: row_height
            }
            val child_result = self.compute_layout(child, child_constraints)

            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: x, y: y },
                size: child_result.size
            })

        return LayoutResult {
            size: Size { width: constraints.max_width, height: row_count as f32 * (row_height + gap) - gap },
            children: child_layouts
        }

    fn layout_block(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Block layout: stack children vertically with full width
        var child_layouts: Array<ChildLayout> = []
        var y_offset: f32 = 0.0

        for child in elem.children:
            val child_constraints = BoxConstraints {
                min_width: constraints.min_width,
                max_width: constraints.max_width,
                min_height: 0.0,
                max_height: constraints.max_height - y_offset
            }

            val child_result = self.compute_layout(child, child_constraints)

            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: 0.0, y: y_offset },
                size: child_result.size
            })

            y_offset += child_result.size.height

        # Handle text elements specially
        if elem.kind == ElementKind::Text:
            val text_size = self.measure_text(elem, constraints)
            return LayoutResult {
                size: text_size,
                children: []
            }

        return LayoutResult {
            size: Size { width: constraints.max_width, height: y_offset },
            children: child_layouts
        }

    fn measure_child_base_size(child: &Element, constraints: BoxConstraints, axis: Axis) -> f32:
        # Measure the intrinsic size of a child along the given axis
        match axis:
            case Axis::Horizontal:
                return child.style.width.unwrap_or(constraints.max_width / 4.0)
            case Axis::Vertical:
                return child.style.height.unwrap_or(constraints.max_height / 4.0)

    fn measure_text(elem: &Element, constraints: BoxConstraints) -> Size:
        # Measure text dimensions using the text renderer
        if val Some(text) = elem.text:
            return self.text_renderer.measure(text, elem.style.font_size.unwrap_or(16.0), constraints.max_width)
        return Size { width: 0.0, height: 0.0 }

# Helper structs for layout
struct FlexChildInfo:
    flex: f32
    base_size: f32

enum Axis:
    Horizontal
    Vertical

enum TrackSize:
    Fr(f32)
    Px(f32)
    Auto

# =============================================================================
# Element Processor (CPU → GPU Data)
# =============================================================================

struct ElementProcessor:
    vertex_builder: VertexBuilder
    draw_list: DrawList

impl ElementProcessor:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_vertices(self) -> bool:
        """Check if any vertices have been generated."""
        self.draw_list.vertices.len() > 0

    pub fn has_indices(self) -> bool:
        """Check if any indices have been generated."""
        self.draw_list.indices.len() > 0

    pub fn vertex_count(self) -> usize:
        """Get number of vertices in draw list."""
        self.draw_list.vertices.len()

    pub fn index_count(self) -> usize:
        """Get number of indices in draw list."""
        self.draw_list.indices.len()

    pub fn triangle_count(self) -> usize:
        """Get number of triangles (indices / 3)."""
        self.draw_list.indices.len() / 3

    pub fn is_empty(self) -> bool:
        """Check if no geometry has been generated."""
        not self.has_vertices()

    pub fn summary(self) -> text:
        """Get summary of element processor state."""
        return "ElementProcessor: {self.vertex_count()} vertices, {self.triangle_count()} triangles"

    # =========================================================================
    # Constructor
    # =========================================================================

    static fn new() -> ElementProcessor:
        return ElementProcessor {
            vertex_builder: VertexBuilder::new(),
            draw_list: DrawList::new()
        }

    fn process_tree(tree: &ElementTree, layout: &LayoutResult) -> DrawList:
        # Clear previous frame's data
        self.draw_list.clear()
        self.vertex_builder.clear()

        # Traverse tree and generate geometry
        self.process_element(tree.root(), layout)

        # Finalize draw list
        self.draw_list.vertices = self.vertex_builder.vertices
        self.draw_list.indices = self.vertex_builder.indices

        return self.draw_list

    fn process_element(elem: &Element, layout: &LayoutResult):
        # Get layout for this element
        val bounds = layout.get_bounds(elem.id)

        # Generate geometry based on element type
        match elem.kind:
            case ElementKind::Box:
                self.emit_rounded_rect(bounds, 4.0, elem)
            case ElementKind::Button:
                self.emit_button(bounds, elem)
            case ElementKind::Text:
                self.emit_text(bounds, elem)
            case _:
                # Default: just background if specified
                if self.has_background(elem):
                    self.emit_rect(bounds, self.get_bg_color(elem))

        # Process children
        for child in &elem.children:
            self.process_element(child, layout)

    fn emit_rect(bounds: Rect, color: Color):
        # TODO: [ui][P3] Generate quad vertices (2 triangles)
        # - Add 4 vertices with positions and color
        # - Add 6 indices (0,1,2, 2,3,0)
        # - Add draw call with SolidColorPipeline
        pass

    fn emit_rounded_rect(bounds: Rect, radius: f32, elem: &Element):
        # TODO: [ui][P3] Generate quad with UVs for SDF shader
        # - Add vertices with UVs (0,0) to (1,1)
        # - Add draw call with RoundedRectPipeline
        # - Store radius in push constants
        pass

    fn emit_text(bounds: Rect, elem: &Element):
        # TODO: [ui][P3] Generate quads for each glyph
        # - Shape text using font metrics
        # - For each glyph:
        #   - Get glyph rect from font atlas
        #   - Generate quad with UVs pointing to atlas
        # - Add draw call with TextPipeline
        pass

    fn emit_button(bounds: Rect, elem: &Element):
        # Emit background
        self.emit_rounded_rect(bounds, 4.0, elem)

        # Emit label text if present
        if val Some(text) = &elem.text:
            # TODO: [ui][P3] Center text in button
            self.emit_text(bounds, elem)

# =============================================================================
# Supporting Types
# =============================================================================

struct Frame:
    image_index: u32           # Swapchain image index
    buffer_index: usize        # Frame buffer index (0-2)
    command_buffer: i64        # VkCommandBuffer

impl Frame:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_valid(self) -> bool:
        """Check if frame has valid command buffer."""
        self.command_buffer != 0

    pub fn is_first_buffer(self) -> bool:
        """Check if using first buffer (index 0)."""
        self.buffer_index == 0

    pub fn is_second_buffer(self) -> bool:
        """Check if using second buffer (index 1)."""
        self.buffer_index == 1

    pub fn is_third_buffer(self) -> bool:
        """Check if using third buffer (index 2)."""
        self.buffer_index == 2

    pub fn summary(self) -> text:
        """Get summary of frame state."""
        return "Frame: image={self.image_index}, buffer={self.buffer_index}"

struct FrameData:
    command_buffer: i64        # VkCommandBuffer
    fence: i64                 # VkFence
    image_available: i64       # VkSemaphore
    render_finished: i64       # VkSemaphore

impl FrameData:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_command_buffer(self) -> bool:
        """Check if command buffer is allocated."""
        self.command_buffer != 0

    pub fn has_fence(self) -> bool:
        """Check if fence is created."""
        self.fence != 0

    pub fn has_semaphores(self) -> bool:
        """Check if both semaphores are created."""
        self.image_available != 0 and self.render_finished != 0

    pub fn has_image_available_semaphore(self) -> bool:
        """Check if image available semaphore exists."""
        self.image_available != 0

    pub fn has_render_finished_semaphore(self) -> bool:
        """Check if render finished semaphore exists."""
        self.render_finished != 0

    pub fn is_fully_initialized(self) -> bool:
        """Check if all resources are initialized."""
        self.has_command_buffer() and self.has_fence() and self.has_semaphores()

    pub fn summary(self) -> text:
        """Get summary of frame data state."""
        val status = if self.is_fully_initialized(): "ready" else: "incomplete"
        return "FrameData: {status}"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> FrameData:
        # TODO: [ui][P3] Allocate command buffer
        # TODO: [ui][P3] Create fence (signaled initially)
        # TODO: [ui][P3] Create semaphores

        return FrameData {
            command_buffer: 0,
            fence: 0,
            image_available: 0,
            render_finished: 0
        }

# Types imported from ui.gui.vulkan.types.*

struct ResourceManager:
    textures: Dict<u64, Image>
    font_atlas: Option<Image>
    pipelines: Dict<u64, Pipeline>

impl ResourceManager:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_textures(self) -> bool:
        """Check if any textures are loaded."""
        self.textures.len() > 0

    pub fn has_font_atlas(self) -> bool:
        """Check if font atlas is loaded."""
        match self.font_atlas:
            case Some(_): true
            case None: false

    pub fn has_pipelines(self) -> bool:
        """Check if any pipelines are created."""
        self.pipelines.len() > 0

    pub fn texture_count(self) -> usize:
        """Get number of loaded textures."""
        self.textures.len()

    pub fn pipeline_count(self) -> usize:
        """Get number of created pipelines."""
        self.pipelines.len()

    pub fn is_empty(self) -> bool:
        """Check if no resources are loaded."""
        not self.has_textures() and not self.has_pipelines()

    pub fn summary(self) -> text:
        """Get summary of resource manager state."""
        val font = if self.has_font_atlas(): "yes" else: "no"
        return "ResourceManager: {self.texture_count()} textures, {self.pipeline_count()} pipelines, font atlas={font}"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> ResourceManager:
        return ResourceManager {
            textures: Dict::new(),
            font_atlas: None,
            pipelines: Dict::new()
        }

struct BufferManager:
    vertex_buffers: Array<Buffer>
    index_buffers: Array<Buffer>
    uniform_buffers: Array<Buffer>

impl BufferManager:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_vertex_buffers(self) -> bool:
        """Check if any vertex buffers exist."""
        self.vertex_buffers.len() > 0

    pub fn has_index_buffers(self) -> bool:
        """Check if any index buffers exist."""
        self.index_buffers.len() > 0

    pub fn has_uniform_buffers(self) -> bool:
        """Check if any uniform buffers exist."""
        self.uniform_buffers.len() > 0

    pub fn vertex_buffer_count(self) -> usize:
        """Get number of vertex buffers."""
        self.vertex_buffers.len()

    pub fn index_buffer_count(self) -> usize:
        """Get number of index buffers."""
        self.index_buffers.len()

    pub fn uniform_buffer_count(self) -> usize:
        """Get number of uniform buffers."""
        self.uniform_buffers.len()

    pub fn total_buffer_count(self) -> usize:
        """Get total number of all buffers."""
        self.vertex_buffer_count() + self.index_buffer_count() + self.uniform_buffer_count()

    pub fn is_empty(self) -> bool:
        """Check if no buffers exist."""
        self.total_buffer_count() == 0

    pub fn summary(self) -> text:
        """Get summary of buffer manager state."""
        return "BufferManager: {self.vertex_buffer_count()} vertex, {self.index_buffer_count()} index, {self.uniform_buffer_count()} uniform"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> BufferManager:
        return BufferManager {
            vertex_buffers: [],
            index_buffers: [],
            uniform_buffers: []
        }

    fn upload_draw_list(draw_list: &DrawList, frame_index: usize):
        # TODO: [ui][P3] Upload vertex data to GPU buffer
        # TODO: [ui][P3] Upload index data to GPU buffer
        # TODO: [ui][P3] Upload uniform data (projection matrix)
        pass

struct TextRenderer:
    font_atlas: Option<Image>
    glyph_cache: Dict<u64, Rect>

impl TextRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_font_atlas(self) -> bool:
        """Check if font atlas is loaded."""
        match self.font_atlas:
            case Some(_): true
            case None: false

    pub fn has_glyph_cache(self) -> bool:
        """Check if any glyphs are cached."""
        self.glyph_cache.len() > 0

    pub fn glyph_count(self) -> usize:
        """Get number of cached glyphs."""
        self.glyph_cache.len()

    pub fn is_ready(self) -> bool:
        """Check if text renderer is ready (has font atlas)."""
        self.has_font_atlas()

    pub fn summary(self) -> text:
        """Get summary of text renderer state."""
        val atlas = if self.has_font_atlas(): "loaded" else: "none"
        return "TextRenderer: font atlas={atlas}, {self.glyph_count()} glyphs cached"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> TextRenderer:
        return TextRenderer {
            font_atlas: None,
            glyph_cache: Dict::new()
        }

struct Pipeline:
    handle: i64                # VkPipeline
    layout: i64                # VkPipelineLayout
    type: PipelineType

impl Pipeline:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_valid(self) -> bool:
        """Check if pipeline has valid handles."""
        self.handle != 0 and self.layout != 0

    pub fn has_handle(self) -> bool:
        """Check if pipeline handle exists."""
        self.handle != 0

    pub fn has_layout(self) -> bool:
        """Check if pipeline layout exists."""
        self.layout != 0

    pub fn summary(self) -> text:
        """Get summary of pipeline state."""
        val status = if self.is_valid(): "valid" else: "invalid"
        return "Pipeline: type={self.type}, {status}"

# =============================================================================
# FFI Declarations (Platform-specific)
# =============================================================================

# Window management (platform-specific: Win32, X11, Wayland, etc.)
extern fn vulkan_create_window(title_ptr: *const u8, title_len: u64, width: u32, height: u32) -> i64

# These would be implemented in Rust/C using actual Vulkan API
# extern fn vk_create_instance(...) -> i64
# extern fn vk_create_device(...) -> i64
# extern fn vk_create_swapchain(...) -> i64
# extern fn vk_create_render_pass(...) -> i64
# extern fn vk_create_pipeline(...) -> i64
# extern fn vk_cmd_begin_render_pass(...) -> ()
# extern fn vk_cmd_draw_indexed(...) -> ()
# ... etc.
