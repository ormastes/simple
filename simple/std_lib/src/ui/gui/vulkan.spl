# Vulkan Renderer - GPU-Accelerated UI Backend
#
# High-performance UI rendering using Vulkan for GPU acceleration.
# Implements the RenderBackend trait with Vulkan-specific optimizations.
#
# Architecture:
#   CPU Layer: Layout, element processing, command recording
#   GPU Layer: Vertex shading, rasterization, fragment shading, composition
#
# Key Features:
#   - SDF (Signed Distance Field) text rendering
#   - Rounded corners and shadows via shaders
#   - Draw call batching and instancing
#   - Triple buffering for smooth rendering
#   - Dirty rectangle tracking for incremental updates

use core.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.vulkan.types.*
use ui.gui.vulkan_ffi.*

# =============================================================================
# Main Vulkan Renderer
# =============================================================================

pub struct VulkanRenderer:
    # Core Vulkan components
    window_handle: u64
    device: VulkanDevice
    swapchain: Swapchain
    render_pass: RenderPass

    # CPU-side processing
    layout_engine: LayoutEngine
    element_processor: ElementProcessor
    resource_manager: ResourceManager

    # GPU-side management
    buffer_manager: BufferManager
    text_renderer: TextRenderer

    # Frame management (triple buffering)
    frame_data: Array<FrameData>  # Size 3
    frame_index: usize

    # State
    initialized: bool
    window_width: u32
    window_height: u32

impl VulkanRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized."""
        self.initialized

    pub fn is_triple_buffered(self) -> bool:
        """Check if using triple buffering (3 frame buffers)."""
        self.frame_data.len() == 3

    pub fn current_frame_index(self) -> usize:
        """Get current frame index."""
        self.frame_index

    pub fn width(self) -> u32:
        """Get window width."""
        self.window_width

    pub fn height(self) -> u32:
        """Get window height."""
        self.window_height

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio."""
        (self.window_width as f64) / (self.window_height as f64)

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation."""
        self.window_width > self.window_height

    pub fn is_portrait(self) -> bool:
        """Check if window is portrait orientation."""
        self.window_height > self.window_width

    pub fn is_square(self) -> bool:
        """Check if window is square."""
        self.window_width == self.window_height

    pub fn summary(self) -> text:
        val status = if self.initialized: "initialized" else: "uninitialized"
        val buffering = if self.is_triple_buffered(): "triple" else: "unknown"
        return "VulkanRenderer: {self.window_width}x{self.window_height} ({status}, {buffering} buffering, frame {self.frame_index})"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new Vulkan renderer
    pub fn new(window_title: &str, width: u32, height: u32) -> Result<VulkanRenderer, RenderError>:
        # Create window using FFI
        val window_handle = rt_vk_window_create(
            window_title.as_ptr(),
            window_title.len() as u64,
            width,
            height
        )
        if window_handle == 0:
            return Err(RenderError::IoError("Failed to create window".to_string()))

        # Initialize Vulkan device
        val device = match VulkanDevice::new(window_handle):
            case Ok(dev): dev
            case Err(e):
                rt_vk_window_destroy(window_handle)
                return Err(RenderError::IoError(e))

        # Create swapchain
        val swapchain = match Swapchain::new(&device, window_handle, width, height):
            case Ok(sc): sc
            case Err(e):
                device.free()
                rt_vk_window_destroy(window_handle)
                return Err(RenderError::IoError(e))

        # Create render pass
        val render_pass = match RenderPass::new(&device, &swapchain):
            case Ok(rp): rp
            case Err(e):
                swapchain.free()
                device.free()
                rt_vk_window_destroy(window_handle)
                return Err(RenderError::IoError(e))

        # Initialize CPU-side components
        val layout_engine = LayoutEngine::new()
        val element_processor = ElementProcessor::new()
        val resource_manager = ResourceManager::new(&device)

        # Initialize GPU-side components
        val buffer_manager = BufferManager::new(&device)
        val text_renderer = TextRenderer::new(&device)

        # Create frame data for triple buffering
        var frame_data: Array<FrameData> = []
        for _ in 0..3:
            frame_data.push(FrameData::new(&device))

        return Ok(VulkanRenderer {
            window_handle: window_handle,
            device: device,
            swapchain: swapchain,
            render_pass: render_pass,
            layout_engine: layout_engine,
            element_processor: element_processor,
            resource_manager: resource_manager,
            buffer_manager: buffer_manager,
            text_renderer: text_renderer,
            frame_data: frame_data,
            frame_index: 0,
            initialized: false,
            window_width: width,
            window_height: height
        })

impl RenderBackend for VulkanRenderer:
    fn init() -> Result<(), RenderError>:
        if self.initialized:
            return Err(RenderError::AlreadyInitialized)

        # Initialize frame data (command buffers are created on-demand)
        # Resources like descriptor pools and pipelines will be created
        # when needed for actual rendering

        self.initialized = true
        return Ok(())

    fn shutdown() -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Wait for device to be idle before cleanup
        match self.device.sync():
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        # Free frame data (command buffers)
        for frame in self.frame_data:
            frame.free()

        # Free render pass and framebuffers
        match self.render_pass.free():
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        # Free swapchain
        match self.swapchain.free():
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        # Free device
        match self.device.free():
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        # Destroy window
        rt_vk_window_destroy(self.window_handle)

        self.initialized = false
        return Ok(())

    fn dimensions() -> (u16, u16):
        return (self.window_width as u16, self.window_height as u16)

    fn render(tree: &ElementTree) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # 1. Begin frame
        val frame = match self.begin_frame():
            case Ok(f): f
            case Err(e): return Err(e)

        # 2. Compute layout (CPU)
        val constraints = BoxConstraints::new(
            0, 0,
            self.window_width, self.window_height
        )
        val layout_result = self.layout_engine.compute_layout(
            tree.root(),
            constraints
        )

        # 3. Process elements into draw list (CPU)
        val draw_list = self.element_processor.process_tree(
            tree,
            &layout_result
        )

        # 4. Upload geometry to GPU
        self.buffer_manager.upload_draw_list(&draw_list, frame.buffer_index)

        # 5. Record rendering commands (CPU → GPU)
        self.record_commands(&frame, &draw_list)

        # 6. End frame and present
        return self.end_frame(frame)

    fn apply_patches(patches: &PatchSet) -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Incremental update implementation:
        # 1. Identify affected elements from patches
        var dirty_nodes: Set<NodeId> = Set::new()
        for patch in patches.iter():
            dirty_nodes.insert(patch.target_node())

        # 2. Mark dirty regions in the layout cache
        for node_id in dirty_nodes:
            self.layout_engine.invalidate(node_id)

        # 3. Recompute layout only for affected subtrees
        for node_id in dirty_nodes:
            if val Some(elem) = self.element_map.get(&node_id):
                val constraints = self.get_constraints_for(elem)
                self.layout_engine.compute(elem, constraints)

        # 4. Regenerate draw list only for dirty regions
        var dirty_draw_commands: Array<DrawCommand> = []
        for node_id in dirty_nodes:
            if val Some(layout) = self.layout_engine.get_cached(node_id):
                if val Some(elem) = self.element_map.get(&node_id):
                    val commands = self.element_processor.process(elem, layout)
                    dirty_draw_commands.extend(commands)

        # 5. Update GPU buffers with new draw commands
        self.buffer_manager.update_draw_commands(&dirty_draw_commands)

        return Ok(())

    fn clear() -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Begin frame and clear to background color
        val frame = match self.begin_frame():
            case Ok(f): f
            case Err(e): return Err(e)

        val cmd_handle = frame.command_buffer as u64
        val fb_handle = self.render_pass.get_framebuffer(frame.image_index as usize)

        # Begin render pass with clear color (clears the framebuffer)
        rt_vk_cmd_begin_render_pass(
            cmd_handle,
            self.render_pass.handle,
            fb_handle,
            0.0, 0.0, 0.0, 1.0  # Black clear color
        )

        # End render pass immediately (just clear, no drawing)
        rt_vk_cmd_end_render_pass(cmd_handle)

        return self.end_frame(frame)

    fn flush() -> Result<(), RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Wait for GPU to finish pending work
        match self.device.sync():
            case Ok(_): return Ok(())
            case Err(e): return Err(RenderError::IoError(e))

    fn poll_event(timeout_ms: u64) -> Result<Option<Event>, RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Poll window events using FFI
        var event_type: i32 = 0
        var event_data: Array<u8> = Array::with_capacity(64)
        event_data.resize(64, 0)

        val result = rt_vk_window_poll_event(
            self.window_handle,
            &mut event_type,
            event_data.as_mut_ptr(),
            64
        )

        if result != VK_SUCCESS:
            return Err(RenderError::IoError("Failed to poll events: error {result}"))

        if event_type == 0:
            return Ok(None)

        # Convert raw event to Event type
        val window_event = WindowEvent::from_raw(event_type, &event_data)
        return Ok(Some(self.convert_window_event(window_event)))

    fn read_event() -> Result<Event, RenderError>:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Block until next event arrives using FFI wait
        var event_type: i32 = 0
        var event_data: Array<u8> = Array::with_capacity(64)
        event_data.resize(64, 0)

        # Wait with 1 second timeout, loop until we get an event
        loop:
            val result = rt_vk_window_wait_event(
                self.window_handle,
                1000,  # 1 second timeout
                &mut event_type,
                event_data.as_mut_ptr(),
                64
            )

            if result != VK_SUCCESS:
                return Err(RenderError::IoError("Failed to wait for events: error {result}"))

            if event_type != 0:
                val window_event = WindowEvent::from_raw(event_type, &event_data)
                return Ok(self.convert_window_event(window_event))
            # event_type == 0 means timeout, continue waiting

    # Helper to convert WindowEvent to ui.renderer.Event
    fn convert_window_event(window_event: WindowEvent) -> Event:
        match window_event:
            case WindowEvent::Resize(w, h):
                # Update renderer dimensions
                self.window_width = w
                self.window_height = h
                # Recreate swapchain for new size
                self.swapchain.recreate(w, h)
                return Event::Resize(w as u16, h as u16)
            case WindowEvent::Close:
                return Event::Quit
            case WindowEvent::KeyPress(key, mods):
                return Event::KeyDown(key, mods)
            case WindowEvent::KeyRelease(key, mods):
                return Event::KeyUp(key, mods)
            case WindowEvent::MouseMove(x, y):
                return Event::MouseMove(x as u16, y as u16)
            case WindowEvent::MouseButton(button, pressed, x, y):
                if pressed:
                    return Event::MouseDown(button, x as u16, y as u16)
                else:
                    return Event::MouseUp(button, x as u16, y as u16)
            case _:
                return Event::None

impl VulkanRenderer:
    # Begin a new frame
    fn begin_frame() -> Result<Frame, RenderError>:
        # Acquire next swapchain image (1 second timeout)
        val image_index = match self.swapchain.acquire_next_image(1_000_000_000):
            case Ok(idx): idx
            case Err(e): return Err(RenderError::IoError(e))

        # Get frame data for current frame index
        val frame_data = self.frame_data[self.frame_index]

        # Begin command buffer recording
        match frame_data.begin():
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        return Ok(Frame {
            image_index: image_index,
            buffer_index: self.frame_index,
            command_buffer: frame_data.command_buffer_handle as i64
        })

    # Record rendering commands
    fn record_commands(frame: &Frame, draw_list: &DrawList):
        val cmd_handle = frame.command_buffer as u64
        val fb_handle = self.render_pass.get_framebuffer(frame.image_index as usize)

        # Begin render pass with clear color (dark gray background)
        rt_vk_cmd_begin_render_pass(
            cmd_handle,
            self.render_pass.handle,
            fb_handle,
            0.1, 0.1, 0.1, 1.0  # RGBA clear color
        )

        # Set viewport
        rt_vk_cmd_set_viewport(
            cmd_handle,
            0.0, 0.0,
            self.window_width as f32,
            self.window_height as f32
        )

        # Set scissor to full window
        rt_vk_cmd_set_scissor(
            cmd_handle,
            0, 0,
            self.window_width,
            self.window_height
        )

        # Process each draw call
        for draw_call in draw_list.draw_calls:
            # Bind pipeline for this draw call type
            if draw_call.pipeline_handle != 0:
                rt_vk_cmd_bind_pipeline(cmd_handle, draw_call.pipeline_handle as u64)

            # Bind vertex buffer if present
            if draw_call.vertex_buffer_handle != 0:
                rt_vk_cmd_bind_vertex_buffer(cmd_handle, draw_call.vertex_buffer_handle as u64, 0)

            # Bind index buffer if present
            if draw_call.index_buffer_handle != 0:
                rt_vk_cmd_bind_index_buffer(cmd_handle, draw_call.index_buffer_handle as u64, 0)

            # Draw indexed geometry
            if draw_call.index_count > 0:
                rt_vk_cmd_draw_indexed(
                    cmd_handle,
                    draw_call.index_count,
                    1,  # instance count
                    draw_call.index_offset,
                    draw_call.vertex_offset as i32,
                    0   # first instance
                )
            else if draw_call.vertex_count > 0:
                rt_vk_cmd_draw(
                    cmd_handle,
                    draw_call.vertex_count,
                    1,  # instance count
                    draw_call.first_vertex,
                    0   # first instance
                )

        # End render pass
        rt_vk_cmd_end_render_pass(cmd_handle)

    # End frame and present
    fn end_frame(frame: Frame) -> Result<(), RenderError>:
        # Get frame data for current frame
        val frame_data = self.frame_data[frame.buffer_index]

        # End command buffer recording
        match frame_data.end():
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        # Submit command buffer for execution
        match frame_data.submit():
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        # Present swapchain image
        match self.swapchain.present(frame.image_index):
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e))

        # Advance frame index for triple buffering
        self.frame_index = (self.frame_index + 1) % 3

        return Ok(())

# =============================================================================
# Vulkan Device Management
# =============================================================================

struct VulkanDevice:
    handle: u64            # rt_vk device handle
    window_handle: u64     # rt_vk window handle

impl VulkanDevice:
    fn new(window_handle: u64) -> Result<VulkanDevice, text>:
        # Create Vulkan device using FFI
        val device_handle = rt_vk_device_create()
        if device_handle == 0:
            return Err("Failed to create Vulkan device")

        return Ok(VulkanDevice {
            handle: device_handle,
            window_handle: window_handle
        })

    fn free(self) -> Result<(), text>:
        val result = rt_vk_device_free(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to free Vulkan device: error {result}")
        return Ok(())

    fn sync(self) -> Result<(), text>:
        val result = rt_vk_device_sync(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to sync device: error {result}")
        return Ok(())

    fn get_handle(self) -> u64:
        self.handle

    fn is_valid(self) -> bool:
        self.handle != 0

    fn create_buffer(size: u64, usage: u32, memory_usage: u32) -> Result<Buffer, text>:
        # Create buffer using VMA (Vulkan Memory Allocator)
        val buffer_info = VkBufferCreateInfo {
            size: size,
            usage: usage,
            sharing_mode: VK_SHARING_MODE_EXCLUSIVE
        }

        val alloc_info = VmaAllocationCreateInfo {
            usage: memory_usage,
            flags: 0
        }

        val (buffer_handle, allocation_handle) = vma_create_buffer(
            self.allocator,
            &buffer_info,
            &alloc_info
        )?

        return Ok(Buffer {
            handle: buffer_handle,
            allocation: allocation_handle,
            size: size
        })

    fn create_image(width: u32, height: u32, format: u32, usage: u32) -> Result<Image, text>:
        # Create image using VMA (Vulkan Memory Allocator)
        val image_info = VkImageCreateInfo {
            image_type: VK_IMAGE_TYPE_2D,
            format: format,
            extent: VkExtent3D { width: width, height: height, depth: 1 },
            mip_levels: 1,
            array_layers: 1,
            samples: VK_SAMPLE_COUNT_1_BIT,
            tiling: VK_IMAGE_TILING_OPTIMAL,
            usage: usage,
            sharing_mode: VK_SHARING_MODE_EXCLUSIVE,
            initial_layout: VK_IMAGE_LAYOUT_UNDEFINED
        }

        val alloc_info = VmaAllocationCreateInfo {
            usage: VMA_MEMORY_USAGE_GPU_ONLY,
            flags: 0
        }

        val (image_handle, allocation_handle) = vma_create_image(
            self.allocator,
            &image_info,
            &alloc_info
        )?

        # Create image view for accessing the image in shaders
        val view_info = VkImageViewCreateInfo {
            image: image_handle,
            view_type: VK_IMAGE_VIEW_TYPE_2D,
            format: format,
            components: VkComponentMapping::identity(),
            subresource_range: VkImageSubresourceRange {
                aspect_mask: VK_IMAGE_ASPECT_COLOR_BIT,
                base_mip_level: 0,
                level_count: 1,
                base_array_layer: 0,
                layer_count: 1
            }
        }

        val image_view = vk_create_image_view(self.device, &view_info)?

        return Ok(Image {
            handle: image_handle,
            view: image_view,
            allocation: allocation_handle,
            width: width,
            height: height,
            format: format
        })

# =============================================================================
# Swapchain Management
# =============================================================================

struct Swapchain:
    handle: u64                # rt_vk swapchain handle
    device_handle: u64         # Parent device handle
    width: u32
    height: u32
    image_count: u32

impl Swapchain:
    fn new(device: &VulkanDevice, window_handle: u64, width: u32, height: u32) -> Result<Swapchain, text>:
        # Create swapchain using FFI
        val swapchain_handle = rt_vk_swapchain_create(device.handle, window_handle, width, height)
        if swapchain_handle == 0:
            return Err("Failed to create swapchain")

        val image_count = rt_vk_swapchain_get_image_count(swapchain_handle)

        return Ok(Swapchain {
            handle: swapchain_handle,
            device_handle: device.handle,
            width: width,
            height: height,
            image_count: image_count
        })

    fn recreate(self, width: u32, height: u32) -> Result<(), text>:
        val result = rt_vk_swapchain_recreate(self.handle, width, height)
        if result != VK_SUCCESS:
            return Err("Failed to recreate swapchain: error {result}")
        self.width = width
        self.height = height
        return Ok(())

    fn acquire_next_image(self, timeout_ns: u64) -> Result<u32, text>:
        var image_index: u32 = 0
        val result = rt_vk_swapchain_acquire_next_image(self.handle, timeout_ns, &mut image_index)
        if result == VK_ERROR_SWAPCHAIN_OUT_OF_DATE:
            return Err("Swapchain out of date")
        if result != VK_SUCCESS:
            return Err("Failed to acquire image: error {result}")
        return Ok(image_index)

    fn present(self, image_index: u32) -> Result<(), text>:
        val result = rt_vk_swapchain_present(self.handle, image_index)
        if result == VK_ERROR_SWAPCHAIN_OUT_OF_DATE:
            return Err("Swapchain out of date")
        if result != VK_SUCCESS:
            return Err("Failed to present: error {result}")
        return Ok(())

    fn free(self) -> Result<(), text>:
        val result = rt_vk_swapchain_destroy(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to destroy swapchain: error {result}")
        return Ok(())

    fn get_handle(self) -> u64:
        self.handle

    fn get_extent(self) -> (u32, u32):
        (self.width, self.height)

    fn is_valid(self) -> bool:
        self.handle != 0

# =============================================================================
# Render Pass
# =============================================================================

# Standard BGRA8 SRGB format constant (VK_FORMAT_B8G8R8A8_SRGB = 50)
val VK_FORMAT_B8G8R8A8_SRGB: u32 = 50

struct RenderPass:
    handle: u64                    # rt_vk render pass handle
    framebuffer_handles: Array<u64>  # Framebuffer handles for each swapchain image
    device_handle: u64

impl RenderPass:
    fn new(device: &VulkanDevice, swapchain: &Swapchain) -> Result<RenderPass, text>:
        # Create simple render pass with standard color format
        val render_pass_handle = rt_vk_render_pass_create_simple(device.handle, VK_FORMAT_B8G8R8A8_SRGB)
        if render_pass_handle == 0:
            return Err("Failed to create render pass")

        # Create framebuffers for each swapchain image
        var framebuffer_handles: Array<u64> = []
        var temp_handles: Array<u64> = Array::with_capacity(swapchain.image_count as usize)
        temp_handles.resize(swapchain.image_count as usize, 0)

        val fb_count = rt_vk_framebuffer_create_for_swapchain(
            device.handle,
            render_pass_handle,
            swapchain.handle,
            temp_handles.as_mut_ptr(),
            swapchain.image_count
        )

        if fb_count < 0:
            rt_vk_render_pass_free(render_pass_handle)
            return Err("Failed to create framebuffers: error {fb_count}")

        # Copy valid handles
        for i in 0..(fb_count as usize):
            framebuffer_handles.push(temp_handles[i])

        return Ok(RenderPass {
            handle: render_pass_handle,
            framebuffer_handles: framebuffer_handles,
            device_handle: device.handle
        })

    fn free(self) -> Result<(), text>:
        # Free all framebuffers
        for fb_handle in self.framebuffer_handles:
            rt_vk_framebuffer_free(fb_handle)

        # Free render pass
        val result = rt_vk_render_pass_free(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to free render pass: error {result}")
        return Ok(())

    fn get_handle(self) -> u64:
        self.handle

    fn get_framebuffer(self, index: usize) -> u64:
        if index < self.framebuffer_handles.len():
            return self.framebuffer_handles[index]
        return 0

    fn is_valid(self) -> bool:
        self.handle != 0

# =============================================================================
# Layout Engine (CPU)
# =============================================================================

struct LayoutEngine:
    cache: LayoutCache

impl LayoutEngine:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_cache(self) -> bool:
        """Check if layout cache exists."""
        # Assuming LayoutCache has a method to check if it's non-empty
        true  # Cache always exists as it's a value type

    pub fn summary(self) -> text:
        """Get summary of layout engine state."""
        return "LayoutEngine: cache active"

    # =========================================================================
    # Constructor
    # =========================================================================

    static fn new() -> LayoutEngine:
        return LayoutEngine {
            cache: LayoutCache::new()
        }

    fn compute_layout(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Check cache first
        if val Some(cached) = self.cache.get(elem.id):
            if cached.constraints == constraints:
                return cached.result

        # Compute layout based on element type
        val result = match elem.kind:
            case ElementKind::Row | ElementKind::Column:
                self.layout_flexbox(elem, constraints)
            case ElementKind::Grid:
                self.layout_grid(elem, constraints)
            case _:
                self.layout_block(elem, constraints)

        # Cache result
        self.cache.set(elem.id, constraints, result)

        return result

    fn layout_flexbox(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Flexbox layout algorithm implementation
        val is_row = elem.kind == ElementKind::Row
        val main_axis = if is_row: Axis::Horizontal else: Axis::Vertical
        val cross_axis = if is_row: Axis::Vertical else: Axis::Horizontal

        val children = elem.children
        val child_count = children.len()
        if child_count == 0:
            return LayoutResult {
                size: Size { width: 0.0, height: 0.0 },
                children: []
            }

        # Phase 1: Calculate base sizes and flex factors
        var total_flex: f32 = 0.0
        var total_fixed_size: f32 = 0.0
        var child_infos: Array<FlexChildInfo> = []

        for child in children:
            val flex = child.style.flex_grow.unwrap_or(0.0)
            val base_size = self.measure_child_base_size(child, constraints, main_axis)
            total_flex += flex
            if flex == 0.0:
                total_fixed_size += base_size
            child_infos.push(FlexChildInfo { flex: flex, base_size: base_size })

        # Phase 2: Distribute remaining space
        val available_main = if is_row: constraints.max_width else: constraints.max_height
        val remaining_space = (available_main - total_fixed_size).max(0.0)
        val space_per_flex = if total_flex > 0.0: remaining_space / total_flex else: 0.0

        # Phase 3: Calculate final child sizes and positions
        var child_layouts: Array<ChildLayout> = []
        var main_offset: f32 = 0.0

        for (i, child) in children.iter().enumerate():
            val info = child_infos[i]
            val main_size = if info.flex > 0.0:
                info.base_size + (space_per_flex * info.flex)
            else:
                info.base_size

            val child_constraints = if is_row:
                BoxConstraints { min_width: main_size, max_width: main_size,
                                 min_height: 0.0, max_height: constraints.max_height }
            else:
                BoxConstraints { min_width: 0.0, max_width: constraints.max_width,
                                 min_height: main_size, max_height: main_size }

            val child_result = self.compute_layout(child, child_constraints)

            val position = if is_row:
                Point { x: main_offset, y: 0.0 }
            else:
                Point { x: 0.0, y: main_offset }

            child_layouts.push(ChildLayout {
                id: child.id,
                position: position,
                size: child_result.size
            })

            main_offset += main_size

        val final_size = if is_row:
            Size { width: main_offset, height: constraints.max_height }
        else:
            Size { width: constraints.max_width, height: main_offset }

        return LayoutResult { size: final_size, children: child_layouts }

    fn layout_grid(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # CSS Grid layout algorithm implementation
        val style = elem.style
        val columns = style.grid_template_columns.unwrap_or([TrackSize::Fr(1.0)])
        val rows = style.grid_template_rows.unwrap_or([TrackSize::Auto])
        val gap = style.gap.unwrap_or(0.0)

        val col_count = columns.len()
        val row_count = rows.len().max((elem.children.len() + col_count - 1) / col_count)

        # Calculate column widths
        val available_width = constraints.max_width - (gap * (col_count - 1) as f32)
        var total_fr: f32 = 0.0
        var fixed_width: f32 = 0.0
        for col in columns:
            match col:
                case TrackSize::Fr(fr): total_fr += fr
                case TrackSize::Px(px): fixed_width += px
                case TrackSize::Auto: pass  # Will be calculated later

        val fr_unit = if total_fr > 0.0: (available_width - fixed_width) / total_fr else: 0.0
        var col_widths: Array<f32> = []
        for col in columns:
            match col:
                case TrackSize::Fr(fr): col_widths.push(fr * fr_unit)
                case TrackSize::Px(px): col_widths.push(px)
                case TrackSize::Auto: col_widths.push(available_width / col_count as f32)

        # Calculate row heights (simplified: equal distribution)
        val available_height = constraints.max_height - (gap * (row_count - 1) as f32)
        val row_height = available_height / row_count as f32

        # Place children in grid cells
        var child_layouts: Array<ChildLayout> = []
        for (i, child) in elem.children.iter().enumerate():
            val col = i % col_count
            val row = i / col_count

            var x: f32 = 0.0
            for c in 0..col:
                x += col_widths[c] + gap

            val y = row as f32 * (row_height + gap)

            val child_constraints = BoxConstraints {
                min_width: col_widths[col], max_width: col_widths[col],
                min_height: row_height, max_height: row_height
            }
            val child_result = self.compute_layout(child, child_constraints)

            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: x, y: y },
                size: child_result.size
            })

        return LayoutResult {
            size: Size { width: constraints.max_width, height: row_count as f32 * (row_height + gap) - gap },
            children: child_layouts
        }

    fn layout_block(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Block layout: stack children vertically with full width
        var child_layouts: Array<ChildLayout> = []
        var y_offset: f32 = 0.0

        for child in elem.children:
            val child_constraints = BoxConstraints {
                min_width: constraints.min_width,
                max_width: constraints.max_width,
                min_height: 0.0,
                max_height: constraints.max_height - y_offset
            }

            val child_result = self.compute_layout(child, child_constraints)

            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: 0.0, y: y_offset },
                size: child_result.size
            })

            y_offset += child_result.size.height

        # Handle text elements specially
        if elem.kind == ElementKind::Text:
            val text_size = self.measure_text(elem, constraints)
            return LayoutResult {
                size: text_size,
                children: []
            }

        return LayoutResult {
            size: Size { width: constraints.max_width, height: y_offset },
            children: child_layouts
        }

    fn measure_child_base_size(child: &Element, constraints: BoxConstraints, axis: Axis) -> f32:
        # Measure the intrinsic size of a child along the given axis
        match axis:
            case Axis::Horizontal:
                return child.style.width.unwrap_or(constraints.max_width / 4.0)
            case Axis::Vertical:
                return child.style.height.unwrap_or(constraints.max_height / 4.0)

    fn measure_text(elem: &Element, constraints: BoxConstraints) -> Size:
        # Measure text dimensions using the text renderer
        if val Some(text) = elem.text:
            return self.text_renderer.measure(text, elem.style.font_size.unwrap_or(16.0), constraints.max_width)
        return Size { width: 0.0, height: 0.0 }

# Helper structs for layout
struct FlexChildInfo:
    flex: f32
    base_size: f32

enum Axis:
    Horizontal
    Vertical

enum TrackSize:
    Fr(f32)
    Px(f32)
    Auto

# =============================================================================
# Element Processor (CPU → GPU Data)
# =============================================================================

struct ElementProcessor:
    vertex_builder: VertexBuilder
    draw_list: DrawList

impl ElementProcessor:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_vertices(self) -> bool:
        """Check if any vertices have been generated."""
        self.draw_list.vertices.len() > 0

    pub fn has_indices(self) -> bool:
        """Check if any indices have been generated."""
        self.draw_list.indices.len() > 0

    pub fn vertex_count(self) -> usize:
        """Get number of vertices in draw list."""
        self.draw_list.vertices.len()

    pub fn index_count(self) -> usize:
        """Get number of indices in draw list."""
        self.draw_list.indices.len()

    pub fn triangle_count(self) -> usize:
        """Get number of triangles (indices / 3)."""
        self.draw_list.indices.len() / 3

    pub fn is_empty(self) -> bool:
        """Check if no geometry has been generated."""
        not self.has_vertices()

    pub fn summary(self) -> text:
        """Get summary of element processor state."""
        return "ElementProcessor: {self.vertex_count()} vertices, {self.triangle_count()} triangles"

    # =========================================================================
    # Constructor
    # =========================================================================

    static fn new() -> ElementProcessor:
        return ElementProcessor {
            vertex_builder: VertexBuilder::new(),
            draw_list: DrawList::new()
        }

    fn process_tree(tree: &ElementTree, layout: &LayoutResult) -> DrawList:
        # Clear previous frame's data
        self.draw_list.clear()
        self.vertex_builder.clear()

        # Traverse tree and generate geometry
        self.process_element(tree.root(), layout)

        # Finalize draw list
        self.draw_list.vertices = self.vertex_builder.vertices
        self.draw_list.indices = self.vertex_builder.indices

        return self.draw_list

    fn process_element(elem: &Element, layout: &LayoutResult):
        # Get layout for this element
        val bounds = layout.get_bounds(elem.id)

        # Generate geometry based on element type
        match elem.kind:
            case ElementKind::Box:
                self.emit_rounded_rect(bounds, 4.0, elem)
            case ElementKind::Button:
                self.emit_button(bounds, elem)
            case ElementKind::Text:
                self.emit_text(bounds, elem)
            case _:
                # Default: just background if specified
                if self.has_background(elem):
                    self.emit_rect(bounds, self.get_bg_color(elem))

        # Process children
        for child in &elem.children:
            self.process_element(child, layout)

    fn emit_rect(bounds: Rect, color: Color):
        # TODO: [ui][P3] Generate quad vertices (2 triangles)
        # - Add 4 vertices with positions and color
        # - Add 6 indices (0,1,2, 2,3,0)
        # - Add draw call with SolidColorPipeline
        pass

    fn emit_rounded_rect(bounds: Rect, radius: f32, elem: &Element):
        # TODO: [ui][P3] Generate quad with UVs for SDF shader
        # - Add vertices with UVs (0,0) to (1,1)
        # - Add draw call with RoundedRectPipeline
        # - Store radius in push constants
        pass

    fn emit_text(bounds: Rect, elem: &Element):
        # TODO: [ui][P3] Generate quads for each glyph
        # - Shape text using font metrics
        # - For each glyph:
        #   - Get glyph rect from font atlas
        #   - Generate quad with UVs pointing to atlas
        # - Add draw call with TextPipeline
        pass

    fn emit_button(bounds: Rect, elem: &Element):
        # Emit background
        self.emit_rounded_rect(bounds, 4.0, elem)

        # Emit label text if present
        if val Some(text) = &elem.text:
            # TODO: [ui][P3] Center text in button
            self.emit_text(bounds, elem)

# =============================================================================
# Supporting Types
# =============================================================================

struct Frame:
    image_index: u32           # Swapchain image index
    buffer_index: usize        # Frame buffer index (0-2)
    command_buffer: i64        # VkCommandBuffer

impl Frame:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_valid(self) -> bool:
        """Check if frame has valid command buffer."""
        self.command_buffer != 0

    pub fn is_first_buffer(self) -> bool:
        """Check if using first buffer (index 0)."""
        self.buffer_index == 0

    pub fn is_second_buffer(self) -> bool:
        """Check if using second buffer (index 1)."""
        self.buffer_index == 1

    pub fn is_third_buffer(self) -> bool:
        """Check if using third buffer (index 2)."""
        self.buffer_index == 2

    pub fn summary(self) -> text:
        """Get summary of frame state."""
        return "Frame: image={self.image_index}, buffer={self.buffer_index}"

struct FrameData:
    command_buffer_handle: u64  # rt_vk command buffer handle
    device_handle: u64          # Parent device handle
    is_recording: bool          # Whether command buffer is recording

impl FrameData:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_command_buffer(self) -> bool:
        """Check if command buffer is allocated."""
        self.command_buffer_handle != 0

    pub fn is_fully_initialized(self) -> bool:
        """Check if all resources are initialized."""
        self.has_command_buffer()

    pub fn summary(self) -> text:
        """Get summary of frame data state."""
        val status = if self.is_fully_initialized(): "ready" else: "incomplete"
        val recording = if self.is_recording: " (recording)" else: ""
        return "FrameData: {status}{recording}"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> FrameData:
        # Command buffer is allocated on-demand when begin() is called
        return FrameData {
            command_buffer_handle: 0,
            device_handle: device.handle,
            is_recording: false
        }

    fn begin(self) -> Result<(), text>:
        """Begin command buffer recording."""
        if self.is_recording:
            return Err("Command buffer already recording")

        val handle = rt_vk_command_buffer_begin(self.device_handle)
        if handle == 0:
            return Err("Failed to begin command buffer")

        self.command_buffer_handle = handle
        self.is_recording = true
        return Ok(())

    fn end(self) -> Result<(), text>:
        """End command buffer recording."""
        if not self.is_recording:
            return Err("Command buffer not recording")

        val result = rt_vk_command_buffer_end(self.command_buffer_handle)
        if result != VK_SUCCESS:
            return Err("Failed to end command buffer: error {result}")

        self.is_recording = false
        return Ok(())

    fn submit(self) -> Result<(), text>:
        """Submit command buffer for execution."""
        if self.is_recording:
            return Err("Cannot submit while recording")

        val result = rt_vk_command_buffer_submit(self.command_buffer_handle)
        if result != VK_SUCCESS:
            return Err("Failed to submit command buffer: error {result}")
        return Ok(())

    fn free(self) -> Result<(), text>:
        """Free the command buffer."""
        if self.command_buffer_handle != 0:
            val result = rt_vk_command_buffer_free(self.command_buffer_handle)
            if result != VK_SUCCESS:
                return Err("Failed to free command buffer: error {result}")
            self.command_buffer_handle = 0
        return Ok(())

    fn get_handle(self) -> u64:
        self.command_buffer_handle

# Types imported from ui.gui.vulkan.types.*

struct ResourceManager:
    textures: Dict<u64, Image>
    font_atlas: Option<Image>
    pipelines: Dict<u64, Pipeline>

impl ResourceManager:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_textures(self) -> bool:
        """Check if any textures are loaded."""
        self.textures.len() > 0

    pub fn has_font_atlas(self) -> bool:
        """Check if font atlas is loaded."""
        match self.font_atlas:
            case Some(_): true
            case None: false

    pub fn has_pipelines(self) -> bool:
        """Check if any pipelines are created."""
        self.pipelines.len() > 0

    pub fn texture_count(self) -> usize:
        """Get number of loaded textures."""
        self.textures.len()

    pub fn pipeline_count(self) -> usize:
        """Get number of created pipelines."""
        self.pipelines.len()

    pub fn is_empty(self) -> bool:
        """Check if no resources are loaded."""
        not self.has_textures() and not self.has_pipelines()

    pub fn summary(self) -> text:
        """Get summary of resource manager state."""
        val font = if self.has_font_atlas(): "yes" else: "no"
        return "ResourceManager: {self.texture_count()} textures, {self.pipeline_count()} pipelines, font atlas={font}"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> ResourceManager:
        return ResourceManager {
            textures: Dict::new(),
            font_atlas: None,
            pipelines: Dict::new()
        }

struct BufferManager:
    vertex_buffers: Array<Buffer>
    index_buffers: Array<Buffer>
    uniform_buffers: Array<Buffer>

impl BufferManager:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_vertex_buffers(self) -> bool:
        """Check if any vertex buffers exist."""
        self.vertex_buffers.len() > 0

    pub fn has_index_buffers(self) -> bool:
        """Check if any index buffers exist."""
        self.index_buffers.len() > 0

    pub fn has_uniform_buffers(self) -> bool:
        """Check if any uniform buffers exist."""
        self.uniform_buffers.len() > 0

    pub fn vertex_buffer_count(self) -> usize:
        """Get number of vertex buffers."""
        self.vertex_buffers.len()

    pub fn index_buffer_count(self) -> usize:
        """Get number of index buffers."""
        self.index_buffers.len()

    pub fn uniform_buffer_count(self) -> usize:
        """Get number of uniform buffers."""
        self.uniform_buffers.len()

    pub fn total_buffer_count(self) -> usize:
        """Get total number of all buffers."""
        self.vertex_buffer_count() + self.index_buffer_count() + self.uniform_buffer_count()

    pub fn is_empty(self) -> bool:
        """Check if no buffers exist."""
        self.total_buffer_count() == 0

    pub fn summary(self) -> text:
        """Get summary of buffer manager state."""
        return "BufferManager: {self.vertex_buffer_count()} vertex, {self.index_buffer_count()} index, {self.uniform_buffer_count()} uniform"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> BufferManager:
        return BufferManager {
            vertex_buffers: [],
            index_buffers: [],
            uniform_buffers: []
        }

    fn upload_draw_list(draw_list: &DrawList, frame_index: usize):
        # TODO: [ui][P3] Upload vertex data to GPU buffer
        # TODO: [ui][P3] Upload index data to GPU buffer
        # TODO: [ui][P3] Upload uniform data (projection matrix)
        pass

struct TextRenderer:
    font_atlas: Option<Image>
    glyph_cache: Dict<u64, Rect>

impl TextRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_font_atlas(self) -> bool:
        """Check if font atlas is loaded."""
        match self.font_atlas:
            case Some(_): true
            case None: false

    pub fn has_glyph_cache(self) -> bool:
        """Check if any glyphs are cached."""
        self.glyph_cache.len() > 0

    pub fn glyph_count(self) -> usize:
        """Get number of cached glyphs."""
        self.glyph_cache.len()

    pub fn is_ready(self) -> bool:
        """Check if text renderer is ready (has font atlas)."""
        self.has_font_atlas()

    pub fn summary(self) -> text:
        """Get summary of text renderer state."""
        val atlas = if self.has_font_atlas(): "loaded" else: "none"
        return "TextRenderer: font atlas={atlas}, {self.glyph_count()} glyphs cached"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(device: &VulkanDevice) -> TextRenderer:
        return TextRenderer {
            font_atlas: None,
            glyph_cache: Dict::new()
        }

struct Pipeline:
    handle: i64                # VkPipeline
    layout: i64                # VkPipelineLayout
    type: PipelineType

impl Pipeline:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_valid(self) -> bool:
        """Check if pipeline has valid handles."""
        self.handle != 0 and self.layout != 0

    pub fn has_handle(self) -> bool:
        """Check if pipeline handle exists."""
        self.handle != 0

    pub fn has_layout(self) -> bool:
        """Check if pipeline layout exists."""
        self.layout != 0

    pub fn summary(self) -> text:
        """Get summary of pipeline state."""
        val status = if self.is_valid(): "valid" else: "invalid"
        return "Pipeline: type={self.type}, {status}"

# =============================================================================
# FFI Notes
# =============================================================================
# All Vulkan FFI functions are imported from ui.gui.vulkan_ffi module
# which provides bindings to the rt_vk_* functions in the runtime.
