# Vulkan Shader Compilation - Phase 1 Implementation
#
# Shader loading and compilation for Vulkan graphics pipeline.
# Supports SPIR-V bytecode loading and shader module creation.
#
# Implementation Status: Phase 1 - Task 4
# - ShaderModule: SPIR-V shader loading
# - Vertex/Fragment shader support
# - Smart defaults for graphics pipeline

use core.*
use ui.gui.vulkan_types.*

# =============================================================================
# Shader Stage Types
# =============================================================================

pub enum ShaderStage:
    Vertex
    Fragment
    Compute
    Geometry
    TessellationControl
    TessellationEvaluation

impl ShaderStage:
    pub fn to_string(self) -> String:
        """Convert shader stage to string.

        Returns:
            String representation

        Example:
            val stage = ShaderStage::Vertex
            assert(stage.to_string() == "vertex")
        """
        match self:
            case Vertex: return "vertex"
            case Fragment: return "fragment"
            case Compute: return "compute"
            case Geometry: return "geometry"
            case TessellationControl: return "tessellation_control"
            case TessellationEvaluation: return "tessellation_evaluation"

    pub fn description(self) -> String:
        """Get detailed description of shader stage.

        Returns:
            Human-readable description

        Example:
            val stage = ShaderStage::Vertex
            assert(stage.description().contains("Vertex"))
        """
        match self:
            case Vertex: return "Vertex shader - processes vertices"
            case Fragment: return "Fragment shader - processes pixels"
            case Compute: return "Compute shader - general GPU computation"
            case Geometry: return "Geometry shader - processes primitives"
            case TessellationControl: return "Tessellation control shader - controls subdivision"
            case TessellationEvaluation: return "Tessellation evaluation shader - generates vertices"

    pub fn is_graphics_stage(self) -> bool:
        """Check if this is a graphics pipeline stage.

        Returns:
            True if vertex, fragment, geometry, or tessellation

        Example:
            assert(ShaderStage::Vertex.is_graphics_stage())
            assert(not ShaderStage::Compute.is_graphics_stage())
        """
        match self:
            case Vertex: return true
            case Fragment: return true
            case Geometry: return true
            case TessellationControl: return true
            case TessellationEvaluation: return true
            case Compute: return false

    pub fn is_compute_stage(self) -> bool:
        """Check if this is a compute pipeline stage.

        Returns:
            True if compute

        Example:
            assert(ShaderStage::Compute.is_compute_stage())
            assert(not ShaderStage::Vertex.is_compute_stage())
        """
        match self:
            case Compute: return true
            case _: return false

    pub fn is_vertex_stage(self) -> bool:
        """Check if this is vertex stage.

        Returns:
            True if vertex

        Example:
            assert(ShaderStage::Vertex.is_vertex_stage())
        """
        match self:
            case Vertex: return true
            case _: return false

    pub fn is_fragment_stage(self) -> bool:
        """Check if this is fragment stage.

        Returns:
            True if fragment

        Example:
            assert(ShaderStage::Fragment.is_fragment_stage())
        """
        match self:
            case Fragment: return true
            case _: return false

    pub fn is_tessellation_stage(self) -> bool:
        """Check if this is a tessellation stage.

        Returns:
            True if tessellation control or evaluation

        Example:
            assert(ShaderStage::TessellationControl.is_tessellation_stage())
        """
        match self:
            case TessellationControl: return true
            case TessellationEvaluation: return true
            case _: return false

    pub fn to_vk_flag(self) -> u32:
        """Convert to Vulkan shader stage flag.

        Returns:
            Vulkan shader stage bit flag

        Example:
            assert(ShaderStage::Vertex.to_vk_flag() == VK_SHADER_STAGE_VERTEX_BIT)
        """
        match self:
            case Vertex: return VK_SHADER_STAGE_VERTEX_BIT
            case Fragment: return VK_SHADER_STAGE_FRAGMENT_BIT
            case Compute: return VK_SHADER_STAGE_COMPUTE_BIT
            case Geometry: return VK_SHADER_STAGE_GEOMETRY_BIT
            case TessellationControl: return VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT
            case TessellationEvaluation: return VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT

# =============================================================================
# Shader Module - SPIR-V Shader Compilation
# =============================================================================

pub struct ShaderModule:
    # Core handles
    device: VkDevice
    module: VkShaderModule
    stage: ShaderStage
    entry_point: String

impl ShaderModule:
    # Create shader module from SPIR-V bytecode
    pub fn from_spirv(device: &VulkanDevice, spirv_code: &Array[u8], stage: ShaderStage) -> Result[ShaderModule, String]:
        # Validate SPIR-V magic number (0x07230203)
        if spirv_code.len() < 4:
            return Err("SPIR-V code too small (less than 4 bytes)")

        val magic = (spirv_code[0] as u32) |
                   ((spirv_code[1] as u32) << 8) |
                   ((spirv_code[2] as u32) << 16) |
                   ((spirv_code[3] as u32) << 24)

        if magic != 0x07230203:
            return Err("Invalid SPIR-V magic number")

        # Create shader module via FFI
        val module = vulkan_create_shader_module(device.device, spirv_code)?

        Ok(ShaderModule {
            device: device.device,
            module: module,
            stage: stage,
            entry_point: "main".to_string(),
        })

    # Create shader module from SPIR-V file
    pub fn from_file(device: &VulkanDevice, path: &str, stage: ShaderStage) -> Result[ShaderModule, String]:
        # TODO: [ui][P3] Read file contents
        val spirv_code = vulkan_read_file(path)?
        Self::from_spirv(device, &spirv_code, stage)

    # Get pipeline shader stage info for pipeline creation
    pub fn get_stage_info(&self) -> VkPipelineShaderStageCreateInfo:
        VkPipelineShaderStageCreateInfo {
            stage: self.stage_to_vk_flags(),
            module: self.module,
            name: self.entry_point.clone(),
        }

    # Convert ShaderStage to VkShaderStageFlagBits
    fn stage_to_vk_flags(&self) -> u32:
        match self.stage:
            case ShaderStage::Vertex: VK_SHADER_STAGE_VERTEX_BIT
            case ShaderStage::Fragment: VK_SHADER_STAGE_FRAGMENT_BIT
            case ShaderStage::Compute: VK_SHADER_STAGE_COMPUTE_BIT
            case ShaderStage::Geometry: VK_SHADER_STAGE_GEOMETRY_BIT
            case ShaderStage::TessellationControl: VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT
            case ShaderStage::TessellationEvaluation: VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT

    # Cleanup
    pub async fn destroy(&self):
        await vulkan_destroy_shader_module_async(self.device, self.module)

    pub fn get_module(self) -> VkShaderModule:
        """Get Vulkan shader module handle.

        Returns:
            Shader module handle

        Example:
            val shader = ShaderModule::from_file(&device, "shader.spv", ShaderStage::Vertex)?
            val handle = shader.get_module()
        """
        self.module

    pub fn get_stage(self) -> ShaderStage:
        """Get shader stage type.

        Returns:
            Shader stage

        Example:
            val shader = ShaderModule::from_file(&device, "vert.spv", ShaderStage::Vertex)?
            assert(shader.get_stage().is_vertex_stage())
        """
        self.stage

    pub fn get_entry_point(self) -> &String:
        """Get shader entry point name.

        Returns:
            Entry point name (usually "main")

        Example:
            val shader = ShaderModule::from_file(&device, "shader.spv", ShaderStage::Fragment)?
            assert(shader.get_entry_point() == "main")
        """
        &self.entry_point

    pub fn is_valid(self) -> bool:
        """Check if shader module is valid.

        Returns:
            True if handle is non-zero

        Example:
            val shader = ShaderModule::from_file(&device, "shader.spv", ShaderStage::Vertex)?
            assert(shader.is_valid())
        """
        self.module != 0

    pub fn is_vertex_shader(self) -> bool:
        """Check if this is a vertex shader.

        Returns:
            True if vertex stage

        Example:
            val shader = ShaderModule::from_file(&device, "vert.spv", ShaderStage::Vertex)?
            assert(shader.is_vertex_shader())
        """
        self.stage.is_vertex_stage()

    pub fn is_fragment_shader(self) -> bool:
        """Check if this is a fragment shader.

        Returns:
            True if fragment stage

        Example:
            val shader = ShaderModule::from_file(&device, "frag.spv", ShaderStage::Fragment)?
            assert(shader.is_fragment_shader())
        """
        self.stage.is_fragment_stage()

    pub fn is_compute_shader(self) -> bool:
        """Check if this is a compute shader.

        Returns:
            True if compute stage

        Example:
            val shader = ShaderModule::from_file(&device, "comp.spv", ShaderStage::Compute)?
            assert(shader.is_compute_shader())
        """
        self.stage.is_compute_stage()

    pub fn summary(self) -> String:
        """Get shader module summary.

        Returns:
            Human-readable summary

        Example:
            val shader = ShaderModule::from_file(&device, "vert.spv", ShaderStage::Vertex)?
            print(shader.summary())
        """
        return "ShaderModule: {self.stage.to_string()}, entry='{self.entry_point}'"

# =============================================================================
# Default Vertex Shader - Passthrough with Position + Color
# =============================================================================
#
# GLSL Source (reference):
# ```glsl
# #version 450
#
# layout(location = 0) in vec3 in_position;
# layout(location = 1) in vec4 in_color;
#
# layout(location = 0) out vec4 frag_color;
#
# void main() {
#     gl_Position = vec4(in_position, 1.0);
#     frag_color = in_color;
# }
# ```
#
# Compiled to SPIR-V:
# ```bash
# glslangValidator -V shader.vert -o vert.spv
# ```

pub const DEFAULT_VERTEX_SHADER_SPIRV: Array[u8] = [
    # SPIR-V magic number
    0x03, 0x02, 0x23, 0x07,

    # TODO: [ui][P3] Replace with actual compiled SPIR-V bytecode
    # This is a placeholder - real SPIR-V would be ~500-1000 bytes
    # For now, FFI implementation will need to provide default shaders
]

# =============================================================================
# Default Fragment Shader - Output Color
# =============================================================================
#
# GLSL Source (reference):
# ```glsl
# #version 450
#
# layout(location = 0) in vec4 frag_color;
#
# layout(location = 0) out vec4 out_color;
#
# void main() {
#     out_color = frag_color;
# }
# ```
#
# Compiled to SPIR-V:
# ```bash
# glslangValidator -V shader.frag -o frag.spv
# ```

pub const DEFAULT_FRAGMENT_SHADER_SPIRV: Array[u8] = [
    # SPIR-V magic number
    0x03, 0x02, 0x23, 0x07,

    # TODO: [ui][P3] Replace with actual compiled SPIR-V bytecode
    # This is a placeholder - real SPIR-V would be ~300-500 bytes
]

# =============================================================================
# Shader Builder - Convenient Shader Creation
# =============================================================================

pub struct ShaderBuilder:
    device: VulkanDevice
    vertex_shader: Option[ShaderModule]
    fragment_shader: Option[ShaderModule]

impl ShaderBuilder:
    # Create new shader builder
    pub fn new(device: &VulkanDevice) -> ShaderBuilder:
        ShaderBuilder {
            device: device.clone(),
            vertex_shader: None,
            fragment_shader: None,
        }

    # Load vertex shader from file
    pub fn vertex_from_file(mut self, path: &str) -> Result[ShaderBuilder, String]:
        val shader = ShaderModule::from_file(&self.device, path, ShaderStage::Vertex)?
        self.vertex_shader = Some(shader)
        Ok(self)

    # Load fragment shader from file
    pub fn fragment_from_file(mut self, path: &str) -> Result[ShaderBuilder, String]:
        val shader = ShaderModule::from_file(&self.device, path, ShaderStage::Fragment)?
        self.fragment_shader = Some(shader)
        Ok(self)

    # Use default vertex shader
    pub fn default_vertex(mut self) -> Result[ShaderBuilder, String]:
        val shader = ShaderModule::from_spirv(
            &self.device,
            &DEFAULT_VERTEX_SHADER_SPIRV,
            ShaderStage::Vertex
        )?
        self.vertex_shader = Some(shader)
        Ok(self)

    # Use default fragment shader
    pub fn default_fragment(mut self) -> Result[ShaderBuilder, String]:
        val shader = ShaderModule::from_spirv(
            &self.device,
            &DEFAULT_FRAGMENT_SHADER_SPIRV,
            ShaderStage::Fragment
        )?
        self.fragment_shader = Some(shader)
        Ok(self)

    # Build shader stages for pipeline
    pub fn build(self) -> Result[ShaderStages, String]:
        val vertex = self.vertex_shader.ok_or("No vertex shader specified")?
        val fragment = self.fragment_shader.ok_or("No fragment shader specified")?

        Ok(ShaderStages {
            vertex: vertex,
            fragment: fragment,
        })

# =============================================================================
# Shader Stages - Vertex + Fragment Pair
# =============================================================================

pub struct ShaderStages:
    vertex: ShaderModule
    fragment: ShaderModule

impl ShaderStages:
    # Create shader stages with smart defaults
    pub fn new_default(device: &VulkanDevice) -> Result[ShaderStages, String]:
        ShaderBuilder::new(device)
            .default_vertex()?
            .default_fragment()?
            .build()

    # Create shader stages from files
    pub fn new_from_files(device: &VulkanDevice, vertex_path: &str, fragment_path: &str) -> Result[ShaderStages, String]:
        ShaderBuilder::new(device)
            .vertex_from_file(vertex_path)?
            .fragment_from_file(fragment_path)?
            .build()

    # Get stage infos for pipeline creation
    pub fn get_stage_infos(&self) -> Array[VkPipelineShaderStageCreateInfo]:
        [
            self.vertex.get_stage_info(),
            self.fragment.get_stage_info(),
        ]

    # Cleanup both shaders
    pub async fn destroy(&self):
        await self.vertex.destroy()
        await self.fragment.destroy()

    pub fn get_vertex(self) -> &ShaderModule:
        """Get vertex shader module.

        Returns:
            Reference to vertex shader

        Example:
            val stages = ShaderStages::new_from_files(&device, "vert.spv", "frag.spv")?
            val vertex = stages.get_vertex()
        """
        &self.vertex

    pub fn get_fragment(self) -> &ShaderModule:
        """Get fragment shader module.

        Returns:
            Reference to fragment shader

        Example:
            val stages = ShaderStages::new_from_files(&device, "vert.spv", "frag.spv")?
            val fragment = stages.get_fragment()
        """
        &self.fragment

    pub fn stage_count(self) -> usize:
        """Get number of shader stages.

        Returns:
            Always 2 (vertex + fragment)

        Example:
            val stages = ShaderStages::new_default(&device)?
            assert(stages.stage_count() == 2)
        """
        2

    pub fn has_vertex(self) -> bool:
        """Check if vertex shader is valid.

        Returns:
            True if vertex shader is valid

        Example:
            val stages = ShaderStages::new_default(&device)?
            assert(stages.has_vertex())
        """
        self.vertex.is_valid()

    pub fn has_fragment(self) -> bool:
        """Check if fragment shader is valid.

        Returns:
            True if fragment shader is valid

        Example:
            val stages = ShaderStages::new_default(&device)?
            assert(stages.has_fragment())
        """
        self.fragment.is_valid()

    pub fn is_valid(self) -> bool:
        """Check if both shaders are valid.

        Returns:
            True if both shaders valid

        Example:
            val stages = ShaderStages::new_default(&device)?
            assert(stages.is_valid())
        """
        self.vertex.is_valid() and self.fragment.is_valid()

    pub fn summary(self) -> String:
        """Get shader stages summary.

        Returns:
            Human-readable summary

        Example:
            val stages = ShaderStages::new_default(&device)?
            print(stages.summary())
        """
        return "ShaderStages: vertex + fragment (2 stages)"

# =============================================================================
# FFI Declarations
# =============================================================================

# Shader module creation/destruction
extern fn vulkan_create_shader_module(device: VkDevice, spirv_code: &Array[u8]) -> Result[VkShaderModule, String]
extern fn vulkan_destroy_shader_module_async(device: VkDevice, module: VkShaderModule) -> Future[Result[(), String]]

# File I/O
extern fn vulkan_read_file(path: &str) -> Result[Array[u8], String]

# =============================================================================
# Vulkan Constants - Shader Stage Flags
# =============================================================================

pub const VK_SHADER_STAGE_VERTEX_BIT: u32 = 0x00000001
pub const VK_SHADER_STAGE_FRAGMENT_BIT: u32 = 0x00000004
pub const VK_SHADER_STAGE_COMPUTE_BIT: u32 = 0x00000020
pub const VK_SHADER_STAGE_GEOMETRY_BIT: u32 = 0x00000008
pub const VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: u32 = 0x00000002
pub const VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: u32 = 0x00000010

# =============================================================================
# Supporting Types
# =============================================================================

pub struct VkPipelineShaderStageCreateInfo:
    stage: u32
    module: VkShaderModule
    name: String

impl VkPipelineShaderStageCreateInfo:
    pub fn get_stage(self) -> u32:
        """Get shader stage flags.

        Returns:
            Vulkan shader stage flags

        Example:
            val info = shader.get_stage_info()
            assert(info.get_stage() == VK_SHADER_STAGE_VERTEX_BIT)
        """
        self.stage

    pub fn get_module(self) -> VkShaderModule:
        """Get shader module handle.

        Returns:
            Shader module handle

        Example:
            val info = shader.get_stage_info()
            val module = info.get_module()
        """
        self.module

    pub fn get_entry_point(self) -> &String:
        """Get entry point name.

        Returns:
            Entry point name

        Example:
            val info = shader.get_stage_info()
            assert(info.get_entry_point() == "main")
        """
        &self.name

    pub fn is_vertex_stage(self) -> bool:
        """Check if this is vertex stage.

        Returns:
            True if vertex stage

        Example:
            val info = vertex_shader.get_stage_info()
            assert(info.is_vertex_stage())
        """
        self.stage == VK_SHADER_STAGE_VERTEX_BIT

    pub fn is_fragment_stage(self) -> bool:
        """Check if this is fragment stage.

        Returns:
            True if fragment stage

        Example:
            val info = fragment_shader.get_stage_info()
            assert(info.is_fragment_stage())
        """
        self.stage == VK_SHADER_STAGE_FRAGMENT_BIT

    pub fn is_compute_stage(self) -> bool:
        """Check if this is compute stage.

        Returns:
            True if compute stage

        Example:
            val info = compute_shader.get_stage_info()
            assert(info.is_compute_stage())
        """
        self.stage == VK_SHADER_STAGE_COMPUTE_BIT

    pub fn is_valid(self) -> bool:
        """Check if stage info is valid.

        Returns:
            True if module is non-zero

        Example:
            val info = shader.get_stage_info()
            assert(info.is_valid())
        """
        self.module != 0

    pub fn summary(self) -> String:
        """Get shader stage info summary.

        Returns:
            Human-readable summary

        Example:
            val info = shader.get_stage_info()
            print(info.summary())
        """
        val stage_name = if self.is_vertex_stage(): "vertex"
                        else if self.is_fragment_stage(): "fragment"
                        else if self.is_compute_stage(): "compute"
                        else: "unknown"
        return "ShaderStageInfo: {stage_name}, entry='{self.name}'"

# Opaque FFI type
pub type VkShaderModule = i64
