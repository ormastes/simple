# Vulkan GUI Renderer - RenderBackend Implementation
#
# Implements the RenderBackend trait using Vulkan for GPU-accelerated
# cross-platform rendering. Connects the UI framework's Element tree
# to Vulkan graphics pipeline.
#
# Architecture:
#   Element Tree → Layout → Vertex Data → GPU Buffers → Vulkan Render
#
# Features:
#   - Hardware-accelerated rendering
#   - Efficient batch drawing
#   - Text rendering with font atlas
#   - Image/texture support
#   - Smooth animations (60+ FPS)
#   - Cross-platform (Windows, Linux, macOS, Android, iOS)

use core.*
use ui.element.*
use ui.renderer.*
use ui.attrs.*
use ui.patchset.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_shaders.*
use ui.gui.vulkan_pipeline.*
use ui.gui.vulkan_buffers.*
use ui.gui.vulkan_commands.*
use ui.gui.vulkan_frame.*
use ui.gui.vulkan_font.*

# =============================================================================
# Vulkan Renderer - Main Implementation
# =============================================================================

pub struct VulkanRenderer:
    # Vulkan infrastructure (Phase 1)
    device: Option<VulkanDevice>
    swapchain: Option<Swapchain>
    render_pass: Option<RenderPass>
    pipeline: Option<GraphicsPipeline>

    # Render loop (Phase 2)
    render_loop: Option<RenderLoop>

    # Window management
    window_handle: i64
    width: u16
    height: u16

    # UI rendering state
    layout_cache: LayoutCache
    vertex_cache: VertexCache
    font_atlas: Option<FontAtlas>

    # Initialization state
    is_initialized: bool

impl VulkanRenderer:
    # Create new renderer for a window
    pub fn new(window_handle: i64, width: u16, height: u16) -> VulkanRenderer:
        VulkanRenderer {
            device: None,
            swapchain: None,
            render_pass: None,
            pipeline: None,
            render_loop: None,
            window_handle: window_handle,
            width: width,
            height: height,
            layout_cache: LayoutCache::new(),
            vertex_cache: VertexCache::new(),
            font_atlas: None,
            is_initialized: false,
        }

impl RenderBackend for VulkanRenderer:
    # Initialize Vulkan resources
    async fn init(&mut self) -> Result<(), RenderError>:
        if self.is_initialized:
            return Err(RenderError::AlreadyInitialized)

        # Phase 1: Initialize Vulkan device
        val device = match VulkanDevice::new(self.window_handle):
            case Ok(d): d
            case Err(e): return Err(RenderError::IoError(e))

        # Phase 1: Create swapchain
        val swapchain = match Swapchain::new(&device, self.window_handle, self.width as u32, self.height as u32):
            case Ok(s): s
            case Err(e): return Err(RenderError::IoError(e))

        # Phase 1: Create render pass
        val render_pass = match RenderPass::new(&device, swapchain.format):
            case Ok(r): r
            case Err(e): return Err(RenderError::IoError(e))

        # Phase 1: Load UI shaders
        val shaders = match ShaderBuilder::new(&device)
            .vertex_from_file("shaders/ui_vertex.spv")
            .fragment_from_file("shaders/ui_fragment.spv")
            .build():
            case Ok(s): s
            case Err(e): return Err(RenderError::IoError(e))

        # Phase 1: Create graphics pipeline for UI rendering
        val pipeline_info = PipelineBuilder::new()
            .shaders(&shaders)
            .vertex_input_ui()  # Position(2) + TexCoord(2) + Color(4)
            .input_assembly_triangles()
            .rasterization_default()
            .viewport_dynamic()
            .multisample_none()  # UI doesn't need MSAA
            .color_blend_alpha()
            .build()

        val pipeline = match GraphicsPipeline::new(&device, &render_pass, &pipeline_info):
            case Ok(p): p
            case Err(e): return Err(RenderError::IoError(e))

        # Phase 2: Create render loop
        val render_loop = match RenderLoop::new(&device, &swapchain, &render_pass):
            case Ok(r): r
            case Err(e): return Err(RenderError::IoError(e))

        # Initialize font atlas for text rendering (uses system default font)
        val font_atlas = match await FontAtlas::default(&device):
            case Ok(atlas): atlas
            case Err(e): return Err(RenderError::IoError(e))

        # Store state
        self.device = Some(device)
        self.swapchain = Some(swapchain)
        self.render_pass = Some(render_pass)
        self.pipeline = Some(pipeline)
        self.render_loop = Some(render_loop)
        self.font_atlas = Some(font_atlas)
        self.is_initialized = true

        Ok(())

    # Shutdown and cleanup
    async fn shutdown(&mut self) -> Result<(), RenderError>:
        if !self.is_initialized:
            return Err(RenderError::NotInitialized)

        # Wait for GPU to finish
        if val Some(render_loop) = &self.render_loop:
            await render_loop.wait_idle()

        # Cleanup resources (in reverse order of creation)
        if val Some(font_atlas) = &mut self.font_atlas:
            await font_atlas.destroy()

        if val Some(render_loop) = &mut self.render_loop:
            await render_loop.destroy()

        if val Some(pipeline) = &self.pipeline:
            await pipeline.destroy()

        if val Some(render_pass) = &self.render_pass:
            await render_pass.destroy()

        if val Some(swapchain) = &self.swapchain:
            await swapchain.destroy()

        if val Some(device) = &self.device:
            await device.destroy()

        self.is_initialized = false
        Ok(())

    # Get window dimensions
    fn dimensions(&self) -> (u16, u16):
        (self.width, self.height)

    # Render element tree
    async fn render(&mut self, tree: &ElementTree) -> Result<(), RenderError>:
        if !self.is_initialized:
            return Err(RenderError::NotInitialized)

        # Step 1: Compute layout for all elements
        self.layout_cache.clear()
        val root_layout = Layout::new(0, 0, self.width, self.height)
        await self.compute_layout(tree.root(), root_layout)?

        # Step 2: Generate vertex data from layout
        self.vertex_cache.clear()
        await self.generate_vertices(tree.root())?

        # Step 3: Upload vertices to GPU
        val device = self.device.as_ref().unwrap()
        val vertex_buffer = VertexBuffer::new(device, &self.vertex_cache.vertices)?

        # Step 4: Render frame
        val render_loop = self.render_loop.as_mut().unwrap()
        val pipeline = self.pipeline.as_ref().unwrap()

        if val Some(mut frame) = await render_loop.frame():
            # Clear background
            frame.clear([0.1, 0.1, 0.1, 1.0])?

            # Bind pipeline
            frame.bind(pipeline)?

            # Draw UI
            frame.draw(&vertex_buffer, self.vertex_cache.vertices.len() as u32)?

            # Frame automatically submitted and presented

        # Cleanup
        await vertex_buffer.destroy()

        Ok(())

    # Apply incremental patches
    async fn apply_patches(&mut self, patches: &PatchSet) -> Result<(), RenderError>:
        if !self.is_initialized:
            return Err(RenderError::NotInitialized)

        # Process patches and track dirty regions
        # For now, we mark all affected nodes and do a full re-render on next render() call
        # Future optimization: only regenerate vertices for dirty subtrees

        var dirty_nodes: Array<NodeId> = []

        for patch in patches.iter():
            val node_id = patch.target_id()
            if !dirty_nodes.contains(&node_id):
                dirty_nodes.push(node_id)

        # Mark layout cache entries as invalid for dirty nodes
        for node_id in &dirty_nodes:
            self.layout_cache.invalidate(*node_id)

        # Clear vertex cache to force regeneration
        # A more sophisticated implementation would only clear affected vertices
        if !dirty_nodes.is_empty():
            self.vertex_cache.clear()

        Ok(())

    # Clear screen
    async fn clear(&mut self) -> Result<(), RenderError>:
        if !self.is_initialized:
            return Err(RenderError::NotInitialized)

        val render_loop = self.render_loop.as_mut().unwrap()

        if val Some(mut frame) = await render_loop.frame():
            frame.clear([0.0, 0.0, 0.0, 1.0])?

        Ok(())

    # Flush pending changes
    async fn flush(&mut self) -> Result<(), RenderError>:
        # Vulkan rendering is already flushed after each frame
        # This is a no-op for Vulkan
        Ok(())

    # Poll for events
    async fn poll_event(&mut self, timeout_ms: u64) -> Result<Option<Event>, RenderError>:
        # TODO: [ui][P3] Integrate with window event system
        Err(RenderError::UnsupportedFeature("event polling not yet implemented"))

    # Read next event (blocking)
    async fn read_event(&mut self) -> Result<Event, RenderError>:
        # TODO: [ui][P3] Integrate with window event system
        Err(RenderError::UnsupportedFeature("event reading not yet implemented"))

# =============================================================================
# Layout Computation
# =============================================================================

impl VulkanRenderer:
    # Recursively compute layout for element tree
    async fn compute_layout(&mut self, node: &Node, parent_layout: Layout) -> Result<(), RenderError>:
        match node:
            case Node::Container(container):
                # Apply container's layout attributes
                val layout = self.compute_container_layout(container, parent_layout)
                self.layout_cache.set(container.id(), layout)

                # Layout children
                var child_y = layout.content_y
                for child in &container.children:
                    val child_layout = Layout::new(
                        layout.content_x,
                        child_y,
                        layout.content_width,
                        20  # Default height, will be refined
                    )
                    await self.compute_layout(child, child_layout)?
                    child_y += 20

            case Node::Text(text):
                # Text layout is simple - just bounding box
                val layout = Layout::new(
                    parent_layout.x,
                    parent_layout.y,
                    parent_layout.width,
                    20  # Single line height
                )
                self.layout_cache.set(text.id(), layout)

            case Node::Button(button):
                # Button has fixed height, centered text
                val layout = Layout::new(
                    parent_layout.x,
                    parent_layout.y,
                    parent_layout.width,
                    30  # Button height
                )
                self.layout_cache.set(button.id(), layout)

            case _:
                # Other elements use parent layout
                pass

        Ok(())

    fn compute_container_layout(&self, container: &Container, parent: Layout) -> Layout:
        # Extract layout attributes
        var layout = parent

        # Apply width/height if specified
        if val Some(width) = container.attrs.get_width():
            layout.width = width
        if val Some(height) = container.attrs.get_height():
            layout.height = height

        # Apply padding
        val padding = container.attrs.get_padding().unwrap_or((0, 0, 0, 0))
        layout = layout.with_padding(padding.0, padding.1, padding.2, padding.3)

        layout

    pub fn get_width(self) -> u16:
        """Get renderer window width.

        Returns:
            Width in pixels

        Example:
            val renderer = VulkanRenderer::new(handle, 800, 600)
            assert(renderer.get_width() == 800)
        """
        self.width

    pub fn get_height(self) -> u16:
        """Get renderer window height.

        Returns:
            Height in pixels

        Example:
            val renderer = VulkanRenderer::new(handle, 800, 600)
            assert(renderer.get_height() == 600)
        """
        self.height

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized.

        Returns:
            True if initialized

        Example:
            var renderer = VulkanRenderer::new(handle, 800, 600)
            assert(not renderer.is_initialized())
            renderer.init().await?
            assert(renderer.is_initialized())
        """
        self.is_initialized

    pub fn has_device(self) -> bool:
        """Check if Vulkan device is created.

        Returns:
            True if device exists

        Example:
            val renderer = VulkanRenderer::new(handle, 800, 600)
            if renderer.has_device():
                print("Device ready")
        """
        self.device.is_some()

    pub fn has_font_atlas(self) -> bool:
        """Check if font atlas is loaded.

        Returns:
            True if font atlas exists

        Example:
            val renderer = VulkanRenderer::new(handle, 800, 600)
            if renderer.has_font_atlas():
                print("Text rendering available")
        """
        self.font_atlas.is_some()

    pub fn vertex_count(self) -> usize:
        """Get current vertex cache size.

        Returns:
            Number of cached vertices

        Example:
            val renderer = VulkanRenderer::new(handle, 800, 600)
            val count = renderer.vertex_count()
        """
        self.vertex_cache.vertices.len()

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio.

        Returns:
            Width / height ratio

        Example:
            val renderer = VulkanRenderer::new(handle, 1920, 1080)
            assert(renderer.aspect_ratio() > 1.7)
        """
        (self.width as f64) / (self.height as f64)

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation.

        Returns:
            True if width > height

        Example:
            val renderer = VulkanRenderer::new(handle, 1920, 1080)
            assert(renderer.is_landscape())
        """
        self.width > self.height

    pub fn summary(self) -> text:
        """Get renderer summary.

        Returns:
            Human-readable summary

        Example:
            val renderer = VulkanRenderer::new(handle, 800, 600)
            print(renderer.summary())
        """
        val state = if self.is_initialized: "initialized" else: "uninitialized"
        return "VulkanRenderer: {self.width}x{self.height}, {state}, {self.vertex_count()} vertices"
    }

# =============================================================================
# Vertex Generation
# =============================================================================

impl VulkanRenderer:
    # Generate vertices for element rendering
    async fn generate_vertices(&mut self, node: &Node) -> Result<(), RenderError>:
        match node:
            case Node::Container(container):
                # Draw container background
                if val Some(layout) = self.layout_cache.get(container.id()):
                    val bg_color = container.attrs.get_background_color().unwrap_or([0.2, 0.2, 0.2, 1.0])
                    self.vertex_cache.add_rect(
                        layout.x as f32,
                        layout.y as f32,
                        layout.width as f32,
                        layout.height as f32,
                        bg_color
                    )

                # Render children
                for child in &container.children:
                    await self.generate_vertices(child)?

            case Node::Text(text):
                # Render text using font atlas
                if val Some(layout) = self.layout_cache.get(text.id()):
                    val color = text.attrs.get_color().unwrap_or([1.0, 1.0, 1.0, 1.0])
                    val font_atlas = self.font_atlas.as_ref().unwrap()

                    match await font_atlas.add_text(
                        &mut self.vertex_cache,
                        &text.content,
                        layout.x as f32,
                        layout.y as f32,
                        color
                    ):
                        case Ok(_): pass
                        case Err(e): return Err(RenderError::IoError(e))

            case Node::Button(button):
                # Draw button background
                if val Some(layout) = self.layout_cache.get(button.id()):
                    val bg_color = button.attrs.get_background_color().unwrap_or([0.3, 0.5, 0.8, 1.0])
                    self.vertex_cache.add_rect(
                        layout.x as f32,
                        layout.y as f32,
                        layout.width as f32,
                        layout.height as f32,
                        bg_color
                    )

                    # Draw button text (centered)
                    val text_color = button.attrs.get_color().unwrap_or([1.0, 1.0, 1.0, 1.0])
                    val font_atlas = self.font_atlas.as_ref().unwrap()

                    # TODO: [ui][P3] Compute text width for centering
                    val text_x = layout.x as f32 + 10.0
                    val text_y = layout.y as f32 + 8.0

                    match await font_atlas.add_text(
                        &mut self.vertex_cache,
                        &button.label,
                        text_x,
                        text_y,
                        text_color
                    ):
                        case Ok(_): pass
                        case Err(e): return Err(RenderError::IoError(e))

            case _:
                pass

        Ok(())
    }

# =============================================================================
# UI Vertex Format
# =============================================================================

pub struct UIVertex:
    position: [f32; 2]    # Screen position (0..width, 0..height)
    tex_coord: [f32; 2]   # Texture coordinates (0..1, 0..1)
    color: [f32; 4]       # RGBA color (0..1)

impl UIVertex:
    pub fn get_position(self) -> (f32, f32):
        """Get vertex position.

        Returns:
            (x, y) screen coordinates

        Example:
            val v = UIVertex { position: [100.0, 200.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            val (x, y) = v.get_position()
            assert(x == 100.0 and y == 200.0)
        """
        (self.position[0], self.position[1])

    pub fn get_tex_coord(self) -> (f32, f32):
        """Get texture coordinates.

        Returns:
            (u, v) texture coordinates

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.5, 0.5], color: [1.0, 1.0, 1.0, 1.0] }
            val (u, v) = v.get_tex_coord()
            assert(u == 0.5 and v == 0.5)
        """
        (self.tex_coord[0], self.tex_coord[1])

    pub fn get_color(self) -> [f32; 4]:
        """Get vertex color.

        Returns:
            RGBA color array

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 0.0, 0.0, 1.0] }
            val c = v.get_color()
            assert(c[0] == 1.0)  # Red
        """
        self.color

    pub fn is_textured(self) -> bool:
        """Check if vertex has non-zero texture coordinates.

        Returns:
            True if texture coordinates are non-zero

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.5, 0.5], color: [1.0, 1.0, 1.0, 1.0] }
            assert(v.is_textured())
        """
        self.tex_coord[0] != 0.0 or self.tex_coord[1] != 0.0

    pub fn is_opaque(self) -> bool:
        """Check if vertex color is fully opaque.

        Returns:
            True if alpha is 1.0

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            assert(v.is_opaque())
        """
        self.color[3] == 1.0

    pub fn is_transparent(self) -> bool:
        """Check if vertex has any transparency.

        Returns:
            True if alpha < 1.0

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 0.5] }
            assert(v.is_transparent())
        """
        self.color[3] < 1.0

    pub fn summary(self) -> text:
        """Get vertex summary.

        Returns:
            Human-readable summary

        Example:
            val v = UIVertex { position: [100.0, 200.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            print(v.summary())
        """
        val (x, y) = self.get_position()
        return "UIVertex: pos({x:.1}, {y:.1}), tex({self.tex_coord[0]:.2}, {self.tex_coord[1]:.2}), alpha={self.color[3]:.2}"

# =============================================================================
# Vertex Cache - Batches UI drawing
# =============================================================================

pub struct VertexCache:
    vertices: Array<UIVertex>

impl VertexCache:
    pub fn new() -> VertexCache:
        VertexCache {
            vertices: Array::new()
        }

    pub fn clear(&mut self):
        self.vertices.clear()

    # Add a colored rectangle (2 triangles = 6 vertices)
    pub fn add_rect(&mut self, x: f32, y: f32, w: f32, h: f32, color: [f32; 4]):
        # Triangle 1: top-left, top-right, bottom-left
        self.vertices.push(UIVertex {
            position: [x, y],
            tex_coord: [0.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [1.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [0.0, 1.0],
            color: color,
        })

        # Triangle 2: bottom-left, top-right, bottom-right
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [0.0, 1.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [1.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y + h],
            tex_coord: [1.0, 1.0],
            color: color,
        })

    pub fn vertex_count(self) -> usize:
        """Get number of vertices in cache.

        Returns:
            Vertex count

        Example:
            val cache = VertexCache::new()
            assert(cache.vertex_count() == 0)
        """
        self.vertices.len()

    pub fn is_empty(self) -> bool:
        """Check if cache is empty.

        Returns:
            True if no vertices

        Example:
            val cache = VertexCache::new()
            assert(cache.is_empty())
        """
        self.vertices.len() == 0

    pub fn triangle_count(self) -> usize:
        """Get number of triangles (vertices / 3).

        Returns:
            Triangle count

        Example:
            var cache = VertexCache::new()
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.triangle_count() == 2)
        """
        self.vertices.len() / 3

    pub fn rect_count(self) -> usize:
        """Estimate number of rectangles (triangles / 2).

        Returns:
            Estimated rect count

        Example:
            var cache = VertexCache::new()
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.rect_count() == 1)
        """
        self.triangle_count() / 2

    pub fn has_vertices(self) -> bool:
        """Check if cache has any vertices.

        Returns:
            True if vertices exist

        Example:
            var cache = VertexCache::new()
            assert(not cache.has_vertices())
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.has_vertices())
        """
        self.vertices.len() > 0

    pub fn is_large(self) -> bool:
        """Check if cache has many vertices (>10000).

        Returns:
            True if vertex count exceeds 10000

        Example:
            val cache = VertexCache::new()
            if cache.is_large():
                print("Large vertex cache, consider batching")
        """
        self.vertices.len() > 10000

    pub fn summary(self) -> text:
        """Get vertex cache summary.

        Returns:
            Human-readable summary

        Example:
            val cache = VertexCache::new()
            print(cache.summary())
        """
        val tris = self.triangle_count()
        val rects = self.rect_count()
        return "VertexCache: {self.vertices.len()} vertices, {tris} triangles, ~{rects} rects"

# =============================================================================
# Font Atlas - Imported from vulkan_font.spl
# =============================================================================
# FontAtlas and related types are imported from ui.gui.vulkan_font

impl VertexCache:
    # Add textured rectangle for glyph rendering
    pub fn add_textured_rect(
        &mut self,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
        tx: f32,
        ty: f32,
        tw: f32,
        th: f32,
        color: [f32; 4]
    ):
        # Similar to add_rect but with custom texture coordinates
        # Triangle 1
        self.vertices.push(UIVertex {
            position: [x, y],
            tex_coord: [tx, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [tx + tw, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [tx, ty + th],
            color: color,
        })

        # Triangle 2
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [tx, ty + th],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [tx + tw, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y + h],
            tex_coord: [tx + tw, ty + th],
            color: color,
        })

# =============================================================================
# Pipeline Builder Extension for UI
# =============================================================================

impl PipelineBuilder:
    # Vertex input for UI rendering (Position2 + TexCoord2 + Color4)
    pub fn vertex_input_ui(mut self) -> PipelineBuilder:
        self.vertex_bindings.push(VkVertexInputBindingDescription {
            binding: 0,
            stride: 32,  # 2*4 + 2*4 + 4*4 = 32 bytes
            input_rate: VK_VERTEX_INPUT_RATE_VERTEX,
        })

        # Position (vec2)
        self.vertex_attributes.push(VkVertexInputAttributeDescription {
            location: 0,
            binding: 0,
            format: VK_FORMAT_R32G32_SFLOAT,
            offset: 0,
        })

        # TexCoord (vec2)
        self.vertex_attributes.push(VkVertexInputAttributeDescription {
            location: 1,
            binding: 0,
            format: VK_FORMAT_R32G32_SFLOAT,
            offset: 8,
        })

        # Color (vec4)
        self.vertex_attributes.push(VkVertexInputAttributeDescription {
            location: 2,
            binding: 0,
            format: VK_FORMAT_R32G32B32A32_SFLOAT,
            offset: 16,
        })

        self

# =============================================================================
# Attribute Helpers
# =============================================================================

# Attributes wrapper for parsing element attributes and styles
pub struct Attributes:
    attrs: Dict<text, text>
    styles: Dict<text, text>

impl Attributes:
    # Create Attributes from an Element
    pub fn from_element(elem: &Element) -> Attributes:
        return Attributes {
            attrs: elem.attrs.clone(),
            styles: elem.styles.clone()
        }

    # Get attribute value by name
    pub fn get(&self, name: &str) -> Option<text>:
        match self.attrs.get(&name.to_string()):
            case Some(v): return Some(v.clone())
            case None:
                match self.styles.get(&name.to_string()):
                    case Some(v): return Some(v.clone())
                    case None: return None

    pub fn get_width(&self) -> Option<u16>:
        match self.get("width"):
            case Some(val): return parse_dimension(&val)
            case None: return None

    pub fn get_height(&self) -> Option<u16>:
        match self.get("height"):
            case Some(val): return parse_dimension(&val)
            case None: return None

    pub fn get_padding(&self) -> Option<(u16, u16, u16, u16)>:
        match self.get("padding"):
            case Some(val): return parse_padding(&val)
            case None: return None

    pub fn get_background_color(&self) -> Option<[f32; 4]>:
        match self.get("background-color"):
            case Some(val): return parse_color(&val)
            case None:
                match self.get("background"):
                    case Some(val): return parse_color(&val)
                    case None: return None

    pub fn get_color(&self) -> Option<[f32; 4]>:
        match self.get("color"):
            case Some(val): return parse_color(&val)
            case None: return None

# Parse dimension value (e.g., "100", "100px", "50%")
fn parse_dimension(val: &str) -> Option<u16>:
    val trimmed = val.trim()
    # Remove 'px' suffix if present
    val numeric = if trimmed.ends_with("px"):
        trimmed[0..trimmed.len() - 2]
    else if trimmed.ends_with("%"):
        # Percentage not supported yet, return None
        return None
    else:
        trimmed

    match numeric.parse::<u16>():
        case Ok(n): return Some(n)
        case Err(_): return None

# Parse padding value (e.g., "10", "10 20", "10 20 30 40")
fn parse_padding(val: &str) -> Option<(u16, u16, u16, u16)>:
    val parts = val.trim().split_whitespace().collect::<Array<&str>>()

    match parts.len():
        case 1:
            # All sides same
            match parts[0].parse::<u16>():
                case Ok(n): return Some((n, n, n, n))
                case Err(_): return None
        case 2:
            # Vertical, Horizontal
            match (parts[0].parse::<u16>(), parts[1].parse::<u16>()):
                case (Ok(v), Ok(h)): return Some((v, h, v, h))
                case _: return None
        case 4:
            # Top, Right, Bottom, Left
            match (parts[0].parse::<u16>(), parts[1].parse::<u16>(),
                   parts[2].parse::<u16>(), parts[3].parse::<u16>()):
                case (Ok(t), Ok(r), Ok(b), Ok(l)): return Some((t, r, b, l))
                case _: return None
        case _:
            return None

# Parse color value (e.g., "#FF0000", "rgb(255,0,0)", "red")
fn parse_color(val: &str) -> Option<[f32; 4]>:
    val trimmed = val.trim().to_lowercase()

    # Named colors
    match trimmed.as_str():
        case "red": return Some([1.0, 0.0, 0.0, 1.0])
        case "green": return Some([0.0, 1.0, 0.0, 1.0])
        case "blue": return Some([0.0, 0.0, 1.0, 1.0])
        case "white": return Some([1.0, 1.0, 1.0, 1.0])
        case "black": return Some([0.0, 0.0, 0.0, 1.0])
        case "yellow": return Some([1.0, 1.0, 0.0, 1.0])
        case "cyan": return Some([0.0, 1.0, 1.0, 1.0])
        case "magenta": return Some([1.0, 0.0, 1.0, 1.0])
        case "gray" | "grey": return Some([0.5, 0.5, 0.5, 1.0])
        case "transparent": return Some([0.0, 0.0, 0.0, 0.0])
        case _: pass

    # Hex color (#RGB, #RRGGBB, #RRGGBBAA)
    if trimmed.starts_with("#"):
        val hex = &trimmed[1..]
        match hex.len():
            case 3:
                # #RGB -> #RRGGBB
                val r = parse_hex_digit(hex[0..1]) * 17
                val g = parse_hex_digit(hex[1..2]) * 17
                val b = parse_hex_digit(hex[2..3]) * 17
                return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, 1.0])
            case 6:
                # #RRGGBB
                val r = parse_hex_byte(&hex[0..2])
                val g = parse_hex_byte(&hex[2..4])
                val b = parse_hex_byte(&hex[4..6])
                return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, 1.0])
            case 8:
                # #RRGGBBAA
                val r = parse_hex_byte(&hex[0..2])
                val g = parse_hex_byte(&hex[2..4])
                val b = parse_hex_byte(&hex[4..6])
                val a = parse_hex_byte(&hex[6..8])
                return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, a as f32 / 255.0])
            case _:
                return None

    # rgb(r, g, b) or rgba(r, g, b, a)
    if trimmed.starts_with("rgb"):
        val inner = if trimmed.starts_with("rgba("):
            &trimmed[5..trimmed.len()-1]
        else if trimmed.starts_with("rgb("):
            &trimmed[4..trimmed.len()-1]
        else:
            return None

        val parts = inner.split(",").map(|s| s.trim()).collect::<Array<&str>>()
        match parts.len():
            case 3:
                match (parts[0].parse::<u8>(), parts[1].parse::<u8>(), parts[2].parse::<u8>()):
                    case (Ok(r), Ok(g), Ok(b)):
                        return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, 1.0])
                    case _: return None
            case 4:
                match (parts[0].parse::<u8>(), parts[1].parse::<u8>(),
                       parts[2].parse::<u8>(), parts[3].parse::<f32>()):
                    case (Ok(r), Ok(g), Ok(b), Ok(a)):
                        return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, a])
                    case _: return None
            case _: return None

    return None

# Parse single hex digit (0-15)
fn parse_hex_digit(s: &str) -> u8:
    match s.chars().next():
        case Some(c):
            if c >= '0' and c <= '9':
                return (c as u8) - ('0' as u8)
            if c >= 'a' and c <= 'f':
                return (c as u8) - ('a' as u8) + 10
            if c >= 'A' and c <= 'F':
                return (c as u8) - ('A' as u8) + 10
            return 0
        case None: return 0

# Parse two hex digits (00-FF)
fn parse_hex_byte(s: &str) -> u8:
    val high = parse_hex_digit(&s[0..1])
    val low = parse_hex_digit(&s[1..2])
    return high * 16 + low

# =============================================================================
# Type Aliases for Vulkan Integration
# =============================================================================

pub type VkTexture = i64
pub type VkVertexInputBindingDescription = i64
pub type VkVertexInputAttributeDescription = i64

pub const VK_VERTEX_INPUT_RATE_VERTEX: u32 = 0
pub const VK_FORMAT_R32G32_SFLOAT: u32 = 103
pub const VK_FORMAT_R32G32B32A32_SFLOAT: u32 = 109
