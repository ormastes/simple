# Vulkan FFI Bindings - Direct mapping to Rust rt_vk_* functions
#
# This module provides direct bindings to the Vulkan FFI layer implemented
# in Rust (src/runtime/src/value/vulkan_ffi/).
#
# All functions use handle-based API with u64 handles for resources.
# Error codes are returned as i32 (0 = success, negative = error).

# =============================================================================
# Error Codes
# =============================================================================

pub const VK_SUCCESS: i32 = 0
pub const VK_ERROR_NOT_AVAILABLE: i32 = -1
pub const VK_ERROR_INVALID_HANDLE: i32 = -2
pub const VK_ERROR_OUT_OF_MEMORY: i32 = -3
pub const VK_ERROR_DEVICE_LOST: i32 = -4
pub const VK_ERROR_COMPILATION_FAILED: i32 = -5
pub const VK_ERROR_BUFFER_TOO_SMALL: i32 = -6
pub const VK_ERROR_INVALID_PARAMETER: i32 = -7
pub const VK_ERROR_SWAPCHAIN_OUT_OF_DATE: i32 = -8
pub const VK_ERROR_SURFACE_LOST: i32 = -9

# =============================================================================
# Device Management
# =============================================================================

# Create a Vulkan device with auto-selected GPU
# Returns: device handle (>0) on success, 0 on failure
extern fn rt_vk_device_create() -> u64

# Free a Vulkan device
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_device_free(device_handle: u64) -> i32

# Wait for device to be idle (all operations complete)
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_device_sync(device_handle: u64) -> i32

# =============================================================================
# Buffer Management
# =============================================================================

# Allocate a GPU buffer
# Returns: buffer handle (>0) on success, 0 on failure
extern fn rt_vk_buffer_alloc(device_handle: u64, size: u64) -> u64

# Free a GPU buffer
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_buffer_free(buffer_handle: u64) -> i32

# Upload data from CPU to GPU buffer
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_buffer_upload(buffer_handle: u64, data: *const u8, size: u64) -> i32

# Download data from GPU buffer to CPU
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_buffer_download(buffer_handle: u64, data: *mut u8, size: u64) -> i32

# =============================================================================
# Compute Kernel Management
# =============================================================================

# Compile SPIR-V bytecode into a compute pipeline
# Returns: pipeline handle (>0) on success, 0 on failure
extern fn rt_vk_kernel_compile(device_handle: u64, spirv: *const u8, spirv_size: u64) -> u64

# Free a compute pipeline
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_kernel_free(pipeline_handle: u64) -> i32

# Launch a compute kernel (3D dispatch)
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_kernel_launch(
    device_handle: u64,
    pipeline_handle: u64,
    buffer_handle: u64,
    groups_x: u32,
    groups_y: u32,
    groups_z: u32
) -> i32

# Launch a compute kernel (1D dispatch)
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_kernel_launch_1d(
    device_handle: u64,
    pipeline_handle: u64,
    buffer_handle: u64,
    num_elements: u32
) -> i32

# =============================================================================
# Descriptor Management
# =============================================================================

# Create a descriptor layout for uniform buffer
extern fn rt_vk_descriptor_layout_create_uniform(device_handle: u64) -> u64

# Create a descriptor layout for sampler
extern fn rt_vk_descriptor_layout_create_sampler(device_handle: u64) -> u64

# Free a descriptor layout
extern fn rt_vk_descriptor_layout_free(layout_handle: u64) -> i32

# Create a descriptor pool
extern fn rt_vk_descriptor_pool_create(device_handle: u64, max_sets: u32) -> u64

# Free a descriptor pool
extern fn rt_vk_descriptor_pool_free(pool_handle: u64) -> i32

# Allocate a descriptor set from pool
extern fn rt_vk_descriptor_set_allocate(pool_handle: u64, layout_handle: u64) -> u64

# Free a descriptor set
extern fn rt_vk_descriptor_set_free(set_handle: u64) -> i32

# Update descriptor set with buffer binding
extern fn rt_vk_descriptor_set_update_buffer(
    set_handle: u64,
    binding: u32,
    buffer_handle: u64,
    offset: u64,
    range: u64
) -> i32

# =============================================================================
# Window Management
# =============================================================================

# Create a window with Vulkan surface
# Returns: window handle (>0) on success, 0 on failure
extern fn rt_vk_window_create(
    title: *const u8,
    title_len: u64,
    width: u32,
    height: u32
) -> u64

# Destroy a window
extern fn rt_vk_window_destroy(window_handle: u64) -> i32

# Get window size
# Returns dimensions via out parameters, returns 0 on success
extern fn rt_vk_window_get_size(
    window_handle: u64,
    width_out: *mut u32,
    height_out: *mut u32
) -> i32

# Set fullscreen mode (0=windowed, 1=borderless, 2=exclusive)
extern fn rt_vk_window_set_fullscreen(window_handle: u64, mode: i32) -> i32

# Poll for window events (non-blocking)
# Returns event data via out parameters
# event_type: 0=none, 1=resize, 2=close, 3=key, 4=mouse
extern fn rt_vk_window_poll_event(
    window_handle: u64,
    event_type_out: *mut i32,
    event_data_out: *mut u8,
    event_data_size: u64
) -> i32

# Wait for window event (blocking with timeout)
extern fn rt_vk_window_wait_event(
    window_handle: u64,
    timeout_ms: u64,
    event_type_out: *mut i32,
    event_data_out: *mut u8,
    event_data_size: u64
) -> i32

# =============================================================================
# Swapchain Management
# =============================================================================

# Create a swapchain for a window
extern fn rt_vk_swapchain_create(
    device_handle: u64,
    window_handle: u64,
    width: u32,
    height: u32
) -> u64

# Recreate swapchain (e.g., after window resize)
extern fn rt_vk_swapchain_recreate(
    swapchain_handle: u64,
    width: u32,
    height: u32
) -> i32

# Destroy a swapchain
extern fn rt_vk_swapchain_destroy(swapchain_handle: u64) -> i32

# Acquire next swapchain image for rendering
# Returns image index via out parameter
extern fn rt_vk_swapchain_acquire_next_image(
    swapchain_handle: u64,
    timeout_ns: u64,
    image_index_out: *mut u32
) -> i32

# Present the current swapchain image
extern fn rt_vk_swapchain_present(swapchain_handle: u64, image_index: u32) -> i32

# Get swapchain image count
extern fn rt_vk_swapchain_get_image_count(swapchain_handle: u64) -> u32

# Get swapchain extent (width, height)
extern fn rt_vk_swapchain_get_extent(
    swapchain_handle: u64,
    width_out: *mut u32,
    height_out: *mut u32
) -> i32

# =============================================================================
# High-Level Wrapper Types
# =============================================================================

pub struct VkDevice:
    handle: u64

impl VkDevice:
    pub fn new() -> Result[VkDevice, String]:
        let handle = rt_vk_device_create()
        if handle == 0:
            return Err("Failed to create Vulkan device")
        return Ok(VkDevice { handle: handle })

    pub fn sync(self) -> Result[(), String]:
        let result = rt_vk_device_sync(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to sync device: error {result}")
        return Ok(())

    pub fn free(self) -> Result[(), String]:
        let result = rt_vk_device_free(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to free device: error {result}")
        return Ok(())

pub struct VkBuffer:
    handle: u64
    size: u64

impl VkBuffer:
    pub fn new(device: &VkDevice, size: u64) -> Result[VkBuffer, String]:
        let handle = rt_vk_buffer_alloc(device.handle, size)
        if handle == 0:
            return Err("Failed to allocate buffer")
        return Ok(VkBuffer { handle: handle, size: size })

    pub fn upload(self, data: &Array[u8]) -> Result[(), String]:
        let result = rt_vk_buffer_upload(self.handle, data.as_ptr(), data.len() as u64)
        if result != VK_SUCCESS:
            return Err("Failed to upload to buffer: error {result}")
        return Ok(())

    pub fn download(self, size: u64) -> Result[Array[u8], String]:
        let mut data = Array::with_capacity(size as usize)
        data.resize(size as usize, 0)
        let result = rt_vk_buffer_download(self.handle, data.as_mut_ptr(), size)
        if result != VK_SUCCESS:
            return Err("Failed to download from buffer: error {result}")
        return Ok(data)

    pub fn free(self) -> Result[(), String]:
        let result = rt_vk_buffer_free(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to free buffer: error {result}")
        return Ok(())

pub struct VkWindow:
    handle: u64
    width: u32
    height: u32

impl VkWindow:
    pub fn new(title: &str, width: u32, height: u32) -> Result[VkWindow, String]:
        let handle = rt_vk_window_create(
            title.as_ptr(),
            title.len() as u64,
            width,
            height
        )
        if handle == 0:
            return Err("Failed to create window")
        return Ok(VkWindow { handle: handle, width: width, height: height })

    pub fn get_size(self) -> (u32, u32):
        let mut w: u32 = 0
        let mut h: u32 = 0
        rt_vk_window_get_size(self.handle, &mut w, &mut h)
        return (w, h)

    pub fn poll_event(self) -> Option[WindowEvent]:
        let mut event_type: i32 = 0
        let mut event_data: Array[u8] = Array::with_capacity(64)
        event_data.resize(64, 0)

        let result = rt_vk_window_poll_event(
            self.handle,
            &mut event_type,
            event_data.as_mut_ptr(),
            64
        )

        if result != VK_SUCCESS or event_type == 0:
            return None

        return Some(WindowEvent::from_raw(event_type, &event_data))

    pub fn free(self) -> Result[(), String]:
        let result = rt_vk_window_destroy(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to destroy window: error {result}")
        return Ok(())

pub struct VkSwapchain:
    handle: u64

impl VkSwapchain:
    pub fn new(device: &VkDevice, window: &VkWindow) -> Result[VkSwapchain, String]:
        let handle = rt_vk_swapchain_create(
            device.handle,
            window.handle,
            window.width,
            window.height
        )
        if handle == 0:
            return Err("Failed to create swapchain")
        return Ok(VkSwapchain { handle: handle })

    pub fn acquire_next_image(self, timeout_ns: u64) -> Result[u32, String]:
        let mut image_index: u32 = 0
        let result = rt_vk_swapchain_acquire_next_image(self.handle, timeout_ns, &mut image_index)
        if result == VK_ERROR_SWAPCHAIN_OUT_OF_DATE:
            return Err("Swapchain out of date")
        if result != VK_SUCCESS:
            return Err("Failed to acquire image: error {result}")
        return Ok(image_index)

    pub fn present(self, image_index: u32) -> Result[(), String]:
        let result = rt_vk_swapchain_present(self.handle, image_index)
        if result == VK_ERROR_SWAPCHAIN_OUT_OF_DATE:
            return Err("Swapchain out of date")
        if result != VK_SUCCESS:
            return Err("Failed to present: error {result}")
        return Ok(())

    pub fn recreate(self, width: u32, height: u32) -> Result[(), String]:
        let result = rt_vk_swapchain_recreate(self.handle, width, height)
        if result != VK_SUCCESS:
            return Err("Failed to recreate swapchain: error {result}")
        return Ok(())

    pub fn free(self) -> Result[(), String]:
        let result = rt_vk_swapchain_destroy(self.handle)
        if result != VK_SUCCESS:
            return Err("Failed to destroy swapchain: error {result}")
        return Ok(())

pub enum WindowEvent:
    None
    Resize(u32, u32)          # (width, height)
    Close
    KeyPress(u32, u32)        # (key, modifiers)
    KeyRelease(u32, u32)      # (key, modifiers)
    MouseMove(i32, i32)       # (x, y)
    MouseButton(u32, bool, i32, i32)  # (button, pressed, x, y)

impl WindowEvent:
    pub fn from_raw(event_type: i32, data: &Array[u8]) -> WindowEvent:
        match event_type:
            case 0: return WindowEvent::None
            case 1:
                # Resize event: data[0..4] = width, data[4..8] = height
                let width = read_u32_le(data, 0)
                let height = read_u32_le(data, 4)
                return WindowEvent::Resize(width, height)
            case 2:
                return WindowEvent::Close
            case 3:
                let key = read_u32_le(data, 0)
                let mods = read_u32_le(data, 4)
                return WindowEvent::KeyPress(key, mods)
            case 4:
                let key = read_u32_le(data, 0)
                let mods = read_u32_le(data, 4)
                return WindowEvent::KeyRelease(key, mods)
            case 5:
                let x = read_i32_le(data, 0)
                let y = read_i32_le(data, 4)
                return WindowEvent::MouseMove(x, y)
            case 6:
                let button = read_u32_le(data, 0)
                let pressed = data[4] != 0
                let x = read_i32_le(data, 8)
                let y = read_i32_le(data, 12)
                return WindowEvent::MouseButton(button, pressed, x, y)
            case _:
                return WindowEvent::None

# Helper functions for reading little-endian values
fn read_u32_le(data: &Array[u8], offset: usize) -> u32:
    return (data[offset] as u32)
         | ((data[offset + 1] as u32) << 8)
         | ((data[offset + 2] as u32) << 16)
         | ((data[offset + 3] as u32) << 24)

fn read_i32_le(data: &Array[u8], offset: usize) -> i32:
    return read_u32_le(data, offset) as i32
