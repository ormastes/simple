# Immediate Mode GUI - egui-style API
#
# Provides an immediate mode GUI paradigm where UI is rebuilt every frame.
# Simpler mental model than retained mode - no state management needed.
# Integrates with existing renderers (Browser, Electron, VSCode, Native, Vulkan).
#
# Key Features:
#   - Stateless API: UI declared in render loop
#   - Automatic layout: Stacking containers
#   - Built-in widgets: Button, Slider, TextEdit, Checkbox, etc.
#   - Response system: Immediate interaction feedback
#   - No manual event handling: Widget functions return interaction state
#
# Example:
#   loop:
#       let ui = ImGui::new()
#       ui.window("Demo Window"):
#           if ui.button("Click me!"):
#               println("Button clicked!")
#           ui.label("Counter: {}", counter)
#           ui.slider("Value", &mut value, 0.0, 100.0)
#       ui.render(renderer)

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.renderer.*

# =============================================================================
# Immediate Mode GUI Context
# =============================================================================

pub struct ImGui:
    # Render state
    ctx: ImGuiContext
    current_window: Option[WindowState]
    current_container: Option[ContainerId]

    # Layout state
    cursor: Point2D
    layout_stack: Array[LayoutInfo]

    # Interaction state
    hot_id: Option[WidgetId]     # Widget under cursor
    active_id: Option[WidgetId]  # Widget being interacted with
    keyboard_focus: Option[WidgetId]

    # Input state
    mouse_pos: Point2D
    mouse_down: bool
    mouse_clicked: bool
    keys_down: Set[KeyCode]

    # ID generation
    id_stack: Array[u64]
    next_id: u64

# Persistent context (survives frames)
struct ImGuiContext:
    windows: Dict[String, WindowState]
    widget_state: Dict[WidgetId, WidgetState]
    last_frame_time: f64
    delta_time: f64

# Window state
struct WindowState:
    id: String
    title: String
    pos: Point2D
    size: Size2D
    collapsed: bool
    focused: bool
    dragging: bool
    drag_offset: Point2D

# Widget identifier (hash-based)
type WidgetId = u64

# Widget state (persistent between frames)
struct WidgetState:
    value: Any  # Stored value (for sliders, inputs, etc.)
    animation: f32  # Animation progress [0.0, 1.0]
    last_interaction: f64

# Container identifier
type ContainerId = u64

# Layout info
struct LayoutInfo:
    direction: LayoutDirection
    spacing: f32
    padding: f32
    available_width: f32
    available_height: f32
    cursor_x: f32
    cursor_y: f32

enum LayoutDirection:
    Vertical
    Horizontal

# Point in 2D space
struct Point2D:
    x: f32
    y: f32

impl Point2D:
    fn new(x: f32, y: f32) -> Point2D:
        return Point2D { x: x, y: y }

# 2D size
struct Size2D:
    width: f32
    height: f32

impl Size2D:
    fn new(w: f32, h: f32) -> Size2D:
        return Size2D { width: w, height: h }

# Widget response
pub struct Response:
    id: WidgetId
    rect: Rect
    clicked: bool
    hovered: bool
    dragged: bool
    drag_delta: Point2D
    has_keyboard_focus: bool
    changed: bool  # Value changed (for inputs)

struct Rect:
    x: f32
    y: f32
    width: f32
    height: f32

impl Rect:
    fn new(x: f32, y: f32, w: f32, h: f32) -> Rect:
        return Rect { x: x, y: y, width: w, height: h }

    fn contains(self, p: Point2D) -> bool:
        return p.x >= self.x and p.x < self.x + self.width
            and p.y >= self.y and p.y < self.y + self.height

# =============================================================================
# ImGui Implementation
# =============================================================================

impl ImGui:
    # Create new ImGui instance
    pub fn new() -> ImGui:
        return ImGui::with_context(ImGuiContext::new())

    pub fn with_context(ctx: ImGuiContext) -> ImGui:
        return ImGui {
            ctx: ctx,
            current_window: None,
            current_container: None,
            cursor: Point2D::new(0.0, 0.0),
            layout_stack: [],
            hot_id: None,
            active_id: None,
            keyboard_focus: None,
            mouse_pos: Point2D::new(0.0, 0.0),
            mouse_down: false,
            mouse_clicked: false,
            keys_down: Set::new(),
            id_stack: [],
            next_id: 0
        }

    # Begin new frame
    pub fn begin_frame(self):
        self.mouse_clicked = false
        self.hot_id = None

    # End frame and generate render commands
    pub fn end_frame(self):
        # Cleanup per-frame state
        if not self.mouse_down:
            self.active_id = None

    # Create a window
    pub fn window(self, title: &str) -> WindowScope:
        let window_id = self.hash_str(title)

        # Get or create window state
        let mut win = self.ctx.windows.get(title).cloned().unwrap_or_else(||:
            WindowState {
                id: title.to_string(),
                title: title.to_string(),
                pos: Point2D::new(100.0, 100.0),
                size: Size2D::new(300.0, 400.0),
                collapsed: false,
                focused: false,
                dragging: false,
                drag_offset: Point2D::new(0.0, 0.0)
            }
        )

        # Handle window dragging
        let title_bar_rect = Rect::new(win.pos.x, win.pos.y, win.size.width, 30.0)
        if title_bar_rect.contains(self.mouse_pos) and self.mouse_clicked:
            win.dragging = true
            win.drag_offset = Point2D::new(
                self.mouse_pos.x - win.pos.x,
                self.mouse_pos.y - win.pos.y
            )

        if win.dragging:
            if self.mouse_down:
                win.pos.x = self.mouse_pos.x - win.drag_offset.x
                win.pos.y = self.mouse_pos.y - win.drag_offset.y
            else:
                win.dragging = false

        # Setup layout
        self.cursor = Point2D::new(win.pos.x + 10.0, win.pos.y + 40.0)
        self.push_layout(LayoutInfo {
            direction: LayoutDirection::Vertical,
            spacing: 5.0,
            padding: 10.0,
            available_width: win.size.width - 20.0,
            available_height: win.size.height - 50.0,
            cursor_x: self.cursor.x,
            cursor_y: self.cursor.y
        })

        self.current_window = Some(win)
        return WindowScope { gui: self }

# Window scope (RAII-style)
pub struct WindowScope:
    gui: &mut ImGui

impl WindowScope:
    pub fn end(self):
        if let Some(win) = &self.gui.current_window:
            self.gui.ctx.windows.insert(win.id.clone(), win.clone())
        self.gui.current_window = None
        self.gui.pop_layout()

# =============================================================================
# Widget Functions
# =============================================================================

impl ImGui:
    # Label widget (non-interactive text)
    pub fn label(self, text: &str) -> Response:
        let id = self.generate_id()
        let layout = self.current_layout()

        let size = Size2D::new(layout.available_width, 20.0)
        let rect = Rect::new(self.cursor.x, self.cursor.y, size.width, size.height)

        # TODO: Emit render command for text

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: false,
            hovered: false,
            dragged: false,
            drag_delta: Point2D::new(0.0, 0.0),
            has_keyboard_focus: false,
            changed: false
        }

    # Button widget
    pub fn button(self, label: &str) -> bool:
        let id = self.generate_id()
        let layout = self.current_layout()

        let size = Size2D::new(layout.available_width, 30.0)
        let rect = Rect::new(self.cursor.x, self.cursor.y, size.width, size.height)

        let hovered = rect.contains(self.mouse_pos)
        let clicked = hovered and self.mouse_clicked

        if hovered:
            self.hot_id = Some(id)

        if clicked:
            self.active_id = Some(id)

        # TODO: Emit render command for button

        self.advance_cursor(size.height + layout.spacing)

        return clicked

    # Checkbox widget
    pub fn checkbox(self, label: &str, checked: &mut bool) -> Response:
        let id = self.generate_id()
        let layout = self.current_layout()

        let size = Size2D::new(20.0, 20.0)
        let rect = Rect::new(self.cursor.x, self.cursor.y, size.width, size.height)

        let hovered = rect.contains(self.mouse_pos)
        let clicked = hovered and self.mouse_clicked

        if clicked:
            *checked = not *checked

        # TODO: Emit render command for checkbox

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: clicked,
            hovered: hovered,
            dragged: false,
            drag_delta: Point2D::new(0.0, 0.0),
            has_keyboard_focus: false,
            changed: clicked
        }

    # Slider widget
    pub fn slider(self, label: &str, value: &mut f32, min: f32, max: f32) -> Response:
        let id = self.generate_id()
        let layout = self.current_layout()

        let size = Size2D::new(layout.available_width, 20.0)
        let rect = Rect::new(self.cursor.x, self.cursor.y, size.width, size.height)

        let hovered = rect.contains(self.mouse_pos)
        let mut changed = false

        if hovered and self.mouse_down:
            self.active_id = Some(id)

        if self.active_id == Some(id) and self.mouse_down:
            # Calculate value from mouse position
            let normalized = (self.mouse_pos.x - rect.x) / rect.width
            let clamped = normalized.max(0.0).min(1.0)
            *value = min + (max - min) * clamped
            changed = true

        # TODO: Emit render command for slider

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: false,
            hovered: hovered,
            dragged: self.active_id == Some(id),
            drag_delta: Point2D::new(0.0, 0.0),
            has_keyboard_focus: false,
            changed: changed
        }

    # Text input widget
    pub fn text_edit(self, label: &str, text: &mut String) -> Response:
        let id = self.generate_id()
        let layout = self.current_layout()

        let size = Size2D::new(layout.available_width, 30.0)
        let rect = Rect::new(self.cursor.x, self.cursor.y, size.width, size.height)

        let hovered = rect.contains(self.mouse_pos)
        let clicked = hovered and self.mouse_clicked
        let mut changed = false

        if clicked:
            self.keyboard_focus = Some(id)

        let has_focus = self.keyboard_focus == Some(id)

        if has_focus:
            # Handle text input
            for key in &self.keys_down:
                match key:
                    case KeyCode::Char(c):
                        text.push(*c)
                        changed = true
                    case KeyCode::Backspace:
                        if not text.is_empty():
                            text.pop()
                            changed = true
                    case _:
                        pass

        # TODO: Emit render command for text input

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: clicked,
            hovered: hovered,
            dragged: false,
            drag_delta: Point2D::new(0.0, 0.0),
            has_keyboard_focus: has_focus,
            changed: changed
        }

    # Horizontal separator
    pub fn separator(self):
        let layout = self.current_layout()
        # TODO: Emit render command for separator line
        self.advance_cursor(10.0)

    # Collapsing header
    pub fn collapsing_header(self, label: &str, default_open: bool) -> HeaderScope:
        let id = self.generate_id()
        let layout = self.current_layout()

        # Get or create state
        let mut is_open = self.ctx.widget_state.get(&id)
            .and_then(|s|: s.value.as_bool())
            .unwrap_or(default_open)

        let size = Size2D::new(layout.available_width, 25.0)
        let rect = Rect::new(self.cursor.x, self.cursor.y, size.width, size.height)

        let hovered = rect.contains(self.mouse_pos)
        let clicked = hovered and self.mouse_clicked

        if clicked:
            is_open = not is_open
            self.ctx.widget_state.insert(id, WidgetState {
                value: Any::Bool(is_open),
                animation: 0.0,
                last_interaction: self.ctx.last_frame_time
            })

        # TODO: Emit render command for header

        self.advance_cursor(size.height + layout.spacing)

        return HeaderScope {
            gui: self,
            is_open: is_open
        }

# Header scope
pub struct HeaderScope:
    gui: &mut ImGui
    is_open: bool

impl HeaderScope:
    pub fn is_open(self) -> bool:
        return self.is_open

    pub fn end(self):
        pass  # Nothing to clean up

# =============================================================================
# Layout Helpers
# =============================================================================

impl ImGui:
    fn push_layout(self, info: LayoutInfo):
        self.layout_stack.push(info)

    fn pop_layout(self):
        self.layout_stack.pop()

    fn current_layout(self) -> &LayoutInfo:
        return &self.layout_stack[self.layout_stack.len() - 1]

    fn advance_cursor(self, amount: f32):
        let layout = self.current_layout()
        match layout.direction:
            case LayoutDirection::Vertical:
                self.cursor.y = self.cursor.y + amount
            case LayoutDirection::Horizontal:
                self.cursor.x = self.cursor.x + amount

# =============================================================================
# ID Generation
# =============================================================================

impl ImGui:
    fn generate_id(self) -> WidgetId:
        let id = self.next_id
        self.next_id = self.next_id + 1
        return id

    fn hash_str(self, s: &str) -> u64:
        let mut hash: u64 = 5381
        for c in s.chars():
            hash = ((hash << 5) + hash) + (c as u64)
        return hash

# =============================================================================
# Context Implementation
# =============================================================================

impl ImGuiContext:
    fn new() -> ImGuiContext:
        return ImGuiContext {
            windows: Dict::new(),
            widget_state: Dict::new(),
            last_frame_time: 0.0,
            delta_time: 0.0
        }

# =============================================================================
# Input Handling
# =============================================================================

impl ImGui:
    pub fn handle_mouse_move(self, x: f32, y: f32):
        self.mouse_pos = Point2D::new(x, y)

    pub fn handle_mouse_down(self, x: f32, y: f32):
        self.mouse_pos = Point2D::new(x, y)
        self.mouse_down = true
        self.mouse_clicked = true

    pub fn handle_mouse_up(self, x: f32, y: f32):
        self.mouse_pos = Point2D::new(x, y)
        self.mouse_down = false

    pub fn handle_key_down(self, key: KeyCode):
        self.keys_down.insert(key)

    pub fn handle_key_up(self, key: KeyCode):
        self.keys_down.remove(&key)

# Placeholder for Any type (would use real Any in production)
enum Any:
    Bool(bool)
    Int(i64)
    Float(f64)
    String(String)

impl Any:
    fn as_bool(self) -> Option[bool]:
        match self:
            case Any::Bool(b): return Some(b)
            case _: return None

# Key codes (simplified)
enum KeyCode:
    Char(char)
    Enter
    Backspace
    Escape
    Tab
    Up
    Down
    Left
    Right
