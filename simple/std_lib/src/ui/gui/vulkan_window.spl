# Vulkan Window Management
#
# High-level wrapper around Vulkan window FFI functions.
# Provides type-safe window creation, event handling, and fullscreen management.
#
# Implementation Status: Phase 5 - Event Handling Complete
# - Window creation and destruction
# - Window property queries (size)
# - Fullscreen mode control
# - Event polling and waiting (7 event types)

use core.*

# =============================================================================
# Window - High-Level Window Management
# =============================================================================

pub struct Window:
    handle: i64              # FFI window handle
    width: u32               # Current width
    height: u32              # Current height
    title: String            # Window title

impl Window:
    # Create a new window
    #
    # Example:
    #   let window = Window::new(1920, 1080, "My Application")?
    #
    pub fn new(width: u32, height: u32, title: &str) -> Result[Window, String]:
        let handle = rt_vk_window_create(0, width, height, title.as_ptr(), title.len() as u64)

        if handle < 0:
            return Err("Failed to create window: error code " + str(handle))

        return Ok(Window {
            handle: handle,
            width: width,
            height: height,
            title: title.to_string()
        })

    # Get window handle (for FFI operations)
    pub fn handle(self) -> i64:
        return self.handle

    # Get current window size
    #
    # Example:
    #   let (width, height) = window.get_size()?
    #
    pub fn get_size(self) -> Result[(u32, u32), String]:
        let mut width: u32 = 0
        let mut height: u32 = 0

        let result = rt_vk_window_get_size(self.handle, &mut width, &mut height)

        if result != 0:
            return Err("Failed to get window size: error code " + str(result))

        return Ok((width, height))

    # Update internal size cache (call after resize event)
    fn update_size(mut self, width: u32, height: u32):
        self.width = width
        self.height = height

    # Set fullscreen mode
    #
    # Modes:
    # - Windowed: Normal window with title bar
    # - Borderless: Fullscreen without mode change
    # - Exclusive: Exclusive fullscreen (requires mode setting)
    #
    # Example:
    #   window.set_fullscreen(FullscreenMode::Borderless)?
    #
    pub fn set_fullscreen(self, mode: FullscreenMode) -> Result[(), String]:
        let mode_code = match mode:
            case FullscreenMode::Windowed: 0
            case FullscreenMode::Borderless: 1
            case FullscreenMode::Exclusive: 2

        let result = rt_vk_window_set_fullscreen(self.handle, mode_code)

        if result != 0:
            return Err("Failed to set fullscreen mode: error code " + str(result))

        return Ok(())

    # Poll for events (non-blocking)
    #
    # Returns Some(event) if event is available, None otherwise.
    #
    # Example:
    #   while let Some(event) = window.poll_event():
    #       match event:
    #           case WindowEvent::CloseRequested:
    #               return
    #           case WindowEvent::Resized(w, h):
    #               resize_swapchain(w, h)
    #
    pub fn poll_event(mut self) -> Option[WindowEvent]:
        let mut event_window: i64 = 0
        let mut event_type: i32 = 0
        let mut data = ByteArray::new(16)  # Max event data size

        let result = rt_vk_window_poll_event(
            &mut event_window,
            &mut event_type,
            data.as_mut_ptr(),
            16
        )

        if result <= 0:
            return None  # No event or error

        # Parse event based on type code
        return Some(Self::parse_event(event_type, &data))

    # Wait for event with timeout (blocking)
    #
    # timeout_ms: Maximum time to wait in milliseconds
    # Returns Some(event) if event received, None on timeout.
    #
    # Example:
    #   # Wait up to 16ms for event (60 FPS)
    #   if let Some(event) = window.wait_event(16):
    #       handle_event(event)
    #   else:
    #       render_frame()
    #
    pub fn wait_event(mut self, timeout_ms: u64) -> Option[WindowEvent]:
        let mut event_window: i64 = 0
        let mut event_type: i32 = 0
        let mut data = ByteArray::new(16)  # Max event data size

        let result = rt_vk_window_wait_event(
            timeout_ms,
            &mut event_window,
            &mut event_type,
            data.as_mut_ptr(),
            16
        )

        if result <= 0:
            return None  # Timeout or error

        # Parse event based on type code
        return Some(Self::parse_event(event_type, &data))

    # Parse event data based on type code
    fn parse_event(event_type: i32, data: &ByteArray) -> WindowEvent:
        match event_type:
            case 1:  # Resized
                let width = data.read_u32(0)
                let height = data.read_u32(4)
                return WindowEvent::Resized(width, height)

            case 2:  # CloseRequested
                return WindowEvent::CloseRequested

            case 3:  # Focused
                let focused = data.read_u8(0) != 0
                return WindowEvent::Focused(focused)

            case 4:  # Moved
                let x = data.read_i32(0)
                let y = data.read_i32(4)
                return WindowEvent::Moved(x, y)

            case 10:  # MouseMoved
                let x = data.read_f64(0)
                let y = data.read_f64(8)
                return WindowEvent::MouseMoved(x, y)

            case 11:  # MouseButton
                let button = data.read_u32(0)
                let pressed = data.read_u8(4) != 0
                return WindowEvent::MouseButton(button, pressed)

            case 20:  # KeyEvent
                let key_code = data.read_u32(0)
                let pressed = data.read_u8(4) != 0
                return WindowEvent::KeyEvent(key_code, pressed)

            case _:  # Unknown event type
                return WindowEvent::Unknown

impl Drop for Window:
    fn drop(mut self):
        # Destroy window on drop
        let _ = rt_vk_window_destroy(self.handle)

# =============================================================================
# Window Event Types
# =============================================================================

pub enum WindowEvent:
    # Window was resized (width, height)
    Resized(u32, u32)

    # User requested to close the window
    CloseRequested

    # Window gained or lost focus
    Focused(bool)

    # Window was moved to new position (x, y)
    Moved(i32, i32)

    # Mouse cursor moved (x, y)
    MouseMoved(f64, f64)

    # Mouse button pressed or released (button, pressed)
    MouseButton(u32, bool)

    # Keyboard key pressed or released (key_code, pressed)
    KeyEvent(u32, bool)

    # Unknown event type (should not occur)
    Unknown

# =============================================================================
# Fullscreen Modes
# =============================================================================

pub enum FullscreenMode:
    # Normal windowed mode with title bar
    Windowed

    # Borderless fullscreen (fast mode switch, no exclusive access)
    Borderless

    # Exclusive fullscreen (requires video mode setting)
    Exclusive

# =============================================================================
# Helper Types
# =============================================================================

# ByteArray for event data serialization
struct ByteArray:
    data: Array[u8]

impl ByteArray:
    fn new(size: u64) -> ByteArray:
        return ByteArray {
            data: Array::with_capacity(size as usize)
        }

    fn as_mut_ptr(mut self) -> *mut u8:
        return self.data.as_mut_ptr()

    fn read_u8(self, offset: usize) -> u8:
        return self.data[offset]

    fn read_u32(self, offset: usize) -> u32:
        # Read little-endian u32
        let b0 = self.data[offset] as u32
        let b1 = self.data[offset + 1] as u32
        let b2 = self.data[offset + 2] as u32
        let b3 = self.data[offset + 3] as u32
        return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

    fn read_i32(self, offset: usize) -> i32:
        return self.read_u32(offset) as i32

    fn read_f64(self, offset: usize) -> f64:
        # Read little-endian f64 (reinterpret u64 bits as f64)
        let b0 = self.data[offset] as u64
        let b1 = self.data[offset + 1] as u64
        let b2 = self.data[offset + 2] as u64
        let b3 = self.data[offset + 3] as u64
        let b4 = self.data[offset + 4] as u64
        let b5 = self.data[offset + 5] as u64
        let b6 = self.data[offset + 6] as u64
        let b7 = self.data[offset + 7] as u64

        let bits = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24) |
                   (b4 << 32) | (b5 << 40) | (b6 << 48) | (b7 << 56)

        return f64::from_bits(bits)

# =============================================================================
# FFI Declarations - Window Management
# =============================================================================

# Create a Vulkan window with surface
#
# Returns window handle on success (positive i64), error code on failure (negative)
extern fn rt_vk_window_create(
    device_handle: u64,      # Currently unused (for future)
    width: u32,
    height: u32,
    title_ptr: *const u8,
    title_len: u64
) -> i64

# Destroy a window
#
# Returns 0 on success, error code on failure
extern fn rt_vk_window_destroy(window_handle: i64) -> i32

# Get window size
#
# Returns 0 on success, error code on failure
extern fn rt_vk_window_get_size(
    window_handle: i64,
    out_width: *mut u32,
    out_height: *mut u32
) -> i32

# Set window fullscreen mode
#
# mode: 0 = windowed, 1 = borderless, 2 = exclusive
# Returns 0 on success, error code on failure
extern fn rt_vk_window_set_fullscreen(window_handle: i64, mode: i32) -> i32

# Poll for window events (non-blocking)
#
# Returns event type (positive) if event available, 0 if no event, negative on error
# Event data is written to out parameters
#
# Event types:
# 1 = Resized (data: u32 width, u32 height)
# 2 = CloseRequested (no data)
# 3 = Focused (data: u8 focused)
# 4 = Moved (data: i32 x, i32 y)
# 10 = MouseMoved (data: f64 x, f64 y)
# 11 = MouseButton (data: u32 button, u8 pressed)
# 20 = KeyEvent (data: u32 key_code, u8 pressed)
extern fn rt_vk_window_poll_event(
    out_window: *mut i64,
    out_type: *mut i32,
    out_data_ptr: *mut u8,
    out_data_len: u64
) -> i32

# Wait for window event with timeout
#
# timeout_ms: timeout in milliseconds
# Returns event type (positive) if event available, 0 on timeout, negative on error
# Event types: same as rt_vk_window_poll_event
extern fn rt_vk_window_wait_event(
    timeout_ms: u64,
    out_window: *mut i64,
    out_type: *mut i32,
    out_data_ptr: *mut u8,
    out_data_len: u64
) -> i32

# =============================================================================
# Usage Examples
# =============================================================================

# Example 1: Basic window creation and event loop
#
# fn main():
#     let window = Window::new(1920, 1080, "My Application")?
#
#     let mut running = true
#     while running:
#         # Poll events
#         while let Some(event) = window.poll_event():
#             match event:
#                 case WindowEvent::CloseRequested:
#                     running = false
#                 case WindowEvent::Resized(width, height):
#                     print("Window resized to " + str(width) + "x" + str(height))
#                 case WindowEvent::KeyEvent(key, pressed):
#                     if pressed:
#                         handle_key_press(key)
#
#         # Render frame
#         render_frame()

# Example 2: Event-driven rendering with timeout
#
# fn game_loop(window: &mut Window):
#     let mut running = true
#
#     while running:
#         # Wait for event or 16ms timeout (60 FPS)
#         match window.wait_event(16):
#             case Some(WindowEvent::CloseRequested):
#                 running = false
#             case Some(WindowEvent::MouseMoved(x, y)):
#                 update_cursor_position(x, y)
#             case Some(event):
#                 handle_event(event)
#             case None:
#                 # Timeout - render frame
#                 render_frame()

# Example 3: Fullscreen toggle
#
# fn toggle_fullscreen(window: &mut Window, is_fullscreen: &mut bool):
#     if *is_fullscreen:
#         window.set_fullscreen(FullscreenMode::Windowed)?
#         *is_fullscreen = false
#     else:
#         window.set_fullscreen(FullscreenMode::Borderless)?
#         *is_fullscreen = true
