# Vulkan Graphics Pipeline - Phase 1 Implementation
#
# Graphics pipeline configuration with smart defaults.
# Follows builder pattern for zero-config initialization.
#
# Implementation Status: Phase 1 - Task 5
# - Pipeline creation with smart defaults
# - Vertex input state from reflection
# - Rasterization state with sensible defaults
# - Dynamic viewport/scissor

use core.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_shaders.*

# =============================================================================
# Graphics Pipeline - Complete Pipeline with Smart Defaults
# =============================================================================

pub struct GraphicsPipeline:
    # Core handles
    device: VkDevice
    pipeline: VkPipeline
    pipeline_layout: VkPipelineLayout

impl GraphicsPipeline:
    # Create pipeline with smart defaults
    pub fn new(
        device: &VulkanDevice,
        render_pass: &RenderPass,
        shaders: &ShaderStages,
    ) -> Result<GraphicsPipeline, text>:
        # Create pipeline layout (no descriptors for now)
        val pipeline_layout = vulkan_create_pipeline_layout(device.device)?

        # Build pipeline with smart defaults
        val pipeline_info = PipelineBuilder::new()
            .shaders(shaders)
            .vertex_input_auto()  # Auto-detect from #[vertex] macro
            .input_assembly_triangles()
            .rasterization_default()
            .viewport_dynamic()
            .multisample_none()
            .color_blend_none()
            .render_pass(render_pass)
            .layout(pipeline_layout)
            .build()

        # Create pipeline via FFI
        val pipeline = vulkan_create_graphics_pipeline(device.device, &pipeline_info)?

        Ok(GraphicsPipeline {
            device: device.device,
            pipeline: pipeline,
            pipeline_layout: pipeline_layout,
        })

    # Cleanup
    pub async fn destroy(&self):
        await vulkan_destroy_pipeline_async(self.device, self.pipeline)
        await vulkan_destroy_pipeline_layout_async(self.device, self.pipeline_layout)

    pub fn get_pipeline(self) -> VkPipeline:
        """Get Vulkan pipeline handle.

        Returns:
            Pipeline handle

        Example:
            val pipeline = GraphicsPipeline::new(&device, &rp, &shaders)?
            val handle = pipeline.get_pipeline()
        """
        self.pipeline

    pub fn get_layout(self) -> VkPipelineLayout:
        """Get pipeline layout handle.

        Returns:
            Layout handle

        Example:
            val pipeline = GraphicsPipeline::new(&device, &rp, &shaders)?
            val layout = pipeline.get_layout()
        """
        self.pipeline_layout

    pub fn is_valid(self) -> bool:
        """Check if pipeline is valid.

        Returns:
            True if both handles are non-zero

        Example:
            val pipeline = GraphicsPipeline::new(&device, &rp, &shaders)?
            assert(pipeline.is_valid())
        """
        self.pipeline != 0 and self.pipeline_layout != 0

    pub fn summary(self) -> text:
        """Get graphics pipeline summary.

        Returns:
            Human-readable summary

        Example:
            val pipeline = GraphicsPipeline::new(&device, &rp, &shaders)?
            print(pipeline.summary())
        """
        return "GraphicsPipeline: pipeline={self.pipeline}, layout={self.pipeline_layout}"

# =============================================================================
# Pipeline Builder - Fluent API for Pipeline Configuration
# =============================================================================

pub struct PipelineBuilder:
    # Shader stages
    shader_stages: Option<ShaderStages>

    # Vertex input
    vertex_bindings: Array<VkVertexInputBindingDescription>
    vertex_attributes: Array<VkVertexInputAttributeDescription>

    # Input assembly
    topology: VkPrimitiveTopology
    primitive_restart: bool

    # Rasterization
    polygon_mode: VkPolygonMode
    cull_mode: VkCullModeFlags
    front_face: VkFrontFace
    line_width: f32

    # Viewport (dynamic by default)
    dynamic_viewport: bool

    # Multisample
    sample_count: VkSampleCountFlagBits
    sample_shading: bool

    # Color blend
    blend_enable: bool

    # Render pass
    render_pass: Option<VkRenderPass>
    subpass: u32

    # Layout
    pipeline_layout: Option<VkPipelineLayout>

impl PipelineBuilder:
    pub fn new() -> PipelineBuilder:
        PipelineBuilder {
            shader_stages: None,
            vertex_bindings: [],
            vertex_attributes: [],
            topology: VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
            primitive_restart: false,
            polygon_mode: VK_POLYGON_MODE_FILL,
            cull_mode: VK_CULL_MODE_BACK_BIT,
            front_face: VK_FRONT_FACE_COUNTER_CLOCKWISE,
            line_width: 1.0,
            dynamic_viewport: true,
            sample_count: VK_SAMPLE_COUNT_1_BIT,
            sample_shading: false,
            blend_enable: false,
            render_pass: None,
            subpass: 0,
            pipeline_layout: None,
        }

    # Set shader stages
    pub fn shaders(mut self, shaders: &ShaderStages) -> PipelineBuilder:
        self.shader_stages = Some(shaders.clone())
        self

    # Auto-detect vertex input from #[vertex] macro reflection
    pub fn vertex_input_auto(mut self) -> PipelineBuilder:
        # TODO: [ui][P3] Use reflection to auto-detect vertex format
        # For now, use default position + color layout
        self.vertex_bindings = [
            VkVertexInputBindingDescription {
                binding: 0,
                stride: 28,  # 3 floats (position) + 4 floats (color) = 7 * 4 bytes
                input_rate: VK_VERTEX_INPUT_RATE_VERTEX,
            }
        ]

        self.vertex_attributes = [
            # Position (location = 0)
            VkVertexInputAttributeDescription {
                location: 0,
                binding: 0,
                format: VK_FORMAT_R32G32B32_SFLOAT,
                offset: 0,
            },
            # Color (location = 1)
            VkVertexInputAttributeDescription {
                location: 1,
                binding: 0,
                format: VK_FORMAT_R32G32B32A32_SFLOAT,
                offset: 12,
            },
        ]

        self

    # Set custom vertex input
    pub fn vertex_input(
        mut self,
        bindings: Array<VkVertexInputBindingDescription>,
        attributes: Array<VkVertexInputAttributeDescription>
    ) -> PipelineBuilder:
        self.vertex_bindings = bindings
        self.vertex_attributes = attributes
        self

    # Input assembly - triangle list (default)
    pub fn input_assembly_triangles(mut self) -> PipelineBuilder:
        self.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
        self.primitive_restart = false
        self

    # Input assembly - triangle strip
    pub fn input_assembly_triangle_strip(mut self) -> PipelineBuilder:
        self.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP
        self.primitive_restart = true
        self

    # Input assembly - line list
    pub fn input_assembly_lines(mut self) -> PipelineBuilder:
        self.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST
        self.primitive_restart = false
        self

    # Rasterization - default settings
    pub fn rasterization_default(mut self) -> PipelineBuilder:
        self.polygon_mode = VK_POLYGON_MODE_FILL
        self.cull_mode = VK_CULL_MODE_BACK_BIT
        self.front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
        self.line_width = 1.0
        self

    # Rasterization - wireframe
    pub fn rasterization_wireframe(mut self) -> PipelineBuilder:
        self.polygon_mode = VK_POLYGON_MODE_LINE
        self.cull_mode = VK_CULL_MODE_NONE
        self.line_width = 1.0
        self

    # Viewport - dynamic (recommended)
    pub fn viewport_dynamic(mut self) -> PipelineBuilder:
        self.dynamic_viewport = true
        self

    # Multisample - none (default)
    pub fn multisample_none(mut self) -> PipelineBuilder:
        self.sample_count = VK_SAMPLE_COUNT_1_BIT
        self.sample_shading = false
        self

    # Multisample - MSAA 4x
    pub fn multisample_4x(mut self) -> PipelineBuilder:
        self.sample_count = VK_SAMPLE_COUNT_4_BIT
        self.sample_shading = true
        self

    # Color blend - none (default)
    pub fn color_blend_none(mut self) -> PipelineBuilder:
        self.blend_enable = false
        self

    # Color blend - alpha blending
    pub fn color_blend_alpha(mut self) -> PipelineBuilder:
        self.blend_enable = true
        self

    # Set render pass
    pub fn render_pass(mut self, render_pass: &RenderPass) -> PipelineBuilder:
        self.render_pass = Some(render_pass.render_pass)
        self

    # Set pipeline layout
    pub fn layout(mut self, layout: VkPipelineLayout) -> PipelineBuilder:
        self.pipeline_layout = Some(layout)
        self

    # Build pipeline info
    pub fn build(self) -> VkGraphicsPipelineCreateInfo:
        # Validate required fields
        if self.shader_stages.is_none():
            panic("Shader stages not set")
        if self.render_pass.is_none():
            panic("Render pass not set")
        if self.pipeline_layout.is_none():
            panic("Pipeline layout not set")

        VkGraphicsPipelineCreateInfo {
            # Shader stages
            shader_stages: self.shader_stages.unwrap().get_stage_infos(),

            # Vertex input
            vertex_bindings: self.vertex_bindings,
            vertex_attributes: self.vertex_attributes,

            # Input assembly
            topology: self.topology,
            primitive_restart: self.primitive_restart,

            # Rasterization
            polygon_mode: self.polygon_mode,
            cull_mode: self.cull_mode,
            front_face: self.front_face,
            line_width: self.line_width,

            # Viewport
            dynamic_viewport: self.dynamic_viewport,

            # Multisample
            sample_count: self.sample_count,
            sample_shading: self.sample_shading,

            # Color blend
            blend_enable: self.blend_enable,

            # Render pass
            render_pass: self.render_pass.unwrap(),
            subpass: self.subpass,

            # Layout
            pipeline_layout: self.pipeline_layout.unwrap(),
        }

# =============================================================================
# FFI Declarations
# =============================================================================

# Pipeline creation/destruction
extern fn vulkan_create_pipeline_layout(device: VkDevice) -> Result<VkPipelineLayout, text>
extern fn vulkan_create_graphics_pipeline(device: VkDevice, info: &VkGraphicsPipelineCreateInfo) -> Result<VkPipeline, text>
extern fn vulkan_destroy_pipeline_async(device: VkDevice, pipeline: VkPipeline) -> Future<Result<(), text>>
extern fn vulkan_destroy_pipeline_layout_async(device: VkDevice, layout: VkPipelineLayout) -> Future<Result<(), text>>

# =============================================================================
# Vulkan Constants - Topology
# =============================================================================

pub const VK_PRIMITIVE_TOPOLOGY_POINT_LIST: u32 = 0
pub const VK_PRIMITIVE_TOPOLOGY_LINE_LIST: u32 = 1
pub const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP: u32 = 2
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: u32 = 3
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP: u32 = 4
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN: u32 = 5

# Polygon mode
pub const VK_POLYGON_MODE_FILL: u32 = 0
pub const VK_POLYGON_MODE_LINE: u32 = 1
pub const VK_POLYGON_MODE_POINT: u32 = 2

# Cull mode
pub const VK_CULL_MODE_NONE: u32 = 0
pub const VK_CULL_MODE_FRONT_BIT: u32 = 0x00000001
pub const VK_CULL_MODE_BACK_BIT: u32 = 0x00000002
pub const VK_CULL_MODE_FRONT_AND_BACK: u32 = 0x00000003

# Front face
pub const VK_FRONT_FACE_COUNTER_CLOCKWISE: u32 = 0
pub const VK_FRONT_FACE_CLOCKWISE: u32 = 1

# Sample count
pub const VK_SAMPLE_COUNT_1_BIT: u32 = 0x00000001
pub const VK_SAMPLE_COUNT_2_BIT: u32 = 0x00000002
pub const VK_SAMPLE_COUNT_4_BIT: u32 = 0x00000004
pub const VK_SAMPLE_COUNT_8_BIT: u32 = 0x00000008
pub const VK_SAMPLE_COUNT_16_BIT: u32 = 0x00000010

# Vertex input rate
pub const VK_VERTEX_INPUT_RATE_VERTEX: u32 = 0
pub const VK_VERTEX_INPUT_RATE_INSTANCE: u32 = 1

# Formats
pub const VK_FORMAT_R32G32B32_SFLOAT: u32 = 106
pub const VK_FORMAT_R32G32B32A32_SFLOAT: u32 = 109

# =============================================================================
# Supporting Types
# =============================================================================

# Opaque FFI types
pub type VkPipeline = i64
pub type VkPipelineLayout = i64
pub type VkPrimitiveTopology = u32
pub type VkPolygonMode = u32
pub type VkCullModeFlags = u32
pub type VkFrontFace = u32
pub type VkSampleCountFlagBits = u32

pub struct VkVertexInputBindingDescription:
    binding: u32
    stride: u32
    input_rate: u32

impl VkVertexInputBindingDescription:
    pub fn get_binding(self) -> u32:
        """Get binding index.

        Returns:
            Binding index

        Example:
            val desc = VkVertexInputBindingDescription { binding: 0, stride: 28, input_rate: VK_VERTEX_INPUT_RATE_VERTEX }
            assert(desc.get_binding() == 0)
        """
        self.binding

    pub fn get_stride(self) -> u32:
        """Get vertex stride in bytes.

        Returns:
            Stride in bytes

        Example:
            val desc = VkVertexInputBindingDescription { binding: 0, stride: 28, input_rate: VK_VERTEX_INPUT_RATE_VERTEX }
            assert(desc.get_stride() == 28)
        """
        self.stride

    pub fn is_per_vertex(self) -> bool:
        """Check if input rate is per-vertex.

        Returns:
            True if per-vertex input

        Example:
            val desc = VkVertexInputBindingDescription { binding: 0, stride: 28, input_rate: VK_VERTEX_INPUT_RATE_VERTEX }
            assert(desc.is_per_vertex())
        """
        self.input_rate == VK_VERTEX_INPUT_RATE_VERTEX

    pub fn is_per_instance(self) -> bool:
        """Check if input rate is per-instance.

        Returns:
            True if per-instance input

        Example:
            val desc = VkVertexInputBindingDescription { binding: 1, stride: 64, input_rate: VK_VERTEX_INPUT_RATE_INSTANCE }
            assert(desc.is_per_instance())
        """
        self.input_rate == VK_VERTEX_INPUT_RATE_INSTANCE

    pub fn is_large_stride(self) -> bool:
        """Check if stride is large (>128 bytes).

        Returns:
            True if stride exceeds 128 bytes

        Example:
            val desc = VkVertexInputBindingDescription { binding: 0, stride: 256, input_rate: VK_VERTEX_INPUT_RATE_VERTEX }
            assert(desc.is_large_stride())
        """
        self.stride > 128

    pub fn summary(self) -> text:
        """Get vertex binding summary.

        Returns:
            Human-readable summary

        Example:
            val desc = VkVertexInputBindingDescription { binding: 0, stride: 28, input_rate: VK_VERTEX_INPUT_RATE_VERTEX }
            print(desc.summary())
        """
        val rate = if self.is_per_vertex(): "per-vertex" else: "per-instance"
        return "VertexBinding: binding={self.binding}, stride={self.stride}, {rate}"

pub struct VkVertexInputAttributeDescription:
    location: u32
    binding: u32
    format: u32
    offset: u32

impl VkVertexInputAttributeDescription:
    pub fn get_location(self) -> u32:
        """Get shader location index.

        Returns:
            Location index

        Example:
            val attr = VkVertexInputAttributeDescription { location: 0, binding: 0, format: VK_FORMAT_R32G32B32_SFLOAT, offset: 0 }
            assert(attr.get_location() == 0)
        """
        self.location

    pub fn get_binding(self) -> u32:
        """Get vertex binding index.

        Returns:
            Binding index

        Example:
            val attr = VkVertexInputAttributeDescription { location: 0, binding: 0, format: VK_FORMAT_R32G32B32_SFLOAT, offset: 0 }
            assert(attr.get_binding() == 0)
        """
        self.binding

    pub fn get_format(self) -> u32:
        """Get attribute format.

        Returns:
            Vulkan format constant

        Example:
            val attr = VkVertexInputAttributeDescription { location: 0, binding: 0, format: VK_FORMAT_R32G32B32_SFLOAT, offset: 0 }
            assert(attr.get_format() == VK_FORMAT_R32G32B32_SFLOAT)
        """
        self.format

    pub fn get_offset(self) -> u32:
        """Get byte offset in vertex.

        Returns:
            Offset in bytes

        Example:
            val attr = VkVertexInputAttributeDescription { location: 1, binding: 0, format: VK_FORMAT_R32G32B32A32_SFLOAT, offset: 12 }
            assert(attr.get_offset() == 12)
        """
        self.offset

    pub fn is_float_format(self) -> bool:
        """Check if format is floating point.

        Returns:
            True if format is f32

        Example:
            val attr = VkVertexInputAttributeDescription { location: 0, binding: 0, format: VK_FORMAT_R32G32B32_SFLOAT, offset: 0 }
            assert(attr.is_float_format())
        """
        self.format == VK_FORMAT_R32G32B32_SFLOAT or self.format == VK_FORMAT_R32G32B32A32_SFLOAT

    pub fn is_position_format(self) -> bool:
        """Check if this is likely a position attribute (vec3 f32).

        Returns:
            True if 3-component f32 at location 0

        Example:
            val attr = VkVertexInputAttributeDescription { location: 0, binding: 0, format: VK_FORMAT_R32G32B32_SFLOAT, offset: 0 }
            assert(attr.is_position_format())
        """
        self.location == 0 and self.format == VK_FORMAT_R32G32B32_SFLOAT

    pub fn is_color_format(self) -> bool:
        """Check if this is likely a color attribute (vec4 f32).

        Returns:
            True if 4-component f32

        Example:
            val attr = VkVertexInputAttributeDescription { location: 1, binding: 0, format: VK_FORMAT_R32G32B32A32_SFLOAT, offset: 12 }
            assert(attr.is_color_format())
        """
        self.format == VK_FORMAT_R32G32B32A32_SFLOAT

    pub fn summary(self) -> text:
        """Get vertex attribute summary.

        Returns:
            Human-readable summary

        Example:
            val attr = VkVertexInputAttributeDescription { location: 0, binding: 0, format: VK_FORMAT_R32G32B32_SFLOAT, offset: 0 }
            print(attr.summary())
        """
        return "VertexAttribute: location={self.location}, binding={self.binding}, offset={self.offset}"

pub struct VkGraphicsPipelineCreateInfo:
    # Shader stages
    shader_stages: Array<VkPipelineShaderStageCreateInfo>

    # Vertex input
    vertex_bindings: Array<VkVertexInputBindingDescription>
    vertex_attributes: Array<VkVertexInputAttributeDescription>

    # Input assembly
    topology: VkPrimitiveTopology
    primitive_restart: bool

    # Rasterization
    polygon_mode: VkPolygonMode
    cull_mode: VkCullModeFlags
    front_face: VkFrontFace
    line_width: f32

    # Viewport
    dynamic_viewport: bool

    # Multisample
    sample_count: VkSampleCountFlagBits
    sample_shading: bool

    # Color blend
    blend_enable: bool

    # Render pass
    render_pass: VkRenderPass
    subpass: u32

    # Layout
    pipeline_layout: VkPipelineLayout

impl VkGraphicsPipelineCreateInfo:
    pub fn shader_stage_count(self) -> usize:
        """Get number of shader stages.

        Returns:
            Number of shader stages (usually 2: vertex + fragment)

        Example:
            val info = builder.build()
            assert(info.shader_stage_count() == 2)
        """
        self.shader_stages.len()

    pub fn vertex_binding_count(self) -> usize:
        """Get number of vertex bindings.

        Returns:
            Number of vertex bindings

        Example:
            val info = builder.build()
            val count = info.vertex_binding_count()
        """
        self.vertex_bindings.len()

    pub fn vertex_attribute_count(self) -> usize:
        """Get number of vertex attributes.

        Returns:
            Number of vertex attributes

        Example:
            val info = builder.build()
            val count = info.vertex_attribute_count()
        """
        self.vertex_attributes.len()

    pub fn is_triangle_topology(self) -> bool:
        """Check if topology is triangle-based.

        Returns:
            True if triangle list, strip, or fan

        Example:
            val info = builder.build()
            if info.is_triangle_topology():
                print("Triangle rendering")
        """
        self.topology == VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST or
        self.topology == VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP or
        self.topology == VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN

    pub fn is_line_topology(self) -> bool:
        """Check if topology is line-based.

        Returns:
            True if line list or strip

        Example:
            val info = builder.build()
            if info.is_line_topology():
                print("Line rendering")
        """
        self.topology == VK_PRIMITIVE_TOPOLOGY_LINE_LIST or
        self.topology == VK_PRIMITIVE_TOPOLOGY_LINE_STRIP

    pub fn is_wireframe(self) -> bool:
        """Check if polygon mode is wireframe.

        Returns:
            True if line mode

        Example:
            val info = builder.rasterization_wireframe().build()
            assert(info.is_wireframe())
        """
        self.polygon_mode == VK_POLYGON_MODE_LINE

    pub fn is_filled(self) -> bool:
        """Check if polygon mode is filled.

        Returns:
            True if fill mode

        Example:
            val info = builder.build()
            assert(info.is_filled())
        """
        self.polygon_mode == VK_POLYGON_MODE_FILL

    pub fn has_backface_culling(self) -> bool:
        """Check if backface culling is enabled.

        Returns:
            True if back faces are culled

        Example:
            val info = builder.build()
            assert(info.has_backface_culling())
        """
        self.cull_mode == VK_CULL_MODE_BACK_BIT or self.cull_mode == VK_CULL_MODE_FRONT_AND_BACK

    pub fn has_multisampling(self) -> bool:
        """Check if multisampling is enabled.

        Returns:
            True if sample count > 1

        Example:
            val info = builder.multisample_4x().build()
            assert(info.has_multisampling())
        """
        self.sample_count > VK_SAMPLE_COUNT_1_BIT

    pub fn has_blending(self) -> bool:
        """Check if color blending is enabled.

        Returns:
            True if blending enabled

        Example:
            val info = builder.color_blend_alpha().build()
            assert(info.has_blending())
        """
        self.blend_enable

    pub fn has_dynamic_viewport(self) -> bool:
        """Check if viewport is dynamic.

        Returns:
            True if viewport set dynamically

        Example:
            val info = builder.build()
            assert(info.has_dynamic_viewport())
        """
        self.dynamic_viewport

    pub fn summary(self) -> text:
        """Get pipeline create info summary.

        Returns:
            Human-readable summary

        Example:
            val info = builder.build()
            print(info.summary())
        """
        val topo = if self.is_triangle_topology(): "triangles" else if self.is_line_topology(): "lines" else: "points"
        val mode = if self.is_wireframe(): "wireframe" else: "filled"
        val msaa = if self.has_multisampling(): "MSAA" else: "no-MSAA"
        return "PipelineCreateInfo: {topo}, {mode}, {msaa}, {self.shader_stage_count()} stages, {self.vertex_attribute_count()} attributes"
