# Electron Renderer - Desktop App Backend
#
# Extends Browser renderer with native desktop capabilities via Electron.
# Combines DOM rendering (shared with Browser backend) with Node.js integration
# for file system, IPC, system tray, notifications, and power management.
#
# Key Features:
#   - All Browser backend features (DOM manipulation, events)
#   - IPC (Inter-Process Communication) between main and renderer
#   - Native file dialogs and system integration
#   - System tray and notifications
#   - Power management events
#   - Clipboard access
#   - Auto-update support

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.browser.*  # Extend Browser renderer

# =============================================================================
# Electron Async Renderer (Browser + Native)
# =============================================================================

pub struct ElectronRenderer:
    # Reuse browser rendering
    browser_renderer: BrowserRenderer

    # Electron-specific state
    ipc_handlers: Dict<text, IpcCallback>
    window_id: u32
    is_main_window: bool

    # Native features
    system_tray: Option<SystemTray>
    power_monitor: PowerMonitor
    clipboard: Clipboard

    # Settings
    enable_node_integration: bool
    context_isolation: bool

impl ElectronRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_main_window(self) -> bool:
        """Check if this is the main window."""
        self.is_main_window

    pub fn has_system_tray(self) -> bool:
        """Check if system tray is created."""
        match self.system_tray:
            case Some(_): true
            case None: false

    pub fn has_ipc_handlers(self) -> bool:
        """Check if any IPC handlers are registered."""
        self.ipc_handlers.len() > 0

    pub fn ipc_handler_count(self) -> usize:
        """Get number of IPC handlers."""
        self.ipc_handlers.len()

    pub fn has_node_integration(self) -> bool:
        """Check if Node integration is enabled."""
        self.enable_node_integration

    pub fn has_context_isolation(self) -> bool:
        """Check if context isolation is enabled."""
        self.context_isolation

    pub fn is_secure_config(self) -> bool:
        """Check if running with secure configuration (no Node integration, with context isolation)."""
        not self.enable_node_integration and self.context_isolation

    pub fn summary(self) -> text:
        """Get summary of Electron renderer state."""
        val main = if self.is_main_window: "main" else: "child"
        val tray = if self.has_system_tray(): "yes" else: "no"
        return "ElectronRenderer: window_id={self.window_id} ({main}), tray={tray}, {self.ipc_handler_count()} IPC handlers"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new Electron renderer
    pub fn new(root_element_id: &str, window_id: u32) -> Result<ElectronRenderer, RenderError>:
        val browser = BrowserRenderer::new(root_element_id)?

        return Ok(ElectronRenderer {
            browser_renderer: browser,
            ipc_handlers: Dict::new(),
            window_id: window_id,
            is_main_window: window_id == 1,
            system_tray: None,
            power_monitor: PowerMonitor::new(),
            clipboard: Clipboard::new(),
            enable_node_integration: false,  # Security best practice
            context_isolation: true
        })

# =============================================================================
# Async RenderBackend Implementation (Delegate to Browser)
# =============================================================================

impl RenderBackend for ElectronRenderer:
    async fn init(self) -> Future<Result<(), RenderError>>:
        # Initialize browser renderer
        await self.browser_renderer.init()

        # Set up Electron-specific features
        await self.setup_ipc()
        await self.setup_power_monitor()

        # Check if running in Electron environment
        val is_electron = await electron_is_available()
        if not is_electron:
            return Future::ready(Err(RenderError::IoError(
                "Not running in Electron environment"
            )))

        return Future::ready(Ok(()))

    async fn shutdown(self) -> Future<Result<(), RenderError>>:
        # Cleanup Electron resources
        await self.cleanup_ipc()
        if val Some(tray) = &self.system_tray:
            await tray.destroy()

        # Shutdown browser renderer
        await self.browser_renderer.shutdown()

        return Future::ready(Ok(()))

    fn dimensions() -> (u16, u16):
        return self.browser_renderer.dimensions()

    async fn render(self, tree: &ElementTree) -> Future<Result<(), RenderError>>:
        # Delegate to browser renderer
        return await self.browser_renderer.render(tree)

    async fn apply_patches(self, patches: &PatchSet) -> Future<Result<(), RenderError>>:
        # Delegate to browser renderer
        return await self.browser_renderer.apply_patches(patches)

    async fn clear(self) -> Future<Result<(), RenderError>>:
        return await self.browser_renderer.clear()

    async fn flush(self) -> Future<Result<(), RenderError>>:
        return await self.browser_renderer.flush()

    async fn poll_event(self, timeout_ms: u64) -> Future<Result<Option<Event>, RenderError>>:
        # Check for IPC events first
        val ipc_event = await self.poll_ipc_event()
        if ipc_event.is_some():
            return Future::ready(Ok(ipc_event))

        # Fall back to browser events
        return await self.browser_renderer.poll_event(timeout_ms)

    async fn read_event(self) -> Future<Result<Event, RenderError>>:
        loop:
            match await self.poll_event(1000):
                case Ok(Some(event)): return Future::ready(Ok(event))
                case Ok(None): pass
                case Err(e): return Future::ready(Err(e))

# =============================================================================
# Electron-Specific Features
# =============================================================================

impl ElectronRenderer:
    # IPC Setup
    async fn setup_ipc(self) -> Future<()>:
        # Register renderer → main IPC channel
        await electron_ipc_on("main-message", |event, args| {
            self.handle_main_message(args)
        })

        # Send ready signal to main process
        await electron_ipc_send("renderer-ready", [self.window_id])

        return Future::ready(())

    async fn cleanup_ipc(self) -> Future<()>:
        await electron_ipc_remove_all_listeners("main-message")
        return Future::ready(())

    # IPC Event Handling
    async fn poll_ipc_event(self) -> Future<Option<Event>>:
        # Check if there are pending IPC events
        # (In real implementation, this would use an event queue)
        return Future::ready(None)

    fn handle_main_message(args: Array<Any>):
        # Handle messages from main process
        if args.is_empty():
            return

        val message_type = args[0].to_string()
        match message_type:
            case "quit":
                # Main process requesting quit
                self.dispatch_event(Event::Quit)
            case "reload":
                # Reload requested
                electron_reload_window()
            case _:
                # Custom message - dispatch as custom event
                pass

    fn dispatch_event(&mut self, event: Event):
        # Push event to the browser renderer's event queue for poll_event/read_event
        self.browser_renderer.push_event(event)

    # Power Monitor
    async fn setup_power_monitor(self) -> Future<()>:
        await self.power_monitor.on_suspend(|| {
            self.dispatch_event(Event::PowerSuspend)
        })

        await self.power_monitor.on_resume(|| {
            self.dispatch_event(Event::PowerResume)
        })

        await self.power_monitor.on_battery(|| {
            self.dispatch_event(Event::BatteryPower)
        })

        return Future::ready(())

    # System Tray
    pub async fn create_system_tray(self, icon_path: &str, tooltip: &str)
        -> Future<Result<(), RenderError>>:
        val tray = await SystemTray::new(icon_path, tooltip)
        self.system_tray = Some(tray)
        return Future::ready(Ok(()))

    pub fn get_system_tray(self) -> Option<&SystemTray>:
        return self.system_tray.as_ref()

    # Native Dialogs
    pub async fn show_open_dialog(self, options: OpenDialogOptions)
        -> Future<Result<Option<Array<text>>, RenderError>>:
        val result = await electron_show_open_dialog(self.window_id, options)
        return Future::ready(Ok(result))

    pub async fn show_save_dialog(self, options: SaveDialogOptions)
        -> Future<Result<Option<text>, RenderError>>:
        val result = await electron_show_save_dialog(self.window_id, options)
        return Future::ready(Ok(result))

    pub async fn show_message_box(self, options: MessageBoxOptions)
        -> Future<Result<u32, RenderError>>:
        val button_index = await electron_show_message_box(self.window_id, options)
        return Future::ready(Ok(button_index))

    # Clipboard
    pub fn read_clipboard_text(self) -> text:
        return self.clipboard.read_text()

    pub fn write_clipboard_text(self, text: &str):
        self.clipboard.write_text(text)

    pub fn read_clipboard_image(self) -> Option<Image>:
        return self.clipboard.read_image()

    # Window Management
    pub async fn set_window_title(self, title: &str) -> Future<()>:
        await electron_set_window_title(self.window_id, title)
        return Future::ready(())

    pub async fn set_window_size(self, width: u32, height: u32) -> Future<()>:
        await electron_set_window_size(self.window_id, width, height)
        return Future::ready(())

    pub async fn maximize_window(self) -> Future<()>:
        await electron_maximize_window(self.window_id)
        return Future::ready(())

    pub async fn minimize_window(self) -> Future<()>:
        await electron_minimize_window(self.window_id)
        return Future::ready(())

    pub async fn close_window(self) -> Future<()>:
        await electron_close_window(self.window_id)
        return Future::ready(())

    # Notifications
    pub async fn show_notification(self, options: NotificationOptions) -> Future<()>:
        await electron_show_notification(options)
        return Future::ready(())

# =============================================================================
# Electron Data Types
# =============================================================================

pub struct OpenDialogOptions:
    title: text
    default_path: Option<text>
    button_label: Option<text>
    filters: Array<FileFilter>
    properties: Array<OpenDialogProperty>

impl OpenDialogOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_default_path(self) -> bool:
        """Check if default path is set."""
        match self.default_path:
            case Some(_): true
            case None: false

    pub fn has_button_label(self) -> bool:
        """Check if custom button label is set."""
        match self.button_label:
            case Some(_): true
            case None: false

    pub fn has_filters(self) -> bool:
        """Check if any file filters are set."""
        self.filters.len() > 0

    pub fn filter_count(self) -> usize:
        """Get number of file filters."""
        self.filters.len()

    pub fn property_count(self) -> usize:
        """Get number of properties."""
        self.properties.len()

    pub fn summary(self) -> text:
        """Get summary of dialog options."""
        return "OpenDialogOptions: '{self.title}', {self.filter_count()} filters, {self.property_count()} properties"

pub struct FileFilter:
    name: text
    extensions: Array<text>

impl FileFilter:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_extensions(self) -> bool:
        """Check if any extensions are defined."""
        self.extensions.len() > 0

    pub fn extension_count(self) -> usize:
        """Get number of extensions."""
        self.extensions.len()

    pub fn summary(self) -> text:
        """Get summary of file filter."""
        return "FileFilter: {self.name} ({self.extension_count()} extensions)"

pub enum OpenDialogProperty:
    OpenFile
    OpenDirectory
    MultiSelections
    ShowHiddenFiles
    CreateDirectory

impl OpenDialogProperty:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case OpenFile: return "openFile"
            case OpenDirectory: return "openDirectory"
            case MultiSelections: return "multiSelections"
            case ShowHiddenFiles: return "showHiddenFiles"
            case CreateDirectory: return "createDirectory"

    pub fn description(self) -> text:
        """Get description of this property."""
        match self:
            case OpenFile: return "Allow files to be selected"
            case OpenDirectory: return "Allow directories to be selected"
            case MultiSelections: return "Allow multiple paths to be selected"
            case ShowHiddenFiles: return "Show hidden files in dialog"
            case CreateDirectory: return "Allow creating new directories"

    pub fn is_open_file(self) -> bool:
        """Check if this allows opening files."""
        match self:
            case OpenFile: true
            case _: false

    pub fn is_open_directory(self) -> bool:
        """Check if this allows opening directories."""
        match self:
            case OpenDirectory: true
            case _: false

    pub fn is_multi_selections(self) -> bool:
        """Check if this allows multiple selections."""
        match self:
            case MultiSelections: true
            case _: false

    pub fn summary(self) -> text:
        """Get dialog property summary.

        Returns:
            Human-readable summary

        Example:
            OpenDialogProperty::OpenFile.summary()
            # → "OpenDialogProperty: openFile (Allow files to be selected)"
        """
        val name = self.to_string()
        val desc = self.description()
        return "OpenDialogProperty: {name} ({desc})"

pub struct SaveDialogOptions:
    title: text
    default_path: Option<text>
    button_label: Option<text>
    filters: Array<FileFilter>

impl SaveDialogOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_default_path(self) -> bool:
        """Check if default path is set."""
        match self.default_path:
            case Some(_): true
            case None: false

    pub fn has_button_label(self) -> bool:
        """Check if custom button label is set."""
        match self.button_label:
            case Some(_): true
            case None: false

    pub fn has_filters(self) -> bool:
        """Check if any file filters are set."""
        self.filters.len() > 0

    pub fn filter_count(self) -> usize:
        """Get number of file filters."""
        self.filters.len()

    pub fn summary(self) -> text:
        """Get summary of dialog options."""
        return "SaveDialogOptions: '{self.title}', {self.filter_count()} filters"

pub struct MessageBoxOptions:
    type: MessageBoxType
    buttons: Array<text>
    default_id: u32
    title: text
    message: text
    detail: Option<text>

impl MessageBoxOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_detail(self) -> bool:
        """Check if detail text is provided."""
        match self.detail:
            case Some(_): true
            case None: false

    pub fn button_count(self) -> usize:
        """Get number of buttons."""
        self.buttons.len()

    pub fn has_buttons(self) -> bool:
        """Check if any buttons are defined."""
        self.buttons.len() > 0

    pub fn summary(self) -> text:
        """Get summary of message box options."""
        return "MessageBoxOptions: '{self.title}', type={self.type.to_string()}, {self.button_count()} buttons"

pub enum MessageBoxType:
    None
    Info
    Error
    Question
    Warning

impl MessageBoxType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case None: return "none"
            case Info: return "info"
            case Error: return "error"
            case Question: return "question"
            case Warning: return "warning"

    pub fn description(self) -> text:
        """Get description of this message box type."""
        match self:
            case None: return "Plain message box with no icon"
            case Info: return "Information message with info icon"
            case Error: return "Error message with error icon"
            case Question: return "Question dialog with question icon"
            case Warning: return "Warning message with warning icon"

    pub fn is_info(self) -> bool:
        """Check if this is an info message."""
        match self:
            case Info: true
            case _: false

    pub fn is_error(self) -> bool:
        """Check if this is an error message."""
        match self:
            case Error: true
            case _: false

    pub fn is_warning(self) -> bool:
        """Check if this is a warning message."""
        match self:
            case Warning: true
            case _: false

    pub fn is_question(self) -> bool:
        """Check if this is a question dialog."""
        match self:
            case Question: true
            case _: false

pub struct NotificationOptions:
    title: text
    body: text
    icon: Option<text>
    silent: bool
    timeout_ms: u32

impl NotificationOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_icon(self) -> bool:
        """Check if icon is provided."""
        match self.icon:
            case Some(_): true
            case None: false

    pub fn is_silent(self) -> bool:
        """Check if notification is silent."""
        self.silent

    pub fn has_timeout(self) -> bool:
        """Check if timeout is set (non-zero)."""
        self.timeout_ms > 0

    pub fn summary(self) -> text:
        """Get summary of notification options."""
        val silent = if self.silent: "silent" else: "audible"
        return "NotificationOptions: '{self.title}', {silent}, timeout={self.timeout_ms}ms"

# =============================================================================
# System Tray
# =============================================================================

pub struct SystemTray:
    icon_path: text
    tooltip: text
    menu: Option<TrayMenu>

impl SystemTray:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_menu(self) -> bool:
        """Check if context menu is set."""
        match self.menu:
            case Some(_): true
            case None: false

    pub fn summary(self) -> text:
        """Get summary of system tray."""
        val menu = if self.has_menu(): "yes" else: "no"
        return "SystemTray: '{self.tooltip}', icon='{self.icon_path}', menu={menu}"

    # =========================================================================
    # Methods
    # =========================================================================

    pub async fn new(icon_path: &str, tooltip: &str) -> Future<SystemTray>:
        val tray = SystemTray {
            icon_path: icon_path.to_string(),
            tooltip: tooltip.to_string(),
            menu: None
        }

        await electron_create_tray(icon_path, tooltip)

        return Future::ready(tray)

    pub async fn set_icon(self, icon_path: &str) -> Future<()>:
        self.icon_path = icon_path.to_string()
        await electron_tray_set_icon(icon_path)
        return Future::ready(())

    pub async fn set_tooltip(self, tooltip: &str) -> Future<()>:
        self.tooltip = tooltip.to_string()
        await electron_tray_set_tooltip(tooltip)
        return Future::ready(())

    pub async fn set_context_menu(self, menu: TrayMenu) -> Future<()>:
        self.menu = Some(menu)
        await electron_tray_set_menu(&menu)
        return Future::ready(())

    pub async fn destroy(self) -> Future<()>:
        await electron_destroy_tray()
        return Future::ready(())

pub struct TrayMenu:
    items: Array<TrayMenuItem>

impl TrayMenu:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_items(self) -> bool:
        """Check if menu has any items."""
        self.items.len() > 0

    pub fn item_count(self) -> usize:
        """Get number of menu items."""
        self.items.len()

    pub fn is_empty(self) -> bool:
        """Check if menu is empty."""
        self.items.len() == 0

    pub fn summary(self) -> text:
        """Get summary of tray menu."""
        return "TrayMenu: {self.item_count()} items"

pub enum TrayMenuItem:
    Normal { label: text, click: fn() }
    Separator
    Submenu { label: text, submenu: TrayMenu }

impl TrayMenuItem:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case Normal { label, .. }: return "Normal: {label}"
            case Separator: return "Separator"
            case Submenu { label, .. }: return "Submenu: {label}"

    pub fn description(self) -> text:
        """Get description of this menu item."""
        match self:
            case Normal { .. }: return "Normal clickable menu item"
            case Separator: return "Menu separator"
            case Submenu { .. }: return "Submenu with child items"

    pub fn is_normal(self) -> bool:
        """Check if this is a normal menu item."""
        match self:
            case Normal { .. }: true
            case _: false

    pub fn is_separator(self) -> bool:
        """Check if this is a separator."""
        match self:
            case Separator: true
            case _: false

    pub fn is_submenu(self) -> bool:
        """Check if this is a submenu."""
        match self:
            case Submenu { .. }: true
            case _: false

# =============================================================================
# Power Monitor
# =============================================================================

pub struct PowerMonitor:
    on_suspend_handler: Option<fn()>
    on_resume_handler: Option<fn()>
    on_battery_handler: Option<fn()>
    on_ac_handler: Option<fn()>

impl PowerMonitor:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_suspend_handler(self) -> bool:
        """Check if suspend handler is registered."""
        match self.on_suspend_handler:
            case Some(_): true
            case None: false

    pub fn has_resume_handler(self) -> bool:
        """Check if resume handler is registered."""
        match self.on_resume_handler:
            case Some(_): true
            case None: false

    pub fn has_battery_handler(self) -> bool:
        """Check if battery handler is registered."""
        match self.on_battery_handler:
            case Some(_): true
            case None: false

    pub fn has_ac_handler(self) -> bool:
        """Check if AC power handler is registered."""
        match self.on_ac_handler:
            case Some(_): true
            case None: false

    pub fn has_any_handlers(self) -> bool:
        """Check if any power event handlers are registered."""
        self.has_suspend_handler() or self.has_resume_handler() or self.has_battery_handler() or self.has_ac_handler()

    pub fn handler_count(self) -> usize:
        """Get number of registered handlers."""
        var count = 0
        if self.has_suspend_handler(): count = count + 1
        if self.has_resume_handler(): count = count + 1
        if self.has_battery_handler(): count = count + 1
        if self.has_ac_handler(): count = count + 1
        count

    pub fn summary(self) -> text:
        """Get summary of power monitor."""
        return "PowerMonitor: {self.handler_count()} handlers registered"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new() -> PowerMonitor:
        return PowerMonitor {
            on_suspend_handler: None,
            on_resume_handler: None,
            on_battery_handler: None,
            on_ac_handler: None
        }

    pub async fn on_suspend(self, handler: fn()) -> Future<()>:
        self.on_suspend_handler = Some(handler)
        await electron_power_on("suspend", handler)
        return Future::ready(())

    pub async fn on_resume(self, handler: fn()) -> Future<()>:
        self.on_resume_handler = Some(handler)
        await electron_power_on("resume", handler)
        return Future::ready(())

    pub async fn on_battery(self, handler: fn()) -> Future<()>:
        self.on_battery_handler = Some(handler)
        await electron_power_on("on-battery", handler)
        return Future::ready(())

    pub async fn on_ac(self, handler: fn()) -> Future<()>:
        self.on_ac_handler = Some(handler)
        await electron_power_on("on-ac", handler)
        return Future::ready(())

# =============================================================================
# Clipboard
# =============================================================================

pub struct Clipboard

impl Clipboard:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn summary(self) -> text:
        """Get summary of clipboard."""
        return "Clipboard: system clipboard access"

    # =========================================================================
    # Constructor and Methods
    # =========================================================================

    pub fn new() -> Clipboard:
        return Clipboard {}

    pub fn read_text(self) -> text:
        return electron_clipboard_read_text()

    pub fn write_text(self, text: &str):
        electron_clipboard_write_text(text)

    pub fn read_image(self) -> Option<Image>:
        # Read image from clipboard using Electron's nativeImage
        val native_image = electron_clipboard_read_image()
        if native_image.is_empty():
            return None

        # Convert to our Image type
        val size = native_image.get_size()
        val buffer = native_image.to_png()

        return Some(Image {
            width: size.width,
            height: size.height,
            format: ImageFormat::Png,
            data: buffer
        })

    pub fn clear(self):
        electron_clipboard_clear()

# =============================================================================
# Custom Events
# =============================================================================

pub enum Event:
    # Extend base Event enum with Electron-specific events
    PowerSuspend
    PowerResume
    BatteryPower
    ACPower
    Quit
    IpcMessage { channel: text, data: Any }

impl Event:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case PowerSuspend: return "PowerSuspend"
            case PowerResume: return "PowerResume"
            case BatteryPower: return "BatteryPower"
            case ACPower: return "ACPower"
            case Quit: return "Quit"
            case IpcMessage { channel, .. }: return "IpcMessage: {channel}"

    pub fn description(self) -> text:
        """Get description of this event."""
        match self:
            case PowerSuspend: return "System is suspending"
            case PowerResume: return "System resumed from suspend"
            case BatteryPower: return "Switched to battery power"
            case ACPower: return "Switched to AC power"
            case Quit: return "Application quit requested"
            case IpcMessage { .. }: return "IPC message from main process"

    pub fn is_power_event(self) -> bool:
        """Check if this is a power-related event."""
        match self:
            case PowerSuspend: true
            case PowerResume: true
            case BatteryPower: true
            case ACPower: true
            case _: false

    pub fn is_power_suspend(self) -> bool:
        """Check if this is a power suspend event."""
        match self:
            case PowerSuspend: true
            case _: false

    pub fn is_power_resume(self) -> bool:
        """Check if this is a power resume event."""
        match self:
            case PowerResume: true
            case _: false

    pub fn is_battery_power(self) -> bool:
        """Check if this is a battery power event."""
        match self:
            case BatteryPower: true
            case _: false

    pub fn is_ac_power(self) -> bool:
        """Check if this is an AC power event."""
        match self:
            case ACPower: true
            case _: false

    pub fn is_quit(self) -> bool:
        """Check if this is a quit event."""
        match self:
            case Quit: true
            case _: false

    pub fn is_ipc_message(self) -> bool:
        """Check if this is an IPC message."""
        match self:
            case IpcMessage { .. }: true
            case _: false

# =============================================================================
# Electron FFI (Node.js Integration)
# =============================================================================

type IpcCallback = fn(Event, Array<Any>) -> ()

# Environment check
extern fn electron_is_available() -> bool

# IPC (Inter-Process Communication)
extern async fn electron_ipc_send(channel: &str, args: Array<Any>) -> Future<()>
extern async fn electron_ipc_on(channel: &str, callback: IpcCallback) -> Future<()>
extern async fn electron_ipc_remove_all_listeners(channel: &str) -> Future<()>

# Dialogs
extern async fn electron_show_open_dialog(window_id: u32, options: OpenDialogOptions)
    -> Future<Option<Array<text>>>
extern async fn electron_show_save_dialog(window_id: u32, options: SaveDialogOptions)
    -> Future<Option<text>>
extern async fn electron_show_message_box(window_id: u32, options: MessageBoxOptions)
    -> Future<u32>

# Window management
extern async fn electron_set_window_title(window_id: u32, title: &str) -> Future<()>
extern async fn electron_set_window_size(window_id: u32, width: u32, height: u32) -> Future<()>
extern async fn electron_maximize_window(window_id: u32) -> Future<()>
extern async fn electron_minimize_window(window_id: u32) -> Future<()>
extern async fn electron_close_window(window_id: u32) -> Future<()>
extern fn electron_reload_window() -> ()

# System Tray
extern async fn electron_create_tray(icon_path: &str, tooltip: &str) -> Future<()>
extern async fn electron_tray_set_icon(icon_path: &str) -> Future<()>
extern async fn electron_tray_set_tooltip(tooltip: &str) -> Future<()>
extern async fn electron_tray_set_menu(menu: &TrayMenu) -> Future<()>
extern async fn electron_destroy_tray() -> Future<()>

# Power Monitor
extern async fn electron_power_on(event: &str, callback: fn()) -> Future<()>

# Clipboard
extern fn electron_clipboard_read_text() -> text
extern fn electron_clipboard_write_text(text: &str) -> ()
extern fn electron_clipboard_read_image() -> NativeImage
extern fn electron_clipboard_clear() -> ()

# NativeImage type for Electron's image handling
struct NativeImage:
    handle: i64

impl NativeImage:
    fn is_empty(self) -> bool:
        return electron_native_image_is_empty(self.handle)

    fn get_size(self) -> ImageSize:
        return electron_native_image_get_size(self.handle)

    fn to_png(self) -> Array<u8>:
        return electron_native_image_to_png(self.handle)

struct ImageSize:
    width: u32
    height: u32

extern fn electron_native_image_is_empty(handle: i64) -> bool
extern fn electron_native_image_get_size(handle: i64) -> ImageSize
extern fn electron_native_image_to_png(handle: i64) -> Array<u8>

# Notifications
extern async fn electron_show_notification(options: NotificationOptions) -> Future<()>
