# Widget - Core Widget Trait and Types
#
# Defines the base Widget trait that all UI components implement.
# This enables the builder pattern for composable, type-safe UI construction.
#
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*

# Build context for widget tree construction
pub struct BuildContext:
    # ID allocator for elements
    next_id: u64
    # Parent element (for relative positioning)
    parent: Option[NodeId]
    # Theme reference
    theme_id: u64

impl BuildContext:
    # Create a new build context
    pub fn new() -> BuildContext:
        return BuildContext {
            next_id: 0,
            parent: None,
            theme_id: 0
        }

    # Allocate a new NodeId
    pub fn alloc_id(mut self) -> NodeId:
        let id = NodeId::new(self.next_id)
        self.next_id = self.next_id + 1
        return id

    # Create a child context with a parent element
    pub fn with_parent(self, parent_id: NodeId) -> BuildContext:
        return BuildContext {
            next_id: self.next_id,
            parent: Some(parent_id),
            theme_id: self.theme_id
        }

# Widget node that contains the built element tree
pub struct WidgetNode:
    # The root element of this widget
    root: Element
    # Any child widget nodes
    children: Array[WidgetNode]

impl WidgetNode:
    # Create a new widget node
    pub fn new(root: Element) -> WidgetNode:
        return WidgetNode {
            root: root,
            children: []
        }

    # Add a child widget node
    pub fn add_child(mut self, child: WidgetNode):
        self.children.push(child)

    # Get the root element
    pub fn element(self) -> Element:
        return self.root

    # Convert to element tree (flattens widget nodes)
    pub fn to_element(self) -> Element:
        let mut elem = self.root.clone()
        for child in self.children:
            elem = elem.with_child(child.to_element())
        return elem

# Core Widget trait - all widgets implement this
pub trait Widget:
    # Build this widget into an element tree
    fn build(self, ctx: &mut BuildContext) -> WidgetNode

# Alignment enums for layout
pub enum Align:
    Start
    Center
    End
    Stretch

pub enum Justify:
    Start
    Center
    End
    SpaceBetween
    SpaceAround
    SpaceEvenly

pub enum Alignment:
    TopLeft
    TopCenter
    TopRight
    CenterLeft
    Center
    CenterRight
    BottomLeft
    BottomCenter
    BottomRight

# Edge insets for padding/margin
pub struct EdgeInsets:
    pub top: i32
    pub right: i32
    pub bottom: i32
    pub left: i32

impl EdgeInsets:
    # Create insets with all sides equal
    pub fn all(value: i32) -> EdgeInsets:
        return EdgeInsets {
            top: value,
            right: value,
            bottom: value,
            left: value
        }

    # Create insets with symmetric values
    pub fn symmetric(vertical: i32, horizontal: i32) -> EdgeInsets:
        return EdgeInsets {
            top: vertical,
            right: horizontal,
            bottom: vertical,
            left: horizontal
        }

    # Create zero insets
    pub fn zero() -> EdgeInsets:
        return EdgeInsets::all(0)

    # Convert to CSS padding/margin string
    pub fn to_css(self) -> String:
        return "{self.top}px {self.right}px {self.bottom}px {self.left}px"

# Size constraints
pub struct BoxConstraints:
    pub min_width: Option[i32]
    pub max_width: Option[i32]
    pub min_height: Option[i32]
    pub max_height: Option[i32]

impl BoxConstraints:
    # Create unbounded constraints
    pub fn unbounded() -> BoxConstraints:
        return BoxConstraints {
            min_width: None,
            max_width: None,
            min_height: None,
            max_height: None
        }

    # Create tight constraints (fixed size)
    pub fn tight(width: i32, height: i32) -> BoxConstraints:
        return BoxConstraints {
            min_width: Some(width),
            max_width: Some(width),
            min_height: Some(height),
            max_height: Some(height)
        }

# Color type for theming
pub struct Color:
    pub rgba: u32  # RGBA in format 0xRRGGBBAA

impl Color:
    # Create color from RGB values (0-255)
    pub fn rgb(r: u8, g: u8, b: u8) -> Color:
        return Color {
            rgba: ((r as u32) << 24) | ((g as u32) << 16) | ((b as u32) << 8) | 0xFF
        }

    # Create color from RGBA values (0-255)
    pub fn rgba(r: u8, g: u8, b: u8, a: u8) -> Color:
        return Color {
            rgba: ((r as u32) << 24) | ((g as u32) << 16) | ((b as u32) << 8) | (a as u32)
        }

    # Create color from hex string (e.g., "#FF5733" or "#FF5733AA")
    pub fn hex(hex: &str) -> Result[Color, String]:
        # Remove '#' prefix if present
        let hex_clean = ""
        if hex.starts_with("#"):
            hex_clean = hex[1..]
        else:
            hex_clean = hex

        if hex_clean.len() == 6:
            # RGB format
            let r = u8::from_str_radix(&hex_clean[0..2], 16)?
            let g = u8::from_str_radix(&hex_clean[2..4], 16)?
            let b = u8::from_str_radix(&hex_clean[4..6], 16)?
            return Ok(Color::rgb(r, g, b))
        else if hex_clean.len() == 8:
            # RGBA format
            let r = u8::from_str_radix(&hex_clean[0..2], 16)?
            let g = u8::from_str_radix(&hex_clean[2..4], 16)?
            let b = u8::from_str_radix(&hex_clean[4..6], 16)?
            let a = u8::from_str_radix(&hex_clean[6..8], 16)?
            return Ok(Color::rgba(r, g, b, a))
        else:
            return Err("Invalid hex color format: {hex_clean}")

    # Get red component
    pub fn red(self) -> u8:
        return ((self.rgba >> 24) & 0xFF) as u8

    # Get green component
    pub fn green(self) -> u8:
        return ((self.rgba >> 16) & 0xFF) as u8

    # Get blue component
    pub fn blue(self) -> u8:
        return ((self.rgba >> 8) & 0xFF) as u8

    # Get alpha component
    pub fn alpha(self) -> u8:
        return (self.rgba & 0xFF) as u8

    # Convert to CSS color string
    pub fn to_css(self) -> String:
        let r = self.red()
        let g = self.green()
        let b = self.blue()
        let a = self.alpha()
        if a == 255:
            return "rgb({r}, {g}, {b})"
        else:
            let alpha_f = (a as f64) / 255.0
            return "rgba({r}, {g}, {b}, {alpha_f})"

# Common color constants
impl Color:
    pub fn transparent() -> Color:
        return Color { rgba: 0 }

    pub fn black() -> Color:
        return Color::rgb(0, 0, 0)

    pub fn white() -> Color:
        return Color::rgb(255, 255, 255)

    pub fn red() -> Color:
        return Color::rgb(255, 0, 0)

    pub fn green() -> Color:
        return Color::rgb(0, 255, 0)

    pub fn blue() -> Color:
        return Color::rgb(0, 0, 255)
