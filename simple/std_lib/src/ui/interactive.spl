# Interactive - Interactive Widgets (Button, TextField, Checkbox, Select, Slider)
#
# Provides interactive form and control widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Button variants
pub enum ButtonVariant:
    Primary
    Secondary
    Outlined
    Text
    Icon

impl ButtonVariant:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_primary(self) -> bool:
        """Check if primary variant.

        Returns:
            true for Primary

        Example:
            variant.is_primary()  # → true
        """
        match self:
            case Primary: return true
            case _: return false

    pub fn is_secondary(self) -> bool:
        """Check if secondary variant.

        Returns:
            true for Secondary

        Example:
            variant.is_secondary()  # → false
        """
        match self:
            case Secondary: return true
            case _: return false

    pub fn is_outlined(self) -> bool:
        """Check if outlined variant.

        Returns:
            true for Outlined

        Example:
            variant.is_outlined()  # → false
        """
        match self:
            case Outlined: return true
            case _: return false

    pub fn is_text(self) -> bool:
        """Check if text variant.

        Returns:
            true for Text

        Example:
            variant.is_text()  # → false
        """
        match self:
            case Text: return true
            case _: return false

    pub fn is_icon(self) -> bool:
        """Check if icon variant.

        Returns:
            true for Icon

        Example:
            variant.is_icon()  # → false
        """
        match self:
            case Icon: return true
            case _: return false

    pub fn to_string(self) -> String:
        """Convert to string.

        Returns:
            Variant name

        Example:
            variant.to_string()  # → "Primary"
        """
        match self:
            case Primary: return "Primary"
            case Secondary: return "Secondary"
            case Outlined: return "Outlined"
            case Text: return "Text"
            case Icon: return "Icon"

# Button - Clickable button widget
pub struct Button:
    label: String
    icon: Option[String]
    on_click: Option[fn()]
    variant: ButtonVariant
    disabled: bool
    full_width: bool

impl Button:
    # Create a new button with label
    pub fn new(label: &str) -> Button:
        return Button {
            label: label.to_string(),
            icon: None,
            on_click: None,
            variant: ButtonVariant::Primary,
            disabled: false,
            full_width: false
        }

    # Set button icon
    pub fn icon(mut self, icon: &str) -> Button:
        self.icon = Some(icon.to_string())
        return self

    # Set click handler
    pub fn on_click(mut self, handler: fn()) -> Button:
        self.on_click = Some(handler)
        return self

    # Set variant
    pub fn variant(mut self, variant: ButtonVariant) -> Button:
        self.variant = variant
        return self

    # Make button secondary
    pub fn secondary(mut self) -> Button:
        self.variant = ButtonVariant::Secondary
        return self

    # Make button outlined
    pub fn outlined(mut self) -> Button:
        self.variant = ButtonVariant::Outlined
        return self

    # Make button text-only
    pub fn text(mut self) -> Button:
        self.variant = ButtonVariant::Text
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Button:
        self.disabled = value
        return self

    # Make button full width
    pub fn full_width(mut self) -> Button:
        self.full_width = true
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_icon(self) -> bool:
        """Check if button has an icon.

        Returns:
            true if icon is set

        Example:
            button.has_icon()  # → false
        """
        return self.icon.is_some()

    pub fn has_click_handler(self) -> bool:
        """Check if click handler is set.

        Returns:
            true if on_click is set

        Example:
            button.has_click_handler()  # → true
        """
        return self.on_click.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if button is disabled.

        Returns:
            true if disabled

        Example:
            button.is_disabled()  # → false
        """
        return self.disabled

    pub fn is_full_width(self) -> bool:
        """Check if button is full width.

        Returns:
            true if full width

        Example:
            button.is_full_width()  # → false
        """
        return self.full_width

    pub fn get_label(self) -> &String:
        """Get button label.

        Returns:
            Label string

        Example:
            button.get_label()  # → "Submit"
        """
        return &self.label

    pub fn summary(self) -> String:
        """Get button summary.

        Returns:
            Human-readable summary

        Example:
            button.summary()
            # → "Button: 'Submit', variant=Primary, disabled=false"
        """
        let variant = self.variant.to_string()
        return "Button: '{self.label}', variant={variant}, disabled={self.disabled}"

impl Widget for Button:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::button(id, &self.label)

        # Apply variant classes
        let variant_class = match self.variant:
            case ButtonVariant::Primary: "btn-primary"
            case ButtonVariant::Secondary: "btn-secondary"
            case ButtonVariant::Outlined: "btn-outlined"
            case ButtonVariant::Text: "btn-text"
            case ButtonVariant::Icon: "btn-icon"

        elem = elem
            .with_class("btn")
            .with_class(variant_class)

        # Apply full width
        if self.full_width:
            elem = elem
                .with_class("btn-full-width")
                .with_style("width", "100%")

        # Apply disabled state
        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Register click handler
        if let Some(handler) = &self.on_click:
            # In a real implementation, this would register the handler
            # with the event system and assign a unique ID
            elem = elem.on_event("click", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# TextField - Text input widget
pub struct TextField:
    value: String
    placeholder: String
    on_change: Option[fn(String)]
    on_submit: Option[fn(String)]
    multiline: bool
    max_length: Option[u32]
    disabled: bool
    password: bool
    autofocus: bool

impl TextField:
    # Create a new text field
    pub fn new() -> TextField:
        return TextField {
            value: String::new(),
            placeholder: String::new(),
            on_change: None,
            on_submit: None,
            multiline: false,
            max_length: None,
            disabled: false,
            password: false,
            autofocus: false
        }

    # Set initial value
    pub fn value(mut self, value: &str) -> TextField:
        self.value = value.to_string()
        return self

    # Set placeholder text
    pub fn placeholder(mut self, placeholder: &str) -> TextField:
        self.placeholder = placeholder.to_string()
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(String)) -> TextField:
        self.on_change = Some(handler)
        return self

    # Set submit handler (Enter key)
    pub fn on_submit(mut self, handler: fn(String)) -> TextField:
        self.on_submit = Some(handler)
        return self

    # Make multiline (textarea)
    pub fn multiline(mut self) -> TextField:
        self.multiline = true
        return self

    # Set max length
    pub fn max_length(mut self, length: u32) -> TextField:
        self.max_length = Some(length)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> TextField:
        self.disabled = value
        return self

    # Make password field
    pub fn password(mut self) -> TextField:
        self.password = true
        return self

    # Enable autofocus
    pub fn autofocus(mut self) -> TextField:
        self.autofocus = true
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_value(self) -> bool:
        """Check if field has a value.

        Returns:
            true if value is not empty

        Example:
            textfield.has_value()  # → false
        """
        return not self.value.is_empty()

    pub fn has_placeholder(self) -> bool:
        """Check if placeholder is set.

        Returns:
            true if placeholder is not empty

        Example:
            textfield.has_placeholder()  # → true
        """
        return not self.placeholder.is_empty()

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            textfield.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn has_submit_handler(self) -> bool:
        """Check if submit handler is set.

        Returns:
            true if on_submit is set

        Example:
            textfield.has_submit_handler()  # → false
        """
        return self.on_submit.is_some()

    pub fn is_multiline(self) -> bool:
        """Check if multiline (textarea).

        Returns:
            true if multiline

        Example:
            textfield.is_multiline()  # → false
        """
        return self.multiline

    pub fn is_password(self) -> bool:
        """Check if password field.

        Returns:
            true if password

        Example:
            textfield.is_password()  # → false
        """
        return self.password

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            textfield.is_disabled()  # → false
        """
        return self.disabled

    pub fn has_autofocus(self) -> bool:
        """Check if autofocus enabled.

        Returns:
            true if autofocus

        Example:
            textfield.has_autofocus()  # → false
        """
        return self.autofocus

    pub fn has_max_length(self) -> bool:
        """Check if max length is set.

        Returns:
            true if max_length is set

        Example:
            textfield.has_max_length()  # → false
        """
        return self.max_length.is_some()

    pub fn get_value(self) -> &String:
        """Get current value.

        Returns:
            Value string

        Example:
            textfield.get_value()  # → "Hello"
        """
        return &self.value

    pub fn summary(self) -> String:
        """Get textfield summary.

        Returns:
            Human-readable summary

        Example:
            textfield.summary()
            # → "TextField: multiline=false, password=false, disabled=false"
        """
        return "TextField: multiline={self.multiline}, password={self.password}, disabled={self.disabled}"

impl Widget for TextField:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::input(id)
        if self.multiline:
            elem = elem.with_attr("type", "textarea")
        else:
            let input_type = ""
            if self.password:
                input_type = "password"
            else:
                input_type = "text"
            elem = elem.with_attr("type", input_type)

        elem = elem
            .with_class("text-field")
            .with_attr("value", &self.value)
            .with_attr("placeholder", &self.placeholder)

        # Apply max length
        if let Some(max_len) = self.max_length:
            elem = elem.with_attr("maxlength", &max_len.to_string())

        # Apply disabled state
        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Apply autofocus
        if self.autofocus:
            elem = elem.with_attr("autofocus", "true")

        # Register handlers
        if let Some(_) = &self.on_change:
            elem = elem.on_event("input", 0)  # Placeholder handler ID
        if let Some(_) = &self.on_submit:
            elem = elem.on_event("submit", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# Checkbox - Boolean toggle widget
pub struct Checkbox:
    checked: bool
    label: String
    on_change: Option[fn(bool)]
    disabled: bool

impl Checkbox:
    # Create a new checkbox
    pub fn new(label: &str) -> Checkbox:
        return Checkbox {
            checked: false,
            label: label.to_string(),
            on_change: None,
            disabled: false
        }

    # Set checked state
    pub fn checked(mut self, checked: bool) -> Checkbox:
        self.checked = checked
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(bool)) -> Checkbox:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Checkbox:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_checked(self) -> bool:
        """Check if checkbox is checked.

        Returns:
            true if checked

        Example:
            checkbox.is_checked()  # → false
        """
        return self.checked

    pub fn is_unchecked(self) -> bool:
        """Check if checkbox is unchecked.

        Returns:
            true if not checked

        Example:
            checkbox.is_unchecked()  # → true
        """
        return not self.checked

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            checkbox.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            checkbox.is_disabled()  # → false
        """
        return self.disabled

    pub fn get_label(self) -> &String:
        """Get checkbox label.

        Returns:
            Label string

        Example:
            checkbox.get_label()  # → "Accept terms"
        """
        return &self.label

    pub fn summary(self) -> String:
        """Get checkbox summary.

        Returns:
            Human-readable summary

        Example:
            checkbox.summary()
            # → "Checkbox: 'Accept terms', checked=false, disabled=false"
        """
        return "Checkbox: '{self.label}', checked={self.checked}, disabled={self.disabled}"

impl Widget for Checkbox:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Checkbox)
            .with_class("checkbox")
            .with_attr("type", "checkbox")

        if self.checked:
            elem = elem.with_attr("checked", "true")

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Wrap with label
        let label_id = ctx.alloc_id()
        let mut label = Element::new(label_id, ElementKind::Div)
            .with_class("checkbox-wrapper")
            .with_child(elem)
            .with_child(
                Element::text(ctx.alloc_id(), &self.label)
                    .with_class("checkbox-label")
            )

        # Register change handler
        if let Some(_) = &self.on_change:
            label = label.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode::new(label)

# Select - Dropdown selection widget
pub struct Select:
    options: Array[(String, String)]  # (value, label) pairs
    selected: Option[String]
    placeholder: String
    on_change: Option[fn(String)]
    disabled: bool

impl Select:
    # Create a new select widget
    pub fn new() -> Select:
        return Select {
            options: [],
            selected: None,
            placeholder: String::new(),
            on_change: None,
            disabled: false
        }

    # Add an option
    pub fn option(mut self, value: &str, label: &str) -> Select:
        self.options.push((value.to_string(), label.to_string()))
        return self

    # Set options from array
    pub fn options(mut self, options: Array[(String, String)]) -> Select:
        self.options = options
        return self

    # Set selected value
    pub fn selected(mut self, value: &str) -> Select:
        self.selected = Some(value.to_string())
        return self

    # Set placeholder
    pub fn placeholder(mut self, placeholder: &str) -> Select:
        self.placeholder = placeholder.to_string()
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(String)) -> Select:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Select:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_options(self) -> bool:
        """Check if select has options.

        Returns:
            true if options exist

        Example:
            select.has_options()  # → true
        """
        return not self.options.is_empty()

    pub fn option_count(self) -> u64:
        """Get number of options.

        Returns:
            Count of options

        Example:
            select.option_count()  # → 3
        """
        return self.options.len()

    pub fn has_selected(self) -> bool:
        """Check if a value is selected.

        Returns:
            true if selected is set

        Example:
            select.has_selected()  # → false
        """
        return self.selected.is_some()

    pub fn has_placeholder(self) -> bool:
        """Check if placeholder is set.

        Returns:
            true if placeholder not empty

        Example:
            select.has_placeholder()  # → true
        """
        return not self.placeholder.is_empty()

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            select.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            select.is_disabled()  # → false
        """
        return self.disabled

    pub fn summary(self) -> String:
        """Get select summary.

        Returns:
            Human-readable summary

        Example:
            select.summary()
            # → "Select: options=3, selected=Some, disabled=false"
        """
        let opts = self.option_count()
        let sel = if self.has_selected() { "Some" } else { "None" }
        return "Select: options={opts}, selected={sel}, disabled={self.disabled}"

impl Widget for Select:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Select)
            .with_class("select")

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Add placeholder option
        if not self.placeholder.is_empty():
            let placeholder_opt = Element::new(ctx.alloc_id(), ElementKind::Div)
                .with_attr("value", "")
                .with_attr("disabled", "true")
                .with_attr("selected", "true")
                .with_text(&self.placeholder)
            elem = elem.with_child(placeholder_opt)

        # Add options
        for (value, label) in &self.options:
            let mut option = Element::new(ctx.alloc_id(), ElementKind::Div)
                .with_attr("value", value)
                .with_text(label)

            if let Some(selected) = &self.selected:
                if selected == value:
                    option = option.with_attr("selected", "true")

            elem = elem.with_child(option)

        # Register change handler
        if let Some(_) = &self.on_change:
            elem = elem.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# Slider - Range input widget
pub struct Slider:
    value: f64
    min: f64
    max: f64
    step: f64
    on_change: Option[fn(f64)]
    disabled: bool

impl Slider:
    # Create a new slider
    pub fn new(value: f64) -> Slider:
        return Slider {
            value: value,
            min: 0.0,
            max: 100.0,
            step: 1.0,
            on_change: None,
            disabled: false
        }

    # Set min value
    pub fn min(mut self, min: f64) -> Slider:
        self.min = min
        return self

    # Set max value
    pub fn max(mut self, max: f64) -> Slider:
        self.max = max
        return self

    # Set step increment
    pub fn step(mut self, step: f64) -> Slider:
        self.step = step
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(f64)) -> Slider:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Slider:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            slider.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            slider.is_disabled()  # → false
        """
        return self.disabled

    pub fn get_value(self) -> f64:
        """Get current value.

        Returns:
            Current value

        Example:
            slider.get_value()  # → 50.0
        """
        return self.value

    pub fn get_min(self) -> f64:
        """Get minimum value.

        Returns:
            Minimum value

        Example:
            slider.get_min()  # → 0.0
        """
        return self.min

    pub fn get_max(self) -> f64:
        """Get maximum value.

        Returns:
            Maximum value

        Example:
            slider.get_max()  # → 100.0
        """
        return self.max

    pub fn get_step(self) -> f64:
        """Get step increment.

        Returns:
            Step value

        Example:
            slider.get_step()  # → 1.0
        """
        return self.step

    pub fn get_range(self) -> (f64, f64):
        """Get range as (min, max) tuple.

        Returns:
            Tuple of (min, max)

        Example:
            slider.get_range()  # → (0.0, 100.0)
        """
        return (self.min, self.max)

    pub fn is_at_min(self) -> bool:
        """Check if value is at minimum.

        Returns:
            true if value equals min

        Example:
            slider.is_at_min()  # → false
        """
        return self.value == self.min

    pub fn is_at_max(self) -> bool:
        """Check if value is at maximum.

        Returns:
            true if value equals max

        Example:
            slider.is_at_max()  # → false
        """
        return self.value == self.max

    pub fn summary(self) -> String:
        """Get slider summary.

        Returns:
            Human-readable summary

        Example:
            slider.summary()
            # → "Slider: value=50.0, range=[0.0-100.0], step=1.0, disabled=false"
        """
        return "Slider: value={self.value}, range=[{self.min}-{self.max}], step={self.step}, disabled={self.disabled}"

impl Widget for Slider:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Input)
            .with_class("slider")
            .with_attr("type", "range")
            .with_attr("value", &self.value.to_string())
            .with_attr("min", &self.min.to_string())
            .with_attr("max", &self.max.to_string())
            .with_attr("step", &self.step.to_string())

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Register change handler
        if let Some(_) = &self.on_change:
            elem = elem.on_event("input", 0)  # Placeholder handler ID

        return WidgetNode::new(elem)

# Radio - Radio button group widget
pub struct RadioGroup:
    name: String
    options: Array[(String, String)]  # (value, label) pairs
    selected: Option[String]
    on_change: Option[fn(String)]
    disabled: bool

impl RadioGroup:
    # Create a new radio group
    pub fn new(name: &str) -> RadioGroup:
        return RadioGroup {
            name: name.to_string(),
            options: [],
            selected: None,
            on_change: None,
            disabled: false
        }

    # Add an option
    pub fn option(mut self, value: &str, label: &str) -> RadioGroup:
        self.options.push((value.to_string(), label.to_string()))
        return self

    # Set selected value
    pub fn selected(mut self, value: &str) -> RadioGroup:
        self.selected = Some(value.to_string())
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(String)) -> RadioGroup:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> RadioGroup:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_options(self) -> bool:
        """Check if radio group has options.

        Returns:
            true if options exist

        Example:
            radiogroup.has_options()  # → true
        """
        return not self.options.is_empty()

    pub fn option_count(self) -> u64:
        """Get number of options.

        Returns:
            Count of options

        Example:
            radiogroup.option_count()  # → 3
        """
        return self.options.len()

    pub fn has_selected(self) -> bool:
        """Check if a value is selected.

        Returns:
            true if selected is set

        Example:
            radiogroup.has_selected()  # → false
        """
        return self.selected.is_some()

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            radiogroup.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            radiogroup.is_disabled()  # → false
        """
        return self.disabled

    pub fn get_name(self) -> &String:
        """Get radio group name.

        Returns:
            Name string

        Example:
            radiogroup.get_name()  # → "gender"
        """
        return &self.name

    pub fn get_selected(self) -> Option[&String]:
        """Get selected value if any.

        Returns:
            Selected value or None

        Example:
            radiogroup.get_selected()  # → Some("male")
        """
        return self.selected.as_ref()

    pub fn is_selected(self, value: &str) -> bool:
        """Check if specific value is selected.

        Args:
            value: Value to check

        Returns:
            true if value is selected

        Example:
            radiogroup.is_selected("male")  # → true
        """
        match &self.selected:
            case Some(sel): return sel == value
            case None: return false

    pub fn summary(self) -> String:
        """Get radio group summary.

        Returns:
            Human-readable summary

        Example:
            radiogroup.summary()
            # → "RadioGroup: name='gender', options=2, selected=Some, disabled=false"
        """
        let opts = self.option_count()
        let sel = if self.has_selected() { "Some" } else { "None" }
        return "RadioGroup: name='{self.name}', options={opts}, selected={sel}, disabled={self.disabled}"

impl Widget for RadioGroup:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut group = Element::new(id, ElementKind::Div)
            .with_class("radio-group")

        # Create radio buttons
        for (value, label) in &self.options:
            let radio_id = ctx.alloc_id()
            let mut radio = Element::new(radio_id, ElementKind::Radio)
                .with_attr("type", "radio")
                .with_attr("name", &self.name)
                .with_attr("value", value)

            if let Some(selected) = &self.selected:
                if selected == value:
                    radio = radio.with_attr("checked", "true")

            if self.disabled:
                radio = radio.with_attr("disabled", "true")

            # Wrap with label
            let wrapper = Element::new(ctx.alloc_id(), ElementKind::Div)
                .with_class("radio-wrapper")
                .with_child(radio)
                .with_child(
                    Element::text(ctx.alloc_id(), label)
                        .with_class("radio-label")
                )

            group = group.with_child(wrapper)

        # Register change handler
        if let Some(_) = &self.on_change:
            group = group.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode::new(group)
