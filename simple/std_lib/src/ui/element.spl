# Element - Shared UI Element Types
#
# This module defines the core Element/Node types that are shared
# between TUI and GUI renderers. The same element tree can be
# rendered to terminal or graphical output.

use core.*

# Unique identifier for nodes in the UI tree
pub struct NodeId:
    id: u64

impl NodeId:
    # Create a new NodeId
    pub fn new(id: u64) -> NodeId:
        return NodeId { id: id }

    # Get the raw ID value
    pub fn value(self) -> u64:
        return self.id

    # Generate next ID (simple incrementing counter)
    pub fn next(self) -> NodeId:
        return NodeId { id: self.id + 1 }

impl Eq for NodeId:
    fn eq(other: &NodeId) -> bool:
        return self.id == other.id

impl Hash for NodeId:
    fn hash() -> u64:
        return self.id

# Element type enumeration
pub enum ElementKind:
    # Container elements
    Div        # Generic block container
    Span       # Generic inline container
    Box        # Box with border (TUI: box drawing, GUI: CSS box)

    # Text elements
    Text       # Plain text node
    Paragraph  # Block-level text
    Heading(u8)  # Heading level 1-6

    # Interactive elements
    Button     # Clickable button
    Input      # Text input field
    Checkbox   # Boolean toggle
    Radio      # Radio button (one of many)
    Select     # Dropdown selection

    # List elements
    List       # Ordered or unordered list
    ListItem   # Item within a list

    # Table elements
    Table      # Data table
    TableRow   # Table row
    TableCell  # Table cell

    # Layout elements
    Row        # Horizontal flex container
    Column     # Vertical flex container
    Grid       # Grid container

    # Semantic elements
    Header     # Page/section header
    Footer     # Page/section footer
    Nav        # Navigation container
    Main       # Main content area
    Section    # Generic section
    Article    # Self-contained content
    Aside      # Sidebar/related content

impl ElementKind:
    # Check if element is a block-level element
    pub fn is_block(self) -> bool:
        match self:
            case Div | Box | Paragraph | Heading(_) | List | Table | Row | Column | Grid:
                return true
            case Header | Footer | Nav | Main | Section | Article | Aside:
                return true
            case _:
                return false

    # Check if element is inline
    pub fn is_inline(self) -> bool:
        return not self.is_block()

    # Check if element is interactive
    pub fn is_interactive(self) -> bool:
        match self:
            case Button | Input | Checkbox | Radio | Select:
                return true
            case _:
                return false

    # Get the default tag name for HTML/SSR output
    pub fn tag_name(self) -> &str:
        match self:
            case Div: return "div"
            case Span: return "span"
            case Box: return "div"
            case Text: return "span"
            case Paragraph: return "p"
            case Heading(1): return "h1"
            case Heading(2): return "h2"
            case Heading(3): return "h3"
            case Heading(4): return "h4"
            case Heading(5): return "h5"
            case Heading(_): return "h6"
            case Button: return "button"
            case Input: return "input"
            case Checkbox: return "input"
            case Radio: return "input"
            case Select: return "select"
            case List: return "ul"
            case ListItem: return "li"
            case Table: return "table"
            case TableRow: return "tr"
            case TableCell: return "td"
            case Row: return "div"
            case Column: return "div"
            case Grid: return "div"
            case Header: return "header"
            case Footer: return "footer"
            case Nav: return "nav"
            case Main: return "main"
            case Section: return "section"
            case Article: return "article"
            case Aside: return "aside"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_container(self) -> bool:
        """Check if element is a container type.

        Returns:
            true for Div/Box/Row/Column/Grid

        Example:
            ElementKind::Div.is_container()  # → true
        """
        match self:
            case Div | Box | Row | Column | Grid:
                return true
            case _:
                return false

    pub fn is_text_element(self) -> bool:
        """Check if element is a text-based element.

        Returns:
            true for Text/Paragraph/Heading

        Example:
            ElementKind::Paragraph.is_text_element()  # → true
        """
        match self:
            case Text | Paragraph | Heading(_):
                return true
            case _:
                return false

    pub fn is_semantic(self) -> bool:
        """Check if element is semantic.

        Returns:
            true for Header/Footer/Nav/Main/Section/Article/Aside

        Example:
            ElementKind::Header.is_semantic()  # → true
        """
        match self:
            case Header | Footer | Nav | Main | Section | Article | Aside:
                return true
            case _:
                return false

    pub fn is_layout(self) -> bool:
        """Check if element is a layout container.

        Returns:
            true for Row/Column/Grid

        Example:
            ElementKind::Grid.is_layout()  # → true
        """
        match self:
            case Row | Column | Grid:
                return true
            case _:
                return false

    pub fn is_table_element(self) -> bool:
        """Check if element is table-related.

        Returns:
            true for Table/TableRow/TableCell

        Example:
            ElementKind::Table.is_table_element()  # → true
        """
        match self:
            case Table | TableRow | TableCell:
                return true
            case _:
                return false

    pub fn is_list_element(self) -> bool:
        """Check if element is list-related.

        Returns:
            true for List/ListItem

        Example:
            ElementKind::List.is_list_element()  # → true
        """
        match self:
            case List | ListItem:
                return true
            case _:
                return false

    pub fn is_input_element(self) -> bool:
        """Check if element is an input control.

        Returns:
            true for Input/Checkbox/Radio/Select

        Example:
            ElementKind::Input.is_input_element()  # → true
        """
        match self:
            case Input | Checkbox | Radio | Select:
                return true
            case _:
                return false

    pub fn is_heading(self) -> bool:
        """Check if element is a heading.

        Returns:
            true for Heading variant

        Example:
            ElementKind::Heading(1).is_heading()  # → true
        """
        match self:
            case Heading(_):
                return true
            case _:
                return false

    pub fn get_heading_level(self) -> Option<u8>:
        """Get heading level if this is a heading.

        Returns:
            Heading level (1-6) or None

        Example:
            ElementKind::Heading(2).get_heading_level()  # → Some(2)
        """
        match self:
            case Heading(level):
                return Some(level)
            case _:
                return None

    pub fn supports_children(self) -> bool:
        """Check if element can contain children.

        Returns:
            true if element can have child elements

        Example:
            ElementKind::Div.supports_children()  # → true
        """
        match self:
            case Text:
                return false
            case Input | Checkbox | Radio:
                return false
            case _:
                return true

    pub fn is_void_element(self) -> bool:
        """Check if element is a void element (no children).

        Returns:
            true for elements that cannot have children

        Example:
            ElementKind::Input.is_void_element()  # → true
        """
        return not self.supports_children()

    pub fn to_string(self) -> text:
        """Convert element kind to string.

        Returns:
            Element kind name

        Example:
            ElementKind::Button.to_string()  # → "button"
        """
        return self.tag_name().to_string()

    fn description() -> text:
        """Get element kind description.

        Returns:
            Human-readable description

        Example:
            ElementKind::Button.description()
            # → "Clickable button element"
        """
        match self:
            case Div: "Generic block container"
            case Span: "Generic inline container"
            case Box: "Box with border (TUI: box drawing, GUI: CSS box)"
            case Text: "Plain text node"
            case Paragraph: "Block-level text paragraph"
            case Heading(1): "Heading level 1 (largest)"
            case Heading(2): "Heading level 2"
            case Heading(3): "Heading level 3"
            case Heading(4): "Heading level 4"
            case Heading(5): "Heading level 5"
            case Heading(_): "Heading level 6 (smallest)"
            case Button: "Clickable button element"
            case Input: "Text input field"
            case Checkbox: "Boolean toggle checkbox"
            case Radio: "Radio button (one of many)"
            case Select: "Dropdown selection menu"
            case List: "Ordered or unordered list container"
            case ListItem: "Item within a list"
            case Table: "Data table container"
            case TableRow: "Table row element"
            case TableCell: "Table cell element"
            case Row: "Horizontal flex container"
            case Column: "Vertical flex container"
            case Grid: "Grid layout container"
            case Header: "Page or section header"
            case Footer: "Page or section footer"
            case Nav: "Navigation menu container"
            case Main: "Main content area"
            case Section: "Generic section container"
            case Article: "Self-contained content article"
            case Aside: "Sidebar or related content"

    pub fn summary(self) -> text:
        """Get element kind summary.

        Returns:
            Human-readable summary

        Example:
            ElementKind::Heading(2).summary()  # → "ElementKind: h2 (text, block)"
        """
        val tag = self.tag_name()
        var props = []

        if self.is_text_element():
            props.push("text")
        if self.is_interactive():
            props.push("interactive")
        if self.is_layout():
            props.push("layout")
        if self.is_semantic():
            props.push("semantic")
        if self.is_block():
            props.push("block")
        else:
            props.push("inline")

        val props_str = props.join(", ")
        return "ElementKind: {tag} ({props_str})"

# An Element in the UI tree
pub struct Element:
    # Unique identifier for this element
    id: NodeId
    # Element type
    kind: ElementKind
    # Optional key for keyed diffing
    key: Option<text>
    # Attributes (name -> value)
    attrs: Dict<text, text>
    # CSS classes
    classes: Array<text>
    # Inline styles (property -> value)
    styles: Dict<text, text>
    # Text content (for text elements)
    text: Option<text>
    # Child elements
    children: Array<Element>
    # Event handlers (event_name -> handler_id)
    events: Dict<text, u64>
    # Focus order (for keyboard navigation)
    tab_index: Option<i32>
    # Whether this element is currently focused
    focused: bool

impl Element:
    # Create a new element with the given kind
    pub fn new(id: NodeId, kind: ElementKind) -> Element:
        return Element {
            id: id,
            kind: kind,
            key: None,
            attrs: Dict::new(),
            classes: [],
            styles: Dict::new(),
            text: None,
            children: [],
            events: Dict::new(),
            tab_index: None,
            focused: false
        }

    # Create a text element
    pub fn text(id: NodeId, content: &str) -> Element:
        var elem = Element::new(id, ElementKind::Text)
        elem.text = Some(content.to_string())
        return elem

    # Create a div element
    pub fn div(id: NodeId) -> Element:
        return Element::new(id, ElementKind::Div)

    # Create a span element
    pub fn span(id: NodeId) -> Element:
        return Element::new(id, ElementKind::Span)

    # Create a button element
    pub fn button(id: NodeId, label: &str) -> Element:
        var elem = Element::new(id, ElementKind::Button)
        elem.text = Some(label.to_string())
        elem.tab_index = Some(0)
        return elem

    # Create an input element
    pub fn input(id: NodeId) -> Element:
        var elem = Element::new(id, ElementKind::Input)
        elem.tab_index = Some(0)
        return elem

    # Builder: set key for diffing
    pub fn with_key(self, key: &str) -> Element:
        self.key = Some(key.to_string())
        return self

    # Builder: set attribute
    pub fn with_attr(self, name: &str, value: &str) -> Element:
        self.attrs.set(name.to_string(), value.to_string())
        return self

    # Builder: add class
    pub fn with_class(self, class: &str) -> Element:
        self.classes.push(class.to_string())
        return self

    # Builder: set style
    pub fn with_style(self, prop: &str, value: &str) -> Element:
        self.styles.set(prop.to_string(), value.to_string())
        return self

    # Builder: set text content
    pub fn with_text(self, text: &str) -> Element:
        self.text = Some(text.to_string())
        return self

    # Builder: add child element
    pub fn with_child(self, child: Element) -> Element:
        self.children.push(child)
        return self

    # Builder: add multiple children
    pub fn with_children(self, children: Array<Element>) -> Element:
        for child in children:
            self.children.push(child)
        return self

    # Builder: set event handler
    pub fn on_event(self, event: &str, handler_id: u64) -> Element:
        self.events.set(event.to_string(), handler_id)
        return self

    # Builder: set tab index
    pub fn with_tab_index(self, index: i32) -> Element:
        self.tab_index = Some(index)
        return self

    # Set focus on this element
    pub fn focus(self):
        self.focused = true

    # Remove focus from this element
    pub fn blur(self):
        self.focused = false

    # Check if element has children
    pub fn has_children(self) -> bool:
        return not self.children.is_empty()

    # Get child by index
    pub fn child_at(self, index: u64) -> Option<&Element>:
        if index < self.children.len():
            return Some(&self.children[index])
        return None

    # Find child by key
    pub fn find_by_key(self, key: &str) -> Option<&Element>:
        for child in &self.children:
            match &child.key:
                case Some(k):
                    if k == key:
                        return Some(child)
                case None: pass
        return None

    # Find descendant by ID (recursive)
    pub fn find_by_id(self, id: NodeId) -> Option<&Element>:
        if self.id == id:
            return Some(&self)
        for child in &self.children:
            match child.find_by_id(id):
                case Some(elem): return Some(elem)
                case None: pass
        return None

    # Get all focusable descendants in tab order
    pub fn focusable_elements(self) -> Array<&Element>:
        var result: Array<&Element> = []
        self._collect_focusable(&mut result)
        # Sort by tab_index
        result.sort_by(|a, b| a.tab_index.unwrap_or(0).cmp(&b.tab_index.unwrap_or(0)))
        return result

    fn _collect_focusable(result: &mut Array<&Element>):
        if self.tab_index.is_some():
            result.push(&self)
        for child in &self.children:
            child._collect_focusable(result)

# Element tree for a complete UI
pub struct ElementTree:
    root: Element
    next_id: u64
    focus_id: Option<NodeId>

impl ElementTree:
    # Create a new element tree with a root element
    pub fn new(root_kind: ElementKind) -> ElementTree:
        val root_id = NodeId::new(0)
        return ElementTree {
            root: Element::new(root_id, root_kind),
            next_id: 1,
            focus_id: None
        }

    # Allocate a new NodeId
    pub fn alloc_id(self) -> NodeId:
        val id = NodeId::new(self.next_id)
        self.next_id = self.next_id + 1
        return id

    # Get the root element
    pub fn root(self) -> &Element:
        return &self.root

    # Get mutable root element
    pub fn root_mut(self) -> &mut Element:
        return &mut self.root

    # Find element by ID
    pub fn find(self, id: NodeId) -> Option<&Element>:
        return self.root.find_by_id(id)

    # Get currently focused element
    pub fn focused(self) -> Option<&Element>:
        match self.focus_id:
            case Some(id): return self.find(id)
            case None: return None

    # Set focus to element by ID
    pub fn set_focus(self, id: NodeId):
        # Clear previous focus
        if val Some(old_id) = self.focus_id:
            if val Some(old) = self.root.find_by_id(old_id):
                old.blur()
        # Set new focus
        if val Some(elem) = self.root.find_by_id(id):
            elem.focus()
            self.focus_id = Some(id)

    # Move focus to next focusable element
    pub fn focus_next(self):
        val focusable = self.root.focusable_elements()
        if focusable.is_empty():
            return

        match self.focus_id:
            case Some(current_id):
                # Find current index and move to next
                for i in 0..focusable.len():
                    if focusable[i].id == current_id:
                        val next_idx = (i + 1) % focusable.len()
                        self.set_focus(focusable[next_idx].id)
                        return
                # Current not found, focus first
                self.set_focus(focusable[0].id)
            case None:
                # Focus first focusable element
                self.set_focus(focusable[0].id)

    # Move focus to previous focusable element
    pub fn focus_prev(self):
        val focusable = self.root.focusable_elements()
        if focusable.is_empty():
            return

        match self.focus_id:
            case Some(current_id):
                # Find current index and move to previous
                for i in 0..focusable.len():
                    if focusable[i].id == current_id:
                        val prev_idx = if i == 0 { focusable.len() - 1 } else { i - 1 }
                        self.set_focus(focusable[prev_idx].id)
                        return
                # Current not found, focus last
                self.set_focus(focusable[focusable.len() - 1].id)
            case None:
                # Focus last focusable element
                self.set_focus(focusable[focusable.len() - 1].id)
