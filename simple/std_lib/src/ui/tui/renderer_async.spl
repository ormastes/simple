# TUI Async Renderer - Terminal UI Backend
#
# Renders UI elements to terminal using ANSI escape codes and box-drawing characters.
# Demonstrates that the same Element/PatchSet API works for terminal output.
#
# Key Features:
#   - ANSI color support (16 colors, 256 colors, true color)
#   - Box drawing characters (Unicode)
#   - Keyboard and mouse input
#   - Async rendering with terminal buffering
#   - Layout calculation for text-based UI
#   - Focus management

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*

# =============================================================================
# TUI Async Renderer (Terminal-based)
# =============================================================================

pub struct TuiAsyncRenderer:
    # Terminal state
    terminal_fd: i32           # File descriptor (stdin/stdout)
    width: u16                 # Terminal width in columns
    height: u16                # Terminal height in rows

    # Display buffer (double buffering)
    front_buffer: TerminalBuffer
    back_buffer: TerminalBuffer

    # Element tracking
    layout_cache: LayoutCache
    focus_id: Option[NodeId]

    # State
    initialized: bool
    mouse_enabled: bool
    alternate_screen: bool

    # Current tree (for diffing)
    current_tree: Option[ElementTree]

impl TuiAsyncRenderer:
    # Create a new TUI renderer
    pub fn new() -> Result[TuiAsyncRenderer, RenderError]:
        return Ok(TuiAsyncRenderer {
            terminal_fd: 0,  # Will be set in init
            width: 80,       # Default, updated in init
            height: 24,      # Default, updated in init
            front_buffer: TerminalBuffer::new(80, 24),
            back_buffer: TerminalBuffer::new(80, 24),
            layout_cache: LayoutCache::new(),
            focus_id: None,
            initialized: false,
            mouse_enabled: false,
            alternate_screen: false,
            current_tree: None
        })

    # Create with options
    pub fn with_mouse(mut self) -> TuiAsyncRenderer:
        self.mouse_enabled = true
        return self

    pub fn with_alternate_screen(mut self) -> TuiAsyncRenderer:
        self.alternate_screen = true
        return self

# =============================================================================
# Async RenderBackend Implementation
# =============================================================================

impl RenderBackend for TuiAsyncRenderer:
    async fn init(self) -> Future[Result[(), RenderError]]:
        if self.initialized:
            return Future::ready(Err(RenderError::AlreadyInitialized))

        # Get terminal file descriptor
        self.terminal_fd = await terminal_get_fd()

        # Enter raw mode (disable line buffering, echo, etc.)
        await terminal_enter_raw_mode(self.terminal_fd)

        # Get terminal size
        let (width, height) = await terminal_get_size(self.terminal_fd)
        self.width = width
        self.height = height

        # Resize buffers
        self.front_buffer = TerminalBuffer::new(width, height)
        self.back_buffer = TerminalBuffer::new(width, height)

        # Enter alternate screen (optional)
        if self.alternate_screen:
            await terminal_write(self.terminal_fd, "\x1b[?1049h")  # Enter alt screen

        # Enable mouse (optional)
        if self.mouse_enabled:
            await terminal_write(self.terminal_fd, "\x1b[?1000h")  # Enable mouse tracking
            await terminal_write(self.terminal_fd, "\x1b[?1003h")  # Enable any-event tracking

        # Hide cursor
        await terminal_write(self.terminal_fd, "\x1b[?25l")

        # Clear screen
        await terminal_write(self.terminal_fd, "\x1b[2J")
        await terminal_write(self.terminal_fd, "\x1b[H")

        self.initialized = true
        return Future::ready(Ok(()))

    async fn shutdown(self) -> Future[Result[(), RenderError]]:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Show cursor
        await terminal_write(self.terminal_fd, "\x1b[?25h")

        # Disable mouse
        if self.mouse_enabled:
            await terminal_write(self.terminal_fd, "\x1b[?1000l")
            await terminal_write(self.terminal_fd, "\x1b[?1003l")

        # Exit alternate screen
        if self.alternate_screen:
            await terminal_write(self.terminal_fd, "\x1b[?1049l")

        # Leave raw mode
        await terminal_exit_raw_mode(self.terminal_fd)

        self.initialized = false
        return Future::ready(Ok(()))

    fn dimensions(self) -> (u16, u16):
        return (self.width, self.height)

    # Render element tree to terminal
    async fn render(self, tree: &ElementTree) -> Future[Result[(), RenderError]]:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Compute layout
        let layout_result = self.compute_layout(tree)

        # Render to back buffer
        self.back_buffer.clear()
        self.render_element_to_buffer(tree.root(), &layout_result, &mut self.back_buffer)

        # Swap buffers and flush diff to terminal
        await self.flush_buffer_diff()

        # Store tree for diffing
        self.current_tree = Some(tree.clone())

        return Future::ready(Ok(()))

    async fn apply_patches(self, patches: &PatchSet) -> Future[Result[(), RenderError]]:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # For TUI, we typically re-render the whole screen
        # (incremental updates are harder with terminal rendering)
        # But we can optimize by only updating dirty regions

        if let Some(tree) = &self.current_tree:
            # Apply patches to tree
            let updated_tree = self.apply_patches_to_tree(tree, patches)
            # Re-render
            await self.render(&updated_tree)

        return Future::ready(Ok(()))

    async fn clear(self) -> Future[Result[(), RenderError]]:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Clear both buffers
        self.front_buffer.clear()
        self.back_buffer.clear()

        # Clear terminal
        await terminal_write(self.terminal_fd, "\x1b[2J")
        await terminal_write(self.terminal_fd, "\x1b[H")

        return Future::ready(Ok(()))

    async fn flush(self) -> Future[Result[(), RenderError]]:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Flush any pending writes
        await terminal_flush(self.terminal_fd)

        return Future::ready(Ok(()))

    # Poll terminal events (keyboard, mouse, resize)
    async fn poll_event(self, timeout_ms: u64) -> Future[Result[Option[Event], RenderError]]:
        if not self.initialized:
            return Future::ready(Err(RenderError::NotInitialized))

        # Poll terminal for input with timeout
        let input = await terminal_poll_input(self.terminal_fd, timeout_ms)

        match input:
            case Some(bytes):
                # Parse input bytes into Event
                let event = self.parse_input_bytes(&bytes)
                return Future::ready(Ok(Some(event)))
            case None:
                return Future::ready(Ok(None))

    async fn read_event(self) -> Future[Result[Event, RenderError]]:
        # Block until event arrives
        loop:
            match await self.poll_event(1000):
                case Ok(Some(event)): return Future::ready(Ok(event))
                case Ok(None): pass
                case Err(e): return Future::ready(Err(e))

# =============================================================================
# Internal Implementation
# =============================================================================

impl TuiAsyncRenderer:
    # Compute layout for terminal
    fn compute_layout(self, tree: &ElementTree) -> LayoutResult:
        # Terminal layout is character-based
        let mut result = LayoutResult::default()

        # Root element takes full terminal
        let root_layout = Layout::new(0, 0, self.width, self.height)
        result.bounds.set(tree.root().id.value(), self.layout_to_rect(root_layout))

        # Recursively layout children
        self.layout_element(tree.root(), root_layout, &mut result)

        return result

    fn layout_element(self, elem: &Element, parent_layout: Layout, result: &mut LayoutResult):
        # Simple vertical stacking for now
        # TODO: Implement proper flexbox/grid layout

        let num_children = elem.children.len() as u16
        if num_children == 0:
            return

        let child_height = parent_layout.content_height / num_children.max(1)
        let mut y = parent_layout.content_y

        for child in &elem.children:
            let child_layout = Layout::new(
                parent_layout.content_x,
                y,
                parent_layout.content_width,
                child_height
            )

            result.bounds.set(child.id.value(), self.layout_to_rect(child_layout))
            self.layout_element(child, child_layout, result)

            y = y + child_height

    fn layout_to_rect(self, layout: Layout) -> Rect:
        return Rect {
            x: layout.x as f32,
            y: layout.y as f32,
            width: layout.width as f32,
            height: layout.height as f32
        }

    # Render element to terminal buffer
    fn render_element_to_buffer(self, elem: &Element, layout: &LayoutResult, buffer: &mut TerminalBuffer):
        # Get layout bounds
        let bounds = match layout.bounds.get(&elem.id.value()):
            case Some(rect): rect
            case None: return

        let x = bounds.x as u16
        let y = bounds.y as u16
        let w = bounds.width as u16
        let h = bounds.height as u16

        # Render based on element type
        match elem.kind:
            case ElementKind::Box:
                self.render_box(x, y, w, h, elem, buffer)
            case ElementKind::Button:
                self.render_button(x, y, w, h, elem, buffer)
            case ElementKind::Text:
                self.render_text(x, y, w, h, elem, buffer)
            case ElementKind::Paragraph:
                self.render_paragraph(x, y, w, h, elem, buffer)
            case _:
                # Default: just render background
                self.render_background(x, y, w, h, elem, buffer)

        # Render children
        for child in &elem.children:
            self.render_element_to_buffer(child, layout, buffer)

    fn render_box(self, x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        # Draw box with Unicode box-drawing characters
        let (fg, bg) = self.get_colors(elem)

        # Top edge
        buffer.set_cell(x, y, Cell::new('┌', fg, bg))
        for i in 1..(w-1):
            buffer.set_cell(x + i, y, Cell::new('─', fg, bg))
        buffer.set_cell(x + w - 1, y, Cell::new('┐', fg, bg))

        # Sides
        for j in 1..(h-1):
            buffer.set_cell(x, y + j, Cell::new('│', fg, bg))
            buffer.set_cell(x + w - 1, y + j, Cell::new('│', fg, bg))

        # Bottom edge
        buffer.set_cell(x, y + h - 1, Cell::new('└', fg, bg))
        for i in 1..(w-1):
            buffer.set_cell(x + i, y + h - 1, Cell::new('─', fg, bg))
        buffer.set_cell(x + w - 1, y + h - 1, Cell::new('┘', fg, bg))

    fn render_button(self, x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        let (fg, bg) = self.get_colors(elem)

        # Draw button background
        for j in 0..h:
            for i in 0..w:
                buffer.set_cell(x + i, y + j, Cell::new(' ', fg, bg))

        # Draw label (centered)
        if let Some(text) = &elem.text:
            let text_len = text.len() as u16
            let text_x = x + (w - text_len) / 2
            let text_y = y + h / 2

            for (i, ch) in text.chars().enumerate():
                buffer.set_cell(text_x + (i as u16), text_y, Cell::new(ch, fg, bg))

        # Draw border if focused
        if elem.focused:
            self.render_box(x, y, w, h, elem, buffer)

    fn render_text(self, x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        let (fg, bg) = self.get_colors(elem)

        if let Some(text) = &elem.text:
            # Render single line of text
            for (i, ch) in text.chars().enumerate():
                if i as u16 >= w:
                    break
                buffer.set_cell(x + (i as u16), y, Cell::new(ch, fg, bg))

    fn render_paragraph(self, x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        let (fg, bg) = self.get_colors(elem)

        if let Some(text) = &elem.text:
            # Word wrap text
            let lines = self.wrap_text(text, w)

            for (j, line) in lines.iter().enumerate():
                if j as u16 >= h:
                    break
                for (i, ch) in line.chars().enumerate():
                    if i as u16 >= w:
                        break
                    buffer.set_cell(x + (i as u16), y + (j as u16), Cell::new(ch, fg, bg))

    fn render_background(self, x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        let (fg, bg) = self.get_colors(elem)

        for j in 0..h:
            for i in 0..w:
                buffer.set_cell(x + i, y + j, Cell::new(' ', fg, bg))

    fn get_colors(self, elem: &Element) -> (Color, Color):
        let fg = match elem.styles.get("color"):
            case Some(color_str): parse_color_string(color_str)
            case None: Color::Default

        let bg = match elem.styles.get("background-color"):
            case Some(color_str): parse_color_string(color_str)
            case None: Color::Default

        return (fg, bg)

    fn wrap_text(self, text: &str, width: u16) -> Array[String]:
        # Simple word wrapping
        let mut lines: Array[String] = []
        let mut current_line = String::new()

        for word in text.split(' '):
            if (current_line.len() + word.len() + 1) as u16 > width:
                if not current_line.is_empty():
                    lines.push(current_line)
                    current_line = String::new()

            if not current_line.is_empty():
                current_line.push(' ')
            current_line.push_str(word)

        if not current_line.is_empty():
            lines.push(current_line)

        return lines

    # Flush buffer diff to terminal
    async fn flush_buffer_diff(self) -> Future[()]:
        # Compare front and back buffers, output only diff
        let mut output = String::new()

        for y in 0..self.height:
            for x in 0..self.width:
                let front_cell = self.front_buffer.get_cell(x, y)
                let back_cell = self.back_buffer.get_cell(x, y)

                if front_cell != back_cell:
                    # Move cursor to position
                    output.push_str(&"\x1b[{y + 1};{x + 1}H")

                    # Set colors if changed
                    if front_cell.fg != back_cell.fg or front_cell.bg != back_cell.bg:
                        output.push_str(&self.color_to_ansi(back_cell.fg, back_cell.bg))

                    # Output character
                    output.push(back_cell.ch)

        # Write to terminal
        if not output.is_empty():
            await terminal_write(self.terminal_fd, &output)

        # Swap buffers
        let temp = self.front_buffer
        self.front_buffer = self.back_buffer
        self.back_buffer = temp

        return Future::ready(())

    fn color_to_ansi(self, fg: Color, bg: Color) -> String:
        let mut result = String::new()

        # Foreground color
        match fg:
            case Color::Black: result.push_str("\x1b[30m")
            case Color::Red: result.push_str("\x1b[31m")
            case Color::Green: result.push_str("\x1b[32m")
            case Color::Yellow: result.push_str("\x1b[33m")
            case Color::Blue: result.push_str("\x1b[34m")
            case Color::Magenta: result.push_str("\x1b[35m")
            case Color::Cyan: result.push_str("\x1b[36m")
            case Color::White: result.push_str("\x1b[37m")
            case Color::Default: result.push_str("\x1b[39m")
            case Color::Rgb(r, g, b):
                result.push_str(&"\x1b[38;2;{r};{g};{b}m")
            case _: pass

        # Background color
        match bg:
            case Color::Black: result.push_str("\x1b[40m")
            case Color::Red: result.push_str("\x1b[41m")
            case Color::Green: result.push_str("\x1b[42m")
            case Color::Yellow: result.push_str("\x1b[43m")
            case Color::Blue: result.push_str("\x1b[44m")
            case Color::Magenta: result.push_str("\x1b[45m")
            case Color::Cyan: result.push_str("\x1b[46m")
            case Color::White: result.push_str("\x1b[47m")
            case Color::Default: result.push_str("\x1b[49m")
            case Color::Rgb(r, g, b):
                result.push_str(&"\x1b[48;2;{r};{g};{b}m")
            case _: pass

        return result

    # Parse terminal input into Event
    fn parse_input_bytes(self, bytes: &Array[u8]) -> Event:
        # Parse ANSI escape sequences
        if bytes.is_empty():
            return Event::Key(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })

        # Special keys (escape sequences)
        if bytes[0] == 0x1b:  # ESC
            if bytes.len() == 1:
                return Event::Key(KeyEvent { code: KeyCode::Escape, modifiers: KeyModifiers::none() })

            # Arrow keys, function keys, etc.
            if bytes.len() >= 3 and bytes[1] == 0x5b:  # ESC [
                match bytes[2]:
                    case 0x41: return Event::Key(KeyEvent { code: KeyCode::Up, modifiers: KeyModifiers::none() })
                    case 0x42: return Event::Key(KeyEvent { code: KeyCode::Down, modifiers: KeyModifiers::none() })
                    case 0x43: return Event::Key(KeyEvent { code: KeyCode::Right, modifiers: KeyModifiers::none() })
                    case 0x44: return Event::Key(KeyEvent { code: KeyCode::Left, modifiers: KeyModifiers::none() })
                    case _: pass

            # Mouse events
            if bytes.len() >= 6 and bytes[1] == 0x5b and bytes[2] == 0x4d:  # ESC [ M
                let button = bytes[3] - 32
                let x = (bytes[4] - 32) as u16
                let y = (bytes[5] - 32) as u16

                let kind = if button & 0x3 == 0:
                    MouseEventKind::Down(MouseButton::Left)
                else if button & 0x3 == 1:
                    MouseEventKind::Down(MouseButton::Middle)
                else:
                    MouseEventKind::Down(MouseButton::Right)

                return Event::Mouse(MouseEvent::new(kind, x, y))

        # Regular keys
        match bytes[0]:
            case 0x0d: return Event::Key(KeyEvent { code: KeyCode::Enter, modifiers: KeyModifiers::none() })
            case 0x7f: return Event::Key(KeyEvent { code: KeyCode::Backspace, modifiers: KeyModifiers::none() })
            case 0x09: return Event::Key(KeyEvent { code: KeyCode::Tab, modifiers: KeyModifiers::none() })
            case ch:
                return Event::Key(KeyEvent {
                    code: KeyCode::Char(ch as char),
                    modifiers: KeyModifiers::none()
                })

    fn apply_patches_to_tree(self, tree: &ElementTree, patches: &PatchSet) -> ElementTree:
        # TODO: Apply patches to tree
        return tree.clone()

# =============================================================================
# Terminal Buffer (Double Buffering)
# =============================================================================

struct TerminalBuffer:
    width: u16
    height: u16
    cells: Array[Cell]

impl TerminalBuffer:
    fn new(width: u16, height: u16) -> TerminalBuffer:
        let size = (width * height) as u64
        let mut cells: Array[Cell] = []
        for _ in 0..size:
            cells.push(Cell::default())

        return TerminalBuffer {
            width: width,
            height: height,
            cells: cells
        }

    fn clear(self):
        for cell in &mut self.cells:
            *cell = Cell::default()

    fn get_cell(self, x: u16, y: u16) -> &Cell:
        if x >= self.width or y >= self.height:
            # Return default cell for out-of-bounds
            return &Cell::default()

        let idx = (y * self.width + x) as u64
        return &self.cells[idx]

    fn set_cell(self, x: u16, y: u16, cell: Cell):
        if x >= self.width or y >= self.height:
            return

        let idx = (y * self.width + x) as u64
        self.cells[idx] = cell

struct Cell:
    ch: char
    fg: Color
    bg: Color

impl Cell:
    fn new(ch: char, fg: Color, bg: Color) -> Cell:
        return Cell { ch: ch, fg: fg, bg: bg }

    fn default() -> Cell:
        return Cell {
            ch: ' ',
            fg: Color::Default,
            bg: Color::Default
        }

impl Eq for Cell:
    fn eq(self, other: &Cell) -> bool:
        return self.ch == other.ch and self.fg == other.fg and self.bg == other.bg

# =============================================================================
# Terminal FFI (OS-specific)
# =============================================================================

# Terminal API functions (implemented via FFI to termios/Windows Console API)

extern async fn terminal_get_fd() -> Future[i32]
extern async fn terminal_enter_raw_mode(fd: i32) -> Future[()]
extern async fn terminal_exit_raw_mode(fd: i32) -> Future[()]
extern async fn terminal_get_size(fd: i32) -> Future[(u16, u16)]
extern async fn terminal_write(fd: i32, data: &str) -> Future[()]
extern async fn terminal_flush(fd: i32) -> Future[()]
extern async fn terminal_poll_input(fd: i32, timeout_ms: u64) -> Future[Option[Array[u8]]]

# Helper function (from attrs.spl)
fn parse_color_string(s: &str) -> Color:
    match s.to_lowercase().as_str():
        case "black": return Color::Black
        case "red": return Color::Red
        case "green": return Color::Green
        case "yellow": return Color::Yellow
        case "blue": return Color::Blue
        case "magenta": return Color::Magenta
        case "cyan": return Color::Cyan
        case "white": return Color::White
        case _: return Color::Default

# Supporting types
struct Rect:
    x: f32
    y: f32
    width: f32
    height: f32

struct LayoutResult:
    bounds: Dict[u64, Rect]

impl LayoutResult:
    fn default() -> LayoutResult:
        return LayoutResult { bounds: Dict::new() }

struct LayoutCache:
    cache: Dict[u64, Layout]

impl LayoutCache:
    fn new() -> LayoutCache:
        return LayoutCache { cache: Dict::new() }
