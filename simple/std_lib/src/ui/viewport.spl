# Viewport - Screen and Viewport Management
#
# Platform-agnostic viewport and screen management for UI rendering.
# Handles window size, DPI scaling, orientation, and layout constraints.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.widget.*

# Viewport dimensions and properties
pub struct Viewport:
    # Physical dimensions (pixels)
    pub width: u32
    pub height: u32
    # Logical dimensions (DIP - device-independent pixels)
    pub logical_width: f64
    pub logical_height: f64
    # Device pixel ratio (physical pixels per logical pixel)
    pub dpr: f64
    # Safe area insets (for notched screens, etc.)
    pub safe_area: EdgeInsets
    # Viewport orientation
    pub orientation: Orientation

# Screen orientation
pub enum Orientation:
    Portrait
    Landscape
    PortraitReverse
    LandscapeReverse

impl Orientation:
    pub fn is_portrait(self) -> bool:
        match self:
            case Orientation::Portrait: return true
            case Orientation::PortraitReverse: return true
            case _: return false

    pub fn is_landscape(self) -> bool:
        return not self.is_portrait()

impl Viewport:
    # Create a viewport with physical dimensions
    pub fn new(width: u32, height: u32, dpr: f64) -> Viewport:
        return Viewport {
            width: width,
            height: height,
            logical_width: (width as f64) / dpr,
            logical_height: (height as f64) / dpr,
            dpr: dpr,
            safe_area: EdgeInsets::zero(),
            orientation: if width > height {
                Orientation::Landscape
            } else {
                Orientation::Portrait
            }
        }

    # Create from logical dimensions
    pub fn from_logical(logical_width: f64, logical_height: f64, dpr: f64) -> Viewport:
        return Viewport {
            width: (logical_width * dpr) as u32,
            height: (logical_height * dpr) as u32,
            logical_width: logical_width,
            logical_height: logical_height,
            dpr: dpr,
            safe_area: EdgeInsets::zero(),
            orientation: if logical_width > logical_height {
                Orientation::Landscape
            } else {
                Orientation::Portrait
            }
        }

    # Set safe area insets
    pub fn with_safe_area(self, insets: EdgeInsets) -> Viewport:
        self.safe_area = insets
        return self

    # Get aspect ratio
    pub fn aspect_ratio(self) -> f64:
        return self.logical_width / self.logical_height

    # Convert physical pixels to logical
    pub fn to_logical(self, physical: i32) -> f64:
        return (physical as f64) / self.dpr

    # Convert logical pixels to physical
    pub fn to_physical(self, logical: f64) -> i32:
        return (logical * self.dpr) as i32

    # Get usable area (excluding safe area)
    pub fn usable_width(self) -> f64:
        return self.logical_width - (self.safe_area.left as f64) - (self.safe_area.right as f64)

    pub fn usable_height(self) -> f64:
        return self.logical_height - (self.safe_area.top as f64) - (self.safe_area.bottom as f64)

# Viewport constraints for responsive layout
pub struct ViewportConstraints:
    pub min_width: Option[f64]
    pub max_width: Option[f64]
    pub min_height: Option[f64]
    pub max_height: Option[f64]

impl ViewportConstraints:
    pub fn unbounded() -> ViewportConstraints:
        return ViewportConstraints {
            min_width: None,
            max_width: None,
            min_height: None,
            max_height: None
        }

    pub fn tight(width: f64, height: f64) -> ViewportConstraints:
        return ViewportConstraints {
            min_width: Some(width),
            max_width: Some(width),
            min_height: Some(height),
            max_height: Some(height)
        }

    pub fn check_viewport(self, viewport: &Viewport) -> bool:
        if let Some(min_w) = self.min_width:
            if viewport.logical_width < min_w:
                return false

        if let Some(max_w) = self.max_width:
            if viewport.logical_width > max_w:
                return false

        if let Some(min_h) = self.min_height:
            if viewport.logical_height < min_h:
                return false

        if let Some(max_h) = self.max_height:
            if viewport.logical_height > max_h:
                return false

        return true

# Responsive breakpoints (common screen sizes)
pub struct Breakpoints:
    pub xs: f64   # Extra small (mobile portrait)
    pub sm: f64   # Small (mobile landscape, small tablets)
    pub md: f64   # Medium (tablets)
    pub lg: f64   # Large (desktop)
    pub xl: f64   # Extra large (large desktop)
    pub xxl: f64  # Extra extra large (ultra-wide)

impl Breakpoints:
    # Default breakpoints (based on common conventions)
    pub fn default() -> Breakpoints:
        return Breakpoints {
            xs: 0.0,
            sm: 640.0,
            md: 768.0,
            lg: 1024.0,
            xl: 1280.0,
            xxl: 1536.0
        }

    # Get current breakpoint for viewport
    pub fn current(self, viewport: &Viewport) -> BreakpointSize:
        let width = viewport.logical_width

        if width >= self.xxl:
            return BreakpointSize::XXL
        else if width >= self.xl:
            return BreakpointSize::XL
        else if width >= self.lg:
            return BreakpointSize::LG
        else if width >= self.md:
            return BreakpointSize::MD
        else if width >= self.sm:
            return BreakpointSize::SM
        else:
            return BreakpointSize::XS

pub enum BreakpointSize:
    XS
    SM
    MD
    LG
    XL
    XXL

# Screen manager - tracks viewport changes
pub struct ScreenManager:
    viewport: Viewport
    breakpoints: Breakpoints
    listeners: Array[fn(&Viewport)]

impl ScreenManager:
    # Create a new screen manager
    pub fn new(viewport: Viewport) -> ScreenManager:
        return ScreenManager {
            viewport: viewport,
            breakpoints: Breakpoints::default(),
            listeners: []
        }

    # Get current viewport
    pub fn viewport(self) -> &Viewport:
        return &self.viewport

    # Update viewport (e.g., on window resize)
    pub fn update_viewport(self, new_viewport: Viewport):
        let old_breakpoint = self.breakpoints.current(&self.viewport)
        let new_breakpoint = self.breakpoints.current(&new_viewport)

        self.viewport = new_viewport

        # Notify listeners
        for listener in &self.listeners:
            listener(&self.viewport)

        # Check if breakpoint changed (for responsive layouts)
        if old_breakpoint != new_breakpoint:
            # Would trigger layout recalculation
            pass

    # Register a viewport change listener
    pub fn on_resize(self, listener: fn(&Viewport)):
        self.listeners.push(listener)

    # Get current breakpoint
    pub fn current_breakpoint(self) -> BreakpointSize:
        return self.breakpoints.current(&self.viewport)

    # Check if viewport matches constraints
    pub fn matches(self, constraints: &ViewportConstraints) -> bool:
        return constraints.check_viewport(&self.viewport)

# Responsive widget wrapper - adapts to viewport
pub struct Responsive:
    child: Box[dyn Widget]
    builder: fn(&Viewport) -> Box[dyn Widget]

impl Responsive:
    # Create responsive widget with builder
    pub fn new(builder: fn(&Viewport) -> Box[dyn Widget]) -> Responsive:
        return Responsive {
            child: Box::new(EmptyWidget::new()),  # Placeholder
            builder: builder
        }

    # Create with breakpoint-specific builders
    pub fn breakpoints(
        xs: Option[fn() -> Box[dyn Widget]],
        sm: Option[fn() -> Box[dyn Widget]],
        md: Option[fn() -> Box[dyn Widget]],
        lg: Option[fn() -> Box[dyn Widget]],
        xl: Option[fn() -> Box[dyn Widget]>
    ) -> Responsive:
        return Responsive::new(|viewport|:
            let size = Breakpoints::default().current(viewport)
            match size:
                case BreakpointSize::XS: return xs.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::SM: return sm.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::MD: return md.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::LG: return lg.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::XL: return xl.unwrap_or(|| Box::new(EmptyWidget::new()))()
                case BreakpointSize::XXL: return xl.unwrap_or(|| Box::new(EmptyWidget::new()))()
        )

# Empty widget (placeholder)
pub struct EmptyWidget:
    pass

impl EmptyWidget:
    pub fn new() -> EmptyWidget:
        return EmptyWidget {}

impl Widget for EmptyWidget:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let elem = Element::new(id, ElementKind::Div)
        return WidgetNode::new(elem)

# MediaQuery - access viewport information in widget tree
pub struct MediaQuery:
    viewport: Viewport

impl MediaQuery:
    pub fn new(viewport: Viewport) -> MediaQuery:
        return MediaQuery { viewport: viewport }

    # Get viewport
    pub fn viewport(self) -> &Viewport:
        return &self.viewport

    # Get size
    pub fn size(self) -> (f64, f64):
        return (self.viewport.logical_width, self.viewport.logical_height)

    # Get orientation
    pub fn orientation(self) -> Orientation:
        return self.viewport.orientation

    # Check if portrait
    pub fn is_portrait(self) -> bool:
        return self.viewport.orientation.is_portrait()

    # Check if landscape
    pub fn is_landscape(self) -> bool:
        return self.viewport.orientation.is_landscape()

    # Get device pixel ratio
    pub fn device_pixel_ratio(self) -> f64:
        return self.viewport.dpr

    # Get platform-specific information
    pub fn platform_brightness(self) -> PlatformBrightness:
        # Would query platform theme
        return PlatformBrightness::Light

pub enum PlatformBrightness:
    Light
    Dark

# Example usage:
#
# let screen = ScreenManager::new(Viewport::new(1920, 1080, 1.0))
#
# screen.on_resize(|viewport|:
#     print("Window resized: {viewport.logical_width}x{viewport.logical_height}")
# )
#
# # Responsive widget
# Responsive::breakpoints(
#     xs: Some(|| Box::new(Text::new("Mobile"))),
#     md: Some(|| Box::new(Text::new("Tablet"))),
#     lg: Some(|| Box::new(Text::new("Desktop")))
# )
