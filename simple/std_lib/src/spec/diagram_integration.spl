# Diagram Integration for SSpec
#
# Connects diagram generation to test execution.
# Provides decorators and helpers to automatically generate diagrams
# during test runs.
#
# Usage:
#   import std.spec.diagram_integration.{with_seq_diagram, traced_it}
#
#   describe "UserService":
#       it "authenticates user", with_seq_diagram:
#           let service = UserService.new()
#           service.authenticate("user", "pass")

import diagram.{
    DiagramType, DiagramConfig, CallEventRecorder,
    set_recorder, get_recorder, clear_recorder,
    generate_sequence, generate_class_diagram, generate_arch_diagram,
    save_diagram, diagram_exists, diagram_placeholder
}
import std.io.fs

# Global state for diagram generation
let _diagram_enabled: Bool = false
let _diagram_types: List[DiagramType] = []
let _diagram_output_dir: String = "doc/spec/diagrams"
let _current_test_file: String = ""
let _current_test_name: String = ""

# Enable diagram generation globally
fn enable_diagrams(types: List[DiagramType]) -> Void:
    _diagram_enabled = true
    _diagram_types = types

# Enable all diagram types
fn enable_all_diagrams() -> Void:
    enable_diagrams([
        DiagramType.Sequence,
        DiagramType.Class,
        DiagramType.Architecture
    ])

# Disable diagram generation
fn disable_diagrams() -> Void:
    _diagram_enabled = false
    _diagram_types = []

# Check if diagrams are enabled
fn is_diagram_enabled() -> Bool:
    return _diagram_enabled

# Set output directory for diagrams
fn set_diagram_output(dir: String) -> Void:
    _diagram_output_dir = dir

# Set current test context (called by test runner)
fn set_test_context(test_file: String, test_name: String) -> Void:
    _current_test_file = test_file
    _current_test_name = test_name

# Clear test context
fn clear_test_context() -> Void:
    _current_test_file = ""
    _current_test_name = ""

# Decorator for sequence diagram generation
# Usage: it "traces flow", with_seq_diagram: ...
fn with_seq_diagram(block: fn() -> Void) -> fn() -> Void:
    return fn():
        if not _diagram_enabled:
            block()
            return

        let rec = CallEventRecorder.new(_current_test_name)
        set_recorder(rec)

        block()

        let config = DiagramConfig.default().with_sequence()
        let content = generate_sequence(rec, config)

        if not content.is_empty():
            save_diagram(content, _current_test_name, _current_test_file, DiagramType.Sequence)

        clear_recorder()

# Decorator for class diagram generation
fn with_class_diagram(block: fn() -> Void) -> fn() -> Void:
    return fn():
        if not _diagram_enabled:
            block()
            return

        let rec = CallEventRecorder.new(_current_test_name)
        set_recorder(rec)

        block()

        let config = DiagramConfig.default().with_class_diagram()
        let content = generate_class_diagram(rec, config)

        if not content.is_empty():
            save_diagram(content, _current_test_name, _current_test_file, DiagramType.Class)

        clear_recorder()

# Decorator for architecture diagram generation
fn with_arch_diagram(block: fn() -> Void) -> fn() -> Void:
    return fn():
        if not _diagram_enabled:
            block()
            return

        let rec = CallEventRecorder.new(_current_test_name)
        set_recorder(rec)

        block()

        let config = DiagramConfig.default().with_architecture()
        let content = generate_arch_diagram(rec, config)

        if not content.is_empty():
            save_diagram(content, _current_test_name, _current_test_file, DiagramType.Architecture)

        clear_recorder()

# Decorator for all diagram types
fn with_all_diagram_types(block: fn() -> Void) -> fn() -> Void:
    return fn():
        if not _diagram_enabled:
            block()
            return

        let rec = CallEventRecorder.new(_current_test_name)
        set_recorder(rec)

        block()

        let config = DiagramConfig.default()

        # Generate all enabled diagram types
        for diagram_type in _diagram_types:
            let content = match diagram_type:
                case DiagramType.Sequence:
                    generate_sequence(rec, config.with_sequence())
                case DiagramType.Class:
                    generate_class_diagram(rec, config.with_class_diagram())
                case DiagramType.Architecture:
                    generate_arch_diagram(rec, config.with_architecture())
                case _:
                    ""

            if not content.is_empty():
                save_diagram(content, _current_test_name, _current_test_file, diagram_type)

        clear_recorder()

# Wrapped `it` that automatically traces when diagrams are enabled
# Usage: traced_it "authenticates user": ...
fn traced_it(description: String, block: fn() -> Void) -> Void:
    import dsl.{it}

    if _diagram_enabled:
        set_test_context(_current_test_file, description)
        it(description, with_all_diagram_types(block))
        clear_test_context()
    else:
        it(description, block)

# Generate diagrams for a spec file
fn generate_diagrams_for_spec(spec_file: String, output_dir: Option[String]) -> List[String]:
    let out_dir = match output_dir:
        case Some(dir) => dir
        case None => _diagram_output_dir

    # Create output directory
    fs.create_dir_all(out_dir)

    # Return list of generated diagram paths
    let mut paths: List[String] = []

    # For each enabled diagram type, check if diagram exists
    for diagram_type in _diagram_types:
        let type_str = match diagram_type:
            case DiagramType.Sequence => "sequence"
            case DiagramType.Class => "class"
            case DiagramType.Architecture => "arch"
            case _ => "unknown"

        # Path format: output_dir/spec_name/diagram_type.mmd
        let spec_name = spec_file
            .replace("simple/std_lib/test/", "")
            .replace("test/", "")
            .replace("_spec.spl", "")
            .replace("_test.spl", "")
            .replace(".spl", "")

        let path = "{out_dir}/{spec_name}/{type_str}.mmd"
        if fs.exists(path):
            paths.push(path)

    return paths

# Generate markdown with embedded diagrams
fn embed_diagrams_in_markdown(spec_file: String, test_name: String) -> String:
    let mut md = ""

    for diagram_type in _diagram_types:
        if diagram_exists(test_name, spec_file, diagram_type):
            let path = get_diagram_path(test_name, spec_file, diagram_type)
            let content = fs.read_string(path)

            let type_name = match diagram_type:
                case DiagramType.Sequence => "Sequence Diagram"
                case DiagramType.Class => "Class Diagram"
                case DiagramType.Architecture => "Architecture Diagram"
                case _ => "Diagram"

            md = md + "\n<details>\n"
            md = md + "<summary>{type_name}</summary>\n\n"
            md = md + "```mermaid\n"
            md = md + content
            md = md + "\n```\n\n"
            md = md + "</details>\n"
        else:
            md = md + "\n" + diagram_placeholder(test_name, spec_file, diagram_type) + "\n"

    return md

# Get path to diagram file
fn get_diagram_path(test_name: String, test_file: String, diagram_type: DiagramType) -> String:
    let base_dir = _diagram_output_dir
    let relative = test_file
        .replace("simple/std_lib/test/", "")
        .replace("test/", "")
        .replace("_spec.spl", "")
        .replace("_test.spl", "")
        .replace(".spl", "")

    let type_suffix = match diagram_type:
        case DiagramType.Sequence => "seq"
        case DiagramType.Class => "class"
        case DiagramType.Architecture => "arch"
        case DiagramType.State => "state"
        case DiagramType.Entity => "entity"

    let safe_name = test_name.replace(" ", "_").replace("/", "_").to_lowercase()
    return "{base_dir}/{relative}/{safe_name}_{type_suffix}.mmd"

# Export public API
export enable_diagrams, enable_all_diagrams, disable_diagrams, is_diagram_enabled
export set_diagram_output, set_test_context, clear_test_context
export with_seq_diagram, with_class_diagram, with_arch_diagram, with_all_diagram_types
export traced_it
export generate_diagrams_for_spec, embed_diagrams_in_markdown, get_diagram_path
