# Property Testing - Shrinking on Failure
# Feature #896: Automatic input minimization when tests fail

module std.spec.property.shrinking:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}
    use property.generators.Generator
    
    # Shrinking configuration
    pub struct ShrinkConfig:
        max_shrinks: i64
        max_depth: i64
    
    impl ShrinkConfig:
        pub fn default() -> ShrinkConfig:
            return ShrinkConfig(
                max_shrinks: 100,
                max_depth: 10
            )
    
    # Shrink result
    pub enum ShrinkResult<T>:
        MinimalFailure(value: T, shrinks: i64)
        NoShrinkPossible(value: T)
        MaxShrinksExceeded(value: T, shrinks: i64)
    
    # Main shrinking algorithm
    pub fn shrink<T>(
        failing_value: T,
        test_fn: fn(T) -> bool,
        generator: impl Generator<T>,
        config: ShrinkConfig
    ) -> ShrinkResult<T>:
        var current = failing_value
        var shrink_count = 0
        var depth = 0
        
        # Keep shrinking while we can find smaller failing inputs
        while shrink_count < config.max_shrinks and depth < config.max_depth:
            val candidates = generator.shrink(current)
            
            if candidates.is_empty():
                # No more shrinks possible
                return ShrinkResult.MinimalFailure(
                    value: current,
                    shrinks: shrink_count
                )
            
            # Try each candidate
            var found_smaller = false
            for candidate in candidates:
                if !test_fn(candidate):
                    # Found a smaller failing input
                    current = candidate
                    shrink_count += 1
                    found_smaller = true
                    break
            
            if !found_smaller:
                # None of the candidates failed
                return ShrinkResult.MinimalFailure(
                    value: current,
                    shrinks: shrink_count
                )
            
            depth += 1
        
        # Hit limits
        if shrink_count >= config.max_shrinks:
            return ShrinkResult.MaxShrinksExceeded(
                value: current,
                shrinks: shrink_count
            )
        
        return ShrinkResult.MinimalFailure(
            value: current,
            shrinks: shrink_count
        )
    
    # Shrinking strategies for common types
    
    # Shrink integers towards zero
    pub fn shrink_i64(value: i64) -> [i64]:
        if value == 0:
            return []
        
        var candidates = [0]
        
        # Binary search towards zero
        candidates.push(value / 2)
        
        # Try moving by 1
        if value > 0:
            candidates.push(value - 1)
        else:
            candidates.push(value + 1)
        
        return candidates
    
    # Shrink lists by removing elements
    pub fn shrink_list<T>(list: [T]) -> [[T]]:
        if list.is_empty():
            return []
        
        var candidates = [[]]  # Empty list
        
        # Remove half
        val mid = list.length() / 2
        if mid > 0:
            candidates.push(list[0..mid])
            candidates.push(list[mid..list.length()])
        
        # Remove first element
        candidates.push(list[1..list.length()])
        
        # Remove last element
        candidates.push(list[0..list.length()-1])
        
        return candidates
    
    # Shrink strings by removing characters
    pub fn shrink_string(s: String) -> [String]:
        if s.length() == 0:
            return []
        
        var candidates = [""]  # Empty string
        
        # Remove half
        val mid = s.length() / 2
        if mid > 0:
            candidates.push(s.substring(0, mid))
            candidates.push(s.substring(mid, s.length()))
        
        # Remove first character
        candidates.push(s.substring(1, s.length()))
        
        # Remove last character
        candidates.push(s.substring(0, s.length() - 1))
        
        return candidates
    
    # Shrink tuples by shrinking components
    pub fn shrink_tuple2<T1, T2>(
        tuple: (T1, T2),
        shrink1: fn(T1) -> [T1],
        shrink2: fn(T2) -> [T2]
    ) -> [(T1, T2)]:
        var candidates = []
        
        # Shrink first component
        for c1 in shrink1(tuple.0):
            candidates.push((c1, tuple.1))
        
        # Shrink second component
        for c2 in shrink2(tuple.1):
            candidates.push((tuple.0, c2))
        
        return candidates
    
    # Example usage:
    # val result = shrink(
    #     failing_value: [1, 2, 3, 4, 5],
    #     test_fn: |list| list.sum() < 10,
    #     generator: generators.list(generators.i64()),
    #     config: ShrinkConfig.default()
    # )
