# Property Testing - Input Generators
# Feature #895: Generator framework for random test inputs

module std.spec.property.generators:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}
    
    # Generator trait - produces random values
    pub trait Generator<T>:
        fn generate(seed: i64) -> T
        fn shrink(value: T) -> [T]
    
    # Built-in generators for primitive types
    
    # Integer generators
    pub fn i64() -> impl Generator<i64>:
        return I64Generator()
    
    pub fn i64_range(min: i64, max: i64) -> impl Generator<i64>:
        return I64RangeGenerator(min: min, max: max)
    
    pub fn u64() -> impl Generator<u64>:
        return U64Generator()
    
    # Boolean generator
    pub fn bool() -> impl Generator<bool>:
        return BoolGenerator()
    
    # String generators
    pub fn string() -> impl Generator<String>:
        return StringGenerator()
    
    pub fn string_with_length(min: i64, max: i64) -> impl Generator<String>:
        return StringLengthGenerator(min: min, max: max)
    
    pub fn ascii() -> impl Generator<String>:
        return AsciiGenerator()
    
    # Collection generators
    pub fn list<T>(elem_gen: impl Generator<T>) -> impl Generator<[T]>:
        return ListGenerator(elem_gen: elem_gen)
    
    pub fn list_with_length<T>(
        elem_gen: impl Generator<T>,
        min: i64,
        max: i64
    ) -> impl Generator<[T]>:
        return ListLengthGenerator(
            elem_gen: elem_gen,
            min: min,
            max: max
        )
    
    # Option generator
    pub fn option<T>(elem_gen: impl Generator<T>) -> impl Generator<Option<T>>:
        return OptionGenerator(elem_gen: elem_gen)
    
    # Result generator
    pub fn result<T, E>(
        ok_gen: impl Generator<T>,
        err_gen: impl Generator<E>
    ) -> impl Generator<Result<T, E>>:
        return ResultGenerator(ok_gen: ok_gen, err_gen: err_gen)
    
    # Generator combinators
    
    # Choose one of several generators
    pub fn one_of<T>(generators: [impl Generator<T>]) -> impl Generator<T>:
        return OneOfGenerator(generators: generators)
    
    # Frequency-based choice
    pub fn frequency<T>(weighted: [(i64, impl Generator<T>)]) -> impl Generator<T>:
        return FrequencyGenerator(weighted: weighted)
    
    # Map generator output
    pub fn map<T, U>(
        gen: impl Generator<T>,
        f: fn(T) -> U
    ) -> impl Generator<U>:
        return MappedGenerator(gen: gen, f: f)
    
    # Bind/flatMap for dependent generation
    pub fn flat_map<T, U>(
        gen: impl Generator<T>,
        f: fn(T) -> impl Generator<U>
    ) -> impl Generator<U>:
        return FlatMappedGenerator(gen: gen, f: f)
    
    # Filter generated values
    pub fn filter<T>(
        gen: impl Generator<T>,
        predicate: fn(T) -> bool
    ) -> impl Generator<T>:
        return FilteredGenerator(gen: gen, predicate: predicate)
    
    # Tuple generators
    pub fn tuple2<T1, T2>(
        gen1: impl Generator<T1>,
        gen2: impl Generator<T2>
    ) -> impl Generator<(T1, T2)>:
        return Tuple2Generator(gen1: gen1, gen2: gen2)
    
    pub fn tuple3<T1, T2, T3>(
        gen1: impl Generator<T1>,
        gen2: impl Generator<T2>,
        gen3: impl Generator<T3>
    ) -> impl Generator<(T1, T2, T3)>:
        return Tuple3Generator(gen1: gen1, gen2: gen2, gen3: gen3)
    
    # Concrete generator implementations
    
    struct I64Generator:
        pass
    
    impl Generator<i64> for I64Generator:
        fn generate(seed: i64) -> i64:
            # Simple LCG random number generator
            let a = 1103515245
            let c = 12345
            let m = 2147483648
            return ((a * seed + c) % m)
        
        fn shrink(value: i64) -> [i64]:
            if value == 0:
                return []
            let candidates = [0, value / 2]
            if value < 0:
                candidates.push(value + 1)
            else:
                candidates.push(value - 1)
            return candidates
    
    struct I64RangeGenerator:
        min: i64
        max: i64
    
    impl Generator<i64> for I64RangeGenerator:
        fn generate(seed: i64) -> i64:
            let range = self.max - self.min
            let raw = I64Generator().generate(seed)
            return self.min + (raw % range)
        
        fn shrink(value: i64) -> [i64]:
            # Shrink towards minimum value in range
            if value == self.min:
                return []
            return [self.min, (self.min + value) / 2]
    
    struct BoolGenerator:
        pass
    
    impl Generator<bool> for BoolGenerator:
        fn generate(seed: i64) -> bool:
            return (I64Generator().generate(seed) % 2) == 0
        
        fn shrink(value: bool) -> [bool]:
            # Shrink true to false
            if value:
                return [false]
            return []
    
    struct StringGenerator:
        pass
    
    impl Generator<String> for StringGenerator:
        fn generate(seed: i64) -> String:
            let length_gen = I64RangeGenerator(min: 0, max: 20)
            let length = length_gen.generate(seed)
            let mut result = ""
            for i in 0..length:
                let char_code = I64RangeGenerator(min: 97, max: 123).generate(seed + i)
                result += char.from_code(char_code)
            return result
        
        fn shrink(value: String) -> [String]:
            if value.length() == 0:
                return []
            # Shrink by removing characters
            return [
                "",
                value.substring(0, value.length() / 2),
                value.substring(1, value.length())
            ]
    
    # Example usage:
    # let gen = generators.i64_range(0, 100)
    # let value = gen.generate(42)  # Returns i64 in [0, 100)
