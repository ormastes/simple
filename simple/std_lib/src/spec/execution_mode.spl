# Execution Mode API (#2050)
# Core API for defining and managing execution modes in spec tests

## ExecutionMode Enum
# Defines the available execution modes for test execution
enum ExecutionMode:
    # Interpreter mode - Direct execution without compilation
    Interpreter

    # JIT mode - Runtime compilation to native code in memory
    JIT

    # SMF Standalone (Cranelift) - AOT compilation to .smf binary
    SMF_Cranelift

    # SMF Standalone (LLVM) - AOT compilation to .smf binary via LLVM
    SMF_LLVM

## ModeSet Type
# Set of execution modes with set operations
struct ModeSet:
    modes: List[ExecutionMode]

    # Create a new ModeSet from a list of modes
    export fn new(modes: List[ExecutionMode]) -> ModeSet:
        ModeSet { modes: modes }

    # Create a ModeSet with all available modes
    export fn all() -> ModeSet:
        ModeSet {
            modes: [
                ExecutionMode.Interpreter,
                ExecutionMode.JIT,
                ExecutionMode.SMF_Cranelift,
                ExecutionMode.SMF_LLVM
            ]
        }

    # Create a ModeSet with only interpreter mode
    export fn interpreter_only() -> ModeSet:
        ModeSet { modes: [ExecutionMode.Interpreter] }

    # Create a ModeSet with only compiled modes (no interpreter)
    export fn compiled_only() -> ModeSet:
        ModeSet {
            modes: [
                ExecutionMode.JIT,
                ExecutionMode.SMF_Cranelift,
                ExecutionMode.SMF_LLVM
            ]
        }

    # Check if a mode is in the set
    export fn contains(self, mode: ExecutionMode) -> Bool:
        for m in self.modes:
            if m == mode:
                return true
        return false

    # Add a mode to the set
    export fn add(mut self, mode: ExecutionMode) -> ModeSet:
        if not self.contains(mode):
            self.modes.push(mode)
        self

    # Remove a mode from the set
    export fn remove(mut self, mode: ExecutionMode) -> ModeSet:
        let mut new_modes = []
        for m in self.modes:
            if m != mode:
                new_modes.push(m)
        self.modes = new_modes
        self

    # Union of two mode sets
    export fn union(self, other: ModeSet) -> ModeSet:
        let mut result = ModeSet.new(self.modes)
        for mode in other.modes:
            result = result.add(mode)
        result

    # Intersection of two mode sets
    export fn intersect(self, other: ModeSet) -> ModeSet:
        let mut result_modes = []
        for mode in self.modes:
            if other.contains(mode):
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Difference of two mode sets (modes in self but not in other)
    export fn difference(self, other: ModeSet) -> ModeSet:
        let mut result_modes = []
        for mode in self.modes:
            if not other.contains(mode):
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Check if mode set is empty
    export fn is_empty(self) -> Bool:
        len(self.modes) == 0

    # Get the number of modes in the set
    export fn size(self) -> Int:
        len(self.modes)

    # Get a list of modes
    export fn to_list(self) -> List[ExecutionMode]:
        self.modes

## Execution Mode Names
# Convert ExecutionMode to string representation
export fn mode_to_string(mode: ExecutionMode) -> String:
    match mode:
        case ExecutionMode.Interpreter => "interpreter"
        case ExecutionMode.JIT => "jit"
        case ExecutionMode.SMF_Cranelift => "smf_cranelift"
        case ExecutionMode.SMF_LLVM => "smf_llvm"

# Parse string to ExecutionMode
export fn string_to_mode(s: String) -> Option[ExecutionMode]:
    match s:
        case "interpreter" => Some(ExecutionMode.Interpreter)
        case "jit" => Some(ExecutionMode.JIT)
        case "smf_cranelift" => Some(ExecutionMode.SMF_Cranelift)
        case "smf_llvm" => Some(ExecutionMode.SMF_LLVM)
        case _ => None

# Check if a mode is currently available for execution
export fn is_mode_available(mode: ExecutionMode) -> Bool:
    match mode:
        case ExecutionMode.Interpreter => true  # Always available
        case ExecutionMode.JIT => true          # Cranelift JIT available
        case ExecutionMode.SMF_Cranelift => true # Cranelift AOT available
        case ExecutionMode.SMF_LLVM => false    # LLVM not yet implemented

# Get all currently available modes
export fn get_available_modes() -> ModeSet:
    let mut modes = []
    for mode in ModeSet.all().to_list():
        if is_mode_available(mode):
            modes.push(mode)
    ModeSet.new(modes)
