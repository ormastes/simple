# Execution Mode API (#2050)
# Core API for defining and managing execution modes in spec tests

## ExecutionMode Enum
# Defines the available execution modes for test execution
enum ExecutionMode:
    # Interpreter mode - Direct execution without compilation
    Interpreter

    # JIT mode - Runtime compilation to native code in memory
    JIT

    # SMF Standalone (Cranelift) - AOT compilation to .smf binary
    SMF_Cranelift

    # SMF Standalone (LLVM) - AOT compilation to .smf binary via LLVM
    SMF_LLVM

## ModeSet Type
# Set of execution modes with set operations
struct ModeSet:
    modes: List[ExecutionMode]

## ModeSet Implementation
# Factory methods and set operations
impl ModeSet:
    # Create a new ModeSet from a list of modes
    fn new(modes: List[ExecutionMode]) -> ModeSet:
        ModeSet { modes: modes }

    # Create a ModeSet with all available modes
    fn all() -> ModeSet:
        ModeSet {
            modes: [
                ExecutionMode.Interpreter,
                ExecutionMode.JIT,
                ExecutionMode.SMF_Cranelift,
                ExecutionMode.SMF_LLVM
            ]
        }

    # Create a ModeSet with only interpreter mode
    fn interpreter_only() -> ModeSet:
        ModeSet { modes: [ExecutionMode.Interpreter] }

    # Create a ModeSet with only compiled modes (no interpreter)
    fn compiled_only() -> ModeSet:
        ModeSet {
            modes: [
                ExecutionMode.JIT,
                ExecutionMode.SMF_Cranelift,
                ExecutionMode.SMF_LLVM
            ]
        }

    # Check if a mode is in the set
    fn contains(self, mode: ExecutionMode) -> Bool:
        for m in self.modes:
            if m == mode:
                return true
        return false

    # Add a mode to the set
    fn add(self, mode: ExecutionMode) -> ModeSet:
        if self.contains(mode):
            return self
        let mut new_modes = []
        for m in self.modes:
            new_modes.push(m)
        new_modes.push(mode)
        ModeSet.new(new_modes)

    # Remove a mode from the set
    fn remove(self, mode: ExecutionMode) -> ModeSet:
        let mut new_modes = []
        for m in self.modes:
            if m != mode:
                new_modes.push(m)
        ModeSet.new(new_modes)

    # Union of two mode sets
    fn union_with(self, other: ModeSet) -> ModeSet:
        let mut result_modes = []
        # Add all modes from self
        for mode in self.modes:
            result_modes.push(mode)
        # Add modes from other that aren't already present
        for mode in other.modes:
            let mut found = false
            for existing in result_modes:
                if existing == mode:
                    found = true
                    break
            if not found:
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Intersection of two mode sets
    fn intersect(self, other: ModeSet) -> ModeSet:
        let mut result_modes = []
        for mode in self.modes:
            if other.contains(mode):
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Difference of two mode sets (modes in self but not in other)
    fn difference(self, other: ModeSet) -> ModeSet:
        let mut result_modes = []
        for mode in self.modes:
            if not other.contains(mode):
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Check if mode set is empty
    fn is_empty(self) -> Bool:
        len(self.modes) == 0

    # Get the number of modes in the set
    fn size(self) -> Int:
        len(self.modes)

    # Get a list of modes
    fn to_list(self) -> List[ExecutionMode]:
        self.modes

## Execution Mode Names
# Convert ExecutionMode to string representation
fn mode_to_string(mode: ExecutionMode) -> String:
    match mode:
        case ExecutionMode.Interpreter => "interpreter"
        case ExecutionMode.JIT => "jit"
        case ExecutionMode.SMF_Cranelift => "smf_cranelift"
        case ExecutionMode.SMF_LLVM => "smf_llvm"

# Parse string to ExecutionMode
fn string_to_mode(s: String) -> Option[ExecutionMode]:
    match s:
        case "interpreter" => Some(ExecutionMode.Interpreter)
        case "jit" => Some(ExecutionMode.JIT)
        case "smf_cranelift" => Some(ExecutionMode.SMF_Cranelift)
        case "smf_llvm" => Some(ExecutionMode.SMF_LLVM)
        case _ => None

# Check if a mode is currently available for execution
fn is_mode_available(mode: ExecutionMode) -> Bool:
    match mode:
        case ExecutionMode.Interpreter => true  # Always available
        case ExecutionMode.JIT => true          # Cranelift JIT available
        case ExecutionMode.SMF_Cranelift => true # Cranelift AOT available
        case ExecutionMode.SMF_LLVM => false    # LLVM not yet implemented

# Get all currently available modes
fn get_available_modes() -> ModeSet:
    let mut modes = []
    for mode in ModeSet.all().to_list():
        if is_mode_available(mode):
            modes.push(mode)
    ModeSet.new(modes)
