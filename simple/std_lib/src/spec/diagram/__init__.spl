# Diagram Generation Module for SSpec
#
# Provides Mermaid diagram generation from test execution traces.
# Supports sequence, class, and architecture diagrams.
#
# Usage:
#   describe "API Flow":
#       it "traces authentication":
#           with_diagram :sequence:
#               trace_method("UserService", "authenticate", [])
#               trace_method("Database", "query", [])

import std.io.fs

# Diagram types supported
enum DiagramType:
    Sequence        # sequenceDiagram - method call flows
    Class           # classDiagram - class relationships
    Architecture    # flowchart TD - component interactions
    State           # stateDiagram-v2 - state transitions
    Entity          # erDiagram - entity relationships

# Diagram configuration
struct DiagramConfig:
    diagram_type: DiagramType
    include_patterns: List[String]
    exclude_patterns: List[String]
    link_to_test: Bool
    output_dir: String
    embed_in_markdown: Bool

    fn default() -> DiagramConfig:
        return DiagramConfig(
            diagram_type=DiagramType.Sequence,
            include_patterns=[],
            exclude_patterns=[],
            link_to_test=true,
            output_dir="doc/spec/diagrams",
            embed_in_markdown=true
        )

    fn with_type(self, t: DiagramType) -> DiagramConfig:
        return DiagramConfig(
            diagram_type=t,
            include_patterns=self.include_patterns,
            exclude_patterns=self.exclude_patterns,
            link_to_test=self.link_to_test,
            output_dir=self.output_dir,
            embed_in_markdown=self.embed_in_markdown
        )

    fn with_include(self, patterns: String) -> DiagramConfig:
        let list = patterns.split(",").map(fn(s): s.trim())
        return DiagramConfig(
            diagram_type=self.diagram_type,
            include_patterns=list,
            exclude_patterns=self.exclude_patterns,
            link_to_test=self.link_to_test,
            output_dir=self.output_dir,
            embed_in_markdown=self.embed_in_markdown
        )

    fn with_exclude(self, patterns: String) -> DiagramConfig:
        let list = patterns.split(",").map(fn(s): s.trim())
        return DiagramConfig(
            diagram_type=self.diagram_type,
            include_patterns=self.include_patterns,
            exclude_patterns=list,
            link_to_test=self.link_to_test,
            output_dir=self.output_dir,
            embed_in_markdown=self.embed_in_markdown
        )

    fn with_sequence(self) -> DiagramConfig:
        return self.with_type(DiagramType.Sequence)

    fn with_class_diagram(self) -> DiagramConfig:
        return self.with_type(DiagramType.Class)

    fn with_architecture(self) -> DiagramConfig:
        return self.with_type(DiagramType.Architecture)

    fn with_all(self) -> DiagramConfig:
        # Mark that all types should be generated
        return self

# Call event types
enum CallType:
    Function
    Method
    Constructor
    Return

# Call event for recording
struct CallEvent:
    callee: String
    callee_class: Option[String]
    arguments: List[String]
    call_type: CallType
    return_value: Option[String]
    timestamp_ns: Int

# Call event recorder
class CallEventRecorder:
    test_name: String
    events: List[CallEvent]
    architectural_entities: List[String]
    class_relationships: Dict[String, List[String]]

    fn new(test_name: String) -> CallEventRecorder:
        return CallEventRecorder(
            test_name=test_name,
            events=[],
            architectural_entities=[],
            class_relationships={}
        )

    fn record_call(self, name: String, class_opt: Option[String], args: List[String], call_type: CallType) -> Void:
        let event = CallEvent(
            callee=name,
            callee_class=class_opt,
            arguments=args,
            call_type=call_type,
            return_value=None,
            timestamp_ns=runtime.now_nanos()
        )
        self.events.push(event)

        # Track class relationships
        match class_opt:
            case Some(cls):
                if not self.class_relationships.contains_key(cls):
                    self.class_relationships[cls] = []
            case None:
                pass

    fn record_return(self, value: Option[String]) -> Void:
        # Update the last call event with return value
        if self.events.len() > 0:
            let last_idx = self.events.len() - 1
            self.events[last_idx].return_value = value

    fn mark_architectural(self, entity: String) -> Void:
        if not self.architectural_entities.contains(entity):
            self.architectural_entities.push(entity)

    fn is_architectural(self, entity: String) -> Bool:
        return self.architectural_entities.contains(entity)

    fn get_events(self) -> List[CallEvent]:
        return self.events

    fn clear(self) -> Void:
        self.events = []
        self.class_relationships = {}

# Global recorder for current test
let _current_recorder: Option[CallEventRecorder] = None

fn set_recorder(recorder: CallEventRecorder) -> Void:
    _current_recorder = Some(recorder)

fn get_recorder() -> Option[CallEventRecorder]:
    return _current_recorder

fn clear_recorder() -> Void:
    _current_recorder = None

# Trace API for manual instrumentation
fn trace_call(name: String, args: List[String]) -> Void:
    match _current_recorder:
        case Some(rec):
            rec.record_call(name, None, args, CallType.Function)
        case None:
            pass

fn trace_method(class_name: String, method_name: String, args: List[String]) -> Void:
    match _current_recorder:
        case Some(rec):
            rec.record_call(method_name, Some(class_name), args, CallType.Method)
        case None:
            pass

fn trace_return(value: Option[String]) -> Void:
    match _current_recorder:
        case Some(rec):
            rec.record_return(value)
        case None:
            pass

fn mark_architectural(component: String) -> Void:
    match _current_recorder:
        case Some(rec):
            rec.mark_architectural(component)
        case None:
            pass

# Diagram generation functions
fn generate_sequence(recorder: CallEventRecorder, config: DiagramConfig) -> String:
    let mut output = "sequenceDiagram\n"

    # Extract participants
    let mut participants: List[String] = []
    for event in recorder.events:
        match event.callee_class:
            case Some(cls):
                if not participants.contains(cls):
                    if _matches_filter(cls, config):
                        participants.push(cls)
            case None:
                pass

    # Add participants
    for p in participants:
        output = output + "    participant {p}\n"

    output = output + "\n"

    # Generate call sequence
    let mut stack: List[String] = ["Test"]
    for event in recorder.events:
        match event.callee_class:
            case Some(cls):
                if not _matches_filter(cls, config):
                    continue

                let caller = stack.last().unwrap_or("Test")
                let method = event.callee

                match event.call_type:
                    case CallType.Method:
                        output = output + "    {caller}->>{cls}: {method}("
                        output = output + event.arguments.join(", ")
                        output = output + ")\n"
                        stack.push(cls)
                    case CallType.Return:
                        if stack.len() > 1:
                            stack.pop()
                            let returner = cls
                            let returnee = stack.last().unwrap_or("Test")
                            match event.return_value:
                                case Some(val):
                                    output = output + "    {returner}-->>{returnee}: {val}\n"
                                case None:
                                    output = output + "    {returner}-->>{returnee}: void\n"
                    case _:
                        pass
            case None:
                pass

    return output

fn generate_class_diagram(recorder: CallEventRecorder, config: DiagramConfig) -> String:
    let mut output = "classDiagram\n"

    # Extract classes and their methods
    let mut classes: Dict[String, List[String]] = {}

    for event in recorder.events:
        match event.callee_class:
            case Some(cls):
                if not _matches_filter(cls, config):
                    continue

                if not classes.contains_key(cls):
                    classes[cls] = []

                let method = event.callee
                if not classes[cls].contains(method):
                    classes[cls].push(method)
            case None:
                pass

    # Generate class definitions
    for (cls, methods) in classes:
        output = output + "    class {cls} {\n"
        for method in methods:
            output = output + "        +{method}()\n"
        output = output + "    }\n"

    # Generate relationships from call patterns
    let mut relationships: List[(String, String)] = []
    let mut last_class: Option[String] = None

    for event in recorder.events:
        match event.callee_class:
            case Some(cls):
                if not _matches_filter(cls, config):
                    continue

                match last_class:
                    case Some(prev):
                        if prev != cls:
                            let rel = (prev, cls)
                            if not relationships.contains(rel):
                                relationships.push(rel)
                    case None:
                        pass
                last_class = Some(cls)
            case None:
                pass

    output = output + "\n"
    for (from_cls, to_cls) in relationships:
        output = output + "    {from_cls} --> {to_cls}\n"

    return output

fn generate_arch_diagram(recorder: CallEventRecorder, config: DiagramConfig) -> String:
    let mut output = "flowchart TD\n"

    # Only show architectural entities
    let mut nodes: List[String] = []
    let mut edges: List[(String, String)] = []

    for entity in recorder.architectural_entities:
        if _matches_filter(entity, config):
            nodes.push(entity)

    # Extract edges from events
    let mut last_arch: Option[String] = None
    for event in recorder.events:
        match event.callee_class:
            case Some(cls):
                if recorder.is_architectural(cls) and _matches_filter(cls, config):
                    match last_arch:
                        case Some(prev):
                            if prev != cls:
                                let edge = (prev, cls)
                                if not edges.contains(edge):
                                    edges.push(edge)
                        case None:
                            pass
                    last_arch = Some(cls)
            case None:
                pass

    # Handle package prefixes as subgraphs
    let mut subgraphs: Dict[String, List[String]] = {}
    for node in nodes:
        if node.contains("."):
            let parts = node.split(".")
            let pkg = parts[0]
            if not subgraphs.contains_key(pkg):
                subgraphs[pkg] = []
            subgraphs[pkg].push(node)
        else:
            output = output + "    {node}\n"

    # Generate subgraphs
    for (pkg, members) in subgraphs:
        output = output + "    subgraph {pkg}\n"
        for member in members:
            let short_name = member.split(".").last().unwrap_or(member)
            output = output + "        {member}[{short_name}]\n"
        output = output + "    end\n"

    # Generate edges
    output = output + "\n"
    for (from_node, to_node) in edges:
        output = output + "    {from_node} --> {to_node}\n"

    return output

# Filter helper
fn _matches_filter(name: String, config: DiagramConfig) -> Bool:
    # Check exclude patterns first
    for pattern in config.exclude_patterns:
        if _matches_pattern(name, pattern):
            return false

    # If no include patterns, include everything
    if config.include_patterns.is_empty():
        return true

    # Check include patterns
    for pattern in config.include_patterns:
        if _matches_pattern(name, pattern):
            return true

    return false

fn _matches_pattern(name: String, pattern: String) -> Bool:
    # Simple glob matching (supports * wildcard)
    if pattern == "*":
        return true

    if pattern.starts_with("*") and pattern.ends_with("*"):
        let middle = pattern[1..pattern.len()-1]
        return name.contains(middle)
    elif pattern.starts_with("*"):
        let suffix = pattern[1..]
        return name.ends_with(suffix)
    elif pattern.ends_with("*"):
        let prefix = pattern[..pattern.len()-1]
        return name.starts_with(prefix)
    else:
        return name == pattern

# Context managers for diagram capture
fn with_sequence_diagram(block: fn() -> Void) -> String:
    let config = DiagramConfig.default().with_sequence()
    return with_diagram(config, block)

fn with_all_diagrams(block: fn() -> Void) -> Dict[String, String]:
    let rec = CallEventRecorder.new("all_diagrams")
    set_recorder(rec)

    block()

    let config = DiagramConfig.default()
    let result = {
        "sequence": generate_sequence(rec, config.with_sequence()),
        "class": generate_class_diagram(rec, config.with_class_diagram()),
        "architecture": generate_arch_diagram(rec, config.with_architecture())
    }

    clear_recorder()
    return result

fn with_diagram(config: DiagramConfig, block: fn() -> Void) -> String:
    let rec = CallEventRecorder.new("diagram")
    set_recorder(rec)

    block()

    let result = match config.diagram_type:
        case DiagramType.Sequence:
            generate_sequence(rec, config)
        case DiagramType.Class:
            generate_class_diagram(rec, config)
        case DiagramType.Architecture:
            generate_arch_diagram(rec, config)
        case _:
            generate_sequence(rec, config)

    clear_recorder()
    return result

# Save diagram to file
fn save_diagram(content: String, test_name: String, test_file: String, diagram_type: DiagramType) -> String:
    let base_dir = "doc/spec/diagrams"
    let relative = test_file
        .replace("simple/std_lib/test/", "")
        .replace("test/", "")
        .replace("_spec.spl", "")
        .replace("_test.spl", "")
        .replace(".spl", "")

    let type_suffix = match diagram_type:
        case DiagramType.Sequence:
            "seq"
        case DiagramType.Class:
            "class"
        case DiagramType.Architecture:
            "arch"
        case DiagramType.State:
            "state"
        case DiagramType.Entity:
            "entity"

    let safe_name = test_name.replace(" ", "_").replace("/", "_").to_lowercase()
    let dir = "{base_dir}/{relative}"
    let path = "{dir}/{safe_name}_{type_suffix}.mmd"

    # Ensure directory exists
    fs.create_dir_all(dir)

    # Write diagram
    fs.write_string(path, content)

    return path

# Check if diagram exists
fn diagram_exists(test_name: String, test_file: String, diagram_type: DiagramType) -> Bool:
    let base_dir = "doc/spec/diagrams"
    let relative = test_file
        .replace("simple/std_lib/test/", "")
        .replace("test/", "")
        .replace("_spec.spl", "")
        .replace("_test.spl", "")
        .replace(".spl", "")

    let type_suffix = match diagram_type:
        case DiagramType.Sequence:
            "seq"
        case DiagramType.Class:
            "class"
        case DiagramType.Architecture:
            "arch"
        case _:
            "seq"

    let safe_name = test_name.replace(" ", "_").replace("/", "_").to_lowercase()
    let path = "{base_dir}/{relative}/{safe_name}_{type_suffix}.mmd"

    return fs.exists(path)

# Generate placeholder markdown for missing diagram
fn diagram_placeholder(test_name: String, test_file: String, diagram_type: DiagramType) -> String:
    let type_flag = match diagram_type:
        case DiagramType.Sequence:
            "--seq-diagram"
        case DiagramType.Class:
            "--class-diagram"
        case DiagramType.Architecture:
            "--arch-diagram"
        case _:
            "--diagram-all"

    let cmd = "simple test {type_flag} {test_file}"

    return "> **Diagram not available**\n>\n> To generate: `{cmd}`"

# Export public API
export DiagramType, DiagramConfig
export CallType, CallEvent, CallEventRecorder
export set_recorder, get_recorder, clear_recorder
export trace_call, trace_method, trace_return, mark_architectural
export generate_sequence, generate_class_diagram, generate_arch_diagram
export with_sequence_diagram, with_all_diagrams, with_diagram
export save_diagram, diagram_exists, diagram_placeholder
