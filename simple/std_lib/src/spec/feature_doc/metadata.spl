# Feature Documentation Metadata
# Defines the structure for feature metadata used to generate documentation

use core.collections.{List, Dict}
use core.string.String
use core.io

## Feature metadata structure
## Contains all information needed to generate a feature documentation file
class FeatureMetadata:
    id: Int                    # Feature ID (#1, #2, etc.)
    name: String               # Feature name ("Lexer", "Parser", etc.)
    category: String           # Category ("Infrastructure", "Language", etc.)
    difficulty: Int            # Difficulty level (1-5)
    status: String             # Status emoji+text ("âœ… Complete", "ðŸ“‹ Planned", "ðŸ”„ In Progress")
    impl_type: String          # Implementation type ("R", "S", "S+R")
    spec_ref: String           # Reference to spec file
    files: List[String]        # Implementation files
    tests: List[String]        # Test files
    description: String        # Feature description
    examples: List[String]     # Code examples
    dependencies: List[Int]    # Feature IDs this depends on
    required_by: List[Int]     # Feature IDs that depend on this
    notes: String              # Additional notes

    fn new(
        id: Int,
        name: String,
        category: String,
        difficulty: Int,
        status: String,
        impl_type: String,
        spec_ref: String,
        files: List[String],
        tests: List[String],
        description: String,
        examples: List[String],
        dependencies: List[Int],
        required_by: List[Int],
        notes: String
    ) -> FeatureMetadata:
        return FeatureMetadata(
            id: id,
            name: name,
            category: category,
            difficulty: difficulty,
            status: status,
            impl_type: impl_type,
            spec_ref: spec_ref,
            files: files,
            tests: tests,
            description: description,
            examples: examples,
            dependencies: dependencies,
            required_by: required_by,
            notes: notes
        )

    ## Get difficulty as human-readable string
    fn difficulty_str(self) -> String:
        return match self.difficulty:
            1 => "1 (Trivial)"
            2 => "2 (Easy)"
            3 => "3 (Medium)"
            4 => "4 (Hard)"
            5 => "5 (Very Hard)"
            _ => f"{self.difficulty} (Unknown)"

    ## Get feature filename (e.g., "0001_lexer.md")
    fn filename(self) -> String:
        # Pad ID to 4 digits
        let id_str = String.pad_left(self.id.to_string(), 4, "0")
        # Convert name to snake_case for filename
        let name_snake = self.name.to_lowercase().replace(" ", "_")
        return f"{id_str}_{name_snake}.md"

    ## Get feature directory path (e.g., "doc/features/infrastructure")
    fn directory_path(self) -> String:
        return f"doc/features/{self.category.to_lowercase()}"

    ## Get full file path (e.g., "doc/features/infrastructure/0001_lexer.md")
    fn full_path(self) -> String:
        return f"{self.directory_path()}/{self.filename()}"

    ## Validate metadata completeness
    fn validate(self) -> (Bool, String):
        if self.id <= 0:
            return (False, "Feature ID must be positive")

        if self.name.is_empty():
            return (False, "Feature name is required")

        if self.category.is_empty():
            return (False, "Category is required")

        if self.difficulty < 1 or self.difficulty > 5:
            return (False, "Difficulty must be 1-5")

        if not (self.status.starts_with("âœ…") or
                self.status.starts_with("ðŸ“‹") or
                self.status.starts_with("ðŸ”„")):
            return (False, "Status must start with âœ…, ðŸ“‹, or ðŸ”„")

        if not (self.impl_type == "R" or
                self.impl_type == "S" or
                self.impl_type == "S+R"):
            return (False, "impl_type must be R, S, or S+R")

        return (True, "Valid")

    ## Debug representation
    fn to_string(self) -> String:
        return f"FeatureMetadata(#{self.id}: {self.name}, {self.category}, difficulty={self.difficulty})"
