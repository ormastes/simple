# Feature Documentation Markdown Generator
# Converts FeatureMetadata into markdown documentation files
# following the template format defined in doc/features/_template.md

use core.collections.{List, Dict}
use core.string.String
use core.time.Timestamp
use spec.feature_doc.metadata.FeatureMetadata

## Generate markdown documentation for a feature
fn generate_markdown(feature: FeatureMetadata) -> String:
    let mut output = String.empty()

    # Header
    output = output + generate_header(feature)

    # Auto-generation warning
    output = output + generate_warning(feature)

    # Overview table
    output = output + generate_overview(feature)

    # Description
    output = output + generate_description(feature)

    # Specification reference
    output = output + generate_specification(feature)

    # Implementation section
    output = output + generate_implementation(feature)

    # Testing section
    output = output + generate_testing(feature)

    # Examples section
    output = output + generate_examples(feature)

    # Dependencies section
    output = output + generate_dependencies(feature)

    # Notes section
    output = output + generate_notes(feature)

    # Footer
    output = output + generate_footer(feature)

    return output

## Generate markdown header
fn generate_header(feature: FeatureMetadata) -> String:
    return f"# Feature #{feature.id}: {feature.name}\n\n"

## Generate auto-generation warning
fn generate_warning(feature: FeatureMetadata) -> String:
    let category_snake = feature.category.to_lowercase().replace(" ", "_")
    let feature_snake = feature.name.to_lowercase().replace(" ", "_")

    return """<!--
This file is auto-generated from BDD system tests.
Manual edits may be overwritten. Edit the spec file instead:
simple/std_lib/test/features/{category_snake}_spec.spl
-->

"""

## Generate overview table
fn generate_overview(feature: FeatureMetadata) -> String:
    let mut output = "## Overview\n\n"
    output = output + "| Property | Value |\n"
    output = output + "|----------|-------|\n"
    output = output + f"| **Feature ID** | #{feature.id} |\n"
    output = output + f"| **Feature Name** | {feature.name} |\n"
    output = output + f"| **Category** | {feature.category} |\n"
    output = output + f"| **Difficulty** | {feature.difficulty_str()} |\n"
    output = output + f"| **Status** | {feature.status} |\n"
    output = output + f"| **Implementation** | {feature.impl_type} |\n"
    output = output + "\n"
    return output

## Generate description section
fn generate_description(feature: FeatureMetadata) -> String:
    let mut output = "## Description\n\n"

    if feature.description.is_empty():
        output = output + "*No description provided.*\n\n"
    else:
        output = output + feature.description + "\n\n"

    return output

## Generate specification section
fn generate_specification(feature: FeatureMetadata) -> String:
    let mut output = "## Specification\n\n"

    if feature.spec_ref.is_empty():
        output = output + "*No specification reference.*\n\n"
    else:
        # Extract filename from path for link text
        let filename = feature.spec_ref.split("/").last().unwrap_or(feature.spec_ref)
        output = output + f"[{filename}](../../{feature.spec_ref})\n\n"

    return output

## Generate implementation section
fn generate_implementation(feature: FeatureMetadata) -> String:
    let mut output = "## Implementation\n\n"

    # Files subsection
    output = output + "### Files\n\n"

    if feature.files.is_empty():
        output = output + "*No implementation files listed.*\n\n"
    else:
        output = output + "| File | Purpose |\n"
        output = output + "|------|---------|\n"

        for file in feature.files:
            output = output + f"| `{file}` | Implementation file |\n"

        output = output + "\n"

    # Key Components subsection
    output = output + "### Key Components\n\n"
    output = output + "*Component details to be added.*\n\n"

    return output

## Generate testing section
fn generate_testing(feature: FeatureMetadata) -> String:
    let mut output = "## Testing\n\n"

    # Simple/BDD tests
    output = output + "### Simple Tests (BDD)\n\n"

    let category_snake = feature.category.to_lowercase().replace(" ", "_")
    let test_file = f"simple/std_lib/test/features/{category_snake}_spec.spl"

    output = output + "| Test File | Description |\n"
    output = output + "|-----------|-------------|\n"
    output = output + f"| `{test_file}` | BDD feature test |\n"
    output = output + "\n"

    # Rust tests
    if not feature.tests.is_empty():
        output = output + "### Rust Tests\n\n"
        output = output + "| Test File | Description |\n"
        output = output + "|-----------|-------------|\n"

        for test in feature.tests:
            output = output + f"| `{test}` | Unit/integration tests |\n"

        output = output + "\n"

    return output

## Generate examples section
fn generate_examples(feature: FeatureMetadata) -> String:
    let mut output = "## Examples\n\n"

    if feature.examples.is_empty():
        output = output + "```simple\n"
        output = output + "# Example code to be added\n"
        output = output + "```\n\n"
    else:
        for example in feature.examples:
            output = output + "```simple\n"
            output = output + example + "\n"
            output = output + "```\n\n"

    return output

## Generate dependencies section
fn generate_dependencies(feature: FeatureMetadata) -> String:
    let mut output = "## Dependencies\n\n"

    # Depends on
    if feature.dependencies.is_empty():
        output = output + "- Depends on: None\n"
    else:
        let dep_list = feature.dependencies.map(\id: f"#{id}").join(", ")
        output = output + f"- Depends on: {dep_list}\n"

    # Required by
    if feature.required_by.is_empty():
        output = output + "- Required by: None\n"
    else:
        let req_list = feature.required_by.map(\id: f"#{id}").join(", ")
        output = output + f"- Required by: {req_list}\n"

    output = output + "\n"
    return output

## Generate notes section
fn generate_notes(feature: FeatureMetadata) -> String:
    if feature.notes.is_empty():
        return ""

    let mut output = "## Notes\n\n"
    output = output + feature.notes + "\n\n"
    return output

## Generate footer with metadata
fn generate_footer(feature: FeatureMetadata) -> String:
    let timestamp = Timestamp.now().format("%Y-%m-%d %H:%M:%S")
    let category_snake = feature.category.to_lowercase().replace(" ", "_")
    let spec_file = f"simple/std_lib/test/features/{category_snake}_spec.spl"

    return f"""---

**Generated:** {timestamp}
**Source:** {spec_file}
"""
