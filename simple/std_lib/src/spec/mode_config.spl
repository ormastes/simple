# Multi-Level Mode Configuration (#2051)
# Configuration hierarchy: Test → Block → File → Directory → Project

import execution_mode.{ExecutionMode, ModeSet, string_to_mode}

## Failure Strategy
enum FailureStrategy:
    # Continue with next mode on failure (default)
    SkipRemaining

    # Stop all modes if any mode fails
    FailAll

    # Run all modes, report all failures at end
    CollectAll

## Mode Configuration
struct ModeConfig:
    modes: Option[ModeSet]
    skip_modes: Option[ModeSet]
    only_modes: Option[ModeSet]
    failure_strategy: Option[FailureStrategy]
    parent: Option[ModeConfig]

## ModeConfig Implementation
impl ModeConfig:
    fn new() -> ModeConfig:
        ModeConfig {
            modes: None,
            skip_modes: None,
            only_modes: None,
            failure_strategy: None,
            parent: None
        }

    fn with_parent(parent: ModeConfig) -> ModeConfig:
        let mut config = ModeConfig.new()
        config.parent = Some(parent)
        return config

    fn set_modes(mut self, modes: ModeSet) -> ModeConfig:
        self.modes = Some(modes)
        return self

    fn set_skip_modes(mut self, modes: ModeSet) -> ModeConfig:
        self.skip_modes = Some(modes)
        return self

    fn set_only_modes(mut self, modes: ModeSet) -> ModeConfig:
        self.only_modes = Some(modes)
        return self

    fn set_failure_strategy(mut self, strategy: FailureStrategy) -> ModeConfig:
        self.failure_strategy = Some(strategy)
        return self

    fn resolve_modes(self) -> ModeSet:
        if self.only_modes.is_some():
            return self.only_modes.unwrap()

        let mut effective_modes = ModeSet.all()
        if self.modes.is_some():
            effective_modes = self.modes.unwrap()
        elif self.parent.is_some():
            effective_modes = self.parent.unwrap().resolve_modes()

        let skip = self.resolve_skip_modes()
        effective_modes = effective_modes.difference(skip)
        return effective_modes

    fn resolve_skip_modes(self) -> ModeSet:
        let mut skip = ModeSet.new([])
        if self.skip_modes.is_some():
            skip = self.skip_modes.unwrap()

        if self.parent.is_some():
            let parent_skip = self.parent.unwrap().resolve_skip_modes()
            skip = skip.union_with(parent_skip)

        return skip

    fn resolve_failure_strategy(self) -> FailureStrategy:
        if self.failure_strategy.is_some():
            return self.failure_strategy.unwrap()

        if self.parent.is_some():
            return self.parent.unwrap().resolve_failure_strategy()

        return FailureStrategy.SkipRemaining

## Configuration Levels
enum ConfigLevel:
    Project
    Directory
    File
    Block
    Test

struct ConfigSource:
    level: ConfigLevel
    path: Option[String]
    name: Option[String]

## Project-Level Configuration
struct ProjectConfig:
    default_modes: ModeSet
    mode_failure_strategy: FailureStrategy

impl ProjectConfig:
    fn default() -> ProjectConfig:
        ProjectConfig {
            default_modes: ModeSet.all(),
            mode_failure_strategy: FailureStrategy.SkipRemaining
        }

    fn to_mode_config(self) -> ModeConfig:
        let mut config = ModeConfig.new()
        config = config.set_modes(self.default_modes)
        config = config.set_failure_strategy(self.mode_failure_strategy)
        return config

## Directory-Level Configuration
struct DirectoryConfig:
    modes: Option[ModeSet]
    skip_modes: Option[ModeSet]
    mode_failure_strategy: Option[FailureStrategy]

impl DirectoryConfig:
    fn new() -> DirectoryConfig:
        DirectoryConfig {
            modes: None,
            skip_modes: None,
            mode_failure_strategy: None
        }

    fn to_mode_config(self, parent: ModeConfig) -> ModeConfig:
        let mut config = ModeConfig.with_parent(parent)

        if self.modes.is_some():
            config = config.set_modes(self.modes.unwrap())

        if self.skip_modes.is_some():
            config = config.set_skip_modes(self.skip_modes.unwrap())

        if self.mode_failure_strategy.is_some():
            config = config.set_failure_strategy(self.mode_failure_strategy.unwrap())

        return config

## File-Level Configuration
struct FileConfig:
    modes: Option[ModeSet]
    skip_modes: Option[ModeSet]
    only_modes: Option[ModeSet]
    mode_failure_strategy: Option[FailureStrategy]

impl FileConfig:
    fn new() -> FileConfig:
        FileConfig {
            modes: None,
            skip_modes: None,
            only_modes: None,
            mode_failure_strategy: None
        }

    fn to_mode_config(self, parent: ModeConfig) -> ModeConfig:
        let mut config = ModeConfig.with_parent(parent)

        if self.modes.is_some():
            config = config.set_modes(self.modes.unwrap())

        if self.skip_modes.is_some():
            config = config.set_skip_modes(self.skip_modes.unwrap())

        if self.only_modes.is_some():
            config = config.set_only_modes(self.only_modes.unwrap())

        if self.mode_failure_strategy.is_some():
            config = config.set_failure_strategy(self.mode_failure_strategy.unwrap())

        return config

## Helper Functions

export fn string_to_failure_strategy(s: String) -> Option[FailureStrategy]:
    match s:
        case "skip_remaining" => Some(FailureStrategy.SkipRemaining)
        case "fail_all" => Some(FailureStrategy.FailAll)
        case "collect_all" => Some(FailureStrategy.CollectAll)
        case _ => None

export fn failure_strategy_to_string(strategy: FailureStrategy) -> String:
    match strategy:
        case FailureStrategy.SkipRemaining => "skip_remaining"
        case FailureStrategy.FailAll => "fail_all"
        case FailureStrategy.CollectAll => "collect_all"

export fn parse_mode_list(mode_names: List[String]) -> Option[ModeSet]:
    let mut modes = []
    let mut valid = true

    for name in mode_names:
        match string_to_mode(name):
            case Some(mode) => modes.push(mode)
            case None => valid = false

    if valid:
        return Some(ModeSet.new(modes))
    else:
        return None
