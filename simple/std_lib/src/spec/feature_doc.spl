# Feature Documentation Framework
# BDD-driven meta documentation generation
# Single-file version (workaround for __init__.spl export bug)

# Feature metadata structure
# Contains all information needed to generate a meta documentation file
class FeatureMetadata:
    id: Int                    # Feature ID (#1, #2, etc.)
    name: String               # Feature name ("Lexer", "Parser", etc.)
    category: String           # Category ("Infrastructure", "Language", etc.)
    difficulty: Int            # Difficulty level (1-5)
    status: String             # Status emoji+text ("âœ… Complete", "ğŸ“‹ Planned", "ğŸ”„ In Progress")
    impl_type: String          # Implementation type ("R", "S", "S+R")
    spec_ref: String           # Reference to spec file
    files: List[String]        # Implementation files
    tests: List[String]        # Test files
    description: String        # Feature description
    code_examples: List[String]     # Code examples
    dependencies: List[Int]    # Feature IDs this depends on
    required_by: List[Int]     # Feature IDs that depend on this
    notes: String              # Additional notes

# Global meta registry
# Singleton that stores all registered features
# NOTE: Using arrays instead of dicts because dict methods are immutable/functional
class FeatureRegistry:
    features: List  # List of FeatureMetadata (Array-based storage)

    fn new():
        return FeatureRegistry {
            features: []
        }

    # Register a feature
    fn register(meta):
        # Use concatenation instead of append (append has mutation bug)
        self.features = self.features + [meta]

    # Get feature by ID
    fn get(id: Int):
        # Linear search through features array
        for item in self.features:
            if item.id == id:
                return item
        return None

    # Get all features in a category
    fn get_by_category(category: String):
        var result = []
        for item in self.features:
            if item.category == category:
                result = result + [item]
        return result

    # Get all features
    fn get_all():
        return self.features

    # Get all unique categories
    fn get_categories():
        var cats = []
        for item in self.features:
            # Check if category already in list
            var found = false
            for cat in cats:
                if cat == item.category:
                    found = true
            if not found:
                cats = cats + [item.category]
        return cats

    # Clear all features (for testing)
    fn clear():
        self.features = []

# Global singleton instance
var _global_registry = None

# Get the global registry (lazy initialization)
fn get_global_registry():
    if _global_registry.is_none():
        _global_registry = Some(FeatureRegistry.new())

    return _global_registry.unwrap()

# Register a meta in the global registry
fn register_feature(meta):
    get_global_registry().register(meta)
    print("Registered meta #{meta.id}: {meta.name}")

# Main API function: Register meta metadata
fn feature_metadata(metadata):
    register_feature(metadata)

# Get a meta from the global registry
fn get_feature(id: Int):
    return get_global_registry().get(id)

# Get all features in a category
fn get_features_by_category(category: String):
    return get_global_registry().get_by_category(category)

# Get all features
fn get_all_features():
    return get_global_registry().get_all()

# Get all categories
fn get_all_categories():
    return get_global_registry().get_categories()

# Clear the global registry (for testing)
fn clear_feature_registry():
    get_global_registry().clear()

# Generate comprehensive markdown documentation for a specific feature
fn generate_feature_doc(id: Int):
    if val Some(meta) = get_feature(id):
        var md = ""

        # Header
        md = md + "# Feature #{meta.id}: {meta.name}\n\n"

        # Overview table
        md = md + "## Overview\n\n"
        md = md + "| Property | Value |\n"
        md = md + "|----------|-------|\n"
        md = md + "| **Feature ID** | #{meta.id} |\n"
        md = md + "| **Feature Name** | {meta.name} |\n"
        md = md + "| **Category** | {meta.category} |\n"
        val diff_label = get_difficulty_label(meta.difficulty)
        md = md + "| **Difficulty** | {meta.difficulty} ({diff_label}) |\n"
        md = md + "| **Status** | {meta.status} |\n"
        md = md + "| **Implementation** | {meta.impl_type} |\n\n"

        # Description
        md = md + "## Description\n\n"
        md = md + meta.description + "\n\n"

        # Specification
        if meta.spec_ref != "":
            md = md + "## Specification\n\n"
            md = md + "[{meta.spec_ref}](../../{meta.spec_ref})\n\n"

        # Implementation files
        if meta.files.len() > 0:
            md = md + "## Implementation\n\n"
            md = md + "### Files\n\n"
            md = md + "| File | Purpose |\n"
            md = md + "|------|---------|\n"
            for file in meta.files:
                md = md + "| `{file}` | Implementation |\n"
            md = md + "\n"

        # Testing
        if meta.tests.len() > 0:
            md = md + "## Testing\n\n"
            md = md + "### Test Files\n\n"
            md = md + "| Test File | Description |\n"
            md = md + "|-----------|-------------|\n"
            for test in meta.tests:
                md = md + "| `{test}` | Test suite |\n"
            md = md + "\n"

        # Code examples
        if meta.code_examples.len() > 0:
            md = md + "## Examples\n\n"
            md = md + "```simple\n"
            for example in meta.code_examples:
                md = md + example + "\n"
            md = md + "```\n\n"

        # Dependencies
        md = md + "## Dependencies\n\n"
        if meta.dependencies.len() > 0:
            md = md + "- Depends on: "
            var first = true
            for dep in meta.dependencies:
                if not first:
                    md = md + ", "
                md = md + "#{dep}"
                first = false
            md = md + "\n"
        else:
            md = md + "- Depends on: None (foundational component)\n"

        if meta.required_by.len() > 0:
            md = md + "- Required by: "
            var first = true
            for req in meta.required_by:
                if not first:
                    md = md + ", "
                md = md + "#{req}"
                first = false
            md = md + "\n"
        md = md + "\n"

        # Notes
        if meta.notes != "":
            md = md + "## Notes\n\n"
            md = md + meta.notes + "\n"

        return Some(md)
    return None

# Get difficulty label from level
fn get_difficulty_label(level: Int) -> String:
    if level == 1:
        return "Trivial"
    if level == 2:
        return "Easy"
    if level == 3:
        return "Medium"
    if level == 4:
        return "Hard"
    if level == 5:
        return "Very Hard"
    return "Unknown"

# Generate markdown documentation for all features in a category
fn generate_category_docs(category: String):
    var docs = []
    val features = get_features_by_category(category)

    for meta in features:
        if val Some(markdown) = generate_feature_doc(meta.id):
            val filename = format_feature_filename(meta.id, meta.name)
            docs = docs + [[filename, markdown]]

    return docs

# Generate category index markdown
fn generate_category_index(category: String) -> String:
    val features = get_features_by_category(category)
    if features.len() == 0:
        return ""

    # Find ID range
    var min_id = 9999
    var max_id = 0
    for meta in features:
        if meta.id < min_id:
            min_id = meta.id
        if meta.id > max_id:
            max_id = meta.id

    var md = ""
    val cat_desc = get_category_description(category)
    val cat_lower = category.lower()

    # Header
    md = md + "# {category} Features (#{min_id}-#{max_id})\n\n"
    md = md + cat_desc + "\n\n"

    # Features table
    md = md + "## Features\n\n"
    md = md + "| ID | Feature | Difficulty | Status | Impl |\n"
    md = md + "|----|---------|------------|--------|------|\n"

    for meta in features:
        val filename = format_feature_filename(meta.id, meta.name)
        val status_icon = get_status_icon(meta.status)
        md = md + "| #{meta.id} | [{meta.name}]({filename}) | {meta.difficulty} | {status_icon} | {meta.impl_type} |\n"

    md = md + "\n"

    # Summary
    var complete = 0
    for meta in features:
        if meta.status == "Complete" or meta.status == "âœ… Complete":
            complete = complete + 1

    val total = features.len()
    md = md + "## Summary\n\n"
    md = md + "**Status:** {complete}/{total} Complete"
    if complete == total:
        md = md + " (100%)"
    md = md + "\n\n"

    # Test locations
    md = md + "## Test Locations\n\n"
    md = md + "- **Simple Tests:** `simple/std_lib/test/features/{cat_lower}/`\n"
    md = md + "- **Rust Tests:** See individual feature pages\n"

    return md

# Get status icon from status string
fn get_status_icon(status: String) -> String:
    if status == "Complete" or status == "âœ… Complete":
        return "âœ…"
    if status == "Planned" or status == "ğŸ“‹ Planned":
        return "ğŸ“‹"
    if status == "In Progress" or status == "ğŸ”„ In Progress":
        return "ğŸ”„"
    return "â“"

# Get category description
fn get_category_description(category: String) -> String:
    if category == "Infrastructure":
        return "Core compiler infrastructure components."
    if category == "Language":
        return "Language features including functions, classes, and types."
    if category == "Codegen":
        return "Code generation and compilation features."
    if category == "Testing":
        return "Testing frameworks and utilities."
    if category == "Concurrency":
        return "Concurrency and async runtime features."
    return "Features in the " + category + " category."

# Format feature filename: 0001_lexer.md
fn format_feature_filename(id: Int, name: String) -> String:
    var padded = ""

    # Pad to 4 digits
    if id < 10:
        padded = "000{id}"
    elif id < 100:
        padded = "00{id}"
    elif id < 1000:
        padded = "0{id}"
    else:
        padded = "{id}"

    # Convert name to lowercase and replace spaces with underscores
    val safe_name = name.lower().replace(" ", "_")

    return "{padded}_{safe_name}.md"

# Generate all feature documentation
fn generate_all_docs():
    var all_docs = []
    val features = get_all_features()

    for meta in features:
        if val Some(markdown) = generate_feature_doc(meta.id):
            val filename = format_feature_filename(meta.id, meta.name)
            val path = meta.category.lower() + "/" + filename
            all_docs = all_docs + [[path, markdown]]

    return all_docs

# Write all feature docs to stdout (for testing)
fn write_feature_docs():
    val features = get_all_features()
    val feat_count = features.len()
    print("Feature documentation summary:")
    print("  Total features: {feat_count}")

    val categories = get_all_categories()
    val cat_count = categories.len()
    print("  Categories: {cat_count}")

    for category in categories:
        val cat_features = get_features_by_category(category)
        val cf_count = cat_features.len()
        print("    {category}: {cf_count} features")

    print("")
    print("Generated documents:")

    # Generate and print each document
    for category in categories:
        print("")
        print("=== Category: {category} ===")

        # Print category index
        val index_md = generate_category_index(category)
        print("")
        print("--- __index__.md ---")
        print(index_md)

        # Print individual feature docs
        val docs = generate_category_docs(category)
        for doc in docs:
            val filename = doc[0]
            val content = doc[1]
            print("")
            print("--- {filename} ---")
            print(content)

# Write docs to files (requires host.async_nogc_mut.io.fs)
# Usage: await write_feature_docs_to_files("doc/features/")
async fn write_feature_docs_to_files(base_path: String):
    # Import file system module
    # use host.async_nogc_mut.io.fs as fs

    val features = get_all_features()
    val categories = get_all_categories()
    val feat_count = features.len()
    val cat_count = categories.len()

    print("Writing feature documentation to: {base_path}")
    print("  Total features: {feat_count}")
    print("  Categories: {cat_count}")

    var files_written = 0

    for category in categories:
        val cat_lower = category.lower()
        val cat_path = base_path + cat_lower + "/"
        print("  Creating directory: {cat_path}")

        # Write category index
        val index_md = generate_category_index(category)
        val index_path = cat_path + "__index__.md"
        print("    Writing: {index_path}")
        # await fs.write_text(index_path, index_md)
        files_written = files_written + 1

        # Write individual feature docs
        val docs = generate_category_docs(category)
        for doc in docs:
            val filename = doc[0]
            val content = doc[1]
            val file_path = cat_path + filename
            print("    Writing: {file_path}")
            # await fs.write_text(file_path, content)
            files_written = files_written + 1

    print("")
    print("Done! Wrote {files_written} files.")

# Export types
export FeatureMetadata
export FeatureRegistry

# Export functions
export get_global_registry
export register_feature
export feature_metadata
export get_feature
export get_features_by_category
export get_all_features
export get_all_categories
export clear_feature_registry
export generate_feature_doc
export generate_category_docs
export generate_category_index
export generate_all_docs
export write_feature_docs
export write_feature_docs_to_files
export format_feature_filename
export get_difficulty_label
export get_status_icon
export get_category_description
