# Feature Documentation Framework
# BDD-driven feature documentation generation
#
# This module extends the BDD framework to capture feature metadata
# and generate markdown documentation automatically from tests.
#
# Usage in BDD tests:
#   describe "Lexer (#1)":
#       feature_metadata(
#           id: 1,
#           name: "Lexer",
#           category: "Infrastructure",
#           difficulty: 3,
#           status: "âœ… Complete",
#           impl_type: "R",
#           spec_ref: "doc/spec/syntax.md",
#           files: ["src/parser/src/lexer.rs"],
#           tests: ["src/parser/tests/lexer_tests.rs"],
#           description: "Tokenizes Simple language source code",
#           examples: [],
#           dependencies: [],
#           required_by: [2],
#           notes: "Performance-critical component"
#       )
#
#       it "tokenizes identifiers":
#           expect tokenize("foo") to succeed

use core.collections.{List, Dict}
use core.string.String

# Re-export public types and functions
export FeatureMetadata from feature_doc.metadata
export FeatureRegistry from feature_doc.registry
export {
    get_global_registry,
    register_feature,
    get_feature,
    get_features_by_category,
    get_all_features,
    get_all_categories,
    clear_feature_registry
} from feature_doc.registry

## Main entry point: Register feature metadata
##
## Call this at the top of a describe block to associate
## feature metadata with the tests.
##
## Example:
##   describe "Lexer (#1)":
##       feature_metadata(
##           id: 1,
##           name: "Lexer",
##           category: "Infrastructure",
##           ...
##       )
fn feature_metadata(
    id: Int,
    name: String,
    category: String,
    difficulty: Int,
    status: String,
    impl_type: String,
    spec_ref: String,
    files: List[String],
    tests: List[String],
    description: String = "",
    examples: List[String] = [],
    dependencies: List[Int] = [],
    required_by: List[Int] = [],
    notes: String = ""
):
    # Create metadata object
    let metadata = FeatureMetadata.new(
        id: id,
        name: name,
        category: category,
        difficulty: difficulty,
        status: status,
        impl_type: impl_type,
        spec_ref: spec_ref,
        files: files,
        tests: tests,
        description: description,
        examples: examples,
        dependencies: dependencies,
        required_by: required_by,
        notes: notes
    )

    # Register in global registry
    register_feature(metadata)

## Generate markdown documentation for a specific feature
## Returns the markdown content as a string
fn generate_feature_doc(id: Int) -> Option[String]:
    if let Some(feature) = get_feature(id):
        # Import generator (will implement next)
        use spec.feature_doc.generator.generate_markdown
        return Some(generate_markdown(feature))

    return None

## Generate markdown documentation for all features in a category
fn generate_category_docs(category: String) -> Dict[String, String]:
    let docs = Dict.new()
    let features = get_features_by_category(category)

    for feature in features:
        use spec.feature_doc.generator.generate_markdown
        let markdown = generate_markdown(feature)
        docs.set(feature.filename(), markdown)

    return docs

## Generate all feature documentation
fn generate_all_docs() -> Dict[String, String]:
    let docs = Dict.new()
    let features = get_all_features()

    for feature in features:
        use spec.feature_doc.generator.generate_markdown
        let markdown = generate_markdown(feature)
        docs.set(feature.full_path(), markdown)

    return docs

## Write generated documentation to files
fn write_feature_docs():
    use spec.feature_doc.file_writer.write_all_features
    write_all_features()
