# Multi-Mode Test Execution (#2050-#2054)
# Executes tests across multiple execution modes with reporting

import execution_mode.{ExecutionMode, ModeSet, mode_to_string, is_mode_available}
import mode_config.{ModeConfig, FailureStrategy}

## Test Result
# Result of running a single test in a specific mode
struct TestResult:
    test_name: String
    mode: ExecutionMode
    status: TestStatus
    error: Option[String]
    duration_ms: Int
    config_source: String  # Which level set the mode configuration

enum TestStatus:
    Passed
    Failed
    Skipped

## Mode Execution Result
# Aggregates results across all modes for a single test
struct ModeExecutionResult:
    test_name: String
    results: List[TestResult]
    total_modes: Int
    passed_modes: Int
    failed_modes: Int
    skipped_modes: Int

    fn new(test_name: String) -> ModeExecutionResult:
        ModeExecutionResult {
            test_name: test_name,
            results: [],
            total_modes: 0,
            passed_modes: 0,
            failed_modes: 0,
            skipped_modes: 0
        }

    # Add a test result
    fn add_result(mut self, result: TestResult) -> ModeExecutionResult:
        self.results.push(result)
        self.total_modes = self.total_modes + 1

        match result.status:
            case TestStatus.Passed => self.passed_modes = self.passed_modes + 1
            case TestStatus.Failed => self.failed_modes = self.failed_modes + 1
            case TestStatus.Skipped => self.skipped_modes = self.skipped_modes + 1

        self

    # Check if all modes passed
    fn all_passed(self) -> Bool:
        self.failed_modes == 0 and self.skipped_modes == 0

    # Check if any mode failed
    fn has_failures(self) -> Bool:
        self.failed_modes > 0

## Mode Runner
# Executes tests in multiple modes
struct ModeRunner:
    config: ModeConfig
    results: List[ModeExecutionResult]

    fn new(config: ModeConfig) -> ModeRunner:
        ModeRunner {
            config: config,
            results: []
        }

    # Run a test function in all configured modes
    fn run_test(mut self, test_name: String, test_fn: fn() -> Void) -> ModeExecutionResult:
        let modes = self.config.resolve_modes()
        let strategy = self.config.resolve_failure_strategy()

        let mut exec_result = ModeExecutionResult.new(test_name)

        for mode in modes.to_list():
            # Skip unavailable modes
            if not is_mode_available(mode):
                let result = TestResult {
                    test_name: test_name,
                    mode: mode,
                    status: TestStatus.Skipped,
                    error: Some("Mode not implemented"),
                    duration_ms: 0,
                    config_source: "availability_check"
                }
                exec_result = exec_result.add_result(result)
                continue

            # Execute test in this mode
            let result = self.execute_in_mode(test_name, test_fn, mode)
            exec_result = exec_result.add_result(result)

            # Handle failure based on strategy
            if result.status == TestStatus.Failed:
                match strategy:
                    case FailureStrategy.FailAll =>
                        # Stop execution, mark remaining modes as skipped
                        exec_result = self.skip_remaining_modes(exec_result, modes, mode)
                        break
                    case FailureStrategy.SkipRemaining =>
                        # Continue with next mode
                        pass
                    case FailureStrategy.CollectAll =>
                        # Continue running all modes
                        pass

        self.results.push(exec_result)
        exec_result

    # Execute test in a specific mode
    fn execute_in_mode(self, test_name: String, test_fn: fn() -> Void, mode: ExecutionMode) -> TestResult:
        let start_time = get_current_time_ms()

        # Try to execute the test
        let mut status = TestStatus.Passed
        let mut error = None

        # TODO: [stdlib][P1] Actual mode switching will be implemented in Phase 3
        # For now, just execute in interpreter mode
        match self.try_execute(test_fn):
            case Ok(_) =>
                status = TestStatus.Passed
            case Err(err) =>
                status = TestStatus.Failed
                error = Some(err)

        let duration = get_current_time_ms() - start_time

        TestResult {
            test_name: test_name,
            mode: mode,
            status: status,
            error: error,
            duration_ms: duration,
            config_source: "test_level"  # TODO: [stdlib][P2] Track actual config source
        }

    # Try to execute a test function, catching errors
    fn try_execute(self, test_fn: fn() -> Void) -> Result[Void, String]:
        # TODO: [stdlib][P1] Implement proper error handling
        # For now, assume tests pass
        test_fn()
        Ok(())

    # Skip remaining modes after a failure
    fn skip_remaining_modes(self, mut exec_result: ModeExecutionResult, modes: ModeSet, failed_mode: ExecutionMode) -> ModeExecutionResult:
        let mut found_failed = false

        for mode in modes.to_list():
            if mode == failed_mode:
                found_failed = true
                continue

            if found_failed:
                let result = TestResult {
                    test_name: exec_result.test_name,
                    mode: mode,
                    status: TestStatus.Skipped,
                    error: Some("Skipped due to failure in {mode_to_string(failed_mode)}"),
                    duration_ms: 0,
                    config_source: "failure_strategy"
                }
                exec_result = exec_result.add_result(result)

        exec_result

    # Get all test results
    fn get_results(self) -> List[ModeExecutionResult]:
        self.results

## Helper: run_in_modes
# Execute a block of code/tests in specific modes
# Usage: run_in_modes([ExecutionMode.JIT, ExecutionMode.SMF_Cranelift]):
#            it "test": ...
export fn run_in_modes(modes: ModeSet, block: fn() -> Void) -> Void:
    # TODO: [stdlib][P3] Set mode configuration for nested tests
    # For now, just execute the block
    block()

## Helper: get current time in milliseconds
# Placeholder - will be replaced with actual time API
fn get_current_time_ms() -> Int:
    0  # TODO: [stdlib][P1] Implement with std.time when available

## Result: type alias for error handling
# Temporary definition until core Result type is available
enum Result[T, E]:
    Ok(T)
    Err(E)

## Exports
export TestResult
export TestStatus
export ModeExecutionResult
export ModeRunner
