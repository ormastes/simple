# Snapshot Testing - Comparison and Diff
# Core snapshot comparison logic with unified diff generation

module std.spec.snapshot.comparison:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}

    # Comparison result
    pub enum ComparisonResult:
        Match
        Mismatch(diff: text, context: DiffContext)

    impl ComparisonResult:
        pub fn is_match(self) -> bool:
            match self:
                ComparisonResult.Match -> return true
                _ -> return false

        pub fn is_mismatch(self) -> bool:
            return !self.is_match()

    # Diff context information
    pub struct DiffContext:
        expected_file: text
        actual_content: text
        test_name: text
        format: text
        added_lines: i64
        removed_lines: i64
        changed_lines: i64

    impl DiffContext:
        pub fn summary(self) -> text:
            return "+{self.added_lines} -{self.removed_lines} ~{self.changed_lines}"

    # Compare two snapshots
    pub fn compare_snapshots(
        expected: text,
        actual: text,
        test_name: text,
        format: text
    ) -> ComparisonResult:
        # Normalize both for comparison
        val exp_normalized = expected.trim()
        val act_normalized = actual.trim()

        if exp_normalized == act_normalized:
            return ComparisonResult.Match

        # Generate diff
        val diff = generate_unified_diff(
            expected: exp_normalized,
            actual: act_normalized,
            test_name: test_name
        )

        # Count changes
        val stats = count_diff_stats(diff)

        val context = DiffContext(
            expected_file: ".snapshots/{test_name}.snap",
            actual_content: actual,
            test_name: test_name,
            format: format,
            added_lines: stats.added,
            removed_lines: stats.removed,
            changed_lines: stats.changed
        )

        return ComparisonResult.Mismatch(diff: diff, context: context)

    # Generate unified diff (similar to `diff -u`)
    pub fn generate_unified_diff(
        expected: text,
        actual: text,
        test_name: text
    ) -> text:
        val exp_lines = expected.split("\n")
        val act_lines = actual.split("\n")

        var diff = ""
        diff += "Snapshot mismatch: {test_name}\n\n"
        diff += "--- Expected\n"
        diff += "+++ Actual\n"

        # Use Myers diff algorithm (simplified)
        val changes = myers_diff(exp_lines, act_lines)

        # Group changes into hunks
        val hunks = group_into_hunks(changes, exp_lines, act_lines)

        for hunk in hunks:
            diff += format_hunk(hunk)

        return diff

    # Simplified Myers diff algorithm
    fn myers_diff(expected: [text], actual: [text]) -> <DiffOp>:
        val n = expected.length()
        val m = actual.length()
        var ops = []

        # Simple line-by-line comparison (could be optimized with full Myers)
        var i = 0
        var j = 0

        while i < n or j < m:
            if i < n and j < m and expected[i] == actual[j]:
                ops.push(DiffOp.Equal(expected[i]))
                i += 1
                j += 1
            elif i < n and j < m:
                # Changed line
                ops.push(DiffOp.Delete(expected[i]))
                ops.push(DiffOp.Insert(actual[j]))
                i += 1
                j += 1
            elif i < n:
                # Deleted line
                ops.push(DiffOp.Delete(expected[i]))
                i += 1
            else:
                # Inserted line
                ops.push(DiffOp.Insert(actual[j]))
                j += 1

        return ops

    # Diff operation types
    enum DiffOp:
        Equal(line: text)
        Delete(line: text)
        Insert(line: text)

    # Diff hunk (group of changes)
    struct DiffHunk:
        old_start: i64
        old_count: i64
        new_start: i64
        new_count: i64
        lines: <DiffLine>

    struct DiffLine:
        prefix: text  # " ", "-", "+"
        content: text
        line_number: i64

    # Group diff operations into hunks with context
    fn group_into_hunks(
        ops: <DiffOp>,
        expected: [text],
        actual: [text]
    ) -> <DiffHunk>:
        var hunks = []
        var current_hunk = None
        val context_lines = 3

        var old_line = 0
        var new_line = 0

        for op in ops:
            match op:
                DiffOp.Equal(line) ->
                    old_line += 1
                    new_line += 1
                    # Add context line
                    if val Some(hunk) = current_hunk:
                        hunk.lines.push(DiffLine(
                            prefix: " ",
                            content: line,
                            line_number: old_line
                        ))

                DiffOp.Delete(line) ->
                    # Start new hunk if needed
                    if current_hunk.is_none():
                        current_hunk = Some(DiffHunk(
                            old_start: old_line + 1,
                            old_count: 0,
                            new_start: new_line + 1,
                            new_count: 0,
                            lines: []
                        ))

                    current_hunk.unwrap().lines.push(DiffLine(
                        prefix: "-",
                        content: line,
                        line_number: old_line + 1
                    ))
                    current_hunk.unwrap().old_count += 1
                    old_line += 1

                DiffOp.Insert(line) ->
                    # Start new hunk if needed
                    if current_hunk.is_none():
                        current_hunk = Some(DiffHunk(
                            old_start: old_line + 1,
                            old_count: 0,
                            new_start: new_line + 1,
                            new_count: 0,
                            lines: []
                        ))

                    current_hunk.unwrap().lines.push(DiffLine(
                        prefix: "+",
                        content: line,
                        line_number: new_line + 1
                    ))
                    current_hunk.unwrap().new_count += 1
                    new_line += 1

        if val Some(hunk) = current_hunk:
            hunks.push(hunk)

        return hunks

    # Format a hunk for display
    fn format_hunk(hunk: DiffHunk) -> text:
        var result = ""

        # Hunk header: @@ -old_start,old_count +new_start,new_count @@
        result += "@@ -{hunk.old_start},{hunk.old_count} +{hunk.new_start},{hunk.new_count} @@\n"

        # Lines
        for line in hunk.lines:
            result += "{line.prefix}{line.content}\n"

        return result

    # Count diff statistics
    struct DiffStats:
        added: i64
        removed: i64
        changed: i64

    fn count_diff_stats(diff: text) -> DiffStats:
        val lines = diff.split("\n")
        var added = 0
        var removed = 0

        for line in lines:
            if line.starts_with("+") and !line.starts_with("+++"):
                added += 1
            elif line.starts_with("-") and !line.starts_with("---"):
                removed += 1

        val changed = min(added, removed)
        added -= changed
        removed -= changed

        return DiffStats(
            added: added,
            removed: removed,
            changed: changed
        )

    # Format comparison result for display
    pub fn format_comparison_result(result: ComparisonResult) -> text:
        match result:
            ComparisonResult.Match ->
                return "âœ“ Snapshot matches"

            ComparisonResult.Mismatch(diff, context) ->
                var output = ""
                output += diff
                output += "\n"
                output += "Summary: {context.summary()}\n"
                output += "\n"
                output += "To update this snapshot, run:\n"
                output += "  simple test --snapshot-update={context.test_name}\n"
                return output
