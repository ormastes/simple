# BDD Registry - Core types and global state for spec framework
#
# This module provides the core data structures used by the BDD framework:
# - ExampleGroup: Hierarchical test organization (describe/context blocks)
# - Example: Individual test cases (it blocks)
# - Hook: Lifecycle hooks (before_each, after_each, etc.)
# - ContextDefinition: Reusable context definitions
# - Given: Setup blocks for contexts
# - SharedExampleDefinition: Shared example groups
#
# The registry maintains global state for registered groups, contexts, and
# shared examples, allowing the DSL functions to coordinate test execution.

# ============================================================================
# Core Types
# ============================================================================

# Hook - Lifecycle callback for test setup and teardown
# Note: Using Any type for blocks to work around parser limitations with function types in enums
enum Hook:
    BeforeEach(block: Any)   # Run before each example - fn() -> void
    AfterEach(block: Any)    # Run after each example - fn() -> void
    BeforeAll(block: Any)    # Run once before all examples in group - fn() -> void
    AfterAll(block: Any)     # Run once after all examples in group - fn() -> void

# Given - Setup block for context definitions
enum Given:
    Lazy(name: Any, block: Any)   # Lazy evaluated on first access - (Symbol, fn() -> Any)
    Eager(block: Any)              # Eagerly evaluated before each - fn() -> void

# Example - Individual test case
class Example:
    description: text
    block: fn() -> void
    is_skipped: bool

    fn new(description: text, block: fn() -> void) -> Example:
        return Example(description, block, false)

    fn skip() -> Example:
        """Mark this example as skipped/pending."""
        self.is_skipped = true
        return self

    fn is_pending() -> bool:
        """Check if this example is pending/skipped."""
        return self.is_skipped

    fn run() -> void:
        """Execute the example block (unless skipped)."""
        if not self.is_skipped:
            self.block()

# ExampleGroup - Hierarchical container for examples (describe/context blocks)
class ExampleGroup:
    description: text
    parent: Option<ExampleGroup>
    children: List<ExampleGroup>
    test_examples: List<Example>
    hooks: List<Hook>

    fn new(description: text, parent: Option<ExampleGroup>) -> ExampleGroup:
        return ExampleGroup(description, parent, [], [], [])

    fn add_child(child: ExampleGroup) -> void:
        """Add a nested example group (context)."""
        self.children.push(child)

    fn add_example(example: Example) -> void:
        """Add a test example (it block)."""
        self.test_examples.push(example)

    fn add_hook(hook: Hook) -> void:
        """Add a lifecycle hook."""
        self.hooks.push(hook)

    fn get_before_each_hooks() -> List<Any>:
        """Extract all before_each hook blocks."""
        val blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.BeforeEach(block):
                    blocks.push(block)
                case _:
                    pass
        return blocks

    fn get_after_each_hooks() -> List<Any>:
        """Extract all after_each hook blocks."""
        val blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.AfterEach(block):
                    blocks.push(block)
                case _:
                    pass
        return blocks

    fn get_before_all_hooks() -> List<Any>:
        """Extract all before_all hook blocks."""
        val blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.BeforeAll(block):
                    blocks.push(block)
                case _:
                    pass
        return blocks

    fn get_after_all_hooks() -> List<Any>:
        """Extract all after_all hook blocks."""
        val blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.AfterAll(block):
                    blocks.push(block)
                case _:
                    pass
        return blocks

    fn full_description() -> text:
        """Get the full hierarchical description path."""
        match self.parent:
            case Some(parent):
                return parent.full_description() + " " + self.description
            case None:
                return self.description

    fn example_count() -> i32:
        """Count total examples in this group and children."""
        var count = self.test_examples.len()
        for child in self.children:
            count = count + child.example_count()
        return count

# ContextDefinition - Reusable context with setup blocks
class ContextDefinition:
    name: Symbol
    givens: List<Given>

    fn new(name: Symbol) -> ContextDefinition:
        return ContextDefinition(name, [])

    fn add_given(given: Given) -> void:
        """Add a setup block to this context."""
        self.givens.push(given)

# SharedExampleDefinition - Reusable example group
# Note: Using Any type for block to work around parser limitations with function types
class SharedExampleDefinition:
    name: text
    block: Any  # fn() -> void
    description: Option<text>

    fn new(name: text, block: Any) -> SharedExampleDefinition:
        return SharedExampleDefinition(name, block, None)

    fn with_description(desc: text) -> SharedExampleDefinition:
        """Add a description to this shared example group."""
        self.description = Some(desc)
        return self

# ============================================================================
# Global Registry State
# ============================================================================

# Top-level example groups (from describe blocks)
val registered_groups: List<ExampleGroup> = []

# Context definitions (from context_def blocks)
val context_registry: Dict<text, ContextDefinition> = {}

# Shared example definitions (from shared_examples blocks)
val shared_examples_registry: Dict<text, SharedExampleDefinition> = {}

# ============================================================================
# Registry Functions
# ============================================================================

fn register_group(group: ExampleGroup) -> void:
    """Register a top-level example group."""
    registered_groups.push(group)

fn get_all_groups() -> List<ExampleGroup>:
    """Get all registered top-level groups."""
    return registered_groups

fn clear_groups() -> void:
    """Clear all registered groups (for testing)."""
    registered_groups.clear()

fn register_context(name: Symbol, def: ContextDefinition) -> void:
    """Register a reusable context definition."""
    context_registry.insert(name.to_string(), def)

fn get_context(name: Symbol) -> Option<ContextDefinition>:
    """Get a registered context definition by name."""
    return context_registry.get(name.to_string())

fn clear_contexts() -> void:
    """Clear all registered contexts (for testing)."""
    context_registry.clear()

fn register_shared_examples(name: text, def: SharedExampleDefinition) -> void:
    """Register a shared example group."""
    shared_examples_registry.insert(name, def)

fn get_shared_examples(name: text) -> Option<SharedExampleDefinition>:
    """Get a registered shared example group by name."""
    return shared_examples_registry.get(name)

fn clear_shared_examples() -> void:
    """Clear all registered shared examples (for testing)."""
    shared_examples_registry.clear()

fn reset_registry() -> void:
    """Clear all registry state (groups, contexts, shared examples)."""
    clear_groups()
    clear_contexts()
    clear_shared_examples()

# ============================================================================
# Export All Public Types and Functions
# ============================================================================

export Hook, Given, Example, ExampleGroup, ContextDefinition, SharedExampleDefinition
export register_group, get_all_groups, clear_groups
export register_context, get_context, clear_contexts
export register_shared_examples, get_shared_examples, clear_shared_examples
export reset_registry
