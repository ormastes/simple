# Expectations - expect/to/not_to DSL
# Provides fluent assertion interface

import matchers.{Matcher, MatchResult}

# Expectation target - wraps actual value
class Expectation[T]:
    actual: T
    negated: Bool
    
    fn new(actual: T) -> Expectation[T]:
        return Expectation {
            actual: actual,
            negated: false
        }
    
    # Positive assertion: expect x to eq 5
    fn to(matcher: Matcher[T]) -> Void:
        val result = matcher.matches(self.actual)
        
        if self.negated:
            if result.matched:
                fail(result.failure_message)
        else:
            if not result.matched:
                fail(result.failure_message)
    
    # Negative assertion: expect x not_to eq 5
    fn not_to(matcher: Matcher[T]) -> Void:
        self.negated = true
        self.to(matcher)

# Main expect function
fn expect[T](actual: T) -> Expectation[T]:
    return Expectation.new(actual)

# Block expectation for errors
class BlockExpectation:
    block: fn() -> Void

    fn new(block: fn() -> Void) -> BlockExpectation:
        return BlockExpectation { block: block }
    
    fn to(matcher: Matcher[Any]) -> Void:
        # Execute block (Simple does not support exceptions)
        # Error handling not available without exception support
        self.block()

        # Pass None to matcher (no error capture available)
        val result = matcher.matches(None)
        if not result.matched:
            fail(result.failure_message)

# expect_raises: Block form for error expectations
# Usage: expect_raises ValueError: do_something()
# NOTE: Simple does not support exceptions - this function is a no-op
fn expect_raises(error_type: Type, block: fn() -> Void) -> Void:
    # Simple does not support exception handling
    # Just execute the block without error checking
    block()

# Failure helper
fn fail(message: String) -> Void:
    panic("Expectation failed: ${message}")
