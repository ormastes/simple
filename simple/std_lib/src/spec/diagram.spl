# Diagram Generation Module
# Provides call flow tracing and Mermaid diagram generation

# ============================================================================
# Types
# ============================================================================

enum DiagramType:
    Sequence
    Class
    Architecture

struct DiagramConfig:
    diagram_type: DiagramType
    output_dir: String
    include_timestamps: Bool
    include_arguments: Bool
    max_depth: Int

    fn new() -> DiagramConfig:
        return DiagramConfig {
            diagram_type: DiagramType.Sequence,
            output_dir: ".diagrams",
            include_timestamps: false,
            include_arguments: true,
            max_depth: 10
        }

enum CallType:
    Direct
    Method
    Ffi
    Closure
    Constructor

struct CallEvent:
    callee: String
    callee_class: Option[String]
    arguments: List[String]
    call_type: CallType
    return_value: Option[String]
    timestamp_ns: Int

    fn new(callee: String, call_type: CallType) -> CallEvent:
        return CallEvent {
            callee: callee,
            callee_class: None,
            arguments: [],
            call_type: call_type,
            return_value: None,
            timestamp_ns: 0
        }

class CallEventRecorder:
    events: List[CallEvent]
    architectural_entities: List[String]
    enabled: Bool

    fn new() -> CallEventRecorder:
        return CallEventRecorder {
            events: [],
            architectural_entities: [],
            enabled: false
        }

    fn enable(self) -> Void:
        self.enabled = true

    fn disable(self) -> Void:
        self.enabled = false

    fn clear(self) -> Void:
        self.events = []
        self.architectural_entities = []

    fn record(self, event: CallEvent) -> Void:
        if self.enabled:
            self.events.push(event)

    fn mark_architectural(self, entity: String) -> Void:
        if not self.architectural_entities.contains(entity):
            self.architectural_entities.push(entity)

# ============================================================================
# Global Recorder
# ============================================================================

let global_recorder: Option[CallEventRecorder] = None

fn set_recorder(recorder: CallEventRecorder) -> Void:
    global_recorder = Some(recorder)

fn get_recorder() -> Option[CallEventRecorder]:
    return global_recorder

fn clear_recorder() -> Void:
    match global_recorder:
        case Some(rec):
            rec.clear()
        case None:
            pass

# ============================================================================
# Tracing Functions (Simple-side)
# ============================================================================

fn trace_call(name: String) -> Void:
    match global_recorder:
        case Some(rec):
            let event = CallEvent.new(name, CallType.Direct)
            rec.record(event)
        case None:
            pass

fn trace_method(class_name: String, method_name: String, args: List[String]) -> Void:
    match global_recorder:
        case Some(rec):
            let event = CallEvent {
                callee: method_name,
                callee_class: Some(class_name),
                arguments: args,
                call_type: CallType.Method,
                return_value: None,
                timestamp_ns: 0
            }
            rec.record(event)
        case None:
            pass

fn trace_return(value: Option[String]) -> Void:
    pass

fn mark_architectural(entity: String) -> Void:
    match global_recorder:
        case Some(rec):
            rec.mark_architectural(entity)
        case None:
            pass

# ============================================================================
# Diagram Generation (Simple-side)
# ============================================================================

fn generate_sequence() -> String:
    return "sequenceDiagram"

fn generate_class_diagram() -> String:
    return "classDiagram"

fn generate_arch_diagram() -> String:
    return "flowchart TD"

# ============================================================================
# Context Helpers
# ============================================================================

fn with_sequence_diagram[T](config: DiagramConfig, block: fn() -> T) -> T:
    enable_ffi_recording()
    clear_ffi_recording()
    let result = block()
    disable_ffi_recording()
    return result

fn with_all_diagrams[T](config: DiagramConfig, block: fn() -> T) -> T:
    enable_ffi_recording()
    clear_ffi_recording()
    let result = block()
    disable_ffi_recording()
    return result

fn with_diagram[T](dtype: DiagramType, config: DiagramConfig, block: fn() -> T) -> T:
    enable_ffi_recording()
    clear_ffi_recording()
    let result = block()
    disable_ffi_recording()
    return result

# ============================================================================
# File Operations
# ============================================================================

fn save_diagram(path: String, content: String) -> Void:
    pass

fn diagram_exists(path: String) -> Bool:
    return false

fn diagram_placeholder(dtype: DiagramType) -> String:
    return "diagram placeholder"

# ============================================================================
# FFI Declarations
# ============================================================================

extern fn rt_diagram_enable() -> Void
extern fn rt_diagram_disable() -> Void
extern fn rt_diagram_clear() -> Void
extern fn rt_diagram_is_enabled() -> Bool
extern fn rt_diagram_trace_method(class_name: String, method_name: String) -> Void
extern fn rt_diagram_trace_method_with_args(class_name: String, method_name: String, args: String) -> Void
extern fn rt_diagram_trace_return(value: String) -> Void
extern fn rt_diagram_mark_architectural(entity: String) -> Void
extern fn rt_diagram_generate_sequence() -> String
extern fn rt_diagram_generate_class() -> String
extern fn rt_diagram_generate_arch() -> String
extern fn rt_diagram_free_string(ptr: Int) -> Void

# ============================================================================
# FFI Wrappers
# ============================================================================

fn enable_ffi_recording() -> Void:
    rt_diagram_enable()

fn disable_ffi_recording() -> Void:
    rt_diagram_disable()

fn clear_ffi_recording() -> Void:
    rt_diagram_clear()

fn generate_sequence_ffi() -> String:
    return rt_diagram_generate_sequence()

fn generate_class_ffi() -> String:
    return rt_diagram_generate_class()

fn generate_arch_ffi() -> String:
    return rt_diagram_generate_arch()

# ============================================================================
# Exports
# ============================================================================

export DiagramType, DiagramConfig
export CallType, CallEvent, CallEventRecorder
export set_recorder, get_recorder, clear_recorder
export trace_call, trace_method, trace_return, mark_architectural
export generate_sequence, generate_class_diagram, generate_arch_diagram
export with_sequence_diagram, with_all_diagrams, with_diagram
export save_diagram, diagram_exists, diagram_placeholder
export enable_ffi_recording, disable_ffi_recording, clear_ffi_recording
export generate_sequence_ffi, generate_class_ffi, generate_arch_ffi
