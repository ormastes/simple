# Markdown Documentation Generator for BDD Specs
# Converts describe/context/it blocks into GitHub-compatible Markdown
# Supports screenshot embedding and diagram generation placeholders

use core.collections.{List, Dict}
use core.string.text
import screenshot.{screenshot_exists, get_screenshot_path, screenshot_markdown}

class MarkdownFormatter:
    output: text
    include_screenshots: bool
    include_diagrams: bool
    test_file: Option<text>

    static fn new() -> MarkdownFormatter:
        return MarkdownFormatter(
            output: text.empty(),
            include_screenshots: true,
            include_diagrams: true,
            test_file: nil
        )

    fn with_test_file(file: text) -> MarkdownFormatter:
        return MarkdownFormatter(
            output: self.output,
            include_screenshots: self.include_screenshots,
            include_diagrams: self.include_diagrams,
            test_file: Some(file)
        )

    fn with_screenshots(enabled: bool) -> MarkdownFormatter:
        return MarkdownFormatter(
            output: self.output,
            include_screenshots: enabled,
            include_diagrams: self.include_diagrams,
            test_file: self.test_file
        )

    fn with_diagrams(enabled: bool) -> MarkdownFormatter:
        return MarkdownFormatter(
            output: self.output,
            include_screenshots: self.include_screenshots,
            include_diagrams: enabled,
            test_file: self.test_file
        )

    fn format_describe(name: text, level: i32) -> text:
        val prefix = "#" * (level + 1)
        return "{prefix} {name}\n\n"

    fn format_context(name: text, level: i32) -> text:
        val prefix = "#" * (level + 2)
        return "{prefix} {name}\n\n"

    fn format_example(name: text, status: text, error: Option<text>) -> text:
        val icon = match status:
            "pass" => "✅"
            "fail" => "❌"
            "skip" => "⏭️"
            _ => "❓"

        var result = "{icon} **{name}**\n\n"

        if val Some(err) = error:
            result = result + "```\nError: {err}\n```\n\n"

        return result

    fn format_example_with_media(name: text, status: text, error: Option<text>, is_gui: bool, has_diagram: bool) -> text:
        var result = self.format_example(name, status, error)

        # Add screenshot section for @gui tests
        if is_gui and self.include_screenshots:
            result = result + self.format_screenshot_section(name)

        # Add diagram section if available
        if has_diagram and self.include_diagrams:
            result = result + self.format_diagram_section(name)

        return result

    fn format_screenshot_section(test_name: text) -> text:
        match self.test_file:
            case Some(file):
                val before_exists = screenshot_exists(test_name, file, "before")
                val after_exists = screenshot_exists(test_name, file, "after")

                if before_exists or after_exists:
                    var section = "<details>\n<summary>Screenshots</summary>\n\n"

                    if before_exists:
                        section = section + "**Before:**\n\n"
                        section = section + screenshot_markdown(test_name, file, "before") + "\n\n"

                    if after_exists:
                        section = section + "**After:**\n\n"
                        section = section + screenshot_markdown(test_name, file, "after") + "\n\n"

                    section = section + "</details>\n\n"
                    return section
                else:
                    # Show placeholder with generation instructions
                    return self.format_screenshot_placeholder(test_name, file)
            case nil:
                return ""

    fn format_screenshot_placeholder(test_name: text, test_file: text) -> text:
        val cmd = "simple test --refresh-gui-image {test_file}"
        return "<details>\n<summary>Screenshots (not available)</summary>\n\n" +
               "> **Screenshot not captured**\n>\n" +
               "> To generate: `{cmd}`\n\n" +
               "</details>\n\n"

    fn format_diagram_section(test_name: text) -> text:
        match self.test_file:
            case Some(file):
                val diagram_path = self.get_diagram_path(test_name, file)
                if diagram_path.is_some():
                    val path = diagram_path.unwrap()
                    return "<details>\n<summary>Sequence Diagram</summary>\n\n" +
                           "```mermaid\n" +
                           _read_diagram_content(path) +
                           "\n```\n\n</details>\n\n"
                else:
                    return self.format_diagram_placeholder(test_name, file)
            case nil:
                return ""

    fn format_diagram_placeholder(test_name: text, test_file: text) -> text:
        val cmd = "simple test --seq-diagram {test_file}"
        return "<details>\n<summary>Diagram (not available)</summary>\n\n" +
               "> **Diagram not generated**\n>\n" +
               "> To generate: `{cmd}`\n\n" +
               "</details>\n\n"

    fn get_diagram_path(test_name: text, test_file: text) -> Option<text>:
        # Compute diagram path similar to screenshot path
        val base_dir = "doc/spec/diagrams"
        val relative = test_file
            .replace("simple/std_lib/test/", "")
            .replace("test/", "")
            .replace("_spec.spl", "")
            .replace("_test.spl", "")
            .replace(".spl", "")

        val safe_name = test_name.replace(" ", "_").replace("/", "_").to_lowercase()
        val path = "{base_dir}/{relative}/{safe_name}.mmd"

        if fs.exists(path):
            return Some(path)
        else:
            return nil

    fn format_code_block(code: text, language: text) -> text:
        return "```{language}\n{code}\n```\n\n"

# Internal: Read diagram content from file
fn _read_diagram_content(path: text) -> text:
    match fs.read_string(path):
        case Ok(content):
            return content
        case Err(_):
            return "# Error reading diagram"

# Convert spec results to Markdown documentation
fn format_spec_to_markdown(spec_results: Dict<text, Any>) -> text:
    val formatter = MarkdownFormatter.new()
    var output = text.empty()

    # Extract spec metadata
    val suite_name = spec_results.get("suite_name").unwrap_or("Test Suite")
    output = output + "# {suite_name}\n\n"

    # Add timestamp
    if val Some(timestamp) = spec_results.get("timestamp"):
        output = output + "*Generated: {timestamp}*\n\n"

    # Process describe blocks
    if val Some(describes) = spec_results.get("describe_blocks"):
        for describe in describes:
            output = output + formatter.format_describe(
                describe.get("description").unwrap_or(""),
                1
            )

            # Process contexts
            if val Some(contexts) = describe.get("contexts"):
                for context in contexts:
                    output = output + formatter.format_context(
                        context.get("description").unwrap_or(""),
                        2
                    )

                    # Process examples (it blocks)
                    if val Some(example_list) = context.get("examples"):
                        for example in example_list:
                            val status = example.get("status").unwrap_or("unknown")
                            val name = example.get("description").unwrap_or("")
                            val error = example.get("error")

                            output = output + formatter.format_example(name, status, error)

                            # Add code if available
                            if val Some(code) = example.get("code"):
                                output = output + formatter.format_code_block(code, "simple")

    # Add summary
    if val Some(summary) = spec_results.get("summary"):
        output = output + "\n---\n\n## Summary\n\n"
        val total = summary.get("total").unwrap_or(0)
        val passed = summary.get("passed").unwrap_or(0)
        val failed = summary.get("failed").unwrap_or(0)
        val skipped = summary.get("skipped").unwrap_or(0)

        output = output + "- **Total:** {total} tests\n"
        output = output + "- **Passed:** {passed} ✅\n"
        output = output + "- **Failed:** {failed} ❌\n"
        output = output + "- **Skipped:** {skipped} ⏭️\n"

    return output
