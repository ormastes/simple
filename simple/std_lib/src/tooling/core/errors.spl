# Error Aggregation Across Languages
# Collect and normalize errors from multiple language compilers

use tooling.core.project.Language
use tooling.compiler.interface.{CompilationError, ErrorSeverity}

# Error output format
pub enum ErrorFormat:
    Terminal    # Human-readable terminal output
    JSON        # JSON array of errors
    XML         # JUnit XML format
    VSCode      # VS Code problem matcher format

# Error aggregator - collects and normalizes errors
pub class ErrorAggregator:
    pub errors: List[CompilationError]
    pub warnings: List[CompilationError]
    pub infos: List[CompilationError]
    pub dedup_enabled: bool

    pub fn new(): ErrorAggregator =
        """Create error aggregator.

        Returns:
            Empty aggregator

        Example:
            let aggregator = ErrorAggregator.new()

            aggregator.add_simple_errors(simple_errors)
            aggregator.add_rust_errors(cargo_output)
            aggregator.add_python_errors(mypy_output)

            for error in aggregator.get_all():
                print(error.format())
        """
        ErrorAggregator {
            errors: [],
            warnings: [],
            infos: [],
            dedup_enabled: true
        }

    pub fn set_deduplication(self, enabled: bool):
        """Enable/disable error deduplication.

        Args:
            enabled: True to remove duplicate errors
        """
        self.dedup_enabled = enabled

    pub fn add_error(self, error: CompilationError):
        """Add compilation error.

        Args:
            error: Error to add
        """
        # Check for duplicate
        if self.dedup_enabled and self.is_duplicate(error):
            return

        match error.severity:
            ErrorSeverity::Error:
                self.errors.append(error)
            ErrorSeverity::Warning:
                self.warnings.append(error)
            ErrorSeverity::Info:
                self.infos.append(error)

    pub fn add_errors(self, errors: List[CompilationError]):
        """Add multiple errors.

        Args:
            errors: List of errors
        """
        for error in errors:
            self.add_error(error)

    pub fn add_simple_errors(self, errors: List[CompilationError]):
        """Add Simple compiler errors.

        Args:
            errors: Simple compiler errors
        """
        self.add_errors(errors)

    pub fn add_rust_errors(self, cargo_output: String):
        """Parse and add Rust/cargo errors.

        Args:
            cargo_output: Cargo JSON output
        """
        let errors = self.parse_cargo_json(cargo_output)
        self.add_errors(errors)

    pub fn add_python_errors(self, mypy_output: String):
        """Parse and add Python/mypy errors.

        Args:
            mypy_output: Mypy text output
        """
        let errors = self.parse_mypy_output(mypy_output)
        self.add_errors(errors)

    pub fn add_javascript_errors(self, eslint_output: String):
        """Parse and add JavaScript/ESLint errors.

        Args:
            eslint_output: ESLint JSON output
        """
        let errors = self.parse_eslint_json(eslint_output)
        self.add_errors(errors)

    fn is_duplicate(self, error: CompilationError): bool =
        """Check if error is duplicate.

        Args:
            error: Error to check

        Returns:
            True if duplicate exists
        """
        let all_errors = self.get_all()

        for existing in all_errors:
            if self.errors_equal(existing, error):
                return true

        false

    fn errors_equal(self, a: CompilationError, b: CompilationError): bool =
        """Check if two errors are equal.

        Args:
            a: First error
            b: Second error

        Returns:
            True if same file, line, column, and message
        """
        a.file == b.file and
        a.line == b.line and
        a.column == b.column and
        a.message == b.message

    pub fn get_all(self): List[CompilationError] =
        """Get all errors, warnings, and infos.

        Returns:
            Combined list sorted by severity
        """
        let mut all: List[CompilationError] = []
        all.extend(self.errors)
        all.extend(self.warnings)
        all.extend(self.infos)
        all

    pub fn get_by_severity(self, severity: ErrorSeverity): List[CompilationError] =
        """Get errors of specific severity.

        Args:
            severity: Error severity

        Returns:
            Filtered error list
        """
        match severity:
            ErrorSeverity::Error:
                self.errors.clone()
            ErrorSeverity::Warning:
                self.warnings.clone()
            ErrorSeverity::Info:
                self.infos.clone()

    pub fn group_by_file(self): Dict[String, List[CompilationError]] =
        """Group errors by file.

        Returns:
            Map from file to errors in that file

        Example:
            let by_file = aggregator.group_by_file()
            for (file, errors) in by_file:
                print(f"{file}: {errors.len()} errors")
        """
        let groups: Dict[String, List[CompilationError]] = {}

        for error in self.get_all():
            if not groups.contains_key(error.file):
                groups[error.file] = []

            groups[error.file].append(error)

        groups

    pub fn group_by_language(self): Dict[Language, List[CompilationError]] =
        """Group errors by language.

        Returns:
            Map from language to errors in that language
        """
        let groups: Dict[Language, List[CompilationError]] = {}

        for error in self.get_all():
            if not groups.contains_key(error.language):
                groups[error.language] = []

            groups[error.language].append(error)

        groups

    pub fn format_output(self, format: ErrorFormat): String =
        """Format errors for output.

        Args:
            format: Output format

        Returns:
            Formatted error string

        Example:
            # Terminal output
            print(aggregator.format_output(ErrorFormat::Terminal))

            # JSON for tools
            let json = aggregator.format_output(ErrorFormat::JSON)
        """
        match format:
            ErrorFormat::Terminal:
                self.format_terminal()
            ErrorFormat::JSON:
                self.format_json()
            ErrorFormat::XML:
                self.format_xml()
            ErrorFormat::VSCode:
                self.format_vscode()

    fn format_terminal(self): String =
        """Format errors for terminal display.

        Returns:
            Human-readable error list
        """
        let mut output = ""

        if self.errors.len() > 0:
            output += "Errors:\n"
            for error in self.errors:
                output += f"  {error.format()}\n"

        if self.warnings.len() > 0:
            output += "\nWarnings:\n"
            for warning in self.warnings:
                output += f"  {warning.format()}\n"

        if self.infos.len() > 0:
            output += "\nInfo:\n"
            for info in self.infos:
                output += f"  {info.format()}\n"

        if output.is_empty():
            output = "No errors\n"

        output

    fn format_json(self): String =
        """Format errors as JSON array.

        Returns:
            JSON string
        """
        # TODO: Implement JSON serialization
        "[]"

    fn format_xml(self): String =
        """Format errors as JUnit XML.

        Returns:
            XML string for CI systems
        """
        # TODO: Implement XML generation
        "<testsuites></testsuites>"

    fn format_vscode(self): String =
        """Format errors for VS Code problem matcher.

        Returns:
            VS Code problem format
        """
        # VS Code format: file(line,col): severity: message
        let mut output = ""

        for error in self.get_all():
            let severity_str = match error.severity:
                ErrorSeverity::Error: "error"
                ErrorSeverity::Warning: "warning"
                ErrorSeverity::Info: "info"

            output += f"{error.file}({error.line},{error.column}): {severity_str}: {error.message}\n"

        output

    # Language-specific parsers

    fn parse_cargo_json(self, json_output: String): List[CompilationError] =
        """Parse Cargo JSON diagnostic output.

        Args:
            json_output: Cargo --message-format=json output

        Returns:
            List of errors
        """
        # TODO: Implement JSON parsing
        []

    fn parse_mypy_output(self, output: String): List[CompilationError] =
        """Parse mypy text output.

        Args:
            output: Mypy stdout

        Returns:
            List of errors

        Format: file:line: error: message
        """
        let errors: List[CompilationError] = []

        let lines = output.split("\n")
        for line in lines:
            if line.trim().is_empty():
                continue

            # Try to parse error line
            match self.try_parse_mypy_line(line):
                some(error):
                    errors.append(error)
                none:
                    pass  # Skip non-error lines

        errors

    fn try_parse_mypy_line(self, line: String): CompilationError? =
        """Try to parse single mypy error line.

        Args:
            line: Error line

        Returns:
            Parsed error or none
        """
        # TODO: Implement regex parsing
        # Format: file:line: severity: message
        none

    fn parse_eslint_json(self, json_output: String): List[CompilationError] =
        """Parse ESLint JSON output.

        Args:
            json_output: ESLint --format=json output

        Returns:
            List of errors
        """
        # TODO: Implement JSON parsing
        []

    pub fn print_summary(self):
        """Print error summary.

        Example:
            aggregator.print_summary()
            # â†’ "3 errors, 5 warnings, 2 infos"
        """
        let total_errors = self.errors.len()
        let total_warnings = self.warnings.len()
        let total_infos = self.infos.len()

        print(f"{total_errors} errors, {total_warnings} warnings, {total_infos} infos")

    pub fn has_errors(self): bool =
        """Check if any errors exist.

        Returns:
            True if errors (not warnings) exist
        """
        self.errors.len() > 0
