# Dependency Tracking
# Track dependencies within and across languages

use tooling.core.project.{Language, ProjectContext}
use core.result.{Result, Ok, Err}

# Dependency edge in the graph
pub class Dependency:
    pub source: text
    pub target: text
    pub dep_type: DependencyType

    pub fn new(source: text, target: text, dep_type: DependencyType): Dependency =
        """Create dependency edge.

        Args:
            source: Source file
            target: Dependency file
            dep_type: Type of dependency

        Returns:
            Dependency edge
        """
        Dependency {
            source: source,
            target: target,
            dep_type: dep_type
        }

    pub fn is_code_dependency(self): bool =
        """Check if this is a code dependency.

        Returns:
            True if Import or FFI
        """
        self.dep_type.is_code_dependency()

    pub fn summary(self): text =
        """Get dependency summary.

        Returns:
            Human-readable summary

        Example:
            dep.summary()  # → "app.spl → lib.spl (import)"
        """
        "{self.source} → {self.target} ({self.dep_type.to_string()})"

# Dependency type
pub enum DependencyType:
    Import       # Language import/include
    FFI          # Foreign function interface
    Resource     # Resource file dependency
    Test         # Test dependency

    pub fn to_string(self): text =
        """Convert dependency type to string.

        Returns:
            Type name

        Example:
            DependencyType::Import.to_string()  # → "import"
        """
        match self:
            DependencyType::Import: "import"
            DependencyType::FFI: "ffi"
            DependencyType::Resource: "resource"
            DependencyType::Test: "test"

    pub fn is_code_dependency(self): bool =
        """Check if this is a code dependency.

        Returns:
            True if Import or FFI

        Example:
            DependencyType::Import.is_code_dependency()  # → true
            DependencyType::Resource.is_code_dependency()  # → false
        """
        match self:
            DependencyType::Import: true
            DependencyType::FFI: true
            DependencyType::Resource: false
            DependencyType::Test: false

    pub fn description(self): text =
        """Get dependency type description.

        Returns:
            Human-readable description

        Example:
            DependencyType::FFI.description()
            # → "Foreign function interface"
        """
        match self:
            DependencyType::Import: "Language import/include"
            DependencyType::FFI: "Foreign function interface"
            DependencyType::Resource: "Resource file dependency"
            DependencyType::Test: "Test dependency"

    pub fn is_resource_dependency(self): bool =
        """Check if this is a resource dependency.

        Returns:
            True if Resource type
        """
        match self:
            DependencyType::Import: false
            DependencyType::FFI: false
            DependencyType::Resource: true
            DependencyType::Test: false

    pub fn is_test_dependency(self): bool =
        """Check if this is a test dependency.

        Returns:
            True if Test type
        """
        match self:
            DependencyType::Import: false
            DependencyType::FFI: false
            DependencyType::Resource: false
            DependencyType::Test: true

    pub fn is_import(self): bool =
        """Check if this is an Import dependency.

        Returns:
            True if Import type

        Example:
            DependencyType::Import.is_import()  # → true
        """
        match self:
            DependencyType::Import: true
            _: false

    pub fn is_ffi(self): bool =
        """Check if this is an FFI dependency.

        Returns:
            True if FFI type

        Example:
            DependencyType::FFI.is_ffi()  # → true
        """
        match self:
            DependencyType::FFI: true
            _: false

    pub fn is_resource(self): bool =
        """Check if this is a Resource dependency.

        Returns:
            True if Resource type

        Example:
            DependencyType::Resource.is_resource()  # → true
        """
        match self:
            DependencyType::Resource: true
            _: false

    pub fn is_test(self): bool =
        """Check if this is a Test dependency.

        Returns:
            True if Test type

        Example:
            DependencyType::Test.is_test()  # → true
        """
        match self:
            DependencyType::Test: true
            _: false

    pub fn summary(self): text =
        """Get dependency type summary.

        Returns:
            Human-readable summary

        Example:
            DependencyType::Import.summary()
            # → "DependencyType: import (Language import/include, code dependency)"
        """
        val name = self.to_string()
        val desc = self.description()
        val category = if self.is_code_dependency():
            "code dependency"
        elif self.is_test_dependency():
            "test dependency"
        else:
            "resource dependency"
        return "DependencyType: {name} ({desc}, {category})"

# Dependency graph
pub class DependencyGraph:
    pub edges: List<Dependency>
    pub nodes: Dict<text, DependencyNode>

    pub fn new(): DependencyGraph =
        """Create empty dependency graph."""
        DependencyGraph {
            edges: [],
            nodes: {}
        }

    pub fn node_count(self): i32 =
        """Get number of nodes in graph.

        Returns:
            Node count
        """
        self.nodes.len()

    pub fn edge_count(self): i32 =
        """Get number of edges in graph.

        Returns:
            Edge count
        """
        self.edges.len()

    pub fn is_empty(self): bool =
        """Check if graph is empty.

        Returns:
            True if no nodes
        """
        self.nodes.len() == 0

    pub fn has_nodes(self): bool =
        """Check if graph has nodes.

        Returns:
            True if nodes exist
        """
        self.nodes.len() > 0

    pub fn has_edges(self): bool =
        """Check if graph has edges.

        Returns:
            True if edges exist
        """
        self.edges.len() > 0

    pub fn has_cycles(self): bool =
        """Check if graph contains cycles.

        Returns:
            True if circular dependencies exist

        Example:
            if graph.has_cycles():
                print("Warning: circular dependencies detected!")
        """
        self.detect_cycles().len() > 0

    pub fn summary(self): text =
        """Get graph summary.

        Returns:
            Human-readable summary

        Example:
            graph.summary()
            # → "DependencyGraph: 50 nodes, 120 edges"
        """
        "DependencyGraph: {self.node_count()} nodes, {self.edge_count()} edges"

    pub fn get_statistics(self): DependencyStatistics =
        """Get graph statistics.

        Returns:
            Dependency statistics

        Example:
            val stats = graph.get_statistics()
            print("Nodes: {stats.total_nodes}")
            print("Edges: {stats.total_edges}")
            print("Avg dependencies: {stats.avg_dependencies_per_node:.1f}")
        """
        val stats = DependencyStatistics.new()
        stats.total_nodes = self.node_count()
        stats.total_edges = self.edge_count()

        if stats.total_nodes > 0:
            stats.avg_dependencies_per_node = (stats.total_edges as f64) / (stats.total_nodes as f64)

        # Find max dependencies
        for (_, node) in self.nodes.items():
            val dep_count = node.dependencies.len()
            if dep_count > stats.max_dependencies:
                stats.max_dependencies = dep_count
                stats.most_dependent_file = node.file

        stats

    pub fn get_root_nodes(self): List<text> =
        """Get root nodes (files with no dependencies).

        Returns:
            List of root node file paths

        Example:
            val roots = graph.get_root_nodes()
            # → ["main.spl", "cli.spl"]
        """
        val roots: List<text> = []
        for (file, node) in self.nodes.items():
            if node.dependencies.len() == 0:
                roots.append(file)
        roots

    pub fn get_leaf_nodes(self): List<text> =
        """Get leaf nodes (files with no dependents).

        Returns:
            List of leaf node file paths

        Example:
            val leaves = graph.get_leaf_nodes()
            # → ["utils.spl", "constants.spl"]
        """
        val leaves: List<text> = []
        for (file, node) in self.nodes.items():
            if node.dependents.len() == 0:
                leaves.append(file)
        leaves

    pub fn add_node(self, file: text, language: Language):
        """Add node to graph.

        Args:
            file: File path
            language: Source language
        """
        if not self.nodes.contains_key(file):
            self.nodes[file] = DependencyNode.new(file, language)

    pub fn add_edge(
        self,
        source: text,
        target: text,
        dep_type: DependencyType
    ):
        """Add dependency edge.

        Args:
            source: Source file
            target: Target file
            dep_type: Dependency type

        Example:
            graph.add_node("app.spl", Language::Simple)
            graph.add_node("lib.spl", Language::Simple)
            graph.add_edge("app.spl", "lib.spl", DependencyType::Import)
        """
        val dep = Dependency.new(source, target, dep_type)
        self.edges.append(dep)

        # Add to node adjacency lists
        if self.nodes.contains_key(source):
            self.nodes[source].dependencies.append(target)

        if self.nodes.contains_key(target):
            self.nodes[target].dependents.append(source)

    pub fn get_dependencies(self, file: text): List<text> =
        """Get direct dependencies of file.

        Args:
            file: File to get dependencies for

        Returns:
            List of dependency files

        Example:
            val deps = graph.get_dependencies("app.spl")
            # → ["lib.spl", "core.spl"]
        """
        match self.nodes.get(file):
            some(node):
                node.dependencies.clone()
            none:
                []

    pub fn get_transitive_dependencies(self, file: text): List<text> =
        """Get all transitive dependencies of file.

        Args:
            file: File to get dependencies for

        Returns:
            List of all dependency files (recursive)

        Example:
            val deps = graph.get_transitive_dependencies("app.spl")
            # → ["lib.spl", "core.spl", "utils.spl"]
        """
        val visited: Dict<text, bool> = {}
        val result: List<text> = []

        self.collect_dependencies_recursive(file, visited, result)

        result

    fn collect_dependencies_recursive(file: text,
        visited: Dict<text, bool>,
        result: List<text>
    ):
        """Recursively collect dependencies.

        Args:
            file: Current file
            visited: Set of visited files
            result: Accumulated dependencies (output)
        """
        if visited.contains_key(file):
            return

        visited[file] = true

        val deps = self.get_dependencies(file)
        for dep in deps:
            result.append(dep)
            self.collect_dependencies_recursive(dep, visited, result)

    pub fn get_reverse_dependencies(self, file: text): List<text> =
        """Get files that depend on given file.

        Args:
            file: File to find dependents of

        Returns:
            List of dependent files

        Example:
            val rdeps = graph.get_reverse_dependencies("lib.spl")
            # → ["app.spl", "test.spl"]
        """
        match self.nodes.get(file):
            some(node):
                node.dependents.clone()
            none:
                []

    pub fn detect_cycles(self): List<List<text>> =
        """Detect circular dependencies.

        Returns:
            List of dependency cycles

        Algorithm: Tarjan's strongly connected components

        Example:
            val cycles = graph.detect_cycles()
            if cycles.len() > 0:
                print("Circular dependencies found!")
                for cycle in cycles:
                    print("  {cycle.join(' → ')}")
        """
        val cycles: List<List<text>> = []
        val visited: Dict<text, bool> = {}
        val stack: List<text> = []
        val in_stack: Dict<text, bool> = {}

        for (file, _) in self.nodes.items():
            if not visited.contains_key(file):
                self.find_cycles_dfs(
                    file,
                    visited,
                    stack,
                    in_stack,
                    cycles
                )

        cycles

    fn find_cycles_dfs(file: text,
        visited: Dict<text, bool>,
        stack: List<text>,
        in_stack: Dict<text, bool>,
        cycles: List<List<text>>
    ):
        """DFS for cycle detection.

        Args:
            file: Current file
            visited: Visited set
            stack: DFS stack
            in_stack: Files in current DFS path
            cycles: Found cycles (output)
        """
        visited[file] = true
        stack.append(file)
        in_stack[file] = true

        val deps = self.get_dependencies(file)
        for dep in deps:
            if not visited.contains_key(dep):
                self.find_cycles_dfs(dep, visited, stack, in_stack, cycles)
            else if in_stack.contains_key(dep):
                # Cycle found - extract cycle from stack
                val cycle = self.extract_cycle(stack, dep)
                cycles.append(cycle)

        stack.pop()
        in_stack.remove(file)

    fn extract_cycle(stack: List<text>, start: text): List<text> =
        """Extract cycle from DFS stack.

        Args:
            stack: DFS stack
            start: Start of cycle

        Returns:
            Files in cycle
        """
        val cycle: List<text> = []
        val found_start = false

        # Find start in stack and collect cycle
        for file in stack.iter().rev():
            cycle.insert(0, file)
            if file == start:
                found_start = true
                break

        cycle

    pub fn topological_sort(self): Result<List<text>, text> =
        """Compute topological ordering of files.

        Returns:
            Ok with ordered file list, or Err if cycle detected

        Example:
            match graph.topological_sort():
                Ok(order):
                    print("Build order: {order}")
                Err(msg):
                    print("Error: {msg}")
        """
        # Check for cycles first
        val cycles = self.detect_cycles()
        if cycles.len() > 0:
            return Err("Circular dependencies detected")

        # Kahn's algorithm
        val in_degree: Dict<text, i32> = {}
        val queue: List<text> = []
        val result: List<text> = []

        # Initialize in-degrees
        for (file, _) in self.nodes.items():
            in_degree[file] = 0

        for edge in self.edges:
            in_degree[edge.target] += 1

        # Find nodes with no incoming edges
        for (file, degree) in in_degree.items():
            if degree == 0:
                queue.append(file)

        # Process queue
        while queue.len() > 0:
            val file = queue.remove(0)
            result.append(file)

            val deps = self.get_dependencies(file)
            for dep in deps:
                in_degree[dep] -= 1
                if in_degree[dep] == 0:
                    queue.append(dep)

        Ok(result)

# Dependency node
pub class DependencyNode:
    pub file: text
    pub language: Language
    pub dependencies: List<text>    # Files this file depends on
    pub dependents: List<text>      # Files that depend on this file

    pub fn new(file: text, language: Language): DependencyNode =
        """Create dependency node.

        Args:
            file: File path
            language: Source language

        Returns:
            Dependency node
        """
        DependencyNode {
            file: file,
            language: language,
            dependencies: [],
            dependents: []
        }

    pub fn has_dependencies(self): bool =
        """Check if node has dependencies.

        Returns:
            True if dependencies exist
        """
        self.dependencies.len() > 0

    pub fn has_dependents(self): bool =
        """Check if node has dependents.

        Returns:
            True if dependents exist
        """
        self.dependents.len() > 0

    pub fn dependency_count(self): i32 =
        """Get number of dependencies.

        Returns:
            Dependency count
        """
        self.dependencies.len()

    pub fn dependent_count(self): i32 =
        """Get number of dependents.

        Returns:
            Dependent count
        """
        self.dependents.len()

    pub fn is_root(self): bool =
        """Check if this is a root node (no dependencies).

        Returns:
            True if no dependencies

        Example:
            if node.is_root():
                print("{node.file} is an entry point")
        """
        self.dependencies.len() == 0

    pub fn is_leaf(self): bool =
        """Check if this is a leaf node (no dependents).

        Returns:
            True if no dependents

        Example:
            if node.is_leaf():
                print("{node.file} is a utility module")
        """
        self.dependents.len() == 0

    pub fn summary(self): text =
        """Get node summary.

        Returns:
            Human-readable summary

        Example:
            node.summary()
            # → "app.spl (Simple): 3 dependencies, 0 dependents"
        """
        "{self.file} ({self.language.to_string()}): {self.dependency_count()} dependencies, {self.dependent_count()} dependents"

# Dependency tracker - builds and analyzes dependency graph
pub class DependencyTracker:
    pub root: text
    pub graph: DependencyGraph
    pub verbose: bool

    pub fn new(root: text): DependencyTracker =
        """Create dependency tracker.

        Args:
            root: Project root directory

        Returns:
            Tracker with empty graph

        Example:
            val tracker = DependencyTracker.new(".")
            tracker.analyze_all_languages()

            val deps = tracker.get_dependencies("app.spl")
            print("Dependencies: {deps}")
        """
        DependencyTracker {
            root: root,
            graph: DependencyGraph.new(),
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.verbose = enabled

    pub fn is_verbose(self): bool =
        """Check if verbose logging is enabled.

        Returns:
            True if verbose mode is on
        """
        self.verbose

    pub fn with_verbose(self, enabled: bool): DependencyTracker =
        """Set verbose logging (fluent API).

        Args:
            enabled: Verbose flag

        Returns:
            Self for chaining

        Example:
            val tracker = DependencyTracker.new(".").with_verbose(true)
        """
        self.verbose = enabled
        self

    pub fn has_graph(self): bool =
        """Check if tracker has built dependency graph.

        Returns:
            True if graph has nodes
        """
        self.graph.has_nodes()

    pub fn get_node_count(self): i32 =
        """Get number of nodes in graph.

        Returns:
            Node count
        """
        self.graph.node_count()

    pub fn get_edge_count(self): i32 =
        """Get number of edges in graph.

        Returns:
            Edge count
        """
        self.graph.edge_count()

    pub fn summary(self): text =
        """Get tracker summary.

        Returns:
            Human-readable summary

        Example:
            tracker.summary()
            # → "DependencyTracker: . (50 files, 120 dependencies, verbose: true)"
        """
        val verbose_str = if self.verbose: "true" else: "false"
        "DependencyTracker: {self.root} ({self.get_node_count()} files, {self.get_edge_count()} dependencies, verbose: {verbose_str})"

    pub fn analyze_all_languages(self):
        """Analyze dependencies for all languages in project.

        Builds complete dependency graph by parsing all source files.
        """
        if self.verbose:
            print("Analyzing dependencies...")

        # Find and analyze all source files by language
        val extensions = [
            (".spl", Language::Simple),
            (".rs", Language::Rust),
            (".py", Language::Python),
            (".js", Language::JavaScript),
            (".ts", Language::TypeScript)
        ]

        for (ext, lang) in extensions:
            val files = find_files_with_extension(self.root, ext)
            for file in files:
                self.analyze_file(file, lang)

        if self.verbose:
            print("Found {self.get_node_count()} files with {self.get_edge_count()} dependencies")


fn find_files_with_extension(root: text, ext: text): List<text> =
    """Find all files with given extension recursively.

    Args:
        root: Root directory
        ext: File extension (e.g., ".spl")

    Returns:
        List of file paths
    """
    @extern("runtime", "rt_dir_list")
    fn _rt_dir_list(path_ptr: &u8, path_len: u64) -> Any

    @extern("runtime", "rt_file_stat")
    fn _rt_file_stat(
        path_ptr: &u8,
        path_len: u64,
        out_exists: &mut bool,
        out_is_file: &mut bool,
        out_is_dir: &mut bool,
        out_is_readable: &mut bool,
        out_is_writable: &mut bool,
        out_size: &mut i64
    )

    var results: List<text> = []

    val entries = _rt_dir_list(root.ptr(), root.len())
    if entries.is_nil():
        return results

    # Cast to list of strings
    val entry_list = entries as List<text>
    for entry in entry_list:
        val full_path = root + "/" + entry

        var exists = false
        var is_file = false
        var is_dir = false
        var is_readable = false
        var is_writable = false
        var size: i64 = 0

        _rt_file_stat(
            full_path.ptr(), full_path.len(),
            &mut exists, &mut is_file, &mut is_dir,
            &mut is_readable, &mut is_writable, &mut size
        )

        if is_file and full_path.ends_with(ext):
            results.append(full_path)
        elif is_dir and not entry.starts_with("."):
            # Recurse into subdirectory
            val sub_files = find_files_with_extension(full_path, ext)
            for f in sub_files:
                results.append(f)

    results


fn parse_simple_imports(file_path: text): List<text> =
    """Parse Simple language import statements.

    Args:
        file_path: Path to .spl file

    Returns:
        List of imported module paths
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: import module.path
        if trimmed.starts_with("import "):
            val module = trimmed.substring(7, trimmed.len()).trim()
            # Remove 'as alias' if present
            val as_pos = module.find(" as ")
            val clean_module = if as_pos >= 0:
                module.substring(0, as_pos)
            else:
                module
            imports.append(clean_module)
        # Match: from module import ...
        elif trimmed.starts_with("from "):
            val rest = trimmed.substring(5, trimmed.len()).trim()
            val import_pos = rest.find(" import ")
            if import_pos >= 0:
                val module = rest.substring(0, import_pos).trim()
                imports.append(module)

    imports


fn parse_rust_imports(file_path: text): List<text> =
    """Parse Rust use statements.

    Args:
        file_path: Path to .rs file

    Returns:
        List of imported crate/module paths
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: use crate::path;
        if trimmed.starts_with("use "):
            var path = trimmed.substring(4, trimmed.len()).trim()
            # Remove trailing semicolon
            if path.ends_with(";"):
                path = path.substring(0, path.len() - 1)
            # Remove braces for grouped imports
            val brace_pos = path.find("{")
            if brace_pos >= 0:
                path = path.substring(0, brace_pos)
            imports.append(path)
        # Match: mod module;
        elif trimmed.starts_with("mod ") and trimmed.ends_with(";"):
            val module = trimmed.substring(4, trimmed.len() - 1).trim()
            imports.append(module)

    imports


fn parse_python_imports(file_path: text): List<text> =
    """Parse Python import statements.

    Args:
        file_path: Path to .py file

    Returns:
        List of imported modules
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: import module
        if trimmed.starts_with("import "):
            val rest = trimmed.substring(7, trimmed.len()).trim()
            # Handle "import a, b, c"
            val parts = rest.split(",")
            for part in parts:
                var module = part.trim()
                # Remove "as alias"
                val as_pos = module.find(" as ")
                if as_pos >= 0:
                    module = module.substring(0, as_pos)
                imports.append(module)
        # Match: from module import ...
        elif trimmed.starts_with("from "):
            val rest = trimmed.substring(5, trimmed.len()).trim()
            val import_pos = rest.find(" import ")
            if import_pos >= 0:
                val module = rest.substring(0, import_pos).trim()
                imports.append(module)

    imports


fn parse_js_imports(file_path: text): List<text> =
    """Parse JavaScript/TypeScript import statements.

    Args:
        file_path: Path to .js/.ts file

    Returns:
        List of imported modules
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: import ... from "module"
        if trimmed.starts_with("import "):
            val from_pos = trimmed.find(" from ")
            if from_pos >= 0:
                var module = trimmed.substring(from_pos + 6, trimmed.len()).trim()
                # Remove quotes and semicolon
                module = module.replace("\"", "").replace("'", "").replace(";", "")
                imports.append(module)
        # Match: const x = require("module")
        val require_pos = trimmed.find("require(")
        if require_pos >= 0:
            var start = require_pos + 8
            val close = trimmed.find(")", start)
            if close > start:
                var module = trimmed.substring(start, close).trim()
                module = module.replace("\"", "").replace("'", "")
                imports.append(module)

    imports

    pub fn analyze_file(self, file: text, language: Language):
        """Analyze dependencies for single file.

        Args:
            file: File to analyze
            language: Source language
        """
        # Add node
        self.graph.add_node(file, language)

        # TODO: [stdlib][P2] Parse file and extract dependencies
        # For now, this is a stub
        val deps = self.extract_dependencies(file, language)

        for dep in deps:
            self.graph.add_node(dep, language)
            self.graph.add_edge(file, dep, DependencyType::Import)

    fn extract_dependencies(file: text, language: Language): List<text> =
        """Extract dependencies from source file.

        Args:
            file: File to parse
            language: Source language

        Returns:
            List of dependency files
        """
        # TODO: [stdlib][P2] Use Tree-sitter to parse imports/includes
        []

    pub fn get_dependencies(self, file: text): List<text> =
        """Get dependencies of file.

        Args:
            file: File path

        Returns:
            Direct dependencies
        """
        self.graph.get_dependencies(file)

    pub fn get_reverse_dependencies(self, file: text): List<text> =
        """Get reverse dependencies of file.

        Args:
            file: File path

        Returns:
            Files that depend on this file
        """
        self.graph.get_reverse_dependencies(file)

    pub fn detect_cycles(self): List<List<text>> =
        """Detect circular dependencies.

        Returns:
            List of dependency cycles
        """
        self.graph.detect_cycles()

    pub fn visualize(self): text =
        """Generate DOT graph visualization.

        Returns:
            DOT format graph

        Example:
            val dot = tracker.visualize()
            # Save to file for rendering with Graphviz
        """
        var output = "digraph dependencies {\n"

        for edge in self.graph.edges:
            output += "  \"{edge.source}\" -> \"{edge.target}\";\n"

        output += "}\n"
        output

# Dependency graph statistics
pub class DependencyStatistics:
    pub total_nodes: i32
    pub total_edges: i32
    pub avg_dependencies_per_node: f64
    pub max_dependencies: i32
    pub most_dependent_file: text

    pub fn new(): DependencyStatistics =
        """Create dependency statistics."""
        DependencyStatistics {
            total_nodes: 0,
            total_edges: 0,
            avg_dependencies_per_node: 0.0,
            max_dependencies: 0,
            most_dependent_file: ""
        }

    pub fn summary(self): text =
        """Get statistics summary.

        Returns:
            Human-readable summary

        Example:
            print(stats.summary())
            # → "50 files, 120 dependencies, avg 2.4 deps/file"
        """
        "{self.total_nodes} files, {self.total_edges} dependencies, avg {self.avg_dependencies_per_node:.1f} deps/file"

    pub fn has_data(self): bool =
        """Check if statistics have data.

        Returns:
            True if nodes exist
        """
        self.total_nodes > 0

    pub fn is_complex(self): bool =
        """Check if dependency graph is complex.

        Returns:
            True if avg dependencies per node > 3.0

        Example:
            if stats.is_complex():
                print("Warning: complex dependency structure")
        """
        self.avg_dependencies_per_node > 3.0

    pub fn has_hotspots(self): bool =
        """Check if there are dependency hotspots.

        Returns:
            True if max dependencies > 10
        """
        self.max_dependencies > 10
