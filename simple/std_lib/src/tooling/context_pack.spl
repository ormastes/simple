# Context Pack Generator for LLM Integration
# Migrated from: src/compiler/src/context_pack.rs
# Purpose: Generate minimal context for LLM tools by extracting only used symbols

# TODO: [compiler][P1] Add BTreeMap/BTreeSet to stdlib
# Using List instead of BTreeMap/BTreeSet for now

# TODO: [compiler][P1] Add JSON serialization to stdlib
# Stubbed for Phase 2

# Function parameter signature
struct FunctionParam:
    name: text
    type_name: Option<text>

# Function signature from API surface
struct FunctionSignature:
    name: text
    params: List<FunctionParam>
    return_type: Option<text>
    is_async: bool
    is_public: bool

# Symbol usage information
struct SymbolUsage:
    used_functions: List<text>
    used_types: List<text>
    required_imports: List<text>

# A minimal context pack for LLM consumption
struct ContextPack:
    target: text                                    # Target module/function being analyzed
    functions: List<(text, FunctionSignature)>      # Functions used by the target (BTreeMap replacement)
    types: List<text>                               # Types used by the target (BTreeSet replacement)
    imports: List<text>                             # Imports required (BTreeSet replacement)
    symbol_count: u64                               # Total symbols in context

impl ContextPack:
    # Create a new empty context pack
    static fn new(target: text) -> ContextPack:
        ContextPack(
            target: target,
            functions: [],
            types: [],
            imports: [],
            symbol_count: 0
        )

    # TODO: [compiler][P1] Integrate with Parser and ApiSurface
    # Extract context from a module, focusing on symbols used by target
    # This requires:
    # - Parser integration (parse Simple code into AST)
    # - ApiSurface analyzer (extract all symbols from module)
    # - SymbolUsageAnalyzer (find which symbols are used by target)
    static fn from_target(target: text, nodes_stub: text, all_symbols_stub: text) -> ContextPack:
        # Stub: Will be implemented when Parser/ApiSurface are available in Simple
        ContextPack.new(target)

    # TODO: [compiler][P1] Implement minimal mode extraction
    # Extract context with minimal mode (only directly used symbols, no transitive deps)
    static fn from_target_minimal(target: text, nodes_stub: text, all_symbols_stub: text) -> ContextPack:
        # Stub: Will be implemented when Parser/ApiSurface are available
        ContextPack.new(target)

    # TODO: [stdlib][P1] Add JSON serialization library
    # Export as JSON (for LLM API consumption)
    fn to_json() -> Result<text, text>:
        # Stub: Needs serde/JSON library
        Err("JSON serialization not yet implemented")

    # Export as compact JSON (single line)
    fn to_json_compact() -> Result<text, text>:
        # Stub: Needs serde/JSON library
        Err("JSON serialization not yet implemented")

    # Export as Markdown (human-readable documentation)
    fn to_markdown() -> text:
        var md = ""

        md = md + "# Context Pack: {self.target}\n\n"
        md = md + "**Symbols:** {self.symbol_count}\n\n"

        # Types section
        if not self.types.is_empty():
            md = md + "## Types Used\n\n"
            var i = 0
            while i < self.types.len():
                val ty = self.types[i]
                md = md + "- `{ty}`\n"
                i = i + 1
            md = md + "\n"

        # Functions section
        if not self.functions.is_empty():
            md = md + "## Functions\n\n"
            var i = 0
            while i < self.functions.len():
                val (name, sig) = self.functions[i]
                md = md + "### `{name}`\n\n"

                # Parameters
                if not sig.params.is_empty():
                    md = md + "**Parameters:**\n"
                    var j = 0
                    while j < sig.params.len():
                        val param = sig.params[j]
                        val type_str = match param.type_name:
                            Some(t): t
                            None: "any"
                        md = md + "- `{param.name}`: {type_str}\n"
                        j = j + 1
                    md = md + "\n"

                # Return type
                match sig.return_type:
                    Some(ret):
                        md = md + "**Returns:** `{ret}`\n\n"
                    None:
                        pass

                # Async marker
                if sig.is_async:
                    md = md + "*Async function*\n\n"

                i = i + 1

        # Imports section
        if not self.imports.is_empty():
            md = md + "## Required Imports\n\n"
            md = md + "```simple\n"
            var i = 0
            while i < self.imports.len():
                val import_path = self.imports[i]
                md = md + "use {import_path}\n"
                i = i + 1
            md = md + "```\n\n"

        md = md + "---\n"
        md = md + "*Generated by Simple Context Pack Generator*\n"

        md

    # Export as plain text (for LLM prompts)
    fn to_text() -> text:
        var text = ""

        text = text + "Context for: {self.target}\n"
        text = text + "Symbols: {self.symbol_count}\n\n"

        # Types section
        if not self.types.is_empty():
            text = text + "Types:\n"
            var i = 0
            while i < self.types.len():
                val ty = self.types[i]
                text = text + "  {ty}\n"
                i = i + 1
            text = text + "\n"

        # Functions section
        if not self.functions.is_empty():
            text = text + "Functions:\n"
            var i = 0
            while i < self.functions.len():
                val (name, sig) = self.functions[i]

                # Build parameters string
                var params_str = ""
                var j = 0
                while j < sig.params.len():
                    val param = sig.params[j]
                    val type_str = match param.type_name:
                        Some(t): t
                        None: "any"
                    if j > 0:
                        params_str = params_str + ", "
                    params_str = params_str + "{param.name}: {type_str}"
                    j = j + 1

                # Return type
                val ret = match sig.return_type:
                    Some(t): t
                    None: "void"

                text = text + "  {name} ({params_str}) -> {ret}\n"
                i = i + 1

        text

    # Calculate token reduction estimate
    # Returns percentage of tokens saved (0-100)
    fn token_savings(full_context_symbols: u64) -> f64:
        if full_context_symbols == 0:
            return 0.0

        val reduction = if full_context_symbols >= self.symbol_count:
            (full_context_symbols - self.symbol_count) as f64
        else:
            0.0

        (reduction / (full_context_symbols as f64)) * 100.0

# Statistics about context generation
struct ContextStats:
    full_symbol_count: u64
    extracted_symbol_count: u64
    reduction_percentage: f64
    estimated_tokens_saved: u64

impl ContextStats:
    # Create stats from full and extracted symbol counts
    static fn new(full: u64, extracted: u64) -> ContextStats:
        val reduction = if full > 0:
            (((full - extracted) as f64) / (full as f64)) * 100.0
        else:
            0.0

        # Rough estimate: ~3 tokens per symbol
        val tokens_saved = (full - extracted) * 3

        ContextStats(
            full_symbol_count: full,
            extracted_symbol_count: extracted,
            reduction_percentage: reduction,
            estimated_tokens_saved: tokens_saved
        )

# Helper: Check if a list contains a text value
fn list_contains(list: List<text>, value: text) -> bool:
    var i = 0
    while i < list.len():
        if list[i] == value:
            return true
        i = i + 1
    false

# Helper: Add unique element to list (set behavior)
fn add_unique(list: List<text>, value: text) -> List<text>:
    if list_contains(list, value):
        list
    else:
        var new_list = list.clone()
        new_list.append(value)
        new_list
