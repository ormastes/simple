# Test Output Formatting and Documentation Generation
#
# This module handles:
# - Text/JSON/Doc format output for test results
# - HTML documentation generation
# - Markdown documentation generation
#
# Migrated from Rust src/driver/src/cli/test_output.rs

use core.*

# =========================================================================
# ANSI Color Constants
# =========================================================================

val ANSI_RESET: text = "\x1b[0m"
val ANSI_GREEN: text = "\x1b[32m"
val ANSI_RED: text = "\x1b[31m"

# =========================================================================
# Data Structures
# =========================================================================

# Output format options
enum OutputFormat:
    Text
    Json
    Doc

# Result for a single test file
class TestFileResult:
    path: text
    passed: i32
    failed: i32
    duration_ms: i64
    error: Option<text>

    static fn new(path: text, passed: i32, failed: i32, duration_ms: i64, error: Option<text>) -> TestFileResult:
        return TestFileResult {
            path: path,
            passed: passed,
            failed: failed,
            duration_ms: duration_ms,
            error: error
        }

    fn has_failure() -> bool:
        return self.failed > 0 or self.error.is_some()

# Aggregate test run result
class TestRunResult:
    files: List<TestFileResult>
    total_passed: i32
    total_failed: i32
    total_duration_ms: i64

    static fn new() -> TestRunResult:
        return TestRunResult {
            files: [],
            total_passed: 0,
            total_failed: 0,
            total_duration_ms: 0
        }

    fn add_file(file: TestFileResult) -> TestRunResult:
        var new_files = self.files
        new_files.append(file)
        return TestRunResult {
            files: new_files,
            total_passed: self.total_passed + file.passed,
            total_failed: self.total_failed + file.failed,
            total_duration_ms: self.total_duration_ms + file.duration_ms
        }

    fn success() -> bool:
        return self.total_failed == 0

# =========================================================================
# Main Output Functions
# =========================================================================

# Print test summary (dispatches to format-specific output)
fn print_summary(result: TestRunResult, format: OutputFormat):
    match format:
        OutputFormat::Text => print_summary_text(result)
        OutputFormat::Json => print_summary_json(result)
        OutputFormat::Doc => print_summary_doc(result)

# =========================================================================
# Text Format Output
# =========================================================================

fn print_summary_text(result: TestRunResult):
    print ""
    print "═══════════════════════════════════════════════════════════════"
    print "Test Summary"
    print "═══════════════════════════════════════════════════════════════"
    print "Files: {result.files.len()}"

    if result.total_failed > 0:
        print "{ANSI_GREEN}Passed: {result.total_passed}{ANSI_RESET}"
        print "{ANSI_RED}Failed: {result.total_failed}{ANSI_RESET}"
    else:
        print "{ANSI_GREEN}Passed: {result.total_passed}{ANSI_RESET}"
        print "Failed: 0"

    print "Duration: {result.total_duration_ms}ms"
    print ""

    if result.success():
        print "{ANSI_GREEN}✓ All tests passed!{ANSI_RESET}"
    else:
        print "{ANSI_RED}✗ Some tests failed{ANSI_RESET}"
        print ""
        print "Failed files:"
        for file in result.files:
            if file.has_failure():
                print "  - {file.path}"

# =========================================================================
# JSON Format Output
# =========================================================================

fn print_summary_json(result: TestRunResult):
    # Build JSON manually without serde dependency
    print "{"
    print "  \"success\": {result.success()},"
    print "  \"total_passed\": {result.total_passed},"
    print "  \"total_failed\": {result.total_failed},"
    print "  \"total_duration_ms\": {result.total_duration_ms},"
    print "  \"files\": ["

    val file_count = result.files.len()
    for i in 0..file_count:
        val file = result.files[i]
        val comma = if i < file_count - 1: "," else: ""
        val error_str = match file.error:
            Some(e) => "\"{json_escape(e)}\""
            None => "null"

        print "    {"
        print "      \"path\": \"{json_escape(file.path)}\","
        print "      \"passed\": {file.passed},"
        print "      \"failed\": {file.failed},"
        print "      \"duration_ms\": {file.duration_ms},"
        print "      \"error\": {error_str}"
        print "    }{comma}"

    print "  ]"
    print "}"

# =========================================================================
# Doc Format Output (RSpec-style)
# =========================================================================

fn print_summary_doc(result: TestRunResult):
    print ""

    # Group by directory structure
    var current_dir = ""

    for file in result.files:
        # Get directory path
        val parts = file.path.split("/")

        # Find the directory (everything except the file name)
        val dir = if parts.len() > 1:
            parts.slice(0, parts.len() - 1).join("/")
        else:
            ""

        # Print directory header if changed
        if dir != current_dir:
            if current_dir.len() > 0:
                print ""
            print dir
            current_dir = dir

        # Get file name
        val file_name = parts[parts.len() - 1]

        # Status indicator
        val status = if file.has_failure():
            "{ANSI_RED}✗{ANSI_RESET}"
        else:
            "{ANSI_GREEN}✓{ANSI_RESET}"

        # Print file with indentation
        print "  {status} {file_name} ({file.duration_ms}ms)"

        # Print error if any
        match file.error:
            Some(err) =>
                val lines = err.split("\n")
                for line in lines.slice(0, 3):
                    print "      {ANSI_RED}{line}{ANSI_RESET}"
            None =>
                pass

    print ""
    print "─────────────────────────────────────────────────────────────────"

    # Summary line
    if result.success():
        print "{ANSI_GREEN}{result.total_passed} examples, 0 failures{ANSI_RESET} ({result.total_duration_ms}ms)"
    else:
        val total = result.total_passed + result.total_failed
        print "{total} examples, {ANSI_RED}{result.total_failed} failures{ANSI_RESET} ({result.total_duration_ms}ms)"

# =========================================================================
# Documentation Generation
# =========================================================================

# Generate HTML and Markdown documentation from test results
fn generate_documentation(result: TestRunResult, docs_dir: text) -> Result<text, text>:
    # Create docs directory
    create_dir(docs_dir)?

    # Generate HTML and Markdown
    generate_html_doc(docs_dir, result)?
    generate_markdown_doc(docs_dir, result)?

    return Ok("Documentation generated in {docs_dir}/")

# Generate HTML documentation file
fn generate_html_doc(docs_dir: text, result: TestRunResult) -> Result<text, text>:
    val timestamp = current_timestamp()
    var html = HTML_HEADER.replace("{{TIMESTAMP}}", timestamp)

    # Add test files
    for file in result.files:
        val status_class = if file.has_failure(): "failure" else: "success"
        val icon = if file.has_failure(): "❌" else: "✅"

        html = html + "        <div class=\"test-file {status_class}\">\n"
        html = html + "            <div class=\"test-title\">\n"
        html = html + "                <span class=\"status-icon\">{icon}</span>\n"
        html = html + "                {file.path} ({file.duration_ms}ms)\n"
        html = html + "            </div>\n"

        match file.error:
            Some(err) =>
                html = html + "            <div class=\"error\">{html_escape(err)}</div>\n"
            None =>
                pass

        html = html + "        </div>\n"

    # Add summary
    html = html + "        <div class=\"summary\">\n"
    html = html + "            <h2>Summary</h2>\n"
    html = html + "            <div class=\"summary-stats\">\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Total</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.files.len()}</div>\n"
    html = html + "                </div>\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Passed ✅</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.total_passed}</div>\n"
    html = html + "                </div>\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Failed ❌</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.total_failed}</div>\n"
    html = html + "                </div>\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Duration</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.total_duration_ms}ms</div>\n"
    html = html + "                </div>\n"
    html = html + "            </div>\n"
    html = html + "        </div>\n"
    html = html + "    </div>\n"
    html = html + "</body>\n"
    html = html + "</html>"

    val html_path = "{docs_dir}/test-spec.html"
    write_file(html_path, html)?
    return Ok(html_path)

# Generate Markdown documentation file
fn generate_markdown_doc(docs_dir: text, result: TestRunResult) -> Result<text, text>:
    val timestamp = current_timestamp()
    var md = "# Test Specification\n\n*Generated: {timestamp}*\n\n"

    # Add test files grouped by directory
    var current_dir = ""

    for file in result.files:
        val parts = file.path.split("/")
        val dir = if parts.len() > 1:
            parts.slice(0, parts.len() - 1).join("/")
        else:
            ""

        if dir != current_dir:
            if current_dir.len() > 0:
                md = md + "\n"
            md = md + "## {dir}\n\n"
            current_dir = dir

        val icon = if file.has_failure(): "❌" else: "✅"
        val file_name = parts[parts.len() - 1]

        md = md + "{icon} **{file_name}** ({file.duration_ms}ms)\n"

        match file.error:
            Some(err) =>
                md = md + "\n```\nError: {err}\n```\n"
            None =>
                pass

        md = md + "\n"

    # Add summary
    md = md + "\n---\n\n## Summary\n\n"
    md = md + "- **Total:** {result.files.len()} tests\n"
    md = md + "- **Passed:** {result.total_passed} ✅\n"
    md = md + "- **Failed:** {result.total_failed} ❌\n"
    md = md + "- **Duration:** {result.total_duration_ms}ms\n"

    val md_path = "{docs_dir}/test-spec.md"
    write_file(md_path, md)?
    return Ok(md_path)

# =========================================================================
# Helper Functions
# =========================================================================

# HTML escape helper
fn html_escape(s: text) -> text:
    return s.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#39;")

# JSON escape helper
fn json_escape(s: text) -> text:
    return s.replace("\\", "\\\\")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t")

# =========================================================================
# FFI Functions
# =========================================================================

# Get current timestamp as formatted string
fn current_timestamp() -> text:
    @extern("runtime", "rt_current_timestamp")
    fn _rt_current_timestamp() -> text
    return _rt_current_timestamp()

# Create directory
fn create_dir(path: text) -> Result<text, text>:
    @extern("runtime", "rt_create_dir")
    fn _rt_create_dir(path_ptr: &u8, path_len: u64) -> i32

    val result = _rt_create_dir(path.ptr(), path.len())
    if result == 0:
        return Ok(path)
    else:
        return Err("Failed to create directory: {path}")

# Write file contents
fn write_file(path: text, content: text) -> Result<text, text>:
    @extern("runtime", "rt_file_write_text")
    fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> i32

    val result = _rt_file_write_text(path.ptr(), path.len(), content.ptr(), content.len())
    if result == 0:
        return Ok(path)
    else:
        return Err("Failed to write file: {path}")

# =========================================================================
# HTML Template (separated for readability)
# =========================================================================

val HTML_HEADER: text = r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Specification - Simple Language</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 40px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; margin-bottom: 10px; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        .timestamp { color: #7f8c8d; font-size: 0.9em; margin-bottom: 30px; }
        .test-file { margin: 20px 0; padding: 15px; background: #f8f9fa; border-left: 3px solid #95a5a6; }
        .test-file.success { background: #d5f4e6; border-left-color: #27ae60; }
        .test-file.failure { background: #fadbd8; border-left-color: #e74c3c; }
        .test-title { font-size: 1.1em; margin-bottom: 8px; display: flex; align-items: center; }
        .status-icon { margin-right: 8px; font-size: 1.2em; }
        .error { margin-top: 10px; padding: 10px; background: #fbe9e7; border-left: 3px solid #e74c3c; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; }
        .summary { margin-top: 40px; padding: 20px; background: #ecf0f1; border-radius: 4px; }
        .summary h2 { color: #2c3e50; margin-bottom: 15px; }
        .summary-stats { display: flex; gap: 20px; flex-wrap: wrap; }
        .stat { padding: 10px 20px; background: white; border-radius: 4px; border-left: 3px solid #3498db; }
        .stat-label { font-weight: bold; color: #7f8c8d; font-size: 0.9em; }
        .stat-value { font-size: 1.5em; color: #2c3e50; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Test Specification</h1>
        <div class="timestamp">Generated: {{TIMESTAMP}}</div>
"#

# =========================================================================
# Exports
# =========================================================================

export OutputFormat, TestFileResult, TestRunResult
export print_summary, print_summary_text, print_summary_json, print_summary_doc
export generate_documentation, generate_html_doc, generate_markdown_doc
export html_escape, json_escape
