# URL/URI utilities
# Parse, encode, and manipulate URLs without regex

use super.string_utils.{split, trim, starts_with, ends_with}

# =====================================
# URL Components
# =====================================

# Represents a parsed URL
struct Url:
    scheme: text         # http, https, ftp, etc.
    username: text       # optional username
    password: text       # optional password
    host: text           # hostname or IP
    port: Option<i32>    # optional port number
    path: text           # /path/to/resource
    query: text          # ?key=value&foo=bar
    fragment: text       # #section

# =====================================
# URL Encoding/Decoding
# =====================================

# URL encode a string (percent encoding)
fn url_encode(input: text) -> text:
    var result = ""

    for ch in input.chars():
        if is_unreserved(ch):
            result = result + ch
        else:
            # Encode as %XX
            val code = char_code(ch)
            result = result + "%" + to_hex(code)

    result

# URL decode a percent-encoded string
fn url_decode(input: text) -> text:
    var result = ""
    var i = 0
    val chars = input.chars()

    while i < chars.len():
        val ch = chars[i]

        if ch == "%":
            # Decode %XX
            if i + 2 < chars.len():
                val hex = chars[i + 1] + chars[i + 2]
                match from_hex(hex):
                    Some(code) =>
                        result = result + from_char_code(code)
                        i = i + 3
                        continue
                    None =>
                        result = result + ch
        elif ch == "+":
            result = result + " "
        else:
            result = result + ch

        i = i + 1

    result

# Check if character is unreserved (doesn't need encoding)
fn is_unreserved(ch: text) -> bool:
    val c = ch.chars()[0] if ch.len() > 0 else: ""

    # A-Z, a-z, 0-9, -, ., _, ~
    (c >= "A" and c <= "Z") or
    (c >= "a" and c <= "z") or
    (c >= "0" and c <= "9") or
    c == "-" or c == "." or c == "_" or c == "~"

# =====================================
# Character Code Conversion
# =====================================

# Get character code (simplified for common ASCII)
fn char_code(ch: text) -> i32:
    match ch:
        "A" => 65, "B" => 66, "C" => 67, "D" => 68, "E" => 69,
        "F" => 70, "G" => 71, "H" => 72, "I" => 73, "J" => 74,
        "K" => 75, "L" => 76, "M" => 77, "N" => 78, "O" => 79,
        "P" => 80, "Q" => 81, "R" => 82, "S" => 83, "T" => 84,
        "U" => 85, "V" => 86, "W" => 87, "X" => 88, "Y" => 89, "Z" => 90,
        "a" => 97, "b" => 98, "c" => 99, "d" => 100, "e" => 101,
        "f" => 102, "g" => 103, "h" => 104, "i" => 105, "j" => 106,
        "k" => 107, "l" => 108, "m" => 109, "n" => 110, "o" => 111,
        "p" => 112, "q" => 113, "r" => 114, "s" => 115, "t" => 116,
        "u" => 117, "v" => 118, "w" => 119, "x" => 120, "y" => 121, "z" => 122,
        "0" => 48, "1" => 49, "2" => 50, "3" => 51, "4" => 52,
        "5" => 53, "6" => 54, "7" => 55, "8" => 56, "9" => 57,
        " " => 32, "!" => 33, "\"" => 34, "#" => 35, "$" => 36,
        "%" => 37, "&" => 38, "'" => 39, "(" => 40, ")" => 41,
        "*" => 42, "+" => 43, "," => 44, "-" => 45, "." => 46,
        "/" => 47, ":" => 58, ";" => 59, "<" => 60, "=" => 61,
        ">" => 62, "?" => 63, "@" => 64, "[" => 91, "\\" => 92,
        "]" => 93, "^" => 94, "_" => 95, "`" => 96, "{" => 123,
        "|" => 124, "}" => 125, "~" => 126,
        _ => 32

# Character from code
fn from_char_code(code: i32) -> text:
    match code:
        65 => "A", 66 => "B", 67 => "C", 68 => "D", 69 => "E",
        70 => "F", 71 => "G", 72 => "H", 73 => "I", 74 => "J",
        75 => "K", 76 => "L", 77 => "M", 78 => "N", 79 => "O",
        80 => "P", 81 => "Q", 82 => "R", 83 => "S", 84 => "T",
        85 => "U", 86 => "V", 87 => "W", 88 => "X", 89 => "Y", 90 => "Z",
        97 => "a", 98 => "b", 99 => "c", 100 => "d", 101 => "e",
        102 => "f", 103 => "g", 104 => "h", 105 => "i", 106 => "j",
        107 => "k", 108 => "l", 109 => "m", 110 => "n", 111 => "o",
        112 => "p", 113 => "q", 114 => "r", 115 => "s", 116 => "t",
        117 => "u", 118 => "v", 119 => "w", 120 => "x", 121 => "y", 122 => "z",
        48 => "0", 49 => "1", 50 => "2", 51 => "3", 52 => "4",
        53 => "5", 54 => "6", 55 => "7", 56 => "8", 57 => "9",
        32 => " ", 33 => "!", 34 => "\"", 35 => "#", 36 => "$",
        37 => "%", 38 => "&", 39 => "'", 40 => "(", 41 => ")",
        42 => "*", 43 => "+", 44 => ",", 45 => "-", 46 => ".",
        47 => "/", 58 => ":", 59 => ";", 60 => "<", 61 => "=",
        62 => ">", 63 => "?", 64 => "@", 91 => "[", 92 => "\\",
        93 => "]", 94 => "^", 95 => "_", 96 => "`", 123 => "{",
        124 => "|", 125 => "}", 126 => "~",
        _ => "?"

# Convert to hex string (2 digits)
fn to_hex(n: i32) -> text:
    val high = (n >> 4) & 0xF
    val low = n & 0xF

    hex_digit(high) + hex_digit(low)

# Convert hex digit to character
fn hex_digit(n: i32) -> text:
    match n:
        0 => "0", 1 => "1", 2 => "2", 3 => "3", 4 => "4",
        5 => "5", 6 => "6", 7 => "7", 8 => "8", 9 => "9",
        10 => "A", 11 => "B", 12 => "C", 13 => "D", 14 => "E", 15 => "F",
        _ => "0"

# Parse hex string to integer
fn from_hex(hex: text) -> Option<i32>:
    if hex.len() != 2:
        return None

    val chars = hex.chars()
    match hex_digit_value(chars[0]):
        None => None
        Some(high) =>
            match hex_digit_value(chars[1]):
                None => None
                Some(low) => Some((high << 4) | low)

# Get value of hex digit
fn hex_digit_value(ch: text) -> Option<i32>:
    match ch:
        "0" => Some(0), "1" => Some(1), "2" => Some(2), "3" => Some(3), "4" => Some(4),
        "5" => Some(5), "6" => Some(6), "7" => Some(7), "8" => Some(8), "9" => Some(9),
        "A" => Some(10), "B" => Some(11), "C" => Some(12), "D" => Some(13), "E" => Some(14), "F" => Some(15),
        "a" => Some(10), "b" => Some(11), "c" => Some(12), "d" => Some(13), "e" => Some(14), "f" => Some(15),
        _ => None

# =====================================
# URL Parsing (Simplified)
# =====================================

# Parse URL string into components
fn parse_url(url: text) -> Option<Url>:
    var remaining = url

    # Extract scheme
    val scheme_end = remaining.find(":")
    if scheme_end < 0:
        return None

    val scheme = remaining.substring(0, scheme_end)
    remaining = remaining.substring(scheme_end + 1, remaining.len())

    # Skip //
    if remaining.starts_with("//"):
        remaining = remaining.substring(2, remaining.len())

    # Extract fragment first (if any)
    var fragment = ""
    val fragment_pos = remaining.find("#")
    if fragment_pos >= 0:
        fragment = remaining.substring(fragment_pos + 1, remaining.len())
        remaining = remaining.substring(0, fragment_pos)

    # Extract query string (if any)
    var query = ""
    val query_pos = remaining.find("?")
    if query_pos >= 0:
        query = remaining.substring(query_pos + 1, remaining.len())
        remaining = remaining.substring(0, query_pos)

    # Extract path (if any)
    var path = "/"
    var host_part = remaining
    val path_pos = remaining.find("/")
    if path_pos >= 0:
        path = remaining.substring(path_pos, remaining.len())
        host_part = remaining.substring(0, path_pos)

    # Parse authority (user:pass@host:port)
    var username = ""
    var password = ""
    var host = host_part
    var port: Option<i32> = None

    # Extract user info (if any)
    val at_pos = host_part.find("@")
    if at_pos >= 0:
        val user_info = host_part.substring(0, at_pos)
        host = host_part.substring(at_pos + 1, host_part.len())

        val colon_pos = user_info.find(":")
        if colon_pos >= 0:
            username = user_info.substring(0, colon_pos)
            password = user_info.substring(colon_pos + 1, user_info.len())
        else:
            username = user_info

    # Extract port (if any)
    val port_pos = host.find(":")
    if port_pos >= 0:
        val port_str = host.substring(port_pos + 1, host.len())
        host = host.substring(0, port_pos)

        match parse_int(port_str):
            Some(p) => port = Some(p)
            None => {}

    Some(Url(
        scheme: scheme,
        username: username,
        password: password,
        host: host,
        port: port,
        path: path,
        query: query,
        fragment: fragment
    ))

# Simple integer parsing
fn parse_int(s: text) -> Option<i32>:
    if s.is_empty():
        return None

    var result = 0
    for ch in s.chars():
        match ch:
            "0" => result = result * 10 + 0
            "1" => result = result * 10 + 1
            "2" => result = result * 10 + 2
            "3" => result = result * 10 + 3
            "4" => result = result * 10 + 4
            "5" => result = result * 10 + 5
            "6" => result = result * 10 + 6
            "7" => result = result * 10 + 7
            "8" => result = result * 10 + 8
            "9" => result = result * 10 + 9
            _ => return None

    Some(result)

# =====================================
# URL Building
# =====================================

# Build URL from components
fn build_url(url: Url) -> text:
    var result = url.scheme + "://"

    # Add user info if present
    if not url.username.is_empty():
        result = result + url.username
        if not url.password.is_empty():
            result = result + ":" + url.password
        result = result + "@"

    # Add host
    result = result + url.host

    # Add port if present and not default
    match url.port:
        Some(p) =>
            if not is_default_port(url.scheme, p):
                result = result + ":" + p.to_string()
        None => {}

    # Add path
    result = result + url.path

    # Add query
    if not url.query.is_empty():
        result = result + "?" + url.query

    # Add fragment
    if not url.fragment.is_empty():
        result = result + "#" + url.fragment

    result

# Check if port is default for scheme
fn is_default_port(scheme: text, port: i32) -> bool:
    match scheme:
        "http" => port == 80
        "https" => port == 443
        "ftp" => port == 21
        _ => false

# =====================================
# Query String Utilities
# =====================================

# Parse query string into key-value pairs
fn parse_query_string(query: text) -> List<(text, text)>:
    var params = []

    if query.is_empty():
        return params

    val pairs = split(query, "&")
    for pair in pairs:
        val eq_pos = pair.find("=")
        if eq_pos >= 0:
            val key = pair.substring(0, eq_pos)
            val value = pair.substring(eq_pos + 1, pair.len())
            params.push((url_decode(key), url_decode(value)))
        else:
            params.push((url_decode(pair), ""))

    params

# Build query string from key-value pairs
fn build_query_string(params: List<(text, text)>) -> text:
    var parts = []

    for (key, value) in params:
        if value.is_empty():
            parts.push(url_encode(key))
        else:
            parts.push(url_encode(key) + "=" + url_encode(value))

    parts.join("&")

# Add parameter to query string
fn add_query_param(query: text, key: text, value: text) -> text:
    val encoded = url_encode(key) + "=" + url_encode(value)

    if query.is_empty():
        encoded
    else:
        query + "&" + encoded

# =====================================
# URL Validation
# =====================================

# Check if string looks like a valid URL
fn is_valid_url(url: text) -> bool:
    # Must have scheme separator
    if not url.contains("://"):
        return false

    # Must have host after ://
    val scheme_end = url.find("://")
    if scheme_end < 0:
        return false

    val after_scheme = url.substring(scheme_end + 3, url.len())
    if after_scheme.is_empty():
        return false

    true

# Check if URL is absolute (has scheme)
fn is_absolute_url(url: text) -> bool:
    url.contains("://")

# Check if URL is relative
fn is_relative_url(url: text) -> bool:
    not is_absolute_url(url)

# =====================================
# Common URL Operations
# =====================================

# Get base URL (scheme + host + port)
fn get_base_url(url: Url) -> text:
    var result = url.scheme + "://" + url.host

    match url.port:
        Some(p) =>
            if not is_default_port(url.scheme, p):
                result = result + ":" + p.to_string()
        None => {}

    result

# Get full path with query and fragment
fn get_full_path(url: Url) -> text:
    var result = url.path

    if not url.query.is_empty():
        result = result + "?" + url.query

    if not url.fragment.is_empty():
        result = result + "#" + url.fragment

    result

# Join base URL with relative path
fn join_url(base: text, relative: text) -> text:
    if is_absolute_url(relative):
        return relative

    var result = base
    if result.ends_with("/") and relative.starts_with("/"):
        result = result.substring(0, result.len() - 1)
    elif not result.ends_with("/") and not relative.starts_with("/"):
        result = result + "/"

    result + relative
