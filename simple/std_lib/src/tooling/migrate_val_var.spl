# Simple Language Syntax Migration Tool - val/var syntax
# Migrated from: scripts/migrate_syntax.py
# Purpose: Migrate from explicit self syntax to Scala-style val/var syntax

# TODO: [stdlib][P1] Add regex library to Simple

import fs.{read_text, write_text, glob, create_dir, basename, join}

use super.time_utils.{migration_backup_dir}

# Migration statistics (reusing from migrate_me_syntax)
struct ValVarMigrationStats:
    files_processed: u64
    files_modified: u64
    lines_changed: u64
    backup_dir: text

impl ValVarMigrationStats:
    # Create empty stats
    static fn new(backup_dir: text) -> ValVarMigrationStats:
        ValVarMigrationStats(
            files_processed: 0,
            files_modified: 0,
            lines_changed: 0,
            backup_dir: backup_dir
        )

    # Record processed file
    me add_processed():
        self.files_processed = self.files_processed + 1

    # Record modified file
    me add_modified(lines: u64):
        self.files_modified = self.files_modified + 1
        self.lines_changed = self.lines_changed + lines

    # Generate summary report
    fn summary() -> text:
        var report = ""
        report = report + "=== Migration Complete ===\n"
        report = report + "Files processed: {self.files_processed}\n"
        report = report + "Files modified: {self.files_modified}\n"
        report = report + "Lines changed: {self.lines_changed}\n"
        report = report + "Backups saved to: {self.backup_dir}\n"
        report

# TODO: [stdlib][P1] Add regex support
# Apply val/var syntax transformations
fn migrate_val_var_content(content: text) -> text:
    # Stub: Needs regex for pattern replacements
    # Transformations in order (ORDER MATTERS!):
    # 1. let mut -> var (MUST come before let -> val)
    # 2. let -> val
    # 3. fn method(mut self) -> var fn method()
    # 4. fn method(self) -> fn method()
    # 5. Add static to constructors (heuristics)

    # Regex patterns needed:
    # - r'\blet\s+mut\b' -> 'var'
    # - r'\blet\b' -> 'val'
    # - r'^(\s*)fn\s+(\w+)\s*\(\s*mut\s+self\s*\)(\s*(?:->)?)' -> r'\1var fn \2()\3'
    # - r'^(\s*)fn\s+(\w+)\s*\(\s*mut\s+self\s*,\s*' -> r'\1var fn \2('
    # - r'^(\s*)fn\s+(\w+)\s*\(\s*self\s*\)(\s*(?:->)?)' -> r'\1fn \2()\3'
    # - r'^(\s*)fn\s+(\w+)\s*\(\s*self\s*,\s*' -> r'\1fn \2('
    # - Constructor patterns (new, default, from_*, etc.)

    content  # Return unchanged for now

# Transformation patterns for val/var migration
struct ValVarPattern:
    order: u64
    name: text
    description: text
    before: text
    after: text
    notes: text

impl ValVarPattern:
    # Create a transformation pattern
    static fn new(order: u64, name: text, desc: text, before: text, after: text, notes: text) -> ValVarPattern:
        ValVarPattern(
            order: order,
            name: name,
            description: desc,
            before: before,
            after: after,
            notes: notes
        )

# Get all val/var transformation patterns
fn get_val_var_patterns() -> List<ValVarPattern>:
    [
        ValVarPattern.new(
            1,
            "let_mut_to_var",
            "Convert let mut to var",
            "let mut x = 42",
            "var x = 42",
            "Must run before let->val conversion"
        ),
        ValVarPattern.new(
            2,
            "let_to_val",
            "Convert let to val",
            "let x = 42",
            "val x = 42",
            "Immutable by default"
        ),
        ValVarPattern.new(
            3,
            "mut_self_to_var_fn",
            "Convert fn(mut self) to var fn()",
            "fn update(mut self, x: i64) ->",
            "var fn update(x: i64) ->",
            "Remove mut self parameter"
        ),
        ValVarPattern.new(
            4,
            "self_to_fn",
            "Remove self from fn(self)",
            "fn get_value(self) -> i64",
            "fn get_value() -> i64",
            "Implicit self in methods"
        ),
        ValVarPattern.new(
            5,
            "constructor_to_static",
            "Add static to constructors",
            "fn new() -> Self",
            "static fn new() -> Self",
            "Heuristic for new, default, from_*, etc."
        )
    ]

# Get list of constructor patterns to make static
fn get_constructor_patterns() -> List<text>:
    [
        "new",
        "default",
        "from_str",
        "from_string",
        "from_file",
        "create",
        "create_empty",
        "make",
        "build",
        "with_capacity"
    ]

# Print val/var transformation examples
fn print_val_var_examples() -> text:
    var output = ""
    output = output + "=== Val/Var Syntax Migration Patterns ===\n\n"
    output = output + "⚠️  ORDER MATTERS! Transformations must run in sequence:\n\n"

    val patterns = get_val_var_patterns()
    var i = 0
    while i < patterns.len():
        val pattern = patterns[i]
        output = output + "{pattern.order}. {pattern.name}\n"
        output = output + "   {pattern.description}\n"
        output = output + "   Before: {pattern.before}\n"
        output = output + "   After:  {pattern.after}\n"
        output = output + "   Note:   {pattern.notes}\n\n"
        i = i + 1

    output = output + "Constructor patterns (automatically get 'static'):\n"
    val constructors = get_constructor_patterns()
    var j = 0
    while j < constructors.len():
        output = output + "  - {constructors[j]}\n"
        j = j + 1

    output

# Migrate a single file with val/var syntax
# TODO: [stdlib][P1] Needs regex for actual migration logic
fn migrate_val_var_file(filepath: text, backup_dir: text) -> MigrationResult:
    # Read file content
    match read_text(filepath):
        Ok(content):
            # Apply migrate_val_var_content() (currently a stub without regex)
            val migrated = migrate_val_var_content(content)

            # Check if anything changed
            if migrated == content:
                return MigrationResult.unchanged()

            # Backup original to backup_dir
            val file_name = basename(filepath)
            val backup_path = join([backup_dir, file_name])

            match write_text(backup_path, content):
                Ok(_):
                    # Write migrated content
                    match write_text(filepath, migrated):
                        Ok(_):
                            # TODO: Count changed lines accurately
                            MigrationResult.changed(1)
                        Err(e):
                            MigrationResult.error("Failed to write migrated file: {e}")
                Err(e):
                    MigrationResult.error("Failed to backup file: {e}")
        Err(e):
            MigrationResult.error("Failed to read file: {e}")

# Find all .spl files in directory
fn find_spl_files(root_dir: text) -> List<text>:
    # Glob for **/*.spl
    match glob(root_dir, "**/*.spl"):
        Ok(files):
            # TODO: Filter out target, .git, .migration_backup directories
            files
        Err(_):
            []  # Return empty list on error

# Run val/var migration on all .spl files
# TODO: [stdlib][P1] Needs regex for actual migration logic
fn run_val_var_migration(root_dir: text) -> ValVarMigrationStats:
    # Create backup directory with timestamp
    val backup_dir = migration_backup_dir("val_var")
    var stats = ValVarMigrationStats.new(backup_dir)

    # Create backup directory
    match create_dir(backup_dir, true):
        Ok(_):
            # Find all .spl files
            val files = find_spl_files(root_dir)

            # Process each file
            var i = 0
            while i < files.len():
                val filepath = files[i]
                stats.add_processed()

                val result = migrate_val_var_file(filepath, backup_dir)
                if result.modified:
                    stats.add_modified(result.lines_changed)
                    print "Migrated: {filepath}"
                elif not result.error.is_empty():
                    print "Error processing {filepath}: {result.error}"

                i = i + 1
        Err(e):
            print "Error creating backup directory: {e}"

    stats

# Migration result (reuse from migrate_me_syntax)
struct MigrationResult:
    modified: bool
    lines_changed: u64
    error: text

impl MigrationResult:
    static fn unchanged() -> MigrationResult:
        MigrationResult(false, 0, "")

    static fn changed(lines: u64) -> MigrationResult:
        MigrationResult(true, lines, "")

    static fn error(message: text) -> MigrationResult:
        MigrationResult(false, 0, message)

# CLI options for migrate_val_var command
struct MigrateValVarOptions:
    dry_run: bool
    backup_dir: Option<text>
    root_dir: text
    show_help: bool

impl MigrateValVarOptions:
    # Create default options
    static fn default() -> MigrateValVarOptions:
        MigrateValVarOptions(
            dry_run: false,
            backup_dir: None,
            root_dir: ".",
            show_help: false
        )

    # Parse CLI arguments
    static fn parse(args: List<text>) -> MigrateValVarOptions:
        var options = MigrateValVarOptions.default()
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg == "--dry-run" or arg == "-n":
                options.dry_run = true
            elif arg == "--backup-dir" and i + 1 < args.len():
                i = i + 1
                options.backup_dir = Some(args[i])
            elif arg == "--help" or arg == "-h":
                options.show_help = true
            elif not arg.starts_with("-"):
                # Positional argument: root directory
                options.root_dir = arg

            i = i + 1

        options

# Print usage help for migrate_val_var
fn print_migrate_val_var_help() -> text:
    var help = ""
    help = help + "Usage: simple migrate-val-var [OPTIONS] [ROOT_DIR]\n\n"
    help = help + "Migrate from let/let mut syntax to val/var syntax.\n\n"
    help = help + "Arguments:\n"
    help = help + "  ROOT_DIR         Directory to migrate (default: current directory)\n\n"
    help = help + "Options:\n"
    help = help + "  -n, --dry-run    Preview changes without writing files\n"
    help = help + "  --backup-dir     Custom backup directory for original files\n"
    help = help + "  -h, --help       Show this help message\n\n"
    help = help + "Examples:\n"
    help = help + "  simple migrate-val-var                    # Migrate current directory\n"
    help = help + "  simple migrate-val-var src/               # Migrate src/ directory\n"
    help = help + "  simple migrate-val-var --dry-run src/     # Preview changes only\n"
    help

# Main entry point
fn main_migrate_val_var(args: List<text>) -> Result<(), text>:
    val options = MigrateValVarOptions.parse(args)

    # Show help if requested
    if options.show_help:
        print print_migrate_val_var_help()
        return Ok(())

    # Show what we're doing
    if options.dry_run:
        print "=== Dry Run Mode - No files will be modified ===\n"

    print "Migrating val/var syntax in: {options.root_dir}"

    # Run the migration
    val stats = run_val_var_migration(options.root_dir)

    # Print summary
    print stats.summary()

    # Print transformation patterns for reference
    if options.dry_run:
        print print_val_var_examples()

    Ok(())
