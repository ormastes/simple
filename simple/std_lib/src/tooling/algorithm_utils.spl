# Algorithm utilities
# Sorting, searching, and algorithm implementations

# =====================================
# Sorting Algorithms
# =====================================

# Bubble sort (simple, O(n²))
fn bubble_sort(list: List<i32>) -> List<i32>:
    var result = list
    var n = result.len()

    for i in 0..n:
        for j in 0..(n - i - 1):
            if result[j] > result[j + 1]:
                # Swap
                val temp = result[j]
                result[j] = result[j + 1]
                result[j + 1] = temp

    result

# Selection sort (O(n²))
fn selection_sort(list: List<i32>) -> List<i32>:
    var result = list
    var n = result.len()

    for i in 0..n:
        var min_idx = i

        for j in (i + 1)..n:
            if result[j] < result[min_idx]:
                min_idx = j

        # Swap
        if min_idx != i:
            val temp = result[i]
            result[i] = result[min_idx]
            result[min_idx] = temp

    result

# Insertion sort (O(n²), good for nearly sorted)
fn insertion_sort(list: List<i32>) -> List<i32>:
    var result = list
    var n = result.len()

    for i in 1..n:
        val key = result[i]
        var j = i - 1

        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1

        result[j + 1] = key

    result

# Quick sort partition helper
fn quick_sort_partition(list: List<i32>, low: i32, high: i32) -> (List<i32>, i32):
    var result = list
    val pivot = result[high]
    var i = low - 1

    for j in low..high:
        if result[j] <= pivot:
            i = i + 1
            # Swap
            val temp = result[i]
            result[i] = result[j]
            result[j] = temp

    # Swap pivot
    val temp = result[i + 1]
    result[i + 1] = result[high]
    result[high] = temp

    (result, i + 1)

# Quick sort recursive helper
fn quick_sort_helper(list: List<i32>, low: i32, high: i32) -> List<i32>:
    if low < high:
        val (partitioned, pi) = quick_sort_partition(list, low, high)
        val left_sorted = quick_sort_helper(partitioned, low, pi - 1)
        return quick_sort_helper(left_sorted, pi + 1, high)

    list

# Quick sort (O(n log n) average)
fn quick_sort(list: List<i32>) -> List<i32>:
    if list.len() <= 1:
        return list

    quick_sort_helper(list, 0, list.len() - 1)

# Merge two sorted lists
fn merge_sorted(left: List<i32>, right: List<i32>) -> List<i32>:
    var result = []
    var i = 0
    var j = 0

    while i < left.len() and j < right.len():
        if left[i] <= right[j]:
            result.push(left[i])
            i = i + 1
        else:
            result.push(right[j])
            j = j + 1

    # Add remaining
    while i < left.len():
        result.push(left[i])
        i = i + 1

    while j < right.len():
        result.push(right[j])
        j = j + 1

    result

# Merge sort (O(n log n), stable)
fn merge_sort(list: List<i32>) -> List<i32>:
    if list.len() <= 1:
        return list

    val mid = list.len() / 2
    val left = list.slice(0, mid)
    val right = list.slice(mid, list.len())

    val sorted_left = merge_sort(left)
    val sorted_right = merge_sort(right)

    merge_sorted(sorted_left, sorted_right)

# Check if list is sorted
fn is_sorted(list: List<i32>) -> bool:
    for i in 1..list.len():
        if list[i - 1] > list[i]:
            return false

    true

# =====================================
# Searching Algorithms
# =====================================

# Linear search
fn linear_search(list: List<i32>, target: i32) -> Option<i32>:
    for i in 0..list.len():
        if list[i] == target:
            return Some(i)

    None

# Binary search (requires sorted list)
fn binary_search(list: List<i32>, target: i32) -> Option<i32>:
    var low = 0
    var high = list.len() - 1

    while low <= high:
        val mid = low + (high - low) / 2

        if list[mid] == target:
            return Some(mid)
        elif list[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    None

# Find minimum value
fn find_min(list: List<i32>) -> Option<i32>:
    if list.len() == 0:
        return None

    var min_value = list[0]
    for i in 1..list.len():
        if list[i] < min_value:
            min_value = list[i]

    Some(min_value)

# Find maximum value
fn find_max(list: List<i32>) -> Option<i32>:
    if list.len() == 0:
        return None

    var max_value = list[0]
    for i in 1..list.len():
        if list[i] > max_value:
            max_value = list[i]

    Some(max_value)

# Find index of minimum
fn find_min_index(list: List<i32>) -> Option<i32>:
    if list.len() == 0:
        return None

    var min_idx = 0
    for i in 1..list.len():
        if list[i] < list[min_idx]:
            min_idx = i

    Some(min_idx)

# Find index of maximum
fn find_max_index(list: List<i32>) -> Option<i32>:
    if list.len() == 0:
        return None

    var max_idx = 0
    for i in 1..list.len():
        if list[i] > list[max_idx]:
            max_idx = i

    Some(max_idx)

# =====================================
# List Manipulation
# =====================================

# Reverse list
fn reverse_list(list: List<i32>) -> List<i32>:
    var result = []

    for i in 0..list.len():
        result.push(list[list.len() - 1 - i])

    result

# Rotate list left by n positions
fn rotate_left(list: List<i32>, n: i32) -> List<i32>:
    if list.len() == 0:
        return list

    val shift = n % list.len()
    val left = list.slice(shift, list.len())
    val right = list.slice(0, shift)

    left + right

# Rotate list right by n positions
fn rotate_right(list: List<i32>, n: i32) -> List<i32>:
    if list.len() == 0:
        return list

    val shift = n % list.len()
    rotate_left(list, list.len() - shift)

# Remove duplicates (preserves order)
fn remove_duplicates(list: List<i32>) -> List<i32>:
    var result = []
    var seen = []

    for item in list:
        var is_duplicate = false
        for s in seen:
            if s == item:
                is_duplicate = true
                break

        if not is_duplicate:
            result.push(item)
            seen.push(item)

    result

# Partition list by predicate
fn partition(list: List<i32>, predicate: fn(i32) -> bool) -> (List<i32>, List<i32>):
    var true_list = []
    var false_list = []

    for item in list:
        if predicate(item):
            true_list.push(item)
        else:
            false_list.push(item)

    (true_list, false_list)

# Take first n elements
fn take(list: List<i32>, n: i32) -> List<i32>:
    if n >= list.len():
        return list

    list.slice(0, n)

# Drop first n elements
fn drop(list: List<i32>, n: i32) -> List<i32>:
    if n >= list.len():
        return []

    list.slice(n, list.len())

# Take while predicate is true
fn take_while(list: List<i32>, predicate: fn(i32) -> bool) -> List<i32>:
    var result = []

    for item in list:
        if predicate(item):
            result.push(item)
        else:
            break

    result

# Drop while predicate is true
fn drop_while(list: List<i32>, predicate: fn(i32) -> bool) -> List<i32>:
    var i = 0

    while i < list.len() and predicate(list[i]):
        i = i + 1

    list.slice(i, list.len())

# =====================================
# Statistical Functions
# =====================================

# Calculate sum
fn sum(list: List<i32>) -> i32:
    var total = 0

    for item in list:
        total = total + item

    total

# Calculate average
fn average(list: List<i32>) -> Option<i32>:
    if list.len() == 0:
        return None

    Some(sum(list) / list.len())

# Calculate median (requires sorting)
fn median(list: List<i32>) -> Option<i32>:
    if list.len() == 0:
        return None

    val sorted = quick_sort(list)
    val mid = sorted.len() / 2

    if sorted.len() % 2 == 0:
        # Average of two middle elements
        Some((sorted[mid - 1] + sorted[mid]) / 2)
    else:
        Some(sorted[mid])

# Calculate mode (most frequent element)
fn mode(list: List<i32>) -> Option<i32>:
    if list.len() == 0:
        return None

    var max_count = 0
    var mode_value = list[0]

    for i in 0..list.len():
        var count = 0

        for j in 0..list.len():
            if list[j] == list[i]:
                count = count + 1

        if count > max_count:
            max_count = count
            mode_value = list[i]

    Some(mode_value)

# Calculate range (max - min)
fn range_value(list: List<i32>) -> Option<i32>:
    match find_min(list):
        Some(min_val) =>
            match find_max(list):
                Some(max_val) => Some(max_val - min_val)
                None => None
        None => None

# =====================================
# Combinatorics
# =====================================

# Generate all pairs from a list
fn all_pairs(list: List<i32>) -> List<(i32, i32)>:
    var result = []

    for i in 0..list.len():
        for j in (i + 1)..list.len():
            result.push((list[i], list[j]))

    result

# Cartesian product of two lists
fn cartesian_product(list1: List<i32>, list2: List<i32>) -> List<(i32, i32)>:
    var result = []

    for a in list1:
        for b in list2:
            result.push((a, b))

    result

# Flatten nested list (one level)
fn flatten(nested: List<List<i32>>) -> List<i32>:
    var result = []

    for sublist in nested:
        for item in sublist:
            result.push(item)

    result

# Chunk list into groups of size n
fn chunk(list: List<i32>, size: i32) -> List<List<i32>>:
    var result = []
    var i = 0

    while i < list.len():
        val end = if i + size <= list.len(): i + size else: list.len()
        result.push(list.slice(i, end))
        i = i + size

    result

# Sliding window of size n
fn sliding_window(list: List<i32>, size: i32) -> List<List<i32>>:
    var result = []

    for i in 0..(list.len() - size + 1):
        result.push(list.slice(i, i + size))

    result

# Interleave two lists
fn interleave(list1: List<i32>, list2: List<i32>) -> List<i32>:
    var result = []
    var i = 0
    val max_len = if list1.len() > list2.len(): list1.len() else: list2.len()

    while i < max_len:
        if i < list1.len():
            result.push(list1[i])
        if i < list2.len():
            result.push(list2[i])
        i = i + 1

    result

# =====================================
# Comparison Utilities
# =====================================

# Check if two lists are equal
fn lists_equal(list1: List<i32>, list2: List<i32>) -> bool:
    if list1.len() != list2.len():
        return false

    for i in 0..list1.len():
        if list1[i] != list2[i]:
            return false

    true

# Check if list1 is prefix of list2
fn is_prefix(prefix: List<i32>, list: List<i32>) -> bool:
    if prefix.len() > list.len():
        return false

    for i in 0..prefix.len():
        if prefix[i] != list[i]:
            return false

    true

# Check if list1 is suffix of list2
fn is_suffix(suffix: List<i32>, list: List<i32>) -> bool:
    if suffix.len() > list.len():
        return false

    val offset = list.len() - suffix.len()

    for i in 0..suffix.len():
        if suffix[i] != list[offset + i]:
            return false

    true

# Find first occurrence of sublist
fn find_sublist(haystack: List<i32>, needle: List<i32>) -> Option<i32>:
    if needle.len() == 0:
        return Some(0)

    if needle.len() > haystack.len():
        return None

    for i in 0..(haystack.len() - needle.len() + 1):
        var matches = true

        for j in 0..needle.len():
            if haystack[i + j] != needle[j]:
                matches = false
                break

        if matches:
            return Some(i)

    None

# Count occurrences of value
fn count_occurrences(list: List<i32>, value: i32) -> i32:
    var count = 0

    for item in list:
        if item == value:
            count = count + 1

    count

# Find all indices of value
fn find_all_indices(list: List<i32>, value: i32) -> List<i32>:
    var indices = []

    for i in 0..list.len():
        if list[i] == value:
            indices.push(i)

    indices
