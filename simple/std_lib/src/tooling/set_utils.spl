# Set operations on lists
# Treating lists as sets for common set operations

# =====================================
# Set Operations
# =====================================

# Check if list contains item (set membership)
fn contains<T>(set: List<T>, item: T) -> bool:
    for elem in set:
        if elem == item:
            return true
    false

# Add item to set if not present
fn add<T>(set: List<T>, item: T) -> List<T>:
    if contains(set, item):
        return set.clone()

    var result = set.clone()
    result.push(item)
    result

# Remove item from set
fn remove<T>(set: List<T>, item: T) -> List<T>:
    var result = []

    for elem in set:
        if elem != item:
            result.push(elem)

    result

# Union of two sets (all unique elements from both)
fn set_union<T>(set1: List<T>, set2: List<T>) -> List<T>:
    var result = set1.clone()

    for elem in set2:
        if not contains(result, elem):
            result.push(elem)

    result

# Intersection of two sets (elements present in both)
fn set_intersection<T>(set1: List<T>, set2: List<T>) -> List<T>:
    var result = []

    for elem in set1:
        if contains(set2, elem):
            result.push(elem)

    result

# Difference (elements in set1 but not in set2)
fn set_difference<T>(set1: List<T>, set2: List<T>) -> List<T>:
    var result = []

    for elem in set1:
        if not contains(set2, elem):
            result.push(elem)

    result

# Symmetric difference (elements in either set but not both)
fn symmetric_difference<T>(set1: List<T>, set2: List<T>) -> List<T>:
    var result = []

    # Elements in set1 but not set2
    for elem in set1:
        if not contains(set2, elem):
            result.push(elem)

    # Elements in set2 but not set1
    for elem in set2:
        if not contains(set1, elem):
            result.push(elem)

    result

# Check if set1 is subset of set2
fn is_subset<T>(set1: List<T>, set2: List<T>) -> bool:
    for elem in set1:
        if not contains(set2, elem):
            return false

    true

# Check if set1 is superset of set2
fn is_superset<T>(set1: List<T>, set2: List<T>) -> bool:
    is_subset(set2, set1)

# Check if sets are disjoint (no common elements)
fn is_disjoint<T>(set1: List<T>, set2: List<T>) -> bool:
    for elem in set1:
        if contains(set2, elem):
            return false

    true

# Cardinality (size of set)
fn cardinality<T>(set: List<T>) -> i32:
    set.len()

# Power set (all subsets) - limited to small sets
fn power_set<T>(set: List<T>) -> List<List<T>>:
    if set.is_empty():
        return [[]]

    if set.len() > 10:
        # Too large, would create 2^n subsets
        return [[]]

    var result: List<List<T>> = [[]]

    for elem in set:
        val current_size = result.len()
        for i in 0..current_size:
            var new_subset = result[i].clone()
            new_subset.push(elem)
            result.push(new_subset)

    result

# Cartesian product of two sets
fn cartesian_product<T, U>(set1: List<T>, set2: List<U>) -> List<(T, U)>:
    var result = []

    for elem1 in set1:
        for elem2 in set2:
            result.push((elem1, elem2))

    result

# =====================================
# Multiset Operations (Bags)
# =====================================

# Count occurrences of item
fn count_occurrences<T>(bag: List<T>, item: T) -> i32:
    var count = 0

    for elem in bag:
        if elem == item:
            count = count + 1

    count

# Multiset union (max count from either bag)
fn multiset_union<T>(bag1: List<T>, bag2: List<T>) -> List<T>:
    var result = []
    var processed: List<T> = []

    # Get unique elements
    val unique1 = unique(bag1)
    val unique2 = unique(bag2)
    val all_unique = set_union(unique1, unique2)

    for elem in all_unique:
        val count1 = count_occurrences(bag1, elem)
        val count2 = count_occurrences(bag2, elem)
        val max_count = if count1 > count2: count1 else: count2

        for _ in 0..max_count:
            result.push(elem)

    result

# Multiset intersection (min count from both bags)
fn multiset_intersection<T>(bag1: List<T>, bag2: List<T>) -> List<T>:
    var result = []
    val unique1 = unique(bag1)

    for elem in unique1:
        val count1 = count_occurrences(bag1, elem)
        val count2 = count_occurrences(bag2, elem)
        val min_count = if count1 < count2: count1 else: count2

        for _ in 0..min_count:
            result.push(elem)

    result

# Remove duplicates (convert multiset to set)
fn unique<T>(list: List<T>) -> List<T>:
    var result = []

    for elem in list:
        if not contains(result, elem):
            result.push(elem)

    result

# =====================================
# Partition Operations
# =====================================

# Partition list by predicate
fn partition_by<T>(list: List<T>, predicate: fn(T) -> bool) -> (List<T>, List<T>):
    var matched = []
    var unmatched = []

    for elem in list:
        if predicate(elem):
            matched.push(elem)
        else:
            unmatched.push(elem)

    (matched, unmatched)

# Group by key function
fn group_by<T, K>(list: List<T>, key_fn: fn(T) -> K) -> List<(K, List<T>)>:
    var groups: List<(K, List<T>)> = []

    for elem in list:
        val key = key_fn(elem)

        # Find existing group
        var found = false
        var new_groups: List<(K, List<T>)> = []

        for (existing_key, group) in groups:
            if existing_key == key:
                var updated_group = group.clone()
                updated_group.push(elem)
                new_groups.push((existing_key, updated_group))
                found = true
            else:
                new_groups.push((existing_key, group))

        if found:
            groups = new_groups
        else:
            groups.push((key, [elem]))

    groups

# =====================================
# Frequency Analysis
# =====================================

# Count frequency of each element
struct Frequency<T>:
    item: T
    count: i32

fn frequency_count<T>(list: List<T>) -> List<Frequency<T>>:
    var frequencies: List<Frequency<T>> = []

    for elem in list:
        var found = false
        var new_freqs: List<Frequency<T>> = []

        for freq in frequencies:
            if freq.item == elem:
                new_freqs.push(Frequency(item: elem, count: freq.count + 1))
                found = true
            else:
                new_freqs.push(freq)

        if found:
            frequencies = new_freqs
        else:
            frequencies.push(Frequency(item: elem, count: 1))

    frequencies

# Find most common element
fn most_common<T>(list: List<T>) -> Option<T>:
    if list.is_empty():
        return None

    val freqs = frequency_count(list)

    var max_freq = freqs[0]
    for freq in freqs:
        if freq.count > max_freq.count:
            max_freq = freq

    Some(max_freq.item)

# Find least common element
fn least_common<T>(list: List<T>) -> Option<T>:
    if list.is_empty():
        return None

    val freqs = frequency_count(list)

    var min_freq = freqs[0]
    for freq in freqs:
        if freq.count < min_freq.count:
            min_freq = freq

    Some(min_freq.item)

# =====================================
# Ranking and Ordering
# =====================================

# Find rank of item in sorted list (0-based)
fn rank<T>(sorted_list: List<T>, item: T) -> Option<i32>:
    for i in 0..sorted_list.len():
        if sorted_list[i] == item:
            return Some(i)

    None

# Find percentile rank (0-100)
fn percentile_rank<T>(sorted_list: List<T>, item: T) -> Option<f64>:
    if sorted_list.is_empty():
        return None

    match rank(sorted_list, item):
        Some(idx) =>
            val percentile = ((idx as f64) / (sorted_list.len() as f64)) * 100.0
            Some(percentile)
        None =>
            None

# =====================================
# Sampling (Deterministic)
# =====================================

# Take every nth element
fn sample_every_nth<T>(list: List<T>, n: i32) -> List<T>:
    if n <= 0:
        return []

    var result = []
    var i = 0

    while i < list.len():
        result.push(list[i])
        i = i + n

    result

# Take first n elements
fn take<T>(list: List<T>, n: i32) -> List<T>:
    if n <= 0:
        return []

    if n >= list.len():
        return list.clone()

    var result = []
    for i in 0..n:
        result.push(list[i])

    result

# Skip first n elements
fn skip<T>(list: List<T>, n: i32) -> List<T>:
    if n <= 0:
        return list.clone()

    if n >= list.len():
        return []

    var result = []
    for i in n..list.len():
        result.push(list[i])

    result

# Take while predicate is true
fn take_while<T>(list: List<T>, predicate: fn(T) -> bool) -> List<T>:
    var result = []

    for elem in list:
        if predicate(elem):
            result.push(elem)
        else:
            break

    result

# Skip while predicate is true
fn skip_while<T>(list: List<T>, predicate: fn(T) -> bool) -> List<T>:
    var result = []
    var skipping = true

    for elem in list:
        if skipping and predicate(elem):
            continue
        else:
            skipping = false
            result.push(elem)

    result
