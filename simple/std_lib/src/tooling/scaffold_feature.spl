# Feature Test Scaffolding Tool
# Migrated from: scripts/scaffold_feature_test.py
# Purpose: Generate BDD test templates from feature markdown files

# TODO: [stdlib][P1] Add regex library to Simple

import fs.{read_text, write_text}

# Feature metadata extracted from markdown
struct FeatureMetadata:
    feature_id: text
    feature_name: text
    category: text
    difficulty: u64
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    dependencies: List<u64>
    required_by: List<u64>
    notes: text

impl FeatureMetadata:
    # Create empty metadata
    static fn new() -> FeatureMetadata:
        FeatureMetadata(
            feature_id: "",
            feature_name: "",
            category: "",
            difficulty: 3,
            status: "âœ… Complete",
            impl_type: "R",
            spec_ref: "",
            files: [],
            tests: [],
            description: "",
            dependencies: [],
            required_by: [],
            notes: ""
        )

    # Create with basic info
    static fn with_info(id: text, name: text, category: text) -> FeatureMetadata:
        var meta = FeatureMetadata.new()
        meta.feature_id = id
        meta.feature_name = name
        meta.category = category
        meta

# Scaffold generation result
struct ScaffoldResult:
    success: bool
    content: text
    error_message: text

impl ScaffoldResult:
    # Create success result
    static fn success(content: text) -> ScaffoldResult:
        ScaffoldResult(
            success: true,
            content: content,
            error_message: ""
        )

    # Create error result
    static fn error(message: text) -> ScaffoldResult:
        ScaffoldResult(
            success: false,
            content: "",
            error_message: message
        )

# TODO: [stdlib][P1] Add regex support
# Parse overview table from markdown content
fn parse_overview_table(content: text) -> FeatureMetadata:
    # Stub: Needs regex to extract table rows
    # Would parse:
    # | **Feature ID** | #123 |
    # | **Feature Name** | My Feature |
    # etc.
    FeatureMetadata.new()

# TODO: [stdlib][P1] Add regex support
# Extract content from a specific markdown section
fn extract_section(content: text, section_name: text) -> text:
    # Stub: Needs regex pattern: ## {section_name}\s*\n\s*(.*?)(?=\n## |\Z)
    ""

# TODO: [stdlib][P1] Add regex support
# Extract file paths from implementation files table
fn parse_file_table(content: text) -> List<text>:
    # Stub: Needs regex to parse table rows
    []

# TODO: [stdlib][P1] Add regex support
# Extract test file paths from testing section
fn parse_test_table(content: text, section_name: text) -> List<text>:
    # Stub: Needs regex to find and parse test table
    []

# TODO: [stdlib][P1] Add regex support
# Extract code examples from Examples section
fn extract_code_examples(content: text) -> List<text>:
    # Stub: Needs regex to find ```simple code blocks
    []

# TODO: [stdlib][P1] Add regex support
# Extract depends_on and required_by feature IDs
fn parse_dependencies(content: text) -> (List<u64>, List<u64>):
    # Stub: Needs regex for patterns like "Depends on: #1, #2, #3"
    ([], [])

# Generate BDD test scaffold from feature metadata
fn generate_test_scaffold(metadata: FeatureMetadata, source_file: text) -> text:
    var output = ""

    # Header comments
    output = output + "# Scaffolded from {source_file}\n"
    output = output + "# TODO: Add real test assertions before marking complete\n\n"

    # Import
    output = output + "use spec.feature_doc.feature_metadata\n\n"

    # Describe block with feature metadata
    output = output + "describe \"{metadata.feature_name} (#{metadata.feature_id})\":\n"
    output = output + "    feature_metadata(\n"
    output = output + "        id: {metadata.feature_id},\n"
    output = output + "        name: \"{metadata.feature_name}\",\n"
    output = output + "        category: \"{metadata.category}\",\n"
    output = output + "        difficulty: {metadata.difficulty},\n"
    output = output + "        status: \"{metadata.status}\",\n"
    output = output + "        impl_type: \"{metadata.impl_type}\",\n"
    output = output + "        spec_ref: \"{metadata.spec_ref}\",\n"

    # Files list
    if metadata.files.is_empty():
        output = output + "        files: [],\n"
    else:
        output = output + "        files: [\n"
        var i = 0
        while i < metadata.files.len():
            output = output + "            \"{metadata.files[i]}\",\n"
            i = i + 1
        output = output + "        ],\n"

    # Tests list
    if metadata.tests.is_empty():
        output = output + "        tests: [],\n"
    else:
        output = output + "        tests: [\n"
        var i = 0
        while i < metadata.tests.len():
            output = output + "            \"{metadata.tests[i]}\",\n"
            i = i + 1
        output = output + "        ],\n"

    # Description (triple-quoted string)
    if metadata.description.is_empty():
        output = output + "        description: \"\",\n"
    else:
        output = output + "        description: \"\"\"\n"
        output = output + "{metadata.description}\n"
        output = output + "        \"\"\",\n"

    # Dependencies
    if metadata.dependencies.is_empty():
        output = output + "        dependencies: [],\n"
    else:
        val deps_str = join_u64_list(metadata.dependencies)
        output = output + "        dependencies: [{deps_str}],\n"

    # Required by
    if metadata.required_by.is_empty():
        output = output + "        required_by: [],\n"
    else:
        val reqs_str = join_u64_list(metadata.required_by)
        output = output + "        required_by: [{reqs_str}],\n"

    # Notes
    if metadata.notes.is_empty():
        output = output + "        notes: \"\"\n"
    else:
        output = output + "        notes: \"\"\"\n"
        output = output + "{metadata.notes}\n"
        output = output + "        \"\"\"\n"

    output = output + "    )\n\n"

    # Add test stubs
    output = output + "    # TODO: Add test contexts and examples\n"
    output = output + "    context \"Basic Functionality\":\n"
    output = output + "        it \"works as expected\":\n"
    output = output + "            # TODO: Import required modules\n"
    output = output + "            # TODO: Add test setup\n"
    output = output + "            # TODO: Write assertions\n"
    output = output + "            skip \"TODO: Add real assertion\"\n\n"

    output

# Helper: Join list of u64 with commas
fn join_u64_list(list: List<u64>) -> text:
    var result = ""
    var i = 0
    while i < list.len():
        if i > 0:
            result = result + ", "
        result = result + "{list[i]}"
        i = i + 1
    result

# Generate scaffold from markdown file
# TODO: [stdlib][P1] Needs regex support for full parsing
fn scaffold_from_file(md_path: text) -> ScaffoldResult:
    # Read markdown file
    match read_text(md_path):
        Ok(content):
            # Parse metadata using regex functions (currently stubs)
            val metadata = parse_overview_table(content)

            # TODO: Once regex is available, implement proper parsing:
            # - Extract description from "Description" section
            # - Parse file table for implementation files
            # - Parse test table for test files
            # - Extract dependencies and required_by
            # - Extract notes section

            # Generate scaffold
            val scaffold_content = generate_test_scaffold(metadata, md_path)
            ScaffoldResult.success(scaffold_content)
        Err(e):
            ScaffoldResult.error("Failed to read markdown file: {e}")

# Scaffold statistics
struct ScaffoldStats:
    total_scaffolds: u64
    successful: u64
    failed: u64

impl ScaffoldStats:
    # Create empty stats
    static fn new() -> ScaffoldStats:
        ScaffoldStats(
            total_scaffolds: 0,
            successful: 0,
            failed: 0
        )

    # Record successful scaffold
    me add_success():
        self.total_scaffolds = self.total_scaffolds + 1
        self.successful = self.successful + 1

    # Record failed scaffold
    me add_failure():
        self.total_scaffolds = self.total_scaffolds + 1
        self.failed = self.failed + 1

    # Generate summary
    fn summary() -> text:
        var report = ""
        report = report + "Scaffold Generation Summary:\n"
        report = report + "  Total: {self.total_scaffolds}\n"
        report = report + "  Successful: {self.successful}\n"
        report = report + "  Failed: {self.failed}\n"
        report

# Write scaffold to file
fn write_scaffold_to_file(output_path: text, content: text) -> Result<(), text>:
    match write_text(output_path, content):
        Ok(_): Ok(())
        Err(e): Err("Failed to write scaffold: {e}")

# Generate and write scaffold from markdown file to output file
fn scaffold_and_write(md_path: text, output_path: text) -> Result<(), text>:
    match scaffold_from_file(md_path):
        Ok(result):
            if result.success:
                write_scaffold_to_file(output_path, result.content)
            else:
                Err(result.error_message)
        Err(e):
            Err(e)

# CLI options for scaffold_feature command
struct ScaffoldFeatureOptions:
    markdown_file: Option<text>
    output_file: Option<text>
    stdout: bool
    show_help: bool

impl ScaffoldFeatureOptions:
    # Create default options
    static fn default() -> ScaffoldFeatureOptions:
        ScaffoldFeatureOptions(
            markdown_file: None,
            output_file: None,
            stdout: false,
            show_help: false
        )

    # Parse CLI arguments
    static fn parse(args: List<text>) -> ScaffoldFeatureOptions:
        var options = ScaffoldFeatureOptions.default()
        var positional_count = 0
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg == "--stdout" or arg == "-s":
                options.stdout = true
            elif arg == "--output" or arg == "-o" and i + 1 < args.len():
                i = i + 1
                options.output_file = Some(args[i])
            elif arg == "--help" or arg == "-h":
                options.show_help = true
            elif not arg.starts_with("-"):
                # Positional arguments: markdown_file and output_file
                if positional_count == 0:
                    options.markdown_file = Some(arg)
                elif positional_count == 1:
                    options.output_file = Some(arg)
                positional_count = positional_count + 1

            i = i + 1

        options

# Print usage help for scaffold_feature
fn print_scaffold_feature_help() -> text:
    var help = ""
    help = help + "Usage: simple scaffold-feature [OPTIONS] <MARKDOWN_FILE> [OUTPUT_FILE]\n\n"
    help = help + "Generate BDD test templates from feature markdown files.\n\n"
    help = help + "Arguments:\n"
    help = help + "  MARKDOWN_FILE    Feature description markdown file\n"
    help = help + "  OUTPUT_FILE      Output _spec.spl file (optional)\n\n"
    help = help + "Options:\n"
    help = help + "  -o, --output     Specify output file explicitly\n"
    help = help + "  -s, --stdout     Print scaffold to stdout instead of file\n"
    help = help + "  -h, --help       Show this help message\n\n"
    help = help + "Examples:\n"
    help = help + "  simple scaffold-feature doc/features/001_lexer.md\n"
    help = help + "  simple scaffold-feature doc/features/001_lexer.md tests/001_lexer_spec.spl\n"
    help = help + "  simple scaffold-feature --stdout doc/features/001_lexer.md\n"
    help

# Main entry point
fn main_scaffold_feature(args: List<text>) -> Result<(), text>:
    val options = ScaffoldFeatureOptions.parse(args)

    # Show help if requested
    if options.show_help:
        print print_scaffold_feature_help()
        return Ok(())

    # Require markdown file
    match options.markdown_file:
        Some(md_path):
            print "Scaffolding from: {md_path}"

            # Generate scaffold
            val result = scaffold_from_file(md_path)

            if result.success:
                if options.stdout:
                    # Print to stdout
                    print result.content
                    Ok(())
                else:
                    # Write to file
                    val output_path = match options.output_file:
                        Some(path): path
                        None:
                            # Generate default output path
                            # Replace .md with _spec.spl
                            val base = md_path.replace(".md", "")
                            "{base}_spec.spl"

                    match write_scaffold_to_file(output_path, result.content):
                        Ok(_):
                            print "Scaffold written to: {output_path}"
                            Ok(())
                        Err(e):
                            Err(e)
            else:
                Err(result.error_message)
        None:
            Err("Missing required argument: MARKDOWN_FILE\nRun with --help for usage information.")
