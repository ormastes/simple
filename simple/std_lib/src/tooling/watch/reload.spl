# Hot Module Replacement (HMR)
# Reload code without restarting application

use core.result.{Result, Ok, Err}

# Reload strategy
pub enum ReloadStrategy:
    Full        # Full application restart
    Incremental # Reload only changed modules
    HotSwap     # Hot-swap functions without restart

    pub fn to_string(self): text =
        """Convert reload strategy to string.

        Returns:
            Strategy name

        Example:
            ReloadStrategy::HotSwap.to_string()  # → "hot-swap"
        """
        match self:
            ReloadStrategy::Full: "full"
            ReloadStrategy::Incremental: "incremental"
            ReloadStrategy::HotSwap: "hot-swap"

    pub fn description(self): text =
        """Get strategy description.

        Returns:
            Human-readable description

        Example:
            ReloadStrategy::HotSwap.description()
            # → "Hot-swap functions without application restart"
        """
        match self:
            ReloadStrategy::Full:
                "Full application restart with state loss"
            ReloadStrategy::Incremental:
                "Reload only changed modules, preserve app state"
            ReloadStrategy::HotSwap:
                "Hot-swap functions without application restart"

    pub fn preserves_state(self): bool =
        """Check if strategy preserves application state.

        Returns:
            True if state is preserved

        Example:
            ReloadStrategy::Full.preserves_state()  # → false
            ReloadStrategy::HotSwap.preserves_state()  # → true
        """
        match self:
            ReloadStrategy::Full: false
            ReloadStrategy::Incremental: true
            ReloadStrategy::HotSwap: true

    pub fn is_full(self): bool =
        """Check if full restart."""
        match self:
            ReloadStrategy::Full: true
            _: false

    pub fn is_incremental(self): bool =
        """Check if incremental."""
        match self:
            ReloadStrategy::Incremental: true
            _: false

    pub fn is_hot_swap(self): bool =
        """Check if hot-swap."""
        match self:
            ReloadStrategy::HotSwap: true
            _: false

# Reload event
pub class ReloadEvent:
    pub modules: List<text>
    pub timestamp: i64
    pub strategy: ReloadStrategy

    pub fn new(modules: List<text>, strategy: ReloadStrategy): ReloadEvent =
        """Create reload event.

        Args:
            modules: Modules to reload
            strategy: Reload strategy

        Returns:
            Reload event
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        ReloadEvent {
            modules: modules,
            timestamp: _rt_time_now_unix_micros() / 1000,  # Convert microseconds to milliseconds
            strategy: strategy
        }

    pub fn module_count(self): i32 =
        """Get number of modules to reload.

        Returns:
            Module count
        """
        self.modules.len()

    pub fn contains_module(self, module: text): bool =
        """Check if event contains specific module.

        Args:
            module: Module path to check

        Returns:
            True if module is in list
        """
        for m in self.modules:
            if m == module:
                return true
        false

    pub fn summary(self): text =
        """Get event summary.

        Returns:
            Human-readable summary

        Example:
            event.summary()
            # → "Reloading 3 modules (incremental)"
        """
        "Reloading {self.module_count()} modules ({self.strategy.to_string()})"

    pub fn is_single_module(self): bool =
        """Check if single module reload."""
        self.module_count() == 1

    pub fn is_batch_reload(self): bool =
        """Check if batch reload."""
        self.module_count() > 1

# HMR client - receives reload notifications
pub class HMRClient:
    pub on_reload_callback: (ReloadEvent) -> ()
    pub connected: bool

    pub fn new(): HMRClient =
        """Create HMR client.

        Returns:
            Client ready to receive reload events

        Example:
            val client = HMRClient.new()

            client.on_reload(fn(event):
                print("Reloading modules: {event.modules}")
                # Reload application state
            )

            client.connect()
        """
        HMRClient {
            on_reload_callback: fn(event): pass,
            connected: false
        }

    pub fn on_reload(self, callback: (ReloadEvent) -> ()):
        """Set reload callback.

        Args:
            callback: Function to call on reload event
        """
        self.on_reload_callback = callback

    pub fn connect(self):
        """Connect to HMR server.

        Establishes connection for receiving reload events.
        Uses HTTP long-polling for simplicity (WebSocket requires more infrastructure).
        """
        @extern("runtime", "rt_http_get")
        fn _rt_http_get(url_ptr: &u8, url_len: u64) -> text

        # Try to connect to HMR server
        val url = "http://{self.server_url}/hmr/connect"
        val response = _rt_http_get(url.ptr(), url.len())

        if response.contains("connected"):
            self.connected = true
            # Start polling for events in background
            self.start_event_polling()
        else:
            self.connected = false

    fn start_event_polling(self):
        """Start background polling for HMR events."""
        import concurrency.threads.{rt_thread_spawn_isolated}

        # Spawn polling thread
        val poll_fn = || self.poll_events()
        rt_thread_spawn_isolated(poll_fn, ())

    fn poll_events(self):
        """Poll for HMR events in a loop."""
        @extern("runtime", "rt_http_get")
        fn _rt_http_get(url_ptr: &u8, url_len: u64) -> text

        @extern("runtime", "rt_thread_sleep")
        fn _rt_thread_sleep(ms: i64)

        while self.connected:
            val url = "http://{self.server_url}/hmr/events"
            val response = _rt_http_get(url.ptr(), url.len())

            if not response.is_empty() and response != "none":
                # Parse event and call callback
                val modules = parse_hmr_event(response)
                if self.on_reload_callback.is_some():
                    self.on_reload_callback.unwrap()(modules)

            # Poll every 100ms
            _rt_thread_sleep(100)

    pub fn disconnect(self):
        """Disconnect from HMR server."""
        self.connected = false

    pub fn is_connected(self): bool =
        """Check if client is connected.

        Returns:
            True if connected
        """
        self.connected

    pub fn summary(self): text =
        """Get client summary."""
        val status = if self.connected: "connected" else: "disconnected"
        "HMRClient: {status}"

# HMR server - sends reload notifications
pub class HMRServer:
    pub clients: List<HMRClient>
    pub running: bool
    pub port: i32

    pub fn new(port: i32): HMRServer =
        """Create HMR server.

        Args:
            port: Server port

        Returns:
            HMR server

        Example:
            val server = HMRServer.new(3000)
            server.start()

            # In watch callback:
            server.notify_reload(["app.spl", "lib.spl"])
        """
        HMRServer {
            clients: [],
            running: false,
            port: port
        }

    pub fn start(self):
        """Start HMR server.

        Listens for client connections using HTTP server.
        Uses HTTP long-polling for simplicity.
        """
        import concurrency.threads.{rt_thread_spawn_isolated}

        self.running = true

        # Start HTTP server in background thread
        val server_fn = || self.run_http_server()
        rt_thread_spawn_isolated(server_fn, ())

    fn run_http_server(self):
        """Run HTTP server for HMR events."""
        @extern("runtime", "rt_http_server_start")
        fn _rt_http_server_start(port: i32) -> i64

        @extern("runtime", "rt_http_server_accept")
        fn _rt_http_server_accept(handle: i64) -> i64

        @extern("runtime", "rt_http_request_path")
        fn _rt_http_request_path(conn: i64) -> text

        @extern("runtime", "rt_http_response_send")
        fn _rt_http_response_send(conn: i64, body_ptr: &u8, body_len: u64)

        val server_handle = _rt_http_server_start(self.port)
        if server_handle < 0:
            self.running = false
            return

        while self.running:
            val conn = _rt_http_server_accept(server_handle)
            if conn < 0:
                continue

            val path = _rt_http_request_path(conn)

            if path == "/hmr/connect":
                # Register client and respond
                _rt_http_response_send(conn, "connected".ptr(), 9)
            elif path == "/hmr/events":
                # Return pending events or "none"
                if self.pending_events.len() > 0:
                    val events = self.pending_events.join(",")
                    self.pending_events.clear()
                    _rt_http_response_send(conn, events.ptr(), events.len())
                else:
                    _rt_http_response_send(conn, "none".ptr(), 4)
            else:
                _rt_http_response_send(conn, "not found".ptr(), 9)

    pub fn stop(self):
        """Stop HMR server."""
        self.running = false

    pub fn client_count(self): i32 =
        """Get number of connected clients.

        Returns:
            Client count
        """
        self.clients.len()

    pub fn is_running(self): bool =
        """Check if server is running.

        Returns:
            True if running
        """
        self.running

    pub fn has_clients(self): bool =
        """Check if has connected clients."""
        self.client_count() > 0

    pub fn summary(self): text =
        """Get server summary."""
        val status = if self.running: "running" else: "stopped"
        "HMRServer: port {self.port}, {self.client_count()} clients ({status})"

    pub fn notify_reload(self, modules: List<text>):
        """Notify all clients to reload modules.

        Args:
            modules: Modules that changed
        """
        val event = ReloadEvent.new(modules, ReloadStrategy::Incremental)

        for client in self.clients:
            self.send_reload_event(client, event)

    fn send_reload_event(client: HMRClient, event: ReloadEvent):
        """Send reload event to client.

        Args:
            client: HMR client
            event: Reload event
        """
        # TODO: [stdlib][P3] Send via WebSocket
        client.on_reload_callback(event)

# Module reloader - handles actual module reloading
pub class ModuleReloader:
    pub loaded_modules: Dict<text, i64>  # module -> mtime
    pub verbose: bool

    pub fn new(): ModuleReloader =
        """Create module reloader.

        Returns:
            Module reloader
        """
        ModuleReloader {
            loaded_modules: {},
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.verbose = enabled

    pub fn is_verbose(self): bool =
        """Check if verbose."""
        self.verbose

    pub fn with_verbose(self, enabled: bool): ModuleReloader =
        """Set verbose (fluent API)."""
        self.verbose = enabled
        self

    pub fn has_loaded_modules(self): bool =
        """Check if has loaded modules."""
        self.get_loaded_count() > 0

    pub fn summary(self): text =
        """Get reloader summary."""
        val verbose_str = if self.verbose: "true" else: "false"
        "ModuleReloader: {self.get_loaded_count()} loaded modules (verbose: {verbose_str})"

    pub fn reload_module(self, module_path: text): Result<(), text> =
        """Reload a module from disk.

        Args:
            module_path: Path to module file

        Returns:
            Ok if successful, Err with error message

        Example:
            val reloader = ModuleReloader.new()

            match reloader.reload_module("lib.spl"):
                Ok(_):
                    print("Module reloaded successfully")
                Err(err):
                    print("Reload failed: {err}")
        """
        if self.verbose:
            print("Reloading module: {module_path}")

        # Module reloading steps:
        # 1. Unload old module
        # 2. Re-compile module
        # 3. Load new module
        # 4. Update function pointers

        # Check if file exists
        @extern("runtime", "rt_file_exists")
        fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

        if not _rt_file_exists(module_path.ptr(), module_path.len()):
            return Err("Module file not found: {module_path}")

        # Step 1: Unload old module if loaded
        if self.loaded_modules.contains_key(module_path):
            if self.verbose:
                print("Unloading old version of {module_path}")
            self.unload_module(module_path)

        # Step 2: Re-compile the module
        if self.verbose:
            print("Compiling {module_path}")

        match self.compile_module(module_path):
            Ok(compiled_path) ->
                # Step 3: Load the new module
                if self.verbose:
                    print("Loading compiled module from {compiled_path}")

                match self.load_compiled_module(compiled_path, module_path):
                    Ok(module_handle) ->
                        # Step 4: Register the loaded module
                        self.loaded_modules[module_path] = module_handle

                        if self.verbose:
                            print("Module {module_path} reloaded successfully")

                        Ok(())
                    Err(load_err) ->
                        Err("Failed to load module: {load_err}")
            Err(compile_err) ->
                Err("Failed to compile module: {compile_err}")

    fn unload_module(self, module_path: text):
        """Unload a previously loaded module."""
        @extern("runtime", "rt_module_unload")
        fn _rt_module_unload(handle: i64)

        if self.loaded_modules.contains_key(module_path):
            val handle = self.loaded_modules[module_path]
            _rt_module_unload(handle)
            self.loaded_modules.remove(module_path)

    fn compile_module(self, module_path: text): Result<text, text> =
        """Compile a module file to bytecode/native."""
        import shell

        # Use the Simple compiler
        val output_path = module_path.replace(".spl", ".smf")
        val result = shell.run("simple", ["compile", module_path, "-o", output_path])

        if result.exit_code == 0:
            Ok(output_path)
        else:
            Err(result.stderr)

    fn load_compiled_module(self, compiled_path: text, module_path: text): Result<i64, text> =
        """Load a compiled module into the runtime."""
        @extern("runtime", "rt_module_load")
        fn _rt_module_load(path_ptr: &u8, path_len: u64) -> i64

        val handle = _rt_module_load(compiled_path.ptr(), compiled_path.len())

        if handle > 0:
            Ok(handle)
        else:
            Err("Runtime failed to load module")

    pub fn reload_modules(self, modules: List<text>): Result<(), text> =
        """Reload multiple modules.

        Args:
            modules: Module paths to reload

        Returns:
            Ok if all successful
        """
        for module in modules:
            match self.reload_module(module):
                Ok(_):
                    pass
                Err(err):
                    return Err("Failed to reload {module}: {err}")

        Ok(())

    pub fn can_hot_reload(self, module_path: text): bool =
        """Check if module can be hot-reloaded.

        Args:
            module_path: Module to check

        Returns:
            True if hot-reloadable

        Not all code can be safely hot-reloaded:
        - Pure functions: Safe
        - Stateful code: Requires state preservation
        - Type definitions: May require full restart
        """
        # TODO: [stdlib][P3] Analyze module for hot-reload safety
        # For now, assume all modules are reloadable
        true

    pub fn get_loaded_count(self): i32 =
        """Get number of loaded modules.

        Returns:
            Count of loaded modules
        """
        self.loaded_modules.len()

    pub fn is_loaded(self, module_path: text): bool =
        """Check if module is currently loaded.

        Args:
            module_path: Module to check

        Returns:
            True if loaded
        """
        self.loaded_modules.contains_key(module_path)

    pub fn clear_cache(self):
        """Clear loaded module cache.

        Forces full reload on next request.
        """
        self.loaded_modules = {}

# Watch mode integration - combines watching + reloading
pub class WatchReloadIntegration:
    pub watcher: Watcher
    pub reloader: ModuleReloader
    pub hmr_server: Option<HMRServer>
    pub auto_reload: bool

    pub fn new(root: text): WatchReloadIntegration =
        """Create integrated watch + reload system.

        Args:
            root: Project root

        Returns:
            Integrated system

        Example:
            val watch_reload = WatchReloadIntegration.new(".")
            watch_reload.set_auto_reload(true)
            watch_reload.start_hmr_server(3000)

            watch_reload.start()  # Watch + auto-reload
        """
        WatchReloadIntegration {
            watcher: Watcher.new(root),
            reloader: ModuleReloader.new(),
            hmr_server: none,
            auto_reload: false
        }

    pub fn set_auto_reload(self, enabled: bool):
        """Enable automatic module reloading.

        Args:
            enabled: True to auto-reload on file changes
        """
        self.auto_reload = enabled

    pub fn start_hmr_server(self, port: i32):
        """Start HMR server for client notifications.

        Args:
            port: Server port
        """
        val server = HMRServer.new(port)
        server.start()
        self.hmr_server = some(server)

    pub fn start(self):
        """Start watching and reloading.

        Blocks until stopped.
        """
        # Set up watch callback
        self.watcher.on_change(fn(files):
            print("Files changed: {files.len()}")

            if self.auto_reload:
                # Reload modules
                match self.reloader.reload_modules(files):
                    Ok(_):
                        print("✓ Modules reloaded successfully")

                        # Notify HMR clients
                        match self.hmr_server:
                            some(server):
                                server.notify_reload(files)
                            none:
                                pass
                    Err(err):
                        print("✗ Reload failed: {err}")
        )

        # Start watching
        self.watcher.start()

    pub fn stop(self):
        """Stop watching and reloading."""
        self.watcher.stop()

        match self.hmr_server:
            some(server):
                server.stop()
            none:
                pass

    pub fn is_auto_reload_enabled(self): bool =
        """Check if auto-reload enabled."""
        self.auto_reload

    pub fn has_hmr_server(self): bool =
        """Check if HMR server is configured."""
        match self.hmr_server:
            some(_): true
            none: false

    pub fn is_running(self): bool =
        """Check if watching is active."""
        self.watcher.is_running()

    pub fn summary(self): text =
        """Get integration summary."""
        val auto_str = if self.auto_reload: "enabled" else: "disabled"
        val hmr_str = if self.has_hmr_server(): "yes" else: "no"
        "WatchReloadIntegration: auto-reload {auto_str}, HMR server: {hmr_str}, {self.reloader.get_loaded_count()} loaded modules"
