# Tensor Broadcasting Utilities
#
# NumPy-style tensor shape broadcasting for element-wise operations.
# Pure functional implementation with provable broadcasting rules.
#
# Lean-friendly: Pure mathematical functions, broadcasting semantics,
# provable properties (associativity, commutativity of valid broadcasts)

# Compute strides for row-major tensor layout
# Strides[i] = product of all dimensions to the right of i
# Example: shape [2, 3, 4] → strides [12, 4, 1]
fn compute_strides(shape: [i32]) -> [i32]:
    if shape.length() == 0:
        return []

    var strides: [i32] = [for _ in shape: 1]
    var i = shape.length() - 2

    while i >= 0:
        strides[i] = strides[i + 1] * shape[i + 1]
        i = i - 1

    strides

# Get dimension at index with left-padding for broadcasting
# Treats missing dimensions as 1 for alignment
fn get_dim_aligned(shape: [i32], index: i32, max_len: i32) -> i32:
    if index < max_len - shape.length():
        1  # Left-pad with 1s
    else:
        shape[index - (max_len - shape.length())]

# Check if two dimensions are broadcast-compatible
# Dimensions are compatible if:
# - They are equal, OR
# - One of them is 1
fn dims_compatible(a: i32, b: i32) -> bool:
    a == b or a == 1 or b == 1

# Compute broadcast result dimension
# Returns the larger dimension if compatible
fn broadcast_dim(a: i32, b: i32) -> Result<i32, text>:
    if a == b:
        Ok(a)
    else if a == 1:
        Ok(b)
    else if b == 1:
        Ok(a)
    else:
        Err("Incompatible dimensions: {a} and {b} cannot broadcast")

# Broadcast two shapes for element-wise operations
# Follows NumPy broadcasting rules:
# 1. Align shapes from the right
# 2. Each dimension must be equal or one must be 1
# 3. Result has max length and max dimension at each position
#
# Examples:
#   [3, 1, 5] + [   4, 5] → [3, 4, 5]
#   [1, 3, 1] + [2, 1, 4] → [2, 3, 4]
#   [3, 4]    + [   5]    → ERROR (4 != 5)
fn broadcast_shapes(a: [i32], b: [i32]) -> Result<[i32], text>:
    val max_len = if a.length() > b.length(): a.length() else: b.length()
    var result: [i32] = []

    for i in 0..max_len:
        val a_dim = get_dim_aligned(a, i, max_len)
        val b_dim = get_dim_aligned(b, i, max_len)

        match broadcast_dim(a_dim, b_dim):
            Ok(dim) -> result = result + [dim]
            Err(msg) -> return Err(msg)

    Ok(result)

# Compute broadcast strides for a shape to fit a target shape
# Stride is 0 if dimension is being broadcast (size 1 → size n)
# Stride is normal if dimension matches
fn compute_broadcast_strides(shape: [i32], target_shape: [i32]) -> [i32]:
    var strides: [i32] = [for _ in target_shape: 0]
    val offset = target_shape.length() - shape.length()
    val original_strides = compute_strides(shape)

    var i = 0
    while i < shape.length():
        if shape[i] == target_shape[offset + i]:
            strides[offset + i] = original_strides[i]
        # else stride remains 0 (broadcasting dimension)
        i = i + 1

    strides

# Check if a shape can broadcast to a target shape
fn can_broadcast_to(shape: [i32], target: [i32]) -> bool:
    if shape.length() > target.length():
        return false

    var i = 0
    while i < shape.length():
        val shape_dim = shape[shape.length() - 1 - i]
        val target_dim = target[target.length() - 1 - i]

        if not dims_compatible(shape_dim, target_dim):
            return false
        if shape_dim != 1 and shape_dim != target_dim:
            return false

        i = i + 1

    true

# Compute total size (number of elements) from shape
fn shape_size(shape: [i32]) -> i32:
    var size = 1
    for dim in shape:
        size = size * dim
    size

# Check if shape is scalar (empty shape)
fn is_scalar(shape: [i32]) -> bool:
    shape.length() == 0

# Check if shape is vector (1-dimensional)
fn is_vector(shape: [i32]) -> bool:
    shape.length() == 1

# Check if shape is matrix (2-dimensional)
fn is_matrix(shape: [i32]) -> bool:
    shape.length() == 2

# Get number of dimensions
fn ndim(shape: [i32]) -> i32:
    shape.length()

# Broadcast multiple shapes (3 or more)
# Returns the broadcasted shape if all are compatible
fn broadcast_shapes_many(shapes: [[i32]]) -> Result<[i32], text>:
    if shapes.length() == 0:
        return Ok([])
    if shapes.length() == 1:
        return Ok(shapes[0])

    var result = shapes[0]
    for shape in shapes[1..]:
        match broadcast_shapes(result, shape):
            Ok(new_result) -> result = new_result
            Err(e) -> return Err(e)

    Ok(result)

# Check if all shapes are broadcast-compatible
fn all_broadcast_compatible(shapes: [[i32]]) -> bool:
    match broadcast_shapes_many(shapes):
        Ok(_) -> true
        Err(_) -> false

# Flatten multi-dimensional index to 1D index using strides
fn ravel_index(indices: [i32], strides: [i32]) -> i32:
    var flat_idx = 0
    var i = 0
    while i < indices.length():
        flat_idx = flat_idx + indices[i] * strides[i]
        i = i + 1
    flat_idx

# Unflatten 1D index to multi-dimensional indices using strides
fn unravel_index(flat_idx: i32, strides: [i32]) -> [i32]:
    var indices: [i32] = []
    var remaining = flat_idx

    for stride in strides:
        if stride == 0:
            indices = indices + [0]  # Broadcasting dimension
        else:
            val coord = remaining / stride
            indices = indices + [coord]
            remaining = remaining % stride

    indices
