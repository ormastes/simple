# Version Management
# Manage versioning across multi-language projects

use core.result.{Result, Ok, Err}

# Semantic version
pub class SemVer:
    pub major: i32
    pub minor: i32
    pub patch: i32
    pub prerelease: String
    pub build_metadata: String

    pub fn new(major: i32, minor: i32, patch: i32): SemVer =
        """Create semantic version.

        Args:
            major: Major version
            minor: Minor version
            patch: Patch version

        Returns:
            Semantic version

        Example:
            let v = SemVer.new(1, 2, 3)
            print(v.to_string())  # → "1.2.3"
        """
        SemVer {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: "",
            build_metadata: ""
        }

    pub fn parse(version_str: String): Result[SemVer, String] =
        """Parse version string.

        Args:
            version_str: Version string (e.g., "1.2.3", "2.0.0-beta.1")

        Returns:
            Parsed version or error

        Supports:
        - Basic: "1.2.3"
        - Prerelease: "1.2.3-beta.1", "1.2.3-alpha"
        - Build metadata: "1.2.3+20240110"
        - Combined: "1.2.3-beta.1+build.123"

        Example:
            match SemVer.parse("1.2.3"):
                Ok(v):
                    print("Version: {v.major}.{v.minor}.{v.patch}")
                Err(e):
                    print("Parse error: {e}")
        """
        # Clean version string
        let trimmed = version_str.trim()

        # Extract build metadata (after '+')
        let (core_and_pre, build_meta) = self.split_on_plus(trimmed)

        # Extract prerelease (after '-')
        let (core, prerelease) = self.split_on_dash(core_and_pre)

        # Parse core version (MAJOR.MINOR.PATCH)
        let parts = core.split(".")
        if parts.len() != 3:
            return Err("Invalid version format: expected MAJOR.MINOR.PATCH, got '" + core + "'")

        # Parse major
        let major = self.parse_int(parts[0])?

        # Parse minor
        let minor = self.parse_int(parts[1])?

        # Parse patch
        let patch = self.parse_int(parts[2])?

        # Build version
        let mut version = SemVer.new(major, minor, patch)
        version.prerelease = prerelease
        version.build_metadata = build_meta

        Ok(version)

    fn split_on_plus(self, text: String): (String, String) =
        """Split on '+' for build metadata.

        Args:
            text: Version string

        Returns:
            (core_and_prerelease, build_metadata)
        """
        let plus_idx = text.find("+")
        if plus_idx >= 0:
            let before = text[0:plus_idx]
            let after = text[plus_idx+1:]
            (before, after)
        else:
            (text, "")

    fn split_on_dash(self, text: String): (String, String) =
        """Split on '-' for prerelease.

        Args:
            text: Version string

        Returns:
            (core, prerelease)
        """
        let dash_idx = text.find("-")
        if dash_idx >= 0:
            let before = text[0:dash_idx]
            let after = text[dash_idx+1:]
            (before, after)
        else:
            (text, "")

    fn parse_int(self, s: String): Result[i32, String] =
        """Parse integer from string.

        Args:
            s: String to parse

        Returns:
            Parsed integer or error
        """
        # Simple integer parsing
        let trimmed = s.trim()
        if trimmed.is_empty():
            return Err("Empty string cannot be parsed as integer")

        let mut result = 0
        let mut negative = false
        let mut start_idx = 0

        # Check for negative sign
        if trimmed[0] == '-':
            negative = true
            start_idx = 1

        # Parse digits
        for i in start_idx..trimmed.len():
            let ch = trimmed[i]
            if ch >= '0' and ch <= '9':
                let digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                return Err("Invalid character in number: '" + ch + "'")

        if negative:
            result = -result

        Ok(result)

    pub fn to_string(self): String =
        """Convert to string.

        Returns:
            Version string

        Example:
            SemVer.new(1, 2, 3).to_string()  # → "1.2.3"
        """
        let mut version = "{self.major}.{self.minor}.{self.patch}"

        if not self.prerelease.is_empty():
            version += "-{self.prerelease}"

        if not self.build_metadata.is_empty():
            version += "+{self.build_metadata}"

        version

    pub fn bump_major(self): SemVer =
        """Bump major version.

        Returns:
            New version with major incremented

        Example:
            SemVer.new(1, 2, 3).bump_major()  # → 2.0.0
        """
        SemVer.new(self.major + 1, 0, 0)

    pub fn bump_minor(self): SemVer =
        """Bump minor version.

        Returns:
            New version with minor incremented

        Example:
            SemVer.new(1, 2, 3).bump_minor()  # → 1.3.0
        """
        SemVer.new(self.major, self.minor + 1, 0)

    pub fn bump_patch(self): SemVer =
        """Bump patch version.

        Returns:
            New version with patch incremented

        Example:
            SemVer.new(1, 2, 3).bump_patch()  # → 1.2.4
        """
        SemVer.new(self.major, self.minor, self.patch + 1)

# Version bump type
pub enum BumpType:
    Major
    Minor
    Patch
    PreRelease

# Version manager
pub class VersionManager:
    pub root: String
    pub current_version: SemVer
    pub verbose: bool

    pub fn new(root: String): VersionManager =
        """Create version manager.

        Args:
            root: Project root

        Returns:
            Version manager

        Example:
            let version = VersionManager.new(".")

            # Current version
            print("Current: {version.get_current()}")  # → "1.0.0"

            # Bump version
            version.bump(BumpType::Minor)  # → "1.1.0"

            # Update all version files
            version.sync_all([
                "Cargo.toml",
                "package.json",
                "pyproject.toml",
                "simple.sdn"
            ])
        """
        VersionManager {
            root: root,
            current_version: SemVer.new(0, 1, 0),
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn get_current(self): String =
        """Get current version.

        Returns:
            Current version string

        Example:
            let v = version.get_current()  # → "1.0.0"
        """
        self.current_version.to_string()

    pub fn bump(self, bump_type: BumpType): String =
        """Bump version.

        Args:
            bump_type: Type of bump

        Returns:
            New version string

        Example:
            version.bump(BumpType::Major)  # 1.0.0 → 2.0.0
            version.bump(BumpType::Minor)  # 1.0.0 → 1.1.0
            version.bump(BumpType::Patch)  # 1.0.0 → 1.0.1
        """
        self.current_version = match bump_type:
            BumpType::Major:
                self.current_version.bump_major()
            BumpType::Minor:
                self.current_version.bump_minor()
            BumpType::Patch:
                self.current_version.bump_patch()
            BumpType::PreRelease:
                # TODO: [stdlib][P1] Handle prerelease bumping
                self.current_version

        if self.verbose:
            print("Bumped version to {self.current_version.to_string()}")

        self.current_version.to_string()

    pub fn sync_all(self, files: List[String]): Result[(), String> =
        """Update version in all files.

        Args:
            files: List of version files

        Returns:
            Ok if successful

        Updates version in:
        - Cargo.toml: version = "1.0.0"
        - package.json: "version": "1.0.0"
        - pyproject.toml: version = "1.0.0"
        - simple.sdn: version: 1.0.0

        Example:
            version.sync_all([
                "Cargo.toml",
                "package.json",
                "simple.sdn"
            ])
        """
        let version_str = self.current_version.to_string()

        if self.verbose:
            print("Syncing version {version_str} to {files.len()} files")

        for file in files:
            match self.update_version_file(file, version_str):
                Ok(_):
                    if self.verbose:
                        print("Updated {file}")
                Err(err):
                    return Err("Failed to update {file}: {err}")

        Ok(())

    fn update_version_file(self, file: String, version: String): Result[(), String> =
        """Update version in single file.

        Args:
            file: File to update
            version: New version

        Returns:
            Ok if successful
        """
        # TODO: [stdlib][P3] Read file
        # TODO: [stdlib][P3] Update version line based on file type
        # TODO: [stdlib][P3] Write file back
        Ok(())

    pub fn validate(self, version: String): Result[(), String> =
        """Validate version string.

        Args:
            version: Version string

        Returns:
            Ok if valid SemVer

        Example:
            match version.validate("1.2.3"):
                Ok(_):
                    print("Valid version")
                Err(err):
                    print("Invalid: {err}")
        """
        match SemVer.parse(version):
            Ok(_):
                Ok(())
            Err(err):
                Err(err)
