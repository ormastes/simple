# Release Automation
# Automate the release process

use core.result.{Result, Ok, Err}

# FFI for process execution and file operations
@extern("runtime", "rt_process_run")
fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

@extern("runtime", "rt_file_size")
fn _rt_file_size(path_ptr: &u8, path_len: u64) -> i64

# Release type
pub enum ReleaseType:
    Major      # Breaking changes
    Minor      # New features
    Patch      # Bug fixes
    PreRelease # Alpha, beta, RC

    pub fn to_string(self): text =
        """Convert release type to string.

        Returns:
            Type name

        Example:
            ReleaseType::Major.to_string()  # → "major"
        """
        match self:
            ReleaseType::Major: "major"
            ReleaseType::Minor: "minor"
            ReleaseType::Patch: "patch"
            ReleaseType::PreRelease: "prerelease"

    pub fn description(self): text =
        """Get release type description.

        Returns:
            Human-readable description
        """
        match self:
            ReleaseType::Major: "Breaking changes"
            ReleaseType::Minor: "New features"
            ReleaseType::Patch: "Bug fixes"
            ReleaseType::PreRelease: "Alpha, beta, RC"

    pub fn is_breaking(self): bool =
        """Check if release contains breaking changes.

        Returns:
            True for major releases
        """
        match self:
            ReleaseType::Major: true
            ReleaseType::Minor: false
            ReleaseType::Patch: false
            ReleaseType::PreRelease: false

    pub fn version_component(self): text =
        """Get version component that changes.

        Returns:
            Version component name
        """
        match self:
            ReleaseType::Major: "major"
            ReleaseType::Minor: "minor"
            ReleaseType::Patch: "patch"
            ReleaseType::PreRelease: "prerelease"

    pub fn bump_version(self, current: text): text =
        """Bump version according to release type.

        Args:
            current: Current version (e.g., "1.2.3")

        Returns:
            New version

        Example:
            ReleaseType::Minor.bump_version("1.2.3")  # → "1.3.0"
        """
        val parts = current.split(".")
        if parts.len() < 3:
            return current

        val major = self.parse_int(parts[0])
        val minor = self.parse_int(parts[1])
        val patch = self.parse_int(parts[2])

        match self:
            ReleaseType::Major:
                "{major + 1}.0.0"
            ReleaseType::Minor:
                "{major}.{minor + 1}.0"
            ReleaseType::Patch:
                "{major}.{minor}.{patch + 1}"
            ReleaseType::PreRelease:
                "{major}.{minor}.{patch}-rc.1"

    fn parse_int(s: text): i32 =
        """Parse string to i32, returns 0 on error.

        Args:
            s: text to parse

        Returns:
            Integer value
        """
        val trimmed = s.trim()
        if trimmed.is_empty():
            return 0

        var result: i32 = 0
        for ch in trimmed.chars():
            if ch >= '0' and ch <= '9':
                val digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                break
        result

# Release artifact
pub class ReleaseArtifact:
    pub name: text
    pub path: text
    pub platform: text
    pub size_bytes: i64

    pub fn new(name: text, path: text, platform: text): ReleaseArtifact =
        """Create release artifact.

        Args:
            name: Artifact name
            path: File path
            platform: Platform (linux-amd64, darwin-arm64, etc.)

        Returns:
            Release artifact
        """
        ReleaseArtifact {
            name: name,
            path: path,
            platform: platform,
            size_bytes: _rt_file_size(path.ptr(), path.len())
        }

    pub fn size_mb(self): f64 =
        """Get size in megabytes.

        Returns:
            Size in MB
        """
        (self.size_bytes as f64) / (1024.0 * 1024.0)

    pub fn get_extension(self): text =
        """Get file extension from path.

        Returns:
            File extension (e.g., ".tar.gz")

        Example:
            # path = "app-1.0.0.tar.gz"
            artifact.get_extension()  # → ".tar.gz"
        """
        if self.path.contains(".tar.gz"):
            return ".tar.gz"
        elif self.path.contains("."):
            val last_dot = self.path.rfind(".")
            if last_dot >= 0:
                return self.path[last_dot:]
        ""

    pub fn parse_platform(self): (text, text) =
        """Parse platform into OS and architecture.

        Returns:
            Tuple of (os, arch)

        Example:
            # platform = "linux-amd64"
            artifact.parse_platform()  # → ("linux", "amd64")

            # platform = "darwin-arm64"
            artifact.parse_platform()  # → ("darwin", "arm64")
        """
        if self.platform.contains("-"):
            val parts = self.platform.split("-")
            if parts.len() >= 2:
                return (parts[0], parts[1])
        (self.platform, "unknown")

    pub fn has_size(self): bool =
        """Check if artifact has size information.

        Returns:
            True if size_bytes > 0
        """
        self.size_bytes > 0

    pub fn is_compressed(self): bool =
        """Check if artifact appears to be compressed.

        Returns:
            True for .gz, .zip, .tar.gz extensions
        """
        val ext = self.get_extension()
        ext.contains(".gz") or ext.contains(".zip") or ext.contains(".xz")

    pub fn summary(self): text =
        """Get artifact summary.

        Returns:
            Human-readable summary

        Example:
            artifact.summary()
            # → "app-linux-amd64.tar.gz (5.2 MB, linux-amd64)"
        """
        "{self.name} ({self.size_mb():.1f} MB, {self.platform})"

# Release configuration
pub class ReleaseConfig:
    pub version: text
    pub release_type: ReleaseType
    pub title: text
    pub draft: bool
    pub prerelease: bool
    pub platforms: List<text>

    pub fn new(version: text): ReleaseConfig =
        """Create release configuration.

        Args:
            version: Release version

        Returns:
            Release config
        """
        ReleaseConfig {
            version: version,
            release_type: ReleaseType::Patch,
            title: "Release {version}",
            draft: false,
            prerelease: false,
            platforms: ["linux", "macos", "windows"]
        }

    pub fn validate(self): Result<(), text> =
        """Validate release configuration.

        Returns:
            Ok if valid, Err otherwise

        Checks:
        - Version is not empty
        - Version follows semver format
        - At least one platform
        """
        if self.version == "":
            return Err("Version is required")

        if not self.is_valid_version(self.version):
            return Err("Invalid version format (use semver: X.Y.Z)")

        if self.platforms.len() == 0:
            return Err("At least one platform is required")

        Ok(())

    fn is_valid_version(version: text): bool =
        """Check if version follows basic semver format.

        Args:
            version: Version string

        Returns:
            True if valid

        Accepts: X.Y.Z or vX.Y.Z
        """
        val v = if version.starts_with("v"):
            version[1:]
        else:
            version

        val parts = v.split(".")
        parts.len() >= 3

    pub fn add_platform(self, platform: text):
        """Add target platform.

        Args:
            platform: Platform name
        """
        self.platforms.append(platform)

    pub fn set_as_draft(self):
        """Mark release as draft."""
        self.draft = true

    pub fn set_as_prerelease(self):
        """Mark release as prerelease."""
        self.prerelease = true
        self.release_type = ReleaseType::PreRelease

    pub fn is_valid(self): bool =
        """Check if configuration is valid.

        Returns:
            True if validation passes
        """
        match self.validate():
            Ok(_): true
            Err(_): false

    pub fn is_draft(self): bool =
        """Check if release is a draft.

        Returns:
            True if draft flag is set
        """
        self.draft

    pub fn is_prerelease(self): bool =
        """Check if release is a prerelease.

        Returns:
            True if prerelease flag is set
        """
        self.prerelease

    pub fn get_platform_count(self): i32 =
        """Get number of target platforms.

        Returns:
            Platform count
        """
        self.platforms.len()

    pub fn has_platforms(self): bool =
        """Check if platforms are configured.

        Returns:
            True if platforms exist
        """
        self.platforms.len() > 0

    pub fn summary(self): text =
        """Get configuration summary.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # → "Release 1.0.0: patch (3 platforms, draft: false, prerelease: false)"
        """
        val draft_str = if self.draft: "true" else: "false"
        val pre_str = if self.prerelease: "true" else: "false"
        "Release {self.version}: {self.release_type.to_string()} ({self.get_platform_count()} platforms, draft: {draft_str}, prerelease: {pre_str})"

# Release automation
pub class ReleaseAutomation:
    pub repo: text
    pub verbose: bool

    pub fn new(): ReleaseAutomation =
        """Create release automation.

        Returns:
            Release automation instance

        Example:
            val release = ReleaseAutomation.new()

            release.set_version("1.0.0")
            release.generate_changelog("v0.9.0..HEAD")
            release.create_git_tag()
            release.build_artifacts(platforms: ["linux", "macos", "windows"])
            release.create_github_release(
                repo: "user/my-app",
                title: "Release 1.0.0",
                draft: false
            )
            release.upload_artifacts()
            release.notify_slack("#releases", "Released v1.0.0!")

            print("✓ Release 1.0.0 complete")
        """
        ReleaseAutomation {
            repo: "",
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn is_verbose(self): bool =
        """Check if verbose logging is enabled.

        Returns:
            True if verbose mode is on
        """
        self.verbose

    pub fn with_verbose(self, enabled: bool): ReleaseAutomation =
        """Set verbose logging (fluent API).

        Args:
            enabled: Verbose flag

        Returns:
            Self for chaining

        Example:
            val release = ReleaseAutomation.new().with_verbose(true)
        """
        self.verbose = enabled
        self

    pub fn has_repo(self): bool =
        """Check if repository is configured.

        Returns:
            True if repo is set
        """
        not self.repo.is_empty()

    pub fn summary(self): text =
        """Get automation summary.

        Returns:
            Human-readable summary

        Example:
            release.summary()
            # → "ReleaseAutomation: user/repo (verbose: true)"
        """
        val verbose_str = if self.verbose: "true" else: "false"
        val repo_str = if self.has_repo(): self.repo else: "(no repo)"
        "ReleaseAutomation: {repo_str} (verbose: {verbose_str})"

    pub fn set_version(self, version: text):
        """Set release version.

        Args:
            version: Version string (e.g., "1.0.0")
        """
        if self.verbose:
            print("Setting version: {version}")

    pub fn generate_changelog(self, git_range: text): text =
        """Generate changelog from git commits.

        Args:
            git_range: Git range (e.g., "v0.9.0..HEAD")

        Returns:
            Changelog markdown

        Example:
            val changelog = release.generate_changelog("v0.9.0..HEAD")
            # → "## Changes\n- Add feature X\n- Fix bug Y\n..."
        """
        if self.verbose:
            print("Generating changelog for {git_range}")

        # Execute git log to get commits
        val cmd = "git"
        val args = "log --oneline {git_range}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code != 0:
            return "# Changelog\n\nNo commits found.\n"

        # Parse commits and categorize
        var features: List<text> = []
        var fixes: List<text> = []
        var other: List<text> = []

        for line in stdout.lines():
            if line.is_empty():
                continue
            if line.contains("feat:") or line.contains("feat("):
                features.append(line)
            elif line.contains("fix:") or line.contains("fix("):
                fixes.append(line)
            else:
                other.append(line)

        # Generate markdown
        var changelog = "# Changelog\n\n"

        if features.len() > 0:
            changelog += "## Features\n"
            for f in features:
                changelog += "- {f}\n"
            changelog += "\n"

        if fixes.len() > 0:
            changelog += "## Bug Fixes\n"
            for f in fixes:
                changelog += "- {f}\n"
            changelog += "\n"

        if other.len() > 0:
            changelog += "## Other Changes\n"
            for o in other:
                changelog += "- {o}\n"
            changelog += "\n"

        changelog

    pub fn create_git_tag(self, version: text, message: text): Result<(), text> =
        """Create git tag.

        Args:
            version: Tag version
            message: Tag message

        Returns:
            Ok if successful

        Example:
            release.create_git_tag("v1.0.0", "Release 1.0.0")
        """
        if self.verbose:
            print("Creating git tag: {version}")

        # Execute git tag command
        val cmd = "git"
        val args = "tag -a {version} -m \"{message}\""
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create git tag: {stderr}")

    pub fn build_artifacts(self, platforms: List<text>): List<ReleaseArtifact> =
        """Build artifacts for all platforms.

        Args:
            platforms: Target platforms

        Returns:
            Built artifacts

        Example:
            val artifacts = release.build_artifacts([
                "linux-amd64",
                "darwin-arm64",
                "windows-amd64"
            ])
        """
        if self.verbose:
            print("Building artifacts for {platforms.len()} platforms")

        val artifacts: List<ReleaseArtifact> = []

        for platform in platforms:
            if self.verbose:
                print("Building for {platform}...")

            # TODO: [stdlib][P3] Build for platform
            # Might use cross-compilation or build matrix
            val artifact = ReleaseArtifact.new(
                "app-{platform}",
                "target/{platform}/release/app",
                platform
            )
            artifacts.append(artifact)

        artifacts

    pub fn create_github_release(
        self,
        repo: text,
        title: text,
        draft: bool
    ): Result<(), text> =
        """Create GitHub release.

        Args:
            repo: Repository (org/name)
            title: Release title
            draft: Create as draft

        Returns:
            Ok if successful

        Example:
            release.create_github_release(
                repo: "user/my-app",
                title: "Release 1.0.0",
                draft: false
            )
        """
        if self.verbose:
            print("Creating GitHub release: {title}")

        self.repo = repo

        # Execute gh release create command
        val cmd = "gh"
        var args = "release create --title \"{title}\""
        if draft:
            args = args + " --draft"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create GitHub release: {stderr}")

    pub fn upload_artifacts(self, artifacts: List<ReleaseArtifact>): Result<(), text> =
        """Upload artifacts to GitHub release.

        Args:
            artifacts: Artifacts to upload

        Returns:
            Ok if successful

        Example:
            release.upload_artifacts(artifacts)
        """
        if self.verbose:
            print("Uploading {artifacts.len()} artifacts")

        for artifact in artifacts:
            if self.verbose:
                print("Uploading {artifact.name}...")

            # Execute gh release upload command
            val cmd = "gh"
            val args = "release upload latest {artifact.path}"
            val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

            if exit_code != 0:
                return Err("Failed to upload artifact {artifact.name}: {stderr}")

        Ok(())

    pub fn notify_slack(self, channel: text, message: text): Result<(), text> =
        """Send Slack notification.

        Args:
            channel: Slack channel
            message: Message to send

        Returns:
            Ok if successful

        Example:
            release.notify_slack("#releases", "Released v1.0.0!")
        """
        if self.verbose:
            print("Sending Slack notification to {channel}")

        # TODO: [stdlib][P3] HTTP POST to Slack webhook
        Ok(())

    pub fn notify_email(
        self,
        recipients: List<text>,
        subject: text,
        body: text
    ): Result<(), text> =
        """Send email notification.

        Args:
            recipients: Email addresses
            subject: Email subject
            body: Email body

        Returns:
            Ok if successful
        """
        if self.verbose:
            print("Sending email to {recipients.len()} recipients")

        # TODO: [stdlib][P3] Send email via SMTP
        Ok(())

    pub fn publish_to_registry(self, registry: text): Result<(), text> =
        """Publish package to registry.

        Args:
            registry: Registry type (npm, pypi, crates, etc.)

        Returns:
            Ok if successful

        Example:
            release.publish_to_registry("npm")
            release.publish_to_registry("pypi")
        """
        if self.verbose:
            print("Publishing to {registry}")

        match registry:
            "npm":
                val cmd = "npm"
                val args = "publish"
                val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())
                if exit_code == 0: Ok(()) else: Err("npm publish failed: {stderr}")
            "pypi":
                val cmd = "twine"
                val args = "upload dist/*"
                val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())
                if exit_code == 0: Ok(()) else: Err("twine upload failed: {stderr}")
            "crates":
                val cmd = "cargo"
                val args = "publish"
                val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())
                if exit_code == 0: Ok(()) else: Err("cargo publish failed: {stderr}")
            _:
                Err("Unknown registry: {registry}")
