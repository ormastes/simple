# Multi-Language Test Runner
# Run tests across all languages in a project

use tooling.core.project.{Language, ProjectContext, LanguageConfig}
use tooling.testing.discovery.{TestDiscovery, TestSuite}
use tooling.testing.aggregation.TestAggregator
use core.result.{Result, Ok, Err}

# Test run configuration
pub class TestConfig:
    pub parallel: bool
    pub fail_fast: bool
    pub verbose: bool
    pub coverage: bool
    pub timeout_seconds: i32
    pub filter_pattern: String

    pub fn new(): TestConfig =
        """Create default test configuration.

        Returns:
            Default test config
        """
        TestConfig {
            parallel: false,
            fail_fast: false,
            verbose: false,
            coverage: false,
            timeout_seconds: 300,  # 5 minutes
            filter_pattern: ""
        }

# Test run result
pub class TestRunResult:
    pub total_tests: i32
    pub passed: i32
    pub failed: i32
    pub skipped: i32
    pub duration_ms: i64
    pub failures: List[TestFailure]

    pub fn new(): TestRunResult =
        """Create empty test result."""
        TestRunResult {
            total_tests: 0,
            passed: 0,
            failed: 0,
            skipped: 0,
            duration_ms: 0,
            failures: []
        }

    pub fn is_success(self): bool =
        """Check if all tests passed.

        Returns:
            True if no failures
        """
        self.failed == 0

    pub fn summary(self): String =
        """Get result summary.

        Returns:
            Human-readable summary
        """
        if self.is_success():
            "âœ“ {self.passed}/{self.total_tests} tests passed in {self.duration_ms}ms"
        else:
            "âœ— {self.failed}/{self.total_tests} tests failed, {self.passed} passed, {self.skipped} skipped"

# Test failure
pub class TestFailure:
    pub test_name: String
    pub language: Language
    pub error_message: String
    pub file: String
    pub line: i32

    pub fn new(
        test_name: String,
        language: Language,
        error_message: String
    ): TestFailure =
        """Create test failure.

        Args:
            test_name: Name of failed test
            language: Test language
            error_message: Failure message

        Returns:
            Test failure instance
        """
        TestFailure {
            test_name: test_name,
            language: language,
            error_message: error_message,
            file: "",
            line: 0
        }

# Multi-language test runner
pub class TestRunner:
    pub project: ProjectContext
    pub config: TestConfig
    pub discovery: TestDiscovery

    pub fn new(root: String): TestRunner =
        """Create test runner for project.

        Args:
            root: Project root directory

        Returns:
            Test runner with auto-detected test suites

        Example:
            let runner = TestRunner.new(".")

            let result = runner.run_all(
                parallel: true,
                verbose: true
            )

            print(result.summary())
        """
        let project = ProjectContext.new(root)
        let discovery = TestDiscovery.new(root)

        TestRunner {
            project: project,
            config: TestConfig.new(),
            discovery: discovery
        }

    pub fn set_parallel(self, enabled: bool):
        """Enable parallel test execution.

        Args:
            enabled: True to run tests in parallel
        """
        self.config.parallel = enabled

    pub fn set_fail_fast(self, enabled: bool):
        """Enable fail-fast mode.

        Args:
            enabled: True to stop on first failure
        """
        self.config.fail_fast = enabled

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose output.

        Args:
            enabled: True for detailed logs
        """
        self.config.verbose = enabled

    pub fn set_coverage(self, enabled: bool):
        """Enable coverage collection.

        Args:
            enabled: True to collect coverage
        """
        self.config.coverage = enabled

    pub fn discover_tests(self): List[TestSuite] =
        """Discover all test suites in project.

        Returns:
            List of test suites

        Example:
            let runner = TestRunner.new(".")
            let suites = runner.discover_tests()

            for suite in suites:
                print("{suite.language}: {suite.test_count} tests")
        """
        self.discovery.discover_all()

    pub fn run_all(
        self,
        parallel: bool,
        fail_fast: bool,
        verbose: bool
    ): TestRunResult =
        """Run all tests in project.

        Args:
            parallel: Run tests in parallel
            fail_fast: Stop on first failure
            verbose: Enable verbose output

        Returns:
            Test run result

        Example:
            let result = runner.run_all(
                parallel: true,
                fail_fast: false,
                verbose: true
            )

            if result.is_success():
                print("All tests passed!")
            else:
                for failure in result.failures:
                    print("Failed: {failure.test_name}")
                    print("  {failure.error_message}")
        """
        self.config.parallel = parallel
        self.config.fail_fast = fail_fast
        self.config.verbose = verbose

        let result = TestRunResult.new()
        let start_time = 0  # TODO: [stdlib][P3] Get current time

        if verbose:
            print("Running tests...")

        # Discover test suites
        let suites = self.discover_tests()

        if verbose:
            print("Found {suites.len()} test suites")

        # Run each test suite
        for suite in suites:
            if verbose:
                print("Running {suite.language} tests...")

            let suite_result = self.run_suite(suite)

            # Aggregate results
            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

            # Fail fast
            if fail_fast and suite_result.failed > 0:
                break

        let end_time = 0  # TODO: [stdlib][P3] Get current time
        result.duration_ms = end_time - start_time

        if verbose:
            print(result.summary())

        result

    fn run_suite(self, suite: TestSuite): TestRunResult =
        """Run single test suite.

        Args:
            suite: Test suite to run

        Returns:
            Test result for suite
        """
        match suite.language:
            Language::Simple:
                self.run_simple_tests(suite)
            Language::Rust:
                self.run_rust_tests(suite)
            Language::Python:
                self.run_python_tests(suite)
            Language::JavaScript:
                self.run_javascript_tests(suite)
            Language::TypeScript:
                self.run_javascript_tests(suite)  # Same runner
            _:
                # Unsupported language
                TestRunResult.new()

    fn run_simple_tests(self, suite: TestSuite): TestRunResult =
        """Run Simple language tests.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        # TODO: [stdlib][P3] Execute Simple spec framework tests
        TestRunResult.new()

    fn run_rust_tests(self, suite: TestSuite): TestRunResult =
        """Run Rust tests via cargo test.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        # Build command: cargo test --manifest-path {suite.path}
        # TODO: [stdlib][P2] Execute and parse output
        TestRunResult.new()

    fn run_python_tests(self, suite: TestSuite): TestRunResult =
        """Run Python tests via pytest.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        # Build command: pytest {suite.path} --json-report
        # TODO: [stdlib][P2] Execute and parse JSON output
        TestRunResult.new()

    fn run_javascript_tests(self, suite: TestSuite): TestRunResult =
        """Run JavaScript tests via jest.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        # Build command: jest {suite.path} --json
        # TODO: [stdlib][P2] Execute and parse JSON output
        TestRunResult.new()

    pub fn run_by_language(self, language: Language): TestRunResult =
        """Run tests for specific language.

        Args:
            language: Language to run tests for

        Returns:
            Test result
        """
        let suites = self.discovery.discover_by_language(language)
        let result = TestRunResult.new()

        for suite in suites:
            let suite_result = self.run_suite(suite)

            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

        result

    pub fn run_by_pattern(self, pattern: String): TestRunResult =
        """Run tests matching pattern.

        Args:
            pattern: Test name pattern

        Returns:
            Test result
        """
        let suites = self.discovery.discover_by_pattern(pattern)
        let result = TestRunResult.new()

        for suite in suites:
            let suite_result = self.run_suite(suite)

            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

        result
