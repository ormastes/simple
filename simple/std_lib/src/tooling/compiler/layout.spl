//! Memory layout calculations for struct types
//!
//! Implements C ABI layout rules:
//! - Fields aligned to natural alignment
//! - Struct padded to largest member alignment
//! - vtable pointer (if present) at offset 0
//!
//! Lean-friendly: Pure alignment and padding calculations

use tooling.compiler.types_util

/// Field layout information
struct FieldLayout:
    name: text
    ty: TypeId
    offset: u32
    size: u32

impl FieldLayout:
    fn to_string() -> text:
        "{self.name}: offset={self.offset}, size={self.size}"

/// Struct memory layout
///
/// Layout follows C ABI rules for zero-cost field access.
struct StructLayout:
    name: text
    fields: List<FieldLayout>
    size: u32
    alignment: u8
    has_vtable: bool
    type_id: u32

impl StructLayout:
    /// Create new struct layout with computed offsets
    ///
    /// Uses C ABI rules:
    /// - vtable pointer is 8 bytes at offset 0 (if present)
    /// - Fields aligned to natural alignment
    /// - Padding inserted for alignment
    /// - Struct padded to alignment boundary
    static fn new(
        name: text,
        fields: List<(text, TypeId)>,
        has_vtable: bool,
        type_id: u32
    ) -> StructLayout:
        var field_layouts = []
        var current_offset = if has_vtable: 8 else: 0  # vtable ptr is 8 bytes
        var max_align: u8 = if has_vtable: 8 else: 1

        # Compute field offsets and sizes
        for (field_name, field_ty) in fields:
            val (size, align) = StructLayout.type_size_align(field_ty)

            # Align current offset
            val align_u32 = align as u32
            val padding = (align_u32 - (current_offset % align_u32)) % align_u32
            current_offset = current_offset + padding

            # Add field layout
            field_layouts.push(FieldLayout(
                name: field_name,
                ty: field_ty,
                offset: current_offset,
                size: size
            ))

            current_offset = current_offset + size
            max_align = if align > max_align: align else: max_align

        # Pad struct to alignment
        val max_align_u32 = max_align as u32
        val final_padding = (max_align_u32 - (current_offset % max_align_u32)) % max_align_u32
        val total_size = current_offset + final_padding

        StructLayout(
            name: name,
            fields: field_layouts,
            size: total_size,
            alignment: max_align,
            has_vtable: has_vtable,
            type_id: type_id
        )

    /// Get size and alignment for a type (C ABI rules)
    ///
    /// Returns (size, alignment) tuple.
    /// Matches C struct layout conventions.
    static fn type_size_align(ty: TypeId) -> (u32, u8):
        if ty.equals(TypeId.VOID()):
            (0, 1)
        else if ty.equals(TypeId.BOOL()) or ty.equals(TypeId.I8()) or ty.equals(TypeId.U8()):
            (1, 1)
        else if ty.equals(TypeId.I16()) or ty.equals(TypeId.U16()):
            (2, 2)
        else if ty.equals(TypeId.I32()) or ty.equals(TypeId.U32()):
            (4, 4)
        else if ty.equals(TypeId.F32()):
            (4, 4)
        else if ty.equals(TypeId.I64()) or ty.equals(TypeId.U64()):
            (8, 8)
        else if ty.equals(TypeId.F64()):
            (8, 8)
        else if ty.equals(TypeId.STRING()) or ty.equals(TypeId.NIL()):
            (8, 8)  # Pointers
        else:
            (8, 8)  # Default to pointer size for custom types

    /// Get field offset by index (O(1))
    fn field_offset(index: u32) -> u32?:
        if index < self.fields.len():
            Some(self.fields[index].offset)
        else:
            None

    /// Get field offset by name (O(n))
    fn field_offset_by_name(name: text) -> u32?:
        for field in self.fields:
            if field.name == name:
                return Some(field.offset)
        None

    /// Get field index by name
    fn field_index(name: text) -> u32?:
        var idx: u32 = 0
        for field in self.fields:
            if field.name == name:
                return Some(idx)
            idx = idx + 1
        None

    fn to_string() -> text:
        "StructLayout({self.name}, size={self.size}, align={self.alignment})"

/// Registry of struct layouts
///
/// Manages layout information for all struct types in a module.
struct LayoutRegistry:
    layouts: Map<u32, StructLayout>     # TypeId -> StructLayout
    name_to_type: Map<text, u32>        # name -> TypeId
    next_type_id: u32

impl LayoutRegistry:
    static fn new() -> LayoutRegistry:
        LayoutRegistry(
            layouts: Map.new(),
            name_to_type: Map.new(),
            next_type_id: 0
        )

    /// Register a struct layout and return runtime type ID
    me register(type_id: u32, layout: StructLayout) -> u32:
        val runtime_id = self.next_type_id
        self.next_type_id = self.next_type_id + 1
        self.name_to_type = self.name_to_type.insert(layout.name, type_id)
        self.layouts = self.layouts.insert(type_id, layout)
        runtime_id

    /// Get layout for a type ID
    fn get(type_id: u32) -> StructLayout?:
        self.layouts.get(type_id)

    /// Get layout by struct name
    fn get_by_name(name: text) -> StructLayout?:
        match self.name_to_type.get(name):
            Some(type_id):
                self.layouts.get(type_id)
            None:
                None

    fn count() -> u32:
        self.layouts.size()
