# Multi-Language Compiler Interface
# Unified compilation interface for multiple programming languages

use tooling.core.project.{Language, LanguageConfig}
use core.result.{Result, Ok, Err}

# Compilation mode
pub enum CompilationMode:
    Debug
    Release
    Profile

# Compilation result
pub class CompilationResult:
    pub success: bool
    pub artifacts: List[Artifact]
    pub errors: List[CompilationError]
    pub warnings: List[CompilationError]
    pub duration_ms: i64

    pub fn new(): CompilationResult =
        """Create empty compilation result."""
        CompilationResult {
            success: true,
            artifacts: [],
            errors: [],
            warnings: [],
            duration_ms: 0
        }

    pub fn is_ok(self): bool =
        """Check if compilation succeeded.

        Returns:
            True if no errors
        """
        self.errors.len() == 0

    pub fn add_error(self, error: CompilationError):
        """Add compilation error.

        Args:
            error: Error to add
        """
        self.errors.append(error)
        self.success = false

    pub fn add_warning(self, warning: CompilationError):
        """Add compilation warning.

        Args:
            warning: Warning to add
        """
        self.warnings.append(warning)

    pub fn add_artifact(self, artifact: Artifact):
        """Add build artifact.

        Args:
            artifact: Artifact to add
        """
        self.artifacts.append(artifact)

# Build artifact
pub class Artifact:
    pub path: String
    pub artifact_type: ArtifactType
    pub size_bytes: i64
    pub language: Language

    pub fn new(path: String, artifact_type: ArtifactType, language: Language): Artifact =
        """Create build artifact.

        Args:
            path: Path to artifact file
            artifact_type: Type of artifact
            language: Source language

        Returns:
            Artifact instance
        """
        Artifact {
            path: path,
            artifact_type: artifact_type,
            size_bytes: 0,  # File size could be queried but not critical
            language: language
        }

    pub fn get_extension(self): String =
        """Get artifact file extension.

        Returns:
            File extension

        Examples:
        - Executable: "" (Unix) or ".exe" (Windows)
        - Library: ".so" (Unix) or ".dll" (Windows)
        - StaticLibrary: ".a" (Unix) or ".lib" (Windows)
        - Object: ".o"
        - Archive: ".tar.gz", ".zip"
        """
        match self.artifact_type:
            ArtifactType::Executable:
                self.get_executable_extension()
            ArtifactType::Library:
                self.get_library_extension()
            ArtifactType::StaticLibrary:
                self.get_static_lib_extension()
            ArtifactType::Object:
                ".o"
            ArtifactType::Archive:
                ".tar.gz"
            ArtifactType::Package:
                self.get_package_extension()

    fn get_executable_extension(self): String =
        """Get executable extension for platform."""
        # Platform-specific, default to Unix
        ""

    fn get_library_extension(self): String =
        """Get shared library extension for platform."""
        ".so"

    fn get_static_lib_extension(self): String =
        """Get static library extension for platform."""
        ".a"

    fn get_package_extension(self): String =
        """Get package extension based on language."""
        match self.language:
            Language::Rust: ".crate"
            Language::Python: ".whl"
            Language::JavaScript: ".tgz"
            Language::Go: ".tar.gz"
            _: ".tar.gz"

# Artifact type
pub enum ArtifactType:
    Executable
    Library
    StaticLibrary
    Object
    Archive
    Package

# Compilation error/warning
pub class CompilationError:
    pub file: String
    pub line: i32
    pub column: i32
    pub message: String
    pub severity: ErrorSeverity
    pub code: String
    pub language: Language

    pub fn new(
        file: String,
        line: i32,
        column: i32,
        message: String,
        severity: ErrorSeverity,
        language: Language
    ): CompilationError =
        """Create compilation error.

        Args:
            file: Source file with error
            line: Line number (1-indexed)
            column: Column number (1-indexed)
            message: Error message
            severity: Error severity
            language: Source language

        Returns:
            Compilation error instance
        """
        CompilationError {
            file: file,
            line: line,
            column: column,
            message: message,
            severity: severity,
            code: "",
            language: language
        }

    pub fn format(self): String =
        """Format error for display.

        Returns:
            Formatted error string

        Example:
            src/main.rs:10:5: error: expected expression
        """
        let severity_str = match self.severity:
            ErrorSeverity::Error: "error"
            ErrorSeverity::Warning: "warning"
            ErrorSeverity::Info: "info"

        "{self.file}:{self.line}:{self.column}: {severity_str}: {self.message}"

# Error severity
pub enum ErrorSeverity:
    Error
    Warning
    Info

# Language compiler interface (adapter pattern)
pub trait LanguageCompiler:
    """Interface for language-specific compilers.

    Each language (Simple, Rust, Python, etc.) implements this trait
    to provide unified compilation interface.
    """

    fn compile(
        self,
        config: LanguageConfig,
        mode: CompilationMode,
        incremental: bool
    ): CompilationResult

    fn get_language(self): Language

    fn supports_incremental(self): bool

    fn get_executable_extension(self): String

    fn get_library_extension(self): String

# Compiler registry - manages language-specific compilers
pub class CompilerRegistry:
    pub compilers: Dict[Language, LanguageCompiler]

    pub fn new(): CompilerRegistry =
        """Create compiler registry."""
        CompilerRegistry {
            compilers: {}
        }

    pub fn register(self, language: Language, compiler: LanguageCompiler):
        """Register language compiler.

        Args:
            language: Language to register
            compiler: Compiler implementation

        Example:
            let registry = CompilerRegistry.new()
            registry.register(Language::Simple, SimpleCompiler.new())
            registry.register(Language::Rust, RustCompiler.new())
        """
        self.compilers[language] = compiler

    pub fn get_compiler(self, language: Language): LanguageCompiler? =
        """Get compiler for language.

        Args:
            language: Language to get compiler for

        Returns:
            Compiler if registered
        """
        self.compilers.get(language)

    pub fn has_compiler(self, language: Language): bool =
        """Check if compiler is registered.

        Args:
            language: Language to check

        Returns:
            True if compiler is available
        """
        self.compilers.contains_key(language)

# Multi-language compiler orchestrator
pub class MultiLanguageCompiler:
    pub registry: CompilerRegistry
    pub mode: CompilationMode
    pub incremental: bool
    pub parallel: bool

    pub fn new(): MultiLanguageCompiler =
        """Create multi-language compiler.

        Returns:
            Compiler with default settings

        Example:
            let compiler = MultiLanguageCompiler.new()
            compiler.set_mode(CompilationMode::Release)
            compiler.set_parallel(true)
        """
        let registry = CompilerRegistry.new()

        MultiLanguageCompiler {
            registry: registry,
            mode: CompilationMode::Debug,
            incremental: false,
            parallel: false
        }

    pub fn set_mode(self, mode: CompilationMode):
        """Set compilation mode.

        Args:
            mode: Debug, Release, or Profile
        """
        self.mode = mode

    pub fn set_incremental(self, enabled: bool):
        """Enable/disable incremental compilation.

        Args:
            enabled: True to enable incremental builds
        """
        self.incremental = enabled

    pub fn set_parallel(self, enabled: bool):
        """Enable/disable parallel compilation.

        Args:
            enabled: True to compile languages in parallel
        """
        self.parallel = enabled

    pub fn compile_all(self, languages: List[LanguageConfig]): CompilationResult =
        """Compile all languages.

        Args:
            languages: List of language configurations to compile

        Returns:
            Combined compilation result

        Example:
            let compiler = MultiLanguageCompiler.new()
            let result = compiler.compile_all(project.languages)

            if result.is_ok():
                print("âœ“ Built {result.artifacts.len()} artifacts")
            else:
                for error in result.errors:
                    print(error.format())
        """
        let combined = CompilationResult.new()
        let start_time = 0  # TODO: [stdlib][P3] Get current time

        for lang_config in languages:
            let compiler = self.registry.get_compiler(lang_config.language)

            match compiler:
                some(c):
                    let result = c.compile(lang_config, self.mode, self.incremental)

                    # Merge results
                    combined.artifacts.extend(result.artifacts)
                    combined.errors.extend(result.errors)
                    combined.warnings.extend(result.warnings)

                    if not result.is_ok():
                        combined.success = false
                none:
                    let error = CompilationError.new(
                        file: "",
                        line: 0,
                        column: 0,
                        message: "No compiler registered for {lang_config.language}",
                        severity: ErrorSeverity::Error,
                        language: lang_config.language
                    )
                    combined.add_error(error)

        let end_time = 0  # TODO: [stdlib][P3] Get current time
        combined.duration_ms = end_time - start_time

        combined

    pub fn compile_single(
        self,
        language: Language,
        config: LanguageConfig
    ): CompilationResult =
        """Compile single language.

        Args:
            language: Language to compile
            config: Language configuration

        Returns:
            Compilation result
        """
        match self.registry.get_compiler(language):
            some(compiler):
                compiler.compile(config, self.mode, self.incremental)
            none:
                let result = CompilationResult.new()
                let error = CompilationError.new(
                    file: "",
                    line: 0,
                    column: 0,
                    message: "No compiler registered for {language}",
                    severity: ErrorSeverity::Error,
                    language: language
                )
                result.add_error(error)
                result
