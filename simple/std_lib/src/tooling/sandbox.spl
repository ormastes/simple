# Sandboxing Configuration for Simple CLI
# Migrated from: src/driver/src/cli/sandbox.rs
# Purpose: Parse sandbox configuration from command-line arguments

# Parse string to u64 using our parse_utils
use super.parse_utils.parse_int

fn str_to_u64(s: text) -> Result<u64, text>:
    match parse_int(s):
        Some(num) =>
            if num >= 0:
                Ok(num as u64)
            else:
                Err("Negative number not valid for u64")
        None =>
            Err("Invalid number format")

# Sandbox configuration structure
# Maps to SandboxConfig in runtime (will use FFI when available)
struct SandboxConfig:
    time_limit_secs: Option<u64>
    memory_limit_bytes: Option<u64>
    fd_limit: Option<u64>
    thread_limit: Option<u64>
    no_network: bool
    network_allowlist: List<text>
    network_blocklist: List<text>
    read_paths: List<text>
    write_paths: List<text>

impl SandboxConfig:
    # Create a new empty sandbox configuration
    static fn new() -> SandboxConfig:
        SandboxConfig(
            time_limit_secs: None,
            memory_limit_bytes: None,
            fd_limit: None,
            thread_limit: None,
            no_network: false,
            network_allowlist: [],
            network_blocklist: [],
            read_paths: [],
            write_paths: []
        )

    # Set CPU time limit in seconds
    fn with_cpu_time(secs: u64) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs: Some(secs),
            memory_limit_bytes,
            fd_limit,
            thread_limit,
            no_network,
            network_allowlist,
            network_blocklist,
            read_paths,
            write_paths
        )

    # Set memory limit in bytes
    fn with_memory(bytes: u64) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes: Some(bytes),
            fd_limit,
            thread_limit,
            no_network,
            network_allowlist,
            network_blocklist,
            read_paths,
            write_paths
        )

    # Set file descriptor limit
    fn with_file_descriptors(count: u64) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes,
            fd_limit: Some(count),
            thread_limit,
            no_network,
            network_allowlist,
            network_blocklist,
            read_paths,
            write_paths
        )

    # Set thread limit
    fn with_threads(count: u64) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes,
            fd_limit,
            thread_limit: Some(count),
            no_network,
            network_allowlist,
            network_blocklist,
            read_paths,
            write_paths
        )

    # Disable network access
    fn with_no_network() -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes,
            fd_limit,
            thread_limit,
            no_network: true,
            network_allowlist,
            network_blocklist,
            read_paths,
            write_paths
        )

    # Set network allowlist (comma-separated domains)
    fn with_network_allowlist(domains: List<text>) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes,
            fd_limit,
            thread_limit,
            no_network,
            network_allowlist: domains,
            network_blocklist,
            read_paths,
            write_paths
        )

    # Set network blocklist (comma-separated domains)
    fn with_network_blocklist(domains: List<text>) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes,
            fd_limit,
            thread_limit,
            no_network,
            network_allowlist,
            network_blocklist: domains,
            read_paths,
            write_paths
        )

    # Set read-only paths
    fn with_read_paths(paths: List<text>) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes,
            fd_limit,
            thread_limit,
            no_network,
            network_allowlist,
            network_blocklist,
            read_paths: paths,
            write_paths
        )

    # Set restricted paths (both read and write)
    fn with_restricted_paths(read: List<text>, write: List<text>) -> SandboxConfig:
        SandboxConfig(
            time_limit_secs,
            memory_limit_bytes,
            fd_limit,
            thread_limit,
            no_network,
            network_allowlist,
            network_blocklist,
            read_paths: read,
            write_paths: write
        )

# Parse memory size from string (supports K, M, G suffixes)
# Examples: "1024", "512K", "2M", "1G"
fn parse_memory_size(s: text) -> Result<u64, text>:
    val trimmed = s.trim()

    # Determine multiplier based on suffix
    var num_str = trimmed
    var multiplier: u64 = 1

    if trimmed.ends_with("G") or trimmed.ends_with("g"):
        num_str = trimmed.slice(0, trimmed.len() - 1)
        multiplier = 1024 * 1024 * 1024
    elif trimmed.ends_with("M") or trimmed.ends_with("m"):
        num_str = trimmed.slice(0, trimmed.len() - 1)
        multiplier = 1024 * 1024
    elif trimmed.ends_with("K") or trimmed.ends_with("k"):
        num_str = trimmed.slice(0, trimmed.len() - 1)
        multiplier = 1024

    # Parse the numeric part
    match str_to_u64(num_str):
        Ok(n): Ok(n * multiplier)
        Err(e): Err("invalid memory size '{s}': {e}")

# Helper: Check if argument is a sandbox flag
fn is_sandbox_flag(a: text) -> bool:
    if a == "--sandbox" or a == "--no-network":
        return true
    if a.starts_with("--time-limit") or a.starts_with("--memory-limit"):
        return true
    if a.starts_with("--fd-limit") or a.starts_with("--thread-limit"):
        return true
    if a.starts_with("--network-allow") or a.starts_with("--network-block"):
        return true
    if a.starts_with("--read-only") or a.starts_with("--read-write"):
        return true
    false

# Parse sandbox configuration from command-line arguments
fn parse_sandbox_config(args: List<text>) -> Option<SandboxConfig>:
    # Check if any sandbox flags are present
    val has_sandbox_flag = args.any(\a: is_sandbox_flag(a))

    if not has_sandbox_flag:
        return None

    var config = SandboxConfig.new()

    # Parse resource limits
    var i = 0
    while i < args.len():
        val arg = args[i]

        if arg == "--time-limit" and i + 1 < args.len():
            match str_to_u64(args[i + 1]):
                Ok(secs):
                    config = config.with_cpu_time(secs)
                Err(_):
                    pass
        elif arg == "--memory-limit" and i + 1 < args.len():
            match parse_memory_size(args[i + 1]):
                Ok(bytes): config = config.with_memory(bytes)
                Err(_): pass
        elif arg == "--fd-limit" and i + 1 < args.len():
            match str_to_u64(args[i + 1]):
                Ok(count): config = config.with_file_descriptors(count)
                Err(_): pass
        elif arg == "--thread-limit" and i + 1 < args.len():
            match str_to_u64(args[i + 1]):
                Ok(count): config = config.with_threads(count)
                Err(_): pass
        elif arg == "--no-network":
            config = config.with_no_network()
        elif arg == "--network-allow" and i + 1 < args.len():
            val domains = args[i + 1].split(",").map(\s: s.trim()).collect()
            config = config.with_network_allowlist(domains)
        elif arg == "--network-block" and i + 1 < args.len():
            val domains = args[i + 1].split(",").map(\s: s.trim()).collect()
            config = config.with_network_blocklist(domains)
        elif arg == "--read-only" and i + 1 < args.len():
            val paths = args[i + 1].split(",").map(\s: s.trim()).collect()
            config = config.with_read_paths(paths)
        elif arg == "--read-write" and i + 1 < args.len():
            val paths = args[i + 1].split(",").map(\s: s.trim()).collect()
            config = config.with_restricted_paths(paths.clone(), paths)

        i = i + 1

    Some(config)

# Apply sandbox configuration to the current process
# TODO: [runtime][P1] Implement FFI binding to simple_runtime::apply_sandbox()
# Requires:
# - Complex struct marshalling (SandboxConfig with nested structs/enums)
# - Two approaches possible:
#   1. Serialize to JSON/msgpack and deserialize in Rust
#   2. Create builder-style FFI functions to construct config piece by piece
# - Reference: src/runtime/src/sandbox/mod.rs::apply_sandbox()
fn apply_sandbox(config: SandboxConfig) -> Result<(), text>:
    # Stub: Will be implemented when struct marshalling is available
    # In production, this would call: simple_runtime::apply_sandbox(&config)
    Ok(())
