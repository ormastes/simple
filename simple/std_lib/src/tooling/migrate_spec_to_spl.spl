# Simple Language Spec Migration Tool - markdown to spl
# Migrated from: scripts/migrate_spec_to_spl.py
# Purpose: Convert doc/spec/*.md to tests/specs/*_spec.spl

# TODO: [stdlib][P1] Add regex library to Simple
# TODO: [stdlib][P1] Add markdown parsing library

import fs.{read_text, write_text}

# Migration statistics
struct SpecMigrationStats:
    files_processed: u64
    files_migrated: u64
    examples_extracted: u64

impl SpecMigrationStats:
    # Create empty stats
    static fn new() -> SpecMigrationStats:
        SpecMigrationStats(0, 0, 0)

    # Record processed file
    me add_processed():
        self.files_processed = self.files_processed + 1

    # Record migrated file
    me add_migrated(examples: u64):
        self.files_migrated = self.files_migrated + 1
        self.examples_extracted = self.examples_extracted + examples

    # Generate summary report
    fn summary() -> text:
        var report = ""
        report = report + "=== Spec Migration Complete ===\n"
        report = report + "Files processed: {self.files_processed}\n"
        report = report + "Files migrated: {self.files_migrated}\n"
        report = report + "Examples extracted: {self.examples_extracted}\n"
        report

# Spec metadata
struct SpecMetadata:
    status: text
    feature_ids: text
    keywords: text
    last_updated: text
    topics: text

impl SpecMetadata:
    # Create empty metadata
    static fn new() -> SpecMetadata:
        SpecMetadata("Draft", "", "", "", "")

# Code example from markdown
struct CodeExample:
    context: text
    code: text
    section: text

impl CodeExample:
    # Create code example
    static fn new(context: text, code: text, section: text) -> CodeExample:
        CodeExample(context, code, section)

# Category A file mapping
struct CategoryAFile:
    md_file: text
    spl_file: text
    feature_ids: text

impl CategoryAFile:
    # Create file mapping
    static fn new(md: text, spl: text, ids: text) -> CategoryAFile:
        CategoryAFile(md, spl, ids)

# Get Category A files for migration
fn get_category_a_files() -> List<CategoryAFile>:
    [
        CategoryAFile.new("syntax.md", "syntax_spec.spl", "#10-19"),
        CategoryAFile.new("types.md", "types_spec.spl", "#20-29"),
        CategoryAFile.new("type_inference.md", "type_inference_spec.spl", "#13"),
        CategoryAFile.new("async_default.md", "async_default_spec.spl", "#276-285"),
        CategoryAFile.new("suspension_operator.md", "suspension_operator_spec.spl", "#270-275"),
        CategoryAFile.new("capability_effects.md", "capability_effects_spec.spl", "#880-884"),
        CategoryAFile.new("sandboxing.md", "sandboxing_spec.spl", "#916-923")
    ]

# TODO: [stdlib][P1] Add regex and markdown parsing
# Extract metadata from markdown
fn extract_metadata(md_content: text) -> SpecMetadata:
    # Stub: Needs regex to extract frontmatter
    # Would extract:
    # - **Status:** ...
    # - **Feature IDs:** ...
    # - **Keywords:** ...
    # - **Last Updated:** ...
    # - **Topics:** ...
    SpecMetadata.new()

# TODO: [stdlib][P1] Add regex
# Extract title from markdown
fn extract_title(md_content: text) -> text:
    # Stub: Needs regex to extract first heading
    # Pattern: r'^#\s+(.+)'
    # Would remove feature IDs: r'\s*\(#[\d-]+\)'
    "Untitled Specification"

# TODO: [stdlib][P1] Add regex
# Extract overview section
fn extract_overview(md_content: text) -> text:
    # Stub: Needs regex to extract overview
    # Pattern: r'##\s+Overview\s*\n+(.*?)(?=\n##|\Z)'
    # Fallback to first paragraph after frontmatter
    "TODO: Add overview from markdown"

# TODO: [stdlib][P1] Add regex
# Extract code examples from markdown
fn extract_code_examples(md_content: text) -> List<CodeExample>:
    # Stub: Needs regex to extract code blocks
    # Pattern: r'```simple\n(.*?)```'
    # Would:
    # 1. Split by sections (## headings)
    # 2. Find code blocks in each section
    # 3. Extract context (paragraph before code)
    # 4. Clean markdown formatting
    # 5. Return list of examples
    []

# Generate _spec.spl content
fn generate_spec_spl(
    md_path: text,
    spl_path: text,
    metadata: SpecMetadata,
    title: text,
    overview: text,
    examples: List<CodeExample>
) -> text:
    # Stub: Needs string building and formatting
    # Would:
    # 1. Build header docstring with metadata
    # 2. Add overview section
    # 3. Add test cases from examples
    # 4. Format with proper indentation
    ""

# Migrate single spec file
# TODO: [stdlib][P1] Needs regex and markdown parsing for full implementation
fn migrate_spec_file(md_path: text, spl_path: text) -> Result<u64, text>:
    # Read markdown file
    match read_text(md_path):
        Ok(md_content):
            # Extract metadata, title, overview (currently stubs)
            val metadata = extract_metadata(md_content)
            val title = extract_title(md_content)
            val overview = extract_overview(md_content)

            # Extract code examples (currently stub)
            val examples = extract_code_examples(md_content)

            # Generate _spec.spl content
            val spl_content = generate_spec_spl(
                md_path,
                spl_path,
                metadata,
                title,
                overview,
                examples
            )

            # Write to output file
            match write_text(spl_path, spl_content):
                Ok(_):
                    Ok(examples.len() as u64)
                Err(e):
                    Err("Failed to write spec file: {e}")
        Err(e):
            Err("Failed to read markdown file: {e}")

# Migrate all Category A files
# TODO: [stdlib][P1] Needs regex and markdown parsing for full implementation
fn migrate_all_category_a() -> SpecMigrationStats:
    var stats = SpecMigrationStats.new()

    # Get Category A files
    val files = get_category_a_files()

    # Process each file
    var i = 0
    while i < files.len():
        val file = files[i]
        stats.add_processed()

        # Construct full paths
        val md_path = "doc/spec/{file.md_file}"
        val spl_path = "tests/specs/{file.spl_file}"

        match migrate_spec_file(md_path, spl_path):
            Ok(examples_count):
                stats.add_migrated(examples_count)
                print "Migrated: {file.md_file} -> {file.spl_file} ({examples_count} examples)"
            Err(e):
                print "Error migrating {file.md_file}: {e}"

        i = i + 1

    stats

# Print Category A files
fn print_category_a_files() -> text:
    var output = ""
    output = output + "=== Category A Files for Migration ===\n\n"

    val files = get_category_a_files()
    var i = 0
    while i < files.len():
        val file = files[i]
        output = output + "{i + 1}. {file.md_file} -> {file.spl_file}\n"
        output = output + "   Feature IDs: {file.feature_ids}\n\n"
        i = i + 1

    output

# CLI options for migrate_spec_to_spl command
struct MigrateSpecOptions:
    all_files: bool
    dry_run: bool
    list_files: bool
    md_path: Option<text>
    spl_path: Option<text>
    show_help: bool

impl MigrateSpecOptions:
    # Create default options
    static fn default() -> MigrateSpecOptions:
        MigrateSpecOptions(
            all_files: false,
            dry_run: false,
            list_files: false,
            md_path: None,
            spl_path: None,
            show_help: false
        )

    # Parse CLI arguments
    static fn parse(args: List<text>) -> MigrateSpecOptions:
        var options = MigrateSpecOptions.default()
        var positional_count = 0
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg == "--all" or arg == "-a":
                options.all_files = true
            elif arg == "--dry-run" or arg == "-n":
                options.dry_run = true
            elif arg == "--list" or arg == "-l":
                options.list_files = true
            elif arg == "--help" or arg == "-h":
                options.show_help = true
            elif not arg.starts_with("-"):
                # Positional arguments: md_path and spl_path
                if positional_count == 0:
                    options.md_path = Some(arg)
                elif positional_count == 1:
                    options.spl_path = Some(arg)
                positional_count = positional_count + 1

            i = i + 1

        options

# Print usage help for migrate_spec_to_spl
fn print_migrate_spec_help() -> text:
    var help = ""
    help = help + "Usage: simple migrate-spec-to-spl [OPTIONS] [MD_PATH] [SPL_PATH]\n\n"
    help = help + "Convert doc/spec/*.md to tests/specs/*_spec.spl test files.\n\n"
    help = help + "Arguments:\n"
    help = help + "  MD_PATH          Input markdown specification file\n"
    help = help + "  SPL_PATH         Output _spec.spl test file\n\n"
    help = help + "Options:\n"
    help = help + "  -a, --all        Migrate all Category A files\n"
    help = help + "  -n, --dry-run    Preview migration without writing files\n"
    help = help + "  -l, --list       List Category A files for migration\n"
    help = help + "  -h, --help       Show this help message\n\n"
    help = help + "Examples:\n"
    help = help + "  simple migrate-spec-to-spl doc/spec/syntax.md tests/specs/syntax_spec.spl\n"
    help = help + "  simple migrate-spec-to-spl --all             # Migrate all Category A files\n"
    help = help + "  simple migrate-spec-to-spl --list            # List files to migrate\n"
    help

# Main entry point
fn main_migrate_spec_to_spl(args: List<text>) -> Result<(), text>:
    val options = MigrateSpecOptions.parse(args)

    # Show help if requested
    if options.show_help:
        print print_migrate_spec_help()
        return Ok(())

    # List Category A files if requested
    if options.list_files:
        print print_category_a_files()
        return Ok(())

    # Determine mode: all files or single file
    if options.all_files:
        # Migrate all Category A files
        print "Migrating all Category A specification files..."
        if options.dry_run:
            print "=== Dry Run Mode - No files will be written ===\n"

        val stats = migrate_all_category_a()

        # Print summary
        print stats.summary()

        Ok(())
    else:
        # Single file migration
        match (options.md_path, options.spl_path):
            (Some(md), Some(spl)):
                print "Migrating: {md}"
                print "Output: {spl}"

                if options.dry_run:
                    print "=== Dry Run Mode - No files will be written ===\n"

                match migrate_spec_file(md, spl):
                    Ok(examples_count):
                        print "\n=== Migration Complete ==="
                        print "Examples extracted: {examples_count}"
                        Ok(())
                    Err(e):
                        Err(e)
            _:
                Err("Missing required arguments. Use --all or provide MD_PATH SPL_PATH.\nRun with --help for usage information.")
