# Extract Tests from Spec - Extract testable code examples from markdown specs
# Migrated from: scripts/extract_tests_from_spec.py
# Purpose: Convert markdown specs to executable _spec.spl test files

# TODO: [stdlib][P1] Add regex library to Simple
# TODO: [stdlib][P1] Add file I/O library to Simple

# Metadata extracted from markdown file
struct SpecMetadata:
    title: text
    status: text
    feature_ids: text

impl SpecMetadata:
    # Create empty metadata
    static fn new() -> SpecMetadata:
        SpecMetadata(
            title: "",
            status: "Reference",
            feature_ids: ""
        )

    # Create with values
    static fn with_values(title: text, status: text, feature_ids: text) -> SpecMetadata:
        SpecMetadata(
            title: title,
            status: status,
            feature_ids: feature_ids
        )

# A code example extracted from markdown
struct CodeExample:
    section: text          # Section name where example appears
    context: text          # Descriptive context before the code
    code: text             # The actual code
    line_number: u64       # Approximate line in source file

impl CodeExample:
    # Create a new code example
    static fn new(section: text, context: text, code: text, line_number: u64) -> CodeExample:
        CodeExample(section, context, code, line_number)

# Extraction result
struct ExtractionResult:
    success: bool
    examples_count: u64
    output_path: text
    error_message: text

impl ExtractionResult:
    # Create success result
    static fn success(count: u64, output: text) -> ExtractionResult:
        ExtractionResult(
            success: true,
            examples_count: count,
            output_path: output,
            error_message: ""
        )

    # Create failure result
    static fn error(message: text) -> ExtractionResult:
        ExtractionResult(
            success: false,
            examples_count: 0,
            output_path: "",
            error_message: message
        )

# TODO: [stdlib][P1] Add regex support
# Extract metadata from markdown content
fn extract_metadata(md_content: text) -> SpecMetadata:
    # Stub: Needs regex for pattern matching
    # Would search for:
    # - **Status:** (.+)
    # - **Feature IDs:** (.+)
    # - ^# (.+) for title
    SpecMetadata.new()

# TODO: [stdlib][P1] Add regex support
# Extract code examples from markdown
fn extract_code_examples(md_content: text) -> List<CodeExample>:
    # Stub: Needs regex to find:
    # - ## sections
    # - ```simple code blocks
    # - Context paragraphs
    # Returns list of (section, context, code, line_number)
    []

# Generate _spec.spl file content from examples
fn generate_spec_spl(
    source_filename: text,
    metadata: SpecMetadata,
    examples: List<CodeExample>
) -> text:
    var output = ""

    # Header with metadata
    output = output + "\"\"\"\n"
    output = output + "# {metadata.title} - Test Specification\n\n"
    output = output + "**Status:** {metadata.status}\n"

    if not metadata.feature_ids.is_empty():
        output = output + "**Feature IDs:** {metadata.feature_ids}\n"

    output = output + "**Source:** {source_filename}\n"
    output = output + "**Type:** Extracted Examples (Category B)\n\n"

    output = output + "## Overview\n\n"
    output = output + "This file contains executable test cases extracted from {source_filename}.\n"
    output = output + "The original specification file remains as architectural reference documentation.\n\n"

    output = output + "**Note:** This is a test extraction file. For complete specification text,\n"
    output = output + "design rationale, and architecture, see doc/spec/{source_filename}\n\n"

    output = output + "## Extracted Test Cases\n\n"
    output = output + "{examples.len()} test cases extracted covering:\n"
    output = output + "- Core functionality examples\n"
    output = output + "- Edge cases and validation\n"
    output = output + "- Integration patterns\n"
    output = output + "\"\"\"\n\n"

    # Generate test cases
    if examples.is_empty():
        # No examples found
        output = output + "# No testable code examples found\n\n"
        output = output + "test \"placeholder\":\n"
        output = output + "    \"\"\"\n"
        output = output + "    Placeholder test - add test cases as implementation progresses.\n"
        output = output + "    \"\"\"\n"
        output = output + "    assert_compiles()\n"
    else:
        var i = 0
        while i < examples.len():
            val example = examples[i]
            val test_num = i + 1

            # Test marker
            output = output + "## Test: {example.section} (Line ~{example.line_number})\n\n"

            # Add context if available
            if not example.context.is_empty() and example.context.len() > 20:
                val context_short = if example.context.len() > 100:
                    example.context.slice(0, 100) + "..."
                else:
                    example.context

                output = output + "\"\"\"\n"
                output = output + "{context_short}\n"
                output = output + "\"\"\"\n"

            # Check if code already has test structure
            if example.code.contains("test ") or example.code.starts_with("fn "):
                # Already structured, use as-is
                output = output + "{example.code}\n\n"
            else:
                # Wrap in test function
                val test_name = generate_test_name(example.section, test_num)
                output = output + "test \"{test_name}\":\n"

                # Indent code
                val indented = indent_code(example.code, 4)
                output = output + "{indented}\n"
                output = output + "    assert_compiles()\n\n"

            i = i + 1

    output

# Generate test name from section name
fn generate_test_name(section: text, num: u64) -> text:
    # Convert section to valid test name
    var name = section.to_lowercase()

    # Remove special characters
    name = name.replace("?", "")
    name = name.replace("!", "")
    name = name.replace(",", "")
    name = name.replace(".", "")
    name = name.replace("(", "")
    name = name.replace(")", "")

    # Replace spaces and dashes with underscores
    name = name.replace(" ", "_")
    name = name.replace("-", "_")

    # Add number
    "{name}_{num}"

# Indent code by n spaces
fn indent_code(code: text, spaces: u64) -> text:
    val lines = code.split("\n")
    var result = ""

    var i = 0
    while i < lines.len():
        val line = lines[i]

        # Add indentation if line is not empty
        if not line.trim().is_empty():
            var indent = ""
            var j: u64 = 0
            while j < spaces:
                indent = indent + " "
                j = j + 1
            result = result + indent + line
        else:
            # Keep empty lines empty
            result = result + ""

        # Add newline except for last line
        if i < lines.len() - 1:
            result = result + "\n"

        i = i + 1

    result

# TODO: [stdlib][P1] Add file I/O
# Extract tests from markdown file to _spec.spl file
fn extract_tests(
    input_md: text,
    output_spl: text,
    dry_run: bool
) -> ExtractionResult:
    # Stub: Needs file I/O
    # Would:
    # 1. Read input markdown file
    # 2. Extract metadata and examples
    # 3. Generate _spec.spl content
    # 4. Write to output file (unless dry_run)
    ExtractionResult.error("file I/O not yet implemented")

# TODO: [stdlib][P1] Add file I/O
# Extract tests from all Category B files
fn extract_all_category_b(
    base_dir: text,
    output_dir: text,
    dry_run: bool
) -> (u64, u64):
    # Stub: Needs file I/O and directory operations
    # Would process all files in CATEGORY_B_FILES list
    # Returns (success_count, total_count)
    (0, 0)

# Category B files mapping
fn get_category_b_files() -> List<(text, text)>:
    [
        ("functions.md", "functions_spec.spl"),
        ("traits.md", "traits_spec.spl"),
        ("memory.md", "memory_spec.spl"),
        ("modules.md", "modules_spec.spl"),
        ("data_structures.md", "data_structures_spec.spl"),
        ("concurrency.md", "concurrency_spec.spl"),
        ("macro.md", "macro_spec.spl"),
        ("metaprogramming.md", "metaprogramming_spec.spl")
    ]

# Extraction statistics
struct ExtractionStats:
    total_files: u64
    successful: u64
    failed: u64
    total_examples: u64

impl ExtractionStats:
    # Create empty stats
    static fn new() -> ExtractionStats:
        ExtractionStats(
            total_files: 0,
            successful: 0,
            failed: 0,
            total_examples: 0
        )

    # Record successful extraction
    me add_success(examples: u64):
        self.total_files = self.total_files + 1
        self.successful = self.successful + 1
        self.total_examples = self.total_examples + examples

    # Record failed extraction
    me add_failure():
        self.total_files = self.total_files + 1
        self.failed = self.failed + 1

    # Generate summary report
    fn summary() -> text:
        var report = ""
        report = report + "Extraction Statistics:\n"
        report = report + "  Total Files: {self.total_files}\n"
        report = report + "  Successful: {self.successful}\n"
        report = report + "  Failed: {self.failed}\n"
        report = report + "  Total Examples: {self.total_examples}\n"
        report

# TODO: [stdlib][P1] Add CLI argument parsing
# Main entry point
fn main_extract_tests(args: List<text>) -> Result<(), text>:
    # Stub: Needs argument parsing and file I/O
    # Would handle:
    # --all                   Extract from all Category B files
    # --dry-run               Preview without writing
    # --verbose               Show detailed info
    # input_md output_spl     Single file extraction
    Err("CLI not yet implemented - use as library instead")
