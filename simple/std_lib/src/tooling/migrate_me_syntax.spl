# Simple Language Syntax Migration Tool - fn/me syntax
# Migrated from: scripts/migrate_to_me_syntax.py
# Purpose: Migrate from old syntax to fn/me syntax

# TODO: [stdlib][P1] Add regex library to Simple

import fs.{read_text, write_text, glob, create_dir, basename, dirname, join}

use super.time_utils.{migration_backup_dir, current_timestamp_string}

# Migration statistics
struct MigrationStats:
    files_processed: u64
    files_modified: u64
    lines_changed: u64
    backup_dir: text

impl MigrationStats:
    # Create empty stats
    static fn new(backup_dir: text) -> MigrationStats:
        MigrationStats(
            files_processed: 0,
            files_modified: 0,
            lines_changed: 0,
            backup_dir: backup_dir
        )

    # Record processed file
    me add_processed():
        self.files_processed = self.files_processed + 1

    # Record modified file
    me add_modified(lines: u64):
        self.files_modified = self.files_modified + 1
        self.lines_changed = self.lines_changed + lines

    # Generate summary report
    fn summary() -> text:
        var report = ""
        report = report + "=== Migration Complete ===\n"
        report = report + "Files processed: {self.files_processed}\n"
        report = report + "Files modified: {self.files_modified}\n"
        report = report + "Lines changed: {self.lines_changed}\n"
        report = report + "Backups saved to: {self.backup_dir}\n"
        report

# File migration result
struct MigrationResult:
    modified: bool
    lines_changed: u64
    error: text

impl MigrationResult:
    # No changes made
    static fn unchanged() -> MigrationResult:
        MigrationResult(
            modified: false,
            lines_changed: 0,
            error: ""
        )

    # Changes made successfully
    static fn changed(lines: u64) -> MigrationResult:
        MigrationResult(
            modified: true,
            lines_changed: lines,
            error: ""
        )

    # Error occurred
    static fn error(message: text) -> MigrationResult:
        MigrationResult(
            modified: false,
            lines_changed: 0,
            error: message
        )

# TODO: [stdlib][P1] Add regex support
# Apply syntax transformations to content
fn migrate_content(content: text) -> text:
    # Stub: Needs regex for pattern replacements
    # Would apply these transformations:
    # 1. var fn method(self, ...) -> me method(self, ...)
    # 2. fn method(mut self, ...) -> me method(self, ...)
    # 3. Keep fn method(self, ...) as is (immutable methods)
    # 4. Keep static fn method() as is (static methods)

    # Regex patterns needed:
    # - r'^(\s*)var\s+fn\s+(\w+)\s*\(\s*self\s*\)(\s*(?:->)?)'
    # - r'^(\s*)var\s+fn\s+(\w+)\s*\(\s*self\s*,\s*'
    # - r'^(\s*)fn\s+(\w+)\s*\(\s*mut\s+self\s*\)(\s*(?:->)?)'
    # - r'^(\s*)fn\s+(\w+)\s*\(\s*mut\s+self\s*,\s*'

    content  # Return unchanged for now

# Migrate a single file
# TODO: [stdlib][P1] Needs regex for actual migration logic
fn migrate_file(filepath: text, backup_dir: text) -> MigrationResult:
    # Read file content
    match read_text(filepath):
        Ok(content):
            # Apply migrate_content() (currently a stub without regex)
            val migrated = migrate_content(content)

            # Check if anything changed
            if migrated == content:
                return MigrationResult.unchanged()

            # Backup original to backup_dir
            val file_name = basename(filepath)
            val backup_path = join([backup_dir, file_name])

            match write_text(backup_path, content):
                Ok(_):
                    # Write migrated content
                    match write_text(filepath, migrated):
                        Ok(_):
                            # TODO: Count changed lines accurately
                            MigrationResult.changed(1)
                        Err(e):
                            MigrationResult.error("Failed to write migrated file: {e}")
                Err(e):
                    MigrationResult.error("Failed to backup file: {e}")
        Err(e):
            MigrationResult.error("Failed to read file: {e}")

# Find all .spl files in directory
fn find_spl_files(root_dir: text) -> List<text>:
    # Glob for **/*.spl
    match glob(root_dir, "**/*.spl"):
        Ok(files):
            # TODO: Filter out target, .git, .migration_backup directories
            # For now, return all files
            files
        Err(_):
            []  # Return empty list on error

# Run migration on all .spl files
# TODO: [stdlib][P1] Needs regex for actual migration logic
fn run_migration(root_dir: text) -> MigrationStats:
    # Create backup directory with timestamp
    val backup_dir = migration_backup_dir("me_syntax")
    var stats = MigrationStats.new(backup_dir)

    # Create backup directory
    match create_dir(backup_dir, true):
        Ok(_):
            # Find all .spl files
            val files = find_spl_files(root_dir)

            # Process each file
            var i = 0
            while i < files.len():
                val filepath = files[i]
                stats.add_processed()

                val result = migrate_file(filepath, backup_dir)
                if result.modified:
                    stats.add_modified(result.lines_changed)
                    print "Migrated: {filepath}"
                elif not result.error.is_empty():
                    print "Error processing {filepath}: {result.error}"

                i = i + 1
        Err(e):
            print "Error creating backup directory: {e}"

    stats

# Syntax transformation patterns (for documentation)
struct TransformPattern:
    name: text
    description: text
    before: text
    after: text

impl TransformPattern:
    # Create a transformation pattern
    static fn new(name: text, desc: text, before: text, after: text) -> TransformPattern:
        TransformPattern(
            name: name,
            description: desc,
            before: before,
            after: after
        )

# Get all transformation patterns
fn get_transform_patterns() -> List<TransformPattern>:
    [
        TransformPattern.new(
            "var_fn_to_me",
            "Convert var fn to me (mutable methods)",
            "var fn method(self) ->",
            "me method(self) ->"
        ),
        TransformPattern.new(
            "mut_self_to_me",
            "Convert fn with mut self to me",
            "fn method(mut self, x: i64) ->",
            "me method(self, x: i64) ->"
        ),
        TransformPattern.new(
            "keep_immutable",
            "Keep immutable methods as fn",
            "fn method(self) ->",
            "fn method(self) ->"
        ),
        TransformPattern.new(
            "keep_static",
            "Keep static methods unchanged",
            "static fn new() ->",
            "static fn new() ->"
        )
    ]

# Print transformation examples
fn print_examples() -> text:
    var output = ""
    output = output + "=== Syntax Migration Patterns ===\n\n"

    val patterns = get_transform_patterns()
    var i = 0
    while i < patterns.len():
        val pattern = patterns[i]
        output = output + "{i + 1}. {pattern.name}\n"
        output = output + "   {pattern.description}\n"
        output = output + "   Before: {pattern.before}\n"
        output = output + "   After:  {pattern.after}\n\n"
        i = i + 1

    output

# CLI options for migrate_me_syntax command
struct MigrateMeOptions:
    dry_run: bool
    backup_dir: Option<text>
    root_dir: text
    show_help: bool

impl MigrateMeOptions:
    # Create default options
    static fn default() -> MigrateMeOptions:
        MigrateMeOptions(
            dry_run: false,
            backup_dir: None,
            root_dir: ".",
            show_help: false
        )

    # Parse CLI arguments
    static fn parse(args: List<text>) -> MigrateMeOptions:
        var options = MigrateMeOptions.default()
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg == "--dry-run" or arg == "-n":
                options.dry_run = true
            elif arg == "--backup-dir" and i + 1 < args.len():
                i = i + 1
                options.backup_dir = Some(args[i])
            elif arg == "--help" or arg == "-h":
                options.show_help = true
            elif not arg.starts_with("-"):
                # Positional argument: root directory
                options.root_dir = arg

            i = i + 1

        options

# Print usage help for migrate_me_syntax
fn print_migrate_me_help() -> text:
    var help = ""
    help = help + "Usage: simple migrate-me-syntax [OPTIONS] [ROOT_DIR]\n\n"
    help = help + "Migrate from old fn/var fn syntax to fn/me syntax.\n\n"
    help = help + "Arguments:\n"
    help = help + "  ROOT_DIR         Directory to migrate (default: current directory)\n\n"
    help = help + "Options:\n"
    help = help + "  -n, --dry-run    Preview changes without writing files\n"
    help = help + "  --backup-dir     Custom backup directory for original files\n"
    help = help + "  -h, --help       Show this help message\n\n"
    help = help + "Examples:\n"
    help = help + "  simple migrate-me-syntax                    # Migrate current directory\n"
    help = help + "  simple migrate-me-syntax src/               # Migrate src/ directory\n"
    help = help + "  simple migrate-me-syntax --dry-run src/     # Preview changes only\n"
    help

# Main entry point
fn main_migrate_me_syntax(args: List<text>) -> Result<(), text>:
    val options = MigrateMeOptions.parse(args)

    # Show help if requested
    if options.show_help:
        print print_migrate_me_help()
        return Ok(())

    # Show what we're doing
    if options.dry_run:
        print "=== Dry Run Mode - No files will be modified ===\n"

    print "Migrating fn/me syntax in: {options.root_dir}"

    # Run the migration
    val stats = run_migration(options.root_dir)

    # Print summary
    print stats.summary()

    # Print transformation patterns for reference
    if options.dry_run:
        print print_examples()

    Ok(())
