# Formatting utilities for text output
# Table formatting, alignment, pretty printing

# =====================================
# Table Formatting
# =====================================

# Simple table row with aligned columns
struct TableRow:
    cells: List<text>

# Table with header and rows
struct Table:
    headers: List<text>
    rows: List<TableRow>
    column_widths: List<i32>

# Create a new table
fn create_table(headers: List<text>) -> Table:
    val widths = headers.map(\h: h.len())
    Table(
        headers: headers,
        rows: [],
        column_widths: widths
    )

# Add row to table and update column widths
fn add_row(table: Table, cells: List<text>) -> Table:
    var new_widths = table.column_widths

    # Update column widths if cells are wider
    for i in 0..cells.len():
        if i < new_widths.len():
            val cell_len = cells[i].len()
            if cell_len > new_widths[i]:
                new_widths[i] = cell_len

    var new_rows = table.rows
    new_rows.push(TableRow(cells: cells))

    Table(
        headers: table.headers,
        rows: new_rows,
        column_widths: new_widths
    )

# Format table as string with borders
fn format_table(table: Table) -> text:
    use super.string_utils.pad_right

    var output = ""

    # Header separator
    var sep = "+"
    for width in table.column_widths:
        var dashes = ""
        for _ in 0..(width + 2):
            dashes = dashes + "-"
        sep = sep + dashes + "+"
    sep = sep + "\n"

    # Print header
    output = output + sep
    output = output + "|"
    for i in 0..table.headers.len():
        val header = table.headers[i]
        val width = table.column_widths[i]
        output = output + " " + pad_right(header, width, " ") + " |"
    output = output + "\n" + sep

    # Print rows
    for row in table.rows:
        output = output + "|"
        for i in 0..row.cells.len():
            if i < row.cells.len():
                val cell = row.cells[i]
                val width = if i < table.column_widths.len():
                    table.column_widths[i]
                else:
                    cell.len()
                output = output + " " + pad_right(cell, width, " ") + " |"
        output = output + "\n"

    output = output + sep
    output

# =====================================
# Progress Indicators
# =====================================

# Simple progress bar
fn progress_bar(current: i32, total: i32, width: i32) -> text:
    if total <= 0:
        return "[" + "=".repeat(width) + "]"

    val filled = (current * width) / total
    val empty = width - filled

    var bar = "["
    for _ in 0..filled:
        bar = bar + "="
    for _ in 0..empty:
        bar = bar + " "
    bar = bar + "]"

    val percent = (current * 100) / total
    "{bar} {percent}%"

# Spinner animation frames
fn spinner_frame(frame_num: i32) -> text:
    val frames = ["|", "/", "-", "\\"]
    val index = frame_num % frames.len()
    frames[index]

# =====================================
# Pretty Printing
# =====================================

# Indent all lines in text
fn indent_text(text: text, spaces: i32) -> text:
    var indent_str = ""
    for _ in 0..spaces:
        indent_str = indent_str + " "

    val lines = text.split("\n")
    var result = []

    for line in lines:
        result.push(indent_str + line)

    result.join("\n")

# Create a box around text
fn box_text(text: text, style: text) -> text:
    val lines = text.split("\n")
    var max_len = 0

    for line in lines:
        if line.len() > max_len:
            max_len = line.len()

    val (top_left, top_right, bottom_left, bottom_right, horizontal, vertical) = match style:
        "double" => ("╔", "╗", "╚", "╝", "═", "║")
        "rounded" => ("╭", "╮", "╰", "╯", "─", "│")
        "single" => ("┌", "┐", "└", "┘", "─", "│")
        _ => ("+", "+", "+", "+", "-", "|")

    var output = top_left
    for _ in 0..(max_len + 2):
        output = output + horizontal
    output = output + top_right + "\n"

    for line in lines:
        use super.string_utils.pad_right
        output = output + vertical + " " + pad_right(line, max_len, " ") + " " + vertical + "\n"

    output = output + bottom_left
    for _ in 0..(max_len + 2):
        output = output + horizontal
    output = output + bottom_right

    output

# =====================================
# Tree Formatting
# =====================================

# Tree node for hierarchical display
struct TreeNode:
    label: text
    children: List<TreeNode>

# Format tree structure
fn format_tree(node: TreeNode, prefix: text, is_last: bool) -> text:
    var output = ""

    # Current node
    val connector = if is_last: "└── " else "├── "
    output = output + prefix + connector + node.label + "\n"

    # Children
    val child_prefix = prefix + (if is_last: "    " else "│   ")

    for i in 0..node.children.len():
        val child = node.children[i]
        val child_is_last = i == node.children.len() - 1
        output = output + format_tree(child, child_prefix, child_is_last)

    output

# =====================================
# Color/Style Utilities
# =====================================

# ANSI color codes
fn ansi_color(text: text, color: text) -> text:
    val code = match color:
        "black" => "30"
        "red" => "31"
        "green" => "32"
        "yellow" => "33"
        "blue" => "34"
        "magenta" => "35"
        "cyan" => "36"
        "white" => "37"
        _ => "0"

    "\x1b[{code}m{text}\x1b[0m"

# ANSI style codes
fn ansi_style(text: text, style: text) -> text:
    val code = match style:
        "bold" => "1"
        "dim" => "2"
        "italic" => "3"
        "underline" => "4"
        "blink" => "5"
        "reverse" => "7"
        "hidden" => "8"
        _ => "0"

    "\x1b[{code}m{text}\x1b[0m"

# Combined color and style
fn styled_text(text: text, color: text, style: text) -> text:
    ansi_style(ansi_color(text, color), style)

# =====================================
# Number Formatting
# =====================================

# Format number with thousand separators
fn format_number(num: i32, separator: text) -> text:
    val s = num.to_string()
    var result = ""
    var count = 0

    # Process digits from right to left
    for i in (s.len() - 1)..=-1..0:
        if count > 0 and count % 3 == 0:
            result = separator + result
        result = s.chars()[i] + result
        count = count + 1

    result

# Format bytes as human readable
fn format_bytes(bytes: i32) -> text:
    if bytes < 1024:
        return "{bytes} B"

    val kb = bytes / 1024
    if kb < 1024:
        return "{kb} KB"

    val mb = kb / 1024
    if mb < 1024:
        return "{mb} MB"

    val gb = mb / 1024
    "{gb} GB"

# Format duration in milliseconds
fn format_duration_ms(ms: i32) -> text:
    if ms < 1000:
        return "{ms}ms"

    val seconds = ms / 1000
    if seconds < 60:
        val remaining_ms = ms % 1000
        return "{seconds}.{remaining_ms}s"

    val minutes = seconds / 60
    val remaining_seconds = seconds % 60
    if minutes < 60:
        return "{minutes}m {remaining_seconds}s"

    val hours = minutes / 60
    val remaining_minutes = minutes % 60
    "{hours}h {remaining_minutes}m"
