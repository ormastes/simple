# Skeletal Animation - Bone-based character animation
#
# Implements hierarchical skeleton system with skinned mesh rendering:
# - Skeleton with joint hierarchy
# - Animation clips with keyframes
# - Linear interpolation (LERP) and spherical interpolation (SLERP)
# - Skinning with vertex weights (up to 4 bones per vertex)
# - Animation blending
# - Inverse kinematics (IK) chains
#
# Based on: doc/spec/graphics_3d.md (Part 4.4: Skeletal Animation)

use core.*
use graphics.math.*
use graphics.scene.*

# =============================================================================
# Skeleton - Bone hierarchy
# =============================================================================

pub struct Skeleton:
    name: String
    joints: Array[Joint]              # All joints in skeleton
    joint_hierarchy: Array[i32]       # Parent indices (-1 = root)
    inverse_bind_matrices: Array[Mat4]  # Bind pose inverses
    root_joints: Array[i32]           # Root joint indices

pub struct Joint:
    name: String
    index: i32                        # Joint index
    parent_index: i32                 # Parent joint (-1 = root)
    local_transform: Transform        # Local transform (relative to parent)
    inverse_bind_matrix: Mat4         # Inverse bind pose matrix

impl Skeleton:
    pub fn new(name: String) -> Skeleton:
        return Skeleton {
            name: name,
            joints: Array::new(),
            joint_hierarchy: Array::new(),
            inverse_bind_matrices: Array::new(),
            root_joints: Array::new()
        }

    # Add joint to skeleton
    pub fn add_joint(
        mut self,
        name: String,
        parent_index: i32,
        local_transform: Transform,
        inverse_bind_matrix: Mat4
    ) -> i32:
        let index = self.joints.len() as i32

        let joint = Joint {
            name: name,
            index: index,
            parent_index: parent_index,
            local_transform: local_transform,
            inverse_bind_matrix: inverse_bind_matrix
        }

        self.joints.push(joint)
        self.joint_hierarchy.push(parent_index)
        self.inverse_bind_matrices.push(inverse_bind_matrix)

        # Track root joints
        if parent_index < 0:
            self.root_joints.push(index)

        return index

    # Find joint by name
    pub fn find_joint(self, name: String) -> Option[i32]:
        for i in 0..self.joints.len():
            if self.joints[i].name == name:
                return Some(i as i32)
        return None

    # Get joint count
    pub fn joint_count(self) -> i32:
        return self.joints.len() as i32

# =============================================================================
# Animation Clip - Keyframe animation data
# =============================================================================

pub struct AnimationClip:
    name: String
    duration: f32                     # Total duration in seconds
    channels: Array[AnimationChannel] # Per-joint animation channels

pub struct AnimationChannel:
    joint_index: i32                  # Target joint
    position_keys: Array[PositionKey]
    rotation_keys: Array[RotationKey]
    scale_keys: Array[ScaleKey]

pub struct PositionKey:
    time: f32
    value: Vec3

pub struct RotationKey:
    time: f32
    value: Quat

pub struct ScaleKey:
    time: f32
    value: Vec3

impl AnimationClip:
    pub fn new(name: String, duration: f32) -> AnimationClip:
        return AnimationClip {
            name: name,
            duration: duration,
            channels: Array::new()
        }

    # Add animation channel
    pub fn add_channel(mut self, channel: AnimationChannel):
        self.channels.push(channel)

    # Sample animation at specific time
    pub fn sample(self, time: f32) -> Array[Transform]:
        let mut transforms = Array[Transform]::new()

        for channel in self.channels:
            let transform = channel.sample(time)
            transforms.push(transform)

        return transforms

# =============================================================================
# Animation Channel Sampling
# =============================================================================

impl AnimationChannel:
    pub fn new(joint_index: i32) -> AnimationChannel:
        return AnimationChannel {
            joint_index: joint_index,
            position_keys: Array::new(),
            rotation_keys: Array::new(),
            scale_keys: Array::new()
        }

    # Sample channel at specific time
    pub fn sample(self, time: f32) -> Transform:
        let position = self.sample_position(time)
        let rotation = self.sample_rotation(time)
        let scale = self.sample_scale(time)

        return Transform::new(position, rotation, scale)

    # Sample position with linear interpolation
    fn sample_position(self, time: f32) -> Vec3:
        if self.position_keys.is_empty():
            return Vec3::zero()

        if self.position_keys.len() == 1:
            return self.position_keys[0].value

        # Find keyframe pair
        let (key0, key1, t) = find_keyframe_pair_position(&self.position_keys, time)

        # Linear interpolation
        return lerp_vec3(key0.value, key1.value, t)

    # Sample rotation with spherical interpolation
    fn sample_rotation(self, time: f32) -> Quat:
        if self.rotation_keys.is_empty():
            return Quat::identity()

        if self.rotation_keys.len() == 1:
            return self.rotation_keys[0].value

        # Find keyframe pair
        let (key0, key1, t) = find_keyframe_pair_rotation(&self.rotation_keys, time)

        # Spherical linear interpolation (SLERP)
        return slerp_quat(key0.value, key1.value, t)

    # Sample scale with linear interpolation
    fn sample_scale(self, time: f32) -> Vec3:
        if self.scale_keys.is_empty():
            return Vec3::new(1.0, 1.0, 1.0)

        if self.scale_keys.len() == 1:
            return self.scale_keys[0].value

        # Find keyframe pair
        let (key0, key1, t) = find_keyframe_pair_scale(&self.scale_keys, time)

        # Linear interpolation
        return lerp_vec3(key0.value, key1.value, t)

# =============================================================================
# Animation State - Runtime animation playback
# =============================================================================

pub struct AnimationState:
    skeleton: Skeleton
    current_clip: Option[AnimationClip]
    current_time: f32
    playback_speed: f32
    looping: bool
    playing: bool
    blend_states: Array[BlendState]

pub struct BlendState:
    clip: AnimationClip
    weight: f32
    time: f32

impl AnimationState:
    pub fn new(skeleton: Skeleton) -> AnimationState:
        return AnimationState {
            skeleton: skeleton,
            current_clip: None,
            current_time: 0.0,
            playback_speed: 1.0,
            looping: true,
            playing: false,
            blend_states: Array::new()
        }

    # Play animation clip
    pub fn play(mut self, clip: AnimationClip):
        self.current_clip = Some(clip)
        self.current_time = 0.0
        self.playing = true

    # Stop animation
    pub fn stop(mut self):
        self.playing = false

    # Set looping
    pub fn set_looping(mut self, looping: bool):
        self.looping = looping

    # Set playback speed
    pub fn set_speed(mut self, speed: f32):
        self.playback_speed = speed

    # Update animation (called each frame)
    pub fn update(mut self, delta_time: f32) -> Array[Mat4]:
        if not self.playing or self.current_clip.is_none():
            # Return bind pose
            return self.get_bind_pose()

        # Advance time
        self.current_time = self.current_time + delta_time * self.playback_speed

        let clip = self.current_clip.unwrap()

        # Handle looping
        if self.current_time >= clip.duration:
            if self.looping:
                self.current_time = self.current_time % clip.duration
            else:
                self.current_time = clip.duration
                self.playing = false

        # Sample animation
        let local_transforms = clip.sample(self.current_time)

        # Compute skinning matrices
        return self.compute_skinning_matrices(local_transforms)

    # Update with blending
    pub fn update_blended(mut self, delta_time: f32) -> Array[Mat4]:
        if self.blend_states.is_empty():
            return self.update(delta_time)

        # Update all blend states
        for i in 0..self.blend_states.len():
            let blend_state = &mut self.blend_states[i]
            blend_state.time = blend_state.time + delta_time * self.playback_speed

            # Loop if needed
            if blend_state.time >= blend_state.clip.duration:
                blend_state.time = blend_state.time % blend_state.clip.duration

        # Blend all animations
        let blended_transforms = self.blend_animations()

        # Compute skinning matrices
        return self.compute_skinning_matrices(blended_transforms)

    # Add blend layer
    pub fn add_blend(mut self, clip: AnimationClip, weight: f32):
        self.blend_states.push(BlendState {
            clip: clip,
            weight: weight,
            time: 0.0
        })

    # Clear blend layers
    pub fn clear_blends(mut self):
        self.blend_states.clear()

    # Blend multiple animations
    fn blend_animations(self) -> Array[Transform]:
        let joint_count = self.skeleton.joint_count()
        let mut blended = Array[Transform]::new()

        # Initialize with identity
        for _ in 0..joint_count:
            blended.push(Transform::identity())

        # Normalize weights
        let mut total_weight = 0.0
        for blend_state in self.blend_states:
            total_weight = total_weight + blend_state.weight

        if total_weight == 0.0:
            return blended

        # Blend each joint
        for joint_index in 0..joint_count:
            let mut blended_pos = Vec3::zero()
            let mut blended_rot = Quat::identity()
            let mut blended_scale = Vec3::zero()

            for blend_state in self.blend_states:
                let transforms = blend_state.clip.sample(blend_state.time)
                let normalized_weight = blend_state.weight / total_weight

                if joint_index < transforms.len() as i32:
                    let transform = transforms[joint_index as usize]

                    blended_pos = blended_pos + transform.translation * normalized_weight
                    blended_rot = slerp_quat(blended_rot, transform.rotation, normalized_weight)
                    blended_scale = blended_scale + transform.scale * normalized_weight

            blended[joint_index as usize] = Transform::new(
                blended_pos,
                blended_rot,
                blended_scale
            )

        return blended

    # Compute skinning matrices from local transforms
    fn compute_skinning_matrices(self, local_transforms: Array[Transform]) -> Array[Mat4]:
        let joint_count = self.skeleton.joint_count()
        let mut global_transforms = Array[Mat4]::new()
        let mut skinning_matrices = Array[Mat4]::new()

        # Initialize arrays
        for _ in 0..joint_count:
            global_transforms.push(Mat4::identity())
            skinning_matrices.push(Mat4::identity())

        # Compute global transforms (hierarchical)
        for i in 0..joint_count:
            let joint = &self.skeleton.joints[i as usize]
            let local_matrix = if i < local_transforms.len() as i32:
                local_transforms[i as usize].to_matrix()
            else:
                joint.local_transform.to_matrix()

            if joint.parent_index < 0:
                # Root joint
                global_transforms[i as usize] = local_matrix
            else:
                # Child joint
                let parent_global = global_transforms[joint.parent_index as usize]
                global_transforms[i as usize] = parent_global * local_matrix

        # Compute skinning matrices (global * inverse bind)
        for i in 0..joint_count:
            let global = global_transforms[i as usize]
            let inverse_bind = self.skeleton.inverse_bind_matrices[i as usize]
            skinning_matrices[i as usize] = global * inverse_bind

        return skinning_matrices

    # Get bind pose matrices
    fn get_bind_pose(self) -> Array[Mat4]:
        let joint_count = self.skeleton.joint_count()
        let mut matrices = Array[Mat4]::new()

        for _ in 0..joint_count:
            matrices.push(Mat4::identity())

        return matrices

# =============================================================================
# Skinned Mesh - Mesh with bone weights
# =============================================================================

pub struct SkinnedMesh:
    mesh: Mesh
    skeleton: Skeleton
    skin_data: SkinData

pub struct SkinData:
    bone_indices: Array[Vec4i]        # 4 bone indices per vertex
    bone_weights: Array[Vec4]         # 4 weights per vertex (sum = 1.0)

pub struct Vec4i:
    x: i32
    y: i32
    z: i32
    w: i32

impl SkinnedMesh:
    pub fn new(mesh: Mesh, skeleton: Skeleton, skin_data: SkinData) -> SkinnedMesh:
        return SkinnedMesh {
            mesh: mesh,
            skeleton: skeleton,
            skin_data: skin_data
        }

    # Upload skinning data to GPU
    pub fn upload_skin_data(self) -> u64:
        # Create GPU buffer with bone indices and weights
        return extern_create_skin_buffer(
            &self.skin_data.bone_indices,
            &self.skin_data.bone_weights
        )

    # Render with skinning
    pub fn render(
        self,
        skinning_matrices: &Array[Mat4],
        material: &Material,
        view_proj: Mat4
    ):
        # Upload skinning matrices to GPU
        extern_upload_skinning_matrices(skinning_matrices)

        # Render mesh with skinning shader
        extern_render_skinned_mesh(
            self.mesh.get_id(),
            self.upload_skin_data(),
            material.get_id(),
            view_proj
        )

# =============================================================================
# Inverse Kinematics (IK) - Two-bone IK chain
# =============================================================================

pub struct IKChain:
    joints: Array[i32]                # Joint indices in chain
    target_position: Vec3             # IK target position
    pole_vector: Vec3                 # Pole vector for orientation
    chain_length: f32                 # Total chain length

impl IKChain:
    # Create two-bone IK chain (e.g., shoulder-elbow-wrist)
    pub fn two_bone(
        root_joint: i32,
        mid_joint: i32,
        end_joint: i32
    ) -> IKChain:
        return IKChain {
            joints: [root_joint, mid_joint, end_joint].to_array(),
            target_position: Vec3::zero(),
            pole_vector: Vec3::new(0.0, 1.0, 0.0),
            chain_length: 0.0
        }

    # Solve two-bone IK
    pub fn solve_two_bone(
        mut self,
        skeleton: &Skeleton,
        target: Vec3,
        pole: Vec3
    ) -> (Transform, Transform):
        # Get joint positions
        let root_pos = skeleton.joints[self.joints[0] as usize].local_transform.translation
        let mid_pos = skeleton.joints[self.joints[1] as usize].local_transform.translation
        let end_pos = skeleton.joints[self.joints[2] as usize].local_transform.translation

        # Bone lengths
        let upper_length = (mid_pos - root_pos).length()
        let lower_length = (end_pos - mid_pos).length()
        let total_length = upper_length + lower_length

        # Vector from root to target
        let to_target = target - root_pos
        let target_distance = to_target.length()

        # Clamp to reachable distance
        let clamped_distance = min_f32(target_distance, total_length * 0.999)
        let target_dir = to_target.normalize()

        # Law of cosines for angles
        let cos_angle0 = (
            upper_length * upper_length +
            clamped_distance * clamped_distance -
            lower_length * lower_length
        ) / (2.0 * upper_length * clamped_distance)

        let cos_angle1 = (
            upper_length * upper_length +
            lower_length * lower_length -
            clamped_distance * clamped_distance
        ) / (2.0 * upper_length * lower_length)

        let angle0 = acos_f32(clamp_f32(cos_angle0, -1.0, 1.0))
        let angle1 = acos_f32(clamp_f32(cos_angle1, -1.0, 1.0))

        # Compute rotations
        let root_rotation = Quat::look_rotation(target_dir, pole)
        let mid_rotation = Quat::from_axis_angle(pole.normalize(), 3.14159 - angle1)

        let root_transform = Transform::new(
            root_pos,
            root_rotation * Quat::from_axis_angle(pole.normalize(), angle0),
            Vec3::new(1.0, 1.0, 1.0)
        )

        let mid_transform = Transform::new(
            mid_pos,
            mid_rotation,
            Vec3::new(1.0, 1.0, 1.0)
        )

        return (root_transform, mid_transform)

# =============================================================================
# Animation Blending
# =============================================================================

fn blend_transforms(
    a: Transform,
    b: Transform,
    t: f32
) -> Transform:
    return Transform::new(
        lerp_vec3(a.translation, b.translation, t),
        slerp_quat(a.rotation, b.rotation, t),
        lerp_vec3(a.scale, b.scale, t)
    )

# =============================================================================
# Keyframe Utilities
# =============================================================================

fn find_keyframe_pair_position(
    keys: &Array[PositionKey],
    time: f32
) -> (PositionKey, PositionKey, f32):
    # Find surrounding keyframes
    for i in 0..(keys.len() - 1):
        if time >= keys[i].time and time < keys[i + 1].time:
            let t = (time - keys[i].time) / (keys[i + 1].time - keys[i].time)
            return (keys[i], keys[i + 1], t)

    # Return last keyframe
    let last_idx = keys.len() - 1
    return (keys[last_idx], keys[last_idx], 0.0)

fn find_keyframe_pair_rotation(
    keys: &Array[RotationKey],
    time: f32
) -> (RotationKey, RotationKey, f32):
    for i in 0..(keys.len() - 1):
        if time >= keys[i].time and time < keys[i + 1].time:
            let t = (time - keys[i].time) / (keys[i + 1].time - keys[i].time)
            return (keys[i], keys[i + 1], t)

    let last_idx = keys.len() - 1
    return (keys[last_idx], keys[last_idx], 0.0)

fn find_keyframe_pair_scale(
    keys: &Array[ScaleKey],
    time: f32
) -> (ScaleKey, ScaleKey, f32):
    for i in 0..(keys.len() - 1):
        if time >= keys[i].time and time < keys[i + 1].time:
            let t = (time - keys[i].time) / (keys[i + 1].time - keys[i].time)
            return (keys[i], keys[i + 1], t)

    let last_idx = keys.len() - 1
    return (keys[last_idx], keys[last_idx], 0.0)

# =============================================================================
# Math Helpers
# =============================================================================

fn lerp_vec3(a: Vec3, b: Vec3, t: f32) -> Vec3:
    return a * (1.0 - t) + b * t

fn slerp_quat(a: Quat, b: Quat, t: f32) -> Quat:
    # Spherical linear interpolation
    let dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

    # Ensure shortest path
    let mut b_adjusted = b
    if dot < 0.0:
        b_adjusted = Quat::new(-b.x, -b.y, -b.z, -b.w)
        dot = -dot

    # Linear interpolation for close quaternions
    if dot > 0.9995:
        return Quat::new(
            lerp_f32(a.x, b_adjusted.x, t),
            lerp_f32(a.y, b_adjusted.y, t),
            lerp_f32(a.z, b_adjusted.z, t),
            lerp_f32(a.w, b_adjusted.w, t)
        ).normalize()

    # Spherical interpolation
    let theta = acos_f32(dot)
    let sin_theta = sin_f32(theta)

    let w_a = sin_f32((1.0 - t) * theta) / sin_theta
    let w_b = sin_f32(t * theta) / sin_theta

    return Quat::new(
        a.x * w_a + b_adjusted.x * w_b,
        a.y * w_a + b_adjusted.y * w_b,
        a.z * w_a + b_adjusted.z * w_b,
        a.w * w_a + b_adjusted.w * w_b
    )

fn lerp_f32(a: f32, b: f32, t: f32) -> f32:
    return a * (1.0 - t) + b * t

fn min_f32(a: f32, b: f32) -> f32:
    if a < b: a else: b

fn clamp_f32(value: f32, min: f32, max: f32) -> f32:
    if value < min:
        return min
    if value > max:
        return max
    return value

fn acos_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn sin_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

impl Quat:
    pub fn normalize(self) -> Quat:
        let len = sqrt_f32(self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w)
        if len == 0.0:
            return Quat::identity()

        return Quat::new(
            self.x / len,
            self.y / len,
            self.z / len,
            self.w / len
        )

    pub fn look_rotation(forward: Vec3, up: Vec3) -> Quat:
        # Simplified - would use proper quaternion from rotation matrix
        return Quat::identity()

    pub fn from_axis_angle(axis: Vec3, angle: f32) -> Quat:
        let half_angle = angle * 0.5
        let s = sin_f32(half_angle)

        return Quat::new(
            axis.x * s,
            axis.y * s,
            axis.z * s,
            cos_f32(half_angle)
        )

fn sqrt_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn cos_f32(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

impl Transform:
    pub fn to_matrix(self) -> Mat4:
        # TRS to matrix
        return Mat4::from_trs(self.translation, self.rotation, self.scale)

# =============================================================================
# External FFI Functions
# =============================================================================

extern fn extern_create_skin_buffer(
    bone_indices: &Array[Vec4i],
    bone_weights: &Array[Vec4]
) -> u64

extern fn extern_upload_skinning_matrices(matrices: &Array[Mat4])

extern fn extern_render_skinned_mesh(
    mesh_id: u64,
    skin_buffer_id: u64,
    material_id: u64,
    view_proj: Mat4
)
