# Mesh - 3D geometry with vertices and indices
#
# Provides Mesh container for vertex/index buffers,
# primitive generators (cube, sphere, plane),
# and normal/tangent computation.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.*

# =============================================================================
# MeshVertex - Vertex structure (64 bytes, cache-friendly)
# =============================================================================

pub struct MeshVertex:
    position: Vec3     # 12 bytes - World position
    normal: Vec3       # 12 bytes - Surface normal
    tangent: Vec4      # 16 bytes - Tangent + bitangent sign (w)
    tex_coord: Vec2    # 8 bytes - UV coordinates
    color: Vec4        # 16 bytes - Vertex color
    # Total: 64 bytes

impl MeshVertex:
    pub fn new(position: Vec3, normal: Vec3, tex_coord: Vec2) -> MeshVertex:
        return MeshVertex {
            position: position,
            normal: normal,
            tangent: Vec4::new(1.0, 0.0, 0.0, 1.0),
            tex_coord: tex_coord,
            color: Vec4::one()
        }

    pub fn with_color(position: Vec3, normal: Vec3, tex_coord: Vec2, color: Vec4) -> MeshVertex:
        return MeshVertex {
            position: position,
            normal: normal,
            tangent: Vec4::new(1.0, 0.0, 0.0, 1.0),
            tex_coord: tex_coord,
            color: color
        }

# =============================================================================
# AABB - Axis-Aligned Bounding Box
# =============================================================================

pub struct AABB:
    min: Vec3
    max: Vec3

impl AABB:
    pub fn new(min: Vec3, max: Vec3) -> AABB:
        return AABB { min: min, max: max }

    pub fn empty() -> AABB:
        let inf = 1000000.0
        return AABB {
            min: Vec3::new(inf, inf, inf),
            max: Vec3::new(-inf, -inf, -inf)
        }

    pub fn from_point(point: Vec3) -> AABB:
        return AABB { min: point, max: point }

    pub fn expand(mut self, point: Vec3):
        self.min = Vec3::new(
            min(self.min.x, point.x),
            min(self.min.y, point.y),
            min(self.min.z, point.z)
        )
        self.max = Vec3::new(
            max(self.max.x, point.x),
            max(self.max.y, point.y),
            max(self.max.z, point.z)
        )

    pub fn center(self) -> Vec3:
        return Vec3::new(
            (self.min.x + self.max.x) / 2.0,
            (self.min.y + self.max.y) / 2.0,
            (self.min.z + self.max.z) / 2.0
        )

    pub fn size(self) -> Vec3:
        return Vec3::new(
            self.max.x - self.min.x,
            self.max.y - self.min.y,
            self.max.z - self.min.z
        )

# =============================================================================
# Mesh - Vertex and index buffer container
# =============================================================================

pub struct Mesh:
    vertices: Array[MeshVertex]
    indices: Array[u32]
    bounds: AABB

impl Mesh:
    # Constructors
    pub fn new() -> Mesh:
        return Mesh {
            vertices: Array::new(),
            indices: Array::new(),
            bounds: AABB::empty()
        }

    pub fn from_vertices(vertices: Array[MeshVertex], indices: Array[u32]) -> Mesh:
        let mut mesh = Mesh {
            vertices: vertices,
            indices: indices,
            bounds: AABB::empty()
        }
        mesh.compute_bounds()
        return mesh

    # Data access
    pub fn get_vertices(self) -> Array[MeshVertex]:
        return self.vertices

    pub fn get_indices(self) -> Array[u32]:
        return self.indices

    pub fn get_vertex_count(self) -> i32:
        return self.vertices.len()

    pub fn get_index_count(self) -> i32:
        return self.indices.len()

    pub fn get_triangle_count(self) -> i32:
        return self.indices.len() / 3

    pub fn get_bounds(self) -> AABB:
        return self.bounds

    # Modification
    pub fn add_vertex(mut self, vertex: MeshVertex):
        self.vertices.push(vertex)
        self.bounds.expand(vertex.position)

    pub fn add_triangle(mut self, i0: u32, i1: u32, i2: u32):
        self.indices.push(i0)
        self.indices.push(i1)
        self.indices.push(i2)

    pub fn clear(mut self):
        self.vertices.clear()
        self.indices.clear()
        self.bounds = AABB::empty()

    # Computation
    pub fn compute_bounds(mut self):
        self.bounds = AABB::empty()
        for vertex in self.vertices:
            self.bounds.expand(vertex.position)

    pub fn compute_normals(mut self):
        # Initialize all normals to zero
        for i in 0..self.vertices.len():
            self.vertices[i].normal = Vec3::zero()

        # Accumulate face normals
        for i in 0..self.get_triangle_count():
            let i0 = self.indices[i * 3] as i32
            let i1 = self.indices[i * 3 + 1] as i32
            let i2 = self.indices[i * 3 + 2] as i32

            let v0 = self.vertices[i0].position
            let v1 = self.vertices[i1].position
            let v2 = self.vertices[i2].position

            let edge1 = v1 - v0
            let edge2 = v2 - v0
            let normal = edge1.cross(edge2)

            self.vertices[i0].normal = self.vertices[i0].normal + normal
            self.vertices[i1].normal = self.vertices[i1].normal + normal
            self.vertices[i2].normal = self.vertices[i2].normal + normal

        # Normalize all normals
        for i in 0..self.vertices.len():
            self.vertices[i].normal = self.vertices[i].normal.normalize()

    pub fn compute_tangents(mut self):
        # Initialize all tangents to zero
        for i in 0..self.vertices.len():
            self.vertices[i].tangent = Vec4::zero()

        # Compute tangents per triangle
        for i in 0..self.get_triangle_count():
            let i0 = self.indices[i * 3] as i32
            let i1 = self.indices[i * 3 + 1] as i32
            let i2 = self.indices[i * 3 + 2] as i32

            let v0 = self.vertices[i0]
            let v1 = self.vertices[i1]
            let v2 = self.vertices[i2]

            let edge1 = v1.position - v0.position
            let edge2 = v2.position - v0.position
            let delta_uv1 = Vec2::new(
                v1.tex_coord.x - v0.tex_coord.x,
                v1.tex_coord.y - v0.tex_coord.y
            )
            let delta_uv2 = Vec2::new(
                v2.tex_coord.x - v0.tex_coord.x,
                v2.tex_coord.y - v0.tex_coord.y
            )

            let f = 1.0 / (delta_uv1.x * delta_uv2.y - delta_uv2.x * delta_uv1.y)
            let tangent = Vec3::new(
                f * (delta_uv2.y * edge1.x - delta_uv1.y * edge2.x),
                f * (delta_uv2.y * edge1.y - delta_uv1.y * edge2.y),
                f * (delta_uv2.y * edge1.z - delta_uv1.y * edge2.z)
            )

            let tangent4 = Vec4::from_vec3(tangent, 1.0)
            self.vertices[i0].tangent = self.vertices[i0].tangent + tangent4
            self.vertices[i1].tangent = self.vertices[i1].tangent + tangent4
            self.vertices[i2].tangent = self.vertices[i2].tangent + tangent4

        # Normalize tangents
        for i in 0..self.vertices.len():
            let t = self.vertices[i].tangent.xyz().normalize()
            self.vertices[i].tangent = Vec4::from_vec3(t, 1.0)

# =============================================================================
# Primitive Generators
# =============================================================================

# Generate a cube mesh (1x1x1, centered at origin)
pub fn create_cube() -> Mesh:
    let mut mesh = Mesh::new()

    # Define 8 vertices
    let vertices = [
        Vec3::new(-0.5, -0.5, -0.5),  # 0: back-bottom-left
        Vec3::new(0.5, -0.5, -0.5),   # 1: back-bottom-right
        Vec3::new(0.5, 0.5, -0.5),    # 2: back-top-right
        Vec3::new(-0.5, 0.5, -0.5),   # 3: back-top-left
        Vec3::new(-0.5, -0.5, 0.5),   # 4: front-bottom-left
        Vec3::new(0.5, -0.5, 0.5),    # 5: front-bottom-right
        Vec3::new(0.5, 0.5, 0.5),     # 6: front-top-right
        Vec3::new(-0.5, 0.5, 0.5)     # 7: front-top-left
    ]

    # Back face (-Z)
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(0.0, 0.0, -1.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(0.0, 0.0, -1.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(0.0, 0.0, -1.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(0.0, 0.0, -1.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(0, 1, 2)
    mesh.add_triangle(0, 2, 3)

    # Front face (+Z)
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(0.0, 0.0, 1.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(0.0, 0.0, 1.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(0.0, 0.0, 1.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(0.0, 0.0, 1.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(4, 5, 6)
    mesh.add_triangle(4, 6, 7)

    # Left face (-X)
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(8, 9, 10)
    mesh.add_triangle(8, 10, 11)

    # Right face (+X)
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(1.0, 0.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(1.0, 0.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(1.0, 0.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(1.0, 0.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(12, 13, 14)
    mesh.add_triangle(12, 14, 15)

    # Bottom face (-Y)
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(0.0, -1.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(0.0, -1.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(0.0, -1.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(0.0, -1.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(16, 17, 18)
    mesh.add_triangle(16, 18, 19)

    # Top face (+Y)
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(0.0, 1.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(0.0, 1.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(0.0, 1.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(0.0, 1.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(20, 21, 22)
    mesh.add_triangle(20, 22, 23)

    mesh.compute_bounds()
    return mesh

# Generate a plane mesh (1x1, XZ plane, centered at origin)
pub fn create_plane(subdivisions: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let step = 1.0 / subdivisions as f32

    # Generate vertices
    for z in 0..(subdivisions + 1):
        for x in 0..(subdivisions + 1):
            let px = (x as f32 * step) - 0.5
            let pz = (z as f32 * step) - 0.5
            let u = x as f32 * step
            let v = z as f32 * step

            mesh.add_vertex(MeshVertex::new(
                Vec3::new(px, 0.0, pz),
                Vec3::unit_y(),
                Vec2::new(u, v)
            ))

    # Generate indices
    for z in 0..subdivisions:
        for x in 0..subdivisions:
            let i0 = (z * (subdivisions + 1) + x) as u32
            let i1 = i0 + 1
            let i2 = i0 + (subdivisions + 1) as u32
            let i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a UV sphere mesh (radius 0.5, centered at origin)
pub fn create_sphere(segments: i32, rings: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359

    # Generate vertices
    for ring in 0..(rings + 1):
        let phi = (ring as f32 / rings as f32) * pi
        let y = cos(phi) * 0.5
        let ring_radius = sin(phi) * 0.5

        for segment in 0..(segments + 1):
            let theta = (segment as f32 / segments as f32) * 2.0 * pi
            let x = cos(theta) * ring_radius
            let z = sin(theta) * ring_radius

            let position = Vec3::new(x, y, z)
            let normal = position.normalize()
            let u = segment as f32 / segments as f32
            let v = ring as f32 / rings as f32

            mesh.add_vertex(MeshVertex::new(position, normal, Vec2::new(u, v)))

    # Generate indices
    for ring in 0..rings:
        for segment in 0..segments:
            let i0 = (ring * (segments + 1) + segment) as u32
            let i1 = i0 + 1
            let i2 = i0 + (segments + 1) as u32
            let i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a cylinder mesh (radius 0.5, height 1.0, centered at origin)
pub fn create_cylinder(segments: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359
    let radius = 0.5
    let half_height = 0.5

    # Top cap center
    let top_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, half_height, 0.0),
        Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Top cap vertices
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let u = (cos(theta) + 1.0) / 2.0
        let v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, half_height, z),
            Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Top cap triangles
    for i in 0..segments:
        mesh.add_triangle(
            top_center_idx,
            top_center_idx + (i + 1) as u32,
            top_center_idx + (i + 2) as u32
        )

    # Side vertices (top ring)
    let side_top_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let normal = Vec3::new(x, 0.0, z).normalize()
        let u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, half_height, z),
            normal,
            Vec2::new(u, 1.0)
        ))

    # Side vertices (bottom ring)
    let side_bottom_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let normal = Vec3::new(x, 0.0, z).normalize()
        let u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            normal,
            Vec2::new(u, 0.0)
        ))

    # Side triangles
    for i in 0..segments:
        let i0 = side_top_start + i as u32
        let i1 = i0 + 1
        let i2 = side_bottom_start + i as u32
        let i3 = i2 + 1

        mesh.add_triangle(i0, i2, i1)
        mesh.add_triangle(i1, i2, i3)

    # Bottom cap vertices
    let bottom_cap_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let u = (cos(theta) + 1.0) / 2.0
        let v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            -Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Bottom cap center
    let bottom_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, -half_height, 0.0),
        -Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Bottom cap triangles
    for i in 0..segments:
        mesh.add_triangle(
            bottom_center_idx,
            bottom_cap_start + (i + 2) as u32,
            bottom_cap_start + (i + 1) as u32
        )

    mesh.compute_bounds()
    return mesh

# Generate a cone mesh (base radius 0.5, height 1.0, centered at origin)
pub fn create_cone(segments: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359
    let radius = 0.5
    let half_height = 0.5

    # Apex vertex
    let apex_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, half_height, 0.0),
        Vec3::unit_y(),
        Vec2::new(0.5, 1.0)
    ))

    # Side vertices
    let side_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius

        # Cone normal (slanted outward)
        let tangent = Vec3::new(-z, 0.0, x).normalize()
        let up_vec = Vec3::new(0.0, half_height, 0.0) - Vec3::new(x, -half_height, z)
        let normal = tangent.cross(up_vec).normalize()

        let u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            normal,
            Vec2::new(u, 0.0)
        ))

    # Side triangles
    for i in 0..segments:
        mesh.add_triangle(
            apex_idx,
            side_start + i as u32,
            side_start + (i + 1) as u32
        )

    # Base vertices
    let base_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let u = (cos(theta) + 1.0) / 2.0
        let v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            -Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Base center
    let base_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, -half_height, 0.0),
        -Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Base triangles
    for i in 0..segments:
        mesh.add_triangle(
            base_center_idx,
            base_start + (i + 2) as u32,
            base_start + (i + 1) as u32
        )

    mesh.compute_bounds()
    return mesh

# Generate a torus mesh (major radius 0.5, minor radius 0.2)
pub fn create_torus(major_segments: i32, minor_segments: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359
    let major_radius = 0.5
    let minor_radius = 0.2

    # Generate vertices
    for major in 0..(major_segments + 1):
        let theta = (major as f32 / major_segments as f32) * 2.0 * pi
        let cos_theta = cos(theta)
        let sin_theta = sin(theta)

        for minor in 0..(minor_segments + 1):
            let phi = (minor as f32 / minor_segments as f32) * 2.0 * pi
            let cos_phi = cos(phi)
            let sin_phi = sin(phi)

            # Position
            let x = (major_radius + minor_radius * cos_phi) * cos_theta
            let y = minor_radius * sin_phi
            let z = (major_radius + minor_radius * cos_phi) * sin_theta

            # Normal
            let normal = Vec3::new(
                cos_phi * cos_theta,
                sin_phi,
                cos_phi * sin_theta
            ).normalize()

            # UV
            let u = major as f32 / major_segments as f32
            let v = minor as f32 / minor_segments as f32

            mesh.add_vertex(MeshVertex::new(
                Vec3::new(x, y, z),
                normal,
                Vec2::new(u, v)
            ))

    # Generate indices
    for major in 0..major_segments:
        for minor in 0..minor_segments:
            let i0 = (major * (minor_segments + 1) + minor) as u32
            let i1 = i0 + 1
            let i2 = i0 + (minor_segments + 1) as u32
            let i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a full-screen quad (for post-processing)
pub fn create_quad() -> Mesh:
    let mut mesh = Mesh::new()

    # Vertices in NDC space (-1 to 1)
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(-1.0, -1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(0.0, 0.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(1.0, -1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(1.0, 0.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(1.0, 1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(1.0, 1.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(-1.0, 1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(0.0, 1.0)
    ))

    mesh.add_triangle(0, 1, 2)
    mesh.add_triangle(0, 2, 3)

    mesh.compute_bounds()
    return mesh

# =============================================================================
# BoundingSphere
# =============================================================================

pub struct BoundingSphere:
    center: Vec3
    radius: f32

impl BoundingSphere:
    pub fn new(center: Vec3, radius: f32) -> BoundingSphere:
        return BoundingSphere { center: center, radius: radius }

    pub fn from_aabb(aabb: AABB) -> BoundingSphere:
        let center = aabb.center()
        let size = aabb.size()
        let radius = sqrt(size.x * size.x + size.y * size.y + size.z * size.z) / 2.0
        return BoundingSphere { center: center, radius: radius }

    pub fn contains_point(self, point: Vec3) -> bool:
        return self.center.distance_to(point) <= self.radius

    pub fn intersects(self, other: BoundingSphere) -> bool:
        let distance = self.center.distance_to(other.center)
        return distance <= (self.radius + other.radius)

# =============================================================================
# PrimitiveTopology
# =============================================================================

pub enum PrimitiveTopology:
    TriangleList
    TriangleStrip
    LineList
    LineStrip
    PointList

# Helper functions
fn min(a: f32, b: f32) -> f32:
    if a < b:
        return a
    return b

fn max(a: f32, b: f32) -> f32:
    if a > b:
        return a
    return b

fn sqrt(x: f32) -> f32:
    # Placeholder - will be provided by core
    return 0.0

fn sin(x: f32) -> f32:
    # Placeholder - will be provided by core
    return 0.0

fn cos(x: f32) -> f32:
    # Placeholder - will be provided by core
    return 0.0
