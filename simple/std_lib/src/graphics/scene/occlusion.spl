# Occlusion Culling - GPU-based visibility testing
#
# Uses GPU occlusion queries to test object visibility before rendering.
# Renders bounding box proxies with depth-only pass, queries determine
# if any pixels would be visible. Skips invisible objects to save performance.
#
# Two-frame delay strategy:
# - Frame N: Render with previous visibility results
# - Frame N: Issue new queries
# - Frame N+1: Use new query results
#
# Based on: doc/spec/graphics_3d.md (Part 3.3: Occlusion Culling)

use core.*
use graphics.math.*
use graphics.scene.*

# =============================================================================
# Occlusion Query System
# =============================================================================

pub struct OcclusionQuerySystem:
    queries: Dict<u64, OcclusionQuery>    # Node ID â†’ Query
    query_pool: Array<u64>                # Reusable query IDs
    enabled: bool                         # Global enable/off switch
    frame_delay: i32                      # Frames before using results (default: 1)
    conservative_mode: bool               # Always render first occurrence

impl OcclusionQuerySystem:
    pub fn new() -> OcclusionQuerySystem:
        return OcclusionQuerySystem {
            queries: Dict::new(),
            query_pool: Array::new(),
            enabled: true,
            frame_delay: 1,
            conservative_mode: true
        }

    # Enable/disable occlusion culling
    pub fn set_enabled(mut self, enabled: bool):
        self.enabled = enabled

    # Set frame delay (0 = immediate, 1 = one frame delay)
    pub fn set_frame_delay(mut self, delay: i32):
        self.frame_delay = max_i32(0, delay)

    # Set conservative mode (render unknown objects)
    pub fn set_conservative(mut self, conservative: bool):
        self.conservative_mode = conservative

    # Begin occlusion testing for a frame
    pub fn begin_frame(mut self):
        # Age all queries
        for (node_id, query) in self.queries.iter_mut():
            query.age()

    # Test if a node should be rendered
    pub fn should_render(self, node_id: u64, aabb: AABB) -> bool:
        if not self.enabled:
            return true

        # Check if we have a query for this node
        if not self.queries.contains_key(node_id):
            # Conservative: render first time
            return self.conservative_mode

        val query = self.queries.get(node_id).unwrap()

        # Check if results are ready
        if query.frames_since_issue <= self.frame_delay:
            # Use previous visibility state
            return query.was_visible

        # Results should be ready, but be conservative if not
        return query.is_visible or self.conservative_mode

    # Issue occlusion query for a node
    pub fn issue_query(
        mut self,
        node_id: u64,
        aabb: AABB,
        view_proj: Mat4
    ):
        if not self.enabled:
            return

        # Get or create query
        val query = if self.queries.contains_key(node_id):
            self.queries.get_mut(node_id).unwrap()
        else:
            val query_id = self.allocate_query()
            val new_query = OcclusionQuery::new(query_id, node_id)
            self.queries.insert(node_id, new_query)
            self.queries.get_mut(node_id).unwrap()

        # Issue query for bounding box
        query.issue(aabb, view_proj)

    # Collect query results
    pub fn collect_results(mut self):
        if not self.enabled:
            return

        for (node_id, query) in self.queries.iter_mut():
            query.collect_result()

    # Clean up old queries (not seen for N frames)
    pub fn cleanup_old_queries(mut self, max_age: i32):
        var to_remove = Array<u64>::new()

        for (node_id, query) in self.queries.iter():
            if query.frames_since_seen > max_age:
                to_remove.push(node_id)
                self.query_pool.push(query.query_id)

        for node_id in to_remove:
            self.queries.remove(node_id)

    # Get statistics
    pub fn get_stats(self) -> OcclusionStats:
        var stats = OcclusionStats {
            total_queries: 0,
            visible_count: 0,
            culled_count: 0,
            pending_count: 0
        }

        for (_, query) in self.queries.iter():
            stats.total_queries = stats.total_queries + 1

            if query.frames_since_issue <= self.frame_delay:
                stats.pending_count = stats.pending_count + 1
            else if query.is_visible:
                stats.visible_count = stats.visible_count + 1
            else:
                stats.culled_count = stats.culled_count + 1

        return stats

    # Internal: Allocate a query ID
    var fn allocate_query() -> u64:
        if not self.query_pool.is_empty():
            return self.query_pool.pop().unwrap()

        return extern_create_occlusion_query()

# =============================================================================
# Occlusion Query
# =============================================================================

pub struct OcclusionQuery:
    query_id: u64                # GPU query object ID
    node_id: u64                 # Associated node
    is_visible: bool             # Last visibility result
    was_visible: bool            # Previous visibility result
    frames_since_issue: i32      # Frames since query issued
    frames_since_seen: i32       # Frames since node was tested
    sample_count: u64            # Number of visible samples

impl OcclusionQuery:
    fn new(query_id: u64, node_id: u64) -> OcclusionQuery:
        return OcclusionQuery {
            query_id: query_id,
            node_id: node_id,
            is_visible: true,    # Conservative default
            was_visible: true,
            frames_since_issue: 999,
            frames_since_seen: 0,
            sample_count: 0
        }

    # Age the query (called each frame)
    var fn age():
        self.frames_since_issue = self.frames_since_issue + 1
        self.frames_since_seen = self.frames_since_seen + 1

    # Issue occlusion query for bounding box
    var fn issue(aabb: AABB, view_proj: Mat4):
        # Begin query
        extern_begin_occlusion_query(self.query_id)

        # Render bounding box proxy (depth-only, no color writes)
        render_aabb_proxy(aabb, view_proj)

        # End query
        extern_end_occlusion_query(self.query_id)

        # Reset counters
        self.frames_since_issue = 0
        self.frames_since_seen = 0

        # Store previous visibility
        self.was_visible = self.is_visible

    # Collect query result
    var fn collect_result():
        # Check if result is available
        val available = extern_is_query_result_available(self.query_id)
        if not available:
            return

        # Get sample count
        self.sample_count = extern_get_query_result(self.query_id)

        # Update visibility (any samples means visible)
        self.is_visible = self.sample_count > 0

# =============================================================================
# Hierarchical Z-Buffer (Hi-Z) Occlusion Culling
# =============================================================================

pub struct HiZOcclusionCuller:
    hiz_pyramid: Array<u64>      # Mipmap chain of depth buffer
    pyramid_levels: i32           # Number of mip levels
    base_resolution: (i32, i32)   # Base depth buffer size
    enabled: bool

impl HiZOcclusionCuller:
    pub fn new(width: i32, height: i32) -> HiZOcclusionCuller:
        val levels = calculate_mip_levels(width, height)

        var culler = HiZOcclusionCuller {
            hiz_pyramid: Array::new(),
            pyramid_levels: levels,
            base_resolution: (width, height),
            enabled: true
        }

        # Create mipmap chain
        culler.create_pyramid()

        return culler

    # Create depth pyramid
    var fn create_pyramid():
        val (mut width, mut height) = self.base_resolution

        for level in 0..self.pyramid_levels:
            val texture_id = extern_create_depth_texture(width, height)
            self.hiz_pyramid.push(texture_id)

            width = max_i32(1, width / 2)
            height = max_i32(1, height / 2)

    # Build depth pyramid from scene depth buffer
    pub fn build_pyramid(self, scene_depth_buffer: u64):
        # Copy scene depth to level 0
        extern_copy_depth_to_texture(scene_depth_buffer, self.hiz_pyramid[0])

        # Downsample each level
        for level in 1..self.pyramid_levels:
            val src = self.hiz_pyramid[level - 1]
            val dst = self.hiz_pyramid[level]

            # Max filter downsample (farthest depth)
            extern_downsample_depth_max(src, dst)

    # Test if AABB is occluded
    pub fn is_occluded(self, aabb: AABB, view_proj: Mat4) -> bool:
        if not self.enabled:
            return false

        # Project AABB to screen space
        val screen_rect = project_aabb_to_screen(aabb, view_proj)

        # Get appropriate mip level based on screen size
        val mip_level = select_mip_level(screen_rect, self.base_resolution)

        # Sample depth pyramid at mip level
        val max_pyramid_depth = sample_depth_pyramid(
            self.hiz_pyramid[mip_level],
            screen_rect,
            mip_level
        )

        # Get AABB closest depth
        val aabb_min_depth = get_aabb_min_depth(aabb, view_proj)

        # Occluded if AABB is behind pyramid depth
        return aabb_min_depth > max_pyramid_depth

    # Resize pyramid
    pub fn resize(mut self, width: i32, height: i32):
        # Clean up old pyramid
        for texture_id in self.hiz_pyramid:
            extern_destroy_texture(texture_id)

        # Recreate
        self.base_resolution = (width, height)
        self.pyramid_levels = calculate_mip_levels(width, height)
        self.hiz_pyramid.clear()
        self.create_pyramid()

# =============================================================================
# Two-Pass Occlusion Culling
# =============================================================================

pub struct TwoPassOcclusionCuller:
    query_system: OcclusionQuerySystem
    hiz_culler: Option<HiZOcclusionCuller>
    use_hiz: bool

impl TwoPassOcclusionCuller:
    pub fn new(use_hiz: bool, width: i32, height: i32) -> TwoPassOcclusionCuller:
        return TwoPassOcclusionCuller {
            query_system: OcclusionQuerySystem::new(),
            hiz_culler: if use_hiz:
                Some(HiZOcclusionCuller::new(width, height))
            else:
                None,
            use_hiz: use_hiz
        }

    # Test and cull scene nodes
    pub fn cull_scene(
        mut self,
        scene: &Scene,
        camera: &Camera,
        visible_nodes: &mut Array<u64>
    ):
        self.query_system.begin_frame()

        val view_proj = camera.get_view_projection_matrix()

        # Build Hi-Z pyramid if enabled
        if self.use_hiz and self.hiz_culler.is_some():
            val depth_buffer = extern_get_current_depth_buffer()
            self.hiz_culler.unwrap().build_pyramid(depth_buffer)

        # Test each node
        for node in scene.get_all_nodes():
            val node_id = node.get_id()
            val aabb = node.get_world_aabb()

            # Frustum culling first (cheap)
            if not camera.is_aabb_visible(aabb):
                continue

            # Hi-Z occlusion test (if enabled)
            if self.use_hiz and self.hiz_culler.is_some():
                if self.hiz_culler.unwrap().is_occluded(aabb, view_proj):
                    # Issue query anyway for next frame
                    self.query_system.issue_query(node_id, aabb, view_proj)
                    continue

            # Query-based occlusion test
            if self.query_system.should_render(node_id, aabb):
                visible_nodes.push(node_id)

            # Issue query for next frame
            self.query_system.issue_query(node_id, aabb, view_proj)

        # Collect results from previous frame
        self.query_system.collect_results()

        # Cleanup old queries
        self.query_system.cleanup_old_queries(60)

    # Get culling statistics
    pub fn get_stats(self) -> OcclusionStats:
        return self.query_system.get_stats()

# =============================================================================
# Statistics
# =============================================================================

pub struct OcclusionStats:
    total_queries: i32
    visible_count: i32
    culled_count: i32
    pending_count: i32

impl OcclusionStats:
    pub fn cull_percentage(self) -> f32:
        if self.total_queries == 0:
            return 0.0
        return (self.culled_count as f32 / self.total_queries as f32) * 100.0

# =============================================================================
# Helper Functions
# =============================================================================

fn render_aabb_proxy(aabb: AABB, view_proj: Mat4):
    # Render AABB as 12 triangles (6 faces * 2 triangles)
    # Use depth-only rendering (no color writes)
    extern_render_aabb_depth_only(aabb, view_proj)

fn project_aabb_to_screen(aabb: AABB, view_proj: Mat4) -> ScreenRect:
    # Project all 8 corners to screen space
    val corners = aabb.get_corners()
    var min_x = f32::INFINITY
    var min_y = f32::INFINITY
    var max_x = f32::NEG_INFINITY
    var max_y = f32::NEG_INFINITY

    for corner in corners:
        val proj = view_proj.transform_point(corner)
        val ndc = Vec3::new(proj.x / proj.w, proj.y / proj.w, proj.z / proj.w)

        # Convert NDC [-1,1] to screen [0,1]
        val screen_x = (ndc.x + 1.0) * 0.5
        val screen_y = (ndc.y + 1.0) * 0.5

        min_x = min_f32(min_x, screen_x)
        min_y = min_f32(min_y, screen_y)
        max_x = max_f32(max_x, screen_x)
        max_y = max_f32(max_y, screen_y)

    return ScreenRect {
        min: Vec2::new(min_x, min_y),
        max: Vec2::new(max_x, max_y)
    }

fn select_mip_level(screen_rect: ScreenRect, base_resolution: (i32, i32)) -> i32:
    val (width, height) = base_resolution
    val rect_width = (screen_rect.max.x - screen_rect.min.x) * width as f32
    val rect_height = (screen_rect.max.y - screen_rect.min.y) * height as f32

    # Use smaller dimension
    val size = min_f32(rect_width, rect_height)

    # Calculate mip level (log2)
    val mip = log2_f32(base_resolution.0 as f32 / size)
    return clamp_i32(mip as i32, 0, 10)

fn sample_depth_pyramid(
    pyramid_texture: u64,
    screen_rect: ScreenRect,
    mip_level: i32
) -> f32:
    # Sample at rectangle center
    val center = Vec2::new(
        (screen_rect.min.x + screen_rect.max.x) * 0.5,
        (screen_rect.min.y + screen_rect.max.y) * 0.5
    )

    return extern_sample_depth_texture(pyramid_texture, center, mip_level)

fn get_aabb_min_depth(aabb: AABB, view_proj: Mat4) -> f32:
    # Find closest point to camera in NDC space
    val corners = aabb.get_corners()
    var min_depth = f32::INFINITY

    for corner in corners:
        val proj = view_proj.transform_point(corner)
        val ndc_z = proj.z / proj.w
        min_depth = min_f32(min_depth, ndc_z)

    return min_depth

fn calculate_mip_levels(width: i32, height: i32) -> i32:
    val max_dim = max_i32(width, height)
    return log2_i32(max_dim) + 1

fn log2_i32(x: i32) -> i32:
    var level = 0
    var value = x
    while value > 1:
        value = value / 2
        level = level + 1
    return level

fn log2_f32(x: f32) -> f32:
    # Use math library
    return 0.0  # Placeholder

fn max_i32(a: i32, b: i32) -> i32:
    if a > b: a else: b

fn min_f32(a: f32, b: f32) -> f32:
    if a < b: a else: b

fn max_f32(a: f32, b: f32) -> f32:
    if a > b: a else: b

fn clamp_i32(value: i32, min: i32, max: i32) -> i32:
    if value < min:
        return min
    if value > max:
        return max
    return value

# =============================================================================
# Supporting Types
# =============================================================================

pub struct ScreenRect:
    min: Vec2
    max: Vec2

impl AABB:
    pub fn get_corners(self) -> Array<Vec3>:
        var corners = Array<Vec3>::new()
        corners.push(Vec3::new(self.min.x, self.min.y, self.min.z))
        corners.push(Vec3::new(self.max.x, self.min.y, self.min.z))
        corners.push(Vec3::new(self.min.x, self.max.y, self.min.z))
        corners.push(Vec3::new(self.max.x, self.max.y, self.min.z))
        corners.push(Vec3::new(self.min.x, self.min.y, self.max.z))
        corners.push(Vec3::new(self.max.x, self.min.y, self.max.z))
        corners.push(Vec3::new(self.min.x, self.max.y, self.max.z))
        corners.push(Vec3::new(self.max.x, self.max.y, self.max.z))
        return corners

# =============================================================================
# External FFI Functions
# =============================================================================

extern fn extern_create_occlusion_query() -> u64
extern fn extern_begin_occlusion_query(query_id: u64)
extern fn extern_end_occlusion_query(query_id: u64)
extern fn extern_is_query_result_available(query_id: u64) -> bool
extern fn extern_get_query_result(query_id: u64) -> u64

extern fn extern_render_aabb_depth_only(aabb: AABB, view_proj: Mat4)

extern fn extern_create_depth_texture(width: i32, height: i32) -> u64
extern fn extern_destroy_texture(texture_id: u64)
extern fn extern_copy_depth_to_texture(src: u64, dst: u64)
extern fn extern_downsample_depth_max(src: u64, dst: u64)
extern fn extern_sample_depth_texture(texture_id: u64, uv: Vec2, mip_level: i32) -> f32
extern fn extern_get_current_depth_buffer() -> u64
