# Mesh Types - Vertex and bounding box structures
#
# Core types for 3D mesh geometry.

export MeshVertex, AABB

use graphics.math.*

# =============================================================================
# MeshVertex - Vertex structure (64 bytes, cache-friendly)
# =============================================================================

pub struct MeshVertex:
    position: Vec3     # 12 bytes - World position
    normal: Vec3       # 12 bytes - Surface normal
    tangent: Vec4      # 16 bytes - Tangent + bitangent sign (w)
    tex_coord: Vec2    # 8 bytes - UV coordinates
    color: Vec4        # 16 bytes - Vertex color
    # Total: 64 bytes

impl MeshVertex:
    pub fn new(position: Vec3, normal: Vec3, tex_coord: Vec2) -> MeshVertex:
        return MeshVertex {
            position: position,
            normal: normal,
            tangent: Vec4::new(1.0, 0.0, 0.0, 1.0),
            tex_coord: tex_coord,
            color: Vec4::one()
        }

    pub fn with_color(position: Vec3, normal: Vec3, tex_coord: Vec2, color: Vec4) -> MeshVertex:
        return MeshVertex {
            position: position,
            normal: normal,
            tangent: Vec4::new(1.0, 0.0, 0.0, 1.0),
            tex_coord: tex_coord,
            color: color
        }

# =============================================================================
# AABB - Axis-Aligned Bounding Box
# =============================================================================

pub struct AABB:
    min: Vec3
    max: Vec3

impl AABB:
    pub fn new(min: Vec3, max: Vec3) -> AABB:
        return AABB { min: min, max: max }

    pub fn empty() -> AABB:
        val inf = 1000000.0
        return AABB {
            min: Vec3::new(inf, inf, inf),
            max: Vec3::new(-inf, -inf, -inf)
        }

    pub fn from_point(point: Vec3) -> AABB:
        return AABB { min: point, max: point }

    pub fn expand(mut self, point: Vec3):
        self.min = Vec3::new(
            min(self.min.x, point.x),
            min(self.min.y, point.y),
            min(self.min.z, point.z)
        )
        self.max = Vec3::new(
            max(self.max.x, point.x),
            max(self.max.y, point.y),
            max(self.max.z, point.z)
        )

    pub fn center(self) -> Vec3:
        return Vec3::new(
            (self.min.x + self.max.x) / 2.0,
            (self.min.y + self.max.y) / 2.0,
            (self.min.z + self.max.z) / 2.0
        )

    pub fn size(self) -> Vec3:
        return Vec3::new(
            self.max.x - self.min.x,
            self.max.y - self.min.y,
            self.max.z - self.min.z
        )

# Helper functions
fn min(a: f32, b: f32) -> f32:
    if a < b:
        return a
    return b

fn max(a: f32, b: f32) -> f32:
    if a > b:
        return a
    return b
