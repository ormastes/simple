# Animation State - Runtime animation playback
#
# Animation playback state with blending support.

export AnimationState, BlendState

use graphics.math.*
use skeleton.*
use animation_clip.*
use animation_utils.*

# =============================================================================
# Animation State - Runtime animation playback
# =============================================================================

pub struct AnimationState:
    skeleton: Skeleton
    current_clip: Option[AnimationClip]
    current_time: f32
    playback_speed: f32
    looping: bool
    playing: bool
    blend_states: Array[BlendState]

pub struct BlendState:
    clip: AnimationClip
    weight: f32
    time: f32

impl AnimationState:
    pub fn new(skeleton: Skeleton) -> AnimationState:
        return AnimationState {
            skeleton: skeleton,
            current_clip: None,
            current_time: 0.0,
            playback_speed: 1.0,
            looping: true,
            playing: false,
            blend_states: Array::new()
        }

    # Play animation clip
    pub fn play(mut self, clip: AnimationClip):
        self.current_clip = Some(clip)
        self.current_time = 0.0
        self.playing = true

    # Stop animation
    pub fn stop(mut self):
        self.playing = false

    # Set looping
    pub fn set_looping(mut self, looping: bool):
        self.looping = looping

    # Set playback speed
    pub fn set_speed(mut self, speed: f32):
        self.playback_speed = speed

    # Update animation (called each frame)
    pub fn update(mut self, delta_time: f32) -> Array[Mat4]:
        if not self.playing or self.current_clip.is_none():
            # Return bind pose
            return self.get_bind_pose()

        # Advance time
        self.current_time = self.current_time + delta_time * self.playback_speed

        val clip = self.current_clip.unwrap()

        # Handle looping
        if self.current_time >= clip.duration:
            if self.looping:
                self.current_time = self.current_time % clip.duration
            else:
                self.current_time = clip.duration
                self.playing = false

        # Sample animation
        val local_transforms = clip.sample(self.current_time)

        # Compute skinning matrices
        return self.compute_skinning_matrices(local_transforms)

    # Update with blending
    pub fn update_blended(mut self, delta_time: f32) -> Array[Mat4]:
        if self.blend_states.is_empty():
            return self.update(delta_time)

        # Update all blend states
        for i in 0..self.blend_states.len():
            val blend_state = &mut self.blend_states[i]
            blend_state.time = blend_state.time + delta_time * self.playback_speed

            # Loop if needed
            if blend_state.time >= blend_state.clip.duration:
                blend_state.time = blend_state.time % blend_state.clip.duration

        # Blend all animations
        val blended_transforms = self.blend_animations()

        # Compute skinning matrices
        return self.compute_skinning_matrices(blended_transforms)

    # Add blend layer
    pub fn add_blend(mut self, clip: AnimationClip, weight: f32):
        self.blend_states.push(BlendState {
            clip: clip,
            weight: weight,
            time: 0.0
        })

    # Clear blend layers
    pub fn clear_blends(mut self):
        self.blend_states.clear()

    # Blend multiple animations
    fn blend_animations() -> Array[Transform]:
        val joint_count = self.skeleton.joint_count()
        var blended = Array[Transform]::new()

        # Initialize with identity
        for _ in 0..joint_count:
            blended.push(Transform::identity())

        # Normalize weights
        var total_weight = 0.0
        for blend_state in self.blend_states:
            total_weight = total_weight + blend_state.weight

        if total_weight == 0.0:
            return blended

        # Blend each joint
        for joint_index in 0..joint_count:
            var blended_pos = Vec3::zero()
            var blended_rot = Quat::identity()
            var blended_scale = Vec3::zero()

            for blend_state in self.blend_states:
                val transforms = blend_state.clip.sample(blend_state.time)
                val normalized_weight = blend_state.weight / total_weight

                if joint_index < transforms.len() as i32:
                    val transform = transforms[joint_index as usize]

                    blended_pos = blended_pos + transform.translation * normalized_weight
                    blended_rot = slerp_quat(blended_rot, transform.rotation, normalized_weight)
                    blended_scale = blended_scale + transform.scale * normalized_weight

            blended[joint_index as usize] = Transform::new(
                blended_pos,
                blended_rot,
                blended_scale
            )

        return blended

    # Compute skinning matrices from local transforms
    fn compute_skinning_matrices(local_transforms: Array[Transform]) -> Array[Mat4]:
        val joint_count = self.skeleton.joint_count()
        var global_transforms = Array[Mat4]::new()
        var skinning_matrices = Array[Mat4]::new()

        # Initialize arrays
        for _ in 0..joint_count:
            global_transforms.push(Mat4::identity())
            skinning_matrices.push(Mat4::identity())

        # Compute global transforms (hierarchical)
        for i in 0..joint_count:
            val joint = &self.skeleton.joints[i as usize]
            val local_matrix = if i < local_transforms.len() as i32:
                local_transforms[i as usize].to_matrix()
            else:
                joint.local_transform.to_matrix()

            if joint.parent_index < 0:
                # Root joint
                global_transforms[i as usize] = local_matrix
            else:
                # Child joint
                val parent_global = global_transforms[joint.parent_index as usize]
                global_transforms[i as usize] = parent_global * local_matrix

        # Compute skinning matrices (global * inverse bind)
        for i in 0..joint_count:
            val global = global_transforms[i as usize]
            val inverse_bind = self.skeleton.inverse_bind_matrices[i as usize]
            skinning_matrices[i as usize] = global * inverse_bind

        return skinning_matrices

    # Get bind pose matrices
    fn get_bind_pose() -> Array[Mat4]:
        val joint_count = self.skeleton.joint_count()
        var matrices = Array[Mat4]::new()

        for _ in 0..joint_count:
            matrices.push(Mat4::identity())

        return matrices
