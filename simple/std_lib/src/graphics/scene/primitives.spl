# Primitives - 3D geometry generators
#
# Generates common 3D primitives: cube, plane, sphere, cylinder, cone, torus, quad.

export create_cube, create_plane, create_sphere, create_cylinder, create_cone, create_torus, create_quad

use graphics.math.*
use mesh_types.*
use mesh_class.*

# =============================================================================
# Primitive Generators
# =============================================================================

# Generate a cube mesh (1x1x1, centered at origin)
pub fn create_cube() -> Mesh:
    var mesh = Mesh::new()

    # Define 8 vertices
    val vertices = [
        Vec3::new(-0.5, -0.5, -0.5),  # 0: back-bottom-left
        Vec3::new(0.5, -0.5, -0.5),   # 1: back-bottom-right
        Vec3::new(0.5, 0.5, -0.5),    # 2: back-top-right
        Vec3::new(-0.5, 0.5, -0.5),   # 3: back-top-left
        Vec3::new(-0.5, -0.5, 0.5),   # 4: front-bottom-left
        Vec3::new(0.5, -0.5, 0.5),    # 5: front-bottom-right
        Vec3::new(0.5, 0.5, 0.5),     # 6: front-top-right
        Vec3::new(-0.5, 0.5, 0.5)     # 7: front-top-left
    ]

    # Back face (-Z)
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(0.0, 0.0, -1.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(0.0, 0.0, -1.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(0.0, 0.0, -1.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(0.0, 0.0, -1.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(0, 1, 2)
    mesh.add_triangle(0, 2, 3)

    # Front face (+Z)
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(0.0, 0.0, 1.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(0.0, 0.0, 1.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(0.0, 0.0, 1.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(0.0, 0.0, 1.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(4, 5, 6)
    mesh.add_triangle(4, 6, 7)

    # Left face (-X)
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(8, 9, 10)
    mesh.add_triangle(8, 10, 11)

    # Right face (+X)
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(1.0, 0.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(1.0, 0.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(1.0, 0.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(1.0, 0.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(12, 13, 14)
    mesh.add_triangle(12, 14, 15)

    # Bottom face (-Y)
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(0.0, -1.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(0.0, -1.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(0.0, -1.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(0.0, -1.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(16, 17, 18)
    mesh.add_triangle(16, 18, 19)

    # Top face (+Y)
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(0.0, 1.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(0.0, 1.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(0.0, 1.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(0.0, 1.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(20, 21, 22)
    mesh.add_triangle(20, 22, 23)

    mesh.compute_bounds()
    return mesh

# Generate a plane mesh (1x1, XZ plane, centered at origin)
pub fn create_plane(subdivisions: i32) -> Mesh:
    var mesh = Mesh::new()
    val step = 1.0 / subdivisions as f32

    # Generate vertices
    for z in 0..(subdivisions + 1):
        for x in 0..(subdivisions + 1):
            val px = (x as f32 * step) - 0.5
            val pz = (z as f32 * step) - 0.5
            val u = x as f32 * step
            val v = z as f32 * step

            mesh.add_vertex(MeshVertex::new(
                Vec3::new(px, 0.0, pz),
                Vec3::unit_y(),
                Vec2::new(u, v)
            ))

    # Generate indices
    for z in 0..subdivisions:
        for x in 0..subdivisions:
            val i0 = (z * (subdivisions + 1) + x) as u32
            val i1 = i0 + 1
            val i2 = i0 + (subdivisions + 1) as u32
            val i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a UV sphere mesh (radius 0.5, centered at origin)
pub fn create_sphere(segments: i32, rings: i32) -> Mesh:
    var mesh = Mesh::new()
    val pi = 3.14159265359

    # Generate vertices
    for ring in 0..(rings + 1):
        val phi = (ring as f32 / rings as f32) * pi
        val y = cos(phi) * 0.5
        val ring_radius = sin(phi) * 0.5

        for segment in 0..(segments + 1):
            val theta = (segment as f32 / segments as f32) * 2.0 * pi
            val x = cos(theta) * ring_radius
            val z = sin(theta) * ring_radius

            val position = Vec3::new(x, y, z)
            val normal = position.normalize()
            val u = segment as f32 / segments as f32
            val v = ring as f32 / rings as f32

            mesh.add_vertex(MeshVertex::new(position, normal, Vec2::new(u, v)))

    # Generate indices
    for ring in 0..rings:
        for segment in 0..segments:
            val i0 = (ring * (segments + 1) + segment) as u32
            val i1 = i0 + 1
            val i2 = i0 + (segments + 1) as u32
            val i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a cylinder mesh (radius 0.5, height 1.0, centered at origin)
pub fn create_cylinder(segments: i32) -> Mesh:
    var mesh = Mesh::new()
    val pi = 3.14159265359
    val radius = 0.5
    val half_height = 0.5

    # Top cap center
    val top_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, half_height, 0.0),
        Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Top cap vertices
    for i in 0..(segments + 1):
        val theta = (i as f32 / segments as f32) * 2.0 * pi
        val x = cos(theta) * radius
        val z = sin(theta) * radius
        val u = (cos(theta) + 1.0) / 2.0
        val v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, half_height, z),
            Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Top cap triangles
    for i in 0..segments:
        mesh.add_triangle(
            top_center_idx,
            top_center_idx + (i + 1) as u32,
            top_center_idx + (i + 2) as u32
        )

    # Side vertices (top ring)
    val side_top_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        val theta = (i as f32 / segments as f32) * 2.0 * pi
        val x = cos(theta) * radius
        val z = sin(theta) * radius
        val normal = Vec3::new(x, 0.0, z).normalize()
        val u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, half_height, z),
            normal,
            Vec2::new(u, 1.0)
        ))

    # Side vertices (bottom ring)
    val side_bottom_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        val theta = (i as f32 / segments as f32) * 2.0 * pi
        val x = cos(theta) * radius
        val z = sin(theta) * radius
        val normal = Vec3::new(x, 0.0, z).normalize()
        val u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            normal,
            Vec2::new(u, 0.0)
        ))

    # Side triangles
    for i in 0..segments:
        val i0 = side_top_start + i as u32
        val i1 = i0 + 1
        val i2 = side_bottom_start + i as u32
        val i3 = i2 + 1

        mesh.add_triangle(i0, i2, i1)
        mesh.add_triangle(i1, i2, i3)

    # Bottom cap vertices
    val bottom_cap_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        val theta = (i as f32 / segments as f32) * 2.0 * pi
        val x = cos(theta) * radius
        val z = sin(theta) * radius
        val u = (cos(theta) + 1.0) / 2.0
        val v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            -Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Bottom cap center
    val bottom_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, -half_height, 0.0),
        -Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Bottom cap triangles
    for i in 0..segments:
        mesh.add_triangle(
            bottom_center_idx,
            bottom_cap_start + (i + 2) as u32,
            bottom_cap_start + (i + 1) as u32
        )

    mesh.compute_bounds()
    return mesh

# Generate a cone mesh (base radius 0.5, height 1.0, centered at origin)
pub fn create_cone(segments: i32) -> Mesh:
    var mesh = Mesh::new()
    val pi = 3.14159265359
    val radius = 0.5
    val half_height = 0.5

    # Apex vertex
    val apex_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, half_height, 0.0),
        Vec3::unit_y(),
        Vec2::new(0.5, 1.0)
    ))

    # Side vertices
    val side_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        val theta = (i as f32 / segments as f32) * 2.0 * pi
        val x = cos(theta) * radius
        val z = sin(theta) * radius

        # Cone normal (slanted outward)
        val tangent = Vec3::new(-z, 0.0, x).normalize()
        val up_vec = Vec3::new(0.0, half_height, 0.0) - Vec3::new(x, -half_height, z)
        val normal = tangent.cross(up_vec).normalize()

        val u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            normal,
            Vec2::new(u, 0.0)
        ))

    # Side triangles
    for i in 0..segments:
        mesh.add_triangle(
            apex_idx,
            side_start + i as u32,
            side_start + (i + 1) as u32
        )

    # Base vertices
    val base_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        val theta = (i as f32 / segments as f32) * 2.0 * pi
        val x = cos(theta) * radius
        val z = sin(theta) * radius
        val u = (cos(theta) + 1.0) / 2.0
        val v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            -Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Base center
    val base_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, -half_height, 0.0),
        -Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Base triangles
    for i in 0..segments:
        mesh.add_triangle(
            base_center_idx,
            base_start + (i + 2) as u32,
            base_start + (i + 1) as u32
        )

    mesh.compute_bounds()
    return mesh

# Generate a torus mesh (major radius 0.5, minor radius 0.2)
pub fn create_torus(major_segments: i32, minor_segments: i32) -> Mesh:
    var mesh = Mesh::new()
    val pi = 3.14159265359
    val major_radius = 0.5
    val minor_radius = 0.2

    # Generate vertices
    for major in 0..(major_segments + 1):
        val theta = (major as f32 / major_segments as f32) * 2.0 * pi
        val cos_theta = cos(theta)
        val sin_theta = sin(theta)

        for minor in 0..(minor_segments + 1):
            val phi = (minor as f32 / minor_segments as f32) * 2.0 * pi
            val cos_phi = cos(phi)
            val sin_phi = sin(phi)

            # Position
            val x = (major_radius + minor_radius * cos_phi) * cos_theta
            val y = minor_radius * sin_phi
            val z = (major_radius + minor_radius * cos_phi) * sin_theta

            # Normal
            val normal = Vec3::new(
                cos_phi * cos_theta,
                sin_phi,
                cos_phi * sin_theta
            ).normalize()

            # UV
            val u = major as f32 / major_segments as f32
            val v = minor as f32 / minor_segments as f32

            mesh.add_vertex(MeshVertex::new(
                Vec3::new(x, y, z),
                normal,
                Vec2::new(u, v)
            ))

    # Generate indices
    for major in 0..major_segments:
        for minor in 0..minor_segments:
            val i0 = (major * (minor_segments + 1) + minor) as u32
            val i1 = i0 + 1
            val i2 = i0 + (minor_segments + 1) as u32
            val i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a full-screen quad (for post-processing)
pub fn create_quad() -> Mesh:
    var mesh = Mesh::new()

    # Vertices in NDC space (-1 to 1)
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(-1.0, -1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(0.0, 0.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(1.0, -1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(1.0, 0.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(1.0, 1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(1.0, 1.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(-1.0, 1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(0.0, 1.0)
    ))

    mesh.add_triangle(0, 1, 2)
    mesh.add_triangle(0, 2, 3)

    mesh.compute_bounds()
    return mesh

# Helper functions
fn sin(x: f32) -> f32:
    # Placeholder - will be provided by core
    return 0.0

fn cos(x: f32) -> f32:
    # Placeholder - will be provided by core
    return 0.0
