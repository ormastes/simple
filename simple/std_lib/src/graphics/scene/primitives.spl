# Primitives - 3D geometry generators
#
# Generates common 3D primitives: cube, plane, sphere, cylinder, cone, torus, quad.

export create_cube, create_plane, create_sphere, create_cylinder, create_cone, create_torus, create_quad

use graphics.math.*
use mesh_types.*
use mesh_class.*

# =============================================================================
# Primitive Generators
# =============================================================================

# Generate a cube mesh (1x1x1, centered at origin)
pub fn create_cube() -> Mesh:
    let mut mesh = Mesh::new()

    # Define 8 vertices
    let vertices = [
        Vec3::new(-0.5, -0.5, -0.5),  # 0: back-bottom-left
        Vec3::new(0.5, -0.5, -0.5),   # 1: back-bottom-right
        Vec3::new(0.5, 0.5, -0.5),    # 2: back-top-right
        Vec3::new(-0.5, 0.5, -0.5),   # 3: back-top-left
        Vec3::new(-0.5, -0.5, 0.5),   # 4: front-bottom-left
        Vec3::new(0.5, -0.5, 0.5),    # 5: front-bottom-right
        Vec3::new(0.5, 0.5, 0.5),     # 6: front-top-right
        Vec3::new(-0.5, 0.5, 0.5)     # 7: front-top-left
    ]

    # Back face (-Z)
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(0.0, 0.0, -1.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(0.0, 0.0, -1.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(0.0, 0.0, -1.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(0.0, 0.0, -1.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(0, 1, 2)
    mesh.add_triangle(0, 2, 3)

    # Front face (+Z)
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(0.0, 0.0, 1.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(0.0, 0.0, 1.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(0.0, 0.0, 1.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(0.0, 0.0, 1.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(4, 5, 6)
    mesh.add_triangle(4, 6, 7)

    # Left face (-X)
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(-1.0, 0.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(8, 9, 10)
    mesh.add_triangle(8, 10, 11)

    # Right face (+X)
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(1.0, 0.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(1.0, 0.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(1.0, 0.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(1.0, 0.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(12, 13, 14)
    mesh.add_triangle(12, 14, 15)

    # Bottom face (-Y)
    mesh.add_vertex(MeshVertex::new(vertices[4], Vec3::new(0.0, -1.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[5], Vec3::new(0.0, -1.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[1], Vec3::new(0.0, -1.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[0], Vec3::new(0.0, -1.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(16, 17, 18)
    mesh.add_triangle(16, 18, 19)

    # Top face (+Y)
    mesh.add_vertex(MeshVertex::new(vertices[3], Vec3::new(0.0, 1.0, 0.0), Vec2::new(0.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[2], Vec3::new(0.0, 1.0, 0.0), Vec2::new(1.0, 0.0)))
    mesh.add_vertex(MeshVertex::new(vertices[6], Vec3::new(0.0, 1.0, 0.0), Vec2::new(1.0, 1.0)))
    mesh.add_vertex(MeshVertex::new(vertices[7], Vec3::new(0.0, 1.0, 0.0), Vec2::new(0.0, 1.0)))
    mesh.add_triangle(20, 21, 22)
    mesh.add_triangle(20, 22, 23)

    mesh.compute_bounds()
    return mesh

# Generate a plane mesh (1x1, XZ plane, centered at origin)
pub fn create_plane(subdivisions: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let step = 1.0 / subdivisions as f32

    # Generate vertices
    for z in 0..(subdivisions + 1):
        for x in 0..(subdivisions + 1):
            let px = (x as f32 * step) - 0.5
            let pz = (z as f32 * step) - 0.5
            let u = x as f32 * step
            let v = z as f32 * step

            mesh.add_vertex(MeshVertex::new(
                Vec3::new(px, 0.0, pz),
                Vec3::unit_y(),
                Vec2::new(u, v)
            ))

    # Generate indices
    for z in 0..subdivisions:
        for x in 0..subdivisions:
            let i0 = (z * (subdivisions + 1) + x) as u32
            let i1 = i0 + 1
            let i2 = i0 + (subdivisions + 1) as u32
            let i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a UV sphere mesh (radius 0.5, centered at origin)
pub fn create_sphere(segments: i32, rings: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359

    # Generate vertices
    for ring in 0..(rings + 1):
        let phi = (ring as f32 / rings as f32) * pi
        let y = cos(phi) * 0.5
        let ring_radius = sin(phi) * 0.5

        for segment in 0..(segments + 1):
            let theta = (segment as f32 / segments as f32) * 2.0 * pi
            let x = cos(theta) * ring_radius
            let z = sin(theta) * ring_radius

            let position = Vec3::new(x, y, z)
            let normal = position.normalize()
            let u = segment as f32 / segments as f32
            let v = ring as f32 / rings as f32

            mesh.add_vertex(MeshVertex::new(position, normal, Vec2::new(u, v)))

    # Generate indices
    for ring in 0..rings:
        for segment in 0..segments:
            let i0 = (ring * (segments + 1) + segment) as u32
            let i1 = i0 + 1
            let i2 = i0 + (segments + 1) as u32
            let i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a cylinder mesh (radius 0.5, height 1.0, centered at origin)
pub fn create_cylinder(segments: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359
    let radius = 0.5
    let half_height = 0.5

    # Top cap center
    let top_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, half_height, 0.0),
        Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Top cap vertices
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let u = (cos(theta) + 1.0) / 2.0
        let v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, half_height, z),
            Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Top cap triangles
    for i in 0..segments:
        mesh.add_triangle(
            top_center_idx,
            top_center_idx + (i + 1) as u32,
            top_center_idx + (i + 2) as u32
        )

    # Side vertices (top ring)
    let side_top_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let normal = Vec3::new(x, 0.0, z).normalize()
        let u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, half_height, z),
            normal,
            Vec2::new(u, 1.0)
        ))

    # Side vertices (bottom ring)
    let side_bottom_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let normal = Vec3::new(x, 0.0, z).normalize()
        let u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            normal,
            Vec2::new(u, 0.0)
        ))

    # Side triangles
    for i in 0..segments:
        let i0 = side_top_start + i as u32
        let i1 = i0 + 1
        let i2 = side_bottom_start + i as u32
        let i3 = i2 + 1

        mesh.add_triangle(i0, i2, i1)
        mesh.add_triangle(i1, i2, i3)

    # Bottom cap vertices
    let bottom_cap_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let u = (cos(theta) + 1.0) / 2.0
        let v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            -Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Bottom cap center
    let bottom_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, -half_height, 0.0),
        -Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Bottom cap triangles
    for i in 0..segments:
        mesh.add_triangle(
            bottom_center_idx,
            bottom_cap_start + (i + 2) as u32,
            bottom_cap_start + (i + 1) as u32
        )

    mesh.compute_bounds()
    return mesh

# Generate a cone mesh (base radius 0.5, height 1.0, centered at origin)
pub fn create_cone(segments: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359
    let radius = 0.5
    let half_height = 0.5

    # Apex vertex
    let apex_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, half_height, 0.0),
        Vec3::unit_y(),
        Vec2::new(0.5, 1.0)
    ))

    # Side vertices
    let side_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius

        # Cone normal (slanted outward)
        let tangent = Vec3::new(-z, 0.0, x).normalize()
        let up_vec = Vec3::new(0.0, half_height, 0.0) - Vec3::new(x, -half_height, z)
        let normal = tangent.cross(up_vec).normalize()

        let u = i as f32 / segments as f32

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            normal,
            Vec2::new(u, 0.0)
        ))

    # Side triangles
    for i in 0..segments:
        mesh.add_triangle(
            apex_idx,
            side_start + i as u32,
            side_start + (i + 1) as u32
        )

    # Base vertices
    let base_start = mesh.get_vertex_count() as u32
    for i in 0..(segments + 1):
        let theta = (i as f32 / segments as f32) * 2.0 * pi
        let x = cos(theta) * radius
        let z = sin(theta) * radius
        let u = (cos(theta) + 1.0) / 2.0
        let v = (sin(theta) + 1.0) / 2.0

        mesh.add_vertex(MeshVertex::new(
            Vec3::new(x, -half_height, z),
            -Vec3::unit_y(),
            Vec2::new(u, v)
        ))

    # Base center
    let base_center_idx = mesh.get_vertex_count() as u32
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(0.0, -half_height, 0.0),
        -Vec3::unit_y(),
        Vec2::new(0.5, 0.5)
    ))

    # Base triangles
    for i in 0..segments:
        mesh.add_triangle(
            base_center_idx,
            base_start + (i + 2) as u32,
            base_start + (i + 1) as u32
        )

    mesh.compute_bounds()
    return mesh

# Generate a torus mesh (major radius 0.5, minor radius 0.2)
pub fn create_torus(major_segments: i32, minor_segments: i32) -> Mesh:
    let mut mesh = Mesh::new()
    let pi = 3.14159265359
    let major_radius = 0.5
    let minor_radius = 0.2

    # Generate vertices
    for major in 0..(major_segments + 1):
        let theta = (major as f32 / major_segments as f32) * 2.0 * pi
        let cos_theta = cos(theta)
        let sin_theta = sin(theta)

        for minor in 0..(minor_segments + 1):
            let phi = (minor as f32 / minor_segments as f32) * 2.0 * pi
            let cos_phi = cos(phi)
            let sin_phi = sin(phi)

            # Position
            let x = (major_radius + minor_radius * cos_phi) * cos_theta
            let y = minor_radius * sin_phi
            let z = (major_radius + minor_radius * cos_phi) * sin_theta

            # Normal
            let normal = Vec3::new(
                cos_phi * cos_theta,
                sin_phi,
                cos_phi * sin_theta
            ).normalize()

            # UV
            let u = major as f32 / major_segments as f32
            let v = minor as f32 / minor_segments as f32

            mesh.add_vertex(MeshVertex::new(
                Vec3::new(x, y, z),
                normal,
                Vec2::new(u, v)
            ))

    # Generate indices
    for major in 0..major_segments:
        for minor in 0..minor_segments:
            let i0 = (major * (minor_segments + 1) + minor) as u32
            let i1 = i0 + 1
            let i2 = i0 + (minor_segments + 1) as u32
            let i3 = i2 + 1

            mesh.add_triangle(i0, i2, i1)
            mesh.add_triangle(i1, i2, i3)

    mesh.compute_bounds()
    return mesh

# Generate a full-screen quad (for post-processing)
pub fn create_quad() -> Mesh:
    let mut mesh = Mesh::new()

    # Vertices in NDC space (-1 to 1)
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(-1.0, -1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(0.0, 0.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(1.0, -1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(1.0, 0.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(1.0, 1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(1.0, 1.0)
    ))
    mesh.add_vertex(MeshVertex::new(
        Vec3::new(-1.0, 1.0, 0.0),
        Vec3::new(0.0, 0.0, 1.0),
        Vec2::new(0.0, 1.0)
    ))

    mesh.add_triangle(0, 1, 2)
    mesh.add_triangle(0, 2, 3)

    mesh.compute_bounds()
    return mesh

# Helper functions
fn sin(x: f32) -> f32:
    # Placeholder - will be provided by core
    return 0.0

fn cos(x: f32) -> f32:
    # Placeholder - will be provided by core
    return 0.0
