# Material - Surface material properties
#
# Provides PBR and Phong material types for realistic
# surface shading with texture support.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.*
use graphics.scene.light.*
use units.graphics.*

# =============================================================================
# TextureHandle - Reference to a texture resource
# =============================================================================

pub struct TextureHandle:
    id: u64

impl TextureHandle:
    pub fn new(id: u64) -> TextureHandle:
        return TextureHandle { id: id }

    pub fn invalid() -> TextureHandle:
        return TextureHandle { id: 0 }

    pub fn is_valid(self) -> bool:
        return self.id != 0

# =============================================================================
# PbrMaterial - Physically Based Rendering material
# =============================================================================

pub struct PbrMaterial:
    albedo: Color                      # Base color
    metallic: Metallic                 # Metallic factor (0.0 = dielectric, 1.0 = metal)
    roughness: Roughness               # Roughness factor (0.0 = smooth, 1.0 = rough)
    emissive: Color                    # Emissive color
    ao: AmbientOcclusion               # Ambient occlusion factor
    albedo_texture: Option<TextureHandle>
    metallic_roughness_texture: Option<TextureHandle>
    normal_texture: Option<TextureHandle>
    emissive_texture: Option<TextureHandle>
    ao_texture: Option<TextureHandle>

impl PbrMaterial:
    # Constructors
    pub fn new(albedo: Color, metallic: Metallic, roughness: Roughness) -> PbrMaterial:
        return PbrMaterial {
            albedo: albedo,
            metallic: metallic,
            roughness: roughness,
            emissive: Color::black(),
            ao: 1.0_ao,
            albedo_texture: None,
            metallic_roughness_texture: None,
            normal_texture: None,
            emissive_texture: None,
            ao_texture: None
        }

    # Material presets
    pub fn default() -> PbrMaterial:
        # Default: white dielectric, medium roughness
        return PbrMaterial::new(Color::white(), 0.0_metallic, 0.5_roughness)

    pub fn metal(albedo: Color, roughness: Roughness) -> PbrMaterial:
        return PbrMaterial::new(albedo, 1.0_metallic, roughness)

    pub fn dielectric(albedo: Color, roughness: Roughness) -> PbrMaterial:
        return PbrMaterial::new(albedo, 0.0_metallic, roughness)

    pub fn gold() -> PbrMaterial:
        return PbrMaterial::metal(Color::from_hex(0xFFD700), 0.2_roughness)

    pub fn silver() -> PbrMaterial:
        return PbrMaterial::metal(Color::from_hex(0xC0C0C0), 0.1_roughness)

    pub fn copper() -> PbrMaterial:
        return PbrMaterial::metal(Color::from_hex(0xB87333), 0.3_roughness)

    pub fn plastic_red() -> PbrMaterial:
        return PbrMaterial::dielectric(Color::red(), 0.4_roughness)

    pub fn plastic_blue() -> PbrMaterial:
        return PbrMaterial::dielectric(Color::blue(), 0.4_roughness)

    pub fn rough_stone() -> PbrMaterial:
        return PbrMaterial::dielectric(Color::from_hex(0x808080), 0.9_roughness)

    # Property access
    pub fn get_albedo(self) -> Color:
        return self.albedo

    pub fn set_albedo(mut self, albedo: Color):
        self.albedo = albedo

    pub fn get_metallic(self) -> Metallic:
        return self.metallic

    pub fn set_metallic(mut self, metallic: Metallic):
        self.metallic = metallic

    pub fn get_roughness(self) -> Roughness:
        return self.roughness

    pub fn set_roughness(mut self, roughness: Roughness):
        self.roughness = roughness

    pub fn get_emissive(self) -> Color:
        return self.emissive

    pub fn set_emissive(mut self, emissive: Color):
        self.emissive = emissive

    pub fn get_ao(self) -> AmbientOcclusion:
        return self.ao

    pub fn set_ao(mut self, ao: AmbientOcclusion):
        self.ao = ao

    # Texture attachment
    pub fn set_albedo_texture(mut self, texture: TextureHandle):
        self.albedo_texture = Some(texture)

    pub fn set_metallic_roughness_texture(mut self, texture: TextureHandle):
        self.metallic_roughness_texture = Some(texture)

    pub fn set_normal_texture(mut self, texture: TextureHandle):
        self.normal_texture = Some(texture)

    pub fn set_emissive_texture(mut self, texture: TextureHandle):
        self.emissive_texture = Some(texture)

    pub fn set_ao_texture(mut self, texture: TextureHandle):
        self.ao_texture = Some(texture)

# =============================================================================
# PhongMaterial - Classic Phong shading material
# =============================================================================

pub struct PhongMaterial:
    diffuse: Color                     # Diffuse color
    specular: Color                    # Specular color
    shininess: f32                     # Specular exponent (1-128)
    emissive: Color                    # Emissive color
    diffuse_texture: Option<TextureHandle>
    specular_texture: Option<TextureHandle>
    normal_texture: Option<TextureHandle>
    emissive_texture: Option<TextureHandle>

impl PhongMaterial:
    # Constructors
    pub fn new(diffuse: Color, specular: Color, shininess: f32) -> PhongMaterial:
        return PhongMaterial {
            diffuse: diffuse,
            specular: specular,
            shininess: shininess,
            emissive: Color::black(),
            diffuse_texture: None,
            specular_texture: None,
            normal_texture: None,
            emissive_texture: None
        }

    # Material presets
    pub fn default() -> PhongMaterial:
        # Default: white diffuse, white specular, medium shininess
        return PhongMaterial::new(Color::white(), Color::white(), 32.0)

    pub fn matte(diffuse: Color) -> PhongMaterial:
        # Matte material (no specular)
        return PhongMaterial::new(diffuse, Color::black(), 1.0)

    pub fn shiny(diffuse: Color, shininess: f32) -> PhongMaterial:
        # Shiny material with white specular
        return PhongMaterial::new(diffuse, Color::white(), shininess)

    pub fn emerald() -> PhongMaterial:
        return PhongMaterial::new(
            Color::from_hex(0x50C878),
            Color::from_hex(0xA5D6A7),
            76.8
        )

    pub fn jade() -> PhongMaterial:
        return PhongMaterial::new(
            Color::from_hex(0x00A86B),
            Color::from_hex(0x7FFFD4),
            12.8
        )

    pub fn ruby() -> PhongMaterial:
        return PhongMaterial::new(
            Color::from_hex(0xE0115F),
            Color::from_hex(0xFF6B9D),
            76.8
        )

    pub fn pearl() -> PhongMaterial:
        return PhongMaterial::new(
            Color::from_hex(0xFFF0DB),
            Color::white(),
            11.264
        )

    # Property access
    pub fn get_diffuse(self) -> Color:
        return self.diffuse

    pub fn set_diffuse(mut self, diffuse: Color):
        self.diffuse = diffuse

    pub fn get_specular(self) -> Color:
        return self.specular

    pub fn set_specular(mut self, specular: Color):
        self.specular = specular

    pub fn get_shininess(self) -> f32:
        return self.shininess

    pub fn set_shininess(mut self, shininess: f32):
        self.shininess = clamp(shininess, 1.0, 128.0)

    pub fn get_emissive(self) -> Color:
        return self.emissive

    pub fn set_emissive(mut self, emissive: Color):
        self.emissive = emissive

    # Texture attachment
    pub fn set_diffuse_texture(mut self, texture: TextureHandle):
        self.diffuse_texture = Some(texture)

    pub fn set_specular_texture(mut self, texture: TextureHandle):
        self.specular_texture = Some(texture)

    pub fn set_normal_texture(mut self, texture: TextureHandle):
        self.normal_texture = Some(texture)

    pub fn set_emissive_texture(mut self, texture: TextureHandle):
        self.emissive_texture = Some(texture)

    # Lighting calculation (simplified Phong)
    pub fn calculate_lighting(
        self,
        normal: Vec3,
        view_dir: Vec3,
        light_dir: Vec3,
        light_color: Color
    ) -> Color:
        # Diffuse component
        val diff_factor = max(0.0, normal.dot(light_dir))
        val diffuse = self.diffuse.mul_color(light_color).mul_scalar(diff_factor)

        # Specular component (Blinn-Phong)
        val half_dir = (light_dir + view_dir).normalize()
        val spec_factor = pow(max(0.0, normal.dot(half_dir)), self.shininess)
        val specular = self.specular.mul_color(light_color).mul_scalar(spec_factor)

        return diffuse.add(specular).add(self.emissive)

# =============================================================================
# UnlitMaterial - No lighting, just solid color or texture
# =============================================================================

pub struct UnlitMaterial:
    color: Color
    texture: Option<TextureHandle>

impl UnlitMaterial:
    pub fn new(color: Color) -> UnlitMaterial:
        return UnlitMaterial {
            color: color,
            texture: None
        }

    pub fn default() -> UnlitMaterial:
        return UnlitMaterial::new(Color::white())

    pub fn get_color(self) -> Color:
        return self.color

    pub fn set_color(mut self, color: Color):
        self.color = color

    pub fn set_texture(mut self, texture: TextureHandle):
        self.texture = Some(texture)

# =============================================================================
# Material - Enum wrapper for all material types
# =============================================================================

pub enum Material:
    Pbr(material: PbrMaterial)
    Phong(material: PhongMaterial)
    Unlit(material: UnlitMaterial)

impl Material:
    pub fn is_pbr(self) -> bool:
        match self:
            case Material::Pbr(_):
                return true
            case _:
                return false

    pub fn is_phong(self) -> bool:
        match self:
            case Material::Phong(_):
                return true
            case _:
                return false

    pub fn is_unlit(self) -> bool:
        match self:
            case Material::Unlit(_):
                return true
            case _:
                return false

    pub fn get_pbr(self) -> Option<PbrMaterial>:
        match self:
            case Material::Pbr(material):
                return Some(material)
            case _:
                return None

    pub fn get_phong(self) -> Option<PhongMaterial>:
        match self:
            case Material::Phong(material):
                return Some(material)
            case _:
                return None

    pub fn get_unlit(self) -> Option<UnlitMaterial>:
        match self:
            case Material::Unlit(material):
                return Some(material)
            case _:
                return None

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert material type to string.

        Returns:
            Material type name

        Example:
            Material::Pbr(pbr_mat).to_string()  # → "pbr"
        """
        match self:
            case Material::Pbr(_): "pbr"
            case Material::Phong(_): "phong"
            case Material::Unlit(_): "unlit"

    pub fn description(self) -> text:
        """Get material description.

        Returns:
            Human-readable description

        Example:
            Material::Pbr(pbr_mat).description()
            # → "Physically-based rendering material"
        """
        match self:
            case Material::Pbr(_): "Physically-based rendering material"
            case Material::Phong(_): "Phong shading material (legacy)"
            case Material::Unlit(_): "Unlit material (no lighting)"

    pub fn uses_lighting(self) -> bool:
        """Check if material uses lighting calculations.

        Returns:
            false for Unlit, true otherwise

        Example:
            Material::Unlit(unlit_mat).uses_lighting()  # → false
        """
        match self:
            case Material::Unlit(_): false
            case _: true

    pub fn is_legacy(self) -> bool:
        """Check if material uses legacy shading.

        Returns:
            true for Phong

        Example:
            Material::Phong(phong_mat).is_legacy()  # → true
        """
        match self:
            case Material::Phong(_): true
            case _: false

    pub fn summary(self) -> text:
        """Get material summary.

        Returns:
            Human-readable summary

        Example:
            Material::Pbr(pbr_mat).summary()
            # → "Material: pbr (Physically-based rendering material, uses lighting)"
        """
        val name = self.to_string()
        val desc = self.description()
        val lighting = if self.uses_lighting(): "uses lighting" else: "no lighting"
        return "Material: {name} ({desc}, {lighting})"

# Helper functions
fn clamp(value: f32, min: f32, max: f32) -> f32:
    if value < min:
        return min
    if value > max:
        return max
    return value

fn max(a: f32, b: f32) -> f32:
    if a > b:
        return a
    return b

fn pow(base: f32, exp: f32) -> f32:
    # Placeholder - will be provided by core
    return 1.0
