# Skybox Shaders - Infinite-distance background rendering
#
# Renders a cubemap at infinite distance with optimized depth handling.
# Removes camera translation to create parallax-free background.
#
# Based on: doc/spec/graphics_3d.md (Part 1.4: Skybox Rendering)

use core.*
use graphics.math.*

# =============================================================================
# Skybox Vertex Input
# =============================================================================

pub struct SkyboxVertexInput:
    position: Vec3      # Cube position (-1 to 1 range)

# =============================================================================
# Skybox Uniforms
# =============================================================================

pub struct SkyboxUniforms:
    view_proj_matrix: Mat4    # View-projection (without translation)
    brightness: f32           # Exposure multiplier
    tint_color: Vec3          # Color tint

# =============================================================================
# Skybox Varyings
# =============================================================================

pub struct SkyboxVaryings:
    tex_coord: Vec3    # Cubemap sampling direction

# =============================================================================
# Skybox Vertex Shader
# =============================================================================

#[vertex_shader]
pub fn skybox_vertex_shader(
    input: SkyboxVertexInput,
    uniforms: SkyboxUniforms
) -> (Vec4, SkyboxVaryings):
    # Use cube position as cubemap sampling direction
    let tex_coord = input.position

    # Transform to clip space
    let mut clip_pos = uniforms.view_proj_matrix.transform_point(input.position)

    # Set depth to 1.0 (far plane) by setting z = w
    # After perspective divide, z/w = 1.0
    clip_pos.z = clip_pos.w

    # Output varyings
    let varyings = SkyboxVaryings {
        tex_coord: tex_coord
    }

    return (clip_pos, varyings)

# =============================================================================
# Skybox Fragment Shader
# =============================================================================

#[fragment_shader]
pub fn skybox_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: SkyboxUniforms
) -> Vec4:
    # Sample cubemap using direction vector
    let color = sample_cubemap(skybox_cubemap, varyings.tex_coord)

    # Apply brightness and tint
    let final_color = color.rgb() * uniforms.brightness * uniforms.tint_color

    return Vec4::from_vec3(final_color, 1.0)

# =============================================================================
# HDR Skybox Fragment Shader
# =============================================================================

#[fragment_shader]
pub fn skybox_hdr_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: SkyboxUniforms
) -> Vec4:
    # Sample HDR cubemap
    let hdr_color = sample_cubemap(skybox_cubemap, varyings.tex_coord)

    # Apply exposure
    let exposed = hdr_color.rgb() * uniforms.brightness

    # Tone mapping (Reinhard)
    let tone_mapped = exposed / (exposed + Vec3::one())

    # Gamma correction
    let gamma_corrected = pow_vec3(tone_mapped, Vec3::new(1.0 / 2.2, 1.0 / 2.2, 1.0 / 2.2))

    # Apply tint
    let final_color = gamma_corrected * uniforms.tint_color

    return Vec4::from_vec3(final_color, 1.0)

# =============================================================================
# Procedural Sky Fragment Shader
# =============================================================================

pub struct ProceduralSkyUniforms:
    view_proj_matrix: Mat4
    sun_direction: Vec3
    sun_color: Vec3
    sky_color: Vec3
    horizon_color: Vec3
    ground_color: Vec3
    sun_size: f32
    atmosphere_intensity: f32

#[fragment_shader]
pub fn procedural_sky_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: ProceduralSkyUniforms
) -> Vec4:
    let dir = varyings.tex_coord.normalize()

    # Calculate gradient based on Y coordinate
    let t = (dir.y + 1.0) * 0.5  # Map -1..1 to 0..1

    # Sky gradient
    let sky_gradient = if dir.y >= 0.0:
        # Upper hemisphere: sky to horizon
        lerp_vec3(uniforms.horizon_color, uniforms.sky_color, dir.y)
    else:
        # Lower hemisphere: horizon to ground
        lerp_vec3(uniforms.ground_color, uniforms.horizon_color, dir.y + 1.0)

    # Sun contribution
    let sun_dot = max(dot(dir, uniforms.sun_direction), 0.0)
    let sun_intensity = pow(sun_dot, 1.0 / uniforms.sun_size)
    let sun_contribution = uniforms.sun_color * sun_intensity

    # Atmospheric scattering (simple approximation)
    let atmosphere = uniforms.atmosphere_intensity * pow(1.0 - abs(dir.y), 2.0)
    let atmosphere_color = uniforms.sun_color * atmosphere

    # Combine
    let final_color = sky_gradient + sun_contribution + atmosphere_color

    return Vec4::from_vec3(final_color, 1.0)

# =============================================================================
# Starfield Fragment Shader
# =============================================================================

pub struct StarfieldUniforms:
    view_proj_matrix: Mat4
    star_brightness: f32
    nebula_color: Vec3
    nebula_intensity: f32
    time: f32  # For twinkling

#[fragment_shader]
pub fn starfield_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: StarfieldUniforms
) -> Vec4:
    let dir = varyings.tex_coord.normalize()

    # Generate stars using hash function
    let star_density = 0.001
    let star_hash = hash_direction(dir)

    let mut color = Vec3::zero()

    # Stars
    if star_hash < star_density:
        let star_size = fract(star_hash * 1000.0)
        let star_intensity = star_size * uniforms.star_brightness

        # Twinkling effect
        let twinkle = sin(uniforms.time * 5.0 + star_hash * 100.0) * 0.3 + 0.7

        color = color + Vec3::one() * star_intensity * twinkle

    # Nebula (noise-based)
    let nebula_noise = simplex_noise_3d(dir * 2.0)
    let nebula = max(nebula_noise, 0.0) * uniforms.nebula_intensity
    color = color + uniforms.nebula_color * nebula

    return Vec4::from_vec3(color, 1.0)

# =============================================================================
# Helper Functions
# =============================================================================

fn max(a: f32, b: f32) -> f32:
    return if a > b: a else: b

fn dot(a: Vec3, b: Vec3) -> f32:
    return a.x * b.x + a.y * b.y + a.z * b.z

fn pow(base: f32, exp: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn pow_vec3(v: Vec3, exp: Vec3) -> Vec3:
    return Vec3::new(
        pow(v.x, exp.x),
        pow(v.y, exp.y),
        pow(v.z, exp.z)
    )

fn lerp_vec3(a: Vec3, b: Vec3, t: f32) -> Vec3:
    return a * (1.0 - t) + b * t

fn fract(x: f32) -> f32:
    # Would use math library
    return x - floor(x)

fn floor(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn sin(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

# Simple hash function for procedural generation
fn hash_direction(dir: Vec3) -> f32:
    let p = Vec3::new(
        dot(dir, Vec3::new(127.1, 311.7, 74.7)),
        dot(dir, Vec3::new(269.5, 183.3, 246.1)),
        dot(dir, Vec3::new(113.5, 271.9, 124.6))
    )

    return fract(sin(p.x + p.y + p.z) * 43758.5453123)

# Simplex noise (3D)
fn simplex_noise_3d(p: Vec3) -> f32:
    # Simplified noise - would use proper simplex implementation
    let hash = hash_direction(p)
    return hash * 2.0 - 1.0  # Map to -1..1

# =============================================================================
# Texture Sampling
# =============================================================================

extern fn sample_cubemap(cubemap_id: u64, direction: Vec3) -> Vec4
extern fn skybox_cubemap() -> u64
