# PBR with IBL - Enhanced PBR shader with Image-Based Lighting
#
# Integrates diffuse irradiance and specular reflection from environment
# maps for photorealistic global illumination.
#
# Based on: doc/spec/graphics_3d.md (Part 4.2 + 1.2: PBR + IBL)

use core.*
use graphics.math.*
use graphics.scene.*

# =============================================================================
# Enhanced PBR Uniforms with IBL
# =============================================================================

pub struct PBRIBLMaterialUniforms:
    # Base PBR properties
    albedo_color: Vec3
    metallic: f32
    roughness: f32
    ao: f32
    emissive: Vec3

    # Texture flags
    use_albedo_map: bool
    use_metallic_roughness_map: bool
    use_normal_map: bool
    use_ao_map: bool
    use_emissive_map: bool

    # IBL settings
    use_ibl: bool
    ibl_diffuse_intensity: f32    # Default: 1.0
    ibl_specular_intensity: f32   # Default: 1.0

# =============================================================================
# Enhanced PBR Fragment Shader with IBL
# =============================================================================

#[fragment_shader]
pub fn pbr_ibl_fragment_shader(
    varyings: PBRVaryings,
    material: PBRIBLMaterialUniforms,
    lighting: PBRLightingUniforms
) -> Vec4:
    # Sample textures (same as basic PBR)
    let albedo = if material.use_albedo_map:
        sample_texture_2d(albedo_map, varyings.tex_coord).rgb() * material.albedo_color
    else:
        material.albedo_color

    let metallic = if material.use_metallic_roughness_map:
        sample_texture_2d(metallic_roughness_map, varyings.tex_coord).b
    else:
        material.metallic

    let roughness = if material.use_metallic_roughness_map:
        sample_texture_2d(metallic_roughness_map, varyings.tex_coord).g
    else:
        material.roughness

    let ao = if material.use_ao_map:
        sample_texture_2d(ao_map, varyings.tex_coord).r
    else:
        material.ao

    let emissive = if material.use_emissive_map:
        sample_texture_2d(emissive_map, varyings.tex_coord).rgb() * material.emissive
    else:
        material.emissive

    # Get normal from normal map or vertex normal
    let N = if material.use_normal_map:
        let normal_sample = sample_texture_2d(normal_map, varyings.tex_coord).rgb()
        let normal_tangent = normal_sample * 2.0 - Vec3::one()

        let T = varyings.tangent_world.normalize()
        let B = varyings.bitangent_world.normalize()
        let N_base = varyings.normal_world.normalize()

        (T * normal_tangent.x + B * normal_tangent.y + N_base * normal_tangent.z).normalize()
    else:
        varyings.normal_world.normalize()

    let V = varyings.view_dir.normalize()

    # Calculate reflectance at normal incidence
    let F0 = Vec3::new(0.04, 0.04, 0.04)
    let F0 = lerp_vec3(F0, albedo, metallic)

    # =============================================================================
    # Direct Lighting (same as basic PBR)
    # =============================================================================

    let mut Lo = Vec3::zero()

    # Directional light
    Lo = Lo + calculate_directional_light(N, V, albedo, metallic, roughness, F0, lighting)

    # Point lights
    for i in 0..lighting.point_light_count:
        Lo = Lo + calculate_point_light(
            varyings.position_world,
            N,
            V,
            albedo,
            metallic,
            roughness,
            F0,
            lighting.point_light_positions[i],
            lighting.point_light_colors[i],
            lighting.point_light_intensities[i],
            lighting.point_light_ranges[i]
        )

    # =============================================================================
    # Image-Based Lighting (IBL)
    # =============================================================================

    let ambient = if material.use_ibl:
        calculate_ibl_contribution(
            N,
            V,
            F0,
            albedo,
            roughness,
            metallic,
            ao,
            material.ibl_diffuse_intensity,
            material.ibl_specular_intensity
        )
    else:
        # Fallback to simple ambient
        let kD = (Vec3::one() - F0) * (1.0 - metallic)
        kD * albedo * lighting.ambient_color * lighting.ambient_intensity * ao

    # =============================================================================
    # Final Color
    # =============================================================================

    let mut color = ambient + Lo + emissive

    # HDR tone mapping (Reinhard)
    color = color / (color + Vec3::one())

    # Gamma correction
    color = pow_vec3(color, Vec3::new(1.0 / 2.2, 1.0 / 2.2, 1.0 / 2.2))

    return Vec4::from_vec3(color, 1.0)

# =============================================================================
# IBL Contribution Calculation
# =============================================================================

fn calculate_ibl_contribution(
    N: Vec3,
    V: Vec3,
    F0: Vec3,
    albedo: Vec3,
    roughness: f32,
    metallic: f32,
    ao: f32,
    diffuse_intensity: f32,
    specular_intensity: f32
) -> Vec3:
    # Reflection vector
    let R = reflect(-V, N)

    # Fresnel for IBL (with roughness)
    let F = fresnel_schlick_roughness(max(N.dot(V), 0.0), F0, roughness)

    # Energy conservation
    let kS = F
    let mut kD = Vec3::one() - kS
    kD = kD * (1.0 - metallic)

    # =============================================================================
    # Diffuse IBL (Irradiance)
    # =============================================================================

    let irradiance = sample_cubemap(irradiance_map, N).rgb()
    let diffuse = irradiance * albedo

    # =============================================================================
    # Specular IBL (Prefiltered Environment + BRDF LUT)
    # =============================================================================

    # Sample prefiltered environment at appropriate roughness level
    let max_reflection_lod = 4.0  # Number of mip levels - 1
    let prefiltered_color = sample_cubemap_lod(
        prefiltered_env_map,
        R,
        roughness * max_reflection_lod
    ).rgb()

    # Sample BRDF integration LUT
    let NdotV = max(N.dot(V), 0.0)
    let brdf = sample_texture_2d(
        brdf_lut,
        Vec2::new(NdotV, roughness)
    ).rg()

    # Combine specular terms
    let specular = prefiltered_color * (F * brdf.x + brdf.y)

    # =============================================================================
    # Combine IBL
    # =============================================================================

    let ibl = (kD * diffuse * diffuse_intensity + specular * specular_intensity) * ao

    return ibl

# =============================================================================
# Direct Lighting Functions (from pbr.spl)
# =============================================================================

fn calculate_directional_light(
    N: Vec3,
    V: Vec3,
    albedo: Vec3,
    metallic: f32,
    roughness: f32,
    F0: Vec3,
    light: PBRLightingUniforms
) -> Vec3:
    if light.dir_light_intensity <= 0.0:
        return Vec3::zero()

    let L = -light.dir_light_direction.normalize()
    let H = (V + L).normalize()

    let radiance = light.dir_light_color * light.dir_light_intensity

    let NDF = distribution_ggx(N, H, roughness)
    let G = geometry_smith(N, V, L, roughness)
    let F = fresnel_schlick(max(H.dot(V), 0.0), F0)

    let numerator = NDF * G * F
    let denominator = 4.0 * max(N.dot(V), 0.0) * max(N.dot(L), 0.0) + 0.0001
    let specular = numerator / denominator

    let kS = F
    let mut kD = Vec3::one() - kS
    kD = kD * (1.0 - metallic)

    let NdotL = max(N.dot(L), 0.0)
    return (kD * albedo / PI + specular) * radiance * NdotL

fn calculate_point_light(
    position_world: Vec3,
    N: Vec3,
    V: Vec3,
    albedo: Vec3,
    metallic: f32,
    roughness: f32,
    F0: Vec3,
    light_pos: Vec3,
    light_color: Vec3,
    light_intensity: f32,
    light_range: f32
) -> Vec3:
    let L = (light_pos - position_world).normalize()
    let H = (V + L).normalize()

    let distance = (light_pos - position_world).length()
    let attenuation = 1.0 / (distance * distance)
    let attenuation = attenuation * clamp((light_range - distance) / light_range, 0.0, 1.0)

    let radiance = light_color * light_intensity * attenuation

    let NDF = distribution_ggx(N, H, roughness)
    let G = geometry_smith(N, V, L, roughness)
    let F = fresnel_schlick(max(H.dot(V), 0.0), F0)

    let numerator = NDF * G * F
    let denominator = 4.0 * max(N.dot(V), 0.0) * max(N.dot(L), 0.0) + 0.0001
    let specular = numerator / denominator

    let kS = F
    let mut kD = Vec3::one() - kS
    kD = kD * (1.0 - metallic)

    let NdotL = max(N.dot(L), 0.0)
    return (kD * albedo / PI + specular) * radiance * NdotL

# =============================================================================
# BRDF Functions
# =============================================================================

const PI: f32 = 3.14159265359

fn distribution_ggx(N: Vec3, H: Vec3, roughness: f32) -> f32:
    let a = roughness * roughness
    let a2 = a * a
    let NdotH = max(N.dot(H), 0.0)
    let NdotH2 = NdotH * NdotH

    let nom = a2
    let denom = (NdotH2 * (a2 - 1.0) + 1.0)
    let denom = PI * denom * denom

    return nom / denom

fn geometry_schlick_ggx(NdotV: f32, roughness: f32) -> f32:
    let r = roughness + 1.0
    let k = (r * r) / 8.0

    let nom = NdotV
    let denom = NdotV * (1.0 - k) + k

    return nom / denom

fn geometry_smith(N: Vec3, V: Vec3, L: Vec3, roughness: f32) -> f32:
    let NdotV = max(N.dot(V), 0.0)
    let NdotL = max(N.dot(L), 0.0)
    let ggx2 = geometry_schlick_ggx(NdotV, roughness)
    let ggx1 = geometry_schlick_ggx(NdotL, roughness)

    return ggx1 * ggx2

fn fresnel_schlick(cos_theta: f32, F0: Vec3) -> Vec3:
    return F0 + (Vec3::one() - F0) * pow(1.0 - cos_theta, 5.0)

fn fresnel_schlick_roughness(cos_theta: f32, F0: Vec3, roughness: f32) -> Vec3:
    let one_minus_roughness = Vec3::new(1.0 - roughness, 1.0 - roughness, 1.0 - roughness)
    return F0 + (max_vec3(one_minus_roughness, F0) - F0) * pow(1.0 - cos_theta, 5.0)

# =============================================================================
# Helper Functions
# =============================================================================

fn max(a: f32, b: f32) -> f32:
    return if a > b: a else: b

fn clamp(value: f32, min: f32, max: f32) -> f32:
    if value < min:
        return min
    if value > max:
        return max
    return value

fn pow(base: f32, exp: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn pow_vec3(v: Vec3, exp: Vec3) -> Vec3:
    return Vec3::new(
        pow(v.x, exp.x),
        pow(v.y, exp.y),
        pow(v.z, exp.z)
    )

fn lerp_vec3(a: Vec3, b: Vec3, t: f32) -> Vec3:
    return a * (1.0 - t) + b * t

fn max_vec3(a: Vec3, b: Vec3) -> Vec3:
    return Vec3::new(
        max(a.x, b.x),
        max(a.y, b.y),
        max(a.z, b.z)
    )

fn reflect(I: Vec3, N: Vec3) -> Vec3:
    return I - N * 2.0 * I.dot(N)

# =============================================================================
# Texture Sampling
# =============================================================================

extern fn sample_texture_2d(texture_id: u64, uv: Vec2) -> Vec4
extern fn sample_cubemap(cubemap_id: u64, direction: Vec3) -> Vec4
extern fn sample_cubemap_lod(cubemap_id: u64, direction: Vec3, lod: f32) -> Vec4

extern fn albedo_map() -> u64
extern fn metallic_roughness_map() -> u64
extern fn normal_map() -> u64
extern fn ao_map() -> u64
extern fn emissive_map() -> u64

# IBL maps
extern fn irradiance_map() -> u64
extern fn prefiltered_env_map() -> u64
extern fn brdf_lut() -> u64
