# Texture - Vulkan texture management for 3D rendering
#
# Provides 2D texture and cubemap creation, loading,
# and sampling for material textures.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.scene.*

# =============================================================================
# TextureFormat - Supported texture formats
# =============================================================================

pub enum TextureFormat:
    RGBA8         # 8-bit per channel RGBA
    RGB8          # 8-bit per channel RGB
    RG8           # 8-bit per channel RG
    R8            # 8-bit single channel
    RGBA16F       # 16-bit f32 per channel RGBA
    RGB16F        # 16-bit f32 per channel RGB
    RGBA32F       # 32-bit f32 per channel RGBA
    Depth24Stencil8  # 24-bit depth + 8-bit stencil

impl TextureFormat:
    pub fn bytes_per_pixel(self) -> u32:
        match self:
            case TextureFormat::RGBA8:
                return 4
            case TextureFormat::RGB8:
                return 3
            case TextureFormat::RG8:
                return 2
            case TextureFormat::R8:
                return 1
            case TextureFormat::RGBA16F:
                return 8
            case TextureFormat::RGB16F:
                return 6
            case TextureFormat::RGBA32F:
                return 16
            case TextureFormat::Depth24Stencil8:
                return 4

    pub fn to_vulkan_format(self) -> u32:
        match self:
            case TextureFormat::RGBA8:
                return VK_FORMAT_R8G8B8A8_UNORM
            case TextureFormat::RGB8:
                return VK_FORMAT_R8G8B8_UNORM
            case TextureFormat::RG8:
                return VK_FORMAT_R8G8_UNORM
            case TextureFormat::R8:
                return VK_FORMAT_R8_UNORM
            case TextureFormat::RGBA16F:
                return VK_FORMAT_R16G16B16A16_SFLOAT
            case TextureFormat::RGB16F:
                return VK_FORMAT_R16G16B16_SFLOAT
            case TextureFormat::RGBA32F:
                return VK_FORMAT_R32G32B32A32_SFLOAT
            case TextureFormat::Depth24Stencil8:
                return VK_FORMAT_D24_UNORM_S8_UINT

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert texture format to string.

        Returns:
            Format name

        Example:
            TextureFormat::RGBA8.to_string()  # → "rgba8"
        """
        match self:
            case TextureFormat::RGBA8: "rgba8"
            case TextureFormat::RGB8: "rgb8"
            case TextureFormat::RG8: "rg8"
            case TextureFormat::R8: "r8"
            case TextureFormat::RGBA16F: "rgba16f"
            case TextureFormat::RGB16F: "rgb16f"
            case TextureFormat::RGBA32F: "rgba32f"
            case TextureFormat::Depth24Stencil8: "depth24stencil8"

    pub fn description(self) -> text:
        """Get format description.

        Returns:
            Human-readable description

        Example:
            TextureFormat::RGBA8.description()  # → "8-bit per channel RGBA"
        """
        match self:
            case TextureFormat::RGBA8: "8-bit per channel RGBA"
            case TextureFormat::RGB8: "8-bit per channel RGB"
            case TextureFormat::RG8: "8-bit per channel RG"
            case TextureFormat::R8: "8-bit single channel"
            case TextureFormat::RGBA16F: "16-bit f32 per channel RGBA"
            case TextureFormat::RGB16F: "16-bit f32 per channel RGB"
            case TextureFormat::RGBA32F: "32-bit f32 per channel RGBA"
            case TextureFormat::Depth24Stencil8: "24-bit depth + 8-bit stencil"

    pub fn is_float(self) -> bool:
        """Check if format uses floating point values.

        Returns:
            true for *16F and *32F formats

        Example:
            TextureFormat::RGBA16F.is_float()  # → true
        """
        match self:
            case TextureFormat::RGBA16F: true
            case TextureFormat::RGB16F: true
            case TextureFormat::RGBA32F: true
            case _: false

    pub fn is_depth_stencil(self) -> bool:
        """Check if format is depth/stencil.

        Returns:
            true for Depth24Stencil8

        Example:
            TextureFormat::Depth24Stencil8.is_depth_stencil()  # → true
        """
        match self:
            case TextureFormat::Depth24Stencil8: true
            case _: false

    pub fn has_alpha(self) -> bool:
        """Check if format has alpha channel.

        Returns:
            true for RGBA formats

        Example:
            TextureFormat::RGBA8.has_alpha()  # → true
        """
        match self:
            case TextureFormat::RGBA8: true
            case TextureFormat::RGBA16F: true
            case TextureFormat::RGBA32F: true
            case _: false

    pub fn channel_count(self) -> u32:
        """Get number of color channels.

        Returns:
            Number of channels (1-4)

        Example:
            TextureFormat::RGBA8.channel_count()  # → 4
        """
        match self:
            case TextureFormat::RGBA8: 4
            case TextureFormat::RGB8: 3
            case TextureFormat::RG8: 2
            case TextureFormat::R8: 1
            case TextureFormat::RGBA16F: 4
            case TextureFormat::RGB16F: 3
            case TextureFormat::RGBA32F: 4
            case TextureFormat::Depth24Stencil8: 2

    pub fn summary(self) -> text:
        """Get texture format summary.

        Returns:
            Human-readable summary

        Example:
            TextureFormat::RGBA8.summary()
            # → "TextureFormat: rgba8 (8-bit per channel RGBA, 4 bytes/pixel, 4 channels)"
        """
        val name = self.to_string()
        val desc = self.description()
        val bpp = self.bytes_per_pixel()
        val channels = self.channel_count()
        return "TextureFormat: {name} ({desc}, {bpp} bytes/pixel, {channels} channels)"

# =============================================================================
# TextureFilter - Texture filtering modes
# =============================================================================

pub enum TextureFilter:
    Nearest       # Nearest neighbor (pixelated)
    Linear        # Bilinear filtering (smooth)
    Trilinear     # Trilinear with mipmaps

impl TextureFilter:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert texture filter to string.

        Returns:
            Filter name

        Example:
            TextureFilter::Linear.to_string()  # → "linear"
        """
        match self:
            case TextureFilter::Nearest: "nearest"
            case TextureFilter::Linear: "linear"
            case TextureFilter::Trilinear: "trilinear"

    pub fn description(self) -> text:
        """Get filter description.

        Returns:
            Human-readable description

        Example:
            TextureFilter::Linear.description()  # → "Bilinear filtering (smooth)"
        """
        match self:
            case TextureFilter::Nearest: "Nearest neighbor (pixelated)"
            case TextureFilter::Linear: "Bilinear filtering (smooth)"
            case TextureFilter::Trilinear: "Trilinear with mipmaps"

    pub fn is_nearest(self) -> bool:
        """Check if Nearest filter."""
        match self:
            case TextureFilter::Nearest: true
            case _: false

    pub fn is_linear(self) -> bool:
        """Check if Linear filter."""
        match self:
            case TextureFilter::Linear: true
            case _: false

    pub fn is_trilinear(self) -> bool:
        """Check if Trilinear filter."""
        match self:
            case TextureFilter::Trilinear: true
            case _: false

    pub fn uses_mipmaps(self) -> bool:
        """Check if filter uses mipmaps.

        Returns:
            true for Trilinear

        Example:
            TextureFilter::Trilinear.uses_mipmaps()  # → true
        """
        match self:
            case TextureFilter::Trilinear: true
            case _: false

    pub fn summary(self) -> text:
        """Get texture filter summary.

        Returns:
            Human-readable summary

        Example:
            TextureFilter::Trilinear.summary()
            # → "TextureFilter: trilinear (Trilinear with mipmaps, uses mipmaps)"
        """
        val name = self.to_string()
        val desc = self.description()
        val mipmaps = if self.uses_mipmaps(): "uses mipmaps" else: "no mipmaps"
        return "TextureFilter: {name} ({desc}, {mipmaps})"

# =============================================================================
# TextureWrap - Texture wrapping modes
# =============================================================================

pub enum TextureWrap:
    Repeat        # Repeat texture
    MirroredRepeat  # Mirror and repeat
    ClampToEdge   # Clamp to edge color
    ClampToBorder  # Clamp to border color

impl TextureWrap:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert texture wrap to string.

        Returns:
            Wrap mode name

        Example:
            TextureWrap::Repeat.to_string()  # → "repeat"
        """
        match self:
            case TextureWrap::Repeat: "repeat"
            case TextureWrap::MirroredRepeat: "mirrored_repeat"
            case TextureWrap::ClampToEdge: "clamp_to_edge"
            case TextureWrap::ClampToBorder: "clamp_to_border"

    pub fn description(self) -> text:
        """Get wrap mode description.

        Returns:
            Human-readable description

        Example:
            TextureWrap::Repeat.description()  # → "Repeat texture"
        """
        match self:
            case TextureWrap::Repeat: "Repeat texture"
            case TextureWrap::MirroredRepeat: "Mirror and repeat"
            case TextureWrap::ClampToEdge: "Clamp to edge color"
            case TextureWrap::ClampToBorder: "Clamp to border color"

    pub fn is_repeat(self) -> bool:
        """Check if Repeat mode."""
        match self:
            case TextureWrap::Repeat: true
            case _: false

    pub fn is_mirrored_repeat(self) -> bool:
        """Check if MirroredRepeat mode."""
        match self:
            case TextureWrap::MirroredRepeat: true
            case _: false

    pub fn is_clamp_to_edge(self) -> bool:
        """Check if ClampToEdge mode."""
        match self:
            case TextureWrap::ClampToEdge: true
            case _: false

    pub fn is_clamp_to_border(self) -> bool:
        """Check if ClampToBorder mode."""
        match self:
            case TextureWrap::ClampToBorder: true
            case _: false

    pub fn repeats(self) -> bool:
        """Check if wrap mode repeats.

        Returns:
            true for Repeat or MirroredRepeat

        Example:
            TextureWrap::Repeat.repeats()  # → true
        """
        match self:
            case TextureWrap::Repeat: true
            case TextureWrap::MirroredRepeat: true
            case _: false

    pub fn clamps(self) -> bool:
        """Check if wrap mode clamps.

        Returns:
            true for ClampToEdge or ClampToBorder

        Example:
            TextureWrap::ClampToEdge.clamps()  # → true
        """
        match self:
            case TextureWrap::ClampToEdge: true
            case TextureWrap::ClampToBorder: true
            case _: false

    pub fn summary(self) -> text:
        """Get texture wrap summary.

        Returns:
            Human-readable summary

        Example:
            TextureWrap::MirroredRepeat.summary()
            # → "TextureWrap: mirrored_repeat (Mirror and repeat, repeats)"
        """
        val name = self.to_string()
        val desc = self.description()
        val behavior = if self.repeats(): "repeats" else: "clamps"
        return "TextureWrap: {name} ({desc}, {behavior})"

# =============================================================================
# Texture2D - 2D texture
# =============================================================================

pub struct Texture2D:
    handle: TextureHandle
    image: u64           # Vulkan image handle
    view: u64            # Vulkan image view handle
    sampler: u64         # Vulkan sampler handle
    memory: u64          # Vulkan memory handle
    format: TextureFormat
    width: u32
    height: u32
    mip_levels: u32

impl Texture2D:
    # Create empty texture
    pub fn new(width: u32, height: u32, format: TextureFormat) -> Texture2D:
        val mip_levels = calculate_mip_levels(width, height)
        val vk_format = format.to_vulkan_format()

        val (image, view, sampler, memory) = vk_create_texture_2d(
            width,
            height,
            mip_levels,
            vk_format
        )

        return Texture2D {
            handle: TextureHandle::new(image),
            image: image,
            view: view,
            sampler: sampler,
            memory: memory,
            format: format,
            width: width,
            height: height,
            mip_levels: mip_levels
        }

    # Create from pixel data
    pub fn from_pixels(
        width: u32,
        height: u32,
        format: TextureFormat,
        pixels: Array<u8>
    ) -> Texture2D:
        var texture = Texture2D::new(width, height, format)
        texture.upload_pixels(pixels)
        return texture

    # Upload pixel data
    pub fn upload_pixels(self, pixels: Array<u8>):
        vk_upload_texture_pixels(self.image, pixels, self.width, self.height)

    # Generate mipmaps
    pub fn generate_mipmaps(self):
        vk_generate_mipmaps(self.image, self.width, self.height, self.mip_levels)

    # Set filtering mode
    pub fn set_filter(mut self, filter: TextureFilter):
        vk_set_texture_filter(self.sampler, filter)

    # Set wrapping mode
    pub fn set_wrap(mut self, wrap: TextureWrap):
        vk_set_texture_wrap(self.sampler, wrap)

    # Getters
    pub fn get_handle(self) -> TextureHandle:
        return self.handle

    pub fn get_image(self) -> u64:
        return self.image

    pub fn get_view(self) -> u64:
        return self.view

    pub fn get_sampler(self) -> u64:
        return self.sampler

    pub fn get_width(self) -> u32:
        return self.width

    pub fn get_height(self) -> u32:
        return self.height

    pub fn get_format(self) -> TextureFormat:
        return self.format

    # Cleanup
    pub fn destroy(self):
        vk_destroy_texture(self.image, self.view, self.sampler, self.memory)

# =============================================================================
# CubemapTexture - Cubemap texture for skyboxes and reflections
# =============================================================================

pub struct CubemapTexture:
    handle: TextureHandle
    image: u64
    view: u64
    sampler: u64
    memory: u64
    format: TextureFormat
    size: u32            # Width/height of each face
    mip_levels: u32

impl CubemapTexture:
    # Create empty cubemap
    pub fn new(size: u32, format: TextureFormat) -> CubemapTexture:
        val mip_levels = calculate_mip_levels(size, size)
        val vk_format = format.to_vulkan_format()

        val (image, view, sampler, memory) = vk_create_texture_cubemap(
            size,
            mip_levels,
            vk_format
        )

        return CubemapTexture {
            handle: TextureHandle::new(image),
            image: image,
            view: view,
            sampler: sampler,
            memory: memory,
            format: format,
            size: size,
            mip_levels: mip_levels
        }

    # Upload pixels for a specific face
    # face: 0=+X, 1=-X, 2=+Y, 3=-Y, 4=+Z, 5=-Z
    pub fn upload_face_pixels(self, face: u32, pixels: Array<u8>):
        vk_upload_cubemap_face_pixels(self.image, face, pixels, self.size, self.size)

    # Generate mipmaps
    pub fn generate_mipmaps(self):
        vk_generate_cubemap_mipmaps(self.image, self.size, self.mip_levels)

    # Getters
    pub fn get_handle(self) -> TextureHandle:
        return self.handle

    pub fn get_image(self) -> u64:
        return self.image

    pub fn get_view(self) -> u64:
        return self.view

    pub fn get_sampler(self) -> u64:
        return self.sampler

    pub fn get_size(self) -> u32:
        return self.size

    # Cleanup
    pub fn destroy(self):
        vk_destroy_texture(self.image, self.view, self.sampler, self.memory)

# =============================================================================
# Helper Functions
# =============================================================================

fn calculate_mip_levels(width: u32, height: u32) -> u32:
    val max_dim = if width > height { width } else { height }
    var mip_levels = 1
    var size = max_dim

    while size > 1:
        size = size / 2
        mip_levels = mip_levels + 1

    return mip_levels

# =============================================================================
# FFI Function Declarations
# =============================================================================

# Vulkan format constants
const VK_FORMAT_R8G8B8A8_UNORM: u32 = 37
const VK_FORMAT_R8G8B8_UNORM: u32 = 23
const VK_FORMAT_R8G8_UNORM: u32 = 16
const VK_FORMAT_R8_UNORM: u32 = 9
const VK_FORMAT_R16G16B16A16_SFLOAT: u32 = 97
const VK_FORMAT_R16G16B16_SFLOAT: u32 = 90
const VK_FORMAT_R32G32B32A32_SFLOAT: u32 = 109
const VK_FORMAT_D24_UNORM_S8_UINT: u32 = 129

# 2D texture FFI
extern fn vk_create_texture_2d(
    width: u32,
    height: u32,
    mip_levels: u32,
    format: u32
) -> (u64, u64, u64, u64)

extern fn vk_upload_texture_pixels(
    image: u64,
    pixels: Array<u8>,
    width: u32,
    height: u32
)

extern fn vk_generate_mipmaps(
    image: u64,
    width: u32,
    height: u32,
    mip_levels: u32
)

# Cubemap FFI
extern fn vk_create_texture_cubemap(
    size: u32,
    mip_levels: u32,
    format: u32
) -> (u64, u64, u64, u64)

extern fn vk_upload_cubemap_face_pixels(
    image: u64,
    face: u32,
    pixels: Array<u8>,
    width: u32,
    height: u32
)

extern fn vk_generate_cubemap_mipmaps(
    image: u64,
    size: u32,
    mip_levels: u32
)

# Sampler configuration FFI
extern fn vk_set_texture_filter(sampler: u64, filter: TextureFilter)
extern fn vk_set_texture_wrap(sampler: u64, wrap: TextureWrap)

# Cleanup FFI
extern fn vk_destroy_texture(
    image: u64,
    view: u64,
    sampler: u64,
    memory: u64
)
