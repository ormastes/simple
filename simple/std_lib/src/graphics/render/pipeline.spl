# Pipeline - Vulkan graphics pipeline for 3D rendering
#
# Provides forward rendering pipeline with Phong lighting,
# shader management, and pipeline configuration.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.*
use graphics.scene.*
use graphics.render.*

# =============================================================================
# PipelineHandle - Opaque handle to Vulkan pipeline
# =============================================================================

pub struct PipelineHandle:
    handle: u64

impl PipelineHandle:
    pub fn new(handle: u64) -> PipelineHandle:
        return PipelineHandle { handle: handle }

    pub fn invalid() -> PipelineHandle:
        return PipelineHandle { handle: 0 }

    pub fn is_valid(self) -> bool:
        return self.handle != 0

    pub fn get_handle(self) -> u64:
        return self.handle

# =============================================================================
# ShaderStage - Shader compilation and management
# =============================================================================

pub enum ShaderStage:
    Vertex
    Fragment
    Geometry
    Compute

pub struct ShaderModule:
    handle: u64
    stage: ShaderStage

impl ShaderModule:
    # Load shader from SPIR-V bytecode
    pub fn from_spirv(spirv: Array[u8], stage: ShaderStage) -> ShaderModule:
        let handle = vk_create_shader_module(spirv)

        return ShaderModule {
            handle: handle,
            stage: stage
        }

    # Load shader from GLSL source (compile to SPIR-V)
    pub fn from_glsl(source: String, stage: ShaderStage) -> ShaderModule:
        let spirv = compile_glsl_to_spirv(source, stage)
        return ShaderModule::from_spirv(spirv, stage)

    # Getters
    pub fn get_handle(self) -> u64:
        return self.handle

    pub fn get_stage(self) -> ShaderStage:
        return self.stage

    # Cleanup
    pub fn destroy(self):
        vk_destroy_shader_module(self.handle)

# =============================================================================
# Pipeline3D - 3D graphics pipeline configuration
# =============================================================================

pub struct Pipeline3D:
    pipeline: PipelineHandle
    layout: u64          # Pipeline layout handle
    vertex_shader: ShaderModule
    fragment_shader: ShaderModule
    depth_test: bool
    depth_write: bool
    cull_mode: CullMode
    front_face: FrontFace

impl Pipeline3D:
    # Create pipeline with shaders
    pub fn new(
        vertex_shader: ShaderModule,
        fragment_shader: ShaderModule
    ) -> Pipeline3D:
        # Default pipeline configuration
        let config = PipelineConfig {
            depth_test: true,
            depth_write: true,
            cull_mode: CullMode::Back,
            front_face: FrontFace::CounterClockwise
        }

        let (pipeline, layout) = vk_create_pipeline_3d(
            vertex_shader.get_handle(),
            fragment_shader.get_handle(),
            config
        )

        return Pipeline3D {
            pipeline: PipelineHandle::new(pipeline),
            layout: layout,
            vertex_shader: vertex_shader,
            fragment_shader: fragment_shader,
            depth_test: config.depth_test,
            depth_write: config.depth_write,
            cull_mode: config.cull_mode,
            front_face: config.front_face
        }

    # Create with custom configuration
    pub fn with_config(
        vertex_shader: ShaderModule,
        fragment_shader: ShaderModule,
        config: PipelineConfig
    ) -> Pipeline3D:
        let (pipeline, layout) = vk_create_pipeline_3d(
            vertex_shader.get_handle(),
            fragment_shader.get_handle(),
            config
        )

        return Pipeline3D {
            pipeline: PipelineHandle::new(pipeline),
            layout: layout,
            vertex_shader: vertex_shader,
            fragment_shader: fragment_shader,
            depth_test: config.depth_test,
            depth_write: config.depth_write,
            cull_mode: config.cull_mode,
            front_face: config.front_face
        }

    # Getters
    pub fn get_pipeline(self) -> PipelineHandle:
        return self.pipeline

    pub fn get_layout(self) -> u64:
        return self.layout

    # Cleanup
    pub fn destroy(self):
        vk_destroy_pipeline(self.pipeline.get_handle(), self.layout)
        self.vertex_shader.destroy()
        self.fragment_shader.destroy()

# =============================================================================
# Pipeline Configuration
# =============================================================================

pub enum CullMode:
    None
    Front
    Back
    FrontAndBack

pub enum FrontFace:
    Clockwise
    CounterClockwise

pub struct PipelineConfig:
    depth_test: bool
    depth_write: bool
    cull_mode: CullMode
    front_face: FrontFace

impl PipelineConfig:
    pub fn default() -> PipelineConfig:
        return PipelineConfig {
            depth_test: true,
            depth_write: true,
            cull_mode: CullMode::Back,
            front_face: FrontFace::CounterClockwise
        }

    pub fn no_depth() -> PipelineConfig:
        return PipelineConfig {
            depth_test: false,
            depth_write: false,
            cull_mode: CullMode::Back,
            front_face: FrontFace::CounterClockwise
        }

    pub fn transparent() -> PipelineConfig:
        return PipelineConfig {
            depth_test: true,
            depth_write: false,  # No depth writes for transparency
            cull_mode: CullMode::None,
            front_face: FrontFace::CounterClockwise
        }

# =============================================================================
# Standard Pipeline Presets
# =============================================================================

# Create standard Phong lighting pipeline
pub fn create_phong_pipeline() -> Pipeline3D:
    let vertex_src = PHONG_VERTEX_SHADER
    let fragment_src = PHONG_FRAGMENT_SHADER

    let vertex_shader = ShaderModule::from_glsl(vertex_src, ShaderStage::Vertex)
    let fragment_shader = ShaderModule::from_glsl(fragment_src, ShaderStage::Fragment)

    return Pipeline3D::new(vertex_shader, fragment_shader)

# Create unlit pipeline (solid color/texture, no lighting)
pub fn create_unlit_pipeline() -> Pipeline3D:
    let vertex_src = UNLIT_VERTEX_SHADER
    let fragment_src = UNLIT_FRAGMENT_SHADER

    let vertex_shader = ShaderModule::from_glsl(vertex_src, ShaderStage::Vertex)
    let fragment_shader = ShaderModule::from_glsl(fragment_src, ShaderStage::Fragment)

    return Pipeline3D::new(vertex_shader, fragment_shader)

# =============================================================================
# Embedded Shaders (GLSL)
# =============================================================================

const PHONG_VERTEX_SHADER: String = "
#version 450

layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;
layout(location = 2) in vec4 inTangent;
layout(location = 3) in vec2 inTexCoord;
layout(location = 4) in vec4 inColor;

layout(set = 0, binding = 0) uniform CameraUniform {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    vec3 cameraPos;
} camera;

layout(push_constant) uniform PushConstants {
    mat4 model;
    mat4 normalMatrix;
} pc;

layout(location = 0) out vec3 fragWorldPos;
layout(location = 1) out vec3 fragNormal;
layout(location = 2) out vec2 fragTexCoord;
layout(location = 3) out vec4 fragColor;

void main() {
    vec4 worldPos = pc.model * vec4(inPosition, 1.0);
    fragWorldPos = worldPos.xyz;
    fragNormal = mat3(pc.normalMatrix) * inNormal;
    fragTexCoord = inTexCoord;
    fragColor = inColor;

    gl_Position = camera.viewProj * worldPos;
}
"

const PHONG_FRAGMENT_SHADER: String = "
#version 450

layout(location = 0) in vec3 fragWorldPos;
layout(location = 1) in vec3 fragNormal;
layout(location = 2) in vec2 fragTexCoord;
layout(location = 3) in vec4 fragColor;

layout(set = 0, binding = 0) uniform CameraUniform {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    vec3 cameraPos;
} camera;

layout(set = 0, binding = 1) uniform LightingUniform {
    vec3 dirLightDirection;
    float _pad0;
    vec3 dirLightColor;
    float dirLightIntensity;

    vec4 pointLightPositions[4];
    vec4 pointLightColors[4];
    int pointLightCount;
    vec3 _pad1;

    vec3 ambientColor;
    float ambientIntensity;
} lighting;

layout(location = 0) out vec4 outColor;

void main() {
    vec3 normal = normalize(fragNormal);
    vec3 viewDir = normalize(camera.cameraPos - fragWorldPos);

    // Ambient
    vec3 ambient = lighting.ambientColor * lighting.ambientIntensity;

    // Directional light (Blinn-Phong)
    vec3 lightDir = normalize(-lighting.dirLightDirection);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 halfDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfDir), 0.0), 32.0);
    vec3 directional = (diff + spec * 0.5) * lighting.dirLightColor * lighting.dirLightIntensity;

    // Point lights
    vec3 pointLighting = vec3(0.0);
    for (int i = 0; i < lighting.pointLightCount && i < 4; i++) {
        vec3 lightPos = lighting.pointLightPositions[i].xyz;
        vec3 lightColor = lighting.pointLightColors[i].rgb;
        float lightIntensity = lighting.pointLightColors[i].a;

        vec3 toLightDir = lightPos - fragWorldPos;
        float distance = length(toLightDir);
        toLightDir = normalize(toLightDir);

        // Attenuation (simple inverse square)
        float attenuation = 1.0 / (1.0 + 0.1 * distance + 0.01 * distance * distance);

        float diffPoint = max(dot(normal, toLightDir), 0.0);
        vec3 halfDirPoint = normalize(toLightDir + viewDir);
        float specPoint = pow(max(dot(normal, halfDirPoint), 0.0), 32.0);

        pointLighting += (diffPoint + specPoint * 0.5) * lightColor * lightIntensity * attenuation;
    }

    // Combine lighting
    vec3 finalColor = (ambient + directional + pointLighting) * fragColor.rgb;
    outColor = vec4(finalColor, fragColor.a);
}
"

const UNLIT_VERTEX_SHADER: String = "
#version 450

layout(location = 0) in vec3 inPosition;
layout(location = 3) in vec2 inTexCoord;
layout(location = 4) in vec4 inColor;

layout(set = 0, binding = 0) uniform CameraUniform {
    mat4 viewProj;
} camera;

layout(push_constant) uniform PushConstants {
    mat4 model;
} pc;

layout(location = 0) out vec2 fragTexCoord;
layout(location = 1) out vec4 fragColor;

void main() {
    gl_Position = camera.viewProj * pc.model * vec4(inPosition, 1.0);
    fragTexCoord = inTexCoord;
    fragColor = inColor;
}
"

const UNLIT_FRAGMENT_SHADER: String = "
#version 450

layout(location = 0) in vec2 fragTexCoord;
layout(location = 1) in vec4 fragColor;

layout(location = 0) out vec4 outColor;

void main() {
    outColor = fragColor;
}
"

# =============================================================================
# FFI Function Declarations
# =============================================================================

# Shader FFI
extern fn vk_create_shader_module(spirv: Array[u8]) -> u64
extern fn vk_destroy_shader_module(module: u64)
extern fn compile_glsl_to_spirv(source: String, stage: ShaderStage) -> Array[u8]

# Pipeline FFI
extern fn vk_create_pipeline_3d(
    vertex_shader: u64,
    fragment_shader: u64,
    config: PipelineConfig
) -> (u64, u64)

extern fn vk_destroy_pipeline(pipeline: u64, layout: u64)
