# Pipeline - Vulkan graphics pipeline for 3D rendering
#
# Provides forward rendering pipeline with Phong lighting,
# shader management, and pipeline configuration.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.*
use graphics.scene.*
use graphics.render.*

# =============================================================================
# PipelineHandle - Opaque handle to Vulkan pipeline
# =============================================================================

pub struct PipelineHandle:
    handle: u64

impl PipelineHandle:
    pub fn new(handle: u64) -> PipelineHandle:
        return PipelineHandle { handle: handle }

    pub fn invalid() -> PipelineHandle:
        return PipelineHandle { handle: 0 }

    pub fn is_valid(self) -> bool:
        return self.handle != 0

    pub fn get_handle(self) -> u64:
        return self.handle

# =============================================================================
# ShaderStage - Shader compilation and management
# =============================================================================

pub enum ShaderStage:
    Vertex
    Fragment
    Geometry
    Compute

impl ShaderStage:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_vertex(self) -> bool:
        """Check if this is Vertex shader stage.

        Returns:
            true for Vertex

        Example:
            ShaderStage::Vertex.is_vertex()  # → true
        """
        match self:
            case Vertex: true
            case _: false

    pub fn is_fragment(self) -> bool:
        """Check if this is Fragment shader stage.

        Returns:
            true for Fragment

        Example:
            ShaderStage::Fragment.is_fragment()  # → true
        """
        match self:
            case Fragment: true
            case _: false

    pub fn is_geometry(self) -> bool:
        """Check if this is Geometry shader stage.

        Returns:
            true for Geometry

        Example:
            ShaderStage::Geometry.is_geometry()  # → true
        """
        match self:
            case Geometry: true
            case _: false

    pub fn is_compute(self) -> bool:
        """Check if this is Compute shader stage.

        Returns:
            true for Compute

        Example:
            ShaderStage::Compute.is_compute()  # → true
        """
        match self:
            case Compute: true
            case _: false

    pub fn is_graphics_stage(self) -> bool:
        """Check if this is a graphics pipeline stage.

        Returns:
            true for Vertex, Fragment, or Geometry

        Example:
            ShaderStage::Vertex.is_graphics_stage()  # → true
            ShaderStage::Compute.is_graphics_stage()  # → false
        """
        match self:
            case Vertex: true
            case Fragment: true
            case Geometry: true
            case Compute: false

    pub fn is_compute_stage(self) -> bool:
        """Check if this is a compute pipeline stage.

        Returns:
            true for Compute

        Example:
            ShaderStage::Compute.is_compute_stage()  # → true
        """
        match self:
            case Compute: true
            case _: false

    pub fn to_string(self) -> String:
        """Convert shader stage to string.

        Returns:
            Stage name

        Example:
            ShaderStage::Vertex.to_string()  # → "vertex"
        """
        match self:
            case Vertex: "vertex"
            case Fragment: "fragment"
            case Geometry: "geometry"
            case Compute: "compute"

    pub fn description(self) -> String:
        """Get shader stage description.

        Returns:
            Human-readable description

        Example:
            ShaderStage::Vertex.description()
            # → "Vertex shader (transforms vertices)"
        """
        match self:
            case Vertex: "Vertex shader (transforms vertices)"
            case Fragment: "Fragment shader (per-pixel shading)"
            case Geometry: "Geometry shader (primitive processing)"
            case Compute: "Compute shader (general-purpose computation)"

    pub fn summary(self) -> String:
        """Get shader stage summary.

        Returns:
            Human-readable summary

        Example:
            ShaderStage::Vertex.summary()
            # → "ShaderStage: vertex (Vertex shader (transforms vertices), graphics stage)"
        """
        val name = self.to_string()
        val desc = self.description()
        val stage_type = if self.is_graphics_stage():
            "graphics stage"
        else:
            "compute stage"
        return "ShaderStage: {name} ({desc}, {stage_type})"

pub struct ShaderModule:
    handle: u64
    stage: ShaderStage

impl ShaderModule:
    # Load shader from SPIR-V bytecode
    pub fn from_spirv(spirv: Array[u8], stage: ShaderStage) -> ShaderModule:
        val handle = vk_create_shader_module(spirv)

        return ShaderModule {
            handle: handle,
            stage: stage
        }

    # Load shader from GLSL source (compile to SPIR-V)
    pub fn from_glsl(source: String, stage: ShaderStage) -> ShaderModule:
        val spirv = compile_glsl_to_spirv(source, stage)
        return ShaderModule::from_spirv(spirv, stage)

    # Getters
    pub fn get_handle(self) -> u64:
        return self.handle

    pub fn get_stage(self) -> ShaderStage:
        return self.stage

    # Cleanup
    pub fn destroy(self):
        vk_destroy_shader_module(self.handle)

# =============================================================================
# Pipeline3D - 3D graphics pipeline configuration
# =============================================================================

pub struct Pipeline3D:
    pipeline: PipelineHandle
    layout: u64          # Pipeline layout handle
    vertex_shader: ShaderModule
    fragment_shader: ShaderModule
    depth_test: bool
    depth_write: bool
    cull_mode: CullMode
    front_face: FrontFace

impl Pipeline3D:
    # Create pipeline with shaders
    pub fn new(
        vertex_shader: ShaderModule,
        fragment_shader: ShaderModule
    ) -> Pipeline3D:
        # Default pipeline configuration
        val config = PipelineConfig {
            depth_test: true,
            depth_write: true,
            cull_mode: CullMode::Back,
            front_face: FrontFace::CounterClockwise
        }

        val (pipeline, layout) = vk_create_pipeline_3d(
            vertex_shader.get_handle(),
            fragment_shader.get_handle(),
            config
        )

        return Pipeline3D {
            pipeline: PipelineHandle::new(pipeline),
            layout: layout,
            vertex_shader: vertex_shader,
            fragment_shader: fragment_shader,
            depth_test: config.depth_test,
            depth_write: config.depth_write,
            cull_mode: config.cull_mode,
            front_face: config.front_face
        }

    # Create with custom configuration
    pub fn with_config(
        vertex_shader: ShaderModule,
        fragment_shader: ShaderModule,
        config: PipelineConfig
    ) -> Pipeline3D:
        val (pipeline, layout) = vk_create_pipeline_3d(
            vertex_shader.get_handle(),
            fragment_shader.get_handle(),
            config
        )

        return Pipeline3D {
            pipeline: PipelineHandle::new(pipeline),
            layout: layout,
            vertex_shader: vertex_shader,
            fragment_shader: fragment_shader,
            depth_test: config.depth_test,
            depth_write: config.depth_write,
            cull_mode: config.cull_mode,
            front_face: config.front_face
        }

    # Getters
    pub fn get_pipeline(self) -> PipelineHandle:
        return self.pipeline

    pub fn get_layout(self) -> u64:
        return self.layout

    # Cleanup
    pub fn destroy(self):
        vk_destroy_pipeline(self.pipeline.get_handle(), self.layout)
        self.vertex_shader.destroy()
        self.fragment_shader.destroy()

# =============================================================================
# Pipeline Configuration
# =============================================================================

pub enum CullMode:
    None
    Front
    Back
    FrontAndBack

impl CullMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_none(self) -> bool:
        """Check if this is None (no culling).

        Returns:
            true for None

        Example:
            CullMode::None.is_none()  # → true
        """
        match self:
            case None: true
            case _: false

    pub fn is_front(self) -> bool:
        """Check if this culls front faces.

        Returns:
            true for Front

        Example:
            CullMode::Front.is_front()  # → true
        """
        match self:
            case Front: true
            case _: false

    pub fn is_back(self) -> bool:
        """Check if this culls back faces.

        Returns:
            true for Back

        Example:
            CullMode::Back.is_back()  # → true
        """
        match self:
            case Back: true
            case _: false

    pub fn is_front_and_back(self) -> bool:
        """Check if this culls both front and back faces.

        Returns:
            true for FrontAndBack

        Example:
            CullMode::FrontAndBack.is_front_and_back()  # → true
        """
        match self:
            case FrontAndBack: true
            case _: false

    pub fn culls_any(self) -> bool:
        """Check if any faces are culled.

        Returns:
            false for None, true otherwise

        Example:
            CullMode::None.culls_any()  # → false
            CullMode::Back.culls_any()  # → true
        """
        match self:
            case None: false
            case _: true

    pub fn culls_all(self) -> bool:
        """Check if all faces are culled.

        Returns:
            true for FrontAndBack

        Example:
            CullMode::FrontAndBack.culls_all()  # → true
        """
        match self:
            case FrontAndBack: true
            case _: false

    pub fn to_string(self) -> String:
        """Convert cull mode to string.

        Returns:
            Cull mode name

        Example:
            CullMode::Back.to_string()  # → "back"
        """
        match self:
            case None: "none"
            case Front: "front"
            case Back: "back"
            case FrontAndBack: "front_and_back"

    pub fn description(self) -> String:
        """Get cull mode description.

        Returns:
            Human-readable description

        Example:
            CullMode::Back.description()
            # → "Cull back faces (most common)"
        """
        match self:
            case None: "No culling (render all faces)"
            case Front: "Cull front faces"
            case Back: "Cull back faces (most common)"
            case FrontAndBack: "Cull all faces (invisible)"

    pub fn summary(self) -> String:
        """Get cull mode summary.

        Returns:
            Human-readable summary

        Example:
            CullMode::Back.summary()
            # → "CullMode: back (Cull back faces (most common), culls faces)"
        """
        val name = self.to_string()
        val desc = self.description()
        val cull_status = if self.culls_all():
            "culls all faces"
        elif self.culls_any():
            "culls faces"
        else:
            "no culling"
        return "CullMode: {name} ({desc}, {cull_status})"

pub enum FrontFace:
    Clockwise
    CounterClockwise

impl FrontFace:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_clockwise(self) -> bool:
        """Check if this is clockwise winding order.

        Returns:
            true for Clockwise

        Example:
            FrontFace::Clockwise.is_clockwise()  # → true
        """
        match self:
            case Clockwise: true
            case _: false

    pub fn is_counter_clockwise(self) -> bool:
        """Check if this is counter-clockwise winding order.

        Returns:
            true for CounterClockwise

        Example:
            FrontFace::CounterClockwise.is_counter_clockwise()  # → true
        """
        match self:
            case CounterClockwise: true
            case _: false

    pub fn to_string(self) -> String:
        """Convert front face winding to string.

        Returns:
            Winding order name

        Example:
            FrontFace::CounterClockwise.to_string()  # → "counter_clockwise"
        """
        match self:
            case Clockwise: "clockwise"
            case CounterClockwise: "counter_clockwise"

    pub fn description(self) -> String:
        """Get front face winding description.

        Returns:
            Human-readable description

        Example:
            FrontFace::CounterClockwise.description()
            # → "Counter-clockwise winding (OpenGL/Vulkan default)"
        """
        match self:
            case Clockwise: "Clockwise winding (DirectX default)"
            case CounterClockwise: "Counter-clockwise winding (OpenGL/Vulkan default)"

    pub fn summary(self) -> String:
        """Get front face winding summary.

        Returns:
            Human-readable summary

        Example:
            FrontFace::CounterClockwise.summary()
            # → "FrontFace: counter_clockwise (Counter-clockwise winding (OpenGL/Vulkan default))"
        """
        val name = self.to_string()
        val desc = self.description()
        return "FrontFace: {name} ({desc})"

pub struct PipelineConfig:
    depth_test: bool
    depth_write: bool
    cull_mode: CullMode
    front_face: FrontFace

impl PipelineConfig:
    pub fn default() -> PipelineConfig:
        return PipelineConfig {
            depth_test: true,
            depth_write: true,
            cull_mode: CullMode::Back,
            front_face: FrontFace::CounterClockwise
        }

    pub fn no_depth() -> PipelineConfig:
        return PipelineConfig {
            depth_test: false,
            depth_write: false,
            cull_mode: CullMode::Back,
            front_face: FrontFace::CounterClockwise
        }

    pub fn transparent() -> PipelineConfig:
        return PipelineConfig {
            depth_test: true,
            depth_write: false,  # No depth writes for transparency
            cull_mode: CullMode::None,
            front_face: FrontFace::CounterClockwise
        }

# =============================================================================
# Standard Pipeline Presets
# =============================================================================

# Create standard Phong lighting pipeline
pub fn create_phong_pipeline() -> Pipeline3D:
    val vertex_src = PHONG_VERTEX_SHADER
    val fragment_src = PHONG_FRAGMENT_SHADER

    val vertex_shader = ShaderModule::from_glsl(vertex_src, ShaderStage::Vertex)
    val fragment_shader = ShaderModule::from_glsl(fragment_src, ShaderStage::Fragment)

    return Pipeline3D::new(vertex_shader, fragment_shader)

# Create unlit pipeline (solid color/texture, no lighting)
pub fn create_unlit_pipeline() -> Pipeline3D:
    val vertex_src = UNLIT_VERTEX_SHADER
    val fragment_src = UNLIT_FRAGMENT_SHADER

    val vertex_shader = ShaderModule::from_glsl(vertex_src, ShaderStage::Vertex)
    val fragment_shader = ShaderModule::from_glsl(fragment_src, ShaderStage::Fragment)

    return Pipeline3D::new(vertex_shader, fragment_shader)

# =============================================================================
# Embedded Shaders (GLSL)
# =============================================================================

const PHONG_VERTEX_SHADER: String = "
#version 450

layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;
layout(location = 2) in vec4 inTangent;
layout(location = 3) in vec2 inTexCoord;
layout(location = 4) in vec4 inColor;

layout(set = 0, binding = 0) uniform CameraUniform {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    vec3 cameraPos;
} camera;

layout(push_constant) uniform PushConstants {
    mat4 model;
    mat4 normalMatrix;
} pc;

layout(location = 0) out vec3 fragWorldPos;
layout(location = 1) out vec3 fragNormal;
layout(location = 2) out vec2 fragTexCoord;
layout(location = 3) out vec4 fragColor;

void main() {
    vec4 worldPos = pc.model * vec4(inPosition, 1.0);
    fragWorldPos = worldPos.xyz;
    fragNormal = mat3(pc.normalMatrix) * inNormal;
    fragTexCoord = inTexCoord;
    fragColor = inColor;

    gl_Position = camera.viewProj * worldPos;
}
"

const PHONG_FRAGMENT_SHADER: String = "
#version 450

layout(location = 0) in vec3 fragWorldPos;
layout(location = 1) in vec3 fragNormal;
layout(location = 2) in vec2 fragTexCoord;
layout(location = 3) in vec4 fragColor;

layout(set = 0, binding = 0) uniform CameraUniform {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    vec3 cameraPos;
} camera;

layout(set = 0, binding = 1) uniform LightingUniform {
    vec3 dirLightDirection;
    float _pad0;
    vec3 dirLightColor;
    float dirLightIntensity;

    vec4 pointLightPositions[4];
    vec4 pointLightColors[4];
    int pointLightCount;
    vec3 _pad1;

    vec3 ambientColor;
    float ambientIntensity;
} lighting;

layout(location = 0) out vec4 outColor;

void main() {
    vec3 normal = normalize(fragNormal);
    vec3 viewDir = normalize(camera.cameraPos - fragWorldPos);

    // Ambient
    vec3 ambient = lighting.ambientColor * lighting.ambientIntensity;

    // Directional light (Blinn-Phong)
    vec3 lightDir = normalize(-lighting.dirLightDirection);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 halfDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfDir), 0.0), 32.0);
    vec3 directional = (diff + spec * 0.5) * lighting.dirLightColor * lighting.dirLightIntensity;

    // Point lights
    vec3 pointLighting = vec3(0.0);
    for (int i = 0; i < lighting.pointLightCount && i < 4; i++) {
        vec3 lightPos = lighting.pointLightPositions[i].xyz;
        vec3 lightColor = lighting.pointLightColors[i].rgb;
        float lightIntensity = lighting.pointLightColors[i].a;

        vec3 toLightDir = lightPos - fragWorldPos;
        float distance = length(toLightDir);
        toLightDir = normalize(toLightDir);

        // Attenuation (simple inverse square)
        float attenuation = 1.0 / (1.0 + 0.1 * distance + 0.01 * distance * distance);

        float diffPoint = max(dot(normal, toLightDir), 0.0);
        vec3 halfDirPoint = normalize(toLightDir + viewDir);
        float specPoint = pow(max(dot(normal, halfDirPoint), 0.0), 32.0);

        pointLighting += (diffPoint + specPoint * 0.5) * lightColor * lightIntensity * attenuation;
    }

    // Combine lighting
    vec3 finalColor = (ambient + directional + pointLighting) * fragColor.rgb;
    outColor = vec4(finalColor, fragColor.a);
}
"

const UNLIT_VERTEX_SHADER: String = "
#version 450

layout(location = 0) in vec3 inPosition;
layout(location = 3) in vec2 inTexCoord;
layout(location = 4) in vec4 inColor;

layout(set = 0, binding = 0) uniform CameraUniform {
    mat4 viewProj;
} camera;

layout(push_constant) uniform PushConstants {
    mat4 model;
} pc;

layout(location = 0) out vec2 fragTexCoord;
layout(location = 1) out vec4 fragColor;

void main() {
    gl_Position = camera.viewProj * pc.model * vec4(inPosition, 1.0);
    fragTexCoord = inTexCoord;
    fragColor = inColor;
}
"

const UNLIT_FRAGMENT_SHADER: String = "
#version 450

layout(location = 0) in vec2 fragTexCoord;
layout(location = 1) in vec4 fragColor;

layout(location = 0) out vec4 outColor;

void main() {
    outColor = fragColor;
}
"

# =============================================================================
# FFI Function Declarations
# =============================================================================

# Shader FFI
extern fn vk_create_shader_module(spirv: Array[u8]) -> u64
extern fn vk_destroy_shader_module(module: u64)
extern fn compile_glsl_to_spirv(source: String, stage: ShaderStage) -> Array[u8]

# Pipeline FFI
extern fn vk_create_pipeline_3d(
    vertex_shader: u64,
    fragment_shader: u64,
    config: PipelineConfig
) -> (u64, u64)

extern fn vk_destroy_pipeline(pipeline: u64, layout: u64)
