# Renderer3D - Main 3D rendering orchestration
#
# Provides render-to-texture 3D rendering loop with
# scene graph traversal, material binding, and lighting.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.*
use graphics.scene.*
use graphics.render.*

# =============================================================================
# RenderTarget3D - Offscreen render target for 3D rendering
# =============================================================================

pub struct RenderTarget3D:
    color_texture: Texture2D
    depth_image: DepthImage
    framebuffer: u64
    width: u32
    height: u32

impl RenderTarget3D:
    # Create offscreen render target
    pub fn new(width: u32, height: u32) -> RenderTarget3D:
        val color_texture = Texture2D::new(width, height, TextureFormat::RGBA8)
        val depth_image = DepthImage::new(width, height)

        val framebuffer = vk_create_framebuffer_3d(
            color_texture.get_view(),
            depth_image.get_view(),
            width,
            height
        )

        return RenderTarget3D {
            color_texture: color_texture,
            depth_image: depth_image,
            framebuffer: framebuffer,
            width: width,
            height: height
        }

    # Getters
    pub fn get_color_texture(self) -> Texture2D:
        return self.color_texture

    pub fn get_depth_image(self) -> DepthImage:
        return self.depth_image

    pub fn get_framebuffer(self) -> u64:
        return self.framebuffer

    pub fn get_width(self) -> u32:
        return self.width

    pub fn get_height(self) -> u32:
        return self.height

    # Cleanup
    pub fn destroy(self):
        vk_destroy_framebuffer(self.framebuffer)
        self.color_texture.destroy()
        self.depth_image.destroy()

# =============================================================================
# MeshBuffers - Cached mesh buffers
# =============================================================================

struct MeshBuffers:
    vertex_buffer: VertexBuffer3D
    index_buffer: IndexBuffer3D

# =============================================================================
# Renderer3D - Main 3D renderer
# =============================================================================

pub struct Renderer3D:
    device: DeviceHandle
    render_target: RenderTarget3D
    phong_pipeline: Pipeline3D
    unlit_pipeline: Pipeline3D
    camera_uniform: UniformBuffer[CameraUniformData]
    lighting_uniform: UniformBuffer[LightingUniformData]
    mesh_cache: Dict[u64, MeshBuffers]
    clear_color: Color

impl Renderer3D:
    # Create renderer
    pub fn new(width: u32, height: u32) -> Renderer3D:
        val device = DeviceHandle::new()
        val render_target = RenderTarget3D::new(width, height)
        val phong_pipeline = create_phong_pipeline()
        val unlit_pipeline = create_unlit_pipeline()
        val camera_uniform = UniformBuffer::new()
        val lighting_uniform = UniformBuffer::new()

        return Renderer3D {
            device: device,
            render_target: render_target,
            phong_pipeline: phong_pipeline,
            unlit_pipeline: unlit_pipeline,
            camera_uniform: camera_uniform,
            lighting_uniform: lighting_uniform,
            mesh_cache: Dict::new(),
            clear_color: Color::new(0.2, 0.3, 0.4)
        }

    # Set clear color
    pub fn set_clear_color(mut self, color: Color):
        self.clear_color = color

    # Get render target (for compositing with 2D UI)
    pub fn get_render_target(self) -> RenderTarget3D:
        return self.render_target

    # Render a scene
    pub fn render(mut self, scene: Scene, camera: Camera):
        # Begin render pass
        vk_begin_render_pass_3d(
            self.render_target.get_framebuffer(),
            self.render_target.get_width(),
            self.render_target.get_height(),
            self.clear_color
        )

        # Update camera uniform
        val camera_data = self.build_camera_uniform(camera)
        self.camera_uniform.update(camera_data)

        # Collect and update lighting uniform
        val lighting_data = self.collect_lighting(scene)
        self.lighting_uniform.update(lighting_data)

        # Bind camera and lighting uniforms
        vk_bind_uniform_buffer(0, 0, self.camera_uniform.get_buffer().get_handle())
        vk_bind_uniform_buffer(0, 1, self.lighting_uniform.get_buffer().get_handle())

        # Traverse scene and render nodes
        scene.traverse(|node, world_transform| {
            self.render_node(node, world_transform)
        })

        # End render pass
        vk_end_render_pass()

    # Render a single node
    var fn render_node(node: SceneNode, world_transform: Mat4):
        # Check if node has mesh renderer
        if not node.has_mesh_renderer():
            return

        val (mesh_handle, material_handle) = node.get_mesh_renderer().unwrap()

        # Get or create mesh buffers
        val mesh_buffers = self.get_or_create_mesh_buffers(mesh_handle)

        # Bind pipeline based on material type
        # TODO: [stdlib][P3] Get actual material from material registry
        vk_bind_pipeline(self.phong_pipeline.get_pipeline().get_handle())

        # Set push constants (model matrix)
        val normal_matrix = world_transform.to_mat3().transpose()
        vk_push_constants(world_transform, normal_matrix)

        # Bind vertex and index buffers
        vk_bind_vertex_buffer(mesh_buffers.vertex_buffer.get_buffer().get_handle())
        vk_bind_index_buffer(mesh_buffers.index_buffer.get_buffer().get_handle())

        # Draw indexed
        vk_draw_indexed(mesh_buffers.index_buffer.get_index_count())

    # Build camera uniform data
    fn build_camera_uniform(camera: Camera) -> CameraUniformData:
        val view = camera.get_view_matrix()
        val proj = camera.get_projection_matrix()
        val view_proj = proj * view
        val camera_pos = camera.get_position()

        return CameraUniformData {
            view: view,
            proj: proj,
            view_proj: view_proj,
            camera_pos: camera_pos,
            _pad0: 0.0
        }

    # Collect lighting from scene
    fn collect_lighting(scene: Scene) -> LightingUniformData:
        var lighting = LightingUniformData {
            dir_light_direction: Vec3::new(0.0, -1.0, 0.0),
            _pad0: 0.0,
            dir_light_color: Vec3::one(),
            dir_light_intensity: 0.0,
            point_light_positions: [
                Vec4::zero(), Vec4::zero(), Vec4::zero(), Vec4::zero()
            ],
            point_light_colors: [
                Vec4::zero(), Vec4::zero(), Vec4::zero(), Vec4::zero()
            ],
            point_light_count: 0,
            _pad1: [0.0, 0.0, 0.0],
            ambient_color: Vec3::new(0.1, 0.1, 0.1),
            ambient_intensity: 1.0
        }

        var point_count = 0

        # Traverse scene and collect lights
        scene.traverse(|node, world_transform| {
            if node.has_light():
                val light = node.get_light().unwrap()

                match light:
                    case Light::Directional(dir_light):
                        lighting.dir_light_direction = dir_light.get_direction()
                        lighting.dir_light_color = dir_light.get_color().to_vec3()
                        lighting.dir_light_intensity = dir_light.get_intensity()

                    case Light::Point(point_light):
                        if point_count < 4:
                            val position = world_transform.transform_point(Vec3::zero())
                            lighting.point_light_positions[point_count] = Vec4::from_vec3(position, 1.0)
                            val color = point_light.get_color().to_vec3()
                            val intensity = point_light.get_intensity()
                            lighting.point_light_colors[point_count] = Vec4::from_vec3(color, intensity)
                            point_count = point_count + 1

                    case Light::Spot(_):
                        # TODO: [stdlib][P3] Add spotlight support
                        pass
        })

        lighting.point_light_count = point_count
        return lighting

    # Get or create mesh buffers
    var fn get_or_create_mesh_buffers(mesh_handle: MeshHandle) -> MeshBuffers:
        val key = mesh_handle.id

        if self.mesh_cache.contains_key(key):
            return self.mesh_cache.get(key).unwrap()

        # TODO: [stdlib][P3] Get actual mesh from mesh registry
        # For now, create a placeholder cube
        val mesh = create_cube()
        val vertex_buffer = VertexBuffer3D::from_mesh(mesh)
        val index_buffer = IndexBuffer3D::from_mesh(mesh)

        val buffers = MeshBuffers {
            vertex_buffer: vertex_buffer,
            index_buffer: index_buffer
        }

        self.mesh_cache.insert(key, buffers)
        return buffers

    # Cleanup
    pub fn destroy(mut self):
        self.render_target.destroy()
        self.phong_pipeline.destroy()
        self.unlit_pipeline.destroy()
        self.camera_uniform.destroy()
        self.lighting_uniform.destroy()

        # Clean up mesh buffers
        for (_, buffers) in self.mesh_cache:
            buffers.vertex_buffer.destroy()
            buffers.index_buffer.destroy()

        self.device.release()

# =============================================================================
# FFI Function Declarations
# =============================================================================

# Framebuffer FFI
extern fn vk_create_framebuffer_3d(
    color_view: u64,
    depth_view: u64,
    width: u32,
    height: u32
) -> u64

extern fn vk_destroy_framebuffer(framebuffer: u64)

# Render pass FFI
extern fn vk_begin_render_pass_3d(
    framebuffer: u64,
    width: u32,
    height: u32,
    clear_color: Color
)

extern fn vk_end_render_pass()

# Binding FFI
extern fn vk_bind_pipeline(pipeline: u64)
extern fn vk_bind_uniform_buffer(set: u32, binding: u32, buffer: u64)
extern fn vk_bind_vertex_buffer(buffer: u64)
extern fn vk_bind_index_buffer(buffer: u64)

# Push constants FFI
extern fn vk_push_constants(model: Mat4, normal_matrix: Mat3)

# Draw FFI
extern fn vk_draw_indexed(index_count: u32)
