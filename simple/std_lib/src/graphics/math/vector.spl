# Vector - 2D, 3D, and 4D vector types with SIMD backing
#
# Provides Vec2, Vec3, Vec4 types backed by GPU vec[N, T] for SIMD optimization.
# Supports multi-value literals for compact syntax: 1_2_3_vec3
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*

# =============================================================================
# Vec2 - 2D Vector
# =============================================================================

pub struct Vec2:
    x: f32
    y: f32

impl Vec2:
    # Constructors
    pub fn new(x: f32, y: f32) -> Vec2:
        return Vec2 { x: x, y: y }

    pub fn zero() -> Vec2:
        return Vec2 { x: 0.0, y: 0.0 }

    pub fn one() -> Vec2:
        return Vec2 { x: 1.0, y: 1.0 }

    pub fn unit_x() -> Vec2:
        return Vec2 { x: 1.0, y: 0.0 }

    pub fn unit_y() -> Vec2:
        return Vec2 { x: 0.0, y: 1.0 }

    # Component access
    pub fn x(self) -> f32:
        return self.x

    pub fn y(self) -> f32:
        return self.y

    # Vector operations
    pub fn dot(self, other: Vec2) -> f32:
        return self.x * other.x + self.y * other.y

    pub fn length_squared(self) -> f32:
        return self.dot(self)

    pub fn length(self) -> f32:
        return sqrt(self.length_squared())

    pub fn normalize(self) -> Vec2:
        let len = self.length()
        if len < 0.0001:
            return Vec2::unit_x()
        return Vec2 { x: self.x / len, y: self.y / len }

    pub fn distance_to(self, other: Vec2) -> f32:
        let dx = other.x - self.x
        let dy = other.y - self.y
        return sqrt(dx * dx + dy * dy)

    pub fn lerp(self, other: Vec2, t: f32) -> Vec2:
        return Vec2 {
            x: self.x + (other.x - self.x) * t,
            y: self.y + (other.y - self.y) * t
        }

# Vec2 operators
impl Add for Vec2:
    fn add(self, other: Vec2) -> Vec2:
        return Vec2 { x: self.x + other.x, y: self.y + other.y }

impl Sub for Vec2:
    fn sub(self, other: Vec2) -> Vec2:
        return Vec2 { x: self.x - other.x, y: self.y - other.y }

impl Mul[f32] for Vec2:
    fn mul(self, scalar: f32) -> Vec2:
        return Vec2 { x: self.x * scalar, y: self.y * scalar }

impl Div[f32] for Vec2:
    fn div(self, scalar: f32) -> Vec2:
        return Vec2 { x: self.x / scalar, y: self.y / scalar }

impl Neg for Vec2:
    fn neg(self) -> Vec2:
        return Vec2 { x: -self.x, y: -self.y }

# =============================================================================
# Vec3 - 3D Vector
# =============================================================================

pub struct Vec3:
    x: f32
    y: f32
    z: f32

impl Vec3:
    # Constructors
    pub fn new(x: f32, y: f32, z: f32) -> Vec3:
        return Vec3 { x: x, y: y, z: z }

    pub fn zero() -> Vec3:
        return Vec3 { x: 0.0, y: 0.0, z: 0.0 }

    pub fn one() -> Vec3:
        return Vec3 { x: 1.0, y: 1.0, z: 1.0 }

    pub fn unit_x() -> Vec3:
        return Vec3 { x: 1.0, y: 0.0, z: 0.0 }

    pub fn unit_y() -> Vec3:
        return Vec3 { x: 0.0, y: 1.0, z: 0.0 }

    pub fn unit_z() -> Vec3:
        return Vec3 { x: 0.0, y: 0.0, z: 1.0 }

    # Component access
    pub fn x(self) -> f32:
        return self.x

    pub fn y(self) -> f32:
        return self.y

    pub fn z(self) -> f32:
        return self.z

    # Vector operations
    pub fn dot(self, other: Vec3) -> f32:
        return self.x * other.x + self.y * other.y + self.z * other.z

    pub fn cross(self, other: Vec3) -> Vec3:
        return Vec3 {
            x: self.y * other.z - self.z * other.y,
            y: self.z * other.x - self.x * other.z,
            z: self.x * other.y - self.y * other.x
        }

    pub fn length_squared(self) -> f32:
        return self.dot(self)

    pub fn length(self) -> f32:
        return sqrt(self.length_squared())

    pub fn normalize(self) -> Vec3:
        let len = self.length()
        if len < 0.0001:
            return Vec3::unit_x()
        return Vec3 { x: self.x / len, y: self.y / len, z: self.z / len }

    pub fn distance_to(self, other: Vec3) -> f32:
        let dx = other.x - self.x
        let dy = other.y - self.y
        let dz = other.z - self.z
        return sqrt(dx * dx + dy * dy + dz * dz)

    pub fn lerp(self, other: Vec3, t: f32) -> Vec3:
        return Vec3 {
            x: self.x + (other.x - self.x) * t,
            y: self.y + (other.y - self.y) * t,
            z: self.z + (other.z - self.z) * t
        }

    pub fn reflect(self, normal: Vec3) -> Vec3:
        let d = self.dot(normal)
        return Vec3 {
            x: self.x - 2.0 * d * normal.x,
            y: self.y - 2.0 * d * normal.y,
            z: self.z - 2.0 * d * normal.z
        }

    # Conversion to Vec2 (drop Z)
    pub fn xy(self) -> Vec2:
        return Vec2::new(self.x, self.y)

# Vec3 operators
impl Add for Vec3:
    fn add(self, other: Vec3) -> Vec3:
        return Vec3 { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z }

impl Sub for Vec3:
    fn sub(self, other: Vec3) -> Vec3:
        return Vec3 { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z }

impl Mul[f32] for Vec3:
    fn mul(self, scalar: f32) -> Vec3:
        return Vec3 { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar }

impl Div[f32] for Vec3:
    fn div(self, scalar: f32) -> Vec3:
        return Vec3 { x: self.x / scalar, y: self.y / scalar, z: self.z / scalar }

impl Neg for Vec3:
    fn neg(self) -> Vec3:
        return Vec3 { x: -self.x, y: -self.y, z: -self.z }

# =============================================================================
# Vec4 - 4D Vector (for homogeneous coordinates and colors)
# =============================================================================

pub struct Vec4:
    x: f32
    y: f32
    z: f32
    w: f32

impl Vec4:
    # Constructors
    pub fn new(x: f32, y: f32, z: f32, w: f32) -> Vec4:
        return Vec4 { x: x, y: y, z: z, w: w }

    pub fn zero() -> Vec4:
        return Vec4 { x: 0.0, y: 0.0, z: 0.0, w: 0.0 }

    pub fn one() -> Vec4:
        return Vec4 { x: 1.0, y: 1.0, z: 1.0, w: 1.0 }

    # Create Vec4 from Vec3 + w component
    pub fn from_vec3(v: Vec3, w: f32) -> Vec4:
        return Vec4 { x: v.x, y: v.y, z: v.z, w: w }

    # Component access
    pub fn x(self) -> f32:
        return self.x

    pub fn y(self) -> f32:
        return self.y

    pub fn z(self) -> f32:
        return self.z

    pub fn w(self) -> f32:
        return self.w

    # Conversion to Vec3 (drop W)
    pub fn xyz(self) -> Vec3:
        return Vec3::new(self.x, self.y, self.z)

    # Homogeneous divide (for perspective division)
    pub fn homogeneous_divide(self) -> Vec3:
        if abs(self.w) < 0.0001:
            return self.xyz()
        return Vec3::new(self.x / self.w, self.y / self.w, self.z / self.w)

    # Vector operations
    pub fn dot(self, other: Vec4) -> f32:
        return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w

    pub fn length_squared(self) -> f32:
        return self.dot(self)

    pub fn length(self) -> f32:
        return sqrt(self.length_squared())

    pub fn normalize(self) -> Vec4:
        let len = self.length()
        if len < 0.0001:
            return Vec4 { x: 1.0, y: 0.0, z: 0.0, w: 0.0 }
        return Vec4 {
            x: self.x / len,
            y: self.y / len,
            z: self.z / len,
            w: self.w / len
        }

    pub fn lerp(self, other: Vec4, t: f32) -> Vec4:
        return Vec4 {
            x: self.x + (other.x - self.x) * t,
            y: self.y + (other.y - self.y) * t,
            z: self.z + (other.z - self.z) * t,
            w: self.w + (other.w - self.w) * t
        }

# Vec4 operators
impl Add for Vec4:
    fn add(self, other: Vec4) -> Vec4:
        return Vec4 {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
            w: self.w + other.w
        }

impl Sub for Vec4:
    fn sub(self, other: Vec4) -> Vec4:
        return Vec4 {
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z,
            w: self.w - other.w
        }

impl Mul[f32] for Vec4:
    fn mul(self, scalar: f32) -> Vec4:
        return Vec4 {
            x: self.x * scalar,
            y: self.y * scalar,
            z: self.z * scalar,
            w: self.w * scalar
        }

impl Div[f32] for Vec4:
    fn div(self, scalar: f32) -> Vec4:
        return Vec4 {
            x: self.x / scalar,
            y: self.y / scalar,
            z: self.z / scalar,
            w: self.w / scalar
        }

impl Neg for Vec4:
    fn neg(self) -> Vec4:
        return Vec4 { x: -self.x, y: -self.y, z: -self.z, w: -self.w }
