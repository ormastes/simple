# Quaternion - Rotation representation for 3D graphics
#
# Provides Quaternion type for smooth rotations without gimbal lock.
# Stored as (x, y, z, w) where w is the scalar part.
# Supports axis-angle conversion, Euler angles, and spherical interpolation (slerp).
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.vector.*
use graphics.math.matrix.*

# =============================================================================
# Quaternion - 4D rotation representation
# =============================================================================

pub struct Quaternion:
    x: f32
    y: f32
    z: f32
    w: f32

impl Quaternion:
    # Constructors
    pub fn new(x: f32, y: f32, z: f32, w: f32) -> Quaternion:
        return Quaternion { x: x, y: y, z: z, w: w }

    pub fn identity() -> Quaternion:
        return Quaternion { x: 0.0, y: 0.0, z: 0.0, w: 1.0 }

    # Create from axis and angle (radians)
    pub fn from_axis_angle(axis: Vec3, angle: f32) -> Quaternion:
        val half_angle = angle / 2.0
        val s = sin(half_angle)
        val n = axis.normalize()

        return Quaternion {
            x: n.x * s,
            y: n.y * s,
            z: n.z * s,
            w: cos(half_angle)
        }

    # Create from Euler angles (radians): pitch (X), yaw (Y), roll (Z)
    pub fn from_euler(pitch: f32, yaw: f32, roll: f32) -> Quaternion:
        val half_pitch = pitch / 2.0
        val half_yaw = yaw / 2.0
        val half_roll = roll / 2.0

        val cp = cos(half_pitch)
        val sp = sin(half_pitch)
        val cy = cos(half_yaw)
        val sy = sin(half_yaw)
        val cr = cos(half_roll)
        val sr = sin(half_roll)

        return Quaternion {
            x: sp * cy * cr - cp * sy * sr,
            y: cp * sy * cr + sp * cy * sr,
            z: cp * cy * sr - sp * sy * cr,
            w: cp * cy * cr + sp * sy * sr
        }

    # Create from rotation matrix
    pub fn from_matrix(m: Mat4) -> Quaternion:
        val trace = m.get(0, 0) + m.get(1, 1) + m.get(2, 2)

        if trace > 0.0:
            val s = sqrt(trace + 1.0) * 2.0
            return Quaternion {
                x: (m.get(2, 1) - m.get(1, 2)) / s,
                y: (m.get(0, 2) - m.get(2, 0)) / s,
                z: (m.get(1, 0) - m.get(0, 1)) / s,
                w: 0.25 * s
            }
        else if m.get(0, 0) > m.get(1, 1) and m.get(0, 0) > m.get(2, 2):
            val s = sqrt(1.0 + m.get(0, 0) - m.get(1, 1) - m.get(2, 2)) * 2.0
            return Quaternion {
                x: 0.25 * s,
                y: (m.get(0, 1) + m.get(1, 0)) / s,
                z: (m.get(0, 2) + m.get(2, 0)) / s,
                w: (m.get(2, 1) - m.get(1, 2)) / s
            }
        else if m.get(1, 1) > m.get(2, 2):
            val s = sqrt(1.0 + m.get(1, 1) - m.get(0, 0) - m.get(2, 2)) * 2.0
            return Quaternion {
                x: (m.get(0, 1) + m.get(1, 0)) / s,
                y: 0.25 * s,
                z: (m.get(1, 2) + m.get(2, 1)) / s,
                w: (m.get(0, 2) - m.get(2, 0)) / s
            }
        else:
            val s = sqrt(1.0 + m.get(2, 2) - m.get(0, 0) - m.get(1, 1)) * 2.0
            return Quaternion {
                x: (m.get(0, 2) + m.get(2, 0)) / s,
                y: (m.get(1, 2) + m.get(2, 1)) / s,
                z: 0.25 * s,
                w: (m.get(1, 0) - m.get(0, 1)) / s
            }

    # Component access
    pub fn x(self) -> f32:
        return self.x

    pub fn y(self) -> f32:
        return self.y

    pub fn z(self) -> f32:
        return self.z

    pub fn w(self) -> f32:
        return self.w

    # Quaternion operations
    pub fn dot(self, other: Quaternion) -> f32:
        return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w

    pub fn length_squared(self) -> f32:
        return self.dot(self)

    pub fn length(self) -> f32:
        return sqrt(self.length_squared())

    pub fn normalize(self) -> Quaternion:
        val len = self.length()
        if len < 0.0001:
            return Quaternion::identity()

        return Quaternion {
            x: self.x / len,
            y: self.y / len,
            z: self.z / len,
            w: self.w / len
        }

    pub fn conjugate(self) -> Quaternion:
        return Quaternion {
            x: -self.x,
            y: -self.y,
            z: -self.z,
            w: self.w
        }

    pub fn inverse(self) -> Quaternion:
        val len_sq = self.length_squared()
        if len_sq < 0.0001:
            return Quaternion::identity()

        val conj = self.conjugate()
        return Quaternion {
            x: conj.x / len_sq,
            y: conj.y / len_sq,
            z: conj.z / len_sq,
            w: conj.w / len_sq
        }

    # Spherical linear interpolation
    pub fn slerp(self, other: Quaternion, t: f32) -> Quaternion:
        var dot = self.dot(other)

        # If the dot product is negative, negate one quaternion to take shorter path
        var other_adj = other
        if dot < 0.0:
            other_adj = Quaternion {
                x: -other.x,
                y: -other.y,
                z: -other.z,
                w: -other.w
            }
            dot = -dot

        # If quaternions are very close, use linear interpolation
        if dot > 0.9995:
            return Quaternion {
                x: self.x + (other_adj.x - self.x) * t,
                y: self.y + (other_adj.y - self.y) * t,
                z: self.z + (other_adj.z - self.z) * t,
                w: self.w + (other_adj.w - self.w) * t
            }.normalize()

        # Spherical interpolation
        val theta = acos(dot)
        val sin_theta = sin(theta)
        val a = sin((1.0 - t) * theta) / sin_theta
        val b = sin(t * theta) / sin_theta

        return Quaternion {
            x: self.x * a + other_adj.x * b,
            y: self.y * a + other_adj.y * b,
            z: self.z * a + other_adj.z * b,
            w: self.w * a + other_adj.w * b
        }

    # Conversion to rotation matrix
    pub fn to_matrix(self) -> Mat4:
        val q = self.normalize()
        val x = q.x
        val y = q.y
        val z = q.z
        val w = q.w

        val x2 = x * x
        val y2 = y * y
        val z2 = z * z
        val xy = x * y
        val xz = x * z
        val yz = y * z
        val wx = w * x
        val wy = w * y
        val wz = w * z

        return Mat4::new(
            1.0 - 2.0 * (y2 + z2), 2.0 * (xy + wz),       2.0 * (xz - wy),       0.0,
            2.0 * (xy - wz),       1.0 - 2.0 * (x2 + z2), 2.0 * (yz + wx),       0.0,
            2.0 * (xz + wy),       2.0 * (yz - wx),       1.0 - 2.0 * (x2 + y2), 0.0,
            0.0,                   0.0,                   0.0,                   1.0
        )

    # Rotate a vector by this quaternion
    pub fn rotate_vector(self, v: Vec3) -> Vec3:
        # Convert to matrix and transform
        return self.to_matrix().transform_vector(v)

    # Alternative direct rotation (more efficient)
    pub fn rotate_vector_direct(self, v: Vec3) -> Vec3:
        val q = self.normalize()
        val qv = Vec3::new(q.x, q.y, q.z)
        val uv = qv.cross(v)
        val uuv = qv.cross(uv)

        return v + (uv * (2.0 * q.w)) + (uuv * 2.0)

    # Get rotation axis and angle
    pub fn to_axis_angle(self) -> (Vec3, f32):
        val q = self.normalize()
        val angle = 2.0 * acos(q.w)
        val s = sqrt(1.0 - q.w * q.w)

        if s < 0.0001:
            # Arbitrary axis when angle is near zero
            return (Vec3::unit_x(), 0.0)

        val axis = Vec3::new(q.x / s, q.y / s, q.z / s)
        return (axis, angle)

    # Get Euler angles (pitch, yaw, roll in radians)
    pub fn to_euler(self) -> (f32, f32, f32):
        val q = self.normalize()

        # Pitch (X-axis rotation)
        val sin_pitch = 2.0 * (q.w * q.x - q.y * q.z)
        val pitch = if abs(sin_pitch) >= 1.0:
            # Gimbal lock case
            if sin_pitch > 0.0:
                1.5707963  # π/2
            else:
                -1.5707963  # -π/2
        else:
            asin(sin_pitch)

        # Yaw (Y-axis rotation)
        val sin_yaw = 2.0 * (q.w * q.y + q.z * q.x)
        val cos_yaw = 1.0 - 2.0 * (q.x * q.x + q.y * q.y)
        val yaw = atan2(sin_yaw, cos_yaw)

        # Roll (Z-axis rotation)
        val sin_roll = 2.0 * (q.w * q.z + q.x * q.y)
        val cos_roll = 1.0 - 2.0 * (q.y * q.y + q.z * q.z)
        val roll = atan2(sin_roll, cos_roll)

        return (pitch, yaw, roll)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_identity(self) -> bool:
        """Check if quaternion is identity (no rotation)."""
        return abs(self.x) < 0.0001 and
               abs(self.y) < 0.0001 and
               abs(self.z) < 0.0001 and
               abs(self.w - 1.0) < 0.0001

    pub fn is_zero(self) -> bool:
        """Check if quaternion is zero (invalid state)."""
        return abs(self.x) < 0.0001 and
               abs(self.y) < 0.0001 and
               abs(self.z) < 0.0001 and
               abs(self.w) < 0.0001

    pub fn is_unit(self) -> bool:
        """Check if quaternion is unit length (normalized)."""
        val len_sq = self.length_squared()
        return abs(len_sq - 1.0) < 0.0001

    pub fn is_normalized(self) -> bool:
        """Check if quaternion is normalized (alias for is_unit)."""
        return self.is_unit()

    pub fn is_finite(self) -> bool:
        """Check if all components are finite (not NaN or infinity)."""
        return is_finite(self.x) and is_finite(self.y) and
               is_finite(self.z) and is_finite(self.w)

    pub fn has_nan(self) -> bool:
        """Check if any component is NaN."""
        return is_nan(self.x) or is_nan(self.y) or
               is_nan(self.z) or is_nan(self.w)

    pub fn is_pure(self) -> bool:
        """Check if quaternion is pure (w ≈ 0, represents rotation axis only)."""
        return abs(self.w) < 0.0001

    pub fn angle(self) -> f32:
        """Get rotation angle in radians."""
        val (_, angle) = self.to_axis_angle()
        return angle

    pub fn axis(self) -> Vec3:
        """Get rotation axis."""
        val (axis, _) = self.to_axis_angle()
        return axis

    pub fn component_min(self) -> f32:
        """Get minimum component value."""
        return min(min(min(self.x, self.y), self.z), self.w)

    pub fn component_max(self) -> f32:
        """Get maximum component value."""
        return max(max(max(self.x, self.y), self.z), self.w)

    pub fn abs(self) -> Quaternion:
        """Get quaternion with absolute value of each component."""
        return Quaternion {
            x: abs(self.x),
            y: abs(self.y),
            z: abs(self.z),
            w: abs(self.w)
        }

    pub fn angle_to(self, other: Quaternion) -> f32:
        """Get angle between two quaternions in radians."""
        val dot = abs(self.normalize().dot(other.normalize()))
        # Clamp to avoid numerical issues with acos
        val clamped = clamp(dot, -1.0, 1.0)
        return 2.0 * acos(clamped)

    pub fn summary(self) -> String:
        """Get summary of quaternion.

        Returns:
            Human-readable summary

        Example:
            Quaternion::identity().summary()
            # → "Quaternion: (0.000, 0.000, 0.000, 1.000), angle: 0.000 rad [identity, unit]"
        """
        val angle = self.angle()
        val axis = self.axis()
        val id = if self.is_identity(): ", identity" else: ""
        val unit = if self.is_unit(): ", unit" else: ""
        val zero = if self.is_zero(): " [zero]" else: ""
        return "Quaternion: ({self.x:.3}, {self.y:.3}, {self.z:.3}, {self.w:.3}), angle: {angle:.3} rad, axis: ({axis.x:.3}, {axis.y:.3}, {axis.z:.3}){id}{unit}{zero}"

# Quaternion operators
impl Mul for Quaternion:
    fn mul(other: Quaternion) -> Quaternion:
        return Quaternion {
            x: self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            y: self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            z: self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w,
            w: self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z
        }

impl Neg for Quaternion:
    fn neg() -> Quaternion:
        return Quaternion {
            x: -self.x,
            y: -self.y,
            z: -self.z,
            w: -self.w
        }
