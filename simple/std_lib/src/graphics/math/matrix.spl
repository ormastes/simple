# Matrix - 3x3 and 4x4 transformation matrices
#
# Provides Mat3 and Mat4 types for 2D and 3D transformations.
# Column-major storage (OpenGL/Vulkan convention).
# Supports transformations, camera matrices, and composition.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.vector.*

# =============================================================================
# Mat3 - 3x3 Matrix (for 2D transforms and normal matrices)
# =============================================================================

pub struct Mat3:
    # Column-major storage: [col0, col1, col2]
    # | m00 m10 m20 |
    # | m01 m11 m21 |
    # | m02 m12 m22 |
    data: [f32; 9]

impl Mat3:
    # Constructors
    pub fn new(
        m00: f32, m10: f32, m20: f32,
        m01: f32, m11: f32, m21: f32,
        m02: f32, m12: f32, m22: f32
    ) -> Mat3:
        return Mat3 {
            data: [m00, m01, m02, m10, m11, m12, m20, m21, m22]
        }

    pub fn identity() -> Mat3:
        return Mat3 {
            data: [
                1.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 0.0, 1.0
            ]
        }

    pub fn zero() -> Mat3:
        return Mat3 {
            data: [
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0
            ]
        }

    # 2D Rotation (radians)
    pub fn rotation_2d(angle: f32) -> Mat3:
        let c = cos(angle)
        let s = sin(angle)
        return Mat3 {
            data: [
                c, s, 0.0,
                -s, c, 0.0,
                0.0, 0.0, 1.0
            ]
        }

    # 2D Scaling
    pub fn scaling_2d(sx: f32, sy: f32) -> Mat3:
        return Mat3 {
            data: [
                sx, 0.0, 0.0,
                0.0, sy, 0.0,
                0.0, 0.0, 1.0
            ]
        }

    # 2D Translation
    pub fn translation_2d(tx: f32, ty: f32) -> Mat3:
        return Mat3 {
            data: [
                1.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                tx, ty, 1.0
            ]
        }

    # Element access
    pub fn get(self, row: i32, col: i32) -> f32:
        return self.data[col * 3 + row]

    pub fn set(mut self, row: i32, col: i32, value: f32):
        self.data[col * 3 + row] = value

    # Matrix operations
    pub fn transpose(self) -> Mat3:
        return Mat3::new(
            self.get(0, 0), self.get(0, 1), self.get(0, 2),
            self.get(1, 0), self.get(1, 1), self.get(1, 2),
            self.get(2, 0), self.get(2, 1), self.get(2, 2)
        )

    pub fn determinant(self) -> f32:
        let m00 = self.get(0, 0)
        let m01 = self.get(0, 1)
        let m02 = self.get(0, 2)
        let m10 = self.get(1, 0)
        let m11 = self.get(1, 1)
        let m12 = self.get(1, 2)
        let m20 = self.get(2, 0)
        let m21 = self.get(2, 1)
        let m22 = self.get(2, 2)

        return m00 * (m11 * m22 - m12 * m21) -
               m01 * (m10 * m22 - m12 * m20) +
               m02 * (m10 * m21 - m11 * m20)

    # Transform Vec2
    pub fn transform_point(self, v: Vec2) -> Vec2:
        let x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2)
        let y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2)
        return Vec2::new(x, y)

    pub fn transform_vector(self, v: Vec2) -> Vec2:
        let x = self.get(0, 0) * v.x + self.get(0, 1) * v.y
        let y = self.get(1, 0) * v.x + self.get(1, 1) * v.y
        return Vec2::new(x, y)

# Mat3 operators
impl Mul for Mat3:
    fn mul(self, other: Mat3) -> Mat3:
        let mut result = Mat3::zero()
        for row in 0..3:
            for col in 0..3:
                let mut sum = 0.0
                for k in 0..3:
                    sum = sum + self.get(row, k) * other.get(k, col)
                result.set(row, col, sum)
        return result

# =============================================================================
# Mat4 - 4x4 Matrix (for 3D transforms)
# =============================================================================

pub struct Mat4:
    # Column-major storage: [col0, col1, col2, col3]
    # | m00 m10 m20 m30 |
    # | m01 m11 m21 m31 |
    # | m02 m12 m22 m32 |
    # | m03 m13 m23 m33 |
    data: [f32; 16]

impl Mat4:
    # Constructors
    pub fn new(
        m00: f32, m10: f32, m20: f32, m30: f32,
        m01: f32, m11: f32, m21: f32, m31: f32,
        m02: f32, m12: f32, m22: f32, m32: f32,
        m03: f32, m13: f32, m23: f32, m33: f32
    ) -> Mat4:
        return Mat4 {
            data: [
                m00, m01, m02, m03,
                m10, m11, m12, m13,
                m20, m21, m22, m23,
                m30, m31, m32, m33
            ]
        }

    pub fn identity() -> Mat4:
        return Mat4 {
            data: [
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn zero() -> Mat4:
        return Mat4 {
            data: [
                0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0
            ]
        }

    # 3D Translation
    pub fn translation(x: f32, y: f32, z: f32) -> Mat4:
        return Mat4 {
            data: [
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                x, y, z, 1.0
            ]
        }

    pub fn translation_vec3(v: Vec3) -> Mat4:
        return Mat4::translation(v.x, v.y, v.z)

    # 3D Scaling
    pub fn scaling(x: f32, y: f32, z: f32) -> Mat4:
        return Mat4 {
            data: [
                x, 0.0, 0.0, 0.0,
                0.0, y, 0.0, 0.0,
                0.0, 0.0, z, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn scaling_vec3(v: Vec3) -> Mat4:
        return Mat4::scaling(v.x, v.y, v.z)

    pub fn scaling_uniform(s: f32) -> Mat4:
        return Mat4::scaling(s, s, s)

    # 3D Rotations (axis-angle, radians)
    pub fn rotation_x(angle: f32) -> Mat4:
        let c = cos(angle)
        let s = sin(angle)
        return Mat4 {
            data: [
                1.0, 0.0, 0.0, 0.0,
                0.0, c, s, 0.0,
                0.0, -s, c, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn rotation_y(angle: f32) -> Mat4:
        let c = cos(angle)
        let s = sin(angle)
        return Mat4 {
            data: [
                c, 0.0, -s, 0.0,
                0.0, 1.0, 0.0, 0.0,
                s, 0.0, c, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn rotation_z(angle: f32) -> Mat4:
        let c = cos(angle)
        let s = sin(angle)
        return Mat4 {
            data: [
                c, s, 0.0, 0.0,
                -s, c, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    # Rotation from axis and angle
    pub fn rotation_axis(axis: Vec3, angle: f32) -> Mat4:
        let n = axis.normalize()
        let c = cos(angle)
        let s = sin(angle)
        let t = 1.0 - c

        let x = n.x
        let y = n.y
        let z = n.z

        return Mat4::new(
            t * x * x + c,     t * x * y + s * z, t * x * z - s * y, 0.0,
            t * x * y - s * z, t * y * y + c,     t * y * z + s * x, 0.0,
            t * x * z + s * y, t * y * z - s * x, t * z * z + c,     0.0,
            0.0,               0.0,               0.0,               1.0
        )

    # Camera Matrices

    # Look-at matrix (view matrix)
    pub fn look_at(eye: Vec3, target: Vec3, up: Vec3) -> Mat4:
        let f = (target - eye).normalize()
        let s = f.cross(up).normalize()
        let u = s.cross(f)

        return Mat4::new(
            s.x, u.x, -f.x, 0.0,
            s.y, u.y, -f.y, 0.0,
            s.z, u.z, -f.z, 0.0,
            -s.dot(eye), -u.dot(eye), f.dot(eye), 1.0
        )

    # Perspective projection (FOV in radians, aspect ratio, near/far planes)
    pub fn perspective(fov_y: f32, aspect: f32, near: f32, far: f32) -> Mat4:
        let tan_half_fov = tan(fov_y / 2.0)
        let f = 1.0 / tan_half_fov

        return Mat4 {
            data: [
                f / aspect, 0.0, 0.0, 0.0,
                0.0, f, 0.0, 0.0,
                0.0, 0.0, (far + near) / (near - far), -1.0,
                0.0, 0.0, (2.0 * far * near) / (near - far), 0.0
            ]
        }

    # Orthographic projection
    pub fn orthographic(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -> Mat4:
        let w = right - left
        let h = top - bottom
        let d = far - near

        return Mat4 {
            data: [
                2.0 / w, 0.0, 0.0, 0.0,
                0.0, 2.0 / h, 0.0, 0.0,
                0.0, 0.0, -2.0 / d, 0.0,
                -(right + left) / w, -(top + bottom) / h, -(far + near) / d, 1.0
            ]
        }

    # Element access
    pub fn get(self, row: i32, col: i32) -> f32:
        return self.data[col * 4 + row]

    pub fn set(mut self, row: i32, col: i32, value: f32):
        self.data[col * 4 + row] = value

    # Matrix operations
    pub fn transpose(self) -> Mat4:
        return Mat4::new(
            self.get(0, 0), self.get(0, 1), self.get(0, 2), self.get(0, 3),
            self.get(1, 0), self.get(1, 1), self.get(1, 2), self.get(1, 3),
            self.get(2, 0), self.get(2, 1), self.get(2, 2), self.get(2, 3),
            self.get(3, 0), self.get(3, 1), self.get(3, 2), self.get(3, 3)
        )

    # Transform Vec3 as point (w=1, applies translation)
    pub fn transform_point(self, v: Vec3) -> Vec3:
        let x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2) * v.z + self.get(0, 3)
        let y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2) * v.z + self.get(1, 3)
        let z = self.get(2, 0) * v.x + self.get(2, 1) * v.y + self.get(2, 2) * v.z + self.get(2, 3)
        return Vec3::new(x, y, z)

    # Transform Vec3 as vector (w=0, no translation)
    pub fn transform_vector(self, v: Vec3) -> Vec3:
        let x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2) * v.z
        let y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2) * v.z
        let z = self.get(2, 0) * v.x + self.get(2, 1) * v.y + self.get(2, 2) * v.z
        return Vec3::new(x, y, z)

    # Transform Vec4 (full matrix multiplication)
    pub fn transform_vec4(self, v: Vec4) -> Vec4:
        let x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2) * v.z + self.get(0, 3) * v.w
        let y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2) * v.z + self.get(1, 3) * v.w
        let z = self.get(2, 0) * v.x + self.get(2, 1) * v.y + self.get(2, 2) * v.z + self.get(2, 3) * v.w
        let w = self.get(3, 0) * v.x + self.get(3, 1) * v.y + self.get(3, 2) * v.z + self.get(3, 3) * v.w
        return Vec4::new(x, y, z, w)

    # Extract Mat3 upper-left (for normal matrix)
    pub fn to_mat3(self) -> Mat3:
        return Mat3::new(
            self.get(0, 0), self.get(0, 1), self.get(0, 2),
            self.get(1, 0), self.get(1, 1), self.get(1, 2),
            self.get(2, 0), self.get(2, 1), self.get(2, 2)
        )

# Mat4 operators
impl Mul for Mat4:
    fn mul(self, other: Mat4) -> Mat4:
        let mut result = Mat4::zero()
        for row in 0..4:
            for col in 0..4:
                let mut sum = 0.0
                for k in 0..4:
                    sum = sum + self.get(row, k) * other.get(k, col)
                result.set(row, col, sum)
        return result
