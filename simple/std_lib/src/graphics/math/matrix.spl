# Matrix - 3x3 and 4x4 transformation matrices
#
# Provides Mat3 and Mat4 types for 2D and 3D transformations.
# Column-major storage (OpenGL/Vulkan convention).
# Supports transformations, camera matrices, and composition.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.vector.*

# =============================================================================
# Mat3 - 3x3 Matrix (for 2D transforms and normal matrices)
# =============================================================================

pub struct Mat3:
    # Column-major storage: [col0, col1, col2]
    # | m00 m10 m20 |
    # | m01 m11 m21 |
    # | m02 m12 m22 |
    data: [f32; 9]

impl Mat3:
    # Constructors
    pub fn new(
        m00: f32, m10: f32, m20: f32,
        m01: f32, m11: f32, m21: f32,
        m02: f32, m12: f32, m22: f32
    ) -> Mat3:
        return Mat3 {
            data: [m00, m01, m02, m10, m11, m12, m20, m21, m22]
        }

    pub fn identity() -> Mat3:
        return Mat3 {
            data: [
                1.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 0.0, 1.0
            ]
        }

    pub fn zero() -> Mat3:
        return Mat3 {
            data: [
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0
            ]
        }

    # 2D Rotation (radians)
    pub fn rotation_2d(angle: f32) -> Mat3:
        val c = cos(angle)
        val s = sin(angle)
        return Mat3 {
            data: [
                c, s, 0.0,
                -s, c, 0.0,
                0.0, 0.0, 1.0
            ]
        }

    # 2D Scaling
    pub fn scaling_2d(sx: f32, sy: f32) -> Mat3:
        return Mat3 {
            data: [
                sx, 0.0, 0.0,
                0.0, sy, 0.0,
                0.0, 0.0, 1.0
            ]
        }

    # 2D Translation
    pub fn translation_2d(tx: f32, ty: f32) -> Mat3:
        return Mat3 {
            data: [
                1.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                tx, ty, 1.0
            ]
        }

    # Element access
    pub fn get(self, row: i32, col: i32) -> f32:
        return self.data[col * 3 + row]

    pub fn set(mut self, row: i32, col: i32, value: f32):
        self.data[col * 3 + row] = value

    # Matrix operations
    pub fn transpose(self) -> Mat3:
        return Mat3::new(
            self.get(0, 0), self.get(0, 1), self.get(0, 2),
            self.get(1, 0), self.get(1, 1), self.get(1, 2),
            self.get(2, 0), self.get(2, 1), self.get(2, 2)
        )

    pub fn determinant(self) -> f32:
        val m00 = self.get(0, 0)
        val m01 = self.get(0, 1)
        val m02 = self.get(0, 2)
        val m10 = self.get(1, 0)
        val m11 = self.get(1, 1)
        val m12 = self.get(1, 2)
        val m20 = self.get(2, 0)
        val m21 = self.get(2, 1)
        val m22 = self.get(2, 2)

        return m00 * (m11 * m22 - m12 * m21) -
               m01 * (m10 * m22 - m12 * m20) +
               m02 * (m10 * m21 - m11 * m20)

    # Transform Vec2
    pub fn transform_point(self, v: Vec2) -> Vec2:
        val x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2)
        val y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2)
        return Vec2::new(x, y)

    pub fn transform_vector(self, v: Vec2) -> Vec2:
        val x = self.get(0, 0) * v.x + self.get(0, 1) * v.y
        val y = self.get(1, 0) * v.x + self.get(1, 1) * v.y
        return Vec2::new(x, y)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_identity(self) -> bool:
        """Check if matrix is identity matrix."""
        for row in 0..3:
            for col in 0..3:
                val expected = if row == col: 1.0 else: 0.0
                if abs(self.get(row, col) - expected) > 0.0001:
                    return false
        return true

    pub fn is_zero(self) -> bool:
        """Check if matrix is zero matrix."""
        for i in 0..9:
            if abs(self.data[i]) > 0.0001:
                return false
        return true

    pub fn is_invertible(self) -> bool:
        """Check if matrix is invertible (non-zero determinant)."""
        return abs(self.determinant()) > 0.0001

    pub fn is_orthogonal(self) -> bool:
        """Check if matrix is orthogonal (M * M^T = I)."""
        val mt = self.transpose()
        val product = self * mt
        return product.is_identity()

    pub fn has_nan(self) -> bool:
        """Check if any element is NaN."""
        for i in 0..9:
            if is_nan(self.data[i]):
                return true
        return false

    pub fn is_finite(self) -> bool:
        """Check if all elements are finite (not NaN or infinity)."""
        for i in 0..9:
            if not is_finite(self.data[i]):
                return false
        return true

    pub fn trace(self) -> f32:
        """Get trace of matrix (sum of diagonal elements)."""
        return self.get(0, 0) + self.get(1, 1) + self.get(2, 2)

    pub fn frobenius_norm(self) -> f32:
        """Get Frobenius norm (square root of sum of squared elements)."""
        var sum = 0.0
        for i in 0..9:
            sum = sum + self.data[i] * self.data[i]
        return sqrt(sum)

    pub fn summary(self) -> text:
        """Get summary of matrix.

        Returns:
            Human-readable summary

        Example:
            Mat3::identity().summary()
            # → "Mat3: 3x3, det: 1.000 [identity, orthogonal]"
        """
        val det = self.determinant()
        val id = if self.is_identity(): ", identity" else: ""
        val ortho = if self.is_orthogonal(): ", orthogonal" else: ""
        val zero = if self.is_zero(): " [zero]" else: ""
        return "Mat3: 3x3, det: {det:.3}{id}{ortho}{zero}"

# Mat3 operators
impl Mul for Mat3:
    fn mul(other: Mat3) -> Mat3:
        var result = Mat3::zero()
        for row in 0..3:
            for col in 0..3:
                var sum = 0.0
                for k in 0..3:
                    sum = sum + self.get(row, k) * other.get(k, col)
                result.set(row, col, sum)
        return result

# =============================================================================
# Mat4 - 4x4 Matrix (for 3D transforms)
# =============================================================================

pub struct Mat4:
    # Column-major storage: [col0, col1, col2, col3]
    # | m00 m10 m20 m30 |
    # | m01 m11 m21 m31 |
    # | m02 m12 m22 m32 |
    # | m03 m13 m23 m33 |
    data: [f32; 16]

impl Mat4:
    # Constructors
    pub fn new(
        m00: f32, m10: f32, m20: f32, m30: f32,
        m01: f32, m11: f32, m21: f32, m31: f32,
        m02: f32, m12: f32, m22: f32, m32: f32,
        m03: f32, m13: f32, m23: f32, m33: f32
    ) -> Mat4:
        return Mat4 {
            data: [
                m00, m01, m02, m03,
                m10, m11, m12, m13,
                m20, m21, m22, m23,
                m30, m31, m32, m33
            ]
        }

    pub fn identity() -> Mat4:
        return Mat4 {
            data: [
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn zero() -> Mat4:
        return Mat4 {
            data: [
                0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0
            ]
        }

    # 3D Translation
    pub fn translation(x: f32, y: f32, z: f32) -> Mat4:
        return Mat4 {
            data: [
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                x, y, z, 1.0
            ]
        }

    pub fn translation_vec3(v: Vec3) -> Mat4:
        return Mat4::translation(v.x, v.y, v.z)

    # 3D Scaling
    pub fn scaling(x: f32, y: f32, z: f32) -> Mat4:
        return Mat4 {
            data: [
                x, 0.0, 0.0, 0.0,
                0.0, y, 0.0, 0.0,
                0.0, 0.0, z, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn scaling_vec3(v: Vec3) -> Mat4:
        return Mat4::scaling(v.x, v.y, v.z)

    pub fn scaling_uniform(s: f32) -> Mat4:
        return Mat4::scaling(s, s, s)

    # 3D Rotations (axis-angle, radians)
    pub fn rotation_x(angle: f32) -> Mat4:
        val c = cos(angle)
        val s = sin(angle)
        return Mat4 {
            data: [
                1.0, 0.0, 0.0, 0.0,
                0.0, c, s, 0.0,
                0.0, -s, c, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn rotation_y(angle: f32) -> Mat4:
        val c = cos(angle)
        val s = sin(angle)
        return Mat4 {
            data: [
                c, 0.0, -s, 0.0,
                0.0, 1.0, 0.0, 0.0,
                s, 0.0, c, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    pub fn rotation_z(angle: f32) -> Mat4:
        val c = cos(angle)
        val s = sin(angle)
        return Mat4 {
            data: [
                c, s, 0.0, 0.0,
                -s, c, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }

    # Rotation from axis and angle
    pub fn rotation_axis(axis: Vec3, angle: f32) -> Mat4:
        val n = axis.normalize()
        val c = cos(angle)
        val s = sin(angle)
        val t = 1.0 - c

        val x = n.x
        val y = n.y
        val z = n.z

        return Mat4::new(
            t * x * x + c,     t * x * y + s * z, t * x * z - s * y, 0.0,
            t * x * y - s * z, t * y * y + c,     t * y * z + s * x, 0.0,
            t * x * z + s * y, t * y * z - s * x, t * z * z + c,     0.0,
            0.0,               0.0,               0.0,               1.0
        )

    # Camera Matrices

    # Look-at matrix (view matrix)
    pub fn look_at(eye: Vec3, target: Vec3, up: Vec3) -> Mat4:
        val f = (target - eye).normalize()
        val s = f.cross(up).normalize()
        val u = s.cross(f)

        return Mat4::new(
            s.x, u.x, -f.x, 0.0,
            s.y, u.y, -f.y, 0.0,
            s.z, u.z, -f.z, 0.0,
            -s.dot(eye), -u.dot(eye), f.dot(eye), 1.0
        )

    # Perspective projection (FOV in radians, aspect ratio, near/far planes)
    pub fn perspective(fov_y: f32, aspect: f32, near: f32, far: f32) -> Mat4:
        val tan_half_fov = tan(fov_y / 2.0)
        val f = 1.0 / tan_half_fov

        return Mat4 {
            data: [
                f / aspect, 0.0, 0.0, 0.0,
                0.0, f, 0.0, 0.0,
                0.0, 0.0, (far + near) / (near - far), -1.0,
                0.0, 0.0, (2.0 * far * near) / (near - far), 0.0
            ]
        }

    # Orthographic projection
    pub fn orthographic(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -> Mat4:
        val w = right - left
        val h = top - bottom
        val d = far - near

        return Mat4 {
            data: [
                2.0 / w, 0.0, 0.0, 0.0,
                0.0, 2.0 / h, 0.0, 0.0,
                0.0, 0.0, -2.0 / d, 0.0,
                -(right + left) / w, -(top + bottom) / h, -(far + near) / d, 1.0
            ]
        }

    # Element access
    pub fn get(self, row: i32, col: i32) -> f32:
        return self.data[col * 4 + row]

    pub fn set(mut self, row: i32, col: i32, value: f32):
        self.data[col * 4 + row] = value

    # Matrix operations
    pub fn transpose(self) -> Mat4:
        return Mat4::new(
            self.get(0, 0), self.get(0, 1), self.get(0, 2), self.get(0, 3),
            self.get(1, 0), self.get(1, 1), self.get(1, 2), self.get(1, 3),
            self.get(2, 0), self.get(2, 1), self.get(2, 2), self.get(2, 3),
            self.get(3, 0), self.get(3, 1), self.get(3, 2), self.get(3, 3)
        )

    # Transform Vec3 as point (w=1, applies translation)
    pub fn transform_point(self, v: Vec3) -> Vec3:
        val x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2) * v.z + self.get(0, 3)
        val y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2) * v.z + self.get(1, 3)
        val z = self.get(2, 0) * v.x + self.get(2, 1) * v.y + self.get(2, 2) * v.z + self.get(2, 3)
        return Vec3::new(x, y, z)

    # Transform Vec3 as vector (w=0, no translation)
    pub fn transform_vector(self, v: Vec3) -> Vec3:
        val x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2) * v.z
        val y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2) * v.z
        val z = self.get(2, 0) * v.x + self.get(2, 1) * v.y + self.get(2, 2) * v.z
        return Vec3::new(x, y, z)

    # Transform Vec4 (full matrix multiplication)
    pub fn transform_vec4(self, v: Vec4) -> Vec4:
        val x = self.get(0, 0) * v.x + self.get(0, 1) * v.y + self.get(0, 2) * v.z + self.get(0, 3) * v.w
        val y = self.get(1, 0) * v.x + self.get(1, 1) * v.y + self.get(1, 2) * v.z + self.get(1, 3) * v.w
        val z = self.get(2, 0) * v.x + self.get(2, 1) * v.y + self.get(2, 2) * v.z + self.get(2, 3) * v.w
        val w = self.get(3, 0) * v.x + self.get(3, 1) * v.y + self.get(3, 2) * v.z + self.get(3, 3) * v.w
        return Vec4::new(x, y, z, w)

    # Extract Mat3 upper-left (for normal matrix)
    pub fn to_mat3(self) -> Mat3:
        return Mat3::new(
            self.get(0, 0), self.get(0, 1), self.get(0, 2),
            self.get(1, 0), self.get(1, 1), self.get(1, 2),
            self.get(2, 0), self.get(2, 1), self.get(2, 2)
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_identity(self) -> bool:
        """Check if matrix is identity matrix."""
        for row in 0..4:
            for col in 0..4:
                val expected = if row == col: 1.0 else: 0.0
                if abs(self.get(row, col) - expected) > 0.0001:
                    return false
        return true

    pub fn is_zero(self) -> bool:
        """Check if matrix is zero matrix."""
        for i in 0..16:
            if abs(self.data[i]) > 0.0001:
                return false
        return true

    pub fn is_invertible(self) -> bool:
        """Check if matrix is invertible (has full rank).

        Note: This is a heuristic check - checks if upper-left 3x3 is invertible.
        """
        val m3 = self.to_mat3()
        return m3.is_invertible()

    pub fn is_orthogonal(self) -> bool:
        """Check if matrix is orthogonal (M * M^T = I)."""
        val mt = self.transpose()
        val product = self * mt
        return product.is_identity()

    pub fn has_nan(self) -> bool:
        """Check if any element is NaN."""
        for i in 0..16:
            if is_nan(self.data[i]):
                return true
        return false

    pub fn is_finite(self) -> bool:
        """Check if all elements are finite (not NaN or infinity)."""
        for i in 0..16:
            if not is_finite(self.data[i]):
                return false
        return true

    pub fn is_affine(self) -> bool:
        """Check if matrix is affine (last row is [0, 0, 0, 1])."""
        return abs(self.get(3, 0)) < 0.0001 and
               abs(self.get(3, 1)) < 0.0001 and
               abs(self.get(3, 2)) < 0.0001 and
               abs(self.get(3, 3) - 1.0) < 0.0001

    pub fn trace(self) -> f32:
        """Get trace of matrix (sum of diagonal elements)."""
        return self.get(0, 0) + self.get(1, 1) + self.get(2, 2) + self.get(3, 3)

    pub fn frobenius_norm(self) -> f32:
        """Get Frobenius norm (square root of sum of squared elements)."""
        var sum = 0.0
        for i in 0..16:
            sum = sum + self.data[i] * self.data[i]
        return sqrt(sum)

    pub fn extract_translation(self) -> Vec3:
        """Extract translation component from transformation matrix."""
        return Vec3::new(self.get(0, 3), self.get(1, 3), self.get(2, 3))

    pub fn extract_scale(self) -> Vec3:
        """Extract scale component from transformation matrix.

        Assumes no shear and extracts length of basis vectors.
        """
        val sx = sqrt(
            self.get(0, 0) * self.get(0, 0) +
            self.get(1, 0) * self.get(1, 0) +
            self.get(2, 0) * self.get(2, 0)
        )
        val sy = sqrt(
            self.get(0, 1) * self.get(0, 1) +
            self.get(1, 1) * self.get(1, 1) +
            self.get(2, 1) * self.get(2, 1)
        )
        val sz = sqrt(
            self.get(0, 2) * self.get(0, 2) +
            self.get(1, 2) * self.get(1, 2) +
            self.get(2, 2) * self.get(2, 2)
        )
        return Vec3::new(sx, sy, sz)

    pub fn is_rotation_matrix(self) -> bool:
        """Check if matrix is a pure rotation (orthogonal + det ≈ 1 + affine)."""
        if not self.is_affine():
            return false
        if not self.is_orthogonal():
            return false
        # Check determinant is 1 (not -1, which would be reflection)
        val m3 = self.to_mat3()
        val det = m3.determinant()
        return abs(det - 1.0) < 0.0001

    pub fn summary(self) -> text:
        """Get summary of matrix.

        Returns:
            Human-readable summary

        Example:
            Mat4::identity().summary()
            # → "Mat4: 4x4, affine, identity, orthogonal"
        """
        val id = if self.is_identity(): "identity" else: ""
        val affine = if self.is_affine(): "affine" else: "projective"
        val ortho = if self.is_orthogonal(): ", orthogonal" else: ""
        val rot = if self.is_rotation_matrix(): ", rotation" else: ""
        val zero = if self.is_zero(): " [zero]" else: ""

        val flags = if id != "": id + ", " + ortho + rot
                    else: affine + ortho + rot

        return "Mat4: 4x4, {flags}{zero}"

# Mat4 operators
impl Mul for Mat4:
    fn mul(other: Mat4) -> Mat4:
        var result = Mat4::zero()
        for row in 0..4:
            for col in 0..4:
                var sum = 0.0
                for k in 0..4:
                    sum = sum + self.get(row, k) * other.get(k, col)
                result.set(row, col, sum)
        return result
