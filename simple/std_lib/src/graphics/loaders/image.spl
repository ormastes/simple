# Image Loader - PNG/JPG texture loading
#
# Loads textures from image files.
# Supports PNG (lossless) and JPG (lossy) formats.
# Handles pixel format conversion and mipmap generation.
# Creates Texture2D objects ready for GPU upload.
#
# Based on: doc/plans/floating-booping-coral.md (Phase 5)

use core.*
use graphics.math.*
use graphics.render.*

# =============================================================================
# Image Loader
# =============================================================================

pub struct ImageLoader:
    # Static utility - no instance data
    _dummy: u8

pub enum ImageFormat:
    PNG
    JPG
    Unknown

pub struct ImageData:
    width: u32
    height: u32
    format: PixelFormat
    pixels: Array[u8]   # Raw pixel data (RGBA8 or RGB8)

pub enum PixelFormat:
    RGB8       # 3 bytes per pixel
    RGBA8      # 4 bytes per pixel
    R8         # 1 byte per pixel (grayscale)

# =============================================================================
# Public API
# =============================================================================

impl ImageLoader:
    # Load image from file
    pub fn load_file(path: String) -> Result[ImageData, String]:
        # Detect format from extension
        let format = ImageLoader::detect_format(path)

        # Read file as bytes
        let bytes = match file_read_bytes(path):
            case Ok(data):
                data
            case Err(err):
                return Err("Failed to read image file: " + err)

        # Decode based on format
        return match format:
            case ImageFormat::PNG:
                ImageLoader::decode_png(bytes)
            case ImageFormat::JPG:
                ImageLoader::decode_jpg(bytes)
            case ImageFormat::Unknown:
                Err("Unknown image format for file: " + path)

    # Load image and create texture
    pub fn load_texture(path: String, generate_mipmaps: bool) -> Result[Texture2D, String]:
        let image_data = ImageLoader::load_file(path)?

        # Convert to texture format
        let texture_format = match image_data.format:
            case PixelFormat::RGB8:
                TextureFormat::RGB8
            case PixelFormat::RGBA8:
                TextureFormat::RGBA8
            case PixelFormat::R8:
                TextureFormat::R8

        # Calculate mip levels
        let mip_levels = if generate_mipmaps:
            ImageLoader::calculate_mip_levels(image_data.width, image_data.height)
        else:
            1

        # Create texture
        let texture = Texture2D::new(
            image_data.width,
            image_data.height,
            texture_format,
            mip_levels
        )

        # Upload pixel data
        texture.upload_data(image_data.pixels)

        # Generate mipmaps if requested
        if generate_mipmaps:
            texture.generate_mipmaps()

        return Ok(texture)

# =============================================================================
# Format Detection
# =============================================================================

impl ImageLoader:
    fn detect_format(path: String) -> ImageFormat:
        let lower_path = path.to_lowercase()

        if lower_path.ends_with(".png"):
            return ImageFormat::PNG
        else if lower_path.ends_with(".jpg") or lower_path.ends_with(".jpeg"):
            return ImageFormat::JPG
        else:
            return ImageFormat::Unknown

    fn calculate_mip_levels(width: u32, height: u32) -> u32:
        let max_dimension = max_u32(width, height)
        let mut levels = 1_u32

        let mut size = max_dimension
        while size > 1:
            size = size / 2
            levels = levels + 1

        return levels

# =============================================================================
# PNG Decoding
# =============================================================================

impl ImageLoader:
    fn decode_png(bytes: Array[u8]) -> Result[ImageData, String]:
        # Verify PNG signature (8 bytes: 137 80 78 71 13 10 26 10)
        if bytes.len() < 8:
            return Err("File too small to be PNG")

        if bytes[0] != 137 or bytes[1] != 80 or bytes[2] != 78 or bytes[3] != 71:
            return Err("Invalid PNG signature")

        # Decode PNG using FFI (delegates to Rust/C library)
        let result = png_decode(bytes)

        return match result:
            case Ok(decoded):
                Ok(decoded)
            case Err(err):
                Err("PNG decoding failed: " + err)

# =============================================================================
# JPG Decoding
# =============================================================================

impl ImageLoader:
    fn decode_jpg(bytes: Array[u8]) -> Result[ImageData, String]:
        # Verify JPG signature (2 bytes: FF D8)
        if bytes.len() < 2:
            return Err("File too small to be JPG")

        if bytes[0] != 0xFF or bytes[1] != 0xD8:
            return Err("Invalid JPG signature")

        # Decode JPG using FFI (delegates to Rust/C library)
        let result = jpg_decode(bytes)

        return match result:
            case Ok(decoded):
                Ok(decoded)
            case Err(err):
                Err("JPG decoding failed: " + err)

# =============================================================================
# Image Data Manipulation
# =============================================================================

impl ImageData:
    # Convert RGB8 to RGBA8 (add alpha channel)
    pub fn to_rgba8(self) -> ImageData:
        if self.format == PixelFormat::RGBA8:
            return self  # Already RGBA8

        if self.format != PixelFormat::RGB8:
            # Cannot convert non-RGB to RGBA
            return self

        let pixel_count = (self.width * self.height) as usize
        let mut rgba_pixels = Array[u8]::with_capacity(pixel_count * 4)

        # Convert RGB to RGBA (add alpha = 255)
        for i in 0..pixel_count:
            let rgb_offset = i * 3
            rgba_pixels.push(self.pixels[rgb_offset])      # R
            rgba_pixels.push(self.pixels[rgb_offset + 1])  # G
            rgba_pixels.push(self.pixels[rgb_offset + 2])  # B
            rgba_pixels.push(255)                          # A (opaque)

        return ImageData {
            width: self.width,
            height: self.height,
            format: PixelFormat::RGBA8,
            pixels: rgba_pixels
        }

    # Flip vertically (OpenGL convention: origin bottom-left)
    pub fn flip_vertical(mut self) -> ImageData:
        let bytes_per_pixel = match self.format:
            case PixelFormat::RGB8: 3
            case PixelFormat::RGBA8: 4
            case PixelFormat::R8: 1

        let row_size = (self.width as usize) * bytes_per_pixel
        let mut flipped = Array[u8]::with_capacity(self.pixels.len())

        # Copy rows in reverse order
        for y in 0..self.height:
            let src_row = ((self.height - 1 - y) as usize) * row_size
            let src_end = src_row + row_size

            for i in src_row..src_end:
                flipped.push(self.pixels[i])

        self.pixels = flipped
        return self

    # Get pixel color at (x, y)
    pub fn get_pixel(self, x: u32, y: u32) -> Color:
        if x >= self.width or y >= self.height:
            return Color::from_rgb(0.0, 0.0, 0.0)  # Out of bounds

        let bytes_per_pixel = match self.format:
            case PixelFormat::RGB8: 3
            case PixelFormat::RGBA8: 4
            case PixelFormat::R8: 1

        let index = ((y * self.width + x) as usize) * bytes_per_pixel

        return match self.format:
            case PixelFormat::RGB8:
                let r = self.pixels[index] as f32 / 255.0
                let g = self.pixels[index + 1] as f32 / 255.0
                let b = self.pixels[index + 2] as f32 / 255.0
                Color::from_rgb(r, g, b)

            case PixelFormat::RGBA8:
                let r = self.pixels[index] as f32 / 255.0
                let g = self.pixels[index + 1] as f32 / 255.0
                let b = self.pixels[index + 2] as f32 / 255.0
                let a = self.pixels[index + 3] as f32 / 255.0
                Color::from_rgba(r, g, b, a)

            case PixelFormat::R8:
                let gray = self.pixels[index] as f32 / 255.0
                Color::from_rgb(gray, gray, gray)

# =============================================================================
# Helper Functions
# =============================================================================

fn max_u32(a: u32, b: u32) -> u32:
    if a > b:
        return a
    return b

# =============================================================================
# File I/O and Image Decoding (FFI - to be implemented in runtime)
# =============================================================================

# Read file as bytes
extern fn file_read_bytes(path: String) -> Result[Array[u8], String]

# Decode PNG image (delegates to image crate in Rust)
extern fn png_decode(bytes: Array[u8]) -> Result[ImageData, String]

# Decode JPG image (delegates to image crate in Rust)
extern fn jpg_decode(bytes: Array[u8]) -> Result[ImageData, String]
