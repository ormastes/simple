# SDN Scene Format - Scene definition in SDN notation
#
# Loads 3D scenes from .sdn files with cameras, lights, nodes, and materials.
# Uses Simple Data Notation (SDN) for clean, readable scene descriptions.
#
# Example SDN scene:
#   scene:
#       name: "Demo Scene"
#       cameras = [{...}]
#       lights = [{...}]
#       nodes = [{...}]
#       materials = [{...}]
#
# Based on: doc/spec/sdn.md + doc/plans/floating-booping-coral.md

use core.*
use graphics.math.*
use graphics.scene.*

# =============================================================================
# SDN Scene Structures
# =============================================================================

pub struct SdnScene:
    name: String
    cameras: Array[SdnCamera]
    lights: Array[SdnLight]
    nodes: Array[SdnNode]
    materials: Array[SdnMaterial]
    skybox: Option[SdnSkybox]
    environment: Option[String]     # Path to HDR environment map

pub struct SdnCamera:
    name: String
    type_name: String               # "perspective" or "orthographic"
    # Perspective
    fov: f32                        # Field of view (degrees)
    aspect: f32                     # Aspect ratio
    near: f32                       # Near plane
    far: f32                        # Far plane
    # Orthographic
    left: f32
    right: f32
    top: f32
    bottom: f32
    # Transform
    position: Vec3
    look_at: Vec3
    up: Vec3

pub struct SdnLight:
    name: String
    type_name: String               # "directional", "point", "spot"
    color: Vec3                     # RGB color
    intensity: f32                  # Light intensity
    # Directional
    direction: Vec3
    # Point
    position: Vec3
    range: f32                      # Max distance
    # Spot
    inner_angle: f32                # Inner cone angle (degrees)
    outer_angle: f32                # Outer cone angle (degrees)
    # Shadows
    cast_shadows: bool

pub struct SdnNode:
    name: String
    # Transform
    position: Vec3                  # Default: (0, 0, 0)
    rotation: Vec3                  # Euler angles (degrees)
    scale: Vec3                     # Default: (1, 1, 1)
    # Components
    mesh: Option[String]            # Mesh file path (.obj, .gltf)
    material: Option[String]        # Material name
    # Hierarchy
    children: Array[SdnNode]

pub struct SdnMaterial:
    name: String
    # PBR properties
    base_color: Vec4                # Default: (1, 1, 1, 1)
    metallic: f32                   # Default: 0.0
    roughness: f32                  # Default: 1.0
    emissive: Vec3                  # Default: (0, 0, 0)
    # Textures
    albedo_map: Option[String]
    metallic_roughness_map: Option[String]
    normal_map: Option[String]
    ao_map: Option[String]
    emissive_map: Option[String]
    # Flags
    double_sided: bool              # Default: false
    alpha_mode: String              # "opaque", "mask", "blend"
    alpha_cutoff: f32               # Default: 0.5

pub struct SdnSkybox:
    type_name: String               # "cubemap", "color", "procedural"
    cubemap_path: Option[String]    # For cubemap type
    color: Vec3                     # For color type
    horizon_color: Vec3             # For procedural type
    zenith_color: Vec3              # For procedural type
    ground_color: Vec3              # For procedural type

# =============================================================================
# SDN Scene Loader
# =============================================================================

pub struct SdnSceneLoader:
    pass

impl SdnSceneLoader:
    # Load scene from .sdn file
    pub fn load_file(path: String) -> Result[SdnScene, String]:
        # Read file contents
        val contents = match file_read_string(path):
            case Ok(data):
                data
            case Err(err):
                return Err("Failed to read SDN file: " + err)

        # Parse SDN
        return SdnSceneLoader::parse(contents)

    # Parse SDN scene from string
    pub fn parse(contents: String) -> Result[SdnScene, String]:
        # Parse SDN root
        val sdn = sdn_parse(contents)
            .ok_or("Failed to parse SDN")?

        # Parse scene block
        val scene_obj = sdn.get("scene")
            .ok_or("SDN file missing 'scene' block")?
            .as_object()
            .ok_or("'scene' must be an object")?

        # Parse fields
        val name = scene_obj.get("name")
            .and_then(|v| v.as_string())
            .unwrap_or("Untitled Scene")

        val cameras = SdnSceneLoader::parse_cameras(scene_obj.get("cameras"))?
        val lights = SdnSceneLoader::parse_lights(scene_obj.get("lights"))?
        val nodes = SdnSceneLoader::parse_nodes(scene_obj.get("nodes"))?
        val materials = SdnSceneLoader::parse_materials(scene_obj.get("materials"))?

        val skybox = scene_obj.get("skybox")
            .and_then(|v| SdnSceneLoader::parse_skybox(v).ok())

        val environment = scene_obj.get("environment")
            .and_then(|v| v.as_string())

        return Ok(SdnScene {
            name: name,
            cameras: cameras,
            lights: lights,
            nodes: nodes,
            materials: materials,
            skybox: skybox,
            environment: environment
        })

# =============================================================================
# Camera Parsing
# =============================================================================

impl SdnSceneLoader:
    fn parse_cameras(sdn_opt: Option[SdnValue]) -> Result[Array[SdnCamera], String]:
        val array = match sdn_opt:
            case Some(sdn):
                sdn.as_array().ok_or("cameras must be an array")?
            case None:
                return Ok(Array::new())

        var cameras = Array[SdnCamera]::new()
        for item in array:
            cameras.push(SdnSceneLoader::parse_camera(item)?)

        return Ok(cameras)

    fn parse_camera(sdn: SdnValue) -> Result[SdnCamera, String]:
        val obj = sdn.as_object().ok_or("camera must be an object")?

        val name = obj.get("name")
            .and_then(|v| v.as_string())
            .unwrap_or("Camera")

        val type_name = obj.get("type")
            .and_then(|v| v.as_string())
            .unwrap_or("perspective")

        # Perspective defaults
        val fov = obj.get("fov")
            .and_then(|v| v.as_f32())
            .unwrap_or(60.0)

        val aspect = obj.get("aspect")
            .and_then(|v| v.as_f32())
            .unwrap_or(16.0 / 9.0)

        val near = obj.get("near")
            .and_then(|v| v.as_f32())
            .unwrap_or(0.1)

        val far = obj.get("far")
            .and_then(|v| v.as_f32())
            .unwrap_or(1000.0)

        # Orthographic defaults
        val left = obj.get("left").and_then(|v| v.as_f32()).unwrap_or(-10.0)
        val right = obj.get("right").and_then(|v| v.as_f32()).unwrap_or(10.0)
        val top = obj.get("top").and_then(|v| v.as_f32()).unwrap_or(10.0)
        val bottom = obj.get("bottom").and_then(|v| v.as_f32()).unwrap_or(-10.0)

        # Transform
        val position = parse_vec3(obj.get("position"), Vec3::new(0.0, 0.0, 5.0))
        val look_at = parse_vec3(obj.get("look_at"), Vec3::zero())
        val up = parse_vec3(obj.get("up"), Vec3::new(0.0, 1.0, 0.0))

        return Ok(SdnCamera {
            name: name,
            type_name: type_name,
            fov: fov,
            aspect: aspect,
            near: near,
            far: far,
            left: left,
            right: right,
            top: top,
            bottom: bottom,
            position: position,
            look_at: look_at,
            up: up
        })

# =============================================================================
# Light Parsing
# =============================================================================

impl SdnSceneLoader:
    fn parse_lights(sdn_opt: Option[SdnValue]) -> Result[Array[SdnLight], String]:
        val array = match sdn_opt:
            case Some(sdn):
                sdn.as_array().ok_or("lights must be an array")?
            case None:
                return Ok(Array::new())

        var lights = Array[SdnLight]::new()
        for item in array:
            lights.push(SdnSceneLoader::parse_light(item)?)

        return Ok(lights)

    fn parse_light(sdn: SdnValue) -> Result[SdnLight, String]:
        val obj = sdn.as_object().ok_or("light must be an object")?

        val name = obj.get("name").and_then(|v| v.as_string()).unwrap_or("Light")
        val type_name = obj.get("type").and_then(|v| v.as_string()).unwrap_or("directional")
        val color = parse_vec3(obj.get("color"), Vec3::new(1.0, 1.0, 1.0))
        val intensity = obj.get("intensity").and_then(|v| v.as_f32()).unwrap_or(1.0)

        # Type-specific
        val direction = parse_vec3(obj.get("direction"), Vec3::new(0.0, -1.0, 0.0))
        val position = parse_vec3(obj.get("position"), Vec3::zero())
        val range = obj.get("range").and_then(|v| v.as_f32()).unwrap_or(10.0)
        val inner_angle = obj.get("inner_angle").and_then(|v| v.as_f32()).unwrap_or(30.0)
        val outer_angle = obj.get("outer_angle").and_then(|v| v.as_f32()).unwrap_or(45.0)

        val cast_shadows = obj.get("cast_shadows")
            .and_then(|v| v.as_bool())
            .unwrap_or(true)

        return Ok(SdnLight {
            name: name,
            type_name: type_name,
            color: color,
            intensity: intensity,
            direction: direction,
            position: position,
            range: range,
            inner_angle: inner_angle,
            outer_angle: outer_angle,
            cast_shadows: cast_shadows
        })

# =============================================================================
# Node Parsing
# =============================================================================

impl SdnSceneLoader:
    fn parse_nodes(sdn_opt: Option[SdnValue]) -> Result[Array[SdnNode], String]:
        val array = match sdn_opt:
            case Some(sdn):
                sdn.as_array().ok_or("nodes must be an array")?
            case None:
                return Ok(Array::new())

        var nodes = Array[SdnNode]::new()
        for item in array:
            nodes.push(SdnSceneLoader::parse_node(item)?)

        return Ok(nodes)

    fn parse_node(sdn: SdnValue) -> Result[SdnNode, String]:
        val obj = sdn.as_object().ok_or("node must be an object")?

        val name = obj.get("name").and_then(|v| v.as_string()).unwrap_or("Node")

        # Transform
        val position = parse_vec3(obj.get("position"), Vec3::zero())
        val rotation = parse_vec3(obj.get("rotation"), Vec3::zero())  # Euler degrees
        val scale = parse_vec3(obj.get("scale"), Vec3::new(1.0, 1.0, 1.0))

        # Components
        val mesh = obj.get("mesh").and_then(|v| v.as_string())
        val material = obj.get("material").and_then(|v| v.as_string())

        # Children
        val children_sdn = obj.get("children")
        val children = match children_sdn:
            case Some(arr_sdn):
                val arr = arr_sdn.as_array().ok_or("children must be an array")?
                var child_nodes = Array[SdnNode]::new()
                for child in arr:
                    child_nodes.push(SdnSceneLoader::parse_node(child)?)
                child_nodes
            case None:
                Array::new()

        return Ok(SdnNode {
            name: name,
            position: position,
            rotation: rotation,
            scale: scale,
            mesh: mesh,
            material: material,
            children: children
        })

# =============================================================================
# Material Parsing (#1808)
# =============================================================================

impl SdnSceneLoader:
    fn parse_materials(sdn_opt: Option[SdnValue]) -> Result[Array[SdnMaterial], String]:
        val array = match sdn_opt:
            case Some(sdn):
                sdn.as_array().ok_or("materials must be an array")?
            case None:
                return Ok(Array::new())

        var materials = Array[SdnMaterial]::new()
        for item in array:
            materials.push(SdnSceneLoader::parse_material(item)?)

        return Ok(materials)

    fn parse_material(sdn: SdnValue) -> Result[SdnMaterial, String]:
        val obj = sdn.as_object().ok_or("material must be an object")?

        val name = obj.get("name").and_then(|v| v.as_string()).unwrap_or("Material")

        # PBR properties
        val base_color = parse_vec4(obj.get("base_color"), Vec4::new(1.0, 1.0, 1.0, 1.0))
        val metallic = obj.get("metallic").and_then(|v| v.as_f32()).unwrap_or(0.0)
        val roughness = obj.get("roughness").and_then(|v| v.as_f32()).unwrap_or(1.0)
        val emissive = parse_vec3(obj.get("emissive"), Vec3::zero())

        # Textures
        val albedo_map = obj.get("albedo_map").and_then(|v| v.as_string())
        val metallic_roughness_map = obj.get("metallic_roughness_map").and_then(|v| v.as_string())
        val normal_map = obj.get("normal_map").and_then(|v| v.as_string())
        val ao_map = obj.get("ao_map").and_then(|v| v.as_string())
        val emissive_map = obj.get("emissive_map").and_then(|v| v.as_string())

        # Flags
        val double_sided = obj.get("double_sided").and_then(|v| v.as_bool()).unwrap_or(false)
        val alpha_mode = obj.get("alpha_mode").and_then(|v| v.as_string()).unwrap_or("opaque")
        val alpha_cutoff = obj.get("alpha_cutoff").and_then(|v| v.as_f32()).unwrap_or(0.5)

        return Ok(SdnMaterial {
            name: name,
            base_color: base_color,
            metallic: metallic,
            roughness: roughness,
            emissive: emissive,
            albedo_map: albedo_map,
            metallic_roughness_map: metallic_roughness_map,
            normal_map: normal_map,
            ao_map: ao_map,
            emissive_map: emissive_map,
            double_sided: double_sided,
            alpha_mode: alpha_mode,
            alpha_cutoff: alpha_cutoff
        })

# =============================================================================
# Skybox Parsing
# =============================================================================

impl SdnSceneLoader:
    fn parse_skybox(sdn: SdnValue) -> Result[SdnSkybox, String]:
        val obj = sdn.as_object().ok_or("skybox must be an object")?

        val type_name = obj.get("type").and_then(|v| v.as_string()).unwrap_or("color")

        val cubemap_path = obj.get("cubemap").and_then(|v| v.as_string())
        val color = parse_vec3(obj.get("color"), Vec3::new(0.5, 0.7, 1.0))
        val horizon_color = parse_vec3(obj.get("horizon_color"), Vec3::new(0.8, 0.8, 0.9))
        val zenith_color = parse_vec3(obj.get("zenith_color"), Vec3::new(0.3, 0.5, 0.9))
        val ground_color = parse_vec3(obj.get("ground_color"), Vec3::new(0.3, 0.25, 0.2))

        return Ok(SdnSkybox {
            type_name: type_name,
            cubemap_path: cubemap_path,
            color: color,
            horizon_color: horizon_color,
            zenith_color: zenith_color,
            ground_color: ground_color
        })

# =============================================================================
# Helper Parsing Functions
# =============================================================================

fn parse_vec3(sdn_opt: Option[SdnValue], default: Vec3) -> Vec3:
    match sdn_opt:
        case Some(sdn):
            # Try array form: [x, y, z]
            if val Some(arr) = sdn.as_array():
                if arr.len() >= 3:
                    return Vec3::new(
                        arr[0].as_f32().unwrap_or(default.x),
                        arr[1].as_f32().unwrap_or(default.y),
                        arr[2].as_f32().unwrap_or(default.z)
                    )
            # Try object form: {x: 1, y: 2, z: 3}
            if val Some(obj) = sdn.as_object():
                return Vec3::new(
                    obj.get("x").and_then(|v| v.as_f32()).unwrap_or(default.x),
                    obj.get("y").and_then(|v| v.as_f32()).unwrap_or(default.y),
                    obj.get("z").and_then(|v| v.as_f32()).unwrap_or(default.z)
                )
        case None:
            pass
    return default

fn parse_vec4(sdn_opt: Option[SdnValue], default: Vec4) -> Vec4:
    match sdn_opt:
        case Some(sdn):
            # Try array form: [x, y, z, w]
            if val Some(arr) = sdn.as_array():
                if arr.len() >= 4:
                    return Vec4::new(
                        arr[0].as_f32().unwrap_or(default.x),
                        arr[1].as_f32().unwrap_or(default.y),
                        arr[2].as_f32().unwrap_or(default.z),
                        arr[3].as_f32().unwrap_or(default.w)
                    )
            # Try object form: {r: 1, g: 1, b: 1, a: 1}
            if val Some(obj) = sdn.as_object():
                return Vec4::new(
                    obj.get("r").or(obj.get("x")).and_then(|v| v.as_f32()).unwrap_or(default.x),
                    obj.get("g").or(obj.get("y")).and_then(|v| v.as_f32()).unwrap_or(default.y),
                    obj.get("b").or(obj.get("z")).and_then(|v| v.as_f32()).unwrap_or(default.z),
                    obj.get("a").or(obj.get("w")).and_then(|v| v.as_f32()).unwrap_or(default.w)
                )
        case None:
            pass
    return default

# =============================================================================
# External FFI Functions
# =============================================================================

# SDN value type (from SDN parser)
extern type SdnValue

# SDN parser
extern fn sdn_parse(contents: String) -> Option[SdnValue]
extern fn file_read_string(path: String) -> Result[String, String]
