# File System Unit Types
# Cross-platform file path handling with mingw-style drive letter support

# FilePath - platform-aware file path
# Supports both Unix (/path/to/file) and Windows (C:/path/to/file) paths
unit FilePath: str as file

# FilePath components
unit FileName: str as filename
unit FileExt: str as ext
unit DirPath: str as dir

# Drive letter for Windows (optional, e.g., "C", "D")
unit DriveLetter: str as drive

# File permissions (Unix-style octal)
unit FileMode: u32 as mode

# Error type for path operations
enum PathError:
    InvalidPath
    InvalidCharacter
    PathTooLong
    EmptyPath
    InvalidDriveLetter

impl PathError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string(self) -> String:
        """Convert error to string."""
        match self:
            case InvalidPath: return "InvalidPath"
            case InvalidCharacter: return "InvalidCharacter"
            case PathTooLong: return "PathTooLong"
            case EmptyPath: return "EmptyPath"
            case InvalidDriveLetter: return "InvalidDriveLetter"

    fn description(self) -> String:
        """Get detailed error description."""
        match self:
            case InvalidPath: return "Invalid file path format"
            case InvalidCharacter: return "Path contains invalid characters"
            case PathTooLong: return "Path exceeds maximum length"
            case EmptyPath: return "Path cannot be empty"
            case InvalidDriveLetter: return "Invalid Windows drive letter"

    fn is_invalid_path(self) -> bool:
        """Check if this is InvalidPath error."""
        match self:
            case InvalidPath: true
            case _: false

    fn is_invalid_character(self) -> bool:
        """Check if this is InvalidCharacter error."""
        match self:
            case InvalidCharacter: true
            case _: false

    fn is_path_too_long(self) -> bool:
        """Check if this is PathTooLong error."""
        match self:
            case PathTooLong: true
            case _: false

    fn is_empty_path(self) -> bool:
        """Check if this is EmptyPath error."""
        match self:
            case EmptyPath: true
            case _: false

    fn is_invalid_drive_letter(self) -> bool:
        """Check if this is InvalidDriveLetter error."""
        match self:
            case InvalidDriveLetter: true
            case _: false

# FilePath implementation
impl FilePath:
    # Construction
    fn from_str(s: str) -> Result[FilePath, PathError]:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        return Ok(s_file)

    fn from_parts(dir: DirPath, name: FileName, ext: Option[FileExt]) -> FilePath:
        let base = (dir as str) + "/" + (name as str)
        match ext:
            case Some(e): return (base + "." + (e as str))_file
            case None: return base_file

    # Components extraction
    fn dir(self) -> Option[DirPath]:
        let s = self as str
        let last_sep = s.rfind("/")
        match last_sep:
            case Some(idx):
                if idx == 0:
                    return Some("/"_dir)
                return Some(s.slice(0, idx)_dir)
            case None:
                return None

    fn file_name(self) -> Option[FileName]:
        let s = self as str
        let last_sep = s.rfind("/")
        match last_sep:
            case Some(idx):
                let name = s.slice(idx + 1, s.len())
                if name.is_empty():
                    return None
                return Some(name_filename)
            case None:
                return Some(s_filename)

    fn extension(self) -> Option[FileExt]:
        let s = self as str
        let last_dot = s.rfind(".")
        let last_sep = s.rfind("/")
        match last_dot:
            case Some(dot_idx):
                # Ensure dot is after last separator
                match last_sep:
                    case Some(sep_idx):
                        if dot_idx > sep_idx:
                            return Some(s.slice(dot_idx + 1, s.len())_ext)
                        return None
                    case None:
                        return Some(s.slice(dot_idx + 1, s.len())_ext)
            case None:
                return None

    fn drive(self) -> Option[DriveLetter]:
        # Check for mingw-style drive letter: C:/path
        let s = self as str
        if s.len() >= 2:
            let first = s.char_at(0)
            let second = s.char_at(1)
            if second == ':' and ((first >= 'A' and first <= 'Z') or (first >= 'a' and first <= 'z')):
                return Some(s.slice(0, 1).to_upper()_drive)
        return None

    # Operations
    fn join(self, child: FilePath) -> FilePath:
        let parent = self as str
        let child_str = child as str

        # Handle absolute child path
        if child_str.starts_with("/") or (child_str.len() >= 2 and child_str.char_at(1) == ':'):
            return child

        # Join with separator
        if parent.ends_with("/"):
            return (parent + child_str)_file
        return (parent + "/" + child_str)_file

    fn parent(self) -> Option[FilePath]:
        match self.dir():
            case Some(d): return Some((d as str)_file)
            case None: return None

    fn with_extension(self, ext: FileExt) -> FilePath:
        let s = self as str
        let current_ext = self.extension()
        match current_ext:
            case Some(e):
                let dot_pos = s.len() - (e as str).len() - 1
                return (s.slice(0, dot_pos) + "." + (ext as str))_file
            case None:
                return (s + "." + (ext as str))_file

    # Normalization
    fn normalize(self) -> FilePath:
        """Normalize path by resolving . and .. components.

        Example:
            "/foo/./bar/../baz".normalize() -> "/foo/baz"
            "C:/foo/../bar/.".normalize() -> "C:/bar"
        """
        let s = self as str

        # Preserve drive letter if present
        let mut drive_prefix = ""
        let mut path_to_normalize = s
        if self.has_drive():
            drive_prefix = s.slice(0, 2)  # "C:"
            path_to_normalize = s.slice(2, s.len())  # Rest after "C:"

        # Check if absolute path
        let is_abs = path_to_normalize.starts_with("/")

        # Split into components
        let components = path_to_normalize.split("/")
        let mut stack: List[str] = []

        # Process each component
        for component in components:
            if component == "" or component == ".":
                # Skip empty and current directory references
                continue
            elif component == "..":
                # Go up one directory (pop from stack)
                if not stack.is_empty():
                    stack.pop()
            else:
                # Normal component - add to stack
                stack.push(component)

        # Reconstruct path
        let mut result = drive_prefix
        if is_abs:
            result = result + "/"

        # Join components
        let mut first = true
        for comp in stack:
            if not first:
                result = result + "/"
            result = result + comp
            first = false

        # Handle edge case: if path is just "/" or "C:/"
        if result == drive_prefix and is_abs:
            result = result + "/"

        # Handle edge case: if path is empty after normalization
        if result.is_empty():
            result = "."

        return result_file

    fn is_absolute(self) -> bool:
        let s = self as str
        # Unix absolute path
        if s.starts_with("/"):
            return true
        # Windows absolute path (C:/)
        if s.len() >= 3 and s.char_at(1) == ':' and s.char_at(2) == '/':
            return true
        return false

    # Platform conversion
    fn to_native(self) -> str:
        # Returns platform-native format
        # On Windows: backslashes, on Unix: forward slashes
        # For now, return as-is (mingw style works everywhere)
        return self as str

    fn to_posix(self) -> str:
        # Convert to POSIX style (forward slashes, /c/path for drives)
        let s = self as str
        match self.drive():
            case Some(d):
                let rest = s.slice(2, s.len())
                return "/" + (d as str).to_lower() + rest
            case None:
                return s

    fn to_mingw(self) -> str:
        # Return mingw style (C:/path)
        return self as str

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> bool:
        """Check if path is empty."""
        return (self as str).is_empty()

    fn is_relative(self) -> bool:
        """Check if path is relative (not absolute)."""
        return not self.is_absolute()

    fn has_drive(self) -> bool:
        """Check if path has a Windows drive letter."""
        return self.drive().is_some()

    fn has_extension(self) -> bool:
        """Check if path has a file extension."""
        return self.extension().is_some()

    fn has_parent(self) -> bool:
        """Check if path has a parent directory."""
        return self.parent().is_some()

    fn is_windows_style(self) -> bool:
        """Check if path uses Windows drive letter (C:/ style)."""
        return self.has_drive()

    fn is_unix_style(self) -> bool:
        """Check if path is Unix-style (starts with / and no drive)."""
        let s = self as str
        return s.starts_with("/") and not self.has_drive()

    fn component_count(self) -> Int:
        """Count path components (separated by /)."""
        let s = self as str
        if s.is_empty():
            return 0
        return s.split("/").len()

    fn ends_with_separator(self) -> bool:
        """Check if path ends with a separator (/)."""
        return (self as str).ends_with("/")

    fn summary(self) -> String:
        """Get summary of file path."""
        let s = self as str
        let abs = if self.is_absolute(): "absolute" else: "relative"
        let ext = match self.extension():
            case Some(e): "." + (e as str)
            case None: "no ext"
        return "FilePath: {s} ({abs}, {ext})"

# DirPath implementation
impl DirPath:
    fn from_str(s: str) -> Result[DirPath, PathError]:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        return Ok(s_dir)

    fn join(self, child: DirPath) -> DirPath:
        let parent = self as str
        let child_str = child as str
        if parent.ends_with("/"):
            return (parent + child_str)_dir
        return (parent + "/" + child_str)_dir

    fn to_file_path(self) -> FilePath:
        return (self as str)_file

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> bool:
        """Check if directory path is empty."""
        return (self as str).is_empty()

    fn is_root(self) -> bool:
        """Check if this is a root directory (/ or C:/)."""
        let s = self as str
        if s == "/":
            return true
        # Windows root: C:/
        if s.len() == 3 and s.char_at(1) == ':' and s.char_at(2) == '/':
            return true
        return false

    fn ends_with_separator(self) -> bool:
        """Check if directory path ends with separator."""
        return (self as str).ends_with("/")

    fn component_count(self) -> Int:
        """Count directory components."""
        let s = self as str
        if s.is_empty():
            return 0
        return s.split("/").len()

    fn summary(self) -> String:
        """Get summary of directory path."""
        let s = self as str
        let root = if self.is_root(): "root" else: "subdir"
        return "DirPath: {s} ({root})"

# FileName implementation
impl FileName:
    fn from_str(s: str) -> Result[FileName, PathError]:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        if s.contains("/") or s.contains("\\"):
            return Err(PathError::InvalidCharacter)
        return Ok(s_filename)

    fn with_extension(self, ext: FileExt) -> FileName:
        return ((self as str) + "." + (ext as str))_filename

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> bool:
        """Check if file name is empty."""
        return (self as str).is_empty()

    fn has_extension(self) -> bool:
        """Check if file name has an extension."""
        return (self as str).contains(".")

    fn is_hidden(self) -> bool:
        """Check if file name starts with . (Unix hidden file)."""
        let s = self as str
        return s.starts_with(".") and s.len() > 1

    fn is_valid(self) -> bool:
        """Check if file name is valid (no path separators)."""
        let s = self as str
        return not s.contains("/") and not s.contains("\\") and not s.is_empty()

    fn summary(self) -> String:
        """Get summary of file name."""
        let s = self as str
        let hidden = if self.is_hidden(): "hidden" else: "visible"
        let ext = if self.has_extension(): "with ext" else: "no ext"
        return "FileName: {s} ({hidden}, {ext})"

# FileExt implementation
impl FileExt:
    fn from_str(s: str) -> Result[FileExt, PathError]:
        if s.is_empty():
            return Err(PathError::EmptyPath)
        if s.contains("."):
            return Err(PathError::InvalidCharacter)
        return Ok(s_ext)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> bool:
        """Check if extension is empty."""
        return (self as str).is_empty()

    fn is_valid(self) -> bool:
        """Check if extension is valid (no dots or path separators)."""
        let s = self as str
        return not s.contains(".") and not s.contains("/") and not s.contains("\\") and not s.is_empty()

    fn is_common_text(self) -> bool:
        """Check if this is a common text file extension."""
        let s = (self as str).to_lower()
        return s == "txt" or s == "md" or s == "rst" or s == "log" or s == "csv"

    fn is_common_code(self) -> bool:
        """Check if this is a common code file extension."""
        let s = (self as str).to_lower()
        return s == "spl" or s == "rs" or s == "py" or s == "js" or s == "c" or s == "cpp" or s == "h" or s == "hpp"

    fn is_common_archive(self) -> bool:
        """Check if this is a common archive extension."""
        let s = (self as str).to_lower()
        return s == "zip" or s == "tar" or s == "gz" or s == "bz2" or s == "xz" or s == "7z"

    fn summary(self) -> String:
        """Get summary of file extension."""
        let s = self as str
        return "FileExt: .{s}"

# FileMode implementation (Unix permissions)
impl FileMode:
    fn readable() -> FileMode:
        return 0o644_mode

    fn executable() -> FileMode:
        return 0o755_mode

    fn readonly() -> FileMode:
        return 0o444_mode

    fn is_readable(self) -> bool:
        return ((self as u32) & 0o400) != 0

    fn is_writable(self) -> bool:
        return ((self as u32) & 0o200) != 0

    fn is_executable(self) -> bool:
        return ((self as u32) & 0o100) != 0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_read_only(self) -> bool:
        """Check if mode is read-only (not writable)."""
        return not self.is_writable()

    fn is_owner_readable(self) -> bool:
        """Check if owner has read permission."""
        return ((self as u32) & 0o400) != 0

    fn is_owner_writable(self) -> bool:
        """Check if owner has write permission."""
        return ((self as u32) & 0o200) != 0

    fn is_owner_executable(self) -> bool:
        """Check if owner has execute permission."""
        return ((self as u32) & 0o100) != 0

    fn is_group_readable(self) -> bool:
        """Check if group has read permission."""
        return ((self as u32) & 0o040) != 0

    fn is_group_writable(self) -> bool:
        """Check if group has write permission."""
        return ((self as u32) & 0o020) != 0

    fn is_group_executable(self) -> bool:
        """Check if group has execute permission."""
        return ((self as u32) & 0o010) != 0

    fn is_other_readable(self) -> bool:
        """Check if others have read permission."""
        return ((self as u32) & 0o004) != 0

    fn is_other_writable(self) -> bool:
        """Check if others have write permission."""
        return ((self as u32) & 0o002) != 0

    fn is_other_executable(self) -> bool:
        """Check if others have execute permission."""
        return ((self as u32) & 0o001) != 0

    fn to_octal_string(self) -> String:
        """Convert mode to octal string (e.g., '0755')."""
        let mode = self as u32
        return "0{mode:o}"

    fn summary(self) -> String:
        """Get summary of file mode."""
        let r = if self.is_readable(): "r" else: "-"
        let w = if self.is_writable(): "w" else: "-"
        let x = if self.is_executable(): "x" else: "-"
        return "FileMode: {self.to_octal_string()} ({r}{w}{x})"

# DriveLetter implementation
impl DriveLetter:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn from_char(c: char) -> Result[DriveLetter, PathError]:
        """Create drive letter from character (A-Z, case-insensitive)."""
        if (c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z'):
            return Ok(c.to_upper()_drive)
        return Err(PathError::InvalidDriveLetter)

    fn is_valid(self) -> bool:
        """Check if drive letter is valid (A-Z)."""
        let s = self as str
        if s.len() != 1:
            return false
        let c = s.char_at(0)
        return c >= 'A' and c <= 'Z'

    fn to_upper(self) -> DriveLetter:
        """Convert drive letter to uppercase."""
        return (self as str).to_upper()_drive

    fn to_lower(self) -> DriveLetter:
        """Convert drive letter to lowercase."""
        return (self as str).to_lower()_drive

    fn to_char(self) -> char:
        """Get drive letter as character."""
        return (self as str).char_at(0)

    fn summary(self) -> String:
        """Get summary of drive letter."""
        let s = self as str
        return "DriveLetter: {s}:"
