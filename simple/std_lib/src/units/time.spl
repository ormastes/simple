# Time Unit Types
# Duration and time-related units

# Duration in nanoseconds (base unit)
unit Duration: u64 as dur

# Time duration units
unit Nanoseconds: u64 as ns
unit Microseconds: u64 as us
unit Milliseconds: u64 as ms
unit Seconds: u64 as s
unit Minutes: u64 as min
unit Hours: u64 as hr
unit Days: u64 as day

# Unit family for automatic conversion
unit family TimeDuration: u64 as ns
    Nanoseconds = 1
    Microseconds = 1_000
    Milliseconds = 1_000_000
    Seconds = 1_000_000_000
    Minutes = 60_000_000_000
    Hours = 3_600_000_000_000
    Days = 86_400_000_000_000

# Constants
const NS_PER_US: u64 = 1_000
const NS_PER_MS: u64 = 1_000_000
const NS_PER_S: u64 = 1_000_000_000
const NS_PER_MIN: u64 = 60_000_000_000
const NS_PER_HR: u64 = 3_600_000_000_000
const NS_PER_DAY: u64 = 86_400_000_000_000

const MS_PER_S: u64 = 1_000
const S_PER_MIN: u64 = 60
const MIN_PER_HR: u64 = 60
const HR_PER_DAY: u64 = 24

# Duration implementation
impl Duration:
    fn from_nanos(ns: u64) -> Duration:
        return ns_dur

    fn from_micros(us: u64) -> Duration:
        return (us * NS_PER_US)_dur

    fn from_millis(ms: u64) -> Duration:
        return (ms * NS_PER_MS)_dur

    fn from_secs(s: u64) -> Duration:
        return (s * NS_PER_S)_dur

    fn from_mins(m: u64) -> Duration:
        return (m * NS_PER_MIN)_dur

    fn from_hours(h: u64) -> Duration:
        return (h * NS_PER_HR)_dur

    fn from_days(d: u64) -> Duration:
        return (d * NS_PER_DAY)_dur

    fn zero() -> Duration:
        return 0_dur

    # Conversions
    fn as_nanos(self) -> u64:
        return self as u64

    fn as_micros(self) -> u64:
        return (self as u64) / NS_PER_US

    fn as_millis(self) -> u64:
        return (self as u64) / NS_PER_MS

    fn as_secs(self) -> u64:
        return (self as u64) / NS_PER_S

    fn as_mins(self) -> u64:
        return (self as u64) / NS_PER_MIN

    fn as_hours(self) -> u64:
        return (self as u64) / NS_PER_HR

    fn as_days(self) -> u64:
        return (self as u64) / NS_PER_DAY

    # Float conversions (for precision)
    fn as_secs_f64(self) -> f64:
        return (self as u64) as f64 / NS_PER_S as f64

    fn as_millis_f64(self) -> f64:
        return (self as u64) as f64 / NS_PER_MS as f64

    # Arithmetic
    fn add(self, other: Duration) -> Duration:
        return ((self as u64) + (other as u64))_dur

    fn sub(self, other: Duration) -> Duration:
        let a = self as u64
        let b = other as u64
        if b > a:
            return 0_dur
        return (a - b)_dur

    fn mul(self, n: u64) -> Duration:
        return ((self as u64) * n)_dur

    fn div(self, n: u64) -> Duration:
        if n == 0:
            return 0_dur
        return ((self as u64) / n)_dur

    # Comparison
    fn is_zero(self) -> bool:
        return (self as u64) == 0

    fn min(self, other: Duration) -> Duration:
        if (self as u64) < (other as u64):
            return self
        return other

    fn max(self, other: Duration) -> Duration:
        if (self as u64) > (other as u64):
            return self
        return other

    # Formatting
    fn to_human_readable(self) -> str:
        let ns = self as u64

        if ns >= NS_PER_DAY:
            let days = ns / NS_PER_DAY
            let remaining = ns % NS_PER_DAY
            if remaining > 0:
                let hours = remaining / NS_PER_HR
                return "{days}d {hours}h"
            return "{days}d"

        if ns >= NS_PER_HR:
            let hours = ns / NS_PER_HR
            let remaining = ns % NS_PER_HR
            if remaining > 0:
                let mins = remaining / NS_PER_MIN
                return "{hours}h {mins}m"
            return "{hours}h"

        if ns >= NS_PER_MIN:
            let mins = ns / NS_PER_MIN
            let remaining = ns % NS_PER_MIN
            if remaining > 0:
                let secs = remaining / NS_PER_S
                return "{mins}m {secs}s"
            return "{mins}m"

        if ns >= NS_PER_S:
            let secs = ns / NS_PER_S
            let remaining = ns % NS_PER_S
            if remaining > 0:
                let ms = remaining / NS_PER_MS
                return "{secs}.{ms:03}s"
            return "{secs}s"

        if ns >= NS_PER_MS:
            let ms = ns / NS_PER_MS
            return "{ms}ms"

        if ns >= NS_PER_US:
            let us = ns / NS_PER_US
            return "{us}us"

        return "{ns}ns"

# Nanoseconds implementation
impl Nanoseconds:
    fn to_duration(self) -> Duration:
        return (self as u64)_dur

    fn to_micros(self) -> Microseconds:
        return ((self as u64) / NS_PER_US)_us

# Microseconds implementation
impl Microseconds:
    fn to_duration(self) -> Duration:
        return ((self as u64) * NS_PER_US)_dur

    fn to_nanos(self) -> Nanoseconds:
        return ((self as u64) * NS_PER_US)_ns

    fn to_millis(self) -> Milliseconds:
        return ((self as u64) / MS_PER_S)_ms

# Milliseconds implementation
impl Milliseconds:
    fn to_duration(self) -> Duration:
        return ((self as u64) * NS_PER_MS)_dur

    fn to_micros(self) -> Microseconds:
        return ((self as u64) * MS_PER_S)_us

    fn to_secs(self) -> Seconds:
        return ((self as u64) / MS_PER_S)_s

# Seconds implementation
impl Seconds:
    fn to_duration(self) -> Duration:
        return ((self as u64) * NS_PER_S)_dur

    fn to_millis(self) -> Milliseconds:
        return ((self as u64) * MS_PER_S)_ms

    fn to_mins(self) -> Minutes:
        return ((self as u64) / S_PER_MIN)_min

# Minutes implementation
impl Minutes:
    fn to_duration(self) -> Duration:
        return ((self as u64) * NS_PER_MIN)_dur

    fn to_secs(self) -> Seconds:
        return ((self as u64) * S_PER_MIN)_s

    fn to_hours(self) -> Hours:
        return ((self as u64) / MIN_PER_HR)_hr

# Hours implementation
impl Hours:
    fn to_duration(self) -> Duration:
        return ((self as u64) * NS_PER_HR)_dur

    fn to_mins(self) -> Minutes:
        return ((self as u64) * MIN_PER_HR)_min

    fn to_days(self) -> Days:
        return ((self as u64) / HR_PER_DAY)_day

# Days implementation
impl Days:
    fn to_duration(self) -> Duration:
        return ((self as u64) * NS_PER_DAY)_dur

    fn to_hours(self) -> Hours:
        return ((self as u64) * HR_PER_DAY)_hr

# Timeout type (for async operations)
unit Timeout: u64 as timeout

impl Timeout:
    fn from_duration(d: Duration) -> Timeout:
        return (d as u64)_timeout

    fn from_millis(ms: u64) -> Timeout:
        return (ms * NS_PER_MS)_timeout

    fn from_secs(s: u64) -> Timeout:
        return (s * NS_PER_S)_timeout

    fn infinite() -> Timeout:
        return 0xFFFFFFFFFFFFFFFF_timeout

    fn is_infinite(self) -> bool:
        return (self as u64) == 0xFFFFFFFFFFFFFFFF

    fn to_duration(self) -> Duration:
        return (self as u64)_dur

# Utility function for parsing duration strings
fn parse_duration(s: str) -> Result[Duration, TimeError]:
    let s = s.trim().to_lower()

    let mut num_end = 0
    for i in 0..s.len():
        let c = s.char_at(i)
        if c.is_digit() or c == '.':
            num_end = i + 1
        else:
            break

    if num_end == 0:
        return Err(TimeError::InvalidFormat)

    let num_str = s.slice(0, num_end)
    let unit = s.slice(num_end, s.len()).trim()

    let num = match num_str.parse_u64():
        case Ok(n): n
        case Err(_): return Err(TimeError::InvalidNumber)

    match unit:
        case "ns" | "nanosecond" | "nanoseconds":
            return Ok(num_dur)
        case "us" | "microsecond" | "microseconds":
            return Ok((num * NS_PER_US)_dur)
        case "ms" | "millisecond" | "milliseconds":
            return Ok((num * NS_PER_MS)_dur)
        case "s" | "sec" | "second" | "seconds":
            return Ok((num * NS_PER_S)_dur)
        case "m" | "min" | "minute" | "minutes":
            return Ok((num * NS_PER_MIN)_dur)
        case "h" | "hr" | "hour" | "hours":
            return Ok((num * NS_PER_HR)_dur)
        case "d" | "day" | "days":
            return Ok((num * NS_PER_DAY)_dur)
        case _:
            return Err(TimeError::InvalidUnit)

enum TimeError:
    InvalidFormat
    InvalidNumber
    InvalidUnit
    Overflow

impl TimeError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string(self) -> String:
        """Convert error to string."""
        match self:
            case InvalidFormat: return "InvalidFormat"
            case InvalidNumber: return "InvalidNumber"
            case InvalidUnit: return "InvalidUnit"
            case Overflow: return "Overflow"

    fn description(self) -> String:
        """Get detailed error description."""
        match self:
            case InvalidFormat: return "Invalid time duration format"
            case InvalidNumber: return "Invalid number in duration string"
            case InvalidUnit: return "Invalid or unknown time unit"
            case Overflow: return "Duration value overflow"

    fn is_invalid_format(self) -> bool:
        """Check if this is InvalidFormat error."""
        match self:
            case InvalidFormat: true
            case _: false

    fn is_invalid_number(self) -> bool:
        """Check if this is InvalidNumber error."""
        match self:
            case InvalidNumber: true
            case _: false

    fn is_invalid_unit(self) -> bool:
        """Check if this is InvalidUnit error."""
        match self:
            case InvalidUnit: true
            case _: false

    fn is_overflow(self) -> bool:
        """Check if this is Overflow error."""
        match self:
            case Overflow: true
            case _: false
