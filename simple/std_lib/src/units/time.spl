# Time Unit Types
# Duration and time-related units

# Duration in nanoseconds (base unit)
unit Duration: u64 as dur

# Time duration units
unit Nanoseconds: u64 as ns
unit Microseconds: u64 as us
unit Milliseconds: u64 as ms
unit Seconds: u64 as s
unit Minutes: u64 as min
unit Hours: u64 as hr
unit Days: u64 as day

# Unit family for automatic conversion
unit family TimeDuration: u64 as ns
    Nanoseconds = 1
    Microseconds = 1_000
    Milliseconds = 1_000_000
    Seconds = 1_000_000_000
    Minutes = 60_000_000_000
    Hours = 3_600_000_000_000
    Days = 86_400_000_000_000

# Constants
const NS_PER_US: u64 = 1_000
const NS_PER_MS: u64 = 1_000_000
const NS_PER_S: u64 = 1_000_000_000
const NS_PER_MIN: u64 = 60_000_000_000
const NS_PER_HR: u64 = 3_600_000_000_000
const NS_PER_DAY: u64 = 86_400_000_000_000

const MS_PER_S: u64 = 1_000
const S_PER_MIN: u64 = 60
const MIN_PER_HR: u64 = 60
const HR_PER_DAY: u64 = 24

# Duration implementation
impl Duration:
    fn from_nanos(ns: u64) -> Duration:
        return ns_dur

    fn from_micros(us: u64) -> Duration:
        return (us * NS_PER_US)_dur

    fn from_millis(ms: u64) -> Duration:
        return (ms * NS_PER_MS)_dur

    fn from_secs(s: u64) -> Duration:
        return (s * NS_PER_S)_dur

    fn from_mins(m: u64) -> Duration:
        return (m * NS_PER_MIN)_dur

    fn from_hours(h: u64) -> Duration:
        return (h * NS_PER_HR)_dur

    fn from_days(d: u64) -> Duration:
        return (d * NS_PER_DAY)_dur

    fn zero() -> Duration:
        return 0_dur

    # Conversions
    fn as_nanos() -> u64:
        return self as u64

    fn as_micros() -> u64:
        return (self as u64) / NS_PER_US

    fn as_millis() -> u64:
        return (self as u64) / NS_PER_MS

    fn as_secs() -> u64:
        return (self as u64) / NS_PER_S

    fn as_mins() -> u64:
        return (self as u64) / NS_PER_MIN

    fn as_hours() -> u64:
        return (self as u64) / NS_PER_HR

    fn as_days() -> u64:
        return (self as u64) / NS_PER_DAY

    # f32 conversions (for precision)
    fn as_secs_f64() -> f64:
        return (self as u64) as f64 / NS_PER_S as f64

    fn as_millis_f64() -> f64:
        return (self as u64) as f64 / NS_PER_MS as f64

    # Arithmetic
    fn add(other: Duration) -> Duration:
        return ((self as u64) + (other as u64))_dur

    fn sub(other: Duration) -> Duration:
        val a = self as u64
        val b = other as u64
        if b > a:
            return 0_dur
        return (a - b)_dur

    fn mul(n: u64) -> Duration:
        return ((self as u64) * n)_dur

    fn div(n: u64) -> Duration:
        if n == 0:
            return 0_dur
        return ((self as u64) / n)_dur

    # Comparison
    fn is_zero() -> bool:
        return (self as u64) == 0

    fn min(other: Duration) -> Duration:
        if (self as u64) < (other as u64):
            return self
        return other

    fn max(other: Duration) -> Duration:
        if (self as u64) > (other as u64):
            return self
        return other

    # Formatting
    fn to_human_readable() -> str:
        val ns = self as u64

        if ns >= NS_PER_DAY:
            val days = ns / NS_PER_DAY
            val remaining = ns % NS_PER_DAY
            if remaining > 0:
                val hours = remaining / NS_PER_HR
                return "{days}d {hours}h"
            return "{days}d"

        if ns >= NS_PER_HR:
            val hours = ns / NS_PER_HR
            val remaining = ns % NS_PER_HR
            if remaining > 0:
                val mins = remaining / NS_PER_MIN
                return "{hours}h {mins}m"
            return "{hours}h"

        if ns >= NS_PER_MIN:
            val mins = ns / NS_PER_MIN
            val remaining = ns % NS_PER_MIN
            if remaining > 0:
                val secs = remaining / NS_PER_S
                return "{mins}m {secs}s"
            return "{mins}m"

        if ns >= NS_PER_S:
            val secs = ns / NS_PER_S
            val remaining = ns % NS_PER_S
            if remaining > 0:
                val ms = remaining / NS_PER_MS
                return "{secs}.{ms:03}s"
            return "{secs}s"

        if ns >= NS_PER_MS:
            val ms = ns / NS_PER_MS
            return "{ms}ms"

        if ns >= NS_PER_US:
            val us = ns / NS_PER_US
            return "{us}us"

        return "{ns}ns"

# Nanoseconds implementation
impl Nanoseconds:
    fn to_duration() -> Duration:
        return (self as u64)_dur

    fn to_micros() -> Microseconds:
        return ((self as u64) / NS_PER_US)_us

# Microseconds implementation
impl Microseconds:
    fn to_duration() -> Duration:
        return ((self as u64) * NS_PER_US)_dur

    fn to_nanos() -> Nanoseconds:
        return ((self as u64) * NS_PER_US)_ns

    fn to_millis() -> Milliseconds:
        return ((self as u64) / MS_PER_S)_ms

# Milliseconds implementation
impl Milliseconds:
    fn to_duration() -> Duration:
        return ((self as u64) * NS_PER_MS)_dur

    fn to_micros() -> Microseconds:
        return ((self as u64) * MS_PER_S)_us

    fn to_secs() -> Seconds:
        return ((self as u64) / MS_PER_S)_s

# Seconds implementation
impl Seconds:
    fn to_duration() -> Duration:
        return ((self as u64) * NS_PER_S)_dur

    fn to_millis() -> Milliseconds:
        return ((self as u64) * MS_PER_S)_ms

    fn to_mins() -> Minutes:
        return ((self as u64) / S_PER_MIN)_min

# Minutes implementation
impl Minutes:
    fn to_duration() -> Duration:
        return ((self as u64) * NS_PER_MIN)_dur

    fn to_secs() -> Seconds:
        return ((self as u64) * S_PER_MIN)_s

    fn to_hours() -> Hours:
        return ((self as u64) / MIN_PER_HR)_hr

# Hours implementation
impl Hours:
    fn to_duration() -> Duration:
        return ((self as u64) * NS_PER_HR)_dur

    fn to_mins() -> Minutes:
        return ((self as u64) * MIN_PER_HR)_min

    fn to_days() -> Days:
        return ((self as u64) / HR_PER_DAY)_day

# Days implementation
impl Days:
    fn to_duration() -> Duration:
        return ((self as u64) * NS_PER_DAY)_dur

    fn to_hours() -> Hours:
        return ((self as u64) * HR_PER_DAY)_hr

# Timeout type (for async operations)
unit Timeout: u64 as timeout

impl Timeout:
    fn from_duration(d: Duration) -> Timeout:
        return (d as u64)_timeout

    fn from_millis(ms: u64) -> Timeout:
        return (ms * NS_PER_MS)_timeout

    fn from_secs(s: u64) -> Timeout:
        return (s * NS_PER_S)_timeout

    fn infinite() -> Timeout:
        return 0xFFFFFFFFFFFFFFFF_timeout

    fn is_infinite() -> bool:
        return (self as u64) == 0xFFFFFFFFFFFFFFFF

    fn to_duration() -> Duration:
        return (self as u64)_dur

# Utility function for parsing duration strings
fn parse_duration(s: str) -> Result<Duration, TimeError>:
    val s = s.trim().to_lower()

    var num_end = 0
    for i in 0..s.len():
        val c = s.char_at(i)
        if c.is_digit() or c == '.':
            num_end = i + 1
        else:
            break

    if num_end == 0:
        return Err(TimeError::InvalidFormat)

    val num_str = s.slice(0, num_end)
    val unit = s.slice(num_end, s.len()).trim()

    val num = match num_str.parse_u64():
        case Ok(n): n
        case Err(_): return Err(TimeError::InvalidNumber)

    match unit:
        case "ns" | "nanosecond" | "nanoseconds":
            return Ok(num_dur)
        case "us" | "microsecond" | "microseconds":
            return Ok((num * NS_PER_US)_dur)
        case "ms" | "millisecond" | "milliseconds":
            return Ok((num * NS_PER_MS)_dur)
        case "s" | "sec" | "second" | "seconds":
            return Ok((num * NS_PER_S)_dur)
        case "m" | "min" | "minute" | "minutes":
            return Ok((num * NS_PER_MIN)_dur)
        case "h" | "hr" | "hour" | "hours":
            return Ok((num * NS_PER_HR)_dur)
        case "d" | "day" | "days":
            return Ok((num * NS_PER_DAY)_dur)
        case _:
            return Err(TimeError::InvalidUnit)

enum TimeError:
    InvalidFormat
    InvalidNumber
    InvalidUnit
    Overflow

impl TimeError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string() -> text:
        """Convert error to string."""
        match self:
            case InvalidFormat: return "InvalidFormat"
            case InvalidNumber: return "InvalidNumber"
            case InvalidUnit: return "InvalidUnit"
            case Overflow: return "Overflow"

    fn description() -> text:
        """Get detailed error description."""
        match self:
            case InvalidFormat: return "Invalid time duration format"
            case InvalidNumber: return "Invalid number in duration string"
            case InvalidUnit: return "Invalid or unknown time unit"
            case Overflow: return "Duration value overflow"

    fn is_invalid_format() -> bool:
        """Check if this is InvalidFormat error."""
        match self:
            case InvalidFormat: true
            case _: false

    fn is_invalid_number() -> bool:
        """Check if this is InvalidNumber error."""
        match self:
            case InvalidNumber: true
            case _: false

    fn is_invalid_unit() -> bool:
        """Check if this is InvalidUnit error."""
        match self:
            case InvalidUnit: true
            case _: false

    fn is_overflow() -> bool:
        """Check if this is Overflow error."""
        match self:
            case Overflow: true
            case _: false

    fn is_parse_error() -> bool:
        """Check if this is a parsing error (format, number, unit).

        Returns:
            true for InvalidFormat, InvalidNumber, or InvalidUnit

        Example:
            TimeError::InvalidFormat.is_parse_error()  # → true
            TimeError::Overflow.is_parse_error()  # → false
        """
        match self:
            case InvalidFormat: true
            case InvalidNumber: true
            case InvalidUnit: true
            case _: false

    fn is_recoverable() -> bool:
        """Check if error might be recoverable with different input.

        Returns:
            true for parsing errors (user can retry with valid input)
            false for Overflow (value exceeds limits)

        Example:
            TimeError::InvalidFormat.is_recoverable()  # → true
            TimeError::Overflow.is_recoverable()  # → false
        """
        return self.is_parse_error()

    fn name() -> text:
        """Get error name without details.

        Returns:
            Short error name

        Example:
            TimeError::InvalidUnit.name()  # → "invalid_unit"
        """
        match self:
            case InvalidFormat: return "invalid_format"
            case InvalidNumber: return "invalid_number"
            case InvalidUnit: return "invalid_unit"
            case Overflow: return "overflow"

    fn summary() -> text:
        """Get comprehensive error summary with type and details.

        Returns:
            Human-readable summary

        Example:
            TimeError::InvalidFormat.summary()
            # → "TimeError: invalid_format (parsing error, recoverable)"
        """
        val name = self.name()
        val desc = self.description()
        val kind = if self.is_parse_error():
            "parsing error"
        else:
            "value error"
        val recoverable = if self.is_recoverable():
            "recoverable"
        else:
            "fatal"
        return "TimeError: {name} ({kind}, {recoverable})"
