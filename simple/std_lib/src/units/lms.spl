# LMS (Language Model System) Unit Types
# Semantic types for LLM interaction and state management

# =============================================================================
# State and Session Units
# =============================================================================

# State identifier (unique ID for conversation state)
unit StateId: i32 as state_id

# Session identifier (unique ID for LLM session)
unit SessionId: i64 as session_id

# Message identifier (unique ID for messages in conversation)
unit MessageId: i64 as msg_id

# Document version number (LSP document versioning)
unit DocumentVersion: i32 as doc_ver

# Token count (number of tokens in text)
unit TokenCount: u64 as tokens

# Error count (number of errors encountered)
unit ErrorCount: u32 as err_count

# Retry attempt number
unit AttemptNumber: u32 as attempt

# StateId implementation
impl StateId:
    pub fn from_i32(n: i32) -> StateId:
        return n_state_id

    pub fn value() -> i32:
        return self as i32

    pub fn invalid() -> StateId:
        """Invalid state ID (-1)."""
        return (-1)_state_id

    pub fn initial() -> StateId:
        """Initial state (0)."""
        return 0_state_id

    pub fn is_valid() -> bool:
        """Check if state ID is valid (>= 0)."""
        return self.value() >= 0

    pub fn is_initial() -> bool:
        """Check if this is the initial state."""
        return self.value() == 0

    pub fn next() -> StateId:
        """Get next state ID."""
        return (self.value() + 1)_state_id

# SessionId implementation
impl SessionId:
    pub fn from_i64(n: i64) -> SessionId:
        return n_session_id

    pub fn value() -> i64:
        return self as i64

    pub fn invalid() -> SessionId:
        """Invalid session ID (-1)."""
        return (-1)_session_id

    pub fn is_valid() -> bool:
        """Check if session ID is valid (>= 0)."""
        return self.value() >= 0

    pub fn from_timestamp(timestamp: u64) -> SessionId:
        """Create session ID from timestamp."""
        return (timestamp as i64)_session_id

# MessageId implementation
impl MessageId:
    pub fn from_i64(n: i64) -> MessageId:
        return n_msg_id

    pub fn value() -> i64:
        return self as i64

    pub fn invalid() -> MessageId:
        """Invalid message ID (-1)."""
        return (-1)_msg_id

    pub fn first() -> MessageId:
        """First message in conversation."""
        return 0_msg_id

    pub fn is_valid() -> bool:
        """Check if message ID is valid (>= 0)."""
        return self.value() >= 0

    pub fn next() -> MessageId:
        """Get next message ID."""
        return (self.value() + 1)_msg_id

    pub fn prev() -> MessageId:
        """Get previous message ID, clamped to 0."""
        val current = self.value()
        if current <= 0:
            return 0_msg_id
        return (current - 1)_msg_id

# DocumentVersion implementation
impl DocumentVersion:
    pub fn from_i32(n: i32) -> DocumentVersion:
        return n_doc_ver

    pub fn value() -> i32:
        return self as i32

    pub fn initial() -> DocumentVersion:
        """Initial document version (0)."""
        return 0_doc_ver

    pub fn increment() -> DocumentVersion:
        """Increment document version."""
        return (self.value() + 1)_doc_ver

    pub fn is_initial() -> bool:
        """Check if this is the initial version."""
        return self.value() == 0

    pub fn is_newer_than(other: DocumentVersion) -> bool:
        """Check if this version is newer than another."""
        return self.value() > other.value()

    pub fn is_older_than(other: DocumentVersion) -> bool:
        """Check if this version is older than another."""
        return self.value() < other.value()

# TokenCount implementation
impl TokenCount:
    pub fn from_u64(n: u64) -> TokenCount:
        return n_tokens

    pub fn value() -> u64:
        return self as u64

    pub fn zero() -> TokenCount:
        return 0_tokens

    pub fn add(other: TokenCount) -> TokenCount:
        """Add two token counts."""
        return (self.value() + other.value())_tokens

    pub fn exceeds(limit: TokenCount) -> bool:
        """Check if token count exceeds limit."""
        return self.value() > limit.value()

    pub fn remaining(limit: TokenCount) -> TokenCount:
        """Calculate remaining tokens before limit."""
        val current = self.value()
        val max = limit.value()
        if current >= max:
            return 0_tokens
        return (max - current)_tokens

    pub fn percentage_of(total: TokenCount) -> f32:
        """Calculate percentage of total tokens used."""
        val total_val = total.value()
        if total_val == 0:
            return 0.0
        return (self.value() as f32) / (total_val as f32) * 100.0

    # Common limits
    pub fn limit_gpt3() -> TokenCount:
        """GPT-3 context limit (4096 tokens)."""
        return 4096_tokens

    pub fn limit_gpt4() -> TokenCount:
        """GPT-4 context limit (8192 tokens)."""
        return 8192_tokens

    pub fn limit_gpt4_32k() -> TokenCount:
        """GPT-4-32k context limit (32768 tokens)."""
        return 32768_tokens

    pub fn limit_claude() -> TokenCount:
        """Claude context limit (100k tokens)."""
        return 100000_tokens

    pub fn limit_claude_extended() -> TokenCount:
        """Claude extended context limit (200k tokens)."""
        return 200000_tokens

# ErrorCount implementation
impl ErrorCount:
    pub fn from_u32(n: u32) -> ErrorCount:
        return n_err_count

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> ErrorCount:
        return 0_err_count

    pub fn increment() -> ErrorCount:
        """Increment error count."""
        return (self.value() + 1)_err_count

    pub fn add(other: ErrorCount) -> ErrorCount:
        """Add two error counts."""
        return (self.value() + other.value())_err_count

    pub fn exceeds_threshold(threshold: u32) -> bool:
        """Check if error count exceeds threshold."""
        return self.value() > threshold

    pub fn is_zero() -> bool:
        return self.value() == 0

# AttemptNumber implementation
impl AttemptNumber:
    pub fn from_u32(n: u32) -> AttemptNumber:
        return n_attempt

    pub fn value() -> u32:
        return self as u32

    pub fn first() -> AttemptNumber:
        """First attempt (1)."""
        return 1_attempt

    pub fn increment() -> AttemptNumber:
        """Increment attempt number."""
        return (self.value() + 1)_attempt

    pub fn exceeds_max(max_attempts: u32) -> bool:
        """Check if attempt number exceeds maximum."""
        return self.value() > max_attempts

    pub fn is_first() -> bool:
        """Check if this is the first attempt."""
        return self.value() == 1

    pub fn is_last(max_attempts: u32) -> bool:
        """Check if this is the last attempt."""
        return self.value() >= max_attempts

# =============================================================================
# Temperature and Probability Units
# =============================================================================

# Temperature parameter for LLM sampling (typically 0.0-2.0)
unit Temperature: f32 as temp

# Probability value (0.0-1.0)
unit Probability: f32 as prob

# Temperature implementation
impl Temperature:
    pub fn from_f32(n: f32) -> Temperature:
        """Create temperature, clamped to valid range [0.0, 2.0]."""
        val clamped = max(0.0, min(2.0, n))
        return clamped_temp

    pub fn value() -> f32:
        return self as f32

    pub fn deterministic() -> Temperature:
        """Deterministic output (temp = 0.0)."""
        return 0.0_temp

    pub fn balanced() -> Temperature:
        """Balanced creativity (temp = 0.7)."""
        return 0.7_temp

    pub fn creative() -> Temperature:
        """Creative output (temp = 1.0)."""
        return 1.0_temp

    pub fn very_creative() -> Temperature:
        """Very creative output (temp = 1.5)."""
        return 1.5_temp

    pub fn is_deterministic() -> bool:
        """Check if temperature is deterministic (< 0.01)."""
        return self.value() < 0.01

    pub fn is_high() -> bool:
        """Check if temperature is high (> 1.2)."""
        return self.value() > 1.2

# Probability implementation
impl Probability:
    pub fn from_f32(n: f32) -> Probability:
        """Create probability, clamped to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_prob

    pub fn value() -> f32:
        return self as f32

    pub fn zero() -> Probability:
        """Impossible (0% probability)."""
        return 0.0_prob

    pub fn one() -> Probability:
        """Certain (100% probability)."""
        return 1.0_prob

    pub fn half() -> Probability:
        """50% probability."""
        return 0.5_prob

    pub fn is_likely() -> bool:
        """Check if probability is high (> 0.7)."""
        return self.value() > 0.7

    pub fn is_unlikely() -> bool:
        """Check if probability is low (< 0.3)."""
        return self.value() < 0.3

    pub fn complement() -> Probability:
        """Get complement probability (1.0 - p)."""
        return (1.0 - self.value())_prob

fn max(a: f32, b: f32) -> f32:
    if a > b:
        return a
    return b

fn min(a: f32, b: f32) -> f32:
    if a < b:
        return a
    return b
