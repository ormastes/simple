# Graphics Unit Types
# Angular units and 3D semantic types for graphics programming

use core.*
use graphics.math.*

# =============================================================================
# Angle Units
# =============================================================================

# Base unit: Radians (internal representation)
unit Radians: f32 as rad

# Derived unit: Degrees
unit Degrees: f32 as deg

# Unit family for automatic conversion
# 1 radian = 57.2957795 degrees
# 1 degree = 0.0174532925 radians
unit family Angle: f32 as rad
    Radians = 1.0
    Degrees = 57.2957795131  # 180/π

# Constants
const PI: f32 = 3.14159265359
const TAU: f32 = 6.28318530718  # 2π
const DEG_TO_RAD: f32 = 0.0174532925
const RAD_TO_DEG: f32 = 57.2957795131

# Radians implementation
impl Radians:
    fn from_f32(n: f32) -> Radians:
        return n_rad

    fn to_f32() -> f32:
        return self as f32

    fn zero() -> Radians:
        return 0.0_rad

    # Convert to degrees
    fn to_deg() -> Degrees:
        return ((self as f32) * RAD_TO_DEG)_deg

    # Normalize to [0, 2π)
    fn normalize() -> Radians:
        var angle = self as f32
        while angle >= TAU:
            angle = angle - TAU
        while angle < 0.0:
            angle = angle + TAU
        return angle_rad

    # Normalize to [-π, π)
    fn normalize_signed() -> Radians:
        var angle = self as f32
        while angle >= PI:
            angle = angle - TAU
        while angle < -PI:
            angle = angle + TAU
        return angle_rad

    # Trigonometric functions
    fn sin() -> f32:
        return sin(self as f32)

    fn cos() -> f32:
        return cos(self as f32)

    fn tan() -> f32:
        return tan(self as f32)

    # Arithmetic
    fn add(other: Radians) -> Radians:
        return ((self as f32) + (other as f32))_rad

    fn sub(other: Radians) -> Radians:
        return ((self as f32) - (other as f32))_rad

    fn mul(scalar: f32) -> Radians:
        return ((self as f32) * scalar)_rad

    fn div(scalar: f32) -> Radians:
        if scalar == 0.0:
            return 0.0_rad
        return ((self as f32) / scalar)_rad

    fn negate() -> Radians:
        return (-(self as f32))_rad

# Degrees implementation
impl Degrees:
    fn from_f32(n: f32) -> Degrees:
        return n_deg

    fn to_f32() -> f32:
        return self as f32

    fn zero() -> Degrees:
        return 0.0_deg

    # Convert to radians
    fn to_rad() -> Radians:
        return ((self as f32) * DEG_TO_RAD)_rad

    # Normalize to [0, 360)
    fn normalize() -> Degrees:
        var angle = self as f32
        while angle >= 360.0:
            angle = angle - 360.0
        while angle < 0.0:
            angle = angle + 360.0
        return angle_deg

    # Normalize to [-180, 180)
    fn normalize_signed() -> Degrees:
        var angle = self as f32
        while angle >= 180.0:
            angle = angle - 360.0
        while angle < -180.0:
            angle = angle + 360.0
        return angle_deg

    # Arithmetic
    fn add(other: Degrees) -> Degrees:
        return ((self as f32) + (other as f32))_deg

    fn sub(other: Degrees) -> Degrees:
        return ((self as f32) - (other as f32))_deg

    fn mul(scalar: f32) -> Degrees:
        return ((self as f32) * scalar)_deg

    fn div(scalar: f32) -> Degrees:
        if scalar == 0.0:
            return 0.0_deg
        return ((self as f32) / scalar)_deg

    fn negate() -> Degrees:
        return (-(self as f32))_deg

# =============================================================================
# Length Units (for 3D coordinates)
# =============================================================================

# Base unit: Meters
unit Meters: f32 as m

# Derived units
unit Centimeters: f32 as cm
unit Millimeters: f32 as mm
unit Kilometers: f32 as km
unit Pixels: f32 as px

# Unit family for automatic conversion
unit family Length: f32 as m
    Meters = 1.0
    Centimeters = 100.0
    Millimeters = 1000.0
    Kilometers = 0.001
    Pixels = 1.0  # 1:1 with meters for simplicity

# Meters implementation
impl Meters:
    fn from_f32(n: f32) -> Meters:
        return n_m

    fn to_f32() -> f32:
        return self as f32

    fn zero() -> Meters:
        return 0.0_m

    fn to_cm() -> Centimeters:
        return ((self as f32) * 100.0)_cm

    fn to_mm() -> Millimeters:
        return ((self as f32) * 1000.0)_mm

    fn to_km() -> Kilometers:
        return ((self as f32) * 0.001)_km

    fn to_px() -> Pixels:
        return ((self as f32))_px

# =============================================================================
# Semantic 3D Types
# =============================================================================

# Position3D - A point in 3D space (has a location)
# Uses parametric length unit U
pub struct Position3D<U>:
    x: U
    y: U
    z: U

impl<U> Position3D<U>:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_zero(self) -> bool:
        """Check if position is at origin."""
        return (self.x as f32) == 0.0 and (self.y as f32) == 0.0 and (self.z as f32) == 0.0

    pub fn is_valid(self) -> bool:
        """Check if all components are valid (not NaN or infinity)."""
        val x_val = self.x as f32
        val y_val = self.y as f32
        val z_val = self.z as f32
        return not (is_nan(x_val) or is_nan(y_val) or is_nan(z_val) or
                    is_infinite(x_val) or is_infinite(y_val) or is_infinite(z_val))

    pub fn manhattan_distance_to(self, other: Position3D<U>) -> U:
        """Calculate Manhattan (L1) distance to another position."""
        val dx = abs((other.x as f32) - (self.x as f32))
        val dy = abs((other.y as f32) - (self.y as f32))
        val dz = abs((other.z as f32) - (self.z as f32))
        return (dx + dy + dz) as U

    pub fn chebyshev_distance_to(self, other: Position3D<U>) -> U:
        """Calculate Chebyshev (L∞) distance to another position."""
        val dx = abs((other.x as f32) - (self.x as f32))
        val dy = abs((other.y as f32) - (self.y as f32))
        val dz = abs((other.z as f32) - (self.z as f32))
        return max(max(dx, dy), dz) as U

    pub fn midpoint(self, other: Position3D<U>) -> Position3D<U>:
        """Calculate midpoint between two positions."""
        return self.lerp(other, 0.5)

    pub fn summary(self) -> text:
        """Get summary of position."""
        return "Position3D: ({self.x as f32}, {self.y as f32}, {self.z as f32})"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new(x: U, y: U, z: U) -> Position3D<U>:
        return Position3D { x: x, y: y, z: z }

    pub fn origin() -> Position3D<U>:
        return Position3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    # Convert to raw Vec3
    pub fn to_vec3(self) -> Vec3:
        return Vec3::new(self.x as f32, self.y as f32, self.z as f32)

    # From raw Vec3
    pub fn from_vec3(v: Vec3) -> Position3D<U>:
        return Position3D {
            x: v.x as U,
            y: v.y as U,
            z: v.z as U
        }

    # Distance to another position
    pub fn distance_to(self, other: Position3D<U>) -> U:
        val dx = (other.x as f32) - (self.x as f32)
        val dy = (other.y as f32) - (self.y as f32)
        val dz = (other.z as f32) - (self.z as f32)
        return sqrt(dx * dx + dy * dy + dz * dz) as U

    # Lerp between positions
    pub fn lerp(self, other: Position3D<U>, t: f32) -> Position3D<U>:
        val x = (self.x as f32) + ((other.x as f32) - (self.x as f32)) * t
        val y = (self.y as f32) + ((other.y as f32) - (self.y as f32)) * t
        val z = (self.z as f32) + ((other.z as f32) - (self.z as f32)) * t
        return Position3D { x: x as U, y: y as U, z: z as U }

# Vector3D - A direction/displacement in 3D space (no location)
# Uses parametric length unit U
pub struct Vector3D<U>:
    x: U
    y: U
    z: U

impl<U> Vector3D<U>:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_zero(self) -> bool:
        """Check if this is a zero vector."""
        return (self.x as f32) == 0.0 and (self.y as f32) == 0.0 and (self.z as f32) == 0.0

    pub fn is_normalized(self) -> bool:
        """Check if vector has unit length (within tolerance)."""
        val len_sq = self.dot(self)
        return abs(len_sq - 1.0) < 0.0001

    pub fn is_valid(self) -> bool:
        """Check if all components are valid (not NaN or infinity)."""
        val x_val = self.x as f32
        val y_val = self.y as f32
        val z_val = self.z as f32
        return not (is_nan(x_val) or is_nan(y_val) or is_nan(z_val) or
                    is_infinite(x_val) or is_infinite(y_val) or is_infinite(z_val))

    pub fn is_parallel_to(self, other: Vector3D<U>) -> bool:
        """Check if this vector is parallel to another (within tolerance)."""
        # Vectors are parallel if their cross product is (near) zero
        val cross_prod = self.cross(other)
        val cross_len_sq = cross_prod.dot(cross_prod)
        return cross_len_sq < 0.0001

    pub fn is_perpendicular_to(self, other: Vector3D<U>) -> bool:
        """Check if this vector is perpendicular to another (within tolerance)."""
        # Vectors are perpendicular if their dot product is (near) zero
        val dot_prod = self.dot(other)
        return abs(dot_prod) < 0.0001

    pub fn angle_to(self, other: Vector3D<U>) -> Radians:
        """Calculate angle to another vector in radians."""
        val self_len = self.length() as f32
        val other_len = other.length() as f32

        if self_len < 0.0001 or other_len < 0.0001:
            return 0.0_rad

        val dot_prod = self.dot(other)
        val cos_angle = dot_prod / (self_len * other_len)

        # Clamp to [-1, 1] to avoid acos domain errors
        val clamped = max(-1.0, min(1.0, cos_angle))
        return acos(clamped)_rad

    pub fn length_squared(self) -> f32:
        """Get squared length (faster than length(), no sqrt)."""
        return self.dot(self)

    pub fn distance_to(self, other: Vector3D<U>) -> U:
        """Calculate distance to another vector."""
        val diff = self.sub(other)
        return diff.length()

    pub fn project_onto(self, onto: Vector3D<U>) -> Vector3D<U>:
        """Project this vector onto another vector."""
        val onto_len_sq = onto.dot(onto)
        if onto_len_sq < 0.0001:
            return Vector3D::zero()

        val scalar = self.dot(onto) / onto_len_sq
        return onto.scale(scalar)

    pub fn reflect(self, normal: Vector3D<U>) -> Vector3D<U>:
        """Reflect this vector across a surface with given normal."""
        val dot_prod = self.dot(normal)
        val reflection = normal.scale(2.0 * dot_prod)
        return self.sub(reflection)

    pub fn summary(self) -> text:
        """Get summary of vector."""
        val len = self.length() as f32
        return "Vector3D: ({self.x as f32}, {self.y as f32}, {self.z as f32}), length={len}"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new(x: U, y: U, z: U) -> Vector3D<U>:
        return Vector3D { x: x, y: y, z: z }

    pub fn zero() -> Vector3D<U>:
        return Vector3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    pub fn unit_x() -> Vector3D<U>:
        return Vector3D {
            x: 1.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    pub fn unit_y() -> Vector3D<U>:
        return Vector3D {
            x: 0.0 as U,
            y: 1.0 as U,
            z: 0.0 as U
        }

    pub fn unit_z() -> Vector3D<U>:
        return Vector3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 1.0 as U
        }

    # Convert to raw Vec3
    pub fn to_vec3(self) -> Vec3:
        return Vec3::new(self.x as f32, self.y as f32, self.z as f32)

    # From raw Vec3
    pub fn from_vec3(v: Vec3) -> Vector3D<U>:
        return Vector3D {
            x: v.x as U,
            y: v.y as U,
            z: v.z as U
        }

    # Vector operations
    pub fn dot(self, other: Vector3D<U>) -> f32:
        return (self.x as f32) * (other.x as f32) +
               (self.y as f32) * (other.y as f32) +
               (self.z as f32) * (other.z as f32)

    pub fn cross(self, other: Vector3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.y as f32) * (other.z as f32) - (self.z as f32) * (other.y as f32)) as U,
            y: ((self.z as f32) * (other.x as f32) - (self.x as f32) * (other.z as f32)) as U,
            z: ((self.x as f32) * (other.y as f32) - (self.y as f32) * (other.x as f32)) as U
        }

    pub fn length(self) -> U:
        val len_sq = self.dot(self)
        return sqrt(len_sq) as U

    pub fn normalize(self) -> Vector3D<U>:
        val len = self.length() as f32
        if len < 0.0001:
            return Vector3D::unit_x()

        return Vector3D {
            x: ((self.x as f32) / len) as U,
            y: ((self.y as f32) / len) as U,
            z: ((self.z as f32) / len) as U
        }

    pub fn scale(self, scalar: f32) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) * scalar) as U,
            y: ((self.y as f32) * scalar) as U,
            z: ((self.z as f32) * scalar) as U
        }

# Type-safe operations

# Position - Position = Vector
impl<U> Sub<Position3D<U>> for Position3D<U>:
    fn sub(other: Position3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) - (other.x as f32)) as U,
            y: ((self.y as f32) - (other.y as f32)) as U,
            z: ((self.z as f32) - (other.z as f32)) as U
        }

# Position + Vector = Position
impl<U> Add<Vector3D<U>> for Position3D<U>:
    fn add(vector: Vector3D<U>) -> Position3D<U>:
        return Position3D {
            x: ((self.x as f32) + (vector.x as f32)) as U,
            y: ((self.y as f32) + (vector.y as f32)) as U,
            z: ((self.z as f32) + (vector.z as f32)) as U
        }

# Vector + Vector = Vector
impl<U> Add for Vector3D<U>:
    fn add(other: Vector3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) + (other.x as f32)) as U,
            y: ((self.y as f32) + (other.y as f32)) as U,
            z: ((self.z as f32) + (other.z as f32)) as U
        }

# Vector - Vector = Vector
impl<U> Sub for Vector3D<U>:
    fn sub(other: Vector3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) - (other.x as f32)) as U,
            y: ((self.y as f32) - (other.y as f32)) as U,
            z: ((self.z as f32) - (other.z as f32)) as U
        }

# Vector * scalar = Vector
impl<U> Mul[f32] for Vector3D<U>:
    fn mul(scalar: f32) -> Vector3D<U>:
        return self.scale(scalar)

# -Vector = Vector
impl<U> Neg for Vector3D<U>:
    fn neg() -> Vector3D<U>:
        return Vector3D {
            x: (-(self.x as f32)) as U,
            y: (-(self.y as f32)) as U,
            z: (-(self.z as f32)) as U
        }

# =============================================================================
# PBR Material Coefficient Units
# =============================================================================
# These units ensure type safety for material properties and prevent
# accidental mixing of different physical properties.

# Metallic coefficient (0.0 = dielectric, 1.0 = metal)
unit Metallic: f32 as metallic

# Surface roughness (0.0 = smooth/mirror-like, 1.0 = rough/diffuse)
unit Roughness: f32 as roughness

# Ambient occlusion factor (0.0 = fully occluded, 1.0 = no occlusion)
unit AmbientOcclusion: f32 as ao

# Opacity/alpha (0.0 = fully transparent, 1.0 = fully opaque)
unit Opacity: f32 as opacity

# Fresnel reflectance at normal incidence (0.0-1.0)
unit Reflectance: f32 as reflectance

# Generic normalized float (0.0-1.0) for other material properties
unit NormalizedFloat: f32 as nf

# Generic multiplicative factor
unit Factor: f32 as factor

# Metallic implementation
impl Metallic:
    pub fn from_f32(n: f32) -> Metallic:
        """Create Metallic from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_metallic

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Metallic:
        """Pure dielectric (non-metal)."""
        return 0.0_metallic

    pub fn one() -> Metallic:
        """Pure metal."""
        return 1.0_metallic

    pub fn is_metal() -> bool:
        """Check if this represents a metal (metallic >= 0.9)."""
        return self.value() >= 0.9

    pub fn is_dielectric() -> bool:
        """Check if this represents a dielectric (metallic <= 0.1)."""
        return self.value() <= 0.1

    pub fn lerp(other: Metallic, t: f32) -> Metallic:
        """Linear interpolation between two metallic values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Metallic::from_f32(result)

# Roughness implementation
impl Roughness:
    pub fn from_f32(n: f32) -> Roughness:
        """Create Roughness from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_roughness

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Roughness:
        """Perfect mirror (no roughness)."""
        return 0.0_roughness

    pub fn one() -> Roughness:
        """Fully rough/diffuse surface."""
        return 1.0_roughness

    pub fn is_smooth() -> bool:
        """Check if surface is smooth (roughness <= 0.1)."""
        return self.value() <= 0.1

    pub fn is_rough() -> bool:
        """Check if surface is rough (roughness >= 0.9)."""
        return self.value() >= 0.9

    pub fn lerp(other: Roughness, t: f32) -> Roughness:
        """Linear interpolation between two roughness values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Roughness::from_f32(result)

    pub fn perceptual() -> f32:
        """
        Convert linear roughness to perceptual roughness (sqrt).
        Useful for artist-friendly controls.
        """
        return sqrt(self.value())

    pub fn from_perceptual(perceptual: f32) -> Roughness:
        """
        Create roughness from perceptual value (squared).
        Converts artist-friendly perceptual roughness to physically-based linear.
        """
        val linear = perceptual * perceptual
        return Roughness::from_f32(linear)

# AmbientOcclusion implementation
impl AmbientOcclusion:
    pub fn from_f32(n: f32) -> AmbientOcclusion:
        """Create AO from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_ao

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> AmbientOcclusion:
        """Fully occluded."""
        return 0.0_ao

    pub fn one() -> AmbientOcclusion:
        """No occlusion."""
        return 1.0_ao

    pub fn lerp(other: AmbientOcclusion, t: f32) -> AmbientOcclusion:
        """Linear interpolation between two AO values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return AmbientOcclusion::from_f32(result)

# Opacity implementation
impl Opacity:
    pub fn from_f32(n: f32) -> Opacity:
        """Create Opacity from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_opacity

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn transparent() -> Opacity:
        """Fully transparent."""
        return 0.0_opacity

    pub fn opaque() -> Opacity:
        """Fully opaque."""
        return 1.0_opacity

    pub fn is_transparent() -> bool:
        """Check if fully or nearly transparent."""
        return self.value() <= 0.01

    pub fn is_opaque() -> bool:
        """Check if fully or nearly opaque."""
        return self.value() >= 0.99

    pub fn lerp(other: Opacity, t: f32) -> Opacity:
        """Linear interpolation between two opacity values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Opacity::from_f32(result)

# Reflectance implementation
impl Reflectance:
    pub fn from_f32(n: f32) -> Reflectance:
        """Create Reflectance from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_reflectance

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Reflectance:
        """No reflectance."""
        return 0.0_reflectance

    pub fn one() -> Reflectance:
        """Full reflectance."""
        return 1.0_reflectance

    pub fn default_dielectric() -> Reflectance:
        """
        Default reflectance for common dielectrics (0.04).
        Corresponds to IOR ~1.5 (glass, plastic, etc.)
        """
        return 0.04_reflectance

    pub fn lerp(other: Reflectance, t: f32) -> Reflectance:
        """Linear interpolation between two reflectance values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Reflectance::from_f32(result)

# NormalizedFloat implementation
impl NormalizedFloat:
    pub fn from_f32(n: f32) -> NormalizedFloat:
        """Create NormalizedFloat from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_nf

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> NormalizedFloat:
        return 0.0_nf

    pub fn one() -> NormalizedFloat:
        return 1.0_nf

    pub fn lerp(other: NormalizedFloat, t: f32) -> NormalizedFloat:
        """Linear interpolation between two normalized values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return NormalizedFloat::from_f32(result)

# Factor implementation (can be > 1.0)
impl Factor:
    pub fn from_f32(n: f32) -> Factor:
        """Create Factor from f32 (no clamping)."""
        return n_factor

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Factor:
        return 0.0_factor

    pub fn one() -> Factor:
        return 1.0_factor

    pub fn mul(other: Factor) -> Factor:
        """Multiply two factors."""
        return (self.value() * other.value())_factor

    pub fn scale(n: f32) -> Factor:
        """Scale factor by a scalar."""
        return (self.value() * n)_factor

# =============================================================================
# Light Property Units
# =============================================================================

# Light intensity (can be > 1.0, typically in lumens or watts)
unit Intensity: f32 as intensity

# Luminance (brightness per unit area)
unit Luminance: f32 as lum

# Intensity implementation
impl Intensity:
    pub fn from_f32(n: f32) -> Intensity:
        """Create Intensity from f32 (clamped to non-negative)."""
        val clamped = max(0.0, n)
        return clamped_intensity

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Intensity:
        """No light."""
        return 0.0_intensity

    pub fn one() -> Intensity:
        """Unit intensity."""
        return 1.0_intensity

    pub fn scale(factor: f32) -> Intensity:
        """Scale intensity by a factor."""
        return Intensity::from_f32(self.value() * factor)

    pub fn add(other: Intensity) -> Intensity:
        """Add two intensities."""
        return Intensity::from_f32(self.value() + other.value())

# Luminance implementation
impl Luminance:
    pub fn from_f32(n: f32) -> Luminance:
        """Create Luminance from f32 (clamped to non-negative)."""
        val clamped = max(0.0, n)
        return clamped_lum

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Luminance:
        """No luminance."""
        return 0.0_lum

    pub fn scale(factor: f32) -> Luminance:
        """Scale luminance by a factor."""
        return Luminance::from_f32(self.value() * factor)

    pub fn add(other: Luminance) -> Luminance:
        """Add two luminance values."""
        return Luminance::from_f32(self.value() + other.value())

# =============================================================================
# Graphics Dimension Units (Counts)
# =============================================================================

# Pixel count (for texture/buffer sizes)
unit PixelCount: u32 as px_count

# Texture dimension size
unit TextureSize: u32 as tex_size

# Number of vertices in a mesh
unit VertexCount: u32 as vtx_count

# Number of indices in an index buffer
unit IndexCount: u32 as idx_count

# Mipmap level (0 = full resolution, increasing = smaller)
unit MipLevel: u32 as mip

# PixelCount implementation
impl PixelCount:
    pub fn from_u32(n: u32) -> PixelCount:
        return n_px_count

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> PixelCount:
        return 0_px_count

# TextureSize implementation
impl TextureSize:
    pub fn from_u32(n: u32) -> TextureSize:
        return n_tex_size

    pub fn value() -> u32:
        return self as u32

    pub fn is_power_of_two() -> bool:
        """Check if size is power of two (common for textures)."""
        val n = self.value()
        return n > 0 and (n & (n - 1)) == 0

    pub fn next_power_of_two() -> TextureSize:
        """Round up to next power of two."""
        var n = self.value()
        if n == 0:
            return 1_tex_size

        n = n - 1
        n = n | (n >> 1)
        n = n | (n >> 2)
        n = n | (n >> 4)
        n = n | (n >> 8)
        n = n | (n >> 16)
        return (n + 1)_tex_size

# VertexCount implementation
impl VertexCount:
    pub fn from_u32(n: u32) -> VertexCount:
        return n_vtx_count

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> VertexCount:
        return 0_vtx_count

    pub fn add(other: VertexCount) -> VertexCount:
        return (self.value() + other.value())_vtx_count

# IndexCount implementation
impl IndexCount:
    pub fn from_u32(n: u32) -> IndexCount:
        return n_idx_count

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> IndexCount:
        return 0_idx_count

    pub fn add(other: IndexCount) -> IndexCount:
        return (self.value() + other.value())_idx_count

    pub fn triangle_count() -> u32:
        """Get number of triangles (assuming triangle list topology)."""
        return self.value() / 3

# MipLevel implementation
impl MipLevel:
    pub fn from_u32(n: u32) -> MipLevel:
        return n_mip

    pub fn value() -> u32:
        return self as u32

    pub fn base_level() -> MipLevel:
        """Base mip level (full resolution)."""
        return 0_mip

    pub fn next_level() -> MipLevel:
        """Get next mip level (smaller resolution)."""
        return (self.value() + 1)_mip

    pub fn prev_level() -> MipLevel:
        """Get previous mip level (larger resolution), clamped to 0."""
        val current = self.value()
        if current == 0:
            return 0_mip
        return (current - 1)_mip

# =============================================================================
# Graphics Index Units
# =============================================================================

# Index into a vertex buffer
unit VertexIndex: i32 as vtx_idx

# Index into a light array
unit LightIndex: i32 as light_idx

# Layer index for layered rendering (e.g., cubemap faces)
unit LayerIndex: i32 as layer

# VertexIndex implementation
impl VertexIndex:
    pub fn from_i32(n: i32) -> VertexIndex:
        return n_vtx_idx

    pub fn value() -> i32:
        return self as i32

    pub fn invalid() -> VertexIndex:
        """Invalid index (-1)."""
        return (-1)_vtx_idx

    pub fn is_valid() -> bool:
        """Check if index is valid (>= 0)."""
        return self.value() >= 0

# LightIndex implementation
impl LightIndex:
    pub fn from_i32(n: i32) -> LightIndex:
        return n_light_idx

    pub fn value() -> i32:
        return self as i32

    pub fn invalid() -> LightIndex:
        """Invalid index (-1)."""
        return (-1)_light_idx

    pub fn is_valid() -> bool:
        """Check if index is valid (>= 0)."""
        return self.value() >= 0

# LayerIndex implementation
impl LayerIndex:
    pub fn from_i32(n: i32) -> LayerIndex:
        return n_layer

    pub fn value() -> i32:
        return self as i32

    pub fn zero() -> LayerIndex:
        """First layer."""
        return 0_layer

    pub fn is_valid() -> bool:
        """Check if index is valid (>= 0)."""
        return self.value() >= 0
