# Graphics Unit Types
# Angular units and 3D semantic types for graphics programming

use core.*
use graphics.math.*

# =============================================================================
# Angle Units
# =============================================================================

# Base unit: Radians (internal representation)
unit Radians: f32 as rad

# Derived unit: Degrees
unit Degrees: f32 as deg

# Unit family for automatic conversion
# 1 radian = 57.2957795 degrees
# 1 degree = 0.0174532925 radians
unit family Angle: f32 as rad
    Radians = 1.0
    Degrees = 57.2957795131  # 180/π

# Constants
const PI: f32 = 3.14159265359
const TAU: f32 = 6.28318530718  # 2π
const DEG_TO_RAD: f32 = 0.0174532925
const RAD_TO_DEG: f32 = 57.2957795131

# Radians implementation
impl Radians:
    fn from_f32(n: f32) -> Radians:
        return n_rad

    fn to_f32(self) -> f32:
        return self as f32

    fn zero() -> Radians:
        return 0.0_rad

    # Convert to degrees
    fn to_deg(self) -> Degrees:
        return ((self as f32) * RAD_TO_DEG)_deg

    # Normalize to [0, 2π)
    fn normalize(self) -> Radians:
        let mut angle = self as f32
        while angle >= TAU:
            angle = angle - TAU
        while angle < 0.0:
            angle = angle + TAU
        return angle_rad

    # Normalize to [-π, π)
    fn normalize_signed(self) -> Radians:
        let mut angle = self as f32
        while angle >= PI:
            angle = angle - TAU
        while angle < -PI:
            angle = angle + TAU
        return angle_rad

    # Trigonometric functions
    fn sin(self) -> f32:
        return sin(self as f32)

    fn cos(self) -> f32:
        return cos(self as f32)

    fn tan(self) -> f32:
        return tan(self as f32)

    # Arithmetic
    fn add(self, other: Radians) -> Radians:
        return ((self as f32) + (other as f32))_rad

    fn sub(self, other: Radians) -> Radians:
        return ((self as f32) - (other as f32))_rad

    fn mul(self, scalar: f32) -> Radians:
        return ((self as f32) * scalar)_rad

    fn div(self, scalar: f32) -> Radians:
        if scalar == 0.0:
            return 0.0_rad
        return ((self as f32) / scalar)_rad

    fn negate(self) -> Radians:
        return (-(self as f32))_rad

# Degrees implementation
impl Degrees:
    fn from_f32(n: f32) -> Degrees:
        return n_deg

    fn to_f32(self) -> f32:
        return self as f32

    fn zero() -> Degrees:
        return 0.0_deg

    # Convert to radians
    fn to_rad(self) -> Radians:
        return ((self as f32) * DEG_TO_RAD)_rad

    # Normalize to [0, 360)
    fn normalize(self) -> Degrees:
        let mut angle = self as f32
        while angle >= 360.0:
            angle = angle - 360.0
        while angle < 0.0:
            angle = angle + 360.0
        return angle_deg

    # Normalize to [-180, 180)
    fn normalize_signed(self) -> Degrees:
        let mut angle = self as f32
        while angle >= 180.0:
            angle = angle - 360.0
        while angle < -180.0:
            angle = angle + 360.0
        return angle_deg

    # Arithmetic
    fn add(self, other: Degrees) -> Degrees:
        return ((self as f32) + (other as f32))_deg

    fn sub(self, other: Degrees) -> Degrees:
        return ((self as f32) - (other as f32))_deg

    fn mul(self, scalar: f32) -> Degrees:
        return ((self as f32) * scalar)_deg

    fn div(self, scalar: f32) -> Degrees:
        if scalar == 0.0:
            return 0.0_deg
        return ((self as f32) / scalar)_deg

    fn negate(self) -> Degrees:
        return (-(self as f32))_deg

# =============================================================================
# Length Units (for 3D coordinates)
# =============================================================================

# Base unit: Meters
unit Meters: f32 as m

# Derived units
unit Centimeters: f32 as cm
unit Millimeters: f32 as mm
unit Kilometers: f32 as km
unit Pixels: f32 as px

# Unit family for automatic conversion
unit family Length: f32 as m
    Meters = 1.0
    Centimeters = 100.0
    Millimeters = 1000.0
    Kilometers = 0.001
    Pixels = 1.0  # 1:1 with meters for simplicity

# Meters implementation
impl Meters:
    fn from_f32(n: f32) -> Meters:
        return n_m

    fn to_f32(self) -> f32:
        return self as f32

    fn zero() -> Meters:
        return 0.0_m

    fn to_cm(self) -> Centimeters:
        return ((self as f32) * 100.0)_cm

    fn to_mm(self) -> Millimeters:
        return ((self as f32) * 1000.0)_mm

    fn to_km(self) -> Kilometers:
        return ((self as f32) * 0.001)_km

    fn to_px(self) -> Pixels:
        return ((self as f32))_px

# =============================================================================
# Semantic 3D Types
# =============================================================================

# Position3D - A point in 3D space (has a location)
# Uses parametric length unit U
pub struct Position3D[U]:
    x: U
    y: U
    z: U

impl[U] Position3D[U]:
    pub fn new(x: U, y: U, z: U) -> Position3D[U]:
        return Position3D { x: x, y: y, z: z }

    pub fn origin() -> Position3D[U]:
        return Position3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    # Convert to raw Vec3
    pub fn to_vec3(self) -> Vec3:
        return Vec3::new(self.x as f32, self.y as f32, self.z as f32)

    # From raw Vec3
    pub fn from_vec3(v: Vec3) -> Position3D[U]:
        return Position3D {
            x: v.x as U,
            y: v.y as U,
            z: v.z as U
        }

    # Distance to another position
    pub fn distance_to(self, other: Position3D[U]) -> U:
        let dx = (other.x as f32) - (self.x as f32)
        let dy = (other.y as f32) - (self.y as f32)
        let dz = (other.z as f32) - (self.z as f32)
        return sqrt(dx * dx + dy * dy + dz * dz) as U

    # Lerp between positions
    pub fn lerp(self, other: Position3D[U], t: f32) -> Position3D[U]:
        let x = (self.x as f32) + ((other.x as f32) - (self.x as f32)) * t
        let y = (self.y as f32) + ((other.y as f32) - (self.y as f32)) * t
        let z = (self.z as f32) + ((other.z as f32) - (self.z as f32)) * t
        return Position3D { x: x as U, y: y as U, z: z as U }

# Vector3D - A direction/displacement in 3D space (no location)
# Uses parametric length unit U
pub struct Vector3D[U]:
    x: U
    y: U
    z: U

impl[U] Vector3D[U]:
    pub fn new(x: U, y: U, z: U) -> Vector3D[U]:
        return Vector3D { x: x, y: y, z: z }

    pub fn zero() -> Vector3D[U]:
        return Vector3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    pub fn unit_x() -> Vector3D[U]:
        return Vector3D {
            x: 1.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    pub fn unit_y() -> Vector3D[U]:
        return Vector3D {
            x: 0.0 as U,
            y: 1.0 as U,
            z: 0.0 as U
        }

    pub fn unit_z() -> Vector3D[U]:
        return Vector3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 1.0 as U
        }

    # Convert to raw Vec3
    pub fn to_vec3(self) -> Vec3:
        return Vec3::new(self.x as f32, self.y as f32, self.z as f32)

    # From raw Vec3
    pub fn from_vec3(v: Vec3) -> Vector3D[U]:
        return Vector3D {
            x: v.x as U,
            y: v.y as U,
            z: v.z as U
        }

    # Vector operations
    pub fn dot(self, other: Vector3D[U]) -> f32:
        return (self.x as f32) * (other.x as f32) +
               (self.y as f32) * (other.y as f32) +
               (self.z as f32) * (other.z as f32)

    pub fn cross(self, other: Vector3D[U]) -> Vector3D[U]:
        return Vector3D {
            x: ((self.y as f32) * (other.z as f32) - (self.z as f32) * (other.y as f32)) as U,
            y: ((self.z as f32) * (other.x as f32) - (self.x as f32) * (other.z as f32)) as U,
            z: ((self.x as f32) * (other.y as f32) - (self.y as f32) * (other.x as f32)) as U
        }

    pub fn length(self) -> U:
        let len_sq = self.dot(self)
        return sqrt(len_sq) as U

    pub fn normalize(self) -> Vector3D[U]:
        let len = self.length() as f32
        if len < 0.0001:
            return Vector3D::unit_x()

        return Vector3D {
            x: ((self.x as f32) / len) as U,
            y: ((self.y as f32) / len) as U,
            z: ((self.z as f32) / len) as U
        }

    pub fn scale(self, scalar: f32) -> Vector3D[U]:
        return Vector3D {
            x: ((self.x as f32) * scalar) as U,
            y: ((self.y as f32) * scalar) as U,
            z: ((self.z as f32) * scalar) as U
        }

# Type-safe operations

# Position - Position = Vector
impl[U] Sub[Position3D[U]] for Position3D[U]:
    fn sub(self, other: Position3D[U]) -> Vector3D[U]:
        return Vector3D {
            x: ((self.x as f32) - (other.x as f32)) as U,
            y: ((self.y as f32) - (other.y as f32)) as U,
            z: ((self.z as f32) - (other.z as f32)) as U
        }

# Position + Vector = Position
impl[U] Add[Vector3D[U]] for Position3D[U]:
    fn add(self, vector: Vector3D[U]) -> Position3D[U]:
        return Position3D {
            x: ((self.x as f32) + (vector.x as f32)) as U,
            y: ((self.y as f32) + (vector.y as f32)) as U,
            z: ((self.z as f32) + (vector.z as f32)) as U
        }

# Vector + Vector = Vector
impl[U] Add for Vector3D[U]:
    fn add(self, other: Vector3D[U]) -> Vector3D[U]:
        return Vector3D {
            x: ((self.x as f32) + (other.x as f32)) as U,
            y: ((self.y as f32) + (other.y as f32)) as U,
            z: ((self.z as f32) + (other.z as f32)) as U
        }

# Vector - Vector = Vector
impl[U] Sub for Vector3D[U]:
    fn sub(self, other: Vector3D[U]) -> Vector3D[U]:
        return Vector3D {
            x: ((self.x as f32) - (other.x as f32)) as U,
            y: ((self.y as f32) - (other.y as f32)) as U,
            z: ((self.z as f32) - (other.z as f32)) as U
        }

# Vector * scalar = Vector
impl[U] Mul[f32] for Vector3D[U]:
    fn mul(self, scalar: f32) -> Vector3D[U]:
        return self.scale(scalar)

# -Vector = Vector
impl[U] Neg for Vector3D[U]:
    fn neg(self) -> Vector3D[U]:
        return Vector3D {
            x: (-(self.x as f32)) as U,
            y: (-(self.y as f32)) as U,
            z: (-(self.z as f32)) as U
        }
