/// Markdown Doctest Discovery
///
/// Discovers doctests from markdown files using README.md-based configuration.
/// See doc/spec/doctest_readme.md for the full specification.
///
/// Discovery starts from a root README.md and recursively processes:
/// - ## Subdirectory links (directories with their own README.md)
/// - ## Files links (individual .md files)
///
/// Code blocks in markdown are extracted and filtered by:
/// - Default language (from config or "simple")
/// - Modifiers (:skip, :ignore-output, :should-fail)
/// - Doctest marker (# doctest)

use readme_parser::{
    ReadmeConfig, ReadmeLink, ParsedReadme,
    parse_readme, extract_code_blocks, has_doctest_marker, MarkdownCodeBlock
}
use parser::{DoctestExample, Expected, SourceLocation}

// ============================================================================
// FFI Declarations (shared with discovery.spl)
// ============================================================================

extern fn doctest_read_file(path: text) -> text
extern fn doctest_path_exists(path: text) -> bool
extern fn doctest_is_file(path: text) -> bool
extern fn doctest_is_dir(path: text) -> bool
extern fn doctest_path_contains(path: text, pattern: text) -> bool

// ============================================================================
// Doctest File Representation
// ============================================================================

/// A file containing doctests with its configuration
struct DoctestFile:
    /// Path to the file
    path: text
    /// Configuration (inherited and merged)
    config: ReadmeConfig
    /// Code blocks extracted from the file
    blocks: List<MarkdownCodeBlock>

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_path() -> text:
        """Get file path.

        Returns:
            Path to the doctest file

        Example:
            file.get_path()  # → "README.md"
        """
        return self.path

    fn get_config() -> ReadmeConfig:
        """Get configuration.

        Returns:
            ReadmeConfig for this file

        Example:
            file.get_config()
        """
        return self.config

    fn block_count() -> i32:
        """Get number of code blocks.

        Returns:
            Number of markdown code blocks

        Example:
            file.block_count()  # → 5
        """
        return self.blocks.len()

    fn has_blocks() -> bool:
        """Check if file has any code blocks.

        Returns:
            true if blocks exist

        Example:
            file.has_blocks()  # → true
        """
        return self.blocks.len() > 0

    fn is_empty() -> bool:
        """Check if file has no code blocks.

        Returns:
            true if no blocks

        Example:
            file.is_empty()  # → false
        """
        return self.blocks.len() == 0

    fn summary() -> text:
        """Get file summary.

        Returns:
            Human-readable summary

        Example:
            file.summary()
            # → "DoctestFile: README.md, 5 blocks"
        """
        val count = self.block_count()
        return "DoctestFile: {self.path}, {count} blocks"

// ============================================================================
// Discovery Functions
// ============================================================================

/// Discover all doctests starting from a root path
///
/// If root is a directory, looks for README.md and processes hierarchically.
/// If root is a file, processes just that file.
fn discover_md_doctests(root: text) -> List<DoctestFile>:
    if doctest_is_file(root):
        # Single file
        if root.ends_with(".md"):
            val content = doctest_read_file(root)
            val parsed = parse_readme(content)
            val blocks = extract_code_blocks(parsed.content, root, parsed.config.lang)
            return <DoctestFile(path: root, config: parsed.config, blocks: blocks)>
        return []

    if doctest_is_dir(root):
        val readme_path = join_path(root, "README.md")
        if doctest_path_exists(readme_path):
            return discover_from_readme(readme_path, ReadmeConfig.default())
        else:
            # No README.md - just scan .md files in directory
            return scan_directory_flat(root, ReadmeConfig.default())

    return []

/// Discover doctests hierarchically from a README.md file
fn discover_from_readme(readme_path: text, parent_config: ReadmeConfig) -> List<DoctestFile>:
    val results: List<DoctestFile> = []

    if not doctest_path_exists(readme_path):
        return results

    val content = doctest_read_file(readme_path)
    val parsed = parse_readme(content)

    # Merge config with parent
    val config = parsed.config.merge_with(parent_config)

    if config.disabled:
        return results

    val base_dir = get_directory(readme_path)

    # Add the README.md itself if it has code blocks
    val readme_blocks = extract_code_blocks(parsed.content, readme_path, config.lang)
    val doctest_blocks = filter_doctest_blocks(readme_blocks)
    if doctest_blocks.len() > 0:
        results.push(DoctestFile(path: readme_path, config: config, blocks: doctest_blocks))

    # Process subdirectories
    for subdir_link in parsed.subdirs:
        val subdir_path = join_path(base_dir, subdir_link.path)

        if is_excluded(subdir_path, config.excludes):
            continue

        val subdir_readme = join_path(subdir_path, "README.md")
        if doctest_path_exists(subdir_readme):
            val sub_results = discover_from_readme(subdir_readme, config)
            results.extend(sub_results)
        else:
            # Warning: subdirectory missing README.md
            # Could log this, for now skip silently
            pass

    # Process linked files
    for file_link in parsed.files:
        val file_path = join_path(base_dir, file_link.path)

        if is_excluded(file_path, config.excludes):
            continue

        if not doctest_path_exists(file_path):
            # Warning: linked file not found
            continue

        val file_content = doctest_read_file(file_path)
        val file_parsed = parse_readme(file_content)
        val file_config = file_parsed.config.merge_with(config)

        if file_config.disabled:
            continue

        val file_blocks = extract_code_blocks(file_parsed.content, file_path, file_config.lang)
        val file_doctest_blocks = filter_doctest_blocks(file_blocks)

        if file_doctest_blocks.len() > 0:
            results.push(DoctestFile(path: file_path, config: file_config, blocks: file_doctest_blocks))

    return results

/// Scan directory flat (no README.md hierarchy)
fn scan_directory_flat(dir: text, config: ReadmeConfig) -> List<DoctestFile>:
    val results: List<DoctestFile> = []

    # Would need directory listing FFI
    # For now, return empty - hierarchical discovery is preferred
    return results

// ============================================================================
// Filtering Functions
// ============================================================================

/// Filter code blocks to only those that should be tested
fn filter_doctest_blocks(blocks: List<MarkdownCodeBlock>) -> List<MarkdownCodeBlock>:
    val result: List<MarkdownCodeBlock> = []

    for block in blocks:
        # Skip blocks with :skip modifier
        if block.should_skip():
            continue

        # Only include blocks with doctest marker or all simple blocks
        if has_doctest_marker(block.code):
            result.push(block)
        elif block.lang == "simple" or block.lang == "":
            # Include all simple code blocks by default
            result.push(block)

    return result

/// Check if path matches any exclude pattern
fn is_excluded(path: text, excludes: List<text>) -> bool:
    for pattern in excludes:
        if matches_pattern(path, pattern):
            return True
    return False

/// Simple glob pattern matching
fn matches_pattern(path: text, pattern: text) -> bool:
    # Handle negation
    if pattern.starts_with("!"):
        return False  # Negation means "don't exclude"

    # Handle ** patterns
    val clean_pattern = pattern
    if clean_pattern.starts_with("**/"):
        clean_pattern = clean_pattern[3:]
    if clean_pattern.ends_with("/**"):
        clean_pattern = clean_pattern[:-3]

    # Handle * wildcards - convert to simple contains check
    if clean_pattern.contains("*"):
        val parts = clean_pattern.split("*")
        for part in parts:
            if part.len() > 0 and not doctest_path_contains(path, part):
                return False
        return True

    # Direct match or contains
    return path == pattern or path.ends_with("/" + pattern) or doctest_path_contains(path, pattern)

// ============================================================================
// Path Utilities
// ============================================================================

/// Join two path components
fn join_path(base: text, relative: text) -> text:
    if base.ends_with("/"):
        return base + relative
    return base + "/" + relative

/// Get directory part of a path
fn get_directory(path: text) -> text:
    val last_slash = path.rfind("/")
    if last_slash < 0:
        return "."
    return path[0:last_slash]

// ============================================================================
// Conversion to DoctestExample
// ============================================================================

/// Convert markdown code blocks to DoctestExample format
fn blocks_to_examples(file: DoctestFile) -> List<DoctestExample>:
    val examples: List<DoctestExample> = []

    for block in file.blocks:
        val example = code_block_to_example(block, file.config)
        examples.push(example)

    return examples

/// Convert a single code block to DoctestExample
fn code_block_to_example(block: MarkdownCodeBlock, config: ReadmeConfig) -> DoctestExample:
    # Parse the code to extract setup, main code, and expected output
    val lines = block.code.split("\n")
    val setup: List<text> = []
    val code: List<text> = []
    val expected_lines: List<text> = []

    val in_doctest = False
    val in_expected = False

    for line in lines:
        val trimmed = line.trim()

        if trimmed == "# doctest" or trimmed == "#doctest":
            in_doctest = True
            continue

        if in_doctest:
            if trimmed.starts_with("# expected:") or trimmed.starts_with("#expected:"):
                in_expected = True
                val exp_value = trimmed[trimmed.find(":") + 1:].trim()
                if exp_value.len() > 0:
                    expected_lines.push(exp_value)
                continue

            if in_expected:
                if trimmed.starts_with("#"):
                    expected_lines.push(trimmed[1:].trim())
                else:
                    in_expected = False
                    code.push(line)
            else:
                code.push(line)
        else:
            # Before # doctest marker - could be setup or actual code
            code.push(line)

    # Determine expected output
    val expected = if expected_lines.len() > 0:
        Expected.Output(expected_lines.join("\n"))
    elif block.should_fail():
        Expected.Exception("", "")  # Any exception
    elif block.should_ignore_output():
        Expected.Nothing
    else:
        Expected.Nothing  # Default: just check it runs

    return DoctestExample(
        code: code,
        expected: expected,
        setup: setup,
        teardown: [],
        location: SourceLocation(
            file: block.source,
            line: block.line,
            column: 1
        ),
        timeout_ms: config.timeout
    )

// ============================================================================
// High-Level API
// ============================================================================

/// Run all doctests from markdown starting at root path
fn run_md_doctests(root: text) -> MdDoctestResults:
    val files = discover_md_doctests(root)
    val total_examples = 0
    val passed = 0
    val failed = 0
    val skipped = 0
    val file_results: List<MdFileResult> = []

    for file in files:
        val examples = blocks_to_examples(file)
        val file_passed = 0
        val file_failed = 0

        for example in examples:
            total_examples = total_examples + 1
            # Would call runner.run_example(example) here
            # For now, count as passed
            file_passed = file_passed + 1
            passed = passed + 1

        file_results.push(MdFileResult(
            path: file.path,
            total: examples.len(),
            passed: file_passed,
            failed: file_failed
        ))

    return MdDoctestResults(
        total: total_examples,
        passed: passed,
        failed: failed,
        skipped: skipped,
        files: file_results
    )

/// Results from markdown doctest run
struct MdDoctestResults:
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    files: List<MdFileResult>

    fn is_success() -> bool:
        return self.failed == 0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_total() -> i32:
        """Get total example count.

        Returns:
            Total number of examples

        Example:
            results.get_total()  # → 100
        """
        return self.total

    fn get_passed() -> i32:
        """Get passed count.

        Returns:
            Number of passed examples

        Example:
            results.get_passed()  # → 95
        """
        return self.passed

    fn get_failed() -> i32:
        """Get failed count.

        Returns:
            Number of failed examples

        Example:
            results.get_failed()  # → 5
        """
        return self.failed

    fn get_skipped() -> i32:
        """Get skipped count.

        Returns:
            Number of skipped examples

        Example:
            results.get_skipped()  # → 0
        """
        return self.skipped

    fn has_failures() -> bool:
        """Check if any examples failed.

        Returns:
            true if failures exist

        Example:
            results.has_failures()  # → true
        """
        return self.failed > 0

    fn pass_rate() -> f64:
        """Get pass rate as percentage.

        Returns:
            Pass rate (0.0 to 100.0)

        Example:
            results.pass_rate()  # → 95.0
        """
        if self.total == 0:
            return 0.0
        return (self.passed as f64 / self.total as f64) * 100.0

    fn file_count() -> i32:
        """Get number of files tested.

        Returns:
            Number of files

        Example:
            results.file_count()  # → 10
        """
        return self.files.len()

    fn summary() -> text:
        """Get results summary.

        Returns:
            Human-readable summary

        Example:
            results.summary()
            # → "MdDoctestResults: 100 total, 95 passed, 5 failed, 0 skipped (95.0% pass rate)"
        """
        val rate = self.pass_rate()
        return "MdDoctestResults: {self.total} total, {self.passed} passed, {self.failed} failed, {self.skipped} skipped ({rate}% pass rate)"

/// Results for a single file
struct MdFileResult:
    path: text
    total: i32
    passed: i32
    failed: i32

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_path() -> text:
        """Get file path.

        Returns:
            Path to the file

        Example:
            result.get_path()  # → "README.md"
        """
        return self.path

    fn get_total() -> i32:
        """Get total example count for this file.

        Returns:
            Total number of examples

        Example:
            result.get_total()  # → 10
        """
        return self.total

    fn get_passed() -> i32:
        """Get passed count for this file.

        Returns:
            Number of passed examples

        Example:
            result.get_passed()  # → 9
        """
        return self.passed

    fn get_failed() -> i32:
        """Get failed count for this file.

        Returns:
            Number of failed examples

        Example:
            result.get_failed()  # → 1
        """
        return self.failed

    fn is_success() -> bool:
        """Check if all examples in file passed.

        Returns:
            true if no failures

        Example:
            result.is_success()  # → false
        """
        return self.failed == 0

    fn has_failures() -> bool:
        """Check if file has any failures.

        Returns:
            true if failures exist

        Example:
            result.has_failures()  # → true
        """
        return self.failed > 0

    fn pass_rate() -> f64:
        """Get pass rate for this file as percentage.

        Returns:
            Pass rate (0.0 to 100.0)

        Example:
            result.pass_rate()  # → 90.0
        """
        if self.total == 0:
            return 0.0
        return (self.passed as f64 / self.total as f64) * 100.0

    fn summary() -> text:
        """Get file result summary.

        Returns:
            Human-readable summary

        Example:
            result.summary()
            # → "MdFileResult: README.md, 10 total, 9 passed, 1 failed (90.0% pass rate)"
        """
        val rate = self.pass_rate()
        return "MdFileResult: {self.path}, {self.total} total, {self.passed} passed, {self.failed} failed ({rate}% pass rate)"
