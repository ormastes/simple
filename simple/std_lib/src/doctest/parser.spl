///
Doctest Example Parser

Extracts >>> examples from:
- Triple-quote blocks (\"\"\"...\"\"\")
- Block comments (/* ... */)
- Markdown code blocks
- Standalone .sdt files
///

# Public exports
export SourceLocation, Expected, DoctestExample
export parse_docstring, parse_sdt_file, parse_spl_file
export extract_triple_quote_blocks, extract_block_comment_blocks
export extract_docstrings, extract_legacy_docstrings

/// Source location for error reporting
struct SourceLocation:
    file: text
    line: i32

    fn to_string() -> text:
        return "${self.file}:${self.line}"

impl SourceLocation:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_file(self) -> text:
        """Get file path.

        Returns:
            File path
        """
        self.file

    pub fn get_line(self) -> i32:
        """Get line number.

        Returns:
            Line number
        """
        self.line

    pub fn is_same_file(self, other: &SourceLocation) -> bool:
        """Check if same file as another location.

        Args:
            other: Location to compare

        Returns:
            True if same file
        """
        self.file == other.file

    pub fn is_before(self, other: &SourceLocation) -> bool:
        """Check if this location is before another.

        Args:
            other: Location to compare

        Returns:
            True if same file and earlier line
        """
        self.file == other.file and self.line < other.line

    pub fn summary(self) -> text:
        """Get summary of source location.

        Returns:
            Human-readable summary

        Example:
            loc.summary()  # → "SourceLocation: test.spl:42"
        """
        "SourceLocation: {self.file}:{self.line}"

/// Expected output type
enum Expected:
    /// Exact string match
    Output(text)
    /// Exception with type and optional message
    Exception(text, Option<text>)  # (type, message)
    /// Empty (no output expected)
    Empty

impl Expected:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_output(self) -> bool:
        """Check if expecting output.

        Returns:
            True for Output variant
        """
        match self:
            case Output(_): true
            case _: false

    pub fn is_exception(self) -> bool:
        """Check if expecting exception.

        Returns:
            True for Exception variant
        """
        match self:
            case Exception(_, _): true
            case _: false

    pub fn is_empty(self) -> bool:
        """Check if expecting no output.

        Returns:
            True for Empty variant
        """
        match self:
            case Empty: true
            case _: false

    pub fn get_output(self) -> Option<text>:
        """Get expected output if available.

        Returns:
            Output string or None
        """
        match self:
            case Output(s): Some(s)
            case _: None

    pub fn get_exception_type(self) -> Option<text>:
        """Get expected exception type if available.

        Returns:
            Exception type or None
        """
        match self:
            case Exception(typ, _): Some(typ)
            case _: None

    pub fn get_exception_message(self) -> Option<text>:
        """Get expected exception message if available.

        Returns:
            Exception message or None
        """
        match self:
            case Exception(_, msg): msg
            case _: None

    pub fn to_string(self) -> text:
        """Convert expected to string.

        Returns:
            Type name
        """
        match self:
            case Output(_): "Output"
            case Exception(_, _): "Exception"
            case Empty: "Empty"

    pub fn description(self) -> text:
        """Get expected output description.

        Returns:
            Human-readable description

        Example:
            Expected::Output("42").description()
            # → "Expecting output match"
        """
        match self:
            case Output(_): "Expecting output match"
            case Exception(_, _): "Expecting exception to be raised"
            case Empty: "Expecting no output"

    pub fn summary(self) -> text:
        """Get summary of expected output.

        Returns:
            Human-readable summary

        Example:
            Expected::Output("42").summary()
            # → "Expected: Output (42)"
            Expected::Exception("ValueError", Some("bad")).summary()
            # → "Expected: Exception (ValueError: bad)"
        """
        match self:
            case Output(s):
                val preview = if s.len() > 30:
                    s.substring(0, 30) + "..."
                else:
                    s
                "Expected: Output ({preview})"
            case Exception(typ, msg):
                match msg:
                    case Some(m): "Expected: Exception ({typ}: {m})"
                    case None: "Expected: Exception ({typ})"
            case Empty:
                "Expected: Empty (no output)"

/// A single doctest example
struct DoctestExample:
    /// Original source (file or docstring)
    source: text
    /// Location in source
    location: SourceLocation
    /// Setup code (executed but output suppressed)
    setup: List<text>
    /// Main code to execute
    code: List<text>
    /// Expected output or exception
    expected: Expected
    /// Teardown code (executed but output suppressed)
    teardown: List<text>
    /// Tags for filtering
    tags: Set<text>
    /// Execution mode (inline or isolated)
    mode: text  # "inline" or "isolated"
    /// Timeout in milliseconds
    timeout_ms: i32
    
    fn to_string() -> text:
        return "DoctestExample(${self.location}, ${self.code.len} lines)"

/// Parse doctests from a string containing docstring content
/// 
/// Examples:
/// >>> examples = parse_docstring(">>> 1 + 1\n2\n")
/// >>> examples.len
/// 1
/// >>> examples[0].code
/// ["1 + 1"]
/// >>> examples[0].expected
/// Expected.Output("2")
fn parse_docstring(content: text, source: text = "<docstring>") -> List<DoctestExample>:
    examples = []
    lines = content.split("\n")
    i = 0
    line_num = 1
    
    # State machine for parsing
    current_code = []
    current_expected = []
    current_setup = []
    current_teardown = []
    in_setup = False
    in_teardown = False
    start_line = 0
    
    while i < lines.len:
        line = lines[i].strip()
        
        # Detect setup block
        if line == "Setup:":
            in_setup = True
            in_teardown = False
            i += 1
            line_num += 1
            continue
        
        # Detect teardown block
        if line == "Teardown:":
            in_teardown = True
            in_setup = False
            i += 1
            line_num += 1
            continue
        
        # Detect example block
        if line == "Example:" or line == "Examples:":
            in_setup = False
            in_teardown = False
            i += 1
            line_num += 1
            continue
        
        # Prompt line: >>> or ...
        if line.starts_with(">>>") or line.starts_with("..."):
            code_line = line[3:].strip()
            
            if in_setup:
                current_setup.push(code_line)
            elif in_teardown:
                current_teardown.push(code_line)
            else:
                if current_code.is_empty:
                    start_line = line_num
                current_code.push(code_line)
        
        # Expected output or exception
        elif not line.is_empty and not current_code.is_empty and not in_setup and not in_teardown:
            current_expected.push(line)
        
        # Blank line or end - finish current example
        elif (line.is_empty or i == lines.len - 1) and not current_code.is_empty:
            # Parse expected output
            expected = parse_expected(current_expected)
            
            examples.push(DoctestExample(
                source: source,
                location: SourceLocation(file: source, line: start_line),
                setup: current_setup.copy(),
                code: current_code,
                expected: expected,
                teardown: current_teardown.copy(),
                tags: Set.new(),
                mode: "inline",
                timeout_ms: 5000
            ))
            
            current_code = []
            current_expected = []
        
        i += 1
        line_num += 1
    
    return examples

/// Parse expected output from lines following >>>
fn parse_expected(lines: List<text>) -> Expected:
    if lines.is_empty:
        return Expected.Empty
    
    # Check if it's an exception
    first = lines[0]
    if first.starts_with("Error:"):
        # Parse "Error: ExceptionType" or "Error: ExceptionType: message"
        rest = first[6:].strip()
        parts = rest.split(":", limit: 2)
        exception_type = parts[0].strip()
        message = if parts.len > 1 then Option.Some(parts[1].strip()) else Option.None
        return Expected.Exception(exception_type, message)
    
    # Otherwise, it's output (join all lines)
    output = lines.join("\n")
    return Expected.Output(output)

/// Parse a standalone .sdt file
/// 
/// .sdt files contain pure doctest format (no docstring wrapping)
fn parse_sdt_file(path: text) -> List<DoctestExample>:
    content = read_file(path)
    # .sdt files are just unwrapped docstring content
    return parse_docstring(content, source: path)

///
Extract triple-quote blocks (///...///) from source code

Finds blocks of form:
///
content here
///
///
fn extract_triple_quote_blocks(source_code: text, file_path: text) -> List<(text, i32)>:
    blocks = []
    lines = source_code.split("\n")
    i = 0

    while i < lines.len:
        trimmed = lines[i].trim()

        # Check for opening ///
        if trimmed.starts_with(///""):
            # Extract language hint if present (e.g., ///simple or ///sdoctest)
            start_line = i + 1
            start_idx = i

            # Collect content until closing ///
            content_lines = []
            i += 1

            while i < lines.len:
                line = lines[i]
                if line.trim() == ///"":
                    # Found closing ///
                    blocks.push((content_lines.join("\n"), start_line))
                    i += 1
                    break
                content_lines.push(line)
                i += 1
        else:
            i += 1

    return blocks

///
Extract /* ... */ block comments from source code

These can contain doctests. If a block comment is immediately
before or after a function/class definition, it belongs to it.
///
fn extract_block_comment_blocks(source_code: text, file_path: text) -> List<(text, i32)>:
    blocks = []
    lines = source_code.split("\n")
    i = 0

    while i < lines.len:
        line = lines[i]
        trimmed = line.trim()

        # Check for opening /*
        if trimmed.starts_with("/*"):
            start_line = i + 1
            content_lines = []
            i += 1

            # Handle /* ... */ on same line
            if trimmed.contains("*/"):
                # Single-line comment - skip for now, handle multi-line
                pass

            # Multi-line comment
            while i < lines.len:
                line = lines[i]
                if line.contains("*/"):
                    # Found closing */ - add content before it
                    close_idx = line.find("*/")
                    if close_idx.is_some:
                        content_lines.push(line[..close_idx.unwrap()])

                    # Combine and store block
                    content = content_lines.join("\n").trim()
                    if not content.is_empty:
                        blocks.push((content, start_line))
                    i += 1
                    break
                else:
                    content_lines.push(line)
                i += 1
        else:
            i += 1

    return blocks

///
Extract docstrings from Simple source file (.spl)

Looks for:
1. Triple-quote blocks (///...///)
2. Block comments (/* ... */)
3. Legacy /// comment blocks

Returns list of (content, line_number) tuples
///
fn extract_docstrings(source_code: text, file_path: text) -> List<(text, i32)>:
    docstrings = []

    # Extract triple-quote blocks
    triple_blocks = extract_triple_quote_blocks(source_code, file_path)
    for (content, line) in triple_blocks:
        docstrings.push((content, line))

    # Extract block comment blocks
    comment_blocks = extract_block_comment_blocks(source_code, file_path)
    for (content, line) in comment_blocks:
        docstrings.push((content, line))

    # Extract legacy /// line comments for backward compatibility
    legacy = extract_legacy_docstrings(source_code, file_path)
    for (content, line) in legacy:
        docstrings.push((content, line))

    return docstrings

///
Extract legacy /// docstring blocks (for backward compatibility)

Finds sequences of /// comments and combines them into docstring blocks.
This maintains support for code written with the old syntax.
///
fn extract_legacy_docstrings(source_code: text, file_path: text) -> List<(text, i32)>:
    docstrings = []
    lines = source_code.split("\n")
    current_docstring = []
    start_line = 0

    for i, line in lines.enumerate():
        trimmed = line.trim_start()
        if trimmed.starts_with("///"):
            if current_docstring.is_empty:
                start_line = i + 1
            # Remove /// prefix
            doc_line = trimmed[3:].trim_start()
            current_docstring.push(doc_line)
        elif not current_docstring.is_empty:
            # End of docstring block
            content = current_docstring.join("\n")
            docstrings.push((content, start_line))
            current_docstring = []

    # Handle docstring at end of file
    if not current_docstring.is_empty:
        content = current_docstring.join("\n")
        docstrings.push((content, start_line))

    return docstrings

/// Parse all doctests from a Simple source file
fn parse_spl_file(path: text) -> List<DoctestExample>:
    source_code = read_file(path)
    docstrings = extract_docstrings(source_code, path)
    
    examples = []
    for (content, line) in docstrings:
        file_examples = parse_docstring(content, source: path)
        # Update line numbers to account for docstring location
        for ex in file_examples:
            ex.location.line += line
        examples.extend(file_examples)
    
    return examples

# Helper to read file (placeholder - will use std.io in real implementation)
fn read_file(path: text) -> text:
    # TODO: [stdlib][P3] Use std.io.read_text_file
    return ""
