/// Doctest Output Matcher
/// 
/// Matches actual output against expected output with support for:
/// - Exact string matching
/// - Wildcard matching (. and *)
/// - Exception matching
/// - Normalized matching (whitespace)

use parser::{Expected, SourceLocation}

# Public exports
export MatchResult, match_output, match_exception
export exact_match, normalize, wildcard_match, format_mismatch

/// Match result
enum MatchResult:
    /// Output matched expected
    Pass
    /// Output did not match
    Fail(String)  # Failure message

impl MatchResult:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_pass(self) -> bool:
        """Check if match passed.

        Returns:
            True for Pass variant
        """
        match self:
            case Pass: true
            case _: false

    pub fn is_fail(self) -> bool:
        """Check if match failed.

        Returns:
            True for Fail variant
        """
        match self:
            case Fail(_): true
            case _: false

    pub fn get_failure_message(self) -> Option[String]:
        """Get failure message if failed.

        Returns:
            Failure message or None
        """
        match self:
            case Fail(msg): Some(msg)
            case _: None

    pub fn unwrap_failure(self) -> String:
        """Get failure message, panics if passed.

        Returns:
            Failure message

        Panics:
            If result is Pass
        """
        match self:
            case Fail(msg): msg
            case Pass: panic("called unwrap_failure on Pass")

    pub fn to_string(self) -> String:
        """Convert result to string.

        Returns:
            "Pass" or "Fail"
        """
        match self:
            case Pass: "Pass"
            case Fail(_): "Fail"

    pub fn summary(self) -> String:
        """Get summary of match result.

        Returns:
            Human-readable summary

        Example:
            MatchResult::Pass.summary()  # → "MatchResult: Pass"
            MatchResult::Fail("mismatch").summary()
            # → "MatchResult: Fail (mismatch)"
        """
        match self:
            case Pass: "MatchResult: Pass"
            case Fail(msg):
                let preview = if msg.len() > 50:
                    msg.substring(0, 50) + "..."
                else:
                    msg
                "MatchResult: Fail ({preview})"

/// Match actual output against expected
fn match_output(actual: String, expected: Expected) -> MatchResult:
    match expected:
        case Expected.Empty:
            if actual.trim().is_empty:
                return MatchResult.Pass
            else:
                return MatchResult.Fail("Expected no output, got: ${actual}")
        
        case Expected.Output(expected_str):
            if exact_match(actual, expected_str):
                return MatchResult.Pass
            elif wildcard_match(actual, expected_str):
                return MatchResult.Pass
            else:
                return MatchResult.Fail(format_mismatch(actual, expected_str))
        
        case Expected.Exception(exc_type, exc_message):
            return MatchResult.Fail("Expected exception ${exc_type}, got output: ${actual}")

/// Match exception against expected
fn match_exception(exc_type: String, exc_message: String, expected: Expected) -> MatchResult:
    match expected:
        case Expected.Exception(expected_type, expected_msg):
            if exc_type != expected_type:
                return MatchResult.Fail("Expected ${expected_type}, got ${exc_type}")
            
            # Check message if provided
            match expected_msg:
                case Option.Some(msg):
                    if not exc_message.contains(msg):
                        return MatchResult.Fail(
                            "Exception type matched, but message mismatch:\n" +
                            "  Expected: ${msg}\n" +
                            "  Got: ${exc_message}"
                        )
                case Option.None:
                    # Type match is enough
                    pass
            
            return MatchResult.Pass
        
        case _:
            return MatchResult.Fail("Expected output, got exception: ${exc_type}: ${exc_message}")

/// Exact string match (after normalization)
fn exact_match(actual: String, expected: String) -> Bool:
    return normalize(actual) == normalize(expected)

/// Normalize string for comparison (strip trailing whitespace, normalize newlines)
fn normalize(s: String) -> String:
    lines = s.split("\n")
    normalized_lines = lines.map(|line| line.trim_end())
    return normalized_lines.join("\n").trim()

/// Wildcard match: . matches any char, * matches any sequence
fn wildcard_match(actual: String, pattern: String) -> Bool:
    return wildcard_match_impl(actual, pattern, 0, 0)

/// Recursive wildcard matching
fn wildcard_match_impl(text: String, pattern: String, t_idx: Int, p_idx: Int) -> Bool:
    # Base cases
    if p_idx >= pattern.len:
        return t_idx >= text.len
    if t_idx >= text.len:
        # Check if remaining pattern is all *
        for i in p_idx..pattern.len:
            if pattern[i] != '*':
                return False
        return True
    
    current_pattern = pattern[p_idx]
    current_text = text[t_idx]
    
    if current_pattern == '*':
        # Try matching 0, 1, 2, ... characters
        # First try 0 (skip *)
        if wildcard_match_impl(text, pattern, t_idx, p_idx + 1):
            return True
        # Then try 1+ (consume one char and keep *)
        return wildcard_match_impl(text, pattern, t_idx + 1, p_idx)
    
    elif current_pattern == '.' or current_pattern == current_text:
        # Match single char
        return wildcard_match_impl(text, pattern, t_idx + 1, p_idx + 1)
    
    else:
        # No match
        return False

/// Format mismatch message with diff
fn format_mismatch(actual: String, expected: String) -> String:
    return "Output mismatch:\n" +
           "  Expected:\n" +
           "    ${expected}\n" +
           "  Got:\n" +
           "    ${actual}"
