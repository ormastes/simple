/// Doctest Output Matcher
/// 
/// Matches actual output against expected output with support for:
/// - Exact string matching
/// - Wildcard matching (. and *)
/// - Exception matching
/// - Normalized matching (whitespace)

use parser::{Expected, SourceLocation}

# Public exports
export MatchResult, match_output, match_exception
export exact_match, normalize, wildcard_match, format_mismatch

/// Match result
enum MatchResult:
    /// Output matched expected
    Pass
    /// Output did not match
    Fail(String)  # Failure message

/// Match actual output against expected
fn match_output(actual: String, expected: Expected) -> MatchResult:
    match expected:
        case Expected.Empty:
            if actual.trim().is_empty:
                return MatchResult.Pass
            else:
                return MatchResult.Fail("Expected no output, got: ${actual}")
        
        case Expected.Output(expected_str):
            if exact_match(actual, expected_str):
                return MatchResult.Pass
            elif wildcard_match(actual, expected_str):
                return MatchResult.Pass
            else:
                return MatchResult.Fail(format_mismatch(actual, expected_str))
        
        case Expected.Exception(exc_type, exc_message):
            return MatchResult.Fail("Expected exception ${exc_type}, got output: ${actual}")

/// Match exception against expected
fn match_exception(exc_type: String, exc_message: String, expected: Expected) -> MatchResult:
    match expected:
        case Expected.Exception(expected_type, expected_msg):
            if exc_type != expected_type:
                return MatchResult.Fail("Expected ${expected_type}, got ${exc_type}")
            
            # Check message if provided
            match expected_msg:
                case Option.Some(msg):
                    if not exc_message.contains(msg):
                        return MatchResult.Fail(
                            "Exception type matched, but message mismatch:\n" +
                            "  Expected: ${msg}\n" +
                            "  Got: ${exc_message}"
                        )
                case Option.None:
                    # Type match is enough
                    pass
            
            return MatchResult.Pass
        
        case _:
            return MatchResult.Fail("Expected output, got exception: ${exc_type}: ${exc_message}")

/// Exact string match (after normalization)
fn exact_match(actual: String, expected: String) -> Bool:
    return normalize(actual) == normalize(expected)

/// Normalize string for comparison (strip trailing whitespace, normalize newlines)
fn normalize(s: String) -> String:
    lines = s.split("\n")
    normalized_lines = lines.map(|line| line.trim_end())
    return normalized_lines.join("\n").trim()

/// Wildcard match: . matches any char, * matches any sequence
fn wildcard_match(actual: String, pattern: String) -> Bool:
    return wildcard_match_impl(actual, pattern, 0, 0)

/// Recursive wildcard matching
fn wildcard_match_impl(text: String, pattern: String, t_idx: Int, p_idx: Int) -> Bool:
    # Base cases
    if p_idx >= pattern.len:
        return t_idx >= text.len
    if t_idx >= text.len:
        # Check if remaining pattern is all *
        for i in p_idx..pattern.len:
            if pattern[i] != '*':
                return False
        return True
    
    current_pattern = pattern[p_idx]
    current_text = text[t_idx]
    
    if current_pattern == '*':
        # Try matching 0, 1, 2, ... characters
        # First try 0 (skip *)
        if wildcard_match_impl(text, pattern, t_idx, p_idx + 1):
            return True
        # Then try 1+ (consume one char and keep *)
        return wildcard_match_impl(text, pattern, t_idx + 1, p_idx)
    
    elif current_pattern == '.' or current_pattern == current_text:
        # Match single char
        return wildcard_match_impl(text, pattern, t_idx + 1, p_idx + 1)
    
    else:
        # No match
        return False

/// Format mismatch message with diff
fn format_mismatch(actual: String, expected: String) -> String:
    return "Output mismatch:\n" +
           "  Expected:\n" +
           "    ${expected}\n" +
           "  Got:\n" +
           "    ${actual}"
