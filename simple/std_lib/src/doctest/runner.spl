/// Doctest Runner
/// 
/// Executes doctest examples in isolated environment and matches output

use parser::{DoctestExample, Expected}
use matcher::{MatchResult, match_output, match_exception}

/// Execution result for a single example
struct ExampleResult:
    example: DoctestExample
    result: MatchResult
    execution_time_ms: i32

    fn passed() -> bool:
        match self.result:
            case MatchResult.Pass:
                return True
            case _:
                return False

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn failed() -> bool:
        """Check if example failed.

        Returns:
            true if example did not pass

        Example:
            result.failed()  # → false
        """
        return not self.passed()

    fn get_execution_time() -> i32:
        """Get execution time in milliseconds.

        Returns:
            Execution time in ms

        Example:
            result.get_execution_time()  # → 42
        """
        return self.execution_time_ms

    fn is_fast(threshold_ms: i32 = 100) -> bool:
        """Check if execution was fast.

        Args:
            threshold_ms: Maximum time to be considered fast (default: 100ms)

        Returns:
            true if execution time is below threshold

        Example:
            result.is_fast()  # → true
            result.is_fast(threshold_ms: 50)  # → false
        """
        return self.execution_time_ms < threshold_ms

    fn is_slow(threshold_ms: i32 = 1000) -> bool:
        """Check if execution was slow.

        Args:
            threshold_ms: Minimum time to be considered slow (default: 1000ms)

        Returns:
            true if execution time exceeds threshold

        Example:
            result.is_slow()  # → false
        """
        return self.execution_time_ms >= threshold_ms

    fn summary() -> text:
        """Get result summary.

        Returns:
            Human-readable summary

        Example:
            result.summary()
            # → "ExampleResult: PASS (42ms)"
        """
        val status = if self.passed() { "PASS" } else { "FAIL" }
        return "ExampleResult: {status} ({self.execution_time_ms}ms)"

/// Runner for executing doctests
struct DoctestRunner:
    /// Timeout for each example (ms)
    default_timeout_ms: i32
    
    /// Create new runner with default timeout
    fn new(timeout_ms: i32 = 5000) -> DoctestRunner:
        return DoctestRunner(default_timeout_ms: timeout_ms)
    
    /// Run a single doctest example
    fn run_example(example: DoctestExample) -> ExampleResult:
        start_time = current_time_ms()
        
        # Create isolated interpreter context
        ctx = create_interpreter_context()
        
        # Execute setup (suppress output)
        for setup_line in example.setup:
            try:
                execute_line(ctx, setup_line, capture_output: False)
            catch e:
                # Setup failure is a test failure
                return ExampleResult(
                    example: example,
                    result: MatchResult.Fail("Setup failed: ${e}"),
                    execution_time_ms: current_time_ms() - start_time
                )
        
        # Execute main code
        actual_output = ""
        exception_raised = None
        
        for code_line in example.code:
            try:
                output = execute_line(ctx, code_line, capture_output: True)
                actual_output += output
            catch e:
                # Extract exception type and message
                exception_raised = (e.type_name(), e.message())
                break
        
        # Execute teardown (suppress output, ignore errors)
        for teardown_line in example.teardown:
            try:
                execute_line(ctx, teardown_line, capture_output: False)
            catch _:
                # Teardown errors are logged but don't fail test
                pass
        
        # Match result
        result = if exception_raised is None:
            match_output(actual_output.trim(), example.expected)
        else:
            (exc_type, exc_msg) = exception_raised
            match_exception(exc_type, exc_msg, example.expected)
        
        execution_time = current_time_ms() - start_time
        
        return ExampleResult(
            example: example,
            result: result,
            execution_time_ms: execution_time
        )
    
    /// Run multiple examples
    fn run_examples(examples: List<DoctestExample>) -> List<ExampleResult>:
        results = []
        for ex in examples:
            results.push(self.run_example(ex))
        return results

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_timeout() -> i32:
        """Get default timeout in milliseconds.

        Returns:
            Default timeout for each example

        Example:
            runner.get_timeout()  # → 5000
        """
        return self.default_timeout_ms

    fn with_timeout(timeout_ms: i32) -> DoctestRunner:
        """Create runner with specific timeout.

        Args:
            timeout_ms: Timeout in milliseconds

        Returns:
            New DoctestRunner with specified timeout

        Example:
            runner = DoctestRunner.with_timeout(3000)
        """
        return DoctestRunner.new(timeout_ms: timeout_ms)

    fn count_results(results: List<ExampleResult>) -> (i32, i32):
        """Count passed and failed examples.

        Args:
            results: List of example results

        Returns:
            Tuple of (passed_count, failed_count)

        Example:
            (passed, failed) = runner.count_results(results)
        """
        var passed = 0
        var failed = 0
        for result in results:
            if result.passed():
                passed = passed + 1
            else:
                failed = failed + 1
        return (passed, failed)

    fn all_passed(results: List<ExampleResult>) -> bool:
        """Check if all examples passed.

        Args:
            results: List of example results

        Returns:
            true if all examples passed

        Example:
            runner.all_passed(results)  # → true
        """
        for result in results:
            if result.failed():
                return False
        return True

    fn summary() -> text:
        """Get runner summary.

        Returns:
            Human-readable summary

        Example:
            runner.summary()
            # → "DoctestRunner: timeout=5000ms"
        """
        return "DoctestRunner: timeout={self.default_timeout_ms}ms"

# Interpreter context (placeholder - will integrate with actual interpreter)
struct InterpreterContext:
    env: Dict<text, Value>

static fn create_interpreter_context() -> InterpreterContext:
    return InterpreterContext(env: Dict.new())

fn execute_line(ctx: InterpreterContext, code: text, capture_output: bool) -> text:
    # TODO: [stdlib][P3] Integrate with actual Simple interpreter
    # For now, return mock output
    return ""

fn current_time_ms() -> i32:
    @extern("runtime", "rt_time_millis")
    fn _rt_time_millis() -> i64

    return _rt_time_millis() as i32

# Value placeholder
type Value = Any
