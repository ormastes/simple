# DSL Features Module
# Provides DSL building blocks for domain-specific languages
#
# Features:
# - #1066: context blocks
# - #1067: method_missing handler
# - #1068: Fluent interface support

# Context Block Support (#1066)
#
# Context blocks allow temporarily changing the receiver for method calls
# Syntax: context obj: ...

class ContextBuilder:
    """
    Helper for building objects with context blocks.

    Example:
        builder = ContextBuilder()
        context builder:
            set_name("Alice")
            set_age(30)
            add_tag("developer")
        # All methods called on builder
    """

    fn __init__(self):
        self.data = {}

    fn set(self, key, value):
        self.data[key] = value
        return self  # Fluent interface

    fn get(self, key):
        return self.data.get(key)


# Method Missing Handler (#1067)
#
# Allows objects to handle undefined method calls dynamically

trait MethodMissing:
    """
    Trait for handling missing methods dynamically.

    Implementers can intercept calls to undefined methods.

    Example:
        class DynamicObject:
            fn method_missing(self, name, args):
                print("Called {name} with {args}")
                return nil

        obj = DynamicObject()
        obj.unknown_method(1, 2, 3)
        # Prints: Called unknown_method with (1, 2, 3)
    """

    fn method_missing(self, method_name: str, args):
        """
        Handle a call to an undefined method.

        Args:
            method_name: Name of the missing method
            args: Arguments passed to the method

        Returns:
            The value to return from the method call
        """
        pass


class DynamicProxy:
    """
    Proxy that delegates all method calls to a handler.

    Example:
        def handler(name, args):
            print("Method {name} called")
            return 42

        proxy = DynamicProxy(handler)
        result = proxy.anything(1, 2, 3)
        # Prints: Method anything called
        # Returns: 42
    """

    fn __init__(self, handler):
        self.handler = handler

    fn method_missing(self, name, args):
        return self.handler(name, args)


class AttributeDict:
    """
    Dictionary that allows attribute-style access.

    Example:
        obj = AttributeDict()
        obj.name = "Alice"
        obj.age = 30
        print(obj.name)  # "Alice"
    """

    fn __init__(self):
        self.data = {}

    fn __getattr__(self, name):
        return self.data.get(name)

    fn __setattr__(self, name, value):
        if name == "data":
            # Special case for internal data storage
            self.data = value
        else:
            self.data[name] = value

    fn method_missing(self, name, args):
        # Allow method calls to be stored as well
        self.data[name] = args
        return self


# Fluent Interface Support (#1068)
#
# Patterns for building fluent/chainable APIs

class FluentBuilder:
    """
    Base class for fluent/builder pattern.

    Methods return self to enable chaining.

    Example:
        class PersonBuilder(FluentBuilder):
            fn with_name(self, name):
                self.name = name
                return self

            fn with_age(self, age):
                self.age = age
                return self

            fn build(self):
                return Person(self.name, self.age)

        person = PersonBuilder()
            .with_name("Alice")
            .with_age(30)
            .build()
    """

    fn __init__(self):
        pass


class QueryBuilder:
    """
    Example of fluent interface for building queries.

    Example:
        query = QueryBuilder()
            .select("name", "age")
            .from_table("users")
            .where("age > 18")
            .order_by("name")
            .limit(10)

        sql = query.to_sql()
    """

    fn __init__(self):
        self.select_fields = []
        self.table = nil
        self.where_clause = nil
        self.order_field = nil
        self.limit_count = nil

    fn select(self, *fields):
        self.select_fields = fields
        return self  # Fluent chaining

    fn from_table(self, table):
        self.table = table
        return self

    fn where(self, condition):
        self.where_clause = condition
        return self

    fn order_by(self, field):
        self.order_field = field
        return self

    fn limit(self, count):
        self.limit_count = count
        return self

    fn to_sql(self):
        fields = ", ".join(self.select_fields)
        sql = "SELECT {fields} FROM {self.table}"

        if self.where_clause:
            sql = sql + " WHERE {self.where_clause}"

        if self.order_field:
            sql = sql + " ORDER BY {self.order_field}"

        if self.limit_count:
            sql = sql + " LIMIT {self.limit_count}"

        return sql


class Pipeline:
    """
    Fluent pipeline for data transformation.

    Example:
        result = Pipeline([1, 2, 3, 4, 5])
            .map(fn(x): x * 2)
            .filter(fn(x): x > 5)
            .reduce(fn(a, b): a + b)

        # result = 18 (6 + 8 + 10)
    """

    fn __init__(self, data):
        self.data = data

    fn map(self, mapper):
        self.data = [mapper(x) for x in self.data]
        return self

    fn filter(self, predicate):
        self.data = [x for x in self.data if predicate(x)]
        return self

    fn reduce(self, reducer):
        result = self.data[0]
        for item in self.data[1:]:
            result = reducer(result, item)
        return result

    fn collect(self):
        return self.data


# DSL Helper Functions

fn dsl_builder(initial_context = nil):
    """
    Create a context-aware DSL builder.

    Example:
        builder = dsl_builder()
        context builder:
            add("item1")
            add("item2")
            set_title("My List")
    """
    return ContextBuilder()


fn fluent(obj):
    """
    Wrap an object to make all methods return self (fluent interface).

    Example:
        class Config:
            fn set_host(self, host):
                self.host = host

            fn set_port(self, port):
                self.port = port

        config = fluent(Config())
            .set_host("localhost")
            .set_port(8080)
    """
    # In a full implementation, this would wrap methods
    return obj
