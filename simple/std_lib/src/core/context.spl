# Context Manager Module
# Provides the ContextManager trait for resource management with `with` statements
#
# Feature #1092: ContextManager trait

trait ContextManager:
    """
    Context manager protocol for use with `with` statements.

    Implementers must define __enter__ and __exit__ methods to manage
    resource acquisition and cleanup.

    Example:
        class FileHandle:
            fn __enter__(self):
                # Acquire resource
                return self

            fn __exit__(self, exc_type, exc_value, traceback):
                # Release resource
                self.close()

        with FileHandle("file.txt") as f:
            # Use f
            pass
        # f.__exit__ automatically called here
    """

    fn __enter__(self):
        """
        Enter the context. Called when entering a `with` block.
        Returns the resource to be bound to the `as` variable.
        """
        pass

    fn __exit__(self, exc_type, exc_value, traceback):
        """
        Exit the context. Called when leaving a `with` block.

        Args:
            exc_type: Exception type if an exception occurred, nil otherwise
            exc_value: Exception value if an exception occurred, nil otherwise
            traceback: Exception traceback if an exception occurred, nil otherwise

        Returns:
            true to suppress the exception, false to propagate it
        """
        pass


# Example Context Managers

class Timer:
    """
    Context manager that times code execution.

    Example:
        with Timer("operation") as t:
            # ... code to time ...
            pass
        # Prints: operation took 1.23s
    """

    fn __init__(self, name):
        self.name = name
        self.start_time = 0

    fn __enter__(self):
        self.start_time = time_now()
        return self

    fn __exit__(self, exc_type, exc_value, traceback):
        elapsed = time_now() - self.start_time
        print("{self.name} took {elapsed}s")
        return false  # Don't suppress exceptions


class Lock:
    """
    Context manager for lock acquisition/release.

    Example:
        lock = Lock()
        with lock:
            # Critical section - lock held
            pass
        # Lock automatically released
    """

    fn __init__(self):
        self.locked = false

    fn __enter__(self):
        self.acquire()
        return self

    fn __exit__(self, exc_type, exc_value, traceback):
        self.release()
        return false

    fn acquire(self):
        # TODO: Implement actual locking
        self.locked = true

    fn release(self):
        self.locked = false


class TransactionContext:
    """
    Context manager for database-like transactions.

    Example:
        with TransactionContext() as tx:
            # ... perform operations ...
            if error:
                tx.rollback()
        # Automatically commits or rolls back
    """

    fn __init__(self):
        self.committed = false
        self.rolled_back = false

    fn __enter__(self):
        self.begin()
        return self

    fn __exit__(self, exc_type, exc_value, traceback):
        if exc_type or self.rolled_back:
            self.rollback()
        else:
            self.commit()
        return false

    fn begin(self):
        print("[TX] Transaction started")

    fn commit(self):
        if not self.rolled_back:
            self.committed = true
            print("[TX] Transaction committed")

    fn rollback(self):
        self.rolled_back = true
        print("[TX] Transaction rolled back")


# Helper function to create context managers from callables

fn contextmanager(enter_fn, exit_fn):
    """
    Create a context manager from enter/exit functions.

    Example:
        def my_enter():
            print("Entering")
            return "resource"

        def my_exit(exc_type, exc_value, tb):
            print("Exiting")
            return false

        cm = contextmanager(my_enter, my_exit)
        with cm as resource:
            print("Using {resource}")
    """
    class CustomContextManager:
        fn __enter__(self):
            return enter_fn()

        fn __exit__(self, exc_type, exc_value, traceback):
            return exit_fn(exc_type, exc_value, traceback)

    return CustomContextManager()


# Utility context managers

fn suppress(*exception_types):
    """
    Context manager that suppresses specified exception types.

    Example:
        with suppress(ValueError, KeyError):
            # Code that might raise ValueError or KeyError
            raise ValueError("This will be suppressed")
        # Execution continues normally
    """
    class SuppressContext:
        fn __init__(self, exceptions):
            self.exceptions = exceptions

        fn __enter__(self):
            return self

        fn __exit__(self, exc_type, exc_value, traceback):
            if exc_type in self.exceptions:
                return true  # Suppress
            return false  # Propagate

    return SuppressContext(exception_types)
