# Graph - Graph data structures and algorithms
# Provides directed/undirected graphs with advanced algorithms

# Edge representation
pub class Edge:
    source: i32
    target: i32
    weight: f32

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_self_loop(self) -> bool:
        """Check if this edge is a self-loop (source == target)."""
        return self.source == self.target

    pub fn is_weighted(self) -> bool:
        """Check if this edge has a weight other than 1.0."""
        return self.weight != 1.0

    pub fn is_negative(self) -> bool:
        """Check if this edge has negative weight."""
        return self.weight < 0.0

    pub fn reverse(self) -> Edge:
        """Create a reversed edge (swap source and target)."""
        return Edge.new(self.target, self.source, self.weight)

    pub fn summary(self) -> text:
        """Get summary of edge."""
        return "Edge: {self.source} -> {self.target} (weight={self.weight})"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new(source: i32, target: i32, weight: f32 = 1.0) -> Edge:
        return Edge {
            source: source,
            target: target,
            weight: weight
        }

# Graph representation using adjacency list
pub class Graph:
    vertices: i32
    edges: List<Edge>
    # Nested generics in field types now supported
    adjacency: Dict<i32, List<i32>>
    directed: bool

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if graph has no edges."""
        return self.edges.len() == 0

    pub fn has_edges(self) -> bool:
        """Check if graph has any edges."""
        return self.edges.len() > 0

    pub fn has_vertices(self) -> bool:
        """Check if graph has vertices."""
        return self.vertices > 0

    pub fn is_directed(self) -> bool:
        """Check if graph is directed."""
        return self.directed

    pub fn is_undirected(self) -> bool:
        """Check if graph is undirected."""
        return not self.directed

    pub fn vertex_exists(self, vertex: i32) -> bool:
        """Check if vertex index is valid."""
        return vertex >= 0 and vertex < self.vertices

    pub fn degree(self, vertex: i32) -> i32:
        """Get degree of vertex (number of connections)."""
        if self.adjacency.has_key(vertex):
            return self.adjacency.get(vertex).len()
        return 0

    pub fn out_degree(self, vertex: i32) -> i32:
        """Get out-degree of vertex (for directed graphs)."""
        return self.degree(vertex)

    pub fn in_degree(self, vertex: i32) -> i32:
        """Get in-degree of vertex (for directed graphs)."""
        var count = 0
        for edge in self.edges:
            if edge.target == vertex:
                count = count + 1
        return count

    pub fn density(self) -> f32:
        """Calculate graph density (ratio of edges to max possible edges)."""
        if self.vertices <= 1:
            return 0.0

        val max_edges = if self.directed:
            self.vertices * (self.vertices - 1)
        else:
            self.vertices * (self.vertices - 1) / 2

        return (self.edges.len() as f32) / (max_edges as f32)

    pub fn is_complete(self) -> bool:
        """Check if graph is complete (all vertices connected)."""
        val expected_edges = if self.directed:
            self.vertices * (self.vertices - 1)
        else:
            self.vertices * (self.vertices - 1) / 2

        return self.edges.len() == expected_edges

    pub fn has_self_loops(self) -> bool:
        """Check if graph contains any self-loops."""
        for edge in self.edges:
            if edge.is_self_loop():
                return True
        return False

    pub fn has_negative_edges(self) -> bool:
        """Check if graph contains any edges with negative weights."""
        for edge in self.edges:
            if edge.is_negative():
                return True
        return False

    pub fn get_edge_weight(self, source: i32, target: i32) -> Option<f32>:
        """Get weight of edge from source to target."""
        for edge in self.edges:
            if edge.source == source and edge.target == target:
                return Some(edge.weight)
        return None

    pub fn summary(self) -> text:
        """Get summary of graph."""
        val graph_type = if self.directed: "directed" else: "undirected"
        val dens = (self.density() * 100.0) as i32
        return "Graph: {self.vertices} vertices, {self.edge_count()} edges ({graph_type}, {dens}% dense)"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new(vertices: i32, directed: bool = False) -> Graph:
        return Graph {
            vertices: vertices,
            edges: [],
            adjacency: {},
            directed: directed
        }

    pub fn add_edge(self, source: i32, target: i32, weight: f32 = 1.0):
        val edge = Edge.new(source, target, weight)
        self.edges.append(edge)

        # Add to adjacency list
        if not self.adjacency.has_key(source):
            self.adjacency.set(source, [])
        self.adjacency.get(source).append(target)

        # For undirected graphs, add reverse edge
        if not self.directed:
            if not self.adjacency.has_key(target):
                self.adjacency.set(target, [])
            self.adjacency.get(target).append(source)

    pub fn get_neighbors(self, vertex: i32) -> List<i32>:
        if self.adjacency.has_key(vertex):
            return self.adjacency.get(vertex)
        return []

    pub fn has_edge(self, source: i32, target: i32) -> bool:
        val neighbors = self.get_neighbors(source)
        return neighbors.contains(target)

    pub fn edge_count(self) -> i32:
        return self.edges.len()

    pub fn vertex_count(self) -> i32:
        return self.vertices

# Depth-First Search
pub fn dfs(graph: Graph, start: i32, visited: Dict<i32, bool> = None) -> List<i32>:
    if visited.is_none():
        visited = {}

    var result = []
    var stack = [start]

    while stack.len() > 0:
        val vertex = stack.pop()

        if not visited.get_or_default(vertex, False):
            visited.set(vertex, True)
            result.append(vertex)

            # Add neighbors to stack
            val neighbors = graph.get_neighbors(vertex)
            for neighbor in neighbors.reverse():
                if not visited.get_or_default(neighbor, False):
                    stack.append(neighbor)

    return result

# Breadth-First Search
pub fn bfs(graph: Graph, start: i32) -> List<i32>:
    var visited = {}
    var result = []
    var queue = [start]

    visited.set(start, True)

    while queue.len() > 0:
        val vertex = queue.remove(0)  # Dequeue
        result.append(vertex)

        # Add neighbors to queue
        val neighbors = graph.get_neighbors(vertex)
        for neighbor in neighbors:
            if not visited.get_or_default(neighbor, False):
                visited.set(neighbor, True)
                queue.append(neighbor)

    return result

# Dijkstra's shortest path algorithm
pub fn dijkstra(graph: Graph, start: i32) -> Dict<i32, f32>:
    var distances = {}
    var visited = {}
    var pq = []  # Priority queue (vertex, distance) pairs

    # Initialize distances
    for v in 0..graph.vertices:
        distances.set(v, f32.INFINITY)

    distances.set(start, 0.0)
    pq.append((start, 0.0))

    while pq.len() > 0:
        # Find minimum distance vertex (simple linear search)
        var min_idx = 0
        var min_dist = f32.INFINITY

        for i in 0..pq.len():
            val pair = pq[i]
            if pair.1 < min_dist:
                min_dist = pair.1
                min_idx = i

        val current_pair = pq.remove(min_idx)
        val current = current_pair.0
        val current_dist = current_pair.1

        if visited.get_or_default(current, False):
            continue

        visited.set(current, True)

        # Update distances to neighbors
        val neighbors = graph.get_neighbors(current)
        for neighbor in neighbors:
            if not visited.get_or_default(neighbor, False):
                # Find edge weight
                var edge_weight = 1.0
                for edge in graph.edges:
                    if edge.source == current and edge.target == neighbor:
                        edge_weight = edge.weight
                        break

                val new_dist = current_dist + edge_weight

                if new_dist < distances.get(neighbor):
                    distances.set(neighbor, new_dist)
                    pq.append((neighbor, new_dist))

    return distances

# Bellman-Ford algorithm (handles negative weights)
pub fn bellman_ford(graph: Graph, start: i32) -> Option<Dict<i32, f32>>:
    var distances = {}

    # Initialize distances
    for v in 0..graph.vertices:
        distances.set(v, f32.INFINITY)

    distances.set(start, 0.0)

    # Relax edges V-1 times
    for _ in 0..(graph.vertices - 1):
        for edge in graph.edges:
            val u = edge.source
            val v = edge.target
            val w = edge.weight

            if distances.get(u) + w < distances.get(v):
                distances.set(v, distances.get(u) + w)

    # Check for negative cycles
    for edge in graph.edges:
        val u = edge.source
        val v = edge.target
        val w = edge.weight

        if distances.get(u) + w < distances.get(v):
            return None  # Negative cycle detected

    return Some(distances)

# Topological sort (for DAGs)
pub fn topological_sort(graph: Graph) -> Option<List<i32>>:
    if not graph.directed:
        return None  # Only works on directed graphs

    var in_degree = {}
    var result = []

    # Calculate in-degrees
    for v in 0..graph.vertices:
        in_degree.set(v, 0)

    for edge in graph.edges:
        val current = in_degree.get(edge.target)
        in_degree.set(edge.target, current + 1)

    # Find vertices with in-degree 0
    var queue = []
    for v in 0..graph.vertices:
        if in_degree.get(v) == 0:
            queue.append(v)

    # Process vertices
    while queue.len() > 0:
        val vertex = queue.remove(0)
        result.append(vertex)

        # Reduce in-degree of neighbors
        val neighbors = graph.get_neighbors(vertex)
        for neighbor in neighbors:
            val current = in_degree.get(neighbor)
            in_degree.set(neighbor, current - 1)

            if in_degree.get(neighbor) == 0:
                queue.append(neighbor)

    # Check if all vertices processed (no cycle)
    if result.len() != graph.vertices:
        return None  # Cycle detected

    return Some(result)

# Detect cycle in directed graph
pub fn has_cycle_directed(graph: Graph) -> bool:
    var visited = {}
    var rec_stack = {}

    fn dfs_cycle(v: i32) -> bool:
        visited.set(v, True)
        rec_stack.set(v, True)

        val neighbors = graph.get_neighbors(v)
        for neighbor in neighbors:
            if not visited.get_or_default(neighbor, False):
                if dfs_cycle(neighbor):
                    return True
            elif rec_stack.get_or_default(neighbor, False):
                return True

        rec_stack.set(v, False)
        return False

    for v in 0..graph.vertices:
        if not visited.get_or_default(v, False):
            if dfs_cycle(v):
                return True

    return False

# Detect cycle in undirected graph
pub fn has_cycle_undirected(graph: Graph) -> bool:
    var visited = {}

    fn dfs_cycle(v: i32, parent: i32) -> bool:
        visited.set(v, True)

        val neighbors = graph.get_neighbors(v)
        for neighbor in neighbors:
            if not visited.get_or_default(neighbor, False):
                if dfs_cycle(neighbor, v):
                    return True
            elif neighbor != parent:
                return True

        return False

    for v in 0..graph.vertices:
        if not visited.get_or_default(v, False):
            if dfs_cycle(v, -1):
                return True

    return False

# Find connected components
pub fn connected_components(graph: Graph) -> List<List<i32>>:
    var visited = {}
    var components = []

    for v in 0..graph.vertices:
        if not visited.get_or_default(v, False):
            val component = dfs(graph, v, visited)
            components.append(component)

    return components

# Check if graph is bipartite (2-colorable)
pub fn is_bipartite(graph: Graph) -> bool:
    var color = {}

    for v in 0..graph.vertices:
        color.set(v, -1)

    for start in 0..graph.vertices:
        if color.get(start) == -1:
            var queue = [start]
            color.set(start, 0)

            while queue.len() > 0:
                val vertex = queue.remove(0)
                val neighbors = graph.get_neighbors(vertex)

                for neighbor in neighbors:
                    if color.get(neighbor) == -1:
                        color.set(neighbor, 1 - color.get(vertex))
                        queue.append(neighbor)
                    elif color.get(neighbor) == color.get(vertex):
                        return False

    return True

# Minimum Spanning Tree - Kruskal's algorithm
pub fn kruskal_mst(graph: Graph) -> List<Edge>:
    # Sort edges by weight
    var sorted_edges = graph.edges.copy()
    # Simple bubble sort
    for i in 0..sorted_edges.len():
        for j in 0..(sorted_edges.len() - i - 1):
            if sorted_edges[j].weight > sorted_edges[j + 1].weight:
                val temp = sorted_edges[j]
                sorted_edges[j] = sorted_edges[j + 1]
                sorted_edges[j + 1] = temp

    # Union-Find data structure
    var parent = {}
    var rank = {}

    fn find(x: i32) -> i32:
        if parent.get(x) != x:
            parent.set(x, find(parent.get(x)))
        return parent.get(x)

    fn union(x: i32, y: i32):
        val px = find(x)
        val py = find(y)

        if px == py:
            return

        if rank.get(px) < rank.get(py):
            parent.set(px, py)
        elif rank.get(px) > rank.get(py):
            parent.set(py, px)
        else:
            parent.set(py, px)
            rank.set(px, rank.get(px) + 1)

    # Initialize union-find
    for v in 0..graph.vertices:
        parent.set(v, v)
        rank.set(v, 0)

    # Build MST
    var mst = []

    for edge in sorted_edges:
        if find(edge.source) != find(edge.target):
            mst.append(edge)
            union(edge.source, edge.target)

    return mst

# Export all types and functions
export Edge
export Graph
export dfs
export bfs
export dijkstra
export bellman_ford
export topological_sort
export has_cycle_directed
export has_cycle_undirected
export connected_components
export is_bipartite
export kruskal_mst
