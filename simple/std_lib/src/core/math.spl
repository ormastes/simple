# Math - Mathematical functions and constants for Simple
# Provides trigonometric, exponential, logarithmic, and utility functions

# Mathematical Constants (use functions since pub let not supported)
pub fn PI() -> Float:
    return 3.141592653589793

pub fn E() -> Float:
    return 2.718281828459045

pub fn TAU() -> Float:
    return 6.283185307179586

pub fn INF() -> Float:
    return 1.0 / 0.0

pub fn NAN() -> Float:
    return 0.0 / 0.0

# Absolute value
pub fn abs(x: Float) -> Float:
    if x < 0.0:
        return -x
    return x

pub fn abs_int(x: Int) -> Int:
    if x < 0:
        return -x
    return x

# Sign function
pub fn sign(x: Float) -> Float:
    if x > 0.0:
        return 1.0
    elif x < 0.0:
        return -1.0
    else:
        return 0.0

# Floor, ceiling, and rounding
pub fn floor(x: Float) -> Int:
    # TODO: Use FFI to call Rust/C floor function
    let i = x as Int
    if x >= 0.0 or x == i as Float:
        return i
    else:
        return i - 1

pub fn ceil(x: Float) -> Int:
    # TODO: Use FFI to call Rust/C ceil function
    let i = x as Int
    if x <= 0.0 or x == i as Float:
        return i
    else:
        return i + 1

pub fn round(x: Float) -> Int:
    if x >= 0.0:
        return floor(x + 0.5)
    else:
        return ceil(x - 0.5)

pub fn trunc(x: Float) -> Int:
    return x as Int

# Power and roots
pub fn pow(base: Float, exp: Float) -> Float:
    # TODO: Implement using FFI or Taylor series
    # For now, stub implementation
    return 1.0

pub fn sqrt(x: Float) -> Float:
    # Newton-Raphson method for square root
    if x < 0.0:
        return NAN
    if x == 0.0:
        return 0.0

    let mut guess = x / 2.0
    let epsilon = 0.000001

    # Iterate until convergence
    for _ in 0..50:
        let new_guess = (guess + x / guess) / 2.0
        if abs(new_guess - guess) < epsilon:
            return new_guess
        guess = new_guess

    return guess

pub fn cbrt(x: Float) -> Float:
    # Cube root using Newton-Raphson
    # TODO: Implement properly
    return 1.0

# Exponential and logarithm
pub fn exp(x: Float) -> Float:
    # e^x using Taylor series
    # e^x = 1 + x + x^2/2! + x^3/3! + ...
    # TODO: Implement using FFI for better precision
    let mut result = 1.0
    let mut term = 1.0
    let iterations = 20

    for n in 1..iterations:
        term = term * x / (n as Float)
        result = result + term
        if abs(term) < 0.000001:
            break

    return result

pub fn log(x: Float) -> Float:
    # Natural logarithm
    # TODO: Implement using FFI or series expansion
    if x <= 0.0:
        return NAN
    return 0.0  # Stub

pub fn log10(x: Float) -> Float:
    # Base-10 logarithm
    # log10(x) = ln(x) / ln(10)
    return log(x) / log(10.0)

pub fn log2(x: Float) -> Float:
    # Base-2 logarithm
    # log2(x) = ln(x) / ln(2)
    return log(x) / log(2.0)

# Trigonometric functions (TODO: Implement using Taylor series or FFI)
pub fn sin(x: Float) -> Float:
    # Taylor series: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    # Normalize x to [-π, π]
    let mut angle = x
    while angle > PI:
        angle = angle - TAU
    while angle < -PI:
        angle = angle + TAU

    let mut result = 0.0
    let mut term = angle
    let mut sign = 1.0
    let iterations = 15

    for n in 0..iterations:
        result = result + sign * term
        let k = (2 * n + 3) as Float
        term = term * angle * angle / ((k - 1.0) * k)
        sign = -sign

        if abs(term) < 0.000001:
            break

    return result

pub fn cos(x: Float) -> Float:
    # cos(x) = sin(x + π/2)
    return sin(x + PI / 2.0)

pub fn tan(x: Float) -> Float:
    let c = cos(x)
    if abs(c) < 0.000001:
        return INF
    return sin(x) / c

# Inverse trigonometric functions
pub fn asin(x: Float) -> Float:
    # TODO: Implement using Taylor series or FFI
    if x < -1.0 or x > 1.0:
        return NAN
    return 0.0  # Stub

pub fn acos(x: Float) -> Float:
    # acos(x) = π/2 - asin(x)
    return PI / 2.0 - asin(x)

pub fn atan(x: Float) -> Float:
    # TODO: Implement using Taylor series or FFI
    return 0.0  # Stub

pub fn atan2(y: Float, x: Float) -> Float:
    # Two-argument arctangent
    # TODO: Implement properly handling all quadrants
    if x > 0.0:
        return atan(y / x)
    return 0.0  # Stub

# Hyperbolic functions
pub fn sinh(x: Float) -> Float:
    # sinh(x) = (e^x - e^(-x)) / 2
    return (exp(x) - exp(-x)) / 2.0

pub fn cosh(x: Float) -> Float:
    # cosh(x) = (e^x + e^(-x)) / 2
    return (exp(x) + exp(-x)) / 2.0

pub fn tanh(x: Float) -> Float:
    # tanh(x) = sinh(x) / cosh(x)
    let ex = exp(x)
    let enx = exp(-x)
    return (ex - enx) / (ex + enx)

# Utility functions
pub fn min(a: Float, b: Float) -> Float:
    if a < b:
        return a
    return b

pub fn max(a: Float, b: Float) -> Float:
    if a > b:
        return a
    return b

pub fn min_int(a: Int, b: Int) -> Int:
    if a < b:
        return a
    return b

pub fn max_int(a: Int, b: Int) -> Int:
    if a > b:
        return a
    return b

pub fn clamp(x: Float, min_val: Float, max_val: Float) -> Float:
    if x < min_val:
        return min_val
    if x > max_val:
        return max_val
    return x

pub fn clamp_int(x: Int, min_val: Int, max_val: Int) -> Int:
    if x < min_val:
        return min_val
    if x > max_val:
        return max_val
    return x

# Degree/radian conversion
pub fn radians(degrees: Float) -> Float:
    return degrees * PI / 180.0

pub fn degrees(radians: Float) -> Float:
    return radians * 180.0 / PI

# Factorial
pub fn factorial(n: Int) -> Int:
    if n < 0:
        return 0
    if n == 0 or n == 1:
        return 1

    let mut result = 1
    for i in 2..(n + 1):
        result = result * i

    return result

# Greatest common divisor
pub fn gcd(a: Int, b: Int) -> Int:
    let mut x = abs_int(a)
    let mut y = abs_int(b)

    while y != 0:
        let temp = y
        y = x % y
        x = temp

    return x

# Least common multiple
pub fn lcm(a: Int, b: Int) -> Int:
    if a == 0 or b == 0:
        return 0
    return abs_int(a * b) / gcd(a, b)

# Check if number is close to another (for floating-point comparisons)
pub fn isclose(a: Float, b: Float, rel_tol: Float = 0.000001, abs_tol: Float = 0.0) -> Bool:
    let diff = abs(a - b)
    return diff <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

# Check for special values
pub fn isnan(x: Float) -> Bool:
    return x != x

pub fn isinf(x: Float) -> Bool:
    return x == INF() or x == -INF()

pub fn isfinite(x: Float) -> Bool:
    return not isnan(x) and not isinf(x)

# Export all functions and constants
export PI
export E
export TAU
export INF
export NAN
export abs
export abs_int
export sign
export floor
export ceil
export round
export trunc
export pow
export sqrt
export cbrt
export exp
export log
export log10
export log2
export sin
export cos
export tan
export asin
export acos
export atan
export atan2
export sinh
export cosh
export tanh
export min
export max
export min_int
export max_int
export clamp
export clamp_int
export radians
export degrees
export factorial
export gcd
export lcm
export isclose
export isnan
export isinf
export isfinite
