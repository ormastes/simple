# JSON - JSON parsing and serialization
# Simple JSON support for data interchange

# JSON value type
pub enum JsonValue:
    Null
    Bool(bool)
    Number(f64)
    Integer(i64)
    String(String)
    Array(List[JsonValue])
    Object(Dict[String, JsonValue])

impl JsonValue:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert JSON value type to string."""
        match self:
            case Null: return "Null"
            case Bool(_): return "Bool"
            case Number(_): return "Number"
            case Integer(_): return "Integer"
            case String(_): return "String"
            case Array(_): return "Array"
            case Object(_): return "Object"

    pub fn description(self) -> String:
        """Get detailed description of JSON value."""
        match self:
            case Null: return "Null value"
            case Bool(b): return "Boolean: {b}"
            case Number(n): return "Number: {n}"
            case Integer(i): return "Integer: {i}"
            case String(s): return "String: \"{s}\""
            case Array(arr): return "Array with {arr.len()} items"
            case Object(obj): return "Object with {obj.len()} fields"

    pub fn is_null(self) -> bool:
        """Check if this is a Null value."""
        match self:
            case Null: true
            case _: false

    pub fn is_bool(self) -> bool:
        """Check if this is a Boolean value."""
        match self:
            case Bool(_): true
            case _: false

    pub fn is_number(self) -> bool:
        """Check if this is a Number (f64) value."""
        match self:
            case Number(_): true
            case _: false

    pub fn is_integer(self) -> bool:
        """Check if this is an Integer (i64) value."""
        match self:
            case Integer(_): true
            case _: false

    pub fn is_string(self) -> bool:
        """Check if this is a String value."""
        match self:
            case String(_): true
            case _: false

    pub fn is_array(self) -> bool:
        """Check if this is an Array value."""
        match self:
            case Array(_): true
            case _: false

    pub fn is_object(self) -> bool:
        """Check if this is an Object value."""
        match self:
            case Object(_): true
            case _: false

    pub fn is_primitive(self) -> bool:
        """Check if this is a primitive value (not array or object)."""
        match self:
            case Array(_): false
            case Object(_): false
            case _: true

    pub fn is_collection(self) -> bool:
        """Check if this is a collection (array or object)."""
        match self:
            case Array(_): true
            case Object(_): true
            case _: false

    pub fn is_numeric(self) -> bool:
        """Check if this is a numeric value (number or integer)."""
        match self:
            case Number(_): true
            case Integer(_): true
            case _: false

    pub fn is_truthy(self) -> bool:
        """Check if value is truthy (non-null, non-false, non-zero, non-empty)."""
        match self:
            case Null: false
            case Bool(b): b
            case Number(n): n != 0.0
            case Integer(i): i != 0
            case String(s): s.len() > 0
            case Array(arr): arr.len() > 0
            case Object(obj): obj.len() > 0

# Helper: check if a character is a digit
fn is_digit(ch: String) -> bool:
    if ch.len() == 0:
        return false
    code = ch.ord()
    return code >= 48 and code <= 57  # '0' is 48, '9' is 57

# JSON Parser state
class JsonParser:
    input: String
    pos: i64
    len: i64

    fn new(input: String) -> JsonParser:
        return JsonParser { input: input, pos: 0, len: input.len() }

    fn peek(self) -> Option[String]:
        if self.pos >= self.len:
            return None
        return Some(self.input.char_at(self.pos))

    fn advance(self) -> Option[String]:
        if self.pos >= self.len:
            return None
        ch = self.input.char_at(self.pos)
        self.pos = self.pos + 1
        return Some(ch)

    fn skip_whitespace(self):
        while self.pos < self.len:
            ch = self.input.char_at(self.pos)
            if ch == " " or ch == "\t" or ch == "\n" or ch == "\r":
                self.pos = self.pos + 1
            else:
                break

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_at_end(self) -> bool:
        """Check if parser has reached end of input.

        Returns:
            true if no more characters to parse

        Example:
            parser = JsonParser.new("{}")
            parser.is_at_end()  # → false
            parser.pos = parser.len
            parser.is_at_end()  # → true
        """
        return self.pos >= self.len

    fn remaining(self) -> i64:
        """Get number of remaining characters.

        Returns:
            Characters left to parse

        Example:
            parser = JsonParser.new("hello")
            parser.remaining()  # → 5
            parser.advance()
            parser.remaining()  # → 4
        """
        return self.len - self.pos

    fn get_position(self) -> i64:
        """Get current position in input.

        Returns:
            Current character index

        Example:
            parser = JsonParser.new("test")
            parser.get_position()  # → 0
            parser.advance()
            parser.get_position()  # → 1
        """
        return self.pos

    fn get_length(self) -> i64:
        """Get total input length.

        Returns:
            Total number of characters

        Example:
            parser = JsonParser.new("hello")
            parser.get_length()  # → 5
        """
        return self.len

    fn reset(self):
        """Reset parser to beginning of input.

        Example:
            parser = JsonParser.new("{}")
            parser.advance()
            parser.reset()
            parser.get_position()  # → 0
        """
        self.pos = 0

    fn summary(self) -> String:
        """Get summary of parser state.

        Returns:
            Human-readable summary

        Example:
            parser.summary()
            # → "JsonParser: pos=0/5, remaining=5"
        """
        let pos = self.pos
        let len = self.len
        let remaining = self.remaining()
        return "JsonParser: pos={pos}/{len}, remaining={remaining}"

    fn parse_value(self) -> Result[JsonValue, String]:
        self.skip_whitespace()

        ch_opt = self.peek()
        if ch_opt.is_none():
            return Err("Unexpected end of input")

        ch = ch_opt.unwrap()

        if ch == "\"":
            return self.parse_string()
        elif ch == '{':
            return self.parse_object()
        elif ch == "[":
            return self.parse_array()
        elif ch == "t":
            return self.parse_true()
        elif ch == "f":
            return self.parse_false()
        elif ch == "n":
            return self.parse_null()
        elif ch == "-" or is_digit(ch):
            return self.parse_number()
        else:
            return Err("Unexpected character: " + ch)

    fn parse_string(self) -> Result[JsonValue, String]:
        self.advance()  # Skip opening quote

        result = ""
        while self.pos < self.len:
            ch_opt = self.advance()
            ch = ch_opt.unwrap()

            if ch == "\"":
                return Ok(JsonValue.String(result))
            elif ch == "\\":
                # Escape sequence
                if self.pos >= self.len:
                    return Err("Unexpected end of string")

                esc_opt = self.advance()
                esc = esc_opt.unwrap()
                if esc == "\"":
                    result = result + "\""
                elif esc == "\\":
                    result = result + "\\"
                elif esc == "/":
                    result = result + "/"
                elif esc == "n":
                    result = result + "\n"
                elif esc == "r":
                    result = result + "\r"
                elif esc == "t":
                    result = result + "\t"
                elif esc == "b":
                    # Backspace - use placeholder since \b not supported
                    result = result + ""
                elif esc == "f":
                    # Form feed - use placeholder since \f not supported
                    result = result + ""
                elif esc == "u":
                    # Unicode escape - skip 4 hex digits for now
                    for _ in 0..4:
                        if self.pos < self.len:
                            self.advance()
                    result = result + "?"  # Placeholder
                else:
                    result = result + esc
            else:
                result = result + ch

        return Err("Unterminated string")

    fn parse_object(self) -> Result[JsonValue, String]:
        self.advance()  # Skip {
        self.skip_whitespace()

        obj = {}

        if self.peek() == Some('}'):
            self.advance()
            return Ok(JsonValue.Object(obj))

        while true:
            self.skip_whitespace()

            # Parse key
            if self.peek() != Some("\""):
                return Err("Expected string key in object")

            key_result = self.parse_string()
            if key_result.is_err():
                return key_result

            key = ""
            match key_result.unwrap():
                case JsonValue.String(s):
                    key = s
                case _:
                    return Err("Key must be string")

            self.skip_whitespace()

            # Expect colon
            if self.peek() != Some(":"):
                return Err("Expected ':' after object key")
            self.advance()

            # Parse value
            value_result = self.parse_value()
            if value_result.is_err():
                return value_result

            obj.set(key, value_result.unwrap())

            self.skip_whitespace()

            ch_opt = self.peek()
            if ch_opt == Some('}'):
                self.advance()
                return Ok(JsonValue.Object(obj))
            elif ch_opt == Some(","):
                self.advance()
            else:
                return Err('Expected comma or closing brace in object')

    fn parse_array(self) -> Result[JsonValue, String]:
        self.advance()  # Skip [
        self.skip_whitespace()

        arr = []

        if self.peek() == Some("]"):
            self.advance()
            return Ok(JsonValue.Array(arr))

        while true:
            value_result = self.parse_value()
            if value_result.is_err():
                return value_result

            arr.append(value_result.unwrap())

            self.skip_whitespace()

            ch_opt = self.peek()
            if ch_opt == Some("]"):
                self.advance()
                return Ok(JsonValue.Array(arr))
            elif ch_opt == Some(","):
                self.advance()
            else:
                return Err("Expected ',' or ']' in array")

    fn parse_true(self) -> Result[JsonValue, String]:
        if self.input.substring(self.pos, self.pos + 4) == "true":
            self.pos = self.pos + 4
            return Ok(JsonValue.Bool(true))
        return Err("Expected 'true'")

    fn parse_false(self) -> Result[JsonValue, String]:
        if self.input.substring(self.pos, self.pos + 5) == "false":
            self.pos = self.pos + 5
            return Ok(JsonValue.Bool(false))
        return Err("Expected 'false'")

    fn parse_null(self) -> Result[JsonValue, String]:
        if self.input.substring(self.pos, self.pos + 4) == "null":
            self.pos = self.pos + 4
            return Ok(JsonValue.Null)
        return Err("Expected 'null'")

    fn parse_number(self) -> Result[JsonValue, String]:
        start = self.pos
        has_dot = false
        has_exp = false

        # Optional negative sign
        if self.peek() == Some("-"):
            self.advance()

        # Integer part
        while self.pos < self.len:
            ch = self.input.char_at(self.pos)
            if is_digit(ch):
                self.advance()
            elif ch == "." and not has_dot:
                has_dot = true
                self.advance()
            elif (ch == "e" or ch == "E") and not has_exp:
                has_exp = true
                self.advance()
                # Optional sign after exponent
                if self.peek() == Some("+") or self.peek() == Some("-"):
                    self.advance()
            else:
                break

        num_str = self.input.substring(start, self.pos)

        if has_dot or has_exp:
            # Parse as float
            value = parse_float(num_str)
            return Ok(JsonValue.Number(value))
        else:
            # Parse as integer
            value = parse_int(num_str)
            return Ok(JsonValue.Integer(value))

# Helper function to parse integer
fn parse_int(s: String) -> i64:
    result = 0
    negative = false
    start = 0

    if s.len() > 0 and s.char_at(0) == "-":
        negative = true
        start = 1

    for i in start..s.len():
        ch = s.char_at(i)
        if is_digit(ch):
            digit = ch.ord() - 48  # 48 is ord('0')
            result = result * 10 + digit

    if negative:
        return -result
    return result

# Helper function to parse float
fn parse_float(s: String) -> f64:
    result = 0.0
    negative = false
    pos = 0

    # Check for negative sign
    if s.len() > 0 and s.char_at(0) == "-":
        negative = true
        pos = 1

    # Parse integer part
    int_part = 0.0
    while pos < s.len():
        ch = s.char_at(pos)
        if is_digit(ch):
            digit = (ch.ord() - 48) as f64
            int_part = int_part * 10.0 + digit
            pos = pos + 1
        else:
            break

    result = int_part

    # Parse decimal part if present
    if pos < s.len() and s.char_at(pos) == ".":
        pos = pos + 1
        decimal_part = 0.0
        decimal_places = 0.0

        while pos < s.len():
            ch = s.char_at(pos)
            if is_digit(ch):
                digit = (ch.ord() - 48) as f64
                decimal_part = decimal_part * 10.0 + digit
                decimal_places = decimal_places + 1.0
                pos = pos + 1
            else:
                break

        if decimal_places > 0.0:
            divisor = 1.0
            for _ in 0..(decimal_places as i64):
                divisor = divisor * 10.0
            result = result + (decimal_part / divisor)

    # Parse exponent if present
    if pos < s.len():
        ch = s.char_at(pos)
        if ch == "e" or ch == "E":
            pos = pos + 1
            exp_negative = false

            if pos < s.len():
                sign_ch = s.char_at(pos)
                if sign_ch == "-":
                    exp_negative = true
                    pos = pos + 1
                elif sign_ch == "+":
                    pos = pos + 1

            exponent = 0
            while pos < s.len():
                ch = s.char_at(pos)
                if is_digit(ch):
                    digit = ch.ord() - 48
                    exponent = exponent * 10 + digit
                    pos = pos + 1
                else:
                    break

            # Apply exponent
            if exponent > 0:
                multiplier = 1.0
                for _ in 0..exponent:
                    multiplier = multiplier * 10.0

                if exp_negative:
                    result = result / multiplier
                else:
                    result = result * multiplier

    if negative:
        return -result
    return result

# Parse JSON string into a value
pub fn parse(input: String) -> Result[JsonValue, String]:
    parser = JsonParser.new(input)
    return parser.parse_value()

# Escape string for JSON output
fn escape_string(s: String) -> String:
    result = ""
    for i in 0..s.len():
        ch = s.char_at(i)
        if ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
    return result

# Serialize JSON value to string
pub fn stringify(value: JsonValue) -> String:
    match value:
        case JsonValue.Null:
            return "null"
        case JsonValue.Bool(b):
            if b:
                return "true"
            else:
                return "false"
        case JsonValue.Number(n):
            return n.to_string()
        case JsonValue.Integer(i):
            return i.to_string()
        case JsonValue.String(s):
            return "\"" + escape_string(s) + "\""
        case JsonValue.Array(arr):
            parts = []
            for item in arr:
                parts.append(stringify(item))
            return "[" + parts.join(", ") + "]"
        case JsonValue.Object(obj):
            parts = []
            for key in obj.keys():
                val = obj.get(key)
                parts.append("\"" + escape_string(key) + "\": " + stringify(val))
            return '{' + parts.join(", ") + '}'

# Pretty print JSON with indentation
pub fn stringify_pretty(value: JsonValue, indent: i64) -> String:
    return stringify_indent(value, indent, 0)

fn stringify_indent(value: JsonValue, indent: i64, level: i64) -> String:
    spaces = " ".repeat(indent * level)
    next_spaces = " ".repeat(indent * (level + 1))

    match value:
        case JsonValue.Null:
            return "null"
        case JsonValue.Bool(b):
            if b:
                return "true"
            else:
                return "false"
        case JsonValue.Number(n):
            return n.to_string()
        case JsonValue.Integer(i):
            return i.to_string()
        case JsonValue.String(s):
            return "\"" + escape_string(s) + "\""
        case JsonValue.Array(arr):
            if arr.len() == 0:
                return "[]"
            parts = []
            for item in arr:
                parts.append(next_spaces + stringify_indent(item, indent, level + 1))
            return "[\n" + parts.join(",\n") + "\n" + spaces + "]"
        case JsonValue.Object(obj):
            keys = obj.keys()
            if keys.len() == 0:
                return '{}'
            parts = []
            for key in keys:
                val = obj.get(key)
                parts.append(next_spaces + "\"" + escape_string(key) + "\": " + stringify_indent(val, indent, level + 1))
            return '{\n' + parts.join(",\n") + "\n" + spaces + '}'

# Parse JSON string into a Dict (convenience function)
pub fn parse_object(input: String) -> Result[Dict[String, JsonValue], String]:
    match parse(input):
        case Ok(JsonValue.Object(obj)):
            Ok(obj)
        case Ok(_):
            Err("JSON value is not an object")
        case Err(e):
            Err(e)

# Helper to get string from JsonValue
pub fn get_string(value: JsonValue) -> Option[String]:
    match value:
        case JsonValue.String(s):
            return Some(s)
        case _:
            return None

# Helper to get integer from JsonValue
pub fn get_int(value: JsonValue) -> Option[i64]:
    match value:
        case JsonValue.Integer(i):
            return Some(i)
        case JsonValue.Number(n):
            return Some(n as i64)
        case _:
            return None

# Helper to get object from JsonValue
pub fn get_object(value: JsonValue) -> Option[Dict[String, JsonValue]]:
    match value:
        case JsonValue.Object(obj):
            return Some(obj)
        case _:
            return None

# Helper to get array from JsonValue
pub fn get_array(value: JsonValue) -> Option[List[JsonValue]]:
    match value:
        case JsonValue.Array(arr):
            return Some(arr)
        case _:
            return None

# Builder for creating JSON objects
pub class JsonBuilder:
    obj: Dict[String, JsonValue]

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if builder has no fields."""
        return self.obj.len() == 0

    pub fn has_fields(self) -> bool:
        """Check if builder has any fields."""
        return self.obj.len() > 0

    pub fn field_count(self) -> usize:
        """Get number of fields."""
        return self.obj.len()

    pub fn has_field(self, key: String) -> bool:
        """Check if field exists."""
        return self.obj.has_key(key)

    pub fn get_field(self, key: String) -> Option[JsonValue]:
        """Get field value."""
        if self.obj.has_key(key):
            return Some(self.obj.get(key))
        return None

    pub fn remove_field(self, key: String) -> JsonBuilder:
        """Remove a field."""
        self.obj = self.obj.remove(key)
        return self

    pub fn clear(self) -> JsonBuilder:
        """Clear all fields."""
        self.obj = {}
        return self

    pub fn keys(self) -> List[String]:
        """Get list of all field keys."""
        return self.obj.keys()

    pub fn summary(self) -> String:
        """Get summary of JSON builder state."""
        return "JsonBuilder: {self.field_count()} fields"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new() -> JsonBuilder:
        return JsonBuilder { obj: {} }

    pub fn set_string(self, key: String, value: String) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.String(value))
        return self

    pub fn set_int(self, key: String, value: i64) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Integer(value))
        return self

    pub fn set_bool(self, key: String, value: bool) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Bool(value))
        return self

    pub fn set_null(self, key: String) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Null)
        return self

    pub fn set_object(self, key: String, value: Dict[String, JsonValue]) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Object(value))
        return self

    pub fn set_array(self, key: String, value: List[JsonValue]) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Array(value))
        return self

    pub fn set(self, key: String, value: JsonValue) -> JsonBuilder:
        self.obj = self.obj.set(key, value)
        return self

    pub fn build(self) -> JsonValue:
        return JsonValue.Object(self.obj)

    pub fn to_string(self) -> String:
        return stringify(self.build())
