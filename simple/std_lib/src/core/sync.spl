# Synchronization Primitives Module
# Provides thread-safe wrappers for concurrent programming
#
# Features:
# - #1101: Atomic[T] - Lock-free atomic operations
# - #1102: Mutex[T] - Mutual exclusion lock
# - #1103: RwLock[T] - Read-write lock
#
# Note: These require #[concurrency_mode(lock_base)] or #[unsafe]

# Extern FFI declarations for runtime primitives
extern fn rt_atomic_new(initial: i64) -> Any
extern fn rt_atomic_load(atomic: Any) -> i64
extern fn rt_atomic_store(atomic: Any, value: i64) -> ()
extern fn rt_atomic_swap(atomic: Any, value: i64) -> i64
extern fn rt_atomic_compare_exchange(atomic: Any, expected: i64, new_value: i64, result_ptr: *i64) -> i64
extern fn rt_atomic_fetch_add(atomic: Any, delta: i64) -> i64
extern fn rt_atomic_fetch_sub(atomic: Any, delta: i64) -> i64
extern fn rt_atomic_fetch_and(atomic: Any, mask: i64) -> i64
extern fn rt_atomic_fetch_or(atomic: Any, mask: i64) -> i64

extern fn rt_mutex_new(value: Any) -> Any
extern fn rt_mutex_lock(mutex: Any) -> Any
extern fn rt_mutex_try_lock(mutex: Any) -> Any
extern fn rt_mutex_unlock(mutex: Any, new_value: Any) -> i64

extern fn rt_rwlock_new(value: Any) -> Any
extern fn rt_rwlock_read(lock: Any) -> Any
extern fn rt_rwlock_try_read(lock: Any) -> Any
extern fn rt_rwlock_write(lock: Any) -> Any
extern fn rt_rwlock_try_write(lock: Any) -> Any
extern fn rt_rwlock_set(lock: Any, new_value: Any) -> i64

# Atomic[T] - Lock-free atomic operations (#1101)

class Atomic[T]:
    """
    Lock-free atomic wrapper for thread-safe operations.

    Supports atomic load, store, compare-and-swap, and arithmetic operations.

    Example:
        counter = Atomic(0)
        counter.fetch_add(1)  # Atomically increment
        value = counter.load()  # Atomically read

    Requires: #[concurrency_mode(lock_base)] or #[unsafe]
    """

    fn __init__(self, initial_value: T):
        self._handle = rt_atomic_new(initial_value as i64)
        self._value = initial_value

    fn load(self) -> T:
        """
        Atomically load the current value.

        Ordering: Acquire (ensures operations after this see effects before the store)
        """
        return rt_atomic_load(self._handle) as T

    fn store(self, value: T):
        """
        Atomically store a new value.

        Ordering: Release (ensures operations before this are visible after the load)
        """
        rt_atomic_store(self._handle, value as i64)

    fn swap(self, value: T) -> T:
        """
        Atomically swap the stored value with a new value.

        Returns: The previous value

        Ordering: AcqRel (both acquire and release)
        """
        return rt_atomic_swap(self._handle, value as i64) as T

    fn compare_and_swap(self, expected: T, new_value: T) -> (bool, T):
        """
        Atomically compare and swap (CAS).

        If current value equals expected, store new_value and return (true, expected).
        Otherwise, return (false, current_value).

        This is the fundamental operation for lock-free algorithms.
        """
        let result: i64 = 0
        let success = rt_atomic_compare_exchange(self._handle, expected as i64, new_value as i64, &result)
        return (success == 1, result as T)

    fn fetch_add(self, delta: T) -> T:
        """
        Atomically add delta and return the previous value.

        Only valid for numeric types (i8, i16, i32, i64, u8, u16, u32, u64).
        """
        return rt_atomic_fetch_add(self._handle, delta as i64) as T

    fn fetch_sub(self, delta: T) -> T:
        """Atomically subtract delta and return the previous value."""
        return rt_atomic_fetch_sub(self._handle, delta as i64) as T

    fn fetch_and(self, mask: T) -> T:
        """Atomically perform bitwise AND and return the previous value."""
        return rt_atomic_fetch_and(self._handle, mask as i64) as T

    fn fetch_or(self, mask: T) -> T:
        """Atomically perform bitwise OR and return the previous value."""
        return rt_atomic_fetch_or(self._handle, mask as i64) as T


# Mutex[T] - Mutual exclusion lock (#1102)

class Mutex[T]:
    """
    Mutual exclusion lock for protecting shared data.

    Only one thread can hold the lock at a time. Provides interior mutability.

    Example:
        shared_data = Mutex(0)

        # Acquire lock, modify data, release lock
        with shared_data.lock() as data:
            data.value = data.value + 1
        # Lock automatically released

    Requires: #[concurrency_mode(lock_base)]
    """

    fn __init__(self, initial_value: T):
        self._handle = rt_mutex_new(initial_value)
        self._value = initial_value

    fn lock(self) -> MutexGuard[T]:
        """
        Acquire the lock, blocking if necessary.

        Returns: A MutexGuard that provides access to the protected data
                 and automatically releases the lock when dropped.
        """
        let value = rt_mutex_lock(self._handle)
        return MutexGuard(self, value)

    fn try_lock(self) -> Option[MutexGuard[T]]:
        """
        Attempt to acquire the lock without blocking.

        Returns: Some(guard) if successful, None if already locked
        """
        let value = rt_mutex_try_lock(self._handle)
        if value == nil:
            return None
        return Some(MutexGuard(self, value))

    fn unlock(self, new_value: T):
        """Internal: Release the lock and update the value."""
        rt_mutex_unlock(self._handle, new_value)

    fn into_inner(self) -> T:
        """
        Consume the mutex and return the inner value.

        This is safe because consuming the mutex ensures no other references exist.
        """
        return self._value


class MutexGuard[T]:
    """
    RAII guard for Mutex. Automatically releases the lock when dropped.

    Provides access to the protected data through the `value` field.
    """

    fn __init__(self, mutex: Mutex[T], value: T):
        self.mutex = mutex
        self.value = value

    fn __exit__(self, exc_type, exc_value, traceback):
        """Automatically release lock when guard goes out of scope."""
        self.mutex.unlock(self.value)
        return false


# RwLock[T] - Read-write lock (#1103)

class RwLock[T]:
    """
    Read-write lock allowing multiple readers or one writer.

    Multiple threads can hold read locks simultaneously, but write locks are exclusive.

    Example:
        shared_data = RwLock(vec![1, 2, 3])

        # Multiple readers can access concurrently
        with shared_data.read() as data:
            print(data.value)

        # Writers get exclusive access
        with shared_data.write() as data:
            data.value.push(4)

    Requires: #[concurrency_mode(lock_base)]
    """

    fn __init__(self, initial_value: T):
        self._handle = rt_rwlock_new(initial_value)
        self._value = initial_value

    fn read(self) -> RwLockReadGuard[T]:
        """
        Acquire a read lock, blocking if a writer holds the lock.

        Multiple readers can hold locks simultaneously.
        """
        let value = rt_rwlock_read(self._handle)
        return RwLockReadGuard(self, value)

    fn try_read(self) -> Option[RwLockReadGuard[T]]:
        """
        Attempt to acquire a read lock without blocking.

        Returns: Some(guard) if successful, None if a writer holds the lock
        """
        let value = rt_rwlock_try_read(self._handle)
        if value == nil:
            return None
        return Some(RwLockReadGuard(self, value))

    fn write(self) -> RwLockWriteGuard[T]:
        """
        Acquire a write lock, blocking if any readers or writer hold locks.

        Write locks are exclusive - only one writer, no readers.
        """
        let value = rt_rwlock_write(self._handle)
        return RwLockWriteGuard(self, value)

    fn try_write(self) -> Option[RwLockWriteGuard[T]]:
        """
        Attempt to acquire a write lock without blocking.

        Returns: Some(guard) if successful, None if locked
        """
        let value = rt_rwlock_try_write(self._handle)
        if value == nil:
            return None
        return Some(RwLockWriteGuard(self, value))

    fn release_read(self):
        """Internal: Release a read lock (no-op, handled by Rust)."""
        pass

    fn release_write(self, new_value: T):
        """Internal: Release a write lock and update the value."""
        rt_rwlock_set(self._handle, new_value)


class RwLockReadGuard[T]:
    """RAII guard for read lock. Auto-releases when dropped."""

    fn __init__(self, rwlock: RwLock[T]):
        self.rwlock = rwlock
        self.value = rwlock._value

    fn __exit__(self, exc_type, exc_value, traceback):
        self.rwlock.release_read()
        return false


class RwLockWriteGuard[T]:
    """RAII guard for write lock. Auto-releases when dropped."""

    fn __init__(self, rwlock: RwLock[T]):
        self.rwlock = rwlock
        self.value = rwlock._value

    fn __exit__(self, exc_type, exc_value, traceback):
        self.rwlock.release_write()
        return false


# Additional synchronization primitives

class Semaphore:
    """
    Counting semaphore for limiting concurrent access.

    Example:
        # Allow up to 3 concurrent operations
        sem = Semaphore(3)

        with sem:
            # Critical section - at most 3 threads here
            pass
    """

    fn __init__(self, permits: i64):
        self.permits = Atomic(permits)

    fn acquire(self):
        """Acquire a permit, blocking if none available."""
        while true:
            current = self.permits.load()
            if current > 0:
                success, _ = self.permits.compare_and_swap(current, current - 1)
                if success:
                    break

    fn release(self):
        """Release a permit."""
        self.permits.fetch_add(1)

    fn __enter__(self):
        self.acquire()
        return self

    fn __exit__(self, exc_type, exc_value, traceback):
        self.release()
        return false
