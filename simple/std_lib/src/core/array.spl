# Array<T, N> - Fixed-size array
# Syntax: [T; N] creates an Array
# Implements collection traits except Growable (fixed size)

use core.traits.*
use core.collections.*

# ============================================
# Array Type Definition
# ============================================

struct Array<T, const N: usize>:
    data: [T; N]

# ============================================
# Constructors
# ============================================

impl Array<T, const N: usize>:
    # Create with default values
    static fn new() -> Array<T, N> where T: Default:
        Array { data: [T::default(); N] }

    # Create from inline array
    fn of(items: [T; N]) -> Array<T, N>:
        Array { data: items }

    # Create filled with single value
    fn filled(value: T) -> Array<T, N> where T: Clone:
        var data: [T; N]
        for i in 0..N:
            data[i] = value.clone()
        Array { data: data }

    # Create filled with function
    fn filled_with(f: fn(usize) -> T) -> Array<T, N>:
        var data: [T; N]
        for i in 0..N:
            data[i] = f(i)
        Array { data: data }

    # Create zeroed (for numeric types)
    fn zeroed() -> Array<T, N> where T: Default:
        Array::new()

# ============================================
# Len trait
# ============================================

impl Len for Array<T, const N: usize>:
    fn len() -> usize:
        N

# ============================================
# Capacity trait (always full for fixed arrays)
# ============================================

impl Capacity for Array<T, const N: usize>:
    fn capacity() -> usize:
        N

    fn is_full() -> bool:
        true  # Fixed arrays are always "full"

# ============================================
# Iterable trait
# ============================================

impl Iterable<T> for Array<T, const N: usize>:
    type Iter = ArrayIter<T, N>

    fn iter() -> Self::Iter:
        ArrayIter { array: self, index: 0 }

    fn into_iter() -> Self::Iter:
        self.iter()

# ============================================
# Collection trait
# ============================================

impl Collection<T> for Array<T, const N: usize>

# ============================================
# Sequence trait
# ============================================

impl Sequence<T> for Array<T, const N: usize>:
    fn get(idx: usize) -> Option<T>:
        if idx < N:
            Some(self.data[idx])
        else:
            None

    fn slice(start: usize, end: usize) -> Slice<T>:
        if start > end or end > N:
            Slice::empty()
        else:
            danger:
                Slice::new(&self.data[start] as *T, end - start)

# ============================================
# MutSequence trait
# ============================================

impl MutSequence<T> for Array<T, const N: usize>:
    fn get_mut(idx: usize) -> Option<&mut T>:
        if idx < N:
            Some(&mut self.data[idx])
        else:
            None

    fn set(idx: usize, value: T) -> Result<(), IndexError>:
        if idx >= N:
            return Err(IndexError::OutOfBounds(idx, N))
        self.data[idx] = value
        Ok(())

    fn sort() where T: Ord:
        # Insertion sort for fixed arrays
        for i in 1..N:
            var j = i
            while j > 0 and self.data[j].lt(&self.data[j - 1]):
                val tmp = self.data[j]
                self.data[j] = self.data[j - 1]
                self.data[j - 1] = tmp
                j = j - 1

    fn retain(predicate: fn(&T) -> bool):
        # Fixed arrays cannot change size, this is a no-op
        # For filtering, use filtered() which returns a List
        pass

    fn as_mut_slice() -> MutSlice<T>:
        danger:
            MutSlice::new(&mut self.data[0] as *mut T, N)

# ============================================
# ImmutSequence trait
# ============================================

impl ImmutSequence<T> for Array<T, const N: usize> where T: Clone:
    type Output = Array<T, N>

    fn with_index(idx: usize, value: T) -> Option<Self::Output>:
        if idx >= N:
            return None
        var new_data = self.data
        new_data[idx] = value
        Some(Array { data: new_data })

    fn sorted() -> Self::Output where T: Ord:
        var new_array = Array { data: self.data }
        new_array.sort()
        new_array

    fn reversed() -> Self::Output:
        var new_data = self.data
        var left: usize = 0
        var right = N - 1
        while left < right:
            val tmp = new_data[left]
            new_data[left] = new_data[right]
            new_data[right] = tmp
            left = left + 1
            right = right - 1
        Array { data: new_data }

    fn filtered(predicate: fn(&T) -> bool) -> List<T>:
        # Returns List because result size is unknown at compile time
        var result = List::new()
        for i in 0..N:
            if predicate(&self.data[i]):
                result.push(self.data[i].clone())
        result

    fn mapped<U>(self, f: fn(T) -> U) -> Array<U, N> where U: Default:
        var new_data: [U; N] = [U::default(); N]
        for i in 0..N:
            new_data[i] = f(self.data[i].clone())
        Array { data: new_data }

    fn appended(item: T) -> List<T>:
        # Returns List because size increases
        var result = List::with_capacity(N + 1)
        for i in 0..N:
            result.push(self.data[i].clone())
        result.push(item)
        result

    fn prepended(item: T) -> List<T>:
        # Returns List because size increases
        var result = List::with_capacity(N + 1)
        result.push(item)
        for i in 0..N:
            result.push(self.data[i].clone())
        result

    fn taken(n: usize) -> List<T>:
        var result = List::new()
        val take_count = if n < N: n else: N
        for i in 0..take_count:
            result.push(self.data[i].clone())
        result

    fn dropped(n: usize) -> List<T>:
        var result = List::new()
        if n < N:
            for i in n..N:
                result.push(self.data[i].clone())
        result

    fn taken_while(predicate: fn(&T) -> bool) -> List<T>:
        var result = List::new()
        for i in 0..N:
            if not predicate(&self.data[i]):
                break
            result.push(self.data[i].clone())
        result

    fn dropped_while(predicate: fn(&T) -> bool) -> List<T>:
        var result = List::new()
        var dropping = true
        for i in 0..N:
            if dropping and predicate(&self.data[i]):
                continue
            dropping = false
            result.push(self.data[i].clone())
        result

# ============================================
# Sliceable trait
# ============================================

impl Sliceable<T> for Array<T, const N: usize>:
    fn as_slice() -> Slice<T>:
        danger:
            Slice::new(&self.data[0] as *T, N)

impl MutSliceable<T> for Array<T, const N: usize>:
    fn as_mut_slice() -> MutSlice<T>:
        danger:
            MutSlice::new(&mut self.data[0] as *mut T, N)

# ============================================
# Danger operations (unchecked, C-like)
# ============================================

impl Array<T, const N: usize>:
    # Unchecked get - requires danger block
    danger fn get_unchecked(self, idx: usize) -> T:
        self.data[idx]

    # Unchecked set - requires danger block
    danger fn set_unchecked(self, idx: usize, value: T):
        self.data[idx] = value

    # Raw pointer - requires danger block
    danger fn as_ptr(self) -> *T:
        &self.data[0] as *T

    # Mutable raw pointer - requires danger block
    danger fn as_mut_ptr(self) -> *mut T:
        &mut self.data[0] as *mut T

    # Copy from slice (unchecked) - requires danger block
    danger fn copy_from_slice(self, src: Slice<T>) where T: Copy:
        val copy_len = if src.len() < N: src.len() else: N
        for i in 0..copy_len:
            self.data[i] = src.get(i).expect("valid")

# ============================================
# Standard trait implementations
# ============================================

impl Clone for Array<T, const N: usize> where T: Clone:
    fn clone() -> Self:
        var new_data: [T; N]
        for i in 0..N:
            new_data[i] = self.data[i].clone()
        Array { data: new_data }

impl Copy for Array<T, const N: usize> where T: Copy

impl Default for Array<T, const N: usize> where T: Default:
    static fn default() -> Self:
        Array::new()

impl Eq for Array<T, const N: usize> where T: Eq:
    fn eq(other: &Self) -> bool:
        for i in 0..N:
            if not self.data[i].eq(&other.data[i]):
                return false
        true

impl Ord for Array<T, const N: usize> where T: Ord:
    fn cmp(other: &Self) -> Ordering:
        for i in 0..N:
            match self.data[i].cmp(&other.data[i]):
                case Ordering::Less: return Ordering::Less
                case Ordering::Greater: return Ordering::Greater
                case Ordering::Equal: continue
        Ordering::Equal

impl Hash for Array<T, const N: usize> where T: Hash:
    fn hash() -> u64:
        var h: u64 = 0
        for i in 0..N:
            h = h * 31 + self.data[i].hash()
        h

impl Display for Array<T, const N: usize> where T: Display:
    fn fmt() -> str:
        var s = "["
        for i in 0..N:
            if i > 0:
                s = s + ", "
            s = s + self.data[i].fmt()
        s + "]"

impl Index<usize> for Array<T, const N: usize>:
    type Output = T

    fn index(idx: usize) -> &Self::Output:
        if idx >= N:
            panic("index {idx} out of bounds (len={N})")
        &self.data[idx]

impl IndexMut<usize> for Array<T, const N: usize>:
    fn index_mut(idx: usize) -> &mut Self::Output:
        if idx >= N:
            panic("index {idx} out of bounds (len={N})")
        &mut self.data[idx]

impl IntoIterator for Array<T, const N: usize>:
    type Item = T
    type IntoIter = ArrayIter<T, N>
    fn into_iter() -> Self::IntoIter:
        self.iter()

# ============================================
# Array Iterator
# ============================================

struct ArrayIter<T, const N: usize>:
    array: Array<T, N>
    index: usize

impl Iterator for ArrayIter<T, const N: usize>:
    type Item = T

    fn next() -> Option<Self::Item>:
        if self.index < N:
            val item = self.array.data[self.index]
            self.index = self.index + 1
            Some(item)
        else:
            None

impl ExactSizeIterator for ArrayIter<T, const N: usize>:
    fn len() -> usize:
        N - self.index

impl DoubleEndedIterator for ArrayIter<T, const N: usize>:
    fn next_back() -> Option<Self::Item>:
        if self.index < N:
            Some(self.array.data<N - 1>)
        else:
            None

impl ArrayIter<T, const N: usize>:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_exhausted() -> bool:
        """Check if iterator is exhausted.

        Returns:
            true if no more elements

        Example:
            iter = Array::of([1, 2]).iter()
            iter.is_exhausted()  # → false
        """
        self.index >= N

    fn remaining() -> usize:
        """Get number of remaining elements.

        Returns:
            Count of remaining elements

        Example:
            iter = Array::of([1, 2, 3]).iter()
            iter.remaining()  # → 3
        """
        if self.index < N:
            N - self.index
        else:
            0

    fn has_next() -> bool:
        """Check if iterator has next element.

        Returns:
            true if more elements available

        Example:
            iter = Array::of([1, 2]).iter()
            iter.has_next()  # → true
        """
        self.index < N

    fn get_index() -> usize:
        """Get current iteration index.

        Returns:
            Current index position

        Example:
            iter = Array::of([1, 2, 3]).iter()
            iter.get_index()  # → 0
        """
        self.index

    fn peek() -> Option<&T>:
        """Peek at next element without consuming.

        Returns:
            Some(&T) if available, None otherwise

        Example:
            iter = Array::of([1, 2, 3]).iter()
            iter.peek()  # → Some(&1)
        """
        if self.index < N:
            Some(&self.array.data[self.index])
        else:
            None

    fn summary() -> str:
        """Get summary of iterator state.

        Returns:
            Human-readable summary

        Example:
            iter.summary()
            # → "ArrayIter<3>: index=0, remaining=3"
        """
        val index = self.index
        val remaining = self.remaining()
        return "ArrayIter[{N}]: index={index}, remaining={remaining}"

# ============================================
# Conversion to List
# ============================================

impl Array<T, const N: usize>:
    fn to_list() -> List<T> where T: Clone:
        var list = List::with_capacity(N)
        for i in 0..N:
            list.push(self.data[i].clone())
        list

    # Convenience methods
    fn map_with_index<U>(self, f: fn(usize, T) -> U) -> Array<U, N> where T: Clone, U: Default:
        var new_data: [U; N] = [U::default(); N]
        for i in 0..N:
            new_data[i] = f(i, self.data[i].clone())
        Array { data: new_data }

    # Ruby-style tap
    fn tap(f: fn(&Array<T, N>)) -> Array<T, N>:
        f(&self)
        self

    # Ruby-style then
    fn then<U>(self, f: fn(Array<T, N>) -> U) -> U:
        f(self)

    # Zip with another array of same size
    fn zip<U>(self, other: Array<U, N>) -> Array<(T, U), N> where T: Clone, U: Clone:
        var new_data: [(T, U); N]
        for i in 0..N:
            new_data[i] = (self.data[i].clone(), other.data[i].clone())
        Array { data: new_data }

    # Enumerate as array of (index, value)
    fn enumerated() -> Array<(usize, T), N> where T: Clone:
        var new_data: [(usize, T); N]
        for i in 0..N:
            new_data[i] = (i, self.data[i].clone())
        Array { data: new_data }

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> bool:
        """Check if array is empty (N == 0).

        Returns:
            true if array size is 0

        Example:
            Array<i32, 0>::new().is_empty()  # → true
            Array<i32, 5>::new().is_empty()  # → false
        """
        N == 0

    fn is_singleton() -> bool:
        """Check if array has exactly one element.

        Returns:
            true if N == 1

        Example:
            Array::of([42]).is_singleton()  # → true
        """
        N == 1

    fn first() -> Option<&T>:
        """Get reference to first element.

        Returns:
            Some(&T) if N > 0, None otherwise

        Example:
            Array::of([1, 2, 3]).first()  # → Some(&1)
        """
        if N > 0:
            Some(&self.data[0])
        else:
            None

    fn last() -> Option<&T>:
        """Get reference to last element.

        Returns:
            Some(&T) if N > 0, None otherwise

        Example:
            Array::of([1, 2, 3]).last()  # → Some(&3)
        """
        if N > 0:
            Some(&self.data<N - 1>)
        else:
            None

    fn contains(value: &T) -> bool where T: Eq:
        """Check if array contains value.

        Args:
            value: Value to search for

        Returns:
            true if found

        Example:
            Array::of([1, 2, 3]).contains(&2)  # → true
        """
        for i in 0..N:
            if self.data[i].eq(value):
                return true
        false

    fn size() -> usize:
        """Get size of array (alias for len()).

        Returns:
            Size N

        Example:
            Array::of([1, 2, 3]).size()  # → 3
        """
        N

    fn is_full() -> bool:
        """Check if array is full (always true for fixed arrays).

        Returns:
            true

        Example:
            Array::of([1, 2, 3]).is_full()  # → true
        """
        true

    fn swap(i: usize, j: usize) -> bool:
        """Swap elements at indices i and j.

        Args:
            i: First index
            j: Second index

        Returns:
            true if swap succeeded, false if indices out of bounds

        Example:
            arr = Array::of([1, 2, 3])
            arr.swap(0, 2)  # arr is now [3, 2, 1]
        """
        if i >= N or j >= N:
            return false
        val tmp = self.data[i]
        self.data[i] = self.data[j]
        self.data[j] = tmp
        true

    fn all(predicate: fn(&T) -> bool) -> bool:
        """Check if all elements satisfy predicate.

        Args:
            predicate: Test function

        Returns:
            true if all elements pass

        Example:
            Array::of([2, 4, 6]).all(|x| x % 2 == 0)  # → true
        """
        for i in 0..N:
            if not predicate(&self.data[i]):
                return false
        true

    fn any(predicate: fn(&T) -> bool) -> bool:
        """Check if any element satisfies predicate.

        Args:
            predicate: Test function

        Returns:
            true if any element passes

        Example:
            Array::of([1, 3, 5]).any(|x| x % 2 == 0)  # → false
        """
        for i in 0..N:
            if predicate(&self.data[i]):
                return true
        false

    fn find(predicate: fn(&T) -> bool) -> Option<&T>:
        """Find first element matching predicate.

        Args:
            predicate: Test function

        Returns:
            Some(&T) if found, None otherwise

        Example:
            Array::of([1, 2, 3]).find(|x| x > 1)  # → Some(&2)
        """
        for i in 0..N:
            if predicate(&self.data[i]):
                return Some(&self.data[i])
        None

    fn position(predicate: fn(&T) -> bool) -> Option<usize>:
        """Find index of first element matching predicate.

        Args:
            predicate: Test function

        Returns:
            Some(index) if found, None otherwise

        Example:
            Array::of([1, 2, 3]).position(|x| x > 1)  # → Some(1)
        """
        for i in 0..N:
            if predicate(&self.data[i]):
                return Some(i)
        None

    fn count(predicate: fn(&T) -> bool) -> usize:
        """Count elements matching predicate.

        Args:
            predicate: Test function

        Returns:
            Count of matching elements

        Example:
            Array::of([1, 2, 3, 4]).count(|x| x % 2 == 0)  # → 2
        """
        var count: usize = 0
        for i in 0..N:
            if predicate(&self.data[i]):
                count = count + 1
        count

    fn summary() -> str where T: Display:
        """Get summary of array.

        Returns:
            Human-readable summary

        Example:
            Array::of([1, 2, 3]).summary()
            # → "Array<3>: [1, 2, 3]"
        """
        val content = self.fmt()
        return "Array<{N}>: {content}"

# ============================================
# Type aliases for common sizes
# ============================================

type Array2<T> = Array<T, 2>
type Array3<T> = Array<T, 3>
type Array4<T> = Array<T, 4>
type Array8<T> = Array<T, 8>
type Array16<T> = Array<T, 16>
type Array32<T> = Array<T, 32>
type Array64<T> = Array<T, 64>
type Array128<T> = Array<T, 128>
type Array256<T> = Array<T, 256>

# Vector types (common in graphics/math)
type Vec2 = Array<f32, 2>
type Vec3 = Array<f32, 3>
type Vec4 = Array<f32, 4>
type Vec2d = Array<f64, 2>
type Vec3d = Array<f64, 3>
type Vec4d = Array<f64, 4>

# Integer vector types
type IVec2 = Array<i32, 2>
type IVec3 = Array<i32, 3>
type IVec4 = Array<i32, 4>

# Matrix type aliases
type Mat2 = Array<Array<f32, 2>, 2>
type Mat3 = Array<Array<f32, 3>, 3>
type Mat4 = Array<Array<f32, 4>, 4>
