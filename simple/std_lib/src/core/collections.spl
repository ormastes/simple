# Collection Traits - Shared interfaces for List, Array, Slice, text
# Enables generic programming over sequential containers
# Similar to C#'s IList<T>, ICollection<T>, IEnumerable<T>

use core.traits.*
use core.sorting.*

# ============================================
# Index Error Type
# ============================================

enum IndexError:
    OutOfBounds(index: usize, len: usize)

impl IndexError:
    fn message() -> str:
        match self:
            case OutOfBounds(i, l): "index {i} out of bounds (len={l})"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert error to string.

        Returns:
            Error name
        """
        "OutOfBounds"

    pub fn description(self) -> text:
        """Get detailed error description.

        Returns:
            Human-readable description
        """
        self.message()

    pub fn get_index(self) -> usize:
        """Get the index that was out of bounds.

        Returns:
            Index value
        """
        match self:
            case OutOfBounds(i, _): i

    pub fn get_length(self) -> usize:
        """Get the collection length.

        Returns:
            Length value
        """
        match self:
            case OutOfBounds(_, l): l

    pub fn is_negative_index(self) -> bool:
        """Check if index is conceptually negative (wraps).

        Returns:
            True if index >= length (likely wrap-around)
        """
        match self:
            case OutOfBounds(i, l): i >= l

    pub fn distance_from_end(self) -> usize:
        """Get distance from end of collection.

        Returns:
            How many elements past the end
        """
        match self:
            case OutOfBounds(i, l):
                if i >= l:
                    i - l + 1
                else:
                    0

    pub fn summary(self) -> text:
        """Get summary of index error.

        Returns:
            Human-readable summary

        Example:
            IndexError::OutOfBounds(10, 5).summary()
            # â†’ "IndexError: index 10 out of bounds (length 5, 6 past end)"
        """
        match self:
            case OutOfBounds(i, l):
                val dist = self.distance_from_end()
                if dist > 0:
                    "IndexError: index {i} out of bounds (length {l}, {dist} past end)"
                else:
                    "IndexError: index {i} out of bounds (length {l})"

impl Display for IndexError:
    fn fmt() -> str:
        self.message()

# TODO: Parser limitation - cannot create empty trait impl
# impl Error for IndexError would go here but parser requires methods
# IndexError already has required Error trait methods in its inherent impl

# ============================================
# Iterable - Base iteration trait
# ============================================

trait Iterable<T>:
    # TODO: Parser limitation - associated type constraints not supported
    # type Iter: Iterator<Item=T>  # ERROR: expected Colon, found DoubleColon
    # Workaround: Remove constraint, loses compile-time type checking
    type Iter  # Should be: Iter: Iterator<Item=T>

    # @deprecated("Use each() instead")  # TODO: decorator not yet supported
    fn iter() -> Self::Iter

    fn into_iter() -> Self::Iter

    # Ruby-style iteration - preferred over iter()
    fn each(f: fn(T)):
        """Execute closure for each element.

        Args:
            f: Closure to execute with each element

        Example:
            list.each(|x| print(x))
        """
        for item in self.into_iter():
            f(item)

    fn each_with_index(f: fn(usize, T)):
        """Execute closure for each element with its index.

        Args:
            f: Closure to execute with index and element

        Example:
            list.each_with_index(|i, x| print("{i}: {x}"))
        """
        var idx: usize = 0
        for item in self.into_iter():
            f(idx, item)
            idx = idx + 1

# ============================================
# Collection - Sized container with containment check
# ============================================

# TODO: Parser limitation - multiple trait bounds with + not supported
# trait Collection<T>: Iterable<T> + Len:  # ERROR: expected Newline, found Identifier
# Workaround: Remove bounds, document in comments
trait Collection<T>:  # Should inherit: Iterable<T> + Len
    fn contains(item: &T) -> bool where T: Eq:
        for x in self.iter():
            if x.eq(item):
                return true
        false

    fn count_matching(predicate: fn(&T) -> bool) -> usize:
        var n: usize = 0
        for x in self.iter():
            if predicate(&x):
                n = n + 1
        n

# ============================================
# Sequence - Indexed read access
# ============================================

# TODO: Parser limitation - trait inheritance not supported
# trait Sequence<T>: Collection<T>:  # ERROR
trait Sequence<T>:  # Should inherit: Collection<T>
    # Safe indexed access - returns None if out of bounds
    fn get(idx: usize) -> Option<T>

    # First element
    fn first() -> Option<T>:
        self.get(0)

    # Last element
    fn last() -> Option<T>:
        if self.is_empty():
            None
        else:
            self.get(self.len() - 1)

    # Find first element matching predicate
    fn find(predicate: fn(&T) -> bool) -> Option<T>:
        for item in self.iter():
            if predicate(&item):
                return Some(item)
        None

    # Find index of first matching element
    fn find_index(predicate: fn(&T) -> bool) -> Option<usize>:
        var idx: usize = 0
        for item in self.iter():
            if predicate(&item):
                return Some(idx)
            idx = idx + 1
        None

    # Find position of item (alias for find_index with equality)
    fn position(item: &T) -> Option<usize> where T: Eq:
        self.find_index(|x| x.eq(item))

    # Get slice of range
    fn slice(start: usize, end: usize) -> Slice<T>

    # Get slice from start to end
    fn slice_from(start: usize) -> Slice<T>:
        self.slice(start, self.len())

    # Get slice from 0 to end
    fn slice_to(end: usize) -> Slice<T>:
        self.slice(0, end)

    # Iterate with index
    fn enumerate() -> Enumerate<Self::Iter>:
        Enumerate::new(self.iter())

    # Check if all elements match predicate
    fn all(predicate: fn(&T) -> bool) -> bool:
        for item in self.iter():
            if not predicate(&item):
                return false
        true

    # Check if any element matches predicate
    fn any(predicate: fn(&T) -> bool) -> bool:
        for item in self.iter():
            if predicate(&item):
                return true
        false

    # Fold/reduce from left
    fn fold<U>(self, init: U, f: fn(U, T) -> U) -> U:
        var acc = init
        for item in self.iter():
            acc = f(acc, item)
        acc

    # Sum elements (requires Add and Default)
    # TODO: Parser limitation - associated type constraints like Add<Output=T> not supported
    fn sum() -> T where T: Add + Default:
        self.fold(T::default(), |acc, x| acc + x)

    # Product of elements (requires Mul and numeric one)
    # TODO: Parser limitation - associated type constraints like Mul<Output=T> not supported
    fn product() -> T where T: Mul + Default:
        self.fold(T::default(), |acc, x| acc * x)

    # Maximum element
    fn max() -> Option<T> where T: Ord:
        if self.is_empty():
            return None
        var result = self.first().expect("not empty")
        for item in self.iter():
            if item.gt(&result):
                result = item
        Some(result)

    # Minimum element
    fn min() -> Option<T> where T: Ord:
        if self.is_empty():
            return None
        var result = self.first().expect("not empty")
        for item in self.iter():
            if item.lt(&result):
                result = item
        Some(result)

# ============================================
# MutSequence - Mutable indexed access
# ============================================

# TODO: Parser limitation - trait inheritance not supported
# trait MutSequence<T>: Sequence<T>:  # ERROR
trait MutSequence<T>:  # Should inherit: Sequence<T>
    # Mutable reference access
    fn get_mut(idx: usize) -> Option<&mut T>

    # Set value at index, returns error if out of bounds
    fn set(idx: usize, value: T) -> Result<(), IndexError>

    # Swap two elements
    fn swap(i: usize, j: usize) -> Result<(), IndexError>:
        if i >= self.len():
            return Err(IndexError::OutOfBounds(i, self.len()))
        if j >= self.len():
            return Err(IndexError::OutOfBounds(j, self.len()))
        if i != j:
            val tmp = self.get(i).expect("bounds checked")
            self.set(i, self.get(j).expect("bounds checked"))?
            self.set(j, tmp)?
        Ok(())

    # Fill all elements with value
    fn fill(value: T) where T: Clone:
        for i in 0..self.len():
            self.set(i, value.clone()).expect("valid index")

    # Fill with values from function
    fn fill_with(f: fn(usize) -> T):
        for i in 0..self.len():
            self.set(i, f(i)).expect("valid index")

    # In-place sort (requires Ord)
    fn sort() where T: Ord:
        """Sort using the default algorithm (PDQSort)."""
        self.sort_with(DEFAULT_SORT_ALGORITHM)

    fn sort_with(algo: SortAlgorithm) where T: Ord:
        """Sort using the specified algorithm.

        Args:
            algo: Sorting algorithm to use

        Example:
            list.sort_with(SortAlgorithm::TimSort)
        """
        sort_with_algorithm(self.as_mut_slice(), algo)

    # In-place reverse
    fn reverse():
        if self.len() < 2:
            return
        var left: usize = 0
        var right = self.len() - 1
        while left < right:
            self.swap(left, right).expect("valid indices")
            left = left + 1
            right = right - 1

    # Retain only elements matching predicate
    fn retain(predicate: fn(&T) -> bool)

    # Get mutable slice
    fn as_mut_slice() -> MutSlice<T>

# ============================================
# ImmutSequence - Functional update operations (return new)
# ============================================

# TODO: Parser limitation - trait inheritance not supported
# trait ImmutSequence<T>: Sequence<T>:  # ERROR
trait ImmutSequence<T>:  # Should inherit: Sequence<T>
    type Output: Sequence<T>

    # Return new sequence with updated index
    fn with_index(idx: usize, value: T) -> Option<Self::Output>

    # Return new sorted sequence
    fn sorted() -> Self::Output where T: Ord

    # Return new reversed sequence
    fn reversed() -> Self::Output

    # Return new filtered sequence (elements matching predicate)
    fn filtered(predicate: fn(&T) -> bool) -> Self::Output

    # Return new mapped sequence
    fn mapped<U>(self, f: fn(T) -> U) -> Self::Output

    # Return new sequence with element appended
    fn appended(item: T) -> Self::Output

    # Return new sequence with element prepended
    fn prepended(item: T) -> Self::Output

    # Take first n elements
    fn taken(n: usize) -> Self::Output

    # Drop first n elements
    fn dropped(n: usize) -> Self::Output

    # Take while predicate is true
    fn taken_while(predicate: fn(&T) -> bool) -> Self::Output

    # Drop while predicate is true
    fn dropped_while(predicate: fn(&T) -> bool) -> Self::Output

# ============================================
# Growable - Can add/remove elements dynamically
# ============================================

# TODO: Parser limitation - trait inheritance not supported
# trait Growable<T>: MutSequence<T>:  # ERROR
trait Growable<T>:  # Should inherit: MutSequence<T>
    # Add element to end
    fn push(item: T)

    # Remove and return last element
    fn pop() -> Option<T>

    # Add element to front
    fn push_front(item: T)

    # Remove and return first element
    fn pop_front() -> Option<T>

    # Insert element at index
    fn insert(idx: usize, item: T) -> Result<(), IndexError>

    # Remove element at index
    fn remove(idx: usize) -> Option<T>

    # Remove all elements
    fn clear()

    # Extend with elements from iterator
    # TODO: Parser limitation - associated type constraints like IntoIterator<Item=T> not supported
    fn extend<I: IntoIterator>(self, iter: I):
        for item in iter:
            self.push(item)

    # Append all elements from another collection
    fn append<C: Sequence<T>>(self, other: C) where T: Clone:
        for item in other.iter():
            self.push(item.clone())

    # Truncate to length
    fn truncate(len: usize):
        while self.len() > len:
            self.pop()

    # Resize to length, filling with value if needed
    fn resize(new_len: usize, value: T) where T: Clone:
        if new_len < self.len():
            self.truncate(new_len)
        else:
            while self.len() < new_len:
                self.push(value.clone())

# ============================================
# Sliceable - Can create slice views
# ============================================

trait Sliceable<T>:
    fn as_slice() -> Slice<T>

# ============================================
# MutSliceable - Can create mutable slice views
# ============================================

# TODO: Parser limitation - trait inheritance not supported
# trait MutSliceable<T>: Sliceable<T>:  # ERROR
trait MutSliceable<T>:  # Should inherit: Sliceable<T>
    fn as_mut_slice() -> MutSlice<T>

# ============================================
# Enumerate Iterator Wrapper
# ============================================

struct Enumerate<I>:
    iter: I
    index: usize

impl Enumerate<I>:
    fn new(iter: I) -> Enumerate<I>:
        Enumerate { iter: iter, index: 0 }

impl Iterator for Enumerate<I> where I: Iterator:
    type Item = (usize, I::Item)

    fn next() -> Option<Self::Item>:
        match self.iter.next():
            case Some(item):
                val idx = self.index
                self.index = self.index + 1
                Some((idx, item))
            case None:
                None

# ============================================
# Slice Type - Borrowed view into a sequence
# ============================================

struct Slice<T>:
    ptr: *T
    len: usize

impl Slice<T>:
    fn new(ptr: *T, len: usize) -> Slice<T>:
        Slice { ptr: ptr, len: len }

    fn empty() -> Slice<T>:
        Slice { ptr: nil, len: 0 }

impl Len for Slice<T>:
    fn len() -> usize:
        self.len

impl Iterable<T> for Slice<T>:
    type Iter = SliceIter<T>

    fn iter() -> Self::Iter:
        SliceIter { slice: self, index: 0 }

    fn into_iter() -> Self::Iter:
        self.iter()

impl Collection<T> for Slice<T>

impl Sequence<T> for Slice<T>:
    fn get(idx: usize) -> Option<T>:
        if idx < self.len:
            danger:
                Some(self.ptr.offset(idx as isize).read())
        else:
            None

    fn slice(start: usize, end: usize) -> Slice<T>:
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.ptr.offset(start as isize), end - start)

impl Sliceable<T> for Slice<T>:
    fn as_slice() -> Slice<T>:
        self

# Slice iterator
struct SliceIter<T>:
    slice: Slice<T>
    index: usize

impl Iterator for SliceIter<T>:
    type Item = T

    fn next() -> Option<Self::Item>:
        if self.index < self.slice.len:
            val item = self.slice.get(self.index).expect("valid index")
            self.index = self.index + 1
            Some(item)
        else:
            None

impl ExactSizeIterator for SliceIter<T>:
    fn len() -> usize:
        self.slice.len - self.index

# ============================================
# MutSlice Type - Mutable borrowed view
# ============================================

struct MutSlice<T>:
    ptr: *mut T
    len: usize

impl MutSlice<T>:
    fn new(ptr: *mut T, len: usize) -> MutSlice<T>:
        MutSlice { ptr: ptr, len: len }

impl Len for MutSlice<T>:
    fn len() -> usize:
        self.len

impl Iterable<T> for MutSlice<T>:
    type Iter = MutSliceIter<T>

    fn iter() -> Self::Iter:
        MutSliceIter { slice: self, index: 0 }

    fn into_iter() -> Self::Iter:
        self.iter()

impl Collection<T> for MutSlice<T>

impl Sequence<T> for MutSlice<T>:
    fn get(idx: usize) -> Option<T>:
        if idx < self.len:
            danger:
                Some(self.ptr.offset(idx as isize).read())
        else:
            None

    fn slice(start: usize, end: usize) -> Slice<T>:
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.ptr.offset(start as isize) as *T, end - start)

impl MutSequence<T> for MutSlice<T>:
    fn get_mut(idx: usize) -> Option<&mut T>:
        if idx < self.len:
            danger:
                Some(&mut *self.ptr.offset(idx as isize))
        else:
            None

    fn set(idx: usize, value: T) -> Result<(), IndexError>:
        if idx >= self.len:
            return Err(IndexError::OutOfBounds(idx, self.len))
        danger:
            self.ptr.offset(idx as isize).write(value)
        Ok(())

    fn sort() where T: Ord:
        sort_default(self)

    fn sort_with(algo: SortAlgorithm) where T: Ord:
        sort_with_algorithm(self, algo)

    fn retain(predicate: fn(&T) -> bool):
        # MutSlice cannot change size, this is a no-op placeholder
        pass

    fn as_mut_slice() -> MutSlice<T>:
        self

impl Sliceable<T> for MutSlice<T>:
    fn as_slice() -> Slice<T>:
        danger:
            Slice::new(self.ptr as *T, self.len)

impl MutSliceable<T> for MutSlice<T>:
    fn as_mut_slice() -> MutSlice<T>:
        self

# MutSlice iterator
struct MutSliceIter<T>:
    slice: MutSlice<T>
    index: usize

impl Iterator for MutSliceIter<T>:
    type Item = T

    fn next() -> Option<Self::Item>:
        if self.index < self.slice.len:
            val item = self.slice.get(self.index).expect("valid index")
            self.index = self.index + 1
            Some(item)
        else:
            None
