# Result Type - Represents success or failure
# Core type for error handling

enum Result<T, E>:
    Ok(T)
    Err(E)

impl Result<T, E>:
    # Check result status
    @pure
    fn is_ok() -> bool:
        match self:
            case Ok(_): return true
            case Err(_): return false

    @pure
    fn is_err() -> bool:
        return not self.is_ok()

    # Unwrap with panic on Err
    @pure
    fn unwrap() -> T:
        match self:
            case Ok(v): return v
            case Err(e): panic("called unwrap on Err: {e}")

    # Unwrap error with panic on Ok
    @pure
    fn unwrap_err() -> E:
        match self:
            case Ok(v): panic("called unwrap_err on Ok: {v}")
            case Err(e): return e

    # Unwrap with default value
    @pure
    fn unwrap_or(default_value: T) -> T:
        match self:
            case Ok(v): return v
            case Err(_): return default_value

    # Unwrap with lazy default
    @pure
    fn unwrap_or_else(f: fn(E) -> T) -> T:
        match self:
            case Ok(v): return v
            case Err(e): return f(e)

    # Expect with custom message
    @pure
    fn expect(msg: str) -> T:
        match self:
            case Ok(v): return v
            case Err(e): panic("{msg}: {e}")

    @pure
    fn expect_err(msg: str) -> E:
        match self:
            case Ok(v): panic("{msg}: {v}")
            case Err(e): return e

    # Map the Ok value
    @pure
    fn map<U>(self, f: fn(T) -> U) -> Result<U, E>:
        match self:
            case Ok(v): return Ok(f(v))
            case Err(e): return Err(e)

    # Map the Err value
    @pure
    fn map_err<F>(self, f: fn(E) -> F) -> Result<T, F>:
        match self:
            case Ok(v): return Ok(v)
            case Err(e): return Err(f(e))

    # Flat map (also known as and_then in Rust, but 'and' is a keyword in Simple)
    @pure
    fn flat_map<U>(self, f: fn(T) -> Result<U, E>) -> Result<U, E>:
        match self:
            case Ok(v): return f(v)
            case Err(e): return Err(e)

    # Or combinator
    @pure
    fn or(other: Result<T, E>) -> Result<T, E>:
        match self:
            case Ok(_): return self
            case Err(_): return other

    # Or with lazy evaluation
    @pure
    fn or_else<F>(self, f: fn(E) -> Result<T, F>) -> Result<T, F>:
        match self:
            case Ok(v): return Ok(v)
            case Err(e): return f(e)

    # Convert Ok to Option
    @pure
    fn ok() -> Option<T>:
        match self:
            case Ok(v): return Some(v)
            case Err(_): return None

    # Convert Err to Option
    @pure
    fn err() -> Option<E>:
        match self:
            case Ok(_): return None
            case Err(e): return Some(e)

    # Get references
    @pure
    fn as_ref() -> Result<&T, &E>:
        match self:
            case Ok(v): return Ok(&v)
            case Err(e): return Err(&e)

    # Transpose Result<Option<T>, E> to Option<Result<T, E>>
    # Note: self type annotation removed due to parser issue with nested generics
    @pure
    fn transpose() -> Option<Result<T, E>>:
        match self:
            case Ok(Some(v)): return Some(Ok(v))
            case Ok(None): return None
            case Err(e): return Some(Err(e))

    # Flatten nested Result
    # Note: self type annotation removed due to parser issue with nested generics
    @pure
    fn flatten() -> Result<T, E>:
        match self:
            case Ok(inner): return inner
            case Err(e): return Err(e)

    # Check if Ok matches predicate
    @pure
    fn is_ok_and(f: fn(&T) -> bool) -> bool:
        match self:
            case Ok(v): return f(&v)
            case Err(_): return false

    # Check if Err matches predicate
    @pure
    fn is_err_and(f: fn(&E) -> bool) -> bool:
        match self:
            case Ok(_): return false
            case Err(e): return f(&e)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    @pure
    fn get() -> &T:
        """Get reference to Ok value, panic if Err.

        Returns:
            Reference to Ok value

        Example:
            Ok(42).get()   # → &42
            Err(e).get()   # → panic!

        Note:
            Prefer expect() for better error messages
        """
        match self:
            case Ok(v): return &v
            case Err(e): panic("called get() on Err: {e}")

    @pure
    fn get_err() -> &E:
        """Get reference to Err value, panic if Ok.

        Returns:
            Reference to Err value

        Example:
            Err("fail").get_err()  # → &"fail"
            Ok(42).get_err()       # → panic!
        """
        match self:
            case Ok(v): panic("called get_err() on Ok: {v}")
            case Err(e): return &e

    @pure
    fn get_or(default_ref: &T) -> &T:
        """Get reference to Ok value or default_ref reference.

        Returns:
            Reference to Ok value if Ok, else default_ref

        Example:
            Ok(42).get_or(&0)   # → &42
            Err(e).get_or(&0)   # → &0
        """
        match self:
            case Ok(v): return &v
            case Err(_): return default_ref

    @pure
    fn contains(value: &T) -> bool:
        """Check if result is Ok with specific value.

        Returns:
            true if Ok(value) matches

        Example:
            Ok(42).contains(&42)   # → true
            Ok(42).contains(&43)   # → false
            Err(e).contains(&42)   # → false
        """
        match self:
            case Ok(v): return &v == value
            case Err(_): return false

    @pure
    fn contains_err(error: &E) -> bool:
        """Check if result is Err with specific error.

        Returns:
            true if Err(error) matches

        Example:
            Err("fail").contains_err(&"fail")  # → true
            Err("fail").contains_err(&"ok")    # → false
            Ok(42).contains_err(&"fail")       # → false
        """
        match self:
            case Ok(_): return false
            case Err(e): return &e == error

    @pure
    fn cloned() -> Result<T, E>:
        """Clone inner Ok value if Ok (requires T: Clone).

        Returns:
            Result with cloned Ok value, preserves Err

        Example:
            Ok(vec![1, 2]).cloned()  # → Ok(vec![1, 2])
            Err(e).cloned()          # → Err(e)
        """
        match self:
            case Ok(v): return Ok(v.clone())
            case Err(e): return Err(e)

    @pure
    fn copied() -> Result<T, E>:
        """Copy inner Ok value if Ok (requires T: Copy).

        Returns:
            Result with copied Ok value, preserves Err

        Example:
            Ok(42).copied()  # → Ok(42)
            Err(e).copied()  # → Err(e)
        """
        match self:
            case Ok(v): return Ok(v)  # Copy happens implicitly
            case Err(e): return Err(e)

    @pure
    fn summary() -> text:
        """Get summary of result.

        Returns:
            Human-readable summary

        Example:
            Ok(42).summary()       # → "Ok(42)"
            Err("fail").summary()  # → "Err(fail)"
        """
        match self:
            case Ok(v):
                return "Ok({v})"
            case Err(e):
                return "Err({e})"

# Helper functions
@pure
fn ok<T, E>(value: T) -> Result<T, E>:
    return Ok(value)

@pure
fn err<T, E>(error: E) -> Result<T, E>:
    return Err(error)

# Try macro support - propagate errors with ?
# Usage: val value = risky_operation()?
# Expands to:
#   match risky_operation():
#       case Ok(v): v
#       case Err(e): return Err(e)
