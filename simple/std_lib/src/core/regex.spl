# Regex - Regular expression support for Simple
# Pattern matching and text processing

# Regex match result
pub class Match:
    text: String
    start: Int
    end: Int
    groups: List[String]

    pub fn new(text: String, start: Int, end: Int) -> Match:
        return Match {
            text: text,
            start: start,
            end: end,
            groups: []
        }

    pub fn matched_text(self) -> String:
        return self.text

    pub fn span(self) -> (Int, Int):
        return (self.start, self.end)

    pub fn group(self, index: Int) -> Option[String]:
        if index < 0 or index >= self.groups.len():
            return None
        return Some(self.groups[index])

    pub fn all_groups(self) -> List[String]:
        return self.groups

# Compiled regex pattern
pub class Pattern:
    pattern: String

    pub fn new(pattern: String) -> Pattern:
        return Pattern {
            pattern: pattern
        }

    # Match at the start of string
    pub fn match(self, text: String) -> Option[Match]:
        # Simple literal matching for now
        # TODO: Implement full regex engine
        if text.starts_with(self.pattern):
            return Some(Match.new(self.pattern, 0, self.pattern.len()))
        return None

    # Search anywhere in string
    pub fn search(self, text: String) -> Option[Match]:
        # TODO: Implement full regex search
        let index = text.find(self.pattern)
        if index >= 0:
            return Some(Match.new(self.pattern, index, index + self.pattern.len()))
        return None

    # Check if entire string matches
    pub fn fullmatch(self, text: String) -> Option[Match]:
        if text == self.pattern:
            return Some(Match.new(self.pattern, 0, self.pattern.len()))
        return None

    # Find all matches
    pub fn findall(self, text: String) -> List[Match]:
        let mut results = []
        let mut pos = 0

        # Simple implementation: find all literal occurrences
        while pos < text.len():
            let index = text.substring(pos, text.len()).find(self.pattern)
            if index < 0:
                break

            let actual_index = pos + index
            results.append(Match.new(
                self.pattern,
                actual_index,
                actual_index + self.pattern.len()
            ))
            pos = actual_index + 1

        return results

    # Replace matches with replacement string
    pub fn sub(self, replacement: String, text: String, count: Int = -1) -> String:
        # TODO: Implement full regex substitution
        if count == -1:
            return text.replace(self.pattern, replacement)

        let mut result = text
        let mut replaced = 0
        let mut pos = 0

        while replaced < count and pos < result.len():
            let index = result.substring(pos, result.len()).find(self.pattern)
            if index < 0:
                break

            # Simple replacement
            # TODO: Proper implementation
            result = result.replace(self.pattern, replacement)
            replaced = replaced + 1
            pos = pos + replacement.len()

        return result

    # Split string by pattern
    pub fn split(self, text: String, maxsplit: Int = -1) -> List[String]:
        # TODO: Implement regex split
        # For now, use simple string split
        return text.split(self.pattern)

# Compile a regex pattern
pub fn compile(pattern: String) -> Pattern:
    return Pattern.new(pattern)

# Match at start of string (convenience function)
pub fn match(pattern: String, text: String) -> Option[Match]:
    let p = compile(pattern)
    return p.match(text)

# Search anywhere in string (convenience function)
pub fn search(pattern: String, text: String) -> Option[Match]:
    let p = compile(pattern)
    return p.search(text)

# Check if entire string matches (convenience function)
pub fn fullmatch(pattern: String, text: String) -> Option[Match]:
    let p = compile(pattern)
    return p.fullmatch(text)

# Find all matches (convenience function)
pub fn findall(pattern: String, text: String) -> List[Match]:
    let p = compile(pattern)
    return p.findall(text)

# Replace matches (convenience function)
pub fn sub(pattern: String, replacement: String, text: String, count: Int = -1) -> String:
    let p = compile(pattern)
    return p.sub(replacement, text, count)

# Split by pattern (convenience function)
pub fn split(pattern: String, text: String, maxsplit: Int = -1) -> List[String]:
    let p = compile(pattern)
    return p.split(text, maxsplit)

# Escape special regex characters
pub fn escape(text: String) -> String:
    # Escape special regex characters
    let mut result = text
    let special_chars = [
        "\\", ".", "^", "$", "*", "+", "?", "{", "}", "[", "]", "(", ")", "|"
    ]

    for ch in special_chars:
        result = result.replace(ch, "\\" + ch)

    return result

# Check if pattern matches (boolean)
pub fn is_match(pattern: String, text: String) -> Bool:
    return search(pattern, text).is_some()

# Extract matched text from Match
pub fn extract_text(m: Match) -> String:
    return m.matched_text()

# Character class helpers (for pattern building)
pub fn digit() -> String:
    return "[0-9]"

pub fn word() -> String:
    return "[a-zA-Z0-9_]"

pub fn whitespace() -> String:
    return "[ \t\n\r]"

pub fn any_char() -> String:
    return "."

# Quantifier helpers
pub fn zero_or_more(pattern: String) -> String:
    return pattern + "*"

pub fn one_or_more(pattern: String) -> String:
    return pattern + "+"

pub fn optional(pattern: String) -> String:
    return pattern + "?"

pub fn exactly(pattern: String, n: Int) -> String:
    return pattern + "{" + n + "}"

pub fn at_least(pattern: String, n: Int) -> String:
    return pattern + "{" + n + ",}"

pub fn between(pattern: String, min: Int, max: Int) -> String:
    return pattern + "{" + min + "," + max + "}"

# Anchor helpers
pub fn start_of_line() -> String:
    return "^"

pub fn end_of_line() -> String:
    return "$"

pub fn word_boundary() -> String:
    return "\\b"

# Export all types and functions
export Match
export Pattern
export compile
export match
export search
export fullmatch
export findall
export sub
export split
export escape
export is_match
export extract_text
export digit
export word
export whitespace
export any_char
export zero_or_more
export one_or_more
export optional
export exactly
export at_least
export between
export start_of_line
export end_of_line
export word_boundary
