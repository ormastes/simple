# Manual Pointer Borrow - Borrow checker model generation
# Generates Lean verification for manual pointer borrow checking

import verification.lean.codegen as codegen

fn regenerate_manual_pointer_borrow() -> String:
    gen = codegen.LeanCodegen.create("ManualPointerBorrow")

    # Namespace
    gen = gen.add_namespace("ManualPointerBorrow")

    # BorrowState structure
    gen = gen.add_doc_comment("A tiny borrow checker for manual pointers: `exclusive` tracks a unique borrow,\n    `shared` counts active shared borrows.")
    borrow_state = codegen.build_class("BorrowState", [
        ("exclusive", codegen.make_simple_type("Bool")),
        ("shared", codegen.make_simple_type("Nat"))
    ])
    gen = gen.add_structure(borrow_state)

    # ValidBorrowState inductive
    gen = gen.add_doc_comment("Type-safe borrow state where invalid states are unrepresentable.\n    The invariant \"exclusive → shared = 0\" is encoded in the inductive structure.")
    valid_state = types.EnumDef.create("ValidBorrowState", [
        types.EnumVariant.create("unborrowed", []),
        types.EnumVariant.create("exclusive", []),
        types.EnumVariant.create("shared", [("count", codegen.make_simple_type("Nat")), ("h", codegen.make_simple_type("count > 0"))])
    ], ["Repr"])
    gen = gen.add_inductive(valid_state)

    # valid definition
    valid_def = codegen.build_function(
        "valid",
        [("s", codegen.make_simple_type("BorrowState"))],
        codegen.make_simple_type("Prop"),
        "if s.exclusive then s.shared = 0 else True"
    )
    gen = gen.add_function(valid_def)

    # Conversion functions
    gen = gen.add_doc_comment("Convert ValidBorrowState to BorrowState. Always produces a valid state.")
    to_state_def = codegen.build_function(
        "ValidBorrowState.toState",
        [("_", codegen.make_simple_type("ValidBorrowState"))],
        codegen.make_simple_type("BorrowState"),
        "match _ with\n| .unborrowed => {{ exclusive := false, shared := 0 }}\n| .exclusive => {{ exclusive := true, shared := 0 }}\n| .shared count _ => {{ exclusive := false, shared := count }}"
    )
    gen = gen.add_raw_line("def ValidBorrowState.toState : ValidBorrowState → BorrowState")
    gen = gen.add_raw_line("  | .unborrowed => {{ exclusive := false, shared := 0 }}")
    gen = gen.add_raw_line("  | .exclusive => {{ exclusive := true, shared := 0 }}")
    gen = gen.add_raw_line("  | .shared count _ => {{ exclusive := false, shared := count }}")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Convert BorrowState to ValidBorrowState if valid.")
    gen = gen.add_raw_line("def BorrowState.toValid (s : BorrowState) : Option ValidBorrowState :=")
    gen = gen.add_raw_line("  match s.exclusive, s.shared with")
    gen = gen.add_raw_line("  | false, 0 => some .unborrowed")
    gen = gen.add_raw_line("  | true, 0 => some .exclusive")
    gen = gen.add_raw_line("  | false, n + 1 => some (.shared (n + 1) (Nat.succ_pos n))")
    gen = gen.add_raw_line("  | true, _ + 1 => none")
    gen = gen.add_blank()

    # Key theorems
    gen = gen.add_theorem(codegen.build_theorem(
        "validState_always_valid",
        [("vs", "ValidBorrowState")],
        "valid vs.toState",
        "cases vs with\n| unborrowed => simp [ValidBorrowState.toState, valid]\n| exclusive => simp [ValidBorrowState.toState, valid]\n| shared count h => simp [ValidBorrowState.toState, valid]"
    ))

    gen = gen.add_theorem(codegen.build_theorem(
        "toValid_toState",
        [("vs", "ValidBorrowState")],
        "vs.toState.toValid = some vs",
        "cases vs with\n| unborrowed => simp [ValidBorrowState.toState, BorrowState.toValid]\n| exclusive => simp [ValidBorrowState.toState, BorrowState.toValid]\n| shared count h =>\n  simp [ValidBorrowState.toState, BorrowState.toValid]\n  cases count with\n  | zero => exact absurd rfl (Nat.ne_of_gt h)\n  | succ n => rfl"
    ))

    # Operation functions
    take_excl_def = codegen.build_function(
        "takeExclusive",
        [("s", codegen.make_simple_type("BorrowState"))],
        codegen.make_simple_type("BorrowState"),
        "if s.shared = 0 then {{ s with exclusive := true }} else s"
    )
    gen = gen.add_function(take_excl_def)

    take_shared_def = codegen.build_function(
        "takeShared",
        [("s", codegen.make_simple_type("BorrowState"))],
        codegen.make_simple_type("BorrowState"),
        "if s.exclusive then s else {{ s with shared := s.shared + 1 }}"
    )
    gen = gen.add_function(take_shared_def)

    release_shared_def = codegen.build_function(
        "releaseShared",
        [("s", codegen.make_simple_type("BorrowState"))],
        codegen.make_simple_type("BorrowState"),
        "{{ s with shared := s.shared.pred }}"
    )
    gen = gen.add_function(release_shared_def)

    release_excl_def = codegen.build_function(
        "releaseExclusive",
        [("s", codegen.make_simple_type("BorrowState"))],
        codegen.make_simple_type("BorrowState"),
        "{{ s with exclusive := false }}"
    )
    gen = gen.add_function(release_excl_def)

    # Preservation theorems
    gen = gen.add_theorem(codegen.build_theorem(
        "exclusive_ok",
        [("s", "BorrowState"), ("hv", "valid s")],
        "valid (takeExclusive s)",
        "unfold takeExclusive valid at *\nsplit\n· assumption\n· exact hv"
    ))

    gen = gen.add_theorem(codegen.build_theorem(
        "shared_ok",
        [("s", "BorrowState"), ("hv", "valid s")],
        "valid (takeShared s)",
        "unfold takeShared valid at *\nsplit\n· split at hv\n  · exact hv\n  · trivial\n· simp"
    ))

    gen = gen.add_theorem(codegen.build_theorem(
        "release_ok",
        [("s", "BorrowState"), ("hv", "valid s")],
        "valid (releaseShared s) ∧ valid (releaseExclusive s)",
        "unfold releaseShared releaseExclusive valid at *\nconstructor\n· split\n  case isTrue hex =>\n    split at hv\n    case isTrue => simp_all\n    case isFalse h => exact absurd hex h\n  case isFalse => trivial\n· simp"
    ))

    # End namespace
    gen = gen.end_namespace("ManualPointerBorrow")

    return gen.emit()


# ============================================================================
# 5. ModuleResolution - Module path resolution (146 lines)
# ============================================================================

