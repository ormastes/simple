# Lean File Regeneration
#
# Regenerates all Lean files in verification/ from Simple models.
# This module generates all 11 Lean verification projects with full proofs.

# Import individual regeneration modules
from verification.regenerate.nogc_compile import regenerate_nogc_compile
from verification.regenerate.async_compile import regenerate_async_compile
from verification.regenerate.gc_manual_borrow import regenerate_gc_manual_borrow
from verification.regenerate.manual_pointer_borrow import regenerate_manual_pointer_borrow
from verification.regenerate.module_resolution import regenerate_module_resolution
from verification.regenerate.visibility_export import regenerate_visibility_export
from verification.regenerate.macro_auto_import import regenerate_macro_auto_import
from verification.regenerate.type_inference import regenerate_type_inference_compile
from verification.regenerate.generics import regenerate_generics
from verification.regenerate.contracts import regenerate_contracts
from verification.regenerate.memory_capabilities import regenerate_memory_capabilities
from verification.regenerate.memory_model_drf import regenerate_memory_model_drf

# Regenerate all Lean files
fn regenerate_all() -> Dict[String, String]:
    print("  [1/12] regenerate_nogc_compile...")
    r1 = regenerate_nogc_compile()
    print("  [2/12] regenerate_async_compile...")
    r2 = regenerate_async_compile()
    print("  [3/12] regenerate_gc_manual_borrow...")
    r3 = regenerate_gc_manual_borrow()
    print("  [4/12] regenerate_manual_pointer_borrow...")
    r4 = regenerate_manual_pointer_borrow()
    print("  [5/12] regenerate_module_resolution...")
    r5 = regenerate_module_resolution()
    print("  [6/12] regenerate_visibility_export...")
    r6 = regenerate_visibility_export()
    print("  [7/12] regenerate_macro_auto_import...")
    r7 = regenerate_macro_auto_import()
    print("  [8/12] regenerate_type_inference_compile...")
    r8 = regenerate_type_inference_compile()
    print("  [9/12] regenerate_generics...")
    r9 = regenerate_generics()
    print("  [10/12] regenerate_contracts...")
    r10 = regenerate_contracts()
    print("  [11/12] regenerate_memory_capabilities...")
    r11 = regenerate_memory_capabilities()
    print("  [12/12] regenerate_memory_model_drf...")
    r12 = regenerate_memory_model_drf()
    print("  Building result dict...")
    return {
        "verification/nogc_compile/src/NogcCompile.lean": r1,
        "verification/async_compile/src/AsyncCompile.lean": r2,
        "verification/gc_manual_borrow/src/GcManualBorrow.lean": r3,
        "verification/manual_pointer_borrow/src/ManualPointerBorrow.lean": r4,
        "verification/module_resolution/src/ModuleResolution.lean": r5,
        "verification/visibility_export/src/VisibilityExport.lean": r6,
        "verification/macro_auto_import/src/MacroAutoImport.lean": r7,
        "verification/type_inference_compile/src/TypeInferenceCompile.lean": r8,
        "verification/type_inference_compile/src/Generics.lean": r9,
        "verification/type_inference_compile/src/Contracts.lean": r10,
        "verification/memory_capabilities/src/MemoryCapabilities.lean": r11,
        "verification/memory_model_drf/src/MemoryModelDRF.lean": r12
    }

# Write regenerated files to disk
fn write_regenerated_files(files: Dict[String, String], base_path: String = ".") -> List[String]:
    import std.io.fs as fs

    written = []
    for (path, content) in files.items():
        full_path = base_path + "/" + path

        # Ensure directory exists
        dir_path = "/".join(full_path.split("/")[:-1])
        if not fs.exists(dir_path):
            fs.create_dir_all(dir_path)

        # Write file
        fs.write_text(full_path, content)
        written.append(full_path)

    return written

# Validate regenerated files match existing
fn validate_regeneration(files: Dict[String, String], base_path: String = ".") -> Dict[String, Bool]:
    import std.io.fs as fs

    result_pairs = []
    for (path, generated) in files.items():
        full_path = base_path + "/" + path
        if fs.exists(full_path):
            existing = fs.read_text(full_path)
            # Normalize whitespace for comparison
            result_pairs.append((path, generated.strip() == existing.strip()))
        else:
            result_pairs.append((path, False))
    return dict(result_pairs)

# Main entry point for CLI
fn main():
    print("Regenerating Lean verification files...")

    files = regenerate_all()

    for (path, content) in files.items():
        print("Generated: " + path + " (" + str(len(content)) + " bytes)")

    print("")
    print("Validating against existing files...")
    validation = validate_regeneration(files)

    all_valid = True
    for (path, valid) in validation.items():
        status = "MISMATCH"
        if valid:
            status = "OK"
        print("  " + path + ": " + status)
        if not valid:
            all_valid = False

    if all_valid:
        print("")
        print("All files validated successfully!")
    else:
        print("")
        print("WARNING: Some files do not match. Review changes before committing.")
