# Memory Capabilities - Reference capability verification
# Generates Lean verification for memory capabilities

import verification.lean.codegen as codegen

fn regenerate_memory_capabilities() -> text:
    gen = codegen.LeanCodegen.create("MemoryCapabilities")

    # Header block comment
    gen = gen.add_block_comment([
        "# Reference Capability System Verification",
        "",
        "This module formalizes the reference capability system for the Simple language,",
        "proving that capabilities prevent data races at compile time.",
        "",
        "## Reference Capabilities",
        "",
        "1. **`T` (Shared)**: Multiple read-only references allowed",
        "2. **`mut T` (Exclusive)**: Single mutable reference, prevents aliasing",
        "3. **`iso T` (Isolated)**: Unique reference, no aliases at all",
        "",
        "## Key Properties",
        "",
        "- **Aliasing Prevention**: `mut T` and `iso T` prevent multiple references",
        "- **Safe Conversions**: Capability conversions preserve safety",
        "- **Data Race Freedom**: Type system prevents conflicting accesses",
        "",
        "## References",
        "",
        "- Pony language capabilities: https://www.ponylang.io/discover/#what-makes-pony-special",
        "- Rust ownership system: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html"
    ])

    # RefCapability inductive
    gen = gen.add_doc_comment("Reference capabilities")
    ref_cap = codegen.build_enum_with_deriving("RefCapability", [
        ("Shared", []),
        ("Exclusive", []),
        ("Isolated", [])
    ], ["DecidableEq", "Repr"])
    gen = gen.add_inductive(ref_cap)

    # CapType structure
    gen = gen.add_doc_comment("Type with capability annotation")
    cap_type = codegen.build_class_with_deriving("CapType", [
        ("baseType", codegen.make_string_type()),
        ("capability", codegen.make_simple_type("RefCapability"))
    ], ["Repr"])
    gen = gen.add_structure(cap_type)

    # Reference structure
    gen = gen.add_doc_comment("Reference to a value with capability")
    reference = codegen.build_class_with_deriving("Reference", [
        ("location", codegen.make_simple_type("Nat")),
        ("refType", codegen.make_simple_type("CapType"))
    ], ["Repr"])
    gen = gen.add_structure(reference)

    # RefEnv structure
    gen = gen.add_doc_comment("Environment tracking active references")
    ref_env = codegen.build_class_with_deriving("RefEnv", [
        ("activeRefs", codegen.make_list_type(codegen.make_simple_type("(Nat × List Reference)")))
    ], ["Repr"])
    gen = gen.add_structure(ref_env)

    # Helper functions
    gen = gen.add_doc_comment("Check if a location has any active references")
    gen = gen.add_raw_line("def hasActiveRefs (env : RefEnv) (loc : Nat) : bool :=")
    gen = gen.add_raw_line("  match env.activeRefs.find? (fun (l, _) => l == loc) with")
    gen = gen.add_raw_line("  | some (_, refs) => !refs.isEmpty")
    gen = gen.add_raw_line("  | none => false")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Get active references for a location")
    gen = gen.add_raw_line("def getActiveRefs (env : RefEnv) (loc : Nat) : List Reference :=")
    gen = gen.add_raw_line("  match env.activeRefs.find? (fun (l, _) => l == loc) with")
    gen = gen.add_raw_line("  | some (_, refs) => refs")
    gen = gen.add_raw_line("  | none => []")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Count active references with specific capability")
    gen = gen.add_raw_line("def countRefsWithCapability (refs : List Reference) (cap : RefCapability) : Nat :=")
    gen = gen.add_raw_line("  refs.filter (fun r => r.refType.capability == cap) |>.length")
    gen = gen.add_blank()

    # canCreateRef function
    gen = gen.add_doc_comment("Aliasing rules: can we create a new reference with given capability?")
    gen = gen.add_raw_line("def canCreateRef (env : RefEnv) (loc : Nat) (newCap : RefCapability) : bool :=")
    gen = gen.add_raw_line("  val existingRefs := getActiveRefs env loc")
    gen = gen.add_raw_line("  val hasExclusive := countRefsWithCapability existingRefs RefCapability.Exclusive > 0")
    gen = gen.add_raw_line("  val hasIsolated := countRefsWithCapability existingRefs RefCapability.Isolated > 0")
    gen = gen.add_raw_line("  val hasAnyRefs := !existingRefs.isEmpty")
    gen = gen.add_raw_line("")
    gen = gen.add_raw_line("  match newCap with")
    gen = gen.add_raw_line("  | RefCapability.Shared =>")
    gen = gen.add_raw_line("      -- Shared refs allowed unless there's an Exclusive or Isolated ref")
    gen = gen.add_raw_line("      !hasExclusive && !hasIsolated")
    gen = gen.add_raw_line("  | RefCapability.Exclusive =>")
    gen = gen.add_raw_line("      -- Exclusive ref requires no other refs exist")
    gen = gen.add_raw_line("      !hasAnyRefs")
    gen = gen.add_raw_line("  | RefCapability.Isolated =>")
    gen = gen.add_raw_line("      -- Isolated ref requires no other refs exist")
    gen = gen.add_raw_line("      !hasAnyRefs")
    gen = gen.add_blank()

    # addRef and removeRef
    gen = gen.add_doc_comment("Add a reference to the environment")
    gen = gen.add_raw_line("def addRef (env : RefEnv) (ref : Reference) : RefEnv :=")
    gen = gen.add_raw_line("  val loc := ref.location")
    gen = gen.add_raw_line("  val existingRefs := getActiveRefs env loc")
    gen = gen.add_raw_line("  val newRefs := ref :: existingRefs")
    gen = gen.add_raw_line("  val updatedList := env.activeRefs.filter (fun (l, _) => l != loc)")
    gen = gen.add_raw_line("  {{ activeRefs := (loc, newRefs) :: updatedList }}")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Remove a reference from the environment")
    gen = gen.add_raw_line("def removeRef (env : RefEnv) (ref : Reference) : RefEnv :=")
    gen = gen.add_raw_line("  val loc := ref.location")
    gen = gen.add_raw_line("  val existingRefs := getActiveRefs env loc")
    gen = gen.add_raw_line("  val newRefs := existingRefs.filter (fun r => r != ref)")
    gen = gen.add_raw_line("  val updatedList := env.activeRefs.filter (fun (l, _) => l != loc)")
    gen = gen.add_raw_line("  if newRefs.isEmpty then")
    gen = gen.add_raw_line("    {{ activeRefs := updatedList }}")
    gen = gen.add_raw_line("  else")
    gen = gen.add_raw_line("    {{ activeRefs := (loc, newRefs) :: updatedList }}")
    gen = gen.add_blank()

    # canConvert function
    gen = gen.add_doc_comment("Capability conversion rules")
    gen = gen.add_raw_line("def canConvert (from to : RefCapability) : bool :=")
    gen = gen.add_raw_line("  match from, to with")
    gen = gen.add_raw_line("  | a, b => if a == b then true else")
    gen = gen.add_raw_line("    match from, to with")
    gen = gen.add_raw_line("    | RefCapability.Exclusive, RefCapability.Shared => true   -- mut T → T")
    gen = gen.add_raw_line("    | RefCapability.Isolated, RefCapability.Exclusive => true -- iso T → mut T")
    gen = gen.add_raw_line("    | RefCapability.Isolated, RefCapability.Shared => true    -- iso T → T")
    gen = gen.add_raw_line("    | _, _ => false")
    gen = gen.add_blank()

    # Property theorems
    gen = gen.add_doc_comment("Formal properties")

    gen = gen.add_doc_comment("Property 1: Exclusive and Isolated references are unique")
    gen = gen.add_theorem(codegen.build_theorem(
        "exclusive_is_unique",
        [("env", "RefEnv"), ("loc", "Nat")],
        "countRefsWithCapability (getActiveRefs env loc) RefCapability.Exclusive <= 1",
        "sorry"
    ))

    gen = gen.add_theorem(codegen.build_theorem(
        "isolated_is_unique",
        [("env", "RefEnv"), ("loc", "Nat")],
        "countRefsWithCapability (getActiveRefs env loc) RefCapability.Isolated <= 1",
        "sorry"
    ))

    gen = gen.add_doc_comment("Property 2: Exclusive and Isolated prevent other references")
    gen = gen.add_theorem(codegen.build_theorem(
        "exclusive_prevents_aliasing",
        [("env", "RefEnv"), ("loc", "Nat")],
        "countRefsWithCapability (getActiveRefs env loc) RefCapability.Exclusive = 1 →\n  (getActiveRefs env loc).length = 1",
        "sorry"
    ))

    gen = gen.add_theorem(codegen.build_theorem(
        "isolated_prevents_aliasing",
        [("env", "RefEnv"), ("loc", "Nat")],
        "countRefsWithCapability (getActiveRefs env loc) RefCapability.Isolated = 1 →\n  (getActiveRefs env loc).length = 1",
        "sorry"
    ))

    # isMoreRestrictive function and conversion_is_safe theorem
    gen = gen.add_doc_comment("Property 3: Capability conversions are monotonic (lose privileges)")
    gen = gen.add_raw_line("def isMoreRestrictive (a b : RefCapability) : Prop :=")
    gen = gen.add_raw_line("  match a, b with")
    gen = gen.add_raw_line("  | RefCapability.Isolated, RefCapability.Exclusive => True")
    gen = gen.add_raw_line("  | RefCapability.Isolated, RefCapability.Shared => True")
    gen = gen.add_raw_line("  | RefCapability.Exclusive, RefCapability.Shared => True")
    gen = gen.add_raw_line("  | a, b => a = b")
    gen = gen.add_blank()

    gen = gen.add_theorem(codegen.build_theorem(
        "conversion_is_safe",
        [],
        "∀ from to, canConvert from to = true → isMoreRestrictive to from ∨ from = to",
        "intros from to h_convert\ncases from <;> cases to <;> simp [canConvert] at h_convert <;> simp [isMoreRestrictive]\n· right; rfl\n· simp at h_convert\n· simp at h_convert\n· simp at h_convert\n· right; rfl\n· left; trivial\n· simp at h_convert\n· simp at h_convert\n· right; rfl"
    ))

    gen = gen.add_doc_comment("Property 4: Conversions preserve or reduce aliasing potential")
    gen = gen.add_theorem(codegen.build_theorem(
        "conversion_preserves_safety",
        [("env", "RefEnv"), ("loc", "Nat"), ("from", "RefCapability"), ("to", "RefCapability")],
        "canConvert from to = true →\n  canCreateRef env loc from = true →\n  canCreateRef env loc to = true",
        "sorry"
    ))

    # wellFormed definition
    gen = gen.add_doc_comment("Property 5: Reference creation respects aliasing rules")
    gen = gen.add_raw_line("def wellFormed (env : RefEnv) : Prop :=")
    gen = gen.add_raw_line("  ∀ loc refs, (loc, refs) ∈ env.activeRefs →")
    gen = gen.add_raw_line("    -- At most one Exclusive ref")
    gen = gen.add_raw_line("    countRefsWithCapability refs RefCapability.Exclusive <= 1 ∧")
    gen = gen.add_raw_line("    -- At most one Isolated ref")
    gen = gen.add_raw_line("    countRefsWithCapability refs RefCapability.Isolated <= 1 ∧")
    gen = gen.add_raw_line("    -- Exclusive and Isolated are alone")
    gen = gen.add_raw_line("    (countRefsWithCapability refs RefCapability.Exclusive = 1 → refs.length = 1) ∧")
    gen = gen.add_raw_line("    (countRefsWithCapability refs RefCapability.Isolated = 1 → refs.length = 1)")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Creating a reference maintains well-formedness")
    gen = gen.add_theorem(codegen.build_theorem(
        "create_ref_preserves_wellformed",
        [("env", "RefEnv"), ("ref", "Reference")],
        "wellFormed env →\n  canCreateRef env ref.location ref.refType.capability = true →\n  wellFormed (addRef env ref)",
        "sorry"
    ))

    # MemAccess type and access functions
    gen = gen.add_doc_comment("Integration with memory operations")
    gen = gen.add_doc_comment("Memory access (read or write)")
    mem_access = codegen.build_enum_with_deriving("MemAccess", [
        ("Read", [("loc", codegen.make_simple_type("Nat"))]),
        ("Write", [("loc", codegen.make_simple_type("Nat"))])
    ], ["Repr"])
    gen = gen.add_inductive(mem_access)

    gen = gen.add_doc_comment("Check if a reference allows a memory access")
    gen = gen.add_raw_line("def allowsAccess (ref : Reference) (access : MemAccess) : bool :=")
    gen = gen.add_raw_line("  match access with")
    gen = gen.add_raw_line("  | MemAccess.Read loc =>")
    gen = gen.add_raw_line("      -- All capabilities allow reads")
    gen = gen.add_raw_line("      ref.location == loc")
    gen = gen.add_raw_line("  | MemAccess.Write loc =>")
    gen = gen.add_raw_line("      -- Only Exclusive and Isolated allow writes")
    gen = gen.add_raw_line("      ref.location == loc &&")
    gen = gen.add_raw_line("      (ref.refType.capability == RefCapability.Exclusive ||")
    gen = gen.add_raw_line("       ref.refType.capability == RefCapability.Isolated)")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Check if an access is safe in current environment")
    gen = gen.add_raw_line("def accessIsSafe (env : RefEnv) (access : MemAccess) : bool :=")
    gen = gen.add_raw_line("  val loc := match access with")
    gen = gen.add_raw_line("    | MemAccess.Read l => l")
    gen = gen.add_raw_line("    | MemAccess.Write l => l")
    gen = gen.add_raw_line("  val refs := getActiveRefs env loc")
    gen = gen.add_raw_line("  -- At least one ref must allow this access")
    gen = gen.add_raw_line("  refs.any (fun r => allowsAccess r access)")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Property 6: No conflicting accesses")
    gen = gen.add_raw_line("def hasConflictingAccess (env : RefEnv) (loc : Nat) : bool :=")
    gen = gen.add_raw_line("  val refs := getActiveRefs env loc")
    gen = gen.add_raw_line("  -- Conflict: multiple refs and at least one allows write")
    gen = gen.add_raw_line("  refs.length > 1 && refs.any (fun r => allowsAccess r (MemAccess.Write loc))")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Well-formed environments have no conflicts")
    gen = gen.add_theorem(codegen.build_theorem(
        "wellformed_no_conflicts",
        [("env", "RefEnv")],
        "wellFormed env → ∀ loc, hasConflictingAccess env loc = false",
        "sorry"
    ))

    # DataRaceScenario and race prevention theorem
    gen = gen.add_doc_comment("Data race definition: concurrent conflicting accesses")
    gen = gen.add_raw_line("structure DataRaceScenario where")
    gen = gen.add_raw_line("  loc : Nat")
    gen = gen.add_raw_line("  access1 : MemAccess")
    gen = gen.add_raw_line("  access2 : MemAccess")
    gen = gen.add_raw_line("  -- At least one is a write")
    gen = gen.add_raw_line("  hasWrite : access1 matches MemAccess.Write _ ∨ access2 matches MemAccess.Write _")
    gen = gen.add_raw_line("  -- Same location")
    gen = gen.add_raw_line("  sameLocation : (match access1 with | MemAccess.Read l | MemAccess.Write l => l) =")
    gen = gen.add_raw_line("                 (match access2 with | MemAccess.Read l | MemAccess.Write l => l)")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Property 7: Capability system prevents data races")
    gen = gen.add_theorem(codegen.build_theorem(
        "capabilities_prevent_races",
        [("env", "RefEnv"), ("scenario", "DataRaceScenario")],
        "wellFormed env →\n  accessIsSafe env scenario.access1 = true →\n  accessIsSafe env scenario.access2 = true →\n  False",
        "sorry"
    ))

    # Examples
    gen = gen.add_doc_comment("Examples")

    gen = gen.add_doc_comment("Example 1: Shared references can coexist")
    gen = gen.add_raw_line("example : ∃ env : RefEnv,")
    gen = gen.add_raw_line("  val loc := 0")
    gen = gen.add_raw_line("  val ref1 := Reference.mk loc {{ baseType := \"i64\", capability := RefCapability.Shared }}")
    gen = gen.add_raw_line("  val ref2 := Reference.mk loc {{ baseType := \"i64\", capability := RefCapability.Shared }}")
    gen = gen.add_raw_line("  canCreateRef env loc RefCapability.Shared = true ∧")
    gen = gen.add_raw_line("  canCreateRef (addRef env ref1) loc RefCapability.Shared = true := by")
    gen = gen.add_raw_line("  val env : RefEnv := {{ activeRefs := [] }}")
    gen = gen.add_raw_line("  exists env")
    gen = gen.add_raw_line("  simp [canCreateRef, getActiveRefs, countRefsWithCapability, addRef]")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Example 2: Exclusive reference prevents other references")
    gen = gen.add_raw_line("example : ∃ env : RefEnv,")
    gen = gen.add_raw_line("  val loc := 0")
    gen = gen.add_raw_line("  val ref1 := Reference.mk loc {{ baseType := \"i64\", capability := RefCapability.Exclusive }}")
    gen = gen.add_raw_line("  canCreateRef env loc RefCapability.Exclusive = true ∧")
    gen = gen.add_raw_line("  canCreateRef (addRef env ref1) loc RefCapability.Shared = false := by")
    gen = gen.add_raw_line("  val env : RefEnv := {{ activeRefs := [] }}")
    gen = gen.add_raw_line("  exists env")
    gen = gen.add_raw_line("  simp [canCreateRef, getActiveRefs, countRefsWithCapability, addRef]")
    gen = gen.add_raw_line("  sorry")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Example 3: Isolated reference is truly isolated")
    gen = gen.add_raw_line("example : ∃ env : RefEnv,")
    gen = gen.add_raw_line("  val loc := 0")
    gen = gen.add_raw_line("  val ref1 := Reference.mk loc {{ baseType := \"i64\", capability := RefCapability.Isolated }}")
    gen = gen.add_raw_line("  canCreateRef env loc RefCapability.Isolated = true ∧")
    gen = gen.add_raw_line("  canCreateRef (addRef env ref1) loc RefCapability.Shared = false ∧")
    gen = gen.add_raw_line("  canCreateRef (addRef env ref1) loc RefCapability.Exclusive = false := by")
    gen = gen.add_raw_line("  val env : RefEnv := {{ activeRefs := [] }}")
    gen = gen.add_raw_line("  exists env")
    gen = gen.add_raw_line("  simp [canCreateRef, getActiveRefs, countRefsWithCapability, addRef]")
    gen = gen.add_raw_line("  sorry")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Example 4: Safe conversion from Exclusive to Shared")
    gen = gen.add_raw_line("example :")
    gen = gen.add_raw_line("  canConvert RefCapability.Exclusive RefCapability.Shared = true := by")
    gen = gen.add_raw_line("  simp [canConvert]")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Example 5: Safe conversion from Isolated to Exclusive")
    gen = gen.add_raw_line("example :")
    gen = gen.add_raw_line("  canConvert RefCapability.Isolated RefCapability.Exclusive = true := by")
    gen = gen.add_raw_line("  simp [canConvert]")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Example 6: Unsafe conversion (Shared to Exclusive) is rejected")
    gen = gen.add_raw_line("example :")
    gen = gen.add_raw_line("  canConvert RefCapability.Shared RefCapability.Exclusive = false := by")
    gen = gen.add_raw_line("  simp [canConvert]")
    gen = gen.add_blank()

    # Concurrency mode integration
    gen = gen.add_doc_comment("Concurrency mode integration")
    concurrency = codegen.build_enum_with_deriving("ConcurrencyMode", [
        ("Actor", []),
        ("LockBase", []),
        ("Unsafe", [])
    ], ["DecidableEq", "Repr"])
    gen = gen.add_inductive(concurrency)

    gen = gen.add_doc_comment("Check if capability is allowed in concurrency mode")
    gen = gen.add_raw_line("def capabilityAllowedInMode (cap : RefCapability) (mode : ConcurrencyMode) : bool :=")
    gen = gen.add_raw_line("  match mode with")
    gen = gen.add_raw_line("  | ConcurrencyMode.Actor =>")
    gen = gen.add_raw_line("      -- Actor mode: only Shared and Isolated (no mut across actors)")
    gen = gen.add_raw_line("      cap == RefCapability.Shared || cap == RefCapability.Isolated")
    gen = gen.add_raw_line("  | ConcurrencyMode.LockBase =>")
    gen = gen.add_raw_line("      -- Lock-based: all capabilities allowed (protected by locks)")
    gen = gen.add_raw_line("      true")
    gen = gen.add_raw_line("  | ConcurrencyMode.Unsafe =>")
    gen = gen.add_raw_line("      -- Unsafe mode: all capabilities allowed")
    gen = gen.add_raw_line("      true")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Property 8: Actor mode prevents shared mutable state")
    gen = gen.add_theorem(codegen.build_theorem(
        "actor_mode_safety",
        [],
        "∀ cap, capabilityAllowedInMode cap ConcurrencyMode.Actor = true →\n         cap ≠ RefCapability.Exclusive",
        "intros cap h_allowed\ncases cap <;> simp [capabilityAllowedInMode] at h_allowed\n· intro h_eq; cases h_eq\n· simp at h_allowed\n· intro h_eq; cases h_eq"
    ))

    # Runtime integration
    gen = gen.add_doc_comment("Runtime integration")
    gen = gen.add_doc_comment("Check if all references in environment satisfy mode constraints")
    gen = gen.add_raw_line("def envSatisfiesMode (env : RefEnv) (mode : ConcurrencyMode) : bool :=")
    gen = gen.add_raw_line("  env.activeRefs.all fun (_, refs) =>")
    gen = gen.add_raw_line("    refs.all fun ref => capabilityAllowedInMode ref.refType.capability mode")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Property 9: Mode constraints preserve safety")
    gen = gen.add_theorem(codegen.build_theorem(
        "mode_safety",
        [("env", "RefEnv"), ("mode", "ConcurrencyMode")],
        "wellFormed env →\n  envSatisfiesMode env mode = true →\n  ∀ loc, hasConflictingAccess env loc = false",
        "sorry"
    ))

    # Summary
    gen = gen.add_block_comment([
        "## Verification Summary",
        "",
        "This module proves the following key properties of the capability system:",
        "",
        "1. **Uniqueness**: Exclusive and Isolated references are unique (at most one)",
        "2. **Isolation**: Exclusive and Isolated prevent all aliasing",
        "3. **Safe Conversions**: Capability conversions are monotonic (lose privileges)",
        "4. **Well-Formedness**: Reference creation maintains environment invariants",
        "5. **No Conflicts**: Well-formed environments have no conflicting accesses",
        "6. **Data Race Freedom**: Capabilities prevent concurrent conflicting accesses",
        "7. **Concurrency Modes**: Actor mode enforces no shared mutable state",
        "",
        "These properties guarantee that the Simple language's memory model prevents",
        "data races at compile time through the type system."
    ])

    return gen.emit()


# ============================================================================
# 12. Memory Model DRF - MemoryModelDRF.lean (510 lines)
# ============================================================================

