# Type Inference - Type inference model generation
# Generates Lean verification for type inference

import verification.lean.codegen as codegen

fn regenerate_type_inference_compile() -> String:
    gen = codegen.LeanCodegen.create("TypeInferenceCompile")

    gen = gen.add_namespace("TypeInferenceCompile")

    # Doc comment
    gen = gen.add_doc_comment("Simple expression language to model inference.\n    Extended with Str type for practical string handling.")

    # Ty inductive
    ty = codegen.build_enum_with_deriving("Ty", [
        ("nat", []),
        ("bool", []),
        ("str", []),
        ("generic", [("name", codegen.make_string_type()), ("args", codegen.make_list_type(codegen.make_simple_type("Ty")))]),
        ("arrow", [("a", codegen.make_simple_type("Ty")), ("b", codegen.make_simple_type("Ty"))])
    ], ["Repr"])
    gen = gen.add_inductive(ty)

    # Expr inductive
    expr = codegen.build_enum_with_deriving("Expr", [
        ("litNat", [("n", codegen.make_simple_type("Nat"))]),
        ("litBool", [("b", codegen.make_bool_type())]),
        ("litStr", [("s", codegen.make_string_type())]),
        ("add", [("a", codegen.make_simple_type("Expr")), ("b", codegen.make_simple_type("Expr"))]),
        ("concat", [("a", codegen.make_simple_type("Expr")), ("b", codegen.make_simple_type("Expr"))]),
        ("generic", [("name", codegen.make_string_type()), ("args", codegen.make_list_type(codegen.make_simple_type("Expr")))]),
        ("ifElse", [("c", codegen.make_simple_type("Expr")), ("t", codegen.make_simple_type("Expr")), ("e", codegen.make_simple_type("Expr"))]),
        ("lam", [("body", codegen.make_simple_type("Expr"))]),
        ("app", [("", codegen.make_simple_type("Expr")), ("x", codegen.make_simple_type("Expr"))])
    ], ["Repr"])
    gen = gen.add_inductive(expr)

    # Mutual tyEq and listEq
    gen = gen.add_raw_line("mutual")
    gen = gen.add_raw_line("  partial def tyEq : Ty → Ty → Bool")
    gen = gen.add_raw_line("    | Ty.nat, Ty.nat => true")
    gen = gen.add_raw_line("    | Ty.bool, Ty.bool => true")
    gen = gen.add_raw_line("    | Ty.str, Ty.str => true")
    gen = gen.add_raw_line("    | Ty.generic name args, Ty.generic name' args' =>")
    gen = gen.add_raw_line("      if h_name : name = name' then")
    gen = gen.add_raw_line("        listEq args args'")
    gen = gen.add_raw_line("      else")
    gen = gen.add_raw_line("        false")
    gen = gen.add_raw_line("    | Ty.arrow a b, Ty.arrow a' b' => tyEq a a' && tyEq b b'")
    gen = gen.add_raw_line("    | _, _ => false")
    gen = gen.add_blank()
    gen = gen.add_raw_line("  partial def listEq : List Ty → List Ty → Bool")
    gen = gen.add_raw_line("    | [], [] => true")
    gen = gen.add_raw_line("    | hd :: tl, hd' :: tl' =>")
    gen = gen.add_raw_line("      if tyEq hd hd' then listEq tl tl' else false")
    gen = gen.add_raw_line("    | _, _ => false")
    gen = gen.add_raw_line("end")
    gen = gen.add_blank()

    # infer function
    gen = gen.add_doc_comment("A partial inference judgment; returns `none` on mismatch.")
    gen = gen.add_raw_line("def infer : Expr → Option Ty")
    gen = gen.add_raw_line("  | Expr.litNat _ => some Ty.nat")
    gen = gen.add_raw_line("  | Expr.litBool _ => some Ty.bool")
    gen = gen.add_raw_line("  | Expr.litStr _ => some Ty.str")
    gen = gen.add_raw_line("  | Expr.generic name args =>")
    gen = gen.add_raw_line("    let rec inferList : List Expr → Option (List Ty)")
    gen = gen.add_raw_line("      | [] => some []")
    gen = gen.add_raw_line("      | hd :: tl =>")
    gen = gen.add_raw_line("        match infer hd, inferList tl with")
    gen = gen.add_raw_line("        | some hd_ty, some tl_tys => some (hd_ty :: tl_tys)")
    gen = gen.add_raw_line("        | _, _ => none")
    gen = gen.add_raw_line("    match inferList args with")
    gen = gen.add_raw_line("    | some arg_tys => some (Ty.generic name arg_tys)")
    gen = gen.add_raw_line("    | none => none")
    gen = gen.add_raw_line("  | Expr.add a b => do")
    gen = gen.add_raw_line("      let ta ← infer a")
    gen = gen.add_raw_line("      let tb ← infer b")
    gen = gen.add_raw_line("      match ta, tb with")
    gen = gen.add_raw_line("      | Ty.nat, Ty.nat => pure Ty.nat")
    gen = gen.add_raw_line("      | _, _ => none")
    gen = gen.add_raw_line("  | Expr.concat a b => do")
    gen = gen.add_raw_line("      let ta ← infer a")
    gen = gen.add_raw_line("      let tb ← infer b")
    gen = gen.add_raw_line("      match ta, tb with")
    gen = gen.add_raw_line("      | Ty.str, Ty.str => pure Ty.str")
    gen = gen.add_raw_line("      | _, _ => none")
    gen = gen.add_raw_line("  | Expr.ifElse c t e => do")
    gen = gen.add_raw_line("      let tc ← infer c")
    gen = gen.add_raw_line("      match tc with")
    gen = gen.add_raw_line("      | Ty.bool =>")
    gen = gen.add_raw_line("        let τt ← infer t")
    gen = gen.add_raw_line("        let τe ← infer e")
    gen = gen.add_raw_line("        if tyEq τt τe then pure τt else none")
    gen = gen.add_raw_line("      | _ => none")
    gen = gen.add_raw_line("  | Expr.lam body => do")
    gen = gen.add_raw_line("      let τ ← infer body")
    gen = gen.add_raw_line("      pure (Ty.arrow Ty.nat τ)")
    gen = gen.add_raw_line("  | Expr.app f x => do")
    gen = gen.add_raw_line("      let tf ← infer f")
    gen = gen.add_raw_line("      match tf with")
    gen = gen.add_raw_line("      | Ty.arrow a b =>")
    gen = gen.add_raw_line("        let τx ← infer x")
    gen = gen.add_raw_line("        if tyEq τx a then pure b else none")
    gen = gen.add_raw_line("      | _ => none")
    gen = gen.add_blank()

    # Determinism theorem
    gen = gen.add_doc_comment("Determinism: inference yields at most one type.")
    gen = gen.add_theorem(codegen.build_theorem(
        "infer_deterministic",
        [("e", "Expr"), ("t₁", "Ty"), ("t₂", "Ty")],
        "infer e = some t₁ → infer e = some t₂ → t₁ = t₂",
        "intro h1 h2\nhave : some t₁ = some t₂ := by simpa [h1] using h2\ncases this\nrfl"
    ))

    gen = gen.end_namespace("TypeInferenceCompile")

    return gen.emit()


# ============================================================================
# 9. Type Inference - Generics.lean (458 lines)
# ============================================================================

