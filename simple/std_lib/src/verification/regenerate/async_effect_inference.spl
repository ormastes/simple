# Async Effect Inference - Automatic async/sync effect detection model generation
# Generates Lean verification for async/sync effect inference based on function body analysis.
#
# Key properties verified:
# 1. Effect Determinism: Each function has exactly one inferred effect
# 2. Effect Propagation: Calling async function makes caller async
# 3. Suspension Detection: ~=, if~, while~ operators indicate async
# 4. Sync Safety: sync-annotated functions cannot contain suspension

import verification.lean.codegen as codegen

fn regenerate_async_effect_inference() -> String:
    gen = codegen.LeanCodegen.create("AsyncEffectInference")

    # =========================================================================
    # Auto-generated header
    # =========================================================================

    gen = gen.add_raw_line("/-")
    gen = gen.add_raw_line("  ============================================================================")
    gen = gen.add_raw_line("  AUTO-GENERATED - DO NOT EDIT MANUALLY")
    gen = gen.add_raw_line("  ============================================================================")
    gen = gen.add_raw_line("  Generated from: simple/std_lib/src/verification/regenerate/async_effect_inference.spl")
    gen = gen.add_raw_line("  To regenerate: ./target/debug/simple simple/std_lib/src/verification/regenerate/__init__.spl")
    gen = gen.add_raw_line("  ============================================================================")
    gen = gen.add_raw_line("-/")
    gen = gen.add_blank()

    gen = gen.add_raw_line("/-")
    gen = gen.add_raw_line("  Async/Sync Effect Inference Model for Simple Language")
    gen = gen.add_raw_line("")
    gen = gen.add_raw_line("  This module models the automatic inference of async/sync effects")
    gen = gen.add_raw_line("  based on function body analysis. Key properties:")
    gen = gen.add_raw_line("")
    gen = gen.add_raw_line("  1. Effect Determinism: Each function has exactly one inferred effect")
    gen = gen.add_raw_line("  2. Effect Propagation: Calling async function makes caller async")
    gen = gen.add_raw_line("  3. Suspension Detection: ~=, if~, while~ operators indicate async")
    gen = gen.add_raw_line("  4. Sync Safety: sync-annotated functions cannot contain suspension")
    gen = gen.add_raw_line("")
    gen = gen.add_raw_line("  Generated from: simple/std_lib/src/verification/regenerate/async_effect_inference.spl")
    gen = gen.add_raw_line("-/")
    gen = gen.add_blank()

    gen = gen.add_namespace("AsyncEffectInference")

    # =========================================================================
    # Effect Type
    # =========================================================================

    gen = gen.add_doc_comment("Effect annotation for functions")
    effect_enum = codegen.build_enum_with_deriving("Effect", [
        ("sync", []),   # Non-suspending, direct return T
        ("async", [])   # May suspend, returns Promise[T]
    ], ["DecidableEq", "Repr"])
    gen = gen.add_inductive(effect_enum)

    # =========================================================================
    # Suspension Operators
    # =========================================================================

    gen = gen.add_doc_comment("Suspension operators in the language")
    suspension_op_enum = codegen.build_enum_with_deriving("SuspensionOp", [
        ("suspendAssign", []),    # ~=
        ("suspendIf", []),        # if~
        ("suspendWhile", []),     # while~
        ("suspendFor", []),       # for~
        ("suspendAnd", []),       # and~
        ("suspendOr", [])         # or~
    ], ["DecidableEq", "Repr"])
    gen = gen.add_inductive(suspension_op_enum)

    # =========================================================================
    # Expression Type
    # =========================================================================

    gen = gen.add_doc_comment("Expression with effect tracking")
    expr_enum = codegen.build_enum_with_deriving("Expr", [
        ("lit", [("n", codegen.make_simple_type("Nat"))]),
        ("var", [("name", codegen.make_string_type())]),
        ("binOp", [("a", codegen.make_simple_type("Expr")), ("b", codegen.make_simple_type("Expr"))]),
        ("call", [("fn", codegen.make_string_type()), ("args", codegen.make_list_type(codegen.make_simple_type("Expr")))]),
        ("suspend", [("op", codegen.make_simple_type("SuspensionOp")), ("e", codegen.make_simple_type("Expr"))]),
        ("lambda", [("body", codegen.make_simple_type("Expr"))]),
        ("ifExpr", [("cond", codegen.make_simple_type("Expr")), ("t", codegen.make_simple_type("Expr")), ("e", codegen.make_simple_type("Expr"))])
    ], ["Repr"])
    gen = gen.add_inductive(expr_enum)

    # =========================================================================
    # Function Declaration
    # =========================================================================

    gen = gen.add_doc_comment("Function declaration with optional explicit effect annotation")
    gen = gen.add_raw_line("structure FnDecl where")
    gen = gen.add_raw_line("  name : String")
    gen = gen.add_raw_line("  body : Expr")
    gen = gen.add_raw_line("  explicitEffect : Option Effect  -- None = infer, Some = explicit")
    gen = gen.add_raw_line("  deriving Repr")
    gen = gen.add_blank()

    # =========================================================================
    # Environment Type
    # =========================================================================

    gen = gen.add_doc_comment("Environment mapping function names to their effects")
    gen = gen.add_raw_line("def Env := String → Option Effect")
    gen = gen.add_blank()

    # =========================================================================
    # Contains Suspension Function
    # =========================================================================

    gen = gen.add_doc_comment("Check if expression contains any suspension operator")
    gen = gen.add_raw_line("def containsSuspension : Expr → Bool")
    gen = gen.add_raw_line("  | Expr.lit _ => false")
    gen = gen.add_raw_line("  | Expr.var _ => false")
    gen = gen.add_raw_line("  | Expr.binOp a b => containsSuspension a || containsSuspension b")
    gen = gen.add_raw_line("  | Expr.call _ args => args.any containsSuspension")
    gen = gen.add_raw_line("  | Expr.suspend _ _ => true  -- Suspension found!")
    gen = gen.add_raw_line("  | Expr.lambda body => containsSuspension body")
    gen = gen.add_raw_line("  | Expr.ifExpr c t e => containsSuspension c || containsSuspension t || containsSuspension e")
    gen = gen.add_blank()

    # =========================================================================
    # Infer Expression Effect
    # =========================================================================

    gen = gen.add_doc_comment("Infer effect of expression given environment")
    gen = gen.add_raw_line("partial def inferExprEffect (env : Env) : Expr → Effect")
    gen = gen.add_raw_line("  | Expr.lit _ => Effect.sync")
    gen = gen.add_raw_line("  | Expr.var _ => Effect.sync")
    gen = gen.add_raw_line("  | Expr.binOp a b =>")
    gen = gen.add_raw_line("    match inferExprEffect env a, inferExprEffect env b with")
    gen = gen.add_raw_line("    | Effect.async, _ => Effect.async")
    gen = gen.add_raw_line("    | _, Effect.async => Effect.async")
    gen = gen.add_raw_line("    | _, _ => Effect.sync")
    gen = gen.add_raw_line("  | Expr.call fn args =>")
    gen = gen.add_raw_line("    -- Check if called function is async")
    gen = gen.add_raw_line("    let fnEffect := match env fn with")
    gen = gen.add_raw_line("      | some eff => eff")
    gen = gen.add_raw_line("      | none => Effect.sync")
    gen = gen.add_raw_line("    let argsAsync := args.any (fun e => inferExprEffect env e == Effect.async)")
    gen = gen.add_raw_line("    if fnEffect == Effect.async || argsAsync then Effect.async else Effect.sync")
    gen = gen.add_raw_line("  | Expr.suspend _ _ => Effect.async  -- Suspension always async")
    gen = gen.add_raw_line("  | Expr.lambda body => inferExprEffect env body")
    gen = gen.add_raw_line("  | Expr.ifExpr c t e =>")
    gen = gen.add_raw_line("    match inferExprEffect env c, inferExprEffect env t, inferExprEffect env e with")
    gen = gen.add_raw_line("    | Effect.async, _, _ => Effect.async")
    gen = gen.add_raw_line("    | _, Effect.async, _ => Effect.async")
    gen = gen.add_raw_line("    | _, _, Effect.async => Effect.async")
    gen = gen.add_raw_line("    | _, _, _ => Effect.sync")
    gen = gen.add_blank()

    # =========================================================================
    # Infer Function Effect
    # =========================================================================

    gen = gen.add_doc_comment("Infer effect of function declaration")
    gen = gen.add_raw_line("def inferFnEffect (env : Env) (fn : FnDecl) : Effect :=")
    gen = gen.add_raw_line("  match fn.explicitEffect with")
    gen = gen.add_raw_line("  | some eff => eff  -- Explicit annotation takes precedence")
    gen = gen.add_raw_line("  | none => inferExprEffect env fn.body")
    gen = gen.add_blank()

    # =========================================================================
    # Validate Sync Constraint
    # =========================================================================

    gen = gen.add_doc_comment("Validate sync constraint: sync function must not contain suspension")
    gen = gen.add_raw_line("def validateSyncConstraint (fn : FnDecl) : Bool :=")
    gen = gen.add_raw_line("  match fn.explicitEffect with")
    gen = gen.add_raw_line("  | some Effect.sync => !containsSuspension fn.body")
    gen = gen.add_raw_line("  | _ => true")
    gen = gen.add_blank()

    # =========================================================================
    # Theorems
    # =========================================================================

    # Theorem 1: Effect Determinism
    gen = gen.add_doc_comment("Effect is deterministic: inference yields exactly one effect")
    gen = gen.add_theorem(codegen.build_theorem(
        "effect_deterministic",
        [("env", "Env"), ("e", "Expr")],
        "∃! eff : Effect, inferExprEffect env e = eff",
        "exists inferExprEffect env e\nsimp only [and_iff_right]\nintros y hy\nexact hy.symm"
    ))

    # Theorem 2: Suspension Implies Async
    gen = gen.add_doc_comment("Suspension implies async: any suspension operator makes expression async")
    gen = gen.add_theorem(codegen.build_theorem(
        "suspension_implies_async",
        [("env", "Env"), ("op", "SuspensionOp"), ("e", "Expr")],
        "inferExprEffect env (Expr.suspend op e) = Effect.async",
        "simp [inferExprEffect]"
    ))

    # Theorem 3: Sync Safety
    gen = gen.add_doc_comment("Sync safety: if validateSyncConstraint passes, no suspension in body")
    gen = gen.add_theorem(codegen.build_theorem(
        "sync_safety",
        [("fn", "FnDecl")],
        "fn.explicitEffect = some Effect.sync → validateSyncConstraint fn = true → !containsSuspension fn.body = true",
        "intro h_explicit h_valid\nsimp [validateSyncConstraint, h_explicit] at h_valid\nexact h_valid"
    ))

    # Theorem 4: Async Propagation
    gen = gen.add_doc_comment("Effect propagation: calling async function in body makes caller async")
    gen = gen.add_theorem(codegen.build_theorem(
        "async_propagation",
        [("env", "Env"), ("fn_name", "String"), ("args", "List Expr")],
        "env fn_name = some Effect.async → inferExprEffect env (Expr.call fn_name args) = Effect.async",
        "intro h_async\nsimp [inferExprEffect, h_async]"
    ))

    # Theorem 5: Literals are Sync
    gen = gen.add_doc_comment("Literals are always sync")
    gen = gen.add_theorem(codegen.build_theorem(
        "lit_is_sync",
        [("env", "Env"), ("n", "Nat")],
        "inferExprEffect env (Expr.lit n) = Effect.sync",
        "simp [inferExprEffect]"
    ))

    # =========================================================================
    # Helper Functions
    # =========================================================================

    gen = gen.add_doc_comment("Build environment from list of function declarations")
    gen = gen.add_raw_line("def buildEnv (fns : List FnDecl) : Env :=")
    gen = gen.add_raw_line("  fun name => (fns.find? (fun f => f.name == name)).map (inferFnEffect (fun _ => none))")
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Fixed-point iteration for mutually recursive functions")
    gen = gen.add_raw_line("partial def inferMutualEffects (fns : List FnDecl) (maxIter : Nat := 100) : Env :=")
    gen = gen.add_raw_line("  let rec iterate (env : Env) (n : Nat) : Env :=")
    gen = gen.add_raw_line("    if n == 0 then env")
    gen = gen.add_raw_line("    else")
    gen = gen.add_raw_line("      let newEnv : Env := fun name =>")
    gen = gen.add_raw_line("        match fns.find? (fun f => f.name == name) with")
    gen = gen.add_raw_line("        | some fn => some (inferFnEffect env fn)")
    gen = gen.add_raw_line("        | none => env name")
    gen = gen.add_raw_line("      -- Check for fixed point")
    gen = gen.add_raw_line("      let changed := fns.any (fun fn => newEnv fn.name != env fn.name)")
    gen = gen.add_raw_line("      if changed then iterate newEnv (n - 1) else newEnv")
    gen = gen.add_raw_line("  iterate (fun _ => none) maxIter")
    gen = gen.add_blank()

    # =========================================================================
    # Examples
    # =========================================================================

    gen = gen.add_doc_comment("Example: sync function")
    gen = gen.add_raw_line('def syncExample : FnDecl := \{')
    gen = gen.add_raw_line('  name := "double"')
    gen = gen.add_raw_line('  body := Expr.binOp (Expr.var "x") (Expr.lit 2)')
    gen = gen.add_raw_line('  explicitEffect := none')
    gen = gen.add_raw_line('\}')
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Example: async function with suspension")
    gen = gen.add_raw_line('def asyncExample : FnDecl := \{')
    gen = gen.add_raw_line('  name := "fetchUser"')
    gen = gen.add_raw_line('  body := Expr.suspend SuspensionOp.suspendAssign (Expr.call "http_get" [Expr.var "url"])')
    gen = gen.add_raw_line('  explicitEffect := none')
    gen = gen.add_raw_line('\}')
    gen = gen.add_blank()

    gen = gen.add_doc_comment("Example: explicit sync constraint")
    gen = gen.add_raw_line('def explicitSyncExample : FnDecl := \{')
    gen = gen.add_raw_line('  name := "compute"')
    gen = gen.add_raw_line('  body := Expr.binOp (Expr.var "x") (Expr.var "x")')
    gen = gen.add_raw_line('  explicitEffect := some Effect.sync')
    gen = gen.add_raw_line('\}')
    gen = gen.add_blank()

    # =========================================================================
    # Check statements
    # =========================================================================

    gen = gen.add_raw_line("#check effect_deterministic")
    gen = gen.add_raw_line("#check suspension_implies_async")
    gen = gen.add_raw_line("#check sync_safety")
    gen = gen.add_raw_line("#check async_propagation")
    gen = gen.add_blank()

    # End namespace
    gen = gen.end_namespace("AsyncEffectInference")

    return gen.emit()


# Main entry point for testing
fn main():
    print("Generating AsyncEffectInference.lean...")
    content = regenerate_async_effect_inference()
    print(content)
    print("")
    print("Generated content successfully")
