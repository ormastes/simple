# Memory Capabilities Model
# Formal model for reference capabilities matching Lean 4 definitions.
#
# This implements the reference capability system for Simple:
# - `mut T` - Mutable, exclusive reference
# - `iso T` - Isolated, transferable ownership  
# - `T` - Immutable, shared reference
#
# ## Capability Rules
#
# | From | To | Allowed |
# |------|-----|---------|
# | mut | iso | Yes (consume) |
# | mut | imm | Yes (freeze) |
# | iso | mut | Yes (recover) |
# | iso | imm | Yes (share) |
# | imm | mut | No |
# | imm | iso | No |

# Reference capability enum
# Matches Lean: inductive RefCapability
enum RefCapability:
    Mut    # Mutable, exclusive access
    Iso    # Isolated, transferable ownership
    Imm    # Immutable, shared read-only

    # Get string representation
    fn to_string(self) -> String:
        match self:
            case Mut: "mut"
            case Iso: "iso"
            case Imm: "imm"

    # Check if this capability allows mutation
    fn allows_mutation(self) -> Bool:
        match self:
            case Mut: true
            case Iso: true
            case Imm: false

    # Check if this capability can be aliased
    fn allows_aliasing(self) -> Bool:
        match self:
            case Mut: false
            case Iso: false
            case Imm: true

# Capability type - combines a capability with a type name
# Matches Lean: structure CapType
class CapType:
    cap: RefCapability
    type_name: String

    fn new(cap: RefCapability, type_name: String) -> CapType:
        CapType(cap: cap, type_name: type_name)

    fn mut_type(type_name: String) -> CapType:
        CapType(cap: RefCapability.Mut, type_name: type_name)

    fn iso_type(type_name: String) -> CapType:
        CapType(cap: RefCapability.Iso, type_name: type_name)

    fn imm_type(type_name: String) -> CapType:
        CapType(cap: RefCapability.Imm, type_name: type_name)

    fn to_string(self) -> String:
        if self.cap == RefCapability.Imm:
            self.type_name
        else:
            "{self.cap.to_string()} {self.type_name}"

# Reference in the environment
# Matches Lean: structure Reference
class Reference:
    name: String
    cap_type: CapType
    is_consumed: Bool

    fn new(name: String, cap_type: CapType) -> Reference:
        Reference(name: name, cap_type: cap_type, is_consumed: false)

    fn consume(mut self):
        self.is_consumed = true

    fn is_available(self) -> Bool:
        not self.is_consumed

# Reference environment for tracking capabilities
# Matches Lean: structure RefEnv
class RefEnv:
    refs: Dict<String, Reference>

    fn new() -> RefEnv:
        RefEnv(refs: {})

    fn add(mut self, name: String, cap_type: CapType):
        self.refs[name] = Reference.new(name, cap_type)

    fn get(self, name: String) -> Option<Reference>:
        self.refs.get(name)

    fn consume(mut self, name: String) -> Result<Nil, String>:
        match self.refs.get(name):
            case Some(ref):
                if ref.is_consumed:
                    Err("Reference '{name}' already consumed")
                else:
                    ref.consume()
                    Ok(nil)
            case None:
                Err("Reference '{name}' not found")

    fn is_available(self, name: String) -> Bool:
        match self.refs.get(name):
            case Some(ref):
                ref.is_available()
            case None:
                false

# Check if a reference can be created from a source capability
# Matches Lean: def canCreateRef
fn can_create_ref(source: RefCapability, target: RefCapability) -> Bool:
    match (source, target):
        # mut can create anything (with restrictions)
        case (RefCapability.Mut, RefCapability.Mut): true
        case (RefCapability.Mut, RefCapability.Iso): true  # consume
        case (RefCapability.Mut, RefCapability.Imm): true  # freeze

        # iso can create mut or imm
        case (RefCapability.Iso, RefCapability.Mut): true  # recover
        case (RefCapability.Iso, RefCapability.Iso): true
        case (RefCapability.Iso, RefCapability.Imm): true  # share

        # imm can only create imm (aliasing)
        case (RefCapability.Imm, RefCapability.Mut): false
        case (RefCapability.Imm, RefCapability.Iso): false
        case (RefCapability.Imm, RefCapability.Imm): true

# Check if capability conversion is allowed
# Matches Lean: def canConvert
fn can_convert(from_cap: RefCapability, to_cap: RefCapability) -> Bool:
    can_create_ref(from_cap, to_cap)

# Conversion kind - how a capability conversion happens
enum ConversionKind:
    Identity   # Same capability
    Consume    # mut -> iso
    Freeze     # mut -> imm
    Recover    # iso -> mut
    Share      # iso -> imm
    Invalid    # Not allowed

    fn to_string(self) -> String:
        match self:
            case Identity: "identity"
            case Consume: "consume"
            case Freeze: "freeze"
            case Recover: "recover"
            case Share: "share"
            case Invalid: "invalid"

# Get the kind of conversion between capabilities
fn get_conversion_kind(from_cap: RefCapability, to_cap: RefCapability) -> ConversionKind:
    match (from_cap, to_cap):
        case (RefCapability.Mut, RefCapability.Mut): ConversionKind.Identity
        case (RefCapability.Mut, RefCapability.Iso): ConversionKind.Consume
        case (RefCapability.Mut, RefCapability.Imm): ConversionKind.Freeze

        case (RefCapability.Iso, RefCapability.Mut): ConversionKind.Recover
        case (RefCapability.Iso, RefCapability.Iso): ConversionKind.Identity
        case (RefCapability.Iso, RefCapability.Imm): ConversionKind.Share

        case (RefCapability.Imm, RefCapability.Imm): ConversionKind.Identity
        case _: ConversionKind.Invalid

# Capability checking result
class CapabilityCheckResult:
    is_valid: Bool
    errors: List<String>
    warnings: List<String>

    fn new() -> CapabilityCheckResult:
        CapabilityCheckResult(is_valid: true, errors: [], warnings: [])

    fn add_error(mut self, msg: String):
        self.is_valid = false
        self.errors.push(msg)

    fn add_warning(mut self, msg: String):
        self.warnings.push(msg)

# Check capability usage in an expression
fn check_capability_usage(env: RefEnv, name: String, required: RefCapability) -> CapabilityCheckResult:
    let mut result = CapabilityCheckResult.new()

    match env.get(name):
        case None:
            result.add_error("Reference '{name}' not in scope")
        case Some(ref):
            if not ref.is_available():
                result.add_error("Reference '{name}' has been consumed")
            else if not can_create_ref(ref.cap_type.cap, required):
                result.add_error(
                    "Cannot use '{name}' with capability {ref.cap_type.cap.to_string()} " +
                    "where {required.to_string()} is required"
                )

    result
