# Visibility Export Model
#
# Formal model for visibility and export rules.
# Mirrors: verification/visibility_export/src/VisibilityExport.lean

# Visibility levels
enum Visibility:
    Private    # Only visible in defining module
    Internal   # Visible in package
    Public     # Visible everywhere

    fn is_private() -> bool:
        """Check if this is Private visibility.
        Returns: true for Private
        Example: Visibility.Private.is_private()  # → true
        """
        match self:
            case Private: true
            case _: false

    fn is_internal() -> bool:
        """Check if this is Internal visibility.
        Returns: true for Internal
        Example: Visibility.Internal.is_internal()  # → true
        """
        match self:
            case Internal: true
            case _: false

    fn is_public() -> bool:
        """Check if this is Public visibility.
        Returns: true for Public
        Example: Visibility.Public.is_public()  # → true
        """
        match self:
            case Public: true
            case _: false

    fn is_module_scoped() -> bool:
        """Check if visibility is module-scoped only.
        Returns: true for Private
        Example: Visibility.Private.is_module_scoped()  # → true
        """
        match self:
            case Private: true
            case _: false

    fn is_package_scoped() -> bool:
        """Check if visibility is package-scoped.
        Returns: true for Internal
        Example: Visibility.Internal.is_package_scoped()  # → true
        """
        match self:
            case Internal: true
            case _: false

    fn is_globally_visible() -> bool:
        """Check if visibility is global (unrestricted).
        Returns: true for Public
        Example: Visibility.Public.is_globally_visible()  # → true
        """
        match self:
            case Public: true
            case _: false

    fn is_restricted() -> bool:
        """Check if visibility has restrictions.
        Returns: false for Public, true otherwise
        Example: Visibility.Private.is_restricted()  # → true
        """
        match self:
            case Public: false
            case _: true

    fn is_more_visible_than(other: Visibility) -> bool:
        """Check if this visibility is more visible than another.
        Ordering: Private < Internal < Public
        Returns: true if this is strictly more visible
        Example: Visibility.Public.is_more_visible_than(Visibility.Internal)  # → true
        """
        match (self, other):
            case (Public, Internal): true
            case (Public, Private): true
            case (Internal, Private): true
            case _: false

    fn is_compatible_with(required: Visibility) -> bool:
        """Check if this visibility satisfies a required visibility.
        A more visible level satisfies a less visible requirement.
        Returns: true if compatible
        Example: Visibility.Public.is_compatible_with(Visibility.Internal)  # → true
        """
        match (self, required):
            case (Public, _): true
            case (Internal, Internal): true
            case (Internal, Private): true
            case (Private, Private): true
            case _: false

    fn can_access(from_same_module: bool, from_same_package: bool) -> bool:
        """Check if access is allowed given module/package context.
        Args:
            from_same_module: Whether accessing from same module
            from_same_package: Whether accessing from same package
        Returns: true if access allowed
        Example: Visibility.Internal.can_access(false, true)  # → true
        """
        match self:
            case Public: return True
            case Internal: return from_same_package
            case Private: return from_same_module

    fn to_string() -> text:
        """Convert Visibility to string representation.
        Returns: lowercase string name
        Example: Visibility.Public.to_string()  # → "public"
        """
        match self:
            case Private: "private"
            case Internal: "internal"
            case Public: "public"

    fn description() -> text:
        """Get human-readable description of the visibility level.
        Returns: descriptive explanation
        Example: Visibility.Private.description()  # → "Visible only in defining module"
        """
        match self:
            case Private: "Visible only in defining module"
            case Internal: "Visible within package"
            case Public: "Visible everywhere"

    fn summary() -> text:
        """Get comprehensive summary of the visibility level.
        Returns: summary with name, description, and scope properties
        Example: Visibility.Internal.summary()
                # → "Visibility: internal (Visible within package, restricted, package-scoped)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_module_scoped():
            props.push("module-scoped")
        if self.is_package_scoped():
            props.push("package-scoped")
        if self.is_globally_visible():
            props.push("globally visible")
        if self.is_restricted():
            props.push("restricted")

        val props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "Visibility: {name} ({desc}{props_str})"

    fn to_lean() -> text:
        """Convert to Lean 4 representation.
        Returns: Lean syntax for this visibility level
        Example: Visibility.Public.to_lean()  # → "Visibility.public"
        """
        match self:
            case Private: return "Visibility.private"
            case Internal: return "Visibility.internal"
            case Public: return "Visibility.public"

# Symbol definition
class SymbolDef:
    name: text
    visibility: Visibility
    module_path: text
    package_path: text

    fn create(name: text, visibility: Visibility, module_path: text, package_path: text) -> SymbolDef:
        return SymbolDef(
            name=name,
            visibility=visibility,
            module_path=module_path,
            package_path=package_path
        )

    fn to_lean() -> text:
        return "{{ name := \"" + self.name + "\", visibility := " + self.visibility.to_lean() + ", modulePath := \"" + self.module_path + "\", packagePath := \"" + self.package_path + "\" }}"

# Export declaration
class ExportDecl:
    name: text
    original: SymbolDef
    re_export_visibility: Option<Visibility>

    fn create(name: text, original: SymbolDef, re_export_visibility: Option<Visibility> = None) -> ExportDecl:
        return ExportDecl(
            name=name,
            original=original,
            re_export_visibility=re_export_visibility
        )

    fn effective_visibility() -> Visibility:
        if self.re_export_visibility is not None:
            # Re-export cannot be more visible than original
            match (self.original.visibility, self.re_export_visibility):
                case (Visibility.Private, _): return Visibility.Private
                case (Visibility.Internal, Visibility.Public): return Visibility.Internal
                case (_, v): return v
        return self.original.visibility

# Access context
class AccessContext:
    current_module: text
    current_package: text

    fn create(module: text, package: text) -> AccessContext:
        return AccessContext(module, package)

    fn same_module_as(symbol: SymbolDef) -> bool:
        return self.current_module == symbol.module_path

    fn same_package_as(symbol: SymbolDef) -> bool:
        return self.current_package == symbol.package_path

# Check if access is allowed
fn can_access(ctx: AccessContext, symbol: SymbolDef) -> bool:
    same_module = ctx.same_module_as(symbol)
    same_package = ctx.same_package_as(symbol)
    return symbol.visibility.can_access(same_module, same_package)

# Export validation
fn validate_export(exp_decl: ExportDecl, ctx: AccessContext) -> bool:
    # Must be able to access the original
    if not can_access(ctx, exp_decl.original):
        return False

    # Re-export visibility must not exceed original
    effective = exp_decl.effective_visibility()
    match (exp_decl.original.visibility, effective):
        case (Visibility.Private, Visibility.Internal): return False
        case (Visibility.Private, Visibility.Public): return False
        case (Visibility.Internal, Visibility.Public): return False
        case _: return True

# Visibility ordering
fn visibility_leq(v1: Visibility, v2: Visibility) -> bool:
    match (v1, v2):
        case (Visibility.Private, _): return True
        case (Visibility.Internal, Visibility.Private): return False
        case (Visibility.Internal, _): return True
        case (Visibility.Public, Visibility.Public): return True
        case (Visibility.Public, _): return False

# Module exports
class ModuleExports:
    module_path: text
    exports: List<ExportDecl>

    fn create(module_path: text) -> ModuleExports:
        return ModuleExports(module_path, [])

    fn add_export(exp_decl: ExportDecl) -> ModuleExports:
        new_exports = self.exports.append(exp_decl)
        return ModuleExports(self.module_path, new_exports)

    fn lookup(name: text) -> ExportDecl | None:
        for e in self.exports:
            if e.name == name:
                return e
        return None

    fn visible_from(ctx: AccessContext) -> List<ExportDecl>:
        result = []
        for e in self.exports:
            effective = e.effective_visibility()
            same_module = ctx.current_module == self.module_path
            same_package = ctx.current_package == self.module_path.split(".")[0]
            if effective.can_access(same_module, same_package):
                result.append(e)
        return result

# Specification functions

fn visibility_monotonic_spec() -> text:
    return "theorem visibility_monotonic : ∀ export, effective_visibility export ≤ exp_decl.original.visibility"

fn private_stays_private_spec() -> text:
    return "theorem private_stays_private : ∀ ctx symbol, symbol.visibility = private → can_access ctx symbol → ctx.currentModule = symbol.modulePath"

fn export_requires_access_spec() -> text:
    return "theorem export_requires_access : ∀ ctx export, valid_export ctx export → can_access ctx exp_decl.original"
