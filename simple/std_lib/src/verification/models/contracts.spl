# Contract Models
# Formal model for function contracts matching Lean 4 definitions.
#
# This implements the contract system for Simple:
# - `requires:` - Preconditions
# - `ensures:` - Postconditions  
# - `invariant:` - Class invariants
# - `decreases:` - Termination arguments
# - `modifies:` - Frame conditions

# Contract expression kinds
# Matches Lean: inductive ContractExpr
enum ContractExprKind:
    # Boolean literals
    True_
    False_
    # Variables
    Var           # Variable reference
    OldValue      # old(expr) - value at function entry
    Result        # result - return value in ensures
    # Logical operators
    And           # expr && expr
    Or            # expr || expr
    Not           # !expr
    Implies       # expr ==> expr
    Iff           # expr <==> expr
    # Quantifiers
    Forall        # forall x: T. expr
    Exists        # exists x: T. expr
    # Comparisons
    Eq            # expr == expr
    Ne            # expr != expr
    Lt            # expr < expr
    Le            # expr <= expr
    Gt            # expr > expr
    Ge            # expr >= expr
    # Arithmetic
    Add           # expr + expr
    Sub           # expr - expr
    Mul           # expr * expr
    Div           # expr / expr
    Mod           # expr % expr
    Neg           # -expr
    # Collection operations
    Len           # len(collection)
    Index         # collection[index]
    Contains      # element in collection
    # Function call
    Call          # func(args...)

# Contract expression
class ContractExpr:
    kind: ContractExprKind
    children: List[ContractExpr]
    name: Option[String]       # For Var, Call
    type_name: Option[String]  # For Forall, Exists
    int_value: Option[Int]     # For integer literals
    
    fn new(kind: ContractExprKind) -> ContractExpr:
        ContractExpr(
            kind: kind,
            children: [],
            name: None,
            type_name: None,
            int_value: None
        )

    fn with_children(mut self, children: List[ContractExpr]) -> ContractExpr:
        self.children = children
        self

    fn with_name(mut self, name: String) -> ContractExpr:
        self.name = Some(name)
        self

    fn with_type(mut self, type_name: String) -> ContractExpr:
        self.type_name = Some(type_name)
        self

    # Factory methods for common expressions
    fn true_() -> ContractExpr:
        ContractExpr.new(ContractExprKind.True_)

    fn false_() -> ContractExpr:
        ContractExpr.new(ContractExprKind.False_)

    fn var(name: String) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Var).with_name(name)

    fn old_expr(expr: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.OldValue).with_children([expr])

    fn result() -> ContractExpr:
        ContractExpr.new(ContractExprKind.Result)

    fn and_(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.And).with_children([left, right])

    fn or_(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Or).with_children([left, right])

    fn not_(expr: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Not).with_children([expr])

    fn implies(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Implies).with_children([left, right])

    fn forall_(var_name: String, type_name: String, body: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Forall)
            .with_name(var_name)
            .with_type(type_name)
            .with_children([body])

    fn exists_(var_name: String, type_name: String, body: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Exists)
            .with_name(var_name)
            .with_type(type_name)
            .with_children([body])

    fn eq(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Eq).with_children([left, right])

    fn lt(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Lt).with_children([left, right])

    fn le(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Le).with_children([left, right])

    fn gt(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Gt).with_children([left, right])

    fn ge(left: ContractExpr, right: ContractExpr) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Ge).with_children([left, right])

    fn call(func_name: String, args: List[ContractExpr]) -> ContractExpr:
        ContractExpr.new(ContractExprKind.Call)
            .with_name(func_name)
            .with_children(args)

# Contract clause - a single requires/ensures/invariant
class ContractClause:
    expr: ContractExpr
    label: Option[String]   # Optional label for the clause
    message: Option[String] # Optional message for violations

    fn new(expr: ContractExpr) -> ContractClause:
        ContractClause(expr: expr, label: None, message: None)

    fn with_label(mut self, label: String) -> ContractClause:
        self.label = Some(label)
        self

    fn with_message(mut self, message: String) -> ContractClause:
        self.message = Some(message)
        self

# Decreases clause for termination
class DecreasesClause:
    exprs: List[ContractExpr]  # Tuple of decreasing expressions
    well_founded: Bool         # Uses well-founded relation

    fn new(exprs: List[ContractExpr]) -> DecreasesClause:
        DecreasesClause(exprs: exprs, well_founded: true)

    fn single(expr: ContractExpr) -> DecreasesClause:
        DecreasesClause.new([expr])

# Modifies clause for frame conditions
class ModifiesClause:
    locations: List[String]  # Memory locations that may be modified
    
    fn new(locations: List[String]) -> ModifiesClause:
        ModifiesClause(locations: locations)

    fn nothing() -> ModifiesClause:
        ModifiesClause(locations: [])

# Complete function contract
# Matches Lean: structure FunctionContract
class FunctionContract:
    preconditions: List[ContractClause]     # Preconditions (in:)
    postconditions: List[ContractClause]    # Postconditions (out:)
    postconditions_err: List[ContractClause]  # Error postconditions (out_err:)
    invariants: List[ContractClause]   # Loop/class invariants
    decreases: Option[DecreasesClause] # Termination argument
    modifies: Option[ModifiesClause]   # Frame condition

    fn new() -> FunctionContract:
        FunctionContract(
            preconditions: [],
            postconditions: [],
            postconditions_err: [],
            invariants: [],
            decreases: None,
            modifies: None
        )

    fn add_precondition(mut self, clause: ContractClause) -> FunctionContract:
        self.preconditions.push(clause)
        self

    fn add_postcondition(mut self, clause: ContractClause) -> FunctionContract:
        self.postconditions.push(clause)
        self

    fn add_postcondition_err(mut self, clause: ContractClause) -> FunctionContract:
        self.postconditions_err.push(clause)
        self

    fn add_invariant(mut self, clause: ContractClause) -> FunctionContract:
        self.invariants.push(clause)
        self

    fn with_decreases(mut self, decreases: DecreasesClause) -> FunctionContract:
        self.decreases = Some(decreases)
        self

    fn with_modifies(mut self, modifies: ModifiesClause) -> FunctionContract:
        self.modifies = Some(modifies)
        self

    fn has_preconditions(self) -> Bool:
        self.preconditions.len() > 0

    fn has_postconditions(self) -> Bool:
        self.postconditions.len() > 0 or self.postconditions_err.len() > 0

    fn has_invariants(self) -> Bool:
        self.invariants.len() > 0

    fn is_total(self) -> Bool:
        self.decreases.is_some()

# Class invariant
class ClassInvariant:
    class_name: String
    inv_expr: ContractExpr
    is_public: Bool  # Whether invariant is visible outside class

    fn new(class_name: String, inv_expr: ContractExpr) -> ClassInvariant:
        ClassInvariant(
            class_name: class_name,
            inv_expr: inv_expr,
            is_public: false
        )

    fn public(mut self) -> ClassInvariant:
        self.is_public = true
        self

# Contract checking context
class ContractContext:
    captured_values: Dict[String, ContractExpr]  # Captured old values
    result_available: Bool                   # Whether result is available
    in_requires: Bool                        # Currently checking requires
    in_ensures: Bool                         # Currently checking ensures

    fn new() -> ContractContext:
        ContractContext(
            captured_values: {},
            result_available: false,
            in_requires: false,
            in_ensures: false
        )

    fn enter_requires(mut self):
        self.in_requires = true
        self.in_ensures = false

    fn enter_ensures(mut self):
        self.in_requires = false
        self.in_ensures = true
        self.result_available = true

    fn capture_old(mut self, name: String, value: ContractExpr):
        self.captured_values[name] = value

    fn get_old(self, name: String) -> Option[ContractExpr]:
        self.captured_values.get(name)

# Check if an expression is pure (no side effects)
fn is_pure_expr(expr: ContractExpr) -> Bool:
    match expr.kind:
        case ContractExprKind.True_: true
        case ContractExprKind.False_: true
        case ContractExprKind.Var: true
        case ContractExprKind.OldValue:
            expr.children.len() == 1 and is_pure_expr(expr.children[0])
        case ContractExprKind.Result: true
        case ContractExprKind.And:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Or:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Not:
            expr.children.len() == 1 and is_pure_expr(expr.children[0])
        case ContractExprKind.Implies:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Forall:
            expr.children.len() == 1 and is_pure_expr(expr.children[0])
        case ContractExprKind.Exists:
            expr.children.len() == 1 and is_pure_expr(expr.children[0])
        case ContractExprKind.Eq:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Lt:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Le:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Gt:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Ge:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Add:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Sub:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Mul:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Len:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Index:
            expr.children.all(|c| is_pure_expr(c))
        case ContractExprKind.Call:
            # Conservative: calls might have side effects
            false
        case _:
            expr.children.all(|c| is_pure_expr(c))

# Validate a contract for well-formedness
fn validate_contract(contract: FunctionContract) -> List[String]:
    let mut errors: List[String] = []

    # Check that all precondition expressions are pure
    for clause in contract.preconditions:
        if not is_pure_expr(clause.expr):
            errors.push("Precondition must be a pure expression")

    # Check that all postcondition expressions are pure
    for clause in contract.postconditions:
        if not is_pure_expr(clause.expr):
            errors.push("Postcondition must be a pure expression")

    # Check that invariants are pure
    for clause in contract.invariants:
        if not is_pure_expr(clause.expr):
            errors.push("Invariant must be a pure expression")

    errors
