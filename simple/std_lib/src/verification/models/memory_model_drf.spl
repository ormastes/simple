# SC-DRF Memory Model
# Sequentially Consistent - Data Race Free memory model.
#
# This implements Simple's memory consistency guarantee:
# Programs that are data-race-free will observe sequentially consistent behavior.

# Memory ordering for atomic operations
enum MemoryOrder:
    Relaxed    # No ordering constraints
    Acquire    # Prevents reordering of later reads
    Release    # Prevents reordering of earlier writes
    AcqRel     # Both acquire and release
    SeqCst     # Sequentially consistent

    fn is_relaxed(self) -> Bool:
        """Check if this is Relaxed ordering.
        Returns: true for Relaxed
        Example: MemoryOrder.Relaxed.is_relaxed()  # → true
        """
        match self:
            case Relaxed: true
            case _: false

    fn is_acquire(self) -> Bool:
        """Check if this is Acquire ordering.
        Returns: true for Acquire
        Example: MemoryOrder.Acquire.is_acquire()  # → true
        """
        match self:
            case Acquire: true
            case _: false

    fn is_release(self) -> Bool:
        """Check if this is Release ordering.
        Returns: true for Release
        Example: MemoryOrder.Release.is_release()  # → true
        """
        match self:
            case Release: true
            case _: false

    fn is_acq_rel(self) -> Bool:
        """Check if this is AcqRel ordering.
        Returns: true for AcqRel
        Example: MemoryOrder.AcqRel.is_acq_rel()  # → true
        """
        match self:
            case AcqRel: true
            case _: false

    fn is_seq_cst(self) -> Bool:
        """Check if this is SeqCst ordering.
        Returns: true for SeqCst
        Example: MemoryOrder.SeqCst.is_seq_cst()  # → true
        """
        match self:
            case SeqCst: true
            case _: false

    fn has_acquire_semantics(self) -> Bool:
        """Check if this ordering has acquire semantics.
        Acquire semantics prevent reordering of later reads.
        Returns: true for Acquire, AcqRel, or SeqCst
        Example: MemoryOrder.Acquire.has_acquire_semantics()  # → true
        """
        match self:
            case Acquire: true
            case AcqRel: true
            case SeqCst: true
            case _: false

    fn has_release_semantics(self) -> Bool:
        """Check if this ordering has release semantics.
        Release semantics prevent reordering of earlier writes.
        Returns: true for Release, AcqRel, or SeqCst
        Example: MemoryOrder.Release.has_release_semantics()  # → true
        """
        match self:
            case Release: true
            case AcqRel: true
            case SeqCst: true
            case _: false

    fn is_weakest(self) -> Bool:
        """Check if this is the weakest ordering (Relaxed).
        Returns: true for Relaxed
        Example: MemoryOrder.Relaxed.is_weakest()  # → true
        """
        match self:
            case Relaxed: true
            case _: false

    fn is_strongest(self) -> Bool:
        """Check if this is the strongest ordering (SeqCst).
        Returns: true for SeqCst
        Example: MemoryOrder.SeqCst.is_strongest()  # → true
        """
        match self:
            case SeqCst: true
            case _: false

    fn to_string(self) -> String:
        """Convert MemoryOrder to string representation.
        Returns: lowercase string name
        Example: MemoryOrder.Acquire.to_string()  # → "acquire"
        """
        match self:
            case Relaxed: "relaxed"
            case Acquire: "acquire"
            case Release: "release"
            case AcqRel: "acq_rel"
            case SeqCst: "seq_cst"

    fn description(self) -> String:
        """Get human-readable description of the memory ordering.
        Returns: descriptive explanation
        Example: MemoryOrder.Acquire.description()  # → "Prevents reordering of later reads"
        """
        match self:
            case Relaxed: "No ordering constraints"
            case Acquire: "Prevents reordering of later reads"
            case Release: "Prevents reordering of earlier writes"
            case AcqRel: "Both acquire and release semantics"
            case SeqCst: "Sequentially consistent ordering"

    fn summary(self) -> String:
        """Get comprehensive summary of the memory ordering.
        Returns: summary with name, description, and properties
        Example: MemoryOrder.AcqRel.summary()
                # → "MemoryOrder: acq_rel (Both acquire and release semantics, acquire semantics, release semantics)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut props = []

        if self.has_acquire_semantics():
            props.push("acquire semantics")
        if self.has_release_semantics():
            props.push("release semantics")
        if self.is_weakest():
            props.push("weakest ordering")
        if self.is_strongest():
            props.push("strongest ordering")

        let props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "MemoryOrder: {name} ({desc}{props_str})"

# Memory location identifier
class MemoryLocation:
    address: Int
    size: Int
    is_atomic: Bool

    fn new(address: Int, size: Int) -> MemoryLocation:
        MemoryLocation(address: address, size: size, is_atomic: false)

    fn atomic(address: Int, size: Int) -> MemoryLocation:
        MemoryLocation(address: address, size: size, is_atomic: true)

    # Check if two locations overlap
    fn overlaps(self, other: MemoryLocation) -> Bool:
        let self_end = self.address + self.size
        let other_end = other.address + other.size
        self.address < other_end and other.address < self_end

# Memory access kind
enum AccessKind:
    Read
    Write
    ReadWrite  # Atomic RMW operations

    fn is_read_only(self) -> Bool:
        """Check if this is Read-only access.
        Returns: true for Read
        Example: AccessKind.Read.is_read_only()  # → true
        """
        match self:
            case Read: true
            case _: false

    fn is_write_only(self) -> Bool:
        """Check if this is Write-only access.
        Returns: true for Write
        Example: AccessKind.Write.is_write_only()  # → true
        """
        match self:
            case Write: true
            case _: false

    fn is_read_write(self) -> Bool:
        """Check if this is ReadWrite (RMW) access.
        Returns: true for ReadWrite
        Example: AccessKind.ReadWrite.is_read_write()  # → true
        """
        match self:
            case ReadWrite: true
            case _: false

    fn is_write(self) -> Bool:
        """Check if this access includes writes.
        Returns: true for Write or ReadWrite
        Example: AccessKind.Write.is_write()  # → true
        """
        match self:
            case Write: true
            case ReadWrite: true
            case Read: false

    fn is_read(self) -> Bool:
        """Check if this access includes reads.
        Returns: true for Read or ReadWrite
        Example: AccessKind.Read.is_read()  # → true
        """
        match self:
            case Read: true
            case ReadWrite: true
            case Write: false

    fn is_atomic_rmw(self) -> Bool:
        """Check if this is an atomic read-modify-write operation.
        Returns: true for ReadWrite
        Example: AccessKind.ReadWrite.is_atomic_rmw()  # → true
        """
        match self:
            case ReadWrite: true
            case _: false

    fn can_conflict_with(self, other: AccessKind) -> Bool:
        """Check if this access can conflict with another.
        Two accesses conflict if at least one is a write.
        Returns: true if at least one is a write
        Example: AccessKind.Write.can_conflict_with(AccessKind.Read)  # → true
        """
        self.is_write() or other.is_write()

    fn to_string(self) -> String:
        """Convert AccessKind to string representation.
        Returns: lowercase string name
        Example: AccessKind.ReadWrite.to_string()  # → "read_write"
        """
        match self:
            case Read: "read"
            case Write: "write"
            case ReadWrite: "read_write"

    fn description(self) -> String:
        """Get human-readable description of the access kind.
        Returns: descriptive explanation
        Example: AccessKind.ReadWrite.description()  # → "Atomic read-modify-write operation"
        """
        match self:
            case Read: "Read-only access"
            case Write: "Write-only access"
            case ReadWrite: "Atomic read-modify-write operation"

    fn summary(self) -> String:
        """Get comprehensive summary of the access kind.
        Returns: summary with name, description, and properties
        Example: AccessKind.ReadWrite.summary()
                # → "AccessKind: read_write (Atomic read-modify-write operation, reads, writes, atomic RMW)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut props = []

        if self.is_read():
            props.push("reads")
        if self.is_write():
            props.push("writes")
        if self.is_atomic_rmw():
            props.push("atomic RMW")

        let props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "AccessKind: {name} ({desc}{props_str})"

# Memory access event
class MemoryAccess:
    thread_id: Int
    location: MemoryLocation
    kind: AccessKind
    order: MemoryOrder
    timestamp: Int

    fn new(thread_id: Int, location: MemoryLocation, kind: AccessKind) -> MemoryAccess:
        MemoryAccess(
            thread_id: thread_id,
            location: location,
            kind: kind,
            order: MemoryOrder.SeqCst,
            timestamp: 0
        )

    fn with_order(mut self, order: MemoryOrder) -> MemoryAccess:
        self.order = order
        self

    fn with_timestamp(mut self, timestamp: Int) -> MemoryAccess:
        self.timestamp = timestamp
        self

# Data race - two conflicting accesses
class DataRace:
    access1: MemoryAccess
    access2: MemoryAccess
    message: String

    fn new(access1: MemoryAccess, access2: MemoryAccess) -> DataRace:
        DataRace(
            access1: access1,
            access2: access2,
            message: "Data race between threads {access1.thread_id} and {access2.thread_id}"
        )

# Check if two accesses conflict (potential data race)
fn accesses_conflict(a1: MemoryAccess, a2: MemoryAccess) -> Bool:
    # Same thread - no conflict
    if a1.thread_id == a2.thread_id:
        return false

    # Must access overlapping locations
    if not a1.location.overlaps(a2.location):
        return false

    # At least one must be a write
    if not (a1.kind.is_write() or a2.kind.is_write()):
        return false

    # Atomic accesses with proper ordering don't conflict
    if a1.location.is_atomic and a2.location.is_atomic:
        return false

    true

# Happens-before relationship
class HappensBefore:
    earlier: MemoryAccess
    later: MemoryAccess

    fn new(earlier: MemoryAccess, later: MemoryAccess) -> HappensBefore:
        HappensBefore(earlier: earlier, later: later)

# Synchronization event
enum SyncEvent:
    Lock(mutex_id: Int)
    Unlock(mutex_id: Int)
    Spawn(child_thread: Int)
    Join(child_thread: Int)
    Send(channel_id: Int)
    Recv(channel_id: Int)
    Fence(order: MemoryOrder)

# Thread state for race detection
class ThreadState:
    thread_id: Int
    accesses: List<MemoryAccess>
    sync_events: List<SyncEvent>
    vector_clock: Dict<Int, Int>  # Thread ID -> logical time

    fn new(thread_id: Int) -> ThreadState:
        let mut vc: Dict<Int, Int> = {}
        vc[thread_id] = 0
        ThreadState(
            thread_id: thread_id,
            accesses: [],
            sync_events: [],
            vector_clock: vc
        )

    fn tick(mut self):
        let current = self.vector_clock.get(self.thread_id).unwrap_or(0)
        self.vector_clock[self.thread_id] = current + 1

    fn get_time(self) -> Int:
        self.vector_clock.get(self.thread_id).unwrap_or(0)

    fn merge_clock(mut self, other_clock: Dict<Int, Int>):
        for (tid, time) in other_clock:
            let my_time = self.vector_clock.get(tid).unwrap_or(0)
            if time > my_time:
                self.vector_clock[tid] = time

    fn happens_before(self, other: ThreadState) -> Bool:
        # self happens-before other if all entries in self's clock <= other's
        for (tid, time) in self.vector_clock:
            let other_time = other.vector_clock.get(tid).unwrap_or(0)
            if time > other_time:
                return false
        true

    fn record_access(mut self, location: MemoryLocation, kind: AccessKind, order: MemoryOrder):
        self.tick()
        let access = MemoryAccess.new(self.thread_id, location, kind)
            .with_order(order)
            .with_timestamp(self.get_time())
        self.accesses.push(access)

# Race detector state
class RaceDetector:
    threads: Dict<Int, ThreadState>
    races: List<DataRace>
    enabled: Bool

    fn new() -> RaceDetector:
        RaceDetector(threads: {}, races: [], enabled: true)

    fn get_or_create_thread(mut self, thread_id: Int) -> ThreadState:
        match self.threads.get(thread_id):
            case Some(state):
                state
            case None:
                let state = ThreadState.new(thread_id)
                self.threads[thread_id] = state
                state

    fn record_access(mut self, thread_id: Int, location: MemoryLocation, kind: AccessKind, order: MemoryOrder):
        if not self.enabled:
            return

        let thread = self.get_or_create_thread(thread_id)
        thread.record_access(location, kind, order)

        # Check for races with other threads
        for (other_id, other_thread) in self.threads:
            if other_id == thread_id:
                continue

            for other_access in other_thread.accesses:
                if accesses_conflict(thread.accesses.last().unwrap(), other_access):
                    # Check happens-before
                    if not thread.happens_before(other_thread) and not other_thread.happens_before(thread):
                        let race = DataRace.new(
                            thread.accesses.last().unwrap(),
                            other_access
                        )
                        self.races.push(race)

    fn record_sync(mut self, thread_id: Int, event: SyncEvent):
        let thread = self.get_or_create_thread(thread_id)
        thread.sync_events.push(event)

        # Update happens-before based on sync event
        match event:
            case SyncEvent.Spawn(child_thread):
                let child = self.get_or_create_thread(child_thread)
                child.merge_clock(thread.vector_clock)
            case SyncEvent.Join(child_thread):
                match self.threads.get(child_thread):
                    case Some(child):
                        thread.merge_clock(child.vector_clock)
                    case None:
                        pass
            case _:
                pass

    fn has_races(self) -> Bool:
        self.races.len() > 0

    fn get_races(self) -> List<DataRace>:
        self.races

# SC-DRF guarantee checker
class SCDRFChecker:
    detector: RaceDetector

    fn new() -> SCDRFChecker:
        SCDRFChecker(detector: RaceDetector.new())

    fn check_program(mut self, accesses: List<MemoryAccess>, syncs: List<(Int, SyncEvent)>) -> Bool:
        # Record all sync events first
        for (thread_id, event) in syncs:
            self.detector.record_sync(thread_id, event)

        # Then check accesses for races
        for access in accesses:
            self.detector.record_access(
                access.thread_id,
                access.location,
                access.kind,
                access.order
            )

        not self.detector.has_races()

    fn get_violations(self) -> List<DataRace>:
        self.detector.get_races()
