# SC-DRF Memory Model
# Sequentially Consistent - Data Race Free memory model.
#
# This implements Simple's memory consistency guarantee:
# Programs that are data-race-free will observe sequentially consistent behavior.

# Memory ordering for atomic operations
enum MemoryOrder:
    Relaxed    # No ordering constraints
    Acquire    # Prevents reordering of later reads
    Release    # Prevents reordering of earlier writes
    AcqRel     # Both acquire and release
    SeqCst     # Sequentially consistent

    fn to_string(self) -> String:
        match self:
            case Relaxed: "relaxed"
            case Acquire: "acquire"
            case Release: "release"
            case AcqRel: "acq_rel"
            case SeqCst: "seq_cst"

# Memory location identifier
class MemoryLocation:
    address: Int
    size: Int
    is_atomic: Bool

    fn new(address: Int, size: Int) -> MemoryLocation:
        MemoryLocation(address: address, size: size, is_atomic: false)

    fn atomic(address: Int, size: Int) -> MemoryLocation:
        MemoryLocation(address: address, size: size, is_atomic: true)

    # Check if two locations overlap
    fn overlaps(self, other: MemoryLocation) -> Bool:
        let self_end = self.address + self.size
        let other_end = other.address + other.size
        self.address < other_end and other.address < self_end

# Memory access kind
enum AccessKind:
    Read
    Write
    ReadWrite  # Atomic RMW operations

    fn is_write(self) -> Bool:
        match self:
            case Write: true
            case ReadWrite: true
            case Read: false

    fn is_read(self) -> Bool:
        match self:
            case Read: true
            case ReadWrite: true
            case Write: false

# Memory access event
class MemoryAccess:
    thread_id: Int
    location: MemoryLocation
    kind: AccessKind
    order: MemoryOrder
    timestamp: Int

    fn new(thread_id: Int, location: MemoryLocation, kind: AccessKind) -> MemoryAccess:
        MemoryAccess(
            thread_id: thread_id,
            location: location,
            kind: kind,
            order: MemoryOrder.SeqCst,
            timestamp: 0
        )

    fn with_order(mut self, order: MemoryOrder) -> MemoryAccess:
        self.order = order
        self

    fn with_timestamp(mut self, timestamp: Int) -> MemoryAccess:
        self.timestamp = timestamp
        self

# Data race - two conflicting accesses
class DataRace:
    access1: MemoryAccess
    access2: MemoryAccess
    message: String

    fn new(access1: MemoryAccess, access2: MemoryAccess) -> DataRace:
        DataRace(
            access1: access1,
            access2: access2,
            message: f"Data race between threads {access1.thread_id} and {access2.thread_id}"
        )

# Check if two accesses conflict (potential data race)
fn accesses_conflict(a1: MemoryAccess, a2: MemoryAccess) -> Bool:
    # Same thread - no conflict
    if a1.thread_id == a2.thread_id:
        return false

    # Must access overlapping locations
    if not a1.location.overlaps(a2.location):
        return false

    # At least one must be a write
    if not (a1.kind.is_write() or a2.kind.is_write()):
        return false

    # Atomic accesses with proper ordering don't conflict
    if a1.location.is_atomic and a2.location.is_atomic:
        return false

    true

# Happens-before relationship
class HappensBefore:
    earlier: MemoryAccess
    later: MemoryAccess

    fn new(earlier: MemoryAccess, later: MemoryAccess) -> HappensBefore:
        HappensBefore(earlier: earlier, later: later)

# Synchronization event
enum SyncEvent:
    Lock(mutex_id: Int)
    Unlock(mutex_id: Int)
    Spawn(child_thread: Int)
    Join(child_thread: Int)
    Send(channel_id: Int)
    Recv(channel_id: Int)
    Fence(order: MemoryOrder)

# Thread state for race detection
class ThreadState:
    thread_id: Int
    accesses: List<MemoryAccess>
    sync_events: List<SyncEvent>
    vector_clock: Dict<Int, Int>  # Thread ID -> logical time

    fn new(thread_id: Int) -> ThreadState:
        let mut vc: Dict<Int, Int> = {}
        vc[thread_id] = 0
        ThreadState(
            thread_id: thread_id,
            accesses: [],
            sync_events: [],
            vector_clock: vc
        )

    fn tick(mut self):
        let current = self.vector_clock.get(self.thread_id).unwrap_or(0)
        self.vector_clock[self.thread_id] = current + 1

    fn get_time(self) -> Int:
        self.vector_clock.get(self.thread_id).unwrap_or(0)

    fn merge_clock(mut self, other_clock: Dict<Int, Int>):
        for (tid, time) in other_clock:
            let my_time = self.vector_clock.get(tid).unwrap_or(0)
            if time > my_time:
                self.vector_clock[tid] = time

    fn happens_before(self, other: ThreadState) -> Bool:
        # self happens-before other if all entries in self's clock <= other's
        for (tid, time) in self.vector_clock:
            let other_time = other.vector_clock.get(tid).unwrap_or(0)
            if time > other_time:
                return false
        true

    fn record_access(mut self, location: MemoryLocation, kind: AccessKind, order: MemoryOrder):
        self.tick()
        let access = MemoryAccess.new(self.thread_id, location, kind)
            .with_order(order)
            .with_timestamp(self.get_time())
        self.accesses.push(access)

# Race detector state
class RaceDetector:
    threads: Dict<Int, ThreadState>
    races: List<DataRace>
    enabled: Bool

    fn new() -> RaceDetector:
        RaceDetector(threads: {}, races: [], enabled: true)

    fn get_or_create_thread(mut self, thread_id: Int) -> ThreadState:
        match self.threads.get(thread_id):
            case Some(state):
                state
            case None:
                let state = ThreadState.new(thread_id)
                self.threads[thread_id] = state
                state

    fn record_access(mut self, thread_id: Int, location: MemoryLocation, kind: AccessKind, order: MemoryOrder):
        if not self.enabled:
            return

        let thread = self.get_or_create_thread(thread_id)
        thread.record_access(location, kind, order)

        # Check for races with other threads
        for (other_id, other_thread) in self.threads:
            if other_id == thread_id:
                continue

            for other_access in other_thread.accesses:
                if accesses_conflict(thread.accesses.last().unwrap(), other_access):
                    # Check happens-before
                    if not thread.happens_before(other_thread) and not other_thread.happens_before(thread):
                        let race = DataRace.new(
                            thread.accesses.last().unwrap(),
                            other_access
                        )
                        self.races.push(race)

    fn record_sync(mut self, thread_id: Int, event: SyncEvent):
        let thread = self.get_or_create_thread(thread_id)
        thread.sync_events.push(event)

        # Update happens-before based on sync event
        match event:
            case SyncEvent.Spawn(child_thread):
                let child = self.get_or_create_thread(child_thread)
                child.merge_clock(thread.vector_clock)
            case SyncEvent.Join(child_thread):
                match self.threads.get(child_thread):
                    case Some(child):
                        thread.merge_clock(child.vector_clock)
                    case None:
                        pass
            case _:
                pass

    fn has_races(self) -> Bool:
        self.races.len() > 0

    fn get_races(self) -> List<DataRace>:
        self.races

# SC-DRF guarantee checker
class SCDRFChecker:
    detector: RaceDetector

    fn new() -> SCDRFChecker:
        SCDRFChecker(detector: RaceDetector.new())

    fn check_program(mut self, accesses: List<MemoryAccess>, syncs: List<(Int, SyncEvent)>) -> Bool:
        # Record all sync events first
        for (thread_id, event) in syncs:
            self.detector.record_sync(thread_id, event)

        # Then check accesses for races
        for access in accesses:
            self.detector.record_access(
                access.thread_id,
                access.location,
                access.kind,
                access.order
            )

        not self.detector.has_races()

    fn get_violations(self) -> List<DataRace>:
        self.detector.get_races()
