# Module Resolution Model
#
# Formal model for module path resolution.
# Mirrors: verification/module_resolution/src/ModuleResolution.lean

# Module path component
class PathComponent:
    name: String
    is_package: Bool

    fn create(name: String, is_package: Bool = False) -> PathComponent:
        return PathComponent(name, is_package)

    fn to_lean(self) -> String:
        pkg = "false"
        if self.is_package:
            pkg = "true"
        return "{{ name := \"" + self.name + "\", isPackage := " + pkg + " }}"

# Full module path
class ModulePath:
    components: List[PathComponent]

    fn create(components: List[PathComponent] = []) -> ModulePath:
        return ModulePath(components)

    fn from_string(path: String) -> ModulePath:
        parts = path.split(".")
        components = [PathComponent.create(p) for p in parts]
        return ModulePath(components)

    fn to_string(self) -> String:
        return ".".join([c.name for c in self.components])

    fn to_lean(self) -> String:
        comps = "[" + ", ".join([c.to_lean() for c in self.components]) + "]"
        return "ModulePath.mk " + comps

    fn parent(self) -> ModulePath | None:
        if len(self.components) <= 1:
            return None
        return ModulePath(self.components[:-1])

    fn child(self, name: String) -> ModulePath:
        new_comps = self.components.append(PathComponent.create(name))
        return ModulePath(new_comps)

# Module entry in the module graph
class ModuleEntry:
    path: ModulePath
    file_path: String
    exports: List[String]
    imports: List[ModulePath]

    fn create(path: ModulePath, file_path: String) -> ModuleEntry:
        return ModuleEntry(path, file_path, [], [])

    fn with_export(self, name: String) -> ModuleEntry:
        new_exports = self.exports.append(name)
        return ModuleEntry(self.path, self.file_path, new_exports, self.imports)

    fn with_import(self, import_mod: ModulePath) -> ModuleEntry:
        new_imports = self.imports.append(import_mod)
        return ModuleEntry(self.path, self.file_path, self.exports, new_imports)

# Module graph
class ModuleGraph:
    modules: List[ModuleEntry]

    fn create() -> ModuleGraph:
        return ModuleGraph([])

    fn add_module(self, entry: ModuleEntry) -> ModuleGraph:
        new_modules = self.modules.append(entry)
        return ModuleGraph(new_modules)

    fn find_module(self, path: ModulePath) -> ModuleEntry | None:
        path_str = path.to_string()
        for m in self.modules:
            if m.path.to_string() == path_str:
                return m
        return None

    fn resolve_import(self, from_module: ModulePath, import_path: ModulePath) -> ModulePath | None:
        # Absolute import
        if self.find_module(import_path) is not None:
            return import_path

        # Relative import (from parent)
        parent = from_module.parent()
        if parent is not None:
            # Combine parent components with import path components
            combined = parent.components
            for c in import_path.components:
                combined = combined.append(c)
            relative = ModulePath(combined)
            if self.find_module(relative) is not None:
                return relative

        return None

# Resolution result
enum ResolveResult:
    Found(entry: ModuleEntry)
    NotFound(path: ModulePath)
    Cycle(path: List[ModulePath])

    fn to_lean(self) -> String:
        match self:
            case Found(e): return "ResolveResult.found " + e.path.to_lean()
            case NotFound(p): return "ResolveResult.notFound " + p.to_lean()
            case Cycle(ps):
                paths = "[" + ", ".join([p.to_lean() for p in ps]) + "]"
                return "ResolveResult.cycle " + paths

# Check for import cycles
fn has_cycle(graph: ModuleGraph, start: ModulePath, visited: List[ModulePath] = []) -> Bool:
    start_str = start.to_string()
    for v in visited:
        if v.to_string() == start_str:
            return True

    entry = graph.find_module(start)
    if entry is None:
        return False

    new_visited = visited.append(start)
    for imp in entry.imports:
        if has_cycle(graph, imp, new_visited):
            return True

    return False

# Specification functions

fn resolution_deterministic_spec() -> String:
    return "theorem resolution_deterministic : ∀ graph from path, resolve graph from path = resolve graph from path"

fn no_cycles_spec() -> String:
    return "theorem no_cycles : ∀ graph, well_formed graph → ¬∃ path, has_cycle graph path"

fn import_exists_spec() -> String:
    return "theorem import_exists : ∀ graph mod imp, imp ∈ mod.imports → ∃ entry, resolve graph mod.path imp = found entry"
