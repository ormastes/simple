# Proof Obligations
#
# Extracts and manages proof obligations from contracts.

import verification.lean.expressions as expressions
import verification.lean.codegen as codegen
import verification.models.contracts as c

# Proof obligation status
enum ProofStatus:
    Pending       # Not yet attempted
    InProgress    # Being worked on
    Proven        # Proof complete
    Admitted      # Accepted without proof (sorry)
    Failed        # Proof attempt failed

    fn to_string() -> String:
        match self:
            case Pending: return "pending"
            case InProgress: return "in_progress"
            case Proven: return "proven"
            case Admitted: return "admitted"
            case Failed: return "failed"

# Single proof obligation
class ProofObligation:
    id: String
    name: String
    source_file: String
    source_line: Int
    proposition: String
    status: ProofStatus
    lean_file: Option<String>
    proof_script: Option<String>

    fn create(id: String, name: String, source_file: String, source_line: Int, proposition: String) -> ProofObligation:
        return ProofObligation(id, name, source_file, source_line, proposition, ProofStatus.Pending, None, None)

    fn with_status(status: ProofStatus) -> ProofObligation:
        return ProofObligation(self.id, self.name, self.source_file, self.source_line, self.proposition, status, self.lean_file, self.proof_script)

    fn with_proof(proof_script: String) -> ProofObligation:
        return ProofObligation(self.id, self.name, self.source_file, self.source_line, self.proposition, ProofStatus.Proven, self.lean_file, proof_script)

    fn to_lean_theorem() -> codegen.LeanTheorem:
        val proof = "sorry"
        if self.proof_script is not None:
            proof = self.proof_script
        codegen.LeanTheorem.new(self.name, self.proposition)
            .with_proof(proof)

# Obligation category
enum ObligationCategory:
    Precondition
    Postcondition
    Invariant
    TypeInvariant
    Termination
    SafetyProperty

# Obligation set for a module
class ObligationSet:
    module_name: String
    obligations: List[ProofObligation]

    fn create(module_name: String) -> ObligationSet:
        return ObligationSet(module_name, [])

    fn add(obligation: ProofObligation) -> ObligationSet:
        new_obligations = self.obligations.append(obligation)
        return ObligationSet(self.module_name, new_obligations)

    fn find_by_id(id: String) -> ProofObligation | None:
        for ob in self.obligations:
            if ob.id == id:
                return ob
        return None

    fn find_by_status(status: ProofStatus) -> List[ProofObligation]:
        return [ob for ob in self.obligations if ob.status == status]

    fn count_by_status() -> Dict[String, Int]:
        counts = {}
        for ob in self.obligations:
            key = ob.status.to_string()
            if key in counts:
                counts[key] = counts[key] + 1
            else:
                counts[key] = 1
        return counts

    fn summary() -> String:
        counts = self.count_by_status()
        total = len(self.obligations)
        proven = counts.get("proven", 0)
        pending = counts.get("pending", 0)
        admitted = counts.get("admitted", 0)
        failed = counts.get("failed", 0)

        return "Proof Obligations for " + self.module_name + ": " + str(total) + " total, " + str(proven) + " proven, " + str(pending) + " pending, " + str(admitted) + " admitted, " + str(failed) + " failed"

# Extract obligations from a function contract
fn extract_from_contract(fn_name: String, source_file: String, source_line: Int, contract: c.FunctionContract) -> List[ProofObligation]:
    obligations = []
    ob_id = 0

    # Precondition obligations
    for i in range(len(contract.preconditions)):
        clause = contract.preconditions[i]
        prop = expressions.translate_contract_expr(clause.condition)
        ob = ProofObligation.create(
            id=fn_name + "_pre_" + str(i),
            name=fn_name + "_precondition_" + str(i),
            source_file=source_file,
            source_line=source_line,
            proposition="∀ args, " + prop
        )
        obligations.append(ob)

    # Postcondition obligations
    for i in range(len(contract.postconditions)):
        clause = contract.postconditions[i]
        prop = expressions.translate_contract_expr(clause.condition)
        ob = ProofObligation.create(
            id=fn_name + "_post_" + str(i),
            name=fn_name + "_postcondition_" + str(i),
            source_file=source_file,
            source_line=source_line,
            proposition="∀ args result, preconditions → " + prop
        )
        obligations.append(ob)

    # Invariant preservation obligations
    for i in range(len(contract.invariants)):
        clause = contract.invariants[i]
        prop = expressions.translate_contract_expr(clause.condition)
        ob = ProofObligation.create(
            id=fn_name + "_inv_" + str(i),
            name=fn_name + "_invariant_preserved_" + str(i),
            source_file=source_file,
            source_line=source_line,
            proposition="∀ self, inv_entry self → " + prop
        )
        obligations.append(ob)

    return obligations

# Extract obligations from a type invariant
fn extract_from_type_invariant(type_name: String, source_file: String, source_line: Int, invariant: c.TypeInvariant) -> List[ProofObligation]:
    obligations = []

    for i in range(len(invariant.conditions)):
        clause = invariant.conditions[i]
        prop = expressions.translate_contract_expr(clause.condition)
        ob = ProofObligation.create(
            id=type_name + "_type_inv_" + str(i),
            name=type_name + "_type_invariant_" + str(i),
            source_file=source_file,
            source_line=source_line,
            proposition="∀ self : " + type_name + ", " + prop
        )
        obligations.append(ob)

    return obligations

# Generate theorem stubs for obligations
fn generate_theorem_stubs(obligations: ObligationSet) -> String:
    lines = []
    lines.append("-- Proof obligations for " + obligations.module_name)
    lines.append("")

    for ob in obligations.obligations:
        lines.append("-- " + ob.id + " (" + ob.status.to_string() + ")")
        lines.append("-- Source: " + ob.source_file + ":" + str(ob.source_line))
        thm = ob.to_lean_theorem()
        lines.append("theorem " + thm.name + " :")
        lines.append("  " + thm.proposition + " := by")
        proof_text = "sorry"
        if thm.proof != "":
            proof_text = thm.proof
        lines.append("  " + proof_text)
        lines.append("")

    return "\n".join(lines)
