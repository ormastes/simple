# Lean Expression Translation
#
# Translates Simple expressions to Lean 4 syntax.

import verification.models.contracts as contracts

# Simple expression AST
enum SimpleExpr:
    IntLit(value: Int)
    BoolLit(value: Bool)
    StringLit(value: String)
    Var(name: String)
    BinOp(op: String, left: SimpleExpr, right: SimpleExpr)
    UnOp(op: String, expr: SimpleExpr)
    Call(fn_name: String, args: List[SimpleExpr])
    FieldAccess(obj: SimpleExpr, field: String)
    MethodCall(obj: SimpleExpr, method: String, args: List[SimpleExpr])
    If(cond: SimpleExpr, then_branch: SimpleExpr, else_branch: SimpleExpr)
    Match(expr: SimpleExpr, cases: List[(String, SimpleExpr)])
    Lambda(params: List[String], body: SimpleExpr)
    Let(name: String, value: SimpleExpr, body: SimpleExpr)
    ListLit(elements: List[SimpleExpr])
    TupleLit(elements: List[SimpleExpr])
    Constructor(type_name: String, variant: String, args: List[SimpleExpr])

# Translate Simple expression to Lean
fn translate_expr(expr: SimpleExpr) -> String:
    match expr:
        case SimpleExpr.IntLit(v):
            return str(v)

        case SimpleExpr.BoolLit(v):
            if v:
                return "true"
            else:
                return "false"

        case SimpleExpr.StringLit(v):
            return "\"" + escape_string(v) + "\""

        case SimpleExpr.Var(name):
            return lean_ident(name)

        case SimpleExpr.BinOp(op, left, right):
            l = translate_expr(left)
            r = translate_expr(right)
            lean_op = translate_operator(op)
            return "(" + l + " " + lean_op + " " + r + ")"

        case SimpleExpr.UnOp(op, e):
            inner = translate_expr(e)
            lean_op = translate_unary_operator(op)
            return "(" + lean_op + inner + ")"

        case SimpleExpr.Call(fn_name, args):
            arg_strs = [translate_expr(a) for a in args]
            if len(arg_strs) == 0:
                return lean_ident(fn_name)
            return lean_ident(fn_name) + " " + arg_strs.join(" ")

        case SimpleExpr.FieldAccess(obj, field):
            obj_str = translate_expr(obj)
            return obj_str + "." + lean_ident(field)

        case SimpleExpr.MethodCall(obj, method, args):
            obj_str = translate_expr(obj)
            arg_strs = [translate_expr(a) for a in args]
            if len(arg_strs) == 0:
                return obj_str + "." + lean_ident(method)
            return obj_str + "." + lean_ident(method) + " " + arg_strs.join(" ")

        case SimpleExpr.If(cond, then_b, else_b):
            c = translate_expr(cond)
            t = translate_expr(then_b)
            e = translate_expr(else_b)
            return "if " + c + " then " + t + " else " + e

        case SimpleExpr.Match(e, cases):
            expr_str = translate_expr(e)
            case_strs = []
            for (pattern, body) in cases:
                body_str = translate_expr(body)
                case_strs.append("| " + pattern + " => " + body_str)
            return "match " + expr_str + " with\n" + case_strs.join("\n")

        case SimpleExpr.Lambda(params, body):
            body_str = translate_expr(body)
            params_str = params.join(" ")
            return "fun " + params_str + " => " + body_str

        case SimpleExpr.Let(name, value, body):
            v = translate_expr(value)
            b = translate_expr(body)
            return "let " + lean_ident(name) + " := " + v + "\n" + b

        case SimpleExpr.ListLit(elements):
            elem_strs = [translate_expr(e) for e in elements]
            return "[" + elem_strs.join(", ") + "]"

        case SimpleExpr.TupleLit(elements):
            elem_strs = [translate_expr(e) for e in elements]
            return "(" + elem_strs.join(", ") + ")"

        case SimpleExpr.Constructor(type_name, variant, args):
            arg_strs = [translate_expr(a) for a in args]
            if len(arg_strs) == 0:
                return type_name + "." + variant
            return type_name + "." + variant + " " + arg_strs.join(" ")

# Convert snake_case to camelCase
fn lean_ident(name: String) -> String:
    parts = name.split("_")
    if len(parts) == 1:
        return name
    result = parts[0]
    for i in range(1, len(parts)):
        if len(parts[i]) > 0:
            result = result + parts[i][0].upper() + parts[i][1:]
    return result

# Escape special characters in strings
fn escape_string(s: String) -> String:
    result = ""
    for c in s:
        if c == "\\":
            result = result + "\\\\"
        elif c == "\"":
            result = result + "\\\""
        elif c == "\n":
            result = result + "\\n"
        elif c == "\t":
            result = result + "\\t"
        else:
            result = result + c
    return result

# Translate binary operator
fn translate_operator(op: String) -> String:
    match op:
        case "+": return "+"
        case "-": return "-"
        case "*": return "*"
        case "/": return "/"
        case "%": return "%"
        case "==": return "=="
        case "!=": return "!="
        case "<": return "<"
        case "<=": return "<="
        case ">": return ">"
        case ">=": return ">="
        case "and": return "&&"
        case "or": return "||"
        case "&&": return "&&"
        case "||": return "||"
        case "++": return "++"  # List concat
        case "::": return "::"  # List cons
        case _: return op

# Translate unary operator
fn translate_unary_operator(op: String) -> String:
    match op:
        case "-": return "-"
        case "not": return "!"
        case "!": return "!"
        case _: return op

# Pattern translation
enum SimplePattern:
    WildcardPat
    VarPat(name: String)
    ConstructorPat(type_name: String, variant: String, args: List[SimplePattern])
    LitPat(value: SimpleExpr)
    TuplePat(elements: List[SimplePattern])

fn translate_pattern(pat: SimplePattern) -> String:
    match pat:
        case SimplePattern.WildcardPat:
            return "_"

        case SimplePattern.VarPat(name):
            return lean_ident(name)

        case SimplePattern.ConstructorPat(type_name, variant, args):
            if len(args) == 0:
                return type_name + "." + variant
            arg_strs = [translate_pattern(a) for a in args]
            return type_name + "." + variant + " " + arg_strs.join(" ")

        case SimplePattern.LitPat(value):
            return translate_expr(value)

        case SimplePattern.TuplePat(elements):
            elem_strs = [translate_pattern(e) for e in elements]
            return "(" + elem_strs.join(", ") + ")"

# Statement translation (for imperative code in do blocks)
enum SimpleStmt:
    ExprStmt(expr: SimpleExpr)
    LetStmt(name: String, value: SimpleExpr)
    ReturnStmt(value: SimpleExpr)
    IfStmt(cond: SimpleExpr, then_stmts: List[SimpleStmt], else_stmts: List[SimpleStmt])
    MatchStmt(expr: SimpleExpr, cases: List[(SimplePattern, List[SimpleStmt])])
    LoopStmt(var: String, iter: SimpleExpr, body: List[SimpleStmt])

fn translate_stmt(stmt: SimpleStmt, in_do_block: Bool = True) -> String:
    match stmt:
        case SimpleStmt.ExprStmt(e):
            return translate_expr(e)

        case SimpleStmt.LetStmt(name, value):
            v = translate_expr(value)
            if in_do_block:
                return "let " + lean_ident(name) + " := " + v
            return "let " + lean_ident(name) + " := " + v

        case SimpleStmt.ReturnStmt(value):
            v = translate_expr(value)
            if in_do_block:
                return "return " + v
            return v

        case SimpleStmt.IfStmt(cond, then_stmts, else_stmts):
            c = translate_expr(cond)
            let mut then_parts = []
            for s in then_stmts:
                then_parts.append(translate_stmt(s))
            then_str = then_parts.join("\n")
            let mut else_parts = []
            for s in else_stmts:
                else_parts.append(translate_stmt(s))
            else_str = else_parts.join("\n")
            return "if " + c + " then\n" + then_str + "\nelse\n" + else_str

        case SimpleStmt.MatchStmt(expr, cases):
            e = translate_expr(expr)
            case_strs = []
            for (pat, stmts) in cases:
                pat_str = translate_pattern(pat)
                let mut body_parts = []
                for s in stmts:
                    body_parts.append(translate_stmt(s))
                body_str = body_parts.join("\n")
                case_strs.append("| " + pat_str + " =>\n" + body_str)
            return "match " + e + " with\n" + case_strs.join("\n")

        case SimpleStmt.LoopStmt(var, iter, body):
            it = translate_expr(iter)
            let mut body_parts = []
            for s in body:
                body_parts.append(translate_stmt(s))
            body_str = body_parts.join("\n")
            return "for " + lean_ident(var) + " in " + it + " do\n" + body_str

# =============================================================================
# Contract Expression Translation
# Translates ContractExpr from verification.models.contracts to Lean syntax
# =============================================================================
# TODO: Module prefix in match patterns not yet supported
# These functions are stubbed out until parser supports this syntax

fn translate_contract_expr(expr: contracts.ContractExpr) -> String:
    # Stub - full implementation requires module-qualified match patterns
    return "_"

# Helper for binary operations
fn translate_binary_contract(expr: contracts.ContractExpr, op: String) -> String:
    return "_"

# Translate a decreases expression for termination proofs
fn translate_decreases_expr(exprs: List[contracts.ContractExpr]) -> String:
    return "_"

# Generate a Lean proposition from a contract expression
fn to_lean_prop(expr: contracts.ContractExpr) -> String:
    return "_"
