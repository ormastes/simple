# Lean Emitter
# Low-level Lean 4 syntax emission.

# Note: This module provides low-level Lean emission.
# It accepts simple data structures to avoid circular imports with codegen.

# Lean syntax emitter
class LeanEmitter:
    output: text
    indent_level: i32
    indent_str: text

    static fn new() -> LeanEmitter:
        LeanEmitter(
            output: "",
            indent_level: 0,
            indent_str: "  "
        )

    var fn indent():
        self.indent_level = self.indent_level + 1

    var fn dedent():
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1

    fn get_indent() -> text:
        var result = ""
        for _ in 0..self.indent_level:
            result = result + self.indent_str
        result

    var fn emit(text: text):
        self.output = self.output + text

    var fn emit_line(line: text):
        self.output = self.output + self.get_indent() + line + "\n"

    var fn emit_blank():
        self.output = self.output + "\n"

    # Emit a Lean structure definition
    # structure: object with .name, .fields (list of tuples), .deriving (list of strings)
    var fn emit_structure_data(name: text, fields: List<(text, text)>, deriving: List<text>):
        self.emit_line("structure {name} where")
        self.indent()

        for (field_name, ty) in fields:
            self.emit_line("{field_name} : {ty}")

        self.dedent()

        if deriving.len() > 0:
            val derives = deriving.join(", ")
            self.emit_line("  deriving {derives}")

    # Emit a Lean inductive definition
    # constructors: list of (name, param_types list)
    var fn emit_inductive_data(name: text, constructors: List<(text, List<text>)>, deriving: List<text>):
        self.emit_line("inductive {name} where")
        self.indent()

        for (ctor_name, params) in constructors:
            if params.len() == 0:
                self.emit_line("| {ctor_name}")
            else:
                val params_str = params.join(" → ")
                self.emit_line("| {ctor_name} : {params_str} → {name}")

        self.dedent()

        if deriving.len() > 0:
            val derives = deriving.join(", ")
            self.emit_line("  deriving {derives}")

    # Emit a Lean function definition
    var fn emit_function_data(name: text, params: List<(text, text)>, return_type: text, body: text, is_partial: bool, termination_measure: Option<text>, use_sorry: bool):
        # Build signature
        var sig = ""
        if is_partial:
            sig = sig + "partial "
        sig = sig + "def {name}"

        # Parameters
        for (param_name, ty) in params:
            sig = sig + " ({param_name} : {ty})"

        sig = sig + " : {return_type}"

        # Termination measure clause
        match termination_measure:
            case Some(expr):
                self.emit_line(sig)
                self.emit_line("  decreases {expr}")
                self.emit_line("  := {body}")
            case None:
                self.emit_line("{sig} :=")
                self.indent()
                self.emit_line(body)
                self.dedent()

    # Emit a Lean theorem
    var fn emit_theorem_data(name: text, params: List<(text, text)>, statement: text, proof: Option<text>, use_sorry: bool):
        # Build signature
        var sig = "theorem {name}"

        # Parameters
        for (param_name, ty) in params:
            sig = sig + " ({param_name} : {ty})"

        sig = sig + " : {statement}"

        self.emit_line("{sig} := by")
        self.indent()

        match proof:
            case Some(p):
                self.emit_line(p)
            case None:
                if use_sorry:
                    self.emit_line("sorry")
                else:
                    self.emit_line("-- TODO: prove this")
                    self.emit_line("sorry")

        self.dedent()

    # Emit a proposition (for invariants)
    var fn emit_prop(name: text, ty: text, body: text):
        self.emit_line("def {name} : {ty} → Prop :=")
        self.indent()
        self.emit_line("fun x => {body}")
        self.dedent()

    # Emit axiom (for trusted functions)
    var fn emit_axiom(name: text, statement: text):
        self.emit_line("axiom {name} : {statement}")

    # Emit constant
    var fn emit_constant(name: text, ty: text, value: text):
        self.emit_line("def {name} : {ty} := {value}")

    # Emit section
    var fn emit_section(name: text):
        self.emit_line("section {name}")
        self.indent()

    var fn emit_end_section(name: text):
        self.dedent()
        self.emit_line("end {name}")

    # Emit variable declaration
    var fn emit_variable(name: text, ty: text):
        self.emit_line("variable ({name} : {ty})")

    # Emit comment
    var fn emit_comment(comment: text):
        self.emit_line("-- {comment}")

    # Emit doc comment
    var fn emit_doc_comment(doc: text):
        self.emit_line("/-- {doc} -/")

    # Get final output
    fn finish() -> text:
        self.output

# Format a Lean type from Simple type
fn format_lean_type(simple_type: text) -> text:
    match simple_type:
        case "i32": "i32"
        case "f32": "f32"
        case "bool": "bool"
        case "text": "text"
        case "Nil": "Unit"
        case "()": "Unit"
        case _:
            if simple_type.starts_with("List<"):
                val inner = simple_type[5..simple_type.len()-1]
                "List {format_lean_type(inner)}"
            else if simple_type.starts_with("Option<"):
                val inner = simple_type[7..simple_type.len()-1]
                "Option {format_lean_type(inner)}"
            else if simple_type.starts_with("Result<"):
                # Extract Ok and Err types
                val inner = simple_type[7..simple_type.len()-1]
                val parts = inner.split(", ")
                if parts.len() == 2:
                    "Except {format_lean_type(parts[1])} {format_lean_type(parts[0])}"
                else:
                    simple_type
            else:
                simple_type

# Format parameter list for Lean
fn format_params(params: List<(text, text)>) -> text:
    var result = []
    for (name, ty) in params:
        result.append("({name} : {format_lean_type(ty)})")
    result.join(" ")
