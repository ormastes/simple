# Lean Contract Translation
#
# Translates contracts to Lean propositions and theorems.

import verification.lean.emitter as emit
import verification.models.contracts as c

# Contract clause as Lean proposition
class LeanProp:
    name: text
    params: List<(text, text)>  # (name, type)
    body: text

    fn create(name: text, params: List<(text, text)>, body: text) -> LeanProp:
        return LeanProp(name, params, body)

    me emit(builder: emit.LeanBuilder) -> emit.LeanBuilder:
        param_strs = ["(" + n + " : " + t + ")" for (n, t) in self.params]
        params_str = param_strs.join(" ")
        sig = "def " + self.name
        if len(self.params) > 0:
            sig = sig + " " + params_str
        sig = sig + " : Prop :="
        b = builder.line(sig)
        b = b.push_indent()
        b = b.line(self.body)
        b = b.pop_indent()
        return b

# Theorem from contract
class LeanTheorem:
    name: text
    params: List<(text, text)>
    proposition: text
    proof: text

    fn create(name: text, params: List<(text, text)>, proposition: text, proof: text = "sorry") -> LeanTheorem:
        return LeanTheorem(name, params, proposition, proof)

    me emit(builder: emit.LeanBuilder) -> emit.LeanBuilder:
        # Split proof by newlines and use multiline emitter if multiple lines
        proof_lines = self.proof.split("\n")
        if len(proof_lines) > 1:
            return emit.emit_theorem_multiline(builder, self.name, self.params, self.proposition, proof_lines)
        return emit.emit_theorem(builder, self.name, self.params, self.proposition, self.proof)

# Theorem with implicit parameters
class LeanTheoremImplicit:
    name: text
    implicit_params: List<(text, text)>
    explicit_params: List<(text, text)>
    proposition: text
    proof_lines: List<text>

    fn create(name: text, implicit_params: List<(text, text)>, explicit_params: List<(text, text)>, proposition: text, proof_lines: List<text>) -> LeanTheoremImplicit:
        return LeanTheoremImplicit(name, implicit_params, explicit_params, proposition, proof_lines)

    me emit(builder: emit.LeanBuilder) -> emit.LeanBuilder:
        return emit.emit_theorem_implicit(builder, self.name, self.implicit_params, self.explicit_params, self.proposition, self.proof_lines)

# Translate contract expression to Lean
fn translate_contract_expr(expr: c.ContractExpr) -> text:
    match expr.kind:
        case c.ContractExprKind.True_:
            return "true"
        case c.ContractExprKind.False_:
            return "false"
        case c.ContractExprKind.ValExpr:
            # Extract val_value from Some
            match expr.value_data:
                case Some(v): return translate_val(v)
                case _: return "invalid_val"
        case c.ContractExprKind.VarRef:
            # Extract name from Some
            match expr.name:
                case Some(n): return n
                case _: return "unknown_var"
        case c.ContractExprKind.OldValue:
            if expr.children.len() > 0:
                return "old_" + translate_contract_expr(expr.children[0])
            return "old_unknown"
        case c.ContractExprKind.Result:
            return "result"
        case c.ContractExprKind.And:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " ∧ " + r + ")"
            return "invalid_and"
        case c.ContractExprKind.Or:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " ∨ " + r + ")"
            return "invalid_or"
        case c.ContractExprKind.Not:
            if expr.children.len() > 0:
                inner = translate_contract_expr(expr.children[0])
                return "¬" + inner
            return "invalid_not"
        case c.ContractExprKind.Implies:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " → " + r + ")"
            return "invalid_implies"
        case c.ContractExprKind.Eq:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " = " + r + ")"
            return "invalid_eq"
        case c.ContractExprKind.Lt:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " < " + r + ")"
            return "invalid_lt"
        case c.ContractExprKind.Le:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " ≤ " + r + ")"
            return "invalid_le"
        case c.ContractExprKind.Gt:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " > " + r + ")"
            return "invalid_gt"
        case c.ContractExprKind.Ge:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " ≥ " + r + ")"
            return "invalid_ge"
        case c.ContractExprKind.Add:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " + " + r + ")"
            return "invalid_add"
        case c.ContractExprKind.Sub:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " - " + r + ")"
            return "invalid_sub"
        case c.ContractExprKind.Mul:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " * " + r + ")"
            return "invalid_mul"
        case c.ContractExprKind.Div:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + " / " + r + ")"
            return "invalid_div"
        case c.ContractExprKind.Len:
            if expr.children.len() > 0:
                inner = translate_contract_expr(expr.children[0])
                return "List.length " + inner
            return "invalid_len"
        case c.ContractExprKind.Index:
            if expr.children.len() >= 2:
                l = translate_contract_expr(expr.children[0])
                r = translate_contract_expr(expr.children[1])
                return "(" + l + "[" + r + "])"
            return "invalid_index"
        case c.ContractExprKind.Call:
            match expr.name:
                case Some(fn_name):
                    arg_strs = [translate_contract_expr(a) for a in expr.children]
                    return fn_name + " " + arg_strs.join(" ")
                case _:
                    return "unknown_call"
        case _:
            return "unsupported_expr"

fn translate_val(v: c.ContractValue) -> text:
    match v:
        case c.ContractValue.IntVal(n): return str(n)
        case c.ContractValue.BoolVal(b):
            if b:
                return "true"
            else:
                return "false"
        case c.ContractValue.StrVal(s): return "\"" + s + "\""
        case c.ContractValue.NilVal: return "none"
        case c.ContractValue.ErrorVal(tag, _): return "error \"" + tag + "\""

fn translate_binop(op: text) -> text:
    match op:
        case "+": return "+"
        case "-": return "-"
        case "*": return "*"
        case "/": return "/"
        case "==": return "="
        case "!=": return "≠"
        case "<": return "<"
        case "<=": return "≤"
        case ">": return ">"
        case ">=": return "≥"
        case "&&": return "∧"
        case "||": return "∨"
        case _: return op

fn translate_unop(op: text) -> text:
    match op:
        case "-": return "-"
        case "!": return "¬"
        case "not": return "¬"
        case _: return op

# Generate invariant proposition
fn generate_invariant_prop(type_name: text, clauses: List<c.ContractClause>) -> LeanProp:
    if len(clauses) == 0:
        body = "True"
    elif len(clauses) == 1:
        body = translate_contract_expr(clauses[0].expr)
    else:
        parts = [translate_contract_expr(cl.expr) for cl in clauses]
        body = parts.join(" ∧ ")

    return LeanProp.create("inv_" + type_name, [("self", type_name)], body)

# Generate precondition theorem
fn generate_precondition_theorem(fn_name: text, contract: c.FunctionContract, params: List<(text, text)>) -> Option<LeanTheorem>:
    if len(contract.preconditions) == 0:
        return None

    parts = [translate_contract_expr(cl.expr) for cl in contract.preconditions]
    prop = parts.join(" ∧ ")

    return Some(LeanTheorem.create(fn_name + "_pre", params, prop))

# Generate postcondition theorem
fn generate_postcondition_theorem(fn_name: text, contract: c.FunctionContract, params: List<(text, text)>, ret_type: text) -> Option<LeanTheorem>:
    if len(contract.postconditions) == 0:
        return None

    # Add result parameter
    full_params = params.append(("result", ret_type))

    parts = [translate_contract_expr(cl.expr) for cl in contract.postconditions]
    prop = parts.join(" ∧ ")

    return Some(LeanTheorem.create(fn_name + "_post", full_params, prop))

# Generate full contract verification theorem
fn generate_contract_theorem(fn_name: text, contract: c.FunctionContract, params: List<(text, text)>, ret_type: text) -> LeanTheorem:
    pre_parts = [translate_contract_expr(cl.expr) for cl in contract.preconditions]
    post_parts = [translate_contract_expr(cl.expr) for cl in contract.postconditions]

    pre = "True"
    if len(pre_parts) > 0:
        pre = pre_parts.join(" ∧ ")
    post = "True"
    if len(post_parts) > 0:
        post = post_parts.join(" ∧ ")

    prop = pre + " → ∃ result : " + ret_type + ", " + post

    return LeanTheorem.create(fn_name + "_contract", params, prop)

# Export public API
export LeanProp, LeanTheorem, LeanTheoremImplicit
