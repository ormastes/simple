# Lean Code Generator
# Main entry point for generating Lean 4 code from Simple.

import verification.lean.emitter as emitter
import verification.lean.types as types
import verification.lean.expressions as expressions
import verification.models.contracts as models_contracts
import io.fs as fs

# Lean code generation options
class LeanCodegenOptions:
    module_name: text
    generate_stubs: bool       # Generate sorry for unproven theorems
    include_proofs: bool       # Include proof obligations
    verbose: bool              # Emit comments
    output_dir: text

    static fn new() -> LeanCodegenOptions:
        LeanCodegenOptions(
            module_name: "Main",
            generate_stubs: true,
            include_proofs: true,
            verbose: false,
            output_dir: "build/lean"
        )

    var fn with_module_name(name: text) -> LeanCodegenOptions:
        self.module_name = name
        self

    var fn with_stubs(generate: bool) -> LeanCodegenOptions:
        self.generate_stubs = generate
        self

    var fn with_output_dir(dir: text) -> LeanCodegenOptions:
        self.output_dir = dir
        self

# Lean function representation
class LeanFunction:
    name: text
    params: List<(text, text)>  # (name, type)
    return_type: text
    body: text
    is_partial: bool
    termination_measure: Option<text>  # Renamed from decreases to avoid keyword conflict

    fn new(name: text) -> LeanFunction:
        LeanFunction(
            name: name,
            params: [],
            return_type: "Unit",
            body: "sorry",
            is_partial: false,
            termination_measure: None
        )

    var fn add_param(name: text, ty: text) -> LeanFunction:
        self.params = self.params + [(name, ty)]
        self

    var fn with_return_type(ty: text) -> LeanFunction:
        self.return_type = ty
        self

    var fn with_body(body: text) -> LeanFunction:
        self.body = body
        self

    var fn with_decreases(expr: text) -> LeanFunction:
        self.termination_measure = Some(expr)
        self

    var fn partial() -> LeanFunction:
        self.is_partial = true
        self

# Lean theorem representation
class LeanTheorem:
    name: text
    params: List<(text, text)>
    statement: text
    proof: Option<text>

    fn new(name: text, statement: text) -> LeanTheorem:
        LeanTheorem(
            name: name,
            params: [],
            statement: statement,
            proof: None
        )

    var fn add_param(name: text, ty: text) -> LeanTheorem:
        self.params = self.params + [(name, ty)]
        self

    var fn with_proof(proof: text) -> LeanTheorem:
        self.proof = Some(proof)
        self

# Lean structure (for Simple classes)
class LeanStructure:
    name: text
    fields: List<(text, text)>  # (name, type)
    deriving: List<text>

    fn new(name: text) -> LeanStructure:
        LeanStructure(name: name, fields: [], deriving: [])

    var fn add_field(name: text, ty: text) -> LeanStructure:
        self.fields = self.fields + [(name, ty)]
        self

    var fn derive(trait_name: text) -> LeanStructure:
        self.deriving = self.deriving + [trait_name]
        self

# Lean inductive (for Simple enums)
class LeanInductive:
    name: text
    constructors: List<(text, List<text>)>  # (name, param types)
    deriving: List<text>

    fn new(name: text) -> LeanInductive:
        LeanInductive(name: name, constructors: [], deriving: [])

    var fn add_constructor(name: text, params: List<text>) -> LeanInductive:
        self.constructors = self.constructors + [(name, params)]
        self

    var fn with_deriving(trait_names: List<text>) -> LeanInductive:
        for t in trait_names:
            self.deriving = self.deriving + [t]
        self

# Lean abbreviation (for type aliases)
class LeanAbbrev:
    name: text
    ty: text

    fn new(name: text, ty: text) -> LeanAbbrev:
        LeanAbbrev(name: name, ty: ty)

# Main Lean code generator
class LeanCodegen:
    options: LeanCodegenOptions
    structures: List<LeanStructure>
    inductives: List<LeanInductive>
    functions: List<LeanFunction>
    theorems: List<LeanTheorem>
    imports: List<text>
    raw_output: text  # For raw line output mode (string concatenation)

    fn new(options: LeanCodegenOptions) -> LeanCodegen:
        LeanCodegen(
            options: options,
            structures: [],
            inductives: [],
            functions: [],
            theorems: [],
            imports: ["Mathlib.Data.Nat.Basic"],
            raw_output: ""
        )

    # Static factory method for simplified creation
    fn create(module_name: text) -> LeanCodegen:
        var options = LeanCodegenOptions.new()
        options = options.with_module_name(module_name)
        LeanCodegen.new(options)

    var fn add_import(import_path: text) -> LeanCodegen:
        self.imports = self.imports + [import_path]
        self

    var fn add_structure(structure: LeanStructure) -> LeanCodegen:
        self.structures = self.structures + [structure]
        self

    var fn add_inductive(inductive: LeanInductive) -> LeanCodegen:
        self.inductives = self.inductives + [inductive]
        self

    var fn add_function(function: LeanFunction) -> LeanCodegen:
        self.functions = self.functions + [function]
        self

    var fn add_theorem(theorem: LeanTheorem) -> LeanCodegen:
        self.theorems = self.theorems + [theorem]
        self

    # Add theorem with implicit parameters
    var fn add_theorem_implicit(theorem: LeanTheorem) -> LeanCodegen:
        self.theorems = self.theorems + [theorem]
        self

    # Raw line output methods for flexible code generation
    # All methods return self for method chaining
    var fn add_raw_line(line: text) -> LeanCodegen:
        self.raw_output = self.raw_output + line + "\n"
        self

    var fn add_blank() -> LeanCodegen:
        self.raw_output = self.raw_output + "\n"
        self

    var fn add_doc_comment(doc: text) -> LeanCodegen:
        self.raw_output = self.raw_output + "/-- {doc} -/\n"
        self

    var fn add_block_comment(lines: List<text>) -> LeanCodegen:
        self.raw_output = self.raw_output + "/-\n"
        for line in lines:
            self.raw_output = self.raw_output + "  {line}\n"
        self.raw_output = self.raw_output + "-/\n"
        self

    var fn add_namespace(name: text) -> LeanCodegen:
        self.raw_output = self.raw_output + "namespace {name}\n"
        self

    var fn end_namespace(name: text) -> LeanCodegen:
        self.raw_output = self.raw_output + "end {name}\n"
        self

    var fn add_section_header(title: text) -> LeanCodegen:
        self.raw_output = self.raw_output + "-- ════════════════════════════════════════════════════════════════\n"
        self.raw_output = self.raw_output + "-- {title}\n"
        self.raw_output = self.raw_output + "-- ════════════════════════════════════════════════════════════════\n\n"
        self

    var fn add_abbrev(abbrev: LeanAbbrev) -> LeanCodegen:
        self.raw_output = self.raw_output + "abbrev {abbrev.name} := {abbrev.ty}\n"
        self

    # Emit all raw output combined with structured content as a single string
    # The structured content is inserted before "end <namespace>" if present
    fn emit() -> text:
        # Build structured content first
        var structured = ""

        # Add inductives (enums)
        for inductive in self.inductives:
            structured = structured + "inductive {inductive.name}\n"
            for (ctor_name, params) in inductive.constructors:
                if params.len() == 0:
                    structured = structured + "  | {ctor_name}\n"
                else:
                    val param_str = params.join(" → ")
                    structured = structured + "  | {ctor_name} : {param_str} → {inductive.name}\n"
            if inductive.deriving.len() > 0:
                val derives = inductive.deriving.join(", ")
                structured = structured + "deriving {derives}\n"
            structured = structured + "\n"

        # Add functions
        for func in self.functions:
            if func.is_partial:
                structured = structured + "partial "
            structured = structured + "def {func.name}"
            for (pname, ptype) in func.params:
                structured = structured + " ({pname} : {ptype})"
            structured = structured + " : {func.return_type} :=\n"
            structured = structured + "  {func.body}\n\n"

        # Add theorems
        for theorem in self.theorems:
            structured = structured + "theorem {theorem.name}"
            for (pname, ptype) in theorem.params:
                structured = structured + " ({pname} : {ptype})"
            structured = structured + " :\n  {theorem.statement} := by\n"
            match theorem.proof:
                case Some(proof):
                    structured = structured + "  {proof}\n\n"
                case None:
                    structured = structured + "  sorry\n\n"

        # Find "end " in raw_output and insert structured content before it
        val lines = self.raw_output.split("\n")
        var result = ""
        var found_end = false
        for line in lines:
            if line.starts_with("end ") and not found_end:
                # Insert structured content before end namespace
                result = result + structured
                found_end = true
            result = result + line + "\n"

        # If no "end" found, just append structured content at the end
        if not found_end:
            result = result + structured

        result

    # Generate Lean code for a function contract
    var fn generate_contract_theorems(func_name: text, contract: models_contracts.FunctionContract):
        # Generate precondition theorem
        for (i, clause) in contract.preconditions.enumerate():
            val theorem_name = "{func_name}_pre_{i}"
            val statement = expressions.translate_contract_expr(clause.expr)
            val theorem = LeanTheorem.new(theorem_name, statement)
            self.add_theorem(theorem)

        # Generate postcondition theorems
        for (i, clause) in contract.postconditions.enumerate():
            val theorem_name = "{func_name}_post_{i}"
            val statement = expressions.translate_contract_expr(clause.expr)
            val theorem = LeanTheorem.new(theorem_name, statement)
            self.add_theorem(theorem)

        # Generate invariant theorems
        for (i, clause) in contract.invariants.enumerate():
            val theorem_name = "{func_name}_inv_{i}"
            val statement = expressions.translate_contract_expr(clause.expr)
            val theorem = LeanTheorem.new(theorem_name, statement)
            self.add_theorem(theorem)

    # Generate complete Lean module
    fn generate() -> text:
        var emit = emitter.LeanEmitter.new()

        # Module header
        emit.emit_line("-- Auto-generated Lean 4 code from Simple")
        emit.emit_line("-- Module: {self.options.module_name}")
        emit.emit_line("")

        # Imports
        for import_path in self.imports:
            emit.emit_line("import {import_path}")
        emit.emit_line("")

        # Namespace
        emit.emit_line("namespace {self.options.module_name}")
        emit.emit_line("")

        # Structures
        for structure in self.structures:
            emit.emit_structure(structure)
            emit.emit_line("")

        # Inductives
        for inductive in self.inductives:
            emit.emit_inductive(inductive)
            emit.emit_line("")

        # Functions
        for function in self.functions:
            emit.emit_function(function, self.options.generate_stubs)
            emit.emit_line("")

        # Theorems
        for theorem in self.theorems:
            emit.emit_theorem(theorem, self.options.generate_stubs)
            emit.emit_line("")

        # Close namespace
        emit.emit_line("end {self.options.module_name}")

        emit.finish()

    # Write generated code to file
    fn write_to_file(filename: text) -> Result<Nil, text>:
        val content = self.generate()
        val path = "{self.options.output_dir}/{filename}.lean"

        # Ensure output directory exists
        fs.makedirs(self.options.output_dir)?

        # Write file
        fs.write_string(path, content)?

        Ok(nil)

# Convenience function to generate Lean for a module
fn generate_module(module_name: text, output_dir: text) -> LeanCodegen:
    val options = LeanCodegenOptions.new()
        .with_module_name(module_name)
        .with_output_dir(output_dir)
    LeanCodegen.new(options)

# =============================================================================
# Helper Functions for Regeneration Scripts
# =============================================================================

# Create a simple type representation
fn make_simple_type(name: text) -> text:
    name

# Create a list type representation
fn make_list_type(elem_type: text) -> text:
    "List {elem_type}"

# Create a string type representation
static fn make_string_type() -> text:
    "text"

# Create an i32 type representation
static fn make_int_type() -> text:
    "i32"

# Create a bool type representation
static fn make_bool_type() -> text:
    "bool"

# Create an option type representation
fn make_option_type(elem_type: text) -> text:
    "Option {elem_type}"

# Create a nat type representation
static fn make_nat_type() -> text:
    "Nat"

# Build an enum/inductive type for regeneration scripts
# Note: Returns LeanInductive. Use with_deriving_enum for deriving clauses.
fn build_enum(name: text, variants: List<(text, List[(text, text)>)]) -> LeanInductive:
    var ind = LeanInductive.new(name)
    for (var_name, params) in variants:
        var param_types: List<text> = []
        for (pname, ptype) in params:
            param_types = param_types + [ptype]
        ind = ind.add_constructor(var_name, param_types)
    ind

# Build an enum with deriving clause - to avoid method chaining issues
fn build_enum_with_deriving(name: text, variants: List<(text, List[(text, text)>)], derives: List<text>) -> LeanInductive:
    var ind = build_enum(name, variants)
    for d in derives:
        ind.deriving = ind.deriving + [d]
    ind

# Build a class/structure for regeneration scripts
fn build_class(name: text, fields: List<(text, text)>) -> LeanStructure:
    var s = LeanStructure.new(name)
    for (fname, ftype) in fields:
        s = s.add_field(fname, ftype)
    s

# Build a class/structure with deriving clause
fn build_class_with_deriving(name: text, fields: List<(text, text)>, derives: List<text>) -> LeanStructure:
    var s = build_class(name, fields)
    for d in derives:
        s.deriving = s.deriving + [d]
    s

# Build a function for regeneration scripts
fn build_function(name: text, params: List<(text, text)>, ret_type: text, body: text) -> LeanFunction:
    var func = LeanFunction.new(name)
    for (pname, ptype) in params:
        func = func.add_param(pname, ptype)
    func = func.with_return_type(ret_type)
    func = func.with_body(body)
    func

# Build a theorem for regeneration scripts
fn build_theorem(name: text, params: List<(text, text)>, statement: text, proof: text) -> LeanTheorem:
    var thm = LeanTheorem.new(name, statement)
    for (pname, ptype) in params:
        thm = thm.add_param(pname, ptype)
    thm = thm.with_proof(proof)
    thm

# Build a theorem with implicit and explicit parameters
fn build_theorem_implicit(name: text, impl_params: List<(text, text)>, expl_params: List<(text, text)>, statement: text, proof_lines: List<text>) -> LeanTheorem:
    val proof = proof_lines.join("\n")
    var thm = LeanTheorem.new(name, statement)
    # Add implicit params first (treated the same for now)
    for (pname, ptype) in impl_params:
        thm = thm.add_param(pname, ptype)
    for (pname, ptype) in expl_params:
        thm = thm.add_param(pname, ptype)
    thm = thm.with_proof(proof)
    thm

# Build an abbreviation for regeneration scripts
fn build_abbrev(name: text, ty: text) -> LeanAbbrev:
    LeanAbbrev.new(name, ty)
