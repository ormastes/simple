/**
Promise Type for Async-by-Default Semantics

Promise<T> represents a value that will be available in the future.
This is the return type of all async functions in the async-by-default model.

Key Concepts:
- `sync fn foo() -> T` returns T directly
- `fn bar() -> T` returns Promise<T> (async by default)
- Use `await` to extract T from Promise<T>

States:
- Pending: Computation not yet complete
- Resolved: Successfully completed with value
- Rejected: Failed with error

Basic Usage:
```sdoctest
>>> val p = Promise.resolved(42)
>>> await p
42
```

Creating Promises:
```sdoctest
>>> val p = Promise.new(\resolve, reject: resolve(100))
>>> await p
100
```

Chaining:
```sdoctest
>>> val p1 = Promise.resolved(10)
>>> val p2 = p1.then(\x: x * 2)
>>> await p2
20
```

Error Handling:
```sdoctest
>>> val p = Promise.rejected("error")
>>> try:
...     await p
... catch e:
...     "caught: " + e
'caught: error'
```
*/

/// Promise state enum
enum PromiseState:
    Pending
    Resolved(value)
    Rejected(error)

impl PromiseState:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string() -> text:
        """Convert state to string."""
        match self:
            case Pending: return "Pending"
            case Resolved(_): return "Resolved"
            case Rejected(_): return "Rejected"

    fn description() -> text:
        """Get detailed state description."""
        match self:
            case Pending: return "Promise is pending"
            case Resolved(v): return "Promise resolved with value"
            case Rejected(e): return "Promise rejected with error"

    fn is_pending() -> bool:
        """Check if this is Pending state."""
        match self:
            case Pending: true
            case _: false

    fn is_resolved() -> bool:
        """Check if this is Resolved state."""
        match self:
            case Resolved(_): true
            case _: false

    fn is_rejected() -> bool:
        """Check if this is Rejected state."""
        match self:
            case Rejected(_): true
            case _: false

    fn is_settled() -> bool:
        """Check if this is settled (resolved or rejected)."""
        match self:
            case Pending: false
            case _: true

    fn summary() -> text:
        """Get summary of promise state.

        Returns:
            Human-readable summary

        Example:
            PromiseState::Pending.summary()
            # → "PromiseState: Pending (not settled)"
            PromiseState::Resolved(42).summary()
            # → "PromiseState: Resolved (settled with value)"
        """
        match self:
            case Pending:
                return "PromiseState: Pending (not settled)"
            case Resolved(_):
                return "PromiseState: Resolved (settled with value)"
            case Rejected(_):
                return "PromiseState: Rejected (settled with error)"

# Promise<T> - Represents an asynchronous computation that will produce T
#
# This is the core type for async-by-default semantics.
# All non-sync functions return Promise<T> instead of T.
class Promise<T>:
    state: PromiseState
    callbacks: List  # List of (resolve_fn, reject_fn) pairs

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_pending() -> bool:
        """Check if promise is pending."""
        return self.state.is_pending()

    fn is_resolved() -> bool:
        """Check if promise is resolved."""
        return self.state.is_resolved()

    fn is_rejected() -> bool:
        """Check if promise is rejected."""
        return self.state.is_rejected()

    fn is_settled() -> bool:
        """Check if promise is settled (resolved or rejected)."""
        return self.state.is_settled()

    fn has_callbacks() -> bool:
        """Check if promise has pending callbacks."""
        return self.callbacks.len() > 0

    fn callback_count() -> i32:
        """Get number of pending callbacks."""
        return self.callbacks.len()

    fn get_state() -> PromiseState:
        """Get current state."""
        return self.state

    fn summary() -> text:
        """Get summary of promise state."""
        val state_str = self.state.to_string()
        val cb_count = self.callback_count()
        return "Promise<T>: {state_str}, {cb_count} callbacks"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new pending promise
    # The executor function receives resolve and reject callbacks:
    # - Call resolve(value) to fulfill the promise
    # - Call reject(error) to reject the promise
    static fn new(executor) -> Promise<T>:
        var promise = Promise<T> {
            state: PromiseState.Pending,
            callbacks: []
        }

        # Define resolve callback
        fn resolve(value):
            if promise.state is PromiseState.Pending:
                promise.state = PromiseState.Resolved(value)
                # Execute all pending callbacks
                for (on_resolve, on_reject) in promise.callbacks:
                    on_resolve(value)

        # Define reject callback
        fn reject(error):
            if promise.state is PromiseState.Pending:
                promise.state = PromiseState.Rejected(error)
                # Execute all pending callbacks
                for (on_resolve, on_reject) in promise.callbacks:
                    on_reject(error)

        # Execute the executor function
        # TODO: [stdlib][P2] Add try-catch when error handling is implemented
        executor(resolve, reject)

        return promise

    # Create an already-resolved promise
    static fn resolved(v: T) -> Promise<T>:
        return Promise<T> {
            state: PromiseState.Resolved(v),
            callbacks: []
        }

    # Create an already-rejected promise
    static fn rejected(err) -> Promise<T>:
        return Promise<T> {
            state: PromiseState.Rejected(err),
            callbacks: []
        }

    # Create a pending promise (for internal use in simplified implementations)
    static fn pending() -> Promise<T>:
        return Promise<T> {
            state: PromiseState.Pending,
            callbacks: []
        }

    # Chain a transformation function
    # Returns a new promise that applies the function to the resolved value.
    fn then<U>(self, on_resolve) -> Promise<U>:
        # Simplified implementation for interpreter compatibility
        if self.state.is_resolved():
            match self.state:
                case PromiseState.Resolved(v):
                    # TODO: [stdlib][P2] Add try-catch when error handling is implemented
                    val result = on_resolve(v)
                    return Promise.resolved(result)
                case _:
                    return Promise.rejected("unreachable")
        elif self.state.is_rejected():
            match self.state:
                case PromiseState.Rejected(e):
                    return Promise.rejected(e)
                case _:
                    return Promise.rejected("unreachable")
        else:
            # Pending - return a pending promise
            # TODO: [stdlib][P2] Implement callback registration for pending promises
            return Promise.pending()

    # Catch errors from a rejected promise
    fn catch<U>(self, on_reject) -> Promise<U>:
        # Simplified implementation for interpreter compatibility
        if self.state.is_resolved():
            match self.state:
                case PromiseState.Resolved(v):
                    return Promise.resolved(v)
                case _:
                    return Promise.rejected("unreachable")
        elif self.state.is_rejected():
            match self.state:
                case PromiseState.Rejected(e):
                    # TODO: [stdlib][P2] Add try-catch when error handling is implemented
                    val result = on_reject(e)
                    return Promise.resolved(result)
                case _:
                    return Promise.rejected("unreachable")
        else:
            # Pending - return a pending promise
            # TODO: [stdlib][P2] Implement callback registration for pending promises
            return Promise.pending()

    # Map a function over the promise value
    # Similar to then(), but specifically for transformations.
    fn map<U>(self, transform) -> Promise<U>:
        return self.then(transform)

    # Flat map - chain promises together
    # Use when the transform function returns another Promise.
    fn flat_map<U>(self, transform) -> Promise<U>:
        # Simplified implementation for interpreter compatibility
        if self.state.is_resolved():
            match self.state:
                case PromiseState.Resolved(v):
                    return transform(v)
                case _:
                    return Promise.rejected("unreachable")
        elif self.state.is_rejected():
            match self.state:
                case PromiseState.Rejected(e):
                    return Promise.rejected(e)
                case _:
                    return Promise.rejected("unreachable")
        else:
            return Promise.pending()

# Wait for all promises to complete
# Returns a promise that resolves to a list of all results.
# If any promise rejects, the returned promise rejects immediately.
fn all<T>(promises: List<Promise<T>>) -> Promise<List<T>>:
    # Simplified implementation for interpreter compatibility
    if promises.is_empty:
        return Promise.resolved([])

    var results = []
    for p in promises:
        if p.state.is_rejected():
            match p.state:
                case PromiseState.Rejected(e):
                    return Promise.rejected(e)
                case _:
                    pass
        elif p.state.is_resolved():
            match p.state:
                case PromiseState.Resolved(v):
                    results.append(v)
                case _:
                    pass
        else:
            # Has pending promise - return pending
            return Promise.pending()
    return Promise.resolved(results)

# Race multiple promises
# Returns a promise that resolves or rejects with the first settled promise.
fn race<T>(promises: List<Promise<T>>) -> Promise<T>:
    # Simplified implementation for interpreter compatibility
    if promises.is_empty:
        return Promise.rejected("race: empty list")

    # Return first settled promise
    for p in promises:
        if p.state.is_settled():
            return p
    # All pending - return pending
    return Promise.pending()

# Wait for all promises, even if some reject
# Returns a promise that resolves to a list of results,
# where each result is either Ok(value) or Err(error).
fn all_settled<T>(promises: List<Promise<T>>) -> Promise<List<Result<T>>>:
    # Simplified implementation for interpreter compatibility
    if promises.is_empty:
        return Promise.resolved([])

    var results = []
    for p in promises:
        if p.state.is_resolved():
            match p.state:
                case PromiseState.Resolved(v):
                    results.append(Ok(v))
                case _:
                    pass
        elif p.state.is_rejected():
            match p.state:
                case PromiseState.Rejected(e):
                    results.append(Err(e))
                case _:
                    pass
        else:
            # Has pending promise - return pending
            return Promise.pending()
    return Promise.resolved(results)

# Create a promise that resolves after a delay
fn delay<T>(milliseconds: i32, v: T) -> Promise<T>:
    # Simplified implementation - resolves immediately
    # TODO: [stdlib][P2] Implement actual timer-based delay
    return Promise.resolved(v)
