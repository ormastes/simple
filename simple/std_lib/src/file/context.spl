# Context Manager Support for File I/O
#
# Implements context manager protocols for automatic resource cleanup.
# Enables `with` and `async with` statements for file handling.

use file.mmap
use file.async_handle

# Sync context manager trait
pub trait ContextManager[T]:
    fn __enter__(self) -> T
    fn __exit__(self, exc: Option[Exception]) -> bool

# Async context manager trait
pub trait AsyncContextManager[T]:
    async fn __aenter__(self) -> T
    async fn __aexit__(self, exc: Option[Exception]) -> bool

# Context manager for MmapRegion (sync)
impl ContextManager[MmapRegion] for MmapRegion:
    fn __enter__(self) -> MmapRegion:
        # Return self - already loaded
        return self

    fn __exit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: unmap the memory region
        # Call sys_munmap from __init__.spl
        # TODO: [stdlib][P1] Implement actual cleanup
        # For now, just return false (don't suppress exceptions)
        return false

# Async context manager for AsyncFileHandle (Pattern 1: auto-loading)
# Usage: async with await file.open(path) as mmap:
impl AsyncContextManager[MmapRegion] for AsyncFileHandle:
    async fn __aenter__(self) -> MmapRegion:
        # Wait for loading to complete, then return the region
        let region = await self.wait()
        match region:
            case Ok(r):
                return r
            case Err(e):
                # TODO: [stdlib][P3] Raise exception
                # For now, create empty region as placeholder
                return MmapRegion {
                    data: null,
                    length: 0,
                    mode: MmapMode::ReadOnly,
                    fd: -1,
                    path: ""
                }

    async fn __aexit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: unmap the region if it was loaded
        match self.state:
            case FileState::Ready(region):
                # TODO: [stdlib][P3] Call sys_munmap on region
                pass
            case _:
                pass
        return false

# Alternative: Lazy loading context manager (Pattern 3)
# This would be used with a hypothetical open_lazy() function
# Usage: async with await file.open_lazy(path) as handle:
impl AsyncContextManager[AsyncFileHandle] for AsyncFileHandle:
    async fn __aenter__(self) -> AsyncFileHandle:
        # Start loading if not already started
        if not self.is_ready() and not self.is_failed():
            self.start_loading()
        return self

    async fn __aexit__(self, exc: Option[Exception]) -> bool:
        # Cleanup: cancel loading if still in progress, unmap if ready
        match self.state:
            case FileState::Loading:
                self.cancel()
            case FileState::Ready(region):
                # TODO: [stdlib][P3] Call sys_munmap on region
                pass
            case _:
                pass
        return false

# Exception type for file operations
# (Placeholder - should be defined in core error system)
pub struct Exception:
    message: String

    pub fn new(message: String) -> Exception:
        return Exception { message: message }

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if exception message is empty."""
        return self.message.is_empty()

    pub fn len(self) -> usize:
        """Get length of exception message."""
        return self.message.len()

    pub fn contains(self, needle: &str) -> bool:
        """Check if exception message contains a substring."""
        return self.message.contains(needle)

    pub fn starts_with(self, prefix: &str) -> bool:
        """Check if exception message starts with prefix."""
        return self.message.starts_with(prefix)

    pub fn ends_with(self, suffix: &str) -> bool:
        """Check if exception message ends with suffix."""
        return self.message.ends_with(suffix)

    pub fn to_string(self) -> String:
        """Convert exception to string."""
        return self.message.clone()

    pub fn summary(self) -> String:
        """Get summary of exception."""
        let preview = if self.message.len() > 50:
            self.message.slice(0, 50) + "..."
        else:
            self.message.clone()
        return "Exception: {preview}"
