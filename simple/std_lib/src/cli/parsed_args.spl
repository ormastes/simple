# CLI ParsedArgs - Parsed argument results

export ParsedArgs

import cli.file as file

# Parsed arguments result with staged files
pub struct ParsedArgs:
    flags: Dict[String, bool]
    options: Dict[String, String]
    positionals: Array[String]
    files: file.StagedFiles  # Automatically staged files

    # Check if a flag is present
    pub fn has_flag(self, name: String) -> bool:
        let result = false
        if self.flags.contains_key(name):
            result = self.flags.get(name).unwrap_or(false)
        return result

    # Get a flag value
    pub fn get_flag(self, name: String) -> bool:
        return self.has_flag(name)

    # Get an option value as string
    pub fn get_option(self, name: String) -> Option[String]:
        if self.options.contains_key(name):
            return Some(self.options.get(name).unwrap())
        return None

    # Get an option value with default
    pub fn get_option_or(self, name: String, default: String) -> String:
        let result = ""
        if self.options.contains_key(name):
            result = self.options.get(name).unwrap()
        else:
            result = default
        return result

    # Get a positional argument by index
    pub fn get_positional_at(self, index: i32) -> Option[String]:
        if index >= 0 and index < self.positionals.len():
            return Some(self.positionals[index])
        return None

    # Get all positionals
    pub fn get_all_positionals(self) -> Array[String]:
        return self.positionals

    # Get all successfully staged files
    pub fn get_staged_files(self) -> Array[file.FileInfo]:
        return self.files.staged()

    # Get file by option name
    pub fn get_file(self, name: String) -> Option[file.FileInfo]:
        # Find file matching this option name
        for f in self.files.staged():
            # TODO: [stdlib][P2] Track which arg each file came from
            # For now, return first file
            return Some(f)
        return None
