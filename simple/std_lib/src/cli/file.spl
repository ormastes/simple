# CLI File Validation - File argument validation and staging utilities
#
# **Supports both sync and async modes:**
# - Sync mode (default): Validates paths only, no file loading
# - Async mode (via ArgParser.with_async_loading): Starts background loading during parse
#
# This module provides SYNCHRONOUS file validation for CLI arguments.
# It is designed for use during argument parsing (pre-execution validation).
#
# **For file I/O operations, use the `file` module:**
# - `file` module: Async memory-mapped file I/O (default for applications)
# - `cli.file` module: Path validation + optional async loading
#
# Extern declarations for file system FFI
extern fn rt_file_exists(path: String) -> Bool
extern fn rt_file_canonicalize(path: String) -> String

# This module provides Python argparse-style file validation for CLI arguments:
# - Check if files exist (relative or absolute paths)
# - Validate file types and permissions
# - Stage multiple files for processing
# - Normalize file paths
# - Optionally start async loading in background
#
# Example (sync mode):
#   let parser = ArgParser::new("myapp", "File processor")
#       .file_arg("input", "i", "Input file", required: true, must_exist: true)
#       .file_arg("output", "o", "Output file", required: false, must_exist: false)
#
#   match parser.parse(sys_get_args()):
#       case Ok(args):
#           # Use the async `file` module to load files
#           for file_info in args.files.staged():
#               async with await file.open(file_info.path) as mmap:
#                   process_file(mmap.as_bytes())
#
# Example (async mode - background loading):
#   let parser = ArgParser::new("myapp", "File processor")
#       .file_arg("input", "i", "Input file", required: true, must_exist: true)
#       .with_async_loading(true)  # Enable background loading
#
#   match parser.parse(sys_get_args()):
#       case Ok(args):
#           # Files already loading in background!
#           let regions = await args.files.wait_all()?
#           for region in regions:
#               process_file(region.as_bytes())

# Import async file handle types for background loading
# The file module re-exports all types from async_handle and mmap
use file::{AsyncFileHandle, FileState, MmapRegion, OpenOptions, FileError}

# File validation result
pub enum FileValidation:
    Exists(String)
    NotFound(String)
    NotFile(String)
    NotReadable(String)
    NotWritable(String)

impl FileValidation:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_exists(self) -> bool:
        """Check if file exists (valid).

        Returns:
            true for Exists variant

        Example:
            FileValidation::Exists("/tmp/file.txt").is_exists()  # → true
        """
        match self:
            case Exists(_): true
            case _: false

    pub fn is_not_found(self) -> bool:
        """Check if file was not found.

        Returns:
            true for NotFound variant

        Example:
            FileValidation::NotFound("/missing.txt").is_not_found()  # → true
        """
        match self:
            case NotFound(_): true
            case _: false

    pub fn is_not_file(self) -> bool:
        """Check if path is not a file (e.g., directory).

        Returns:
            true for NotFile variant

        Example:
            FileValidation::NotFile("/tmp").is_not_file()  # → true
        """
        match self:
            case NotFile(_): true
            case _: false

    pub fn is_not_readable(self) -> bool:
        """Check if file is not readable.

        Returns:
            true for NotReadable variant

        Example:
            FileValidation::NotReadable("/noaccess").is_not_readable()  # → true
        """
        match self:
            case NotReadable(_): true
            case _: false

    pub fn is_not_writable(self) -> bool:
        """Check if file is not writable.

        Returns:
            true for NotWritable variant

        Example:
            FileValidation::NotWritable("/readonly.txt").is_not_writable()  # → true
        """
        match self:
            case NotWritable(_): true
            case _: false

    pub fn is_error(self) -> bool:
        """Check if validation failed.

        Returns:
            false for Exists, true for any error variant

        Example:
            FileValidation::Exists("/file").is_error()  # → false
            FileValidation::NotFound("/miss").is_error()  # → true
        """
        match self:
            case Exists(_): false
            case _: true

    pub fn is_valid(self) -> bool:
        """Check if validation passed.

        Returns:
            true for Exists

        Example:
            FileValidation::Exists("/file").is_valid()  # → true
        """
        match self:
            case Exists(_): true
            case _: false

    pub fn is_permission_error(self) -> bool:
        """Check if error is permission-related.

        Returns:
            true for NotReadable or NotWritable

        Example:
            FileValidation::NotReadable("/file").is_permission_error()  # → true
        """
        match self:
            case NotReadable(_): true
            case NotWritable(_): true
            case _: false

    pub fn get_path(self) -> String:
        """Get the file path.

        Returns:
            Path from any variant

        Example:
            FileValidation::Exists("/tmp/file.txt").get_path()  # → "/tmp/file.txt"
        """
        match self:
            case Exists(path): path
            case NotFound(path): path
            case NotFile(path): path
            case NotReadable(path): path
            case NotWritable(path): path

    pub fn to_string(self) -> String:
        """Convert validation result to string.

        Returns:
            Result type name

        Example:
            FileValidation::NotFound("/miss").to_string()  # → "not-found"
        """
        match self:
            case Exists(_): "exists"
            case NotFound(_): "not-found"
            case NotFile(_): "not-file"
            case NotReadable(_): "not-readable"
            case NotWritable(_): "not-writable"

    pub fn description(self) -> String:
        """Get validation result description.

        Returns:
            Human-readable description

        Example:
            FileValidation::NotReadable("/file").description()
            # → "File exists but is not readable"
        """
        match self:
            case Exists(_): "File exists and is valid"
            case NotFound(_): "File does not exist"
            case NotFile(_): "Path is not a regular file"
            case NotReadable(_): "File exists but is not readable"
            case NotWritable(_): "File exists but is not writable"

    pub fn summary(self) -> String:
        """Get file validation summary.

        Returns:
            Human-readable summary

        Example:
            FileValidation::NotFound("/missing.txt").summary()
            # → "FileValidation: not-found (File does not exist): /missing.txt [error]"
        """
        let name = self.to_string()
        let desc = self.description()
        let path = self.get_path()
        let status = if self.is_valid(): "valid" else: "error"
        return "FileValidation: {name} ({desc}): {path} [{status}]"

# File metadata
pub struct FileInfo:
    path: String
    absolute_path: String
    exists: bool
    is_file: bool
    is_dir: bool
    is_readable: bool
    is_writable: bool

# Staged files for processing
#
# **Supports two modes:**
# 1. Sync validation only (default) - validates paths, no file loading
# 2. Async loading (via ArgParser.with_async_loading) - starts loading files in background
#
# **Usage:**
#   # Sync mode (validation only)
#   let staged = stage_files(args)
#   for file in staged.staged():
#       # Use file module to load
#       async with await file.open(file.path) as mmap:
#           process(mmap)
#
#   # Async mode (background loading)
#   let staged = stage_files_async(args)  # Files start loading
#   # Wait for all files
#   let regions = await staged.wait_all()?
#   # Or process as ready
#   for handle in staged.ready_handles():
#       let mmap = handle.get()?
pub struct StagedFiles:
    files: Array[FileInfo]
    handles: Array[AsyncFileHandle]  # Async file handles (if async loading enabled)
    errors: Array[String]

    # Get all successfully staged files
    pub fn staged(self) -> Array[FileInfo]:
        let mut result = []
        for file in self.files:
            if file.exists and file.is_file:
                result.push(file)
        return result

    # Get async file handles (if async loading enabled)
    pub fn handles(self) -> Array[AsyncFileHandle]:
        return self.handles

    # Wait for all files to load (async)
    pub async fn wait_all(self) -> Result[Array[MmapRegion], Error]:
        let mut regions = []
        for handle in self.handles:
            let region = await handle.wait()?
            regions.push(region)
        return Ok(regions)

    # Get files that are already ready (non-blocking)
    pub fn ready_handles(self) -> Array[AsyncFileHandle]:
        let mut ready = []
        for handle in self.handles:
            if handle.is_ready():
                ready.push(handle)
        return ready

    # Get all errors
    pub fn get_errors(self) -> Array[String]:
        return self.errors

    # Check if any files have errors
    pub fn has_errors(self) -> bool:
        return self.errors.len() > 0

    # Get count of successfully staged files
    pub fn count(self) -> i32:
        return self.staged().len()

# File argument validator
pub struct FileValidator:
    must_exist: bool
    must_be_file: bool
    must_be_readable: bool
    must_be_writable: bool
    allowed_extensions: Array[String]

    # Create a new file validator
    pub fn new() -> FileValidator:
        return FileValidator {
            must_exist: false,
            must_be_file: true,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }

    # Require file to exist
    pub fn require_exists(mut self) -> FileValidator:
        self.must_exist = true
        return self

    # Require file to be readable
    pub fn require_readable(mut self) -> FileValidator:
        self.must_be_readable = true
        return self

    # Require file to be writable
    pub fn require_writable(mut self) -> FileValidator:
        self.must_be_writable = true
        return self

    # Allow only specific extensions
    pub fn with_extensions(mut self, extensions: Array[String]) -> FileValidator:
        self.allowed_extensions = extensions
        return self

    # Validate a file path
    pub fn validate(self, path: String) -> Result[FileInfo, String]:
        # Check if file exists (using file_exists FFI)
        let exists = file_exists(path)

        # Get file info
        let info = get_file_info(path)

        # Validate existence
        if self.must_exist and not exists:
            return Err("File does not exist: {path}")

        # Validate it's a file (not directory)
        if self.must_be_file and exists and info.is_dir:
            return Err("Path is a directory, not a file: {path}")

        # Validate readable
        if self.must_be_readable and exists and not info.is_readable:
            return Err("File is not readable: {path}")

        # Validate writable
        if self.must_be_writable and exists and not info.is_writable:
            return Err("File is not writable: {path}")

        # Validate extension
        if self.allowed_extensions.len() > 0:
            let ext = get_file_extension(path)
            let mut valid_ext = false
            for allowed in self.allowed_extensions:
                if ext == allowed:
                    valid_ext = true

            if not valid_ext:
                return Err("Invalid file extension: {ext} (allowed: {self.allowed_extensions})")

        return Ok(info)

# File staging manager
#
# **SYNC MODE:** Validates file paths synchronously during CLI parsing.
# Does NOT load file contents - use the `file` module for actual I/O.
pub struct FileStager:
    validators: Dict[String, FileValidator]

    # Create a new file stager
    pub fn new() -> FileStager:
        return FileStager {
            validators: {}
        }

    # Add a file validator for an argument
    pub fn add_validator(mut self, arg_name: String, validator: FileValidator) -> FileStager:
        self.validators.insert(arg_name, validator)
        return self

    # Stage files from parsed arguments (sync mode - no background loading)
    pub fn stage_files(self, args: ParsedArgs) -> StagedFiles:
        let mut files: Array[FileInfo] = []
        let mut errors: Array[String] = []

        # Validate options with validators
        for (name, validator) in self.validators:
            let value = args.get_option(name)
            match value:
                case Some(path):
                    match validator.validate(path):
                        case Ok(info):
                            files.push(info)
                        case Err(error):
                            errors.push("{name}: {error}")
                case None:
                    # Option not provided - skip if optional
                    pass

        # Validate positional files
        let positionals = args.get_all_positionals()
        for path in positionals:
            # Use default validator for positionals
            let default_validator = FileValidator::new().require_exists()
            match default_validator.validate(path):
                case Ok(info):
                    files.push(info)
                case Err(error):
                    errors.push("positional: {error}")

        return StagedFiles {
            files: files,
            handles: [],  # No async handles in sync mode
            errors: errors
        }

    # Stage files with async loading (background loading)
    pub fn stage_files_async(self, args: ParsedArgs, options: OpenOptions) -> StagedFiles:
        let mut files: Array[FileInfo] = []
        let mut handles: Array[AsyncFileHandle] = []
        let mut errors: Array[String] = []

        # Validate options with validators
        for (name, validator) in self.validators:
            let value = args.get_option(name)
            match value:
                case Some(path):
                    match validator.validate(path):
                        case Ok(info):
                            files.push(info)
                            # Start loading file in background
                            let handle = AsyncFileHandle::with_options(info.path, options)
                            handle.start_loading()
                            handles.push(handle)
                        case Err(error):
                            errors.push("{name}: {error}")
                case None:
                    # Option not provided - skip if optional
                    pass

        # Validate positional files
        let positionals = args.get_all_positionals()
        for path in positionals:
            # Use default validator for positionals
            let default_validator = FileValidator::new().require_exists()
            match default_validator.validate(path):
                case Ok(info):
                    files.push(info)
                    # Start loading file in background
                    let handle = AsyncFileHandle::with_options(info.path, options)
                    handle.start_loading()
                    handles.push(handle)
                case Err(error):
                    errors.push("positional: {error}")

        return StagedFiles {
            files: files,
            handles: handles,
            errors: errors
        }

# File utility functions

# Check if a file exists
fn file_exists(path: String) -> bool:
    return rt_file_exists(path)

# Get file information using FFI
fn get_file_info(path: String) -> FileInfo:
    let exists = rt_file_exists(path)
    let absolute_path = normalize_path(path)

    # For now, use simple heuristics for file/dir detection
    # A more complete implementation would use rt_file_stat FFI
    let is_file = exists and not path.ends_with("/")
    let is_dir = exists and path.ends_with("/")

    return FileInfo {
        path: path,
        absolute_path: absolute_path,
        exists: exists,
        is_file: is_file,
        is_dir: is_dir,
        is_readable: exists,  # Assume readable if exists
        is_writable: exists   # Assume writable if exists
    }

# Normalize file path (handle relative/absolute)
pub fn normalize_path(path: String) -> String:
    return rt_file_canonicalize(path)

# Get file extension
pub fn get_file_extension(path: String) -> String:
    let parts = path.split(".")
    if parts.len() > 1:
        return parts[parts.len() - 1]
    return ""

# Check if path is absolute
pub fn is_absolute_path(path: String) -> bool:
    return path.starts_with("/") or path.starts_with("C:") or path.starts_with("D:")

# Check if path is relative
pub fn is_relative_path(path: String) -> bool:
    return not is_absolute_path(path)

# Join path components
pub fn join_paths(base: String, relative: String) -> String:
    if base.ends_with("/"):
        return "{base}{relative}"
    else:
        return "{base}/{relative}"

# Get directory from path
pub fn get_directory(path: String) -> String:
    let parts = path.split("/")
    if parts.len() > 1:
        # Remove last component
        let mut dir = ""
        let mut i = 0
        while i < parts.len() - 1:
            if i > 0:
                dir = "{dir}/"
            dir = "{dir}{parts[i]}"
            i = i + 1
        return dir
    return "."

# Get filename from path
pub fn get_filename(path: String) -> String:
    let parts = path.split("/")
    if parts.len() > 0:
        return parts[parts.len() - 1]
    return path

# Get filename without extension
pub fn get_basename(path: String) -> String:
    let filename = get_filename(path)
    let parts = filename.split(".")
    if parts.len() > 1:
        # Return everything except last part (extension)
        let mut base = ""
        let mut i = 0
        while i < parts.len() - 1:
            if i > 0:
                base = "{base}."
            base = "{base}{parts[i]}"
            i = i + 1
        return base
    return filename

# Validate multiple files at once
pub fn validate_files(paths: Array[String], validator: FileValidator) -> Result[Array[FileInfo], Array[String]]:
    let mut files: Array[FileInfo] = []
    let mut errors: Array[String] = []

    for path in paths:
        match validator.validate(path):
            case Ok(info):
                files.push(info)
            case Err(error):
                errors.push(error)

    if errors.len() > 0:
        return Err(errors)

    return Ok(files)

# Create file validator for common cases

# Validator for input files (must exist, readable)
pub fn input_file_validator() -> FileValidator:
    return FileValidator::new()
        .require_exists()
        .require_readable()

# Validator for output files (can be created, writable)
pub fn output_file_validator() -> FileValidator:
    return FileValidator::new()
        .require_writable()

# Validator for config files (must exist, readable, specific extensions)
pub fn config_file_validator() -> FileValidator:
    return FileValidator::new()
        .require_exists()
        .require_readable()
        .with_extensions(["json", "toml", "yaml", "yml", "conf"])

# Validator for source code files
pub fn source_file_validator() -> FileValidator:
    return FileValidator::new()
        .require_exists()
        .require_readable()
        .with_extensions(["spl", "rs", "py", "js", "ts"])
