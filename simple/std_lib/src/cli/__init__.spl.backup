# CLI - Command-Line Argument Parsing Library
# Provides a declarative API for parsing command-line arguments with flags, options, and subcommands
#
# Submodules:
#   - cli.file - File validation and staging utilities (Python argparse-style)
#
# Example:
#   let parser = ArgParser::new("myapp", "My application description")
#       .flag("verbose", "v", "Enable verbose output")
#       .option("output", "o", "Output file path", required: true)
#       .option("count", "c", "Number of items", default: "10")
#       .positional("input", "Input file path", required: true)
#
#   match parser.parse(sys_get_args()):
#       case Ok(args):
#           if args.get_flag("verbose"):
#               print("Verbose mode enabled")
#           let output = args.get_option("output")
#           let count = args.get_option_int("count").unwrap_or(10)
#           let input = args.get_positional("input")
#       case Err(error):
#           print(f"Error: {error}")
#           parser.print_help()

# Argument value types
pub enum ArgValue:
    String(value: String)
    Int(value: i32)
    Float(value: f64)
    Bool(value: bool)
    Multiple(values: Array[String])

# Parsed arguments result
pub struct ParsedArgs:
    flags: Dict[String, bool]
    options: Dict[String, String]
    positionals: Array[String]

    # Check if a flag is present
    pub fn has_flag(self, name: String) -> bool:
        let result = false
        if self.flags.contains_key(name):
            result = self.flags.get(name).unwrap_or(false)
        return result

    # Get a flag value (alias for has_flag)
    pub fn get_flag(self, name: String) -> bool:
        return self.has_flag(name)

    # Get an option value as string
    pub fn get_option(self, name: String) -> Option[String]:
        if self.options.contains_key(name):
            return Some(self.options.get(name).unwrap())
        return None

    # Get an option value with default
    pub fn get_option_or(self, name: String, default: String) -> String:
        let result = ""
        if self.options.contains_key(name):
            result = self.options.get(name).unwrap()
        else:
            result = default
        return result

    # Get an option value as integer
    pub fn get_option_int(self, name: String) -> Option[i32]:
        if self.options.contains_key(name):
            let value = self.options.get(name).unwrap()
            # TODO: Implement actual int parsing
            # For now, return None - needs String::parse_int()
            return None
        return None

    # Get an option value as float
    pub fn get_option_float(self, name: String) -> Option[f64]:
        if self.options.contains_key(name):
            let value = self.options.get(name).unwrap()
            # TODO: Implement actual float parsing
            return None
        return None

    # Get a positional argument by index
    pub fn get_positional_at(self, index: i32) -> Option[String]:
        if index >= 0 and index < self.positionals.len():
            return Some(self.positionals[index])
        return None

    # Get a positional argument by name (must match order)
    pub fn get_positional(self, name: String) -> Option[String]:
        # This requires tracking positional names separately
        # For now, just return the first positional
        if self.positionals.len() > 0:
            return Some(self.positionals[0])
        return None

    # Get all positionals
    pub fn get_all_positionals(self) -> Array[String]:
        return self.positionals

# Argument specification
struct ArgSpec:
    name: String
    short: Option[String]
    long: String
    help: String
    required: bool
    default_value: Option[String]
    arg_type: ArgType

# Argument type
enum ArgType:
    Flag          # Boolean flag (--verbose, -v)
    Option        # String option (--output <file>, -o <file>)
    Positional    # Positional argument

# Main argument parser
pub struct ArgParser:
    program_name: String
    description: String
    args: Array[ArgSpec]

    # Create a new argument parser
    pub fn new(program_name: String, description: String) -> ArgParser:
        return ArgParser {
            program_name: program_name,
            description: description,
            args: []
        }

    # Add a boolean flag
    pub fn flag(mut self, name: String, short: String, help: String) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: false,
            default_value: None,
            arg_type: ArgType::Flag
        }
        self.args.push(spec)
        return self

    # Add a string option
    pub fn option(mut self, name: String, short: String, help: String, required: bool, default: Option[String]) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: required,
            default_value: default,
            arg_type: ArgType::Option
        }
        self.args.push(spec)
        return self

    # Add a required option (convenience method)
    pub fn required_option(mut self, name: String, short: String, help: String) -> ArgParser:
        return self.option(name, short, help, true, None)

    # Add an optional option with default (convenience method)
    pub fn optional_option(mut self, name: String, short: String, help: String, default: String) -> ArgParser:
        return self.option(name, short, help, false, Some(default))

    # Add a positional argument
    pub fn positional(mut self, name: String, help: String, required: bool) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: None,
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::Positional
        }
        self.args.push(spec)
        return self

    # Add a required positional argument (convenience method)
    pub fn required_positional(mut self, name: String, help: String) -> ArgParser:
        return self.positional(name, help, true)

    # Parse command-line arguments
    pub fn parse(self, args: Array[String]) -> Result[ParsedArgs, String]:
        let mut flags: Dict[String, bool] = {}
        let mut options: Dict[String, String] = {}
        let mut positionals: Array[String] = []

        let mut i = 0
        while i < args.len():
            let arg = args[i]

            # Check for help flag
            if arg == "--help" or arg == "-h":
                self.print_help()
                # Return empty result for help
                return Ok(ParsedArgs { flags: flags, options: options, positionals: positionals })

            # Check if it's a flag or option (starts with -)
            if arg.starts_with("--"):
                # Long form: --flag or --option=value or --option value
                let processed = false

                # Check for --option=value format
                if arg.contains("="):
                    let parts = arg.split("=")
                    if parts.len() == 2:
                        let name = parts[0].trim_start_matches("--")
                        let value = parts[1]

                        # Find matching option spec
                        let mut found = false
                        for spec in self.args:
                            if spec.long == name:
                                match spec.arg_type:
                                    case ArgType::Flag:
                                        return Err(f"Flag --{name} does not take a value")
                                    case ArgType::Option:
                                        options.insert(name, value)
                                        found = true
                                    case ArgType::Positional:
                                        # Skip
                                        pass

                        if not found:
                            return Err(f"Unknown option: --{name}")

                        processed = true

                if not processed:
                    # --flag or --option value format
                    let name = arg.trim_start_matches("--")

                    # Find matching spec
                    let mut found = false
                    for spec in self.args:
                        if spec.long == name:
                            match spec.arg_type:
                                case ArgType::Flag:
                                    flags.insert(name, true)
                                    found = true
                                case ArgType::Option:
                                    # Next arg should be the value
                                    if i + 1 < args.len():
                                        i = i + 1
                                        let value = args[i]
                                        options.insert(name, value)
                                        found = true
                                    else:
                                        return Err(f"Option --{name} requires a value")
                                case ArgType::Positional:
                                    # Skip
                                    pass

                    if not found:
                        return Err(f"Unknown option: --{name}")

            else:
                if arg.starts_with("-") and arg.len() > 1:
                    # Short form: -f or -o value
                    let short = arg[1..2]

                    # Find matching spec
                    let mut found = false
                    for spec in self.args:
                        if spec.short.is_some() and spec.short.unwrap() == short:
                            match spec.arg_type:
                                case ArgType::Flag:
                                    flags.insert(spec.name, true)
                                    found = true
                                case ArgType::Option:
                                    # Next arg should be the value
                                    if i + 1 < args.len():
                                        i = i + 1
                                        let value = args[i]
                                        options.insert(spec.name, value)
                                        found = true
                                    else:
                                        return Err(f"Option -{short} requires a value")
                                case ArgType::Positional:
                                    # Skip
                                    pass

                    if not found:
                        return Err(f"Unknown option: -{short}")
                else:
                    # Positional argument
                    positionals.push(arg)

            i = i + 1

        # Set default values for options
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Option:
                    if not options.contains_key(spec.name):
                        if spec.default_value.is_some():
                            options.insert(spec.name, spec.default_value.unwrap())
                        else:
                            if spec.required:
                                return Err(f"Required option --{spec.name} not provided")
                case _:
                    pass

        # Check required positionals
        let mut required_positional_count = 0
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Positional:
                    if spec.required:
                        required_positional_count = required_positional_count + 1
                case _:
                    pass

        if positionals.len() < required_positional_count:
            return Err(f"Expected at least {required_positional_count} positional arguments, got {positionals.len()}")

        return Ok(ParsedArgs {
            flags: flags,
            options: options,
            positionals: positionals
        })

    # Print help message
    pub fn print_help(self):
        print(f"{self.program_name} - {self.description}")
        print("")
        print("USAGE:")

        # Build usage line
        let mut usage = f"    {self.program_name}"

        # Add flags and options
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Flag:
                    if spec.short.is_some():
                        usage = f"{usage} [-{spec.short.unwrap()}|--{spec.long}]"
                    else:
                        usage = f"{usage} [--{spec.long}]"
                case ArgType::Option:
                    let opt_str = ""
                    if spec.short.is_some():
                        opt_str = f"-{spec.short.unwrap()}|--{spec.long} <{spec.name}>"
                    else:
                        opt_str = f"--{spec.long} <{spec.name}>"

                    if spec.required:
                        usage = f"{usage} {opt_str}"
                    else:
                        usage = f"{usage} [{opt_str}]"
                case ArgType::Positional:
                    if spec.required:
                        usage = f"{usage} <{spec.name}>"
                    else:
                        usage = f"{usage} [<{spec.name}>]"

        print(usage)
        print("")
        print("OPTIONS:")

        # Print flags
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Flag:
                    if spec.short.is_some():
                        print(f"    -{spec.short.unwrap()}, --{spec.long:<20} {spec.help}")
                    else:
                        print(f"        --{spec.long:<20} {spec.help}")
                case _:
                    pass

        # Print options
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Option:
                    let opt_name = f"--{spec.long} <{spec.name}>"
                    if spec.short.is_some():
                        print(f"    -{spec.short.unwrap()}, {opt_name:<20} {spec.help}")
                    else:
                        print(f"        {opt_name:<20} {spec.help}")

                    if spec.default_value.is_some():
                        print(f"        {'':24} [default: {spec.default_value.unwrap()}]")

                    if spec.required:
                        print(f"        {'':24} [required]")
                case _:
                    pass

        # Print positionals
        if self.has_positionals():
            print("")
            print("ARGS:")
            for spec in self.args:
                match spec.arg_type:
                    case ArgType::Positional:
                        print(f"    <{spec.name}>    {spec.help}")
                        if spec.required:
                            print(f"        {'':12} [required]")
                    case _:
                        pass

        print("")
        print("    -h, --help               Print this help message")

    # Check if parser has positional arguments
    fn has_positionals(self) -> bool:
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Positional:
                    return true
                case _:
                    pass
        return false

# Helper function to create a simple parser
pub fn simple_parser(program_name: String, description: String) -> ArgParser:
    return ArgParser::new(program_name, description)

# Helper to parse args with automatic help handling
pub fn parse_args(parser: ArgParser, args: Array[String]) -> Result[ParsedArgs, String]:
    return parser.parse(args)
