# CLI - Command-Line Argument Parsing Library (Python argparse-style)
#
# Python argparse-like API with automatic file staging and async loading:
# - Define file arguments with .file() or .file_option()
# - Files are automatically validated and staged during parse()
# - Optionally enable async loading for background file loading
# - File errors are reported clearly
# - Can disable auto-staging per argument
#
# Example (sync mode):
#   let parser = ArgParser::new("myapp", "Process files")
#       .flag("verbose", "v", "Verbose output")
#       .file_option("input", "i", "Input file", required: true, must_exist: true)
#       .file_option("output", "o", "Output file", required: true, must_exist: false)
#       .file_positional("files", "Files to process", required: false)
#
#   match parser.parse(sys_get_args()):
#       case Ok(args):
#           # Files are already validated and staged!
#           for file in args.files.staged():
#               async with await file.open(file.path) as mmap:
#                   process_file(mmap)
#
# Example (async mode - background loading):
#   let parser = ArgParser::new("myapp", "Process files")
#       .file_option("input", "i", "Input file", required: true, must_exist: true)
#       .with_async_loading(true)  # Enable background loading
#
#   match parser.parse(sys_get_args()):
#       case Ok(args):
#           # Files already loading in background!
#           let regions = await args.files.wait_all()?
#           for region in regions:
#               process_file(region.as_bytes())

# Import file I/O types for async loading support
use file.mmap::{OpenOptions}
#       case Err(error):
#           print(f"Error: {error}")

import cli.file as file

# Argument types
enum ArgType:
    Flag          # Boolean flag
    Option        # String option
    Positional    # Positional string
    FileOption    # File option (auto-staged)
    FilePositional # File positional (auto-staged)

# Argument specification
struct ArgSpec:
    name: String
    short: Option[String]
    long: String
    help: String
    required: bool
    default_value: Option[String]
    arg_type: ArgType
    # File-specific options
    auto_stage: bool
    must_exist: bool
    must_be_readable: bool
    must_be_writable: bool
    allowed_extensions: Array[String]

# Parsed arguments result with staged files
pub struct ParsedArgs:
    flags: Dict[String, bool]
    options: Dict[String, String]
    positionals: Array[String]
    files: file.StagedFiles  # Automatically staged files

    # Check if a flag is present
    pub fn has_flag(self, name: String) -> bool:
        let result = false
        if self.flags.contains_key(name):
            result = self.flags.get(name).unwrap_or(false)
        return result

    # Get a flag value
    pub fn get_flag(self, name: String) -> bool:
        return self.has_flag(name)

    # Get an option value as string
    pub fn get_option(self, name: String) -> Option[String]:
        if self.options.contains_key(name):
            return Some(self.options.get(name).unwrap())
        return None

    # Get an option value with default
    pub fn get_option_or(self, name: String, default: String) -> String:
        let result = ""
        if self.options.contains_key(name):
            result = self.options.get(name).unwrap()
        else:
            result = default
        return result

    # Get a positional argument by index
    pub fn get_positional_at(self, index: i32) -> Option[String]:
        if index >= 0 and index < self.positionals.len():
            return Some(self.positionals[index])
        return None

    # Get all positionals
    pub fn get_all_positionals(self) -> Array[String]:
        return self.positionals

    # Get all successfully staged files
    pub fn get_staged_files(self) -> Array[file.FileInfo]:
        return self.files.staged()

    # Get file by option name
    pub fn get_file(self, name: String) -> Option[file.FileInfo]:
        # Find file matching this option name
        for f in self.files.staged():
            # TODO: Track which arg each file came from
            # For now, return first file
            return Some(f)
        return None

# Main argument parser
pub struct ArgParser:
    program_name: String
    description: String
    args: Array[ArgSpec]
    auto_stage_files: bool  # Global auto-staging toggle
    async_loading: bool     # Enable background file loading during parse
    mmap_options: OpenOptions  # Options for memory-mapped file I/O

    # Create a new argument parser
    pub fn new(program_name: String, description: String) -> ArgParser:
        return ArgParser {
            program_name: program_name,
            description: description,
            args: [],
            auto_stage_files: true,  # Default: auto-stage enabled
            async_loading: false,    # Default: sync validation only
            mmap_options: OpenOptions::new()  # Default options
        }

    # Disable automatic file staging globally
    pub fn no_auto_stage(mut self) -> ArgParser:
        self.auto_stage_files = false
        return self

    # Enable async file loading (starts loading during argument parsing)
    #
    # When enabled, files specified via file_option() or file_positional()
    # will start loading in background as soon as arguments are parsed.
    # This provides better performance for processing multiple large files.
    #
    # Example:
    #   let parser = ArgParser::new("processor", "File processor")
    #       .file_option("input", "i", "Input file", required: true, must_exist: true)
    #       .with_async_loading(true)
    #
    #   match parser.parse(args):
    #       case Ok(args):
    #           # Files already loading in background!
    #           let regions = await args.files.wait_all()?
    pub fn with_async_loading(mut self, enable: bool) -> ArgParser:
        self.async_loading = enable
        return self

    # Configure memory-mapped I/O options
    #
    # Allows customization of mmap behavior (mode, prefaulting, advice).
    # Only applies when async_loading is enabled.
    #
    # Example:
    #   let opts = OpenOptions::new()
    #       .mode(MmapMode::ReadOnly)
    #       .advice(MmapAdvice::Sequential)
    #
    #   let parser = ArgParser::new("processor", "File processor")
    #       .file_option("input", "i", "Input file", required: true, must_exist: true)
    #       .with_async_loading(true)
    #       .with_mmap_options(opts)
    pub fn with_mmap_options(mut self, opts: OpenOptions) -> ArgParser:
        self.mmap_options = opts
        return self

    # Add a boolean flag
    pub fn flag(mut self, name: String, short: String, help: String) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: false,
            default_value: None,
            arg_type: ArgType::Flag,
            auto_stage: false,
            must_exist: false,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a string option
    pub fn option(mut self, name: String, short: String, help: String, required: bool, default: Option[String]) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: required,
            default_value: default,
            arg_type: ArgType::Option,
            auto_stage: false,
            must_exist: false,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a required option
    pub fn required_option(mut self, name: String, short: String, help: String) -> ArgParser:
        return self.option(name, short, help, true, None)

    # Add an optional option with default
    pub fn optional_option(mut self, name: String, short: String, help: String, default: String) -> ArgParser:
        return self.option(name, short, help, false, Some(default))

    # Add a FILE option (automatically staged)
    pub fn file_option(mut self, name: String, short: String, help: String, required: bool, must_exist: bool) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::FileOption,
            auto_stage: true,  # Files are auto-staged by default
            must_exist: must_exist,
            must_be_readable: must_exist,  # If must exist, must be readable
            must_be_writable: not must_exist,  # If output, must be writable
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a file option with custom validation
    pub fn file_option_custom(mut self, name: String, short: String, help: String, required: bool,
                               must_exist: bool, must_be_readable: bool, must_be_writable: bool,
                               extensions: Array[String]) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::FileOption,
            auto_stage: true,
            must_exist: must_exist,
            must_be_readable: must_be_readable,
            must_be_writable: must_be_writable,
            allowed_extensions: extensions
        }
        self.args.push(spec)
        return self

    # Add a file positional (automatically staged)
    pub fn file_positional(mut self, name: String, help: String, required: bool) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: None,
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::FilePositional,
            auto_stage: true,
            must_exist: true,  # Positional files usually must exist
            must_be_readable: true,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a positional argument (non-file)
    pub fn positional(mut self, name: String, help: String, required: bool) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: None,
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::Positional,
            auto_stage: false,
            must_exist: false,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a required positional
    pub fn required_positional(mut self, name: String, help: String) -> ArgParser:
        return self.positional(name, help, true)

    # Parse command-line arguments with automatic file staging
    pub fn parse(self, args: Array[String]) -> Result[ParsedArgs, String]:
        let mut flags: Dict[String, bool] = {}
        let mut options: Dict[String, String] = {}
        let mut positionals: Array[String] = []
        let mut file_paths: Array[String] = []  # Collect file paths for staging

        # Parse arguments (same as before, but collect file args)
        let mut i = 0
        while i < args.len():
            let arg = args[i]

            # Check for help flag
            if arg == "--help" or arg == "-h":
                self.print_help()
                # Return empty result
                return Ok(ParsedArgs {
                    flags: flags,
                    options: options,
                    positionals: positionals,
                    files: file.StagedFiles { files: [], handles: [], errors: [] }
                })

            # Parse long-form options
            if arg.starts_with("--"):
                # Handle --option=value or --option value
                let processed = false

                if arg.contains("="):
                    let parts = arg.split("=")
                    if parts.len() == 2:
                        let name = parts[0].trim_start_matches("--")
                        let value = parts[1]

                        # Find spec and handle based on type
                        let mut found = false
                        for spec in self.args:
                            if spec.long == name:
                                match spec.arg_type:
                                    case ArgType::Flag:
                                        return Err(f"Flag --{name} does not take a value")
                                    case ArgType::Option:
                                        options.insert(name, value)
                                        found = true
                                    case ArgType::FileOption:
                                        options.insert(name, value)
                                        if spec.auto_stage and self.auto_stage_files:
                                            file_paths.push(value)
                                        found = true
                                    case _:
                                        pass

                        if not found:
                            return Err(f"Unknown option: --{name}")
                        processed = true

                if not processed:
                    let name = arg.trim_start_matches("--")
                    let mut found = false

                    for spec in self.args:
                        if spec.long == name:
                            match spec.arg_type:
                                case ArgType::Flag:
                                    flags.insert(name, true)
                                    found = true
                                case ArgType::Option:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        options.insert(name, args[i])
                                        found = true
                                    else:
                                        return Err(f"Option --{name} requires a value")
                                case ArgType::FileOption:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        let value = args[i]
                                        options.insert(name, value)
                                        if spec.auto_stage and self.auto_stage_files:
                                            file_paths.push(value)
                                        found = true
                                    else:
                                        return Err(f"Option --{name} requires a value")
                                case _:
                                    pass

                    if not found:
                        return Err(f"Unknown option: --{name}")

            else:
                if arg.starts_with("-") and arg.len() > 1:
                    # Short form
                    let short = arg[1..2]
                    let mut found = false

                    for spec in self.args:
                        if spec.short.is_some() and spec.short.unwrap() == short:
                            match spec.arg_type:
                                case ArgType::Flag:
                                    flags.insert(spec.name, true)
                                    found = true
                                case ArgType::Option:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        options.insert(spec.name, args[i])
                                        found = true
                                    else:
                                        return Err(f"Option -{short} requires a value")
                                case ArgType::FileOption:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        let value = args[i]
                                        options.insert(spec.name, value)
                                        if spec.auto_stage and self.auto_stage_files:
                                            file_paths.push(value)
                                        found = true
                                    else:
                                        return Err(f"Option -{short} requires a value")
                                case _:
                                    pass

                    if not found:
                        return Err(f"Unknown option: -{short}")
                else:
                    # Positional argument
                    positionals.push(arg)

                    # Check if this is a file positional
                    if self.auto_stage_files:
                        file_paths.push(arg)

            i = i + 1

        # Apply defaults
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Option:
                    if not options.contains_key(spec.name):
                        if spec.default_value.is_some():
                            options.insert(spec.name, spec.default_value.unwrap())
                        else:
                            if spec.required:
                                return Err(f"Required option --{spec.name} not provided")
                case _:
                    pass

        # Check required positionals
        let mut required_positional_count = 0
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Positional:
                    if spec.required:
                        required_positional_count = required_positional_count + 1
                case ArgType::FilePositional:
                    if spec.required:
                        required_positional_count = required_positional_count + 1
                case _:
                    pass

        if positionals.len() < required_positional_count:
            return Err(f"Expected at least {required_positional_count} positional arguments, got {positionals.len()}")

        # AUTOMATIC FILE STAGING - Python argparse style!
        let staged_files = self.stage_files(file_paths)

        # Check for file staging errors
        if staged_files.has_errors():
            let error_msg = "File validation errors:"
            for err in staged_files.get_errors():
                error_msg = f"{error_msg}\n  - {err}"
            return Err(error_msg)

        return Ok(ParsedArgs {
            flags: flags,
            options: options,
            positionals: positionals,
            files: staged_files
        })

    # Stage files with validation (called automatically during parse)
    #
    # Supports two modes:
    # 1. Sync mode (default): Validates paths only, no file loading
    # 2. Async mode (if async_loading enabled): Starts loading files in background
    fn stage_files(self, paths: Array[String]) -> file.StagedFiles:
        let mut all_files: Array[file.FileInfo] = []
        let mut all_handles: Array[file.AsyncFileHandle] = []
        let mut all_errors: Array[String] = []

        for path in paths:
            # Find the arg spec for this path to get validation rules
            let validator = self.get_validator_for_path(path)

            match validator.validate(path):
                case Ok(info):
                    all_files.push(info)

                    # If async loading enabled, start loading file in background
                    if self.async_loading:
                        let handle = file.AsyncFileHandle::with_options(
                            info.path,
                            self.mmap_options
                        )
                        handle.start_loading()
                        all_handles.push(handle)

                case Err(error):
                    all_errors.push(error)

        return file.StagedFiles {
            files: all_files,
            handles: all_handles,  # Empty if sync mode, populated if async mode
            errors: all_errors
        }

    # Get validator for a file path based on arg specs
    fn get_validator_for_path(self, path: String) -> file.FileValidator:
        # Find matching file arg spec
        for spec in self.args:
            match spec.arg_type:
                case ArgType::FileOption:
                    # Build validator from spec
                    let mut validator = file.FileValidator::new()

                    if spec.must_exist:
                        validator = validator.require_exists()
                    if spec.must_be_readable:
                        validator = validator.require_readable()
                    if spec.must_be_writable:
                        validator = validator.require_writable()
                    if spec.allowed_extensions.len() > 0:
                        validator = validator.with_extensions(spec.allowed_extensions)

                    return validator

                case ArgType::FilePositional:
                    let mut validator = file.FileValidator::new()

                    if spec.must_exist:
                        validator = validator.require_exists()
                    if spec.must_be_readable:
                        validator = validator.require_readable()

                    return validator

                case _:
                    pass

        # Default validator for unmatched files
        return file.FileValidator::new().require_exists()

    # Print help message
    pub fn print_help(self):
        print(f"{self.program_name} - {self.description}")
        print("")
        print("USAGE:")

        let mut usage = f"    {self.program_name}"

        for spec in self.args:
            match spec.arg_type:
                case ArgType::Flag:
                    if spec.short.is_some():
                        usage = f"{usage} [-{spec.short.unwrap()}|--{spec.long}]"
                    else:
                        usage = f"{usage} [--{spec.long}]"

                case ArgType::Option:
                    let opt_str = ""
                    if spec.short.is_some():
                        opt_str = f"-{spec.short.unwrap()}|--{spec.long} <{spec.name}>"
                    else:
                        opt_str = f"--{spec.long} <{spec.name}>"

                    if spec.required:
                        usage = f"{usage} {opt_str}"
                    else:
                        usage = f"{usage} [{opt_str}]"

                case ArgType::FileOption:
                    let opt_str = ""
                    if spec.short.is_some():
                        opt_str = f"-{spec.short.unwrap()}|--{spec.long} <file>"
                    else:
                        opt_str = f"--{spec.long} <file>"

                    if spec.required:
                        usage = f"{usage} {opt_str}"
                    else:
                        usage = f"{usage} [{opt_str}]"

                case ArgType::Positional:
                    if spec.required:
                        usage = f"{usage} <{spec.name}>"
                    else:
                        usage = f"{usage} [<{spec.name}>]"

                case ArgType::FilePositional:
                    if spec.required:
                        usage = f"{usage} <file>"
                    else:
                        usage = f"{usage} [<file>...]"

        print(usage)
        print("")
        print("OPTIONS:")

        # Print flags
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Flag:
                    if spec.short.is_some():
                        print(f"    -{spec.short.unwrap()}, --{spec.long:<20} {spec.help}")
                    else:
                        print(f"        --{spec.long:<20} {spec.help}")
                case _:
                    pass

        # Print options (including file options)
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Option:
                    let opt_name = f"--{spec.long} <{spec.name}>"
                    if spec.short.is_some():
                        print(f"    -{spec.short.unwrap()}, {opt_name:<20} {spec.help}")
                    else:
                        print(f"        {opt_name:<20} {spec.help}")

                    if spec.default_value.is_some():
                        print(f"        {'':24} [default: {spec.default_value.unwrap()}]")
                    if spec.required:
                        print(f"        {'':24} [required]")

                case ArgType::FileOption:
                    let opt_name = f"--{spec.long} <file>"
                    if spec.short.is_some():
                        print(f"    -{spec.short.unwrap()}, {opt_name:<20} {spec.help}")
                    else:
                        print(f"        {opt_name:<20} {spec.help}")

                    if spec.must_exist:
                        print(f"        {'':24} [must exist]")
                    if spec.required:
                        print(f"        {'':24} [required]")

                case _:
                    pass

        # Print positionals
        if self.has_positionals():
            print("")
            print("ARGS:")
            for spec in self.args:
                match spec.arg_type:
                    case ArgType::Positional:
                        print(f"    <{spec.name}>    {spec.help}")
                        if spec.required:
                            print(f"        {'':12} [required]")

                    case ArgType::FilePositional:
                        print(f"    <file>...    {spec.help}")
                        if spec.must_exist:
                            print(f"        {'':12} [files must exist]")

                    case _:
                        pass

        print("")
        print("    -h, --help               Print this help message")

    fn has_positionals(self) -> bool:
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Positional:
                    return true
                case ArgType::FilePositional:
                    return true
                case _:
                    pass
        return false

# Helper function
pub fn simple_parser(program_name: String, description: String) -> ArgParser:
    return ArgParser::new(program_name, description)
