# Common Input Abstraction
#
# Engine-agnostic input handling interface
# Works with both Godot Input and Unreal Enhanced Input
#
# Features:
# - Keyboard input
# - Mouse input
# - Gamepad input
# - Touch input
# - Input mapping and actions

import sys.ffi

mod input

# KeyCode
# Common keyboard key codes
pub enum KeyCode:
    Unknown = 0
    Space = 32
    A = 65
    B = 66
    C = 67
    D = 68
    E = 69
    F = 70
    W = 87
    S = 83
    Escape = 256
    Enter = 257
    Tab = 258
    Left = 263
    Right = 262
    Up = 265
    Down = 264
    Shift = 340
    Ctrl = 341
    Alt = 342

impl KeyCode:
    pub fn to_int(self) -> i32:
        if self == KeyCode::Space:
            return 32
        elif self == KeyCode::A:
            return 65
        # ... (other mappings)
        else:
            return 0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert key code to string.

        Returns:
            Key name

        Example:
            KeyCode::Space.to_string()  # → "space"
        """
        match self:
            case Unknown: "unknown"
            case Space: "space"
            case A: "a"
            case B: "b"
            case C: "c"
            case D: "d"
            case E: "e"
            case F: "f"
            case W: "w"
            case S: "s"
            case Escape: "escape"
            case Enter: "enter"
            case Tab: "tab"
            case Left: "left"
            case Right: "right"
            case Up: "up"
            case Down: "down"
            case Shift: "shift"
            case Ctrl: "ctrl"
            case Alt: "alt"

    pub fn is_letter(self) -> bool:
        """Check if key is a letter.

        Returns:
            true for A-Z keys

        Example:
            KeyCode::A.is_letter()  # → true
        """
        match self:
            case A | B | C | D | E | F | W | S: true
            case _: false

    pub fn is_arrow(self) -> bool:
        """Check if key is an arrow key.

        Returns:
            true for arrow keys

        Example:
            KeyCode::Left.is_arrow()  # → true
        """
        match self:
            case Left | Right | Up | Down: true
            case _: false

    pub fn is_modifier(self) -> bool:
        """Check if key is a modifier key.

        Returns:
            true for Shift, Ctrl, Alt

        Example:
            KeyCode::Ctrl.is_modifier()  # → true
        """
        match self:
            case Shift | Ctrl | Alt: true
            case _: false

    pub fn summary(self) -> String:
        """Get key code summary.

        Returns:
            Human-readable summary

        Example:
            KeyCode::Left.summary()
            # → "KeyCode: left (arrow key, code=263)"
        """
        let name = self.to_string()
        let code = self.to_int()
        let mut props = []

        if self.is_letter():
            props.push("letter")
        if self.is_arrow():
            props.push("arrow key")
        if self.is_modifier():
            props.push("modifier")

        if props.is_empty():
            return "KeyCode: {name} (code={code})"
        else:
            let props_str = props.join(", ")
            return "KeyCode: {name} ({props_str}, code={code})"


# MouseButton
# Mouse button identifiers
pub enum MouseButton:
    Left = 0
    Right = 1
    Middle = 2
    Button4 = 3
    Button5 = 4

impl MouseButton:
    pub fn to_int(self) -> i32:
        if self == MouseButton::Left:
            return 0
        elif self == MouseButton::Right:
            return 1
        elif self == MouseButton::Middle:
            return 2
        elif self == MouseButton::Button4:
            return 3
        else:
            return 4

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert mouse button to string.

        Returns:
            Button name

        Example:
            MouseButton::Left.to_string()  # → "left"
        """
        match self:
            case Left: "left"
            case Right: "right"
            case Middle: "middle"
            case Button4: "button4"
            case Button5: "button5"

    pub fn is_primary(self) -> bool:
        """Check if this is a primary button (left/right).

        Returns:
            true for Left or Right

        Example:
            MouseButton::Left.is_primary()  # → true
        """
        match self:
            case Left | Right: true
            case _: false

    pub fn is_left(self) -> bool:
        """Check if this is left button."""
        match self:
            case Left: true
            case _: false

    pub fn is_right(self) -> bool:
        """Check if this is right button."""
        match self:
            case Right: true
            case _: false

    pub fn is_middle(self) -> bool:
        """Check if this is middle button."""
        match self:
            case Middle: true
            case _: false

    pub fn summary(self) -> String:
        """Get mouse button summary.

        Returns:
            Human-readable summary

        Example:
            MouseButton::Left.summary()
            # → "MouseButton: left (primary, button=0)"
        """
        let name = self.to_string()
        let code = self.to_int()
        let primary = if self.is_primary(): "primary" else: "extra"
        return "MouseButton: {name} ({primary}, button={code})"


# GamepadAxis
# Gamepad axis identifiers
pub enum GamepadAxis:
    LeftX = 0
    LeftY = 1
    RightX = 2
    RightY = 3
    TriggerLeft = 4
    TriggerRight = 5

impl GamepadAxis:
    pub fn to_int(self) -> i32:
        if self == GamepadAxis::LeftX:
            return 0
        elif self == GamepadAxis::LeftY:
            return 1
        elif self == GamepadAxis::RightX:
            return 2
        elif self == GamepadAxis::RightY:
            return 3
        elif self == GamepadAxis::TriggerLeft:
            return 4
        else:
            return 5

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> String:
        """Convert gamepad axis to string.

        Returns:
            Axis name

        Example:
            GamepadAxis::LeftX.to_string()  # → "left_x"
        """
        match self:
            case LeftX: "left_x"
            case LeftY: "left_y"
            case RightX: "right_x"
            case RightY: "right_y"
            case TriggerLeft: "trigger_left"
            case TriggerRight: "trigger_right"

    pub fn is_stick(self) -> bool:
        """Check if axis is a stick (not trigger).

        Returns:
            true for stick axes

        Example:
            GamepadAxis::LeftX.is_stick()  # → true
        """
        match self:
            case LeftX | LeftY | RightX | RightY: true
            case _: false

    pub fn is_trigger(self) -> bool:
        """Check if axis is a trigger.

        Returns:
            true for trigger axes

        Example:
            GamepadAxis::TriggerLeft.is_trigger()  # → true
        """
        match self:
            case TriggerLeft | TriggerRight: true
            case _: false

    pub fn is_left_stick(self) -> bool:
        """Check if axis belongs to left stick.

        Returns:
            true for LeftX or LeftY

        Example:
            GamepadAxis::LeftX.is_left_stick()  # → true
        """
        match self:
            case LeftX | LeftY: true
            case _: false

    pub fn is_right_stick(self) -> bool:
        """Check if axis belongs to right stick.

        Returns:
            true for RightX or RightY

        Example:
            GamepadAxis::RightX.is_right_stick()  # → true
        """
        match self:
            case RightX | RightY: true
            case _: false

    pub fn is_horizontal(self) -> bool:
        """Check if axis represents horizontal movement.

        Returns:
            true for X axes

        Example:
            GamepadAxis::LeftX.is_horizontal()  # → true
        """
        match self:
            case LeftX | RightX: true
            case _: false

    pub fn is_vertical(self) -> bool:
        """Check if axis represents vertical movement.

        Returns:
            true for Y axes

        Example:
            GamepadAxis::LeftY.is_vertical()  # → true
        """
        match self:
            case LeftY | RightY: true
            case _: false

    pub fn summary(self) -> String:
        """Get gamepad axis summary.

        Returns:
            Human-readable summary

        Example:
            GamepadAxis::LeftX.summary()
            # → "GamepadAxis: left_x (left stick, horizontal, axis=0)"
        """
        let name = self.to_string()
        let code = self.to_int()
        let mut props = []

        if self.is_left_stick():
            props.push("left stick")
        elif self.is_right_stick():
            props.push("right stick")
        elif self.is_trigger():
            props.push("trigger")

        if self.is_horizontal():
            props.push("horizontal")
        elif self.is_vertical():
            props.push("vertical")

        let props_str = props.join(", ")
        return "GamepadAxis: {name} ({props_str}, axis={code})"


# InputSystem trait
# Common interface for input handling
pub trait InputSystem:
    # Keyboard
    fn is_key_pressed(self, key: KeyCode) -> bool
    fn is_key_just_pressed(self, key: KeyCode) -> bool
    fn is_key_just_released(self, key: KeyCode) -> bool

    # Mouse
    fn is_mouse_button_pressed(self, button: MouseButton) -> bool
    fn is_mouse_button_just_pressed(self, button: MouseButton) -> bool
    fn is_mouse_button_just_released(self, button: MouseButton) -> bool
    fn get_mouse_position(self) -> (f32, f32)
    fn get_mouse_delta(self) -> (f32, f32)

    # Gamepad
    fn is_gamepad_button_pressed(self, gamepad_id: i32, button: i32) -> bool
    fn get_gamepad_axis(self, gamepad_id: i32, axis: GamepadAxis) -> f32

    # Actions (mapped inputs)
    fn is_action_pressed(self, action_name: String) -> bool
    fn is_action_just_pressed(self, action_name: String) -> bool
    fn get_action_strength(self, action_name: String) -> f32


# GodotInputAdapter
# Adapts Godot Input singleton to InputSystem trait
pub struct GodotInputAdapter:
    input_ptr: ffi.VoidPtr

impl GodotInputAdapter:
    pub fn get_instance() -> GodotInputAdapter:
        let ptr = godot_input_get_singleton()
        return GodotInputAdapter(input_ptr: ptr)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_input_ptr(self) -> ffi.VoidPtr:
        """Get input singleton pointer.

        Returns:
            Input pointer

        Example:
            adapter.get_input_ptr()
        """
        return self.input_ptr

    pub fn has_input(self) -> bool:
        """Check if has valid input pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_input()  # → true
        """
        return not ffi.is_null_ptr(self.input_ptr)

    pub fn summary(self) -> String:
        """Get Godot input adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "GodotInputAdapter: connected to Godot Input singleton"
        """
        let status = if self.has_input() { "connected to Godot Input singleton" } else { "no input singleton" }
        return "GodotInputAdapter: {status}"

impl InputSystem for GodotInputAdapter:
    fn is_key_pressed(self, key: KeyCode) -> bool:
        return godot_input_is_key_pressed(self.input_ptr, key.to_int())

    fn is_key_just_pressed(self, key: KeyCode) -> bool:
        return godot_input_is_key_just_pressed(self.input_ptr, key.to_int())

    fn is_key_just_released(self, key: KeyCode) -> bool:
        return godot_input_is_key_just_released(self.input_ptr, key.to_int())

    fn is_mouse_button_pressed(self, button: MouseButton) -> bool:
        return godot_input_is_mouse_button_pressed(self.input_ptr, button.to_int())

    fn is_mouse_button_just_pressed(self, button: MouseButton) -> bool:
        return godot_input_is_mouse_button_just_pressed(self.input_ptr, button.to_int())

    fn is_mouse_button_just_released(self, button: MouseButton) -> bool:
        return godot_input_is_mouse_button_just_released(self.input_ptr, button.to_int())

    fn get_mouse_position(self) -> (f32, f32):
        let x = ffi.alloc_f32()
        let y = ffi.alloc_f32()
        godot_input_get_mouse_position(self.input_ptr, x, y)
        let result = (ffi.read_f32(x), ffi.read_f32(y))
        ffi.free(x)
        ffi.free(y)
        return result

    fn get_mouse_delta(self) -> (f32, f32):
        let x = ffi.alloc_f32()
        let y = ffi.alloc_f32()
        godot_input_get_mouse_delta(self.input_ptr, x, y)
        let result = (ffi.read_f32(x), ffi.read_f32(y))
        ffi.free(x)
        ffi.free(y)
        return result

    fn is_gamepad_button_pressed(self, gamepad_id: i32, button: i32) -> bool:
        return godot_input_is_gamepad_button_pressed(self.input_ptr, gamepad_id, button)

    fn get_gamepad_axis(self, gamepad_id: i32, axis: GamepadAxis) -> f32:
        return godot_input_get_gamepad_axis(self.input_ptr, gamepad_id, axis.to_int())

    fn is_action_pressed(self, action_name: String) -> bool:
        return godot_input_is_action_pressed(self.input_ptr, action_name)

    fn is_action_just_pressed(self, action_name: String) -> bool:
        return godot_input_is_action_just_pressed(self.input_ptr, action_name)

    fn get_action_strength(self, action_name: String) -> f32:
        return godot_input_get_action_strength(self.input_ptr, action_name)


# UnrealInputAdapter
# Adapts Unreal Enhanced Input to InputSystem trait
pub struct UnrealInputAdapter:
    player_controller_ptr: ffi.VoidPtr

impl UnrealInputAdapter:
    pub fn new(player_controller_ptr: ffi.VoidPtr) -> UnrealInputAdapter:
        return UnrealInputAdapter(player_controller_ptr: player_controller_ptr)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_player_controller_ptr(self) -> ffi.VoidPtr:
        """Get player controller pointer.

        Returns:
            Player controller pointer

        Example:
            adapter.get_player_controller_ptr()
        """
        return self.player_controller_ptr

    pub fn has_player_controller(self) -> bool:
        """Check if has valid player controller pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_player_controller()  # → true
        """
        return not ffi.is_null_ptr(self.player_controller_ptr)

    pub fn summary(self) -> String:
        """Get Unreal input adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "UnrealInputAdapter: connected to player controller"
        """
        let status = if self.has_player_controller() { "connected to player controller" } else { "no player controller" }
        return "UnrealInputAdapter: {status}"

impl InputSystem for UnrealInputAdapter:
    fn is_key_pressed(self, key: KeyCode) -> bool:
        return unreal_input_is_key_down(self.player_controller_ptr, key.to_int())

    fn is_key_just_pressed(self, key: KeyCode) -> bool:
        return unreal_input_was_key_just_pressed(self.player_controller_ptr, key.to_int())

    fn is_key_just_released(self, key: KeyCode) -> bool:
        return unreal_input_was_key_just_released(self.player_controller_ptr, key.to_int())

    fn is_mouse_button_pressed(self, button: MouseButton) -> bool:
        return unreal_input_is_mouse_button_down(self.player_controller_ptr, button.to_int())

    fn is_mouse_button_just_pressed(self, button: MouseButton) -> bool:
        return unreal_input_was_mouse_button_just_pressed(self.player_controller_ptr, button.to_int())

    fn is_mouse_button_just_released(self, button: MouseButton) -> bool:
        return unreal_input_was_mouse_button_just_released(self.player_controller_ptr, button.to_int())

    fn get_mouse_position(self) -> (f32, f32):
        let x = ffi.alloc_f32()
        let y = ffi.alloc_f32()
        unreal_input_get_mouse_position(self.player_controller_ptr, x, y)
        let result = (ffi.read_f32(x), ffi.read_f32(y))
        ffi.free(x)
        ffi.free(y)
        return result

    fn get_mouse_delta(self) -> (f32, f32):
        let x = ffi.alloc_f32()
        let y = ffi.alloc_f32()
        unreal_input_get_mouse_delta(self.player_controller_ptr, x, y)
        let result = (ffi.read_f32(x), ffi.read_f32(y))
        ffi.free(x)
        ffi.free(y)
        return result

    fn is_gamepad_button_pressed(self, gamepad_id: i32, button: i32) -> bool:
        return unreal_input_is_gamepad_button_pressed(self.player_controller_ptr, gamepad_id, button)

    fn get_gamepad_axis(self, gamepad_id: i32, axis: GamepadAxis) -> f32:
        return unreal_input_get_gamepad_axis(self.player_controller_ptr, gamepad_id, axis.to_int())

    fn is_action_pressed(self, action_name: String) -> bool:
        return unreal_input_is_action_pressed(self.player_controller_ptr, action_name)

    fn is_action_just_pressed(self, action_name: String) -> bool:
        return unreal_input_was_action_just_pressed(self.player_controller_ptr, action_name)

    fn get_action_strength(self, action_name: String) -> f32:
        return unreal_input_get_action_value(self.player_controller_ptr, action_name)


# Utility functions

# Get Godot input system
pub fn get_godot_input() -> GodotInputAdapter:
    return GodotInputAdapter::get_instance()

# Get Unreal input system
pub fn get_unreal_input(player_controller_ptr: ffi.VoidPtr) -> UnrealInputAdapter:
    return UnrealInputAdapter::new(player_controller_ptr)


# FFI declarations for Godot
extern "C":
    fn godot_input_get_singleton() -> ffi.VoidPtr
    fn godot_input_is_key_pressed(input: ffi.VoidPtr, key: i32) -> bool
    fn godot_input_is_key_just_pressed(input: ffi.VoidPtr, key: i32) -> bool
    fn godot_input_is_key_just_released(input: ffi.VoidPtr, key: i32) -> bool
    fn godot_input_is_mouse_button_pressed(input: ffi.VoidPtr, button: i32) -> bool
    fn godot_input_is_mouse_button_just_pressed(input: ffi.VoidPtr, button: i32) -> bool
    fn godot_input_is_mouse_button_just_released(input: ffi.VoidPtr, button: i32) -> bool
    fn godot_input_get_mouse_position(input: ffi.VoidPtr, x: ffi.VoidPtr, y: ffi.VoidPtr)
    fn godot_input_get_mouse_delta(input: ffi.VoidPtr, x: ffi.VoidPtr, y: ffi.VoidPtr)
    fn godot_input_is_gamepad_button_pressed(input: ffi.VoidPtr, gamepad: i32, button: i32) -> bool
    fn godot_input_get_gamepad_axis(input: ffi.VoidPtr, gamepad: i32, axis: i32) -> f32
    fn godot_input_is_action_pressed(input: ffi.VoidPtr, action: String) -> bool
    fn godot_input_is_action_just_pressed(input: ffi.VoidPtr, action: String) -> bool
    fn godot_input_get_action_strength(input: ffi.VoidPtr, action: String) -> f32

# FFI declarations for Unreal
extern "C":
    fn unreal_input_is_key_down(controller: ffi.VoidPtr, key: i32) -> bool
    fn unreal_input_was_key_just_pressed(controller: ffi.VoidPtr, key: i32) -> bool
    fn unreal_input_was_key_just_released(controller: ffi.VoidPtr, key: i32) -> bool
    fn unreal_input_is_mouse_button_down(controller: ffi.VoidPtr, button: i32) -> bool
    fn unreal_input_was_mouse_button_just_pressed(controller: ffi.VoidPtr, button: i32) -> bool
    fn unreal_input_was_mouse_button_just_released(controller: ffi.VoidPtr, button: i32) -> bool
    fn unreal_input_get_mouse_position(controller: ffi.VoidPtr, x: ffi.VoidPtr, y: ffi.VoidPtr)
    fn unreal_input_get_mouse_delta(controller: ffi.VoidPtr, x: ffi.VoidPtr, y: ffi.VoidPtr)
    fn unreal_input_is_gamepad_button_pressed(controller: ffi.VoidPtr, gamepad: i32, button: i32) -> bool
    fn unreal_input_get_gamepad_axis(controller: ffi.VoidPtr, gamepad: i32, axis: i32) -> f32
    fn unreal_input_is_action_pressed(controller: ffi.VoidPtr, action: String) -> bool
    fn unreal_input_was_action_just_pressed(controller: ffi.VoidPtr, action: String) -> bool
    fn unreal_input_get_action_value(controller: ffi.VoidPtr, action: String) -> f32


# Example usage:
#
# # Get input system (Godot)
# let input = get_godot_input()
#
# # Check keyboard
# if input.is_key_pressed(KeyCode::W):
#     print("W is pressed")
#
# # Check mouse
# if input.is_mouse_button_just_pressed(MouseButton::Left):
#     let (x, y) = input.get_mouse_position()
#     print("Clicked at {x}, {y}")
#
# # Check action
# if input.is_action_pressed("jump"):
#     player.jump()
