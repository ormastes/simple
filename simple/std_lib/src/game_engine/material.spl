# Common Material Abstraction
#
# Engine-agnostic material interface
# Works with both Godot StandardMaterial3D and Unreal UMaterial
#
# Features:
# - Material properties (albedo, roughness, metallic, etc.)
# - Texture binding
# - Shader parameters
# - Material instances
# - PBR workflow support

import sys.ffi

mod material

# MaterialParameter
# Generic material parameter value
pub enum MaterialParameter:
    Float(f32)
    Vec2(f32, f32)
    Vec3(f32, f32, f32)
    Vec4(f32, f32, f32, f32)
    Color(f32, f32, f32, f32)
    Texture(ffi.VoidPtr)
    Bool(bool)

impl MaterialParameter:
    # =========================================================================
    # Type Checkers
    # =========================================================================

    pub fn is_float(self) -> bool:
        """Check if parameter is Float.

        Returns:
            true if Float variant
        """
        match self:
            case Float(_): true
            case _: false

    pub fn is_vec2(self) -> bool:
        """Check if parameter is Vec2."""
        match self:
            case Vec2(_, _): true
            case _: false

    pub fn is_vec3(self) -> bool:
        """Check if parameter is Vec3."""
        match self:
            case Vec3(_, _, _): true
            case _: false

    pub fn is_vec4(self) -> bool:
        """Check if parameter is Vec4."""
        match self:
            case Vec4(_, _, _, _): true
            case _: false

    pub fn is_color(self) -> bool:
        """Check if parameter is Color."""
        match self:
            case Color(_, _, _, _): true
            case _: false

    pub fn is_texture(self) -> bool:
        """Check if parameter is Texture."""
        match self:
            case Texture(_): true
            case _: false

    pub fn is_bool(self) -> bool:
        """Check if parameter is Bool."""
        match self:
            case Bool(_): true
            case _: false

    # =========================================================================
    # Conversion Methods
    # =========================================================================

    pub fn as_float(self) -> f32:
        if self is MaterialParameter::Float(value):
            return value
        else:
            return 0.0

    pub fn as_vec3(self) -> (f32, f32, f32):
        if self is MaterialParameter::Vec3(x, y, z):
            return (x, y, z)
        else:
            return (0.0, 0.0, 0.0)

    pub fn as_color(self) -> (f32, f32, f32, f32):
        if self is MaterialParameter::Color(r, g, b, a):
            return (r, g, b, a)
        else:
            return (0.0, 0.0, 0.0, 1.0)

    pub fn as_texture(self) -> ffi.VoidPtr:
        if self is MaterialParameter::Texture(ptr):
            return ptr
        else:
            return ffi.null_ptr()

    pub fn to_string(self) -> String:
        """Convert parameter to string representation."""
        match self:
            case Float(v): return "Float({v})"
            case Vec2(x, y): return "Vec2({x}, {y})"
            case Vec3(x, y, z): return "Vec3({x}, {y}, {z})"
            case Vec4(x, y, z, w): return "Vec4({x}, {y}, {z}, {w})"
            case Color(r, g, b, a): return "Color({r}, {g}, {b}, {a})"
            case Texture(_): return "Texture(<ptr>)"
            case Bool(b): return "Bool({b})"

    pub fn description(self) -> String:
        """Get material parameter description.

        Returns:
            Human-readable description

        Example:
            MaterialParameter::Color(1.0, 0.0, 0.0, 1.0).description()
            # → "RGBA color value"
        """
        match self:
            case Float(_): "Single floating-point value"
            case Vec2(_, _): "2D vector (x, y)"
            case Vec3(_, _, _): "3D vector (x, y, z)"
            case Vec4(_, _, _, _): "4D vector (x, y, z, w)"
            case Color(_, _, _, _): "RGBA color value"
            case Texture(_): "Texture resource pointer"
            case Bool(_): "Boolean flag"

    pub fn is_vector(self) -> bool:
        """Check if parameter is any vector type.

        Returns:
            True for Vec2, Vec3, or Vec4

        Example:
            MaterialParameter::Vec3(1.0, 2.0, 3.0).is_vector()  # → true
        """
        match self:
            case Vec2(_, _): true
            case Vec3(_, _, _): true
            case Vec4(_, _, _, _): true
            case _: false

    pub fn is_numeric(self) -> bool:
        """Check if parameter is numeric type.

        Returns:
            True for Float or any vector type

        Example:
            MaterialParameter::Float(0.5).is_numeric()  # → true
        """
        match self:
            case Float(_): true
            case Vec2(_, _): true
            case Vec3(_, _, _): true
            case Vec4(_, _, _, _): true
            case _: false

    pub fn summary(self) -> String:
        """Get material parameter summary.

        Returns:
            Human-readable summary

        Example:
            MaterialParameter::Color(1.0, 0.0, 0.0, 1.0).summary()
            # → "MaterialParameter: Color(1.0, 0.0, 0.0, 1.0) (RGBA color value, numeric)"
        """
        let value_str = self.to_string()
        let desc = self.description()
        let mut props = []

        if self.is_vector():
            props.push("vector")
        if self.is_numeric():
            props.push("numeric")
        if self.is_texture():
            props.push("resource")
        if self.is_bool():
            props.push("flag")

        if props.len() > 0:
            let props_str = ", ".join(props)
            return "MaterialParameter: {value_str} ({desc}, {props_str})"
        else:
            return "MaterialParameter: {value_str} ({desc})"


# Material trait
# Common interface for all materials
pub trait Material:
    # Properties
    fn get_parameter(self, name: String) -> Option[MaterialParameter]
    fn set_parameter(mut self, name: String, value: MaterialParameter)

    # PBR properties
    fn get_albedo(self) -> (f32, f32, f32, f32)
    fn set_albedo(mut self, r: f32, g: f32, b: f32, a: f32)
    fn get_roughness(self) -> f32
    fn set_roughness(mut self, roughness: f32)
    fn get_metallic(self) -> f32
    fn set_metallic(mut self, metallic: f32)
    fn get_emissive(self) -> (f32, f32, f32)
    fn set_emissive(mut self, r: f32, g: f32, b: f32)

    # Textures
    fn get_albedo_texture(self) -> Option[ffi.VoidPtr]
    fn set_albedo_texture(mut self, texture_ptr: ffi.VoidPtr)
    fn get_normal_texture(self) -> Option[ffi.VoidPtr]
    fn set_normal_texture(mut self, texture_ptr: ffi.VoidPtr)
    fn get_roughness_texture(self) -> Option[ffi.VoidPtr]
    fn set_roughness_texture(mut self, texture_ptr: ffi.VoidPtr)
    fn get_metallic_texture(self) -> Option[ffi.VoidPtr]
    fn set_metallic_texture(mut self, texture_ptr: ffi.VoidPtr)

    # Rendering state
    fn is_two_sided(self) -> bool
    fn set_two_sided(mut self, two_sided: bool)
    fn is_transparent(self) -> bool
    fn set_transparent(mut self, transparent: bool)


# GodotMaterialAdapter
# Adapts Godot StandardMaterial3D to Material trait
pub struct GodotMaterialAdapter:
    material_ptr: ffi.VoidPtr

impl GodotMaterialAdapter:
    pub fn new(material_ptr: ffi.VoidPtr) -> GodotMaterialAdapter:
        return GodotMaterialAdapter(material_ptr: material_ptr)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_material_ptr(self) -> ffi.VoidPtr:
        """Get material pointer.

        Returns:
            Material pointer

        Example:
            adapter.get_material_ptr()
        """
        return self.material_ptr

    pub fn has_material(self) -> bool:
        """Check if has valid material pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_material()  # → true
        """
        return not ffi.is_null_ptr(self.material_ptr)

    pub fn has_albedo_texture(self) -> bool:
        """Check if albedo texture is set.

        Returns:
            true if albedo texture exists

        Example:
            adapter.has_albedo_texture()  # → false
        """
        return self.get_albedo_texture().is_some()

    pub fn has_normal_texture(self) -> bool:
        """Check if normal texture is set.

        Returns:
            true if normal texture exists

        Example:
            adapter.has_normal_texture()  # → false
        """
        return self.get_normal_texture().is_some()

    pub fn summary(self) -> String:
        """Get Godot material adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "GodotMaterialAdapter: roughness=0.5, metallic=0.0, transparent"
        """
        let rough = self.get_roughness()
        let metal = self.get_metallic()
        let transparent_str = if self.is_transparent() { "transparent" } else { "opaque" }
        let two_sided_str = if self.is_two_sided() { ", two-sided" } else { "" }
        return "GodotMaterialAdapter: roughness={rough}, metallic={metal}, {transparent_str}{two_sided_str}"

impl Material for GodotMaterialAdapter:
    fn get_parameter(self, name: String) -> Option[MaterialParameter]:
        # Stub - would query parameter
        return None

    fn set_parameter(mut self, name: String, value: MaterialParameter):
        # Stub - would set parameter
        pass

    fn get_albedo(self) -> (f32, f32, f32, f32):
        let r = ffi.alloc_f32()
        let g = ffi.alloc_f32()
        let b = ffi.alloc_f32()
        let a = ffi.alloc_f32()

        godot_material_get_albedo(self.material_ptr, r, g, b, a)

        let result = (ffi.read_f32(r), ffi.read_f32(g), ffi.read_f32(b), ffi.read_f32(a))

        ffi.free(r)
        ffi.free(g)
        ffi.free(b)
        ffi.free(a)

        return result

    fn set_albedo(mut self, r: f32, g: f32, b: f32, a: f32):
        godot_material_set_albedo(self.material_ptr, r, g, b, a)

    fn get_roughness(self) -> f32:
        return godot_material_get_roughness(self.material_ptr)

    fn set_roughness(mut self, roughness: f32):
        godot_material_set_roughness(self.material_ptr, roughness)

    fn get_metallic(self) -> f32:
        return godot_material_get_metallic(self.material_ptr)

    fn set_metallic(mut self, metallic: f32):
        godot_material_set_metallic(self.material_ptr, metallic)

    fn get_emissive(self) -> (f32, f32, f32):
        let r = ffi.alloc_f32()
        let g = ffi.alloc_f32()
        let b = ffi.alloc_f32()

        godot_material_get_emissive(self.material_ptr, r, g, b)

        let result = (ffi.read_f32(r), ffi.read_f32(g), ffi.read_f32(b))

        ffi.free(r)
        ffi.free(g)
        ffi.free(b)

        return result

    fn set_emissive(mut self, r: f32, g: f32, b: f32):
        godot_material_set_emissive(self.material_ptr, r, g, b)

    fn get_albedo_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = godot_material_get_albedo_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_albedo_texture(mut self, texture_ptr: ffi.VoidPtr):
        godot_material_set_albedo_texture(self.material_ptr, texture_ptr)

    fn get_normal_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = godot_material_get_normal_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_normal_texture(mut self, texture_ptr: ffi.VoidPtr):
        godot_material_set_normal_texture(self.material_ptr, texture_ptr)

    fn get_roughness_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = godot_material_get_roughness_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_roughness_texture(mut self, texture_ptr: ffi.VoidPtr):
        godot_material_set_roughness_texture(self.material_ptr, texture_ptr)

    fn get_metallic_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = godot_material_get_metallic_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_metallic_texture(mut self, texture_ptr: ffi.VoidPtr):
        godot_material_set_metallic_texture(self.material_ptr, texture_ptr)

    fn is_two_sided(self) -> bool:
        return godot_material_is_two_sided(self.material_ptr)

    fn set_two_sided(mut self, two_sided: bool):
        godot_material_set_two_sided(self.material_ptr, two_sided)

    fn is_transparent(self) -> bool:
        return godot_material_is_transparent(self.material_ptr)

    fn set_transparent(mut self, transparent: bool):
        godot_material_set_transparent(self.material_ptr, transparent)


# UnrealMaterialAdapter
# Adapts Unreal UMaterial to Material trait
pub struct UnrealMaterialAdapter:
    material_ptr: ffi.VoidPtr

impl UnrealMaterialAdapter:
    pub fn new(material_ptr: ffi.VoidPtr) -> UnrealMaterialAdapter:
        return UnrealMaterialAdapter(material_ptr: material_ptr)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_material_ptr(self) -> ffi.VoidPtr:
        """Get material pointer.

        Returns:
            Material pointer

        Example:
            adapter.get_material_ptr()
        """
        return self.material_ptr

    pub fn has_material(self) -> bool:
        """Check if has valid material pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_material()  # → true
        """
        return not ffi.is_null_ptr(self.material_ptr)

    pub fn has_albedo_texture(self) -> bool:
        """Check if albedo texture is set.

        Returns:
            true if albedo texture exists

        Example:
            adapter.has_albedo_texture()  # → false
        """
        return self.get_albedo_texture().is_some()

    pub fn has_normal_texture(self) -> bool:
        """Check if normal texture is set.

        Returns:
            true if normal texture exists

        Example:
            adapter.has_normal_texture()  # → false
        """
        return self.get_normal_texture().is_some()

    pub fn summary(self) -> String:
        """Get Unreal material adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "UnrealMaterialAdapter: roughness=0.5, metallic=0.0, transparent"
        """
        let rough = self.get_roughness()
        let metal = self.get_metallic()
        let transparent_str = if self.is_transparent() { "transparent" } else { "opaque" }
        let two_sided_str = if self.is_two_sided() { ", two-sided" } else { "" }
        return "UnrealMaterialAdapter: roughness={rough}, metallic={metal}, {transparent_str}{two_sided_str}"

impl Material for UnrealMaterialAdapter:
    fn get_parameter(self, name: String) -> Option[MaterialParameter]:
        return None

    fn set_parameter(mut self, name: String, value: MaterialParameter):
        pass

    fn get_albedo(self) -> (f32, f32, f32, f32):
        let r = ffi.alloc_f32()
        let g = ffi.alloc_f32()
        let b = ffi.alloc_f32()
        let a = ffi.alloc_f32()

        unreal_material_get_base_color(self.material_ptr, r, g, b, a)

        let result = (ffi.read_f32(r), ffi.read_f32(g), ffi.read_f32(b), ffi.read_f32(a))

        ffi.free(r)
        ffi.free(g)
        ffi.free(b)
        ffi.free(a)

        return result

    fn set_albedo(mut self, r: f32, g: f32, b: f32, a: f32):
        unreal_material_set_base_color(self.material_ptr, r, g, b, a)

    fn get_roughness(self) -> f32:
        return unreal_material_get_roughness(self.material_ptr)

    fn set_roughness(mut self, roughness: f32):
        unreal_material_set_roughness(self.material_ptr, roughness)

    fn get_metallic(self) -> f32:
        return unreal_material_get_metallic(self.material_ptr)

    fn set_metallic(mut self, metallic: f32):
        unreal_material_set_metallic(self.material_ptr, metallic)

    fn get_emissive(self) -> (f32, f32, f32):
        let r = ffi.alloc_f32()
        let g = ffi.alloc_f32()
        let b = ffi.alloc_f32()

        unreal_material_get_emissive(self.material_ptr, r, g, b)

        let result = (ffi.read_f32(r), ffi.read_f32(g), ffi.read_f32(b))

        ffi.free(r)
        ffi.free(g)
        ffi.free(b)

        return result

    fn set_emissive(mut self, r: f32, g: f32, b: f32):
        unreal_material_set_emissive(self.material_ptr, r, g, b)

    fn get_albedo_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = unreal_material_get_base_color_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_albedo_texture(mut self, texture_ptr: ffi.VoidPtr):
        unreal_material_set_base_color_texture(self.material_ptr, texture_ptr)

    fn get_normal_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = unreal_material_get_normal_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_normal_texture(mut self, texture_ptr: ffi.VoidPtr):
        unreal_material_set_normal_texture(self.material_ptr, texture_ptr)

    fn get_roughness_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = unreal_material_get_roughness_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_roughness_texture(mut self, texture_ptr: ffi.VoidPtr):
        unreal_material_set_roughness_texture(self.material_ptr, texture_ptr)

    fn get_metallic_texture(self) -> Option[ffi.VoidPtr]:
        let tex_ptr = unreal_material_get_metallic_texture(self.material_ptr)
        if ffi.is_null_ptr(tex_ptr):
            return None
        else:
            return Some(tex_ptr)

    fn set_metallic_texture(mut self, texture_ptr: ffi.VoidPtr):
        unreal_material_set_metallic_texture(self.material_ptr, texture_ptr)

    fn is_two_sided(self) -> bool:
        return unreal_material_is_two_sided(self.material_ptr)

    fn set_two_sided(mut self, two_sided: bool):
        unreal_material_set_two_sided(self.material_ptr, two_sided)

    fn is_transparent(self) -> bool:
        return unreal_material_is_transparent(self.material_ptr)

    fn set_transparent(mut self, transparent: bool):
        unreal_material_set_transparent(self.material_ptr, transparent)


# FFI declarations for Godot materials
extern "C":
    fn godot_material_get_albedo(material: ffi.VoidPtr, r: ffi.VoidPtr, g: ffi.VoidPtr, b: ffi.VoidPtr, a: ffi.VoidPtr)
    fn godot_material_set_albedo(material: ffi.VoidPtr, r: f32, g: f32, b: f32, a: f32)
    fn godot_material_get_roughness(material: ffi.VoidPtr) -> f32
    fn godot_material_set_roughness(material: ffi.VoidPtr, roughness: f32)
    fn godot_material_get_metallic(material: ffi.VoidPtr) -> f32
    fn godot_material_set_metallic(material: ffi.VoidPtr, metallic: f32)
    fn godot_material_get_emissive(material: ffi.VoidPtr, r: ffi.VoidPtr, g: ffi.VoidPtr, b: ffi.VoidPtr)
    fn godot_material_set_emissive(material: ffi.VoidPtr, r: f32, g: f32, b: f32)
    fn godot_material_get_albedo_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn godot_material_set_albedo_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn godot_material_get_normal_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn godot_material_set_normal_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn godot_material_get_roughness_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn godot_material_set_roughness_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn godot_material_get_metallic_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn godot_material_set_metallic_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn godot_material_is_two_sided(material: ffi.VoidPtr) -> bool
    fn godot_material_set_two_sided(material: ffi.VoidPtr, two_sided: bool)
    fn godot_material_is_transparent(material: ffi.VoidPtr) -> bool
    fn godot_material_set_transparent(material: ffi.VoidPtr, transparent: bool)

# FFI declarations for Unreal materials
extern "C":
    fn unreal_material_get_base_color(material: ffi.VoidPtr, r: ffi.VoidPtr, g: ffi.VoidPtr, b: ffi.VoidPtr, a: ffi.VoidPtr)
    fn unreal_material_set_base_color(material: ffi.VoidPtr, r: f32, g: f32, b: f32, a: f32)
    fn unreal_material_get_roughness(material: ffi.VoidPtr) -> f32
    fn unreal_material_set_roughness(material: ffi.VoidPtr, roughness: f32)
    fn unreal_material_get_metallic(material: ffi.VoidPtr) -> f32
    fn unreal_material_set_metallic(material: ffi.VoidPtr, metallic: f32)
    fn unreal_material_get_emissive(material: ffi.VoidPtr, r: ffi.VoidPtr, g: ffi.VoidPtr, b: ffi.VoidPtr)
    fn unreal_material_set_emissive(material: ffi.VoidPtr, r: f32, g: f32, b: f32)
    fn unreal_material_get_base_color_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_material_set_base_color_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn unreal_material_get_normal_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_material_set_normal_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn unreal_material_get_roughness_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_material_set_roughness_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn unreal_material_get_metallic_texture(material: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_material_set_metallic_texture(material: ffi.VoidPtr, texture: ffi.VoidPtr)
    fn unreal_material_is_two_sided(material: ffi.VoidPtr) -> bool
    fn unreal_material_set_two_sided(material: ffi.VoidPtr, two_sided: bool)
    fn unreal_material_is_transparent(material: ffi.VoidPtr) -> bool
    fn unreal_material_set_transparent(material: ffi.VoidPtr, transparent: bool)


# Example usage:
#
# # Create material adapter for Godot
# let godot_mat = GodotMaterialAdapter::new(godot_material_ptr)
# godot_mat.set_albedo(1.0, 0.0, 0.0, 1.0)  # Red
# godot_mat.set_roughness(0.5)
# godot_mat.set_metallic(0.0)
#
# # Create material adapter for Unreal
# let unreal_mat = UnrealMaterialAdapter::new(unreal_material_ptr)
# unreal_mat.set_albedo(0.0, 1.0, 0.0, 1.0)  # Green
# unreal_mat.set_roughness(0.3)
# unreal_mat.set_metallic(1.0)
#
# # Both materials use the same trait interface!
