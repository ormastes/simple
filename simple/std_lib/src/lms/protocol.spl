# MCP Protocol Types
# Implements Anthropic's Model Context Protocol message structures

# Client information
pub class ClientInfo:
    name: text
    version: text

# Server information
pub class ServerInfo:
    name: text
    version: text

# Tool definition
pub class Tool:
    name: text
    description: text
    input_schema: Dict       # JSON Schema for tool inputs

# Resource definition
pub class Resource:
    uri: text
    name: text
    description: Option<text>
    mime_type: Option<text>

# Prompt definition
pub class Prompt:
    name: text
    description: Option<text>
    arguments: Option<List<Dict>>  # Argument schema

# Server capabilities
pub class ServerCapabilities:
    tools: Option<ToolsCapability>
    resources: Option<ResourcesCapability>
    prompts: Option<PromptsCapability>

pub class ToolsCapability:
    list_changed: Option<bool>   # Whether tool list can change

pub class ResourcesCapability:
    subscribe: Option<bool>       # Whether supports subscriptions
    list_changed: Option<bool>    # Whether resource list can change

pub class PromptsCapability:
    list_changed: Option<bool>    # Whether prompt list can change

# Client capabilities
pub class ClientCapabilities:
    roots: Option<RootsCapability>
    sampling: Option<Dict>

pub class RootsCapability:
    list_changed: Option<bool>    # Whether root list changes

# Initialize request parameters
pub class InitializeParams:
    protocol_version: text
    capabilities: ClientCapabilities
    client_info: ClientInfo

# Initialize response result
pub class InitializeResult:
    protocol_version: text
    capabilities: ServerCapabilities
    server_info: ServerInfo

# Tool call request parameters
pub class ToolCallParams:
    name: text
    arguments: Option<Dict>

# Tool call result
pub class ToolCallResult:
    content: List<Content>
    is_error: Option<bool>

# Content types for tool results
pub enum Content:
    Text(TextContent)
    Image(ImageContent)
    Resource(ResourceContent)

impl Content:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_text(self) -> bool:
        """Check if content is text.

        Returns:
            true for Text variant

        Example:
            Content::Text(tc).is_text()  # → true
        """
        match self:
            case Text(_): True
            case _: False

    pub fn is_image(self) -> bool:
        """Check if content is image.

        Returns:
            true for Image variant

        Example:
            Content::Image(ic).is_image()  # → true
        """
        match self:
            case Image(_): True
            case _: False

    pub fn is_resource(self) -> bool:
        """Check if content is resource.

        Returns:
            true for Resource variant

        Example:
            Content::Resource(rc).is_resource()  # → true
        """
        match self:
            case Resource(_): True
            case _: False

    pub fn get_text(self) -> Option<TextContent>:
        """Get text content if available.

        Returns:
            TextContent if Text variant

        Example:
            Content::Text(tc).get_text()  # → Some(tc)
        """
        match self:
            case Text(tc): Some(tc)
            case _: None

    pub fn get_image(self) -> Option<ImageContent>:
        """Get image content if available.

        Returns:
            ImageContent if Image variant

        Example:
            Content::Image(ic).get_image()  # → Some(ic)
        """
        match self:
            case Image(ic): Some(ic)
            case _: None

    pub fn get_resource(self) -> Option<ResourceContent>:
        """Get resource content if available.

        Returns:
            ResourceContent if Resource variant

        Example:
            Content::Resource(rc).get_resource()  # → Some(rc)
        """
        match self:
            case Resource(rc): Some(rc)
            case _: None

    pub fn content_type(self) -> text:
        """Get content type string.

        Returns:
            "text", "image", or "resource"

        Example:
            Content::Text(tc).content_type()  # → "text"
        """
        match self:
            case Text(_): "text"
            case Image(_): "image"
            case Resource(_): "resource"

    pub fn to_string(self) -> text:
        """Convert content to string description.

        Returns:
            Content type name

        Example:
            Content::Text(tc).to_string()  # → "text"
        """
        self.content_type()

    fn description() -> text:
        """Get content type description.

        Returns:
            Human-readable description

        Example:
            Content::Image(ic).description()
            # → "Image content (base64 encoded)"
        """
        match self:
            case Text(_): "Text content (plain text)"
            case Image(_): "Image content (base64 encoded)"
            case Resource(_): "Resource content (URI reference)"

    pub fn summary(self) -> text:
        """Get content summary.

        Returns:
            Human-readable summary

        Example:
            Content::Text(tc).summary()  # → "Content: text"
        """
        val ctype = self.content_type()
        return "Content: {ctype}"

pub class TextContent:
    content_type: text      # Always "text"
    text: text

pub class ImageContent:
    content_type: text      # Always "image"
    data: text              # Base64 encoded
    mime_type: text

pub class ResourceContent:
    content_type: text      # Always "resource"
    resource: ResourceReference

pub class ResourceReference:
    uri: text
    text: Option<text>

# Resource read request
pub class ReadResourceParams:
    uri: text

# Resource read result
pub class ReadResourceResult:
    contents: List<ResourceContents>

pub class ResourceContents:
    uri: text
    mime_type: Option<text>
    text: Option<text>
    blob: Option<text>      # Base64 encoded

# List tools result
pub class ListToolsResult:
    tools: List<Tool>

# List resources result
pub class ListResourcesResult:
    resources: List<Resource>

# List prompts result
pub class ListPromptsResult:
    prompts: List<Prompt>

# Helper functions to create common message types

pub fn create_initialize_response(server_info: ServerInfo, capabilities: ServerCapabilities) -> Dict:
    val server_info_dict = {"name": server_info.name, "version": server_info.version}
    return {"protocolVersion": "2024-11-05", "capabilities": capabilities_to_dict(capabilities), "serverInfo": server_info_dict}

pub fn capabilities_to_dict(caps: ServerCapabilities) -> Dict:
    var result = {}

    match caps.tools:
        Some(tools_cap) ->
            result["tools"] = {"listChanged": tools_cap.list_changed.unwrap_or(false)}
        None ->
            pass

    match caps.resources:
        Some(res_cap) ->
            result["resources"] = {"subscribe": res_cap.subscribe.unwrap_or(false), "listChanged": res_cap.list_changed.unwrap_or(false)}
        None ->
            pass

    match caps.prompts:
        Some(prompt_cap) ->
            result["prompts"] = {"listChanged": prompt_cap.list_changed.unwrap_or(false)}
        None ->
            pass

    result

pub fn tool_to_dict(tool: Tool) -> Dict:
    return {"name": tool.name, "description": tool.description, "inputSchema": tool.input_schema}

pub fn resource_to_dict(resource: Resource) -> Dict:
    var result = {"uri": resource.uri, "name": resource.name}

    match resource.description:
        Some(desc) ->
            result["description"] = desc
        None ->
            pass

    match resource.mime_type:
        Some(mime) ->
            result["mimeType"] = mime
        None ->
            pass

    result
