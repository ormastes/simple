# Token Kinds and Grammar Helper Functions
#
# Token types and helper functions for grammar construction.

import parser.treesitter.{Rule}

export TokenKind
export token, ref, seq, choice, optional, repeat, repeat1, field, prec_left, prec_right

# ============================================================================
# Helper Functions for Grammar Construction
# ============================================================================

fn token(kind: TokenKind) -> Rule:
    Rule.Token(kind)

fn ref(name: text) -> Rule:
    Rule.Ref(name)

fn seq(rules: List<Rule>) -> Rule:
    Rule.Seq(rules)

fn choice(rules: List<Rule>) -> Rule:
    Rule.Choice(rules)

fn optional(rule: Rule) -> Rule:
    Rule.Optional(rule)

fn repeat(rule: Rule) -> Rule:
    Rule.Repeat(rule)

fn repeat1(rule: Rule) -> Rule:
    Rule.Repeat1(rule)

fn field(name: text, rule: Rule) -> Rule:
    Rule.Field(name, rule)

fn prec_left(precedence: i32, rule: Rule) -> Rule:
    Rule.PrecLeft(precedence, rule)

fn prec_right(precedence: i32, rule: Rule) -> Rule:
    Rule.PrecRight(precedence, rule)

# ============================================================================
# Token Kinds
# ============================================================================

enum TokenKind:
    # Keywords
    Fn, Let, Mut, Return, If, Elif, Else, Match, Case,
    For, In, While, Loop, Break, Continue,
    Class, Struct, Enum, Trait,
    Import, As, From,
    True, False, Nil,
    And, Or, Not,
    Then,  # For if-expressions

    # Operators
    Plus, Minus, Star, Slash, Percent, DoubleStar,
    Eq, DoubleEq, NotEq,
    Lt, Gt, LtEq, GtEq,
    Pipe, Ampersand, Caret, Tilde,
    LtLt, GtGt,
    Dot, Comma, Colon, Arrow, Question, Exclamation,
    Underscore,

    # Delimiters
    LParen, RParen,
    LBracket, RBracket,
    LBrace, RBrace,
    Newline, Indent, Dedent,

    # Literals
    Integer, f32, text,
    FStringStart, FStringText, FStringEnd, FStringFormatSpec,

    # Identifiers
    Identifier, TypeIdentifier

impl TokenKind:
    fn is_keyword() -> bool:
        """Check if this is any keyword token.
        Returns: true for all keyword variants
        Example: TokenKind.Fn.is_keyword()  # → true
        """
        match self:
            case Fn: true
            case Let: true
            case Mut: true
            case Return: true
            case If: true
            case Elif: true
            case Else: true
            case Match: true
            case Case: true
            case For: true
            case In: true
            case While: true
            case Loop: true
            case Break: true
            case Continue: true
            case Class: true
            case Struct: true
            case Enum: true
            case Trait: true
            case Import: true
            case As: true
            case From: true
            case True: true
            case False: true
            case Nil: true
            case And: true
            case Or: true
            case Not: true
            case Then: true
            case _: false

    fn is_operator() -> bool:
        """Check if this is an operator token.
        Returns: true for operator variants
        Example: TokenKind.Plus.is_operator()  # → true
        """
        match self:
            case Plus: true
            case Minus: true
            case Star: true
            case Slash: true
            case Percent: true
            case DoubleStar: true
            case Eq: true
            case DoubleEq: true
            case NotEq: true
            case Lt: true
            case Gt: true
            case LtEq: true
            case GtEq: true
            case Pipe: true
            case Ampersand: true
            case Caret: true
            case Tilde: true
            case LtLt: true
            case GtGt: true
            case Dot: true
            case Comma: true
            case Colon: true
            case Arrow: true
            case Question: true
            case Exclamation: true
            case Underscore: true
            case _: false

    fn is_delimiter() -> bool:
        """Check if this is a delimiter token.
        Returns: true for delimiter variants
        Example: TokenKind.LParen.is_delimiter()  # → true
        """
        match self:
            case LParen: true
            case RParen: true
            case LBracket: true
            case RBracket: true
            case LBrace: true
            case RBrace: true
            case Newline: true
            case Indent: true
            case Dedent: true
            case _: false

    fn is_literal() -> bool:
        """Check if this is a literal token.
        Returns: true for literal variants
        Example: TokenKind.Integer.is_literal()  # → true
        """
        match self:
            case Integer: true
            case f32: true
            case text: true
            case FStringStart: true
            case FStringText: true
            case FStringEnd: true
            case FStringFormatSpec: true
            case _: false

    fn is_identifier() -> bool:
        """Check if this is an identifier token.
        Returns: true for Identifier or TypeIdentifier
        Example: TokenKind.Identifier.is_identifier()  # → true
        """
        match self:
            case Identifier: true
            case TypeIdentifier: true
            case _: false

    fn is_control_flow() -> bool:
        """Check if this is a control flow keyword.
        Returns: true for control flow keywords
        Example: TokenKind.If.is_control_flow()  # → true
        """
        match self:
            case If: true
            case Elif: true
            case Else: true
            case Match: true
            case Case: true
            case For: true
            case While: true
            case Loop: true
            case Break: true
            case Continue: true
            case Return: true
            case _: false

    fn is_declaration() -> bool:
        """Check if this is a declaration keyword.
        Returns: true for declaration keywords
        Example: TokenKind.Fn.is_declaration()  # → true
        """
        match self:
            case Fn: true
            case Let: true
            case Class: true
            case Struct: true
            case Enum: true
            case Trait: true
            case _: false

    fn is_comparison() -> bool:
        """Check if this is a comparison operator.
        Returns: true for comparison operators
        Example: TokenKind.Lt.is_comparison()  # → true
        """
        match self:
            case DoubleEq: true
            case NotEq: true
            case Lt: true
            case Gt: true
            case LtEq: true
            case GtEq: true
            case _: false

    fn is_arithmetic() -> bool:
        """Check if this is an arithmetic operator.
        Returns: true for arithmetic operators
        Example: TokenKind.Plus.is_arithmetic()  # → true
        """
        match self:
            case Plus: true
            case Minus: true
            case Star: true
            case Slash: true
            case Percent: true
            case DoubleStar: true
            case _: false

    fn is_bitwise() -> bool:
        """Check if this is a bitwise operator.
        Returns: true for bitwise operators
        Example: TokenKind.Pipe.is_bitwise()  # → true
        """
        match self:
            case Pipe: true
            case Ampersand: true
            case Caret: true
            case Tilde: true
            case LtLt: true
            case GtGt: true
            case _: false

    fn is_logical() -> bool:
        """Check if this is a logical operator.
        Returns: true for logical operators
        Example: TokenKind.And.is_logical()  # → true
        """
        match self:
            case And: true
            case Or: true
            case Not: true
            case _: false

    fn is_bracket() -> bool:
        """Check if this is a bracket delimiter.
        Returns: true for bracket pairs
        Example: TokenKind.LBracket.is_bracket()  # → true
        """
        match self:
            case LParen: true
            case RParen: true
            case LBracket: true
            case RBracket: true
            case LBrace: true
            case RBrace: true
            case _: false

    fn is_whitespace() -> bool:
        """Check if this is whitespace/indentation token.
        Returns: true for Newline, Indent, Dedent
        Example: TokenKind.Indent.is_whitespace()  # → true
        """
        match self:
            case Newline: true
            case Indent: true
            case Dedent: true
            case _: false

    fn is_fstring_part() -> bool:
        """Check if this is part of f-string literal.
        Returns: true for f-string components
        Example: TokenKind.FStringText.is_fstring_part()  # → true
        """
        match self:
            case FStringStart: true
            case FStringText: true
            case FStringEnd: true
            case FStringFormatSpec: true
            case _: false

    fn to_string() -> text:
        """Convert TokenKind to string representation.
        Returns: lowercase symbolic name
        Example: TokenKind.DoubleEq.to_string()  # → "=="
        """
        match self:
            case Fn: "fn"
            case Let: "val"
            case Mut: "mut"
            case Return: "return"
            case If: "if"
            case Elif: "elif"
            case Else: "else"
            case Match: "match"
            case Case: "case"
            case For: "for"
            case In: "in"
            case While: "while"
            case Loop: "loop"
            case Break: "break"
            case Continue: "continue"
            case Class: "class"
            case Struct: "struct"
            case Enum: "enum"
            case Trait: "trait"
            case Import: "import"
            case As: "as"
            case From: "from"
            case True: "true"
            case False: "false"
            case Nil: "nil"
            case And: "and"
            case Or: "or"
            case Not: "not"
            case Then: "then"
            case Plus: "+"
            case Minus: "-"
            case Star: "*"
            case Slash: "/"
            case Percent: "%"
            case DoubleStar: "**"
            case Eq: "="
            case DoubleEq: "=="
            case NotEq: "!="
            case Lt: "<"
            case Gt: ">"
            case LtEq: "<="
            case GtEq: ">="
            case Pipe: "|"
            case Ampersand: "&"
            case Caret: "^"
            case Tilde: "~"
            case LtLt: "<<"
            case GtGt: ">>"
            case Dot: "."
            case Comma: ","
            case Colon: ":"
            case Arrow: "->"
            case Question: "?"
            case Exclamation: "!"
            case Underscore: "_"
            case LParen: "("
            case RParen: ")"
            case LBracket: "["
            case RBracket: "]"
            case LBrace: "{"
            case RBrace: "}"
            case Newline: "\\n"
            case Indent: "<indent>"
            case Dedent: "<dedent>"
            case Integer: "<integer>"
            case f32: "<f32>"
            case text: "<string>"
            case FStringStart: "<fstring_start>"
            case FStringText: "<fstring_text>"
            case FStringEnd: "<fstring_end>"
            case FStringFormatSpec: "<fstring_fmt>"
            case Identifier: "<identifier>"
            case TypeIdentifier: "<type_id>"

    fn description() -> text:
        """Get human-readable description of the token kind.
        Returns: descriptive explanation
        Example: TokenKind.Fn.description()  # → "Function declaration keyword"
        """
        match self:
            case Fn: "Function declaration keyword"
            case Let: "Variable binding keyword"
            case Mut: "Mutable modifier keyword"
            case Return: "Return statement keyword"
            case If: "Conditional if keyword"
            case Elif: "Conditional elif keyword"
            case Else: "Conditional else keyword"
            case Match: "Pattern match keyword"
            case Case: "Match case keyword"
            case For: "For loop keyword"
            case In: "In operator keyword"
            case While: "While loop keyword"
            case Loop: "Infinite loop keyword"
            case Break: "Break statement keyword"
            case Continue: "Continue statement keyword"
            case Class: "Class declaration keyword"
            case Struct: "Struct declaration keyword"
            case Enum: "Enum declaration keyword"
            case Trait: "Trait declaration keyword"
            case Import: "Import statement keyword"
            case As: "Alias as keyword"
            case From: "From import keyword"
            case True: "Boolean true literal"
            case False: "Boolean false literal"
            case Nil: "Null/nil literal"
            case And: "Logical and operator"
            case Or: "Logical or operator"
            case Not: "Logical not operator"
            case Then: "Then keyword for expressions"
            case Plus: "Addition operator"
            case Minus: "Subtraction operator"
            case Star: "Multiplication operator"
            case Slash: "Division operator"
            case Percent: "Modulo operator"
            case DoubleStar: "Exponentiation operator"
            case Eq: "Assignment operator"
            case DoubleEq: "Equality comparison"
            case NotEq: "Inequality comparison"
            case Lt: "Less-than comparison"
            case Gt: "Greater-than comparison"
            case LtEq: "Less-or-equal comparison"
            case GtEq: "Greater-or-equal comparison"
            case Pipe: "Bitwise OR operator"
            case Ampersand: "Bitwise AND operator"
            case Caret: "Bitwise XOR operator"
            case Tilde: "Bitwise NOT operator"
            case LtLt: "Left shift operator"
            case GtGt: "Right shift operator"
            case Dot: "Member access operator"
            case Comma: "Comma separator"
            case Colon: "Colon separator"
            case Arrow: "Arrow type annotation"
            case Question: "Optional operator"
            case Exclamation: "Unwrap/assertion operator"
            case Underscore: "Wildcard underscore"
            case LParen: "Left parenthesis"
            case RParen: "Right parenthesis"
            case LBracket: "Left bracket"
            case RBracket: "Right bracket"
            case LBrace: "Left brace"
            case RBrace: "Right brace"
            case Newline: "Newline character"
            case Indent: "Indentation increase"
            case Dedent: "Indentation decrease"
            case Integer: "Integer literal"
            case f32: "f32 literal"
            case text: "text literal"
            case FStringStart: "F-string start delimiter"
            case FStringText: "F-string text content"
            case FStringEnd: "F-string end delimiter"
            case FStringFormatSpec: "F-string format specifier"
            case Identifier: "Variable/function identifier"
            case TypeIdentifier: "Type name identifier"

    fn summary() -> text:
        """Get comprehensive summary of the token kind.
        Returns: summary with token, description, and category
        Example: TokenKind.Plus.summary()
                # → "TokenKind: + (Addition operator, operator, arithmetic)"
        """
        val name = self.to_string()
        val desc = self.description()
        var cats = []

        if self.is_keyword():
            cats.push("keyword")
        if self.is_operator():
            cats.push("operator")
        if self.is_delimiter():
            cats.push("delimiter")
        if self.is_literal():
            cats.push("literal")
        if self.is_identifier():
            cats.push("identifier")
        if self.is_control_flow():
            cats.push("control flow")
        if self.is_declaration():
            cats.push("declaration")
        if self.is_comparison():
            cats.push("comparison")
        if self.is_arithmetic():
            cats.push("arithmetic")
        if self.is_bitwise():
            cats.push("bitwise")
        if self.is_logical():
            cats.push("logical")

        val cats_str = if cats.len() > 0:
            ", " + cats.join(", ")
        else:
            ""

        "TokenKind: {name} ({desc}{cats_str})"
