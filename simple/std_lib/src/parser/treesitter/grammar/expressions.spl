# Grammar Expressions
#
# Expression rules: binary, unary, call, index, literals, etc.

import parser.treesitter.{Grammar}
import tokens.{TokenKind, token, ref, seq, choice, optional, field, repeat, prec_left, prec_right}

export add_expression_rules

# Add all expression rules to grammar
fn add_expression_rules(grammar: Grammar):
    # Expressions (Pratt parser priorities)
    grammar.add_rule("expression", choice([
        ref("binary_expr"),
        ref("unary_expr"),
        ref("call_expr"),
        ref("index_expr"),
        ref("field_expr"),
        ref("lambda_expr"),
        ref("if_expr"),
        ref("match_expr"),
        ref("primary_expr")
    ]))

    # Binary expressions
    grammar.add_rule("binary_expr", prec_left(1, seq([
        field("left", ref("expression")),
        field("operator", choice([
            token(Plus), token(Minus), token(Star), token(Slash),
            token(Percent), token(DoubleStar),
            token(DoubleEq), token(NotEq),
            token(Lt), token(Gt), token(LtEq), token(GtEq),
            token(And), token(Or),
            token(Pipe), token(Ampersand), token(Caret),
            token(LtLt), token(GtGt)
        ])),
        field("right", ref("expression"))
    ])))

    # Unary expressions
    grammar.add_rule("unary_expr", prec_right(2, seq([
        field("operator", choice([
            token(Minus), token(Not), token(Tilde)
        ])),
        field("operand", ref("expression"))
    ])))

    # Call expression
    grammar.add_rule("call_expr", prec_left(3, seq([
        field("callee", ref("expression")),
        token(LParen),
        optional(ref("argument_list")),
        token(RParen)
    ])))

    # Argument list
    grammar.add_rule("argument_list", seq([
        ref("expression"),
        repeat(seq([token(Comma), ref("expression")]))
    ]))

    # Index expression
    grammar.add_rule("index_expr", prec_left(3, seq([
        field("value", ref("expression")),
        token(LBracket),
        field("index", ref("expression")),
        token(RBracket)
    ])))

    # Field expression
    grammar.add_rule("field_expr", prec_left(3, seq([
        field("value", ref("expression")),
        token(Dot),
        field("field", ref("identifier"))
    ])))

    # Lambda expression
    grammar.add_rule("lambda_expr", seq([
        token(Pipe),
        optional(ref("parameter_list")),
        token(Pipe),
        choice([
            ref("expression"),
            seq([token(Colon), ref("block")])
        ])
    ]))

    # If expression
    grammar.add_rule("if_expr", seq([
        token(If),
        field("condition", ref("expression")),
        token(Then),
        field("then_value", ref("expression")),
        token(Else),
        field("else_value", ref("expression"))
    ]))

    # Match expression
    grammar.add_rule("match_expr", seq([
        token(Match),
        field("value", ref("expression")),
        token(Colon),
        ref("match_expr_block")
    ]))

    # Match expression block (inline)
    grammar.add_rule("match_expr_block", seq([
        token(LBrace),
        ref("match_case"),
        repeat(seq([token(Comma), ref("match_case")])),
        optional(token(Comma)),
        token(RBrace)
    ]))

    # Primary expressions
    grammar.add_rule("primary_expr", choice([
        ref("literal"),
        ref("identifier"),
        ref("array_literal"),
        ref("tuple_literal"),
        ref("dict_literal"),
        ref("struct_literal"),
        ref("paren_expr")
    ]))

    # Add literal rules
    add_literal_rules(grammar)

    # Expression list
    grammar.add_rule("expression_list", seq([
        ref("expression"),
        repeat(seq([token(Comma), ref("expression")])),
        optional(token(Comma))
    ]))

# Add literal rules
fn add_literal_rules(grammar: Grammar):
    # Literals
    grammar.add_rule("literal", choice([
        ref("integer_literal"),
        ref("float_literal"),
        ref("string_literal"),
        ref("fstring_literal"),
        ref("boolean_literal"),
        ref("nil_literal")
    ]))

    grammar.add_rule("integer_literal", token(Integer))
    grammar.add_rule("float_literal", token(f32))
    grammar.add_rule("string_literal", token(text))

    # F-string literal
    grammar.add_rule("fstring_literal", seq([
        token(FStringStart),
        repeat(choice([
            token(FStringText),
            ref("fstring_interpolation")
        ])),
        token(FStringEnd)
    ]))

    grammar.add_rule("fstring_interpolation", seq([
        token(LBrace),
        ref("expression"),
        optional(seq([token(Colon), ref("format_spec")])),
        token(RBrace)
    ]))

    grammar.add_rule("format_spec", token(FStringFormatSpec))

    grammar.add_rule("boolean_literal", choice([
        token(True),
        token(False)
    ]))

    grammar.add_rule("nil_literal", token(Nil))

    # Array literal
    grammar.add_rule("array_literal", seq([
        token(LBracket),
        optional(ref("expression_list")),
        token(RBracket)
    ]))

    # Tuple literal
    grammar.add_rule("tuple_literal", seq([
        token(LParen),
        ref("expression"),
        token(Comma),
        optional(ref("expression_list")),
        token(RParen)
    ]))

    # Dict literal
    grammar.add_rule("dict_literal", seq([
        token(LBrace),
        optional(ref("dict_entry_list")),
        token(RBrace)
    ]))

    grammar.add_rule("dict_entry_list", seq([
        ref("dict_entry"),
        repeat(seq([token(Comma), ref("dict_entry")])),
        optional(token(Comma))
    ]))

    grammar.add_rule("dict_entry", seq([
        field("key", ref("expression")),
        token(Colon),
        field("value", ref("expression"))
    ]))

    # Struct literal
    grammar.add_rule("struct_literal", seq([
        field("name", ref("type_identifier")),
        token(LParen),
        optional(ref("field_init_list")),
        token(RParen)
    ]))

    grammar.add_rule("field_init_list", seq([
        ref("field_init"),
        repeat(seq([token(Comma), ref("field_init")])),
        optional(token(Comma))
    ]))

    grammar.add_rule("field_init", seq([
        field("name", ref("identifier")),
        token(Colon),
        field("value", ref("expression"))
    ]))

    # Parenthesized expression
    grammar.add_rule("paren_expr", seq([
        token(LParen),
        ref("expression"),
        token(RParen)
    ]))
