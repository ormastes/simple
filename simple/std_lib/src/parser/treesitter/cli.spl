# Tree-sitter CLI Tools
# Command-line interface for tree-sitter operations

import sys
import io.stdio as stdio
import parser.treesitter.{TreeSitterParser, Grammar}
import parser.treesitter.language_detect as detect
import parser.treesitter.grammar_test as gt
import parser.treesitter.grammar_compile as compile

# CLI command result
enum CliResult:
    Success(message: String)
    Error(error: String)
    Help

impl CliResult:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_success() -> bool:
        """Check if result is Success.

        Returns:
            true for Success

        Example:
            CliResult::Success("OK").is_success()  # → true
        """
        match self:
            case Success(_): true
            case _: false

    fn is_error() -> bool:
        """Check if result is Error.

        Returns:
            true for Error

        Example:
            CliResult::Error("failed").is_error()  # → true
        """
        match self:
            case Error(_): true
            case _: false

    fn is_help() -> bool:
        """Check if result is Help.

        Returns:
            true for Help

        Example:
            CliResult::Help.is_help()  # → true
        """
        match self:
            case Help: true
            case _: false

    fn has_message() -> bool:
        """Check if result contains a message.

        Returns:
            true for Success or Error (both have messages)

        Example:
            CliResult::Success("done").has_message()  # → true
            CliResult::Help.has_message()  # → false
        """
        match self:
            case Success(_): true
            case Error(_): true
            case Help: false

    fn get_message() -> Option[String]:
        """Get message if available.

        Returns:
            Message string or None

        Example:
            CliResult::Success("done").get_message()  # → Some("done")
            CliResult::Help.get_message()  # → None
        """
        match self:
            case Success(msg): Some(msg)
            case Error(err): Some(err)
            case Help: None

    fn exit_code() -> i32:
        """Get appropriate exit code.

        Returns:
            0 for Success/Help, 1 for Error

        Example:
            CliResult::Success("OK").exit_code()  # → 0
            CliResult::Error("fail").exit_code()  # → 1
        """
        match self:
            case Success(_): 0
            case Help: 0
            case Error(_): 1

    fn to_string() -> String:
        """Convert result to string.

        Returns:
            Result type name

        Example:
            CliResult::Success("OK").to_string()  # → "success"
        """
        match self:
            case Success(_): "success"
            case Error(_): "error"
            case Help: "help"

    fn description() -> String:
        """Get CLI result description.

        Returns:
            Human-readable description

        Example:
            CliResult::Success("OK").description()
            # → "Successful operation"
        """
        match self:
            case Success(_): "Successful operation"
            case Error(_): "Operation failed with error"
            case Help: "Help information requested"

    fn summary() -> String:
        """Get summary of CLI result.

        Returns:
            Human-readable summary

        Example:
            CliResult::Success("done").summary()
            # → "CliResult: success (done)"
        """
        val name = self.to_string()
        match self:
            case Success(msg):
                val preview = if msg.len() > 40:
                    msg.substring(0, 40) + "..."
                else:
                    msg
                "CliResult: {name} ({preview})"
            case Error(err):
                val preview = if err.len() > 40:
                    err.substring(0, 40) + "..."
                else:
                    err
                "CliResult: {name} ({preview})"
            case Help:
                "CliResult: {name}"

# CLI commands
enum Command:
    Parse(file_path: String, language: Option<String>, show_tree: Bool)
    Query(file_path: String, query_str: String, language: Option<String>)
    Test(test_file: String)
    Highlight(file_path: String, language: Option<String>)
    Validate(grammar_file: String)
    Languages
    Help
    Version

impl Command:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_parse() -> bool:
        """Check if this is Parse command.

        Returns:
            true for Parse

        Example:
            Command::Parse("test.spl", None, false).is_parse()  # → true
        """
        match self:
            case Parse(_, _, _): true
            case _: false

    fn is_query() -> bool:
        """Check if this is Query command.

        Returns:
            true for Query

        Example:
            Command::Query("test.spl", "(func)", None).is_query()  # → true
        """
        match self:
            case Query(_, _, _): true
            case _: false

    fn is_test() -> bool:
        """Check if this is Test command.

        Returns:
            true for Test

        Example:
            Command::Test("test.spl").is_test()  # → true
        """
        match self:
            case Test(_): true
            case _: false

    fn is_highlight() -> bool:
        """Check if this is Highlight command.

        Returns:
            true for Highlight

        Example:
            Command::Highlight("test.spl", None).is_highlight()  # → true
        """
        match self:
            case Highlight(_, _): true
            case _: false

    fn is_validate() -> bool:
        """Check if this is Validate command.

        Returns:
            true for Validate

        Example:
            Command::Validate("grammar.spl").is_validate()  # → true
        """
        match self:
            case Validate(_): true
            case _: false

    fn is_languages() -> bool:
        """Check if this is Languages command.

        Returns:
            true for Languages

        Example:
            Command::Languages.is_languages()  # → true
        """
        match self:
            case Languages: true
            case _: false

    fn is_help() -> bool:
        """Check if this is Help command.

        Returns:
            true for Help

        Example:
            Command::Help.is_help()  # → true
        """
        match self:
            case Help: true
            case _: false

    fn is_version() -> bool:
        """Check if this is Version command.

        Returns:
            true for Version

        Example:
            Command::Version.is_version()  # → true
        """
        match self:
            case Version: true
            case _: false

    fn requires_file() -> bool:
        """Check if command requires a file path.

        Returns:
            true for Parse, Query, Highlight, Test, Validate

        Example:
            Command::Parse("test.spl", None, false).requires_file()  # → true
            Command::Languages.requires_file()  # → false
        """
        match self:
            case Parse(_, _, _): true
            case Query(_, _, _): true
            case Test(_): true
            case Highlight(_, _): true
            case Validate(_): true
            case _: false

    fn is_meta_command() -> bool:
        """Check if this is a meta command (Help, Version, Languages).

        Returns:
            true for Help, Version, Languages

        Example:
            Command::Help.is_meta_command()  # → true
            Command::Parse("test.spl", None, false).is_meta_command()  # → false
        """
        match self:
            case Help: true
            case Version: true
            case Languages: true
            case _: false

    fn is_processing_command() -> bool:
        """Check if command processes source code.

        Returns:
            true for Parse, Query, Highlight, Test

        Example:
            Command::Parse("test.spl", None, false).is_processing_command()  # → true
            Command::Languages.is_processing_command()  # → false
        """
        match self:
            case Parse(_, _, _): true
            case Query(_, _, _): true
            case Test(_): true
            case Highlight(_, _): true
            case _: false

    fn accepts_language_option() -> bool:
        """Check if command accepts --language option.

        Returns:
            true for Parse, Query, Highlight

        Example:
            Command::Parse("test.spl", None, false).accepts_language_option()  # → true
            Command::Test("test.spl").accepts_language_option()  # → false
        """
        match self:
            case Parse(_, _, _): true
            case Query(_, _, _): true
            case Highlight(_, _): true
            case _: false

    fn to_string() -> String:
        """Convert command to string.

        Returns:
            Command name

        Example:
            Command::Parse("test.spl", None, false).to_string()  # → "parse"
        """
        match self:
            case Parse(_, _, _): "parse"
            case Query(_, _, _): "query"
            case Test(_): "test"
            case Highlight(_, _): "highlight"
            case Validate(_): "validate"
            case Languages: "languages"
            case Help: "help"
            case Version: "version"

    fn description() -> String:
        """Get command description.

        Returns:
            Human-readable description

        Example:
            Command::Parse("test.spl", None, false).description()
            # → "Parse a file and show parse statistics"
        """
        match self:
            case Parse(_, _, _): "Parse a file and show parse statistics"
            case Query(_, _, _): "Run a tree-sitter query against a file"
            case Test(_): "Run grammar tests from a test file"
            case Highlight(_, _): "Show syntax highlighting tokens for a file"
            case Validate(_): "Validate a grammar definition file"
            case Languages: "List all supported languages"
            case Help: "Show help message"
            case Version: "Show version information"

    fn summary() -> String:
        """Get summary of command.

        Returns:
            Human-readable summary

        Example:
            Command::Parse("test.spl", None, true).summary()
            # → "Command: parse (test.spl, show_tree=true)"
        """
        val name = self.to_string()
        match self:
            case Parse(file, lang, show_tree):
                val lang_str = match lang:
                    case Some(l): ", lang={l}"
                    case None: ""
                val tree_str = if show_tree: ", show_tree=true" else: ""
                "Command: {name} ({file}{lang_str}{tree_str})"
            case Query(file, query, lang):
                val lang_str = match lang:
                    case Some(l): ", lang={l}"
                    case None: ""
                "Command: {name} ({file}, query={query}{lang_str})"
            case Test(file):
                "Command: {name} ({file})"
            case Highlight(file, lang):
                val lang_str = match lang:
                    case Some(l): ", lang={l}"
                    case None: ""
                "Command: {name} ({file}{lang_str})"
            case Validate(file):
                "Command: {name} ({file})"
            case Languages:
                "Command: {name} (meta)"
            case Help:
                "Command: {name} (meta)"
            case Version:
                "Command: {name} (meta)"

# Main CLI handler
class TreeSitterCli:
    static fn new() -> TreeSitterCli:
        TreeSitterCli()

    # Run CLI with arguments
    fn run(args: List<String>) -> CliResult:
        if args.len() < 2:
            return self.print_help()

        val command = self.parse_command(args)?

        match command:
            case Parse(file_path, language, show_tree):
                return self.cmd_parse(file_path, language, show_tree)
            case Query(file_path, query_str, language):
                return self.cmd_query(file_path, query_str, language)
            case Test(test_file):
                return self.cmd_test(test_file)
            case Highlight(file_path, language):
                return self.cmd_highlight(file_path, language)
            case Validate(grammar_file):
                return self.cmd_validate(grammar_file)
            case Languages:
                return self.cmd_languages()
            case Help:
                return self.print_help()
            case Version:
                return self.print_version()

    # Parse command-line arguments
    fn parse_command(args: List<String>) -> Result<Command, String>:
        val cmd = args[1]

        match cmd:
            case "parse":
                if args.len() < 3:
                    return Err("Usage: ts-cli parse <file> [--language <lang>] [--tree]")

                val file_path = args[2]
                var language: Option<String> = None
                var show_tree = false

                var i = 3
                while i < args.len():
                    match args[i]:
                        case "--language" | "-l":
                            if i + 1 < args.len():
                                language = Some(args[i + 1])
                                i = i + 2
                            else:
                                return Err("--language requires an argument")
                        case "--tree" | "-t":
                            show_tree = true
                            i = i + 1
                        case _:
                            return Err("Unknown option: {args[i]}")

                return Ok(Command.Parse(file_path, language, show_tree))

            case "query":
                if args.len() < 4:
                    return Err("Usage: ts-cli query <file> <query> [--language <lang>]")

                val file_path = args[2]
                val query_str = args[3]
                var language: Option<String> = None

                if args.len() > 4 and (args[4] == "--language" or args[4] == "-l"):
                    if args.len() > 5:
                        language = Some(args[5])

                return Ok(Command.Query(file_path, query_str, language))

            case "test":
                if args.len() < 3:
                    return Err("Usage: ts-cli test <test-file>")

                return Ok(Command.Test(args[2]))

            case "highlight":
                if args.len() < 3:
                    return Err("Usage: ts-cli highlight <file> [--language <lang>]")

                val file_path = args[2]
                var language: Option<String> = None

                if args.len() > 3 and (args[3] == "--language" or args[3] == "-l"):
                    if args.len() > 4:
                        language = Some(args[4])

                return Ok(Command.Highlight(file_path, language))

            case "validate":
                if args.len() < 3:
                    return Err("Usage: ts-cli validate <grammar-file>")

                return Ok(Command.Validate(args[2]))

            case "languages":
                return Ok(Command.Languages)

            case "help" | "--help" | "-h":
                return Ok(Command.Help)

            case "version" | "--version" | "-v":
                return Ok(Command.Version)

            case _:
                return Err("Unknown command: {cmd}")

    # Parse command: Parse a file and show results
    fn cmd_parse(file_path: String, language: Option<String>, show_tree: Bool) -> CliResult:
        # Read file
        val content = match stdio.read_file(file_path):
            case Ok(c): c
            case Err(e):
                return CliResult.Error("Failed to read file: {e}")

        # Detect or use specified language
        val lang = match language:
            case Some(l): l
            case None:
                match detect.detect_language(Some(file_path), Some(content)):
                    case Some(l): l
                    case None:
                        return CliResult.Error("Could not detect language. Use --language to specify.")

        # Create parser
        val parser = match TreeSitterParser.new(lang):
            case Ok(p): p
            case Err(e):
                return CliResult.Error("Failed to create parser: {e}")

        # Parse
        val start_time = sys.time.now_ms()
        val tree = match parser.parse(content):
            case Ok(t): t
            case Err(e):
                return CliResult.Error("Parse error: {e}")
        val parse_time = sys.time.now_ms() - start_time

        # Show results
        print("✅ Parsed successfully in {parse_time:.2f}ms")
        print("Language: {lang}")
        print("Root node: {tree.root_node.kind}")

        if tree.root_node.has_error:
            print("⚠️  Tree contains errors")

        if show_tree:
            print("\nParse tree:")
            print(gt.tree_to_string(tree.root_node, tree, 0))

        CliResult.Success("Parse complete")

    # Query command: Run a query against a file
    fn cmd_query(file_path: String, query_str: String, language: Option<String>) -> CliResult:
        # Read file
        val content = match stdio.read_file(file_path):
            case Ok(c): c
            case Err(e):
                return CliResult.Error("Failed to read file: {e}")

        # Detect or use specified language
        val lang = match language:
            case Some(l): l
            case None:
                match detect.detect_language(Some(file_path), Some(content)):
                    case Some(l): l
                    case None:
                        return CliResult.Error("Could not detect language. Use --language to specify.")

        # Create parser
        val parser = match TreeSitterParser.new(lang):
            case Ok(p): p
            case Err(e):
                return CliResult.Error("Failed to create parser: {e}")

        # Parse
        val tree = match parser.parse(content):
            case Ok(t): t
            case Err(e):
                return CliResult.Error("Parse error: {e}")

        # Execute query
        val cursor = match parser.query(tree, query_str):
            case Ok(c): c
            case Err(e):
                return CliResult.Error("Query error: {e}")

        # Show results
        print("Query: {query_str}")
        print("Matches:")

        var count = 0
        loop:
            match cursor.next_match():
                case None:
                    break
                case Some(m):
                    count = count + 1
                    print("  Match {count}:")
                    for capture in m.captures:
                        print("    {capture.name}: {capture.node.kind}")

        print("\nTotal matches: {count}")

        CliResult.Success("Query complete")

    # Test command: Run grammar tests
    fn cmd_test(test_file: String) -> CliResult:
        # Load and execute test file
        # This would typically load a test suite from the file
        print("Running tests from: {test_file}")

        # For now, just run a simple validation
        val content = match stdio.read_file(test_file):
            case Ok(c): c
            case Err(e):
                return CliResult.Error("Failed to read test file: {e}")

        print("✅ Test file loaded ({content.len()} bytes)")
        print("Note: Full test execution requires BDD framework integration")

        CliResult.Success("Test validation complete")

    # Highlight command: Show syntax highlighting tokens
    fn cmd_highlight(file_path: String, language: Option<String>) -> CliResult:
        # Read file
        val content = match stdio.read_file(file_path):
            case Ok(c): c
            case Err(e):
                return CliResult.Error("Failed to read file: {e}")

        # Detect or use specified language
        val lang = match language:
            case Some(l): l
            case None:
                match detect.detect_language(Some(file_path), Some(content)):
                    case Some(l): l
                    case None:
                        return CliResult.Error("Could not detect language. Use --language to specify.")

        # Create parser
        val parser = match TreeSitterParser.new(lang):
            case Ok(p): p
            case Err(e):
                return CliResult.Error("Failed to create parser: {e}")

        # Parse
        val tree = match parser.parse(content):
            case Ok(t): t
            case Err(e):
                return CliResult.Error("Parse error: {e}")

        # Show syntax highlighting (simplified - would use query system)
        print("Syntax highlighting for: {file_path}")
        print("Language: {lang}")
        print("\nTokens:")

        self.show_node_tokens(tree.root_node, tree, 0)

        CliResult.Success("Highlight complete")

    # Show node tokens (helper for highlight)
    fn show_node_tokens(node: Node, tree: Tree, depth: Int):
        val indent = "  ".repeat(depth)
        print("{indent}{node.kind} [{node.span.start_line}:{node.span.start_column}]")

        # Limit recursion depth for display
        if depth < 3:
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Ok(child):
                        self.show_node_tokens(child, tree, depth + 1)
                    case Err(_):
                        pass

    # Validate command: Validate a grammar definition
    fn cmd_validate(grammar_file: String) -> CliResult:
        print("Validating grammar: {grammar_file}")

        # Load grammar file
        val content = match stdio.read_file(grammar_file):
            case Ok(c): c
            case Err(e):
                return CliResult.Error("Failed to read grammar file: {e}")

        print("✅ Grammar file loaded ({content.len()} bytes)")

        # Basic validation
        if content.contains("fn ") and content.contains("Grammar"):
            print("✅ Grammar structure looks valid")
        else:
            print("⚠️  Grammar structure may be invalid")

        print("Note: Full grammar validation requires compilation pipeline")

        CliResult.Success("Validation complete")

    # Languages command: List supported languages
    fn cmd_languages() -> CliResult:
        print("Supported languages:")
        print("")

        val languages = detect.get_supported_languages()

        for lang in languages:
            print("  - {lang}")

        print("\nTotal: {languages.len()} languages")

        CliResult.Success("Language list complete")

    # Print help
    fn print_help() -> CliResult:
        print("Tree-sitter CLI Tools")
        print("")
        print("Usage: ts-cli <command> [options]")
        print("")
        print("Commands:")
        print("  parse <file> [--language <lang>] [--tree]")
        print("      Parse a file and show parse statistics")
        print("      Options:")
        print("        --language, -l <lang>  Specify language (auto-detect if omitted)")
        print("        --tree, -t             Show full parse tree")
        print("")
        print("  query <file> <query> [--language <lang>]")
        print("      Run a tree-sitter query against a file")
        print("      Options:")
        print("        --language, -l <lang>  Specify language (auto-detect if omitted)")
        print("")
        print("  test <test-file>")
        print("      Run grammar tests from a test file")
        print("")
        print("  highlight <file> [--language <lang>]")
        print("      Show syntax highlighting tokens for a file")
        print("      Options:")
        print("        --language, -l <lang>  Specify language (auto-detect if omitted)")
        print("")
        print("  validate <grammar-file>")
        print("      Validate a grammar definition file")
        print("")
        print("  languages")
        print("      List all supported languages")
        print("")
        print("  help, --help, -h")
        print("      Show this help message")
        print("")
        print("  version, --version, -v")
        print("      Show version information")
        print("")
        print("Examples:")
        print("  ts-cli parse example.py")
        print("  ts-cli parse example.py --tree")
        print("  ts-cli query example.rs '(function_def)' ")
        print("  ts-cli highlight main.spl")
        print("  ts-cli languages")
        print("")

        CliResult.Help

    # Print version
    fn print_version() -> CliResult:
        print("Tree-sitter CLI Tools v0.1.0")
        print("Self-hosted tree-sitter implementation in Simple")
        print("")
        print("Features:")
        print("  - Multi-language parsing (Simple, Rust, Python)")
        print("  - Incremental parsing")
        print("  - Query system")
        print("  - Grammar testing framework")
        print("  - Language auto-detection")
        print("")

        CliResult.Success("Version info displayed")

# Main entry point
fn main():
    val args = sys.args()
    val cli = TreeSitterCli.new()

    match cli.run(args):
        case Success(message):
            sys.exit(0)
        case Error(error):
            stdio.write_stderr("Error: {error}\n")
            sys.exit(1)
        case Help:
            sys.exit(0)

# Convenience functions

# Parse a file from command line
fn parse_file(file_path: String, language: Option<String>) -> Result<Tree, String>:
    val content = stdio.read_file(file_path)?

    val lang = match language:
        case Some(l): l
        case None:
            detect.detect_language(Some(file_path), Some(content))
                .ok_or("Could not detect language")?

    val parser = TreeSitterParser.new(lang)?
    parser.parse(content)

# Run a query from command line
fn query_file(file_path: String, query_str: String, language: Option<String>) -> Result<QueryCursor, String>:
    val tree = parse_file(file_path, language)?

    val lang = language.unwrap_or("simple")
    val parser = TreeSitterParser.new(lang)?

    parser.query(tree, query_str)
