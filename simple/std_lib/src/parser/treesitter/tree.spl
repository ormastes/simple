# Tree representation for parsed Simple language source
# Immutable CST with arena allocation and structural sharing

import core.{Option, Result}

# Handle to a node in the arena (not a pointer)
struct NodeId:
    index: u32
    generation: u32

# Source location span
struct Span:
    start_byte: i64
    end_byte: i64
    start_line: i64
    end_line: i64
    start_column: i64
    end_column: i64

    fn contains(line: i64, column: i64) -> bool:
        if self.start_line == line and self.end_line == line:
            return self.start_column <= column and column < self.end_column
        elif self.start_line == line:
            return self.start_column <= column
        elif self.end_line == line:
            return column < self.end_column
        else:
            return self.start_line < line and line < self.end_line

# Alias for Span (tree-sitter compatibility)
type Range = Span

# Parse tree node (immutable)
struct Node:
    id: NodeId
    kind: str                    # "function_def", "identifier", etc.
    span: Span
    children: <NodeId>           # Child node handles
    fields: {str: NodeId}        # Named fields (@name, @params)
    has_error: bool              # Contains ERROR node?
    text: str                    # Cached text slice

    fn child_count() -> i64:
        return self.children.len()

    fn child(index: i64) -> Option<NodeId>:
        if index >= 0 and index < self.children.len():
            return Some(self.children[index])
        else:
            return None

    fn child_by_field(field_name: str) -> Option<NodeId>:
        return self.fields.get(field_name)

    fn is_named() -> bool:
        # Named nodes (non-tokens) have lowercase kind
        return self.kind.len() > 0 and self.kind[0].is_lowercase()

# Arena allocator for nodes (based on core_nogc/arena.spl pattern)
struct NodeArena:
    nodes: <Node>
    generation: u32

    static fn new() -> NodeArena:
        return NodeArena(nodes: [], generation: 0)

    var fn alloc(node: Node) -> NodeId:
        val index = self.nodes.len() as u32
        self.nodes.push(node)
        return NodeId(index: index, generation: self.generation)

    fn get(id: NodeId) -> Option<Node>:
        if id.generation != self.generation:
            return None
        if id.index >= 0 and (id.index as i64) < self.nodes.len():
            return Some(self.nodes[id.index as i64])
        else:
            return None

    fn clone_shallow() -> NodeArena:
        # Structural sharing - copy arena reference
        return NodeArena(
            nodes: self.nodes,
            generation: self.generation + 1
        )

# Immutable parse tree
struct Tree:
    root_node: NodeId
    arena: NodeArena
    source: str
    version: u32

    fn root() -> Option<Node>:
        return self.arena.get(self.root_node)

    fn get_node(id: NodeId) -> Option<Node>:
        return self.arena.get(id)

    fn walk() -> TreeCursor:
        return TreeCursor(
            tree: self,
            current: self.root_node,
            depth: 0,
            parent_stack: [],
            current_child_index: 0
        )

# Parent tracking entry for cursor navigation
struct ParentEntry:
    node_id: NodeId
    child_index: i64

# Tree cursor for efficient traversal
struct TreeCursor:
    tree: Tree
    current: NodeId
    depth: i64
    parent_stack: <ParentEntry>  # Stack of (parent_id, child_index)
    current_child_index: i64     # Index within current parent's children

    fn node() -> Option<Node>:
        return self.tree.get_node(self.current)

    var fn goto_first_child() -> bool:
        match self.node():
            case Some(node):
                match node.child(0):
                    case Some(child_id):
                        # Push current onto parent stack
                        self.parent_stack.push(ParentEntry {
                            node_id: self.current,
                            child_index: self.current_child_index
                        })
                        self.current = child_id
                        self.current_child_index = 0
                        self.depth = self.depth + 1
                        return true
                    case None:
                        return false
            case None:
                return false

    var fn goto_next_sibling() -> bool:
        # Navigate to next sibling using parent tracking
        if self.parent_stack.len() == 0:
            return false  # At root, no siblings

        val parent_entry = self.parent_stack[self.parent_stack.len() - 1]
        match self.tree.get_node(parent_entry.node_id):
            case Some(parent_node):
                val next_index = self.current_child_index + 1
                match parent_node.child(next_index):
                    case Some(sibling_id):
                        self.current = sibling_id
                        self.current_child_index = next_index
                        return true
                    case None:
                        return false  # No more siblings
            case None:
                return false

    var fn goto_parent() -> bool:
        # Navigate to parent using parent stack
        if self.parent_stack.len() == 0:
            return false  # Already at root

        val parent_entry = self.parent_stack.pop().unwrap()
        self.current = parent_entry.node_id
        self.current_child_index = parent_entry.child_index
        self.depth = self.depth - 1
        return true
