# ML Configuration System
#
# Hierarchical, type-safe configuration management for ML experiments.
# Built on SDN (Simple Data Notation) for native Simple syntax.
#
# Usage:
#     import ml.config.Conf
#
#     # Load configuration from file
#     val cfg = Conf.load("config.sdn")
#
#     # Access values with dot notation
#     val lr = cfg.get("training.lr")
#
#     # Merge configurations
#     val merged = Conf.merge(base_cfg, override_cfg)
#
#     # Parse CLI dotlist overrides
#     val cli_cfg = Conf.parse_dotlist(["train.epochs=20", "model.size=512"])

export Conf, ConfValue, ConfResolver, ConfError, ConfSchema


class ConfValue:
    """A configuration value with hierarchical access."""
    _data: any  # Dict or primitive value

    fn __init__(data: any):
        self._data = data

    fn get(key: str) -> ConfValue:
        """Get a nested value by key.

        Args:
            key: Key to look up (supports dot notation like "model.hidden_size")

        Returns:
            ConfValue wrapping the found value, or empty ConfValue if not found
        """
        val parts = key.split(".")
        var current = self._data

        for part in parts:
            if current is dict:
                if part in current:
                    current = current[part]
                else:
                    return ConfValue({})
            else:
                return ConfValue({})

        return ConfValue(current)

    fn as_str() -> str:
        """Get value as string."""
        if self._data is str:
            return self._data
        return ""

    fn as_int() -> i64:
        """Get value as integer."""
        if self._data is i64:
            return self._data
        if self._data is i32:
            return self._data as i64
        return 0

    fn as_float() -> f64:
        """Get value as float."""
        if self._data is f64:
            return self._data
        if self._data is f32:
            return self._data as f64
        if self._data is i64:
            return self._data as f64
        return 0.0

    fn as_bool() -> bool:
        """Get value as boolean."""
        if self._data is bool:
            return self._data
        return false

    fn as_list() -> any:
        """Get value as list."""
        if self._data is list:
            return self._data
        return []

    fn as_dict() -> any:
        """Get value as dictionary."""
        if self._data is dict:
            return self._data
        return {}

    fn is_empty() -> bool:
        """Check if value is empty or missing."""
        if self._data is dict:
            return self._data.len() == 0
        return self._data == nil

    fn raw() -> any:
        """Get the raw underlying data."""
        return self._data


class Conf:
    """Configuration management class.

    Provides static methods for loading, merging, and validating configurations.
    """
    _data: any
    _frozen: bool

    fn __init__(data: any = {}):
        self._data = data
        self._frozen = false

    static fn load(path: str) -> Conf:
        """Load configuration from an SDN file.

        Args:
            path: Path to the SDN configuration file

        Returns:
            Conf instance with loaded configuration

        Example:
            val cfg = Conf.load("config.sdn")
            val lr = cfg.get("training.lr").as_float()
        """
        # Read file content
        val content = _read_file(path)
        if content == "":
            return Conf({})

        # Parse SDN content
        val data = _parse_sdn(content)
        return Conf(data)

    static fn from_dict(data: any) -> Conf:
        """Create configuration from a dictionary.

        Args:
            data: Dictionary with configuration values

        Returns:
            Conf instance
        """
        return Conf(data)

    static fn merge(base: Conf, override: Conf) -> Conf:
        """Deep merge two configurations.

        Values from override take precedence over base.

        Args:
            base: Base configuration
            override: Override configuration

        Returns:
            New Conf with merged values

        Example:
            val base = Conf.load("base.sdn")
            val override = Conf.load("large.sdn")
            val merged = Conf.merge(base, override)
        """
        val merged = _deep_merge(base._data, override._data)
        return Conf(merged)

    static fn parse_dotlist(args: any) -> Conf:
        """Parse dotlist-style command-line arguments.

        Dotlist syntax: key.subkey.field=value

        Args:
            args: List of dotlist strings like ["train.lr=0.01", "model.size=512"]

        Returns:
            Conf with parsed values

        Example:
            val cfg = Conf.parse_dotlist(["train.epochs=20", "model.size=512"])
            # Result: {train: {epochs: 20}, model: {size: 512}}
        """
        var result = {}

        for arg in args:
            if "=" in arg:
                val parts = arg.split("=")
                if parts.len() >= 2:
                    val key = parts[0]
                    val value = parts[1]
                    _set_nested(result, key, _parse_value(value))

        return Conf(result)

    fn get(key: str) -> ConfValue:
        """Get a configuration value by key.

        Supports dot notation for nested access.

        Args:
            key: Key to look up (e.g., "model.hidden_size")

        Returns:
            ConfValue wrapping the found value
        """
        return ConfValue(self._data).get(key)

    fn get_str(key: str, default_val: str = "") -> str:
        """Get string value with default."""
        val v = self.get(key)
        if v.is_empty():
            return default_val
        return v.as_str()

    fn get_int(key: str, default_val: i64 = 0) -> i64:
        """Get integer value with default."""
        val v = self.get(key)
        if v.is_empty():
            return default_val
        return v.as_int()

    fn get_float(key: str, default_val: f64 = 0.0) -> f64:
        """Get float value with default."""
        val v = self.get(key)
        if v.is_empty():
            return default_val
        return v.as_float()

    fn get_bool(key: str, default_val: bool = false) -> bool:
        """Get boolean value with default."""
        val v = self.get(key)
        if v.is_empty():
            return default_val
        return v.as_bool()

    me set(key: str, value: any):
        """Set a configuration value.

        Args:
            key: Key to set (supports dot notation)
            value: Value to set
        """
        if self._frozen:
            print("Error: Cannot modify frozen configuration")
            return

        _set_nested(self._data, key, value)

    fn freeze() -> Conf:
        """Create a frozen (immutable) copy of this configuration.

        Returns:
            New Conf that cannot be modified
        """
        var frozen = Conf(self._data)
        frozen._frozen = true
        return frozen

    fn is_frozen() -> bool:
        """Check if configuration is frozen."""
        return self._frozen

    fn to_dict() -> any:
        """Convert configuration to dictionary."""
        return self._data

    fn keys() -> any:
        """Get all top-level keys."""
        if self._data is dict:
            return self._data.keys()
        return []

    fn resolve() -> Conf:
        """Resolve all ${...} interpolations in the configuration.

        Supports:
        - ${path.to.var} - Reference another config value
        - ${resolver:args} - Call a registered resolver

        Returns:
            New Conf with all interpolations resolved

        Example:
            val cfg = Conf.from_dict({
                "base_dir": "/data",
                "train_path": "${base_dir}/train"
            })
            val resolved = cfg.resolve()
            # resolved.get("train_path").as_str() == "/data/train"
        """
        val resolved_data = _interpolate_all(self._data, self._data)
        return Conf.from_dict(resolved_data)

    fn validate_with(schema: ConfSchema) -> any:
        """Validate configuration against a schema.

        Args:
            schema: Schema to validate against

        Returns:
            List of ConfError, empty if valid

        Example:
            val schema = ConfSchema.new()
                .field("model.hidden_size", "int", required=true)
            val errors = cfg.validate_with(schema)
            if errors.len() > 0:
                for err in errors:
                    print(err.to_string())
        """
        return schema.validate(self)

    fn with_defaults(schema: ConfSchema) -> Conf:
        """Apply default values from schema.

        Args:
            schema: Schema with default values

        Returns:
            New Conf with defaults applied
        """
        return schema.apply_defaults(self)


# ============================================================================
# Helper Functions
# ============================================================================

fn _read_file(path: str) -> str:
    """Read file contents. Returns empty string on error."""
    # Placeholder - in real implementation, use io.fs module
    print("Conf: Would read file: {path}")
    return ""

fn _parse_sdn(content: str) -> any:
    """Parse SDN content to dictionary."""
    # Use the SDN parser from std_lib
    # For now, return empty dict as placeholder
    return {}

fn _deep_merge(base: any, override: any) -> any:
    """Deep merge two dictionaries."""
    if not (base is dict) or not (override is dict):
        return override

    var result = {}

    # Copy base values
    for key in base.keys():
        result[key] = base[key]

    # Merge override values
    for key in override.keys():
        if key in result and result[key] is dict and override[key] is dict:
            result[key] = _deep_merge(result[key], override[key])
        else:
            result[key] = override[key]

    return result

fn _set_nested(data: any, key: str, value: any):
    """Set a nested value using dot notation."""
    val parts = key.split(".")

    if parts.len() == 1:
        data[key] = value
        return

    var current = data
    for i in 0..(parts.len() - 1):
        val part = parts[i]
        if not (part in current):
            current[part] = {}
        current = current[part]

    current[parts[parts.len() - 1]] = value

fn _parse_value(value: str) -> any:
    """Parse a string value to appropriate type."""
    # Try boolean
    if value == "true":
        return true
    if value == "false":
        return false

    # Try integer
    var is_int = true
    var has_dot = false
    for ch in value:
        if ch == ".":
            has_dot = true
            is_int = false
        elif ch < "0" or ch > "9":
            if ch != "-" or value.len() == 0:
                is_int = false

    if is_int and not has_dot:
        return _parse_int(value)

    # Try float
    if has_dot:
        return _parse_float(value)

    # Return as string
    return value

fn _parse_int(s: str) -> i64:
    """Parse string to integer."""
    var result: i64 = 0
    var negative = false
    var start = 0

    if s.len() > 0 and s.char_at(0) == "-":
        negative = true
        start = 1

    for i in start..s.len():
        val ch = s.char_at(i)
        if ch >= "0" and ch <= "9":
            result = result * 10 + (ch.ord() - 48)

    if negative:
        return 0 - result
    return result

fn _parse_float(s: str) -> f64:
    """Parse string to float."""
    var int_part: f64 = 0.0
    var dec_part: f64 = 0.0
    var negative = false
    var pos = 0

    if s.len() > 0 and s.char_at(0) == "-":
        negative = true
        pos = 1

    # Parse integer part
    while pos < s.len() and s.char_at(pos) != ".":
        val ch = s.char_at(pos)
        if ch >= "0" and ch <= "9":
            int_part = int_part * 10.0 + (ch.ord() - 48) as f64
        pos = pos + 1

    # Parse decimal part
    if pos < s.len() and s.char_at(pos) == ".":
        pos = pos + 1
        var decimal_place = 0.1
        while pos < s.len():
            val ch = s.char_at(pos)
            if ch >= "0" and ch <= "9":
                dec_part = dec_part + (ch.ord() - 48) as f64 * decimal_place
                decimal_place = decimal_place * 0.1
            pos = pos + 1

    val result = int_part + dec_part
    if negative:
        return -result
    return result


# ============================================================================
# Resolver System
# ============================================================================

# Global resolver registry
var _resolvers: any = {}

class ConfResolver:
    """Custom resolver for configuration interpolation.

    Resolvers handle ${resolver_name:args} patterns in config values.

    Example:
        ConfResolver.register("double", |args| -> any:
            val num = _parse_int(args)
            return num * 2
        )
        # In config: ${double:21} -> 42
    """

    static me register(name: str, handler: fn(str) -> any):
        """Register a custom resolver.

        Args:
            name: Resolver name (used as ${name:args})
            handler: Function that takes args string and returns resolved value

        Example:
            ConfResolver.register("upper", |s| s.to_upper())
        """
        _resolvers[name] = handler

    static fn resolve(name: str, args: str) -> any:
        """Resolve a value using a registered resolver.

        Args:
            name: Resolver name
            args: Arguments to pass to resolver

        Returns:
            Resolved value, or original string if resolver not found
        """
        if name in _resolvers:
            val handler = _resolvers[name]
            return handler(args)
        return "${" + name + ":" + args + "}"

    static fn has(name: str) -> bool:
        """Check if a resolver is registered."""
        return name in _resolvers


# ============================================================================
# Built-in Resolvers
# ============================================================================

fn _init_builtin_resolvers():
    """Initialize built-in resolvers."""

    # Environment variable resolver: ${env:VAR_NAME}
    ConfResolver.register("env", |name| -> any:
        # Placeholder - would use sys.get_env(name) when available
        return ""
    )

    # Path join resolver: ${path.join:a,b,c}
    ConfResolver.register("path.join", |args| -> any:
        val parts = args.split(",")
        var result = ""
        for i in 0..parts.len():
            if i > 0:
                result = result + "/"
            result = result + parts[i].trim()
        return result
    )

    # Current time resolver: ${time.now:%Y%m%d}
    ConfResolver.register("time.now", |format| -> any:
        # Placeholder - would use datetime formatting when available
        return "20260118"
    )

    # CPU count resolver: ${sys.cpu_count}
    ConfResolver.register("sys.cpu_count", |_| -> any:
        # Placeholder - would use sys.cpu_count() when available
        return 8
    )

    # Math floor resolver: ${math.floor:3.7}
    ConfResolver.register("math.floor", |args| -> any:
        val num = _parse_float(args)
        return num as i64
    )

    # Math ceil resolver: ${math.ceil:3.2}
    ConfResolver.register("math.ceil", |args| -> any:
        val num = _parse_float(args)
        val floor_val = num as i64
        if num > floor_val as f64:
            return floor_val + 1
        return floor_val
    )

# Initialize built-in resolvers on module load
_init_builtin_resolvers()


# ============================================================================
# Interpolation
# ============================================================================

fn _interpolate_value(value: any, config: any) -> any:
    """Interpolate ${...} references in a value.

    Supports:
    - ${path.to.var} - Reference another config value
    - ${resolver:args} - Call a registered resolver

    Args:
        value: Value to interpolate
        config: Full config dict for variable references

    Returns:
        Interpolated value
    """
    if not (value is str):
        return value

    var result = value
    var pos = 0

    while pos < result.len():
        # Find ${
        val start = _find_substr(result, "${", pos)
        if start < 0:
            break

        # Find matching }
        val end = _find_char(result, "}", start + 2)
        if end < 0:
            break

        # Extract expression
        val expr = result.substr(start + 2, end)

        # Resolve the expression
        val resolved = _resolve_expr(expr, config)

        # Replace in result
        val before = result.substr(0, start)
        val after = result.substr(end + 1, result.len())
        result = before + _to_string(resolved) + after

        pos = start + _to_string(resolved).len()

    return result

fn _resolve_expr(expr: str, config: any) -> any:
    """Resolve a single interpolation expression.

    Args:
        expr: Expression like "path.to.var" or "resolver:args"
        config: Full config dict

    Returns:
        Resolved value
    """
    # Check for resolver syntax: name:args
    val colon_pos = _find_char(expr, ":", 0)
    if colon_pos > 0:
        val resolver_name = expr.substr(0, colon_pos)
        val args = expr.substr(colon_pos + 1, expr.len())

        # First interpolate args (for nested references)
        val interp_args = _interpolate_value(args, config)

        if ConfResolver.has(resolver_name):
            return ConfResolver.resolve(resolver_name, _to_string(interp_args))

    # Otherwise, treat as config path reference
    return _get_nested(config, expr)

fn _get_nested(data: any, key: str) -> any:
    """Get a nested value from a dictionary."""
    val parts = key.split(".")
    var current = data

    for part in parts:
        if current is dict:
            if part in current:
                current = current[part]
            else:
                return ""
        else:
            return ""

    return current

fn _find_substr(s: str, needle: str, start: i64) -> i64:
    """Find substring position, returns -1 if not found."""
    for i in start..(s.len() - needle.len() + 1):
        var found = true
        for j in 0..needle.len():
            if s.char_at(i + j) != needle.char_at(j):
                found = false
                break
        if found:
            return i
    return -1

fn _find_char(s: str, ch: str, start: i64) -> i64:
    """Find character position, returns -1 if not found."""
    for i in start..s.len():
        if s.char_at(i) == ch:
            return i
    return -1

fn _to_string(value: any) -> str:
    """Convert any value to string."""
    if value is str:
        return value
    if value is i64:
        return "{value}"
    if value is f64:
        return "{value}"
    if value is bool:
        if value:
            return "true"
        return "false"
    return ""

fn _interpolate_all(data: any, root: any) -> any:
    """Recursively interpolate all values in a config."""
    if data is dict:
        var result = {}
        for key in data.keys():
            result[key] = _interpolate_all(data[key], root)
        return result
    if data is list:
        var result = []
        for item in data:
            result = result.push(_interpolate_all(item, root))
        return result
    return _interpolate_value(data, root)


# ============================================================================
# Schema Validation
# ============================================================================

class ConfError:
    """Configuration validation error."""
    path: str
    message: str

    fn __init__(path: str, message: str):
        self.path = path
        self.message = message

    fn to_string() -> str:
        """Format error message."""
        return "error at {self.path}: {self.message}"


class ConfSchema:
    """Schema definition for configuration validation.

    Defines expected structure, types, and constraints.

    Example:
        val schema = ConfSchema.new()
            .field("model.hidden_size", "int", required=true)
            .field("training.lr", "float", required=true)
            .field("training.epochs", "int", default_val=10)
    """
    _fields: any  # Dict of field definitions

    fn __init__():
        self._fields = {}

    static fn new() -> ConfSchema:
        """Create a new schema."""
        return ConfSchema()

    me field(path: str, type_name: str, required: bool = false, default_val: any = nil) -> ConfSchema:
        """Define a field in the schema.

        Args:
            path: Dot-notation path to field
            type_name: Expected type ("int", "float", "str", "bool", "list", "dict")
            required: Whether field is required
            default_val: Default value if not provided

        Returns:
            Self for chaining
        """
        self._fields[path] = {
            "type": type_name,
            "required": required,
            "default": default_val
        }
        return self

    fn validate(config: Conf) -> any:
        """Validate a configuration against this schema.

        Args:
            config: Configuration to validate

        Returns:
            List of ConfError, empty if valid
        """
        var errors = []

        for path in self._fields.keys():
            val field_def = self._fields[path]
            val value = config.get(path)

            if value.is_empty():
                if field_def["required"]:
                    errors = errors.push(ConfError(path, "required field missing"))
            else:
                val type_name = field_def["type"]
                val raw = value.raw()

                if not _check_type(raw, type_name):
                    errors = errors.push(ConfError(path,
                        "expected {type_name}, got " + _type_of(raw)))

        return errors

    fn apply_defaults(config: Conf) -> Conf:
        """Apply default values to missing fields.

        Args:
            config: Configuration to apply defaults to

        Returns:
            New configuration with defaults applied
        """
        var data = config.to_dict()

        for path in self._fields.keys():
            val field_def = self._fields[path]
            val current = config.get(path)

            if current.is_empty() and field_def["default"] != nil:
                _set_nested(data, path, field_def["default"])

        return Conf.from_dict(data)


fn _check_type(value: any, type_name: str) -> bool:
    """Check if value matches expected type."""
    if type_name == "int":
        return value is i64 or value is i32
    if type_name == "float":
        return value is f64 or value is f32 or value is i64 or value is i32
    if type_name == "str":
        return value is str
    if type_name == "bool":
        return value is bool
    if type_name == "list":
        return value is list
    if type_name == "dict":
        return value is dict
    return true

fn _type_of(value: any) -> str:
    """Get type name of value."""
    if value is i64 or value is i32:
        return "int"
    if value is f64 or value is f32:
        return "float"
    if value is str:
        return "str"
    if value is bool:
        return "bool"
    if value is list:
        return "list"
    if value is dict:
        return "dict"
    return "unknown"
