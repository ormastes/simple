# Tensor Factory Functions
#
# Convenience functions for creating tensors.

export from_data, zeros, ones, randn, arange, stack, select, zeros_like

import tensor_class.{Tensor}
import dtype.{DType, dtype_code}
import device.{Device, device_code}


# ============================================================================
# Factory Functions
# ============================================================================

fn from_data(data: [[f64]], dtype: DType = DType::Float64, device: Device = Device::CPU) -> Tensor:
    """Create tensor from nested list data.

    Args:
        data: Nested list of f32 values (2D array)
        dtype: Data type (default: Float64)
        device: Device to create tensor on (default: CPU)

    Returns:
        New tensor with data from nested list

    Example:
        ```simple
        val A = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
        print(A.shape())  # [2, 2]
        ```

    Note:
        Currently only supports 2D tensors (nested lists).
        Use zeros/ones/randn for higher dimensions.
    """
    # Flatten data and compute shape
    val rows = data.len()
    if rows == 0:
        panic("Cannot create tensor from empty data")

    val cols = data[0].len()
    var flat_data: [f64] = []

    for row in data:
        if row.len() != cols:
            panic("All rows must have the same length")
        for val in row:
            flat_data.append(val)

    # Create shape array
    val shape: [i64] = [rows as i64, cols as i64]

    # Call FFI to create tensor
    val handle = @rt_torch_tensor(
        flat_data.data_ptr(),
        flat_data.len() as i64,
        shape.data_ptr(),
        shape.len() as i32,
        dtype_code(dtype),
        device_code(device)
    )

    if handle == 0:
        panic("Failed to create tensor from data")

    return Tensor(handle)


fn zeros(shape: [i64], dtype: DType = DType::Float32, device: Device = Device::CPU) -> Tensor:
    """Create tensor filled with zeros.

    Args:
        shape: Tensor dimensions
        dtype: Data type (default: Float32)
        device: Device to create tensor on (default: CPU)

    Returns:
        New tensor filled with zeros
    """
    return Tensor::zeros(shape, dtype, device)


fn ones(shape: [i64], dtype: DType = DType::Float32, device: Device = Device::CPU) -> Tensor:
    """Create tensor filled with ones.

    Args:
        shape: Tensor dimensions
        dtype: Data type (default: Float32)
        device: Device to create tensor on (default: CPU)

    Returns:
        New tensor filled with ones
    """
    return Tensor::ones(shape, dtype, device)


fn randn(shape: [i64], dtype: DType = DType::Float32, device: Device = Device::CPU) -> Tensor:
    """Create tensor with random normal distribution.

    Args:
        shape: Tensor dimensions
        dtype: Data type (default: Float32)
        device: Device to create tensor on (default: CPU)

    Returns:
        New tensor with values from N(0, 1)
    """
    return Tensor::randn(shape, dtype, device)


fn arange(start: i64, end: i64, step: i64 = 1, dtype: DType = DType::Int64, device: Device = Device::CPU) -> Tensor:
    """Create 1D tensor with evenly spaced values.

    Args:
        start: Start value (inclusive)
        end: End value (exclusive)
        step: Step size (default: 1)
        dtype: Data type (default: Int64)
        device: Device to create tensor on (default: CPU)

    Returns:
        New 1D tensor with range [start, end)
    """
    return Tensor::arange(start, end, step, dtype, device)


fn stack(tensors: <Tensor>, dim: i64 = 0) -> Tensor:
    """Stack tensors along a new dimension.

    Concatenates tensors along a new dimension. All tensors must have the same shape.

    Args:
        tensors: List of tensors to stack
        dim: Dimension to stack along (default: 0)

    Returns:
        Stacked tensor with one additional dimension

    Example:
        ```simple
        val a = torch.tensor([[1, 2]])  # shape [1, 2]
        val b = torch.tensor([[3, 4]])  # shape [1, 2]
        val c = torch.tensor([[5, 6]])  # shape [1, 2]

        val stacked = torch.stack([a, b, c], dim=0)
        # Result shape: [3, 1, 2]
        # Result: [[[1, 2]], [[3, 4]], [[5, 6]]]
        ```

    Note:
        This is commonly used in DataLoader to batch individual samples.
    """
    if tensors.len() == 0:
        panic("Cannot stack empty list of tensors")

    # Get first tensor handle for FFI call
    var handles = []
    for t in tensors:
        handles.append(t.handle)

    # Call FFI to stack tensors
    val result_handle = @rt_torch_stack(
        handles.as_ptr(),
        handles.len() as i32,
        dim
    )

    if result_handle == 0:
        panic("Tensor stacking failed")

    return Tensor(result_handle)


fn select(condition: Tensor, a: Tensor, b: Tensor) -> Tensor:
    """Conditional selection from two tensors.

    Returns elements from `a` where condition is true (non-zero),
    otherwise returns elements from `b`.

    Args:
        condition: Boolean-like tensor (1.0 = true, 0.0 = false)
        a: Tensor to select from when condition is true
        b: Tensor to select from when condition is false

    Returns:
        Tensor with selected elements

    Example:
        ```simple
        val cond = torch.from_data([[1.0, 0.0, 1.0]])
        val a = torch.from_data([[10.0, 20.0, 30.0]])
        val b = torch.from_data([[1.0, 2.0, 3.0]])
        val result = torch.select(cond, a, b)
        # Result: [[10.0, 2.0, 30.0]]
        ```

    Note:
        This function was renamed from `where()` to avoid keyword conflict.
        PyTorch equivalent: torch.where(condition, a, b)
    """
    val result_handle = @rt_torch_where(
        condition.handle,
        a.handle,
        b.handle
    )

    if result_handle == 0:
        panic("Conditional selection failed")

    return Tensor(result_handle)


fn zeros_like(tensor: Tensor, dtype: DType = None, device: Device = None) -> Tensor:
    """Create tensor of zeros with same shape as input.

    Args:
        tensor: Tensor whose shape to match
        dtype: Data type (default: same as input)
        device: Device (default: same as input)

    Returns:
        Tensor filled with zeros

    Example:
        ```simple
        val x = torch.from_data([[1.0, 2.0], [3.0, 4.0]])
        val zeros = torch.zeros_like(x)
        # Result: [[0.0, 0.0], [0.0, 0.0]]
        ```
    """
    val shape = tensor.shape()
    val target_dtype = dtype if dtype != None else tensor.dtype()
    val target_device = device if device != None else tensor.device()

    return zeros(shape, target_dtype, target_device)


# ============================================================================
# External FFI Functions
# ============================================================================

extern fn rt_torch_tensor(
    data_ptr: *f64,
    data_len: i64,
    shape_ptr: *i64,
    shape_len: i32,
    dtype_code: i32,
    device_code: i32
) -> u64

extern fn rt_torch_stack(handles: *u64, count: i32, dim: i64) -> u64
extern fn rt_torch_where(cond: u64, a: u64, b: u64) -> u64
