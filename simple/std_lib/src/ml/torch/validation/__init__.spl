# Runtime Validation System
#
# Comprehensive runtime validation with three modes:
# - check_only: Validate all logic paths without training
# - train_only: Skip validation, train normally
# - check_and_train: Validate then train if passed
#
# ## Features
# - Memory validation (model + activation memory)
# - Shape validation (tensor dimensions through model)
# - Gradient flow validation (detect dead layers, NaN/Inf)
# - Numeric stability (NaN/Inf in outputs/loss)
# - Device placement (model/data consistency)
# - DataLoader validation (iteration tests)
# - Optimizer validation (parameter tracking)
# - Training loop validation (mini-epochs)
#
# ## Example
# ```simple
# import ml.torch.validation.{RuntimeValidator, ValidationMode}
#
# val validator = RuntimeValidator(ValidationMode.CheckAndTrain)
# val report = validator.validate_all(model, dataloader, optimizer, loss_fn)
# report.print()
#
# if report.has_errors():
#     sys.exit(1)
#
# # Proceed with training
# train(model, dataloader)
# ```

export RuntimeValidator, ValidationMode, ValidationReport, ValidationSection


# ============================================================================
# Enums
# ============================================================================

# Validation execution mode:
# - CheckOnly: Run checks, no training
# - TrainOnly: Skip checks, train normally
# - CheckAndTrain: Run checks then train
enum ValidationMode:
    CheckOnly
    TrainOnly
    CheckAndTrain

impl ValidationMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_check_only() -> bool:
        """Check if this is CheckOnly mode.

        Returns:
            true for CheckOnly

        Example:
            ValidationMode::CheckOnly.is_check_only()  # → true
        """
        match self:
            case CheckOnly: true
            case _: false

    fn is_train_only() -> bool:
        """Check if this is TrainOnly mode.

        Returns:
            true for TrainOnly

        Example:
            ValidationMode::TrainOnly.is_train_only()  # → true
        """
        match self:
            case TrainOnly: true
            case _: false

    fn is_check_and_train() -> bool:
        """Check if this is CheckAndTrain mode.

        Returns:
            true for CheckAndTrain

        Example:
            ValidationMode::CheckAndTrain.is_check_and_train()  # → true
        """
        match self:
            case CheckAndTrain: true
            case _: false

    fn runs_validation() -> bool:
        """Check if mode runs validation checks.

        Returns:
            true for CheckOnly and CheckAndTrain

        Example:
            ValidationMode::CheckOnly.runs_validation()  # → true
            ValidationMode::TrainOnly.runs_validation()  # → false
        """
        match self:
            case CheckOnly: true
            case CheckAndTrain: true
            case TrainOnly: false

    fn runs_training() -> bool:
        """Check if mode runs training.

        Returns:
            true for TrainOnly and CheckAndTrain

        Example:
            ValidationMode::TrainOnly.runs_training()  # → true
            ValidationMode::CheckOnly.runs_training()  # → false
        """
        match self:
            case TrainOnly: true
            case CheckAndTrain: true
            case CheckOnly: false

    fn stops_on_error() -> bool:
        """Check if mode stops training on validation error.

        Returns:
            true for CheckOnly and CheckAndTrain

        Example:
            ValidationMode::CheckAndTrain.stops_on_error()  # → true
        """
        match self:
            case CheckOnly: true
            case CheckAndTrain: true
            case TrainOnly: false

    fn to_string() -> text:
        """Convert mode to string.

        Returns:
            Mode name

        Example:
            ValidationMode::CheckOnly.to_string()  # → "check_only"
        """
        match self:
            case CheckOnly: "check_only"
            case TrainOnly: "train_only"
            case CheckAndTrain: "check_and_train"

    fn description() -> text:
        """Get mode description.

        Returns:
            Human-readable description

        Example:
            ValidationMode::CheckOnly.description()
            # → "Run checks, no training"
        """
        match self:
            case CheckOnly: "Run checks, no training"
            case TrainOnly: "Skip checks, train normally"
            case CheckAndTrain: "Run checks then train"

    fn summary() -> text:
        """Get summary of validation mode.

        Returns:
            Human-readable summary

        Example:
            ValidationMode::CheckAndTrain.summary()
            # → "ValidationMode: check_and_train (runs validation, runs training, stops on error)"
        """
        val name = self.to_string()
        val val = if self.runs_validation(): "runs validation" else: "no validation"
        val train = if self.runs_training(): "runs training" else: "no training"
        val stop = if self.stops_on_error(): "stops on error" else: "continues"
        return "ValidationMode: {name} ({val}, {train}, {stop})"


# ============================================================================
# Validation Section
# ============================================================================

class ValidationSection:
    """Single validation section (e.g., "Memory Validation").

    Attributes:
        name: Section name
        infos: Info messages
        warnings: Warning messages
        errors: Error messages
        passed: Whether section passed
    """
    name: str
    infos: [str]
    warnings: [str]
    errors: [str]
    passed: bool

    fn __init__(name: str):
        self.name = name
        self.infos = []
        self.warnings = []
        self.errors = []
        self.passed = false

    fn add_info(msg: str):
        """Add info message."""
        self.infos.append(msg)

    fn add_warning(msg: str):
        """Add warning message."""
        self.warnings.append(msg)

    fn add_error(msg: str):
        """Add error message."""
        self.errors.append(msg)

    fn add_pass(msg: str):
        """Mark section as passed."""
        self.passed = true
        self.infos.append("✓ {msg}")

    fn has_errors() -> bool:
        """Check if section has errors."""
        return self.errors.len() > 0


# ============================================================================
# Validation Report
# ============================================================================

class ValidationReport:
    """Validation report containing all sections.

    Attributes:
        sections: List of validation sections
        skipped: Whether validation was skipped
    """
    sections: <ValidationSection>
    skipped: bool

    fn __init__(skipped: bool):
        self.sections = []
        self.skipped = skipped

    fn add_section(section: ValidationSection):
        """Add validation section."""
        self.sections.append(section)

    fn has_errors() -> bool:
        """Check if any section has errors."""
        return any(s.has_errors() for s in self.sections)

    fn print():
        """Print validation report."""
        if self.skipped:
            print("Validation skipped (train_only mode)")
            return

        print("=" * 70)
        print("RUNTIME VALIDATION REPORT")
        print("=" * 70)

        for section in self.sections:
            print(f"\n{section.name}")
            print("-" * 70)

            for info in section.infos:
                print(f"  [INFO] {info}")

            for warning in section.warnings:
                print(f"  [WARN] {warning}")

            for error in section.errors:
                print(f"  [ERROR] {error}")

        print("\n" + "=" * 70)
        if self.has_errors():
            print("VALIDATION FAILED ❌")
        else:
            print("VALIDATION PASSED ✓")
        print("=" * 70)


# ============================================================================
# Runtime Validator
# ============================================================================

class RuntimeValidator:
    """Runtime validation system.

    Validates model, data, optimizer, and training loop before training.

    Example:
        ```simple
        val validator = RuntimeValidator(ValidationMode.CheckAndTrain)
        val report = validator.validate_all(
            model, train_loader, optimizer, loss_fn
        )

        if report.has_errors():
            print("Validation failed!")
            sys.exit(1)
        ```

    Attributes:
        mode: Validation mode
        checks_passed: Whether all checks passed
        errors: List of validation errors
    """
    mode: ValidationMode
    checks_passed: bool
    errors: [str]

    fn __init__(mode: ValidationMode):
        """Initialize validator.

        Args:
            mode: Validation mode (default: TrainOnly)
        """
        self.mode = mode
        self.checks_passed = false
        self.errors = []

    fn should_check() -> bool:
        """Check if validation should run."""
        return self.mode in <ValidationMode.CheckOnly, ValidationMode.CheckAndTrain>

    fn should_train() -> bool:
        """Check if training should run."""
        return self.mode in <ValidationMode.TrainOnly, ValidationMode.CheckAndTrain>

    fn validate_all(model: any,  # torch.nn.Module
        dataloader: any,  # DataLoader
        optimizer: any,  # Optimizer
        loss_fn: any  # Loss function
    ) -> ValidationReport:
        """Run all validation checks.

        Args:
            model: Model to validate
            dataloader: DataLoader to validate
            optimizer: Optimizer to validate
            loss_fn: Loss function

        Returns:
            Validation report

        Example:
            ```simple
            val report = validator.validate_all(
                model, train_loader, optimizer, loss_fn
            )
            report.print()
            ```
        """
        if not self.should_check():
            return ValidationReport(skipped=true)

        val report = ValidationReport()

        # 1. Memory validation
        report.add_section(self._check_memory(model, dataloader))

        # 2. Shape validation
        report.add_section(self._check_shapes(model, dataloader))

        # 3. Gradient flow
        report.add_section(self._check_gradients(model, dataloader, loss_fn))

        # 4. NaN/Inf detection
        report.add_section(self._check_numeric_stability(model, dataloader, loss_fn))

        # 5. Device placement
        report.add_section(self._check_devices(model, dataloader))

        # 6. Data pipeline
        report.add_section(self._check_dataloader(dataloader))

        # 7. Optimizer state
        report.add_section(self._check_optimizer(optimizer, model))

        # 8. Training loop
        report.add_section(self._check_training_loop(
            model, dataloader, optimizer, loss_fn
        ))

        self.checks_passed = not report.has_errors()
        self.errors = [for s in report.sections for e in s.errors: e]

        return report

    # ========================================================================
    # Validation Methods
    # ========================================================================

    fn _check_memory(model: any, dataloader: any) -> ValidationSection:
        """Validate memory usage.

        Checks:
        - Model parameter memory
        - Activation memory (forward pass)
        - GPU memory availability

        Args:
            model: Model to check
            dataloader: DataLoader for sample batch

        Returns:
            Validation section
        """
        val section = ValidationSection("Memory Validation")

        # Get model memory (TODO: implement)
        # val model_params = sum(p.numel() * p.element_size() for p in model.parameters())
        # section.add_info(f"Model parameters: {model_params / 1e6:.2f} MB")

        section.add_info("Memory validation: implementation pending")
        section.add_pass("Memory validation skipped (pending implementation)")

        return section

    fn _check_shapes(model: any, dataloader: any) -> ValidationSection:
        """Validate tensor shapes through the model.

        Checks:
        - Input shape
        - Output shape
        - Batch size consistency

        Args:
            model: Model to check
            dataloader: DataLoader for sample batch

        Returns:
            Validation section
        """
        val section = ValidationSection("Shape Validation")

        # TODO: [stdlib][P2] Implement shape checking
        section.add_info("Shape validation: implementation pending")
        section.add_pass("Shape validation skipped (pending implementation)")

        return section

    fn _check_gradients(model: any,
        dataloader: any,
        loss_fn: any
    ) -> ValidationSection:
        """Validate gradient flow.

        Checks:
        - All parameters have gradients
        - No NaN/Inf gradients
        - No zero gradients (potential dead layers)

        Args:
            model: Model to check
            dataloader: DataLoader for sample batch
            loss_fn: Loss function

        Returns:
            Validation section
        """
        val section = ValidationSection("Gradient Flow Validation")

        # TODO: [stdlib][P2] Implement gradient checking
        section.add_info("Gradient flow validation: implementation pending")
        section.add_pass("Gradient flow validation skipped (pending implementation)")

        return section

    fn _check_numeric_stability(model: any,
        dataloader: any,
        loss_fn: any
    ) -> ValidationSection:
        """Check for NaN/Inf in outputs and loss.

        Args:
            model: Model to check
            dataloader: DataLoader for sample batch
            loss_fn: Loss function

        Returns:
            Validation section
        """
        val section = ValidationSection("Numeric Stability Validation")

        # TODO: [stdlib][P2] Implement NaN/Inf checking
        section.add_info("Numeric stability validation: implementation pending")
        section.add_pass("Numeric stability validation skipped (pending implementation)")

        return section

    fn _check_devices(model: any, dataloader: any) -> ValidationSection:
        """Validate device placement.

        Checks:
        - Model device
        - Data device
        - Consistency between model and data

        Args:
            model: Model to check
            dataloader: DataLoader for sample batch

        Returns:
            Validation section
        """
        val section = ValidationSection("Device Validation")

        # TODO: [stdlib][P2] Implement device checking
        section.add_info("Device validation: implementation pending")
        section.add_pass("Device validation skipped (pending implementation)")

        return section

    fn _check_dataloader(dataloader: any) -> ValidationSection:
        """Validate data pipeline.

        Checks:
        - DataLoader can iterate
        - Batches are produced correctly
        - No errors during iteration

        Args:
            dataloader: DataLoader to check

        Returns:
            Validation section
        """
        val section = ValidationSection("DataLoader Validation")

        # TODO: [stdlib][P2] Implement dataloader checking
        section.add_info("DataLoader validation: implementation pending")
        section.add_pass("DataLoader validation skipped (pending implementation)")

        return section

    fn _check_optimizer(optimizer: any, model: any) -> ValidationSection:
        """Validate optimizer configuration.

        Checks:
        - Optimizer has parameters
        - Parameter count matches model
        - Learning rate is reasonable

        Args:
            optimizer: Optimizer to check
            model: Model

        Returns:
            Validation section
        """
        val section = ValidationSection("Optimizer Validation")

        # TODO: [stdlib][P2] Implement optimizer checking
        section.add_info("Optimizer validation: implementation pending")
        section.add_pass("Optimizer validation skipped (pending implementation)")

        return section

    fn _check_training_loop(model: any,
        dataloader: any,
        optimizer: any,
        loss_fn: any
    ) -> ValidationSection:
        """Run mini training loop to validate all logic paths.

        Runs 2-3 mini-epochs with 2 batches each to ensure:
        - Forward pass works
        - Backward pass works
        - Optimizer step works
        - No runtime errors

        Args:
            model: Model to check
            dataloader: DataLoader
            optimizer: Optimizer
            loss_fn: Loss function

        Returns:
            Validation section
        """
        val section = ValidationSection("Training Loop Validation")

        # TODO: [stdlib][P2] Implement training loop validation
        section.add_info("Training loop validation: implementation pending")
        section.add_pass("Training loop validation skipped (pending implementation)")

        return section
