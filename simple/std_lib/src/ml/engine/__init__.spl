# Training Engine
#
# Event-driven training loops inspired by PyTorch Ignite.
# Eliminates boilerplate while maintaining flexibility.
#
# ## Features
# - Generic Engine for any training/evaluation process
# - Event system (STARTED, EPOCH_COMPLETED, etc.)
# - Periodic events (every=N, once=N)
# - Custom events
# - Reusable handlers (Checkpoint, EarlyStopping)
# - Metrics computation
#
# ## Example
# ```simple
# import ml.engine.{Engine, Events}
#
# fn train_step(engine: Engine, batch: any):
#     model.train()
#     x, y = batch
#     pred = model(x)
#     loss = loss_fn(pred, y)
#     loss.backward()
#     optimizer.step()
#     return {"loss": loss.item()}
#
# val trainer = Engine(train_step)
#
# @trainer.on(EPOCH_COMPLETED)
# fn log_metrics(engine: Engine):
#     print(f"Epoch {engine.state.epoch}: loss={engine.state.output.loss}")
#
# trainer.run(train_loader, max_epochs=10)
# ```

export Engine, State, Metric, Loss, Accuracy, MSE, MAE, RMSE
export ITERATION_COMPLETED_EVERY, EPOCH_COMPLETED_EVERY
export STARTED, EPOCH_STARTED, ITERATION_STARTED, ITERATION_COMPLETED
export EPOCH_COMPLETED, COMPLETED, EXCEPTION_RAISED


# ============================================================================
# Events - Built-in engine events
# ============================================================================

# Events fired during engine execution:
# - STARTED: Engine started
# - EPOCH_STARTED: Epoch started
# - ITERATION_STARTED: Before batch processing
# - ITERATION_COMPLETED: After batch processing
# - EPOCH_COMPLETED: Epoch completed
# - COMPLETED: Engine completed all epochs
# - EXCEPTION_RAISED: Exception during execution

val STARTED: str = "started"
val EPOCH_STARTED: str = "epoch_started"
val ITERATION_STARTED: str = "iteration_started"
val ITERATION_COMPLETED: str = "iteration_completed"
val EPOCH_COMPLETED: str = "epoch_completed"
val COMPLETED: str = "completed"
val EXCEPTION_RAISED: str = "exception_raised"


fn ITERATION_COMPLETED_EVERY(n: i64) -> str:
    """Create periodic event (every N iterations).

    Args:
        n: Iteration frequency

    Returns:
        Event name
    """
    return f"iteration_completed_every_{n}"


fn EPOCH_COMPLETED_EVERY(n: i64) -> str:
    """Create periodic event (every N epochs).

    Args:
        n: Epoch frequency

    Returns:
        Event name
    """
    return f"epoch_completed_every_{n}"


# ============================================================================
# State Class
# ============================================================================

class State:
    """Engine state.

    Tracks current progress and output during execution.

    Attributes:
        epoch: Current epoch (0-indexed)
        iteration: Global iteration counter
        epoch_iteration: Iteration within current epoch
        max_epochs: Total epochs to run
        output: Return value of process function
        metrics: Computed metrics dict
        dataloader: Current dataloader
        batch: Current batch
    """
    epoch: i64
    iteration: i64
    epoch_iteration: i64
    max_epochs: i64
    output: any
    metrics: any
    dataloader: any
    batch: any

    static fn new() -> State:
        """Create new state instance."""
        return State {
            epoch: 0,
            iteration: 0,
            epoch_iteration: 0,
            max_epochs: 0,
            output: 0,
            metrics: {},
            dataloader: 0,
            batch: 0
        }


# ============================================================================
# Metric Base Class
# ============================================================================

class Metric:
    """Base class for metrics.

    Subclasses must implement reset(), update(), and compute().

    Example:
        ```simple
        class Accuracy(Metric):
            static fn new():
                self.correct = 0
                self.total = 0

            fn reset():
                self.correct = 0
                self.total = 0

            fn update(output: any):
                pred, labels = output
                self.correct += (pred == labels).sum()
                self.total += labels.len()

            fn compute() -> f64:
                return self.correct / self.total
        ```
    """

    fn reset():
        """Reset metric state for new epoch."""
        return

    fn update(output: any):
        """Update metric with batch output.

        Args:
            output: Process function output
        """
        return

    fn compute() -> f64:
        """Compute final metric value.

        Returns:
            Metric value
        """
        return 0.0


# ============================================================================
# Engine Class
# ============================================================================

class Engine:
    """Generic training/evaluation engine.

    Executes a process function on each batch and fires events.

    Example:
        ```simple
        fn train_step(engine: Engine, batch: any):
            # Training logic here
            return {"loss": loss.item()}

        val trainer = Engine(train_step)

        @trainer.on(ITERATION_COMPLETED)
        fn log(engine):
            print(f"Step {engine.state.iteration}")

        trainer.run(dataloader, max_epochs=10)
        ```

    Attributes:
        process_function: Function to execute per batch
        state: Engine state
        _event_handlers: Event handlers dict
        _metrics: Metrics dict
        _should_terminate: Termination flag
    """
    process_function: any
    state: State
    _event_handlers: any
    _metrics: any
    _should_terminate: bool

    fn __init__(process_function: any):
        """Initialize engine.

        Args:
            process_function: Function(engine, batch) -> output
        """
        self.process_function = process_function
        self.state = State()
        self._event_handlers = {}
        self._metrics = {}
        self._should_terminate = false

    fn attach_handler(event: str, handler: any, priority: i32):
        """Attach event handler.

        Args:
            event: Event name
            handler: Handler function(engine)
            priority: Priority (higher = earlier)

        Example:
            ```simple
            trainer.attach_handler(EPOCH_COMPLETED, log_epoch, 0)
            ```
        """
        if not (event in self._event_handlers):
            self._event_handlers[event] = []

        # Add handler with priority
        self._event_handlers[event].append((priority, handler))

        # TODO: Sort by priority (descending) - lambda not supported yet
        # self._event_handlers[event].sort(key=lambda h: -h[0])

    fn fire_event(event: str):
        """Fire event and execute handlers.

        Args:
            event: Event name
        """
        if event in self._event_handlers:
            for (priority, handler) in self._event_handlers[event]:
                handler(self)

    fn add_metric(metric: Metric, name: str):
        """Add metric to engine.

        Args:
            metric: Metric instance
            name: Metric name
        """
        self._metrics[name] = metric

    fn add_metrics(metrics: any):
        """Add multiple metrics.

        Args:
            metrics: Dict of name -> metric
        """
        for (name, metric) in metrics.items():
            self.add_metric(metric, name)

    fn run(data: any, max_epochs: i64):
        """Run engine on data.

        Args:
            data: Iterable dataloader
            max_epochs: Number of epochs to run

        Example:
            ```simple
            trainer.run(train_loader, max_epochs=10)
            ```
        """
        self.state.max_epochs = max_epochs
        self.state.dataloader = data

        # Fire STARTED event
        self.fire_event(STARTED)

        try:
            for epoch in range(max_epochs):
                if self._should_terminate:
                    break

                self.state.epoch = epoch
                self.state.epoch_iteration = 0

                # Reset metrics for new epoch
                for metric in self._metrics.values():
                    metric.reset()

                # Fire EPOCH_STARTED event
                self.fire_event(EPOCH_STARTED)

                # Iterate over data
                for batch in data:
                    if self._should_terminate:
                        break

                    self.state.batch = batch
                    self.state.epoch_iteration += 1
                    self.state.iteration += 1

                    # Fire ITERATION_STARTED event
                    self.fire_event(ITERATION_STARTED)

                    # Execute process function
                    self.state.output = self.process_function(self, batch)

                    # Update metrics
                    for metric in self._metrics.values():
                        metric.update(self.state.output)

                    # Fire ITERATION_COMPLETED event
                    self.fire_event(ITERATION_COMPLETED)

                    # Fire periodic events
                    self._fire_periodic_events()

                # Compute final metrics for epoch
                for (name, metric) in self._metrics.items():
                    self.state.metrics[name] = metric.compute()

                # Fire EPOCH_COMPLETED event
                self.fire_event(EPOCH_COMPLETED)

                # Fire periodic epoch events
                self._fire_periodic_epoch_events()

        except Exception as e:
            # Fire EXCEPTION_RAISED event
            self.fire_event(EXCEPTION_RAISED)
            raise e

        # Fire COMPLETED event
        self.fire_event(COMPLETED)

    fn terminate():
        """Terminate engine execution."""
        self._should_terminate = true

    # ========================================================================
    # Helper Methods
    # ========================================================================

    fn _fire_periodic_events():
        """Fire periodic iteration events."""
        # Check for every_N events
        for event_name in self._event_handlers.keys():
            if event_name.startswith("iteration_completed_every_"):
                # Extract N from event name
                val parts = event_name.split("_")
                val n = i32(parts[-1])

                if self.state.iteration % n == 0:
                    self.fire_event(event_name)

    fn _fire_periodic_epoch_events():
        """Fire periodic epoch events."""
        # Check for every_N events
        for event_name in self._event_handlers.keys():
            if event_name.startswith("epoch_completed_every_"):
                # Extract N from event name
                val parts = event_name.split("_")
                val n = i32(parts[-1])

                if (self.state.epoch + 1) % n == 0:
                    self.fire_event(event_name)


# ============================================================================
# Common Metrics
# ============================================================================

class Accuracy(Metric):
    """Accuracy metric for classification.

    Expects output to be dict with "pred" and "labels" keys, or tuple (pred, labels).
    Predictions and labels can be lists/arrays of class indices.

    Example:
        ```simple
        val accuracy = Accuracy()
        trainer.add_metric(accuracy, "acc")

        # Output format options:
        # 1. Dict: {"pred": [0, 1, 2], "labels": [0, 1, 1]}
        # 2. Tuple: ([0, 1, 2], [0, 1, 1])
        ```
    """
    correct: i64
    total: i64

    static fn new():
        """Initialize accuracy metric."""
        self.correct = 0
        self.total = 0

    fn reset():
        """Reset for new epoch."""
        self.correct = 0
        self.total = 0

    fn update(output: any):
        """Update with batch output.

        Args:
            output: Dict with "pred" and "labels" keys

        Supported formats:
            - Dict: {"pred": [0, 1, 2], "labels": [0, 1, 1]}
            - Dict: {"y_pred": [...], "y_true": [...]}
        """
        var pred = []
        var labels = []

        # Extract predictions and labels from output dict
        if "pred" in output and "labels" in output:
            pred = output["pred"]
            labels = output["labels"]
        elif "y_pred" in output and "y_true" in output:
            pred = output["y_pred"]
            labels = output["y_true"]

        # Compute matches
        if len(pred) > 0 and len(labels) > 0:
            val n = min(len(pred), len(labels))
            for i in range(n):
                self.total += 1
                if pred[i] == labels[i]:
                    self.correct += 1

    fn compute() -> f64:
        """Compute accuracy.

        Returns:
            Accuracy value in range [0.0, 1.0]
        """
        if self.total == 0:
            return 0.0
        return (self.correct.to_float()) / (self.total.to_float())


class Loss(Metric):
    """Average loss metric.

    Example:
        ```simple
        val loss_metric = Loss()
        trainer.add_metric(loss_metric, "loss")
        ```
    """
    total_loss: f64
    count: i64

    static fn new():
        """Initialize loss metric."""
        self.total_loss = 0.0
        self.count = 0

    fn reset():
        """Reset for new epoch."""
        self.total_loss = 0.0
        self.count = 0

    fn update(output: any):
        """Update with batch output.

        Args:
            output: Dict with "loss" key
        """
        # Check for dict with "loss" key
        if "loss" in output:
            self.total_loss += output["loss"]
            self.count += 1

    fn compute() -> f64:
        """Compute average loss.

        Returns:
            Average loss
        """
        if self.count == 0:
            return 0.0
        return self.total_loss / (self.count.to_float())


# ============================================================================
# Regression Metrics
# ============================================================================

class MSE(Metric):
    """Mean Squared Error metric for regression.

    Computes: (1/n) * sum((pred - actual)^2)

    Example:
        ```simple
        val mse = MSE()
        trainer.add_metric(mse, "mse")

        # Output format: {"pred": [1.0, 2.0], "actual": [1.1, 2.2]}
        ```
    """
    total_squared_error: f64
    count: i64

    static fn new():
        """Initialize MSE metric."""
        self.total_squared_error = 0.0
        self.count = 0

    fn reset():
        """Reset for new epoch."""
        self.total_squared_error = 0.0
        self.count = 0

    fn update(output: any):
        """Update with batch output.

        Args:
            output: Dict with "pred" and "actual" keys
        """
        var pred = []
        var actual = []

        # Extract predictions and actuals from output dict
        if "pred" in output and "actual" in output:
            pred = output["pred"]
            actual = output["actual"]
        elif "y_pred" in output and "y_true" in output:
            pred = output["y_pred"]
            actual = output["y_true"]

        # Compute squared errors
        if len(pred) > 0 and len(actual) > 0:
            val n = min(len(pred), len(actual))
            for i in range(n):
                val p = pred[i]
                val a = actual[i]
                val diff = p - a
                self.total_squared_error += diff * diff
                self.count += 1

    fn compute() -> f64:
        """Compute mean squared error.

        Returns:
            MSE value
        """
        if self.count == 0:
            return 0.0
        return self.total_squared_error / (self.count.to_float())


class MAE(Metric):
    """Mean Absolute Error metric for regression.

    Computes: (1/n) * sum(|pred - actual|)

    Example:
        ```simple
        val mae = MAE()
        trainer.add_metric(mae, "mae")

        # Output format: {"pred": [1.0, 2.0], "actual": [1.1, 2.2]}
        ```
    """
    total_absolute_error: f64
    count: i64

    static fn new():
        """Initialize MAE metric."""
        self.total_absolute_error = 0.0
        self.count = 0

    fn reset():
        """Reset for new epoch."""
        self.total_absolute_error = 0.0
        self.count = 0

    fn update(output: any):
        """Update with batch output.

        Args:
            output: Dict with "pred" and "actual" keys
        """
        var pred = []
        var actual = []

        # Extract predictions and actuals from output dict
        if "pred" in output and "actual" in output:
            pred = output["pred"]
            actual = output["actual"]
        elif "y_pred" in output and "y_true" in output:
            pred = output["y_pred"]
            actual = output["y_true"]

        # Compute absolute errors
        if len(pred) > 0 and len(actual) > 0:
            val n = min(len(pred), len(actual))
            for i in range(n):
                val p = pred[i]
                val a = actual[i]
                val diff = p - a
                self.total_absolute_error += abs(diff)
                self.count += 1

    fn compute() -> f64:
        """Compute mean absolute error.

        Returns:
            MAE value
        """
        if self.count == 0:
            return 0.0
        return self.total_absolute_error / (self.count.to_float())


class RMSE(Metric):
    """Root Mean Squared Error metric for regression.

    Computes: sqrt((1/n) * sum((pred - actual)^2))

    Example:
        ```simple
        val rmse = RMSE()
        trainer.add_metric(rmse, "rmse")
        ```
    """
    total_squared_error: f64
    count: i64

    static fn new():
        """Initialize RMSE metric."""
        self.total_squared_error = 0.0
        self.count = 0

    fn reset():
        """Reset for new epoch."""
        self.total_squared_error = 0.0
        self.count = 0

    fn update(output: any):
        """Update with batch output.

        Args:
            output: Dict with "pred" and "actual" keys
        """
        var pred = []
        var actual = []

        # Extract predictions and actuals from output dict
        if "pred" in output and "actual" in output:
            pred = output["pred"]
            actual = output["actual"]
        elif "y_pred" in output and "y_true" in output:
            pred = output["y_pred"]
            actual = output["y_true"]

        # Compute squared errors
        if len(pred) > 0 and len(actual) > 0:
            val n = min(len(pred), len(actual))
            for i in range(n):
                val p = pred[i]
                val a = actual[i]
                val diff = p - a
                self.total_squared_error += diff * diff
                self.count += 1

    fn compute() -> f64:
        """Compute root mean squared error.

        Returns:
            RMSE value
        """
        if self.count == 0:
            return 0.0
        val mse_val = self.total_squared_error / (self.count.to_float())
        return sqrt(mse_val)


# ============================================================================
# Helper Functions
# ============================================================================

fn abs(x: f64) -> f64:
    """Absolute value."""
    if x < 0.0:
        return -x
    return x


fn sqrt(x: f64) -> f64:
    """Square root using Newton's method."""
    if x <= 0.0:
        return 0.0
    var guess = x / 2.0
    for _ in range(20):  # Newton iterations
        guess = (guess + x / guess) / 2.0
    return guess


fn min(a: i64, b: i64) -> i64:
    """Minimum of two integers."""
    if a < b:
        return a
    return b
