/**
Synchronization Primitives

High-level synchronization for concurrent programming.

Features:
- Mutex: Mutual exclusion lock
- RwLock: Reader-writer lock
- Once: One-time initialization
- Lazy: Lazy initialization
- ThreadLocal: Thread-local storage

```sdoctest
>>> val mutex = Mutex.new([])
>>> mutex.lock(\list: list.push(42))
>>> mutex.lock(\list: list[0])
42
```
*/

# FFI declarations for synchronization primitives
extern fn rt_mutex_new() -> i64
extern fn rt_mutex_lock(mutex: i64)
extern fn rt_mutex_try_lock(mutex: i64) -> i64
extern fn rt_mutex_unlock(mutex: i64)
extern fn rt_mutex_free(mutex: i64)

extern fn rt_rwlock_new() -> i64
extern fn rt_rwlock_read(lock: i64)
extern fn rt_rwlock_try_read(lock: i64) -> i64
extern fn rt_rwlock_write(lock: i64)
extern fn rt_rwlock_try_write(lock: i64) -> i64
extern fn rt_rwlock_unlock_read(lock: i64)
extern fn rt_rwlock_unlock_write(lock: i64)
extern fn rt_rwlock_free(lock: i64)

extern fn rt_condvar_new() -> i64
extern fn rt_condvar_wait(cv: i64, mutex: i64)
extern fn rt_condvar_wait_timeout(cv: i64, mutex: i64, millis: i64) -> i64
extern fn rt_condvar_notify_one(cv: i64)
extern fn rt_condvar_notify_all(cv: i64)
extern fn rt_condvar_free(cv: i64)

extern fn rt_once_new() -> i64
extern fn rt_once_call(once: i64, func: i64) -> i64
extern fn rt_once_is_completed(once: i64) -> i64
extern fn rt_once_free(once: i64)

extern fn rt_thread_local_new() -> i64
extern fn rt_thread_local_get(tls: i64) -> i64
extern fn rt_thread_local_set(tls: i64, value: i64)
extern fn rt_thread_local_free(tls: i64)

/**
Mutex for mutual exclusion.

Provides exclusive access to protected data.
Only one thread can hold the lock at a time.

```sdoctest
>>> val data = Mutex.new(0)
>>> data.lock(\x: x + 1)
>>> data.lock(\x: x)
1
```
*/
struct Mutex[T]:
    _handle: i64
    _value: T

    /**
    Create a new mutex protecting a value.
    */
    fn new(value: T) -> Mutex[T]:
        val handle = rt_mutex_new()
        return Mutex(_handle: handle, _value: value)

    /**
    Lock the mutex and apply a function to the protected value.
    Returns the function's result.
    */
    fn lock[R](self, func: fn(T) -> R) -> R:
        rt_mutex_lock(self._handle)
        val result = func(self._value)
        rt_mutex_unlock(self._handle)
        return result

    /**
    Try to lock the mutex without blocking.
    Returns Some(result) if lock acquired, None otherwise.
    */
    fn try_lock[R](self, func: fn(T) -> R) -> Option[R]:
        if rt_mutex_try_lock(self._handle) == 1:
            val result = func(self._value)
            rt_mutex_unlock(self._handle)
            return Option.Some(result)
        return Option.None

    /**
    Lock and mutate the protected value.
    */
    fn with_lock(func: fn(T) -> T):
        rt_mutex_lock(self._handle)
        self._value = func(self._value)
        rt_mutex_unlock(self._handle)

    /**
    Get a copy of the protected value.
    */
    fn get() -> T:
        return self.lock(\x: x)

    /**
    Set the protected value.
    */
    fn set(value: T):
        self.with_lock(\x: value)

    /**
    Free the mutex.
    */
    fn free():
        rt_mutex_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn summary() -> String:
        """Get summary of mutex.

        Returns:
            Human-readable summary

        Example:
            mutex.summary()
            # → "Mutex[T]"
        """
        return "Mutex[T]"

/**
Reader-writer lock.

Allows multiple concurrent readers or one exclusive writer.
Ideal for read-heavy workloads.

```sdoctest
>>> val data = RwLock.new(Map.new())
>>> data.read(\m: m.get("key"))  # Multiple readers OK
>>> data.write(\m: m.insert("key", 42))  # Exclusive write
```
*/
struct RwLock[T]:
    _handle: i64
    _value: T

    fn new(value: T) -> RwLock[T]:
        val handle = rt_rwlock_new()
        return RwLock(_handle: handle, _value: value)

    /**
    Acquire read lock and apply function.
    Multiple readers can hold the lock simultaneously.
    */
    fn read[R](self, func: fn(T) -> R) -> R:
        rt_rwlock_read(self._handle)
        val result = func(self._value)
        rt_rwlock_unlock_read(self._handle)
        return result

    /**
    Try to acquire read lock without blocking.
    */
    fn try_read[R](self, func: fn(T) -> R) -> Option[R]:
        if rt_rwlock_try_read(self._handle) == 1:
            val result = func(self._value)
            rt_rwlock_unlock_read(self._handle)
            return Option.Some(result)
        return Option.None

    /**
    Acquire write lock and apply function.
    Exclusive access - no other readers or writers.
    */
    fn write[R](self, func: fn(T) -> R) -> R:
        rt_rwlock_write(self._handle)
        val result = func(self._value)
        rt_rwlock_unlock_write(self._handle)
        return result

    /**
    Try to acquire write lock without blocking.
    */
    fn try_write[R](self, func: fn(T) -> R) -> Option[R]:
        if rt_rwlock_try_write(self._handle) == 1:
            val result = func(self._value)
            rt_rwlock_unlock_write(self._handle)
            return Option.Some(result)
        return Option.None

    /**
    Write lock and mutate.
    */
    fn with_write(func: fn(T) -> T):
        rt_rwlock_write(self._handle)
        self._value = func(self._value)
        rt_rwlock_unlock_write(self._handle)

    /**
    Get value (read lock).
    */
    fn get() -> T:
        return self.read(\x: x)

    /**
    Set value (write lock).
    */
    fn set(value: T):
        self.with_write(\x: value)

    fn free():
        rt_rwlock_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn summary() -> String:
        """Get summary of reader-writer lock.

        Returns:
            Human-readable summary

        Example:
            rwlock.summary()
            # → "RwLock[T]"
        """
        return "RwLock[T]"

/**
Condition variable for thread signaling.

Used with a mutex to wait for conditions.

```sdoctest
>>> val mutex = Mutex.new(false)
>>> val cv = CondVar.new()
>>> # Thread 1: Wait for condition
>>> mutex.lock(\ready:
...     while not ready:
...         cv.wait(mutex)
... )
>>> # Thread 2: Signal condition
>>> mutex.with_lock(\ready: true)
>>> cv.notify_one()
```
*/
struct CondVar:
    _handle: i64

    static fn new() -> CondVar:
        val handle = rt_condvar_new()
        return CondVar(_handle: handle)

    /**
    Wait on the condition variable.
    Must be called while holding the mutex lock.
    Releases the mutex while waiting and reacquires on wake.
    */
    fn wait(mutex: Mutex[Any]):
        rt_condvar_wait(self._handle, mutex._handle)

    /**
    Wait with timeout.
    Returns true if signaled, false if timed out.
    */
    fn wait_timeout(mutex: Mutex[Any], millis: i64) -> Bool:
        return rt_condvar_wait_timeout(self._handle, mutex._handle, millis) == 1

    /**
    Wake one waiting thread.
    */
    fn notify_one():
        rt_condvar_notify_one(self._handle)

    /**
    Wake all waiting threads.
    */
    fn notify_all():
        rt_condvar_notify_all(self._handle)

    fn free():
        rt_condvar_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn summary() -> String:
        """Get summary of condition variable.

        Returns:
            Human-readable summary

        Example:
            cv.summary()
            # → "CondVar"
        """
        return "CondVar"

/**
Once - one-time initialization.

Ensures a function is called exactly once.

```sdoctest
>>> val once = Once.new()
>>> val called = 0
>>> once.call(\: called = called + 1)
>>> once.call(\: called = called + 1)
>>> called
1
```
*/
struct Once:
    _handle: i64
    _completed: Bool

    static fn new() -> Once:
        val handle = rt_once_new()
        return Once(_handle: handle, _completed: false)

    /**
    Call the function exactly once.
    Subsequent calls are no-ops.
    */
    fn call(func: fn()):
        if not self._completed:
            rt_once_call(self._handle, func as i64)
            self._completed = true

    /**
    Call with result.
    Returns the result from the first call.
    */
    fn call_once[T](self, func: fn() -> T, default: T) -> T:
        if not self._completed:
            val result = func()
            self._completed = true
            return result
        return default

    /**
    Check if already called.
    */
    fn is_completed() -> Bool:
        return self._completed or rt_once_is_completed(self._handle) == 1

    fn free():
        rt_once_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_pending() -> Bool:
        """Check if not yet called."""
        return not self.is_completed()

    fn summary() -> String:
        """Get summary of once.

        Returns:
            Human-readable summary

        Example:
            once.summary()
            # → "Once: completed" or "Once: pending"
        """
        val status = if self.is_completed(): "completed" else: "pending"
        return "Once: {status}"

/**
Lazy - lazy initialization.

Defers initialization until first access.

```sdoctest
>>> val lazy = Lazy.new(\: expensive_computation())
>>> # Value not computed yet
>>> lazy.get()  # Computes on first access
>>> lazy.get()  # Returns cached value
```
*/
struct Lazy[T]:
    _init: fn() -> T
    _value: Option[T]
    _once: Once

    fn new(init: fn() -> T) -> Lazy[T]:
        return Lazy(
            _init: init,
            _value: Option.None,
            _once: Once.new()
        )

    /**
    Get the value, initializing if necessary.
    */
    fn get() -> T:
        if self._value.is_none():
            self._once.call(\:
                self._value = Option.Some(self._init())
            )
        return self._value.unwrap()

    /**
    Check if value has been initialized.
    */
    fn is_initialized() -> Bool:
        return self._value.is_some()

    /**
    Force initialization.
    */
    fn force() -> T:
        return self.get()

    fn free():
        self._once.free()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_uninitialized() -> Bool:
        """Check if not yet initialized."""
        return not self.is_initialized()

    fn summary() -> String:
        """Get summary of lazy value.

        Returns:
            Human-readable summary

        Example:
            lazy.summary()
            # → "Lazy[T]: initialized" or "Lazy[T]: uninitialized"
        """
        val status = if self.is_initialized(): "initialized" else: "uninitialized"
        return "Lazy[T]: {status}"

/**
Thread-local storage.

Each thread gets its own copy of the value.

```sdoctest
>>> val tls = ThreadLocal.new(\: Buffer.new(1024))
>>> val buf = tls.get()  # Per-thread buffer
```
*/
struct ThreadLocal[T]:
    _handle: i64
    _init: fn() -> T

    fn new(init: fn() -> T) -> ThreadLocal[T]:
        val handle = rt_thread_local_new()
        return ThreadLocal(_handle: handle, _init: init)

    /**
    Get this thread's value, initializing if needed.
    */
    fn get() -> T:
        val ptr = rt_thread_local_get(self._handle)
        if ptr == 0:
            val value = self._init()
            rt_thread_local_set(self._handle, value as i64)
            return value
        return ptr as T

    /**
    Set this thread's value.
    */
    fn set(value: T):
        rt_thread_local_set(self._handle, value as i64)

    /**
    Apply function to thread-local value.
    */
    fn with[R](self, func: fn(T) -> R) -> R:
        return func(self.get())

    fn free():
        rt_thread_local_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn summary() -> String:
        """Get summary of thread-local storage.

        Returns:
            Human-readable summary

        Example:
            tls.summary()
            # → "ThreadLocal[T]"
        """
        return "ThreadLocal[T]"

/**
Barrier for thread synchronization.

All threads must reach the barrier before any proceed.

```sdoctest
>>> val barrier = Barrier.new(4)
>>> # In each of 4 threads:
>>> barrier.wait()  # Blocks until all 4 arrive
```
*/
struct Barrier:
    _count: i64
    _waiting: AtomicInt
    _generation: AtomicInt
    _mutex: Mutex[Bool]
    _cv: CondVar

    fn new(count: i64) -> Barrier:
        use infra.atomic.AtomicInt
        return Barrier(
            _count: count,
            _waiting: AtomicInt.new(0),
            _generation: AtomicInt.new(0),
            _mutex: Mutex.new(false),
            _cv: CondVar.new()
        )

    /**
    Wait at the barrier.
    Returns true for one thread (the "leader").
    */
    fn wait() -> Bool:
        val gen = self._generation.load()
        val arrived = self._waiting.fetch_add(1) + 1

        if arrived == self._count:
            # Last thread - release all
            self._waiting.store(0)
            self._generation.fetch_add(1)
            self._cv.notify_all()
            return true
        else:
            # Wait for others
            self._mutex.lock(\ready:
                while self._generation.load() == gen:
                    self._cv.wait(self._mutex)
            )
            return false

    fn free():
        self._waiting.free()
        self._generation.free()
        self._mutex.free()
        self._cv.free()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn waiting_count() -> i64:
        """Get number of threads currently waiting at barrier."""
        return self._waiting.load()

    fn is_full() -> Bool:
        """Check if all threads have arrived at barrier."""
        return self._waiting.load() >= self._count

    fn is_empty() -> Bool:
        """Check if no threads are waiting."""
        return self._waiting.load() == 0

    fn summary() -> String:
        """Get summary of barrier.

        Returns:
            Human-readable summary

        Example:
            barrier.summary()
            # → "Barrier: 3/4 waiting"
        """
        val waiting = self.waiting_count()
        val total = self._count
        return "Barrier: {waiting}/{total} waiting"

/**
Semaphore for resource limiting.

```sdoctest
>>> val sem = Semaphore.new(3)  # 3 permits
>>> sem.acquire()  # Get permit (blocks if none available)
>>> sem.release()  # Return permit
```
*/
struct Semaphore:
    _permits: AtomicInt
    _max: i64
    _mutex: Mutex[Bool]
    _cv: CondVar

    fn new(permits: i64) -> Semaphore:
        use infra.atomic.AtomicInt
        return Semaphore(
            _permits: AtomicInt.new(permits),
            _max: permits,
            _mutex: Mutex.new(false),
            _cv: CondVar.new()
        )

    fn acquire():
        while true:
            val current = self._permits.load()
            if current > 0:
                val (success, _) = self._permits.compare_exchange(current, current - 1)
                if success:
                    return
            # Wait for permit
            self._mutex.lock(\ready:
                if self._permits.load() == 0:
                    self._cv.wait(self._mutex)
            )

    fn try_acquire() -> Bool:
        val current = self._permits.load()
        if current > 0:
            val (success, _) = self._permits.compare_exchange(current, current - 1)
            return success
        return false

    fn release():
        val current = self._permits.load()
        if current < self._max:
            self._permits.fetch_add(1)
            self._cv.notify_one()

    fn available() -> i64:
        return self._permits.load()

    fn free():
        self._permits.free()
        self._mutex.free()
        self._cv.free()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_exhausted() -> Bool:
        """Check if no permits available."""
        return self.available() == 0

    fn is_full() -> Bool:
        """Check if all permits are available."""
        return self.available() >= self._max

    fn in_use() -> i64:
        """Get number of permits currently in use."""
        return self._max - self.available()

    fn max_permits() -> i64:
        """Get maximum number of permits."""
        return self._max

    fn summary() -> String:
        """Get summary of semaphore.

        Returns:
            Human-readable summary

        Example:
            sem.summary()
            # → "Semaphore: 2/5 permits available"
        """
        val avail = self.available()
        val total = self._max
        return "Semaphore: {avail}/{total} permits available"

/**
Latch - one-time countdown barrier.

```sdoctest
>>> val latch = Latch.new(3)
>>> # Each worker calls countdown()
>>> latch.countdown()
>>> # Main thread waits
>>> latch.wait()  # Blocks until count reaches 0
```
*/
struct Latch:
    _count: AtomicInt
    _mutex: Mutex[Bool]
    _cv: CondVar

    fn new(count: i64) -> Latch:
        use infra.atomic.AtomicInt
        return Latch(
            _count: AtomicInt.new(count),
            _mutex: Mutex.new(false),
            _cv: CondVar.new()
        )

    fn countdown():
        val old = self._count.fetch_sub(1)
        if old == 1:
            self._cv.notify_all()

    fn wait():
        self._mutex.lock(\ready:
            while self._count.load() > 0:
                self._cv.wait(self._mutex)
        )

    fn is_done() -> Bool:
        return self._count.load() == 0

    fn free():
        self._count.free()
        self._mutex.free()
        self._cv.free()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_pending() -> Bool:
        """Check if latch is not yet done."""
        return not self.is_done()

    fn remaining() -> i64:
        """Get remaining count."""
        return self._count.load()

    fn summary() -> String:
        """Get summary of latch.

        Returns:
            Human-readable summary

        Example:
            latch.summary()
            # → "Latch: 2 remaining" or "Latch: done"
        """
        if self.is_done():
            return "Latch: done"
        else:
            val rem = self.remaining()
            return "Latch: {rem} remaining"
