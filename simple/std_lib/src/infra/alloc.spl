/**
Allocator Interface

Custom memory allocation strategies for performance-critical code.

Features:
- Arena: Batch allocations with single deallocation
- Pool: Object reuse for fixed-size allocations
- @allocator decorator: Custom allocator for classes

```sdoctest
>>> let arena = Arena.new(1000)
>>> let ptr = arena.alloc(42)
>>> arena.reset()  # Free all at once
```
*/

# FFI declarations for allocator operations
extern fn rt_arena_new(capacity: i64) -> i64
extern fn rt_arena_alloc(arena: i64, size: i64) -> i64
extern fn rt_arena_reset(arena: i64)
extern fn rt_arena_free(arena: i64)
extern fn rt_arena_used(arena: i64) -> i64
extern fn rt_arena_capacity(arena: i64) -> i64

extern fn rt_pool_new(object_size: i64, capacity: i64) -> i64
extern fn rt_pool_acquire(pool: i64) -> i64
extern fn rt_pool_release(pool: i64, ptr: i64)
extern fn rt_pool_free(pool: i64)
extern fn rt_pool_available(pool: i64) -> i64
extern fn rt_pool_capacity(pool: i64) -> i64

/**
Allocator trait - interface for custom allocators.

Implement this trait to create custom allocation strategies.

```sdoctest
>>> trait Allocator:
...     fn alloc(self, size: i64) -> i64
...     fn dealloc(self, ptr: i64)
```
*/
trait Allocator:
    /**
    Allocate memory of the given size.
    Returns a pointer (as i64) to the allocated memory.
    */
    fn alloc(self, size: i64) -> i64

    /**
    Deallocate memory at the given pointer.
    */
    fn dealloc(self, ptr: i64)

    /**
    Returns true if this allocator supports individual deallocation.
    Arena allocators return false.
    */
    fn supports_dealloc(self) -> Bool:
        return true

/**
Arena allocator for batch allocations.

Allocates memory linearly from a pre-allocated buffer.
All allocations are freed at once via reset().
Ideal for temporary allocations with known lifetime.

```sdoctest
>>> let arena = Arena.new(1024)
>>> let p1 = arena.alloc_raw(64)
>>> let p2 = arena.alloc_raw(128)
>>> arena.used()  # Returns bytes used
192
>>> arena.reset()
>>> arena.used()
0
```
*/
struct Arena:
    _handle: i64
    _capacity: i64

    /**
    Create a new arena with the given capacity in bytes.
    */
    fn new(capacity: i64) -> Arena:
        let handle = rt_arena_new(capacity)
        return Arena(_handle: handle, _capacity: capacity)

    /**
    Allocate raw bytes from the arena.
    Returns 0 if the arena is full.
    */
    fn alloc_raw(self, size: i64) -> i64:
        return rt_arena_alloc(self._handle, size)

    /**
    Reset the arena, freeing all allocations.
    Does not release the underlying memory.
    */
    fn reset(self):
        rt_arena_reset(self._handle)

    /**
    Get the number of bytes currently used.
    */
    fn used(self) -> i64:
        return rt_arena_used(self._handle)

    /**
    Get the total capacity in bytes.
    */
    fn capacity(self) -> i64:
        return rt_arena_capacity(self._handle)

    /**
    Check if the arena has space for the given size.
    */
    fn has_space(self, size: i64) -> Bool:
        return self.used() + size <= self.capacity()

    /**
    Free the arena and release underlying memory.
    */
    fn free(self):
        rt_arena_free(self._handle)

    # Implement Allocator trait
    fn alloc(self, size: i64) -> i64:
        return self.alloc_raw(size)

    fn dealloc(self, ptr: i64):
        # Arena doesn't support individual deallocation
        pass

    fn supports_dealloc(self) -> Bool:
        return false

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> Bool:
        """Check if arena has no allocations.

        Returns:
            True if no bytes are used
        """
        return self.used() == 0

    fn is_full(self) -> Bool:
        """Check if arena is full.

        Returns:
            True if no space remaining
        """
        return self.used() >= self.capacity()

    fn available(self) -> i64:
        """Get available space in bytes.

        Returns:
            Number of bytes remaining
        """
        return self.capacity() - self.used()

    fn utilization(self) -> f64:
        """Get utilization as percentage.

        Returns:
            Percentage of capacity used (0.0 to 1.0)
        """
        let cap = self.capacity()
        if cap == 0:
            return 0.0
        return (self.used() as f64) / (cap as f64)

    fn summary(self) -> String:
        """Get summary of arena state.

        Returns:
            Human-readable summary

        Example:
            arena.summary()
            # → "Arena: 512/1024 bytes (50.0% used)"
        """
        let used_bytes = self.used()
        let total_bytes = self.capacity()
        let util_pct = self.utilization() * 100.0
        return "Arena: {used_bytes}/{total_bytes} bytes ({util_pct:.1}% used)"

/**
Typed arena for allocating objects of a specific type.

```sdoctest
>>> struct Node:
...     value: i64
...     next: i64
>>> let arena = TypedArena[Node].new(100)
>>> let node = arena.alloc(Node(value: 42, next: 0))
```
*/
struct TypedArena[T]:
    _arena: Arena
    _object_size: i64

    /**
    Create a new typed arena with capacity for N objects.
    */
    fn new(capacity: i64) -> TypedArena[T]:
        let object_size = 64  # Placeholder - would use sizeof(T)
        let arena = Arena.new(capacity * object_size)
        return TypedArena(_arena: arena, _object_size: object_size)

    /**
    Allocate a new object in the arena.
    */
    fn alloc(self, value: T) -> T:
        let ptr = self._arena.alloc_raw(self._object_size)
        # In real impl, would copy value to ptr
        return value

    /**
    Reset the arena, invalidating all allocated objects.
    */
    fn reset(self):
        self._arena.reset()

    /**
    Get the number of objects allocated.
    */
    fn count(self) -> i64:
        return self._arena.used() / self._object_size

    /**
    Get the maximum number of objects.
    */
    fn capacity(self) -> i64:
        return self._arena.capacity() / self._object_size

    /**
    Free the arena.
    */
    fn free(self):
        self._arena.free()

/**
Object pool for reusing fixed-size allocations.

Maintains a pool of pre-allocated objects that can be
acquired and released for reuse.

```sdoctest
>>> let pool = Pool.new(64, 100)  # 100 objects of 64 bytes
>>> let buf = pool.acquire()
>>> pool.release(buf)
```
*/
struct Pool:
    _handle: i64
    _object_size: i64
    _capacity: i64

    /**
    Create a new pool with objects of the given size.

    Arguments:
    - object_size: Size of each object in bytes
    - capacity: Maximum number of objects in the pool
    */
    fn new(object_size: i64, capacity: i64) -> Pool:
        let handle = rt_pool_new(object_size, capacity)
        return Pool(
            _handle: handle,
            _object_size: object_size,
            _capacity: capacity
        )

    /**
    Acquire an object from the pool.
    Returns 0 if the pool is exhausted.
    */
    fn acquire(self) -> i64:
        return rt_pool_acquire(self._handle)

    /**
    Release an object back to the pool for reuse.
    */
    fn release(self, ptr: i64):
        rt_pool_release(self._handle, ptr)

    /**
    Get the number of available objects.
    */
    fn available(self) -> i64:
        return rt_pool_available(self._handle)

    /**
    Get the total capacity.
    */
    fn capacity(self) -> i64:
        return rt_pool_capacity(self._handle)

    /**
    Check if the pool has available objects.
    */
    fn has_available(self) -> Bool:
        return self.available() > 0

    /**
    Free the pool and all objects.
    */
    fn free(self):
        rt_pool_free(self._handle)

    # Implement Allocator trait
    fn alloc(self, size: i64) -> i64:
        if size > self._object_size:
            return 0
        return self.acquire()

    fn dealloc(self, ptr: i64):
        self.release(ptr)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> Bool:
        """Check if all objects are available (none in use).

        Returns:
            True if all objects are in the pool
        """
        return self.available() == self.capacity()

    fn is_exhausted(self) -> Bool:
        """Check if pool has no available objects.

        Returns:
            True if no objects available
        """
        return self.available() == 0

    fn in_use(self) -> i64:
        """Get number of objects currently in use.

        Returns:
            Number of acquired objects
        """
        return self.capacity() - self.available()

    fn utilization(self) -> f64:
        """Get utilization as percentage.

        Returns:
            Percentage of objects in use (0.0 to 1.0)
        """
        let cap = self.capacity()
        if cap == 0:
            return 0.0
        return (self.in_use() as f64) / (cap as f64)

    fn object_size(self) -> i64:
        """Get size of each object in bytes.

        Returns:
            Object size
        """
        return self._object_size

    fn summary(self) -> String:
        """Get summary of pool state.

        Returns:
            Human-readable summary

        Example:
            pool.summary()
            # → "Pool: 25/100 objects in use (25.0%), 64 bytes each"
        """
        let in_use_count = self.in_use()
        let total_count = self.capacity()
        let util_pct = self.utilization() * 100.0
        let obj_size = self._object_size
        return "Pool: {in_use_count}/{total_count} objects in use ({util_pct:.1}%), {obj_size} bytes each"

/**
Typed object pool for reusing objects of a specific type.

```sdoctest
>>> struct Buffer:
...     data: [u8]
...     size: i64
>>> let pool = TypedPool[Buffer].new(100)
>>> let buf = pool.acquire()
>>> buf.size = 1024
>>> pool.release(buf)
```
*/
struct TypedPool[T]:
    _pool: Pool
    _object_size: i64

    /**
    Create a new typed pool with capacity for N objects.
    */
    fn new(capacity: i64) -> TypedPool[T]:
        let object_size = 64  # Placeholder - would use sizeof(T)
        let pool = Pool.new(object_size, capacity)
        return TypedPool(_pool: pool, _object_size: object_size)

    /**
    Acquire an object from the pool.
    Returns None if the pool is exhausted.
    */
    fn acquire(self) -> Option[T]:
        let ptr = self._pool.acquire()
        if ptr == 0:
            return Option.None
        # In real impl, would read object from ptr
        return Option.None  # Placeholder

    /**
    Release an object back to the pool.
    */
    fn release(self, obj: T):
        # In real impl, would get ptr from obj and release
        pass

    /**
    Get the number of available objects.
    */
    fn available(self) -> i64:
        return self._pool.available()

    /**
    Get the total capacity.
    */
    fn capacity(self) -> i64:
        return self._pool.capacity()

    /**
    Free the pool.
    */
    fn free(self):
        self._pool.free()

/**
Bump allocator - simple linear allocator.

Even simpler than Arena - just bumps a pointer forward.
No metadata overhead, but no reset capability.

```sdoctest
>>> let bump = BumpAllocator.new(4096)
>>> let p1 = bump.alloc(100)
>>> let p2 = bump.alloc(200)
>>> bump.remaining()
3796
```
*/
struct BumpAllocator:
    _buffer: i64
    _capacity: i64
    _offset: i64

    fn new(capacity: i64) -> BumpAllocator:
        let buffer = rt_arena_new(capacity)
        return BumpAllocator(
            _buffer: buffer,
            _capacity: capacity,
            _offset: 0
        )

    fn alloc(self, size: i64) -> i64:
        if self._offset + size > self._capacity:
            return 0
        let ptr = self._buffer + self._offset
        self._offset = self._offset + size
        return ptr

    fn remaining(self) -> i64:
        return self._capacity - self._offset

    fn used(self) -> i64:
        return self._offset

    fn free(self):
        rt_arena_free(self._buffer)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> Bool:
        """Check if no allocations have been made.

        Returns:
            True if offset is zero
        """
        return self._offset == 0

    fn is_full(self) -> Bool:
        """Check if allocator is full.

        Returns:
            True if no space remaining
        """
        return self._offset >= self._capacity

    fn capacity(self) -> i64:
        """Get total capacity in bytes.

        Returns:
            Total capacity
        """
        return self._capacity

    fn utilization(self) -> f64:
        """Get utilization as percentage.

        Returns:
            Percentage of capacity used (0.0 to 1.0)
        """
        if self._capacity == 0:
            return 0.0
        return (self._offset as f64) / (self._capacity as f64)

    fn summary(self) -> String:
        """Get summary of allocator state.

        Returns:
            Human-readable summary

        Example:
            bump.summary()
            # → "BumpAllocator: 256/4096 bytes used (6.2%)"
        """
        let used_bytes = self.used()
        let total_bytes = self.capacity()
        let util_pct = self.utilization() * 100.0
        return "BumpAllocator: {used_bytes}/{total_bytes} bytes used ({util_pct:.1}%)"

/**
Allocator configuration for classes.

Use with @allocator decorator to specify custom allocation.
*/
struct AllocatorConfig:
    allocator_type: str
    capacity: i64

    fn arena(capacity: i64) -> AllocatorConfig:
        return AllocatorConfig(allocator_type: "arena", capacity: capacity)

    fn pool(capacity: i64) -> AllocatorConfig:
        return AllocatorConfig(allocator_type: "pool", capacity: capacity)

    fn default() -> AllocatorConfig:
        return AllocatorConfig(allocator_type: "gc", capacity: 0)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_arena(self) -> Bool:
        """Check if configuration is for arena allocator.

        Returns:
            True if allocator type is "arena"
        """
        return self.allocator_type == "arena"

    fn is_pool(self) -> Bool:
        """Check if configuration is for pool allocator.

        Returns:
            True if allocator type is "pool"
        """
        return self.allocator_type == "pool"

    fn is_gc(self) -> Bool:
        """Check if configuration is for GC allocator.

        Returns:
            True if allocator type is "gc"
        """
        return self.allocator_type == "gc"

    fn has_capacity(self) -> Bool:
        """Check if configuration specifies capacity.

        Returns:
            True if capacity > 0
        """
        return self.capacity > 0

    fn summary(self) -> String:
        """Get summary of allocator configuration.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # → "AllocatorConfig: arena, capacity: 1024"
        """
        let cap_str = if self.has_capacity():
            ", capacity: {self.capacity}"
        else:
            ""
        return "AllocatorConfig: {self.allocator_type}{cap_str}"
