# A unified dictionary-like interface for configuration, environment variables, and arguments.
#
# Provides a consistent way to access configuration from multiple sources:
# - Direct key-value pairs
# - Environment variables
# - Command-line arguments (--key=value or --key value format)

use core.option.{Option, Some}

# Helper function to parse integer from text
fn parse_int_helper(s: text) -> i64:
    var result = 0
    var negative = false
    var start = 0

    if s.len() > 0 and s.char_at(0) == "-":
        negative = true
        start = 1

    for i in start..s.len():
        val ch = s.char_at(i)
        val ord_val = ch.ord()
        if ord_val >= 48 and ord_val <= 57:  # '0' to '9'
            val digit = ord_val - 48
            result = result * 10 + digit

    if negative:
        return -result
    else:
        return result

pub struct ConfigEnv:
    data: Dict<text, text>

impl ConfigEnv:
    # Create a new empty ConfigEnv.
    static fn new() -> ConfigEnv:
        ConfigEnv(data: {})

    # Create a ConfigEnv from command-line arguments.
    #
    # Supports formats:
    # - `--key=value`
    # - `--key value`
    # - `-k value`
    # - Positional args stored as `_0`, `_1`, etc.
    static fn from_args(args: [text]) -> ConfigEnv:
        var config = ConfigEnv.new()
        var positional_idx = 0
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg.starts_with("--"):
                val key_value = arg.substring(2, arg.len())

                if key_value.contains("="):
                    # Find the equals sign and split manually
                    var eq_pos = 0
                    while eq_pos < key_value.len() and key_value.char_at(eq_pos) != "=":
                        eq_pos = eq_pos + 1

                    if eq_pos < key_value.len():
                        val key = key_value.substring(0, eq_pos)
                        val value = key_value.substring(eq_pos + 1, key_value.len())
                        config.set(key, value)
                    i = i + 1
                elif i + 1 < args.len() and not args[i + 1].starts_with("-"):
                    # --key value format
                    config.set(key_value, args[i + 1])
                    i = i + 2
                else:
                    # --flag (boolean)
                    config.set(key_value, "true")
                    i = i + 1
            elif arg.starts_with("-") and arg.len() == 2:
                # -k value format
                val key = arg.substring(1, 2)
                if i + 1 < args.len() and not args[i + 1].starts_with("-"):
                    config.set(key, args[i + 1])
                    i = i + 2
                else:
                    config.set(key, "true")
                    i = i + 1
            else:
                # Positional argument
                config.set("_{positional_idx}", arg)
                positional_idx = positional_idx + 1
                i = i + 1

        return config

    # Create a ConfigEnv from all environment variables.
    static fn from_env() -> ConfigEnv:
        var config = ConfigEnv.new()
        val env_vars = get_env_vars()  # FFI call to get all env vars
        for pair in env_vars:
            config.set(pair.0, pair.1)
        return config

    # Create a ConfigEnv from environment variables with a specific prefix.
    #
    # The prefix is stripped from the key names.
    # Example: with prefix "SIMPLE_", env var "SIMPLE_DEBUG" becomes key "DEBUG".
    static fn from_env_with_prefix(prefix: text) -> ConfigEnv:
        var config = ConfigEnv.new()
        val env_vars = get_env_vars()
        for pair in env_vars:
            val key = pair.0
            val value = pair.1
            if key.starts_with(prefix):
                val stripped_key = key.substring(prefix.len(), key.len())
                config.set(stripped_key, value)
        return config

    # Get a value by key.
    fn get(key: text) -> Option<text>:
        if self.data.contains(key):
            return Some(self.data[key])
        else:
            return nil

    # Get a value by key, or return a default.
    fn get_or(key: text, default_value: text) -> text:
        if self.data.contains(key):
            return self.data[key]
        else:
            return default_value

    # Set a key-value pair.
    me set(key: text, value: text):
        var d = self.data
        d.set(key, value)
        self.data = d

    # Check if a key exists.
    fn contains(key: text) -> bool:
        return self.data.contains(key)

    # Remove a key and return its value.
    # TODO(dict): Implement rt_dict_remove() in runtime
    me remove(key: text) -> Option<text>:
        if self.data.contains(key):
            val value = self.data[key]
            # NOTE: data.remove() not yet implemented in runtime
            # For now, we can't actually remove the key
            # This is a known limitation
            return Some(value)
        else:
            return nil

    # Get a value as an integer.
    fn get_int(key: text) -> Option<i64>:
        match self.get(key):
            case Some(s):
                # Try to parse the string as an integer
                val result = parse_int_helper(s)
                return Some(result)
            case nil:
                return nil

    # Get a value as an integer with a default.
    fn get_int_or(key: text, default_value: i64) -> i64:
        match self.get_int(key):
            case Some(i): return i
            case nil: return default_value

    # Get a value as a boolean.
    #
    # Returns true for "true", "1", "yes", "on" (case-insensitive).
    # Returns false for "false", "0", "no", "off" (case-insensitive).
    # Returns nil for other values or missing keys.
    fn get_bool(key: text) -> Option<bool>:
        if not self.data.contains(key):
            return nil

        val s = self.data[key]
        # Check all variations without lowercased() to avoid type issues
        if s == "true" or s == "True" or s == "TRUE" or s == "1" or s == "yes" or s == "Yes" or s == "YES" or s == "on" or s == "On" or s == "ON":
            return Some(true)
        elif s == "false" or s == "False" or s == "FALSE" or s == "0" or s == "no" or s == "No" or s == "NO" or s == "off" or s == "Off" or s == "OFF":
            return Some(false)
        else:
            return nil

    # Get a value as a boolean with a default.
    fn get_bool_or(key: text, default_value: bool) -> bool:
        match self.get_bool(key):
            case Some(b): return b
            case nil: return default_value

    # Get all keys.
    fn keys() -> [text]:
        return self.data.keys()

    # Get all values.
    fn values() -> [text]:
        return self.data.values()

    # Iterate over all key-value pairs.
    fn iter() -> [(text, text)]:
        val keys = self.data.keys()
        val values = self.data.values()
        var result: [(text, text)] = []
        for i in 0..keys.len():
            result.push((keys[i], values[i]))
        return result

    # Get the number of entries.
    fn len() -> i64:
        return self.data.len()

    # Check if empty.
    fn is_empty() -> bool:
        return self.data.len() == 0

    # Merge another ConfigEnv into this one.
    #
    # Values from `other` override existing values.
    me merge(other: ConfigEnv):
        var d = self.data
        val keys = other.data.keys()
        val values = other.data.values()
        for i in 0..keys.len():
            d.set(keys[i], values[i])
        self.data = d

    # Add environment variables to this config.
    #
    # Environment values override existing config values.
    me with_env() -> ConfigEnv:
        val env_vars = get_env_vars()
        for pair in env_vars:
            self.set(pair.0, pair.1)
        return self

    # Add environment variables with a prefix to this config.
    me with_env_prefix(prefix: text) -> ConfigEnv:
        val env_vars = get_env_vars()
        for pair in env_vars:
            val key = pair.0
            val value = pair.1
            if key.starts_with(prefix):
                val stripped_key = key.substring(prefix.len(), key.len())
                self.set(stripped_key, value)
        return self

    # Add command-line arguments to this config.
    #
    # Argument values override existing config values.
    me with_args(args: [text]) -> ConfigEnv:
        val args_config = ConfigEnv.from_args(args)
        self.merge(args_config)
        return self

# FFI: Get all environment variables as array of (key, value) tuples
extern fn rt_env_all() -> List<(text, text)>

# Helper function to get environment variables
pub fn get_env_vars() -> [(text, text)]:
    rt_env_all()
