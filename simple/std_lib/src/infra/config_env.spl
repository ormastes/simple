# A unified dictionary-like interface for configuration, environment variables, and arguments.
#
# Provides a consistent way to access configuration from multiple sources:
# - Direct key-value pairs
# - Environment variables
# - Command-line arguments (--key=value or --key value format)

use core.option.{Option, Some}

# Helper function to parse integer from text
fn parse_int_helper(s: text) -> i64:
    var result = 0
    var negative = false
    var start = 0

    if s.len() > 0 and s.char_at(0) == '-':
        negative = true
        start = 1

    for i in start..s.len():
        val ch = s.char_at(i)
        if ch >= '0' and ch <= '9':
            val digit = (ch as i64) - ('0' as i64)
            result = result * 10 + digit

    if negative:
        -result
    else:
        result

pub struct ConfigEnv:
    self.data: Dict<text, text>

impl ConfigEnv:
    # Create a new empty ConfigEnv.
    static fn new() -> ConfigEnv:
        ConfigEnv(self.data: {})

    # Create a ConfigEnv from command-line arguments.
    #
    # Supports formats:
    # - `--key=value`
    # - `--key value`
    # - `-k value`
    # - Positional args stored as `_0`, `_1`, etc.
    static fn from_args(args: [text]) -> ConfigEnv:
        var config = ConfigEnv.new()
        var positional_idx = 0
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg.starts_with("--"):
                val key_value = arg.substring(2, arg.len())

                if key_value.contains("="):
                    match key_value.split_once("="):
                        case Some((key, value)):
                            config.set(key, value)
                            i = i + 1
                        case nil:
                            i = i + 1
                elif i + 1 < args.len() and not args[i + 1].starts_with("-"):
                    # --key value format
                    config.set(key_value, args[i + 1])
                    i = i + 2
                else:
                    # --flag (boolean)
                    config.set(key_value, "true")
                    i = i + 1
            elif arg.starts_with("-") and arg.len() == 2:
                # -k value format
                val key = arg.substring(1, 2)
                if i + 1 < args.len() and not args[i + 1].starts_with("-"):
                    config.set(key, args[i + 1])
                    i = i + 2
                else:
                    config.set(key, "true")
                    i = i + 1
            else:
                # Positional argument
                config.set("_{positional_idx}", arg)
                positional_idx = positional_idx + 1
                i = i + 1

        config

    # Create a ConfigEnv from all environment variables.
    static fn from_env() -> ConfigEnv:
        var config = ConfigEnv.new()
        val env_vars = get_env_vars()  # FFI call to get all env vars
        for pair in env_vars:
            config.set(pair.0, pair.1)
        config

    # Create a ConfigEnv from environment variables with a specific prefix.
    #
    # The prefix is stripped from the key names.
    # Example: with prefix "SIMPLE_", env var "SIMPLE_DEBUG" becomes key "DEBUG".
    static fn from_env_with_prefix(prefix: text) -> ConfigEnv:
        var config = ConfigEnv.new()
        val env_vars = get_env_vars()
        for pair in env_vars:
            val key = pair.0
            val value = pair.1
            if key.starts_with(prefix):
                val stripped_key = key.substring(prefix.len(), key.len())
                config.set(stripped_key, value)
        config

    # Get a value by key.
    fn get(key: text) -> Option<text>:
        if self.data.contains(key):
            Some(self.data[key])
        else:
            nil

    # Get a value by key, or return a default.
    fn get_or(key: text, default_value: text) -> text:
        if self.data.contains(key):
            self.data[key]
        else:
            default_value

    # Set a key-value pair.
    me set(key: text, value: text):
        self.data.set(key, value)

    # Check if a key exists.
    fn contains(key: text) -> bool:
        self.data.contains(key)

    # Remove a key and return its value.
    # TODO(dict): Implement rt_dict_remove() in runtime
    me remove(key: text) -> Option<text>:
        if self.data.contains(key):
            val value = self.data[key]
            # NOTE: self.data.remove() not yet implemented in runtime
            # For now, we can't actually remove the key
            # This is a known limitation
            Some(value)
        else:
            nil

    # Get a value as an integer.
    fn get_int(key: text) -> Option<i64>:
        match get(key):
            case Some(s):
                # Try to parse the string as an integer
                val result = parse_int_helper(s)
                return Some(result)
            case nil:
                return nil

    # Get a value as an integer with a default.
    fn get_int_or(key: text, default_value: i64) -> i64:
        match get_int(key):
            case Some(i): return i
            case nil: return default_value

    # Get a value as a boolean.
    #
    # Returns true for "true", "1", "yes", "on" (case-insensitive).
    # Returns false for "false", "0", "no", "off" (case-insensitive).
    # Returns nil for other values or missing keys.
    fn get_bool(key: text) -> Option<bool>:
        match get(key):
            case Some(s):
                val lower = s.lowercased()
                if lower == "true" or lower == "1" or lower == "yes" or lower == "on":
                    return Some(true)
                elif lower == "false" or lower == "0" or lower == "no" or lower == "off":
                    return Some(false)
                else:
                    return nil
            case nil:
                return nil

    # Get a value as a boolean with a default.
    fn get_bool_or(key: text, default_value: bool) -> bool:
        match get_bool(key):
            case Some(b): return b
            case nil: return default_value

    # Get all keys.
    fn keys() -> [text]:
        self.data.keys()

    # Get all values.
    fn values() -> [text]:
        self.data.values()

    # Iterate over all key-value pairs.
    fn iter() -> [(text, text)]:
        val keys = self.data.keys()
        val values = self.data.values()
        var result: [(text, text)] = []
        for i in 0..keys.len():
            result.push((keys[i], values[i]))
        result

    # Get the number of entries.
    fn len() -> i64:
        self.data.len()

    # Check if empty.
    fn is_empty() -> bool:
        self.data.len() == 0

    # Merge another ConfigEnv into this one.
    #
    # Values from `other` override existing values.
    me merge(other: ConfigEnv):
        val keys = other.self.data.keys()
        val values = other.self.data.values()
        for i in 0..keys.len():
            self.data.set(keys[i], values[i])

    # Add environment variables to this config.
    #
    # Environment values override existing config values.
    me with_env() -> ConfigEnv:
        val env_vars = get_env_vars()
        for pair in env_vars:
            set(pair.0, pair.1)
        self

    # Add environment variables with a prefix to this config.
    me with_env_prefix(prefix: text) -> ConfigEnv:
        val env_vars = get_env_vars()
        for pair in env_vars:
            val key = pair.0
            val value = pair.1
            if key.starts_with(prefix):
                val stripped_key = key.substring(prefix.len(), key.len())
                set(stripped_key, value)
        self

    # Add command-line arguments to this config.
    #
    # Argument values override existing config values.
    me with_args(args: [text]) -> ConfigEnv:
        val args_config = ConfigEnv.from_args(args)
        merge(args_config)
        self

# FFI: Get all environment variables as array of (key, value) tuples
# TODO(runtime): Implement rt_env_vars() in runtime/src/ffi/env.rs
# extern fn rt_env_vars() -> i64  # Returns RuntimeValue representing array of tuples

# Helper function to get environment variables
# For now, returns empty array until FFI is implemented
pub fn get_env_vars() -> [(text, text)]:
    []  # TODO: Call rt_env_vars() when implemented
