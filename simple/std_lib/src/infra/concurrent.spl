/**
Concurrent Collections

Thread-safe collections for concurrent access.

Features:
- ConcurrentMap: Thread-safe hash map
- ConcurrentSet: Thread-safe hash set
- ConcurrentQueue: Multi-producer multi-consumer queue
- ConcurrentStack: Lock-free stack
- ConcurrentVec: Thread-safe dynamic array
- ShardedMap: Sharded map for reduced contention

```sdoctest
>>> val map = ConcurrentMap.new()
>>> map.insert("key", 42)
>>> map.get("key")
Some(42)
```
*/

# FFI declarations for concurrent collections
extern fn rt_concurrent_map_new() -> i64
extern fn rt_concurrent_map_insert(map: i64, key: i64, value: i64) -> i64
extern fn rt_concurrent_map_get(map: i64, key: i64) -> i64
extern fn rt_concurrent_map_remove(map: i64, key: i64) -> i64
extern fn rt_concurrent_map_contains(map: i64, key: i64) -> i64
extern fn rt_concurrent_map_len(map: i64) -> i64
extern fn rt_concurrent_map_clear(map: i64)
extern fn rt_concurrent_map_free(map: i64)

extern fn rt_concurrent_queue_new() -> i64
extern fn rt_concurrent_queue_push(queue: i64, value: i64)
extern fn rt_concurrent_queue_pop(queue: i64) -> i64
extern fn rt_concurrent_queue_is_empty(queue: i64) -> i64
extern fn rt_concurrent_queue_len(queue: i64) -> i64
extern fn rt_concurrent_queue_free(queue: i64)

extern fn rt_concurrent_stack_new() -> i64
extern fn rt_concurrent_stack_push(stack: i64, value: i64)
extern fn rt_concurrent_stack_pop(stack: i64) -> i64
extern fn rt_concurrent_stack_is_empty(stack: i64) -> i64
extern fn rt_concurrent_stack_free(stack: i64)

/**
Thread-safe concurrent hash map.

Provides lock-free reads and fine-grained locking for writes.
Safe to access from multiple threads simultaneously.

```sdoctest
>>> val map = ConcurrentMap.new()
>>> map.insert("alice", 100)
>>> map.insert("bob", 200)
>>> map.get("alice")
Some(100)
>>> map.len()
2
```
*/
struct ConcurrentMap<K, V>:
    _handle: i64

    /**
    Create a new empty concurrent map.
    */
    static fn new() -> ConcurrentMap<K, V>:
        val handle = rt_concurrent_map_new()
        return ConcurrentMap(_handle: handle)

    /**
    Insert a key-value pair.
    Returns the previous value if the key existed.
    */
    fn insert(key: K, value: V) -> Option<V>:
        val prev = rt_concurrent_map_insert(self._handle, key as i64, value as i64)
        if prev == 0:
            return Option.None
        return Option.Some(prev as V)

    /**
    Get the value for a key.
    */
    fn get(key: K) -> Option<V>:
        val value = rt_concurrent_map_get(self._handle, key as i64)
        if value == 0:
            return Option.None
        return Option.Some(value as V)

    /**
    Remove a key-value pair.
    Returns the removed value if it existed.
    */
    fn remove(key: K) -> Option<V>:
        val value = rt_concurrent_map_remove(self._handle, key as i64)
        if value == 0:
            return Option.None
        return Option.Some(value as V)

    /**
    Check if the map contains a key.
    */
    fn contains(key: K) -> bool:
        return rt_concurrent_map_contains(self._handle, key as i64) == 1

    /**
    Get the number of entries.
    */
    fn len() -> i64:
        return rt_concurrent_map_len(self._handle)

    /**
    Check if the map is empty.
    */
    fn is_empty() -> bool:
        return self.len() == 0

    /**
    Remove all entries.
    */
    fn clear():
        rt_concurrent_map_clear(self._handle)

    /**
    Get or insert a value.
    Returns the existing value or inserts and returns the default.
    */
    fn get_or_insert(key: K, default: V) -> V:
        val existing = self.get(key)
        match existing:
            case Some(v):
                return v
            case None:
                self.insert(key, default)
                return default

    /**
    Update a value atomically.
    Returns the new value.
    */
    fn update(key: K, updater: fn(V) -> V, default: V) -> V:
        val existing = self.get(key)
        match existing:
            case Some(v):
                val new_value = updater(v)
                self.insert(key, new_value)
                return new_value
            case None:
                self.insert(key, default)
                return default

    /**
    Free the map.
    */
    fn free():
        rt_concurrent_map_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_key(key: K) -> bool:
        """Check if map contains a key (alias for contains).

        Returns:
            true if key exists

        Example:
            map.has_key("alice")  # → true
        """
        return self.contains(key)

    fn is_not_empty() -> bool:
        """Check if map has entries.

        Returns:
            true if not empty

        Example:
            map.is_not_empty()  # → true
        """
        return not self.is_empty()

    fn count() -> i64:
        """Get number of entries (alias for len).

        Returns:
            Entry count

        Example:
            map.count()  # → 3
        """
        return self.len()

    fn summary() -> text:
        """Get summary of concurrent map.

        Returns:
            Human-readable summary

        Example:
            map.summary()
            # → "ConcurrentMap: 5 entries"
        """
        val count = self.len()
        return "ConcurrentMap: {count} entries"

/**
Thread-safe concurrent hash set.

```sdoctest
>>> val set = ConcurrentSet.new()
>>> set.insert("apple")
>>> set.insert("banana")
>>> set.contains("apple")
true
>>> set.len()
2
```
*/
struct ConcurrentSet<T>:
    _map: ConcurrentMap<T, bool>

    static fn new() -> ConcurrentSet<T>:
        return ConcurrentSet(_map: ConcurrentMap.new())

    fn insert(value: T) -> bool:
        val prev = self._map.insert(value, true)
        return prev.is_none()

    fn remove(value: T) -> bool:
        val prev = self._map.remove(value)
        return prev.is_some()

    fn contains(value: T) -> bool:
        return self._map.contains(value)

    fn len() -> i64:
        return self._map.len()

    fn is_empty() -> bool:
        return self._map.is_empty()

    fn clear():
        self._map.clear()

    fn free():
        self._map.free()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has(value: T) -> bool:
        """Check if set contains a value (alias for contains).

        Returns:
            true if value exists

        Example:
            set.has("apple")  # → true
        """
        return self.contains(value)

    fn is_not_empty() -> bool:
        """Check if set has elements.

        Returns:
            true if not empty

        Example:
            set.is_not_empty()  # → true
        """
        return not self.is_empty()

    fn count() -> i64:
        """Get number of elements (alias for len).

        Returns:
            Element count

        Example:
            set.count()  # → 3
        """
        return self.len()

    fn summary() -> text:
        """Get summary of concurrent set.

        Returns:
            Human-readable summary

        Example:
            set.summary()
            # → "ConcurrentSet: 5 elements"
        """
        val count = self.len()
        return "ConcurrentSet: {count} elements"

/**
Multi-producer multi-consumer concurrent queue.

Thread-safe queue supporting concurrent push and pop operations.

```sdoctest
>>> val queue = ConcurrentQueue.new()
>>> queue.push(1)
>>> queue.push(2)
>>> queue.pop()
Some(1)
>>> queue.pop()
Some(2)
```
*/
struct ConcurrentQueue<T>:
    _handle: i64

    static fn new() -> ConcurrentQueue<T>:
        val handle = rt_concurrent_queue_new()
        return ConcurrentQueue(_handle: handle)

    /**
    Push a value to the back of the queue.
    */
    fn push(value: T):
        rt_concurrent_queue_push(self._handle, value as i64)

    /**
    Pop a value from the front of the queue.
    Returns None if the queue is empty.
    */
    fn pop() -> Option<T>:
        if self.is_empty():
            return Option.None
        val value = rt_concurrent_queue_pop(self._handle)
        return Option.Some(value as T)

    /**
    Check if the queue is empty.
    */
    fn is_empty() -> bool:
        return rt_concurrent_queue_is_empty(self._handle) == 1

    /**
    Get the number of elements.
    */
    fn len() -> i64:
        return rt_concurrent_queue_len(self._handle)

    /**
    Free the queue.
    */
    fn free():
        rt_concurrent_queue_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_not_empty() -> bool:
        """Check if queue has elements.

        Returns:
            true if not empty

        Example:
            queue.is_not_empty()  # → true
        """
        return not self.is_empty()

    fn count() -> i64:
        """Get number of elements (alias for len).

        Returns:
            Element count

        Example:
            queue.count()  # → 5
        """
        return self.len()

    fn try_pop() -> Option<T>:
        """Try to pop a value (alias for pop).

        Returns:
            Some(value) or None if empty

        Example:
            queue.try_pop()  # → Some(42)
        """
        return self.pop()

    fn summary() -> text:
        """Get summary of concurrent queue.

        Returns:
            Human-readable summary

        Example:
            queue.summary()
            # → "ConcurrentQueue: 5 elements"
        """
        val count = self.len()
        return "ConcurrentQueue: {count} elements"

/**
Lock-free concurrent stack.

Thread-safe stack using atomic operations.

```sdoctest
>>> val stack = ConcurrentStack.new()
>>> stack.push(1)
>>> stack.push(2)
>>> stack.pop()
Some(2)
>>> stack.pop()
Some(1)
```
*/
struct ConcurrentStack<T>:
    _handle: i64

    static fn new() -> ConcurrentStack<T>:
        val handle = rt_concurrent_stack_new()
        return ConcurrentStack(_handle: handle)

    /**
    Push a value onto the stack.
    */
    fn push(value: T):
        rt_concurrent_stack_push(self._handle, value as i64)

    /**
    Pop a value from the stack.
    Returns None if the stack is empty.
    */
    fn pop() -> Option<T>:
        if self.is_empty():
            return Option.None
        val value = rt_concurrent_stack_pop(self._handle)
        return Option.Some(value as T)

    /**
    Check if the stack is empty.
    */
    fn is_empty() -> bool:
        return rt_concurrent_stack_is_empty(self._handle) == 1

    /**
    Free the stack.
    */
    fn free():
        rt_concurrent_stack_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_not_empty() -> bool:
        """Check if stack has elements.

        Returns:
            true if not empty

        Example:
            stack.is_not_empty()  # → true
        """
        return not self.is_empty()

    fn try_pop() -> Option<T>:
        """Try to pop a value (alias for pop).

        Returns:
            Some(value) or None if empty

        Example:
            stack.try_pop()  # → Some(42)
        """
        return self.pop()

    fn summary() -> text:
        """Get summary of concurrent stack.

        Returns:
            Human-readable summary

        Example:
            stack.summary()
            # → "ConcurrentStack: lock-free"
        """
        return "ConcurrentStack: lock-free"

/**
Thread-safe dynamic array.

Provides concurrent read access and synchronized writes.

```sdoctest
>>> val vec = ConcurrentVec.new()
>>> vec.push(1)
>>> vec.push(2)
>>> vec.get(0)
Some(1)
>>> vec.len()
2
```
*/
struct ConcurrentVec<T>:
    _data: List<T>
    _lock: i64  # Would be a real lock in implementation

    static fn new() -> ConcurrentVec<T>:
        return ConcurrentVec(_data: [], _lock: 0)

    fn push(value: T):
        self._data.push(value)

    fn pop() -> Option<T>:
        if self._data.is_empty():
            return Option.None
        return Option.Some(self._data.pop())

    fn get(index: i64) -> Option<T>:
        if index < 0 or index >= len(self._data):
            return Option.None
        return Option.Some(self._data[index])

    fn set(index: i64, value: T) -> bool:
        if index < 0 or index >= len(self._data):
            return false
        self._data[index] = value
        return true

    fn len() -> i64:
        return len(self._data)

    fn is_empty() -> bool:
        return self._data.is_empty()

    fn clear():
        self._data.clear()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_not_empty() -> bool:
        """Check if vector has elements.

        Returns:
            true if not empty

        Example:
            vec.is_not_empty()  # → true
        """
        return not self.is_empty()

    fn count() -> i64:
        """Get number of elements (alias for len).

        Returns:
            Element count

        Example:
            vec.count()  # → 5
        """
        return self.len()

    fn try_pop() -> Option<T>:
        """Try to pop a value (alias for pop).

        Returns:
            Some(value) or None if empty

        Example:
            vec.try_pop()  # → Some(42)
        """
        return self.pop()

    fn has_index(index: i64) -> bool:
        """Check if index is valid.

        Args:
            index: Index to check

        Returns:
            true if index is valid

        Example:
            vec.has_index(5)  # → true
        """
        return index >= 0 and index < self.len()

    fn summary() -> text:
        """Get summary of concurrent vector.

        Returns:
            Human-readable summary

        Example:
            vec.summary()
            # → "ConcurrentVec: 5 elements"
        """
        val count = self.len()
        return "ConcurrentVec: {count} elements"

/**
Sharded concurrent map for reduced contention.

Divides the key space into shards, each with its own lock.
Reduces lock contention for high-throughput scenarios.

```sdoctest
>>> val map = ShardedMap.new(16)  # 16 shards
>>> map.insert("key1", 100)
>>> map.get("key1")
Some(100)
```
*/
struct ShardedMap<K, V>:
    _shards: List<ConcurrentMap<K, V>>
    _num_shards: i64

    fn new(num_shards: i64) -> ShardedMap<K, V>:
        val shards = []
        for i in range(num_shards):
            shards.push(ConcurrentMap.new())
        return ShardedMap(_shards: shards, _num_shards: num_shards)

    fn _get_shard(key: K) -> ConcurrentMap<K, V>:
        val hash = key as i64  # Simplified - would use proper hash
        val shard_idx = hash % self._num_shards
        if shard_idx < 0:
            shard_idx = -shard_idx
        return self._shards[shard_idx]

    fn insert(key: K, value: V) -> Option<V>:
        return self._get_shard(key).insert(key, value)

    fn get(key: K) -> Option<V>:
        return self._get_shard(key).get(key)

    fn remove(key: K) -> Option<V>:
        return self._get_shard(key).remove(key)

    fn contains(key: K) -> bool:
        return self._get_shard(key).contains(key)

    fn len() -> i64:
        val total = 0
        for shard in self._shards:
            total = total + shard.len()
        return total

    fn is_empty() -> bool:
        for shard in self._shards:
            if not shard.is_empty():
                return false
        return true

    fn clear():
        for shard in self._shards:
            shard.clear()

    fn free():
        for shard in self._shards:
            shard.free()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_key(key: K) -> bool:
        """Check if map contains a key (alias for contains).

        Returns:
            true if key exists

        Example:
            map.has_key("alice")  # → true
        """
        return self.contains(key)

    fn is_not_empty() -> bool:
        """Check if map has entries.

        Returns:
            true if not empty

        Example:
            map.is_not_empty()  # → true
        """
        return not self.is_empty()

    fn count() -> i64:
        """Get number of entries (alias for len).

        Returns:
            Entry count

        Example:
            map.count()  # → 100
        """
        return self.len()

    fn shard_count() -> i64:
        """Get number of shards.

        Returns:
            Number of shards

        Example:
            map.shard_count()  # → 16
        """
        return self._num_shards

    fn get_or_insert(key: K, default: V) -> V:
        """Get or insert a value.

        Args:
            key: Key to lookup
            default: Default value if key doesn't exist

        Returns:
            Existing or newly inserted value

        Example:
            map.get_or_insert("alice", 100)  # → 100
        """
        return self._get_shard(key).get_or_insert(key, default)

    fn summary() -> text:
        """Get summary of sharded map.

        Returns:
            Human-readable summary

        Example:
            map.summary()
            # → "ShardedMap: 100 entries, 16 shards"
        """
        val count = self.len()
        val shards = self._num_shards
        return "ShardedMap: {count} entries, {shards} shards"
