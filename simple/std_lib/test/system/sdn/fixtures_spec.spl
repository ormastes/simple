///
SDN Fixtures System Tests

Tests using real fixture files.
Validates fixture loading and error handling.

No mocks - tests with actual fixture files:
- Valid fixtures (config, data, primitives, etc.)
- Invalid fixtures (syntax errors)
- Large/complex fixtures
- Fixture-based workflows
///

import std.spec
import std.fs
import std.path
import sdn.document.SdnDocument
import sdn.parser.parse

describe "SDN Fixtures System Tests":
    context "valid fixtures":
        it "loads config example fixture":
            val fixture_path = find_fixture("config_example.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(doc):
                    # Verify basic structure
                    expect doc.get("app.name").flatmap(|v| v.as_str()) == Some("MyService")
                    expect doc.get("app.version").flatmap(|v| v.as_str()) == Some("2.1.0")
                    expect doc.get("server.port").flatmap(|v| v.as_i64()) == Some(8080)
                    expect doc.get("database.host").flatmap(|v| v.as_str()) == Some("localhost")

                    # Verify nested config
                    expect doc.get("server.config.max_connections").flatmap(|v| v.as_i64()) == Some(1000)
                    expect doc.get("server.config.keep_alive").flatmap(|v| v.as_bool()) == Some(True)

                    # Verify arrays
                    match doc.get("features"):
                        case Some(arr):
                            expect arr.is_array() == True
                        case None:
                            fail("Expected features array")
                case Err(e):
                    fail("Failed to load config fixture: ${e}")

        it "loads data example fixture":
            val fixture_path = find_fixture("data_example.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(doc):
                    # Verify tables
                    match doc.get("users"):
                        case Some(table):
                            expect table.is_table() == True
                        case None:
                            fail("Expected users table")

                    match doc.get("products"):
                        case Some(table):
                            expect table.is_table() == True
                        case None:
                            fail("Expected products table")

                    # Verify nested orders
                    expect doc.get("orders.order_1.user_id").flatmap(|v| v.as_i64()) == Some(1)
                    expect doc.get("orders.order_1.status").flatmap(|v| v.as_str()) == Some("completed")

                    # Verify statistics
                    expect doc.get("statistics.total_users").flatmap(|v| v.as_i64()) == Some(5)
                case Err(e):
                    fail("Failed to load data fixture: ${e}")

        it "loads primitives fixture":
            val fixture_path = find_fixture("primitives.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(doc):
                    # Integers
                    expect doc.get("int_positive").flatmap(|v| v.as_i64()) == Some(42)
                    expect doc.get("int_negative").flatmap(|v| v.as_i64()) == Some(-17)
                    expect doc.get("int_zero").flatmap(|v| v.as_i64()) == Some(0)

                    # Floats
                    match doc.get("float_positive"):
                        case Some(val):
                            expect val.is_float() == True
                        case None:
                            fail("Expected float_positive")

                    # Strings
                    expect doc.get("string_simple").flatmap(|v| v.as_str()) == Some("hello")
                    expect doc.get("string_with_spaces").flatmap(|v| v.as_str()) == Some("Hello, World!")

                    # Booleans
                    expect doc.get("bool_true").flatmap(|v| v.as_bool()) == Some(True)
                    expect doc.get("bool_false").flatmap(|v| v.as_bool()) == Some(False)

                    # Null
                    match doc.get("null_value"):
                        case Some(val):
                            expect val.is_null() == True
                        case None:
                            fail("Expected null_value")
                case Err(e):
                    fail("Failed to load primitives fixture: ${e}")

        it "loads collections fixture":
            val fixture_path = find_fixture("collections.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(doc):
                    # Inline arrays
                    match doc.get("simple_array"):
                        case Some(arr):
                            expect arr.is_array() == True
                        case None:
                            fail("Expected simple_array")

                    # Inline dicts
                    match doc.get("simple_dict"):
                        case Some(dict):
                            expect dict.is_dict() == True
                        case None:
                            fail("Expected simple_dict")

                    # Empty collections
                    match doc.get("empty_array"):
                        case Some(arr):
                            expect arr.is_array() == True
                        case None:
                            fail("Expected empty_array")

                    match doc.get("empty_dict"):
                        case Some(dict):
                            expect dict.is_dict() == True
                        case None:
                            fail("Expected empty_dict")

                    # Nested collections
                    expect doc.get("nested_block.level1.level2.level3.value").flatmap(|v| v.as_str()) == Some("deep")
                case Err(e):
                    fail("Failed to load collections fixture: ${e}")

        it "loads nested fixture":
            val fixture_path = find_fixture("nested.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(doc):
                    # 4-level nesting
                    expect doc.get("application.core.engine.settings.max_threads").flatmap(|v| v.as_i64()) == Some(8)

                    # 5-level nesting
                    expect doc.get("organization.departments.engineering.teams.backend.lead").flatmap(|v| v.as_str()) == Some("alice")

                    # Deep paths
                    expect doc.get("config.services.web.frontend.host").flatmap(|v| v.as_str()) == Some("frontend.example.com")
                    expect doc.get("system.infrastructure.cloud.provider").flatmap(|v| v.as_str()) == Some("aws")
                case Err(e):
                    fail("Failed to load nested fixture: ${e}")

    context "invalid fixtures":
        it "detects bad indentation":
            val fixture_path = find_fixture("invalid/bad_indent.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(_):
                    fail("Should have failed for bad indentation")
                case Err(e):
                    pass  # Expected error

        it "detects missing colon":
            val fixture_path = find_fixture("invalid/missing_colon.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(_):
                    fail("Should have failed for missing colon")
                case Err(e):
                    pass  # Expected error

        it "detects unclosed bracket":
            val fixture_path = find_fixture("invalid/unclosed_bracket.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(_):
                    fail("Should have failed for unclosed bracket")
                case Err(e):
                    pass  # Expected error

        it "detects invalid table":
            val fixture_path = find_fixture("invalid/invalid_table.sdn")

            match SdnDocument.from_file(fixture_path):
                case Ok(_):
                    # May or may not fail depending on table validation
                    # Some parsers are lenient with table field counts
                    pass
                case Err(e):
                    pass  # Error is acceptable

    context "fixture-based workflows":
        it "converts config fixture to JSON and back":
            val fixture_path = find_fixture("config_example.sdn")

            # Load SDN
            match SdnDocument.from_file(fixture_path):
                case Ok(doc):
                    # Convert to JSON
                    val json_output = doc.to_json()

                    # Parse JSON
                    match json.parse(json_output):
                        case Ok(json_value):
                            # Convert back to SDN
                            val sdn_value = json_to_sdn(json_value)
                            val sdn_output = to_sdn(sdn_value)

                            # Re-parse SDN
                            match parse(sdn_output):
                                case Ok(final_value):
                                    # Verify key fields preserved
                                    match final_value.get("app.name"):
                                        case Some(name):
                                            expect name.as_str() == Some("MyService")
                                        case None:
                                            fail("Lost app.name in round-trip")
                                case Err(e):
                                    fail("Failed to re-parse SDN: ${e}")
                        case Err(e):
                            fail("Invalid JSON output: ${e}")
                case Err(e):
                    fail("Failed to load fixture: ${e}")

        it "modifies data fixture and persists":
            val fixture_path = find_fixture("data_example.sdn")
            val temp_path = "/tmp/sdn_fixture_test_${process.pid()}.sdn"

            # Copy fixture to temp file
            match fs.read_to_string(fixture_path):
                case Ok(content):
                    fs.write(temp_path, content)
                case Err(e):
                    fail("Failed to copy fixture: ${e}")

            # Load and modify
            match SdnDocument.from_file(temp_path):
                case Ok(mut doc):
                    # Update statistics
                    doc.set("statistics.total_users", SdnValue.Int(6))
                    doc.set("statistics.active_users", SdnValue.Int(5))

                    # Save changes
                    match doc.write_file(temp_path):
                        case Ok(_):
                            pass
                        case Err(e):
                            fail("Failed to save: ${e}")
                case Err(e):
                    fail("Failed to load: ${e}")

            # Verify changes
            match SdnDocument.from_file(temp_path):
                case Ok(doc):
                    expect doc.get("statistics.total_users").flatmap(|v| v.as_i64()) == Some(6)
                    expect doc.get("statistics.active_users").flatmap(|v| v.as_i64()) == Some(5)
                case Err(e):
                    fail("Failed to verify: ${e}")

            # Cleanup
            fs.remove(temp_path)

### Helper Functions

fn find_fixture(name: String) -> String:
    """Find fixture file by name"""
    val candidates = [
        "simple/std_lib/test/fixtures/sdn/${name}",
        "./simple/std_lib/test/fixtures/sdn/${name}",
        "../../../fixtures/sdn/${name}",
        "test/fixtures/sdn/${name}"
    ]

    for path in candidates:
        if fs.exists(path):
            return path

    fail("Fixture not found: ${name}")

fn json_to_sdn(json_value: json.Value) -> SdnValue:
    """Convert JSON value to SDN value"""
    match json_value:
        case json.Value.Null:
            return SdnValue.Null
        case json.Value.Bool(b):
            return SdnValue.Bool(b)
        case json.Value.Number(n):
            if n.floor() == n:
                return SdnValue.Int(n.to_i64())
            else:
                return SdnValue.Float(n)
        case json.Value.String(s):
            return SdnValue.String(s)
        case json.Value.Array(arr):
            var sdn_arr = []
            for item in arr:
                sdn_arr.push(json_to_sdn(item))
            return SdnValue.Array(sdn_arr)
        case json.Value.Object(obj):
            var sdn_dict = {}
            for (key, val) in obj.items():
                sdn_dict[key] = json_to_sdn(val)
            return SdnValue.Dict(sdn_dict)
