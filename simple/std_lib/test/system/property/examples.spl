# Property Testing Examples
# Demonstrates how to use the property testing framework

module tests.property_examples:
    use std.spec.property.{PropertyConfig, run_property_test, generators}
    use std.spec.expect.{expect}
    
    # Example 1: Basic property test
    @property_test
    fn test_reverse_twice_is_identity():
        # Property: reverse(reverse(list)) == list
        val gen = generators.list(generators.i64())
        val config = PropertyConfig.default()
        
        val result = run_property_test(
            test_fn: |list| {
                val reversed_twice = list.reverse().reverse()
                return reversed_twice == list
            },
            generator: gen,
            config: config
        )
        
        expect(result).to_be_success()
    
    # Example 2: Integer properties
    @property_test(iterations: 1000)
    fn test_addition_commutative():
        # Property: a + b == b + a
        val gen = generators.tuple2(generators.i64(), generators.i64())
        val config = PropertyConfig.default().with_iterations(1000)
        
        val result = run_property_test(
            test_fn: |(a, b)| {
                return a + b == b + a
            },
            generator: gen,
            config: config
        )
        
        expect(result).to_be_success()
    
    # Example 3: String properties
    @property_test
    fn test_string_length_concat():
        # Property: length(s1 + s2) == length(s1) + length(s2)
        val gen = generators.tuple2(generators.string(), generators.string())
        
        val result = run_property_test(
            test_fn: |(s1, s2)| {
                val concatenated = s1 + s2
                return concatenated.length() == s1.length() + s2.length()
            },
            generator: gen,
            config: PropertyConfig.default()
        )
        
        expect(result).to_be_success()
    
    # Example 4: Custom generator
    @property_test
    fn test_sorted_list_is_ordered():
        # Property: sorted list has elements in order
        val gen = generators.list(generators.i64_range(0, 100))
        
        val result = run_property_test(
            test_fn: |list| {
                val sorted = list.sort()
                for i in 0..(sorted.length() - 1):
                    if sorted[i] > sorted[i + 1]:
                        return false
                return true
            },
            generator: gen,
            config: PropertyConfig.default()
        )
        
        expect(result).to_be_success()
    
    # Example 5: Testing with shrinking
    @property_test
    fn test_sum_less_than_threshold():
        # This will fail and demonstrate shrinking
        val gen = generators.list_with_length(
            generators.i64_range(1, 10),
            min: 0,
            max: 10
        )
        
        val result = run_property_test(
            test_fn: |list| {
                # Deliberately false property to show shrinking
                return list.sum() < 5
            },
            generator: gen,
            config: PropertyConfig.default()
        )
        
        # This will fail and show minimal counterexample
        # e.g., [5] or [1, 1, 1, 1, 1]
    
    # Example 6: Generator combinators
    @property_test
    fn test_option_map():
        # Property: option.map(f).map(g) == option.map(f âˆ˜ g)
        val gen = generators.option(generators.i64())
        
        val f = |x| x * 2
        val g = |x| x + 1
        
        val result = run_property_test(
            test_fn: |opt| {
                val left = opt.map(f).map(g)
                val right = opt.map(|x| g(f(x)))
                return left == right
            },
            generator: gen,
            config: PropertyConfig.default()
        )
        
        expect(result).to_be_success()
    
    # Example 7: Conditional properties
    @property_test
    fn test_division_when_nonzero():
        # Property: (a / b) * b == a (when b != 0)
        val gen = generators.tuple2(
            generators.i64(),
            generators.i64_range(1, 100)  # non-zero divisor
        )
        
        val result = run_property_test(
            test_fn: |(a, b)| {
                val quotient = a / b
                val reconstructed = quotient * b
                # Allow for integer division truncation
                return (reconstructed - a).abs() < b
            },
            generator: gen,
            config: PropertyConfig.default()
        )
        
        expect(result).to_be_success()
    
    # Example 8: Using configuration
    @property_test
    fn test_with_custom_config():
        val gen = generators.i64()
        
        val config = PropertyConfig.default()
            .with_iterations(5000)
            .with_seed(42)  # Reproducible
            .verbose()
        
        val result = run_property_test(
            test_fn: |x| {
                return x * 0 == 0
            },
            generator: gen,
            config: config
        )
        
        expect(result).to_be_success()
