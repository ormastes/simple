//! SSpec tests for error_utils.spl

use std.testing.sspec
use tooling.compiler.error_utils

feature "Error Code Enumeration":
    describe "ErrorCode enum":
        it "converts InvalidOperation to string":
            val code = ErrorCode.InvalidOperation
            val result = code.to_string()
            assert result == "INVALID_OPERATION", "Should stringify to INVALID_OPERATION"

        it "converts UndefinedFunction to string":
            val code = ErrorCode.UndefinedFunction
            val result = code.to_string()
            assert result == "UNDEFINED_FUNCTION", "Should stringify to UNDEFINED_FUNCTION"

        it "converts ArgumentCountMismatch to string":
            val code = ErrorCode.ArgumentCountMismatch
            val result = code.to_string()
            assert result == "ARGUMENT_COUNT_MISMATCH", "Should stringify to ARGUMENT_COUNT_MISMATCH"

        it "converts TypeMismatch to string":
            val code = ErrorCode.TypeMismatch
            val result = code.to_string()
            assert result == "TYPE_MISMATCH", "Should stringify to TYPE_MISMATCH"

        it "converts RuntimeError to string":
            val code = ErrorCode.RuntimeError
            val result = code.to_string()
            assert result == "RUNTIME_ERROR", "Should stringify to RUNTIME_ERROR"

feature "Error Context Construction":
    describe "ErrorContext builder pattern":
        it "creates new context with default values":
            val ctx = ErrorContext.new()
            val code_str = ctx.code.to_string()
            assert code_str == "RUNTIME_ERROR", "Default code should be RuntimeError"
            assert ctx.help == "", "Default help should be empty"

        it "sets error code with with_code":
            val ctx = ErrorContext.new()
                .with_code(ErrorCode.InvalidOperation)
            val code_str = ctx.code.to_string()
            assert code_str == "INVALID_OPERATION", "Code should be set to InvalidOperation"

        it "sets help text with with_help":
            val ctx = ErrorContext.new()
                .with_help("This is help text")
            assert ctx.help == "This is help text", "Help text should be set"

        it "chains multiple with_ methods":
            val ctx = ErrorContext.new()
                .with_code(ErrorCode.TypeMismatch)
                .with_help("Check your types")
            val code_str = ctx.code.to_string()
            assert code_str == "TYPE_MISMATCH", "Code should be TypeMismatch"
            assert ctx.help == "Check your types", "Help should be set"

feature "Compile Error Construction":
    describe "CompileError creation":
        it "creates semantic error with context":
            val ctx = ErrorContext.new()
                .with_code(ErrorCode.InvalidOperation)
                .with_help("help text")
            val err = CompileError.semantic_with_context("error message", ctx)
            assert err.message == "error message", "Message should match"
            assert err.context.code.to_string() == "INVALID_OPERATION", "Code should match"

        it "creates runtime error":
            val err = CompileError.runtime("runtime failure")
            assert err.message == "runtime failure", "Message should match"
            assert err.context.code.to_string() == "RUNTIME_ERROR", "Code should be RuntimeError"

        it "converts error to string":
            val ctx = ErrorContext.new().with_code(ErrorCode.TypeMismatch)
            val err = CompileError.semantic_with_context("type error", ctx)
            val result = err.to_string()
            assert result == "[TYPE_MISMATCH] type error", "Should format correctly"

        it "includes help text when present":
            val ctx = ErrorContext.new()
                .with_code(ErrorCode.InvalidOperation)
                .with_help("Check the inputs")
            val err = CompileError.semantic_with_context("bad operation", ctx)
            val result = err.with_help()
            assert result.contains("[INVALID_OPERATION] bad operation"), "Should contain error"
            assert result.contains("Help: Check the inputs"), "Should contain help"

        it "excludes help section when empty":
            val ctx = ErrorContext.new().with_code(ErrorCode.RuntimeError)
            val err = CompileError.semantic_with_context("runtime issue", ctx)
            val result = err.with_help()
            assert not result.contains("Help:"), "Should not have help section"

feature "Error Constructor Functions":
    describe "semantic_error function":
        it "creates semantic error with standard context":
            val err = semantic_error("invalid list operation")
            assert err.message == "invalid list operation", "Message should match"
            assert err.context.code.to_string() == "INVALID_OPERATION", "Code should be InvalidOperation"
            assert err.context.help.contains("check the operation"), "Help should mention operation"

    describe "unknown_function function":
        it "creates unknown function error":
            val err = unknown_function("rt_mystery_function")
            assert err.message.contains("unknown extern function"), "Should mention unknown function"
            assert err.message.contains("rt_mystery_function"), "Should include function name"
            assert err.context.code.to_string() == "UNDEFINED_FUNCTION", "Code should be UndefinedFunction"

        it "provides helpful error message":
            val err = unknown_function("foo")
            assert err.context.help.contains("spelled correctly"), "Should suggest checking spelling"

    describe "wrong_arg_count function":
        it "creates argument count error":
            val err = wrong_arg_count("add", 2, 3)
            assert err.message.contains("add"), "Should include function name"
            assert err.message.contains("2"), "Should include expected count"
            assert err.message.contains("3"), "Should include actual count"
            assert err.context.code.to_string() == "ARGUMENT_COUNT_MISMATCH", "Code should be ArgumentCountMismatch"

        it "formats message correctly":
            val err = wrong_arg_count("concat", 1, 0)
            assert err.message == "concat expects 1 argument(s), got 0", "Message should be formatted"

        it "provides helpful context":
            val err = wrong_arg_count("multiply", 2, 5)
            assert err.context.help.contains("2 argument(s)"), "Help should mention required count"

    describe "wrong_arg_type function":
        it "creates argument type error":
            val err = wrong_arg_type("substring", 0, "string")
            assert err.message.contains("substring"), "Should include function name"
            assert err.message.contains("string"), "Should include expected type"
            assert err.message.contains("0"), "Should include position"
            assert err.context.code.to_string() == "TYPE_MISMATCH", "Code should be TypeMismatch"

        it "formats position correctly":
            val err = wrong_arg_type("map", 1, "function")
            assert err.message.contains("position 1"), "Should specify position"

        it "provides type hint in help":
            val err = wrong_arg_type("filter", 0, "lambda")
            assert err.context.help.contains("lambda"), "Help should mention expected type"
            assert err.context.help.contains("position 0"), "Help should mention position"

    describe "deprecated_function function":
        it "creates deprecation error":
            val err = deprecated_function("old_api", "new_api", "Faster implementation")
            assert err.message.contains("old_api"), "Should mention old name"
            assert err.message.contains("new_api"), "Should mention new name"
            assert err.message.contains("Faster implementation"), "Should include reason"

        it "formats deprecation message correctly":
            val err = deprecated_function("foo", "bar", "Better design")
            assert err.message == "'foo' is deprecated. Use 'bar' instead. Better design", "Message should be formatted"

        it "uses runtime error code":
            val err = deprecated_function("a", "b", "c")
            assert err.context.code.to_string() == "RUNTIME_ERROR", "Should be runtime error"

    describe "runtime_error function":
        it "creates simple runtime error":
            val err = runtime_error("division by zero")
            assert err.message == "division by zero", "Message should match"
            assert err.context.code.to_string() == "RUNTIME_ERROR", "Code should be RuntimeError"

feature "Error Message Formatting":
    describe "message generation":
        it "interpolates function names correctly":
            val err = wrong_arg_count("my_function", 3, 2)
            assert err.message.contains("my_function"), "Should contain function name"

        it "interpolates numbers correctly":
            val err = wrong_arg_type("process", 5, "integer")
            assert err.message.contains("5"), "Should contain position number"

        it "handles empty strings":
            val err = unknown_function("")
            assert err.message == "unknown extern function: ", "Should handle empty string"

        it "handles special characters in names":
            val err = unknown_function("rt_get_$value")
            assert err.message.contains("rt_get_$value"), "Should preserve special chars"

feature "Lean Verification Properties":
    describe "deterministic error construction":
        it "produces identical errors for same inputs":
            val err1 = wrong_arg_count("func", 2, 3)
            val err2 = wrong_arg_count("func", 2, 3)
            assert err1.message == err2.message, "Messages should be identical"
            assert err1.context.code.to_string() == err2.context.code.to_string(), "Codes should be identical"

        it "is pure (no side effects)":
            # This property is implicit - function has no observable side effects
            # Creates new error object without modifying any global state
            val before_count = 0  # Hypothetical error counter
            val err = semantic_error("test")
            val after_count = 0   # Should still be 0
            assert before_count == after_count, "Should have no side effects"

    describe "error code exhaustiveness":
        it "covers all error scenarios":
            # Verify all error codes can be constructed
            val codes = [
                ErrorCode.InvalidOperation,
                ErrorCode.UndefinedFunction,
                ErrorCode.ArgumentCountMismatch,
                ErrorCode.TypeMismatch,
                ErrorCode.RuntimeError
            ]
            # All codes should convert to strings
            for code in codes:
                val str = code.to_string()
                assert str.len() > 0, "All codes should have non-empty strings"

feature "Edge Cases":
    describe "boundary conditions":
        it "handles zero argument count":
            val err = wrong_arg_count("func", 0, 1)
            assert err.message.contains("0 argument(s)"), "Should handle zero"

        it "handles large argument counts":
            val err = wrong_arg_count("func", 100, 99)
            assert err.message.contains("100"), "Should handle large numbers"

        it "handles very long function names":
            val long_name = "very_long_function_name_that_exceeds_normal_length"
            val err = unknown_function(long_name)
            assert err.message.contains(long_name), "Should handle long names"

        it "handles empty help text":
            val ctx = ErrorContext.new().with_help("")
            val err = CompileError.semantic_with_context("msg", ctx)
            val help_str = err.with_help()
            assert not help_str.contains("Help:"), "Empty help should not show section"
