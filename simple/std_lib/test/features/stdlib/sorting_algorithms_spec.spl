# Sorting Algorithms Feature Specification
# Feature: Configurable sorting algorithms with SortAlgorithm enum
# Category: Stdlib | Difficulty: 3 | Status: Complete

"""
Configurable Sorting Algorithms - Feature #1002

Overview:
    Configurable sorting algorithms allowing users to choose between
    InsertionSort, PDQSort, TimSort, and HeapSort based on their specific
    needs. PDQSort is the default for general-purpose sorting.

Syntax:
    list.sort()                              # Default (PDQSort)
    list.sort_with(SortAlgorithm::TimSort)   # Specific algorithm
    SortAlgorithm::TimSort.is_stable()       # Check stability

Implementation:
    - SortAlgorithm enum with 4 variants:
      - InsertionSort: stable, for small arrays
      - PDQSort: unstable, fast general-purpose (default)
      - TimSort: stable, for nearly-sorted data
      - HeapSort: unstable, guaranteed O(n log n)
    - is_stable() method to check stability
    - sort() uses PDQSort by default
    - sort_with() accepts algorithm parameter
    - Handles all edge cases: empty, single, sorted, reverse

Notes:
    - PDQSort is the default algorithm
    - TimSort is recommended for nearly-sorted data
    - InsertionSort is used internally for small arrays
    - All algorithms handle duplicates correctly
"""

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 1002,
    name: "Configurable Sorting Algorithms",
    category: "Stdlib",
    difficulty: 3,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "simple/improve_request.md",
    files: [
        "simple/std_lib/src/core/sorting.spl",
        "simple/std_lib/src/core/collections.spl",
        "simple/std_lib/src/core/list.spl"
    ],
    tests: [
        "simple/std_lib/test/features/stdlib/sorting_algorithms_spec.spl"
    ],
    description: "Configurable sorting algorithms allowing users to choose between InsertionSort, PDQSort, TimSort, and HeapSort based on their specific needs.",
    code_examples: [
        "# Default sort (PDQSort)",
        "list.sort()",
        "",
        "# Sort with specific algorithm",
        "list.sort_with(SortAlgorithm::TimSort)",
        "",
        "# Check algorithm properties",
        "SortAlgorithm::TimSort.is_stable()  # true"
    ],
    dependencies: [],
    required_by: [],
    notes: "PDQSort is the default algorithm. TimSort is recommended for nearly-sorted data. InsertionSort is used internally for small arrays."
}

# =====================================================
# BDD Specification Tests
# =====================================================

print("============================================================")
print("  SORTING ALGORITHMS SPECIFICATION (#1002)")
print("  Category: Stdlib | Difficulty: 3 | Status: Complete")
print("============================================================")
print("")

var passed = 0
var failed = 0

# describe "SortAlgorithm enum"
print("describe SortAlgorithm enum:")

# it "has InsertionSort variant"
print("  it has InsertionSort variant:")
val insertion = SortAlgorithm::InsertionSort
if insertion.to_string() == "InsertionSort":
    print("    [PASS] InsertionSort variant exists")
    passed = passed + 1
else:
    print("    [FAIL] InsertionSort variant")
    failed = failed + 1

# it "has PDQSort variant"
print("  it has PDQSort variant:")
val pdq = SortAlgorithm::PDQSort
if pdq.to_string() == "PDQSort":
    print("    [PASS] PDQSort variant exists")
    passed = passed + 1
else:
    print("    [FAIL] PDQSort variant")
    failed = failed + 1

# it "has TimSort variant"
print("  it has TimSort variant:")
val tim = SortAlgorithm::TimSort
if tim.to_string() == "TimSort":
    print("    [PASS] TimSort variant exists")
    passed = passed + 1
else:
    print("    [FAIL] TimSort variant")
    failed = failed + 1

# it "has HeapSort variant"
print("  it has HeapSort variant:")
val heap = SortAlgorithm::HeapSort
if heap.to_string() == "HeapSort":
    print("    [PASS] HeapSort variant exists")
    passed = passed + 1
else:
    print("    [FAIL] HeapSort variant")
    failed = failed + 1

# describe "Algorithm stability"
print("")
print("describe Algorithm stability:")

# it "InsertionSort is stable"
print("  it InsertionSort is stable:")
if SortAlgorithm::InsertionSort.is_stable():
    print("    [PASS] InsertionSort is stable")
    passed = passed + 1
else:
    print("    [FAIL] InsertionSort should be stable")
    failed = failed + 1

# it "TimSort is stable"
print("  it TimSort is stable:")
if SortAlgorithm::TimSort.is_stable():
    print("    [PASS] TimSort is stable")
    passed = passed + 1
else:
    print("    [FAIL] TimSort should be stable")
    failed = failed + 1

# it "PDQSort is unstable"
print("  it PDQSort is unstable:")
if not SortAlgorithm::PDQSort.is_stable():
    print("    [PASS] PDQSort is unstable")
    passed = passed + 1
else:
    print("    [FAIL] PDQSort should be unstable")
    failed = failed + 1

# it "HeapSort is unstable"
print("  it HeapSort is unstable:")
if not SortAlgorithm::HeapSort.is_stable():
    print("    [PASS] HeapSort is unstable")
    passed = passed + 1
else:
    print("    [FAIL] HeapSort should be unstable")
    failed = failed + 1

# describe "List sort_with()"
print("")
print("describe List sort_with():")

# it "sorts with InsertionSort"
print("  it sorts with InsertionSort:")
var list1 = [5, 2, 8, 1, 9]
list1.sort_with(SortAlgorithm::InsertionSort)
if list1.get(0) == Some(1) and list1.get(4) == Some(9):
    print("    [PASS] InsertionSort sorts correctly")
    passed = passed + 1
else:
    print("    [FAIL] InsertionSort sorting")
    failed = failed + 1

# it "sorts with PDQSort"
print("  it sorts with PDQSort:")
var list2 = [5, 2, 8, 1, 9]
list2.sort_with(SortAlgorithm::PDQSort)
if list2.get(0) == Some(1) and list2.get(4) == Some(9):
    print("    [PASS] PDQSort sorts correctly")
    passed = passed + 1
else:
    print("    [FAIL] PDQSort sorting")
    failed = failed + 1

# it "sorts with TimSort"
print("  it sorts with TimSort:")
var list3 = [5, 2, 8, 1, 9]
list3.sort_with(SortAlgorithm::TimSort)
if list3.get(0) == Some(1) and list3.get(4) == Some(9):
    print("    [PASS] TimSort sorts correctly")
    passed = passed + 1
else:
    print("    [FAIL] TimSort sorting")
    failed = failed + 1

# it "sorts with HeapSort"
print("  it sorts with HeapSort:")
var list4 = [5, 2, 8, 1, 9]
list4.sort_with(SortAlgorithm::HeapSort)
if list4.get(0) == Some(1) and list4.get(4) == Some(9):
    print("    [PASS] HeapSort sorts correctly")
    passed = passed + 1
else:
    print("    [FAIL] HeapSort sorting")
    failed = failed + 1

# describe "Default sort()"
print("")
print("describe Default sort():")

# it "uses PDQSort by default"
print("  it uses PDQSort by default:")
var list5 = [3, 1, 4, 1, 5, 9, 2, 6]
list5.sort()
if list5.get(0) == Some(1) and list5.get(7) == Some(9):
    print("    [PASS] default sort() works correctly")
    passed = passed + 1
else:
    print("    [FAIL] default sort()")
    failed = failed + 1

# describe "Edge cases"
print("")
print("describe Edge cases:")

# it "handles empty list"
print("  it handles empty list:")
var empty_list: List<i64> = []
empty_list.sort()
if empty_list.len() == 0:
    print("    [PASS] empty list sort succeeds")
    passed = passed + 1
else:
    print("    [FAIL] empty list sort")
    failed = failed + 1

# it "handles single element"
print("  it handles single element:")
var single_list = [42]
single_list.sort()
if single_list.get(0) == Some(42):
    print("    [PASS] single element sort succeeds")
    passed = passed + 1
else:
    print("    [FAIL] single element sort")
    failed = failed + 1

# it "handles already sorted"
print("  it handles already sorted:")
var sorted_list = [1, 2, 3, 4, 5]
sorted_list.sort()
if sorted_list.get(0) == Some(1) and sorted_list.get(4) == Some(5):
    print("    [PASS] already sorted list unchanged")
    passed = passed + 1
else:
    print("    [FAIL] already sorted list")
    failed = failed + 1

# it "handles reverse sorted"
print("  it handles reverse sorted:")
var reverse_list = [5, 4, 3, 2, 1]
reverse_list.sort()
if reverse_list.get(0) == Some(1) and reverse_list.get(4) == Some(5):
    print("    [PASS] reverse sorted list sorted correctly")
    passed = passed + 1
else:
    print("    [FAIL] reverse sorted list")
    failed = failed + 1

# it "handles duplicates"
print("  it handles duplicates:")
var dup_list = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
dup_list.sort()
if dup_list.get(0) == Some(1) and dup_list.get(1) == Some(1):
    print("    [PASS] duplicates handled correctly")
    passed = passed + 1
else:
    print("    [FAIL] duplicates handling")
    failed = failed + 1

# =====================================================
# Generated Documentation
# =====================================================

print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# Configurable Sorting Algorithms")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5")
print("**Status:** {FEATURE.status}")
print("**Implementation:** {FEATURE.impl_type}")
print("")
print("## Description")
print("")
print("{FEATURE.description}")
print("")
print("## Implementation Files")
for file in FEATURE.files:
    print("- `{file}`")
print("")
print("## Test Files")
for test in FEATURE.tests:
    print("- `{test}`")
print("")
print("## Code Examples")
print("")
print("```simple")
for example in FEATURE.code_examples:
    print("{example}")
print("```")
print("")
print("## Notes")
print("")
print("{FEATURE.notes}")

# =====================================================
# Test Summary
# =====================================================

print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {passed + failed}")

if failed == 0:
    print("")
    print("All tests PASSED!")

print("============================================================")
