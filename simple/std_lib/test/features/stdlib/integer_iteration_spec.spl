# Integer Iteration Methods Feature Specification
# Feature: Ruby-style integer iteration methods (times, upto, downto)
# Category: Stdlib | Difficulty: 2 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 1004,
    name: "Integer Iteration Methods",
    category: "Stdlib",
    difficulty: 2,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "simple/improve_request.md",
    files: [
        "simple/std_lib/src/core/primitives.spl"
    ],
    tests: [
        "simple/std_lib/test/features/stdlib/integer_iteration_spec.spl"
    ],
    description: "Ruby-style integer iteration methods: times(), upto(), and downto(). These methods provide convenient ways to iterate over ranges of integers.",
    code_examples: [
        "# Execute n times (0 to n-1)",
        "5.times(|i| print(i))  # 0, 1, 2, 3, 4",
        "",
        "# Iterate from start to end (inclusive)",
        "1.upto(5, |i| print(i))  # 1, 2, 3, 4, 5",
        "",
        "# Iterate from start down to end (inclusive)",
        "5.downto(1, |i| print(i))  # 5, 4, 3, 2, 1"
    ],
    dependencies: [],
    required_by: [],
    notes: "These methods are inspired by Ruby's Integer class. They provide a more expressive alternative to traditional for loops."
}

# =====================================================
# BDD Specification Tests
# =====================================================

print("============================================================")
print("  INTEGER ITERATION METHODS SPECIFICATION (#1004)")
print("  Category: Stdlib | Difficulty: 2 | Status: Complete")
print("============================================================")
print("")

var passed = 0
var failed = 0

# describe "times() method"
print("describe times() method:")

# it "executes n times for positive n"
print("  it executes n times for positive n:")
var times_count = 0
val n: i64 = 5
n.times(|_| times_count = times_count + 1)
if times_count == 5:
    print("    [PASS] 5.times() executes 5 times")
    passed = passed + 1
else:
    print("    [FAIL] times() execution count")
    failed = failed + 1

# it "provides index starting at 0"
print("  it provides index starting at 0:")
var first_index: i64 = -1
val m: i64 = 3
m.times(|i| if first_index == -1: first_index = i)
if first_index == 0:
    print("    [PASS] times() index starts at 0")
    passed = passed + 1
else:
    print("    [FAIL] times() index start")
    failed = failed + 1

# it "provides last index as n-1"
print("  it provides last index as n-1:")
var last_index: i64 = -1
val p: i64 = 5
p.times(|i| last_index = i)
if last_index == 4:
    print("    [PASS] times() last index is n-1")
    passed = passed + 1
else:
    print("    [FAIL] times() last index")
    failed = failed + 1

# it "does nothing for 0"
print("  it does nothing for 0:")
var zero_count = 0
val zero: i64 = 0
zero.times(|_| zero_count = zero_count + 1)
if zero_count == 0:
    print("    [PASS] 0.times() does nothing")
    passed = passed + 1
else:
    print("    [FAIL] 0.times()")
    failed = failed + 1

# it "does nothing for negative"
print("  it does nothing for negative:")
var neg_count = 0
val negative: i64 = -5
negative.times(|_| neg_count = neg_count + 1)
if neg_count == 0:
    print("    [PASS] (-5).times() does nothing")
    passed = passed + 1
else:
    print("    [FAIL] negative.times()")
    failed = failed + 1

# describe "upto() method"
print("")
print("describe upto() method:")

# it "iterates from start to end inclusive"
print("  it iterates from start to end inclusive:")
var upto_sum: i64 = 0
val start: i64 = 1
start.upto(5, |i| upto_sum = upto_sum + i)
# 1 + 2 + 3 + 4 + 5 = 15
if upto_sum == 15:
    print("    [PASS] 1.upto(5) sums to 15")
    passed = passed + 1
else:
    print("    [FAIL] upto() sum")
    failed = failed + 1

# it "includes start value"
print("  it includes start value:")
var upto_first: i64 = -1
val s2: i64 = 3
s2.upto(7, |i| if upto_first == -1: upto_first = i)
if upto_first == 3:
    print("    [PASS] upto() includes start value")
    passed = passed + 1
else:
    print("    [FAIL] upto() start value")
    failed = failed + 1

# it "includes end value"
print("  it includes end value:")
var upto_last: i64 = -1
val s3: i64 = 1
s3.upto(5, |i| upto_last = i)
if upto_last == 5:
    print("    [PASS] upto() includes end value")
    passed = passed + 1
else:
    print("    [FAIL] upto() end value")
    failed = failed + 1

# it "works when start equals end"
print("  it works when start equals end:")
var same_count = 0
var same_val: i64 = -1
val s4: i64 = 5
s4.upto(5, |i| { same_count = same_count + 1; same_val = i })
if same_count == 1 and same_val == 5:
    print("    [PASS] upto() works when start == end")
    passed = passed + 1
else:
    print("    [FAIL] upto() start == end")
    failed = failed + 1

# it "does nothing when start > end"
print("  it does nothing when start > end:")
var nothing_count = 0
val s5: i64 = 10
s5.upto(5, |_| nothing_count = nothing_count + 1)
if nothing_count == 0:
    print("    [PASS] upto() does nothing when start > end")
    passed = passed + 1
else:
    print("    [FAIL] upto() start > end")
    failed = failed + 1

# describe "downto() method"
print("")
print("describe downto() method:")

# it "iterates from start down to end inclusive"
print("  it iterates from start down to end inclusive:")
var downto_sum: i64 = 0
val d1: i64 = 5
d1.downto(1, |i| downto_sum = downto_sum + i)
# 5 + 4 + 3 + 2 + 1 = 15
if downto_sum == 15:
    print("    [PASS] 5.downto(1) sums to 15")
    passed = passed + 1
else:
    print("    [FAIL] downto() sum")
    failed = failed + 1

# it "includes start value"
print("  it includes start value:")
var downto_first: i64 = -1
val d2: i64 = 7
d2.downto(3, |i| if downto_first == -1: downto_first = i)
if downto_first == 7:
    print("    [PASS] downto() includes start value")
    passed = passed + 1
else:
    print("    [FAIL] downto() start value")
    failed = failed + 1

# it "includes end value"
print("  it includes end value:")
var downto_last: i64 = -1
val d3: i64 = 5
d3.downto(1, |i| downto_last = i)
if downto_last == 1:
    print("    [PASS] downto() includes end value")
    passed = passed + 1
else:
    print("    [FAIL] downto() end value")
    failed = failed + 1

# it "works when start equals end"
print("  it works when start equals end:")
var same_down_count = 0
var same_down_val: i64 = -1
val d4: i64 = 5
d4.downto(5, |i| { same_down_count = same_down_count + 1; same_down_val = i })
if same_down_count == 1 and same_down_val == 5:
    print("    [PASS] downto() works when start == end")
    passed = passed + 1
else:
    print("    [FAIL] downto() start == end")
    failed = failed + 1

# it "does nothing when start < end"
print("  it does nothing when start < end:")
var nothing_down_count = 0
val d5: i64 = 1
d5.downto(10, |_| nothing_down_count = nothing_down_count + 1)
if nothing_down_count == 0:
    print("    [PASS] downto() does nothing when start < end")
    passed = passed + 1
else:
    print("    [FAIL] downto() start < end")
    failed = failed + 1

# describe "Edge cases"
print("")
print("describe Edge cases:")

# it "times() handles 1"
print("  it times() handles 1:")
var one_count = 0
val one: i64 = 1
one.times(|_| one_count = one_count + 1)
if one_count == 1:
    print("    [PASS] 1.times() executes once")
    passed = passed + 1
else:
    print("    [FAIL] 1.times()")
    failed = failed + 1

# it "upto/downto handle negative ranges"
print("  it upto/downto handle negative ranges:")
var neg_range_sum: i64 = 0
val neg_start: i64 = -3
neg_start.upto(-1, |i| neg_range_sum = neg_range_sum + i)
# -3 + -2 + -1 = -6
if neg_range_sum == -6:
    print("    [PASS] negative range iteration works")
    passed = passed + 1
else:
    print("    [FAIL] negative range iteration")
    failed = failed + 1

# =====================================================
# Generated Documentation
# =====================================================

print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# Integer Iteration Methods")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5")
print("**Status:** {FEATURE.status}")
print("**Implementation:** {FEATURE.impl_type}")
print("")
print("## Description")
print("")
print("{FEATURE.description}")
print("")
print("## Implementation Files")
for file in FEATURE.files:
    print("- `{file}`")
print("")
print("## Test Files")
for test in FEATURE.tests:
    print("- `{test}`")
print("")
print("## Code Examples")
print("")
print("```simple")
for example in FEATURE.code_examples:
    print("{example}")
print("```")
print("")
print("## Notes")
print("")
print("{FEATURE.notes}")

# =====================================================
# Test Summary
# =====================================================

print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {passed + failed}")

if failed == 0:
    print("")
    print("All tests PASSED!")

print("============================================================")
