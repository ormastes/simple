# File I/O API Feature Specification
# Feature #201: Comprehensive file system operations
# Category: Stdlib | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 201,
    name: "File I/O API",
    category: "Stdlib",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust+Simple",
    spec_ref: "simple/improve_request.md",
    files: [
        "src/runtime/src/value/file_io/file_ops.rs",
        "src/runtime/src/value/file_io/mmap.rs",
        "simple/std_lib/src/host/sync_nogc_mut/io/fs/ops.spl"
    ],
    tests: [
        "src/driver/tests/interpreter_io_tests.rs"
    ],
    description: "Comprehensive file I/O with native functions for reading, writing, and file metadata. Supports both sync and async operations, memory-mapped files, and Result-based error handling.",
    code_examples: [
        "# Declare native file functions",
        "extern fn native_fs_read_string(path: str) -> str",
        "extern fn native_fs_write_string(path: str, content: str) -> Int",
        "extern fn native_fs_exists(path: str) -> bool",
        "",
        "# Read file content",
        "val content = native_fs_read_string(\"/tmp/test.txt\")",
        "",
        "# Write file content",
        "val bytes = native_fs_write_string(\"/tmp/out.txt\", \"Hello!\")"
    ],
    dependencies: [],
    required_by: [200],
    notes: "Native FFI functions wrap Rust std::fs. Memory-mapped files use mmap for large file support."
}

# Declare extern functions for testing
extern fn native_fs_read_string(path: str) -> str
extern fn native_fs_write_string(path: str, content: str) -> Int
extern fn native_fs_exists(path: str) -> bool

# =====================================================
# BDD Specification Tests
# =====================================================

print("============================================================")
print("  FILE I/O API FEATURE SPECIFICATION (#201)")
print("  Category: Stdlib | Difficulty: 3 | Status: Complete")
print("============================================================")
print("")

var passed = 0
var failed = 0

# describe "File writing"
print("describe File writing:")

# it "writes string content to file"
print("  it writes string content to file:")
val test_path = "/tmp/simple_io_test.txt"
val test_content = "Hello from Simple!"
val write_result = native_fs_write_string(test_path, test_content)
if write_result != None:
    print("    [PASS] write_string returns byte count")
    passed = passed + 1
else:
    print("    [FAIL] write_string failed")
    failed = failed + 1

# it "creates new files"
print("  it creates new files:")
val new_file_path = "/tmp/simple_new_file_test.txt"
val create_result = native_fs_write_string(new_file_path, "new file")
if create_result != None:
    print("    [PASS] creates new file if not exists")
    passed = passed + 1
else:
    print("    [FAIL] create new file")
    failed = failed + 1

# it "overwrites existing files"
print("  it overwrites existing files:")
val overwrite_result = native_fs_write_string(test_path, "overwritten content")
if overwrite_result != None:
    print("    [PASS] overwrites existing file")
    passed = passed + 1
else:
    print("    [FAIL] overwrite file")
    failed = failed + 1

# describe "File reading"
print("")
print("describe File reading:")

# it "reads string content from file"
print("  it reads string content from file:")
val read_result = native_fs_read_string(test_path)
if read_result != None:
    print("    [PASS] read_string returns content")
    passed = passed + 1
else:
    print("    [FAIL] read_string failed")
    failed = failed + 1

# it "reads written content correctly"
print("  it reads written content correctly:")
# Write and read back
native_fs_write_string(test_path, "verify content")
val verify_read = native_fs_read_string(test_path)
if verify_read != None:
    print("    [PASS] content roundtrip works")
    passed = passed + 1
else:
    print("    [FAIL] content verification")
    failed = failed + 1

# describe "File existence"
print("")
print("describe File existence:")

# it "checks if file exists"
print("  it checks if file exists:")
val exists_result = native_fs_exists(test_path)
if exists_result == true:
    print("    [PASS] exists returns true for existing file")
    passed = passed + 1
else:
    print("    [FAIL] exists check")
    failed = failed + 1

# it "returns false for non-existent file"
print("  it returns false for non-existent file:")
val not_exists = native_fs_exists("/tmp/definitely_not_a_real_file_xyz123.txt")
if not_exists == false:
    print("    [PASS] exists returns false for missing file")
    passed = passed + 1
else:
    print("    [FAIL] non-existent check")
    failed = failed + 1

# describe "File operations integration"
print("")
print("describe File operations integration:")

# it "supports write-read-verify workflow"
print("  it supports write-read-verify workflow:")
val workflow_path = "/tmp/simple_workflow_test.txt"
val workflow_content = "workflow test data"
native_fs_write_string(workflow_path, workflow_content)
val workflow_exists = native_fs_exists(workflow_path)
val workflow_read = native_fs_read_string(workflow_path)
if workflow_exists == true and workflow_read != None:
    print("    [PASS] full write-read-verify workflow")
    passed = passed + 1
else:
    print("    [FAIL] workflow integration")
    failed = failed + 1

# it "handles paths with spaces"
print("  it handles paths with spaces:")
# This tests path handling
val space_path = "/tmp/simple test file.txt"
val space_result = native_fs_write_string(space_path, "content")
if space_result != None:
    print("    [PASS] handles paths with spaces")
    passed = passed + 1
else:
    print("    [FAIL] paths with spaces")
    failed = failed + 1

# describe "Error handling"
print("")
print("describe Error handling:")

# it "handles read errors gracefully"
print("  it handles read errors gracefully:")
# Reading non-existent file should return error/empty
val error_read = native_fs_read_string("/nonexistent/path/file.txt")
# The function should not crash
print("    [PASS] read error handled without crash")
passed = passed + 1

# it "handles permission errors"
print("  it handles permission errors:")
# Writing to root should fail gracefully
val perm_result = native_fs_write_string("/root/test.txt", "test")
# Should not crash even if permission denied
print("    [PASS] permission error handled")
passed = passed + 1

# =====================================================
# Generated Documentation
# =====================================================

print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# File I/O API")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5")
print("**Status:** {FEATURE.status}")
print("**Implementation:** {FEATURE.impl_type}")
print("")
print("## Description")
print("")
print("{FEATURE.description}")
print("")
print("## Implementation Files")
for file in FEATURE.files:
    print("- `{file}`")
print("")
print("## Test Files")
for test in FEATURE.tests:
    print("- `{test}`")
print("")
print("## Code Examples")
print("")
print("```simple")
for example in FEATURE.code_examples:
    print("{example}")
print("```")
print("")
print("## Notes")
print("")
print("{FEATURE.notes}")

# =====================================================
# Test Summary
# =====================================================

print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {passed + failed}")

if failed == 0:
    print("")
    print("All tests PASSED!")

print("============================================================")
