# Empty Predicate Feature Specification
# Feature: Ruby-style empty? predicate for collections and strings
# Category: Stdlib | Difficulty: 1 | Status: Complete

"""
Empty Predicate - Feature #1001

Overview:
    Ruby-style empty? predicate method for collections and strings. Provides
    a convenient way to check if a collection has no elements. The empty?()
    method is a Ruby-style alias for is_empty() with both methods available.

Syntax:
    val empty_list: List<i64> = []
    empty_list.empty?()  # true

    "".empty?()          # true
    "hello".empty?()     # false

Implementation:
    - empty?() method on List, String, and Slice types
    - Returns true for empty collections
    - Returns false for non-empty collections
    - Equivalent to is_empty() method
    - Works after clear() or pop() operations
    - String whitespace is not considered empty (has bytes)

Notes:
    - The empty?() method is a Ruby-style alias for is_empty()
    - Both methods are available for compatibility
    - Provides more expressive code than len() == 0
"""

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 1001,
    name: "Empty Predicate",
    category: "Stdlib",
    difficulty: 1,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "simple/improve_request.md",
    files: [
        "simple/std_lib/src/core/traits.spl"
    ],
    tests: [
        "simple/std_lib/test/features/stdlib/empty_predicate_spec.spl"
    ],
    description: "Ruby-style empty? predicate method for collections and strings. Provides a convenient way to check if a collection has no elements.",
    code_examples: [
        "# List empty check",
        "val empty_list: List<i64> = []",
        "empty_list.empty?()  # true",
        "",
        "# String empty check",
        "\"\".empty?()  # true",
        "\"hello\".empty?()  # false"
    ],
    dependencies: [],
    required_by: [],
    notes: "The empty?() method is a Ruby-style alias for is_empty(). Both methods are available."
}

# =====================================================
# BDD Specification Tests
# =====================================================

print("============================================================")
print("  EMPTY PREDICATE SPECIFICATION (#1001)")
print("  Category: Stdlib | Difficulty: 1 | Status: Complete")
print("============================================================")
print("")

var passed = 0
var failed = 0

# describe "List empty?"
print("describe List empty?:")

# it "returns true for empty list"
print("  it returns true for empty list:")
val empty_list: List<i64> = []
if empty_list.empty?():
    print("    [PASS] empty list returns true")
    passed = passed + 1
else:
    print("    [FAIL] empty list should return true")
    failed = failed + 1

# it "returns false for non-empty list"
print("  it returns false for non-empty list:")
val non_empty_list = [1, 2, 3]
if not non_empty_list.empty?():
    print("    [PASS] non-empty list returns false")
    passed = passed + 1
else:
    print("    [FAIL] non-empty list should return false")
    failed = failed + 1

# it "is equivalent to is_empty()"
print("  it is equivalent to is_empty():")
val test_list: List<i64> = []
if test_list.empty?() == test_list.is_empty():
    print("    [PASS] empty?() equals is_empty()")
    passed = passed + 1
else:
    print("    [FAIL] empty?() should equal is_empty()")
    failed = failed + 1

# describe "String empty?"
print("")
print("describe String empty?:")

# it "returns true for empty string"
print("  it returns true for empty string:")
val empty_str = ""
if empty_str.empty?():
    print("    [PASS] empty string returns true")
    passed = passed + 1
else:
    print("    [FAIL] empty string should return true")
    failed = failed + 1

# it "returns false for non-empty string"
print("  it returns false for non-empty string:")
val non_empty_str = "hello"
if not non_empty_str.empty?():
    print("    [PASS] non-empty string returns false")
    passed = passed + 1
else:
    print("    [FAIL] non-empty string should return false")
    failed = failed + 1

# it "returns false for whitespace string"
print("  it returns false for whitespace string:")
val whitespace_str = "   "
if not whitespace_str.empty?():
    print("    [PASS] whitespace string returns false (has bytes)")
    passed = passed + 1
else:
    print("    [FAIL] whitespace string should return false")
    failed = failed + 1

# describe "Slice empty?"
print("")
print("describe Slice empty?:")

# it "returns true for empty slice"
print("  it returns true for empty slice:")
val empty_slice = Slice<i64>::empty()
if empty_slice.empty?():
    print("    [PASS] empty slice returns true")
    passed = passed + 1
else:
    print("    [FAIL] empty slice should return true")
    failed = failed + 1

# it "returns false for slice with elements"
print("  it returns false for slice with elements:")
val list_for_slice = [1, 2, 3]
val non_empty_slice = list_for_slice.as_slice()
if not non_empty_slice.empty?():
    print("    [PASS] non-empty slice returns false")
    passed = passed + 1
else:
    print("    [FAIL] non-empty slice should return false")
    failed = failed + 1

# describe "Edge cases"
print("")
print("describe Edge cases:")

# it "handles list after clear"
print("  it handles list after clear:")
var mutable_list = [1, 2, 3]
mutable_list.clear()
if mutable_list.empty?():
    print("    [PASS] cleared list returns true")
    passed = passed + 1
else:
    print("    [FAIL] cleared list should return true")
    failed = failed + 1

# it "handles list after pop to empty"
print("  it handles list after pop to empty:")
var single_list = [42]
single_list.pop()
if single_list.empty?():
    print("    [PASS] popped-to-empty list returns true")
    passed = passed + 1
else:
    print("    [FAIL] popped-to-empty list should return true")
    failed = failed + 1

# =====================================================
# Generated Documentation
# =====================================================

print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# Empty Predicate")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5")
print("**Status:** {FEATURE.status}")
print("**Implementation:** {FEATURE.impl_type}")
print("")
print("## Description")
print("")
print("{FEATURE.description}")
print("")
print("## Implementation Files")
for file in FEATURE.files:
    print("- `{file}`")
print("")
print("## Test Files")
for test in FEATURE.tests:
    print("- `{test}`")
print("")
print("## Code Examples")
print("")
print("```simple")
for example in FEATURE.code_examples:
    print("{example}")
print("```")
print("")
print("## Notes")
print("")
print("{FEATURE.notes}")

# =====================================================
# Test Summary
# =====================================================

print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {passed + failed}")

if failed == 0:
    print("")
    print("All tests PASSED!")

print("============================================================")
