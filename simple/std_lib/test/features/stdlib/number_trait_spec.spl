# Number Trait Feature Specification
# Feature: Number trait unifying Int and Float numeric types
# Category: Stdlib | Difficulty: 2 | Status: Complete

"""
Number Trait - Feature #1003

Overview:
    Number trait providing a unified interface for numeric types (i64, f64).
    Enables generic programming over numbers with methods like zero(), one(),
    abs(), signum(), and conversions. Common interface for both integer and
    floating-point types.

Syntax:
    val x: i64 = -42
    x.abs()          # 42
    x.signum()       # -1
    x.is_negative()  # true

    val y: f64 = -3.14
    y.abs()          # 3.14
    y.to_i64()       # -3

Implementation:
    - Number trait implemented for i64 and f64
    - Static methods: zero(), one()
    - Instance methods: abs(), signum()
    - Predicates: is_zero(), is_positive(), is_negative()
    - Conversions: to_i64(), to_f64()
    - f64::to_i64() truncates toward zero
    - Handles edge cases: negative zero, large integers

Notes:
    - The Number trait provides a common interface for both integer and
      floating-point types, enabling generic numeric algorithms
    - Enables writing generic functions over numeric types
"""

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 1003,
    name: "Number Trait",
    category: "Stdlib",
    difficulty: 2,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "simple/improve_request.md",
    files: [
        "simple/std_lib/src/core/traits.spl",
        "simple/std_lib/src/core/primitives.spl"
    ],
    tests: [
        "simple/std_lib/test/features/stdlib/number_trait_spec.spl"
    ],
    description: "Number trait providing a unified interface for numeric types (i64, f64). Enables generic programming over numbers with methods like zero(), one(), abs(), signum(), and conversions.",
    code_examples: [
        "# Number trait methods on integers",
        "val x: i64 = -42",
        "x.abs()       # 42",
        "x.signum()    # -1",
        "x.is_negative()  # true",
        "",
        "# Number trait methods on floats",
        "val y: f64 = -3.14",
        "y.abs()       # 3.14",
        "y.signum()    # -1.0",
        "y.to_i64()    # -3"
    ],
    dependencies: [],
    required_by: [],
    notes: "The Number trait provides a common interface for both integer and floating-point types, enabling generic numeric algorithms."
}

# =====================================================
# BDD Specification Tests
# =====================================================

print("============================================================")
print("  NUMBER TRAIT SPECIFICATION (#1003)")
print("  Category: Stdlib | Difficulty: 2 | Status: Complete")
print("============================================================")
print("")

var passed = 0
var failed = 0

# describe "i64 Number trait"
print("describe i64 Number trait:")

# it "zero() returns 0"
print("  it zero() returns 0:")
val i_zero = i64::zero()
if i_zero == 0:
    print("    [PASS] i64::zero() = 0")
    passed = passed + 1
else:
    print("    [FAIL] i64::zero()")
    failed = failed + 1

# it "one() returns 1"
print("  it one() returns 1:")
val i_one = i64::one()
if i_one == 1:
    print("    [PASS] i64::one() = 1")
    passed = passed + 1
else:
    print("    [FAIL] i64::one()")
    failed = failed + 1

# it "abs() returns absolute value"
print("  it abs() returns absolute value:")
val neg_int: i64 = -42
if neg_int.abs() == 42:
    print("    [PASS] (-42).abs() = 42")
    passed = passed + 1
else:
    print("    [FAIL] i64.abs()")
    failed = failed + 1

# it "is_zero() checks for zero"
print("  it is_zero() checks for zero:")
val zero_int: i64 = 0
val non_zero_int: i64 = 5
if zero_int.is_zero() and not non_zero_int.is_zero():
    print("    [PASS] is_zero() works correctly")
    passed = passed + 1
else:
    print("    [FAIL] i64.is_zero()")
    failed = failed + 1

# it "is_positive() checks for positive"
print("  it is_positive() checks for positive:")
val pos_int: i64 = 42
val neg_int2: i64 = -42
if pos_int.is_positive() and not neg_int2.is_positive():
    print("    [PASS] is_positive() works correctly")
    passed = passed + 1
else:
    print("    [FAIL] i64.is_positive()")
    failed = failed + 1

# it "is_negative() checks for negative"
print("  it is_negative() checks for negative:")
if neg_int.is_negative() and not pos_int.is_negative():
    print("    [PASS] is_negative() works correctly")
    passed = passed + 1
else:
    print("    [FAIL] i64.is_negative()")
    failed = failed + 1

# it "signum() returns sign"
print("  it signum() returns sign:")
val pos: i64 = 42
val neg: i64 = -42
val zer: i64 = 0
if pos.signum() == 1 and neg.signum() == -1 and zer.signum() == 0:
    print("    [PASS] signum() returns correct sign")
    passed = passed + 1
else:
    print("    [FAIL] i64.signum()")
    failed = failed + 1

# it "to_f64() converts to float"
print("  it to_f64() converts to float:")
val int_val: i64 = 42
if int_val.to_f64() == 42.0:
    print("    [PASS] to_f64() converts correctly")
    passed = passed + 1
else:
    print("    [FAIL] i64.to_f64()")
    failed = failed + 1

# it "to_i64() returns self"
print("  it to_i64() returns self:")
if int_val.to_i64() == 42:
    print("    [PASS] to_i64() returns self")
    passed = passed + 1
else:
    print("    [FAIL] i64.to_i64()")
    failed = failed + 1

# describe "f64 Number trait"
print("")
print("describe f64 Number trait:")

# it "zero() returns 0.0"
print("  it zero() returns 0.0:")
val f_zero = f64::zero()
if f_zero == 0.0:
    print("    [PASS] f64::zero() = 0.0")
    passed = passed + 1
else:
    print("    [FAIL] f64::zero()")
    failed = failed + 1

# it "one() returns 1.0"
print("  it one() returns 1.0:")
val f_one = f64::one()
if f_one == 1.0:
    print("    [PASS] f64::one() = 1.0")
    passed = passed + 1
else:
    print("    [FAIL] f64::one()")
    failed = failed + 1

# it "abs() returns absolute value"
print("  it abs() returns absolute value:")
val neg_float: f64 = -3.14
if neg_float.abs() == 3.14:
    print("    [PASS] (-3.14).abs() = 3.14")
    passed = passed + 1
else:
    print("    [FAIL] f64.abs()")
    failed = failed + 1

# it "is_zero() checks for zero"
print("  it is_zero() checks for zero:")
val zero_float: f64 = 0.0
val non_zero_float: f64 = 5.0
if zero_float.is_zero() and not non_zero_float.is_zero():
    print("    [PASS] is_zero() works correctly")
    passed = passed + 1
else:
    print("    [FAIL] f64.is_zero()")
    failed = failed + 1

# it "is_positive() checks for positive"
print("  it is_positive() checks for positive:")
val pos_float: f64 = 3.14
val neg_float2: f64 = -3.14
if pos_float.is_positive() and not neg_float2.is_positive():
    print("    [PASS] is_positive() works correctly")
    passed = passed + 1
else:
    print("    [FAIL] f64.is_positive()")
    failed = failed + 1

# it "is_negative() checks for negative"
print("  it is_negative() checks for negative:")
if neg_float.is_negative() and not pos_float.is_negative():
    print("    [PASS] is_negative() works correctly")
    passed = passed + 1
else:
    print("    [FAIL] f64.is_negative()")
    failed = failed + 1

# it "signum() returns sign"
print("  it signum() returns sign:")
val pos_f: f64 = 3.14
val neg_f: f64 = -3.14
val zer_f: f64 = 0.0
if pos_f.signum() == 1.0 and neg_f.signum() == -1.0 and zer_f.signum() == 0.0:
    print("    [PASS] signum() returns correct sign")
    passed = passed + 1
else:
    print("    [FAIL] f64.signum()")
    failed = failed + 1

# it "to_i64() truncates to integer"
print("  it to_i64() truncates to integer:")
val float_val: f64 = 3.7
if float_val.to_i64() == 3:
    print("    [PASS] to_i64() truncates correctly")
    passed = passed + 1
else:
    print("    [FAIL] f64.to_i64()")
    failed = failed + 1

# it "to_f64() returns self"
print("  it to_f64() returns self:")
if float_val.to_f64() == 3.7:
    print("    [PASS] to_f64() returns self")
    passed = passed + 1
else:
    print("    [FAIL] f64.to_f64()")
    failed = failed + 1

# describe "Edge cases"
print("")
print("describe Edge cases:")

# it "handles negative zero for f64"
print("  it handles negative zero for f64:")
val neg_zero: f64 = -0.0
if neg_zero.is_zero():
    print("    [PASS] -0.0 is_zero() = true")
    passed = passed + 1
else:
    print("    [FAIL] -0.0 is_zero()")
    failed = failed + 1

# it "handles large integers"
print("  it handles large integers:")
val large: i64 = 9223372036854775807  # i64::MAX
if large.is_positive() and not large.is_zero():
    print("    [PASS] large integer predicates work")
    passed = passed + 1
else:
    print("    [FAIL] large integer predicates")
    failed = failed + 1

# =====================================================
# Generated Documentation
# =====================================================

print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# Number Trait")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5")
print("**Status:** {FEATURE.status}")
print("**Implementation:** {FEATURE.impl_type}")
print("")
print("## Description")
print("")
print("{FEATURE.description}")
print("")
print("## Implementation Files")
for file in FEATURE.files:
    print("- `{file}`")
print("")
print("## Test Files")
for test in FEATURE.tests:
    print("- `{test}`")
print("")
print("## Code Examples")
print("")
print("```simple")
for example in FEATURE.code_examples:
    print("{example}")
print("```")
print("")
print("## Notes")
print("")
print("{FEATURE.notes}")

# =====================================================
# Test Summary
# =====================================================

print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {passed + failed}")

if failed == 0:
    print("")
    print("All tests PASSED!")

print("============================================================")
