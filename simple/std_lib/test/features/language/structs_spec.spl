"""
# Struct Types (Classes)

**Feature ID:** #14
**Category:** Language
**Difficulty:** 3/5
**Status:** Complete

## Overview

Structs in Simple provide a way to group related data together into named types with typed
fields. Using the `class` keyword (without methods), structs define data-only types that are
fundamental to organizing complex data structures.

Structs are **nominal types** - each struct definition creates a distinct type, even if the
field signatures are identical. They support typed fields, struct literal syntax for
instantiation, dot notation for field access, and can be nested or contain collections.

## Syntax

### Struct Definition

```simple
class Point:
    x: i32
    y: i32

class User:
    name: text
    age: i32
    active: bool
```

**Grammar:**
```
struct_def = 'class' IDENTIFIER ':' NEWLINE INDENT field+ DEDENT
field = IDENTIFIER ':' type_annotation NEWLINE
```

### Struct Literals

```simple
val p = Point { x: 10, y: 20 }
val user = User { name: 'Alice', age: 30, active: true }

# Nested structs
val rect = Rectangle {
    origin: Point { x: 0, y: 0 },
    size: Point { x: 100, y: 50 }
}
```

**Grammar:**
```
struct_literal = type_name '{' field_init (',' field_init)* '}'
field_init = field_name ':' expression
```

### Field Access

```simple
val x_coord = p.x          # Read field
val name = user.name       # Access text field
val nested = rect.origin.x # Nested access
```

**Grammar:**
```
field_access = expression '.' IDENTIFIER
```

## Runtime Representation

Structs are represented as `RuntimeValue::Object` containing a HashMap of field values:

```rust
pub enum RuntimeValue {
    Object {
        class_name: String,
        fields: HashMap<String, RuntimeValue>,
    },
    // ... other variants
}
```

**Memory Layout:**
- Fields stored in HashMap for O(1) access
- Class name stored for type checking and debugging
- No vtable (structs are data-only, not polymorphic)
- Field access is runtime-checked (panic on missing field)

## Key Properties

**Type Safety:**
- Fields must match declared types
- Type checking at parse/compile time where possible
- Runtime type validation for dynamic scenarios

**Initialization:**
- All fields must be initialized in struct literal
- Missing fields cause compile error
- Extra fields cause compile error
- Field order in literal doesn't matter

**Field Access:**
- O(1) average time complexity (HashMap lookup)
- Panic on access to non-existent field
- Supports arbitrarily nested access (a.b.c.d)

**Comparison:**
- No automatic equality (must compare field-by-field)
- Structural comparison available manually
- No built-in `Eq` trait (planned feature)

## Comparison with Other Languages

| Feature | Simple | Python | Rust | TypeScript |
|---------|--------|--------|------|------------|
| Definition | `class Point:\n  x: i32` | `@dataclass class Point` | `struct Point { x: i32 }` | `interface Point { x: number }` |
| Literal Syntax | `Point { x: 10 }` | `Point(x=10)` | `Point { x: 10 }` | `{ x: 10 }` |
| Field Access | `p.x` | `p.x` | `p.x` | `p.x` |
| Type Checking | Nominal | Duck typing | Nominal | Structural |
| Memory | HashMap (runtime) | `__dict__` | Stack/heap | Object |
| Missing Field | Panic | `AttributeError` | Compile error | `undefined` |

**Key Differences:**
- Simple uses `class` keyword (Rust uses `struct`)
- Simple requires field init syntax like Rust (Python uses positional/keyword args)
- Simple is nominally typed (TypeScript is structural)
- Simple stores fields in HashMap (Rust has compile-time layout)

## Common Patterns

### Data Transfer Objects (DTOs)

```simple
class UserDTO:
    id: i32
    name: text
    email: text

fn create_user(name: text, email: text) -> UserDTO:
    return UserDTO { id: generate_id(), name: name, email: email }
```

### Nested Structures

```simple
class Address:
    street: text
    city: text
    zip: text

class Person:
    name: text
    address: Address

val person = Person {
    name: 'Alice',
    address: Address { street: '123 Main', city: 'NYC', zip: '10001' }
}
```

### Structs with Collections

```simple
class Inventory:
    items: List<text>
    quantities: List<i32>

val inv = Inventory {
    items: ['apple', 'banana'],
    quantities: [10, 20]
}
```

### Working with Struct Data

```simple
# Extract and transform
fn process_point(p: Point) -> i32:
    return p.x + p.y

# Field-by-field comparison
fn points_equal(p1: Point, p2: Point) -> bool:
    return p1.x == p2.x and p1.y == p2.y
```

## Implementation Files

**Parser:**
- `src/parser/src/statements/mod.rs` - Struct definition parsing
- `src/parser/src/expressions/mod.rs` - Struct literal parsing
- `src/parser/src/ast.rs` - AST nodes for structs

**Type System:**
- `src/compiler/src/hir/types.rs` - Struct type representation
- `src/compiler/src/type_checker.rs` - Field type checking

**Runtime:**
- `src/runtime/src/value/core.rs` - RuntimeValue::Object
- `src/compiler/src/interpreter.rs` - Struct instantiation and field access

**Tests:**
- `src/driver/tests/interpreter_oop_tests.rs` - Rust integration tests
- `simple/std_lib/test/features/language/structs_spec.spl` - This file

## Related Features

- **Classes (#11)**: Structs + methods = classes
- **Enums (#15)**: Sum types (alternatives to product types)
- **Tuples (#18)**: Anonymous structs with positional fields
- **Traits (#planned)**: Interface abstraction for structs
- **Pattern Matching (#19)**: Destructuring struct values

## Notes

- Structs are value types semantically but reference types in implementation
- No automatic `Clone`, `Eq`, or `Hash` derivation yet (planned)
- Field visibility is public by default (no private fields yet)
- No struct update syntax (`{ ...old_struct, field: new_val }`) yet
"""

# Structs Feature Specification
# Feature #14: Struct definitions
# Category: Language | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 14,
    name: 'Structs',
    category: 'Language',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/data_structures.md',
    files: [
        'src/compiler/src/interpreter.rs',
        'src/parser/src/statements/mod.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_oop_tests.rs'
    ],
    description: 'Struct type for grouping related data. Supports typed fields, struct literals, and field access.',
    code_examples: [],
    dependencies: [1, 2, 10],
    required_by: [11, 16],
    notes: 'Structs arevalue types. Use struct literal syntax for instantiation.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('  STRUCTS FEATURE SPECIFICATION (#14)')
print('  Category: Language | Difficulty: 3 | Status: Complete')
print('')


describe "Struct definition":
    """
    ## Defining Structs with Typed Fields

    Struct definitions in Simple use the `class` keyword followed by field declarations with
    type annotations. Each field must have an explicit type, and all fields are public by default.

    **Grammar:**
    ```
    class_def = 'class' IDENTIFIER ':' NEWLINE INDENT field+ DEDENT
    field = IDENTIFIER ':' type_annotation NEWLINE
    ```

    **Key Properties:**
    - Nominal typing: Each class creates a unique type
    - All fields must be typed explicitly
    - Fields are immutable references (unless struct contains mutable collections)
    - No field initialization in definition (use struct literals)

    **Implementation:** `src/parser/src/statements/mod.rs:parse_class_definition()`
    """

        it "defines struct with typed fields":
            """
            **Given** a struct definition with typed fields
            **When** creating an instance with a struct literal
            **Then** all fields are accessible with correct values

            **Code Example:**
            ```simple
            class Point:
                x: i32
                y: i32

            val p = Point { x: 10, y: 20 }
            assert p.x == 10
            assert p.y == 20
            ```

            **Runtime Behavior:**
            1. Parser creates ClassDef AST node with field list
            2. Type checker validates field types exist
            3. Interpreter stores class definition in environment
            4. Struct literal creates RuntimeValue::Object with HashMap of fields
            5. Field access uses O(1) HashMap lookup

            **Implementation:**
            - Class def: `src/parser/src/statements/mod.rs:576`
            - Struct literal: `src/parser/src/expressions/mod.rs:892`
            - Field access: `src/compiler/src/interpreter.rs:1234`

            **Related Features:**
            - Basic types for field types
            - Field access expressions
            - Type annotations

            **Common Patterns:**
            ```simple
            # Simple 2D point
            class Point:
                x: i32
                y: i32

            # 3D vector
            class Vec3:
                x: f32
                y: f32
                z: f32
            ```
            """

class Point:
    x: i32
    y: i32

val p = Point { x: 10, y: 20 }
expect(p.x).to(eq(10))
expect(p.y).to(eq(20))

        it "defines struct with multiple types":
            """
            **Given** a struct with fields of different primitive types
            **When** instantiating with mixed type values
            **Then** each field retains its correct type and value

            **Code Example:**
            ```simple
            class User:
                name: text
                age: i32
                active: bool

            val user = User { name: 'Alice', age: 30, active: true }
            assert user.name == 'Alice'  # text field
            assert user.age == 30        # i32 field
            assert user.active == true   # bool field
            ```

            **Runtime Behavior:**
            - Each field stored as RuntimeValue of appropriate type
            - No type coercion between fields
            - Field types validated at struct literal creation

            **Type Safety:**
            - Cannot assign `i32` to `text` field
            - Cannot assign `bool` to `i32` field
            - Type mismatches caught at parse/compile time

            **Implementation:**
            - Type checking: `src/compiler/src/type_checker.rs:validate_struct_literal()`
            - Field storage: `HashMap<String, RuntimeValue>` in Object variant

            **Common Patterns:**
            ```simple
            # User profile
            class Profile:
                username: text
                email: text
                age: i32
                verified: bool
                score: f32

            # Configuration
            class Config:
                host: text
                port: i32
                ssl_enabled: bool
            ```
            """

class User:
    name: text
    age: i32
    active: bool

val user = User { name: 'Alice', age: 30, active: true }
expect(user.name).to(eq('Alice'))
expect(user.age).to(eq(30))
expect(user.active).to(be_true())

print('')
describe "Struct access":
    """
    ## Field Access with Dot Notation

    After creating a struct instance, fields are accessed using dot notation (`struct.field`).
    Field access is runtime-checked and panics if the field doesn't exist.

    **Grammar:**
    ```
    field_access = expression '.' IDENTIFIER
    ```

    **Performance:**
    - O(1) average access time (HashMap lookup)
    - No vtable dispatch (structs are not polymorphic)
    - Field names resolved at runtime

    **Implementation:** `src/compiler/src/interpreter.rs:eval_field_access()`
    """

        it "reads fieldvalues":
            """
            **Given** a struct instance with initialized fields
            **When** accessing fields via dot notation
            **Then** returns the stored values with correct types

            **Code Example:**
            ```simple
            class Vec2:
                x: f32
                y: f32

            val v = Vec2 { x: 3.0, y: 4.0 }
            assert v.x == 3.0  # Access f32 field
            assert v.y == 4.0  # Access f32 field
            ```

            **Runtime Behavior:**
            1. Evaluate left-hand side expression (gets `v`)
            2. Check that result is RuntimeValue::Object
            3. Lookup field name in HashMap
            4. Return field value or panic if missing

            **Error Handling:**
            ```simple
            val bad_access = v.z  # PANIC: field 'z' not found on Vec2
            ```

            **Performance:** O(1) HashMap lookup

            **Implementation:**
            - Field access: `src/compiler/src/interpreter.rs:eval_expression()` (FieldAccess case)
            - Panic on missing: `panic!("Field {} not found", field_name)`

            **Common Patterns:**
            ```simple
            # Extract fields for calculation
            fn magnitude(v: Vec2) -> f32:
                return sqrt(v.x * v.x + v.y * v.y)

            # Chain field access
            val x_squared = v.x * v.x
            ```
            """

class Vec2:
    x: f32
    y: f32

val v = Vec2 { x: 3.0, y: 4.0 }
expect(v.x).to(eq(3.0))
expect(v.y).to(eq(4.0))

        it "supports nested structs":
            """
            **Given** a struct with fields that are themselves structs
            **When** accessing nested fields with chained dot notation
            **Then** correctly retrieves values from arbitrarily deep nesting

            **Code Example:**
            ```simple
            class Rectangle:
                origin: Point
                size: Point

            val rect = Rectangle {
                origin: Point { x: 0, y: 0 },
                size: Point { x: 100, y: 50 }
            }

            assert rect.origin.x == 0    # Nested access: rect → origin → x
            assert rect.size.x == 100    # Nested access: rect → size → x
            ```

            **Runtime Behavior:**
            1. Access `rect.origin` returns RuntimeValue::Object (Point instance)
            2. Access `.x` on that Point returns RuntimeValue::Int(0)
            3. Each level performs O(1) HashMap lookup

            **Nested Literal Syntax:**
            - Inline: `origin: Point { x: 0, y: 0 }`
            - Outer struct literal contains inner struct literals
            - Type checker validates nested types match field types

            **Performance:**
            - Chained access: O(depth) where depth is nesting level
            - Each level is O(1) HashMap lookup

            **Implementation:**
            - Parser handles nested literals recursively
            - Field access evaluates left-to-right

            **Common Patterns:**
            ```simple
            # Scene graph / hierarchical data
            class Transform:
                position: Vec3
                rotation: Vec3
                scale: Vec3

            class Entity:
                name: text
                transform: Transform

            val player = Entity {
                name: 'Player',
                transform: Transform {
                    position: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
                    rotation: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
                    scale: Vec3 { x: 1.0, y: 1.0, z: 1.0 }
                }
            }

            val player_x = player.transform.position.x  # 3-level nesting
            ```
            """

class Rectangle:
    origin: Point
    size: Point

val rect = Rectangle {
    origin: Point { x: 0, y: 0 },
    size: Point { x: 100, y: 50 }
}
expect(rect.origin.x).to(eq(0))
expect(rect.size.x).to(eq(100))

print('')
describe "Struct with collections":
    """
    ## Structs with Collection Fields

    Struct fields can be collection types like List, Dict, or arrays. Collections are stored
    as RuntimeValue variants and can be accessed/mutated through field access.

    **Supported Collection Types:**
    - `List<T>` - Dynamic arrays
    - `Dict<K, V>` - Hash maps
    - `[T]` - Fixed-size arrays

    **Key Property:** Collections in struct fields are mutable even if the struct binding is immutable (`val`).

    **Implementation:** Collections stored as RuntimeValue::List, RuntimeValue::Dict, etc.
    """

        it "supports list fields":
            """
            **Given** a struct with a List field
            **When** accessing the list field
            **Then** can call list methods and iterate

            **Code Example:**
            ```simple
            class Container:
                items: List

            val cont = Container { items: [1, 2, 3] }
            assert cont.items.len() == 3
            ```

            **Runtime Behavior:**
            - List stored as RuntimeValue::List (Vec<RuntimeValue> internally)
            - Field access returns the List value
            - List methods (.len(), .push(), etc.) available on the returned value

            **Mutability:**
            ```simple
            # Even with val binding, list is mutable
            val cont = Container { items: [1, 2, 3] }
            cont.items.push(4)  # OK - modifies the list
            assert cont.items.len() == 4
            ```

            **Type Annotations:**
            - Generic: `items: List<i32>` (preferred)
            - Untyped: `items: List` (dynamic typing)

            **Implementation:**
            - List field: RuntimeValue::List in Object's HashMap
            - Method calls: `src/runtime/src/value/list.rs`

            **Common Patterns:**
            ```simple
            # Task list
            class TodoList:
                tasks: List<text>
                completed: List<bool>

            # Inventory system
            class Inventory:
                item_ids: List<i32>
                quantities: List<i32>
                names: List<text>
            ```
            """

class Container:
    items: List

val cont = Container { items: [1, 2, 3] }
expect(cont.items.len()).to(eq(3))

        it "supports computedvalues":
            """
            **Given** a struct instance passed to a function
            **When** the function computes values from struct fields
            **Then** fields are accessible and computable

            **Code Example:**
            ```simple
            class Score:
                points: i32

            fn double_score(s):
                return s.points * 2

            val score = Score { points: 50 }
            assert double_score(score) == 100
            ```

            **Runtime Behavior:**
            - Struct passed to function as RuntimeValue::Object
            - Function accesses fields via normal field access
            - Computed value returned as new RuntimeValue

            **Use Cases:**
            - Derived properties (calculated from fields)
            - Transform functions (map struct to different type)
            - Validation (check field constraints)

            **No Getters/Setters:**
            - Simple doesn't have getter/setter methods
            - Use functions that take struct as parameter
            - Fields are always public

            **Implementation:**
            - Function receives struct as argument
            - Field access works same as outside function

            **Common Patterns:**
            ```simple
            # Computed properties via functions
            class Circle:
                radius: f32

            fn area(c: Circle) -> f32:
                return 3.14159 * c.radius * c.radius

            fn circumference(c: Circle) -> f32:
                return 2.0 * 3.14159 * c.radius

            # Transform functions
            class Celsius:
                temp: f32

            class Fahrenheit:
                temp: f32

            fn to_fahrenheit(c: Celsius) -> Fahrenheit:
                return Fahrenheit { temp: c.temp * 1.8 + 32.0 }

            # Validation
            class Age:
                years: i32

            fn is_adult(a: Age) -> bool:
                return a.years >= 18
            ```
            """

class Score:
    points: i32

fn double_score(s):
    return s.points * 2

val score = Score { points: 50 }
expect(double_score(score)).to(eq(100))

        it "supports struct comparison":
            """
            **Given** two struct instances with the same field values
            **When** comparing fields manually
            **Then** can check structural equality field-by-field

            **Code Example:**
            ```simple
            class Coord:
                x: i32
                y: i32

            val c1 = Coord { x: 5, y: 5 }
            val c2 = Coord { x: 5, y: 5 }

            # Manual field comparison (no automatic equality)
            assert c1.x == c2.x and c1.y == c2.y
            ```

            **Runtime Behavior:**
            - No automatic `==` operator for structs
            - Must compare field-by-field manually
            - Each field comparison uses field type's equality

            **Limitations:**
            - `c1 == c2` compares object identity, not structural equality
            - No automatic `Eq` or `PartialEq` derivation
            - Must write comparison logic explicitly

            **Planned Features:**
            ```simple
            # Future: Automatic equality derivation
            @derive(Eq, Hash)
            class Point:
                x: i32
                y: i32

            val p1 = Point { x: 1, y: 2 }
            val p2 = Point { x: 1, y: 2 }
            assert p1 == p2  # Automatic structural equality
            ```

            **Workaround Patterns:**
            ```simple
            # Manual equality function
            fn coords_equal(c1: Coord, c2: Coord) -> bool:
                return c1.x == c2.x and c1.y == c2.y

            # Or method on struct (if using class with methods)
            impl Coord:
                fn equals(other: Coord) -> bool:
                    return self.x == other.x and self.y == other.y

            # Use case
            if coords_equal(c1, c2):
                print('Coordinates are equal')
            ```

            **Identity vs Equality:**
            - Identity: Same object in memory (reference equality)
            - Structural equality: Same field values (not automatic)
            - Simple currently only supports manual structural comparison

            **Implementation:**
            - Field comparison: Standard RuntimeValue equality
            - No overloaded operators for structs yet
            """

class Coord:
    x: i32
    y: i32

val c1 = Coord { x: 5, y: 5 }
val c2 = Coord { x: 5, y: 5 }
expect(c1.x).to(eq(c2.x))
expect(c1.y).to(eq(c2.y))

# =====================================================
# Documentation Output
# =====================================================

print('')
print('  GENERATED DOCUMENTATION')
print('')
print('# Structs')
print('')
print('**Feature ID:** #14')
print('**Category:** Language')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('  TEST SUMMARY')
print('Passed: {passed}')
print('Failed: {failed}')
print('Total:  {passed + failed}')
    print('All tests PASSED!')