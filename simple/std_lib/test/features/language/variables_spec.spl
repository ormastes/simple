# Variables Feature Specification
"""
# Variable Declarations

**Feature ID:** #15
**Category:** Language
**Difficulty:** 2/5
**Status:** Complete

## Overview

Variables in Simple provide named storage for values with support for both immutable
and mutable bindings. Following Scala/Rust conventions, Simple defaults to immutable
bindings with `val` and requires explicit `var` for mutable variables.

This design encourages functional programming patterns and makes mutability explicit,
improving code safety and readability.

## Key Features

**Immutable Bindings (`val`):**
- Default binding type
- Cannot be reassigned after initialization
- Encourages functional style
- Compiler-optimized

**Mutable Bindings (`var`):**
- Explicit mutability
- Can be reassigned
- Required for imperative algorithms
- Clear visual signal of state changes

**Scope Rules:**
- Block-scoped (like JavaScript let/const)
- Lexical scoping with closures
- Shadow outer variables in inner scopes
- No hoisting

**Type System Integration:**
- Type inference from initializer
- Optional type annotations
- Works with all Simple types
- Generic-aware

## Syntax

```simple
# Immutable binding (preferred)
val name = "Alice"
val age = 30
val is_active = true

# Mutable binding (explicit)
var count = 0
count = count + 1

# Type annotations (optional)
val x: i32 = 42
var message: text = "Hello"

# Multiple declarations
val a = 1
val b = 2
val c = 3

# Block scoping
val outer = 100
if true:
    val inner = 200  # Different scope
    val outer = 300  # Shadows outer variable
```

## Comparison with Other Languages

| Feature | Simple | Rust | Scala | JavaScript | Python |
|---------|--------|------|-------|------------|--------|
| Immutable keyword | `val` | `let` | `val` | `const` | N/A |
| Mutable keyword | `var` | `let mut` | `var` | `let` | (default) |
| Default mutability | Immutable | Immutable | Immutable | Mutable | Mutable |
| Type inference | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes |
| Type annotations | Optional | Optional | Optional | Optional (TS) | Optional |
| Block scoping | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ❌ No (function) |
| Shadowing | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes |

## Implementation Details

**Parser:** `src/parser/src/statements/mod.rs`
**Interpreter:** `src/compiler/src/interpreter.rs`

**Variable Storage:**
Variables are stored in the interpreter's environment as `RuntimeValue` entries:
    ```rust
struct Environment {
    bindings: HashMap<String, RuntimeValue>,
    mutable_flags: HashSet<String>,  // Tracks var vs val
    parent: Option<Box<Environment>>,  // For nested scopes
}
```

**Mutability Check:**
The interpreter checks the `mutable_flags` set before allowing reassignment:
    ```rust
fn assign(&mut self, name: &str, value: RuntimeValue) -> Result<(), Error> {
    if !self.mutable_flags.contains(name) {
        return Err(Error::ImmutableReassignment(name.to_string()));
    }
    self.bindings.insert(name.to_string(), value);
    Ok(())
}
```

## Use Cases

**1. Configuration Values (val):**
```simple
val API_URL = "https://api.example.com"
val MAX_RETRIES = 3
val TIMEOUT_MS = 5000
```

**2. Loop Counters (var):**
```simple
var i = 0
while i < 10:
    print(i)
    i = i + 1
```

**3. Accumulation (var):**
```simple
var sum = 0
for x in numbers:
    sum = sum + x
```

**4. Shadowing for Transformation:**
```simple
val data = load_data()
val data = validate(data)
val data = transform(data)  # Each shadows previous
```

## Performance Characteristics

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Declaration | O(1) | O(1) | Hash map insertion |
| Access | O(1) | - | Hash map lookup |
| Assignment (var) | O(1) | - | Hash map update |
| Scope entry | O(1) | O(n) | New environment frame |
| Scope exit | O(1) | - | Drop environment frame |

**Optimization:** Immutable bindings (`val`) enable compiler optimizations:
    - Constant propagation
- Dead code elimination
- Inlining

## Related Features

- **#1 - Lexer**: Tokenizes `val` and `var` keywords
- **#2 - Parser**: Parses variable declarations
- **#10 - Functions**: Variables as function parameters
- **#11 - Closures**: Variable capture mechanics
- **#12 - Classes**: Instance variables and fields

## Test Coverage

This specification covers:
    - ✅ Let bindings (immutable variables)
- ✅ Mutable bindings (var)
- ✅ Variable scope (block scoping and shadowing)
- ✅ Variable initialization (expressions and function calls)

**Total:** 10 tests across 4 describe blocks
"""

import std.spec


describe "Let bindings":
    """
    ## Immutable Variable Bindings

    The `val` keyword creates immutable bindings - variables that cannot be reassigned
    after initialization. This is the default and recommended way to declare variables
    in Simple, encouraging functional programming patterns.

    **Syntax:** `val name = value`

    **Characteristics:**
    - Immutable after initialization
    - Type inferred from initializer
    - Block-scoped
    - Can be shadowed in nested scopes
    - Compiler-optimized (constant propagation)
    """

    it "creates immutable binding":
        """
        **Given** an immutable binding with val keyword
        **When** assigning an integer value
        **Then** the variable holds the value and cannot be reassigned

        **Example:**
        ```simple
        val x = 42
        # x = 43  # Would cause error: cannot reassign immutable variable
        ```

        **Implementation:** Stored in environment without mutable flag
        """
        val x = 42
        expect(x).to(eq(42))

    it "creates string binding":
        """
        **Given** an immutable binding with val keyword
        **When** assigning a string value
        **Then** the variable holds the string value

        **Example:**
        ```simple
        val name = 'Alice'
        val greeting = "Hello, " + name
        ```
        """
        val name = 'Alice'
        expect(name).to(eq('Alice'))

    it "creates boolean binding":
        """
        **Given** an immutable binding with val keyword
        **When** assigning a boolean value
        **Then** the variable holds the boolean value

        **Example:**
        ```simple
        val flag = true
        if flag:
            print("Flag is set")
        ```
        """
        val flag = true
        expect(flag).to(be_true())

describe "Mutable bindings":
    """
    ## Mutable Variable Bindings

    The `var` keyword creates mutable bindings - variables that can be reassigned
    after initialization. Use `var` when you need to update a variable's value,
    such as in loops, accumulators, or imperative algorithms.

    **Syntax:** `var name = value`

    **Characteristics:**
    - Mutable after initialization
    - Type inferred from initializer
    - Can be reassigned to values of same type
    - Block-scoped
    - Explicitly signals mutability
    """

    it "creates mutable binding":
        """
        **Given** a mutable binding with var keyword
        **When** assigning and then updating the value
        **Then** the variable can be reassigned

        **Example:**
        ```simple
        var count = 0
        count = count + 1
        count = count + 1
        # count is now 2
        ```
        """
        var count = 0
        count = count + 1
        expect(count).to(eq(1))

    it "allows reassignment":
        """
        **Given** a mutable variable
        **When** reassigning multiple times
        **Then** each assignment updates the value

        **Example:**
        ```simple
        var value = 10
        value = 20  # First reassignment
        value = 30  # Second reassignment
        ```

        **Note:** Simple allows shadowing with `val`, but `var` is for true mutation.
        """
        var value = 10
        value = 20
        value = 30
        expect(value).to(eq(30))

    it "supports compound assignment":
        """
        **Given** a mutable variable
        **When** using compound operations
        **Then** the variable is updated correctly

        **Example:**
        ```simple
        var n = 5
        n = n + 3  # n = 8
        n = n * 2  # n = 16
        ```

        **Note:** Simple currently requires explicit `n = n + x` syntax.
        Compound operators like `+=` are a future enhancement.
        """
        var n = 5
        n = n + 3
        n = n * 2
        expect(n).to(eq(16))

describe "Variable scope":
    """
    ## Variable Scoping

    Simple uses lexical block scoping similar to JavaScript's let/const and Rust's
    variable bindings. Variables are scoped to the block where they're declared and
    can shadow outer variables in nested scopes.

    **Scoping Rules:**
    - Variables are scoped to their declaring block
    - Inner blocks can access outer variables
    - Inner blocks can shadow outer variables
    - No hoisting (unlike JavaScript var)
    - Scopes form a chain for closure capture
    """

    it "respects block scope":
        """
        **Given** variables declared in different scopes
        **When** accessing from inner and outer scopes
        **Then** inner scope can access outer, but not vice versa

        **Example:**
        ```simple
        val outer = 100
        if true:
            val inner = 200
            print(outer)  # ✓ Can access outer
            print(inner)  # ✓ Can access inner
        # print(inner)  # ✗ Error: inner not in scope
        ```

        **Implementation:** Environment forms a chain with parent pointer.
        """
        val outer = 100
        if true:
            val inner = 200
            expect(outer).to(eq(100))
            expect(inner).to(eq(200))

    it "shadows outer variables":
        """
        **Given** an outer variable and an inner variable with the same name
        **When** accessing the variable in the inner scope
        **Then** the inner variable shadows the outer one

        **Example:**
        ```simple
        val shadow = 1
        print(shadow)  # Prints 1
        if true:
            val shadow = 2
            print(shadow)  # Prints 2 (shadows outer)
        print(shadow)  # Prints 1 (back to outer)
        ```

        **Use Case:** Shadowing is useful for transforming values:
            ```simple
        val data = load_data()
        val data = validate(data)
        val data = transform(data)
        ```
        """
        val shadow = 1
        if true:
            val shadow = 2
            expect(shadow).to(eq(2))
        expect(shadow).to(eq(1))

describe "Variable initialization":
    """
    ## Variable Initialization

    Variables can be initialized with any expression, including literals, arithmetic
    operations, function calls, and complex expressions. The type is inferred from
    the initializer.

    **Initialization Patterns:**
    - Literal values: `val x = 42`
    - Expressions: `val sum = a + b`
    - Function calls: `val result = compute()`
    - Complex expressions: `val value = (a + b) * c`
    """

    it "initializes with expressions":
        """
        **Given** variables initialized with arithmetic expressions
        **When** evaluating the expressions
        **Then** variables hold the computed results

        **Example:**
        ```simple
        val a = 5
        val b = 3
        val sum = a + b
        val product = a * b
        val complex = (a + b) * 2
        ```

        **Note:** Type inference works through expressions - `sum` is inferred as i32.
        """
        val a = 5
        val b = 3
        val sum = a + b
        expect(sum).to(eq(8))

    it "initializes with function calls":
        """
        **Given** a variable initialized with a function call
        **When** the function returns a value
        **Then** the variable holds the returned value

        **Example:**
        ```simple
        fn get_value():
            return 42

        val result = get_value()
        val doubled = get_value() * 2
        ```

        **Use Case:** Common for configuration and computed values:
            ```simple
        val config = load_config()
        val db = connect_database(config)
        val users = fetch_users(db)
        ```
        """
        fn get_value():
            return 42

        val result = get_value()
        expect(result).to(eq(42))