# Variables Feature Specification
"""
# Variable Declarations

**Feature ID:** #15
**Category:** Language
**Difficulty:** 2/5
**Status:** Complete

## Overview

Variables in Simple provide named storage for values with support for both immutable
and mutable bindings. Following Scala/Rust conventions, Simple defaults to immutable
bindings with `val` and requires explicit `var` for mutable variables.

This design encourages functional programming patterns and makes mutability explicit,
improving code safety and readability.

## Key Features

**Immutable Bindings (`val`):**
- Default binding type
- Cannot be reassigned after initialization
- Encourages functional style
- Compiler-optimized

**Mutable Bindings (`var`):**
- Explicit mutability
- Can be reassigned
- Required for imperative algorithms
- Clear visual signal of state changes

**Scope Rules:**
- Block-scoped (like JavaScript let/const)
- Lexical scoping with closures
- Shadow outer variables in inner scopes
- No hoisting

**Type System Integration:**
- Type inference from initializer
- Optional type annotations
- Works with all Simple types
- Generic-aware

## Syntax

```simple
# Immutable binding (preferred)
val name = "Alice"
val age = 30
val is_active = true

# Mutable binding (explicit)
var count = 0
count = count + 1

# Type annotations (optional)
val x: i32 = 42
var message: text = "Hello"

# Multiple declarations
val a = 1
val b = 2
val c = 3

# Block scoping
val outer = 100
if true:
    val inner = 200  # Different scope
    val outer = 300  # Shadows outer variable
```

## Comparison with Other Languages

| Feature | Simple | Rust | Scala | JavaScript | Python |
|---------|--------|------|-------|------------|--------|
| Immutable keyword | `val` | `let` | `val` | `const` | N/A |
| Mutable keyword | `var` | `let mut` | `var` | `let` | (default) |
| Default mutability | Immutable | Immutable | Immutable | Mutable | Mutable |
| Type inference | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes |
| Type annotations | Optional | Optional | Optional | Optional (TS) | Optional |
| Block scoping | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ❌ No (function) |
| Shadowing | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes |

## Implementation Details

**Parser:** `src/parser/src/statements/mod.rs`
**Interpreter:** `src/compiler/src/interpreter.rs`

**Variable Storage:**
Variables are stored in the interpreter's environment as `RuntimeValue` entries:
```rust
struct Environment {
    bindings: HashMap<String, RuntimeValue>,
    mutable_flags: HashSet<String>,  // Tracks var vs val
    parent: Option<Box<Environment>>,  // For nested scopes
}
```

**Mutability Check:**
The interpreter checks the `mutable_flags` set before allowing reassignment:
```rust
fn assign(&mut self, name: &str, value: RuntimeValue) -> Result<(), Error> {
    if !self.mutable_flags.contains(name) {
        return Err(Error::ImmutableReassignment(name.to_string()));
    }
    self.bindings.insert(name.to_string(), value);
    Ok(())
}
```

## Use Cases

**1. Configuration Values (val):**
```simple
val API_URL = "https://api.example.com"
val MAX_RETRIES = 3
val TIMEOUT_MS = 5000
```

**2. Loop Counters (var):**
```simple
var i = 0
while i < 10:
    print(i)
    i = i + 1
```

**3. Accumulation (var):**
```simple
var sum = 0
for x in numbers:
    sum = sum + x
```

**4. Shadowing for Transformation:**
```simple
val data = load_data()
val data = validate(data)
val data = transform(data)  # Each shadows previous
```

## Performance Characteristics

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Declaration | O(1) | O(1) | Hash map insertion |
| Access | O(1) | - | Hash map lookup |
| Assignment (var) | O(1) | - | Hash map update |
| Scope entry | O(1) | O(n) | New environment frame |
| Scope exit | O(1) | - | Drop environment frame |

**Optimization:** Immutable bindings (`val`) enable compiler optimizations:
- Constant propagation
- Dead code elimination
- Inlining

## Related Features

- **#1 - Lexer**: Tokenizes `val` and `var` keywords
- **#2 - Parser**: Parses variable declarations
- **#10 - Functions**: Variables as function parameters
- **#11 - Closures**: Variable capture mechanics
- **#12 - Classes**: Instance variables and fields

## Test Coverage

This specification covers:
- ✅ Let bindings (immutable variables)
- ✅ Mutable bindings (var)
- ✅ Variable scope (block scoping and shadowing)
- ✅ Variable initialization (expressions and function calls)

**Total:** 10 tests across 4 describe blocks
"""

import std.spec


describe "Let bindings":
    """
    TODO: Add documentation here
    """
        it "creates immutable binding":
            """
            TODO: Add documentation here
            """

val x = 42
if x == 42:
else:

        it "creates string binding":
            """
            TODO: Add documentation here
            """

val name = 'Alice'
if name == 'Alice':
else:

        it "creates boolean binding":
            """
            TODO: Add documentation here
            """

val flag = true
if flag:
else:

print('')
describe "Mutable bindings":
    """
    TODO: Add documentation here
    """
        it "creates mutable binding":
            """
            TODO: Add documentation here
            """

var count = 0
count = count + 1
if count == 1:
else:

        it "allows reassignment":
            """
            TODO: Add documentation here
            """

var value = 10
value = 20
value = 30
if value == 30:
else:

        it "supports compound assignment":
            """
            TODO: Add documentation here
            """

var n = 5
n = n + 3
n = n * 2
if n == 16:
else:

print('')
describe "Variable scope":
    """
    TODO: Add documentation here
    """
        it "respects block scope":
            """
            TODO: Add documentation here
            """

val outer = 100
if true:
    val inner = 200
    if outer == 100:
    else:

        it "shadows outer variables":
            """
            TODO: Add documentation here
            """

val shadow = 1
if true:
    val shadow = 2
    if shadow == 2:
    else:

print('')
describe "Variable initialization":
    """
    TODO: Add documentation here
    """
        it "initializes with expressions":
            """
            TODO: Add documentation here
            """

val a = 5
val b = 3
val sum = a + b
if sum == 8:
else:

        it "initializes with function calls":
            """
            TODO: Add documentation here
            """

fn get_value():
    return 42

val result = get_value()
if result == 42:
else:

# =====================================================
# Documentation Output
# =====================================================

print('')
print('  GENERATED DOCUMENTATION')
print('')
print('# Variables')
print('')
print('**Feature ID:** #15')
print('**Category:** Language')
print('**Difficulty:** Level 2/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('  TEST SUMMARY')
print('Passed: {passed}')
print('Failed: {failed}')
print('Total:  {passed + failed}')
    print('All tests PASSED!')