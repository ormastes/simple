# Functions Feature Specification
"""
# Functions (Named, Lambda, Higher-Order)

**Feature ID:** #12
**Category:** Language
**Difficulty:** 3/5 (Intermediate)
**Status:** Complete

## Overview

Functions in Simple are first-class values supporting named functions, anonymous lambdas, lexical
closures, and higher-order functions. Following functional programming principles from Scala and
Haskell, functions can be passed as arguments, returned from other functions, and stored in variables.

**Key Concepts:**
- **Named functions:** Traditional function definitions with `fn` keyword
- **Lambda expressions:** Anonymous functions with `\param: body` syntax
- **Closures:** Functions that capture their lexical environment
- **Higher-order functions:** Functions that take or return other functions (map, filter, reduce)
- **First-class values:** Functions are values like integers or strings

## Syntax

### Named Functions

```simple
fn function_name(param1: Type1, param2: Type2) -> ReturnType:
    # Function body
    return value
```

**Grammar:**
```
fn_def = 'fn' identifier '(' param_list? ')' ('->' type)? ':' NEWLINE INDENT statement+ DEDENT
param_list = param (',' param)*
param = identifier (':' type)?
```

### Lambda Expressions

```simple
# Single parameter
val double = \x: x * 2

# Multiple parameters
val add = \a, b: a + b

# With type annotations (planned)
val typed = \(x: i32, y: i32) -> i32: x + y
```

**Grammar:**
```
lambda_expr = '\\' param_list ':' expression
```

### Function Calls

```simple
result = function_name(arg1, arg2)
result = lambda_expr(arg)
```

## Runtime Representation

**Function Values:**
Functions are represented as closures in the runtime:
```rust
pub struct Function {
    name: String,
    params: Vec<String>,
    body: Vec<Statement>,
    closure_env: Environment,  // Captured variables
}
```

**Closure Capture:**
When a function is defined, it captures references to variables in its enclosing scope:
```simple
fn make_adder(x):
    fn adder(y):
        return x + y  # Captures x from outer scope
    return adder
```

**Call Stack:**
Function calls use a stack frame:
1. Push new stack frame with parameters
2. Execute function body
3. Pop stack frame, return value

## Comparison with Other Languages

| Feature | Simple | Python | JavaScript | Rust | Scala |
|---------|--------|--------|------------|------|-------|
| Named functions | `fn name()` | `def name():` | `function name()` | `fn name()` | `def name()` |
| Lambda syntax | `\x: x+1` | `lambda x: x+1` | `x => x+1` | `\|x\| x+1` | `x => x+1` |
| First-class | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes |
| Closures | ✅ Lexical | ✅ Lexical | ✅ Lexical | ✅ Lexical | ✅ Lexical |
| Higher-order | ✅ map/filter/reduce | ✅ map/filter/reduce | ✅ map/filter/reduce | ✅ map/filter/fold | ✅ map/filter/fold |
| Type annotations | ⚠️ Optional | ⚠️ Optional (hints) | ❌ No (TS: Yes) | ✅ Required | ✅ Inferred |
| Default params | ❌ Planned | ✅ Yes | ✅ Yes | ❌ No | ✅ Yes |

## Common Patterns

### Function as Return Value
```simple
fn multiplier(factor):
    return \x: x * factor

val times3 = multiplier(3)
val result = times3(10)  # 30
```

### Function as Argument
```simple
fn apply_twice(f, x):
    return f(f(x))

val result = apply_twice(\x: x + 1, 5)  # 7
```

### Partial Application (Manual)
```simple
fn add(a, b):
    return a + b

fn add5(x):
    return add(5, x)
```

### Map/Filter/Reduce Pipeline
```simple
val result = [1, 2, 3, 4, 5]
    .filter(\x: x % 2 == 0)  # [2, 4]
    .map(\x: x * x)          # [4, 16]
    .reduce(0, \acc, x: acc + x)  # 20
```

## Implementation Files

**Parser:** `src/parser/src/expressions/mod.rs` - Function definition and lambda parsing
**Interpreter:** `src/compiler/src/interpreter_call.rs` - Function calls and closure capture
**Runtime:** `src/runtime/src/value/functions.rs` - Function value representation
**Tests:** `src/driver/tests/interpreter_basic_tests.rs` - Function tests

## Related Features

- **Variables (#15):** Captured in closures
- **Type System (#1):** Function types (A -> B)
- **Methods (#TBD):** Member functions on classes
- **Pattern Matching (#90):** Destructuring in parameters (planned)

## Limitations and Future Work

**Current Limitations:**
- No default parameters
- No variadic arguments (...args)
- No keyword arguments
- No function overloading
- Lambda type annotations not yet supported

**Planned Features:**
- Default/optional parameters: `fn greet(name: text = "World")`
- Variadic args: `fn sum(...numbers)`
- Function composition operators: `>>` and `<<`
- Currying syntax
- Pattern matching in parameters
"""

import std.spec


describe "Function definitions":
    """
    ## Named Function Definitions

    Named functions are defined with the `fn` keyword and can have parameters, return types
    (inferred or annotated), and a body. Functions support recursion and nesting (closures).

    **Grammar:** `fn name(params) -> ReturnType: body`

    **Key Features:**
    - Top-level or nested definitions
    - Lexical scoping (closures)
    - Recursion support
    - Return type inference
    """

        it "defines and calls named functions":
            """
            **Given** a named function with two parameters
            **When** calling the function with arguments
            **Then** the function executes and returns the computed value

            Named functions are the primary way to define reusable code blocks. Parameters
            are positional, and return is explicit with `return` keyword.

            **Implementation:** `src/compiler/src/interpreter_call.rs:call_function()`
            """
fn add(a, b):
    return a + b
expect(add(2, 3)).to(eq(5))

        it "supports recursive functions":
            """
            **Given** a function that calls itself
            **When** executing the recursive function
            **Then** each call uses a new stack frame until base case

            Recursion is fully supported. Each recursive call creates a new stack frame.

            **Pattern:** Factorial demonstrates recursive pattern with base case (n <= 1).
            """
fn factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
expect(factorial(5)).to(eq(120))

        it "supports nested functions":
            """
            **Given** a function defined inside another function
            **When** the nested function accesses outer function's variables
            **Then** the nested function captures the outer scope (closure)

            Nested functions have access to all variables in enclosing scopes. This enables
            closures - functions that "remember" their environment.

            **Pattern:** Factory pattern - outer function returns inner function with captured context.
            """
fn outer(x):
    fn inner(y):
        return x + y
    return inner(10)
expect(outer(5)).to(eq(15))

describe "Lambda expressions":
    """
    ## Lambda Expressions - Anonymous Functions

    Lambda expressions create anonymous functions using backslash syntax: `\params: body`.
    Lambdas are expressions (not statements) and can be assigned to variables or passed directly.

    **Grammar:** `lambda = '\\' params ':' expression`

    **Use Cases:**
    - Inline callbacks for map/filter/reduce
    - Short functions without needing `fn` keyword
    - Function-as-argument patterns
    """

        it "creates inline lambdas":
            """
            **Given** a lambda expression with single parameter
            **When** assigning lambda to a variable and calling it
            **Then** the lambda executes like a regular function

            Lambdas are first-class values - can be stored in variables, passed as arguments,
            and returned from functions.

            **Syntax:** `\param: expression` for single-expression bodies.
            """
val double = \x: x * 2
expect(double(5)).to(eq(10))

        it "supports multi-param lambdas":
            """
            **Given** a lambda with multiple parameters
            **When** calling the lambda with multiple arguments
            **Then** all parameters are bound to corresponding arguments

            Multi-parameter lambdas use comma-separated parameter lists: `\a, b, c: expression`.

            **Pattern:** Lambda as function value - assigned to variable, called like named function.
            """
val add_lambda = \a, b: a + b
expect(add_lambda(3, 4)).to(eq(7))

describe "Higher-order functions":
    """
    ## Higher-Order Functions - Functions Operating on Functions

    Higher-order functions take functions as arguments or return functions as results. Common
    examples include map (transform each element), filter (select elements), and reduce
    (aggregate elements).

    **Collections API:**
    - `list.map(fn)` - Transform each element
    - `list.filter(fn)` - Select elements matching predicate
    - `list.reduce(init, fn)` - Aggregate elements with accumulator

    **Implementation:** `src/runtime/src/value/collections.rs`
    """

        it "uses map":
            """
            **Given** an array and a transformation function
            **When** calling .map() with a lambda
            **Then** returns new array with function applied to each element

            Map applies a function to every element, returning a new array of results.

            **Pattern:** Transform collections without explicit loops.
            """
val nums = [1, 2, 3]
val doubled = nums.map(\x: x * 2)
expect(doubled).to(eq([2, 4, 6]))

        it "uses filter":
            """
            **Given** an array and a predicate function
            **When** calling .filter() with a lambda
            **Then** returns new array with only elements where predicate is true

            Filter selects elements matching a condition.

            **Pattern:** Select subset of collection based on criteria.
            """
val nums2 = [1, 2, 3, 4, 5]
val evens = nums2.filter(\x: x % 2 == 0)
expect(evens).to(eq([2, 4]))

        it "uses reduce":
            """
            **Given** an array, initial value, and reduction function
            **When** calling .reduce() with accumulator function
            **Then** combines all elements into single value

            Reduce (fold) aggregates elements using accumulator pattern.

            **Pattern:** Sum, product, concatenation - any aggregation operation.
            **Signature:** `reduce(initial, \acc, elem: acc op elem)`
            """
val nums3 = [1, 2, 3, 4]
val sum = nums3.reduce(0, \acc, x: acc + x)
expect(sum).to(eq(10))