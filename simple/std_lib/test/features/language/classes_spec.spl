# Classes Feature Specification
# Feature #11: Class definitions, methods, inheritance
# Category: Language | Difficulty: 4 | Status: Complete

print("============================================================")
print("  CLASSES FEATURE SPECIFICATION (#11)")
print("  Category: Language | Difficulty: 4 | Status: Complete")
print("============================================================")
print("")

let mut passed = 0
let mut failed = 0

print("describe Class definitions:")
print("  it defines classes with typed fields:")

class Point:
    x: Int
    y: Int

let p = Point { x: 3, y: 4 }
if p.x == 3 and p.y == 4:
    print("    [PASS] class with fields")
    passed = passed + 1
else:
    print("    [FAIL] class fields")
    failed = failed + 1

print("  it supports methods:")

class Counter:
    value: Int

    fn increment(self):
        self.value = self.value + 1

    fn get(self):
        return self.value

let c = Counter { value: 0 }
c.increment()
c.increment()
if c.get() == 2:
    print("    [PASS] methods with self")
    passed = passed + 1
else:
    print("    [FAIL] methods")
    failed = failed + 1

print("  it supports static methods (new pattern):")

class Person:
    name: String
    age: Int

    fn new(n: String, a: Int):
        return Person { name: n, age: a }

    fn greet(self):
        return f"Hello, I am {self.name}"

let person = Person.new("Alice", 30)
if person.name == "Alice" and person.age == 30:
    print("    [PASS] static new method")
    passed = passed + 1
else:
    print("    [FAIL] static method")
    failed = failed + 1

print("")
print("describe Class with collections:")

print("  it supports List fields:")

class Container:
    items: List

    fn new():
        return Container { items: [] }

    fn add(self, item):
        self.items = self.items + [item]

    fn count(self):
        return self.items.len()

let cont = Container.new()
cont.add(1)
cont.add(2)
cont.add(3)
if cont.count() == 3:
    print("    [PASS] class with List field")
    passed = passed + 1
else:
    print("    [FAIL] List field")
    failed = failed + 1

print("  it supports nested class instances:")

class Outer:
    inner: Point

let outer = Outer { inner: Point { x: 1, y: 2 } }
if outer.inner.x == 1 and outer.inner.y == 2:
    print("    [PASS] nested class instances")
    passed = passed + 1
else:
    print("    [FAIL] nested instances")
    failed = failed + 1

# Documentation
print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# Classes")
print("")
print("**Feature ID:** #11")
print("**Category:** Language")
print("**Difficulty:** Level 4/5")
print("**Status:** Complete")
print("**Implementation:** Rust")
print("")
print("## Description")
print("")
print("Object-oriented programming with class definitions, typed fields,")
print("methods, static methods, and struct-literal instantiation.")
print("Supports single inheritance.")
print("")
print("## Implementation Files")
print("- `src/compiler/src/interpreter.rs`")
print("- `src/parser/src/statements/mod.rs`")
print("")
print("## Code Examples")
print("See test cases above for usage patterns.")
print("")
print("## Notes")
print("Classes support struct-literal syntax for instantiation.")
print("Methods use self parameter for instance access.")

# Summary
print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print(f"Passed: {passed}")
print(f"Failed: {failed}")
if failed == 0:
    print("All tests PASSED!")
print("============================================================")
