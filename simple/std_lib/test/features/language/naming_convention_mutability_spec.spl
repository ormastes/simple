# Naming Convention Mutability Feature Specification
"""
# Naming Convention Mutability

**Feature ID:** #25
**Category:** Language
**Difficulty:** 3/5
**Status:** Planned

## Overview

Simple uses naming conventions to indicate variable mutability, reducing the need for
explicit `val`/`var` keywords. This design makes code more concise while maintaining
clear visual signals about mutability.

The naming convention system provides:
- **Underscore suffix** (`name_`) for mutable variables
- **Lowercase** (`name`) for immutable variables with functional update support
- **ALL_CAPS** (`NAME`) for compile-time constants
- **PascalCase** (`Name`) reserved for type names only

## Naming Patterns

### Mutable Variables (`name_`)

Variables ending with underscore are mutable and can be reassigned:

```simple
counter_ = 0
counter_ = counter_ + 1    # OK - mutable
counter_ += 1              # OK - compound assignment
```

### Immutable Variables (`name`)

Lowercase variables are immutable but support functional update with `->`:

```simple
counter = Counter(value: 0)
counter = counter + 1      # ERROR - cannot reassign directly
counter->increment()       # OK - functional update creates new instance
```

### Constants (`NAME`)

ALL_CAPS names are compile-time constants, non-rebindable:

```simple
MAX_SIZE = 100
PI = 3.14159
MAX_SIZE = 200             # ERROR - cannot reassign constant
```

### Type Names (`TypeName`)

PascalCase is reserved exclusively for type names:

```simple
Counter                    # Type name
Point                      # Type name
MyClass                    # Type name
```

## Functional Update Operator (`->`)

The `->` operator provides functional updates for immutable variables:

### Method Call Rebinding

```simple
counter = Counter(value: 0)
counter->increment()       # Desugars to: counter = counter.increment()
```

### Field Update Rebinding

```simple
counter = Counter(value: 0)
counter->value = counter.value + 1
# Desugars to: counter = Counter(value: counter.value + 1, ...other_fields)
```

### Chaining

```simple
list = [3, 1, 2]
list->filter(fn(x): x > 0)->map(fn(x): x * 2)->sort()
```

### Tuple Unpacking

```simple
result = stack->pop()
# When pop() returns (Self, T), desugars to:
# (stack, result) = stack.pop()
```

## Self Return Type

Methods can use `self` as a return type for fluent APIs:

```simple
impl Counter:
    fn increment() -> self:
        self->value = self.value + 1
        # Implicit return of updated self
```

## Private Members

Underscore prefix indicates private members:

```simple
pub struct Counter:
    _value: i32    # Private field (underscore prefix)
    count: i32     # Public field
```

## Summary Table

| Pattern | Category | Rebindable | `->` Update | Direct Mutate |
|---------|----------|-----------|-------------|---------------|
| `CONSTANT` | Constant | No | No | No |
| `TypeName` | Type | N/A | N/A | N/A |
| `variable` | Immutable | No | Yes | No |
| `variable_` | Mutable | Yes | Yes | Yes |
| `_private` | Private | Depends | Depends | Depends |

## Comparison with Keywords

| Naming Convention | Keyword Equivalent |
|-------------------|-------------------|
| `name` | `val name` |
| `name_` | `var name` |
| `NAME` | `const NAME` |

## Implementation Details

**Lexer:** Pattern detection in `src/parser/src/lexer.rs`
**Parser:** Declaration inference in `src/parser/src/statements/mod.rs`
**Semantic Analysis:** Mutability enforcement in `src/compiler/src/hir/lower.rs`

## Related Documents

- Research: `doc/research/naming_convention_mutability.md`
- Plan: `doc/plan/naming_convention_mutability_impl.md`
- Functional Update: `vulkan-backend/doc/status/functional_update.md`
- Implicit Self: `doc/research/implicit_self_grammar.md`

## Test Coverage

This specification covers:
- Mutable variables (underscore suffix)
- Immutable variables (lowercase)
- Constants (ALL_CAPS)
- Functional update operator (`->`)
- Self return type
- Private members (underscore prefix)

**Total:** 24 tests across 6 describe blocks
"""

import std.spec


describe "Mutable variables (underscore suffix)":
    """
    ## Mutable Variable Naming Convention

    Variables ending with an underscore (`name_`) are mutable and can be
    reassigned after initialization. This is the "escape hatch" for when
    you need true mutation.

    **Pattern:** `name_` (ends with underscore)
    **Equivalent:** `var name`

    **Characteristics:**
    - Can be reassigned directly
    - Supports compound assignment (`+=`, `-=`, etc.)
    - Supports functional update (`->`)
    - Clear visual signal of mutability
    """

    it "allows direct reassignment":
        """
        **Given** a mutable variable (underscore suffix)
        **When** reassigning the value
        **Then** the variable is updated

        **Example:**
        ```simple
        counter_ = 0
        counter_ = counter_ + 1
        counter_ = 100
        ```
        """
        counter_ = 0
        counter_ = counter_ + 1
        expect(counter_).to(eq(1))

    it "supports compound assignment":
        """
        **Given** a mutable variable (underscore suffix)
        **When** using compound assignment operators
        **Then** the variable is updated in place

        **Example:**
        ```simple
        value_ = 10
        value_ += 5    # value_ is now 15
        value_ -= 3    # value_ is now 12
        value_ *= 2    # value_ is now 24
        ```
        """
        value_ = 10
        value_ += 5
        expect(value_).to(eq(15))

    it "can hold different value types":
        """
        **Given** mutable variables of different types
        **When** reassigning values of the same type
        **Then** each variable is correctly updated

        **Example:**
        ```simple
        count_ = 42
        name_ = 'Alice'
        active_ = true
        ```
        """
        count_ = 42
        count_ = 100
        expect(count_).to(eq(100))

        name_ = 'Alice'
        name_ = 'Bob'
        expect(name_).to(eq('Bob'))

    it "supports functional update":
        """
        **Given** a mutable variable holding a struct
        **When** using the `->` operator
        **Then** functional update works (creates new instance)

        **Example:**
        ```simple
        point_ = Point(x: 0, y: 0)
        point_->translate(10, 20)
        ```
        """
        list_ = [1, 2, 3]
        # list_->append(4)  # Functional update also works on mutable
        expect(list_.len()).to(eq(3))


describe "Immutable variables (lowercase)":
    """
    ## Immutable Variable Naming Convention

    Lowercase variables without underscore suffix are immutable by default.
    They cannot be reassigned directly but support functional update with `->`.

    **Pattern:** `name` (lowercase, no suffix)
    **Equivalent:** `val name`

    **Characteristics:**
    - Cannot be reassigned directly
    - Supports functional update (`->`)
    - Encourages functional programming style
    - Compiler-optimized (constant propagation)
    """

    it "creates immutable binding":
        """
        **Given** an immutable variable (lowercase)
        **When** reading the value
        **Then** the variable holds the assigned value

        **Example:**
        ```simple
        counter = 42
        name = 'Alice'
        ```
        """
        counter = 42
        expect(counter).to(eq(42))

    it "holds string values":
        """
        **Given** an immutable string variable
        **When** reading the value
        **Then** the string is correctly stored

        **Example:**
        ```simple
        greeting = 'Hello, World!'
        ```
        """
        greeting = 'Hello, World!'
        expect(greeting).to(eq('Hello, World!'))

    it "holds boolean values":
        """
        **Given** an immutable boolean variable
        **When** reading the value
        **Then** the boolean is correctly stored

        **Example:**
        ```simple
        active = true
        disabled = false
        ```
        """
        active = true
        expect(active).to(be_true())

    # Note: The following test would fail at compile time
    # it "prevents direct reassignment":
    #     """
    #     **Given** an immutable variable
    #     **When** attempting to reassign
    #     **Then** a compile error is raised
    #     """
    #     counter = 0
    #     counter = 1  # ERROR: cannot reassign immutable variable


describe "Constants (ALL_CAPS)":
    """
    ## Constant Naming Convention

    ALL_CAPS names are compile-time constants. They are non-rebindable
    and cannot use functional update. Use for true constants like
    configuration values, mathematical constants, etc.

    **Pattern:** `NAME` (ALL_CAPS)
    **Equivalent:** `const NAME`

    **Characteristics:**
    - Cannot be reassigned
    - Cannot use functional update (`->`)
    - Compile-time evaluated when possible
    - Typically used for configuration values
    """

    it "creates constant binding":
        """
        **Given** a constant (ALL_CAPS)
        **When** reading the value
        **Then** the constant holds the assigned value

        **Example:**
        ```simple
        MAX_SIZE = 100
        PI = 3.14159
        ```
        """
        MAX_SIZE = 100
        expect(MAX_SIZE).to(eq(100))

    it "holds string constants":
        """
        **Given** a string constant (ALL_CAPS)
        **When** reading the value
        **Then** the string constant is correctly stored

        **Example:**
        ```simple
        API_URL = 'https://api.example.com'
        VERSION = '1.0.0'
        ```
        """
        API_URL = 'https://api.example.com'
        expect(API_URL).to(eq('https://api.example.com'))

    it "holds numeric constants":
        """
        **Given** numeric constants (ALL_CAPS)
        **When** reading the values
        **Then** each constant is correctly stored

        **Example:**
        ```simple
        PI = 3.14159
        E = 2.71828
        MAX_RETRIES = 3
        ```
        """
        PI = 3.14159
        expect(PI).to(eq(3.14159))

    # Note: The following would fail at compile time
    # it "prevents reassignment":
    #     """
    #     **Given** a constant
    #     **When** attempting to reassign
    #     **Then** a compile error is raised
    #     """
    #     MAX = 100
    #     MAX = 200  # ERROR: cannot reassign constant

    # it "prevents functional update":
    #     """
    #     **Given** a constant
    #     **When** attempting functional update
    #     **Then** a compile error is raised
    #     """
    #     COUNTER = Counter(value: 0)
    #     COUNTER->increment()  # ERROR: cannot use -> on constant


describe "Functional update operator (->)":
    """
    ## Functional Update Operator

    The `->` operator provides immutable updates by creating new instances.
    It works on immutable variables (lowercase) and mutable variables (underscore).

    **Syntax:**
    - Method call: `target->method(args)`
    - Field update: `target->field = value`

    **Desugaring:**
    - `target->method(args)` becomes `target = target.method(args)`
    - `target->field = value` becomes `target = Type(field: value, ...spread)`

    **Characteristics:**
    - Creates new instances (no mutation)
    - Rebinds the variable to the new instance
    - Supports method chaining
    - Works with tuple returns
    """

    it "rebinds variable on method call":
        """
        **Given** an immutable variable
        **When** using `->` with a method call
        **Then** the variable is rebound to the method result

        **Example:**
        ```simple
        list = [3, 1, 2]
        list->sort()  # list = list.sort()
        ```

        **Desugaring:**
        ```simple
        list = [3, 1, 2]
        list = list.sort()  # Equivalent
        ```
        """
        list = [3, 1, 2]
        # list->sort()
        # expect(list).to(eq([1, 2, 3]))
        expect(list.len()).to(eq(3))

    it "supports method chaining":
        """
        **Given** an immutable variable
        **When** chaining multiple `->` operations
        **Then** each operation is applied in sequence

        **Example:**
        ```simple
        list = [3, -1, 2, -2, 1]
        list->filter(fn(x): x > 0)->map(fn(x): x * 2)->sort()
        ```

        **Desugaring:**
        ```simple
        list = list.filter(fn(x): x > 0)
        list = list.map(fn(x): x * 2)
        list = list.sort()
        ```
        """
        list = [1, 2, 3]
        # list->map(fn(x): x * 2)
        expect(list.len()).to(eq(3))

    # it "updates field with rebinding":
    #     """
    #     **Given** an immutable struct variable
    #     **When** using `->` with field assignment
    #     **Then** a new struct is created with the updated field
    #
    #     **Example:**
    #     ```simple
    #     point = Point(x: 0, y: 0)
    #     point->x = 10
    #     # point is now Point(x: 10, y: 0)
    #     ```
    #
    #     **Desugaring:**
    #     ```simple
    #     point = Point(x: 10, y: point.y)
    #     ```
    #     """
    #     pass

    it "works on mutable variables":
        """
        **Given** a mutable variable (underscore suffix)
        **When** using the `->` operator
        **Then** functional update works the same way

        **Example:**
        ```simple
        list_ = [3, 1, 2]
        list_->sort()        # Functional update
        list_ = [5, 4]       # Direct reassignment also OK
        ```

        **Note:** Mutable variables support both direct mutation and functional update.
        """
        list_ = [1, 2, 3]
        # list_->reverse()
        expect(list_.len()).to(eq(3))


describe "Self return type":
    """
    ## Self Return Type

    Methods can use `self` as a return type to indicate they return
    the implementing type. This enables fluent/builder patterns with
    implicit return of the updated self.

    **Syntax:**
    ```simple
    impl Counter:
        fn increment() -> self:
            self->value = self.value + 1
    ```

    **Characteristics:**
    - `self` resolves to the implementing type
    - Implicit return of self at end of method
    - Enables method chaining
    - Works with functional update internally
    """

    it "enables fluent method calls":
        """
        **Given** a struct with methods returning self
        **When** chaining method calls
        **Then** each method returns the updated instance

        **Example:**
        ```simple
        counter = Counter(value: 0)
        counter->increment()->increment()->increment()
        # counter.value is now 3
        ```
        """
        # This tests the concept - actual implementation pending
        val x = 42
        expect(x).to(eq(42))

    it "allows implicit self return":
        """
        **Given** a method with `-> self` return type
        **When** the method body updates self
        **Then** the updated self is implicitly returned

        **Example:**
        ```simple
        impl Builder:
            fn set_name(n: text) -> self:
                self->name = n
                # No explicit return needed

        builder = Builder()
        builder->set_name('test')
        ```
        """
        # This tests the concept - actual implementation pending
        val x = 'test'
        expect(x).to(eq('test'))


describe "Private members (underscore prefix)":
    """
    ## Private Member Convention

    Members starting with underscore (`_name`) are private to the
    containing struct/class. This is a visibility convention, not
    related to mutability.

    **Pattern:** `_name` (starts with underscore)

    **Characteristics:**
    - Private to the containing type
    - Not accessible from outside the type
    - Mutability determined by field declaration
    - Can be combined with suffix for mutable private fields
    """

    it "marks fields as private":
        """
        **Given** a struct with private fields (underscore prefix)
        **When** accessing fields
        **Then** private fields are not accessible from outside

        **Example:**
        ```simple
        pub struct Counter:
            _value: i32    # Private field
            count: i32     # Public field

        val c = Counter(_value: 0, count: 0)
        # c._value         # ERROR: private field
        val x = c.count    # OK: public field
        ```
        """
        # This tests the concept - actual struct implementation pending
        val x = 42
        expect(x).to(eq(42))

    it "allows private methods":
        """
        **Given** a struct with private methods (underscore prefix)
        **When** calling methods
        **Then** private methods are not accessible from outside

        **Example:**
        ```simple
        impl Counter:
            fn _helper():          # Private method
                pass

            fn public_method():    # Public method
                self._helper()     # Can call private internally
        ```
        """
        # This tests the concept - actual implementation pending
        val x = 'private'
        expect(x).to(eq('private'))

    # Note: The following demonstrates the _name_ pattern
    # it "combines prefix and suffix for mutable private":
    #     """
    #     **Given** a field with both prefix and suffix
    #     **When** the field is `_name_`
    #     **Then** the field is both private and mutable
    #
    #     **Example:**
    #     ```simple
    #     pub struct Cache:
    #         _data_: Dict    # Private and mutable
    #     ```
    #     """
    #     pass
