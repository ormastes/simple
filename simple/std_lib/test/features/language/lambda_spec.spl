# Lambda Syntax Specification
# Feature: Lambda expressions with backslash syntax and capture-all
# Category: Language | Difficulty: 2 | Status: Complete

"""
# Lambda Expressions

**Category:** Language - Functional Programming
**Difficulty:** 2/5
**Status:** Complete

## Overview

Simple supports multiple syntaxes for creating lambda (anonymous) functions.
This specification focuses on the backslash syntax (`\param: expr`) and the
new capture-all feature (`\ *:`), complementing the pipe syntax (`|param| expr`).

## Syntax Variants

### Backslash Syntax
```simple
\x: x * 2                    # Single parameter
\a, b: a + b                 # Multiple parameters
\x, y, z: x + y + z          # Three or more parameters
```

### Pipe Syntax (Alternative)
```simple
|x| x * 2                    # Single parameter
|a, b| a + b                 # Multiple parameters
```

### Capture-All Syntax (NEW)
```simple
\ *: expr                    # Capture all immutable variables
\: expr                      # Empty colon (equivalent to \ *:)
```

## Key Features

- **Dual Syntax:** Both backslash (`\`) and pipe (`|`) syntax supported
- **Capture-All:** Explicit syntax for capturing all variables in scope
- **Type Inference:** Parameter and return types automatically inferred
- **First-Class:** Lambdas are values that can be stored and passed
- **Lexical Closure:** Automatically captures referenced variables

## Capture-All Mechanism

The `\ *:` syntax explicitly captures all immutable variables from the
enclosing scope, making captured dependencies visible in the syntax:

```simple
val a = 10
val b = 20
val c = 30

# Explicitly shows this lambda captures everything
val sum_all = \ *: a + b + c
```

**Empty Colon Shorthand:**
The `\:` syntax (without explicit `*`) is equivalent to `\ *:`:

```simple
\: a + b + c    # Same as \ *: a + b + c
```

## Comparison with Other Syntax

| Syntax | Example | Use Case |
|--------|---------|----------|
| Backslash | `\x: x * 2` | Clean, LL(1)-friendly |
| Pipe | `|x| x * 2` | Familiar to Rust/Ruby users |
| Capture-all | `\ *: expr` | Make captures explicit |
| Empty colon | `\: expr` | Concise capture-all |

## Test Coverage

This specification validates:
1. **Backslash Lambda Syntax:** Basic parameter syntax
2. **Multiple Parameters:** Comma-separated parameter lists
3. **Capture-All:** Explicit `\ *:` syntax
4. **Empty Colon:** `\:` shorthand for capture-all
5. **Mixed Usage:** Combining different lambda forms

## Related Features

- Closures (#24): Full closure specification with pipe syntax
- Functions (#12): Named function definitions
- Go expressions: Similar `\ *:` syntax for goroutine captures
"""

describe "Backslash lambda syntax":
    """
    ## Backslash Lambda Expressions

    The backslash syntax (`\param: expr`) provides an alternative to pipe
    syntax that is more LL(1)-parser friendly and visually distinct.

    **Syntax:**
    ```simple
    \param: expression
    \p1, p2: expression
    \p1, p2, p3: expression
    ```

    **Advantages:**
    - Single-token lookahead parsing (LL(1) compatible)
    - Clear parameter/body boundary (colon)
    - Consistent with `go` expression syntax
    - No ambiguity with bitwise OR operator

    **Comparison:**
    ```simple
    # Backslash syntax
    val add = \a, b: a + b

    # Pipe syntax (alternative)
    val add = |a, b| a + b
    ```

    Both syntaxes are fully equivalent and can be used interchangeably.
    """

    it "creates lambda with single parameter":
        """
        **Given** a backslash lambda with one parameter
        **When** calling the lambda
        **Then** executes the lambda body correctly

        **Example:**
        ```simple
        val double = \x: x * 2
        double(5)  # 10
        ```

        **Parser Handling:**
        1. Sees `\` token → lambda expression
        2. Parses identifier `x` → parameter name
        3. Expects `:` token → parameter/body separator
        4. Parses `x * 2` → lambda body
        5. Creates Lambda AST node

        **Verification:** double(5) must equal 10
        """
        val double = \x: x * 2
        expect(double(5)).to(eq(10))

    it "creates lambda with multiple parameters":
        """
        **Given** a backslash lambda with multiple parameters
        **When** calling with multiple arguments
        **Then** binds arguments to parameters correctly

        **Example:**
        ```simple
        val add = \a, b: a + b
        add(3, 7)  # 10
        ```

        **Parameter List Parsing:**
        1. Sees `\` → lambda start
        2. Parses `a` → first parameter
        3. Sees `,` → expects more parameters
        4. Parses `b` → second parameter
        5. Sees `:` → parameter list ends
        6. Parses body

        **Multiple Parameters:**
        ```simple
        val sum3 = \x, y, z: x + y + z
        sum3(1, 2, 3)  # 6
        ```

        **Verification:** add(3, 7) must equal 10
        """
        val add = \a, b: a + b
        expect(add(3, 7)).to(eq(10))

    it "creates lambda with three parameters":
        """
        **Given** a backslash lambda with three parameters
        **When** calling with three arguments
        **Then** binds all arguments correctly

        **Example:**
        ```simple
        val sum3 = \x, y, z: x + y + z
        sum3(1, 2, 3)  # 6
        ```

        **Verification:** sum3(1, 2, 3) must equal 6
        """
        val sum3 = \x, y, z: x + y + z
        expect(sum3(1, 2, 3)).to(eq(6))

describe "Capture-all syntax":
    """
    ## Explicit Capture-All

    The `\ *:` syntax makes it explicit that a lambda captures all variables
    from the enclosing scope, improving code clarity and intent.

    **Syntax:**
    ```simple
    \ *: expression      # Explicit capture-all
    \: expression        # Shorthand (empty colon)
    ```

    **When to Use:**
    - Lambda references many outer variables
    - Want to make captures explicit for clarity
    - Documenting dependencies on outer scope

    **Captured Variables:**
    - All immutable (`val`) variables in scope
    - Variables from all outer scopes (lexical closure)
    - NOT parameters (those are lambda-local)
    - NOT mutable variables (safety)

    **Example:**
    ```simple
    val a = 1
    val b = 2
    val c = 3

    # Makes it clear this lambda depends on outer scope
    val sum_all = \ *: a + b + c
    sum_all()  # 6
    ```

    **Empty Colon Shorthand:**
    `\:` is syntactic sugar for `\ *:`:
    ```simple
    \: a + b        # Same as \ *: a + b
    ```

    **Implementation Note:**
    The `*` is a separate token with whitespace: `\ *:` not `\*:`
    This ensures clean parsing and avoids ambiguity with multiply operator.
    """

    it "captures all variables with star syntax":
        """
        **Given** variables in outer scope
        **When** creating lambda with `\ *:` syntax
        **Then** lambda captures all immutable variables

        **Example:**
        ```simple
        val x = 10
        val y = 20
        val capture_all = \ *: x + y
        capture_all()  # 30
        ```

        **Capture Process:**
        1. Lambda created with capture-all marker
        2. Compiler scans current scope for `val` variables
        3. Creates capture list: [x, y]
        4. When called, lambda accesses captured values

        **Verification:** capture_all() must equal 30 (10 + 20)

        **Syntax Note:** Space between `\` and `*` is required.
        `\*:` would be parse error, must be `\ *:`
        """
        val x = 10
        val y = 20
        val capture_all = \ *: x + y
        expect(capture_all()).to(eq(30))

    it "captures all with empty colon syntax":
        """
        **Given** variables in outer scope
        **When** creating lambda with `\:` (empty colon) syntax
        **Then** lambda captures all variables (same as `\ *:`)

        **Example:**
        ```simple
        val a = 5
        val b = 15
        val sum = \: a + b
        sum()  # 20
        ```

        **Empty Colon Behavior:**
        - Equivalent to `\ *:` capture-all
        - More concise when star is obvious
        - Common shorthand in practice

        **When to Use:**
        - Lambda clearly depends on outer scope
        - Capture intent is obvious from context
        - Prefer brevity over explicitness

        **When to Use `\ *:` Instead:**
        - Make captures explicitly visible
        - Documentation/code review clarity
        - Complex scopes with many variables

        **Verification:** sum() must equal 20 (5 + 15)
        """
        val a = 5
        val b = 15
        val sum = \: a + b
        expect(sum()).to(eq(20))

    it "captures multiple variables":
        """
        **Given** multiple variables in scope
        **When** lambda with capture-all references them
        **Then** all variables are accessible in lambda

        **Example:**
        ```simple
        val base = 100
        val multiplier = 2
        val offset = 10
        val compute = \ *: base * multiplier + offset
        compute()  # 210 (100 * 2 + 10)
        ```

        **Verification:** compute() must equal 210
        """
        val base = 100
        val multiplier = 2
        val offset = 10
        val compute = \ *: base * multiplier + offset
        expect(compute()).to(eq(210))

describe "Mixed lambda usage":
    """
    ## Combining Lambda Forms

    All lambda syntaxes can be used together in the same codebase.
    Choose the syntax that best fits each use case.

    **Guidelines:**
    - **Backslash (`\x: expr`):** Default, LL(1)-friendly
    - **Pipe (`|x| expr`):** When more familiar to team
    - **Capture-all (`\ *:`):** Make captures explicit
    - **Empty colon (`\:`):** Concise capture-all

    **Consistency:**
    While mixing is allowed, prefer consistency within a module or project.
    """

    it "uses backslash lambda with captures":
        """
        **Given** a lambda with explicit parameters that also captures
        **When** lambda references both parameters and outer variables
        **Then** both are accessible

        **Example:**
        ```simple
        val multiplier = 10
        val scale = \x: x * multiplier
        scale(5)  # 50
        ```

        **Dual Access:**
        - `x` is a parameter (passed explicitly)
        - `multiplier` is captured from outer scope
        - Both accessible in lambda body

        **Verification:** scale(5) must equal 50 (5 * 10)
        """
        val multiplier = 10
        val scale = \x: x * multiplier
        expect(scale(5)).to(eq(50))

    it "returns lambda from function":
        """
        **Given** a function that returns a lambda
        **When** lambda captures function's local variables
        **Then** returned lambda retains access to captured variables

        **Example:**
        ```simple
        fn make_adder(n):
            return \x: x + n

        val add10 = make_adder(10)
        add10(5)  # 15
        ```

        **Closure Property:**
        - Lambda `\x: x + n` captures `n` from function scope
        - Even after function returns, `n` is accessible
        - This is true lexical closure

        **Verification:** add10(5) must equal 15 (5 + 10)
        """
        fn make_adder(n):
            return \x: x + n

        val add10 = make_adder(10)
        expect(add10(5)).to(eq(15))

    it "uses lambda in higher-order function":
        """
        **Given** a higher-order function accepting function parameter
        **When** passing backslash lambda as argument
        **Then** lambda executes correctly within higher-order function

        **Example:**
        ```simple
        fn apply_twice(f, x):
            return f(f(x))

        apply_twice(\n: n + 1, 5)  # 7 (5+1+1)
        ```

        **Higher-Order Pattern:**
        - `apply_twice` accepts function `f` and value `x`
        - Calls `f(x)` then `f(result)` (applies twice)
        - Lambda `\n: n + 1` is the increment function

        **Verification:** apply_twice(\n: n + 1, 5) must equal 7
        """
        fn apply_twice(f, x):
            return f(f(x))

        val result = apply_twice(\n: n + 1, 5)
        expect(result).to(eq(7))
