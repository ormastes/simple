# Closures Feature Specification
# Feature #24: Lambda functions and closures
# Category: Language | Difficulty: 3 | Status: Complete

"""
# Lambda Functions and Closures

**Feature ID:** #24
**Category:** Language - Functional Programming
**Difficulty:** 3/5
**Status:** Complete

## Overview

Closures are anonymous functions that can capture variables from their enclosing
scope, enabling powerful functional programming patterns. Simple's closures follow
the lexical scoping model found in JavaScript, Python, and Rust, making them
familiar to developers from those ecosystems.

## Syntax

**Lambda Expression:**
```simple
|param1, param2| expression
|param1, param2| { statement1; statement2 }
```

**Examples:**
```simple
val add = |a, b| a + b          # Simple lambda
val square = |x| x * x          # Single parameter
val greet = |name| {            # Block body
    val msg = "Hello, " + name
    print(msg)
}
```

## Key Features

- **First-Class Functions:** Lambdas are values that can be stored, passed, and returned
- **Lexical Capture:** Automatically captures variables from enclosing scope
- **Capture by Reference:** Captured variables are accessed by reference, not copied
- **Type Inference:** Parameter and return types inferred from usage
- **Higher-Order Functions:** Functions that take or return functions

## Closure Capture Mechanism

When a lambda references a variable from an outer scope, it "closes over" that
variable, creating a closure:

```simple
fn make_counter():
    var count = 0
    return || {
        count = count + 1
        return count
    }

val counter = make_counter()
counter()  # 1
counter()  # 2
counter()  # 3
```

**How It Works:**
1. Lambda created: references to outer variables stored
2. Outer scope exits: captured variables kept alive
3. Lambda called: accesses captured variables through references

## Test Coverage

This specification validates:
    1. **Lambda Functions:** Basic anonymous function creation and invocation
2. **Closure Capture:** Capturing variables from enclosing scopes
3. **Higher-Order Functions:** Functions as parameters and return values
4. **Functional Patterns:** map(), filter(), and other list operations

## Implementation

**Primary Files:**
- `src/compiler/src/interpreter_call.rs` - Lambda invocation and closure capture
- `src/runtime/src/value/objects.rs` - Closure runtime representation

**Testing:**
- `src/driver/tests/interpreter_basic_tests.rs` - Rust integration tests

**Dependencies:**
- Feature #1: Lexer (tokenizes | and =>)
- Feature #2: Parser (parses lambda expressions)
- Feature #12: Functions (function call mechanism)

**Required By:**
- Feature #20: List operations (map, filter, reduce)

## Runtime Representation

```rust
struct Closure {
    parameters: Vec<String>,
    body: Expr,
    captured_env: Environment,  // Captured variables
}
```

- **parameters:** Lambda parameter names
- **body:** Expression or block to execute
- **captured_env:** Snapshot of outer scope variables

## Capture Semantics

**By Reference (Simple's Model):**
```simple
var x = 10
val f = || x + 1
x = 20
f()  # Returns 21 (sees updated value)
```

**Alternative Models (for comparison):**
- **By Value (C++):** Copies variable value at lambda creation
- **By Move (Rust):** Transfers ownership to closure

Simple uses by-reference for simplicity and familiarity.

## Common Patterns

**Partial Application:**
```simple
fn make_adder(n):
    return |x| x + n

val add10 = make_adder(10)
add10(5)  # 15
```

**Currying:**
```simple
fn curry_add(a):
    return |b| |c| a + b + c

curry_add(1)(2)(3)  # 6
```

**Callbacks:**
```simple
fn async_operation(callback):
    # ... do work ...
    callback(result)

async_operation(|result| print(result))
```

**List Processing:**
```simple
[1, 2, 3, 4, 5]
    .filter(|x| x % 2 == 0)
    .map(|x| x * x)
    .reduce(|acc, x| acc + x, 0)
```

## Performance Characteristics

- **Creation:** O(1) + O(k) where k = number of captured variables
- **Invocation:** Same as regular function call
- **Memory:** Captured environment kept alive (potential for memory leaks if not careful)

## Comparison with Other Languages

| Feature | Simple | JavaScript | Python | Rust |
|---------|--------|------------|--------|------|
| Lambda syntax | `\|x\| expr` | `x => expr` | `lambda x: expr` | `\|x\| expr` |
| Capture by ref | ✅ | ✅ | ✅ | Optional |
| Capture by move | ❌ | ❌ | ❌ | ✅ |
| Type inference | ✅ | ✅ | ✅ | ✅ |

## Related Features

- Feature #12: Functions (foundation for lambdas)
- Feature #20: List operations (map, filter, reduce)
- Feature #95: Type inference (lambda type deduction)

**Migration Notes:**
- Automated migration: N/A (already in SSpec format)
- Manual assertion conversion: ~18 minutes (9 assertions × 2 min)
- Docstring enhancement: ~32 minutes
- Total: ~50 minutes
"""

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 24,
    name: 'Closures',
    category: 'Language',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/functions.md',
    files: [
        'src/compiler/src/interpreter_call.rs',
        'src/runtime/src/value/objects.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_basic_tests.rs'
    ],
    description: 'Lambda functions (anonymous functions) with lexical closure. Captures variables from enclosing scope.',
    code_examples: [],
    dependencies: [1, 2, 12],
    required_by: [20],
    notes: 'Closures capture by reference. Support first-class functionvalues.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('  CLOSURES FEATURE SPECIFICATION (#24)')
print('  Category: Language | Difficulty: 3 | Status: Complete')
print('')


describe "Lambda functions":
    """
    ## Anonymous Functions (Lambdas)

    Lambda functions are anonymous functions defined with the `|params| expression`
    syntax. They can be assigned to variables, passed as arguments, or used inline.

    **Syntax:**
    ```simple
    |param1, param2| expression
    |param| expression
    || expression  # no parameters
    ```

    **Key Properties:**
    - First-class values (can be stored in variables)
    - Can be passed to functions as arguments
    - Can be returned from functions
    - Type inferred from context
    - Concise syntax for simple operations

    **Use Cases:**
    - Inline operations (map, filter transformations)
    - Event handlers and callbacks
    - Higher-order function arguments
    - Temporary helper functions

    **Implementation:** Lambdas are compiled to the same runtime representation
    as named functions, with generated names.
    """

        it "creates simple lambda":
            """
            **Given** a lambda expression with two parameters
            **When** assigning to a variable and calling it
            **Then** executes the lambda body and returns the result

            **Example:**
            ```simple
            val add = |a, b| a + b
            add(2, 3)  # 5
            ```

            **Compilation:**
            1. Parser recognizes `|a, b| a + b` as lambda expression
            2. Creates anonymous function with parameters [a, b]
            3. Body is the expression `a + b`
            4. Stores function value in variable `add`

            **Runtime Representation:**
            ```
            Closure {
                parameters: ["a", "b"],
                body: BinaryOp(Var("a"), Add, Var("b")),
                captured_env: {}  # no captures
            }
            ```

            **Invocation:**
            - `add(2, 3)` calls the lambda with arguments [2, 3]
            - Parameters bound: a=2, b=3
            - Body evaluated: 2 + 3
            - Result: 5

            **Type Inference:**
            - From usage `add(2, 3)`, infers parameter types are numeric
            - Return type inferred from body expression

            **Verification:** Confirms lambda creation and invocation work correctly

            **Implementation:** See interpreter_call.rs::call_closure()
            """
            val add = |a, b| a + b
            expect(add(2, 3)).to(eq(5))

        it "creates single-arg lambda":
            """
            **Given** a lambda with one parameter
            **When** calling with single argument
            **Then** applies operation to argument

            **Example:**
            ```simple
            val double = |x| x * 2
            double(5)  # 10
            ```

            **Single Parameter Syntax:**
            - Parentheses around parameter are optional: `|x|` not `|(x)|`
            - Common for map/filter operations
            - Cleaner than multi-parameter syntax

            **Common Single-Parameter Patterns:**
            ```simple
            [1, 2, 3].map(|x| x * 2)        # double each
            [1, 2, 3].filter(|x| x > 1)     # filter
            items.forEach(|item| print(item)) # iteration
            ```

            **Performance:**
            Single-parameter lambdas have same performance as multi-parameter.
            No special optimization for single parameters.

            **Verification:** double(5) must equal 10

            **Implementation:** Single-parameter lambdas use same mechanism
            as multi-parameter, just with params.len() == 1
            """
            val double = |x| x * 2
            expect(double(5)).to(eq(10))

        it "supports chained operations":
            """
            **Given** multiple lambda invocations
            **When** calling lambda on result of lambda
            **Then** compositions work correctly

            **Example:**
            ```simple
            val triple = |x| x * 3
            triple(triple(2))  # triple(6) = 18
            ```

            **Evaluation Order:**
            1. Inner call: triple(2) → 2 * 3 = 6
            2. Outer call: triple(6) → 6 * 3 = 18

            **Function Composition:**
            This enables functional composition patterns:
                ```simple
            fn compose(f, g):
                return |x| f(g(x))

            val double = |x| x * 2
            val add1 = |x| x + 1
            val double_then_add1 = compose(add1, double)

            double_then_add1(5)  # add1(double(5)) = add1(10) = 11
            ```

            **Nesting vs Composition:**
            ```simple
            # Nested (immediate)
            f(g(h(x)))

            # Composed (reusable)
            val fgh = compose(f, compose(g, h))
            fgh(x)
            ```

            **Verification:** triple(triple(2)) must equal 18

            **Performance:** Each invocation is independent function call,
            no tail-call optimization (yet)

            **Related:** Feature #42 (Function composition), Feature #95 (Type inference)
            """
            val triple = |x| x * 3
            val result = triple(triple(2))
            expect(result).to(eq(18))

print('')
describe "Closure capture":
    """
    ## Lexical Closure

    Closures "close over" variables from their enclosing scope, capturing them
    for later use even after the enclosing scope exits.

    **Capture Mechanism:**
    ```simple
    val outer = 10
    val f = |x| x + outer  # captures 'outer'
    f(5)  # 15
    ```

    **What Gets Captured:**
    - Variables referenced in lambda body
    - NOT parameters (those are local)
    - NOT variables defined inside lambda

    **Capture Lifetime:**
    - Captured variables kept alive as long as closure exists
    - Prevents garbage collection of captured environment
    - Can lead to memory retention if not careful

    **Capture By Reference:**
    Simple captures by reference, not by value:
        ```simple
    var x = 10
    val f = || x
    x = 20
    f()  # 20 (sees updated value)
    ```

    **Multiple Closures:**
    Multiple closures can capture same variable:
        ```simple
    var count = 0
    val inc = || { count += 1 }
    val dec = || { count -= 1 }
    inc(); inc(); dec()  # count = 1
    ```
    """

        it "captures outer variable":
            """
            **Given** a lambda referencing variable from outer scope
            **When** lambda is created and called
            **Then** accesses the captured variable correctly

            **Example:**
            ```simple
            val multiplier = 10
            val scale = |x| x * multiplier
            scale(5)  # 50
            ```

            **Capture Process:**
            1. Lambda `|x| x * multiplier` references `multiplier`
            2. Compiler detects `multiplier` is not a parameter
            3. Searches outer scopes, finds `multiplier = 10`
            4. Stores reference to `multiplier` in closure environment
            5. When called, lambda accesses captured `multiplier`

            **Runtime Representation:**
            ```
            Closure {
                parameters: ["x"],
                body: BinaryOp(Var("x"), Mul, Var("multiplier")),
                captured_env: { "multiplier": Ref(10) }
            }
            ```

            **Verification:** scale(5) must equal 50 (5 * 10)

            **Memory:**
            - Closure keeps reference to `multiplier`
            - If `multiplier` goes out of scope, value is still accessible
            - Prevents premature garbage collection

            **Mutation:**
            If `multiplier` were `var` instead of `val`, changes would be visible:
                ```simple
            var multiplier = 10
            val scale = |x| x * multiplier
            multiplier = 20
            scale(5)  # 100 (uses updated value)
            ```

            **Implementation:** See interpreter_call.rs::capture_environment()

            **Related:** Feature #95 (Variable scoping), Feature #12 (Functions)
            """
            val multiplier = 10
            val scale = |x| x * multiplier
            expect(scale(5)).to(eq(50))

        it "captures multiple variables":
            """
            **Given** a lambda referencing multiple outer variables
            **When** lambda is called
            **Then** all captured variables are accessible

            **Example:**
            ```simple
            val base = 100
            val offset = 5
            val compute = |x| base + x + offset
            compute(10)  # 115 (100 + 10 + 5)
            ```

            **Multiple Captures:**
            - Each referenced outer variable is captured independently
            - Captured as references, not copies
            - All kept alive for closure lifetime

            **Captured Environment:**
            ```
            captured_env: {
                "base": Ref(100),
                "offset": Ref(5)
            }
            ```

            **Scope Chain:**
            Lambda searches scopes outward:
                1. Lambda parameters (x)
            2. Lambda body locals
            3. Immediately enclosing scope (base, offset)
            4. Further outer scopes
            5. Global scope

            **Verification:** compute(10) must equal 115

            **Performance:**
            - Each captured variable adds small overhead (pointer + lookup)
            - Typically 8-16 bytes per capture
            - Negligible for most use cases

            **Deep Capture:**
            Can capture from deeply nested scopes:
                ```simple
            fn outer():
                val a = 1
                fn middle():
                    val b = 2
                    fn inner():
                        return || a + b  # captures from 2 levels up
                    return inner()
                return middle()
            ```

            **Implementation:** Closure stores hashmap of captured variable names
            to their runtime values

            **Related:** Feature #95 (Lexical scoping)
            """
            val base = 100
            val offset = 5
            val compute = |x| base + x + offset
            expect(compute(10)).to(eq(115))

print('')
describe "Higher-order functions":
    """
    ## Functions as First-Class Values

    Higher-order functions are functions that:
        1. Accept functions as parameters, or
    2. Return functions as results

    This enables powerful abstractions and code reuse patterns.

    **Function Parameters:**
    ```simple
    fn apply(f, x):
        return f(x)

    apply(|n| n * 2, 5)  # 10
    ```

    **Function Returns:**
    ```simple
    fn make_multiplier(n):
        return |x| x * n

    val times3 = make_multiplier(3)
    times3(4)  # 12
    ```

    **Common Higher-Order Functions:**
    - **map:** Transform each element: `[1,2,3].map(|x| x*2)` → `[2,4,6]`
    - **filter:** Select elements: `[1,2,3,4].filter(|x| x%2==0)` → `[2,4]`
    - **reduce:** Aggregate: `[1,2,3].reduce(|a,b| a+b, 0)` → `6`
    - **forEach:** Side effects: `items.forEach(|x| print(x))`

    **Benefits:**
    - Code reuse (one function, many behaviors)
    - Abstraction (hide implementation details)
    - Composability (combine simple functions)
    - Declarative style (what not how)
    """

        it "passes lambda to function":
            """
            **Given** a function accepting function parameter
            **When** passing lambda as argument
            **Then** function calls the lambda correctly

            **Example:**
            ```simple
            fn apply(f, x):
                return f(x)

            val square = |n| n * n
            apply(square, 4)  # 16
            ```

            **Parameter Passing:**
            1. `square` lambda created and stored
            2. `apply(square, 4)` called with function value
            3. Inside `apply`, `f` binds to the lambda
            4. `f(x)` invokes the lambda with x=4
            5. Lambda executes: 4 * 4 = 16

            **Type Signature (conceptual):**
            ```
            apply: (fn(T) -> U, T) -> U
            ```

            **Common Patterns:**
            ```simple
            fn retry(operation, times):
                for i in 0..times:
                    if operation():
                        return true
                return false

            retry(|| network_request(), 3)
            ```

            **Verification:** apply(square, 4) must equal 16

            **Performance:** Passing functions has same cost as passing
            any other value (pointer-sized)

            **Implementation:** Functions are first-class RuntimeValue variants

            **Inline Lambdas:**
            Can pass lambda inline without intermediate variable:
                ```simple
            apply(|n| n * n, 4)  # 16
            ```

            **Related:** Feature #20 (List operations), Feature #12 (Functions)
            """
            fn apply(f, x):
                return f(x)

            val square = |n| n * n
            expect(apply(square, 4)).to(eq(16))

        it "returns lambda from function":
            """
            **Given** a function that returns lambda
            **When** calling the function and then calling returned lambda
            **Then** returned lambda has access to function's scope (closure)

            **Example:**
            ```simple
            fn make_adder(n):
                return |x| x + n

            val add5 = make_adder(5)
            add5(10)  # 15
            ```

            **Closure Creation:**
            1. `make_adder(5)` called
            2. Inside function, `n` = 5
            3. Lambda `|x| x + n` created
            4. Lambda captures `n` from function scope
            5. Function returns lambda (as closure)
            6. Even though function exited, lambda retains `n`

            **This is True Closure:**
            - Lambda "closes over" function's local variable `n`
            - `n` kept alive because closure references it
            - Different calls create different closures:

            ```simple
            val add5 = make_adder(5)
            val add10 = make_adder(10)
            add5(3)   # 8
            add10(3)  # 13
            ```

            **Memory Management:**
            - Each closure maintains its own captured environment
            - `add5` has captured `n=5`
            - `add10` has captured `n=10`
            - No sharing between closures

            **Verification:** add5(10) must equal 15 (10 + 5)

            **Practical Use - Partial Application:**
            ```simple
            fn make_url_fetcher(base_url):
                return |path| fetch(base_url + path)

            val github = make_url_fetcher("https://github.com")
            github("/anthropics/claude")
            ```

            **Implementation:** Returned closure contains snapshot of
            function's environment at return time

            **Related:** Feature #95 (Variable lifetime), Feature #12 (Return values)
            """
            fn make_adder(n):
                return |x| x + n

            val add5 = make_adder(5)
            expect(add5(10)).to(eq(15))

        it "uses map with lambda":
            """
            **Given** an array and a transformation lambda
            **When** calling map() method
            **Then** returns new array with lambda applied to each element

            **Example:**
            ```simple
            val nums = [1, 2, 3]
            val doubled = nums.map(|x| x * 2)
            # doubled = [2, 4, 6]
            ```

            **Map Operation:**
            - Takes array and function
            - Applies function to each element
            - Collects results in new array
            - Original array unchanged

            **Conceptual Implementation:**
            ```simple
            fn map(array, f):
                val result = []
                for item in array:
                    result.append(f(item))
                return result
            ```

            **Verification:**
            - doubled[0] must equal 2 (1 * 2)
            - doubled[1] must equal 4 (2 * 2)
            - doubled[2] must equal 6 (3 * 2)

            **Chaining:**
            ```simple
            [1, 2, 3]
                .map(|x| x * 2)     # [2, 4, 6]
                .map(|x| x + 1)     # [3, 5, 7]
                .map(|x| x.toString()) # ["3", "5", "7"]
            ```

            **Type Safety:**
            - Lambda input type: element type of array
            - Lambda return type: element type of result array
            - Type inference determines types automatically

            **Performance:**
            - O(n) where n = array length
            - Creates new array (no mutation)
            - Each lambda call has function call overhead

            **Implementation:** See runtime/value/objects.rs::array_map()

            **Related:** Feature #20 (List operations), Feature #13 (Arrays)
            """
            val nums = [1, 2, 3]
            val doubled = nums.map(|x| x * 2)
            expect(doubled[0]).to(eq(2))
            expect(doubled[1]).to(eq(4))
            expect(doubled[2]).to(eq(6))

        it "uses filter with lambda":
            """
            **Given** an array and a predicate lambda
            **When** calling filter() method
            **Then** returns new array with only elements where predicate is true

            **Example:**
            ```simple
            val values = [1, 2, 3, 4, 5]
            val evens = values.filter(|x| x % 2 == 0)
            # evens = [2, 4]
            ```

            **Filter Operation:**
            - Takes array and predicate function
            - Calls predicate on each element
            - Includes element if predicate returns true
            - Excludes element if predicate returns false

            **Conceptual Implementation:**
            ```simple
            fn filter(array, predicate):
                val result = []
                for item in array:
                    if predicate(item):
                        result.append(item)
                return result
            ```

            **Predicate Function:**
            - Must return boolean (true/false)
            - Called once per element
            - Should be pure (no side effects) for predictability

            **Verification:** evens.len() must equal 2 (only [2, 4] match)

            **Common Predicates:**
            ```simple
            # Greater than
            nums.filter(|x| x > 10)

            # Type check
            items.filter(|x| x.is_string())

            # Property check
            users.filter(|u| u.active)

            # Complex condition
            products.filter(|p| p.price < 100 and p.in_stock)
            ```

            **Chaining with Map:**
            ```simple
            [1, 2, 3, 4, 5]
                .filter(|x| x % 2 == 0)  # [2, 4]
                .map(|x| x * x)          # [4, 16]
            ```

            **Performance:**
            - O(n) where n = array length
            - Creates new array (size ≤ original)
            - Best case: all filtered out (empty array)
            - Worst case: none filtered (full copy)

            **Implementation:** See runtime/value/objects.rs::array_filter()

            **Related:** Feature #20 (List operations), Feature #13 (Arrays)
            """
            val values = [1, 2, 3, 4, 5]
            val evens = values.filter(|x| x % 2 == 0)
            expect(evens.len()).to(eq(2))

# =====================================================
# Documentation Output
# =====================================================

print('')
print('  GENERATED DOCUMENTATION')
print('')
print('# Closures')
print('')
print('**Feature ID:** #24')
print('**Category:** Language')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('  TEST SUMMARY')
print('Passed: {passed}')
print('Failed: {failed}')
print('Total:  {passed + failed}')
    print('All tests PASSED!')
