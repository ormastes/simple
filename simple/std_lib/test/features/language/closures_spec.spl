# Closures Feature Specification
# Feature #24: Lambda functions and closures
# Category: Language | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 24,
    name: 'Closures',
    category: 'Language',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/functions.md',
    files: [
        'src/compiler/src/interpreter_call.rs',
        'src/runtime/src/value/objects.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_basic_tests.rs'
    ],
    description: 'Lambda functions (anonymous functions) with lexical closure. Captures variables from enclosing scope.',
    code_examples: [],
    dependencies: [1, 2, 12],
    required_by: [20],
    notes: 'Closures capture by reference. Support first-class function values.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  CLOSURES FEATURE SPECIFICATION (#24)')
print('  Category: Language | Difficulty: 3 | Status: Complete')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

print('describe Lambda functions:')
print('  it creates simple lambda:')

let add = |a, b| a + b
if add(2, 3) == 5:
    print('    [PASS] simple lambda')
    passed = passed + 1
else:
    print('    [FAIL] lambda')
    failed = failed + 1

print('  it creates single-arg lambda:')

let double = |x| x * 2
if double(5) == 10:
    print('    [PASS] single-arg lambda')
    passed = passed + 1
else:
    print('    [FAIL] single-arg')
    failed = failed + 1

print('  it supports chained operations:')

let triple = |x| x * 3
let result = triple(triple(2))
if result == 18:
    print('    [PASS] chained lambda calls')
    passed = passed + 1
else:
    print('    [FAIL] chained calls')
    failed = failed + 1

print('')
print('describe Closure capture:')
print('  it captures outer variable:')

let multiplier = 10
let scale = |x| x * multiplier
if scale(5) == 50:
    print('    [PASS] closure capture')
    passed = passed + 1
else:
    print('    [FAIL] capture')
    failed = failed + 1

print('  it captures multiple variables:')

let base = 100
let offset = 5
let compute = |x| base + x + offset
if compute(10) == 115:
    print('    [PASS] multi-capture')
    passed = passed + 1
else:
    print('    [FAIL] multi-capture')
    failed = failed + 1

print('')
print('describe Higher-order functions:')
print('  it passes lambda to function:')

fn apply(f, x):
    return f(x)

let square = |n| n * n
if apply(square, 4) == 16:
    print('    [PASS] function as argument')
    passed = passed + 1
else:
    print('    [FAIL] function arg')
    failed = failed + 1

print('  it returns lambda from function:')

fn make_adder(n):
    return |x| x + n

let add5 = make_adder(5)
if add5(10) == 15:
    print('    [PASS] function returns lambda')
    passed = passed + 1
else:
    print('    [FAIL] return lambda')
    failed = failed + 1

print('  it uses map with lambda:')

let nums = [1, 2, 3]
let doubled = nums.map(|x| x * 2)
if doubled[0] == 2 and doubled[1] == 4 and doubled[2] == 6:
    print('    [PASS] map with lambda')
    passed = passed + 1
else:
    print('    [FAIL] map')
    failed = failed + 1

print('  it uses filter with lambda:')

let values = [1, 2, 3, 4, 5]
let evens = values.filter(|x| x % 2 == 0)
if evens.len() == 2:
    print('    [PASS] filter with lambda')
    passed = passed + 1
else:
    print('    [FAIL] filter')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Closures')
print('')
print('**Feature ID:** #24')
print('**Category:** Language')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
print('Passed: {passed}')
print('Failed: {failed}')
print('Total:  {passed + failed}')
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
