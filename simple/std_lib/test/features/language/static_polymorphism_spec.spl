# Static Polymorphism Feature Specification
# Feature: Interface Bindings for Static Dispatch
# Category: Language | Difficulty: 4 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 2001,
    name: 'Static Polymorphism',
    category: 'Language',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/traits.md#interface-bindings-static-polymorphism',
    files: [
        'src/compiler/src/monomorphize/binding_specializer.rs',
        'src/compiler/src/interpreter_eval.rs',
        'src/compiler/src/interpreter_method/special/objects.rs',
        'src/compiler/src/hir/types/module.rs',
        'src/compiler/src/mir/lower/lowering_core.rs',
        'src/parser/src/ast/nodes/definitions.rs'
    ],
    tests: [
        'tests/static_polymorphism_test.spl',
        'simple/std_lib/test/features/language/static_polymorphism_spec.spl'
    ],
    description: 'Interface bindings for static polymorphism via bind Interface = ImplType. Enables compile-time dispatch for trait method calls, eliminating vtable lookup overhead.',
    code_examples: [],
    dependencies: [31],
    required_by: [],
    notes: 'Static polymorphism bindings are module-local. They enable dependency injection patterns with zero runtime overhead.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  STATIC POLYMORPHISM FEATURE SPECIFICATION (#2001)')
print('  Category: Language | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Basic Interface Binding
# -----------------------------------------------------

print('describe Interface binding:')
print('  context basic binding syntax:')
print('    it parses bind Interface = Impl:')

trait Logger:
    fn log(msg: str) -> str

class ConsoleLogger:
    fn log(msg: str) -> str:
        return "Console: " + msg

bind Logger = ConsoleLogger

# Test that binding is accepted by parser
print('      [PASS] bind syntax parsed')
passed = passed + 1

print('')
print('  context binding with method dispatch:')
print('    it dispatches to bound implementation:')

static fn create_logger() -> Logger:
    return ConsoleLogger()

val logger: Logger = create_logger()
val result = logger.log("Hello")

if result == "Console: Hello":
    print('      [PASS] static dispatch works')
    passed = passed + 1
else:
    print('      [FAIL] static dispatch works')
    print("        Expected: Console: Hello")
    print("        Got: {result}")
    failed = failed + 1

# -----------------------------------------------------
# Multiple Method Binding
# -----------------------------------------------------

print('')
print('describe Multiple method binding:')
print('  context trait with multiple methods:')
print('    it dispatches all methods statically:')

trait Calculator:
    fn add(a: i64, b: i64) -> i64
    fn multiply(a: i64, b: i64) -> i64

class SimpleCalculator:
    fn add(a: i64, b: i64) -> i64:
        return a + b
    fn multiply(a: i64, b: i64) -> i64:
        return a * b

bind Calculator = SimpleCalculator

val calc: Calculator = SimpleCalculator()
val sum_result = calc.add(3, 4)
val mul_result = calc.multiply(3, 4)

if sum_result == 7 and mul_result == 12:
    print('      [PASS] multiple methods dispatch correctly')
    passed = passed + 1
else:
    print('      [FAIL] multiple methods dispatch correctly')
    print("        add result: {sum_result}")
    print("        multiply result: {mul_result}")
    failed = failed + 1

# -----------------------------------------------------
# Binding with Different Implementations
# -----------------------------------------------------

print('')
print('describe Different implementations:')
print('  context multiple classes implementing trait:')
print('    it uses the bound implementation:')

trait Formatter:
    fn format(value: i64) -> str

class DecimalFormatter:
    fn format(value: i64) -> str:
        return "Decimal: {value}"

class HexFormatter:
    fn format(value: i64) -> str:
        return "Hex: 0x{value}"

# Bind to DecimalFormatter
bind Formatter = DecimalFormatter

val fmt: Formatter = DecimalFormatter()
val formatted = fmt.format(42)

if formatted == "Decimal: 42":
    print('      [PASS] uses bound DecimalFormatter')
    passed = passed + 1
else:
    print('      [FAIL] uses bound DecimalFormatter')
    print("        Expected: Decimal: 42")
    print("        Got: {formatted}")
    failed = failed + 1

# -----------------------------------------------------
# Binding with Self Parameter
# -----------------------------------------------------

print('')
print('describe Self parameter handling:')
print('  context method with self:')
print('    it correctly handles self in bound type:')

trait Counter:
    fn increment() -> i64
    fn get_value() -> i64

class SimpleCounter:
    value: i64

    fn increment() -> i64:
        return self.value + 1

    fn get_value() -> i64:
        return self.value

bind Counter = SimpleCounter

val counter: Counter = SimpleCounter { value: 10 }
val incremented = counter.increment()
val current = counter.get_value()

if incremented == 11 and current == 10:
    print('      [PASS] self parameter handled correctly')
    passed = passed + 1
else:
    print('      [FAIL] self parameter handled correctly')
    print("        incremented: {incremented}")
    print("        current: {current}")
    failed = failed + 1

# -----------------------------------------------------
# Binding with Return Types
# -----------------------------------------------------

print('')
print('describe Return type handling:')
print('  context method returning complex types:')
print('    it handles return values correctly:')

trait StringProcessor:
    fn process(input: str) -> str

class UppercaseProcessor:
    fn process(input: str) -> str:
        return "UPPER: " + input

bind StringProcessor = UppercaseProcessor

val processor: StringProcessor = UppercaseProcessor()
val processed = processor.process("hello")

if processed == "UPPER: hello":
    print('      [PASS] return values handled correctly')
    passed = passed + 1
else:
    print('      [FAIL] return values handled correctly')
    print("        Expected: UPPER: hello")
    print("        Got: {processed}")
    failed = failed + 1

# -----------------------------------------------------
# Binding in Function Parameters
# -----------------------------------------------------

print('')
print('describe Function parameter binding:')
print('  context trait-typed function parameter:')
print('    it dispatches correctly in function:')

trait Greeter:
    fn greet(name: str) -> str

class FormalGreeter:
    fn greet(name: str) -> str:
        return "Good day, " + name

bind Greeter = FormalGreeter

fn do_greeting(g: Greeter, name: str) -> str:
    return g.greet(name)

val greeter: Greeter = FormalGreeter()
val greeting = do_greeting(greeter, "Alice")

if greeting == "Good day, Alice":
    print('      [PASS] function parameter dispatch works')
    passed = passed + 1
else:
    print('      [FAIL] function parameter dispatch works')
    print("        Expected: Good day, Alice")
    print("        Got: {greeting}")
    failed = failed + 1

# -----------------------------------------------------
# Chained Method Calls
# -----------------------------------------------------

print('')
print('describe Chained method calls:')
print('  context multiple method calls:')
print('    it chains bound method calls:')

trait Builder:
    fn add_value(v: i64) -> i64
    fn get_total() -> i64

class SumBuilder:
    total: i64

    fn add_value(v: i64) -> i64:
        return self.total + v

    fn get_total() -> i64:
        return self.total

bind Builder = SumBuilder

val builder: Builder = SumBuilder { total: 100 }
val v1 = builder.add_value(10)
val v2 = builder.add_value(20)
val total = builder.get_total()

if v1 == 110 and v2 == 120 and total == 100:
    print('      [PASS] chained method calls work')
    passed = passed + 1
else:
    print('      [FAIL] chained method calls work')
    print("        v1: {v1}, v2: {v2}, total: {total}")
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Static Polymorphism (Interface Bindings)')
print('')
print('**Feature ID:** #2001')
print('**Category:** Language')
print('**Difficulty:** Level 4/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Syntax')
print('')
print('```simple')
print('trait Interface:')
print('    fn method(self) -> Type')
print('')
print('class Implementation:')
print('    fn method(self) -> Type:')
print('        return value')
print('')
print('# Static dispatch via binding')
print('bind Interface = Implementation')
print('')
print('val obj: Interface = Implementation()')
print('obj.method()  # Dispatches statically to Implementation::method')
print('```')
print('')
print('## Dispatch Modes')
print('')
print('- **With binding:** `bind Interface = Impl` → Static dispatch (no vtable)')
print('- **Without binding:** Default → Dynamic dispatch (vtable-based)')
print('')
print('Note: There is no `static` or `dyn` keyword in bind statements.')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
else:
    print('Some tests FAILED!')
print('============================================================')

# Return exit code for test runner
main = failed
