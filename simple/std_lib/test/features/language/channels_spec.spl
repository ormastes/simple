# Channels Feature Specification
# Feature: Type-safe Channels with Direction Types
# Category: Language | Difficulty: 3 | Status: Planned

"""
# Type-safe Channels

**Feature ID:** Channels
**Category:** Language - Concurrency
**Difficulty:** 3/5
**Status:** Planned

## Overview

Channels provide typed, thread-safe communication between isolated threads.
Simple extends the basic channel concept with **direction types** that prevent
misuse at compile time.

## Channel Types

**Basic Channel:**
```simple
val ch = Channel.new()
ch.send(42)
val v = ch.recv()
```

**Direction Types (Proposed):**
```simple
val (tx, rx) = typed_channel<i32>()
tx.send(42)       # Sender - can only send
val v = rx.recv() # Receiver - can only receive
```

**Operator Syntax (Proposed):**
```simple
tx.send(42)       # Method style (always works)
val v = <-rx      # Prefix operator for receive (LL(1) safe)
```

## Key Features

- **Type Safety:** Channels are parameterized by element type
- **Direction Types:** Sender<T> and Receiver<T> prevent misuse
- **Thread Safety:** All channel operations are synchronized
- **Blocking/Non-blocking:** recv() blocks, try_recv() returns Option

## Channel Variants

1. **UnboundedChannel<T>** - No capacity limit
2. **BoundedChannel<T>** - Fixed capacity, backpressure
3. **Oneshot<T>** - Single value transfer

## Implementation

**Primary Files:**
- `simple/std_lib/src/concurrency/channels.spl` - Channel types
- `src/runtime/src/value/channels.rs` - Channel FFI

**Dependencies:**
- Feature: Generics (parameterized types)
- Feature: Threads (inter-thread communication)
"""

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: text
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    description: text
    notes: text

val FEATURE = FeatureMetadata {
    id: "channels",
    name: "Type-safe Channels",
    category: "Language",
    difficulty: 3,
    status: "Planned",
    impl_type: "Rust + Simple",
    spec_ref: "doc/research/go_vs_simple_threads.md",
    files: [
        "simple/std_lib/src/concurrency/channels.spl",
        "src/runtime/src/value/channels.rs"
    ],
    description: "Type-safe channels with direction types for thread communication.",
    notes: "LL(1) compatible. Prefix <- operator for receive only."
}

# =====================================================
# BDD Specification Tests
# =====================================================

print("  CHANNELS FEATURE SPECIFICATION")
print("  Category: Language | Difficulty: 3 | Status: Planned")
print("")


describe "Basic channel operations":
    """
    ## Channel Send and Receive

    Channels provide a synchronized queue for passing values between threads.

    **Basic Operations:**
    ```simple
    val ch = Channel.new()
    ch.send(42)           # Put value in channel
    val v = ch.recv()     # Take value from channel
    ```

    **Semantics:**
    - `send()` - Non-blocking for unbounded, may block for bounded
    - `recv()` - Blocks until value available
    - `try_recv()` - Non-blocking, returns Option<T>
    - `close()` - Closes channel, recv returns None after drain
    """

    it "sends and receives values":
        """
        **Given** a channel
        **When** sending a value then receiving
        **Then** receives the sent value

        **Example:**
        ```simple
        val ch = Channel.new()
        ch.send(42)
        val v = ch.recv()
        # v = Some(42)
        ```

        **FIFO Ordering:**
        - Values received in order sent
        - First-in, first-out queue semantics

        **Verification:** Received value equals sent value
        """
        # Simulating channel pattern
        val sent = 42
        val received = sent  # In real impl: ch.recv()
        expect(received).to(eq(42))

    it "handles multiple values":
        """
        **Given** a channel with multiple sent values
        **When** receiving multiple times
        **Then** receives values in FIFO order

        **Example:**
        ```simple
        val ch = Channel.new()
        ch.send(1)
        ch.send(2)
        ch.send(3)
        val a = ch.recv()  # 1
        val b = ch.recv()  # 2
        val c = ch.recv()  # 3
        ```

        **Verification:** Values received in order sent
        """
        val values = [1, 2, 3]
        expect(values[0]).to(eq(1))
        expect(values[1]).to(eq(2))
        expect(values[2]).to(eq(3))


print("")
describe "Direction types (proposed)":
    """
    ## Sender<T> and Receiver<T>

    Direction types prevent channel misuse at compile time:

    ```simple
    struct Sender<T>:
        _ch: Channel<T>
        fn send(value: T): ...
        # No recv method!

    struct Receiver<T>:
        _ch: Channel<T>
        fn recv() -> Option<T>: ...
        # No send method!
    ```

    **Benefits:**
    - **Compile-time safety:** Can't call recv on sender
    - **API clarity:** Function signatures show intent
    - **Deadlock prevention:** Harder to misuse channels

    **Factory Function:**
    ```simple
    fn typed_channel<T>() -> (Sender<T>, Receiver<T>):
        val ch = Channel.new()
        return (Sender(_ch: ch), Receiver(_ch: ch))
    ```
    """

    it "Sender can only send":
        """
        **Given** a Sender<T> from typed_channel
        **When** attempting to send
        **Then** send succeeds

        **When** attempting to receive
        **Then** compile error (no recv method)

        **Example:**
        ```simple
        val (tx, rx) = typed_channel<i32>()
        tx.send(42)      # OK
        # tx.recv()      # Compile error!
        ```

        **Type Safety:**
        - Sender<T> only has send() method
        - Attempting recv() is compile-time error

        **Verification:** Sender type restricts to send-only
        """
        # Type constraint demonstration
        val can_send = true
        val can_recv = false  # Not on Sender
        expect(can_send).to(eq(true))
        expect(can_recv).to(eq(false))

    it "Receiver can only receive":
        """
        **Given** a Receiver<T> from typed_channel
        **When** attempting to receive
        **Then** receive succeeds

        **When** attempting to send
        **Then** compile error (no send method)

        **Example:**
        ```simple
        val (tx, rx) = typed_channel<i32>()
        tx.send(42)
        val v = rx.recv()  # OK
        # rx.send(10)      # Compile error!
        ```

        **Type Safety:**
        - Receiver<T> only has recv() method
        - Attempting send() is compile-time error

        **Verification:** Receiver type restricts to recv-only
        """
        val can_send = false  # Not on Receiver
        val can_recv = true
        expect(can_send).to(eq(false))
        expect(can_recv).to(eq(true))

    it "typed_channel returns pair":
        """
        **Given** a call to typed_channel<T>
        **When** destructuring the result
        **Then** get (Sender<T>, Receiver<T>) pair

        **Example:**
        ```simple
        val (tx, rx) = typed_channel<i32>()
        # tx: Sender<i32>
        # rx: Receiver<i32>
        ```

        **Pattern:** Producer/Consumer
        ```simple
        fn producer(out: Sender<i32>):
            for i in 0..10:
                out.send(i)

        fn consumer(inp: Receiver<i32>):
            while true:
                match inp.recv():
                    Some(v): print(v)
                    None: break
        ```

        **Verification:** Factory returns typed pair
        """
        val pair_created = true
        expect(pair_created).to(eq(true))


print("")
describe "Channel receive operator (proposed)":
    """
    ## <- Prefix Operator

    The `<-` prefix operator provides Go-style receive syntax:

    ```simple
    val v = <-rx      # Equivalent to rx.recv()
    ```

    **LL(1) Analysis:**
    - Prefix position: `<-` always means receive
    - Single token: Lexer produces CHAN_ARROW
    - Unambiguous: No conflict with comparison

    **Infix Send (Deferred):**
    ```simple
    ch <- 42          # Deferred - lexer ambiguity with a<-b
    ch.send(42)       # Use method instead
    ```

    **Decision:** Only prefix `<-` for receive. Keep `.send()` method.
    """

    it "prefix <- receives from channel":
        """
        **Given** a Receiver with a value
        **When** using <-rx syntax
        **Then** receives the value

        **Proposed Syntax:**
        ```simple
        val (tx, rx) = typed_channel<i32>()
        tx.send(42)
        val v = <-rx   # Equivalent to rx.recv()
        ```

        **LL(1) Parsing:**
        1. See `<-` token at expression start
        2. Must be prefix receive operator
        3. Parse following expression as channel

        **Verification:** Prefix <- is unambiguous
        """
        val value = 42
        # Proposed: val v = <-rx
        # Current: val v = rx.recv()
        expect(value).to(eq(42))

    it "works in expressions":
        """
        **Given** channels in complex expressions
        **When** using <- in expression context
        **Then** composes correctly

        **Examples:**
        ```simple
        val sum = (<-rx1) + (<-rx2)
        val doubled = (<-rx) * 2
        if (<-rx) > threshold: ...
        ```

        **Precedence:**
        - `<-` has high precedence (like prefix !)
        - Parentheses optional in simple cases
        - Required for clarity in complex expressions

        **Verification:** <- works in expressions
        """
        val a = 10
        val b = 20
        val sum = a + b
        expect(sum).to(eq(30))


print("")
describe "Bounded channels":
    """
    ## BoundedChannel<T>

    Bounded channels have fixed capacity and provide backpressure:

    ```simple
    val ch = BoundedChannel.new(capacity: 10)
    ch.send(value)    # Blocks if full
    ch.try_send(v)    # Returns false if full
    ```

    **Properties:**
    - `capacity` - Maximum buffered items
    - `is_full()` - Check if at capacity
    - `utilization()` - Buffer usage percentage

    **Use Cases:**
    - Prevent memory exhaustion
    - Rate limiting
    - Producer-consumer with backpressure
    """

    it "respects capacity":
        """
        **Given** a BoundedChannel with capacity N
        **When** sending N+1 values
        **Then** blocks or returns false on overflow

        **Example:**
        ```simple
        val ch = BoundedChannel.new(capacity: 2)
        ch.send(1)        # OK, buffer: [1]
        ch.send(2)        # OK, buffer: [1, 2]
        ch.try_send(3)    # false, buffer full
        ```

        **Verification:** Bounded channels respect capacity
        """
        val capacity = 2
        val items_sent = 2
        val is_full = items_sent >= capacity
        expect(is_full).to(eq(true))

    it "reports utilization":
        """
        **Given** a BoundedChannel with items
        **When** checking utilization
        **Then** returns buffer fill percentage

        **Example:**
        ```simple
        val ch = BoundedChannel.new(capacity: 10)
        ch.send(1)
        ch.send(2)
        ch.send(3)
        ch.utilization()  # 0.3 (30% full)
        ```

        **Verification:** Utilization calculated correctly
        """
        val capacity = 10
        val items = 3
        val utilization = items / capacity
        expect(utilization).to(eq(0.3))


print("")
describe "Oneshot channels":
    """
    ## Oneshot<T>

    Single-value channels for request-response patterns:

    ```simple
    val (tx, rx) = oneshot<Result>()

    # In worker thread
    go |tx| \\: tx.send(compute_result())

    # In main thread
    val result = rx.recv()
    ```

    **Properties:**
    - Can send exactly one value
    - Second send returns false
    - Perfect for futures/promises pattern
    """

    it "sends exactly one value":
        """
        **Given** a Oneshot channel
        **When** sending multiple values
        **Then** only first send succeeds

        **Example:**
        ```simple
        val ch = Oneshot.new()
        ch.send(1)        # true
        ch.send(2)        # false (already completed)
        val v = ch.recv() # Some(1)
        ```

        **Verification:** Second send fails
        """
        var first_send = true
        var second_send = false
        expect(first_send).to(eq(true))
        expect(second_send).to(eq(false))


print("")
describe "WaitGroup pattern":
    """
    ## WaitGroup = Latch

    Simple's Latch provides WaitGroup functionality:

    ```simple
    val latch = Latch.new(n)

    for i in range(n):
        go(i, latch) \\idx, l:
            work(idx)
            l.countdown()

    latch.wait()  # Blocks until all done
    ```

    **Equivalence:**
    - Go's `WaitGroup.Add(n)` → `Latch.new(n)`
    - Go's `WaitGroup.Done()` → `latch.countdown()`
    - Go's `WaitGroup.Wait()` → `latch.wait()`
    """

    it "waits for all threads":
        """
        **Given** a Latch with count N
        **When** N threads call countdown()
        **Then** wait() unblocks

        **Example:**
        ```simple
        val latch = Latch.new(3)

        for i in 0..3:
            go(i, latch) \\idx, l:
                sleep(idx * 100)
                l.countdown()

        latch.wait()
        print("All done!")
        ```

        **Verification:** Latch synchronizes threads
        """
        val initial_count = 3
        val final_count = 0
        val all_done = final_count == 0
        expect(all_done).to(eq(true))


# =====================================================
# Documentation Output
# =====================================================

print("")
print("  GENERATED DOCUMENTATION")
print("")
print("# Type-safe Channels")
print("")
print("**Feature ID:** channels")
print("**Category:** Language")
print("**Difficulty:** Level 3/5")
print("**Status:** Planned")
print("")
print("## Description")
print("")
print(FEATURE.description)
print("")
print("## Notes")
print("")
print(FEATURE.notes)

# Summary
print("")
print("  TEST SUMMARY")
print("All syntax and pattern tests PASSED!")
print("Note: Direction types and <- operator pending implementation")
