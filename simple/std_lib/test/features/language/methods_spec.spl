# Methods Feature Specification
# Feature #17: Methods and self
# Category: Language | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 17,
    name: 'Methods',
    category: 'Language',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/data_structures.md',
    files: [
        'src/compiler/src/interpreter_method.rs',
        'src/parser/src/statements/mod.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_oop_tests.rs'
    ],
    description: 'Instance methods with self parameter, static methods, and method chaining. Methods are defined inside class bodies.',
    code_examples: [],
    dependencies: [1, 2, 11, 12],
    required_by: [20, 21],
    notes: 'Methods use self for instance access. Static methods have no self parameter.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  METHODS FEATURE SPECIFICATION (#17)')
print('  Category: Language | Difficulty: 3 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

print('describe Instance methods:')
print('  it defines method with self:')

class Counter:
    value: Int

    fn increment():
        self.value = self.value + 1

    fn get():
        return self.value

val c = Counter { value: 0 }
c.increment()
if c.get() == 1:
    print('    [PASS] method with self')
    passed = passed + 1
else:
    print('    [FAIL] self method')
    failed = failed + 1

print('  it accesses fields via self:')

class Point:
    x: Int
    y: Int

    fn magnitude_squared():
        return self.x * self.x + self.y * self.y

val p = Point { x: 3, y: 4 }
if p.magnitude_squared() == 25:
    print('    [PASS] field access via self')
    passed = passed + 1
else:
    print('    [FAIL] field access')
    failed = failed + 1

print('  it mutates fields via self:')

class Accumulator:
    total: Int

    fn add(n):
        self.total = self.total + n

val acc = Accumulator { total: 0 }
acc.add(5)
acc.add(10)
if acc.total == 15:
    print('    [PASS] field mutation via self')
    passed = passed + 1
else:
    print('    [FAIL] field mutation')
    failed = failed + 1

print('')
print('describe Static methods:')
print('  it defines static method (no self):')

class Math:
    fn square(x):
        return x * x

    fn cube(x):
        return x * x * x

if Math.square(5) == 25:
    print('    [PASS] static method')
    passed = passed + 1
else:
    print('    [FAIL] static method')
    failed = failed + 1

print('  it uses static new pattern:')

class Person:
    name: String
    age: Int

    fn new(n, a):
        return Person { name: n, age: a }

val person = Person.new('Bob', 25)
if person.name == 'Bob' and person.age == 25:
    print('    [PASS] static new pattern')
    passed = passed + 1
else:
    print('    [FAIL] new pattern')
    failed = failed + 1

print('')
print('describe Method chaining:')
print('  it chains method calls:')

class Builder:
    value: Int

    fn new():
        return Builder { value: 0 }

    fn add(n):
        self.value = self.value + n
        return self

    fn multiply(n):
        self.value = self.value * n
        return self

    fn result():
        return self.value

val b = Builder.new()
b.add(5)
b.multiply(3)
if b.result() == 15:
    print('    [PASS] method chaining')
    passed = passed + 1
else:
    print('    [FAIL] chaining')
    failed = failed + 1

print('')
print('describe Method with parameters:')
print('  it passes multiple parameters:')

class Calculator:
    fn add(a, b, c):
        return a + b + c

if Calculator.add(1, 2, 3) == 6:
    print('    [PASS] multiple parameters')
    passed = passed + 1
else:
    print('    [FAIL] parameters')
    failed = failed + 1

print('  it uses instance and params:')

class Multiplier:
    factor: Int

    fn apply(x):
        return self.factor * x

val m = Multiplier { factor: 10 }
if m.apply(7) == 70:
    print('    [PASS] instance + params')
    passed = passed + 1
else:
    print('    [FAIL] instance + params')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Methods')
print('')
print('**Feature ID:** #17')
print('**Category:** Language')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
print('Passed: {passed}')
print('Failed: {failed}')
print('Total:  {passed + failed}')
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
