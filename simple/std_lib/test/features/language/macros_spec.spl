# Macros Feature Specification
# Feature #29: Compile-time metaprogramming with macros
# Category: Language | Difficulty: 4 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 29,
    name: 'Macros',
    category: 'Language',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/metaprogramming.md',
    files: [
        'src/compiler/src/interpreter_macro.rs',
        'src/parser/src/statements/mod.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_macros.rs',
        'src/driver/tests/interpreter_macro_hygiene.rs'
    ],
    description: 'Compile-time code generation with builtin and user-defined macros. Includes vec!, assert!, assert_eq!, format!, panic!, dbg! and custom macro definitions.',
    code_examples: [],
    dependencies: [1, 2, 12],
    required_by: [180, 181, 182],
    notes: 'User macros use emit blocks to specify output. Macro hygiene prevents name collisions.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  MACROS FEATURE SPECIFICATION (#29)')
print('  Category: Language | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Builtin Macros
# -----------------------------------------------------

print('describe Builtin macros:')
print('  context vec! macro:')
print('    it creates an array from elements:')

val arr = vec!(1, 2, 3, 4, 5)
if arr.len() == 5:
    print('      [PASS] vec! creates array')
    passed = passed + 1
else:
    print('      [FAIL] vec! creates array')
    failed = failed + 1

print('    it supports expressions:')

val a = 5
val expr_arr = vec!(a * 2, a + 3, a - 1)
if expr_arr[0] == 10 and expr_arr[1] == 8 and expr_arr[2] == 4:
    print('      [PASS] vec! with expressions')
    passed = passed + 1
else:
    print('      [FAIL] vec! with expressions')
    failed = failed + 1

print('    it computes sum:')

val sum_arr = vec!(10, 20, 30)
if sum_arr.sum() == 60:
    print('      [PASS] vec! sum works')
    passed = passed + 1
else:
    print('      [FAIL] vec! sum')
    failed = failed + 1

print('')
print('  context assert! macro:')
print('    it passes on true:')

val assert_passed = true
assert!(true)
assert!(1 == 1)
if assert_passed:
    print('      [PASS] assert! on true')
    passed = passed + 1
else:
    print('      [FAIL] assert! on true')
    failed = failed + 1

print('    it works with expressions:')

val x = 10
val y = 10
assert!(x == y)
print('      [PASS] assert! with expressions')
passed = passed + 1

print('')
print('  context assert_eq! macro:')
print('    it compares equal values:')

assert_eq!(5, 5)
assert_eq!("hello", "hello")
print('      [PASS] assert_eq! passes')
passed = passed + 1

print('    it works with variables:')

val v1 = 42
val v2 = 42
assert_eq!(v1, v2)
print('      [PASS] assert_eq! with variables')
passed = passed + 1

print('')
print('  context format! macro:')
print('    it concatenates strings:')

val s = format!("hello", " ", "world")
if s == "hello world":
    print('      [PASS] format! concatenates')
    passed = passed + 1
else:
    print('      [FAIL] format! concatenates')
    failed = failed + 1

print('    it returns correct length:')

if s.len() == 11:
    print('      [PASS] format! length')
    passed = passed + 1
else:
    print('      [FAIL] format! length')
    failed = failed + 1

print('')
print('  context dbg! macro:')
print('    it returns the value:')

val dbg_val = dbg!(42)
if dbg_val == 42:
    print('      [PASS] dbg! returns value')
    passed = passed + 1
else:
    print('      [FAIL] dbg! returns value')
    failed = failed + 1

print('    it works with expressions:')

val dbg_expr = dbg!(10 + 20)
if dbg_expr == 30:
    print('      [PASS] dbg! with expression')
    passed = passed + 1
else:
    print('      [FAIL] dbg! with expression')
    failed = failed + 1

# -----------------------------------------------------
# User-Defined Macros
# -----------------------------------------------------

print('')
print('describe User-defined macros:')
print('  context simple macro:')
print('    it returns a constant:')

macro answer() -> (returns result: Int):
    emit result:
        42

if answer!() == 42:
    print('      [PASS] simple macro returns constant')
    passed = passed + 1
else:
    print('      [FAIL] simple macro')
    failed = failed + 1

print('')
print('  context macro with parameter:')
print('    it uses parameter value:')

macro double(x: Int) -> (returns result: Int):
    emit result:
        x * 2

if double!(21) == 42:
    print('      [PASS] macro with parameter')
    passed = passed + 1
else:
    print('      [FAIL] macro with parameter')
    failed = failed + 1

print('')
print('  context macro with two parameters:')
print('    it combines parameters:')

macro add(a: Int, b: Int) -> (returns result: Int):
    emit result:
        a + b

if add!(30, 12) == 42:
    print('      [PASS] macro with two params')
    passed = passed + 1
else:
    print('      [FAIL] macro with two params')
    failed = failed + 1

print('')
print('  context macro with control flow:')
print('    it supports if expressions:')

macro max(a: Int, b: Int) -> (returns result: Int):
    emit result:
        if a > b:
            return a
        else:
            return b

if max!(10, 50) == 50:
    print('      [PASS] macro with control flow')
    passed = passed + 1
else:
    print('      [FAIL] macro with control flow')
    failed = failed + 1

print('    it handles reverse order:')

if max!(50, 10) == 50:
    print('      [PASS] macro reverse order')
    passed = passed + 1
else:
    print('      [FAIL] macro reverse order')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Macros')
print('')
print('**Feature ID:** #29')
print('**Category:** Language')
print('**Difficulty:** Level 4/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Builtin Macros')
print('')
print('| Macro | Purpose |')
print('|-------|---------|')
print('| `vec!(...)` | Create array from elements |')
print('| `assert!(cond)` | Assert condition is true |')
print('| `assert_eq!(a, b)` | Assert values are equal |')
print('| `format!(...)` | Concatenate to string |')
print('| `dbg!(expr)` | Debug print and return |')
print('| `panic!(msg)` | Abort with message |')
print('')
print('## User-Defined Macros')
print('')
print('```simple')
print('macro name(params) -> (returns result: Type):')
print('    emit result:')
print('        expression')
print('```')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
print('Passed: {passed}')
print('Failed: {failed}')
print('Total:  {passed + failed}')
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
