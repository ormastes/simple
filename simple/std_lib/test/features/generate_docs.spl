# Feature Documentation Generator
# Self-contained script that generates markdown documentation from feature specs

# =====================================================
# Feature Metadata and Registry (self-contained)
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

class FeatureRegistry:
    features: List

    fn new():
        return FeatureRegistry { features: [] }

    fn register(meta):
        self.features = self.features + [meta]

    fn get(id: i32):
        for item in self.features:
            if item.id == id:
                return Some(item)
        return None

    fn get_by_category(category: text):
        var result = []
        for item in self.features:
            if item.category == category:
                result = result + [item]
        return result

    fn get_all():
        return self.features

    fn get_categories():
        var cats = []
        for item in self.features:
            var found = false
            for cat in cats:
                if cat == item.category:
                    found = true
            if not found:
                cats = cats + [item.category]
        return cats

# Global registry
val registry = FeatureRegistry.new()

# =====================================================
# Documentation Generation Functions
# =====================================================

fn get_difficulty_label(level: i32) -> text:
    if level == 1:
        return "Trivial"
    if level == 2:
        return "Easy"
    if level == 3:
        return "Medium"
    if level == 4:
        return "Hard"
    if level == 5:
        return "Very Hard"
    return "Unknown"

fn get_status_icon(status: text) -> text:
    if status == "Complete":
        return "âœ…"
    if status == "Planned":
        return "ðŸ“‹"
    if status == "In Progress":
        return "ðŸ”„"
    return "â“"

fn to_lowercase(s: text) -> text:
    var result = s.replace("A", "a").replace("B", "b").replace("C", "c")
    result = result.replace("D", "d").replace("E", "e").replace("F", "f")
    result = result.replace("G", "g").replace("H", "h").replace("I", "i")
    result = result.replace("J", "j").replace("K", "k").replace("L", "l")
    result = result.replace("M", "m").replace("N", "n").replace("O", "o")
    result = result.replace("P", "p").replace("Q", "q").replace("R", "r")
    result = result.replace("S", "s").replace("T", "t").replace("U", "u")
    result = result.replace("V", "v").replace("W", "w").replace("X", "x")
    result = result.replace("Y", "y").replace("Z", "z")
    return result

fn format_feature_filename(id: i32, name: text) -> text:
    var padded = ""
    if id < 10:
        padded = "000{id}"
    elif id < 100:
        padded = "00{id}"
    elif id < 1000:
        padded = "0{id}"
    else:
        padded = "{id}"
    val safe_name = to_lowercase(name).replace(" ", "_")
    return "{padded}_{safe_name}.md"

fn generate_feature_doc(meta) -> text:
    var md = ""

    # Header
    md = md + "# Feature #{meta.id}: {meta.name}\n\n"

    # Overview table
    md = md + "## Overview\n\n"
    md = md + "| Property | Value |\n"
    md = md + "|----------|-------|\n"
    md = md + "| **Feature ID** | #{meta.id} |\n"
    md = md + "| **Feature Name** | {meta.name} |\n"
    md = md + "| **Category** | {meta.category} |\n"
    val diff_label = get_difficulty_label(meta.difficulty)
    md = md + "| **Difficulty** | {meta.difficulty} ({diff_label}) |\n"
    md = md + "| **Status** | {get_status_icon(meta.status)} {meta.status} |\n"
    md = md + "| **Implementation** | {meta.impl_type} |\n\n"

    # Description
    md = md + "## Description\n\n"
    md = md + meta.description + "\n\n"

    # Specification
    if meta.spec_ref != "":
        md = md + "## Specification\n\n"
        md = md + "[{meta.spec_ref}](../../{meta.spec_ref})\n\n"

    # Implementation files
    if meta.files.len() > 0:
        md = md + "## Implementation\n\n"
        md = md + "### Files\n\n"
        md = md + "| File | Purpose |\n"
        md = md + "|------|---------|\n"
        for file in meta.files:
            md = md + "| `{file}` | Implementation |\n"
        md = md + "\n"

    # Testing
    if meta.tests.len() > 0:
        md = md + "## Testing\n\n"
        md = md + "### Test Files\n\n"
        md = md + "| Test File | Description |\n"
        md = md + "|-----------|-------------|\n"
        for test in meta.tests:
            md = md + "| `{test}` | Test suite |\n"
        md = md + "\n"

    # Dependencies
    md = md + "## Dependencies\n\n"
    if meta.dependencies.len() > 0:
        md = md + "- Depends on: "
        var first = true
        for dep in meta.dependencies:
            if not first:
                md = md + ", "
            md = md + "#{dep}"
            first = false
        md = md + "\n"
    else:
        md = md + "- Depends on: None (foundational component)\n"

    if meta.required_by.len() > 0:
        md = md + "- Required by: "
        var first = true
        for req in meta.required_by:
            if not first:
                md = md + ", "
            md = md + "#{req}"
            first = false
        md = md + "\n"
    md = md + "\n"

    # Notes
    if meta.notes != "":
        md = md + "## Notes\n\n"
        md = md + meta.notes + "\n"

    return md

fn generate_category_index(category: text, features: List) -> text:
    if features.len() == 0:
        return ""

    # Find ID range
    var min_id = 9999
    var max_id = 0
    for meta in features:
        if meta.id < min_id:
            min_id = meta.id
        if meta.id > max_id:
            max_id = meta.id

    var md = ""
    val cat_lower = to_lowercase(category).replace(" ", "_")

    # Header
    md = md + "# {category} Features (#{min_id}-#{max_id})\n\n"

    # Description based on category
    if category == "Infrastructure":
        md = md + "Core compiler infrastructure components.\n\n"
    elif category == "Language":
        md = md + "Language features including functions, classes, and types.\n\n"
    elif category == "Data Structures":
        md = md + "Built-in data structures and collections.\n\n"
    elif category == "Control Flow":
        md = md + "Control flow constructs and pattern matching.\n\n"
    elif category == "Codegen":
        md = md + "Code generation and compilation backends.\n\n"
    elif category == "Types":
        md = md + "Type system and primitive types.\n\n"
    else:
        md = md + "Features in the {category} category.\n\n"

    # Features table
    md = md + "## Features\n\n"
    md = md + "| ID | Feature | Difficulty | Status | Impl |\n"
    md = md + "|----|---------|------------|--------|------|\n"

    for meta in features:
        val filename = format_feature_filename(meta.id, meta.name)
        val status_icon = get_status_icon(meta.status)
        md = md + "| #{meta.id} | [{meta.name}]({filename}) | {meta.difficulty} | {status_icon} | {meta.impl_type} |\n"

    md = md + "\n"

    # Summary
    var complete = 0
    for meta in features:
        if meta.status == "Complete":
            complete = complete + 1

    val total = features.len()
    md = md + "## Summary\n\n"
    md = md + "**Status:** {complete}/{total} Complete"
    if complete == total:
        md = md + " (100%)"
    md = md + "\n\n"

    # Test locations
    md = md + "## Test Locations\n\n"
    md = md + "- **Simple Tests:** `simple/std_lib/test/features/{cat_lower}/`\n"
    md = md + "- **Rust Tests:** See individual feature pages\n"

    return md

# =====================================================
# Register All Features (with BDD specs)
# =====================================================

# ----- INFRASTRUCTURE (9 features) -----

# Feature #1: Lexer
registry.register(FeatureMetadata {
    id: 1,
    name: "Lexer",
    category: "Infrastructure",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/lexer_parser.md",
    files: ["src/parser/src/lexer/mod.rs", "src/parser/src/token.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/lexer_spec.spl"],
    description: "Tokenizes Simple language source code into a stream of tokens. Handles indentation-based syntax with INDENT/DEDENT tokens, string literals, numbers, identifiers, operators, and keywords.",
    code_examples: [],
    dependencies: [],
    required_by: [2],
    notes: "First stage of compilation pipeline. Uses INDENT/DEDENT for Python-like significant whitespace."
})

# Feature #2: Parser
registry.register(FeatureMetadata {
    id: 2,
    name: "Parser",
    category: "Infrastructure",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/lexer_parser.md",
    files: ["src/parser/src/parser.rs", "src/parser/src/expressions/mod.rs", "src/parser/src/statements/mod.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/parser_spec.spl"],
    description: "Transforms token stream into Abstract Syntax Tree (AST). Uses recursive descent for statements and Pratt parsing for expressions with operator precedence.",
    code_examples: [],
    dependencies: [1],
    required_by: [3, 4],
    notes: "Pratt parser handles operator precedence elegantly. Recursive descent for control flow."
})

# Feature #3: AST
registry.register(FeatureMetadata {
    id: 3,
    name: "AST",
    category: "Infrastructure",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/lexer_parser.md",
    files: ["src/parser/src/ast.rs", "src/parser/src/expressions/mod.rs", "src/parser/src/statements/mod.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/ast_spec.spl"],
    description: "Abstract Syntax Tree for all Simple language constructs. Parses literals, expressions, statements, patterns, and type annotations into structured tree representation.",
    code_examples: [],
    dependencies: [1, 2],
    required_by: [4],
    notes: "AST nodes use spans for error reporting. Pratt parser for expressions with correct precedence."
})

# Feature #4: HIR
registry.register(FeatureMetadata {
    id: 4,
    name: "HIR",
    category: "Infrastructure",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/architecture/README.md",
    files: ["src/compiler/src/hir/mod.rs", "src/compiler/src/hir/types.rs", "src/compiler/src/hir/lower.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/hir_spec.spl"],
    description: "High-level IR for type checking and semantic analysis. Performs type inference, mutability checking, and capability verification after AST parsing.",
    code_examples: [],
    dependencies: [3],
    required_by: [5],
    notes: "HIR preserves source structure while adding type information. Validates semantic correctness before MIR lowering."
})

# Feature #5: MIR
registry.register(FeatureMetadata {
    id: 5,
    name: "MIR",
    category: "Infrastructure",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/codegen_technical.md",
    files: ["src/compiler/src/mir/mod.rs", "src/compiler/src/mir/instructions.rs", "src/compiler/src/mir/blocks.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/mir_spec.spl"],
    description: "Mid-level IR with 50+ instruction types. Represents code in basic blocks for optimization and codegen. Includes effect annotations for async/concurrent analysis.",
    code_examples: [],
    dependencies: [4],
    required_by: [100],
    notes: "MIR uses SSA form for optimization. Basic blocks enable control flow analysis and efficient codegen."
})

# Feature #6: RuntimeValue
registry.register(FeatureMetadata {
    id: 6,
    name: "RuntimeValue",
    category: "Infrastructure",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/architecture/README.md",
    files: ["src/runtime/src/value/core.rs", "src/runtime/src/value/tags.rs", "src/runtime/src/value/heap.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/runtime_value_spec.spl"],
    description: "Tagged pointervalue system with 64-bit representation. Supports inline integers, booleans, and heap pointers with efficient dispatch. 9 modules with 50+ FFI functions.",
    code_examples: [],
    dependencies: [],
    required_by: [7, 100],
    notes: "Uses NaN boxing for efficientvalue representation. Tag bits distinguishvalue types for fast dispatch."
})

# Feature #7: GC
registry.register(FeatureMetadata {
    id: 7,
    name: "GC",
    category: "Infrastructure",
    difficulty: 5,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/architecture/README.md",
    files: ["src/runtime/src/memory/gc.rs", "src/runtime/src/memory/gcless.rs", "src/runtime/src/memory/no_gc.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/gc_spec.spl"],
    description: "Abfall-backed garbage collection with optional logging. Supports GC-less mode for deterministic deallocation. Includes write barriers and safe point management.",
    code_examples: [],
    dependencies: [6],
    required_by: [],
    notes: "GC uses tri-color marking. Supports incremental collection and concurrent marking phases."
})

# Feature #8: Package Manager
registry.register(FeatureMetadata {
    id: 8,
    name: "Package Manager",
    category: "Infrastructure",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/architecture/README.md",
    files: ["src/pkg/src/manifest.rs", "src/pkg/src/lock.rs", "src/pkg/src/cache.rs", "src/pkg/src/resolver/graph.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/package_manager_spec.spl"],
    description: "UV-style package manager with simple.toml manifest, simple.lock lockfile, global cache with hard links, and topological dependency resolution.",
    code_examples: [],
    dependencies: [],
    required_by: [],
    notes: "Supports semantic versioning, workspace packages, and incremental updates. Cache uses hard links to save disk space."
})

# Feature #9: SMF
registry.register(FeatureMetadata {
    id: 9,
    name: "SMF",
    category: "Infrastructure",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/architecture/README.md",
    files: ["src/loader/src/smf/mod.rs", "src/loader/src/smf/header.rs", "src/compiler/src/linker/smf_writer.rs"],
    tests: ["simple/std_lib/test/features/infrastructure/smf_spec.spl"],
    description: "Simple Module Format binary container. Stores compiled code, symbols, relocations, and metadata. Supports memory-mapped loading for fast startup.",
    code_examples: [],
    dependencies: [5],
    required_by: [],
    notes: "SMF uses ELF-inspired section layout. Supports lazy symbol resolution and incremental linking."
})

# ----- TYPES (7 features) -----

# Feature #10: Basic Types
registry.register(FeatureMetadata {
    id: 10,
    name: "Basic Types",
    category: "Types",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/types.md",
    files: ["src/compiler/src/hir/types.rs", "src/runtime/src/value/core.rs"],
    tests: ["simple/std_lib/test/features/types/basic_types_spec.spl"],
    description: "Primitive types: i32 (i64), f32 (f64), bool, text, and Nil. Supports type annotations and inference.",
    code_examples: [],
    dependencies: [1, 2],
    required_by: [11, 12, 14],
    notes: "i32 is 64-bit signed. f32 is 64-bit IEEE 754. bool is true/false."
})

# Feature #16: Enums
registry.register(FeatureMetadata {
    id: 16,
    name: "Enums",
    category: "Types",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/parser/src/statements/mod.rs", "src/runtime/src/value/objects.rs"],
    tests: ["simple/std_lib/test/features/types/enums_spec.spl"],
    description: "Algebraic data types with variants. Supports tuple variants, struct variants, and pattern matching. Used for Result and Option types.",
    code_examples: [],
    dependencies: [10],
    required_by: [27],
    notes: "Enums use discriminant tags for variant identification. Supports exhaustive pattern matching."
})

# Feature #18: Memory Types
registry.register(FeatureMetadata {
    id: 18,
    name: "Memory Types",
    category: "Types",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/memory.md",
    files: ["src/compiler/src/hir/types.rs"],
    tests: ["simple/std_lib/test/features/types/memory_types_spec.spl"],
    description: "Reference capabilities for memory safety: T (read-only), mut T (mutable), iso T (isolated/unique). Enables safe concurrent programming.",
    code_examples: [],
    dependencies: [10],
    required_by: [19],
    notes: "Reference capabilities prevent data races at compile time. iso T enables safe transfer between actors."
})

# Feature #19: Borrowing
registry.register(FeatureMetadata {
    id: 19,
    name: "Borrowing",
    category: "Types",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/memory.md",
    files: ["src/compiler/src/hir/types.rs"],
    tests: ["simple/std_lib/test/features/types/borrowing_spec.spl"],
    description: "Ownership semantics with borrowing. Supports immutable borrows, mutable borrows, and borrow checking for memory safety without GC overhead.",
    code_examples: [],
    dependencies: [18],
    required_by: [],
    notes: "Borrow checker verified with Lean 4. Enables zero-cost memory safety."
})

# Feature #27: Option/Result
registry.register(FeatureMetadata {
    id: 27,
    name: "Option/Result",
    category: "Types",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/types.md",
    files: ["src/runtime/src/value/objects.rs"],
    tests: ["simple/std_lib/test/features/types/option_result_spec.spl"],
    description: "Optionalvalues (Some/None) and error handling (Ok/Err). Replaces null with type-safe alternatives. Supports ? operator for propagation.",
    code_examples: [],
    dependencies: [16],
    required_by: [35],
    notes: "Option and Result are generic enums. Pattern matching provides exhaustive handling."
})

# Feature #30: Operators
registry.register(FeatureMetadata {
    id: 30,
    name: "Operators",
    category: "Types",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/syntax.md",
    files: ["src/parser/src/expressions/mod.rs", "src/compiler/src/interpreter_expr.rs"],
    tests: ["simple/std_lib/test/features/types/operators_spec.spl"],
    description: "Arithmetic (+, -, *, /, %), comparison (==, !=, <, >, <=, >=), logical (and, or, not), and bitwise operators with proper precedence.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "Pratt parser handles precedence. Operators can be overloaded via traits."
})

# Feature #32: Generics
registry.register(FeatureMetadata {
    id: 32,
    name: "Generics",
    category: "Types",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/types.md",
    files: ["src/compiler/src/hir/types.rs", "src/type/src/lib.rs"],
    tests: ["simple/std_lib/test/features/types/generics_spec.spl"],
    description: "Generic type parameters for functions, structs, and traits. Supports type bounds, where clauses, and monomorphization.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "Uses Hindley-Milner type inference. Generics are erased at runtime (monomorphized)."
})

# ----- LANGUAGE (9 features) -----

# Feature #11: Classes
registry.register(FeatureMetadata {
    id: 11,
    name: "Classes",
    category: "Language",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/compiler/src/interpreter.rs", "src/compiler/src/interpreter_method.rs", "src/parser/src/statements/mod.rs"],
    tests: ["simple/std_lib/test/features/language/classes_spec.spl"],
    description: "Object-oriented programming with class definitions, typed fields, methods, static methods, and struct-literal instantiation. Supports single inheritance.",
    code_examples: [],
    dependencies: [1, 2, 12],
    required_by: [],
    notes: "Classes support struct-literal syntax for instantiation. Methods use self parameter for instance access."
})

# Feature #12: Functions
registry.register(FeatureMetadata {
    id: 12,
    name: "Functions",
    category: "Language",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: ["src/compiler/src/interpreter_call.rs", "src/parser/src/expressions/mod.rs"],
    tests: ["simple/std_lib/test/features/language/functions_spec.spl"],
    description: "First-class functions with lexical closure. Supports named functions, anonymous lambdas, default parameters, variadic arguments, and higher-order functions.",
    code_examples: [],
    dependencies: [1, 2],
    required_by: [11],
    notes: "Functions are first-classvalues. Closures capture lexical environment."
})

# Feature #14: Structs
registry.register(FeatureMetadata {
    id: 14,
    name: "Structs",
    category: "Language",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/parser/src/statements/mod.rs", "src/runtime/src/value/objects.rs"],
    tests: ["simple/std_lib/test/features/language/structs_spec.spl"],
    description: "Value types with named fields. Supports struct literals, field access, and destructuring. Structs arevalue types copied by default.",
    code_examples: [],
    dependencies: [10],
    required_by: [11],
    notes: "Structs are similar to Rust structs. Use impl blocks to add methods."
})

# Feature #15: Variables
registry.register(FeatureMetadata {
    id: 15,
    name: "Variables",
    category: "Language",
    difficulty: 1,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/syntax.md",
    files: ["src/parser/src/statements/mod.rs", "src/compiler/src/interpreter.rs"],
    tests: ["simple/std_lib/test/features/language/variables_spec.spl"],
    description: "Variable declarations with val (immutable), var (mutable), and const (compile-time constant). Type inference with optional annotations.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "Variables are immutable by default. Use 'var' for mutable bindings."
})

# Feature #17: Methods
registry.register(FeatureMetadata {
    id: 17,
    name: "Methods",
    category: "Language",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: ["src/compiler/src/interpreter_method.rs"],
    tests: ["simple/std_lib/test/features/language/methods_spec.spl"],
    description: "Methods on structs and classes via impl blocks. Supports self parameter, static methods, and method chaining.",
    code_examples: [],
    dependencies: [12, 14],
    required_by: [],
    notes: "Methods use self for instance access. Static methods omit self parameter."
})

# Feature #24: Closures
registry.register(FeatureMetadata {
    id: 24,
    name: "Closures",
    category: "Language",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: ["src/runtime/src/value/objects.rs", "src/compiler/src/interpreter.rs"],
    tests: ["simple/std_lib/test/features/language/closures_spec.spl"],
    description: "Lambda functions that capture their lexical environment. Supports move semantics and multiple capture modes.",
    code_examples: [],
    dependencies: [12],
    required_by: [],
    notes: "Closures capture variables from enclosing scope. Use |args| body syntax for lambdas."
})

# Feature #28: Imports
registry.register(FeatureMetadata {
    id: 28,
    name: "Imports",
    category: "Language",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/import_export_and__init__.md",
    files: ["src/compiler/src/module_resolver.rs", "src/parser/src/statements/mod.rs"],
    tests: ["simple/std_lib/test/features/language/imports_spec.spl"],
    description: "Module imports with import statements. Supports absolute/relative imports, aliasing, and selective imports from modules.",
    code_examples: [],
    dependencies: [],
    required_by: [],
    notes: "Modules use __init__.spl for package definitions. import std.io imports from standard library."
})

# Feature #29: Macros
registry.register(FeatureMetadata {
    id: 29,
    name: "Macros",
    category: "Language",
    difficulty: 5,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/metaprogramming.md",
    files: ["src/compiler/src/interpreter_macro.rs"],
    tests: ["simple/std_lib/test/features/language/macros_spec.spl"],
    description: "Compile-time metaprogramming with declarative and procedural macros. Supports pattern matching on AST and code generation.",
    code_examples: [],
    dependencies: [3],
    required_by: [],
    notes: "Macros expand at compile time. Use @decorator syntax for attribute macros."
})

# Feature #31: Traits
registry.register(FeatureMetadata {
    id: 31,
    name: "Traits",
    category: "Language",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/traits.md",
    files: ["src/parser/src/statements/mod.rs", "src/compiler/src/hir/types.rs"],
    tests: ["simple/std_lib/test/features/language/traits_spec.spl"],
    description: "Interface definitions with trait blocks. Supports default implementations, trait bounds, and trait objects for dynamic dispatch.",
    code_examples: [],
    dependencies: [12, 14],
    required_by: [],
    notes: "Traits enable polymorphism. impl Trait for Type provides implementations."
})

# ----- DATA STRUCTURES (6 features) -----

# Feature #20: Arrays
registry.register(FeatureMetadata {
    id: 20,
    name: "Arrays",
    category: "Data Structures",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/runtime/src/value/collections.rs"],
    tests: ["simple/std_lib/test/features/data_structures/arrays_spec.spl"],
    description: "Dynamic arrays (lists) with built-in methods: len, push, pop, map, filter, reduce, find, contains, sort, reverse, slice, and more.",
    code_examples: [],
    dependencies: [1, 2],
    required_by: [11, 12],
    notes: "Arrays are dynamically sized. Use concatenation (+) for adding elements."
})

# Feature #21: Dicts
registry.register(FeatureMetadata {
    id: 21,
    name: "Dicts",
    category: "Data Structures",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/runtime/src/value/collections.rs"],
    tests: ["simple/std_lib/test/features/data_structures/dicts_spec.spl"],
    description: "Hash map dictionaries with string keys. Supports literal syntax, key access, iteration, and methods like keys(),values(), items().",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "Dicts use hash tables for O(1) average lookup. Keys must be hashable."
})

# Feature #25: Strings
registry.register(FeatureMetadata {
    id: 25,
    name: "Strings",
    category: "Data Structures",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/runtime/src/value/collections.rs"],
    tests: ["simple/std_lib/test/features/data_structures/strings_spec.spl"],
    description: "UTF-8 string type with interpolation. Double-quoted strings support {expr} interpolation. Methods: len, split, join, contains, replace, trim.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "All double-quoted strings are interpolated by default. Use single quotes for raw strings."
})

# Feature #26: Tuples
registry.register(FeatureMetadata {
    id: 26,
    name: "Tuples",
    category: "Data Structures",
    difficulty: 1,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/runtime/src/value/collections.rs"],
    tests: ["simple/std_lib/test/features/data_structures/tuples_spec.spl"],
    description: "Fixed-size heterogeneous collections. Supports pattern matching, indexing, and destructuring. Immutable by design.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "Tuples arevalue types. Use (a, b, c) syntax. Access via index or destructuring."
})

# Feature #33: Sets
registry.register(FeatureMetadata {
    id: 33,
    name: "Sets",
    category: "Data Structures",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/runtime/src/value/collections.rs"],
    tests: ["simple/std_lib/test/features/data_structures/sets_spec.spl"],
    description: "Unordered collections of unique elements. Supports set operations: union, intersection, difference, symmetric_difference.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "Sets use hash tables. Elements must be hashable. Use {} syntax with set() constructor."
})

# Feature #34: Ranges
registry.register(FeatureMetadata {
    id: 34,
    name: "Ranges",
    category: "Data Structures",
    difficulty: 1,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: ["src/parser/src/expressions/mod.rs"],
    tests: ["simple/std_lib/test/features/data_structures/ranges_spec.spl"],
    description: "Range expressions for iteration: start..end (exclusive), start..=end (inclusive). Supports step and reverse ranges.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "Ranges are lazy iterators. Use in for loops or convert to arrays with .to_list()."
})

# ----- CONTROL FLOW (4 features) -----

# Feature #13: Loops
registry.register(FeatureMetadata {
    id: 13,
    name: "Loops",
    category: "Control Flow",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/syntax.md",
    files: ["src/compiler/src/interpreter_control.rs"],
    tests: ["simple/std_lib/test/features/control_flow/loops_spec.spl"],
    description: "For loops (for x in iter), while loops, loop (infinite), break, and continue. Supports labeled breaks for nested loops.",
    code_examples: [],
    dependencies: [2],
    required_by: [],
    notes: "For loops work with any iterable. While loops evaluate condition each iteration."
})

# Feature #35: Error Handling
registry.register(FeatureMetadata {
    id: 35,
    name: "Error Handling",
    category: "Control Flow",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/types.md",
    files: ["src/compiler/src/interpreter_control.rs"],
    tests: ["simple/std_lib/test/features/control_flow/error_handling_spec.spl"],
    description: "Result-based error handling with Ok/Err types. Supports ? operator for propagation, try blocks, and pattern matching on errors.",
    code_examples: [],
    dependencies: [27],
    required_by: [],
    notes: "No exceptions - use Result type. ? operator propagates errors up the call stack."
})

# Feature #90: Match Expressions
registry.register(FeatureMetadata {
    id: 90,
    name: "Match Expressions",
    category: "Control Flow",
    difficulty: 5,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: ["src/compiler/src/interpreter_control.rs", "src/parser/src/expressions/mod.rs"],
    tests: ["simple/std_lib/test/features/control_flow/match_spec.spl"],
    description: "Powerful pattern matching with exhaustiveness checking. Supports literal patterns, variable binding, wildcard (_), guards, and destructuring.",
    code_examples: [],
    dependencies: [2],
    required_by: [],
    notes: "Level 5 feature. Exhaustiveness checking ensures all cases are handled."
})

# Feature #91: Conditionals
registry.register(FeatureMetadata {
    id: 91,
    name: "Conditionals",
    category: "Control Flow",
    difficulty: 1,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/syntax.md",
    files: ["src/compiler/src/interpreter_control.rs"],
    tests: ["simple/std_lib/test/features/control_flow/conditionals_spec.spl"],
    description: "If/elif/else statements and expressions. Supports conditional expressions (ternary), if-val bindings, and short-circuit evaluation.",
    code_examples: [],
    dependencies: [10],
    required_by: [],
    notes: "If statements can be used as expressions returningvalues."
})

# ----- CONCURRENCY (4 features) -----

# Feature #40: Actors
registry.register(FeatureMetadata {
    id: 40,
    name: "Actors",
    category: "Concurrency",
    difficulty: 4,
    status: "Partial",
    impl_type: "Rust",
    spec_ref: "doc/spec/concurrency.md",
    files: ["src/runtime/src/value/actors.rs", "src/runtime/src/concurrency/mod.rs"],
    tests: ["simple/std_lib/test/features/concurrency/actors_spec.spl"],
    description: "Actor-based concurrency with spawn. Actors run in isolation with message passing. Default concurrency mode for Simple programs.",
    code_examples: [],
    dependencies: [12],
    required_by: [],
    notes: "Actor mode is the default. Rejects mut T in parameters for data race safety. Send/receive pending."
})

# Feature #41: Async/Await
registry.register(FeatureMetadata {
    id: 41,
    name: "Async/Await",
    category: "Concurrency",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/concurrency.md",
    files: ["src/compiler/src/mir/instructions.rs", "src/runtime/src/value/async_gen.rs"],
    tests: ["simple/std_lib/test/features/concurrency/async_await_spec.spl"],
    description: "Asynchronous function execution with async fn and await expressions. Enables non-blocking I/O and concurrent task execution.",
    code_examples: [],
    dependencies: [12, 43],
    required_by: [],
    notes: "Async functions return futures. await suspends execution until future completes."
})

# Feature #42: Generators
registry.register(FeatureMetadata {
    id: 42,
    name: "Generators",
    category: "Concurrency",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/concurrency.md",
    files: ["src/compiler/src/mir/generator.rs", "src/runtime/src/value/async_gen.rs"],
    tests: ["simple/std_lib/test/features/concurrency/generators_spec.spl"],
    description: "Yield-based lazy iteration with generator functions. Supports infinite sequences, state machines, and coroutine-style programming.",
    code_examples: [],
    dependencies: [12],
    required_by: [],
    notes: "Generators are state machines. yield suspends and producesvalues. MIR lowers to state machine."
})

# Feature #43: Futures
registry.register(FeatureMetadata {
    id: 43,
    name: "Futures",
    category: "Concurrency",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/concurrency.md",
    files: ["src/runtime/src/value/async_gen.rs"],
    tests: ["simple/std_lib/test/features/concurrency/futures_spec.spl"],
    description: "Promise-based asyncvalues representing eventual results. Supports combinators like map, and_then, race, and all.",
    code_examples: [],
    dependencies: [],
    required_by: [41],
    notes: "Futures are lazy - computation starts when awaited. Use spawn for eager execution."
})

# ----- CODEGEN (5 features) -----

# Feature #95: Buffer Pool
registry.register(FeatureMetadata {
    id: 95,
    name: "Buffer Pool",
    category: "Codegen",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/codegen_technical.md",
    files: ["src/compiler/src/codegen/mod.rs"],
    tests: ["simple/std_lib/test/features/codegen/buffer_pool_spec.spl"],
    description: "Code buffer pooling for efficient compilation. Reuses memory buffers across compilation units to reduce allocation overhead.",
    code_examples: [],
    dependencies: [],
    required_by: [100],
    notes: "Buffer pools reduce memory churn during JIT compilation. Thread-local pools for concurrent compilation."
})

# Feature #96: Generator Codegen
registry.register(FeatureMetadata {
    id: 96,
    name: "Generator Codegen",
    category: "Codegen",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/codegen_technical.md",
    files: ["src/compiler/src/mir/generator.rs", "src/compiler/src/codegen/cranelift.rs"],
    tests: ["simple/std_lib/test/features/codegen/generator_codegen_spec.spl"],
    description: "Generator state machine code generation. Transforms yield-based functions into resumable state machines with efficient dispatch.",
    code_examples: [],
    dependencies: [42, 5],
    required_by: [],
    notes: "Generators compile to switch-based state machines. State stored in closure environment."
})

# Feature #97: LLVM Backend
registry.register(FeatureMetadata {
    id: 97,
    name: "LLVM Backend",
    category: "Codegen",
    difficulty: 5,
    status: "Planned",
    impl_type: "Rust",
    spec_ref: "doc/codegen_technical.md",
    files: [],
    tests: ["simple/std_lib/test/features/codegen/llvm_backend_spec.spl"],
    description: "LLVM code generation backend for optimized native code. Enables advanced optimizations and multi-architecture support.",
    code_examples: [],
    dependencies: [5],
    required_by: [],
    notes: "LLVM provides production-quality optimizations. Alternative to Cranelift for release builds."
})

# Feature #100: Cranelift Backend
registry.register(FeatureMetadata {
    id: 100,
    name: "Cranelift Backend",
    category: "Codegen",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/codegen_technical.md",
    files: ["src/compiler/src/codegen/cranelift.rs", "src/compiler/src/codegen/jit.rs"],
    tests: ["simple/std_lib/test/features/codegen/cranelift_spec.spl"],
    description: "Cranelift-based code generation backend for AOT and JIT compilation. Provides fast compilation with good runtime performance.",
    code_examples: [],
    dependencies: [5, 6],
    required_by: [101],
    notes: "Primary backend for AOT compilation. JIT mode enables fast development iteration."
})

# Feature #101: Native Binary
registry.register(FeatureMetadata {
    id: 101,
    name: "Native Binary",
    category: "Codegen",
    difficulty: 4,
    status: "In Progress",
    impl_type: "Rust",
    spec_ref: "doc/research/binary_locality.md",
    files: ["src/compiler/src/linker/native.rs", "src/driver/src/cli/compile.rs"],
    tests: ["simple/std_lib/test/features/codegen/native_binary_spec.spl"],
    description: "Standalone native binary generation using mold/lld/ld linkers with 4KB page-aligned code layout for optimal startup performance.",
    code_examples: [],
    dependencies: [100, 5],
    required_by: [],
    notes: "Generates standalone executables without runtime dependency. Uses layout optimization for cache efficiency."
})

# ----- TESTING FRAMEWORK (7 features) -----

# Feature #180: Describe Blocks
registry.register(FeatureMetadata {
    id: 180,
    name: "Describe Blocks",
    category: "Testing Framework",
    difficulty: 2,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "doc/spec/testing/testing_bdd_framework.md",
    files: ["simple/std_lib/src/spec/dsl.spl", "simple/std_lib/src/spec/bdd.spl"],
    tests: ["simple/std_lib/test/features/testing_framework/describe_blocks_spec.spl"],
    description: "BDD describe blocks for grouping related test examples. Creates example groups with descriptions that organize tests hierarchically.",
    code_examples: [],
    dependencies: [],
    required_by: [181, 182],
    notes: "Top-level grouping construct. Supports nested context blocks. Registers with global test registry."
})

# Feature #181: Context Blocks
registry.register(FeatureMetadata {
    id: 181,
    name: "Context Blocks",
    category: "Testing Framework",
    difficulty: 2,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "doc/spec/testing/testing_bdd_framework.md",
    files: ["simple/std_lib/src/spec/dsl.spl"],
    tests: ["simple/std_lib/test/features/testing_framework/context_blocks_spec.spl"],
    description: "BDD context blocks for nested grouping within describe blocks. Provides conditional setup and scenario-based organization.",
    code_examples: [],
    dependencies: [180],
    required_by: [182],
    notes: "Context blocks nest within describe blocks. Use for 'when X' or 'with Y' scenarios."
})

# Feature #182: It Examples
registry.register(FeatureMetadata {
    id: 182,
    name: "It Examples",
    category: "Testing Framework",
    difficulty: 2,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "doc/spec/testing/testing_bdd_framework.md",
    files: ["simple/std_lib/src/spec/dsl.spl"],
    tests: ["simple/std_lib/test/features/testing_framework/it_examples_spec.spl"],
    description: "BDD it blocks for individual test examples. Each it block represents a single testable behavior with expectations.",
    code_examples: [],
    dependencies: [180, 181],
    required_by: [],
    notes: "it blocks contain the actual test code. Use descriptive names: 'it adds two numbers'."
})

# Feature #183: Before Each
registry.register(FeatureMetadata {
    id: 183,
    name: "Before Each",
    category: "Testing Framework",
    difficulty: 2,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "doc/spec/testing/testing_bdd_framework.md",
    files: ["simple/std_lib/src/spec/dsl.spl"],
    tests: ["simple/std_lib/test/features/testing_framework/before_each_spec.spl"],
    description: "BDD before_each hooks for test setup. Runs before each it block in the current context to initialize test state.",
    code_examples: [],
    dependencies: [180],
    required_by: [],
    notes: "before_each runs before every it block. Useful for creating test fixtures."
})

# Feature #184: After Each
registry.register(FeatureMetadata {
    id: 184,
    name: "After Each",
    category: "Testing Framework",
    difficulty: 2,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "doc/spec/testing/testing_bdd_framework.md",
    files: ["simple/std_lib/src/spec/dsl.spl"],
    tests: ["simple/std_lib/test/features/testing_framework/after_each_spec.spl"],
    description: "BDD after_each hooks for test teardown. Runs after each it block to clean up test state and resources.",
    code_examples: [],
    dependencies: [180],
    required_by: [],
    notes: "after_each runs after every it block. Useful for cleanup and resource release."
})

# Feature #187: Expect Matchers
registry.register(FeatureMetadata {
    id: 187,
    name: "Expect Matchers",
    category: "Testing Framework",
    difficulty: 3,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "doc/spec/testing/testing_bdd_framework.md",
    files: ["simple/std_lib/src/spec/expect.spl", "simple/std_lib/src/spec/matchers.spl"],
    tests: ["simple/std_lib/test/features/testing_framework/expect_matchers_spec.spl"],
    description: "BDD expect/to assertion matchers. Provides fluent assertions: expect(value).to eq(expected), be_truthy, contain, etc.",
    code_examples: [],
    dependencies: [180],
    required_by: [],
    notes: "Matchers provide readable assertions. Custom matchers can be defined. Negation with .not."
})

# Feature #192: Doctest
registry.register(FeatureMetadata {
    id: 192,
    name: "Doctest",
    category: "Testing Framework",
    difficulty: 3,
    status: "Complete",
    impl_type: "Simple",
    spec_ref: "doc/spec/testing/sdoctest.md",
    files: ["simple/std_lib/src/doctest/mod.spl"],
    tests: ["simple/std_lib/test/features/testing_framework/doctest_spec.spl"],
    description: "Documentation testing framework. Extracts and runs code examples from docstrings to ensure documentation stays accurate.",
    code_examples: [],
    dependencies: [],
    required_by: [],
    notes: "Doctest parses triple-quoted docstrings. Examples must include expected output."
})

# =====================================================
# Generate Documentation
# =====================================================

print("============================================================")
print("  FEATURE DOCUMENTATION GENERATOR")
print("============================================================")
print("")

val features = registry.get_all()
val categories = registry.get_categories()

print("Registered features: {features.len()}")
print("Categories: {categories.len()}")
for cat in categories:
    val cat_features = registry.get_by_category(cat)
    print("  {cat}: {cat_features.len()} features")

print("")
print("============================================================")
print("  GENERATING DOCUMENTATION")
print("============================================================")

for category in categories:
    val cat_lower = to_lowercase(category).replace(" ", "_")
    val cat_features = registry.get_by_category(category)

    print("")
    print("=== {category} ===")
    print("")

    # Generate category index
    val index_md = generate_category_index(category, cat_features)
    print("FILE: doc/features/{cat_lower}/__index__.md")
    print("----------------------------------------")
    print(index_md)

    # Generate individual feature docs
    for meta in cat_features:
        val filename = format_feature_filename(meta.id, meta.name)
        val content = generate_feature_doc(meta)
        print("")
        print("FILE: doc/features/{cat_lower}/{filename}")
        print("----------------------------------------")
        print(content)

print("")
print("============================================================")
print("  GENERATION COMPLETE")
print("============================================================")
