# Feature Documentation Generator
# Self-contained script that generates markdown documentation from feature specs

# =====================================================
# Feature Metadata and Registry (self-contained)
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

class FeatureRegistry:
    features: List

    fn new():
        return FeatureRegistry { features: [] }

    fn register(self, meta):
        self.features = self.features + [meta]

    fn get(self, id: Int):
        for item in self.features:
            if item.id == id:
                return Some(item)
        return None

    fn get_by_category(self, category: String):
        let mut result = []
        for item in self.features:
            if item.category == category:
                result = result + [item]
        return result

    fn get_all(self):
        return self.features

    fn get_categories(self):
        let mut cats = []
        for item in self.features:
            let mut found = false
            for cat in cats:
                if cat == item.category:
                    found = true
            if not found:
                cats = cats + [item.category]
        return cats

# Global registry
let registry = FeatureRegistry.new()

# =====================================================
# Documentation Generation Functions
# =====================================================

fn get_difficulty_label(level: Int) -> String:
    if level == 1:
        return "Trivial"
    if level == 2:
        return "Easy"
    if level == 3:
        return "Medium"
    if level == 4:
        return "Hard"
    if level == 5:
        return "Very Hard"
    return "Unknown"

fn get_status_icon(status: String) -> String:
    if status == "Complete":
        return "âœ…"
    if status == "Planned":
        return "ðŸ“‹"
    if status == "In Progress":
        return "ðŸ”„"
    return "â“"

fn to_lowercase(s: String) -> String:
    let mut result = s.replace("A", "a").replace("B", "b").replace("C", "c")
    result = result.replace("D", "d").replace("E", "e").replace("F", "f")
    result = result.replace("G", "g").replace("H", "h").replace("I", "i")
    result = result.replace("J", "j").replace("K", "k").replace("L", "l")
    result = result.replace("M", "m").replace("N", "n").replace("O", "o")
    result = result.replace("P", "p").replace("Q", "q").replace("R", "r")
    result = result.replace("S", "s").replace("T", "t").replace("U", "u")
    result = result.replace("V", "v").replace("W", "w").replace("X", "x")
    result = result.replace("Y", "y").replace("Z", "z")
    return result

fn format_feature_filename(id: Int, name: String) -> String:
    let mut padded = ""
    if id < 10:
        padded = "000{id}"
    elif id < 100:
        padded = "00{id}"
    elif id < 1000:
        padded = "0{id}"
    else:
        padded = "{id}"
    let safe_name = to_lowercase(name).replace(" ", "_")
    return "{padded}_{safe_name}.md"

fn generate_feature_doc(meta) -> String:
    let mut md = ""

    # Header
    md = md + "# Feature #{meta.id}: {meta.name}\n\n"

    # Overview table
    md = md + "## Overview\n\n"
    md = md + "| Property | Value |\n"
    md = md + "|----------|-------|\n"
    md = md + "| **Feature ID** | #{meta.id} |\n"
    md = md + "| **Feature Name** | {meta.name} |\n"
    md = md + "| **Category** | {meta.category} |\n"
    let diff_label = get_difficulty_label(meta.difficulty)
    md = md + "| **Difficulty** | {meta.difficulty} ({diff_label}) |\n"
    md = md + "| **Status** | {get_status_icon(meta.status)} {meta.status} |\n"
    md = md + "| **Implementation** | {meta.impl_type} |\n\n"

    # Description
    md = md + "## Description\n\n"
    md = md + meta.description + "\n\n"

    # Specification
    if meta.spec_ref != "":
        md = md + "## Specification\n\n"
        md = md + "[{meta.spec_ref}](../../{meta.spec_ref})\n\n"

    # Implementation files
    if meta.files.len() > 0:
        md = md + "## Implementation\n\n"
        md = md + "### Files\n\n"
        md = md + "| File | Purpose |\n"
        md = md + "|------|---------|\n"
        for file in meta.files:
            md = md + "| `{file}` | Implementation |\n"
        md = md + "\n"

    # Testing
    if meta.tests.len() > 0:
        md = md + "## Testing\n\n"
        md = md + "### Test Files\n\n"
        md = md + "| Test File | Description |\n"
        md = md + "|-----------|-------------|\n"
        for test in meta.tests:
            md = md + "| `{test}` | Test suite |\n"
        md = md + "\n"

    # Dependencies
    md = md + "## Dependencies\n\n"
    if meta.dependencies.len() > 0:
        md = md + "- Depends on: "
        let mut first = true
        for dep in meta.dependencies:
            if not first:
                md = md + ", "
            md = md + "#{dep}"
            first = false
        md = md + "\n"
    else:
        md = md + "- Depends on: None (foundational component)\n"

    if meta.required_by.len() > 0:
        md = md + "- Required by: "
        let mut first = true
        for req in meta.required_by:
            if not first:
                md = md + ", "
            md = md + "#{req}"
            first = false
        md = md + "\n"
    md = md + "\n"

    # Notes
    if meta.notes != "":
        md = md + "## Notes\n\n"
        md = md + meta.notes + "\n"

    return md

fn generate_category_index(category: String, features: List) -> String:
    if features.len() == 0:
        return ""

    # Find ID range
    let mut min_id = 9999
    let mut max_id = 0
    for meta in features:
        if meta.id < min_id:
            min_id = meta.id
        if meta.id > max_id:
            max_id = meta.id

    let mut md = ""
    let cat_lower = to_lowercase(category).replace(" ", "_")

    # Header
    md = md + "# {category} Features (#{min_id}-#{max_id})\n\n"

    # Description based on category
    if category == "Infrastructure":
        md = md + "Core compiler infrastructure components.\n\n"
    elif category == "Language":
        md = md + "Language features including functions, classes, and types.\n\n"
    elif category == "Data Structures":
        md = md + "Built-in data structures and collections.\n\n"
    elif category == "Control Flow":
        md = md + "Control flow constructs and pattern matching.\n\n"
    elif category == "Codegen":
        md = md + "Code generation and compilation backends.\n\n"
    elif category == "Types":
        md = md + "Type system and primitive types.\n\n"
    else:
        md = md + "Features in the {category} category.\n\n"

    # Features table
    md = md + "## Features\n\n"
    md = md + "| ID | Feature | Difficulty | Status | Impl |\n"
    md = md + "|----|---------|------------|--------|------|\n"

    for meta in features:
        let filename = format_feature_filename(meta.id, meta.name)
        let status_icon = get_status_icon(meta.status)
        md = md + "| #{meta.id} | [{meta.name}]({filename}) | {meta.difficulty} | {status_icon} | {meta.impl_type} |\n"

    md = md + "\n"

    # Summary
    let mut complete = 0
    for meta in features:
        if meta.status == "Complete":
            complete = complete + 1

    let total = features.len()
    md = md + "## Summary\n\n"
    md = md + "**Status:** {complete}/{total} Complete"
    if complete == total:
        md = md + " (100%)"
    md = md + "\n\n"

    # Test locations
    md = md + "## Test Locations\n\n"
    md = md + "- **Simple Tests:** `simple/std_lib/test/features/{cat_lower}/`\n"
    md = md + "- **Rust Tests:** See individual feature pages\n"

    return md

# =====================================================
# Register All Features (with BDD specs)
# =====================================================

# Feature #1: Lexer
registry.register(FeatureMetadata {
    id: 1,
    name: "Lexer",
    category: "Infrastructure",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/lexer_parser.md",
    files: [
        "src/parser/src/lexer/mod.rs",
        "src/parser/src/token.rs"
    ],
    tests: [
        "src/parser/tests/lexer_tests.rs"
    ],
    description: "Tokenizes Simple language source code into a stream of tokens. Handles indentation-based syntax with INDENT/DEDENT tokens, string literals, numbers, identifiers, operators, and keywords.",
    code_examples: [],
    dependencies: [],
    required_by: [2],
    notes: "First stage of compilation pipeline. Uses INDENT/DEDENT for Python-like significant whitespace."
})

# Feature #2: Parser
registry.register(FeatureMetadata {
    id: 2,
    name: "Parser",
    category: "Infrastructure",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/lexer_parser.md",
    files: [
        "src/parser/src/parser.rs",
        "src/parser/src/expressions/mod.rs",
        "src/parser/src/statements/mod.rs"
    ],
    tests: [
        "src/parser/tests/parser_tests.rs"
    ],
    description: "Transforms token stream into Abstract Syntax Tree (AST). Uses recursive descent for statements and Pratt parsing for expressions with operator precedence.",
    code_examples: [],
    dependencies: [1],
    required_by: [3, 4],
    notes: "Pratt parser handles operator precedence elegantly. Recursive descent for control flow."
})

# Feature #10: Basic Types
registry.register(FeatureMetadata {
    id: 10,
    name: "Basic Types",
    category: "Types",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/types.md",
    files: [
        "src/compiler/src/hir/types.rs",
        "src/runtime/src/value/core.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_types_tests.rs"
    ],
    description: "Primitive types: Int (i64), Float (f64), Bool, String, and Nil. Supports type annotations and inference.",
    code_examples: [],
    dependencies: [1, 2],
    required_by: [11, 12, 14],
    notes: "Int is 64-bit signed. Float is 64-bit IEEE 754. Bool is true/false."
})

# Feature #11: Classes
registry.register(FeatureMetadata {
    id: 11,
    name: "Classes",
    category: "Language",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: [
        "src/compiler/src/interpreter.rs",
        "src/compiler/src/interpreter_method.rs",
        "src/parser/src/statements/mod.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_oop_tests.rs"
    ],
    description: "Object-oriented programming with class definitions, typed fields, methods, static methods, and struct-literal instantiation. Supports single inheritance.",
    code_examples: [],
    dependencies: [1, 2, 12],
    required_by: [],
    notes: "Classes support struct-literal syntax for instantiation. Methods use self parameter for instance access."
})

# Feature #12: Functions
registry.register(FeatureMetadata {
    id: 12,
    name: "Functions",
    category: "Language",
    difficulty: 3,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: [
        "src/compiler/src/interpreter_call.rs",
        "src/parser/src/expressions/mod.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_basic_tests.rs"
    ],
    description: "First-class functions with lexical closure. Supports named functions, anonymous lambdas, default parameters, variadic arguments, and higher-order functions like map/filter/reduce.",
    code_examples: [],
    dependencies: [1, 2],
    required_by: [11],
    notes: "Functions are first-class values. Closures capture lexical environment."
})

# Feature #20: Arrays
registry.register(FeatureMetadata {
    id: 20,
    name: "Arrays",
    category: "Data Structures",
    difficulty: 2,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/data_structures.md",
    files: [
        "src/runtime/src/value/collections.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_collections_tests.rs"
    ],
    description: "Dynamic arrays (lists) with built-in methods: len, push, pop, map, filter, reduce, find, contains, sort, reverse, slice, and more.",
    code_examples: [],
    dependencies: [1, 2],
    required_by: [11, 12],
    notes: "Arrays are dynamically sized. Use concatenation (+) for adding elements."
})

# Feature #90: Match Expressions
registry.register(FeatureMetadata {
    id: 90,
    name: "Match Expressions",
    category: "Control Flow",
    difficulty: 5,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: [
        "src/compiler/src/interpreter_control.rs",
        "src/parser/src/expressions/mod.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_control.rs"
    ],
    description: "Powerful pattern matching with exhaustiveness checking. Supports literal patterns, variable binding, wildcard (_), guards, and destructuring.",
    code_examples: [],
    dependencies: [2],
    required_by: [],
    notes: "Level 5 feature. Exhaustiveness checking ensures all cases are handled."
})

# Feature #100: Cranelift Backend
registry.register(FeatureMetadata {
    id: 100,
    name: "Cranelift Backend",
    category: "Codegen",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/codegen_technical.md",
    files: [
        "src/compiler/src/codegen/cranelift.rs",
        "src/compiler/src/codegen/jit.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_jit_tests.rs"
    ],
    description: "Cranelift-based code generation backend for AOT and JIT compilation. Provides fast compilation with good runtime performance.",
    code_examples: [],
    dependencies: [2, 5],
    required_by: [],
    notes: "Primary backend for AOT compilation. JIT mode enables fast development iteration."
})

# =====================================================
# Generate Documentation
# =====================================================

print("============================================================")
print("  FEATURE DOCUMENTATION GENERATOR")
print("============================================================")
print("")

let features = registry.get_all()
let categories = registry.get_categories()

print("Registered features: {features.len()}")
print("Categories: {categories.len()}")
for cat in categories:
    let cat_features = registry.get_by_category(cat)
    print("  {cat}: {cat_features.len()} features")

print("")
print("============================================================")
print("  GENERATING DOCUMENTATION")
print("============================================================")

for category in categories:
    let cat_lower = to_lowercase(category).replace(" ", "_")
    let cat_features = registry.get_by_category(category)

    print("")
    print("=== {category} ===")
    print("")

    # Generate category index
    let index_md = generate_category_index(category, cat_features)
    print("FILE: doc/features/{cat_lower}/__index__.md")
    print("----------------------------------------")
    print(index_md)

    # Generate individual feature docs
    for meta in cat_features:
        let filename = format_feature_filename(meta.id, meta.name)
        let content = generate_feature_doc(meta)
        print("")
        print("FILE: doc/features/{cat_lower}/{filename}")
        print("----------------------------------------")
        print(content)

print("")
print("============================================================")
print("  GENERATION COMPLETE")
print("============================================================")
