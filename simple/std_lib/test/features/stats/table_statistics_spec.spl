"""
# SDN Table, TQL, and Custom Blocks Specification

**Feature IDs:** TBD
**Category:** Stdlib
**Difficulty:** 4/5
**Status:** Draft

## Overview

This specification defines:
- Unified block syntax (`{}` and `:` styles)
- Collection statistics (mean, std, var, etc.)
- DataFrame type with columnar storage
- TQL (Table Query Language) for declarative queries
- Custom blocks (math, regex, html, css, json)

## Unified Block Syntax

Both styles produce identical AST:

```simple
# Indentation style
val result = tql:
    from users
    select @id, @age

# Brace style
val result = tql {
    from users
    select @id, @age
}
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| `Table<Schema>` | Typed table with compile-time schema validation |
| `Column<T>` | Typed column vector, vectorized operations |
| `tql` / `tql:` / `tql {}` | Query block (standalone or method chain) |
| `@column` | Column reference prefix |
| `math` / `regex` / etc. | Other custom block types |

See `doc/spec/dataframe.md` for full specification.
"""

import std.spec


# ============================================================================
# Test Group 1: Unified Block Syntax
# ============================================================================

describe "Unified Block Syntax":
    """
    ## Block Style Equivalence

    Both `{}` and `:` block styles must produce identical behavior.
    """

    context "when using tql blocks":
        """
        ### Scenario: TQL Block Styles

        Both brace and indent styles should work identically.
        """

        it "parses indent-style tql block":
            val users = table |id, name, age|:
                1, "Alice", 30
                2, "Bob", 25

            val result = tql:
                from users
                select @id, @name

            expect(result.column_count()).to(eq(2))

        it "parses brace-style tql block":
            val users = table |id, name, age| {
                1, "Alice", 30
                2, "Bob", 25
            }

            val result = tql {
                from users
                select @id, @name
            }

            expect(result.column_count()).to(eq(2))

        it "produces identical results from both styles":
            val users = table |id, age|:
                1, 30
                2, 25
                3, 35

            val result_indent = tql:
                from users
                where @age >= 30

            val result_brace = tql {
                from users
                where @age >= 30
            }

            expect(result_indent.len()).to(eq(result_brace.len()))
            expect(result_indent.len()).to(eq(2))

    context "when using method chain style":
        """
        ### Scenario: Method Chain TQL

        Tables can use `.tql` method with either block style.
        """

        it "supports method chain with indent style":
            val users = table |id, age|:
                1, 30
                2, 25

            val result = users.tql:
                where @age >= 30
                select @id

            expect(result.len()).to(eq(1))

        it "supports method chain with brace style":
            val users = table |id, age| {
                1, 30
                2, 25
            }

            val result = users.tql {
                where @age >= 30
                select @id
            }

            expect(result.len()).to(eq(1))

    context "when nesting blocks":
        """
        ### Scenario: Mixed Block Styles

        Nested blocks can use different styles.
        """

        it "allows indent inside braces":
            val users = table |id, city, age|:
                1, "Seoul", 30
                2, "Seoul", 25
                3, "Busan", 35

            val result = tql {
                from users
                groupby @city
                agg:
                    count: count()
                    avg: mean(@age)
            }

            expect(result.len()).to(eq(2))

        it "allows braces inside indent":
            val users = table |id, city, age|:
                1, "Seoul", 30
                2, "Seoul", 25
                3, "Busan", 35

            val result = tql:
                from users
                groupby @city
                agg {
                    count: count()
                    avg: mean(@age)
                }

            expect(result.len()).to(eq(2))


# ============================================================================
# Test Group 2: Collection Statistics
# ============================================================================

describe "Collection Statistics":
    """
    ## Basic Statistics on Arrays

    Arrays and vectors support statistical operations.
    """

    context "when computing descriptive statistics":
        it "computes mean - indent style setup":
            val data = [1, 2, 3, 4, 5]
            expect(data.mean()).to(eq(3.0))

        it "computes standard deviation":
            val data = [2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0]
            expect(data.std()).to(be_close_to(2.0, 0.001))

        it "computes variance":
            val data = [2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0]
            expect(data.variance()).to(be_close_to(4.0, 0.001))

        it "computes min and max":
            val data = [3, 1, 4, 1, 5, 9, 2, 6]
            expect(data.min()).to(eq(1))
            expect(data.max()).to(eq(9))

    context "when computing order statistics":
        it "computes median of odd-length array":
            val data = [3, 1, 4, 1, 5]
            expect(data.median()).to(eq(3.0))

        it "computes median of even-length array":
            val data = [1, 2, 3, 4]
            expect(data.median()).to(eq(2.5))

        it "computes quantiles":
            val data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
            expect(data.quantile(0.25)).to(be_close_to(3.25, 0.01))
            expect(data.quantile(0.75)).to(be_close_to(7.75, 0.01))


# ============================================================================
# Test Group 3: Table Construction
# ============================================================================

describe "Table Construction":
    """
    ## Table Literal Syntax

    Tables can be created with row or column orientation.
    """

    context "when using row-oriented syntax":
        it "creates table with indent style":
            val users = table |id, name, age|:
                1, "Alice", 30
                2, "Bob", 25
                3, "Carol", 28

            expect(users.len()).to(eq(3))
            expect(users.column_count()).to(eq(3))

        it "creates table with brace style":
            val users = table |id, name, age| {
                1, "Alice", 30
                2, "Bob", 25
                3, "Carol", 28
            }

            expect(users.len()).to(eq(3))

    context "when using column-oriented syntax":
        it "creates dataframe with indent style":
            val df = dataframe:
                id:   [1, 2, 3]
                name: ["Alice", "Bob", "Carol"]
                age:  [30, 25, 28]

            expect(df.len()).to(eq(3))
            expect(df.column_count()).to(eq(3))

        it "creates dataframe with brace style":
            val df = dataframe {
                id:   [1, 2, 3]
                name: ["Alice", "Bob", "Carol"]
                age:  [30, 25, 28]
            }

            expect(df.len()).to(eq(3))


# ============================================================================
# Test Group 4: TQL Queries
# ============================================================================

describe "TQL Queries":
    """
    ## Table Query Language

    Declarative queries with select, where, groupby, orderby, limit.
    """

    before_each:
        @users = table |id, name, age, city|:
            1, "Alice", 31, "Seoul"
            2, "Bob", 24, "Busan"
            3, "Carol", 28, "Seoul"
            4, "Dave", 35, "Seoul"
            5, "Eve", 22, "Busan"

    context "when using select and where":
        it "filters and projects - indent style":
            val result = tql:
                from @users
                where @age >= 25
                select @name, @age

            expect(result.len()).to(eq(3))
            expect(result.column_count()).to(eq(2))

        it "filters and projects - brace style":
            val result = tql {
                from @users
                where @age >= 25
                select @name, @age
            }

            expect(result.len()).to(eq(3))

        it "uses outer variables in predicates":
            val min_age = 30
            val result = tql {
                from @users
                where @age >= min_age
            }

            expect(result.len()).to(eq(2))

    context "when using orderby and limit":
        it "orders and limits - indent style":
            val result = tql:
                from @users
                orderby @age desc
                limit 3

            val ages = result.get_column("age").to_array()
            expect(ages).to(eq([35, 31, 28]))

        it "orders and limits - brace style":
            val result = tql {
                from @users
                orderby @age
                limit 2
            }

            val ages = result.get_column("age").to_array()
            expect(ages).to(eq([22, 24]))

    context "when using groupby and aggregations":
        it "groups and aggregates - indent style":
            val result = tql:
                from @users
                groupby @city
                agg:
                    n: count()
                    avg_age: mean(@age)

            expect(result.len()).to(eq(2))

        it "groups and aggregates - brace style":
            val result = tql {
                from @users
                groupby @city
                agg {
                    n: count()
                    avg_age: mean(@age)
                }
            }

            expect(result.len()).to(eq(2))

        it "computes multiple statistics per group":
            val result = tql {
                from @users
                groupby @city
                agg {
                    n: count()
                    total_age: sum(@age)
                    avg_age: mean(@age)
                    min_age: min(@age)
                    max_age: max(@age)
                    std_age: std(@age)
                }
            }

            val seoul = result.filter(@city == "Seoul").first()
            expect(seoul.get("n")).to(eq(3))
            expect(seoul.get("avg_age")).to(be_close_to(31.33, 0.01))


# ============================================================================
# Test Group 5: Math Block
# ============================================================================

describe "Math Block":
    """
    ## Symbolic Math Expressions

    Compile-time math with symbolic computation.
    """

    context "when defining functions":
        it "defines and evaluates functions - brace style":
            val f = math {
                f(x) = x^2 + 2*x + 1
            }

            expect(f.eval(2)).to(eq(9.0))  # 4 + 4 + 1

        it "defines and evaluates functions - indent style":
            val g = math:
                g(x) = sin(x) + cos(x)

            expect(g.eval(0)).to(be_close_to(1.0, 0.001))  # sin(0) + cos(0) = 0 + 1

    context "when computing derivatives":
        it "computes symbolic derivative":
            val result = math {
                d/dx (x^3 + 2*x^2 + x)
            }

            # Result: 3*x^2 + 4*x + 1
            expect(result.eval(1)).to(eq(8.0))  # 3 + 4 + 1

        it "computes derivative - indent style":
            val result = math:
                d/dx (sin(x))

            # Result: cos(x)
            expect(result.eval(0)).to(eq(1.0))  # cos(0) = 1

    context "when performing matrix operations":
        it "multiplies matrices - brace style":
            val result = math {
                A = [[1, 2], [3, 4]]
                B = [[5, 6], [7, 8]]
                C = A * B
            }

            # [[1*5+2*7, 1*6+2*8], [3*5+4*7, 3*6+4*8]]
            # [[19, 22], [43, 50]]
            expect(result.get("C")[0][0]).to(eq(19))
            expect(result.get("C")[1][1]).to(eq(50))

        it "computes matrix transpose":
            val result = math {
                A = [[1, 2, 3], [4, 5, 6]]
                B = transpose(A)
            }

            expect(result.get("B").rows()).to(eq(3))
            expect(result.get("B").cols()).to(eq(2))

    context "when using inline expressions":
        it "evaluates inline math":
            val r = 5.0
            val area = math { pi * r^2 }

            expect(area).to(be_close_to(78.54, 0.01))


# ============================================================================
# Test Group 6: Regex Block
# ============================================================================

describe "Regex Block":
    """
    ## Compile-Time Regex Patterns

    Type-safe regex with named captures.
    """

    context "when defining patterns":
        it "creates pattern - brace style":
            val pattern = regex {
                ^\d{3}-\d{4}$
            }

            expect(pattern.test("123-4567")).to(be_true())
            expect(pattern.test("12-4567")).to(be_false())

        it "creates pattern - indent style":
            val pattern = regex:
                ^[a-z]+$

            expect(pattern.test("hello")).to(be_true())
            expect(pattern.test("Hello")).to(be_false())

    context "when using named captures":
        it "extracts named groups":
            val email_pattern = regex {
                ^(?<user>[a-zA-Z0-9._%+-]+)@(?<domain>[a-zA-Z0-9.-]+)\.(?<tld>[a-zA-Z]{2,})$
            }

            val matches = email_pattern.match("alice@example.com")

            expect(matches.get("user")).to(eq("alice"))
            expect(matches.get("domain")).to(eq("example"))
            expect(matches.get("tld")).to(eq("com"))

    context "when using inline patterns":
        it "tests inline regex":
            val phone = "555-1234"
            val is_valid = regex { ^\d{3}-\d{4}$ }.test(phone)

            expect(is_valid).to(be_true())


# ============================================================================
# Test Group 7: JSON Block
# ============================================================================

describe "JSON Block":
    """
    ## Type-Safe JSON Construction

    Compile-time JSON with schema validation.
    """

    context "when creating JSON objects":
        it "creates JSON - brace style":
            val config = json {
                "name": "my-app",
                "version": "1.0.0",
                "debug": true
            }

            expect(config.get("name")).to(eq("my-app"))
            expect(config.get("debug")).to(eq(true))

        it "creates nested JSON":
            val data = json {
                "user": {
                    "id": 123,
                    "name": "Alice"
                },
                "settings": {
                    "theme": "dark"
                }
            }

            expect(data.get("user").get("name")).to(eq("Alice"))

    context "when using schema validation":
        it "validates against schema":
            struct UserSchema:
                id: Int
                name: Str
                email: Str

            val user = json<UserSchema> {
                "id": 123,
                "name": "Alice",
                "email": "alice@example.com"
            }

            expect(user.id).to(eq(123))
            expect(user.name).to(eq("Alice"))


# ============================================================================
# Test Group 8: HTML Block
# ============================================================================

describe "HTML Block":
    """
    ## Type-Safe HTML Generation

    Compile-time validated HTML.
    """

    context "when creating HTML elements":
        it "creates HTML - brace style":
            val div = html {
                div class="container" {
                    h1 { "Hello World" }
                    p { "Welcome!" }
                }
            }

            expect(div.to_string()).to(contain("<div class=\"container\">"))
            expect(div.to_string()).to(contain("<h1>Hello World</h1>"))

        it "creates HTML - indent style":
            val card = html:
                div class="card":
                    h2: "Title"
                    p: "Description"

            expect(card.to_string()).to(contain("<div class=\"card\">"))

    context "when using dynamic content":
        it "interpolates variables":
            val username = "Alice"
            val greeting = html {
                h1 { "Hello, " + username + "!" }
            }

            expect(greeting.to_string()).to(contain("Hello, Alice!"))

        it "renders loops":
            val items = ["Apple", "Banana", "Cherry"]
            val list = html {
                ul {
                    for item in items {
                        li { item }
                    }
                }
            }

            expect(list.to_string()).to(contain("<li>Apple</li>"))
            expect(list.to_string()).to(contain("<li>Cherry</li>"))


# ============================================================================
# Test Group 9: Advanced TQL Statistics
# ============================================================================

describe "TQL Advanced Statistics":
    """
    ## Statistical Functions in TQL

    Advanced analytics within query blocks.
    """

    before_each:
        @data = table |x, y|:
            1.0, 2.0
            2.0, 4.0
            3.0, 5.0
            4.0, 4.0
            5.0, 5.0

    context "when computing correlation":
        it "computes covariance and correlation":
            val result = tql {
                from @data
                agg {
                    cov_xy: cov(@x, @y)
                    corr_xy: corr(@x, @y)
                }
            }

            expect(result.get("cov_xy")).to(be_close_to(1.5, 0.01))
            expect(result.get("corr_xy")).to(be_close_to(0.775, 0.01))

    context "when computing regression":
        it "performs linear regression":
            val result = tql {
                from @data
                agg {
                    reg: regress(@y, @x)
                }
            }

            expect(result.get("reg").slope).to(be_close_to(0.6, 0.01))
            expect(result.get("reg").intercept).to(be_close_to(2.2, 0.01))

    context "when detecting trends":
        it "computes linear trend":
            val linear = table |t, value|:
                1, 10
                2, 20
                3, 30
                4, 40

            val result = linear.tql {
                agg {
                    slope: trend(@value)
                }
            }

            expect(result.get("slope")).to(eq(10.0))


# ============================================================================
# Helper Functions
# ============================================================================

fn be_close_to(expected: f64, tolerance: f64) -> Matcher<f64>:
    Matcher.new(fn(actual):
        (actual - expected).abs() <= tolerance
    )

fn contain(substring: Str) -> Matcher<Str>:
    Matcher.new(fn(actual):
        actual.contains(substring)
    )

struct Regression:
    slope: f64
    intercept: f64
    r_squared: f64
