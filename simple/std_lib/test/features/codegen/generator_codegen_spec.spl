# Generator Codegen Feature Specification
# Feature #96: Generator state machine code generation
# Category: Codegen | Difficulty: 4 | Status: Complete

"""
# Generator Codegen

**Feature ID:** #96
**Category:** Codegen
**Difficulty:** Level 4/5
**Status:** Complete
**Implementation:** Rust

## Overview

Generator state machine code generation. Transforms generator functions with yield
statements into resumable state machines with dispatcher entry blocks.

## Syntax

```simple
val gen = generator(\: yield 42)
val value = next(gen)  # Returns 42

val multi = generator(\: [yield 1, yield 2, yield 3])
val collected = collect(multi)  # [1, 2, 3]
```

## Implementation

**Files:**
- src/compiler/src/mir/generator.rs - Generator state machine lowering
- src/compiler/src/mir/state_machine_utils.rs - State machine utilities
- src/compiler/src/codegen/instr_async.rs - Async instruction codegen

**Tests:**
- src/driver/tests/runner_async_tests.rs

**Dependencies:** Features #5, #42
**Required By:** None

## Notes

Generators are lowered to state machines with dispatcher + resume blocks. Liveness
analysis preserves values across suspension points.
"""

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 96,
    name: 'Generator Codegen',
    category: 'Codegen',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'src/compiler/src/mir/generator.rs',
    files: [
        'src/compiler/src/mir/generator.rs',
        'src/compiler/src/mir/state_machine_utils.rs',
        'src/compiler/src/codegen/instr_async.rs'
    ],
    tests: [
        'src/driver/tests/runner_async_tests.rs'
    ],
    description: 'Generator state machine code generation. Transforms generator functions with yield statements into resumable state machines with dispatcher entry blocks.',
    code_examples: [],
    dependencies: [5, 42],
    required_by: [],
    notes: 'Generators are lowered to state machines with dispatcher + resume blocks. Liveness analysis preservesvalues across suspension points.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  GENERATOR CODEGEN FEATURE SPECIFICATION (#96)')
print('  Category: Codegen | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Basic Generator State Machine
# -----------------------------------------------------

print('describe Generator state machine:')
print('  context single yield:')
print('    it generates dispatcher for single yield:')

val gen1 = generator(\: yield 42)
val val1 = next(gen1)
if val1 == 42:
    print('      [PASS] single yield state machine')
    passed = passed + 1
else:
    print('      [FAIL] single yield state machine')
    failed = failed + 1

print('    it returns nil after exhaustion:')

val gen_exhaust = generator(\: yield 100)
val first = next(gen_exhaust)
val second = next(gen_exhaust)
if first == 100 and second == nil:
    print('      [PASS] exhaustion returns nil')
    passed = passed + 1
else:
    print('      [FAIL] exhaustion returns nil')
    failed = failed + 1

# -----------------------------------------------------
# Multiple Yield Points
# -----------------------------------------------------

print('')
print('  context multiple yields:')
print('    it handles sequential yields:')

val gen_seq = generator(\: [yield 1, yield 2, yield 3])
val v1 = next(gen_seq)
val v2 = next(gen_seq)
val v3 = next(gen_seq)
if v1 == 1 and v2 == 2 and v3 == 3:
    print('      [PASS] sequential yields')
    passed = passed + 1
else:
    print('      [FAIL] sequential yields')
    failed = failed + 1

print('    it creates correct state transitions:')

val gen_states = generator(\: [yield 10, yield 20, yield 30, yield 40])
val sum_states = next(gen_states) + next(gen_states) + next(gen_states) + next(gen_states)
if sum_states == 100:
    print('      [PASS] state transitions')
    passed = passed + 1
else:
    print('      [FAIL] state transitions')
    failed = failed + 1

# -----------------------------------------------------
# Value Preservation Across Yields
# -----------------------------------------------------

print('')
print('describe Value preservation:')
print('  context computedvalue preservation:')
print('    it preserves computedvalues:')

val gen_preserve = generator(\: [yield 10, yield 20, yield 30])
val p1 = next(gen_preserve)
val p2 = next(gen_preserve)
val p3 = next(gen_preserve)
if p1 == 10 and p2 == 20 and p3 == 30:
    print('      [PASS]value preservation')
    passed = passed + 1
else:
    print('      [FAIL]value preservation')
    failed = failed + 1

print('    it preserves incrementalvalues:')

val gen_incr = generator(\: [yield 1, yield 2, yield 3])
val m1 = next(gen_incr)
val m2 = next(gen_incr)
val m3 = next(gen_incr)
if m1 == 1 and m2 == 2 and m3 == 3:
    print('      [PASS] incrementalvalues')
    passed = passed + 1
else:
    print('      [FAIL] incrementalvalues')
    failed = failed + 1

# -----------------------------------------------------
# Control Flow in Generators
# -----------------------------------------------------

print('')
print('describe Control flow lowering:')
print('  context sequential yields:')
print('    it handles sequential control:')

val gen_seq2 = generator(\: [yield 5, yield 10, yield 15])
val seq_sum = next(gen_seq2) + next(gen_seq2) + next(gen_seq2)
if seq_sum == 30:
    print('      [PASS] sequential control')
    passed = passed + 1
else:
    print('      [FAIL] sequential control')
    failed = failed + 1

print('')
print('  context alternating yields:')
print('    it handles alternating patterns:')

val gen_alt = generator(\: [yield 1, yield 10, yield 2, yield 20])
val a1 = next(gen_alt)
val a2 = next(gen_alt)
val a3 = next(gen_alt)
val a4 = next(gen_alt)
if a1 == 1 and a2 == 10 and a3 == 2 and a4 == 20:
    print('      [PASS] alternating patterns')
    passed = passed + 1
else:
    print('      [FAIL] alternating patterns')
    failed = failed + 1

# -----------------------------------------------------
# Generator with External State
# -----------------------------------------------------

print('')
print('describe External state capture:')
print('  context captured variables:')
print('    it captures externalvalues:')

val base_val = 100
val gen_capture = generator(\: [yield base_val, yield base_val])
val c1 = next(gen_capture)
val c2 = next(gen_capture)
if c1 == 100 and c2 == 100:
    print('      [PASS] capturedvalues')
    passed = passed + 1
else:
    print('      [FAIL] capturedvalues')
    failed = failed + 1

# -----------------------------------------------------
# Generator Composition
# -----------------------------------------------------

print('')
print('describe Generator composition:')
print('  context multiple generators:')
print('    it handles concurrent generators:')

val gen_a = generator(\: [yield 1, yield 2])
val gen_b = generator(\: [yield 10, yield 20])

val a1 = next(gen_a)
val b1 = next(gen_b)
val a2 = next(gen_a)
val b2 = next(gen_b)

if a1 == 1 and b1 == 10 and a2 == 2 and b2 == 20:
    print('      [PASS] concurrent generators')
    passed = passed + 1
else:
    print('      [FAIL] concurrent generators')
    failed = failed + 1

# -----------------------------------------------------
# Generator Collection
# -----------------------------------------------------

print('')
print('describe Generator collection:')
print('  context collect to array:')
print('    it collects generatorvalues:')

val gen_collect = generator(\: [yield 1, yield 2, yield 3])
val collected = collect(gen_collect)
if collected.len() == 3 and collected[0] == 1 and collected[2] == 3:
    print('      [PASS] collect generator')
    passed = passed + 1
else:
    print('      [FAIL] collect generator')
    failed = failed + 1

# -----------------------------------------------------
# Range Generator Pattern
# -----------------------------------------------------

print('')
print('describe Range generator pattern:')
print('  context counting generator:')
print('    it generates rangevalues:')

val gen_range = generator(\: [yield 0, yield 1, yield 2, yield 3, yield 4])
val range_sum = next(gen_range) + next(gen_range) + next(gen_range) + next(gen_range) + next(gen_range)
if range_sum == 10:
    print('      [PASS] range generator')
    passed = passed + 1
else:
    print('      [FAIL] range generator')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Generator Codegen')
print('')
print("**Feature ID:** #96")
print("**Category:** Codegen")
print("**Difficulty:** Level 4/5")
print("**Status:** Complete")
print("**Implementation:** Rust")
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## State Machine Structure')
print('')
print('| Component | Purpose |')
print('|-----------|---------|')
print('| Dispatcher | Entry block routing by state |')
print('| Resume Blocks | Continuation after each yield |')
print('| State Variable | Tracks current suspension point |')
print('| Frame | Preserved local variables |')
print('')
print('## Lowering Process')
print('')
print('1. Identify yield points in generator body')
print('2. Split blocks at each yield')
print('3. Create dispatcher with state-based jumps')
print('4. Generate resume blocks for continuations')
print('5. Compute liveness for frame allocation')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
