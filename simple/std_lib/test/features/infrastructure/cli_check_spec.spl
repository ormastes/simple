# CLI Check Command Specification
# Feature #210: Syntax validation without execution
# Category: Infrastructure | Difficulty: 2 | Status: Planned

"""
# CLI Check Command

**Feature ID:** #210
**Category:** Infrastructure - Developer Tools
**Difficulty:** 2/5
**Status:** Planned

## Overview

The `simple check` command validates Simple source code syntax and type correctness
without executing the program. This provides fast feedback during development and
enables use in CI/CD pipelines for pre-commit validation.

## Key Features

- **Syntax Validation:** Parse source code and report syntax errors
- **Type Checking:** Validate type correctness without execution
- **Import Resolution:** Verify all dependencies can be resolved
- **Fast Feedback:** Return results in < 200ms for small files
- **Exit Codes:** 0 for success, 1 for errors
- **Multiple Files:** Check multiple files in single invocation

## Implementation

**Primary Files:**
- `src/driver/src/cli/check.rs` - Check command implementation
- `src/driver/src/main.rs` - CLI integration

**Dependencies:**
- Feature #1: Lexer
- Feature #2: Parser
- Feature #100: Type Inference
- Feature #104: Dependency Tracker

## Usage

### Basic Syntax Check
```bash
simple check hello.spl
```

### Check Multiple Files
```bash
simple check src/*.spl
```

### Verbose Output
```bash
simple check -v program.spl
```

### JSON Output (for tooling)
```bash
simple check --json program.spl
```

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | All files valid |
| 1 | Syntax or type errors found |
| 2 | File not found |
| 3 | Import resolution failed |

## Error Output Format

### Human-Readable (default)
```
program.spl:10:5: error: type mismatch
  expected: i32
  found:    str
   10 |     val x: i32 = "hello"
      |                  ^^^^^^^
```

### JSON Format (--json)
```json
{
  "status": "error",
  "files_checked": 1,
  "errors": [
    {
      "file": "program.spl",
      "line": 10,
      "column": 5,
      "severity": "error",
      "message": "type mismatch",
      "expected": "i32",
      "found": "str"
    }
  ]
}
```

## Test Coverage

Validates syntax checking, type validation, and error reporting.
"""
import std.spec

describe "Syntax validation":
    it "accepts valid Simple code":
        """
        **Given** syntactically correct Simple source code
        **When** running `simple check`
        **Then** exits with code 0
        **And** reports success

        **Example:**
        ```simple
        fn main():
            val x = 42
            print(x)
        ```

        **Expected output:**
        ```
        Checking program.spl... OK
        ```

        **Verification:** Valid code passes check
        """
        val valid_code = "fn main():\n    val x = 42\n    print(x)"
        val is_valid = true
        expect(is_valid).to(be_true())

    it "detects syntax errors":
        """
        **Given** Simple code with syntax errors
        **When** running `simple check`
        **Then** exits with code 1
        **And** reports error location

        **Example:**
        ```simple
        fn main():
            val x =
        ```

        **Expected output:**
        ```
        program.spl:2:13: error: unexpected end of expression
            val x =
                    ^
        ```

        **Verification:** Syntax errors are detected
        """
        val has_syntax_error = true
        expect(has_syntax_error).to(be_true())

    it "reports multiple errors":
        """
        **Given** code with multiple syntax errors
        **When** running `simple check`
        **Then** reports all errors found

        **Example:**
        ```simple
        fn main():
            val x =
            val y = "hello
            print(z)
        ```

        **Expected:** Reports 3 errors (incomplete assignment, unterminated string, undefined variable)

        **Verification:** All syntax errors reported
        """
        val can_report_multiple = true
        expect(can_report_multiple).to(be_true())

print("")
describe "Type validation":
    it "detects type mismatches":
        """
        **Given** code with type errors
        **When** running `simple check`
        **Then** reports type mismatch

        **Example:**
        ```simple
        fn main():
            val x: i32 = "hello"
        ```

        **Expected output:**
        ```
        program.spl:2:18: error: type mismatch
          expected: i32
          found:    str
        ```

        **Verification:** Type errors detected
        """
        val detects_type_errors = true
        expect(detects_type_errors).to(be_true())

    it "validates function signatures":
        """
        **Given** function call with wrong arguments
        **When** running `simple check`
        **Then** reports argument mismatch

        **Example:**
        ```simple
        fn add(a: i32, b: i32) -> i32:
            return a + b

        fn main():
            val result = add(5, "10")
        ```

        **Expected:** Reports type error on second argument

        **Verification:** Function signature validation works
        """
        val validates_signatures = true
        expect(validates_signatures).to(be_true())

    it "checks return type compatibility":
        """
        **Given** function with wrong return type
        **When** running `simple check`
        **Then** reports return type mismatch

        **Example:**
        ```simple
        fn get_number() -> i32:
            return "not a number"
        ```

        **Expected:** Reports return type error

        **Verification:** Return type checking works
        """
        val checks_returns = true
        expect(checks_returns).to(be_true())

print("")
describe "Import resolution":
    it "validates import statements":
        """
        **Given** code with valid imports
        **When** running `simple check`
        **Then** resolves all imports successfully

        **Example:**
        ```simple
        import std.io
        import std.collections

        fn main():
            print("Hello")
        ```

        **Expected:** All imports resolved

        **Verification:** Import resolution works
        """
        val resolves_imports = true
        expect(resolves_imports).to(be_true())

    it "reports missing imports":
        """
        **Given** code with non-existent imports
        **When** running `simple check`
        **Then** reports import error

        **Example:**
        ```simple
        import nonexistent.module
        ```

        **Expected output:**
        ```
        program.spl:1:8: error: cannot find module 'nonexistent.module'
        ```

        **Verification:** Missing imports detected
        """
        val detects_missing_imports = true
        expect(detects_missing_imports).to(be_true())

    it "detects circular imports":
        """
        **Given** modules with circular dependencies
        **When** running `simple check`
        **Then** reports circular import error

        **Example:**
        ```
        # a.spl
        import b

        # b.spl
        import a
        ```

        **Expected:** Reports circular dependency

        **Verification:** Circular imports detected
        """
        val detects_circular = true
        expect(detects_circular).to(be_true())

print("")
describe "Multiple file checking":
    it "checks multiple files in one invocation":
        """
        **Given** multiple source files
        **When** running `simple check file1.spl file2.spl`
        **Then** validates all files

        **Expected output:**
        ```
        Checking file1.spl... OK
        Checking file2.spl... OK
        All checks passed (2 files)
        ```

        **Verification:** Batch checking works
        """
        val checks_multiple = true
        expect(checks_multiple).to(be_true())

    it "reports which files have errors":
        """
        **Given** mix of valid and invalid files
        **When** running batch check
        **Then** reports status for each file

        **Expected:**
        - file1.spl: OK
        - file2.spl: ERROR (type mismatch)
        - file3.spl: OK

        **Verification:** Per-file status reported
        """
        val reports_per_file = true
        expect(reports_per_file).to(be_true())

    it "supports glob patterns":
        """
        **Given** glob pattern like `src/*.spl`
        **When** running `simple check src/*.spl`
        **Then** checks all matching files

        **Example:**
        ```bash
        simple check src/**/*.spl
        ```

        **Verification:** Glob expansion works
        """
        val supports_globs = true
        expect(supports_globs).to(be_true())

print("")
describe "Output formats":
    it "provides human-readable output by default":
        """
        **Given** any check result
        **When** running without format flags
        **Then** outputs human-readable messages

        **Format:**
        - Color-coded errors (red)
        - Source context with caret
        - Clear error messages

        **Verification:** Default output is readable
        """
        val has_readable_output = true
        expect(has_readable_output).to(be_true())

    it "supports JSON output for tooling":
        """
        **Given** check result
        **When** running `simple check --json`
        **Then** outputs structured JSON

        **Example output:**
        ```json
        {
          "status": "success",
          "files_checked": 3,
          "errors": [],
          "warnings": []
        }
        ```

        **Verification:** JSON output works
        """
        val has_json_output = true
        expect(has_json_output).to(be_true())

    it "supports quiet mode":
        """
        **Given** any check
        **When** running `simple check --quiet`
        **Then** only outputs errors
        **And** no progress messages

        **Use case:** CI/CD pipelines

        **Verification:** Quiet mode suppresses verbose output
        """
        val has_quiet_mode = true
        expect(has_quiet_mode).to(be_true())

print("")
describe "Performance":
    it "provides fast feedback for small files":
        """
        **Given** small source file (< 1000 lines)
        **When** running check
        **Then** completes in < 200ms

        **Performance target:** Sub-second feedback

        **Verification:** Check is fast for development
        """
        val is_fast = true
        expect(is_fast).to(be_true())

    it "handles large files efficiently":
        """
        **Given** large source file (> 10,000 lines)
        **When** running check
        **Then** completes in reasonable time (< 2s)

        **Optimization:** Parallel type checking

        **Verification:** Scales to large files
        """
        val handles_large = true
        expect(handles_large).to(be_true())

    it "caches type information":
        """
        **Given** unchanged imported modules
        **When** running check multiple times
        **Then** reuses cached type information

        **Performance:** Second run much faster

        **Verification:** Incremental checking works
        """
        val uses_cache = true
        expect(uses_cache).to(be_true())

print("")
describe "Integration with other tools":
    it "integrates with LSP for IDE support":
        """
        **Given** LSP server running
        **When** file is modified
        **Then** check runs automatically
        **And** errors appear in editor

        **Use case:** Real-time error highlighting

        **Verification:** LSP integration works
        """
        val has_lsp_integration = true
        expect(has_lsp_integration).to(be_true())

    it "works in CI/CD pipelines":
        """
        **Given** CI script
        **When** running `simple check` on all files
        **Then** fails build on any error

        **Example CI config:**
        ```yaml
        - name: Check syntax
          run: simple check src/**/*.spl
        ```

        **Verification:** CI/CD integration works
        """
        val works_in_ci = true
        expect(works_in_ci).to(be_true())

    it "supports pre-commit hooks":
        """
        **Given** git pre-commit hook
        **When** committing changes
        **Then** validates only changed files

        **Example hook:**
        ```bash
        #!/bin/sh
        git diff --cached --name-only | grep '.spl$' | xargs simple check
        ```

        **Verification:** Pre-commit hook integration works
        """
        val supports_hooks = true
        expect(supports_hooks).to(be_true())

print("")
print("============================================================")
print("  CLI CHECK COMMAND SPECIFICATION COMPLETE")
print("  Feature #210: Syntax validation without execution")
print("  Status: Planned - Ready for implementation")
print("============================================================")
