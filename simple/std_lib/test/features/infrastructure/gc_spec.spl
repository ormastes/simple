# GC Feature Specification
# Feature #7: Garbage Collection
# Category: Infrastructure | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 7,
    name: 'GC',
    category: 'Infrastructure',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/architecture/memory_model_implementation.md',
    files: [
        'src/runtime/src/memory/gc.rs',
        'src/runtime/src/memory/mod.rs'
    ],
    tests: [
        'src/driver/tests/runner_tests.rs'
    ],
    description: 'Automatic memory management with tracing garbage collection. Handles allocation, collection cycles, and safe deallocation of heap objects.',
    code_examples: [],
    dependencies: [6],
    required_by: [],
    notes: 'Abfall-backed GC with optional logging. Supports GC-less mode for real-time contexts. Collection triggered by allocation pressure.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  GC FEATURE SPECIFICATION (#7)')
print('  Category: Infrastructure | Difficulty: 3 | Status: Complete')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

# -----------------------------------------------------
# Heap Allocation
# -----------------------------------------------------

print('describe Heap allocation:')
print('  context array allocation:')
print('    it allocates arrays:')

let arr = [1, 2, 3, 4, 5]
if arr.len() == 5:
    print('      [PASS] array allocated')
    passed = passed + 1
else:
    print('      [FAIL] array allocated')
    failed = failed + 1

print('    it handles large arrays:')

let large = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
if large.len() == 10:
    print('      [PASS] large array allocated')
    passed = passed + 1
else:
    print('      [FAIL] large array allocated')
    failed = failed + 1

print('')
print('  context string allocation:')
print('    it allocates strings:')

let s = "hello world this is a test string"
if s.len() > 20:
    print('      [PASS] string allocated')
    passed = passed + 1
else:
    print('      [FAIL] string allocated')
    failed = failed + 1

print('')
print('  context dict allocation:')
print('    it allocates dicts:')

let d = {"a": 1, "b": 2, "c": 3, "d": 4}
if d["a"] + d["d"] == 5:
    print('      [PASS] dict allocated')
    passed = passed + 1
else:
    print('      [FAIL] dict allocated')
    failed = failed + 1

# -----------------------------------------------------
# Object Lifetime
# -----------------------------------------------------

print('')
print('describe Object lifetime:')
print('  context local scope:')
print('    it creates scoped objects:')

fn create_array():
    let local = [100, 200, 300]
    return local.sum()

if create_array() == 600:
    print('      [PASS] scoped object works')
    passed = passed + 1
else:
    print('      [FAIL] scoped object works')
    failed = failed + 1

print('    it returns objects from functions:')

fn make_array():
    return [1, 2, 3]

let returned = make_array()
if returned.len() == 3:
    print('      [PASS] returned object lives')
    passed = passed + 1
else:
    print('      [FAIL] returned object lives')
    failed = failed + 1

print('')
print('  context nested objects:')
print('    it handles nested allocation:')

let nested = [[1, 2], [3, 4], [5, 6]]
if nested[0][0] + nested[2][1] == 7:
    print('      [PASS] nested objects')
    passed = passed + 1
else:
    print('      [FAIL] nested objects')
    failed = failed + 1

# -----------------------------------------------------
# Multiple Allocations
# -----------------------------------------------------

print('')
print('describe Multiple allocations:')
print('  context sequential allocation:')
print('    it handles many allocations:')

let a1 = [1, 2, 3]
let a2 = [4, 5, 6]
let a3 = [7, 8, 9]
let a4 = [10, 11, 12]
let a5 = [13, 14, 15]
let total = a1.sum() + a2.sum() + a3.sum() + a4.sum() + a5.sum()
if total == 120:
    print('      [PASS] sequential allocations')
    passed = passed + 1
else:
    print('      [FAIL] sequential allocations')
    failed = failed + 1

print('')
print('  context loop allocation:')
print('    it allocates in loops:')

let mut sum = 0
let mut i = 0
while i < 5:
    let temp = [i, i + 1]
    sum = sum + temp[0] + temp[1]
    i = i + 1

if sum == 25:
    print('      [PASS] loop allocations')
    passed = passed + 1
else:
    print('      [FAIL] loop allocations')
    failed = failed + 1

# -----------------------------------------------------
# Struct Allocation
# -----------------------------------------------------

print('')
print('describe Struct allocation:')
print('  context struct instances:')
print('    it allocates structs:')

struct Box:
    value: i64

let b1 = Box { value: 10 }
let b2 = Box { value: 20 }
let b3 = Box { value: 30 }
if b1.value + b2.value + b3.value == 60:
    print('      [PASS] struct allocation')
    passed = passed + 1
else:
    print('      [FAIL] struct allocation')
    failed = failed + 1

print('')
print('  context struct with collections:')
print('    it handles structs with arrays:')

struct Container:
    items: List[i64]

let c = Container { items: [1, 2, 3, 4] }
if c.items.len() == 4:
    print('      [PASS] struct with collection')
    passed = passed + 1
else:
    print('      [FAIL] struct with collection')
    failed = failed + 1

# -----------------------------------------------------
# Closure Allocation
# -----------------------------------------------------

print('')
print('describe Closure allocation:')
print('  context closure capture:')
print('    it allocates closures:')

let multiplier = 10
let mult = |x| x * multiplier
if mult(5) == 50:
    print('      [PASS] closure allocated')
    passed = passed + 1
else:
    print('      [FAIL] closure allocated')
    failed = failed + 1

print('    it handles multiple closures:')

let add5 = |x| x + 5
let add10 = |x| x + 10
if add5(0) + add10(0) == 15:
    print('      [PASS] multiple closures')
    passed = passed + 1
else:
    print('      [FAIL] multiple closures')
    failed = failed + 1

# -----------------------------------------------------
# Memory Safety
# -----------------------------------------------------

print('')
print('describe Memory safety:')
print('  context no dangling pointers:')
print('    it safely accesses objects:')

fn get_first(arr):
    return arr[0]

let data = [42, 43, 44]
if get_first(data) == 42:
    print('      [PASS] safe object access')
    passed = passed + 1
else:
    print('      [FAIL] safe object access')
    failed = failed + 1

print('    it handles object passing:')

fn double_first(arr):
    return arr[0] * 2

let nums = [21, 22, 23]
if double_first(nums) == 42:
    print('      [PASS] object passing')
    passed = passed + 1
else:
    print('      [FAIL] object passing')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# GC')
print('')
print('**Feature ID:** #7')
print('**Category:** Infrastructure')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## GC Behavior')
print('')
print('| Aspect | Description |')
print('|--------|-------------|')
print('| Allocation | Heap objects allocated on demand |')
print('| Collection | Triggered by allocation pressure |')
print('| Roots | Stack, globals, captured variables |')
print('| Safety | No dangling pointers, no use-after-free |')
print('')
print('## Allocated Types')
print('')
print('| Type | GC Managed |')
print('|------|------------|')
print('| Arrays | Yes |')
print('| Strings | Yes |')
print('| Dicts | Yes |')
print('| Structs | Yes |')
print('| Closures | Yes |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
