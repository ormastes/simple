# HIR Feature Specification
# Feature #4: High-level Intermediate Representation
# Category: Infrastructure | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 4,
    name: 'HIR',
    category: 'Infrastructure',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/architecture/README.md',
    files: [
        'src/compiler/src/hir/mod.rs',
        'src/compiler/src/hir/types.rs',
        'src/compiler/src/hir/lower.rs'
    ],
    tests: [
        'src/driver/tests/runner_tests.rs'
    ],
    description: 'High-level IR for type checking and semantic analysis. Performs type inference, mutability checking, and capability verification after AST parsing.',
    code_examples: [],
    dependencies: [3],
    required_by: [5],
    notes: 'HIR preserves source structure while adding type information. Validates semantic correctness before MIR lowering.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  HIR FEATURE SPECIFICATION (#4)')
print('  Category: Infrastructure | Difficulty: 3 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Type Inference
# -----------------------------------------------------

print('describe Type inference:')
print('  context integer inference:')
print('    it infers integer type:')

val inferred_int = 42
if inferred_int + 1 == 43:
    print('      [PASS] infers integer')
    passed = passed + 1
else:
    print('      [FAIL] infers integer')
    failed = failed + 1

print('')
print('  context string inference:')
print('    it infers string type:')

val inferred_str = "hello"
if inferred_str.len() == 5:
    print('      [PASS] infers string')
    passed = passed + 1
else:
    print('      [FAIL] infers string')
    failed = failed + 1

print('')
print('  context collection inference:')
print('    it infers array element type:')

val nums = [1, 2, 3]
if nums[0] + nums[1] == 3:
    print('      [PASS] infers array type')
    passed = passed + 1
else:
    print('      [FAIL] infers array type')
    failed = failed + 1

print('')
print('  context function return inference:')
print('    it infers return type:')

fn get_value():
    return 42

val value = get_value()
if value == 42:
    print('      [PASS] infers function return')
    passed = passed + 1
else:
    print('      [FAIL] infers function return')
    failed = failed + 1

# -----------------------------------------------------
# Mutability Checking
# -----------------------------------------------------

print('')
print('describe Mutability checking:')
print('  context mutable bindings:')
print('    it allows mutation with mut:')

var counter = 0
counter = counter + 1
counter = counter + 1
if counter == 2:
    print('      [PASS] mutable binding')
    passed = passed + 1
else:
    print('      [FAIL] mutable binding')
    failed = failed + 1

print('    it allows reassignment:')

var x = 10
x = 20
x = 30
if x == 30:
    print('      [PASS] reassignment')
    passed = passed + 1
else:
    print('      [FAIL] reassignment')
    failed = failed + 1

print('')
print('  context immutable bindings:')
print('    it preserves immutablevalues:')

val immut = 100
if immut == 100:
    print('      [PASS] immutable preserved')
    passed = passed + 1
else:
    print('      [FAIL] immutable preserved')
    failed = failed + 1

# -----------------------------------------------------
# Type Annotations
# -----------------------------------------------------

print('')
print('describe Type annotations:')
print('  context explicit types:')
print('    it respects type annotations:')

val typed: i64 = 42
if typed == 42:
    print('      [PASS] explicit type')
    passed = passed + 1
else:
    print('      [FAIL] explicit type')
    failed = failed + 1

print('    it works with function params:')

fn typed_add(a: i64, b: i64) -> i64:
    return a + b

if typed_add(20, 22) == 42:
    print('      [PASS] typed function params')
    passed = passed + 1
else:
    print('      [FAIL] typed function params')
    failed = failed + 1

print('')
print('  context generic type annotations:')
print('    it handles generic types:')

val list: List<i64> = [10, 20, 30]
if list.len() == 3:
    print('      [PASS] generic type annotation')
    passed = passed + 1
else:
    print('      [FAIL] generic type annotation')
    failed = failed + 1

# -----------------------------------------------------
# Type Narrowing
# -----------------------------------------------------

print('')
print('describe Type narrowing:')
print('  context pattern matching:')
print('    it narrows Option type:')

val opt = Some(42)
var result = 0
match opt:
    Some(v) =>
        result = v
    None =>
        result = -1

if result == 42:
    print('      [PASS] Option type narrowing')
    passed = passed + 1
else:
    print('      [FAIL] Option type narrowing')
    failed = failed + 1

print('    it narrows Result type:')

val res = Ok(100)
var result_value = 0
match res:
    Ok(v) =>
       result_value = v
    Err(e) =>
       result_value = -1

if result_value == 100:
    print('      [PASS] Result type narrowing')
    passed = passed + 1
else:
    print('      [FAIL] Result type narrowing')
    failed = failed + 1

# -----------------------------------------------------
# Struct Type Checking
# -----------------------------------------------------

print('')
print('describe Struct type checking:')
print('  context struct fields:')
print('    it verifies field types:')

struct Point:
    x: i64
    y: i64

val p = Point { x: 10, y: 20 }
if p.x + p.y == 30:
    print('      [PASS] struct field types')
    passed = passed + 1
else:
    print('      [FAIL] struct field types')
    failed = failed + 1

print('    it allows nested structs:')

struct Rect:
    width: i64
    height: i64

val r = Rect { width: 5, height: 10 }
if r.width * r.height == 50:
    print('      [PASS] nested struct access')
    passed = passed + 1
else:
    print('      [FAIL] nested struct access')
    failed = failed + 1

# -----------------------------------------------------
# Method Resolution
# -----------------------------------------------------

print('')
print('describe Method resolution:')
print('  context impl methods:')
print('    it resolves struct methods:')

struct Counter:
   value: i64

impl Counter:
    fn get() -> i64:
        return self.value

val c = Counter {value: 42 }
if c.get() == 42:
    print('      [PASS] method resolution')
    passed = passed + 1
else:
    print('      [FAIL] method resolution')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# HIR')
print('')
print('**Feature ID:** #4')
print('**Category:** Infrastructure')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## HIR Phases')
print('')
print('| Phase | Purpose |')
print('|-------|---------|')
print('| Type Inference | Determine types from usage |')
print('| Mutability Check | Verify mut/immut semantics |')
print('| Type Narrowing | Refine types in branches |')
print('| Method Resolution | Find impl methods |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
