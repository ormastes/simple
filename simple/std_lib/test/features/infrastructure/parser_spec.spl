# Parser Feature Specification
# Feature #2: Transforms tokens into Abstract Syntax Tree
# Category: Infrastructure | Difficulty: 4 | Status: Complete

"""
# Parser (Syntax Analysis)

**Feature ID:** #2
**Category:** Infrastructure - Compiler
**Difficulty:** 4/5
**Status:** Complete

## Overview

The Parser is the second phase of the Simple compiler pipeline, transforming a flat
stream of tokens (from the Lexer) into a hierarchical Abstract Syntax Tree (AST).
The AST represents the syntactic structure of the program in a form suitable for
semantic analysis and code generation.

Simple's parser uses two complementary parsing techniques:
- **Pratt Parsing** for expressions (handles operator precedence elegantly)
- **Recursive Descent** for statements (clear control flow parsing)

This hybrid approach combines the strengths of both methods, resulting in clean,
maintainable code that correctly handles operator precedence and complex control flow.

## Key Features

- **Pratt Expression Parsing:** Elegant handling of operator precedence and associativity
- **Recursive Descent Statements:** Clear parsing of control flow structures
- **Error Recovery:** Produces useful error messages with source locations
- **LL(1) Grammar:** Deterministic parsing without backtracking
- **Implicit Self:** Methods don't require explicit `self` parameter
- **Angle Bracket Generics:** Uses `<T>` instead of `[T]` for type parameters

## Syntax

**Parser Pipeline:**
```
Token Stream → Parser → Abstract Syntax Tree
```

**Example Input (Tokens):**
```
[Keyword(val), Ident("x"), Equals, Int(2), Plus, Int(3), Star, Int(4)]
```

**Example Output (AST):**
```
VariableDeclaration {
    name: "x",
    value: BinaryOp {
        op: Plus,
        left: Int(2),
        right: BinaryOp {
            op: Star,
            left: Int(3),
            right: Int(4)
        }
    }
}
```

**Operator Precedence (Highest to Lowest):**
```
1. Primary (literals, identifiers, parentheses)
2. Field access (.)
3. Function calls, subscript ([])
4. Unary (-, not)
5. Multiplication, division (*, /)
6. Addition, subtraction (+, -)
7. Comparisons (<, >, <=, >=, ==, !=)
8. Logical and
9. Logical or
```

## Test Coverage

This specification validates:
1. **Expression Parsing:** Arithmetic, precedence, parentheses, unary operators
2. **Statement Parsing:** if-else, match, for loops, while loops
3. **Function Parsing:** Function definitions, lambda expressions

## Implementation

**Primary Files:**
- `src/parser/src/parser.rs` - Main parser entry point and coordination
- `src/parser/src/expressions/mod.rs` - Pratt parser for expressions
- `src/parser/src/statements/mod.rs` - Recursive descent for statements

**Testing:**
- `src/parser/tests/expression_tests.rs` - Expression parsing tests
- `src/parser/tests/statement_tests.rs` - Statement parsing tests

**Dependencies:**
- Feature #1: Lexer (produces token stream for parser)

**Required By:**
- Feature #3: AST (uses AST nodes produced by parser)
- Feature #4: Type Checker (analyzes AST structure)
- Feature #5: Code Generator (compiles AST to IR/machine code)

## Parsing Algorithm

### Pratt Parser for Expressions

Named after Vaughan Pratt, this technique associates precedence levels with operators
and uses them to guide parsing. Each operator has a binding power that determines
how strongly it binds to its operands.

**Binding Powers:**
```rust
Multiplication: 60
Addition: 50
Comparison: 40
LogicalAnd: 30
LogicalOr: 20
```

**Algorithm:**
```
parse_expression(min_bp):
    left = parse_primary()
    while next_token is operator and bp(operator) >= min_bp:
        operator = consume_token()
        right = parse_expression(bp(operator) + 1)
        left = BinaryOp(operator, left, right)
    return left
```

**Example - Parsing `2 + 3 * 4`:**
```
parse_expression(0):
    left = 2
    see '+' (bp=50) >= 0, consume
        right = parse_expression(51):
            left = 3
            see '*' (bp=60) >= 51, consume
                right = parse_expression(61):
                    left = 4
                    return 4
                left = 3 * 4
            return 3 * 4
        left = 2 + (3 * 4)
    return 2 + (3 * 4)

Result AST:
    +
   / \
  2   *
     / \
    3   4
```

### Recursive Descent for Statements

Statements use traditional recursive descent, where each grammar rule becomes a
parsing function.

**Example Grammar:**
```
statement = if_statement
          | while_statement
          | for_statement
          | match_statement
          | variable_declaration
          | function_definition
          | expression_statement

if_statement = "if" expression ":" block ["else" ":" block]
```

**Parsing Function:**
```rust
fn parse_if_statement() -> Statement {
    expect(Token::If);
    let condition = parse_expression();
    expect(Token::Colon);
    let then_block = parse_block();
    let else_block = if match_token(Token::Else) {
        expect(Token::Colon);
        Some(parse_block())
    } else {
        None
    };
    Statement::If { condition, then_block, else_block }
}
```

## Error Handling

The parser provides detailed error messages with source locations:

**Example Error:**
```simple
val x = 2 +
```

**Error Message:**
```
error: expected expression after '+' operator
  --> example.spl:1:12
   |
 1 | val x = 2 +
   |            ^ expected expression
   |
   = note: binary operators require an operand on both sides
```

**Error Recovery:**
- Parser attempts to recover from errors to report multiple issues
- Uses synchronization points (statement boundaries)
- Inserts error nodes in AST for IDE tooling

## AST Node Types

**Expression Nodes:**
- `IntLiteral(i64)` - Integer constant
- `StringLiteral(String)` - String constant
- `BoolLiteral(bool)` - Boolean constant
- `Identifier(String)` - Variable reference
- `BinaryOp { op, left, right }` - Binary operation
- `UnaryOp { op, operand }` - Unary operation
- `Call { func, args }` - Function call
- `Index { object, index }` - Subscript access
- `FieldAccess { object, field }` - Member access
- `Lambda { params, body }` - Lambda function
- `If { condition, then_expr, else_expr }` - Conditional expression

**Statement Nodes:**
- `VariableDecl { name, type, value }` - Variable declaration
- `FunctionDef { name, params, return_type, body }` - Function definition
- `If { condition, then_block, else_block }` - If statement
- `While { condition, body }` - While loop
- `For { var, iterable, body }` - For loop
- `Match { value, arms }` - Pattern matching
- `Return { value }` - Return statement
- `Expression { expr }` - Expression statement

## Comparison with Other Parsers

| Feature | Simple | Python | Rust | JavaScript |
|---------|--------|--------|------|------------|
| Expression Parsing | Pratt | Recursive descent | Pratt-like | Recursive descent |
| Statement Parsing | Recursive descent | Recursive descent | Recursive descent | Recursive descent |
| Precedence Handling | Explicit BP | Precedence climbing | Operator precedence | Precedence table |
| Error Recovery | Synchronization points | Synchronization | Error productions | Error recovery |
| Grammar Complexity | LL(1) | LL(1) | LR-like | Complex |

## Performance Characteristics

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Parse expression | O(n) | Linear in tokens |
| Parse statement | O(n) | Linear in tokens |
| Parse program | O(n) | Single pass |
| Memory | O(n) | AST size proportional to source |

**Optimizations:**
- No backtracking (LL(1) grammar)
- Single pass parsing
- Efficient token consumption
- Minimal allocations for AST nodes

## Related Features

- Feature #1: Lexer (produces tokens for parser)
- Feature #3: AST (defines node types used by parser)
- Feature #4: Type Checker (analyzes parser output)
- Feature #28: Module System (imports require parsing)
- Feature #16: Enums (pattern matching in match statements)

## Language Design Notes

**LL(1) Grammar:**
Simple's grammar is designed to be parseable with 1 token of lookahead:
- No ambiguous constructs
- Clear statement/expression boundaries
- Deterministic parsing decisions

**Implicit Self:**
Methods don't require explicit `self` parameter:
```simple
impl MyClass:
    fn get_value() -> i32:  # 'self' is implicit
        return value
```

**Angle Bracket Generics:**
```simple
fn map<T, U>(f: fn(T) -> U) -> U  # <> not []
```

**Migration Notes:**
- Automated migration: N/A (infrastructure)
- Manual assertion conversion: ~16 minutes (8 assertions × 2 min)
- Docstring enhancement: ~32 minutes (1 file + 3 describe + 8 it)
- Total: ~48 minutes (Session 4)
"""
import std.spec


describe "Parser expressions":
    """
    ## Expression Parsing with Pratt Algorithm

    Expression parsing uses the Pratt algorithm (top-down operator precedence parsing)
    to correctly handle operator precedence and associativity without explicit grammar
    rules for each precedence level.

    **Key Concepts:**

    **Binding Power:** Each operator has a numeric precedence level:
    - `*`, `/`: 60 (highest)
    - `+`, `-`: 50
    - `<`, `>`, `==`: 40
    - `and`: 30
    - `or`: 20 (lowest)

    **Left vs Right Associativity:**
    - Left associative: `a + b + c` → `(a + b) + c`
    - Right associative: `a ** b ** c` → `a ** (b ** c)`

    **Pratt Algorithm:**
    ```
    1. Parse left operand (highest precedence)
    2. While next operator has higher/equal precedence:
       a. Consume operator
       b. Parse right operand (recursively, at operator's precedence)
       c. Build binary expression node
    3. Return expression tree
    ```

    **Benefits:**
    - Simple, elegant code
    - Easy to extend with new operators
    - Natural handling of precedence
    - No grammar ambiguity

    **Implementation:** See src/parser/src/expressions/mod.rs::parse_expression()
    """

    it "parses arithmetic with correct precedence":
        """
        **Given** an arithmetic expression with mixed operators
        **When** parsing the expression
        **Then** respects operator precedence (multiplication before addition)

        **Expression:**
        ```simple
        val expr = 2 + 3 * 4
        ```

        **Parse Tree:**
        ```
            +
           / \
          2   *
             / \
            3   4
        ```

        **Evaluation:**
        ```
        3 * 4 = 12  (multiply first, higher precedence)
        2 + 12 = 14 (add second, lower precedence)
        ```

        **Precedence Rules:**
        - Multiplication (`*`): binding power 60
        - Addition (`+`): binding power 50
        - Higher binding power = evaluated first

        **Parsing Steps:**
        1. Parse `2` (primary expression)
        2. See `+` (bp=50), consume it
        3. Recursively parse right side with bp=51
        4. In recursive call, parse `3`
        5. See `*` (bp=60) > 51, consume it
        6. Recursively parse right side with bp=61
        7. In that call, parse `4`, return it
        8. Build `3 * 4` node
        9. Return to outer call, build `2 + (3 * 4)` node

        **AST Node:**
        ```rust
        BinaryOp {
            op: Plus,
            left: IntLiteral(2),
            right: BinaryOp {
                op: Multiply,
                left: IntLiteral(3),
                right: IntLiteral(4)
            }
        }
        ```

        **Verification:** Result must equal 14 (not 20)

        **Implementation:** See parse_expression() with binding powers

        **Contrast - Wrong Precedence:**
        If parsed left-to-right without precedence:
        ```
        (2 + 3) * 4 = 5 * 4 = 20  (WRONG)
        ```

        **Related:** Feature #10 (Binary operators), Feature #8 (Arithmetic)
        """
        val expr1 = 2 + 3 * 4
        expect(expr1).to(eq(14))

        it "parses parenthesized expressions":
            """
            **Given** an expression with parentheses
            **When** parsing the expression
            **Then** parentheses override default precedence

            **Expression:**
            ```simple
            val expr = (2 + 3) * 4
            ```

            **Parse Tree:**
            ```
                *
               / \
              +   4
             / \
            2   3
            ```

            **Evaluation:**
            ```
            2 + 3 = 5   (parentheses force evaluation first)
            5 * 4 = 20
            ```

            **Parentheses Semantics:**
            - Override operator precedence
            - Treated as primary expression (highest precedence)
            - Recursively parse contents
            - Group subexpressions

            **Parsing Steps:**
            1. See `(`, consume it
            2. Recursively parse expression inside parentheses
            3. Parse `2 + 3` as normal (produces `2 + 3` node)
            4. See `)`, consume it
            5. Return `(2 + 3)` as primary expression
            6. Continue parsing outer expression
            7. See `*`, consume it
            8. Parse `4`
            9. Build `(2 + 3) * 4` node

            **AST Node:**
            ```rust
            BinaryOp {
                op: Multiply,
                left: BinaryOp {
                    op: Plus,
                    left: IntLiteral(2),
                    right: IntLiteral(3)
                },
                right: IntLiteral(4)
            }
            ```

            **Nested Parentheses:**
            ```simple
            val complex = ((1 + 2) * (3 + 4)) + 5
            # Parsed as: ((1 + 2) * (3 + 4)) + 5
            # Result: (3 * 7) + 5 = 21 + 5 = 26
            ```

            **Verification:** Result must equal 20 (not 14)

            **Implementation:** Parentheses handled in parse_primary()

            **Error - Unmatched Parentheses:**
            ```simple
            val bad = (2 + 3 * 4
            # Error: expected ')' after expression
            ```

            **Related:** Feature #10 (Grouping), Feature #8 (Arithmetic)
            """
        val expr2 = (2 + 3) * 4
        expect(expr2).to(eq(20))

        it "parses unary operators":
            """
            **Given** expressions with unary operators (negation, logical not)
            **When** parsing the expressions
            **Then** correctly applies unary operators to their operands

            **Unary Negation:**
            ```simple
            val negative = -5
            ```

            **Logical Not:**
            ```simple
            val inverted = not false
            ```

            **Unary Operator Characteristics:**
            - Prefix operators (appear before operand)
            - High binding power (higher than binary operators)
            - Right-associative: `-(-5)` valid

            **Parse Tree for `-5`:**
            ```
              -
              |
              5
            ```

            **Parse Tree for `not false`:**
            ```
             not
              |
            false
            ```

            **Precedence:**
            Unary operators have higher precedence than binary:
            ```simple
            -2 + 3  # Parsed as (-2) + 3 = 1, not -(2 + 3)
            ```

            **Multiple Unary Operators:**
            ```simple
            val double_neg = -(-5)  # 5
            val double_not = not (not true)  # true
            ```

            **Parsing Steps for `-5`:**
            1. See `-` token
            2. Consume it
            3. Recursively parse operand (higher precedence)
            4. Parse `5`
            5. Build UnaryOp node with operator=Negate, operand=5

            **AST Nodes:**
            ```rust
            // -5
            UnaryOp {
                op: Negate,
                operand: IntLiteral(5)
            }

            // not false
            UnaryOp {
                op: LogicalNot,
                operand: BoolLiteral(false)
            }
            ```

            **Supported Unary Operators:**
            - `-` (negation): numeric negation
            - `not` (logical not): boolean inversion

            **Verification:**
            - `-5` must equal -5
            - `not false` must equal true

            **Implementation:** See parse_unary() in expressions/mod.rs

            **Error - Type Mismatch:**
            ```simple
            val bad = -true  # Error: cannot negate boolean
            ```

            **Related:** Feature #10 (Unary operators), Feature #8 (Negation)
            """
        val expr3 = -5
        val expr4 = not false
        expect(expr3).to(eq(-5))
        expect(expr4).to(be_true())

print("")
describe "Parser statements":
    """
    ## Statement Parsing with Recursive Descent

    Statement parsing uses recursive descent, where each grammar rule corresponds to
    a parsing function. This approach is intuitive and produces clear, maintainable code.

    **Statement Categories:**
    - **Control Flow:** if, while, for, match
    - **Declarations:** val, var, fn, class
    - **Expressions:** Any expression followed by newline/semicolon

    **Recursive Descent Algorithm:**
    ```
    parse_statement():
        match next_token:
            Keyword("if") → parse_if_statement()
            Keyword("while") → parse_while_statement()
            Keyword("for") → parse_for_statement()
            Keyword("match") → parse_match_statement()
            Keyword("val") → parse_variable_declaration()
            Keyword("fn") → parse_function_definition()
            _ → parse_expression_statement()
    ```

    **Block Parsing:**
    ```
    parse_block():
        expect(Indent)
        statements = []
        while not Dedent:
            statements.append(parse_statement())
        expect(Dedent)
        return Block(statements)
    ```

    **Benefits:**
    - Clear correspondence between grammar and code
    - Easy to debug
    - Supports complex nested structures
    - Natural error recovery

    **Implementation:** See src/parser/src/statements/mod.rs
    """

    it "parses if-else statements":
        """
        **Given** an if-else expression
        **When** parsing the expression
        **Then** creates conditional AST node with both branches

        **Syntax (Expression Form):**
        ```simple
        val result = if condition: then_value else: else_value
        ```

        **Syntax (Statement Form):**
        ```simple
        if condition:
            then_block
        else:
            else_block
        ```

        **Parse Tree (Expression):**
        ```
            If
           / | \
          T  1  2
        ```

        **Parsing Steps:**
        1. Consume `if` keyword
        2. Parse condition expression (`true`)
        3. Consume `:` token
        4. Parse then-branch (`1`)
        5. Consume `else` keyword
        6. Consume `:` token
        7. Parse else-branch (`2`)
        8. Build If expression node

        **AST Node:**
        ```rust
        If {
            condition: BoolLiteral(true),
            then_expr: IntLiteral(1),
            else_expr: IntLiteral(2)
        }
        ```

        **Evaluation:**
        ```
        if true: 1 else: 2
            ↓
        condition = true
            ↓
        result = 1 (then-branch)
        ```

        **Block Form:**
        ```simple
        val result = if x > 0:
            val pos = x
            pos * 2
        else:
            val neg = -x
            neg * 2
        ```

        **Nested If:**
        ```simple
        val result = if a:
            if b: 1 else: 2
        else:
            if c: 3 else: 4
        ```

        **Verification:** When condition is true, result is 1 (not 2)

        **Implementation:** See parse_if_expression() in expressions/mod.rs

        **Related:** Feature #14 (Conditionals), Feature #10 (Control flow)
        """
        val if_result = if true: 1 else: 2
        expect(if_result).to(eq(1))

        it "parses match expressions":
            """
            **Given** a match expression with multiple arms
            **When** parsing the expression
            **Then** creates match AST node with pattern matching arms

            **Syntax:**
            ```simple
            val result = match value:
                pattern1 => expression1
                pattern2 => expression2
                _ => default_expression
            ```

            **Parse Tree:**
            ```
                  Match
                 /  |  \
              value  |   \
                   arms  arms
                   /  \
                  1   "one"
            ```

            **Match Arms:**
            Each arm consists of:
            - **Pattern:** Value to match against (or `_` for wildcard)
            - **Guard:** Optional condition (future feature)
            - **Expression:** Value to return if matched

            **Parsing Steps:**
            1. Consume `match` keyword
            2. Parse scrutinee expression (`match_val`)
            3. Consume `:` token
            4. Expect indent
            5. While not dedent:
               a. Parse pattern
               b. Consume `=>` token
               c. Parse arm expression
               d. Add arm to list
            6. Expect dedent
            7. Build Match node

            **AST Node:**
            ```rust
            Match {
                scrutinee: Identifier("match_val"),
                arms: vec![
                    MatchArm {
                        pattern: IntLiteral(1),
                        expression: StringLiteral("one")
                    },
                    MatchArm {
                        pattern: IntLiteral(2),
                        expression: StringLiteral("two")
                    },
                    MatchArm {
                        pattern: Wildcard,
                        expression: StringLiteral("other")
                    }
                ]
            }
            ```

            **Evaluation:**
            ```
            match 2:
                1 => "one"    # 2 != 1, skip
                2 => "two"    # 2 == 2, MATCH!
                _ => "other"  # Not reached

            Result: "two"
            ```

            **Pattern Types:**
            - **Literals:** `1`, `"text"`, `true`
            - **Wildcard:** `_` (matches anything)
            - **Variables:** `x` (binds value to name)
            - **Enum Variants:** `Color::Red` (future)
            - **Tuples:** `(1, 2)` (future)

            **Exhaustiveness:**
            Compiler should check that all possible values are covered:
            ```simple
            match value:
                1 => "one"
                2 => "two"
                # WARNING: non-exhaustive, missing default case
            ```

            **Verification:** When value is 2, result is "two"

            **Implementation:** See parse_match_expression() in expressions/mod.rs

            **Related:** Feature #16 (Enums), Feature #90 (Pattern matching)
            """
        val match_val = 2
        val match_result = match match_val:
        1 => "one"
        2 => "two"
        _ => "other"
        expect(match_result).to(eq("two"))

        it "parses for loops":
            """
            **Given** a for loop iterating over a collection
            **When** parsing the loop
            **Then** creates for loop AST node with iteration variable and body

            **Syntax:**
            ```simple
            for item in iterable:
                body
            ```

            **Parse Tree:**
            ```
                 For
                / | \
               i [..] body
            ```

            **For Loop Components:**
            - **Loop Variable:** Binds each element (`i`)
            - **Iterable:** Collection to iterate over (`[1, 2, 3]`)
            - **Body:** Statements to execute for each element

            **Parsing Steps:**
            1. Consume `for` keyword
            2. Parse loop variable identifier (`i`)
            3. Consume `in` keyword
            4. Parse iterable expression (`[1, 2, 3]`)
            5. Consume `:` token
            6. Parse body block
            7. Build For statement node

            **AST Node:**
            ```rust
            For {
                var: "i",
                iterable: ArrayLiteral([
                    IntLiteral(1),
                    IntLiteral(2),
                    IntLiteral(3)
                ]),
                body: Block([
                    Assignment {
                        target: "sum",
                        value: BinaryOp {
                            op: Plus,
                            left: Identifier("sum"),
                            right: Identifier("i")
                        }
                    }
                ])
            }
            ```

            **Execution:**
            ```
            Initial: sum = 0

            Iteration 1: i = 1, sum = 0 + 1 = 1
            Iteration 2: i = 2, sum = 1 + 2 = 3
            Iteration 3: i = 3, sum = 3 + 3 = 6

            Final: sum = 6
            ```

            **Iterable Types:**
            - **Arrays:** `[1, 2, 3]`
            - **Lists:** `List.of(1, 2, 3)`
            - **Ranges:** `range(10)` (future)
            - **Strings:** `"abc"` (iterates characters)
            - **Dicts:** `dict.keys()` or `dict.values()`

            **For Loop Variants:**
            ```simple
            # With index
            for (i, item) in enumerate(items):
                print("{i}: {item}")

            # Multiple iteration
            for x in items1:
                for y in items2:
                    process(x, y)
            ```

            **Verification:** After loop, sum equals 6 (1 + 2 + 3)

            **Implementation:** See parse_for_statement() in statements/mod.rs

            **Desugaring:**
            ```simple
            for i in items:
                body

            # Desugars to:
            val iterator = items.iter()
            while iterator.has_next():
                val i = iterator.next()
                body
            ```

            **Related:** Feature #20 (Lists), Feature #12 (Arrays), Feature #17 (Iteration)
            """
        var sum = 0
        for i in [1, 2, 3]:
        sum = sum + i
        expect(sum).to(eq(6))

        it "parses while loops":
            """
            **Given** a while loop with a condition
            **When** parsing the loop
            **Then** creates while loop AST node with condition and body

            **Syntax:**
            ```simple
            while condition:
                body
            ```

            **Parse Tree:**
            ```
                While
                / \
              cond body
            ```

            **While Loop Components:**
            - **Condition:** Boolean expression evaluated before each iteration
            - **Body:** Statements to execute while condition is true

            **Parsing Steps:**
            1. Consume `while` keyword
            2. Parse condition expression (`count < 3`)
            3. Consume `:` token
            4. Parse body block
            5. Build While statement node

            **AST Node:**
            ```rust
            While {
                condition: BinaryOp {
                    op: LessThan,
                    left: Identifier("count"),
                    right: IntLiteral(3)
                },
                body: Block([
                    Assignment {
                        target: "count",
                        value: BinaryOp {
                            op: Plus,
                            left: Identifier("count"),
                            right: IntLiteral(1)
                        }
                    }
                ])
            }
            ```

            **Execution:**
            ```
            Initial: count = 0

            Check: 0 < 3? Yes
              Execute: count = 0 + 1 = 1

            Check: 1 < 3? Yes
              Execute: count = 1 + 1 = 2

            Check: 2 < 3? Yes
              Execute: count = 2 + 1 = 3

            Check: 3 < 3? No
              Exit loop

            Final: count = 3
            ```

            **Infinite Loop:**
            ```simple
            while true:
                # Runs forever unless break statement
                if done:
                    break
            ```

            **Loop Control:**
            ```simple
            while condition:
                if skip_this:
                    continue  # Skip rest of body, check condition again
                if done:
                    break     # Exit loop immediately
                process()
            ```

            **Verification:** After loop, count equals 3

            **Implementation:** See parse_while_statement() in statements/mod.rs

            **Comparison - While vs For:**
            - **While:** Condition-based iteration, unknown iteration count
            - **For:** Collection-based iteration, known iteration count

            **Example - Until Pattern:**
            ```simple
            # While condition is false (until true)
            while not ready:
                prepare()
            ```

            **Related:** Feature #14 (Conditionals), Feature #17 (Loop control)
            """
        var count = 0
        while count < 3:
        count = count + 1
        expect(count).to(eq(3))

print("")
describe "Parser function definitions":
    """
    ## Function Definition Parsing

    Function definitions are parsed as top-level statements or class members. The
    parser handles parameter lists, optional return type annotations, and function bodies.

    **Function Syntax:**
    ```simple
    fn function_name(param1, param2, ...) -> ReturnType:
        body
    ```

    **Components:**
    - **Name:** Identifier for the function
    - **Parameters:** Comma-separated list with optional type annotations
    - **Return Type:** Optional type annotation after `->`
    - **Body:** Block of statements

    **Parsing Steps:**
    1. Consume `fn` keyword
    2. Parse function name
    3. Parse parameter list (enclosed in parentheses)
    4. If `->` present, parse return type
    5. Consume `:` token
    6. Parse function body (indented block)
    7. Build FunctionDef node

    **Lambda Functions:**
    Anonymous functions with shorter syntax:
    ```simple
    val func = \\param: expression
    val func = \\param1, param2: expression
    val func = \\param: { block }
    ```

    **Implementation:** See parse_function_definition() in statements/mod.rs
    and parse_lambda() in expressions/mod.rs
    """

    it "parses function definitions":
        """
        **Given** a function definition with parameters
        **When** parsing the definition
        **Then** creates function AST node with name, parameters, and body

        **Syntax:**
        ```simple
        fn add(a, b):
            return a + b
        ```

        **Parse Tree:**
        ```
            FunctionDef
           /    |    \
        "add" [a,b] body
        ```

        **Function Components:**
        - **Name:** `add` (identifier)
        - **Parameters:** `[a, b]` (parameter list)
        - **Return Type:** None (inferred from return statement)
        - **Body:** Block containing return statement

        **Parsing Steps:**
        1. Consume `fn` keyword
        2. Parse function name (`add`)
        3. Consume `(` token
        4. Parse parameter list (`a, b`)
        5. Consume `)` token
        6. Optional: parse `-> ReturnType`
        7. Consume `:` token
        8. Parse function body block
        9. Build FunctionDef node

        **AST Node:**
        ```rust
        FunctionDef {
            name: "add",
            parameters: vec![
                Parameter { name: "a", type_annotation: None },
                Parameter { name: "b", type_annotation: None }
            ],
            return_type: None,
            body: Block([
                Return {
                    value: BinaryOp {
                        op: Plus,
                        left: Identifier("a"),
                        right: Identifier("b")
                    }
                }
            ])
        }
        ```

        **Parameter Variants:**
        ```simple
        # No type annotations (inferred)
        fn func1(a, b):
            return a + b

        # With type annotations
        fn func2(a: i64, b: i64) -> i64:
            return a + b

        # With default values
        fn func3(a: i64, b: i64 = 0) -> i64:
            return a + b
        ```

        **Function Call:**
        ```simple
        val result = add(2, 3)  # 5
        ```

        **Verification:** Calling add(2, 3) returns 5

        **Implementation:** See parse_function_definition() in statements/mod.rs

        **Scope:**
        - Parameters are in function scope
        - Body can access parameters and outer scope
        - Return value exits function

        **Recursion:**
        ```simple
        fn factorial(n: i64) -> i64:
            if n <= 1:
                return 1
            return n * factorial(n - 1)
        ```

        **Related:** Feature #15 (Functions), Feature #18 (Parameters)
        """
        fn add(a, b):
        return a + b
        expect(add(2, 3)).to(eq(5))

        it "parses lambda expressions":
            """
            **Given** a lambda expression
            **When** parsing the expression
            **Then** creates anonymous function AST node

            **Syntax:**
            ```simple
            val func = \\param: expression
            ```

            **Lambda Variants:**
            ```simple
            # Single parameter
            val double = \\x: x * 2

            # Multiple parameters
            val add = \\x, y: x + y

            # Block body
            val complex = \\x: {
                val squared = x * x
                squared + 1
            }
            ```

            **Parse Tree:**
            ```
                Lambda
               /    \
             [x]   body
            ```

            **Parsing Steps:**
            1. Consume `\\` token (lambda start)
            2. Parse parameter list (without parentheses)
            3. Consume `:` token
            4. Parse expression or block body
            5. Build Lambda node

            **AST Node:**
            ```rust
            Lambda {
                parameters: vec![
                    Parameter { name: "x", type_annotation: None }
                ],
                body: BinaryOp {
                    op: Multiply,
                    left: Identifier("x"),
                    right: IntLiteral(2)
                }
            }
            ```

            **Lambda as Value:**
            Lambdas are first-class values:
            ```simple
            val double = \\x: x * 2
            val result = double(5)  # 10

            # Pass to higher-order function
            val numbers = [1, 2, 3]
            val doubled = numbers.map(\\x: x * 2)  # [2, 4, 6]
            ```

            **Closure Capture:**
            Lambdas can capture variables from outer scope:
            ```simple
            val multiplier = 10
            val scale = \\x: x * multiplier  # Captures 'multiplier'
            scale(5)  # 50
            ```

            **Verification:** Calling lambda with 5 returns 10

            **Implementation:** See parse_lambda() in expressions/mod.rs

            **Contrast with Function Definitions:**
            - **Lambda:** Anonymous, expression, captures environment
            - **Function:** Named, statement, no implicit capture

            **Alternative Syntax (Pipes):**
            ```simple
            # Lambda:  \\x: x * 2
            # Pipe:    |x| x * 2   (alternative, not yet supported)
            ```

            **Related:** Feature #24 (Closures), Feature #15 (Functions), Feature #22 (HOFs)
            """
        val double = \x: x * 2
        expect(double(5)).to(eq(10))
