# Parser Feature Specification
# Feature #2: Transforms tokens into Abstract Syntax Tree
# Category: Infrastructure | Difficulty: 4 | Status: Complete

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

let FEATURE = FeatureMetadata {
    id: 2,
    name: "Parser",
    category: "Infrastructure",
    difficulty: 4,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/lexer_parser.md",
    files: [
        "src/parser/src/parser.rs",
        "src/parser/src/expressions/mod.rs",
        "src/parser/src/statements/mod.rs"
    ],
    tests: [
        "src/parser/tests/expression_tests.rs",
        "src/parser/tests/statement_tests.rs"
    ],
    description: "Transforms token stream into Abstract Syntax Tree (AST). Uses recursive descent for statements and Pratt parsing for expressions with operator precedence.",
    code_examples: [
        "# Expression parsing with precedence:",
        "let result = 2 + 3 * 4  # Parses as 2 + (3 * 4)",
        "",
        "# Statement parsing:",
        "if condition:",
        "    do_something()",
        "else:",
        "    do_other()"
    ],
    dependencies: [1],
    required_by: [3],
    notes: "Pratt parser handles operator precedence elegantly. Recursive descent for control flow."
}

print("============================================================")
print("  PARSER FEATURE SPECIFICATION (#2)")
print("  Category: Infrastructure | Difficulty: 4 | Status: Complete")
print("============================================================")
print("")

let mut passed = 0
let mut failed = 0

print("describe Parser expressions:")

print("  it parses arithmetic with correct precedence:")
let expr1 = 2 + 3 * 4
if expr1 == 14:
    print("    [PASS] 2 + 3 * 4 = 14")
    passed = passed + 1
else:
    print("    [FAIL] precedence error")
    failed = failed + 1

print("  it parses parenthesized expressions:")
let expr2 = (2 + 3) * 4
if expr2 == 20:
    print("    [PASS] (2 + 3) * 4 = 20")
    passed = passed + 1
else:
    print("    [FAIL] parentheses error")
    failed = failed + 1

print("  it parses unary operators:")
let expr3 = -5
let expr4 = not false
if expr3 == -5 and expr4 == true:
    print("    [PASS] unary - and not")
    passed = passed + 1
else:
    print("    [FAIL] unary operators")
    failed = failed + 1

print("")
print("describe Parser statements:")

print("  it parses if-else statements:")
let if_result = if true: 1 else: 2
if if_result == 1:
    print("    [PASS] if-else expression")
    passed = passed + 1
else:
    print("    [FAIL] if-else")
    failed = failed + 1

print("  it parses match expressions:")
let match_val = 2
let match_result = match match_val:
    1 => "one"
    2 => "two"
    _ => "other"
if match_result == "two":
    print("    [PASS] match expression")
    passed = passed + 1
else:
    print("    [FAIL] match expression")
    failed = failed + 1

print("  it parses for loops:")
let mut sum = 0
for i in [1, 2, 3]:
    sum = sum + i
if sum == 6:
    print("    [PASS] for loop")
    passed = passed + 1
else:
    print("    [FAIL] for loop")
    failed = failed + 1

print("  it parses while loops:")
let mut count = 0
while count < 3:
    count = count + 1
if count == 3:
    print("    [PASS] while loop")
    passed = passed + 1
else:
    print("    [FAIL] while loop")
    failed = failed + 1

print("")
print("describe Parser function definitions:")

print("  it parses function definitions:")
fn add(a, b):
    return a + b
if add(2, 3) == 5:
    print("    [PASS] function definition and call")
    passed = passed + 1
else:
    print("    [FAIL] function definition")
    failed = failed + 1

print("  it parses lambda expressions:")
let double = \x: x * 2
if double(5) == 10:
    print("    [PASS] lambda expression")
    passed = passed + 1
else:
    print("    [FAIL] lambda expression")
    failed = failed + 1

# Documentation
print("")
print("============================================================")
print("  GENERATED DOCUMENTATION")
print("============================================================")
print("")
print("# {FEATURE.name}")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5")
print("**Status:** {FEATURE.status}")
print("**Implementation:** {FEATURE.impl_type}")
print("")
print("## Description")
print("")
print(FEATURE.description)
print("")
print("## Implementation Files")
for file in FEATURE.files:
    print("- `{file}`")
print("")
print("## Dependencies")
print("Depends on: {FEATURE.dependencies}")
print("")
print("## Notes")
print(FEATURE.notes)

# Summary
print("")
print("============================================================")
print("  TEST SUMMARY")
print("============================================================")
print("Passed: {passed}")
print("Failed: {failed}")
if failed == 0:
    print("All tests PASSED!")
print("============================================================")
