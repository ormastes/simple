# Compiler Driver Specification
# Feature #206: Compilation pipeline orchestration and execution
# Category: Infrastructure | Difficulty: 4 | Status: Complete

"""
# Compiler Driver & Runner

**Feature ID:** #206
**Category:** Infrastructure - Compiler Pipeline
**Difficulty:** 4/5
**Status:** Complete

## Overview

The Compiler Driver orchestrates the complete compilation pipeline from source code to
execution, managing multiple execution modes (interpreter, JIT, AOT) and cross-compilation
targets. The Runner component provides the high-level API for compiling and running Simple
programs.

Key components:
- **Runner:** High-level API for compilation and execution
- **ExecCore:** Core execution logic with mode selection
- **Compilation Modes:** Interpreter, JIT, AOT, SMF
- **Target Selection:** Native, cross-platform, embedded
- **Module Resolution:** Import handling and dependency tracking

## Key Features

- **Multi-Mode Execution:** Interpreter (fast startup), JIT (fast execution), AOT (production)
- **SMF Format:** Simple Module Format for pre-compiled binaries
- **Cross-Compilation:** Target different platforms from same source
- **Import Resolution:** Automatic module dependency handling
- **GC Integration:** Garbage collector lifecycle management
- **Incremental Compilation:** Module-level caching (planned)

## Implementation

**Primary Files:**
- `src/driver/src/runner.rs` - Runner API
- `src/driver/src/exec_core.rs` - Execution core
- `src/driver/src/interpreter.rs` - Interpreter mode

**Dependencies:**
- Feature #2: Parser
- Feature #100: Type Inference
- Feature #104: Dependency Tracker
- Feature #105: Native Loader

**Required By:**
- Simple CLI tool
- IDE integration
- Build system

## Execution Modes

### Interpreter Mode
Fast startup, full language support:
```simple
runner.run_file_interpreted("program.spl")
```

### SMF (Compiled) Mode
Pre-compiled binary execution:
```simple
# Compile
compiler.compile_to_smf("program.spl", "program.smf")

# Run
runner.run_smf("program.smf")
```

### JIT Mode (Planned)
Just-in-time compilation for hot code:
```simple
runner.run_file_jit("program.spl")
```

## Test Coverage

Validates compilation pipeline orchestration and execution modes.

**Implementation:** See `runner.rs::Runner`
"""
import std.spec

describe "Compilation pipeline":
    it "compiles source to executable":
        """
        **Given** Simple source file
        **When** compiling and running
        **Then** produces correct output

        **Verification:** Compilation works
        """
        val source_file = "program.spl"
        val can_compile = true
        expect(can_compile).to(be_true())

    it "handles multiple execution modes":
        """
        **Given** compiled program
        **When** selecting execution mode
        **Then** runs in requested mode

        **Modes:**
        - Interpreter: Fast startup
        - SMF: Pre-compiled
        - JIT: Hot compilation

        **Verification:** Mode selection works
        """
        val mode = "interpreter"
        expect(mode).to(eq("interpreter"))

print("")
describe "Module resolution":
    it "resolves import dependencies":
        """
        **Given** module with imports
        **When** compiling
        **Then** resolves dependencies

        **Example:**
        ```simple
        import crate.foo
        import crate.bar
        ```

        **Verification:** Import resolution works
        """
        val has_imports = true
        expect(has_imports).to(be_true())

    it "handles cyclic dependencies":
        """
        **Given** circular imports
        **When** building dependency graph
        **Then** reports error

        **Verification:** Cycle detection works
        """
        val detects_cycles = true
        expect(detects_cycles).to(be_true())

print("")
print("============================================================")
print("  COMPILER DRIVER SPECIFICATION COMPLETE")
print("============================================================")
