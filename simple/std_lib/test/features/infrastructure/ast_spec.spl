# AST Feature Specification
# Feature #3: Abstract Syntax Tree parsing
# Category: Infrastructure | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 3,
    name: 'AST',
    category: 'Infrastructure',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/lexer_parser.md',
    files: [
        'src/parser/src/ast.rs',
        'src/parser/src/expressions/mod.rs',
        'src/parser/src/statements/mod.rs'
    ],
    tests: [
        'src/driver/tests/runner_tests.rs'
    ],
    description: 'Abstract Syntax Tree for all Simple language constructs. Parses literals, expressions, statements, patterns, and type annotations into structured tree representation.',
    code_examples: [],
    dependencies: [1, 2],
    required_by: [4],
    notes: 'AST nodes use spans for error reporting. Pratt parser for expressions with correct precedence.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  AST FEATURE SPECIFICATION (#3)')
print('  Category: Infrastructure | Difficulty: 3 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Literal Parsing
# -----------------------------------------------------

print('describe Literal parsing:')
print('  context integer literals:')
print('    it parses decimal integers:')

val dec = 42
if dec == 42:
    print('      [PASS] decimal integer')
    passed = passed + 1
else:
    print('      [FAIL] decimal integer')
    failed = failed + 1

print('    it parses negative integers:')

val neg = -100
if neg == -100:
    print('      [PASS] negative integer')
    passed = passed + 1
else:
    print('      [FAIL] negative integer')
    failed = failed + 1

print('')
print('  context f32 literals:')
print('    it parses floats:')

val f = 3.14
if f > 3.0 and f < 4.0:
    print('      [PASS] f32 literal')
    passed = passed + 1
else:
    print('      [FAIL] f32 literal')
    failed = failed + 1

print('')
print('  context boolean literals:')
print('    it parses true and false:')

val t = true
val f_bool = false
if t and not f_bool:
    print('      [PASS] boolean literals')
    passed = passed + 1
else:
    print('      [FAIL] boolean literals')
    failed = failed + 1

print('')
print('  context string literals:')
print('    it parses double-quoted strings:')

val s = "hello"
if s == "hello":
    print('      [PASS] double-quoted string')
    passed = passed + 1
else:
    print('      [FAIL] double-quoted string')
    failed = failed + 1

print('    it parses raw strings:')

val raw = 'hello world'
if raw == "hello world":
    print('      [PASS] raw string')
    passed = passed + 1
else:
    print('      [FAIL] raw string')
    failed = failed + 1

# -----------------------------------------------------
# Expression Parsing
# -----------------------------------------------------

print('')
print('describe Expression parsing:')
print('  context binary operators:')
print('    it parses arithmetic:')

val arith = 2 + 3 * 4 - 1
if arith == 13:
    print('      [PASS] arithmetic precedence')
    passed = passed + 1
else:
    print('      [FAIL] arithmetic precedence')
    failed = failed + 1

print('    it parses comparisons:')

val cmp = 5 > 3 and 2 <= 2
if cmp:
    print('      [PASS] comparisons')
    passed = passed + 1
else:
    print('      [FAIL] comparisons')
    failed = failed + 1

print('')
print('  context unary operators:')
print('    it parses negation:')

val x = 10
if -x == -10:
    print('      [PASS] negation')
    passed = passed + 1
else:
    print('      [FAIL] negation')
    failed = failed + 1

print('    it parses logical not:')

if not false:
    print('      [PASS] logical not')
    passed = passed + 1
else:
    print('      [FAIL] logical not')
    failed = failed + 1

print('')
print('  context parentheses:')
print('    it respects grouping:')

val grouped = (2 + 3) * 4
if grouped == 20:
    print('      [PASS] parentheses grouping')
    passed = passed + 1
else:
    print('      [FAIL] parentheses grouping')
    failed = failed + 1

# -----------------------------------------------------
# Collection Literals
# -----------------------------------------------------

print('')
print('describe Collection literals:')
print('  context array literals:')
print('    it parses arrays:')

val arr = [1, 2, 3, 4, 5]
if arr.len() == 5 and arr[0] == 1:
    print('      [PASS] array literal')
    passed = passed + 1
else:
    print('      [FAIL] array literal')
    failed = failed + 1

print('')
print('  context tuple literals:')
print('    it parses tuples:')

val tup = (10, 20, 30)
if tup[0] == 10 and tup[2] == 30:
    print('      [PASS] tuple literal')
    passed = passed + 1
else:
    print('      [FAIL] tuple literal')
    failed = failed + 1

print('')
print('  context dict literals:')
print('    it parses dicts:')

val d = {"a": 1, "b": 2}
if d["a"] == 1:
    print('      [PASS] dict literal')
    passed = passed + 1
else:
    print('      [FAIL] dict literal')
    failed = failed + 1

# -----------------------------------------------------
# Type Annotations
# -----------------------------------------------------

print('')
print('describe Type annotations:')
print('  context basic types:')
print('    it parses type annotations:')

val typed: i64 = 42
if typed == 42:
    print('      [PASS] basic type annotation')
    passed = passed + 1
else:
    print('      [FAIL] basic type annotation')
    failed = failed + 1

print('')
print('  context generic types:')
print('    it parses generic annotations:')

val items: List<i64> = [1, 2, 3]
if items.len() == 3:
    print('      [PASS] generic type annotation')
    passed = passed + 1
else:
    print('      [FAIL] generic type annotation')
    failed = failed + 1

# -----------------------------------------------------
# Function Definitions
# -----------------------------------------------------

print('')
print('describe Function definitions:')
print('  context basic function:')
print('    it parses function def:')

fn add(a, b):
    return a + b

if add(15, 27) == 42:
    print('      [PASS] function definition')
    passed = passed + 1
else:
    print('      [FAIL] function definition')
    failed = failed + 1

print('')
print('  context typed function:')
print('    it parses with return type:')

fn multiply(a: i64, b: i64) -> i64:
    return a * b

if multiply(6, 7) == 42:
    print('      [PASS] typed function')
    passed = passed + 1
else:
    print('      [FAIL] typed function')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# AST')
print('')
print('**Feature ID:** #3')
print('**Category:** Infrastructure')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## AST Node Categories')
print('')
print('| Category | Examples |')
print('|----------|----------|')
print('| Literals | i32, f32, bool, text |')
print('| Expressions | Binary, Unary, Call, Index |')
print('| Statements | Let, If, Match, Loop |')
print('| Patterns | Literal, Variable, Enum |')
print('| Types | Basic, Generic, Capability |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
