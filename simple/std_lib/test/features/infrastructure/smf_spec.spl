# SMF Binary Format Feature Specification
# Feature #9: Simple Module Format
# Category: Infrastructure | Difficulty: 4 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 9,
    name: 'SMF Binary Format',
    category: 'Infrastructure',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'src/loader/src/smf/mod.rs',
    files: [
        'src/loader/src/smf/header.rs',
        'src/loader/src/smf/section.rs',
        'src/loader/src/smf/symbol.rs',
        'src/loader/src/smf/reloc.rs',
        'src/loader/src/loader.rs',
        'src/loader/src/module.rs'
    ],
    tests: [
        'src/driver/tests/runner_tests.rs'
    ],
    description: 'Simple Module Format - binary executable format for compiled Simple programs. Supports sections, symbols, relocations, and memory mapping for efficient loading and execution.',
    code_examples: [],
    dependencies: [5],
    required_by: [],
    notes: 'Magic: SMF\\0. Sections: Code, Data, RoData, BSS, Reloc, SymTab, StrTab, Debug. Supports 64-bit architectures.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  SMF BINARY FORMAT FEATURE SPECIFICATION (#9)')
print('  Category: Infrastructure | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Header Structure
# -----------------------------------------------------

print('describe Header structure:')
print('  context magic number:')
print('    it identifies SMF files:')

struct SmfHeader:
    magic: text
    version_major: i64
    version_minor: i64
    platform: i64
    arch: i64
    flags: i64
    section_count: i64
    entry_point: i64

fn create_header() -> SmfHeader:
    return SmfHeader {
        magic: "SMF",
        version_major: 1,
        version_minor: 0,
        platform: 1,
        arch: 64,
        flags: 1,
        section_count: 5,
        entry_point: 4096
    }

val header = create_header()
if header.magic == "SMF":
    print('      [PASS] magic number')
    passed = passed + 1
else:
    print('      [FAIL] magic number')
    failed = failed + 1

print('    it stores version info:')

if header.version_major == 1 and header.version_minor == 0:
    print('      [PASS] version info')
    passed = passed + 1
else:
    print('      [FAIL] version info')
    failed = failed + 1

print('')
print('  context platform info:')
print('    it stores architecture:')

if header.arch == 64:
    print('      [PASS] architecture')
    passed = passed + 1
else:
    print('      [FAIL] architecture')
    failed = failed + 1

print('    it stores entry point:')

if header.entry_point == 4096:
    print('      [PASS] entry point')
    passed = passed + 1
else:
    print('      [FAIL] entry point')
    failed = failed + 1

# -----------------------------------------------------
# Section Types
# -----------------------------------------------------

print('')
print('describe Section types:')
print('  context code section:')
print('    it holds executable code:')

struct Section:
    section_type: text
    flags: i64
    offset: i64
    size: i64
    name: text

val code_section = Section {
    section_type: "Code",
    flags: 5,
    offset: 4096,
    size: 8192,
    name: ".text"
}
if code_section.section_type == "Code" and code_section.flags == 5:
    print('      [PASS] code section')
    passed = passed + 1
else:
    print('      [FAIL] code section')
    failed = failed + 1

print('')
print('  context data section:')
print('    it holds initialized data:')

val data_section = Section {
    section_type: "Data",
    flags: 3,
    offset: 12288,
    size: 1024,
    name: ".data"
}
if data_section.section_type == "Data" and data_section.flags == 3:
    print('      [PASS] data section')
    passed = passed + 1
else:
    print('      [FAIL] data section')
    failed = failed + 1

print('')
print('  context rodata section:')
print('    it holds read-only data:')

val rodata_section = Section {
    section_type: "RoData",
    flags: 1,
    offset: 13312,
    size: 512,
    name: ".rodata"
}
if rodata_section.section_type == "RoData" and rodata_section.flags == 1:
    print('      [PASS] rodata section')
    passed = passed + 1
else:
    print('      [FAIL] rodata section')
    failed = failed + 1

print('')
print('  context bss section:')
print('    it holds uninitialized data:')

val bss_section = Section {
    section_type: "Bss",
    flags: 2,
    offset: 0,
    size: 2048,
    name: ".bss"
}
if bss_section.section_type == "Bss":
    print('      [PASS] bss section')
    passed = passed + 1
else:
    print('      [FAIL] bss section')
    failed = failed + 1

# -----------------------------------------------------
# Section Flags
# -----------------------------------------------------

print('')
print('describe Section flags:')
print('  context permission flags:')
print('    it marks readable sections:')

fn is_readable(flags: i64) -> bool:
    return (flags % 2) == 1

if is_readable(code_section.flags):
    print('      [PASS] readable flag')
    passed = passed + 1
else:
    print('      [FAIL] readable flag')
    failed = failed + 1

print('    it marks executable sections:')

fn is_executable(flags: i64) -> bool:
    return flags >= 4

if is_executable(code_section.flags):
    print('      [PASS] executable flag')
    passed = passed + 1
else:
    print('      [FAIL] executable flag')
    failed = failed + 1

print('    it marks writable sections:')

fn is_writable(flags: i64) -> bool:
    return (flags / 2) % 2 == 1

if is_writable(data_section.flags):
    print('      [PASS] writable flag')
    passed = passed + 1
else:
    print('      [FAIL] writable flag')
    failed = failed + 1

# -----------------------------------------------------
# Symbol Table
# -----------------------------------------------------

print('')
print('describe Symbol table:')
print('  context symbol entries:')
print('    it stores function symbols:')

struct Symbol:
    name: text
    sym_type: text
    address: i64
    size: i64
    exported: bool

val func_sym = Symbol {
    name: "main",
    sym_type: "Function",
    address: 4096,
    size: 256,
    exported: true
}
if func_sym.sym_type == "Function" and func_sym.exported:
    print('      [PASS] function symbol')
    passed = passed + 1
else:
    print('      [FAIL] function symbol')
    failed = failed + 1

print('    it stores data symbols:')

val data_sym = Symbol {
    name: "GLOBAL_VAR",
    sym_type: "Data",
    address: 12288,
    size: 8,
    exported: false
}
if data_sym.sym_type == "Data":
    print('      [PASS] data symbol')
    passed = passed + 1
else:
    print('      [FAIL] data symbol')
    failed = failed + 1

print('')
print('  context symbol lookup:')
print('    it finds by name:')

fn find_symbol(symbols: List<Symbol>, name: text) -> i64:
    var i = 0
    while i < symbols.len():
        if symbols[i].name == name:
            return symbols[i].address
        i = i + 1
    return 0

val symbols = [func_sym, data_sym]
if find_symbol(symbols, "main") == 4096:
    print('      [PASS] symbol lookup')
    passed = passed + 1
else:
    print('      [FAIL] symbol lookup')
    failed = failed + 1

# -----------------------------------------------------
# Relocations
# -----------------------------------------------------

print('')
print('describe Relocations:')
print('  context relocation entries:')
print('    it stores relocation info:')

struct Relocation:
    offset: i64
    sym_index: i64
    reloc_type: text
    addend: i64

val reloc = Relocation {
    offset: 4128,
    sym_index: 1,
    reloc_type: "Abs64",
    addend: 0
}
if reloc.reloc_type == "Abs64":
    print('      [PASS] relocation entry')
    passed = passed + 1
else:
    print('      [FAIL] relocation entry')
    failed = failed + 1

print('    it applies relocations:')

fn apply_reloc(base: i64, reloc: Relocation, sym_addr: i64) -> i64:
    return sym_addr + reloc.addend

val resolved = apply_reloc(0, reloc, 12288)
if resolved == 12288:
    print('      [PASS] relocation apply')
    passed = passed + 1
else:
    print('      [FAIL] relocation apply')
    failed = failed + 1

# -----------------------------------------------------
# Module Loading
# -----------------------------------------------------

print('')
print('describe Module loading:')
print('  context memory mapping:')
print('    it allocates sections:')

struct LoadedSection:
    name: text
    base_addr: i64
    size: i64

fn load_sections(sections: List<Section>) -> List<LoadedSection>:
    var loaded = []
    var addr = 4096
    var i = 0
    while i < sections.len():
        loaded = loaded + [LoadedSection {
            name: sections[i].name,
            base_addr: addr,
            size: sections[i].size
        }]
        addr = addr + sections[i].size
        i = i + 1
    return loaded

val sections_to_load = [code_section, data_section]
val loaded = load_sections(sections_to_load)
if loaded.len() == 2 and loaded[0].base_addr == 4096:
    print('      [PASS] section allocation')
    passed = passed + 1
else:
    print('      [FAIL] section allocation')
    failed = failed + 1

print('')
print('  context entry point:')
print('    it locates main entry:')

struct LoadedModule:
    entry_point: i64
    sections: List<LoadedSection>
    symbols: List<Symbol>

val loaded_mod = LoadedModule {
    entry_point: 4096,
    sections: loaded,
    symbols: symbols
}
if loaded_mod.entry_point == 4096:
    print('      [PASS] entry point')
    passed = passed + 1
else:
    print('      [FAIL] entry point')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# SMF Binary Format')
print('')
print('**Feature ID:** #9')
print('**Category:** Infrastructure')
print('**Difficulty:** Level 4/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## File Structure')
print('')
print('```')
print('+------------------+')
print('| SMF Header       |  Magic, version, flags')
print('+------------------+')
print('| Section Table    |  Section descriptors')
print('+------------------+')
print('| .text (Code)     |  Executable code')
print('+------------------+')
print('| .data (Data)     |  Initialized data')
print('+------------------+')
print('| .rodata (RoData) |  Read-only data')
print('+------------------+')
print('| .bss (Bss)       |  Uninitialized data')
print('+------------------+')
print('| Symbol Table     |  Function/data symbols')
print('+------------------+')
print('| Relocations      |  Address fixups')
print('+------------------+')
print('```')
print('')
print('## Section Types')
print('')
print('| Type | Purpose | Flags |')
print('|------|---------|-------|')
print('| Code | Executable instructions | R+X |')
print('| Data | Initialized globals | R+W |')
print('| RoData | Constants, strings | R |')
print('| Bss | Zero-initialized data | R+W |')
print('| SymTab | Symbol table | R |')
print('| StrTab | text table | R |')
print('| Debug | Debug information | R |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
