"""
# Named Argument with Equals Syntax Specification

**Feature IDs:** #NAMED-ARG-EQUALS
**Category:** Syntax
**Status:** Implemented

Named arguments allow passing function arguments by name rather than position.
Simple supports both colon syntax `name: value` and equals syntax `name=value`
for named arguments, providing flexibility in coding style.

## Syntax

```simple
# Colon syntax (preferred for readability)
connect(host: "localhost", port: 8080)

# Equals syntax (concise, especially for single args)
Point(x=3, y=4)

# Mixed with positional
greet("Hello", name="World")
```

## Key Behaviors

- Named arguments can appear in any order
- Named arguments can be mixed with positional arguments
- Positional arguments must come before named arguments
- Both `name: value` and `name=value` syntax are supported
"""
use std.spec.*

describe "Named Arguments with Equals Syntax":
    """
    ## Named Argument Specification

    Named arguments provide explicit parameter binding by name, improving
    code readability and allowing flexible argument ordering. This test
    suite verifies:
    - Basic named argument syntax with `=` and `:`
    - Mixing positional and named arguments
    - Arbitrary ordering of named arguments
    - Named arguments with default parameter values
    - Named arguments in struct construction
    """

    context "basic named arguments with equals":
        it "passes single named argument":
            fn greet(name: text) -> text:
                "Hello, {name}!"
            expect greet(name="World") == "Hello, World!"

        it "passes multiple named arguments":
            fn format_point(x: i64, y: i64) -> text:
                "({x}, {y})"
            expect format_point(x=3, y=4) == "(3, 4)"

        it "allows reordered named arguments":
            fn format_point(x: i64, y: i64) -> text:
                "({x}, {y})"
            expect format_point(y=4, x=3) == "(3, 4)"

    context "basic named arguments with colon":
        it "passes single named argument with colon":
            fn greet(name: text) -> text:
                "Hello, {name}!"
            expect greet(name: "World") == "Hello, World!"

        it "passes multiple named arguments with colon":
            fn format_point(x: i64, y: i64) -> text:
                "({x}, {y})"
            expect format_point(x: 3, y: 4) == "(3, 4)"

        it "allows reordered named arguments with colon":
            fn format_point(x: i64, y: i64) -> text:
                "({x}, {y})"
            expect format_point(y: 4, x: 3) == "(3, 4)"

    context "mixed positional and named arguments":
        it "combines positional with named equals":
            fn connect(host: text, port: i64) -> text:
                "{host}:{port}"
            expect connect("localhost", port=8080) == "localhost:8080"

        it "combines positional with named colon":
            fn connect(host: text, port: i64) -> text:
                "{host}:{port}"
            expect connect("localhost", port: 8080) == "localhost:8080"

        it "uses multiple positional then named":
            fn format_record(id: i64, name: text, active: bool) -> text:
                "{id}: {name} (active={active})"
            expect format_record(1, "Alice", active=true) == "1: Alice (active=true)"

    context "named arguments with default values":
        it "uses default when named arg omitted":
            fn create_config(host: text, port: i64 = 80, timeout: i64 = 30) -> text:
                "{host}:{port} (timeout={timeout})"
            expect create_config(host="example.com") == "example.com:80 (timeout=30)"

        it "overrides default with named arg":
            fn create_config(host: text, port: i64 = 80, timeout: i64 = 30) -> text:
                "{host}:{port} (timeout={timeout})"
            expect create_config(host="example.com", port=443) == "example.com:443 (timeout=30)"

        it "overrides multiple defaults":
            fn create_config(host: text, port: i64 = 80, timeout: i64 = 30) -> text:
                "{host}:{port} (timeout={timeout})"
            expect create_config(host="example.com", port=443, timeout=60) == "example.com:443 (timeout=60)"

        it "overrides defaults in any order":
            fn create_config(host: text, port: i64 = 80, timeout: i64 = 30) -> text:
                "{host}:{port} (timeout={timeout})"
            expect create_config(host="example.com", timeout=120, port=8080) == "example.com:8080 (timeout=120)"

    context "struct construction with named arguments":
        it "constructs struct with equals syntax":
            struct Point:
                x: i64
                y: i64
            val p = Point(x=10, y=20)
            expect p.x == 10
            expect p.y == 20

        it "constructs struct with colon syntax":
            struct Point:
                x: i64
                y: i64
            val p = Point(x: 10, y: 20)
            expect p.x == 10
            expect p.y == 20

        it "allows reordered struct fields":
            struct Point:
                x: i64
                y: i64
            val p = Point(y=20, x=10)
            expect p.x == 10
            expect p.y == 20

        it "constructs complex struct":
            struct Person:
                name: text
                age: i64
                active: bool
            val person = Person(name="Alice", age=30, active=true)
            expect person.name == "Alice"
            expect person.age == 30
            expect person.active == true

    context "edge cases":
        it "handles single character parameter names":
            fn f(a: i64, b: i64) -> i64:
                a + b
            expect f(a=1, b=2) == 3

        it "handles longer parameter names":
            fn calculate(first_operand: i64, second_operand: i64) -> i64:
                first_operand * second_operand
            expect calculate(first_operand=5, second_operand=6) == 30

        it "handles underscored parameter names":
            fn process(input_value: i64, max_retries: i64) -> i64:
                input_value * max_retries
            expect process(input_value=10, max_retries=3) == 30
