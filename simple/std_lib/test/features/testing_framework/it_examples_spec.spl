# It Examples Feature Specification
# Feature #182: BDD it blocks for test examples
# Category: Testing Framework | Difficulty: 2 | Status: Complete

"""
It Examples - Feature #182

Overview:
    BDD it blocks for defining individual test examples. Each it block represents
    a single test case with description and assertion block. Test examples are
    collected during definition phase and executed during run phase.

Syntax:
    it "adds two numbers":
        val result = 1 + 2
        expect(result).to eq(3)

    skip "not implemented yet":
        pass

Implementation:
    - it creates test case with description
    - Executes test body with assertion block
    - Supports descriptive names for clarity
    - skip marks tests as pending
    - Tracks test results (pass/fail/skip)
    - Multiple assertions per test allowed

Notes:
    - Test examples are collected during definition phase
    - Executed during run phase with proper hook execution
    - Supports pending/skipped tests
"""

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 182,
    name: 'It Examples',
    category: 'Testing Framework',
    difficulty: 2,
    status: 'Complete',
    impl_type: 'Simple',
    spec_ref: 'doc/spec/testing/testing_bdd_framework.md',
    files: [
        'simple/std_lib/src/spec/dsl.spl'
    ],
    tests: [
        'simple/std_lib/test/system/spec/spec_framework_spec.spl'
    ],
    description: 'BDD it blocks for defining individual test examples. Each it block represents a single test case with description and assertion block.',
    code_examples: [],
    dependencies: [180, 181],
    required_by: [183, 184],
    notes: 'Test examples are collected during definition phase. Executed during run phase with proper hook execution.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  IT EXAMPLES FEATURE SPECIFICATION (#182)')
print('  Category: Testing Framework | Difficulty: 2 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Test Definition
# -----------------------------------------------------

print('describe Test definition:')
print('  context it defines tests:')
print('    it creates a test case:')

struct TestCase:
    description: text
    pending: bool

fn create_test(desc: text) -> TestCase:
    return TestCase { description: desc, pending: false }

val test = create_test("adds two numbers")
if test.description == "adds two numbers":
    print('      [PASS] creates test case')
    passed = passed + 1
else:
    print('      [FAIL] creates test case')
    failed = failed + 1

print('    it supports descriptive names:')

val descriptive = create_test("returns the sum of all elements when called with a non-empty array")
if descriptive.description.len() > 50:
    print('      [PASS] descriptive names')
    passed = passed + 1
else:
    print('      [FAIL] descriptive names')
    failed = failed + 1

# -----------------------------------------------------
# Test Execution
# -----------------------------------------------------

print('')
print('describe Test execution:')
print('  context it runs test blocks:')
print('    it executes the test body:')

fn test_body() -> i64:
    return 1 + 1

if test_body() == 2:
    print('      [PASS] executes test body')
    passed = passed + 1
else:
    print('      [FAIL] executes test body')
    failed = failed + 1

print('    it captures test results:')

struct TestResult:
    test_passed: bool
    message: text

fn run_test(condition: bool) -> TestResult:
    if condition:
        return TestResult { test_passed: true, message: "success" }
    return TestResult { test_passed: false, message: "failure" }

val result = run_test(true)
if result.test_passed:
    print('      [PASS] captures results')
    passed = passed + 1
else:
    print('      [FAIL] captures results')
    failed = failed + 1

# -----------------------------------------------------
# Multiple Assertions
# -----------------------------------------------------

print('')
print('describe Multiple assertions:')
print('  context it supports multiple checks:')
print('    it runs multiple assertions:')

val a = 1 + 1
val b = 2 * 2
val c = 3 - 1
if a == 2 and b == 4 and c == 2:
    print('      [PASS] multiple assertions')
    passed = passed + 1
else:
    print('      [FAIL] multiple assertions')
    failed = failed + 1

print('    it stops on first failure:')

fn check_all(vals: List<i64>) -> bool:
    var all_positive = true
    var i = 0
    while i < vals.len():
        if vals[i] <= 0:
            all_positive = false
        i = i + 1
    return all_positive

if check_all([1, 2, 3, 4, 5]):
    print('      [PASS] checks allvalues')
    passed = passed + 1
else:
    print('      [FAIL] checks allvalues')
    failed = failed + 1

# -----------------------------------------------------
# Skip/Pending Tests
# -----------------------------------------------------

print('')
print('describe Skip pending tests:')
print('  context skip marks pending:')
print('    it marks tests as pending:')

fn skip_test(desc: text) -> TestCase:
    return TestCase { description: desc, pending: true }

val skipped = skip_test("not implemented yet")
if skipped.pending:
    print('      [PASS] marks as pending')
    passed = passed + 1
else:
    print('      [FAIL] marks as pending')
    failed = failed + 1

print('    it tracks pending count:')

val tests = [
    TestCase { description: "test1", pending: false },
    TestCase { description: "test2", pending: true },
    TestCase { description: "test3", pending: true }
]

fn count_pending(test_list: List<TestCase>) -> i64:
    var count = 0
    var i = 0
    while i < test_list.len():
        if test_list[i].pending:
            count = count + 1
        i = i + 1
    return count

if count_pending(tests) == 2:
    print('      [PASS] tracks pending count')
    passed = passed + 1
else:
    print('      [FAIL] tracks pending count')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# It Examples')
print('')
print("**Feature ID:** #182")
print("**Category:** Testing Framework")
print("**Difficulty:** Level 2/5")
print("**Status:** Complete")
print("**Implementation:** Simple")
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Usage Example')
print('')
print('```simple')
print('it "adds two numbers":')
print('    val result = 1 + 2')
print('    expect(result).to eq(3)')
print('')
print('skip "not implemented yet":')
print('    # This test is pending')
print('    pass')
print('```')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
