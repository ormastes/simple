# After Each Feature Specification
# Feature #184: BDD after_each hooks for test teardown
# Category: Testing Framework | Difficulty: 2 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 184,
    name: 'After Each Hooks',
    category: 'Testing Framework',
    difficulty: 2,
    status: 'Complete',
    impl_type: 'Simple',
    spec_ref: 'doc/spec/testing/testing_bdd_framework.md',
    files: [
        'simple/std_lib/src/spec/dsl.spl'
    ],
    tests: [
        'simple/std_lib/test/system/spec/spec_framework_spec.spl'
    ],
    description: 'BDD after_each hooks for running cleanup code after each test example. Ensures resources are released and state is cleaned up.',
    code_examples: [],
    dependencies: [183],
    required_by: [],
    notes: 'Runs after each it block. Runs even if test fails. Child hooks run before parent hooks.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  AFTER EACH HOOKS FEATURE SPECIFICATION (#184)')
print('  Category: Testing Framework | Difficulty: 2 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Teardown Definition
# -----------------------------------------------------

print('describe Teardown definition:')
print('  context after_each registers hooks:')
print('    it stores cleanup blocks:')

struct TeardownHook:
    hook_type: text
    cleanup_fn: text

fn create_teardown(name: text) -> TeardownHook:
    return TeardownHook { hook_type: "after_each", cleanup_fn: name }

val hook = create_teardown("close_connection")
if hook.hook_type == "after_each":
    print('      [PASS] stores cleanup blocks')
    passed = passed + 1
else:
    print('      [FAIL] stores cleanup blocks')
    failed = failed + 1

print('    it supports multiple cleanups:')

val hooks = [
    create_teardown("cleanup1"),
    create_teardown("cleanup2")
]
if hooks.len() == 2:
    print('      [PASS] multiple cleanups')
    passed = passed + 1
else:
    print('      [FAIL] multiple cleanups')
    failed = failed + 1

# -----------------------------------------------------
# Teardown Execution
# -----------------------------------------------------

print('')
print('describe Teardown execution:')
print('  context runs after each test:')
print('    it executes cleanup:')

fn cleanup() -> text:
    return "cleaned"

if cleanup() == "cleaned":
    print('      [PASS] executes cleanup')
    passed = passed + 1
else:
    print('      [FAIL] executes cleanup')
    failed = failed + 1

print('    it runs for every test:')

fn count_teardowns(num_tests: i64) -> i64:
    var teardown_count = 0
    var i = 0
    while i < num_tests:
        teardown_count = teardown_count + 1
        i = i + 1
    return teardown_count

if count_teardowns(3) == 3:
    print('      [PASS] runs for every test')
    passed = passed + 1
else:
    print('      [FAIL] runs for every test')
    failed = failed + 1

# -----------------------------------------------------
# Guaranteed Execution
# -----------------------------------------------------

print('')
print('describe Guaranteed execution:')
print('  context runs even on failure:')
print('    it runs after passing tests:')

fn run_with_teardown(test_passes: bool) -> text:
    var teardown_ran = false
    if test_passes:
        teardown_ran = true
    else:
        teardown_ran = true
    if teardown_ran:
        return "teardown executed"
    return "no teardown"

if run_with_teardown(true) == "teardown executed":
    print('      [PASS] runs after passing')
    passed = passed + 1
else:
    print('      [FAIL] runs after passing')
    failed = failed + 1

print('    it runs after failing tests:')

if run_with_teardown(false) == "teardown executed":
    print('      [PASS] runs after failing')
    passed = passed + 1
else:
    print('      [FAIL] runs after failing')
    failed = failed + 1

# -----------------------------------------------------
# Reverse Order
# -----------------------------------------------------

print('')
print('describe Reverse order:')
print('  context child before parent:')
print('    it runs child hooks first:')

struct HookOrder:
    child_hooks: List<text>
    parent_hooks: List<text>

fn get_teardown_order(order: HookOrder) -> List<text>:
    return order.child_hooks + order.parent_hooks

val tear_order = HookOrder { child_hooks: ["child"], parent_hooks: ["parent"] }
val exec_order = get_teardown_order(tear_order)
if exec_order[0] == "child" and exec_order[1] == "parent":
    print('      [PASS] child hooks first')
    passed = passed + 1
else:
    print('      [FAIL] child hooks first')
    failed = failed + 1

print('    it maintains LIFO order:')

fn lifo_teardown(items: List<text>) -> List<text>:
    var reversed = []
    var i = items.len() - 1
    while i >= 0:
        reversed = reversed + [items[i]]
        i = i - 1
    return reversed

val original = ["first", "second", "third"]
val lifo = lifo_teardown(original)
if lifo[0] == "third" and lifo[2] == "first":
    print('      [PASS] LIFO order')
    passed = passed + 1
else:
    print('      [FAIL] LIFO order')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# After Each Hooks')
print('')
print("**Feature ID:** #184")
print("**Category:** Testing Framework")
print("**Difficulty:** Level 2/5")
print("**Status:** Complete")
print("**Implementation:** Simple")
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Usage Example')
print('')
print('```simple')
print('describe "Database":')
print('    after_each:')
print('        db.rollback()')
print('        db.close()')
print('')
print('    it "inserts record":')
print('        db.insert(record)')
print('        expect(db.count).to eq(1)')
print('```')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
