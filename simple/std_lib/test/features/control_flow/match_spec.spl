# Match Expressions Feature Specification
# Feature #90: Pattern matching with match expressions
# Category: Control Flow | Difficulty: 5 | Status: Complete

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

val FEATURE = FeatureMetadata {
    id: 90,
    name: "Match Expressions",
    category: "Control Flow",
    difficulty: 5,
    status: "Complete",
    impl_type: "Rust",
    spec_ref: "doc/spec/functions.md",
    files: [
        "src/compiler/src/interpreter_control.rs",
        "src/parser/src/expressions/mod.rs"
    ],
    tests: [
        "src/driver/tests/interpreter_control.rs"
    ],
    description: "Powerful pattern matching with exhaustiveness checking. Supports literal patterns, variable binding, wildcard (_), guards, and destructuring.",
    code_examples: [
        "# Basic match",
        "val result = matchvalue:",
        "    1 => \"one\"",
        "    2 => \"two\"",
        "    _ => \"other\"",
        "",
        "# Match with guards",
        "val grade = match score:",
        "    n if n >= 90 => \"A\"",
        "    n if n >= 80 => \"B\"",
        "    n if n >= 70 => \"C\"",
        "    _ => \"F\"",
        "",
        "# Match on enums",
        "match option:",
        "    Some(x) => process(x)",
        "    None => default_value"
    ],
    dependencies: [2],
    required_by: [],
    notes: "Level 5 feature. Exhaustiveness checking ensures all cases are handled."
}

print("  MATCH EXPRESSIONS FEATURE SPECIFICATION (#90)")
print("  Category: Control Flow | Difficulty: 5 | Status: Complete")
print("")


describe "Match basic patterns":
    """
    TODO: Add documentation here
    """

        it "matches literal integers":
            """
            TODO: Add documentation here
            """
val val1 = 2
val result1 = match val1:
    1 => "one"
    2 => "two"
    3 => "three"
    _ => "other"
if result1 == "two":
else:

        it "matches literal strings":
            """
            TODO: Add documentation here
            """
val color = "red"
val result2 = match color:
    "red" => 1
    "green" => 2
    "blue" => 3
    _ => 0
if result2 == 1:
else:

        it "uses wildcard pattern":
            """
            TODO: Add documentation here
            """
val val3 = 999
val result3 = match val3:
    1 => "one"
    2 => "two"
    _ => "wildcard"
if result3 == "wildcard":
else:

print("")
describe "Match with variable binding":
    """
    TODO: Add documentation here
    """

        it "binds matchedvalue to variable":
            """
            TODO: Add documentation here
            """
val val4 = 42
val result4 = match val4:
    0 => "zero"
    x => "value is {x}"
if result4 == "value is 42":
else:

print("")
describe "Match as expression":
    """
    TODO: Add documentation here
    """

        it "returnsvalues from branches":
            """
            TODO: Add documentation here
            """
fn classify(n):
    return match n:
        0 => "zero"
        1 => "one"
        _ => "many"

if classify(0) == "zero" and classify(1) == "one" and classify(5) == "many":
else:

        it "works in if-val style":
            """
            TODO: Add documentation here
            """
val opt = Some(42)
val value = match opt:
    Some(x) => x
    None => 0
if value == 42:
else:

print("")
describe "Match exhaustiveness":
    """
    TODO: Add documentation here
    """

        it "requires exhaustive patterns":
            """
            TODO: Add documentation here
            """
val bool_val = true
val result5 = match bool_val:
    true => "yes"
    false => "no"
if result5 == "yes":
else:

# Documentation
print("")
print("  GENERATED DOCUMENTATION")
print("")
print("# {FEATURE.name}")
print("")
print("**Feature ID:** #{FEATURE.id}")
print("**Category:** {FEATURE.category}")
print("**Difficulty:** Level {FEATURE.difficulty}/5 (Expert)")
print("**Status:** {FEATURE.status}")
print("")
print("## Description")
print("")
print(FEATURE.description)
print("")
print("## Code Examples")
print("```simple")
for ex in FEATURE.code_examples:
    print(ex)
print("```")
print("")
print("## Notes")
print(FEATURE.notes)

# Summary
print("")
print("  TEST SUMMARY")
print("Passed: {passed}")
print("Failed: {failed}")
    print("All tests PASSED!")