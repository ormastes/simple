"""
# Pattern Matching (Match Expressions)

**Feature ID:** #90
**Category:** Control Flow
**Difficulty:** 5/5 (Expert)
**Status:** Complete

## Overview

Match expressions in Simple provide powerful pattern matching with exhaustiveness checking, enabling
type-safe branching based on values, structure, and conditions. Unlike simple if/else chains, match
expressions ensure all possible cases are handled at compile time.

Match is an **expression** (not a statement) - it evaluates to a value. Every branch must return a
value of the same type, and the compiler enforces that all possible input values are covered.

## Syntax

### Basic Match Expression

```simple
val result = match value:
    pattern1 => expression1
    pattern2 => expression2
    _ => default_expression
```

**Grammar:**
```
match_expr = 'match' expression ':' NEWLINE INDENT arm+ DEDENT
arm = pattern ('=>' | 'if' guard '=>') expression NEWLINE
pattern = literal | identifier | wildcard | constructor_pattern
wildcard = '_'
guard = expression
```

### Pattern Types

**Literal Patterns:**
```simple
match x:
    1 => "one"
    2 => "two"
    "hello" => "greeting"
    true => "yes"
    _ => "other"
```

**Variable Binding:**
```simple
match x:
    0 => "zero"
    n => "value is {n}"  # n binds to x's value
```

**Wildcard Pattern:**
```simple
match x:
    1 => "one"
    _ => "anything else"  # Catch-all
```

**Enum Destructuring:**
```simple
match option:
    Some(x) => x
    None => 0
```

**Guards (Conditional Patterns):**
```simple
match score:
    n if n >= 90 => "A"
    n if n >= 80 => "B"
    n if n >= 70 => "C"
    _ => "F"
```

### Match as Expression

```simple
# Assign match result
val grade = match score:
    n if n >= 90 => "A"
    _ => "B"

# Return from function
fn classify(n: i32) -> text:
    return match n:
        0 => "zero"
        1 => "one"
        _ => "many"

# Inline in expressions
val message = "You got: " + match result:
    Ok(v) => v
    Err(e) => "error"
```

## Runtime Representation

Match expressions compile to conditional logic that evaluates patterns in order:

```rust
// Conceptual IR for: match x: 1 => "one", 2 => "two", _ => "other"
if x == 1:
    result = "one"
else if x == 2:
    result = "two"
else:
    result = "other"
```

**Pattern Evaluation:**
- Patterns evaluated top-to-bottom
- First matching pattern's expression is evaluated
- Result becomes the match expression's value
- Remaining patterns are skipped

**Exhaustiveness Checking:**
- Compiler verifies all possible values are covered
- Missing cases cause compile error
- Wildcard `_` catches all unmatched values

## Key Properties

**Exhaustiveness:**
- All possible values must be covered
- Compiler error if any case is missing
- Wildcard `_` ensures exhaustiveness

**Expression Nature:**
- Match is an expression, not a statement
- Every branch must return a value
- All branches must return the same type

**Pattern Ordering:**
- Patterns matched top-to-bottom
- First match wins
- Unreachable patterns should be warned (not yet implemented)

**Type Safety:**
- Branch return types must match
- Type checker validates all branches
- No implicit conversions between branch types

**Guards:**
- Arbitrary boolean expressions after `if`
- Evaluated only if pattern matches
- Guard failure continues to next pattern

## Comparison with Other Languages

| Feature | Simple | Rust | Python | JavaScript |
|---------|--------|------|--------|------------|
| Syntax | `match x: pat => expr` | `match x { pat => expr }` | `match x: case pat: expr` | `switch (x) { case pat: expr }` |
| Exhaustiveness | Required | Required | Optional | Optional |
| Expression | Yes | Yes | Yes (3.10+) | No (statement) |
| Guards | `pat if cond =>` | `pat if cond =>` | `case pat if cond:` | N/A |
| Wildcard | `_` | `_` | `_` | `default:` |
| Destructuring | Yes (enums) | Yes (full) | Yes (limited) | No |
| Fallthrough | No | No | No | Yes (default) |

**Key Differences:**
- Simple requires exhaustiveness (like Rust, unlike Python/JS)
- Simple uses `:` and `=>` (Rust uses `{}`)
- Simple match is always an expression (JS switch is statement)
- Simple guards use `if` keyword (Rust also uses `if`)

## Common Patterns

### Literal Matching

```simple
val day_name = match day:
    1 => "Monday"
    2 => "Tuesday"
    3 => "Wednesday"
    4 => "Thursday"
    5 => "Friday"
    6 => "Saturday"
    7 => "Sunday"
    _ => "Invalid day"
```

### Range-Based Classification (with Guards)

```simple
fn grade_letter(score: i32) -> text:
    return match score:
        n if n >= 90 => "A"
        n if n >= 80 => "B"
        n if n >= 70 => "C"
        n if n >= 60 => "D"
        _ => "F"
```

### Option/Result Handling

```simple
# Extract value from Option
val value = match maybe_value:
    Some(x) => x
    None => default_value

# Transform Result
val output = match result:
    Ok(v) => v * 2
    Err(e) => 0
```

### State Machine Transitions

```simple
fn next_state(state: State, event: Event) -> State:
    return match (state, event):
        (Idle, Start) => Running
        (Running, Pause) => Paused
        (Paused, Resume) => Running
        (Running, Stop) => Idle
        _ => state  # No transition
```

### Type-Based Dispatch

```simple
fn handle_value(val: RuntimeValue) -> text:
    return match val:
        Int(n) => "Integer: {n}"
        String(s) => "String: {s}"
        Bool(b) => "Boolean: {b}"
        _ => "Unknown type"
```

## Implementation Files

**Parser:**
- `src/parser/src/expressions/mod.rs` - Match expression parsing
- `src/parser/src/ast.rs` - MatchExpr, Pattern AST nodes

**Type Checker:**
- `src/compiler/src/type_checker.rs` - Exhaustiveness checking
- `src/compiler/src/type_checker.rs` - Branch type unification

**Interpreter:**
- `src/compiler/src/interpreter_control.rs` - Pattern matching evaluation
- `src/compiler/src/interpreter.rs` - Match expression execution

**Tests:**
- `src/driver/tests/interpreter_control.rs` - Rust integration tests
- `simple/std_lib/test/features/control_flow/match_spec.spl` - This file

## Related Features

- **Enums (#15)**: Match is primary way to destructure enums
- **Option/Result (#17)**: Match extracts values safely
- **If Expressions (#8)**: Simple conditional alternative
- **Pattern Matching (#91)**: Full pattern system (planned enhancement)
- **Guards (#92)**: Conditional patterns

## Exhaustiveness Checking

Simple enforces that all possible values are covered in match expressions:

**Complete Coverage:**
```simple
# Bool has 2 values - both covered ✓
match flag:
    true => "yes"
    false => "no"
```

**Incomplete Coverage (Error):**
```simple
# ERROR: Missing false case
match flag:
    true => "yes"
```

**Wildcard Ensures Exhaustiveness:**
```simple
# ✓ Wildcard catches all other values
match number:
    1 => "one"
    2 => "two"
    _ => "other"
```

**Enum Exhaustiveness:**
```simple
# Must handle all enum variants
match option:
    Some(x) => x    # ✓ Covers Some
    None => 0       # ✓ Covers None
```

## Planned Features

**Not Yet Implemented:**
- Tuple patterns: `(x, y) => ...`
- Array patterns: `[first, ...rest] => ...`
- Or patterns: `1 | 2 | 3 => ...`
- Struct patterns: `Point { x, y } => ...`
- Nested patterns: `Some(Some(x)) => ...`
- Pattern guards on literals: `1 if x > 0 => ...`
- Unreachable pattern warnings

**Future Enhancements:**
- Range patterns: `1..10 => ...`
- Slice patterns: `[a, b, ..] => ...`
- Named fields: `Point { x: px, y: py } => ...`
- Type patterns: `x: Int => ...`

## Notes

- Match is Level 5 feature (expert-level complexity)
- Exhaustiveness checking is compile-time guarantee
- Patterns evaluated in declaration order
- Guards allow arbitrary boolean conditions
- All branches must return same type
- Match always returns a value (is expression, not statement)
- Wildcard `_` must be last (matches everything)
"""

import std.spec


describe "Match basic patterns":
    """
    ## Basic Pattern Matching

    Match expressions support literal patterns for integers, strings, booleans, and other primitive types.
    Each pattern is checked in order, and the first matching pattern's expression is evaluated.

    **Supported Literal Patterns:**
    - Integer literals: `1`, `2`, `42`
    - String literals: `"red"`, `"hello"`
    - Boolean literals: `true`, `false`
    - Wildcard: `_` (matches anything)

    **Syntax:**
    ```
    match expression:
        pattern1 => result1
        pattern2 => result2
        _ => default_result
    ```

    **Implementation:** `src/compiler/src/interpreter_control.rs:eval_match()`
    """

    it "matches literal integers":
        """
        **Given** a match expression with integer literal patterns
        **When** matching against an integer value
        **Then** evaluates the expression for the matching pattern

        **Code Example:**
        ```simple
        val val1 = 2
        val result1 = match val1:
            1 => "one"
            2 => "two"
            3 => "three"
            _ => "other"
        assert result1 == "two"
        ```

        **Runtime Behavior:**
        1. Evaluate match target expression (val1)
        2. Compare against each pattern in order
        3. First match: pattern `2` matches value `2`
        4. Evaluate right-hand expression `"two"`
        5. Return that value as match result

        **Pattern Matching:**
        - Literal comparison: `pattern_value == match_value`
        - Order matters: first match wins
        - Unreached patterns ignored

        **Type Requirements:**
        - All branch expressions must return same type
        - Match value and pattern must be comparable types

        **Implementation:**
        - Pattern: `src/parser/src/ast.rs:Pattern::Literal`
        - Matching: Direct equality comparison in interpreter

        **Common Patterns:**
        ```simple
        # Day of week
        val day = match day_num:
            1 => "Monday"
            2 => "Tuesday"
            7 => "Sunday"
            _ => "Invalid"

        # Status codes
        val message = match code:
            200 => "OK"
            404 => "Not Found"
            500 => "Server Error"
            _ => "Unknown"
        ```
        """
        val val1 = 2
        val result1 = match val1:
            1 => "one"
            2 => "two"
            3 => "three"
            _ => "other"
        expect(result1).to(eq("two"))

        it "matches literal strings":
            """
            **Given** a match expression with string literal patterns
            **When** matching against a text value
            **Then** evaluates the expression for the matching string

            **Code Example:**
            ```simple
            val color = "red"
            val result2 = match color:
                "red" => 1
                "green" => 2
                "blue" => 3
                _ => 0
            assert result2 == 1
            ```

            **Runtime Behavior:**
            - String patterns use exact equality comparison
            - Case-sensitive matching
            - First matching string pattern wins

            **String Comparison:**
            - Byte-by-byte comparison
            - `"red" == "red"` → true
            - `"red" == "Red"` → false (case-sensitive)

            **Type Safety:**
            - Match value must be text type
            - All branches return i32 in this example

            **Implementation:**
            - Uses same equality operator as `==`
            - String patterns stored as StringLiteral

            **Common Patterns:**
            ```simple
            # Command parsing
            val action = match command:
                "start" => start_service()
                "stop" => stop_service()
                "restart" => restart_service()
                _ => print_help()

            # File extension handling
            val handler = match extension:
                ".txt" => TextHandler
                ".json" => JsonHandler
                ".xml" => XmlHandler
                _ => DefaultHandler
            ```
            """
        val color = "red"
        val result2 = match color:
            "red" => 1
            "green" => 2
            "blue" => 3
            _ => 0
        expect(result2).to(eq(1))

        it "uses wildcard pattern":
            """
            **Given** a match expression with wildcard pattern `_`
            **When** no literal patterns match
            **Then** wildcard pattern catches all remaining values

            **Code Example:**
            ```simple
            val val3 = 999
            val result3 = match val3:
                1 => "one"
                2 => "two"
                _ => "wildcard"
            assert result3 == "wildcard"
            ```

            **Wildcard Semantics:**
            - Matches any value
            - Does not bind value to variable
            - Typically used as last pattern (catch-all)
            - Ensures exhaustiveness

            **Pattern Ordering:**
            ```simple
            # ✓ Correct: wildcard last
            match x:
                1 => "one"
                _ => "other"

            # ✗ Wrong: wildcard first (unreachable patterns)
            match x:
                _ => "other"    # Catches everything
                1 => "one"      # Never reached
            ```

            **Exhaustiveness:**
            - Wildcard makes any match expression exhaustive
            - Without wildcard, must cover all possible values
            - Wildcard required for open-ended types (i32, text)

            **Implementation:**
            - Pattern: `Pattern::Wildcard`
            - Always matches (no comparison needed)

            **Common Patterns:**
            ```simple
            # Default case
            match status:
                "active" => process()
                "pending" => queue()
                _ => ignore()

            # Catch-all error handling
            match result:
                Ok(v) => v
                _ => default_value
            ```
            """
        val val3 = 999
        val result3 = match val3:
            1 => "one"
            2 => "two"
            _ => "wildcard"
        expect(result3).to(eq("wildcard"))

describe "Match with variable binding":
    """
    ## Variable Binding in Patterns

    Instead of matching specific literals, patterns can bind the matched value to a variable.
    The variable can then be used in the branch expression, including in interpolated strings.

    **Syntax:**
    ```
    match value:
        identifier => expression  # identifier binds to value
    ```

    **Binding Scope:**
    - Variable is scoped to its branch expression only
    - Different branches can use same variable name
    - Variable shadows outer scope bindings

    **Implementation:** `src/compiler/src/interpreter_control.rs:eval_pattern()`
    """

    it "binds matched value to variable":
        """
        **Given** a match expression with variable binding pattern
        **When** pattern matches
        **Then** variable holds the matched value and is usable in expression

        **Code Example:**
        ```simple
        val val4 = 42
        val result4 = match val4:
            0 => "zero"
            x => "value is {x}"  # x binds to 42
        assert result4 == "value is 42"
        ```

        **Variable Binding:**
        - Pattern `x` binds to match value (42)
        - Variable available in right-hand expression
        - Interpolation `{x}` accesses bound value
        - Variable scoped to this branch only

        **Pattern Semantics:**
        - Identifier pattern always matches
        - Acts as catch-all like `_`, but binds value
        - Should be last pattern if used without guard

        **Use in Expression:**
        ```simple
        match num:
            0 => "zero"
            n => "The number is {n}"  # n is available here

        match value:
            x => x * 2  # Can use x in calculations

        match data:
            result => process(result)  # Can pass to functions
        ```

        **Scoping:**
        ```simple
        val x = 10
        val result = match 20:
            x => x + 5  # x shadows outer x, x is 20 here
        # x is 10 here (outer scope restored)
        ```

        **Implementation:**
        - Pattern: `Pattern::Identifier(name)`
        - Binding: Add to match arm's local environment
        - Scope: Branch expression only

        **Common Patterns:**
        ```simple
        # Transform value
        match input:
            0 => "none"
            n => "count: {n}"

        # Use in calculation
        match score:
            0 => "failed"
            s => "earned {s * 10} points"

        # Pass to function
        match data:
            d => validate_and_process(d)
        ```
        """
        val val4 = 42
        val result4 = match val4:
            0 => "zero"
            x => "value is {x}"
        expect(result4).to(eq("value is 42"))

describe "Match as expression":
    """
    ## Match as Expression (Not Statement)

    Match in Simple is an expression that evaluates to a value, not a statement. This means:
        - Match can be assigned to variables
    - Match can be returned from functions
    - Match can be used inline in expressions

    All branches must return values of the same type.

    **Expression Properties:**
    - Evaluates to single value
    - Can appear anywhere expression is allowed
    - Type is union of all branch types

    **Implementation:** Match expressions return RuntimeValue
    """

    it "returns values from branches":
        """
        **Given** a function that returns a match expression
        **When** calling the function
        **Then** match evaluates and function returns the matched branch's value

        **Code Example:**
        ```simple
        fn classify(n):
            return match n:
                0 => "zero"
                1 => "one"
                _ => "many"

        assert classify(0) == "zero"
        assert classify(1) == "one"
        assert classify(5) == "many"
        ```

        **Match as Return Value:**
        - Match expression is evaluated
        - Result is returned directly from function
        - No need for intermediate variable

        **Type Consistency:**
        - All branches return text
        - Function return type inferred as text
        - Type checker validates branch types match

        **Alternatives:**
        ```simple
        # With intermediate variable (less concise)
        fn classify_verbose(n):
            val result = match n:
                0 => "zero"
                1 => "one"
                _ => "many"
            return result

        # Direct return (preferred)
        fn classify_concise(n):
            return match n:
                0 => "zero"
                1 => "one"
                _ => "many"
        ```

        **Implementation:**
        - Match expression evaluates to RuntimeValue
        - Return statement uses that value
        - Same as returning any expression

        **Common Patterns:**
        ```simple
        # Grade calculation
        fn letter_grade(score: i32) -> text:
            return match score:
                n if n >= 90 => "A"
                n if n >= 80 => "B"
                n if n >= 70 => "C"
                _ => "F"

        # Status message
        fn status_message(code: i32) -> text:
            return match code:
                200 => "Success"
                404 => "Not Found"
                500 => "Error"
                _ => "Unknown"
        ```
        """
        fn classify(n):
            return match n:
                0 => "zero"
                1 => "one"
                _ => "many"

        expect(classify(0)).to(eq("zero"))
        expect(classify(1)).to(eq("one"))
        expect(classify(5)).to(eq("many"))

        it "works in if-val style":
            """
            **Given** a match expression on an Option type
            **When** pattern matching to extract value
            **Then** safely handles Some and None cases

            **Code Example:**
            ```simple
            val opt = Some(42)
            val value = match opt:
                Some(x) => x
                None => 0
            assert value == 42
            ```

            **Option Destructuring:**
            - `Some(x)` pattern matches Some variant and binds inner value
            - `x` is the value inside Some (42)
            - `None` pattern matches None variant
            - All possible Option values covered (exhaustive)

            **Type Safety:**
            - Cannot access inner value without matching
            - Compiler ensures both Some and None are handled
            - No null pointer exceptions possible

            **Pattern Structure:**
            - Constructor pattern: `Some(x)`
            - Inner value bound to `x`
            - Can use `x` in branch expression

            **Exhaustiveness:**
            ```simple
            # ✓ Exhaustive: Both variants covered
            match opt:
                Some(x) => x
                None => 0

            # ✗ Non-exhaustive: Missing None case (compile error)
            match opt:
                Some(x) => x
            ```

            **Implementation:**
            - Pattern: `Pattern::Constructor(name, patterns)`
            - Enum variant matching in interpreter
            - Destructuring binds inner values

            **Common Patterns:**
            ```simple
            # Extract with default
            val name = match maybe_name:
                Some(n) => n
                None => "Unknown"

            # Transform inner value
            val doubled = match maybe_num:
                Some(n) => n * 2
                None => 0

            # Chain operations
            val result = match get_value():
                Some(v) => process(v)
                None => default_result()
            ```
            """
            val opt = Some(42)
            val value = match opt:
                Some(x) => x
                None => 0
            expect(value).to(eq(42))

describe "Match exhaustiveness":
    """
    ## Exhaustiveness Checking

    Simple's match expressions require exhaustiveness - all possible values must be covered.
    The compiler validates this at compile time, preventing runtime match failures.

    **Exhaustiveness Requirements:**
    - All enum variants must be handled
    - Finite types (bool) must cover all values
    - Open types (i32, text) require wildcard

    **Compiler Checking:**
    - Type-based analysis
    - Ensures no value can fall through
    - Compile error if incomplete

    **Implementation:** `src/compiler/src/type_checker.rs:check_exhaustiveness()`
    """

    it "requires exhaustive patterns":
        """
        **Given** a match expression on a boolean value
        **When** both true and false cases are provided
        **Then** match is exhaustive and compiles successfully

        **Code Example:**
        ```simple
        val bool_val = true
        val result5 = match bool_val:
            true => "yes"
            false => "no"
        assert result5 == "yes"
        ```

        **Boolean Exhaustiveness:**
        - Bool has exactly 2 values: true, false
        - Both must be covered
        - No wildcard needed (finite type)

        **Exhaustiveness Examples:**
        ```simple
        # ✓ Exhaustive: Both bool values
        match flag:
            true => "on"
            false => "off"

        # ✓ Exhaustive: Wildcard covers remaining
        match flag:
            true => "on"
            _ => "off"

        # ✗ Non-exhaustive: Missing false case
        match flag:
            true => "on"
            # Compile error: false not handled
        ```

        **Compiler Guarantees:**
        - No runtime match failure possible
        - All code paths known at compile time
        - Type safety enforced

        **Other Finite Types:**
        ```simple
        # Enum (must cover all variants)
        match color:
            Red => 1
            Green => 2
            Blue => 3

        # Option (must cover Some and None)
        match maybe:
            Some(x) => x
            None => default

        # Result (must cover Ok and Err)
        match result:
            Ok(v) => v
            Err(e) => handle_error(e)
        ```

        **Implementation:**
        - Type checker analyzes patterns
        - Builds coverage set
        - Verifies all type values covered
        - Emits error if incomplete

        **Common Patterns:**
        ```simple
        # Safe bool handling
        fn bool_to_int(b: bool) -> i32:
            return match b:
                true => 1
                false => 0

        # State transitions (all states handled)
        fn next_state(current: State) -> State:
            return match current:
                Idle => Active
                Active => Done
                Done => Idle
        ```
        """
        val bool_val = true
        val result5 = match bool_val:
            true => "yes"
            false => "no"
        expect(result5).to(eq("yes"))
