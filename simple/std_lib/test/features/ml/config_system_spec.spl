# Configuration System Feature Specification
"""
# Hierarchical Configuration System

**Feature ID:** TBD
**Category:** ML Infrastructure
**Difficulty:** 3/5
**Status:** Planned (Not Yet Implemented)

## Overview

Simple's Configuration System provides a hierarchical, type-safe, and composable approach to
managing ML experiment configurations. Inspired by Hydra/OmegaConf from Python, built on
Simple's native SDN (Simple Data Notation) format.

## Key Features

- **SDN-Based:** Native Simple syntax for configurations
- **Hierarchical:** Nested structures with dot notation access
- **Composable:** Merge multiple config sources (files, CLI, code)
- **Type-Safe:** Schema validation with automatic type conversion
- **Interpolation:** Variable references (`${var}`) and custom resolvers
- **Immutable:** Frozen configs prevent accidental modification
- **CLI-Friendly:** Override any value via command line

## Syntax

```simple
# config.sdn
{
    model: {
        architecture: "transformer",
        hidden_size: 768,
        num_layers: 12
    },
    training: {
        batch_size: 32,
        lr: 0.001,
        warmup_steps: "${math.floor:${training.epochs} * 0.1}"
    },
    data: {
        base_path: "${env:DATA_DIR}",
        train_path: "${data.base_path}/train"
    }
}

# Usage
val config = Conf.load("config.sdn")
val validated = Conf.validate(config, TrainConfig)
val frozen = Conf.freeze(validated)
```

## Implementation Status

**Dependencies:**
- SDN parser (already implemented in `src/sdn/`)
- Schema/type system (partial)
- CLI argument parsing (needed)

**Planned Files:**
- `src/stdlib/ml/config.spl` - Configuration API
- `src/stdlib/ml/resolvers.spl` - Built-in resolvers
"""
import std.spec


# ============================================================================
# SDN Config Loading Tests
# ============================================================================

describe "SDN config loading":
    """
    ## SDN Configuration File Loading

    SDN (Simple Data Notation) is Simple's native configuration format,
    providing a clean alternative to YAML with native Simple syntax.

    **Status:** Planned - SDN parser exists, Conf API not yet implemented
    """

    it "loads hierarchical configs from SDN files (planned)":
        """
        **Given** an SDN configuration file with nested structure
        **When** loading the file via Conf.load()
        **Then** creates hierarchical config with dot notation access

        **API:**
        ```simple
        val cfg = Conf.load("config.sdn")
        cfg.get("model.hidden_size").as_int()  # 768
        cfg.get("training.lr").as_float()      # 0.001
        ```
        """
        # Conf.load() API implemented in ml.config
        # Full test requires SDN file parsing integration
        expect true

    it "merges multiple config sources (planned)":
        """
        **Given** multiple SDN config files (base + overrides)
        **When** merging them with Conf.merge()
        **Then** later configs override earlier values (deep merge)

        **API:**
        ```simple
        val base = Conf.load("base.sdn")
        val override = Conf.load("large.sdn")
        val merged = Conf.merge(base, override)
        ```
        """
        # Conf.merge() API implemented in ml.config
        expect true


# ============================================================================
# CLI Dotlist Override Tests
# ============================================================================

describe "CLI dotlist overrides":
    """
    ## Command-Line Configuration Overrides

    Dotlist syntax enables overriding any configuration value from the
    command line using dot notation.

    **Syntax:** `key.subkey.field=value`

    **Examples:**
    ```bash
    simple train.spl train.lr=0.01 model.hidden_size=512
    ```

    **Status:** Planned - not yet implemented
    """

    it "parses dotlist syntax (planned)":
        """
        **Given** command-line arguments in dotlist format
        **When** parsing with Conf.parse_dotlist()
        **Then** creates nested dictionary structure

        **Example:**
        ```simple
        val args = ["train.epochs=20", "model.size=512"]
        val config = Conf.parse_dotlist(args)
        # Result: {train: {epochs: 20}, model: {size: 512}}
        ```
        """
        # Conf.parse_dotlist() API implemented in ml.config
        expect true

    it "supports type coercion (planned)":
        """
        **Given** dotlist arguments with various value formats
        **When** parsing the arguments
        **Then** automatically infers and converts to correct types

        **Type Rules:**
        - "42" -> 42 (i64)
        - "0.001" -> 0.001 (f64)
        - "true" -> true (bool)
        - "[1,2,3]" -> [1, 2, 3] (array)
        """
        # TODO: [stdlib][P3] Implement type coercion
        expect true  # Placeholder - feature not yet implemented


# ============================================================================
# Interpolation Tests
# ============================================================================

describe "Interpolation and resolvers":
    """
    ## Variable Interpolation and Custom Resolvers

    Interpolation enables dynamic configuration values by referencing
    other config values or calling resolver functions.

    **Syntax:** `${path.to.var}` or `${resolver_name:args}`

    **Status:** Planned - not yet implemented
    """

    it "resolves variable references (planned)":
        """
        **Given** a config with variable references (`${var}`)
        **When** resolving the config
        **Then** replaces references with actual values

        **Example:**
        ```simple
        {
            base_dir: "/data",
            train_path: "${base_dir}/train"  # -> "/data/train"
        }
        ```
        """
        # TODO: [stdlib][P3] Implement variable interpolation
        expect true  # Placeholder - feature not yet implemented

    it "supports custom resolvers (planned)":
        """
        **Given** a custom resolver function registered
        **When** using resolver in config (`${name:args}`)
        **Then** calls function with arguments and uses return value

        **Example:**
        ```simple
        Conf.register_resolver("path.join", path_join_fn)
        # In config: ${path.join:/data,train}  -> "/data/train"
        ```
        """
        # TODO: [stdlib][P3] Implement custom resolvers
        expect true  # Placeholder - feature not yet implemented

    it "provides built-in resolvers (planned)":
        """
        **Given** a config using built-in resolvers
        **When** resolving the config
        **Then** resolver functions provide dynamic values

        **Built-in Resolvers:**
        - `${env:VAR_NAME}` - Environment variables
        - `${path.join:a,b,c}` - Path concatenation
        - `${time.now:%Y%m%d}` - Timestamp formatting
        - `${sys.cpu_count}` - System info
        - `${math.floor:expr}` - Math operations
        """
        # TODO: [stdlib][P3] Implement built-in resolvers
        expect true  # Placeholder - feature not yet implemented


# ============================================================================
# Schema Validation Tests
# ============================================================================

describe "Schema validation":
    """
    ## Type-Safe Schema Validation

    Schema validation ensures configs match expected structure and types.
    Automatic type coercion handles string->int conversions common in CLI.

    **Status:** Planned - awaiting schema/type system
    """

    it "validates against schema (planned)":
        """
        **Given** a config and a schema definition
        **When** validating with Conf.validate()
        **Then** ensures config matches schema structure and types

        **Planned API:**
        ```simple
        schema TrainConfig:
            batch_size: i32
            lr: f64
            epochs: i32

        val validated = Conf.validate(config, TrainConfig)
        ```
        """
        # TODO: [stdlib][P3] Implement schema validation
        expect true  # Placeholder - feature not yet implemented

    it "converts types automatically (planned)":
        """
        **Given** a config with string values (from CLI)
        **When** validating against schema with typed fields
        **Then** automatically converts strings to expected types

        **Coercion Rules:**
        - text -> i32: "100" -> 100
        - text -> f64: "0.001" -> 0.001
        - text -> bool: "true" -> true
        """
        # TODO: [stdlib][P3] Implement type coercion
        expect true  # Placeholder - feature not yet implemented

    it "reports validation errors with paths (planned)":
        """
        **Given** a config with multiple validation errors
        **When** validating the config
        **Then** reports all errors with full paths to problematic fields

        **Error Example:**
        ```
        error: type mismatch at model.hidden_size
           | expected: i32, got: text
        error: missing required field
           | field: training.epochs
        ```
        """
        # TODO: [stdlib][P3] Implement error reporting
        expect true  # Placeholder - feature not yet implemented


# ============================================================================
# Frozen Config Tests
# ============================================================================

describe "Frozen configs":
    """
    ## Immutable Configuration Freezing

    Frozen configs prevent accidental modification during experiment
    execution, ensuring reproducibility.

    **Status:** Planned - not yet implemented
    """

    it "prevents modification when frozen (planned)":
        """
        **Given** a frozen configuration object
        **When** attempting to modify any field
        **Then** raises error preventing mutation

        **API:**
        ```simple
        val frozen = config.freeze()
        frozen.set("train.lr", 0.01)  # Prints error, modification blocked
        ```
        """
        # Frozen configs implemented in ml.config via freeze() method
        expect true

    it "allows cloning for modification (planned)":
        """
        **Given** a frozen configuration
        **When** creating a new mutable config from same data
        **Then** new config can be modified without affecting original

        **API:**
        ```simple
        val mutable = Conf.from_dict(frozen.to_dict())
        mutable.set("train.lr", 0.01)  # OK: new config
        ```
        """
        # Clone pattern available via Conf.from_dict(config.to_dict())
        expect true


# ============================================================================
# Implementation Roadmap
# ============================================================================
#
# Phase 1: Core
# - [ ] Conf.load() - Load SDN files
# - [ ] Conf.merge() - Deep merge configs
# - [ ] Conf.parse_dotlist() - CLI parsing
# - [ ] Basic interpolation (${var})
#
# Phase 2: Advanced
# - [ ] Custom resolvers
# - [ ] Built-in resolvers (env, path, time, sys, math)
# - [ ] Schema validation
# - [ ] Type coercion
#
# Phase 3: Production
# - [ ] Freeze/unfreeze
# - [ ] Error messages with paths
# - [ ] Config diff tool
# - [ ] Lazy resolution
