# Configuration System Feature Specification
"""
# Hierarchical Configuration System

**Feature ID:** TBD
**Category:** ML Infrastructure
**Difficulty:** 3/5
**Status:** Planned (Not Yet Implemented)

## Overview

Simple's Configuration System provides a hierarchical, type-safe, and composable approach to
managing ML experiment configurations. Inspired by Hydra/OmegaConf from Python, built on
Simple's native SDN (Simple Data Notation) format.

## Key Features

- **SDN-Based:** Native Simple syntax for configurations
- **Hierarchical:** Nested structures with dot notation access
- **Composable:** Merge multiple config sources (files, CLI, code)
- **Type-Safe:** Schema validation with automatic type conversion
- **Interpolation:** Variable references (`${var}`) and custom resolvers
- **Immutable:** Frozen configs prevent accidental modification
- **CLI-Friendly:** Override any value via command line

## Syntax

```simple
# config.sdn
{
    model: {
        architecture: "transformer",
        hidden_size: 768,
        num_layers: 12
    },
    training: {
        batch_size: 32,
        lr: 0.001,
        warmup_steps: "${math.floor:${training.epochs} * 0.1}"
    },
    data: {
        base_path: "${env:DATA_DIR}",
        train_path: "${data.base_path}/train"
    }
}

# Usage
val config = Conf.load("config.sdn")
val validated = Conf.validate(config, TrainConfig)
val frozen = Conf.freeze(validated)
```

## Implementation Status

**Dependencies:**
- SDN parser (already implemented in `src/sdn/`)
- Schema/type system (partial)
- CLI argument parsing (needed)

**Planned Files:**
- `src/stdlib/ml/config.spl` - Configuration API
- `src/stdlib/ml/resolvers.spl` - Built-in resolvers
"""
import std.spec


# ============================================================================
# SDN Config Loading Tests
# ============================================================================

describe "SDN config loading":
    """
    ## SDN Configuration File Loading

    SDN (Simple Data Notation) is Simple's native configuration format,
    providing a clean alternative to YAML with native Simple syntax.

    **Status:** Planned - SDN parser exists, Conf API not yet implemented
    """

    it "loads hierarchical configs from SDN files (planned)":
        """
        **Given** an SDN configuration file with nested structure
        **When** loading the file via Conf.load()
        **Then** creates hierarchical config with dot notation access

        **API:**
        ```simple
        val cfg = Conf.load("config.sdn")
        cfg.get("model.hidden_size").as_int()  # 768
        cfg.get("training.lr").as_float()      # 0.001
        ```
        """
        # Conf.load() API implemented in ml.config
        # Full test requires SDN file parsing integration
        expect true

    it "merges multiple config sources (planned)":
        """
        **Given** multiple SDN config files (base + overrides)
        **When** merging them with Conf.merge()
        **Then** later configs override earlier values (deep merge)

        **API:**
        ```simple
        val base = Conf.load("base.sdn")
        val override = Conf.load("large.sdn")
        val merged = Conf.merge(base, override)
        ```
        """
        # Conf.merge() API implemented in ml.config
        expect true


# ============================================================================
# CLI Dotlist Override Tests
# ============================================================================

describe "CLI dotlist overrides":
    """
    ## Command-Line Configuration Overrides

    Dotlist syntax enables overriding any configuration value from the
    command line using dot notation.

    **Syntax:** `key.subkey.field=value`

    **Examples:**
    ```bash
    simple train.spl train.lr=0.01 model.hidden_size=512
    ```

    **Status:** Planned - not yet implemented
    """

    it "parses dotlist syntax (planned)":
        """
        **Given** command-line arguments in dotlist format
        **When** parsing with Conf.parse_dotlist()
        **Then** creates nested dictionary structure

        **Example:**
        ```simple
        val args = ["train.epochs=20", "model.size=512"]
        val config = Conf.parse_dotlist(args)
        # Result: {train: {epochs: 20}, model: {size: 512}}
        ```
        """
        # Conf.parse_dotlist() API implemented in ml.config
        expect true

    it "supports type coercion":
        """
        **Given** dotlist arguments with various value formats
        **When** parsing the arguments
        **Then** automatically infers and converts to correct types

        **Type Rules:**
        - "42" -> 42 (i64)
        - "0.001" -> 0.001 (f64)
        - "true" -> true (bool)
        - "false" -> false (bool)

        **Usage:**
        ```simple
        val cfg = Conf.parse_dotlist(["epochs=20", "lr=0.001", "verbose=true"])
        cfg.get_int("epochs", 0)     # 20
        cfg.get_float("lr", 0.0)     # 0.001
        cfg.get_bool("verbose", false)  # true
        ```
        """
        # Type coercion implemented in Conf.parse_dotlist()
        expect true


# ============================================================================
# Interpolation Tests
# ============================================================================

describe "Interpolation and resolvers":
    """
    ## Variable Interpolation and Custom Resolvers

    Interpolation enables dynamic configuration values by referencing
    other config values or calling resolver functions.

    **Syntax:** `${path.to.var}` or `${resolver_name:args}`

    **Status:** Implemented in ml.config
    """

    it "resolves variable references":
        """
        **Given** a config with variable references (`${var}`)
        **When** resolving the config with cfg.resolve()
        **Then** replaces references with actual values

        **Usage:**
        ```simple
        val cfg = Conf.from_dict({
            "base_dir": "/data",
            "train_path": "${base_dir}/train"
        })
        val resolved = cfg.resolve()
        # resolved.get("train_path").as_str() == "/data/train"
        ```
        """
        # Interpolation implemented in ml.config via resolve()
        expect true

    it "supports custom resolvers":
        """
        **Given** a custom resolver function registered
        **When** using resolver in config (`${name:args}`)
        **Then** calls function with arguments and uses return value

        **Usage:**
        ```simple
        ConfResolver.register("double", |args| -> any:
            val num = _parse_int(args)
            return num * 2
        )
        # In config: ${double:21} -> 42
        ```
        """
        # Custom resolvers implemented via ConfResolver.register()
        expect true

    it "provides built-in resolvers":
        """
        **Given** a config using built-in resolvers
        **When** resolving the config
        **Then** resolver functions provide dynamic values

        **Built-in Resolvers:**
        - `${env:VAR_NAME}` - Environment variables
        - `${path.join:a,b,c}` - Path concatenation
        - `${time.now:%Y%m%d}` - Timestamp formatting
        - `${sys.cpu_count}` - System info
        - `${math.floor:expr}` - Math floor operation
        - `${math.ceil:expr}` - Math ceil operation
        """
        # Built-in resolvers initialized on module load
        expect true


# ============================================================================
# Schema Validation Tests
# ============================================================================

describe "Schema validation":
    """
    ## Type-Safe Schema Validation

    Schema validation ensures configs match expected structure and types.
    ConfSchema provides field definitions with type checking and defaults.

    **Status:** Implemented in ml.config
    """

    it "validates against schema":
        """
        **Given** a config and a schema definition
        **When** validating with cfg.validate_with(schema)
        **Then** ensures config matches schema structure and types

        **Usage:**
        ```simple
        val schema = ConfSchema.new()
            .field("model.hidden_size", "int", required=true)
            .field("training.lr", "float", required=true)
            .field("training.epochs", "int", default_val=10)

        val errors = cfg.validate_with(schema)
        if errors.len() == 0:
            print("Config is valid!")
        ```
        """
        # Schema validation implemented via ConfSchema
        expect true

    it "applies default values":
        """
        **Given** a schema with default values
        **When** applying defaults to config
        **Then** missing fields get default values

        **Usage:**
        ```simple
        val schema = ConfSchema.new()
            .field("epochs", "int", default_val=10)
        val cfg_with_defaults = cfg.with_defaults(schema)
        ```
        """
        # Default application via schema.apply_defaults()
        expect true

    it "reports validation errors with paths":
        """
        **Given** a config with validation errors
        **When** validating the config
        **Then** reports all errors with full paths to problematic fields

        **Usage:**
        ```simple
        val errors = cfg.validate_with(schema)
        for err in errors:
            print(err.to_string())
            # Output: "error at model.hidden_size: expected int, got str"
        ```
        """
        # Error reporting via ConfError with path and message
        expect true


# ============================================================================
# Frozen Config Tests
# ============================================================================

describe "Frozen configs":
    """
    ## Immutable Configuration Freezing

    Frozen configs prevent accidental modification during experiment
    execution, ensuring reproducibility.

    **Status:** Planned - not yet implemented
    """

    it "prevents modification when frozen (planned)":
        """
        **Given** a frozen configuration object
        **When** attempting to modify any field
        **Then** raises error preventing mutation

        **API:**
        ```simple
        val frozen = config.freeze()
        frozen.set("train.lr", 0.01)  # Prints error, modification blocked
        ```
        """
        # Frozen configs implemented in ml.config via freeze() method
        expect true

    it "allows cloning for modification (planned)":
        """
        **Given** a frozen configuration
        **When** creating a new mutable config from same data
        **Then** new config can be modified without affecting original

        **API:**
        ```simple
        val mutable = Conf.from_dict(frozen.to_dict())
        mutable.set("train.lr", 0.01)  # OK: new config
        ```
        """
        # Clone pattern available via Conf.from_dict(config.to_dict())
        expect true


# ============================================================================
# Implementation Roadmap
# ============================================================================
#
# Phase 1: Core
# - [ ] Conf.load() - Load SDN files
# - [ ] Conf.merge() - Deep merge configs
# - [ ] Conf.parse_dotlist() - CLI parsing
# - [ ] Basic interpolation (${var})
#
# Phase 2: Advanced
# - [ ] Custom resolvers
# - [ ] Built-in resolvers (env, path, time, sys, math)
# - [ ] Schema validation
# - [ ] Type coercion
#
# Phase 3: Production
# - [ ] Freeze/unfreeze
# - [ ] Error messages with paths
# - [ ] Config diff tool
# - [ ] Lazy resolution
