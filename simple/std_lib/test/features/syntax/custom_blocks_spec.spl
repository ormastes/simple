"""
# Custom Blocks Feature Specification

**Feature IDs:** #1090-1098
**Category:** Syntax
**Difficulty:** 4/5
**Status:** Planned

## Overview

Custom Blocks embed domain-specific languages (DSLs) inside Simple source code while preserving
LL(1) parseability, deterministic semantics, and tooling support. Blocks are parsed by dedicated
handlers and produce typed values.

**Standard Block Kinds:**
- `m{}` - Mathematics (LaTeX-like input, semantic IR)
- `sh{}` - Portable shell scripting (Bash-like surface, OS-neutral)
- `sql{}` - SQL queries (dialect-tagged, parameter-safe)
- `re{}` - Regular expressions (compiled, typed captures)
- `md{}` - Markdown documents
- `html{}` - HTML content
- `graph{}` - Diagrams (Mermaid/DOT)
- `img{}` - Image embedding/generation

## Syntax

### Block Expression Forms

```simple
# Inline form
val expr = m{ \frac{a}{b} }
val result = sh{ echo "hello" }

# Indented form
val query = sql:
    dialect: postgres
    SELECT * FROM users WHERE id = :id
```

### Grammar

```
BlockExpr ::= BlockKind '{' BlockPayload '}'
BlockStmt ::= BlockKind ':' NEWLINE INDENT BlockLines DEDENT
```

### LL(1) Compatibility

Block kind is always `IDENT` followed by `{` or `:`. Single token lookahead is sufficient.

## Compilation Pipeline

1. Outer parse: `BlockNode(kind, payload, span)` without parsing payload
2. Block resolution: Map `kind` to registered handler
3. Block parse: Handler parses payload into Block AST
4. Validation/typing: Handler produces typed IR
5. Lowering/codegen: IR lowers to runtime calls

"""

import std.spec


# ============================================================================
# Math Block (m{})
# ============================================================================

describe "Math Block m{}":
    """
    ## Math Block - LaTeX-like Input with Semantic IR

    The `m{}` block provides human-friendly math entry similar to LaTeX,
    producing a semantic IR that can be rendered to various formats.

    **Type:** `std.math.Expr`

    **Features:**
    - LaTeX-like operators (`\frac`, `\sqrt`, `\sum`, `\int`)
    - ASCII aliases (`frac(a, b)`, `sqrt(x)`)
    - Implicit multiplication (`2x`, `3(x+1)`)
    - Greek letters (`\alpha`, `\pi`)
    """

    it "parses basic arithmetic":
        """
        Simple arithmetic expressions.
        """
        val expr = m{ 2 + 3 * 4 }
        expect(expr.eval()).to(eq(14))

    it "parses fractions":
        """
        LaTeX-style fractions with `\frac{num}{denom}`.
        """
        val expr = m{ \frac{1}{2} + \frac{1}{4} }
        expect(expr.eval()).to(be_close_to(0.75, 0.001))

    it "parses square roots":
        """
        Square root with `\sqrt{x}`.
        """
        val expr = m{ \sqrt{16} }
        expect(expr.eval()).to(eq(4.0))

    it "parses powers":
        """
        Exponentiation with `x^n` syntax.
        """
        val expr = m{ 2^10 }
        expect(expr.eval()).to(eq(1024))

    it "supports implicit multiplication":
        """
        Number-variable adjacency implies multiplication.
        """
        val x = 5
        val expr = m{ 3x + 2 }
        expect(expr.eval_with({ x: x })).to(eq(17))

    it "supports group-group multiplication":
        """
        Adjacent parenthesized groups multiply.
        """
        val x = 2
        val expr = m{ (x+1)(x-1) }
        expect(expr.eval_with({ x: x })).to(eq(3))  # (3)(1) = 3

    it "parses Greek letters":
        """
        Greek letter constants.
        """
        val expr = m{ \pi }
        expect(expr.eval()).to(be_close_to(3.14159, 0.0001))

    it "parses summation":
        """
        Summation notation.
        """
        val expr = m{ \sum_{i=1}^{5} i }
        expect(expr.eval()).to(eq(15))  # 1+2+3+4+5

    it "parses integrals":
        """
        Definite integral notation.
        """
        val expr = m{ \int_{0}^{1} x dx }
        expect(expr.eval()).to(be_close_to(0.5, 0.01))  # x^2/2 from 0 to 1

    it "renders to LaTeX":
        """
        Export math expression as LaTeX string.
        """
        val expr = m{ \frac{1}{1+x} }
        val latex = std.math.render(expr, "latex")
        expect(latex).to(eq("\\frac{1}{1+x}"))

    it "renders to MathML":
        """
        Export math expression as MathML.
        """
        val expr = m{ x^2 }
        val mathml = std.math.render(expr, "mathml")
        expect(mathml).to(contain("<msup>"))


# ============================================================================
# Shell Block (sh{})
# ============================================================================

describe "Shell Block sh{}":
    """
    ## Shell Block - Portable Shell Scripting

    The `sh{}` block provides Bash-like syntax with OS-neutral execution.
    Commands are NOT executed by `/bin/sh` or `cmd.exe` - they run consistently
    across Windows, macOS, and Linux.

    **Type:** `std.shell.Result { stdout: Bytes, stderr: Bytes, status: i32 }`

    **Features:**
    - Portable built-in commands (cp, mv, rm, mkdir, echo)
    - Pipes and redirects
    - Block-local variables
    - No shell injection vulnerabilities
    """

    it "executes echo command":
        """
        Basic echo command.
        """
        val r = sh{ echo "hello world" }
        expect(r.status).to(eq(0))
        expect(r.stdout.to_str()).to(eq("hello world\n"))

    it "supports pipes":
        """
        Pipe output between commands.
        """
        val r = sh{ echo "hello\nworld" | grep "world" }
        expect(r.status).to(eq(0))
        expect(r.stdout.to_str()).to(contain("world"))

    it "supports redirects":
        """
        Redirect output to file.
        """
        val r = sh{
            echo "test" > /tmp/test_output.txt
            cat /tmp/test_output.txt
        }
        expect(r.status).to(eq(0))
        expect(r.stdout.to_str()).to(eq("test\n"))

    it "supports block-local variables":
        """
        Variables scoped to the block.
        """
        val r = sh{
            NAME=world
            echo "hello $NAME"
        }
        expect(r.stdout.to_str()).to(eq("hello world\n"))

    it "creates directories":
        """
        Portable mkdir command.
        """
        val r = sh{
            mkdir -p /tmp/test_dir/sub
            exists /tmp/test_dir/sub
        }
        expect(r.status).to(eq(0))

    it "copies files":
        """
        Portable cp command.
        """
        val r = sh{
            echo "content" > /tmp/src.txt
            cp /tmp/src.txt /tmp/dst.txt
            cat /tmp/dst.txt
        }
        expect(r.stdout.to_str()).to(contain("content"))

    it "returns non-zero status on failure":
        """
        Failed commands return non-zero status.
        """
        val r = sh{ cat /nonexistent/file }
        expect(r.status).to(not(eq(0)))
        expect(r.stderr.to_str()).to(not(be_empty()))

    it "supports multiple commands":
        """
        Multiple commands execute in sequence.
        """
        val r = sh{
            echo "line1"
            echo "line2"
            echo "line3"
        }
        expect(r.stdout.to_str()).to(eq("line1\nline2\nline3\n"))


# ============================================================================
# SQL Block (sql{})
# ============================================================================

describe "SQL Block sql{}":
    """
    ## SQL Block - Parameterized SQL Queries

    The `sql{}` block embeds SQL with typed parameters and dialect support.
    Parameters prevent SQL injection by using prepared statements.

    **Type:** `std.sql.Query`

    **Features:**
    - Named parameters (`:name`)
    - Positional parameters (`?`)
    - Dialect selection (postgres, mysql, sqlite, ansi)
    """

    it "creates a query with named parameters":
        """
        Named parameter markers.
        """
        val q = sql{
            dialect: postgres
            SELECT id, name FROM users WHERE id = :id
        }

        expect(q.sql).to(contain("$1"))  # Postgres uses $1, $2...
        expect(q.params).to(eq(["id"]))

    it "creates a query with positional parameters":
        """
        Positional parameter markers.
        """
        val q = sql{
            dialect: sqlite
            SELECT * FROM items WHERE price < ? AND category = ?
        }

        expect(q.sql).to(contain("?"))
        expect(q.param_count).to(eq(2))

    it "supports postgres dialect":
        """
        PostgreSQL-specific syntax.
        """
        val q = sql{
            dialect: postgres
            SELECT * FROM users WHERE data @> '{"active": true}'::jsonb
        }

        expect(q.dialect).to(eq("postgres"))

    it "supports mysql dialect":
        """
        MySQL-specific syntax.
        """
        val q = sql{
            dialect: mysql
            SELECT * FROM users LIMIT 10, 20
        }

        expect(q.dialect).to(eq("mysql"))

    it "supports sqlite dialect":
        """
        SQLite-specific syntax.
        """
        val q = sql{
            dialect: sqlite
            SELECT * FROM users WHERE rowid = :id
        }

        expect(q.dialect).to(eq("sqlite"))

    it "validates SQL syntax at compile time":
        """
        Invalid SQL produces compile-time error.
        """
        # This should be a compile error, not runtime
        # val q = sql{ SELEC * FORM users }  # Typo: compile error


# ============================================================================
# Regex Block (re{})
# ============================================================================

describe "Regex Block re{}":
    """
    ## Regex Block - Compiled Regular Expressions

    The `re{}` block provides regular expressions without string escaping noise.
    Patterns are compiled at build time when possible.

    **Type:** `std.regex.Pattern`

    **Features:**
    - Named capture groups
    - Compile-time validation
    - Flags (i, m, s, x)
    """

    it "matches simple patterns":
        """
        Basic pattern matching.
        """
        val p = re{ hello }
        expect(p.is_match("hello world")).to(be_true())
        expect(p.is_match("goodbye")).to(be_false())

    it "supports character classes":
        """
        Character class patterns.
        """
        val p = re{ [a-z]+ }
        expect(p.is_match("hello")).to(be_true())
        expect(p.is_match("123")).to(be_false())

    it "supports named capture groups":
        """
        Named captures for structured extraction.
        """
        val p = re{ (?P<user>[a-zA-Z_]\w*)@(?P<host>[\w.]+) }
        val m = p.match("alice@example.com")

        expect(m).to(not(be_none()))
        expect(m.group("user")).to(eq("alice"))
        expect(m.group("host")).to(eq("example.com"))

    it "supports case-insensitive flag":
        """
        Case insensitive matching with `i` flag.
        """
        val p = re{
            flags: i
            hello
        }

        expect(p.is_match("HELLO")).to(be_true())
        expect(p.is_match("HeLLo")).to(be_true())

    it "supports multiline flag":
        """
        Multiline mode with `m` flag.
        """
        val p = re{
            flags: m
            ^line
        }

        expect(p.is_match("first\nline")).to(be_true())

    it "validates regex at compile time":
        """
        Invalid regex produces compile-time error.
        """
        # This should be a compile error
        # val p = re{ [invalid }  # Unbalanced bracket: compile error


# ============================================================================
# Markdown Block (md{})
# ============================================================================

describe "Markdown Block md{}":
    """
    ## Markdown Block - Document Embedding

    The `md{}` block embeds Markdown content directly in source code.
    Supports embedded sub-blocks for math and diagrams.

    **Type:** `std.doc.Markdown`
    """

    it "parses basic markdown":
        """
        Headers, paragraphs, lists.
        """
        val doc = md{
            # Title

            This is a paragraph.

            - Item 1
            - Item 2
        }

        expect(doc.to_html()).to(contain("<h1>Title</h1>"))
        expect(doc.to_html()).to(contain("<li>Item 1</li>"))

    it "supports inline code":
        """
        Inline code spans.
        """
        val doc = md{
            Use `println` to print.
        }

        expect(doc.to_html()).to(contain("<code>println</code>"))

    it "supports code blocks":
        """
        Fenced code blocks.
        """
        val doc = md{
            ```simple
            val x = 42
            ```
        }

        expect(doc.to_html()).to(contain("val x = 42"))

    it "embeds math via interpolation":
        """
        Math blocks via `${m{...}}` interpolation.
        """
        val doc = md{
            The equation: ${m{ x^2 + y^2 = z^2 }}
        }

        expect(doc.to_html()).to(contain("x^2"))

    it "embeds math via fenced block":
        """
        Math blocks via fenced syntax.
        """
        val doc = md{
            ```math
            \frac{1}{1+x}
            ```
        }

        expect(doc.to_html()).to(contain("frac"))


# ============================================================================
# Graph Block (graph{})
# ============================================================================

describe "Graph Block graph{}":
    """
    ## Graph Block - Diagram Embedding

    The `graph{}` block embeds diagrams using text-based DSLs like Mermaid or DOT.

    **Type:** `std.graph.Diagram { format: str, asset_ref: AssetRef }`
    """

    it "creates mermaid diagram":
        """
        Mermaid flowchart syntax.
        """
        val d = graph{
            engine: mermaid
            graph TD
                A-->B
                B-->C
        }

        expect(d.format).to(eq("svg"))
        expect(d.to_svg()).to(contain("<svg"))

    it "creates DOT diagram":
        """
        Graphviz DOT syntax.
        """
        val d = graph{
            engine: dot
            digraph G {
                A -> B;
                B -> C;
            }
        }

        expect(d.format).to(eq("svg"))

    it "embeds in markdown":
        """
        Diagrams can be embedded in markdown docs.
        """
        val d = graph{
            engine: mermaid
            graph LR
                Parse --> IR --> Render
        }

        val doc = md{
            ## Pipeline
            ${d}
        }

        expect(doc.to_html()).to(contain("<svg"))


# ============================================================================
# Image Block (img{})
# ============================================================================

describe "Image Block img{}":
    """
    ## Image Block - Image Embedding

    The `img{}` block embeds existing images or generates new ones.

    **Type:** `std.media.Image { format: str, asset_ref: AssetRef }`

    **Note:** Image generation requires explicit opt-in via package config.
    """

    it "embeds existing image":
        """
        Load image from file path.
        """
        val logo = img{
            from: file "assets/logo.png"
        }

        expect(logo.format).to(eq("png"))

    it "specifies image format":
        """
        Explicit format specification.
        """
        val icon = img{
            from: file "assets/icon.svg"
            format: svg
        }

        expect(icon.format).to(eq("svg"))


# ============================================================================
# HTML Block (html{})
# ============================================================================

describe "HTML Block html{}":
    """
    ## HTML Block - Raw HTML Content

    The `html{}` block embeds HTML content directly.

    **Type:** `std.doc.Html`
    """

    it "parses basic HTML":
        """
        Basic HTML elements.
        """
        val page = html{
            <div class="container">
                <h1>Title</h1>
                <p>Content</p>
            </div>
        }

        expect(page.to_str()).to(contain("<h1>Title</h1>"))

    it "supports interpolation":
        """
        Simple expressions can be interpolated.
        """
        val name = "World"
        val page = html{
            <p>Hello, ${name}!</p>
        }

        expect(page.to_str()).to(contain("Hello, World!"))

    it "embeds math":
        """
        Math expressions render as MathML.
        """
        val page = html{
            <p>Equation: ${m{ x^2 }}</p>
        }

        expect(page.to_str()).to(contain("<math"))


# ============================================================================
# Block Nesting and Interpolation
# ============================================================================

describe "Block Nesting and Interpolation":
    """
    ## Nested Blocks and Interpolation

    Blocks can be nested via interpolation `${...}`. The interpolated
    expression must implement a render interface for the host block.
    """

    it "nests math in markdown":
        """
        Math block renders inside markdown.
        """
        val eq = m{ E = mc^2 }
        val doc = md{
            # Physics
            Einstein's equation: ${eq}
        }

        expect(doc.to_html()).to(contain("E = mc"))

    it "nests graph in markdown":
        """
        Graph block renders inside markdown.
        """
        val flow = graph{
            engine: mermaid
            graph LR
                A --> B
        }

        val doc = md{
            ## Flow
            ${flow}
        }

        expect(doc.to_html()).to(contain("<svg"))

    it "nests multiple blocks":
        """
        Multiple block types in one document.
        """
        val eq = m{ x^2 + y^2 = z^2 }
        val diagram = graph{
            engine: mermaid
            graph TD
                A --> B
        }

        val doc = md{
            # Combined

            Equation: ${eq}

            Diagram:
            ${diagram}
        }

        expect(doc.to_html()).to(contain("x^2"))
        expect(doc.to_html()).to(contain("<svg"))


# ============================================================================
# Custom Block Handlers
# ============================================================================

describe "Custom Block Handlers":
    """
    ## User-Defined Block Kinds

    Users can define custom block handlers via the `__block__` dunder interface.
    """

    it "defines custom block kind":
        """
        Custom block with __block__ dunder.
        """
        class JsonBlock:
            data: Any

            static fn __block__(kind: "json", payload: str) -> JsonBlock:
                JsonBlock { data: std.json.parse(payload) }

        val j = json{ {"name": "Alice", "age": 30} }

        expect(j.data["name"]).to(eq("Alice"))
        expect(j.data["age"]).to(eq(30))


# ============================================================================
# Error Handling
# ============================================================================

describe "Block Error Handling":
    """
    ## Compile-Time and Runtime Errors

    Block parse errors are compile-time. Execution errors (sh{}) are runtime.
    """

    it "reports math parse errors at compile time":
        """
        Invalid math syntax is caught at compile time.
        """
        # This should be a compile error:
        # val expr = m{ \frac{1} }  # Missing second argument

    it "reports regex errors at compile time":
        """
        Invalid regex is caught at compile time.
        """
        # This should be a compile error:
        # val p = re{ [a-z }  # Unbalanced bracket

    it "reports SQL errors at compile time":
        """
        Invalid SQL is caught at compile time.
        """
        # This should be a compile error:
        # val q = sql{ SELEC * FORM users }  # Typos

    it "returns runtime errors from sh{}":
        """
        Shell execution errors are returned, not thrown.
        """
        val r = sh{ exit 1 }
        expect(r.status).to(eq(1))
