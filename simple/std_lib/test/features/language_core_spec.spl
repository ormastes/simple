# Language Core Features - BDD Tests
# Tests core language features

use spec.{describe, context, it, expect}
use spec.{eq, be_true, be_false, have_length, include}
use spec.feature_doc.feature_metadata

describe "Functions (#12)":
    feature_metadata(
        id: 12,
        name: "Functions",
        category: "Language",
        difficulty: 3,
        status: "âœ… Complete",
        impl_type: "Rust",
        spec_ref: "spec/functions.md",
        files: [
            "src/compiler/src/interpreter_call.rs",
            "src/parser/src/parser_impl/items.rs",
            "src/runtime/src/value/objects.rs"
        ],
        tests: [
            "simple/std_lib/test/unit/core/functions_spec.spl",
            "src/driver/tests/interpreter_basic.rs"
        ],
        description: """
Functions are the basic unit of code organization in Simple. They support:
- Named functions with fn keyword
- Return values with explicit types
- Default argument values
- Named argument calls
- Multiple return values (via tuples)
- Closures and lambdas
        """,
        dependencies: [],
        required_by: [],
        notes: """
- Functions are first-class values
- Closures capture their lexical environment
- Tail call optimization planned for future
        """,
        examples: [
            """
# Basic function
fn add(a: i64, b: i64) -> i64:
    return a + b

# Default arguments
fn greet(name: str = "World") -> str:
    return f"Hello, {name}!"

# Closure
let adder = fn(x: i64) -> fn(i64) -> i64:
    return fn(y: i64) -> i64:
        return x + y

let add5 = adder(5)
add5(10)  # Returns 15
            """
        ]
    )

    context "Basic Function Definitions":
        it "defines and calls simple functions":
            fn add(a: Int, b: Int) -> Int:
                return a + b

            expect add(2, 3) to eq 5

        it "handles functions with no parameters":
            fn get_answer() -> Int:
                return 42

            expect get_answer() to eq 42

        it "handles functions with no return value":
            let mut side_effect = 0

            fn increment_global():
                side_effect = side_effect + 1

            increment_global()
            expect side_effect to eq 1

        it "handles multiple parameters":
            fn calculate(a: Int, b: Int, c: Int) -> Int:
                return a + b * c

            expect calculate(2, 3, 4) to eq 14

    context "Return Values":
        it "returns explicit values":
            fn double(x: Int) -> Int:
                return x * 2

            expect double(21) to eq 42

        it "handles early returns":
            fn check_positive(x: Int) -> String:
                if x < 0:
                    return "negative"
                if x == 0:
                    return "zero"
                return "positive"

            expect check_positive(-5) to eq "negative"
            expect check_positive(0) to eq "zero"
            expect check_positive(10) to eq "positive"

        it "returns complex types":
            fn get_list() -> List[Int]:
                return [1, 2, 3]

            let result = get_list()
            expect result to have_length 3

        it "returns tuples for multiple values":
            fn divide_with_remainder(a: Int, b: Int) -> (Int, Int):
                return (a / b, a % b)

            let (quotient, remainder) = divide_with_remainder(10, 3)
            expect quotient to eq 3
            expect remainder to eq 1

    context "Default Arguments":
        it "uses default values when arguments omitted":
            fn greet(name: String = "World") -> String:
                return f"Hello, {name}!"

            expect greet() to eq "Hello, World!"
            expect greet("Alice") to eq "Hello, Alice!"

        it "handles multiple default arguments":
            fn format_message(text: String, prefix: String = "[INFO]", suffix: String = "") -> String:
                return f"{prefix} {text}{suffix}"

            expect format_message("test") to include "[INFO]"
            expect format_message("test", "[ERROR]") to include "[ERROR]"

    context "Named Arguments":
        it "calls functions with named arguments":
            fn create_point(x: Int, y: Int) -> String:
                return f"({x}, {y})"

            expect create_point(x: 10, y: 20) to eq "(10, 20)"

        it "allows mixing positional and named arguments":
            fn make_label(id: Int, name: String, active: Bool = true) -> String:
                let status = if active: "active" else: "inactive"
                return f"{id}: {name} ({status})"

            expect make_label(1, "test") to include "active"
            expect make_label(2, name: "demo", active: false) to include "inactive"

    context "Closures and Lambdas":
        it "creates simple closures":
            let add_one = \x: x + 1

            expect add_one(5) to eq 6

        it "captures lexical environment":
            let multiplier = 10

            let multiply_by_ten = \x: x * multiplier

            expect multiply_by_ten(5) to eq 50

        it "creates nested closures":
            fn make_adder(n: Int) -> fn(Int) -> Int:
                return \x: x + n

            let add_five = make_adder(5)
            expect add_five(10) to eq 15

        it "uses closures with higher-order functions":
            let numbers = [1, 2, 3, 4, 5]
            let doubled = numbers.map(\x: x * 2)

            expect doubled to eq [2, 4, 6, 8, 10]

        it "uses closures for filtering":
            let numbers = [1, 2, 3, 4, 5]
            let evens = numbers.filter(\x: x % 2 == 0)

            expect evens to eq [2, 4]

    context "First-Class Functions":
        it "assigns functions to variables":
            fn square(x: Int) -> Int:
                return x * x

            let func = square
            expect func(7) to eq 49

        it "passes functions as arguments":
            fn apply_twice(f: fn(Int) -> Int, x: Int) -> Int:
                return f(f(x))

            fn increment(n: Int) -> Int:
                return n + 1

            expect apply_twice(increment, 5) to eq 7

        it "returns functions from functions":
            fn make_multiplier(factor: Int) -> fn(Int) -> Int:
                return \x: x * factor

            let times_three = make_multiplier(3)
            expect times_three(7) to eq 21

        it "stores functions in collections":
            fn add(a: Int, b: Int) -> Int:
                return a + b

            fn subtract(a: Int, b: Int) -> Int:
                return a - b

            let operations = [add, subtract]
            expect operations[0](10, 5) to eq 15
            expect operations[1](10, 5) to eq 5

    context "Recursion":
        it "handles simple recursion":
            fn factorial(n: Int) -> Int:
                if n <= 1:
                    return 1
                return n * factorial(n - 1)

            expect factorial(5) to eq 120

        it "handles mutual recursion":
            fn is_even(n: Int) -> Bool:
                if n == 0:
                    return true
                return is_odd(n - 1)

            fn is_odd(n: Int) -> Bool:
                if n == 0:
                    return false
                return is_even(n - 1)

            expect is_even(4) to be_true
            expect is_odd(4) to be_false

    context "Type Annotations":
        it "enforces parameter types":
            fn typed_add(a: Int, b: Int) -> Int:
                return a + b

            expect typed_add(10, 20) to eq 30

        it "enforces return types":
            fn returns_string() -> String:
                return "hello"

            expect returns_string() to eq "hello"

        it "handles generic type parameters":
            fn first[T](list: List[T]) -> T:
                return list[0]

            expect first([1, 2, 3]) to eq 1
            expect first(["a", "b"]) to eq "a"

    context "Advanced Features":
        it "handles variadic arguments":
            fn sum_all(*args: Int) -> Int:
                let mut total = 0
                for n in args:
                    total = total + n
                return total

            expect sum_all(1, 2, 3, 4) to eq 10

        it "handles keyword arguments":
            fn configure(**kwargs: String) -> Int:
                return kwargs.len()

            expect configure(a: "1", b: "2", c: "3") to eq 3

        it "supports function composition":
            fn compose(f: fn(Int) -> Int, g: fn(Int) -> Int) -> fn(Int) -> Int:
                return \x: f(g(x))

            fn double(x: Int) -> Int:
                return x * 2

            fn increment(x: Int) -> Int:
                return x + 1

            let double_then_increment = compose(increment, double)
            expect double_then_increment(5) to eq 11  # (5 * 2) + 1
