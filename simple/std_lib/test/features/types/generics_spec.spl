# Generics Feature Specification
# Feature #32: Generic type parameters
# Category: Types | Difficulty: 4 | Status: Partial

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List[String]
    tests: List[String]
    description: String
    code_examples: List[String]
    dependencies: List[Int]
    required_by: List[Int]
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 32,
    name: 'Generics',
    category: 'Types',
    difficulty: 4,
    status: 'Partial',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/types.md',
    files: [
        'src/parser/src/types_def/mod.rs',
        'src/compiler/src/interpreter.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_primitive_types.rs',
        'src/driver/tests/interpreter_generics_tests.rs'
    ],
    description: 'Generic type parameters for functions, structs, and enums. Supports single and multiple type parameters with bracket notation.',
    code_examples: [],
    dependencies: [1, 2, 10],
    required_by: [27],
    notes: 'Uses <T> for declarations and [T] for type arguments. Advanced features (where clauses, const generics) pending.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  GENERICS FEATURE SPECIFICATION (#32)')
print('  Category: Types | Difficulty: 4 | Status: Partial')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

# -----------------------------------------------------
# Generic Functions
# -----------------------------------------------------

print('describe Generic functions:')
print('  context single type parameter:')
print('    it works with identity function:')

fn identity<T>(x: T) -> T:
    return x

if identity(42) == 42:
    print('      [PASS] generic identity function')
    passed = passed + 1
else:
    print('      [FAIL] generic identity function')
    failed = failed + 1

print('    it works with strings:')

if identity("hello") == "hello":
    print('      [PASS] generic with string')
    passed = passed + 1
else:
    print('      [FAIL] generic with string')
    failed = failed + 1

print('')
print('  context multiple type parameters:')
print('    it works with two parameters:')

fn first<A, B>(a: A, b: B) -> A:
    return a

fn second<A, B>(a: A, b: B) -> B:
    return b

let x = first(10, 20)
let y = second(30, 40)
if x + y == 50:
    print('      [PASS] multiple type params')
    passed = passed + 1
else:
    print('      [FAIL] multiple type params')
    failed = failed + 1

print('    it returns correct types:')

if first(100, "ignored") == 100:
    print('      [PASS] first returns A')
    passed = passed + 1
else:
    print('      [FAIL] first returns A')
    failed = failed + 1

if second("ignored", 200) == 200:
    print('      [PASS] second returns B')
    passed = passed + 1
else:
    print('      [FAIL] second returns B')
    failed = failed + 1

# -----------------------------------------------------
# Generic Structs
# -----------------------------------------------------

print('')
print('describe Generic structs:')
print('  context struct with type parameter:')
print('    it creates generic struct:')

struct Box<T>:
    value: T

let b = Box { value: 42 }
if b.value == 42:
    print('      [PASS] generic struct')
    passed = passed + 1
else:
    print('      [FAIL] generic struct')
    failed = failed + 1

print('    it works with different types:')

let str_box = Box { value: "hello" }
if str_box.value == "hello":
    print('      [PASS] struct with string')
    passed = passed + 1
else:
    print('      [FAIL] struct with string')
    failed = failed + 1

# -----------------------------------------------------
# Generic Enums
# -----------------------------------------------------

print('')
print('describe Generic enums:')
print('  context enum with type parameter:')
print('    it creates generic enum:')

enum Maybe<T>:
    Just(T)
    Nothing

fn get_or_fallback(m: Maybe[i64], fallback: i64) -> i64:
    match m:
        Maybe::Just(v) =>
            return v
        Maybe::Nothing =>
            return fallback
    return fallback

let x = Maybe::Just(42)
if get_or_fallback(x, 0) == 42:
    print('      [PASS] generic enum Just')
    passed = passed + 1
else:
    print('      [FAIL] generic enum Just')
    failed = failed + 1

print('    it handles Nothing case:')

let n = Maybe::Nothing
if get_or_fallback(n, 99) == 99:
    print('      [PASS] generic enum Nothing')
    passed = passed + 1
else:
    print('      [FAIL] generic enum Nothing')
    failed = failed + 1

# -----------------------------------------------------
# Nested Generic Types
# -----------------------------------------------------

print('')
print('describe Nested generics:')
print('  context nested type parameters:')
print('    it parses nested generic types:')

struct Container:
    items: List[Option[i64]]

# Just verifying this compiles - nested generics in types
print('      [PASS] nested generic types parse')
passed = passed + 1

# -----------------------------------------------------
# Tuple Return Types
# -----------------------------------------------------

print('')
print('describe Tuple return types:')
print('  context function returning tuple:')
print('    it returns tuple:')

fn get_pair() -> (i64, str):
    return (42, "hello")

let pair = get_pair()
if pair[0] == 42:
    print('      [PASS] tuple return first element')
    passed = passed + 1
else:
    print('      [FAIL] tuple return first element')
    failed = failed + 1

print('    it returns both elements:')

if pair[1] == "hello":
    print('      [PASS] tuple return second element')
    passed = passed + 1
else:
    print('      [FAIL] tuple return second element')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Generics')
print('')
print('**Feature ID:** #32')
print('**Category:** Types')
print('**Difficulty:** Level 4/5')
print('**Status:** Partial')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Syntax')
print('')
print('```simple')
print('# Generic function')
print('fn identity<T>(x: T) -> T:')
print('    return x')
print('')
print('# Generic struct')
print('struct Box<T>:')
print('    value: T')
print('')
print('# Generic enum')
print('enum Maybe<T>:')
print('    Just(T)')
print('    Nothing')
print('')
print('# Type arguments use brackets')
print('let b: Box[i64] = Box { value: 42 }')
print('```')
print('')
print('## Implemented')
print('')
print('| Feature | Status |')
print('|---------|--------|')
print('| Generic functions | Complete |')
print('| Generic structs | Complete |')
print('| Generic enums | Complete |')
print('| Nested generics | Complete |')
print('| Tuple return types | Complete |')
print('')
print('## Pending')
print('')
print('| Feature | Status |')
print('|---------|--------|')
print('| Const generics | Planned |')
print('| Where clauses | Planned |')
print('| Multiple trait bounds | Planned |')
print('| Associated types | Planned |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
