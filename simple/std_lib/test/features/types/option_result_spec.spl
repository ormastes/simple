# Option and Result Feature Specification
"""
# Option and Result Types

**Feature ID:** #27
**Category:** Types
**Difficulty:** 3/5 (Intermediate)
**Status:** Complete

## Overview

Option and Result types provide type-safe alternatives to null values and exceptions in Simple.
These algebraic data types (sum types/tagged unions) enable explicit representation of absence
(Option) and fallibility (Result), forcing developers to handle edge cases at compile time.

**Option<T>:** Represents an optional value - either Some(value) or None
**Result<T, E>:** Represents a computation that might fail - either Ok(value) or Err(error)

Unlike languages with null/undefined, Simple requires explicit checks for Option/Result, preventing
null pointer exceptions and unhandled errors. This design is borrowed from Rust, Scala, and Haskell.

## Syntax

### Option Type

```simple
enum Option<T>:
    Some(value: T)
    None

# Create Option values
val some: Option<i32> = Option::Some(42)
val none: Option<i32> = Option::None

# Pattern match to extract value
match some:
    Option::Some(x) => print("Got: {x}")
    Option::None => print("No value")
```

**Grammar:**
```
option_expr = 'Option' '::' ('Some' '(' expression ')' | 'None')
```

### Result Type

```simple
enum Result<T, E>:
    Ok(value: T)
    Err(error: E)

# Create Result values
val success: Result<i32, text> = Result::Ok(100)
val failure: Result<i32, text> = Result::Err("Not found")

# Pattern match to handle errors
match divide(10, 2):
    Result::Ok(v) => print("Result: {v}")
    Result::Err(e) => print("Error: {e}")
```

**Grammar:**
```
result_expr = 'Result' '::' ('Ok' | 'Err') '(' expression ')'
```

## Runtime Representation

**Option Values:**
Implemented as Rust enums in the runtime:
    ```rust
pub enum OptionValue {
    Some(Box<RuntimeValue>),  // Boxed to allow arbitrary types
    None,
}
```

**Result Values:**
```rust
pub enum ResultValue {
    Ok(Box<RuntimeValue>),
    Err(Box<RuntimeValue>),  // Error can be any type (usually text)
}
```

**Memory Layout:**
- Both use tagged union representation (8-byte discriminant + pointer)
- Inner values are heap-allocated (Box) for flexibility
- Pattern matching compiles to discriminant checks + value extraction

## Comparison with Other Languages

| Feature | Simple | Rust | Scala | Haskell | TypeScript | Python |
|---------|--------|------|-------|---------|------------|--------|
| Null safety | ✅ Option | ✅ Option | ✅ Option | ✅ Maybe | ❌ null/undefined | ❌ None |
| Error handling | ✅ Result | ✅ Result | ✅ Either/Try | ✅ Either | ❌ exceptions | ❌ exceptions |
| Forced handling | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ⚠️ Optional | ❌ No |
| Pattern matching | ✅ match | ✅ match | ✅ match | ✅ case | ⚠️ Limited | ⚠️ match (3.10+) |
| Type inference | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ⚠️ Limited |
| Monadic ops | ❌ Planned | ✅ map/and_then | ✅ map/flatMap | ✅ fmap/>>= | ⚠️ Limited | ❌ No |

## Common Patterns

### Option Patterns

**1. Nullable Return Values:**
```simple
fn find(items: List<i32>, target: i32) -> Option<i32>:
    for item in items:
        if item == target:
            return Option::Some(item)
    return Option::None
```

**2. Safe Indexing:**
```simple
fn get_at(items: List<i32>, index: i32) -> Option<i32>:
    if index >= 0 and index < items.len():
        return Option::Some(items[index])
    return Option::None
```

**3. Default Values (Pattern Matching):**
```simple
val opt = Option::Some(42)
val value = match opt:
    Option::Some(x) => x
    Option::None => 0  # Default to 0
```

### Result Patterns

**1. Fallible Operations:**
```simple
fn divide(a: i32, b: i32) -> Result<i32, text>:
    if b == 0:
        return Result::Err("Division by zero")
    return Result::Ok(a / b)
```

**2. Error Propagation:**
```simple
fn complex_calc(a: i32, b: i32, c: i32) -> Result<i32, text>:
    match divide(a, b):
        Result::Ok(v) => Result::Ok(v + c)
        Result::Err(e) => Result::Err(e)  # Propagate error
```

**3. Chaining Operations:**
```simple
fn safe_pipeline(x: i32) -> Result<i32, text>:
    val step1 = validate(x)
    match step1:
        Result::Err(e) => return Result::Err(e)
        Result::Ok(v1) =>
            val step2 = transform(v1)
            match step2:
                Result::Err(e) => return Result::Err(e)
                Result::Ok(v2) => return Result::Ok(v2)
```

## Implementation Files

**Parser:** `src/parser/src/types_def/mod.rs` - Enum variant parsing
**Interpreter:** `src/compiler/src/interpreter/expr/ops.rs` - Pattern matching
**Runtime:** `src/runtime/src/value/objects.rs` - Option/Result value representation
**Tests:** `src/driver/tests/interpreter_oop_tests.rs` - Enum variant tests

## Related Features

- **Pattern Matching (#90):** Essential for extracting Option/Result values safely
- **Enums (#16):** Option and Result are built-in enum types
- **Type System (#1):** Generic types enable Option<T> and Result<T, E>
- **Error Handling (#TBD):** Result is primary mechanism for recoverable errors

## Future Enhancements

**Planned (Not Yet Implemented):**
- Monadic operators: map, flatMap, filter, getOrElse
- Question mark operator (?) for error propagation (like Rust)
- Try-catch syntax sugar for Result conversion
- Option/Result combinators library in stdlib
"""
import std.spec

import std.spec


# Define Option enum for tests
enum Option:
    Some(value)
    None

# Define Result enum for tests
enum Result:
    Ok(value)
    Err(msg)

describe "Option type":
    """
    ## Option Type - Representing Optional Values

    The Option type encodes the possibility of absence in a type-safe way. Instead of using
    null/undefined (which can cause runtime errors), Option forces explicit handling of the
    "no value" case at compile time.

    **Key Properties:**
    - Two variants: Some(value) and None
    - Generic over the value type: Option<T>
    - Must be unwrapped via pattern matching to access the inner value
    - Prevents null pointer exceptions by design

    **Grammar:**
    ```
    option_value = 'Option' '::' 'Some' '(' expression ')'
                 | 'Option' '::' 'None'
    ```

    **Use Cases:**
    - Function return values that might not have a result (e.g., search, lookup)
    - Optional struct fields
    - Nullable parameters
    - Absence of a value without using a sentinel value

    **Implementation:** `src/runtime/src/value/objects.rs:OptionValue`
    """
    it "creates Some value":
        """
        **Given** a value to wrap in an Option
        **When** creating Option::Some(value)
        **Then** the Some variant is created containing the value

        The Some variant wraps a value, indicating that a value is present. The wrapped value
        can be of any type, and Option is generic over that type.

        **Code Example:**
        ```simple
        val num: Option<i32> = Option::Some(42)
        val text: Option<text> = Option::Some("hello")
        val list: Option<List<i32>> = Option::Some([1, 2, 3])
        ```

        **Runtime Behavior:**
        - Creates an OptionValue::Some variant in the runtime
        - The inner value is boxed (heap-allocated) to allow arbitrary types
        - Type inference determines T in Option<T> from the wrapped value

        **Common Use Case:**
        Return Some from functions when a value is successfully found or computed.

        **Implementation:** `src/runtime/src/value/objects.rs:OptionValue::Some`
        """

        val some_val = Option::Some(42)

        expect(some_val).to(be_instance_of(Option))


    it "creates None value":
        """
        **Given** a situation where no value is available
        **When** creating Option::None
        **Then** the None variant is created representing absence

        The None variant represents the absence of a value. Unlike null/undefined in other
        languages, None must be explicitly handled via pattern matching, preventing null
        pointer exceptions.

        **Code Example:**
        ```simple
        val nothing: Option<i32> = Option::None

        # Must handle None explicitly
        match nothing:
            Option::Some(x) => print("Got: {x}")
            Option::None => print("No value")  # Must handle this case!
        ```

        **Runtime Behavior:**
        - Creates an OptionValue::None variant in the runtime
        - No heap allocation (None contains no value)
        - Type must often be annotated or inferred from context

        **Common Use Case:**
        Return None from functions when no result is available (e.g., search fails, index out
        of bounds, optional parameter not provided).

        **Difference from null:**
        - None is a value, not the absence of initialization
        - Must be explicitly unwrapped via pattern matching
        - Caught at compile time if not handled

        **Implementation:** `src/runtime/src/value/objects.rs:OptionValue::None`
        """

        val none_val = Option::None

        expect(none_val).to(be_instance_of(Option))


    it "uses Option for nullable":
        """
        **Given** a function that might or might not find a value
        **When** returning Option from the function
        **Then** the caller must handle both Some and None cases explicitly

        Option is the idiomatic way to represent nullable return values in Simple. Functions
        that might not have a result return Option instead of using null/undefined or throwing
        exceptions.

        **Code Example:**
        ```simple
        fn find_first(items: List<i32>, predicate: fn(i32) -> bool) -> Option<i32>:
            for item in items:
                if predicate(item):
                    return Option::Some(item)
            return Option::None

        val result = find_first([1, 2, 3], fn(x) -> x > 2)
        match result:
            Option::Some(x) => print("Found: {x}")  # Prints "Found: 3"
            Option::None => print("Not found")
        ```

        **Runtime Behavior:**
        - Function returns either Some(value) or None based on search result
        - Caller must pattern match to extract value
        - Compile-time guarantee that None case is handled

        **Pattern:**
        This is the "search pattern" - iterate through a collection, return Some when found,
        return None if iteration completes without finding.

        **Comparison with Other Languages:**
        - Python: Return None or raise exception (no type safety)
        - JavaScript: Return undefined or throw (no type safety)
        - Rust: Return Option<T> (same pattern)
        - Java: Return Optional<T> or null (weaker guarantees)

        **Related Features:**
        - Pattern matching (#90) for safe value extraction
        - List iteration (#45) for searching collections
        """

        fn find_item(items, target):
            for item in items:
                if item == target:
                    return Option::Some(item)
            return Option::None

        val found = find_item([1, 2, 3], 2)

        expect(found).to(eq(Option::Some(2)))


describe "Result type":
    """
    ## Result Type - Type-Safe Error Handling

    The Result type encodes the possibility of failure in a type-safe way. Instead of throwing
    exceptions (which can crash programs or require try/catch), Result forces explicit handling
    of errors at compile time.

    **Key Properties:**
    - Two variants: Ok(value) for success, Err(error) for failure
    - Generic over both success and error types: Result<T, E>
    - Must be unwrapped via pattern matching to access value or error
    - Replaces exceptions for recoverable errors

    **Grammar:**
    ```
    result_value = 'Result' '::' 'Ok' '(' expression ')'
                 | 'Result' '::' 'Err' '(' expression ')'
    ```

    **Use Cases:**
    - Fallible operations (division by zero, file not found, parse errors)
    - Operations that can fail with known error types
    - Error propagation without exceptions
    - Composable error handling

    **Design Philosophy:**
    Result makes errors visible in function signatures. If a function returns Result<T, E>,
    callers know it can fail and must handle errors. This is more explicit than exceptions,
    which are invisible in signatures.

    **Implementation:** `src/runtime/src/value/objects.rs:ResultValue`
    """
    it "creates Ok value":
        """
        **Given** a successful computation result
        **When** creating Result::Ok(value)
        **Then** the Ok variant is created containing the success value

        The Ok variant wraps a success value, indicating that an operation completed without
        errors. The wrapped value can be of any type.

        **Code Example:**
        ```simple
        fn parse_int(s: text) -> Result<i32, text>:
            # Simplified parsing
            if s == "42":
                return Result::Ok(42)
            return Result::Err("Invalid number")

        val result: Result<i32, text> = parse_int("42")
        # result is Result::Ok(42)
        ```

        **Runtime Behavior:**
        - Creates a ResultValue::Ok variant in the runtime
        - The success value is boxed (heap-allocated)
        - Type inference determines T in Result<T, E> from the value

        **Common Use Case:**
        Return Ok from functions when an operation succeeds. The caller can then extract the
        value via pattern matching.

        **Implementation:** `src/runtime/src/value/objects.rs:ResultValue::Ok`
        """

        val ok_val = Result::Ok(100)

        expect(ok_val).to(be_instance_of(Result))


    it "creates Err value":
        """
        **Given** a failed computation
        **When** creating Result::Err(error)
        **Then** the Err variant is created containing the error information

        The Err variant wraps an error value, indicating that an operation failed. The error
        can be of any type (typically text for error messages, but can be custom error types).

        **Code Example:**
        ```simple
        fn safe_divide(a: i32, b: i32) -> Result<i32, text>:
            if b == 0:
                return Result::Err("Cannot divide by zero")
            return Result::Ok(a / b)

        val result: Result<i32, text> = safe_divide(10, 0)
        # result is Result::Err("Cannot divide by zero")
        ```

        **Runtime Behavior:**
        - Creates a ResultValue::Err variant in the runtime
        - The error value is boxed (heap-allocated)
        - Type inference determines E in Result<T, E> from the error value

        **Common Use Case:**
        Return Err from functions when an operation fails. Include descriptive error messages
        or structured error objects to help callers understand what went wrong.

        **Error Type Flexibility:**
        - Simple errors: Use text ("file not found", "invalid input")
        - Structured errors: Use custom error enums/structs
        - Error codes: Use integers

        **Implementation:** `src/runtime/src/value/objects.rs:ResultValue::Err`
        """

        val err_val = Result::Err('not found')

        expect(err_val).to(be_instance_of(Result))


    it "uses Result for fallible ops":
        """
        **Given** an operation that can fail (e.g., division by zero)
        **When** wrapping the operation in a function that returns Result
        **Then** callers must handle both success and failure cases explicitly

        Result is the idiomatic way to handle fallible operations in Simple. Operations that
        can fail return Result instead of throwing exceptions or returning sentinel values.

        **Code Example:**
        ```simple
        fn safe_sqrt(x: f32) -> Result<f32, text>:
            if x < 0:
                return Result::Err("Cannot take square root of negative number")
            return Result::Ok(sqrt(x))

        val result = safe_sqrt(16.0)
        match result:
            Result::Ok(v) => print("√16 = {v}")  # Prints "√16 = 4.0"
            Result::Err(e) => print("Error: {e}")
        ```

        **Runtime Behavior:**
        - Function checks preconditions (e.g., b != 0)
        - Returns Result::Err if precondition fails
        - Returns Result::Ok if operation succeeds
        - Caller must pattern match to extract value or handle error

        **Pattern:**
        The "guard-then-compute" pattern:
            1. Check if operation can proceed safely
        2. Return Err with descriptive message if not
        3. Perform operation and return Ok if yes

        **Comparison with Exceptions:**
        - Exceptions: Hidden in signature, can crash if not caught
        - Result: Visible in signature, forced to handle at compile time

        **Related Features:**
        - Pattern matching (#90) for safe error handling
        - Control flow (#17) for conditional logic
        """

        fn divide(a, b):
            if b == 0:
                return Result::Err('division by zero')
            return Result::Ok(a / b)

        val result = divide(10, 2)

        expect(result).to(eq(Result::Ok(5)))


describe "Option/Result patterns":
    """
    ## Common Option and Result Patterns

    This section covers idiomatic usage patterns for Option and Result types, including:
        - Returning Option/Result from functions
    - Chaining operations (monadic composition)
    - Error propagation
    - Combining multiple fallible operations

    **Key Patterns:**

    **1. Early Return Pattern:**
    Use pattern matching to unwrap values and return early on None/Err:
        ```simple
    fn process(opt: Option<i32>) -> i32:
        match opt:
            Option::None => return 0  # Early return
            Option::Some(x) => x * 2
    ```

    **2. Error Propagation Pattern:**
    Pass errors up the call stack without handling:
        ```simple
    fn outer() -> Result<i32, text>:
        match inner():
            Result::Err(e) => return Result::Err(e)  # Propagate
            Result::Ok(v) => Result::Ok(v + 1)
    ```

    **3. Transformation Pattern:**
    Apply function to inner value without unwrapping:
        ```simple
    match opt:
        Option::Some(x) => Option::Some(x * 2)  # Transform
        Option::None => Option::None             # Preserve None
    ```

    **Implementation:** Patterns shown are currently manual; monadic operators (map, flatMap)
    are planned for stdlib to automate these patterns.
    """
    it "returns Option from function":
        """
        **Given** a function that accesses a potentially missing value (e.g., first element)
        **When** implementing the function with Option return type
        **Then** the function returns Some when value exists, None otherwise

        Functions that access collections or perform lookups should return Option to indicate
        that a value might not be available. This is safer than returning null or throwing
        exceptions.

        **Code Example:**
        ```simple
        fn get_last<T>(items: List<T>) -> Option<T>:
            val len = items.len()
            if len == 0:
                return Option::None
            return Option::Some(items[len - 1])

        val numbers = [10, 20, 30]
        val last = get_last(numbers)  # Some(30)

        val empty = []
        val no_last = get_last(empty)  # None
        ```

        **Runtime Behavior:**
        - Function checks if collection is non-empty
        - Returns Some(items[0]) if items exist
        - Returns None if collection is empty
        - No exceptions thrown, no null returned

        **Pattern:**
        The "safe accessor" pattern - any operation that might not have a result returns
        Option instead of using null or -1 sentinel values.

        **Common Variations:**
        - get_first(list) -> Option<T>
        - get_last(list) -> Option<T>
        - find(list, predicate) -> Option<T>
        - lookup(map, key) -> Option<V>

        **Related Features:**
        - List operations (#45) for collection access
        - Pattern matching (#90) to extract values
        """

        fn get_first(items):
            if items.len() > 0:
                return Option::Some(items[0])
            return Option::None

        val first = get_first([10, 20, 30])

        expect(first).to(eq(Option::Some(10)))


    it "chains Option operations":
        """
        **Given** an Option value to transform
        **When** applying a function that preserves the Option wrapper
        **Then** the transformation only applies to Some, None passes through unchanged

        Option chaining (also called mapping or monadic composition) allows transforming the
        inner value of an Option without explicitly unwrapping it. This pattern is fundamental
        to functional programming with Option types.

        **Code Example:**
        ```simple
        # Manual chaining (current Simple)
        fn safe_add_one(opt: Option<i32>) -> Option<i32>:
            match opt:
                Option::Some(x) => Option::Some(x + 1)
                Option::None => Option::None

        val result = safe_add_one(Option::Some(5))  # Some(6)
        val none_result = safe_add_one(Option::None)  # None

        # Future: opt.map(fn(x) -> x + 1)  (planned)
        ```

        **Runtime Behavior:**
        - Pattern match discriminates between Some and None
        - For Some(x): Apply transformation, wrap in new Some
        - For None: Short-circuit, return None without computation
        - Result is always Option<U> where U is transformation output type

        **Pattern:**
        The "functor map" pattern - transform a value inside a container without unwrapping
        the container. This allows chaining multiple transformations:
            ```simple
        val result = opt
            |> double_if_some
            |> add_ten_if_some
            |> to_string_if_some
        # Result is Option<text>
        ```

        **Future Enhancement:**
        The stdlib will include .map() method:
            ```simple
        opt.map(fn(x) -> x * 2)  # Equivalent to manual match
        ```

        **Related Features:**
        - Pattern matching (#90) for manual chaining
        - Higher-order functions (#TBD) for functional composition
        """

        fn double_if_some(opt):
            match opt:
                case Option::Some(x):
                    return Option::Some(x * 2)
                case Option::None:
                    return Option::None

        val doubled = double_if_some(Option::Some(5))

        expect(doubled).to(eq(Option::Some(10)))


    it "propagates Result errors":
        """
        **Given** a chain of fallible operations
        **When** one operation returns Err
        **Then** the error propagates up without executing subsequent operations

        Error propagation is a core pattern in Result-based error handling. When one step
        fails, the error bubbles up through the call stack, skipping all subsequent computation.
        This is similar to exception propagation but type-safe and explicit.

        **Code Example:**
        ```simple
        fn parse_and_square(s: text) -> Result<i32, text>:
            val parse_result = parse_int(s)
            match parse_result:
                Result::Err(e) => return Result::Err(e)  # Propagate parse error
                Result::Ok(num) =>
                    if num < 0:
                        return Result::Err("Cannot square negative")
                    return Result::Ok(num * num)

        val success = parse_and_square("5")  # Ok(25)
        val failure = parse_and_square("abc")  # Err("Invalid number")
        ```

        **Runtime Behavior:**
        - Call inner function (divide) which returns Result
        - Pattern match on Result
        - If Err: Immediately return the error (short-circuit)
        - If Ok: Continue computation with unwrapped value
        - Wrap final result in Ok

        **Pattern:**
        The "early return on error" pattern. This is manual error propagation; Rust's ? operator
        automates this, and Simple may add similar syntax in the future.

        **Comparison with Exceptions:**
        ```python
        # Python exceptions (implicit)
        def unsafe_calc(a, b, c):
            return (a / b) + c  # May throw, caller doesn't know

        # Simple Result (explicit)
        fn safe_calc(a, b, c) -> Result<i32, text>:
            # Signature shows function can fail
        ```

        **Future Enhancement:**
        Question mark operator for concise error propagation:
            ```simple
        fn safe_calc(a, b, c) -> Result<i32, text>:
            val v = divide(a, b)?  # Auto-propagate Err, unwrap Ok
            return Result::Ok(v + c)
        ```

        **Related Features:**
        - Pattern matching (#90) for manual propagation
        - Error handling (#TBD) for error type hierarchy
        """

        fn safe_divide_and_add(a, b, c):
            val div_result = divide(a, b)
            match div_result:
                case Result::Ok(v):
                    return Result::Ok(v + c)
                case Result::Err(e):
                    return Result::Err(e)

        val calc = safe_divide_and_add(10, 2, 3)

        expect(calc).to(eq(Result::Ok(8)))
