# Memory Types Feature Specification
# Feature #18: Reference Capabilities
# Category: Types | Difficulty: 4 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 18,
    name: 'Memory Types',
    category: 'Types',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/memory.md',
    files: [
        'src/compiler/src/hir/types.rs',
        'src/runtime/src/memory/mod.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_memory_tests.rs'
    ],
    description: 'Reference capability system with GC-managed references (T), unique pointers (&T), shared pointers (*T), weak pointers (-T), and handle pointers (+T).',
    code_examples: [],
    dependencies: [10],
    required_by: [19],
    notes: 'GC is default. Manual memory is opt-in via pointer types. RAII for unique pointers. Reference counting for shared pointers.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  MEMORY TYPES FEATURE SPECIFICATION (#18)')
print('  Category: Types | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# GC-Managed References
# -----------------------------------------------------

print('describe GC-managed references:')
print('  context plain T type:')
print('    it creates heap objects:')

struct Player:
    name: text
    hp: i64

val p = Player { name: "Hero", hp: 100 }
if p.name == "Hero" and p.hp == 100:
    print('      [PASS] heap object created')
    passed = passed + 1
else:
    print('      [FAIL] heap object created')
    failed = failed + 1

print('    it shares references:')

val p2 = p
if p2.hp == 100:
    print('      [PASS] reference shared')
    passed = passed + 1
else:
    print('      [FAIL] reference shared')
    failed = failed + 1

print('    it passes to functions:')

fn get_hp(player: Player) -> i64:
    return player.hp

if get_hp(p) == 100:
    print('      [PASS] passed to function')
    passed = passed + 1
else:
    print('      [FAIL] passed to function')
    failed = failed + 1

# -----------------------------------------------------
# Unique Pointer Semantics
# -----------------------------------------------------

print('')
print('describe Unique pointer semantics:')
print('  context &T type:')
print('    it has single owner:')

struct UniqueBox:
    value: i64
    owner_id: i64

fn create_unique() -> UniqueBox:
    return UniqueBox {value: 42, owner_id: 1 }

val unique = create_unique()
if unique.owner_id == 1:
    print('      [PASS] single owner')
    passed = passed + 1
else:
    print('      [FAIL] single owner')
    failed = failed + 1

print('    it transfers ownership:')

fn transfer_ownership(box: UniqueBox) -> UniqueBox:
    return UniqueBox {value: box.value, owner_id: 2 }

val transferred = transfer_ownership(unique)
if transferred.owner_id == 2:
    print('      [PASS] ownership transferred')
    passed = passed + 1
else:
    print('      [FAIL] ownership transferred')
    failed = failed + 1

# -----------------------------------------------------
# Shared Pointer Semantics
# -----------------------------------------------------

print('')
print('describe Shared pointer semantics:')
print('  context *T type:')
print('    it allows multiple owners:')

struct SharedData:
    value: i64
    ref_count: i64

fn create_shared() -> SharedData:
    return SharedData {value: 100, ref_count: 1 }

fn clone_shared(data: SharedData) -> SharedData:
    return SharedData {value: data.value, ref_count: data.ref_count + 1 }

val shared1 = create_shared()
val shared2 = clone_shared(shared1)
if shared2.ref_count == 2:
    print('      [PASS] multiple owners')
    passed = passed + 1
else:
    print('      [FAIL] multiple owners')
    failed = failed + 1

print('    it tracks reference count:')

val shared3 = clone_shared(shared2)
if shared3.ref_count == 3:
    print('      [PASS] reference count')
    passed = passed + 1
else:
    print('      [FAIL] reference count')
    failed = failed + 1

# -----------------------------------------------------
# Weak Pointer Semantics
# -----------------------------------------------------

print('')
print('describe Weak pointer semantics:')
print('  context -T type:')
print('    it does not own object:')

struct WeakRef:
    target_id: i64
    is_valid: bool

fn create_weak(id: i64) -> WeakRef:
    return WeakRef { target_id: id, is_valid: true }

val weak = create_weak(42)
if weak.is_valid and weak.target_id == 42:
    print('      [PASS] non-owning reference')
    passed = passed + 1
else:
    print('      [FAIL] non-owning reference')
    failed = failed + 1

print('    it can be upgraded:')

fn upgrade_weak(w: WeakRef) -> i64:
    if w.is_valid:
        return w.target_id
    return 0

if upgrade_weak(weak) == 42:
    print('      [PASS] upgrade to strong')
    passed = passed + 1
else:
    print('      [FAIL] upgrade to strong')
    failed = failed + 1

print('    it detects invalidation:')

val invalid_weak = WeakRef { target_id: 0, is_valid: false }
if upgrade_weak(invalid_weak) == 0:
    print('      [PASS] detects invalid')
    passed = passed + 1
else:
    print('      [FAIL] detects invalid')
    failed = failed + 1

# -----------------------------------------------------
# Handle Pointer Semantics
# -----------------------------------------------------

print('')
print('describe Handle pointer semantics:')
print('  context +T type:')
print('    it uses slot and generation:')

struct Handle:
    slot: i64
    generation: i64

val handle = Handle { slot: 5, generation: 1 }
if handle.slot == 5 and handle.generation == 1:
    print('      [PASS] slot and generation')
    passed = passed + 1
else:
    print('      [FAIL] slot and generation')
    failed = failed + 1

print('    it validates generation:')

fn is_valid_handle(h: Handle, current_gen: i64) -> bool:
    return h.generation == current_gen

if is_valid_handle(handle, 1):
    print('      [PASS] generation valid')
    passed = passed + 1
else:
    print('      [FAIL] generation valid')
    failed = failed + 1

print('    it detects stale handles:')

if not is_valid_handle(handle, 2):
    print('      [PASS] stale handle detected')
    passed = passed + 1
else:
    print('      [FAIL] stale handle detected')
    failed = failed + 1

# -----------------------------------------------------
# Mutability
# -----------------------------------------------------

print('')
print('describe Mutability:')
print('  context mut keyword:')
print('    it allows mutation:')

var counter = 0
counter = counter + 1
if counter == 1:
    print('      [PASS] mutable variable')
    passed = passed + 1
else:
    print('      [FAIL] mutable variable')
    failed = failed + 1

print('    it tracks mutability:')

struct MutBox:
   value: i64

var mbox = MutBox {value: 10 }
mbox = MutBox {value: 20 }
if mbox.value == 20:
    print('      [PASS] mutable struct')
    passed = passed + 1
else:
    print('      [FAIL] mutable struct')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Memory Types')
print('')
print('**Feature ID:** #18')
print('**Category:** Types')
print('**Difficulty:** Level 4/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Pointer Types')
print('')
print('| Type | Name | Ownership | Use Case |')
print('|------|------|-----------|----------|')
print('| T | GC Reference | GC-managed | Default, most code |')
print('| &T | Unique Pointer | Single owner | RAII, exclusive access |')
print('| *T | Shared Pointer | Ref-counted | Multiple owners |')
print('| -T | Weak Pointer | Non-owning | Break cycles |')
print('| +T | Handle Pointer | Pool-managed | Entity systems |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
