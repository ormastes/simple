# Borrowing Feature Specification
# Feature #19: Ownership and Borrowing
# Category: Types | Difficulty: 4 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 19,
    name: 'Borrowing',
    category: 'Types',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/memory.md',
    files: [
        'src/compiler/src/hir/types.rs',
        'src/compiler/src/effects.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_memory_tests.rs'
    ],
    description: 'Ownership semantics with move, borrow, and lifetime tracking. Ensures memory safety without garbage collection for manual memory types.',
    code_examples: [],
    dependencies: [18],
    required_by: [],
    notes: 'Move transfers ownership. Borrow creates temporary reference. Lifetimes prevent dangling pointers. Checked at compile time.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  BORROWING FEATURE SPECIFICATION (#19)')
print('  Category: Types | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Ownership
# -----------------------------------------------------

print('describe Ownership:')
print('  context value ownership:')
print('    it assigns owner:')

struct Resource:
    id: i64
    data: text

val res = Resource { id: 1, data: "owned" }
if res.id == 1:
    print('      [PASS] owner assigned')
    passed = passed + 1
else:
    print('      [FAIL] owner assigned')
    failed = failed + 1

print('    it tracks single owner:')

fn take_ownership(r: Resource) -> i64:
    return r.id

val owner_id = take_ownership(res)
if owner_id == 1:
    print('      [PASS] single owner')
    passed = passed + 1
else:
    print('      [FAIL] single owner')
    failed = failed + 1

# -----------------------------------------------------
# Move Semantics
# -----------------------------------------------------

print('')
print('describe Move semantics:')
print('  context move transfers:')
print('    it moves value:')

struct MoveBox:
    value: i64
    moved: bool

fn move_box(b: MoveBox) -> MoveBox:
    return MoveBox {value: b.value, moved: true }

val original = MoveBox {value: 42, moved: false }
val moved = move_box(original)
if moved.moved and moved.value == 42:
    print('      [PASS] value moved')
    passed = passed + 1
else:
    print('      [FAIL] value moved')
    failed = failed + 1

print('    it invalidates source:')

fn is_moved(b: MoveBox) -> bool:
    return b.moved

if is_moved(moved):
    print('      [PASS] source invalidated')
    passed = passed + 1
else:
    print('      [FAIL] source invalidated')
    failed = failed + 1

print('    it transfers to function:')

fn consume(b: MoveBox) -> i64:
    return b.value * 2

val box_to_consume = MoveBox {value: 10, moved: false }
if consume(box_to_consume) == 20:
    print('      [PASS] transferred to function')
    passed = passed + 1
else:
    print('      [FAIL] transferred to function')
    failed = failed + 1

# -----------------------------------------------------
# Borrowing
# -----------------------------------------------------

print('')
print('describe Borrowing:')
print('  context immutable borrow:')
print('    it allows read access:')

struct Data:
    value: i64

fn read_data(d: Data) -> i64:
    return d.value

val data = Data {value: 100 }
if read_data(data) == 100:
    print('      [PASS] read access')
    passed = passed + 1
else:
    print('      [FAIL] read access')
    failed = failed + 1

print('    it allows multiple readers:')

fn sum_data(d1: Data, d2: Data) -> i64:
    return d1.value + d2.value

val data2 = Data {value: 50 }
if sum_data(data, data2) == 150:
    print('      [PASS] multiple readers')
    passed = passed + 1
else:
    print('      [FAIL] multiple readers')
    failed = failed + 1

print('')
print('  context mutable borrow:')
print('    it allows write access:')

fn modify_value(value: i64) -> i64:
    return value + 10

var mutable_val = 5
mutable_val = modify_value(mutable_val)
if mutable_val == 15:
    print('      [PASS] write access')
    passed = passed + 1
else:
    print('      [FAIL] write access')
    failed = failed + 1

print('    it ensures exclusive access:')

fn exclusive_modify(value: i64) -> i64:
    return value * 2

var exclusive = 7
exclusive = exclusive_modify(exclusive)
if exclusive == 14:
    print('      [PASS] exclusive access')
    passed = passed + 1
else:
    print('      [FAIL] exclusive access')
    failed = failed + 1

# -----------------------------------------------------
# Lifetime Tracking
# -----------------------------------------------------

print('')
print('describe Lifetime tracking:')
print('  context scope lifetime:')
print('    it lives within scope:')

fn scoped_value() -> i64:
    val local = Data {value: 999 }
    return local.value

if scoped_value() == 999:
    print('      [PASS] scoped lifetime')
    passed = passed + 1
else:
    print('      [FAIL] scoped lifetime')
    failed = failed + 1

print('    it extends with return:')

fn return_value() -> Data:
    return Data {value: 888 }

val returned = return_value()
if returned.value == 888:
    print('      [PASS] extended lifetime')
    passed = passed + 1
else:
    print('      [FAIL] extended lifetime')
    failed = failed + 1

print('')
print('  context reference lifetime:')
print('    it tracks ref validity:')

struct RefHolder:
    ref_id: i64
    valid: bool

fn create_ref(id: i64) -> RefHolder:
    return RefHolder { ref_id: id, valid: true }

val ref_holder = create_ref(42)
if ref_holder.valid:
    print('      [PASS] reference valid')
    passed = passed + 1
else:
    print('      [FAIL] reference valid')
    failed = failed + 1

print('    it invalidates on drop:')

fn invalidate_ref(r: RefHolder) -> RefHolder:
    return RefHolder { ref_id: r.ref_id, valid: false }

val dropped = invalidate_ref(ref_holder)
if not dropped.valid:
    print('      [PASS] invalidated on drop')
    passed = passed + 1
else:
    print('      [FAIL] invalidated on drop')
    failed = failed + 1

# -----------------------------------------------------
# Copy vs Move
# -----------------------------------------------------

print('')
print('describe Copy vs Move:')
print('  context copy types:')
print('    it copies primitives:')

val num1 = 42
val num2 = num1
if num1 == 42 and num2 == 42:
    print('      [PASS] primitives copied')
    passed = passed + 1
else:
    print('      [FAIL] primitives copied')
    failed = failed + 1

print('    it copies booleans:')

val bool1 = true
val bool2 = bool1
if bool1 and bool2:
    print('      [PASS] booleans copied')
    passed = passed + 1
else:
    print('      [FAIL] booleans copied')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Borrowing')
print('')
print('**Feature ID:** #19')
print('**Category:** Types')
print('**Difficulty:** Level 4/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Ownership Rules')
print('')
print('| Rule | Description |')
print('|------|-------------|')
print('| Single Owner | Eachvalue has exactly one owner |')
print('| Move | Assignment transfers ownership |')
print('| Drop | Value dropped when owner goes out of scope |')
print('| Borrow | Temporary reference without ownership |')
print('')
print('## Borrow Rules')
print('')
print('| Type | Count | Mutation |')
print('|------|-------|----------|')
print('| Immutable | Multiple | No |')
print('| Mutable | One | Yes |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
