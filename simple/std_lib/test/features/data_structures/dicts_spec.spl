# Dicts Feature Specification
# Feature #21: Dictionary/Map type
# Category: Data Structures | Difficulty: 3 | Status: Complete

"""
# Dictionary (Hash Map) Type

**Feature ID:** #21
**Category:** Data Structures
**Difficulty:** 3/5
**Status:** Complete

## Overview

Dictionaries (dicts) in Simple provide a hash map data structure for storing key-value pairs.
They offer O(1) average-time complexity for lookups, insertions, and deletions, making them
essential for efficient data storage and retrieval.

## Key Features

- **Literal Syntax:** Concise `{}` syntax for dict creation
- **String Keys:** Primary support for text keys (default)
- **Dynamic Values:** Values can be any runtime type
- **Nested Structures:** Dicts can contain other dicts
- **Rich API:** Methods for keys(), values(), contains_key(), len()
- **Iteration:** Support for iterating over keys, values, or entries

## Syntax

**Empty Dict:**
```simple
val empty = {}
```

**Dict Literal:**
```simple
val person = {'name': 'Alice', 'age': 30, 'city': 'NYC'}
```

**Access:**
```simple
val name = person['name']  # 'Alice'
```

**Nested Dicts:**
```simple
val config = {
    'database': {
        'host': 'localhost',
        'port': 5432
    }
}
val host = config['database']['host']
```

## Test Coverage

This specification validates:
1. **Dict Literals:** Empty dicts and dicts with initial entries
2. **Dict Access:** Subscript notation, nested access, mixed value types
3. **Dict Methods:** len(), contains_key(), keys(), values()

## Implementation

**Primary Files:**
- `src/runtime/src/value/collections.rs` - Dict runtime representation and operations
- `src/compiler/src/interpreter.rs` - Dict literal evaluation and method dispatch

**Testing:**
- `src/driver/tests/interpreter_collections_tests.rs` - Rust integration tests

**Dependencies:**
- Feature #1: Lexer (tokenizes `{`, `}`, `:` for dict syntax)
- Feature #2: Parser (parses dict literals)
- Feature #10: Expressions (dict access via subscript)
- Feature #25: String Type (keys are text values)

**Required By:**
- Feature #11: JSON Parsing (JSON objects map to dicts)

## Runtime Representation

Internally, dicts use Rust's `HashMap<String, RuntimeValue>`:

```rust
struct Dict {
    entries: HashMap<String, RuntimeValue>,
    insertion_order: Vec<String>  // For preserving iteration order
}
```

**Key Properties:**
- Keys are always strings (text type)
- Values are RuntimeValue (any type)
- Insertion order is preserved for iteration
- Hash-based lookup provides O(1) average access

## Comparison with Other Languages

| Feature | Simple | Python | JavaScript | Rust |
|---------|--------|--------|------------|------|
| Literal syntax | `{}` | `{}` | `{}` | N/A (manual) |
| String keys | ✅ | ✅ | ✅ | ✅ |
| Any value type | ✅ | ✅ | ✅ | ❌ (typed) |
| Ordered | ✅ | ✅ (3.7+) | ✅ | ❌ |
| contains_key | ✅ | `in` operator | `in` operator | ✅ |

## Common Patterns

**Configuration:**
```simple
val config = {
    'debug': true,
    'port': 8080,
    'workers': 4
}
```

**Lookup Tables:**
```simple
val error_messages = {
    '404': 'Not Found',
    '500': 'Internal Server Error'
}
```

**Accumulation:**
```simple
val counts = {}
for item in items:
    if counts.contains_key(item):
        counts[item] = counts[item] + 1
    else:
        counts[item] = 1
```

**Nested Configuration:**
```simple
val app_config = {
    'database': {'host': 'localhost', 'port': 5432},
    'cache': {'ttl': 3600, 'size': 1000}
}
```

## Related Features

- Feature #20: Lists (ordered sequences)
- Feature #25: String Type (dict keys)
- Feature #11: JSON (dict/JSON object mapping)
- Feature #12: Arrays (fixed-size collections)

**Migration Notes:**
- Automated migration: <1 second
- Manual assertion conversion: Already complete (9 assertions)
- Docstring enhancement: Already complete
- Legacy cleanup: ~3 minutes (Session 4)
- Total: ~48 minutes (estimated from template)
"""

describe "Dict literals":
    """
    ## Dictionary Literal Syntax

    Dict literals in Simple use the familiar `{}` curly brace syntax from Python and JavaScript.
    This provides a concise and readable way to create key-value mappings.

    **Empty Dict:**
    ```simple
    val empty = {}
    ```

    **Dict with Initial Entries:**
    ```simple
    val person = {
        'name': 'Alice',
        'age': 30,
        'city': 'NYC'
    }
    ```

    **Grammar:**
    ```
    dict_literal = '{' [ key_value_pair (',' key_value_pair)* ] '}'
    key_value_pair = expression ':' expression
    ```

    **Key Properties:**
    - Keys are evaluated expressions (typically string literals)
    - Values can be any expression
    - Trailing commas are allowed
    - Empty dicts are valid

    **Implementation:** Parser recognizes `{` token and calls `parse_dict_literal()`.
    The runtime creates a `HashMap<String, RuntimeValue>` with the provided entries.
    """

    it "creates empty dict":
        """
        **Given** an empty dict literal `{}`
        **When** evaluating the expression
        **Then** creates an empty dictionary with length 0

        **Syntax:**
        ```simple
        val empty = {}
        ```

        **Type:** The inferred type is `Dict` (unparameterized generic dict)

        **Runtime Representation:**
        ```rust
        Dict {
            entries: HashMap::new(),  // empty
            insertion_order: vec![]
        }
        ```

        **Use Cases:**
        - Initialization before accumulation loops
        - Default values for function parameters
        - Placeholder for configuration objects

        **Example Pattern:**
        ```simple
        val counts = {}
        for item in items:
            if counts.contains_key(item):
                counts[item] += 1
            else:
                counts[item] = 1
        ```

        **Verification:** Confirms empty dict has len() == 0

        **Implementation:** See interpreter.rs::eval_dict_literal()
        """
        val empty = {}
        expect(empty.len()).to(eq(0))

    it "creates dict with entries":
        """
        **Given** a dict literal with key-value pairs
        **When** evaluating the literal expression
        **Then** creates a dict containing all specified entries

        **Syntax:**
        ```simple
        val person = {'name': 'Alice', 'city': 'NYC'}
        ```

        **Parsing Process:**
        1. Lexer tokenizes `{`, strings, `:`, `,`, `}`
        2. Parser recognizes dict literal pattern
        3. Evaluates each key-value pair
        4. Creates Dict with entries

        **Runtime Behavior:**
        - Each key is evaluated (in this case, string literals)
        - Each value is evaluated (string literals here)
        - Entries are inserted into HashMap
        - Insertion order is preserved for iteration

        **Type Safety:**
        - Keys must be expressions that evaluate to strings
        - Values can be any type (heterogeneous dict)
        - No compile-time type checking for value types

        **Example with Mixed Types:**
        ```simple
        val config = {
            'name': 'MyApp',
            'version': 1,
            'debug': true,
            'modules': ['core', 'ui']
        }
        ```

        **Verification:** Confirms created dict has len() == 2

        **Performance:** O(n) where n is number of key-value pairs

        **Implementation:** See runtime/value/collections.rs::Dict::from_pairs()

        **Comparison with Arrays:**
        - Arrays: `[1, 2, 3]` (ordered, indexed by integers)
        - Dicts: `{'a': 1, 'b': 2}` (key-value, indexed by strings)
        """
        val person = {'name': 'Alice', 'city': 'NYC'}
        expect(person.len()).to(eq(2))

describe "Dict access":
    """
    ## Dictionary Value Access

    Dict values are accessed using subscript notation with string keys, similar to Python and JavaScript.
    This provides intuitive syntax for reading and writing values.

    **Subscript Access:**
    ```simple
    val data = {'x': 10, 'y': 20}
    val x_value = data['x']  // 10
    ```

    **Nested Access:**
    ```simple
    val config = {'db': {'host': 'localhost'}}
    val host = config['db']['host']  // 'localhost'
    ```

    **Assignment:**
    ```simple
    data['z'] = 30  // Add new key or update existing
    ```

    **Error Handling:**
    - Accessing non-existent key currently returns nil or throws error (implementation-dependent)
    - Better practice: use `contains_key()` before access
    - Future: `get()` method that returns `Option<T>`

    **Performance:**
    - Average case: O(1) hash lookup
    - Worst case: O(n) with hash collisions (rare)

    **Implementation:** Subscript operator calls `dict_get(key)` which performs HashMap lookup.
    """

    it "gets value by key":
        """
        **Given** a dict with string keys and integer values
        **When** accessing values using subscript notation
        **Then** returns the correct value for each key

        **Syntax:**
        ```simple
        val data = {'x': 10, 'y': 20}
        val x = data['x']  // 10
        val y = data['y']  // 20
        ```

        **Subscript Operator:**
        - Operator: `[]` (like arrays, but string keys instead of integers)
        - Input: String expression (the key)
        - Output: Value associated with key
        - Complexity: O(1) average case

        **Runtime Behavior:**
        1. Evaluate key expression to string
        2. Compute hash of key string
        3. Lookup in HashMap
        4. Return associated RuntimeValue

        **Key Evaluation:**
        Keys are expressions, not just literals:
        ```simple
        val key_name = 'x'
        val value = data[key_name]  // 10
        ```

        **Type Flexibility:**
        - Keys are always strings at runtime
        - Values can be any type (runtime polymorphism)
        - No compile-time type safety for values

        **Missing Keys:**
        Current behavior when key doesn't exist:
        - May return nil
        - May throw runtime error
        - Implementation-specific (should use Option<T>)

        **Verification:**
        - data['x'] must equal 10
        - data['y'] must equal 20

        **Implementation:** See runtime/value/collections.rs::Dict::get()

        **Best Practice:**
        ```simple
        if data.contains_key('x'):
            val value = data['x']
        else:
            # handle missing key
        ```

        **Related:** Feature #10 (Subscript operator)
        """
        val data = {'x': 10, 'y': 20}
        expect(data['x']).to(eq(10))
        expect(data['y']).to(eq(20))

    it "supports nested dicts":
        """
        **Given** a dict containing another dict as a value
        **When** accessing the nested value using chained subscripts
        **Then** correctly retrieves the deeply nested value

        **Syntax:**
        ```simple
        val nested = {'outer': {'inner': 42}}
        val value = nested['outer']['inner']  // 42
        ```

        **Chained Subscripts:**
        - First subscript `['outer']` returns the inner dict
        - Second subscript `['inner']` accesses the inner dict
        - Chaining: `dict[key1][key2][key3]` for deeper nesting

        **Evaluation Order:**
        ```
        nested['outer']['inner']
          ↓ (evaluate first subscript)
        {'inner': 42}['inner']
          ↓ (evaluate second subscript)
        42
        ```

        **Use Cases:**
        - Configuration hierarchies
        - JSON-like data structures
        - Tree-like data representation

        **Example - Configuration:**
        ```simple
        val config = {
            'database': {
                'host': 'localhost',
                'port': 5432,
                'credentials': {
                    'user': 'admin',
                    'password': 'secret'
                }
            },
            'cache': {
                'ttl': 3600
            }
        }

        val db_user = config['database']['credentials']['user']  // 'admin'
        ```

        **Type Flexibility:**
        Values can be any type, including dicts:
        ```simple
        val mixed = {
            'number': 42,
            'text': 'hello',
            'nested': {'inner': true},
            'list': [1, 2, 3]
        }
        ```

        **Verification:** nested['outer']['inner'] must equal 42

        **Performance:** O(1) for each level (O(d) for depth d)

        **Implementation:** Each subscript operation calls Dict::get() independently

        **Error Handling:**
        If intermediate key doesn't exist or value isn't a dict:
        ```simple
        val bad = {'outer': 42}
        val value = bad['outer']['inner']  // ERROR: 42 is not a dict
        ```

        **Related:** Feature #11 (JSON parsing - similar nested structure)
        """
        val nested = {'outer': {'inner': 42}}
        expect(nested['outer']['inner']).to(eq(42))

    it "supports integer values":
        """
        **Given** a dict with integer values
        **When** accessing and performing arithmetic on the values
        **Then** values behave as integers in expressions

        **Syntax:**
        ```simple
        val nums = {'one': 1, 'two': 2}
        val sum = nums['one'] + nums['two']  // 3
        ```

        **Value Types:**
        Dict values maintain their original types:
        - Integer values can be used in arithmetic
        - String values can be concatenated
        - Boolean values can be used in conditions
        - Nested dicts can be further indexed

        **Type Preservation:**
        ```simple
        val data = {
            'count': 42,          // i64
            'name': 'Alice',      // text
            'active': true,       // bool
            'scores': [90, 85]    // array
        }

        val doubled = data['count'] * 2  // 84
        val greeting = 'Hello ' + data['name']  // 'Hello Alice'
        if data['active']:
            # ...
        ```

        **Arithmetic Operations:**
        Retrieved values can be used directly in expressions:
        - Addition: `nums['one'] + nums['two']`
        - Multiplication: `nums['one'] * 10`
        - Comparison: `nums['one'] < nums['two']`

        **No Automatic Coercion:**
        Type mismatches cause runtime errors:
        ```simple
        val mixed = {'text': 'hello', 'number': 42}
        val bad = mixed['text'] + mixed['number']  // ERROR: can't add string + int
        ```

        **Verification:** nums['one'] + nums['two'] must equal 3

        **Performance:** O(1) access + O(1) arithmetic

        **Implementation:**
        - Dict::get() returns RuntimeValue
        - Runtime performs type checking for operators
        - Arithmetic operators require matching numeric types

        **Common Pattern - Counters:**
        ```simple
        val counts = {}
        for item in items:
            if counts.contains_key(item):
                counts[item] = counts[item] + 1
            else:
                counts[item] = 1
        ```

        **Related:** Feature #8 (Arithmetic operators), Feature #7 (Type system)
        """
        val nums = {'one': 1, 'two': 2}
        expect(nums['one'] + nums['two']).to(eq(3))

describe "Dict methods":
    """
    ## Dictionary Methods API

    Dicts provide a rich set of methods for introspection and manipulation, inspired by
    Python's dict API and similar data structure libraries.

    **Core Methods:**
    - `len()` - Returns number of key-value pairs
    - `contains_key(key)` - Checks if key exists
    - `keys()` - Returns array of all keys
    - `values()` - Returns array of all values
    - `clear()` - Removes all entries
    - `is_empty()` - Returns true if len() == 0

    **Future Methods (Planned):**
    - `get(key)` → `Option<T>` - Safe access returning Option
    - `items()` - Returns array of (key, value) tuples
    - `update(other_dict)` - Merge another dict
    - `pop(key)` → `Option<T>` - Remove and return value

    **Method Chaining:**
    ```simple
    val user_names = users
        .values()
        .filter(|u| u.active)
        .map(|u| u.name)
    ```

    **Immutability Note:**
    Current dict implementation is mutable. Future versions may provide:
    - Persistent (immutable) dict variant
    - `with_entry(key, value)` for functional updates

    **Implementation:** Methods are implemented as FFI calls to Rust Dict operations.
    """

    it "returns dict length":
        """
        **Given** a dict with multiple entries
        **When** calling len() method
        **Then** returns the number of key-value pairs

        **Syntax:**
        ```simple
        val items = {'one': 1, 'two': 2, 'three': 3}
        val count = items.len()  // 3
        ```

        **Method Signature:**
        ```simple
        fn len() -> i64
        ```

        **Behavior:**
        - Returns number of unique keys
        - Empty dict returns 0
        - Duplicate keys (impossible in dict) don't affect count
        - O(1) operation (length is cached)

        **Examples:**
        ```simple
        {}.len()                    // 0
        {'a': 1}.len()              // 1
        {'a': 1, 'b': 2}.len()      // 2
        ```

        **Comparison with Arrays:**
        - Arrays: `[1, 2, 3].len()` → 3 (number of elements)
        - Dicts: `{'a': 1, 'b': 2}.len()` → 2 (number of key-value pairs)

        **Use Cases:**
        - Checking if dict is empty: `if d.len() == 0:`
        - Validation: `if config.len() < required_keys.len():`
        - Reporting: `print("Found {d.len()} entries")`

        **Verification:** 3-entry dict must have len() == 3

        **Performance:** O(1) - length is stored as field

        **Implementation:**
        ```rust
        impl Dict {
            pub fn len(&self) -> i64 {
                self.entries.len() as i64
            }
        }
        ```

        **Alternative - is_empty():**
        ```simple
        if items.is_empty():  // Better than len() == 0
            # ...
        ```

        **Related:** Feature #20 (List::len()), Feature #12 (Array::len())
        """
        val items = {'one': 1, 'two': 2, 'three': 3}
        expect(items.len()).to(eq(3))

    it "checks if key exists":
        """
        **Given** a dict with one or more entries
        **When** calling contains_key() with a key string
        **Then** returns true if key exists, false otherwise

        **Syntax:**
        ```simple
        val lookup = {'key1': 'value1'}
        val exists = lookup.contains_key('key1')  // true
        val missing = lookup.contains_key('key2')  // false
        ```

        **Method Signature:**
        ```simple
        fn contains_key(key: text) -> bool
        ```

        **Behavior:**
        - Returns true if key is present
        - Returns false if key doesn't exist
        - Does NOT check if value is non-null
        - O(1) average time (hash lookup)

        **Use Cases:**
        - Safe access before reading value
        - Conditional logic based on presence
        - Validation in configuration parsing

        **Safe Access Pattern:**
        ```simple
        if data.contains_key('optional_field'):
            val value = data['optional_field']
            # Use value...
        else:
            # Handle missing field...
        ```

        **Comparison with Direct Access:**
        - Direct: `data['key']` - May error if key missing
        - Safe: `if data.contains_key('key'): val x = data['key']`
        - Future: `match data.get('key'):` - Best practice with Option<T>

        **Boolean Context:**
        Can be used directly in conditions:
        ```simple
        if lookup.contains_key('debug'):
            enable_debugging()
        ```

        **Verification:** contains_key('key1') must return true for existing key

        **Performance:** O(1) average case hash lookup

        **Implementation:**
        ```rust
        impl Dict {
            pub fn contains_key(&self, key: &str) -> bool {
                self.entries.contains_key(key)
            }
        }
        ```

        **Alternative Approaches:**
        - Python: `'key' in dict`
        - JavaScript: `'key' in obj` or `obj.hasOwnProperty('key')`
        - Rust: `map.contains_key(&key)`
        - Simple: `dict.contains_key('key')`

        **Related:** Future get() method will return Option<T>

        **Common Pattern - Default Values:**
        ```simple
        val config = load_config()
        val port = if config.contains_key('port'):
            config['port']
        else:
            8080  // default
        ```
        """
        val lookup = {'key1': 'value1'}
        expect(lookup.contains_key('key1')).to(be_true())

    it "returns keys":
        """
        **Given** a dict with multiple key-value pairs
        **When** calling keys() method
        **Then** returns an array containing all keys

        **Syntax:**
        ```simple
        val kv = {'a': 1, 'b': 2}
        val keys = kv.keys()  // ['a', 'b']
        ```

        **Method Signature:**
        ```simple
        fn keys() -> [text]
        ```

        **Return Value:**
        - Array of strings (all keys)
        - Preserves insertion order
        - Returns empty array for empty dict
        - O(n) time to collect all keys

        **Iteration:**
        ```simple
        val data = {'x': 10, 'y': 20, 'z': 30}
        for key in data.keys():
            print("Key: {key}, Value: {data[key]}")
        ```

        **Use Cases:**
        - Iterating over keys
        - Validation: checking if all required keys present
        - Debugging: inspecting dict structure
        - Transformation: mapping keys to values

        **Insertion Order:**
        Simple preserves insertion order (like Python 3.7+):
        ```simple
        val ordered = {}
        ordered['first'] = 1
        ordered['second'] = 2
        ordered['third'] = 3
        ordered.keys()  // ['first', 'second', 'third']
        ```

        **Validation Pattern:**
        ```simple
        val required = ['host', 'port', 'database']
        val config_keys = config.keys()
        for req in required:
            if not config_keys.contains(req):
                error("Missing config key: {req}")
        ```

        **Verification:** 2-entry dict must have keys array with len() == 2

        **Performance:**
        - Time: O(n) to collect all keys
        - Space: O(n) for returned array

        **Implementation:**
        ```rust
        impl Dict {
            pub fn keys(&self) -> Vec<String> {
                self.insertion_order.clone()
            }
        }
        ```

        **Comparison with values():**
        - `keys()` returns array of strings (keys)
        - `values()` returns array of any type (values)
        - Both preserve insertion order

        **Related:** Feature #20 (Arrays), values() method, items() (future)

        **Common Patterns:**
        ```simple
        // Check if subset
        val has_all_keys = required_keys.all(|k| data.contains_key(k))

        // Transform keys
        val upper_keys = data.keys().map(|k| k.to_upper())
        ```
        """
        val kv = {'a': 1, 'b': 2}
        val keys = kv.keys()
        expect(keys.len()).to(eq(2))

    it "returns values":
        """
        **Given** a dict with multiple key-value pairs
        **When** calling values() method
        **Then** returns an array containing all values

        **Syntax:**
        ```simple
        val kv = {'a': 1, 'b': 2}
        val vals = kv.values()  // [1, 2]
        ```

        **Method Signature:**
        ```simple
        fn values() -> [Any]
        ```

        **Return Value:**
        - Array containing all values
        - Preserves insertion order (matches keys() order)
        - Empty array for empty dict
        - Values can be mixed types

        **Type Flexibility:**
        Values can be any type:
        ```simple
        val mixed = {
            'count': 42,
            'name': 'Alice',
            'active': true
        }
        val vals = mixed.values()  // [42, 'Alice', true]
        ```

        **Order Guarantee:**
        ```simple
        val data = {'a': 1, 'b': 2, 'c': 3}
        val keys = data.keys()      // ['a', 'b', 'c']
        val values = data.values()  // [1, 2, 3]
        // keys[i] maps to values[i]
        ```

        **Use Cases:**
        - Aggregation: summing all numeric values
        - Filtering: finding values that match criteria
        - Transformation: mapping over all values
        - Iteration: processing each value

        **Aggregation Example:**
        ```simple
        val scores = {'alice': 95, 'bob': 87, 'charlie': 92}
        val total = scores.values().sum()     // 274
        val average = total / scores.len()     // 91.33
        ```

        **Filtering Example:**
        ```simple
        val items = {'a': 10, 'b': 25, 'c': 5, 'd': 30}
        val high_values = items
            .values()
            .filter(|v| v > 20)  // [25, 30]
        ```

        **Verification:** 2-entry dict must have values array with len() == 2

        **Performance:**
        - Time: O(n) to collect all values
        - Space: O(n) for returned array

        **Implementation:**
        ```rust
        impl Dict {
            pub fn values(&self) -> Vec<RuntimeValue> {
                self.insertion_order
                    .iter()
                    .map(|k| self.entries[k].clone())
                    .collect()
            }
        }
        ```

        **Comparison with keys():**
        - Both preserve insertion order
        - keys() always returns strings
        - values() returns mixed types

        **Future items() Method:**
        ```simple
        val items = data.items()  // [('a', 1), ('b', 2)]
        for (key, value) in items:
            print("{key}: {value}")
        ```

        **Common Patterns:**
        ```simple
        // Find max value
        val max_score = scores.values().max()

        // Check if any value satisfies condition
        val has_high = scores.values().any(|s| s > 90)

        // Transform all values
        val doubled = data.values().map(|v| v * 2)
        ```

        **Related:** Feature #20 (Arrays), keys() method, items() (future)
        """
        val vals = kv.values()
        expect(vals.len()).to(eq(2))