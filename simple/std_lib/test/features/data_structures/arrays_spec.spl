# Arrays Feature Specification
"""
# Arrays (Dynamic Lists)

**Feature ID:** #20
**Category:** Data Structures
**Difficulty:** 2/5 (Beginner-Intermediate)
**Status:** Complete

## Overview

Arrays in Simple are dynamically-sized, ordered collections of values accessible by index.
Following Python's list model, Simple arrays are heterogeneous (can hold mixed types),
zero-indexed, and support rich built-in methods for functional programming.

**Key Features:**
- **Dynamic sizing:** Arrays grow/shrink as elements are added/removed
- **Zero-indexed:** First element at index 0
- **Heterogeneous:** Can mix types (unless type-constrained)
- **Built-in methods:** map, filter, reduce, find, sort, reverse, slice
- **Literal syntax:** `[1, 2, 3]` for array creation
- **Immutable operations:** Methods return new arrays, don't mutate original

## Syntax

### Array Literals

```simple
# Homogeneous arrays
val numbers = [1, 2, 3, 4, 5]
val strings = ["hello", "world"]
val booleans = [true, false, true]

# Heterogeneous (mixed types)
val mixed = [1, "text", true, [1, 2]]

# Empty array
val empty = []

# Nested arrays
val matrix = [[1, 2], [3, 4], [5, 6]]
```

### Indexing

```simple
val arr = [10, 20, 30]
val first = arr[0]   # 10
val second = arr[1]  # 20
val third = arr[2]   # 30
```

**Grammar:**
```
index_expr = expression '[' expression ']'
```

### Array Methods

```simple
# Length
val len = arr.len()  # 3

# Element access
val item = arr[0]    # First element
val last = arr[arr.len() - 1]  # Last element

# Transformation
val doubled = arr.map(\x: x * 2)
val evens = arr.filter(\x: x % 2 == 0)
val sum = arr.reduce(0, \acc, x: acc + x)

# Searching
val found = arr.find(\x: x > 5)
val has_ten = arr.contains(10)

# Mutation (creates new array)
val extended = arr + [40, 50]
```

## Runtime Representation

**Array Storage:**
```rust
pub enum RuntimeValue {
    List(Vec<RuntimeValue>),
    // ... other variants
}
```

**Implementation:**
- Backed by Rust `Vec<RuntimeValue>`
- Dynamic resizing with capacity management
- Copy-on-write semantics for immutability
- O(1) indexing, O(n) search

**Memory Layout:**
```
Array: [ptr | len | cap]
         ↓
Heap: [elem0 | elem1 | elem2 | ... | elemN]
```

## Comparison with Other Languages

| Feature | Simple | Python | JavaScript | Rust | Scala |
|---------|--------|--------|------------|------|-------|
| Syntax | `[1, 2, 3]` | `[1, 2, 3]` | `[1, 2, 3]` | `vec![1, 2, 3]` | `List(1, 2, 3)` |
| Indexing | `arr[0]` | `arr[0]` | `arr[0]` | `arr[0]` | `arr(0)` |
| Length | `.len()` | `len(arr)` | `.length` | `.len()` | `.length` |
| Map | `.map(fn)` | `map(fn, arr)` | `.map(fn)` | `.iter().map(fn)` | `.map(fn)` |
| Filter | `.filter(fn)` | `filter(fn, arr)` | `.filter(fn)` | `.iter().filter(fn)` | `.filter(fn)` |
| Reduce | `.reduce(init, fn)` | `reduce(fn, arr, init)` | `.reduce(fn, init)` | `.iter().fold(init, fn)` | `.foldLeft(init)(fn)` |
| Mutability | Immutable methods | Mutable | Mutable | Explicit (`&mut`) | Immutable |
| Heterogeneous | ✅ Yes | ✅ Yes | ✅ Yes | ❌ No (typed) | ❌ No (typed) |

**Philosophy:**
- Simple: Python-like flexibility with functional methods
- Python: Mutable lists with comprehensions
- JavaScript: Mutable arrays with functional methods
- Rust: Typed vectors with iterator chains
- Scala: Immutable lists with rich functional API

## Common Patterns

### Map-Filter-Reduce Pipeline
```simple
val result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(\x: x % 2 == 0)      # [2, 4, 6, 8, 10]
    .map(\x: x * x)              # [4, 16, 36, 64, 100]
    .reduce(0, \acc, x: acc + x) # 220
```

### Array Comprehension (Manual)
```simple
var evens = []
for x in [1, 2, 3, 4, 5]:
    if x % 2 == 0:
        evens = evens + [x]
# evens = [2, 4]
```

### Finding Elements
```simple
val users = [
    User { name: "Alice", age: 30 },
    User { name: "Bob", age: 25 }
]
val found = users.find(\u: u.name == "Alice")
```

### Concatenation
```simple
val a = [1, 2, 3]
val b = [4, 5, 6]
val combined = a + b  # [1, 2, 3, 4, 5, 6]
```

## Built-in Methods

### Accessors
- `len()` - Returns array length (number of elements)
- `[index]` - Access element at index (zero-based)

### Transformations (Return New Array)
- `map(fn)` - Apply function to each element
- `filter(fn)` - Keep elements where predicate is true
- `reduce(init, fn)` - Fold elements into single value

### Searching
- `find(fn)` - Find first element matching predicate
- `contains(value)` - Check if array contains value

### Sorting (Planned)
- `sort()` - Sort array in ascending order
- `reverse()` - Reverse array order

### Slicing (Planned)
- `slice(start, end)` - Extract subarray
- `take(n)` - Take first n elements
- `drop(n)` - Skip first n elements

## Implementation Files

**Runtime:** `src/runtime/src/value/collections.rs` - Array methods implementation
**Interpreter:** `src/compiler/src/interpreter.rs` - Array evaluation, indexing
**Parser:** `src/parser/src/expressions/mod.rs` - Array literal parsing
**Tests:** `src/driver/tests/interpreter_collections_tests.rs` - Array tests

## Related Features

- **Tuples (#18):** Fixed-size, immutable collections
- **Strings (#TBD):** Character arrays with string methods
- **Range (#TBD):** Lazy sequences for iteration
- **For Loops (#13):** Iterate over arrays
- **Functions (#12):** Higher-order methods (map/filter/reduce)

## Performance Characteristics

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Create literal | O(n) | O(n) | n = number of elements |
| Index access | O(1) | - | Direct pointer arithmetic |
| len() | O(1) | - | Stored field |
| Concatenation (+) | O(n+m) | O(n+m) | Creates new array |
| map(fn) | O(n) | O(n) | New array with transformed elements |
| filter(fn) | O(n) | O(k) | k = matching elements |
| reduce(init, fn) | O(n) | O(1) | Single accumulator |
| find(fn) | O(n) | O(1) | Early exit on match |
| contains(v) | O(n) | O(1) | Linear search |

**Amortized Complexity:**
- Array growth uses exponential resizing (1.5x or 2x)
- Push operations are O(1) amortized

## Limitations and Future Work

**Current Limitations:**
- No built-in sort/reverse (planned)
- No slicing syntax (`arr[1:5]`)
- No negative indexing (`arr[-1]` for last element)
- No multi-dimensional indexing sugar (`arr[i][j]` works but verbose)
- No array comprehensions (`[x*2 for x in arr if x > 0]`)

**Planned Features:**
- Slice syntax: `arr[start:end]`, `arr[:5]`, `arr[5:]`
- Negative indexing: `arr[-1]` (last element)
- Array comprehensions: `[expr for var in arr if condition]`
- Destructuring: `val [a, b, c] = arr`
- Pattern matching on arrays: `match arr: [first, ...rest] => ...`
- Typed arrays: `List<i32>` with compile-time type checking
- Parallel methods: `par_map`, `par_filter` for large arrays

## Type System Integration

**Generic Arrays (Planned):**
```simple
# Type-constrained arrays
val numbers: List<i32> = [1, 2, 3]
val strings: List<text> = ["a", "b", "c"]

# Type inference
val inferred = [1, 2, 3]  # Inferred as List<i32>

# Heterogeneous allowed without type constraint
val mixed = [1, "text", true]  # OK without type annotation
```

**Current:** Arrays are heterogeneous by default (no type constraint)
**Future:** Optional type constraints with generic syntax
"""

import std.spec


describe "Array creation":
    """
    ## Creating Arrays

    Arrays are created using square bracket literal syntax. Elements are comma-separated
    and can be of any type (heterogeneous arrays supported).

    **Syntax:** `[elem1, elem2, elem3, ...]`

    **Empty Array:** `[]`

    **Implementation:** Parsed as ArrayLiteral AST node, evaluated to RuntimeValue::List
    """

        it "creates array literal":
            """
            **Given** an array literal with integer elements
            **When** evaluating the literal
            **Then** creates an array containing the elements in order

            **Example:**
            ```simple
            val arr = [1, 2, 3]
            assert arr.len() == 3
            assert arr[0] == 1
            ```

            **Runtime:** Vec<RuntimeValue> with elements [Int(1), Int(2), Int(3)]
            """
val arr = [1, 2, 3]
expect(arr.len()).to(eq(3))

        it "creates empty array":
            """
            **Given** an empty array literal `[]`
            **When** evaluating the literal
            **Then** creates an array with length 0

            **Example:**
            ```simple
            val empty = []
            assert empty.len() == 0
            ```

            **Use Case:** Initialize empty array before populating in loop
            """
val empty = []
expect(empty.len()).to(eq(0))

describe "Array indexing":
    """
    ## Array Indexing - Element Access

    Arrays are zero-indexed: first element at index 0, last at index len()-1.
    Indexing uses square bracket syntax: `array[index]`.

    **Grammar:** `array_expr '[' index_expr ']'`

    **Bounds:** Out-of-bounds access panics (runtime error)

    **Implementation:** O(1) direct access to underlying Vec
    """

        it "accesses elements by index":
            """
            **Given** an array with elements
            **When** accessing elements with index operator
            **Then** returns the element at that position

            **Example:**
            ```simple
            val arr = [10, 20, 30]
            assert arr[0] == 10  # First element
            assert arr[1] == 20  # Second element
            assert arr[2] == 30  # Third element
            ```

            **Zero-indexed:** First element is at index 0, not 1
            """
val arr2 = [10, 20, 30]
expect(arr2[0]).to(eq(10))
expect(arr2[1]).to(eq(20))
expect(arr2[2]).to(eq(30))

        it "gets array length":
            """
            **Given** an array with elements
            **When** calling .len() method
            **Then** returns the number of elements

            **Example:**
            ```simple
            val arr = [1, 2, 3, 4, 5]
            assert arr.len() == 5
            ```

            **Performance:** O(1) - stored as Vec field
            """
val arr3 = [1, 2, 3, 4, 5]
expect(arr3.len()).to(eq(5))

describe "Array methods":
    """
    ## Array Methods - Higher-Order Operations

    Arrays support functional programming methods that operate on elements
    without mutating the original array. All methods return new arrays.

    **Functional Methods:**
    - `map(fn)` - Transform each element
    - `filter(fn)` - Select elements matching predicate
    - `reduce(init, fn)` - Aggregate elements into single value

    **Philosophy:** Immutable operations - original array unchanged

    **Implementation:** `src/runtime/src/value/collections.rs`
    """

        it "transforms with map":
            """
            **Given** an array and a transformation function
            **When** calling .map(fn)
            **Then** returns new array with function applied to each element

            **Example:**
            ```simple
            val numbers = [1, 2, 3]
            val doubled = numbers.map(\x: x * 2)
            assert doubled == [2, 4, 6]
            assert numbers == [1, 2, 3]  # Original unchanged
            ```

            **Signature:** `map(fn: T -> U) -> List<U>`
            **Performance:** O(n) where n = array length
            """
val numbers = [1, 2, 3]
val doubled = numbers.map(\x: x * 2)
expect(doubled).to(eq([2, 4, 6]))

        it "filters with predicate":
            """
            **Given** an array and a predicate function
            **When** calling .filter(fn)
            **Then** returns new array with only elements where predicate is true

            **Example:**
            ```simple
            val numbers = [1, 2, 3, 4, 5]
            val evens = numbers.filter(\x: x % 2 == 0)
            assert evens == [2, 4]
            ```

            **Signature:** `filter(fn: T -> bool) -> List<T>`
            **Performance:** O(n), result size ≤ n
            """
val numbers2 = [1, 2, 3, 4, 5]
val evens = numbers2.filter(\x: x % 2 == 0)
expect(evens).to(eq([2, 4]))

        it "aggregates with reduce":
            """
            **Given** an array, initial value, and reduction function
            **When** calling .reduce(init, fn)
            **Then** combines all elements into single value using accumulator

            **Example:**
            ```simple
            val numbers = [1, 2, 3, 4]
            val sum = numbers.reduce(0, \acc, x: acc + x)
            assert sum == 10
            ```

            **Process:**
            1. Start with init (0)
            2. For each element: acc = fn(acc, element)
            3. Return final acc

            **Signature:** `reduce(init: U, fn: (U, T) -> U) -> U`
            **Performance:** O(n)
            """
val numbers3 = [1, 2, 3, 4]
val sum = numbers3.reduce(0, \acc, x: acc + x)
expect(sum).to(eq(10))

describe "Array concatenation":
    """
    ## Array Concatenation

    Arrays can be concatenated using the `+` operator, creating a new array
    containing all elements from both arrays in order.

    **Syntax:** `arr1 + arr2`

    **Immutability:** Creates new array, doesn't modify originals

    **Performance:** O(n+m) where n, m are array lengths

    **Implementation:** Creates new Vec and copies all elements
    """

        it "concatenates arrays":
            """
            **Given** two arrays
            **When** using + operator to concatenate
            **Then** returns new array with all elements from both arrays

            **Example:**
            ```simple
            val a = [1, 2, 3]
            val b = [4, 5, 6]
            val combined = a + b
            assert combined == [1, 2, 3, 4, 5, 6]
            assert a == [1, 2, 3]  # Original unchanged
            assert b == [4, 5, 6]  # Original unchanged
            ```

            **Pattern:** Building arrays incrementally
            ```simple
            var result = []
            result = result + [1]
            result = result + [2, 3]
            # result = [1, 2, 3]
            ```
            """
val a = [1, 2]
val b = [3, 4]
val combined = a + b
expect(combined).to(eq([1, 2, 3, 4]))
