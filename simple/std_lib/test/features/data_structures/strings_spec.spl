"""
# String Type (text)

**Feature ID:** #25
**Category:** Data Structures
**Difficulty:** 2/5
**Status:** Complete

## Overview

The `text` type in Simple represents immutable UTF-8 encoded strings. Strings support both single-quote
and double-quote literals, with double quotes enabling interpolation. Simple provides a rich set of
string methods for manipulation, searching, and transformation.

Strings are immutable - operations like `replace()` and `upper()` return new strings rather than
modifying the original. This ensures thread safety and makes string behavior predictable.

## Syntax

### String Literals

**Single Quotes (Raw Strings):**
```simple
val name = 'Alice'
val path = '/home/user/file.txt'
```

**Double Quotes (With Interpolation):**
```simple
val age = 25
val message = "Alice is {age} years old"  # Interpolation
```

**Grammar:**
```
string_literal = SINGLE_QUOTE chars SINGLE_QUOTE
               | DOUBLE_QUOTE (chars | interpolation)* DOUBLE_QUOTE
interpolation = '{' expression '}'
```

### String Concatenation

```simple
val first = 'Hello'
val second = ' world'
val result = first + second  # "Hello world"
```

### String Interpolation (f-strings)

```simple
val name = 'Bob'
val score = 95
val message = "Player {name} scored {score} points"
# Result: "Player Bob scored 95 points"
```

**Interpolation Features:**
- Any expression can be interpolated: `"Result: {x + y}"`
- Works with variables, function calls, field access
- Only available in double-quoted strings

### String Methods

```simple
val text = "Hello World"

# Length
text.len()                    # 11

# Case conversion
text.upper()                  # "HELLO WORLD"
text.lower()                  # "hello world"

# Searching
text.contains("World")        # true
text.starts_with("Hello")     # true
text.ends_with("World")       # true

# Transformation
text.replace("World", "Simple")  # "Hello Simple"
text.trim()                      # Remove whitespace

# Splitting
"a,b,c".split(",")            # ["a", "b", "c"]
```

## Runtime Representation

Strings are stored as `RuntimeValue::String(String)` using Rust's String type:

```rust
pub enum RuntimeValue {
    String(String),  // UTF-8 heap-allocated string
    // ... other variants
}
```

**Memory Layout:**
- Heap-allocated (pointer + length + capacity)
- UTF-8 encoding (variable bytes per character)
- Immutable (copying on modification)

**String Methods:**
```rust
impl RuntimeValue {
    pub fn string_len(&self) -> usize { ... }
    pub fn string_contains(&self, needle: &str) -> bool { ... }
    pub fn string_replace(&self, from: &str, to: &str) -> String { ... }
    pub fn string_split(&self, delimiter: &str) -> Vec<String> { ... }
    // ... more methods
}
```

## Key Properties

**Immutability:**
- Strings cannot be modified in-place
- All methods return new strings
- Original string unchanged

**UTF-8 Encoding:**
- Full Unicode support
- Multi-byte characters supported
- Length is byte count (not character count)

**Concatenation:**
- Uses `+` operator
- Creates new string (does not modify operands)
- Can chain: `a + b + c`

**Interpolation:**
- Only in double-quoted strings
- Expressions evaluated at runtime
- Automatic conversion to string (via `.to_string()`)

**Method Chaining:**
```simple
val result = text.trim().lower().replace(" ", "_")
```

## Comparison with Other Languages

| Feature | Simple | Python | Rust | JavaScript |
|---------|--------|--------|------|------------|
| Type Name | `text` | `str` | `String`, `&str` | `string` |
| Literals | `'...'`, `"..."` | `'...'`, `"..."`, `"""..."""` | `"..."` | `'...'`, `"..."`, `` `...` `` |
| Interpolation | `"{x}"` (double quotes) | `f"{x}"` | `format!("{}", x)` | `` `${x}` `` |
| Mutability | Immutable | Immutable | Mutable (`String`) | Immutable |
| Concatenation | `+` | `+` | `+` (String only) | `+` |
| Encoding | UTF-8 | UTF-8 | UTF-8 | UTF-16 |
| Length Method | `.len()` | `len(s)` | `.len()` | `.length` |
| Case Methods | `.upper()`, `.lower()` | `.upper()`, `.lower()` | `.to_uppercase()` | `.toUpperCase()` |

**Key Differences:**
- Simple has single `text` type (Rust has `String` vs `&str`)
- Simple interpolation requires double quotes (Python uses `f"..."` prefix)
- Simple uses methods (Rust uses functions for some operations)
- Simple `.len()` is byte count like Rust (not char count like Python)

## Common Patterns

### String Building

```simple
# Simple concatenation
val full_name = first_name + " " + last_name

# With interpolation
val greeting = "Hello, {first_name} {last_name}!"

# Building from parts
val parts = ["Alice", "Bob", "Charlie"]
val joined = parts.join(", ")  # "Alice, Bob, Charlie"
```

### String Parsing

```simple
# CSV parsing
val csv_line = "name,age,city"
val fields = csv_line.split(",")

# Path parsing
val path = "/home/user/file.txt"
if path.starts_with("/home"):
    val filename = path.split("/").last()
```

### String Validation

```simple
fn is_valid_email(email: text) -> bool:
    return email.contains("@") and email.contains(".")

fn is_numeric_id(id: text) -> bool:
    return id.len() > 0 and id.all(is_digit)
```

### Template Strings

```simple
fn format_error(code: i32, message: text) -> text:
    return "Error {code}: {message}"

fn format_date(year: i32, month: i32, day: i32) -> text:
    return "{year}-{month:02}-{day:02}"
```

### String Transformation

```simple
# Normalize user input
fn normalize_username(input: text) -> text:
    return input.trim().lower()

# Title case
fn to_title_case(s: text) -> text:
    val words = s.split(" ")
    return words.map(capitalize).join(" ")
```

## Implementation Files

**Runtime:**
- `src/runtime/src/value/collections.rs` - String method implementations
- `src/runtime/src/value/core.rs` - RuntimeValue::String variant

**Parser:**
- `src/parser/src/lexer.rs` - String literal tokenization
- `src/parser/src/expressions/mod.rs` - String interpolation parsing

**Interpreter:**
- `src/compiler/src/interpreter.rs` - String operations, concatenation, interpolation

**Tests:**
- `src/driver/tests/interpreter_strings_tests.rs` - Rust integration tests
- `simple/std_lib/test/features/data_structures/strings_spec.spl` - This file

## Related Features

- **Basic Types (#10)**: text is a primitive type
- **Interpolation (#26)**: f-string syntax
- **Collections (#20)**: String split returns List<text>
- **Operators (#16)**: `+` for concatenation, `==` for equality
- **Methods (#13)**: String methods use method call syntax

## Planned Features

**Not Yet Implemented:**
- Multi-line strings (`"""..."""`)
- Raw strings (escaping backslashes)
- String formatting (padding, alignment)
- Regular expressions
- Character indexing (`s[0]` to get first char)
- Substring slicing (`s[1:3]`)

**Future Methods:**
- `.trim_start()`, `.trim_end()`
- `.repeat(n)`
- `.is_empty()`
- `.chars()` - iterator over characters
- `.bytes()` - iterator over bytes
- `.lines()` - split by newlines

## Notes

- String literals can use single or double quotes
- Only double quotes support interpolation
- Strings are immutable - all operations return new strings
- `.len()` returns byte count, not character count (UTF-8)
- No string indexing yet (`s[0]` not supported)
- Concatenation with `+` creates new string each time (consider StringBuilder for performance)
"""

import std.spec


describe "text literals":
    """
    ## String Literal Syntax

    Simple supports two types of string literals: single-quoted (raw) and double-quoted (with interpolation).
    Both create immutable UTF-8 encoded strings.

    **Single Quotes:** `'...'` - Raw string, no interpolation
    **Double Quotes:** `"..."` - Supports `{expr}` interpolation

    **Grammar:**
    ```
    string_literal = SINGLE_QUOTE chars SINGLE_QUOTE
                   | DOUBLE_QUOTE (chars | '{' expr '}')* DOUBLE_QUOTE
    ```

    **Implementation:** `src/parser/src/lexer.rs:tokenize_string()`
    """

    it "creates string literals":
        """
        **Given** single-quoted string literal
        **When** binding to variable
        **Then** creates immutable text value

        **Code Example:**
        ```simple
        val s = 'hello'
        assert s == 'hello'
        ```

        **Runtime Behavior:**
        - Lexer tokenizes string contents between quotes
        - Parser creates StringLiteral AST node
        - Interpreter stores as RuntimeValue::String(String)
        - String is heap-allocated, UTF-8 encoded

        **Quote Types:**
        - Single quotes: `'hello'`
        - Double quotes: `"hello"`
        - Both create same type (text)
        - Only difference: interpolation support

        **Escaping:**
        - `\\` for backslash
        - `\'` for single quote (in single-quoted strings)
        - `\"` for double quote (in double-quoted strings)
        - `\n` for newline

        **Implementation:**
        - Lexer: `src/parser/src/lexer.rs:tokenize_string()`
        - Runtime: `RuntimeValue::String(String)` wraps Rust String

        **Common Patterns:**
        ```simple
        val name = 'Alice'
        val message = 'Hello, world!'
        val path = '/home/user/file.txt'
        ```
        """

val s = 'hello'
expect(s).to(eq('hello'))

        it "supports string concatenation":
            """
            **Given** two text values
            **When** using + operator
            **Then** creates new string with concatenated contents

            **Code Example:**
            ```simple
            val a = 'hello'
            val b = ' world'
            val c = a + b
            assert c == 'hello world'
            ```

            **Runtime Behavior:**
            - `+` operator implemented for String + String
            - Creates new String (does not modify operands)
            - Allocates memory for result string
            - Copies bytes from both strings

            **Immutability:**
            ```simple
            val x = 'foo'
            val y = x + 'bar'  # x unchanged, y is new string
            assert x == 'foo'  # x still 'foo'
            assert y == 'foobar'
            ```

            **Performance:**
            - Each concatenation allocates new string
            - O(n + m) where n, m are string lengths
            - For many concatenations, consider building a list and joining

            **Chaining:**
            ```simple
            val result = a + b + c  # Multiple concatenations
            ```

            **Implementation:**
            - Binary op: `src/compiler/src/interpreter.rs:eval_binary_op()`
            - Uses Rust String `+` operator

            **Common Patterns:**
            ```simple
            # Build full name
            val full_name = first_name + " " + last_name

            # Build path
            val path = base_dir + "/" + filename

            # Build message
            val msg = prefix + ": " + content
            ```
            """

val a = 'hello'
val b = ' world'
val c = a + b
expect(c).to(eq('hello world'))

        it "supports f-string interpolation":
            """
            **Given** double-quoted string with {expr} placeholders
            **When** evaluating the string
            **Then** expressions are evaluated and inserted into the string

            **Code Example:**
            ```simple
            val name = 'Alice'
            val greeting = "Hello, {name}!"
            assert greeting == 'Hello, Alice!'
            ```

            **Interpolation Syntax:**
            - Only in double-quoted strings
            - Use `{expr}` to insert expression result
            - Expression can be variable, calculation, method call, etc.

            **Examples:**
            ```simple
            val x = 10
            "Value: {x}"              # "Value: 10"
            "Sum: {x + 5}"            # "Sum: 15"
            "Length: {text.len()}"    # "Length: 5"
            "Name: {user.name}"       # Field access
            ```

            **Runtime Behavior:**
            1. Parse string into literal parts and expression parts
            2. Evaluate each expression
            3. Convert expression result to string (.to_string())
            4. Concatenate all parts into final string

            **Type Conversion:**
            - Integers/floats converted automatically
            - Booleans converted to "true"/"false"
            - Objects converted via .to_string() if available

            **Nested Braces:**
            - Single level only: `"{name}"`
            - No nesting: `"{{x}}"` not supported

            **Implementation:**
            - Parser: `src/parser/src/expressions/mod.rs:parse_string_interpolation()`
            - Evaluates each `{expr}` separately and concatenates

            **Common Patterns:**
            ```simple
            # User messages
            "Welcome, {username}!"
            "{count} items in cart"

            # Formatted output
            "Result: {score}/{max_score}"
            "Player {player_name} scored {points} points"

            # Logging
            "Error at line {line_num}: {error_message}"
            ```
            """

val name = 'Alice'
val greeting = "Hello, {name}!"
expect(greeting).to(eq('Hello, Alice!'))

describe "text methods":
    """
    ## String Methods

    The text type provides built-in methods for querying and transforming strings. All methods
    return new values and do not modify the original string (immutability).

    **Query Methods:**
    - `.len()` - Get string length in bytes
    - `.contains(substr)` - Check if contains substring
    - `.starts_with(prefix)` - Check if starts with prefix
    - `.ends_with(suffix)` - Check if ends with suffix

    **Transform Methods:**
    - `.replace(from, to)` - Replace all occurrences
    - `.split(delimiter)` - Split into list of strings
    - `.trim()` - Remove leading/trailing whitespace
    - `.upper()` - Convert to uppercase
    - `.lower()` - Convert to lowercase

    **Implementation:** `src/runtime/src/value/collections.rs`
    """

    it "returns string length":
        """
        **Given** a text value
        **When** calling .len() method
        **Then** returns byte count as i32

        **Code Example:**
        ```simple
        val text = 'hello'
        assert text.len() == 5
        ```

        **Runtime Behavior:**
        - Returns number of bytes, not characters
        - UTF-8 multi-byte characters count as multiple bytes
        - Empty string has length 0

        **UTF-8 Considerations:**
        ```simple
        'hello'.len()    # 5 bytes (ASCII)
        '你好'.len()      # 6 bytes (2 chars × 3 bytes each in UTF-8)
        'café'.len()     # 5 bytes ('é' is 2 bytes in UTF-8)
        ```

        **Performance:** O(1) - length stored in String

        **Return Type:** i32 (not usize like Rust)

        **Implementation:**
        - Method call: `src/compiler/src/interpreter.rs:eval_method_call()`
        - Delegates to Rust String.len()

        **Common Patterns:**
        ```simple
        # Validation
        if password.len() < 8:
            print("Password too short")

        # Empty check
        if input.len() == 0:
            print("No input provided")

        # Bounds checking
        if text.len() > max_length:
            text = text.substring(0, max_length)
        ```
        """

val text = 'hello'
expect(text.len()).to(eq(5))

        it "supports replace":
            """
            **Given** a text value with substring to replace
            **When** calling .replace(from, to)
            **Then** returns new string with all occurrences replaced

            **Code Example:**
            ```simple
            val original = 'hello world'
            val replaced = original.replace('world', 'Simple')
            assert replaced == 'hello Simple'
            assert original == 'hello world'  # Original unchanged
            ```

            **Runtime Behavior:**
            - Replaces ALL occurrences (not just first)
            - Returns new string (original unchanged)
            - If `from` not found, returns identical string

            **Examples:**
            ```simple
            'aaa'.replace('a', 'b')           # 'bbb'
            'hello world'.replace('l', 'L')   # 'heLLo worLd'
            'test'.replace('x', 'y')          # 'test' (no match)
            ```

            **Case Sensitivity:**
            - Exact match required
            - 'Hello'.replace('hello', 'Hi') does nothing
            - Use .lower() first for case-insensitive replace

            **Performance:** O(n × m) where n is string length, m is replacement count

            **Implementation:**
            - Uses Rust String.replace() internally
            - `src/runtime/src/value/collections.rs:string_replace()`

            **Common Patterns:**
            ```simple
            # Sanitize input
            val safe_input = input.replace('<', '&lt;').replace('>', '&gt;')

            # Normalize paths
            val unix_path = windows_path.replace('\\', '/')

            # Template substitution
            val message = template.replace('{name}', user_name)
            ```
            """

val original = 'hello world'
val replaced = original.replace('world', 'Simple')
expect(replaced).to(eq('hello Simple'))

        it "supports split":
            """
            **Given** a text value with delimiter
            **When** calling .split(delimiter)
            **Then** returns List of substrings

            **Code Example:**
            ```simple
            val csv = 'a,b,c'
            val parts = csv.split(',')
            assert parts.len() == 3
            assert parts[0] == 'a'
            assert parts[1] == 'b'
            assert parts[2] == 'c'
            ```

            **Runtime Behavior:**
            - Splits string at each occurrence of delimiter
            - Returns List<text>
            - Delimiter is consumed (not included in results)
            - Empty strings included if delimiter is adjacent

            **Edge Cases:**
            ```simple
            'a,,c'.split(',')      # ['a', '', 'c'] (empty string in middle)
            ',a,b,'.split(',')     # ['', 'a', 'b', ''] (empty at ends)
            'abc'.split(',')       # ['abc'] (no delimiter found)
            ''.split(',')          # [''] (empty string splits to list with empty string)
            ```

            **Common Delimiters:**
            - `,` for CSV
            - ` ` for words
            - `\n` for lines
            - `/` for paths

            **Performance:** O(n) where n is string length

            **Return Type:** List<text>

            **Implementation:**
            - `src/runtime/src/value/collections.rs:string_split()`
            - Uses Rust String.split()

            **Common Patterns:**
            ```simple
            # Parse CSV
            val fields = csv_line.split(',')

            # Split into words
            val words = sentence.split(' ')

            # Parse path
            val segments = path.split('/')

            # Multi-line processing
            val lines = text.split('\n')
            for line in lines:
                process(line)
            ```
            """

val csv = 'a,b,c'
val parts = csv.split(',')
expect(parts.len()).to(eq(3))

        it "supports contains":
            """
            **Given** a text value and substring to search
            **When** calling .contains(substring)
            **Then** returns true if substring found, false otherwise

            **Code Example:**
            ```simple
            val sentence = 'The quick brown fox'
            assert sentence.contains('quick')
            assert not sentence.contains('slow')
            ```

            **Runtime Behavior:**
            - Searches for exact substring match
            - Returns bool
            - Case-sensitive

            **Examples:**
            ```simple
            'hello world'.contains('world')   # true
            'hello world'.contains('o w')     # true
            'hello world'.contains('World')   # false (case-sensitive)
            'test'.contains('')               # true (empty string in all strings)
            ```

            **Performance:** O(n × m) substring search

            **Case-Insensitive Search:**
            ```simple
            val found = text.lower().contains(query.lower())
            ```

            **Implementation:**
            - `src/runtime/src/value/collections.rs:string_contains()`
            - Uses Rust String.contains()

            **Common Patterns:**
            ```simple
            # Validation
            if email.contains('@'):
                # Valid email format

            # Search
            if document.contains(search_term):
                print("Found!")

            # Feature detection
            if user_agent.contains('Mobile'):
                serve_mobile_version()
            ```
            """

val sentence = 'The quick brown fox'
expect(sentence.contains('quick')).to(be_true())

        it "supports starts_with and ends_with":
            """
            **Given** a text value and prefix/suffix to check
            **When** calling .starts_with(prefix) or .ends_with(suffix)
            **Then** returns true if string starts/ends with given substring

            **Code Example:**
            ```simple
            val path = '/home/user/file.txt'
            assert path.starts_with('/home')
            assert path.ends_with('.txt')
            assert not path.starts_with('/var')
            assert not path.ends_with('.jpg')
            ```

            **Runtime Behavior:**
            - Checks if string begins/ends with exact match
            - Returns bool
            - Case-sensitive
            - Empty string check returns true

            **Examples:**
            ```simple
            # starts_with
            'hello world'.starts_with('hello')  # true
            'hello world'.starts_with('world')  # false
            'hello world'.starts_with('')       # true

            # ends_with
            'hello world'.ends_with('world')    # true
            'hello world'.ends_with('hello')    # false
            'hello world'.ends_with('')         # true
            ```

            **Performance:**
            - O(m) where m is prefix/suffix length
            - Much faster than .contains() for prefix/suffix checks

            **Implementation:**
            - `src/runtime/src/value/collections.rs:string_starts_with()`
            - `src/runtime/src/value/collections.rs:string_ends_with()`

            **Common Patterns:**
            ```simple
            # File extension check
            if filename.ends_with('.spl'):
                compile_file(filename)

            # URL protocol check
            if url.starts_with('https://'):
                use_secure_connection()

            # Path validation
            if path.starts_with('/'):
                # Absolute path
            else:
                # Relative path

            # Command prefix
            if input.starts_with('/'):
                handle_command(input)
            ```
            """

val path = '/home/user/file.txt'
expect(path.starts_with('/home')).to(be_true())
expect(path.ends_with('.txt')).to(be_true())

describe "text comparison":
    """
    ## String Equality and Comparison

    Strings support equality (==, !=) and lexicographic ordering (<, >, <=, >=).
    Comparisons are case-sensitive and use UTF-8 byte order.

    **Equality Operators:**
    - `==` - Exact string equality
    - `!=` - String inequality

    **Ordering Operators:**
    - `<`, `>`, `<=`, `>=` - Lexicographic (dictionary) order

    **Implementation:** `src/compiler/src/interpreter.rs:eval_comparison()`
    """

    it "compares strings for equality":
        """
        **Given** two text values
        **When** using == operator
        **Then** returns true if strings are identical, false otherwise

        **Code Example:**
        ```simple
        val x = 'test'
        val y = 'test'
        assert x == y
        ```

        **Runtime Behavior:**
        - Byte-by-byte comparison
        - Must be exact match (case-sensitive)
        - Different quote types don't matter: `'hello'` == `"hello"`

        **Examples:**
        ```simple
        'hello' == 'hello'   # true
        'hello' == 'Hello'   # false (case-sensitive)
        'test' == 'test'     # true
        '' == ''             # true (empty strings equal)
        ```

        **Performance:** O(n) where n is string length

        **Case-Insensitive Comparison:**
        ```simple
        val equal = x.lower() == y.lower()
        ```

        **Implementation:**
        - Uses Rust String PartialEq implementation
        - Byte-by-byte comparison

        **Common Patterns:**
        ```simple
        # Input validation
        if command == 'exit':
            quit()

        # Option selection
        if choice == 'yes':
            proceed()

        # Format checking
        if extension == '.txt':
            read_text_file()
        ```
        """

val x = 'test'
val y = 'test'
expect(x).to(eq(y))

        it "compares strings for inequality":
            """
            **Given** two text values
            **When** using != operator
            **Then** returns true if strings are different

            **Code Example:**
            ```simple
            val p = 'abc'
            val q = 'xyz'
            assert p != q
            ```

            **Runtime Behavior:**
            - Opposite of ==
            - Returns true if strings differ in any way
            - Case-sensitive

            **Examples:**
            ```simple
            'abc' != 'xyz'   # true
            'abc' != 'ABC'   # true (case-sensitive)
            'test' != 'test' # false
            ```

            **Performance:** O(n) but short-circuits on first difference

            **Implementation:**
            - Uses Rust String PartialEq with negation

            **Common Patterns:**
            ```simple
            # Validation
            if password != confirm_password:
                print("Passwords don't match")

            # Change detection
            if new_value != old_value:
                save_changes()

            # Filtering
            if item != "skip":
                process(item)
            ```
            """

val p = 'abc'
val q = 'xyz'
expect(p).to_not(eq(q))
