# Sets Feature Specification
"""
# Sets (Unique Collections)

**Feature ID:** #33
**Category:** Data Structures
**Difficulty:** 2/5 (Beginner-Intermediate)
**Status:** Complete

## Overview

Sets in Simple are unordered collections of unique elements. Unlike arrays, sets automatically
prevent duplicates and provide O(1) membership testing. Sets support mathematical set operations
like union, intersection, and difference.

**Key Features:**
- **Uniqueness:** Automatically deduplicates elements
- **Unordered:** No guaranteed iteration order
- **Fast lookup:** O(1) contains() operation via hashing
- **Set algebra:** union, intersection, difference, subset operations
- **Hashable elements:** Elements must be hashable (numbers, strings, booleans)

**Implementation:** Sets are implemented in Simple itself (`simple/std_lib/src/core/collections/set.spl`)
using a hash-based approach for O(1) operations.

## Syntax

### Set Creation

```simple
# From array (deduplicates automatically)
val s = Set.from_array([1, 2, 3, 2, 1])  # {1, 2, 3}

# Empty set
val empty = Set.new()

# Add elements
s.add(4)
s.add(5)
```

### Set Operations

```simple
val a = Set.from_array([1, 2, 3])
val b = Set.from_array([3, 4, 5])

# Membership
val has_two = a.contains(2)  # true

# Union (all elements from both sets)
val union = a.union(b)  # {1, 2, 3, 4, 5}

# Intersection (elements in both sets)
val inter = a.intersection(b)  # {3}

# Difference (elements in a but not b)
val diff = a.difference(b)  # {1, 2}

# Subset check
val is_subset = a.is_subset(b)  # false
```

## Runtime Representation

**Hash-Based Storage:**
```simple
class Set:
    elements: Dict<Any, bool>  # Keys are elements, values unused

    fn contains(elem) -> bool:
        return self.elements.has_key(elem)
```

**Implementation:**
- Backed by dictionary with element as key
- O(1) add, remove, contains via hashing
- No ordering guarantees
- Memory: O(n) where n = unique elements

## Comparison with Other Languages

| Feature | Simple | Python | JavaScript | Rust | Scala |
|---------|--------|--------|------------|------|-------|
| Creation | `Set.from_array([1,2,3])` | `{1, 2, 3}` or `set([1,2,3])` | `new Set([1,2,3])` | `HashSet::from([1,2,3])` | `Set(1, 2, 3)` |
| Add | `.add(elem)` | `.add(elem)` | `.add(elem)` | `.insert(elem)` | `.+(elem)` |
| Contains | `.contains(elem)` | `elem in set` | `.has(elem)` | `.contains(&elem)` | `.contains(elem)` |
| Union | `.union(other)` | `a \\| b` | (manual) | `.union(&other)` | `.union(other)` |
| Size | `.size()` | `len(set)` | `.size` | `.len()` | `.size` |
| Mutability | Mutable | Mutable | Mutable | Explicit | Immutable |

## Common Patterns

### Deduplication
```simple
val arr = [1, 2, 2, 3, 3, 3]
val unique = Set.from_array(arr).to_array()  # [1, 2, 3] (order may vary)
```

### Membership Testing
```simple
val valid_ids = Set.from_array([101, 102, 103, 104])
if valid_ids.contains(user_id):
    process_user(user_id)
```

### Set Algebra
```simple
val admins = Set.from_array(["alice", "bob"])
val moderators = Set.from_array(["bob", "charlie"])
val all_staff = admins.union(moderators)
val both_roles = admins.intersection(moderators)
```

## Built-in Methods

### Creation
- `Set.new()` - Create empty set
- `Set.from_array(arr)` - Create set from array (deduplicates)

### Modification
- `add(elem)` - Add element to set
- `remove(elem)` - Remove element from set

### Query
- `contains(elem)` - Check if element exists (O(1))
- `size()` - Number of elements
- `is_empty()` - Check if set has no elements

### Set Operations
- `union(other)` - All elements from both sets
- `intersection(other)` - Elements in both sets
- `difference(other)` - Elements in this set but not other
- `is_subset(other)` - Check if all elements are in other set

### Conversion
- `to_array()` - Convert to array (order undefined)

## Implementation Files

**Library:** `simple/std_lib/src/core/collections/set.spl` - Set implementation in Simple
**Tests:** `simple/std_lib/test/unit/core/set_spec.spl` - Set tests
**Dependencies:** Requires Dict/HashMap for hashing

## Related Features

- **Arrays (#20):** Ordered collections with duplicates allowed
- **Dicts (#TBD):** Key-value mappings (sets use dicts internally)
- **Tuples (#18):** Fixed-size collections
- **Hashable Types:** Elements must implement hash function

## Performance Characteristics

| Operation | Time | Notes |
|-----------|------|-------|
| Create from array | O(n) | n = array length |
| add(elem) | O(1) avg | Hash insertion |
| remove(elem) | O(1) avg | Hash removal |
| contains(elem) | O(1) avg | Hash lookup |
| size() | O(1) | Cached count |
| union(other) | O(n+m) | Visit all elements |
| intersection(other) | O(min(n,m)) | Visit smaller set |
| difference(other) | O(n) | Visit this set |

## Limitations and Future Work

**Current Limitations:**
- No set literal syntax (`{1, 2, 3}` is not supported)
- Elements must be hashable (no sets of sets)
- No frozen/immutable sets
- Iteration order undefined

**Planned Features:**
- Set literals: `{1, 2, 3}` syntax
- Frozen sets (immutable)
- Symmetric difference: `a ^ b`
- Disjoint check: `a.is_disjoint(b)`
- Set comprehensions: `{x*2 for x in arr if x > 0}`
"""

import std.spec
use core.*


describe "Set creation":
    """
    ## Creating Sets

    Sets are created from arrays using `Set.from_array()` or as empty sets with `Set.new()`.
    Duplicate elements in the source array are automatically removed.

    **No literal syntax yet:** Unlike Python's `{1, 2, 3}`, Simple requires explicit construction

    **Implementation:** `simple/std_lib/src/core/collections/set.spl`
    """

    it "creates set from array":
        """
        **Given** an array with duplicate elements
        **When** creating a set from the array
        **Then** set contains only unique elements

        **Example:**
        ```simple
        val s = Set.from_array([1, 2, 2, 3, 3, 3])
        assert s.size() == 3  # Only unique elements
        assert s.contains(1) and s.contains(2) and s.contains(3)
        ```

        **Deduplication:** Automatic - no manual work needed
        """
        val s = Set.from_array([1, 2, 2, 3])
        expect(s.size()).to(eq(3))
        expect(s.contains(1)).to(be_true())
        expect(s.contains(2)).to(be_true())
        expect(s.contains(3)).to(be_true())

        it "creates empty set":
            """
            **Given** a call to Set.new()
            **When** creating the set
            **Then** set has zero elements

            **Example:**
            ```simple
            val empty = Set.new()
            assert empty.size() == 0
            assert empty.is_empty() == true
            ```

            **Use Case:** Build set incrementally with add()
            """
        val empty = Set.new()
        expect(empty.size()).to(eq(0))
        expect(empty.is_empty()).to(be_true())

describe "Set operations":
    """
    ## Set Operations - Mathematical Set Algebra

    Sets support classic set theory operations: union (∪), intersection (∩), and difference (\\).
    These operations create new sets without modifying the originals.

    **Union:** All elements from both sets
    **Intersection:** Elements present in both sets
    **Difference:** Elements in first set but not second

    **Immutable:** Operations return new sets
    """

    it "computes union":
        """
        **Given** two sets with some overlapping elements
        **When** calling .union(other)
        **Then** returns set with all unique elements from both sets

        **Example:**
        ```simple
        val a = Set.from_array([1, 2, 3])
        val b = Set.from_array([3, 4, 5])
        val u = a.union(b)
        assert u == {1, 2, 3, 4, 5}  # All elements
        ```

        **Math:** a ∪ b = {x | x ∈ a or x ∈ b}
        **Performance:** O(n + m)
        """
        val a = Set.from_array([1, 2, 3])
        val b = Set.from_array([3, 4, 5])
        val u = a.union(b)
        expect(u.size()).to(eq(5))
        expect(u.contains(1)).to(be_true())
        expect(u.contains(5)).to(be_true())

        it "computes intersection":
            """
            **Given** two sets with overlapping elements
            **When** calling .intersection(other)
            **Then** returns set with only elements present in both

            **Example:**
            ```simple
            val a = Set.from_array([1, 2, 3])
            val b = Set.from_array([2, 3, 4])
            val i = a.intersection(b)
            assert i == {2, 3}  # Common elements
            ```

            **Math:** a ∩ b = {x | x ∈ a and x ∈ b}
            **Performance:** O(min(n, m))
            """
        val a2 = Set.from_array([1, 2, 3])
        val b2 = Set.from_array([2, 3, 4])
        val i = a2.intersection(b2)
        expect(i.size()).to(eq(2))
        expect(i.contains(2)).to(be_true())
        expect(i.contains(3)).to(be_true())

        it "computes difference":
            """
            **Given** two sets
            **When** calling .difference(other)
            **Then** returns elements in first set but not in second

            **Example:**
            ```simple
            val a = Set.from_array([1, 2, 3])
            val b = Set.from_array([2, 3, 4])
            val d = a.difference(b)
            assert d == {1}  # Only in a
            ```

            **Math:** a \\ b = {x | x ∈ a and x ∉ b}
            **Asymmetric:** a.difference(b) ≠ b.difference(a)
            """
        val a3 = Set.from_array([1, 2, 3])
        val b3 = Set.from_array([2, 3, 4])
        val d = a3.difference(b3)
        expect(d.size()).to(eq(1))
        expect(d.contains(1)).to(be_true())

describe "Set membership":
    """
    ## Set Membership Testing

    The primary use of sets is fast membership testing with O(1) contains() operation.
    This makes sets ideal for "is X in this collection?" checks.

    **Performance:** O(1) average case via hashing
    **Use Case:** Whitelists, blacklists, seen-tracking, deduplication
    """

    it "tests membership with contains":
        """
        **Given** a set of elements
        **When** calling .contains(elem)
        **Then** returns true if element in set, false otherwise

        **Example:**
        ```simple
        val primes = Set.from_array([2, 3, 5, 7, 11])
        assert primes.contains(5) == true
        assert primes.contains(6) == false
        ```

        **Performance:** O(1) hash lookup
        **Advantage:** Much faster than array.contains() for large collections
        """
        val nums = Set.from_array([10, 20, 30])
        expect(nums.contains(20)).to(be_true())
        expect(nums.contains(99)).to(be_false())

        it "adds elements":
            """
            **Given** a set
            **When** calling .add(elem)
            **Then** element is added to set (if not already present)

            **Example:**
            ```simple
            val s = Set.new()
            s.add(1)
            s.add(2)
            s.add(1)  # Duplicate ignored
            assert s.size() == 2
            ```

            **Idempotent:** Adding same element multiple times has no effect
            """
        val s2 = Set.new()
        s2.add(1)
        s2.add(2)
        s2.add(1)
        expect(s2.size()).to(eq(2))
