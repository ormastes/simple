# Tuples Feature Specification
# Feature #26: Tuple type
# Category: Data Structures | Difficulty: 2 | Status: Complete

"""
# Tuple Type

**Feature ID:** #26
**Category:** Data Structures
**Difficulty:** 2/5
**Status:** Complete

## Overview

Tuples in Simple provide fixed-size, heterogeneous collections that group multiple values
into a single compound value. Unlike arrays (which are homogeneous and dynamic-sized) or
structs (which have named fields), tuples are anonymous ordered collections where each
position can hold a value of any type.

Tuples are immutable after creation and primarily used for returning multiple values from
functions, grouping related data temporarily, or pattern matching. They provide a lightweight
alternative to defining custom struct types for short-lived multi-value returns.

## Key Features

- **Literal Syntax:** Parentheses-based syntax `(value1, value2, ...)`
- **Heterogeneous:** Each element can be a different type
- **Fixed Size:** Size is determined at creation time
- **Zero-Indexed:** Access elements via `tuple[index]` notation
- **Immutable:** Cannot modify elements after creation
- **Nestable:** Tuples can contain other tuples or collections
- **Function Returns:** Primary use case for returning multiple values

## Syntax

**Pair (2-tuple):**
```simple
val coordinates = (10, 20)
val x = coordinates[0]  # 10
val y = coordinates[1]  # 20
```

**Triple (3-tuple):**
```simple
val rgb = (255, 128, 0)
val red = rgb[0]
```

**Mixed Types:**
```simple
val user = (42, 'Alice', true)  # (id: i64, name: text, active: bool)
val id = user[0]                # 42
val name = user[1]              # 'Alice'
val active = user[2]            # true
```

**Function Returns:**
```simple
fn divide_with_remainder(a, b):
    return (a / b, a % b)

val (quotient, remainder) = divide_with_remainder(17, 5)
# quotient = 3, remainder = 2
```

## Test Coverage

This specification validates:
1. **Tuple Creation:** Pairs, triples, mixed-type tuples
2. **Tuple Indexing:** Element access by position, computed indices
3. **Functions:** Returning tuples, passing tuples as arguments
4. **Nesting:** Nested tuples, tuples containing arrays

## Implementation

**Primary Files:**
- `src/runtime/src/value/collections.rs` - Tuple runtime representation and operations
- `src/compiler/src/interpreter.rs` - Tuple literal evaluation and indexing

**Testing:**
- `src/driver/tests/interpreter_collections_tests.rs` - Rust integration tests

**Dependencies:**
- Feature #1: Lexer (tokenizes `(`, `)`, `,` for tuple syntax)
- Feature #2: Parser (parses tuple literals)
- Feature #10: Expressions (tuple indexing via subscript)

**Required By:**
- Feature #12: Arrays (array of tuples pattern)
- Feature #90: Pattern Matching (tuple destructuring)

## Runtime Representation

Internally, tuples use Rust's `Vec<RuntimeValue>` with fixed size:

```rust
struct Tuple {
    elements: Vec<RuntimeValue>,
    len: usize  // Fixed at creation
}
```

**Key Properties:**
- Elements stored in insertion order
- Random access via index: O(1)
- Heterogeneous: each element is RuntimeValue (any type)
- Immutable: cannot add/remove/replace elements

## Comparison with Other Languages

| Feature | Simple | Python | Rust | TypeScript |
|---------|--------|--------|------|------------|
| Literal syntax | `(1, 2)` | `(1, 2)` | `(1, 2)` | `[1, 2]` (array) |
| Heterogeneous | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Mutable | ‚ùå | ‚ùå | ‚ùå (default) | ‚ùå |
| Destructuring | üöß (planned) | ‚úÖ | ‚úÖ | ‚úÖ |
| Indexing | `t[0]` | `t[0]` | `t.0` | `t[0]` |

## Common Patterns

**Multiple Return Values:**
```simple
fn find_min_max(numbers):
    var min_val = numbers[0]
    var max_val = numbers[0]
    for n in numbers:
        if n < min_val:
            min_val = n
        if n > max_val:
            max_val = n
    return (min_val, max_val)

val (min, max) = find_min_max([3, 7, 1, 9, 2])
```

**Coordinate Pairs:**
```simple
val origin = (0, 0)
val point = (100, 200)

fn distance(p1, p2):
    val dx = p2[0] - p1[0]
    val dy = p2[1] - p1[1]
    return sqrt(dx * dx + dy * dy)
```

**Database Rows:**
```simple
val users = [
    (1, 'alice@example.com', 'Alice'),
    (2, 'bob@example.com', 'Bob')
]

for user in users:
    val (id, email, name) = user
    print("User {id}: {name} <{email}>")
```

**Configuration Triples:**
```simple
val endpoints = [
    ('api', 'https://api.example.com', 443),
    ('web', 'https://www.example.com', 443),
    ('db', 'localhost', 5432)
]
```

## Performance Characteristics

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Creation | O(n) | Allocates n elements |
| Indexing | O(1) | Direct array access |
| Iteration | O(n) | Linear traversal |
| Comparison | O(n) | Element-wise equality |
| Copy | O(n) | Deep copy all elements |

## Related Features

- Feature #20: Lists (dynamic-size homogeneous sequences)
- Feature #21: Dicts (key-value mappings)
- Feature #12: Arrays (fixed-size collections)
- Feature #90: Pattern Matching (tuple destructuring)
- Feature #19: Struct Types (named fields vs indexed positions)

## Future Enhancements

**Destructuring (Planned):**
```simple
val (x, y, z) = (1, 2, 3)
# x=1, y=2, z=3
```

**Tuple Methods:**
```simple
val t = (1, 2, 3)
t.len()        # 3
t.contains(2)  # true
t.to_list()    # [1, 2, 3]
```

**Type Annotations:**
```simple
fn get_user() -> (i64, text, bool):
    return (42, 'Alice', true)
```

**Migration Notes:**
- Automated migration: N/A (needs manual conversion)
- Manual assertion conversion: ~16 minutes (8 assertions √ó 2 min)
- Docstring enhancement: ~32 minutes (1 file + 4 describe + 8 it)
- Total: ~48 minutes (Session 4)
"""
import std.spec


describe "Tuple creation":
    """
    ## Tuple Literal Syntax

    Tuples are created using parentheses with comma-separated values. The syntax is
    similar to mathematical notation and function parameters, making it intuitive
    for grouping multiple values.

    **Basic Syntax:**
    ```simple
    val pair = (value1, value2)
    val triple = (value1, value2, value3)
    val quad = (value1, value2, value3, value4)
    ```

    **Key Characteristics:**
    - Parentheses `()` delimit the tuple
    - Commas `,` separate elements
    - Minimum 2 elements (single-element tuples need trailing comma: `(x,)`)
    - No maximum size (but typically 2-5 elements)
    - Elements evaluated left-to-right

    **Grammar:**
    ```
    tuple_literal = '(' expression (',' expression)+ [','] ')'
    ```

    **Type Inference:**
    The tuple's type is inferred from its elements:
    - `(1, 2)` ‚Üí Tuple<i64, i64>
    - `(42, 'text')` ‚Üí Tuple<i64, text>
    - `(true, 1, 'x')` ‚Üí Tuple<bool, i64, text>

    **Immutability:**
    Tuples are immutable - once created, elements cannot be changed:
    ```simple
    val t = (1, 2)
    t[0] = 3  # ERROR: Cannot assign to tuple element
    ```

    **Implementation:** Parser recognizes `(` token followed by comma-separated expressions.
    The runtime creates a fixed-size Vec<RuntimeValue> with the evaluated elements.
    """

    it "creates pair tuple":
        """
        **Given** a tuple literal with two integer values
        **When** evaluating the literal expression
        **Then** creates a 2-tuple with both values accessible by index

        **Syntax:**
        ```simple
        val pair = (1, 2)
        ```

        **Type:** Tuple<i64, i64> (inferred)

        **Runtime Representation:**
        ```rust
        Tuple {
            elements: vec![
                RuntimeValue::Int(1),
                RuntimeValue::Int(2)
            ],
            len: 2
        }
        ```

        **Memory Layout:**
        ```
        pair: [RuntimeValue, RuntimeValue]
               ‚Üì            ‚Üì
               Int(1)       Int(2)
        Index: 0            1
        ```

        **Access Patterns:**
        - `pair[0]` ‚Üí 1 (first element)
        - `pair[1]` ‚Üí 2 (second element)
        - `pair[2]` ‚Üí ERROR: Index out of bounds

        **Use Cases:**
        - Coordinates: `(x, y)`
        - Key-value pairs: `(key, value)`
        - Before/after: `(old_value, new_value)`
        - Min/max: `(minimum, maximum)`

        **Verification:** Confirms pair[0] == 1 and pair[1] == 2

        **Performance:** O(1) creation for small tuples

        **Implementation:** See interpreter.rs::eval_tuple_literal()

        **Related:** Feature #20 (Lists - dynamic size), Feature #12 (Arrays - homogeneous)
        """
        val pair = (1, 2)
        expect(pair[0]).to(eq(1))
        expect(pair[1]).to(eq(2))

    it "creates triple tuple":
        """
        **Given** a tuple literal with three integer values
        **When** evaluating the expression
        **Then** creates a 3-tuple with all values accessible

        **Syntax:**
        ```simple
        val triple = (1, 2, 3)
        ```

        **Type:** Tuple<i64, i64, i64>

        **Common Triple Patterns:**
        - RGB colors: `(255, 128, 0)`
        - 3D coordinates: `(x, y, z)`
        - Date components: `(year, month, day)`
        - Network addresses: `(host, port, protocol)`

        **Example - RGB Color:**
        ```simple
        val orange = (255, 165, 0)
        val red = orange[0]    # 255
        val green = orange[1]  # 165
        val blue = orange[2]   # 0
        ```

        **Example - Date:**
        ```simple
        val date = (2024, 1, 15)
        val year = date[0]
        val month = date[1]
        val day = date[2]
        ```

        **Size Considerations:**
        - 2-tuples (pairs): Most common, used for coordinates, key-value
        - 3-tuples (triples): Common for RGB, xyz coordinates
        - 4-tuples (quads): Less common, consider using struct instead
        - 5+ tuples: Rarely used, struct with named fields is clearer

        **Verification:** Confirms all three elements match expected values

        **Implementation:** See runtime/value/collections.rs::Tuple::new()

        **Best Practice:** For tuples with > 4 elements, consider defining a struct
        with named fields for better code clarity.
        """
        val triple = (1, 2, 3)
        expect(triple[0]).to(eq(1))
        expect(triple[1]).to(eq(2))
        expect(triple[2]).to(eq(3))

    it "creates mixed-type tuple":
        """
        **Given** a tuple with different types (int, string, bool)
        **When** creating the tuple literal
        **Then** stores all values with their original types preserved

        **Syntax:**
        ```simple
        val mixed = (42, 'hello', true)
        ```

        **Type:** Tuple<i64, text, bool>

        **Heterogeneous Collections:**
        Unlike arrays (homogeneous), tuples can mix types:
        - Arrays: `[1, 2, 3]` - all integers
        - Tuples: `(1, 'two', true)` - mixed types

        **Runtime Representation:**
        ```rust
        Tuple {
            elements: vec![
                RuntimeValue::Int(42),
                RuntimeValue::String("hello".to_string()),
                RuntimeValue::Bool(true)
            ],
            len: 3
        }
        ```

        **Type Safety:**
        Each element retains its type:
        ```simple
        val data = (42, 'text', true)
        val num = data[0]      # i64
        val text = data[1]     # text
        val flag = data[2]     # bool

        val doubled = data[0] * 2       # 84 (valid)
        val upper = data[1].to_upper()  # 'TEXT' (valid)
        val bad = data[0] + data[1]     # ERROR: can't add int + text
        ```

        **Common Mixed-Type Patterns:**
        - User records: `(id: i64, name: text, active: bool)`
        - HTTP responses: `(status: i64, body: text, success: bool)`
        - Validation: `(is_valid: bool, error_message: text, code: i64)`
        - Database rows: `(id: i64, email: text, verified: bool, age: i64)`

        **Example - User Record:**
        ```simple
        fn get_user(id):
            # Returns (id, username, is_admin)
            return (id, 'alice', false)

        val user = get_user(42)
        val user_id = user[0]       # 42
        val username = user[1]      # 'alice'
        val is_admin = user[2]      # false
        ```

        **Verification:** Confirms each element maintains its original type and value

        **Implementation:** RuntimeValue enum allows storing any type in collection

        **Trade-off:** Flexibility vs type safety - consider struct for complex data

        **Related:** Feature #19 (Structs - named fields), Feature #7 (Type system)
        """
        val mixed = (42, 'hello', true)
        expect(mixed[0]).to(eq(42))
        expect(mixed[1]).to(eq('hello'))
        expect(mixed[2]).to(be_true())

describe "Tuple indexing":
    """
    ## Tuple Element Access

    Tuples use zero-based indexing with subscript notation, similar to arrays and lists.
    Each position in the tuple has a fixed index from 0 to (len-1).

    **Subscript Notation:**
    ```simple
    val t = (10, 20, 30)
    val first = t[0]   # 10
    val second = t[1]  # 20
    val third = t[2]   # 30
    ```

    **Index Characteristics:**
    - Zero-based: First element is index 0
    - Integer indices only (no negative indexing yet)
    - Compile-time or runtime index evaluation
    - Out-of-bounds access causes runtime error

    **Performance:**
    - Access: O(1) - direct array indexing
    - Bounds checking: O(1) - compare against length

    **Error Handling:**
    ```simple
    val t = (1, 2)
    val x = t[0]   # OK: 1
    val y = t[2]   # ERROR: Index 2 out of bounds for tuple length 2
    ```

    **Comparison with Struct Field Access:**
    - Tuples: `user[0]`, `user[1]`, `user[2]` (positional)
    - Structs: `user.name`, `user.email`, `user.age` (named)

    Tuples are best for short-lived, order-based data. Structs are better when
    field names improve clarity.

    **Implementation:** Subscript operator calls `tuple_get(index)` which performs
    bounds checking and returns the RuntimeValue at that position.
    """

    it "accesses elements by index":
        """
        **Given** a 4-element tuple
        **When** accessing elements using integer indices
        **Then** returns the value at each position

        **Syntax:**
        ```simple
        val t = (10, 20, 30, 40)
        val first = t[0]   # 10
        val last = t[3]    # 40
        ```

        **Index Range:**
        For a tuple of length n:
        - Valid indices: 0, 1, 2, ..., n-1
        - Index n or higher: Out of bounds error
        - Negative indices: Not supported (yet)

        **Indexing Process:**
        1. Evaluate index expression to integer
        2. Check if index < tuple.len()
        3. If valid, return element at position
        4. If invalid, throw runtime error

        **Examples:**
        ```simple
        val data = (100, 200, 300, 400, 500)

        data[0]   # 100 (first)
        data[2]   # 300 (middle)
        data[4]   # 500 (last)
        data[5]   # ERROR: Out of bounds
        ```

        **Iteration Pattern:**
        ```simple
        val t = (10, 20, 30, 40)
        var sum = 0
        for i in range(4):  # 0, 1, 2, 3
            sum += t[i]
        # sum = 100
        ```

        **Bounds Checking:**
        Runtime always validates indices:
        ```rust
        impl Tuple {
            pub fn get(&self, index: usize) -> Result<&RuntimeValue, Error> {
                if index >= self.len {
                    Err(Error::IndexOutOfBounds { index, len: self.len })
                } else {
                    Ok(&self.elements[index])
                }
            }
        }
        ```

        **Verification:** Confirms first and last elements are accessible

        **Performance:** O(1) access time

        **Implementation:** See runtime/value/collections.rs::Tuple::get()

        **Future Enhancement:** Negative indexing like Python: `t[-1]` for last element
        """
        val t = (10, 20, 30, 40)
        expect(t[0]).to(eq(10))
        expect(t[3]).to(eq(40))

    it "works with computed index":
        """
        **Given** a tuple and an integer variable
        **When** using the variable as an index
        **Then** correctly retrieves the element at that position

        **Syntax:**
        ```simple
        val data = (100, 200, 300)
        val idx = 1
        val value = data[idx]  # 200
        ```

        **Dynamic Indexing:**
        Indices can be any expression that evaluates to an integer:
        ```simple
        val t = (10, 20, 30, 40, 50)

        # Variable index
        val i = 2
        val x = t[i]           # 30

        # Expression index
        val y = t[i + 1]       # 40

        # Function call index
        fn get_index():
            return 3
        val z = t[get_index()] # 40
        ```

        **Use Cases:**
        - Loop-based access
        - Conditional element selection
        - Algorithm-driven indexing
        - User input-based access

        **Example - Loop Access:**
        ```simple
        val scores = (95, 87, 92, 88)
        var total = 0
        for i in range(4):
            total += scores[i]
        val average = total / 4
        ```

        **Example - Conditional Access:**
        ```simple
        val options = ('easy', 'medium', 'hard')
        val difficulty_level = 2  # from user input
        val selected = options[difficulty_level]  # 'hard'
        ```

        **Safety Considerations:**
        ```simple
        val data = (1, 2, 3)
        val user_input = 5  # Unsafe: could be out of bounds

        # Better: validate before access
        if user_input >= 0 and user_input < 3:
            val value = data[user_input]
        else:
            print("Invalid index")
        ```

        **Verification:** Confirms variable-based indexing works correctly

        **Performance:** O(1) - same as literal indices

        **Implementation:** Index expression evaluated to i64, then converted to usize
        for array access

        **Related:** Feature #10 (Subscript operator), Feature #8 (Arithmetic expressions)
        """
        val data = (100, 200, 300)
        val idx = 1
        expect(data[idx]).to(eq(200))

describe "Tuple in functions":
    """
    ## Tuples and Functions

    Tuples are particularly useful in functions for returning multiple values or passing
    grouped data as arguments. This provides a lightweight alternative to defining custom
    struct types for short-lived multi-value returns.

    **Return Multiple Values:**
    ```simple
    fn get_dimensions():
        return (1920, 1080)  # width, height

    val (w, h) = get_dimensions()
    ```

    **Pass Grouped Data:**
    ```simple
    fn distance(point):
        return sqrt(point[0]**2 + point[1]**2)

    val d = distance((3, 4))  # 5.0
    ```

    **Common Patterns:**
    - **Division with remainder:** `fn divmod(a, b) -> (i64, i64)`
    - **Min/max pair:** `fn find_extremes(nums) -> (i64, i64)`
    - **Success with result:** `fn try_parse(text) -> (bool, i64)`
    - **Before/after:** `fn update(old) -> (T, T)`

    **Benefits:**
    - No need to define custom types for simple returns
    - Clear, ordered semantics
    - Pattern matching support (future)
    - Familiar syntax from Python, Rust, etc.

    **Trade-offs:**
    - Positional (not named) - can be unclear for > 3 elements
    - No type safety beyond element types
    - Cannot add methods like structs can

    **When to Use Tuples vs Structs:**
    - **Tuples:** Temporary, 2-4 values, obvious meaning from context
    - **Structs:** Long-lived, > 4 fields, benefits from named fields

    **Implementation:** Functions return RuntimeValue::Tuple, caller receives it as
    single value that can be indexed or destructured.
    """

    it "returns tuple from function":
        """
        **Given** a function that returns a tuple
        **When** calling the function and accessing the returned tuple
        **Then** correctly retrieves elements from the returned tuple

        **Syntax:**
        ```simple
        fn get_point():
            return (3, 4)

        val point = get_point()
        val x = point[0]  # 3
        val y = point[1]  # 4
        ```

        **Return Value Flow:**
        ```
        get_point() called
            ‚Üì
        Tuple (3, 4) created
            ‚Üì
        Returned to caller
            ‚Üì
        Stored in 'point' variable
            ‚Üì
        Elements accessed via indexing
        ```

        **Common Use Cases:**

        **1. Coordinates:**
        ```simple
        fn get_mouse_position():
            return (150, 200)

        val pos = get_mouse_position()
        draw_cursor(pos[0], pos[1])
        ```

        **2. Division with Remainder:**
        ```simple
        fn divmod(dividend, divisor):
            val quotient = dividend / divisor
            val remainder = dividend % divisor
            return (quotient, remainder)

        val result = divmod(17, 5)
        print("17 √∑ 5 = {result[0]} R {result[1]}")  # "17 √∑ 5 = 3 R 2"
        ```

        **3. Min/Max Pair:**
        ```simple
        fn find_extremes(numbers):
            var min_val = numbers[0]
            var max_val = numbers[0]
            for n in numbers:
                if n < min_val:
                    min_val = n
                if n > max_val:
                    max_val = n
            return (min_val, max_val)

        val (min, max) = find_extremes([3, 7, 1, 9, 2])
        ```

        **4. Success with Value:**
        ```simple
        fn try_parse_int(text):
            # Returns (success: bool, value: i64)
            if is_valid_number(text):
                return (true, parse(text))
            return (false, 0)

        val result = try_parse_int('42')
        if result[0]:  # success
            print("Parsed: {result[1]}")
        ```

        **Future - Destructuring:**
        ```simple
        val (x, y) = get_point()  # Direct unpacking
        ```

        **Verification:** Confirms returned tuple elements are correct

        **Implementation:** See interpreter.rs::eval_return_statement()

        **Related:** Feature #90 (Pattern matching), Feature #19 (Structs)
        """
        fn get_point():
            return (3, 4)

        val point = get_point()
        expect(point[0]).to(eq(3))
        expect(point[1]).to(eq(4))

    it "passes tuple as argument":
        """
        **Given** a function that accepts a tuple parameter
        **When** calling the function with a tuple literal
        **Then** function can access tuple elements within its body

        **Syntax:**
        ```simple
        fn sum_pair(p):
            return p[0] + p[1]

        val result = sum_pair((5, 7))  # 12
        ```

        **Parameter Passing:**
        Tuples passed by value (copied):
        ```
        Caller: sum_pair((5, 7))
            ‚Üì (create tuple)
        Tuple (5, 7) created
            ‚Üì (pass to function)
        Parameter 'p' receives tuple
            ‚Üì (access elements)
        p[0] = 5, p[1] = 7
            ‚Üì (compute result)
        Return 5 + 7 = 12
        ```

        **Common Patterns:**

        **1. Point Operations:**
        ```simple
        fn distance_from_origin(point):
            val x = point[0]
            val y = point[1]
            return sqrt(x * x + y * y)

        val d = distance_from_origin((3, 4))  # 5.0
        ```

        **2. Vector Addition:**
        ```simple
        fn add_vectors(v1, v2):
            return (
                v1[0] + v2[0],
                v1[1] + v2[1]
            )

        val result = add_vectors((1, 2), (3, 4))  # (4, 6)
        ```

        **3. Rectangle Area:**
        ```simple
        fn area(dimensions):
            return dimensions[0] * dimensions[1]

        val a = area((10, 20))  # 200
        ```

        **4. RGB to Grayscale:**
        ```simple
        fn to_grayscale(rgb):
            val r = rgb[0]
            val g = rgb[1]
            val b = rgb[2]
            return (r + g + b) / 3

        val gray = to_grayscale((255, 200, 150))
        ```

        **Multiple Tuple Arguments:**
        ```simple
        fn dot_product(v1, v2):
            return v1[0] * v2[0] + v1[1] * v2[1]

        val dp = dot_product((1, 2), (3, 4))  # 11
        ```

        **Type Flexibility:**
        Mixed-type tuples work too:
        ```simple
        fn format_user(user):
            # Expects (id: i64, name: text)
            return "User #{user[0]}: {user[1]}"

        val msg = format_user((42, 'Alice'))  # "User #42: Alice"
        ```

        **Verification:** Confirms tuple argument is correctly processed

        **Performance:** Tuple copy overhead for small tuples is minimal

        **Implementation:** Tuple passed as RuntimeValue::Tuple, function body
        accesses it via subscript expressions

        **Alternative - Destructuring (Future):**
        ```simple
        fn sum_pair((a, b)):  # Direct destructuring in parameter
            return a + b
        ```

        **Related:** Feature #15 (Function parameters), Feature #10 (Subscript)
        """
        fn sum_pair(p):
            return p[0] + p[1]

        val result = sum_pair((5, 7))
        expect(result).to(eq(12))

describe "Nested tuples":
    """
    ## Nested Tuple Structures

    Tuples can contain other tuples or collections, enabling multi-dimensional data
    structures. This is useful for representing matrices, grids, or hierarchical data.

    **Syntax:**
    ```simple
    val nested = ((1, 2), (3, 4))
    val element = nested[0][1]  # 2
    ```

    **Chained Indexing:**
    - First subscript accesses outer tuple element
    - Second subscript accesses inner tuple/collection element
    - Can chain arbitrarily: `data[0][1][2]`

    **Use Cases:**
    - **2D Points:** `val line = ((0, 0), (100, 100))`
    - **Matrices:** `val matrix = ((1, 2), (3, 4))`
    - **Trees:** `val tree = (value, (left_child, right_child))`
    - **Nested config:** `val settings = (('theme', 'dark'), ('size', 12))`

    **Nesting Different Types:**
    ```simple
    val mixed = (
        (1, 2),           # tuple
        [3, 4],           # array
        {'x': 5}          # dict
    )
    ```

    **Performance:**
    - Access: O(1) per level
    - Total: O(d) where d is nesting depth
    - Memory: Nested structures have indirection overhead

    **Comparison with Alternatives:**
    - **Nested tuples:** `((1, 2), (3, 4))` - lightweight, immutable
    - **Arrays of tuples:** `[(1, 2), (3, 4)]` - dynamic, iterable
    - **2D arrays:** `[[1, 2], [3, 4]]` - homogeneous, rectangular

    **Implementation:** Each nested tuple is a separate RuntimeValue::Tuple,
    subscript chains resolve left-to-right.
    """

    it "creates nested tuples":
        """
        **Given** a tuple containing other tuples
        **When** accessing elements using chained subscripts
        **Then** correctly retrieves deeply nested values

        **Syntax:**
        ```simple
        val nested = ((1, 2), (3, 4))
        val a = nested[0][0]  # 1
        val b = nested[1][1]  # 4
        ```

        **Structure Visualization:**
        ```
        nested: ((1, 2), (3, 4))
                 ‚Üì       ‚Üì
              outer[0] outer[1]
                 ‚Üì       ‚Üì
              (1, 2)   (3, 4)
               ‚Üì  ‚Üì     ‚Üì  ‚Üì
              [0][1]   [0][1]
               1  2     3  4
        ```

        **Chained Access:**
        - `nested[0]` ‚Üí `(1, 2)` (first inner tuple)
        - `nested[0][0]` ‚Üí `1` (first element of first tuple)
        - `nested[1]` ‚Üí `(3, 4)` (second inner tuple)
        - `nested[1][1]` ‚Üí `4` (second element of second tuple)

        **Evaluation Order:**
        ```simple
        nested[0][1]
            ‚Üì (evaluate first subscript)
        (1, 2)[1]
            ‚Üì (evaluate second subscript)
        2
        ```

        **Common Patterns:**

        **1. Line Segments:**
        ```simple
        val line = ((0, 0), (100, 50))  # start point, end point
        val start_x = line[0][0]  # 0
        val start_y = line[0][1]  # 0
        val end_x = line[1][0]    # 100
        val end_y = line[1][1]    # 50
        ```

        **2. 2√ó2 Matrix:**
        ```simple
        val matrix = (
            (1, 2),
            (3, 4)
        )

        # Access row 0, column 1
        val element = matrix[0][1]  # 2

        # Matrix multiplication example
        fn matrix_mult(m1, m2):
            return (
                (m1[0][0]*m2[0][0] + m1[0][1]*m2[1][0],
                 m1[0][0]*m2[0][1] + m1[0][1]*m2[1][1]),
                (m1[1][0]*m2[0][0] + m1[1][1]*m2[1][0],
                 m1[1][0]*m2[0][1] + m1[1][1]*m2[1][1])
            )
        ```

        **3. Bounding Box:**
        ```simple
        val bbox = ((10, 20), (100, 200))  # (top-left, bottom-right)
        val width = bbox[1][0] - bbox[0][0]   # 90
        val height = bbox[1][1] - bbox[0][1]  # 180
        ```

        **4. Tree Node:**
        ```simple
        val tree = (
            5,                    # value
            (3, nil, nil),        # left subtree
            (7, nil, nil)         # right subtree
        )
        val root_val = tree[0]      # 5
        val left_val = tree[1][0]   # 3
        ```

        **Verification:** Confirms nested tuple access works correctly

        **Performance:** O(1) per level, O(2) total for 2-level nesting

        **Implementation:** Each subscript operation returns a RuntimeValue,
        which can be indexed again if it's a tuple/array

        **Alternative - Flattening:**
        ```simple
        # Instead of ((1, 2), (3, 4))
        # Could use (1, 2, 3, 4) with index math
        val flat = (1, 2, 3, 4)
        val element = flat[row * 2 + col]
        ```

        **Related:** Feature #12 (Multi-dimensional arrays)
        """
        val nested = ((1, 2), (3, 4))
        expect(nested[0][0]).to(eq(1))
        expect(nested[1][1]).to(eq(4))

    it "mixes tuples and arrays":
        """
        **Given** a tuple containing arrays
        **When** accessing elements with chained subscripts
        **Then** correctly retrieves array elements within the tuple

        **Syntax:**
        ```simple
        val combo = ([1, 2], [3, 4])
        val a = combo[0][0]  # 1
        val b = combo[1][1]  # 4
        ```

        **Mixed Collection Structure:**
        ```
        combo: ([1, 2], [3, 4])
                ‚Üì       ‚Üì
             array   array
              [0]     [1]
               ‚Üì       ‚Üì
             [1, 2]  [3, 4]
              ‚Üì  ‚Üì    ‚Üì  ‚Üì
             [0][1]  [0][1]
              1  2    3  4
        ```

        **Type Composition:**
        - Outer: Tuple (immutable, fixed-size)
        - Inner: Arrays (mutable, fixed-size but different type)
        - Elements: Integers

        **Access Patterns:**
        - `combo[0]` ‚Üí `[1, 2]` (first array, type: Array<i64>)
        - `combo[0][0]` ‚Üí `1` (first element of first array)
        - `combo[1]` ‚Üí `[3, 4]` (second array)
        - `combo[1][1]` ‚Üí `4` (second element of second array)

        **Use Cases:**

        **1. Multiple Sequences:**
        ```simple
        val dataset = (
            [1, 2, 3],     # input data
            [10, 20, 30]   # expected outputs
        )

        for i in range(3):
            val input = dataset[0][i]
            val expected = dataset[1][i]
            val actual = process(input)
            assert(actual == expected)
        ```

        **2. Grid Rows:**
        ```simple
        val grid = (
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        )

        val center = grid[1][1]  # 5
        ```

        **3. Test Cases:**
        ```simple
        val test_cases = (
            [1, 2, 3],      # inputs
            [2, 4, 6],      # expected outputs
            ['odd', 'even', 'odd']  # categories
        )
        ```

        **Mutability Considerations:**
        ```simple
        val data = ([1, 2], [3, 4])

        # Can modify array contents
        data[0][0] = 100  # OK: arrays are mutable
        # Result: ([100, 2], [3, 4])

        # Cannot replace array
        data[0] = [5, 6]  # ERROR: tuple elements immutable
        ```

        **Mixed with Other Collections:**
        ```simple
        val complex = (
            [1, 2],           # array
            (3, 4),           # tuple
            {'x': 5, 'y': 6}  # dict
        )

        val a = complex[0][1]       # 2 (array access)
        val b = complex[1][0]       # 3 (tuple access)
        val c = complex[2]['x']     # 5 (dict access)
        ```

        **Verification:** Confirms tuple-of-arrays access works correctly

        **Performance:** O(1) for tuple access, O(1) for array access

        **Implementation:** Subscript operator polymorphic over collection types

        **Comparison:**
        - `((1, 2), (3, 4))` - fully immutable
        - `([1, 2], [3, 4])` - inner arrays mutable
        - `[[1, 2], [3, 4]]` - array of arrays, fully mutable

        **Related:** Feature #12 (Arrays), Feature #20 (Lists)
        """
        val combo = ([1, 2], [3, 4])
        expect(combo[0][0]).to(eq(1))
        expect(combo[1][1]).to(eq(4))
