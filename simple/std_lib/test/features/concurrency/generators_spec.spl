# Generators Feature Specification
# Feature #42: Yield-based lazy iteration
# Category: Concurrency | Difficulty: 4 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: i32
    name: text
    category: text
    difficulty: i32
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    code_examples: List<text>
    dependencies: List<i32>
    required_by: List<i32>
    notes: text

# Feature Definition
val FEATURE = FeatureMetadata {
    id: 42,
    name: 'Generators',
    category: 'Concurrency',
    difficulty: 4,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/spec/concurrency.md',
    files: [
        'src/compiler/src/mir/generator.rs',
        'src/runtime/src/value/async_gen.rs'
    ],
    tests: [
        'src/driver/tests/interpreter_async_tests.rs',
        'src/driver/tests/runner_async_tests.rs'
    ],
    description: 'Generators for lazyvalue production using yield. Supports single and multiple yields, state preservation, captured variables, and collection.',
    code_examples: [],
    dependencies: [24],
    required_by: [],
    notes: 'Generators use state machine lowering in MIR. Yield has low precedence - use parentheses for expressions.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  GENERATORS FEATURE SPECIFICATION (#42)')
print('  Category: Concurrency | Difficulty: 4 | Status: Complete')
print('============================================================')
print('')

var passed = 0
var failed = 0

# -----------------------------------------------------
# Basic Generator
# -----------------------------------------------------

print('describe Generator creation:')
print('  context single yield:')
print('    it yields singlevalue:')

val gen1 = generator(\: yield 42)
if next(gen1) == 42:
    print('      [PASS] single yield')
    passed = passed + 1
else:
    print('      [FAIL] single yield')
    failed = failed + 1

print('')
print('  context multiple yields:')
print('    it yields multiplevalues:')

val gen2 = generator(\: [yield 1, yield 2, yield 3])
val first = next(gen2)
val second = next(gen2)
val third = next(gen2)
if first + second + third == 6:
    print('      [PASS] multiple yields')
    passed = passed + 1
else:
    print('      [FAIL] multiple yields')
    failed = failed + 1

print('    it maintains order:')

val gen3 = generator(\: [yield 10, yield 20, yield 30])
if next(gen3) == 10 and next(gen3) == 20 and next(gen3) == 30:
    print('      [PASS] yield order')
    passed = passed + 1
else:
    print('      [FAIL] yield order')
    failed = failed + 1

# -----------------------------------------------------
# Generator State
# -----------------------------------------------------

print('')
print('describe Generator state:')
print('  context exhaustion:')
print('    it returns nil when exhausted:')

val gen4 = generator(\: yield 1)
val v1 = next(gen4)
val v2 = next(gen4)
# v2 is nil which is falsy
if v1 == 1 and not v2:
    print('      [PASS] exhaustion returns nil')
    passed = passed + 1
else:
    print('      [FAIL] exhaustion returns nil')
    failed = failed + 1

print('')
print('  context state preservation:')
print('    it preserves state across yields:')

val gen5 = generator(\: (yield 10, yield 15)[1])
val a = next(gen5)
val b = next(gen5)
if a + b == 25:
    print('      [PASS] state preserved')
    passed = passed + 1
else:
    print('      [FAIL] state preserved')
    failed = failed + 1

# -----------------------------------------------------
# Captured Variables
# -----------------------------------------------------

print('')
print('describe Captured variables:')
print('  context outer variable capture:')
print('    it captures outer variable:')

val base = 100
val gen6 = generator(\: [yield base, yield base])
val c1 = next(gen6)
val c2 = next(gen6)
if c1 + c2 == 200:
    print('      [PASS] captures outer var')
    passed = passed + 1
else:
    print('      [FAIL] captures outer var')
    failed = failed + 1

print('    it uses captured in expression:')

val offset = 100
val gen7 = generator(\: [yield (1 + offset), yield (2 + offset)])
val d1 = next(gen7)
val d2 = next(gen7)
if d1 + d2 == 203:
    print('      [PASS] captured in expression')
    passed = passed + 1
else:
    print('      [FAIL] captured in expression')
    failed = failed + 1

print('')
print('  context multiple captures:')
print('    it captures multiple variables:')

val x = 5
val y = 3
val gen8 = generator(\: yield (x * y + x))
if next(gen8) == 20:
    print('      [PASS] multiple captures')
    passed = passed + 1
else:
    print('      [FAIL] multiple captures')
    failed = failed + 1

# -----------------------------------------------------
# Arithmetic in Yield
# -----------------------------------------------------

print('')
print('describe Yield expressions:')
print('  context arithmetic yield:')
print('    it evaluates before yield:')

val value = 2 * 3
val gen9 = generator(\: yieldvalue)
if next(gen9) == 6:
    print('      [PASS] arithmetic yield')
    passed = passed + 1
else:
    print('      [FAIL] arithmetic yield')
    failed = failed + 1

# -----------------------------------------------------
# Collect Generator
# -----------------------------------------------------

print('')
print('describe Collect:')
print('  context collectingvalues:')
print('    it collects all yields:')

val gen10 = generator(\: (yield 10, yield 20, yield 30, 0)[3])
val arr = collect(gen10)
if arr[0] + arr[1] + arr[2] == 60:
    print('      [PASS] collect generator')
    passed = passed + 1
else:
    print('      [FAIL] collect generator')
    failed = failed + 1

# -----------------------------------------------------
# Nested Iteration
# -----------------------------------------------------

print('')
print('describe Nested iteration:')
print('  context draining generator:')
print('    it supports chained next:')

val gen11 = generator(\: [yield 1, yield 2, yield 3, yield 4])
val sum = next(gen11) + next(gen11) + next(gen11) + next(gen11)
if sum == 10:
    print('      [PASS] chained next calls')
    passed = passed + 1
else:
    print('      [FAIL] chained next calls')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# Generators')
print('')
print('**Feature ID:** #42')
print('**Category:** Concurrency')
print('**Difficulty:** Level 4/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## Syntax')
print('')
print('```simple')
print('# Create generator with yield')
print('val gen = generator(\\: yield 42)')
print('')
print('# Get nextvalue')
print('val value = next(gen)')
print('')
print('# Multiple yields')
print('val gen = generator(\\: [yield 1, yield 2, yield 3])')
print('')
print('# Collect allvalues')
print('val arr = collect(gen)')
print('```')
print('')
print('## Yield Precedence')
print('')
print('Yield has low precedence. Use parentheses for expressions:')
print('```simple')
print('yield (x + 1)    # Correct')
print('yield x + 1      # May not work as expected')
print('```')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
val total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
