# Integration Tests for Ratatui Backend
#
# Tests the FFI bridge between Simple and Ratatui framework.
# These tests verify that:
#   - Terminal lifecycle (create/cleanup) works correctly
#   - Text buffer operations function as expected
#   - Rendering completes without errors
#   - Event reading works (basic check)
#
# Note: These are headless tests - they don't require a real terminal.
# The Ratatui FFI backend handles terminal initialization gracefully.

use spec.*
use ui.tui.backend.ratatui.*

describe "Ratatui Backend FFI":
    context "terminal lifecycle":
        it "creates terminal successfully":
            let terminal = terminal_new()

            # Should return non-zero handle
            expect(terminal).to_not eq(0)

            # Cleanup
            terminal_cleanup(terminal)

        it "allows cleanup of terminal":
            let terminal = terminal_new()
            terminal_cleanup(terminal)

            # No error should occur
            expect(true).to be_true()

        it "supports terminal clear":
            let terminal = terminal_new()
            terminal_clear(terminal)

            # Clear should complete without error
            expect(true).to be_true()

            terminal_cleanup(terminal)

    context "text buffer creation":
        it "creates empty text buffer":
            let buffer = textbuffer_new()

            # Should return non-zero handle
            expect(buffer).to_not eq(0)

            # Should be empty initially
            let text = textbuffer_get_text(buffer)
            expect(text).to eq("")

            # Cleanup
            object_destroy(buffer)

        it "creates multiple independent buffers":
            let buffer1 = textbuffer_new()
            let buffer2 = textbuffer_new()

            # Should have different handles
            expect(buffer1).to_not eq(buffer2)
            expect(buffer1).to_not eq(0)
            expect(buffer2).to_not eq(0)

            # Cleanup
            object_destroy(buffer1)
            object_destroy(buffer2)

    context "text buffer operations":
        it "sets and gets text":
            let buffer = textbuffer_new()

            textbuffer_set_text(buffer, "Hello, World!")
            let text = textbuffer_get_text(buffer)

            expect(text).to eq("Hello, World!")

            object_destroy(buffer)

        it "handles empty string":
            let buffer = textbuffer_new()

            textbuffer_set_text(buffer, "")
            let text = textbuffer_get_text(buffer)

            expect(text).to eq("")

            object_destroy(buffer)

        it "handles multiline text":
            let buffer = textbuffer_new()

            textbuffer_set_text(buffer, "Line 1\nLine 2\nLine 3")
            let text = textbuffer_get_text(buffer)

            expect(text).to eq("Line 1\nLine 2\nLine 3")

            object_destroy(buffer)

        it "inserts characters":
            let buffer = textbuffer_new()

            textbuffer_insert_char(buffer, 'H')
            textbuffer_insert_char(buffer, 'i')
            let text = textbuffer_get_text(buffer)

            expect(text).to eq("Hi")

            object_destroy(buffer)

        it "handles backspace on non-empty buffer":
            let buffer = textbuffer_new()

            textbuffer_set_text(buffer, "Hello")
            textbuffer_backspace(buffer)
            let text = textbuffer_get_text(buffer)

            expect(text).to eq("Hell")

            object_destroy(buffer)

        it "handles backspace on empty buffer gracefully":
            let buffer = textbuffer_new()

            # Should not crash
            textbuffer_backspace(buffer)
            let text = textbuffer_get_text(buffer)

            expect(text).to eq("")

            object_destroy(buffer)

        it "handles newline insertion":
            let buffer = textbuffer_new()

            textbuffer_set_text(buffer, "First")
            textbuffer_newline(buffer)
            let text = textbuffer_get_text(buffer)

            # Note: Newline behavior depends on cursor position
            # This test verifies it doesn't crash
            expect(text).to_not be_nil()

            object_destroy(buffer)

    context "rendering":
        it "renders text buffer with prompt":
            let terminal = terminal_new()
            let buffer = textbuffer_new()

            textbuffer_set_text(buffer, "test input")
            render_textbuffer(terminal, buffer, ">>> ")

            # Rendering should complete without error
            expect(true).to be_true()

            object_destroy(buffer)
            terminal_cleanup(terminal)

        it "renders empty buffer":
            let terminal = terminal_new()
            let buffer = textbuffer_new()

            render_textbuffer(terminal, buffer, ">>> ")

            # Should render without error
            expect(true).to be_true()

            object_destroy(buffer)
            terminal_cleanup(terminal)

        it "renders with empty prompt":
            let terminal = terminal_new()
            let buffer = textbuffer_new()

            textbuffer_set_text(buffer, "content")
            render_textbuffer(terminal, buffer, "")

            # Should render without error
            expect(true).to be_true()

            object_destroy(buffer)
            terminal_cleanup(terminal)

    context "event handling":
        it "reads event with timeout":
            # Note: This test verifies the FFI call works
            # In headless mode, it will timeout (no keyboard input)
            let event = read_event(10)  # 10ms timeout

            # Should return an event structure (possibly timeout event)
            # event_type == 0 means timeout/no event
            expect(event.event_type).to be_gte(0)

    context "helper functions":
        it "identifies printable characters":
            expect(is_printable(65)).to be_true()   # 'A'
            expect(is_printable(97)).to be_true()   # 'a'
            expect(is_printable(48)).to be_true()   # '0'
            expect(is_printable(32)).to be_true()   # space
            expect(is_printable(13)).to be_false()  # enter
            expect(is_printable(27)).to be_false()  # escape

        it "checks modifiers correctly":
            expect(has_modifier(MOD_CTRL, MOD_CTRL)).to be_true()
            expect(has_modifier(MOD_SHIFT, MOD_SHIFT)).to be_true()
            expect(has_modifier(MOD_CTRL | MOD_SHIFT, MOD_CTRL)).to be_true()
            expect(has_modifier(MOD_CTRL | MOD_SHIFT, MOD_SHIFT)).to be_true()
            expect(has_modifier(0, MOD_CTRL)).to be_false()

        it "converts printable events to char":
            let event = TuiEvent {
                event_type: EventType::Key,
                key_code: 65,
                key_mods: 0,
                char_value: 65
            }

            match event_to_char(event):
                case Some(ch):
                    expect(ch).to eq('A')
                case None:
                    fail("Expected Some(char)")

        it "returns None for non-printable events":
            let event = TuiEvent {
                event_type: EventType::Key,
                key_code: KEY_ENTER,
                key_mods: 0,
                char_value: 13
            }

            match event_to_char(event):
                case Some(_):
                    fail("Expected None for non-printable")
                case None:
                    expect(true).to be_true()

    context "resource cleanup":
        it "can destroy terminal objects":
            let terminal = terminal_new()
            object_destroy(terminal)

            # Should not crash
            expect(true).to be_true()

        it "can destroy buffer objects":
            let buffer = textbuffer_new()
            object_destroy(buffer)

            # Should not crash
            expect(true).to be_true()

    context "stress test":
        it "handles many sequential operations":
            let buffer = textbuffer_new()

            # Insert many characters
            for i in range(0, 100):
                textbuffer_insert_char(buffer, 'x')

            let text = textbuffer_get_text(buffer)
            expect(text.len()).to eq(100)

            # Backspace many times
            for i in range(0, 50):
                textbuffer_backspace(buffer)

            text = textbuffer_get_text(buffer)
            expect(text.len()).to eq(50)

            object_destroy(buffer)

        it "handles many buffer creations/destructions":
            for i in range(0, 10):
                let buffer = textbuffer_new()
                textbuffer_set_text(buffer, "test")
                let text = textbuffer_get_text(buffer)
                expect(text).to eq("test")
                object_destroy(buffer)

            # All buffers should be properly cleaned up
            expect(true).to be_true()
