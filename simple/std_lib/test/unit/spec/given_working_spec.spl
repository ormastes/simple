/// Comprehensive tests to verify given: (unnamed eager) and given :name (named eager) work correctly

describe "Given (Eager Fixtures)":

    describe "Unnamed eager - given { }":
        context "with eager setup":
            let setup_ran = false

            given:
                # This should run before each example
                setup_ran = true

            it "runs eager given before example":
                expect setup_ran

            it "setup_ran is true in second example too":
                expect setup_ran

    describe "Named eager - given :name, \\:":
        context "with named eager setup":
            let counter = 0
            let processed = false

            given :initialize, \:
                counter = counter + 1

            given :process, \:
                processed = true

            it "runs first named given":
                expect counter == 1

            it "runs all named givens":
                expect processed

            it "each example gets fresh state":
                expect counter == 1
                expect processed

    describe "Combining unnamed and named given":
        context "with mixed eager fixtures":
            let order = []

            given:
                order.push("unnamed")

            given :first, \:
                order.push("first")

            given :second, \:
                order.push("second")

            it "all setup runs in order":
                expect order.len == 3
                expect order[0] == "unnamed"
                expect order[1] == "first"
                expect order[2] == "second"

            it "second example gets fresh order":
                expect order.len == 3

    describe "Given with lazy fixtures":
        context "mixing eager and lazy":
            let initialized = false

            given:
                initialized = true

            given_lazy :data, \:
                { value: 42, initialized: initialized }

            it "eager runs before lazy":
                expect initialized
                expect data.initialized
                expect data.value == 42

            it "lazy is memoized, eager runs again":
                expect initialized
                expect data.value == 42

    describe "Given in nested contexts":
        context "outer context":
            let level = 0

            given:
                level = level + 1

            context "inner context":
                given:
                    level = level + 10

                it "inner given adds to outer given":
                    expect level == 11

    describe "Given in context_def":
        context_def :with_eager_setup:
            given:
                # This should work in context definitions
                pass

            given_lazy :fixture, \:
                "value"

        context :with_eager_setup:
            it "context_def given works":
                expect fixture == "value"

    describe "Real-world database simulation":
        context "with realistic setup":
            let db_state = { tables: 0, connected: false }

            given:
                # Simulate: db.connect()
                db_state.connected = true
                # Simulate: db.migrate()
                db_state.tables = db_state.tables + 1

            given_lazy :users_table, \:
                db_state.tables = db_state.tables + 1
                { count: 0, name: "users" }

            it "connection established":
                expect db_state.connected

            it "tables created":
                expect db_state.tables >= 2

            it "users table exists":
                expect users_table.name == "users"

            it "second test gets fresh setup":
                expect db_state.connected
                expect db_state.tables >= 2
