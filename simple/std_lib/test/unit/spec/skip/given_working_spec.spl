/// Comprehensive tests to verify given: (unnamed eager) and given :name (named eager) work correctly

describe "Given (Eager Fixtures)":

    describe "Unnamed eager - given { }":
        context "with eager setup":
            let setup_ran = false

            given:
                # This should run before each example
                setup_ran = true

            it "runs eager given before example":
                expect setup_ran

            it "setup_ran is true in second example too":
                expect setup_ran

    describe "Named eager - given :name, \\:":
        context "with named eager setup":
            let counter = 0
            let processed = false

            given :initialize, \:
                counter = counter + 1

            given :process, \:
                processed = true

            it "runs first named given":
                expect counter == 1

            it "runs all named givens":
                expect processed

            it "each example gets fresh state":
                expect counter == 1
                expect processed

    describe "Combining unnamed and named given":
        context "with mixed eager fixtures":
            let order = []

            given:
                order.push("unnamed")

            given :first, \:
                order.push("first")

            given :second, \:
                order.push("second")

            it "all setup runs in order":
                expect order.len == 3
                expect order[0] == "unnamed"
                expect order[1] == "first"
                expect order[2] == "second"

            it "second example gets fresh order":
                expect order.len == 3

    describe "Given with lazy fixtures":
        context "mixing eager and lazy":
            let initialized = false

            given:
                initialized = true

            given_lazy :data, \:
                { value: 42, initialized: initialized }

            it "eager runs before lazy":
                expect initialized
                expect data.initialized
                expect data.value == 42

            it "lazy is memoized, eager runs again":
                expect initialized
                expect data.value == 42

    describe "Given in nested contexts":
        context "outer context":
            let level = 0

            given:
                level = level + 1

            context "inner context":
                given:
                    level = level + 10

                it "inner given adds to outer given":
                    expect level == 11

    describe "Given in context_def":
        context_def :with_eager_setup:
            given:
                # This should work in context definitions
                pass

            given_lazy :fixture, \:
                "value"

        context :with_eager_setup:
            it "context_def given works":
                expect fixture == "value"

    describe "Real-world database simulation":
        context "with realistic setup":
            let db_state = { tables: 0, connected: false }

            given:
                # Simulate: db.connect()
                db_state.connected = true
                # Simulate: db.migrate()
                db_state.tables = db_state.tables + 1

            given_lazy :users_table, \:
                db_state.tables = db_state.tables + 1
                { count: 0, name: "users" }

            it "connection established":
                expect db_state.connected

            it "tables created":
                expect db_state.tables >= 2

            it "users table exists":
                expect users_table.name == "users"

            it "second test gets fresh setup":
                expect db_state.connected
                expect db_state.tables >= 2

    describe "Referencing context_def in given blocks":
        context_def :db_fixtures:
            given_lazy :database, \:
                { connected: true, tables: ["users", "posts"] }

        context_def :auth_fixtures:
            given_lazy :token, \:
                "auth_token_xyz"

        context "composing multiple contexts via given":
            # Reference context_def directly via given
            given :db_fixtures

            given :auth_fixtures

            it "has database from context_def":
                expect database.connected
                expect database.tables.len == 2

            it "has token from context_def":
                expect token == "auth_token_xyz"

    describe "Sequential given block with context refs and variables":
        context_def :user_data:
            given_lazy :user, \:
                { name: "Alice", id: 42 }

        context "sequential setup - refs then variables":
            # Single given: block with sequential statements
            given:
                # Step 1: Reference context_def
                given :user_data

                # Step 2: Define derived variables from fixtures
                let user_key = "user_" + user.id.to_string()
                let greeting = "Hello, " + user.name

            it "accesses fixture from context_def":
                expect user.name == "Alice"

            it "uses derived variable from fixture":
                expect user_key == "user_42"

            it "combines context data with new variables":
                expect greeting == "Hello, Alice"

            it "each test gets fresh derived state":
                expect user_key == "user_42"
                expect greeting == "Hello, Alice"
