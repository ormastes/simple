# Test file for TEST-012: let memoization
# Verifies that let and let_lazy work correctly

import test.unit.*
import std.spec

# ============================================================================
# TEST-012: Let Memoization
# ============================================================================

describe "Let Memoization (TEST-012)":

    describe "let (eager - before_each)":
        context "basic usage":
            let x = 10

            it "provides the value":
                expect x == 10

            it "value is available in each example":
                expect x == 10

    describe "let_lazy (true lazy memoization)":
        context "basic lazy evaluation":
            let_lazy :lazy_value, \: 42

            it "can access lazy value":
                let val = get_let(:lazy_value)
                expect val == 42

        context "multiple lazy values":
            let_lazy :first, \: 10
            let_lazy :second, \: 20

            it "accesses first value":
                expect get_let(:first) == 10

            it "accesses second value":
                expect get_let(:second) == 20

    describe "has_let helper":
        context "checking existence":
            let_lazy :defined_value, \: 100

            it "returns true for defined let_lazy":
                expect has_let(:defined_value)

    describe "get_let helper":
        context "accessing lazy values":
            let_lazy :accessible, \: "hello"

            it "returns the value":
                expect get_let(:accessible) == "hello"

    describe "combining let and let_lazy":
        context "in same context":
            let eager = 10
            let_lazy :lazy, \: 20

            it "eager value is accessible":
                expect eager == 10

            it "lazy value is accessible":
                expect get_let(:lazy) == 20

        context "with given_lazy":
            given_lazy :given_value, \: 5

            it "given_lazy is accessible":
                expect get_let(:given_value) == 5

    describe "nested lazy values":
        context "with dependencies":
            let_lazy :outer, \: 10
            let_lazy :middle, \: 20

            it "outer is accessible":
                expect get_let(:outer) == 10

            it "middle is accessible":
                expect get_let(:middle) == 20


# ============================================================================
# Edge cases
# ============================================================================

describe "Let Memoization Edge Cases":

    context "lazy value with simple types":
        let_lazy :string_val, \: "test string"
        let_lazy :int_val, \: 42
        let_lazy :bool_val, \: true

        it "handles string values":
            expect get_let(:string_val) == "test string"

        it "handles int values":
            expect get_let(:int_val) == 42

        it "handles bool values":
            expect get_let(:bool_val) == true

    context "lazy value with list":
        let_lazy :list_val, \: [1, 2, 3]

        it "handles list values":
            let list = get_let(:list_val)
            expect len(list) == 3
            expect list[0] == 1
