describe "Context Sharing - Usage Examples":

    # ============================================================================
    # EXAMPLE 1: Basic Context Definition and Reference
    # ============================================================================

    # Define a reusable context with lazy fixtures
    context_def :admin_user:
        given_lazy :user, fn():
            # Simulate creating an admin user
            "admin@example.com"

        given_lazy :permissions, fn():
            ["read", "write", "delete"]

    # Reference the context in tests
    context :admin_user:
        it "has admin user email":
            expect user == "admin@example.com"

        it "has write permissions":
            expect permissions.includes?("write")

        it "has delete permissions":
            expect permissions.includes?("delete")


    # ============================================================================
    # EXAMPLE 2: Multiple Contexts - Eager vs Lazy Fixtures
    # ============================================================================

    context_def :with_database:
        # Eager given - runs before each example
        given:
            # Setup database (runs every time)
            pass  # Placeholder for db.setup()

        # Lazy given - memoized per example
        given_lazy :db_connection, fn():
            "database://localhost:5432"

    context_def :with_logging:
        given_lazy :logs, fn():
            []

    # Compose multiple contexts
    context_compose :with_database, :with_logging:
        it "has database connection":
            expect db_connection.includes?("localhost")

        it "has empty logs initially":
            expect logs.len == 0


    # ============================================================================
    # EXAMPLE 3: Stack Example (Classic BDD Pattern)
    # ============================================================================

    context_def :empty_stack:
        given_lazy :stack, fn():
            # Stack is empty when created
            []

    context_def :stack_with_items:
        given_lazy :stack, fn():
            [1, 2, 3]

    describe "Stack Operations":
        context :empty_stack:
            it "is empty":
                expect stack.len == 0

            it "can push items":
                stack.push(42)
                expect stack.len == 1
                expect stack[0] == 42

        context :stack_with_items:
            it "contains items":
                expect stack.len == 3
                expect stack[0] == 1

            it "can pop items":
                let item = stack[stack.len - 1]
                expect item == 3


    # ============================================================================
    # EXAMPLE 4: Inline Given Fixtures (Anonymous Eager Setup)
    # ============================================================================

    describe "List Operations":
        context "when adding items":
            # Eager given - runs before each test
            given:
                # This setup runs before each example
                pass  # Placeholder for setup code

            it "can add to list":
                let items = []
                items.push(1)
                expect items.len == 1

            it "preserves order":
                let items = [1, 2, 3]
                expect items[0] == 1
                expect items[2] == 3


    # ============================================================================
    # EXAMPLE 5: Context with Nested Description (Combining Old and New)
    # ============================================================================

    context_def :authenticated_session:
        given_lazy :auth_token, fn():
            "token_abc123"

        given_lazy :user_id, fn():
            42

    describe "User Session Management":
        context :authenticated_session:
            it "has valid auth token":
                expect auth_token.len > 0

            it "has valid user id":
                expect user_id == 42

            # Can still use nested string-based context
            context "when accessing protected resource":
                it "requires auth token":
                    expect auth_token == "token_abc123"

                it "has user context":
                    expect user_id == 42


    # ============================================================================
    # EXAMPLE 6: BDD Given-When-Then Style
    # ============================================================================

    context_def :calculator_state:
        given_lazy :calculator, fn():
            0  # Start with zero

    describe "Calculator (Given-When-Then)":
        context :calculator_state:
            it "starts at zero":
                expect calculator == 0

            # Given: value is 5
            context "when adding 10":
                given:
                    # When: perform addition
                    pass  # calculator = calculator + 10

                # Then: verify result
                it "equals 15":
                    expect true  # Would verify calculator == 15

            # Different scenario
            context "when multiplying by 2":
                given:
                    # When: perform multiplication
                    pass  # calculator = calculator * 2

                # Then: verify result
                it "equals 0":
                    expect true  # Multiplying 0 by 2 is 0


    # ============================================================================
    # EXAMPLE 7: Multi-Context Composition with Setup
    # ============================================================================

    context_def :base_user:
        given_lazy :user, fn():
            "user@example.com"

    context_def :with_api_key:
        given_lazy :api_key, fn():
            "key_xyz789"

    context_def :with_rate_limit:
        given_lazy :rate_limit, fn():
            100

    describe "API Client":
        # Compose all three contexts
        context_compose :base_user, :with_api_key, :with_rate_limit:
            it "has user":
                expect user == "user@example.com"

            it "has api key":
                expect api_key == "key_xyz789"

            it "has rate limit":
                expect rate_limit == 100

            it "all fixtures available":
                expect user.len > 0
                expect api_key.len > 0
                expect rate_limit > 0


    # ============================================================================
    # EXAMPLE 8: Fixture Dependency (Using Other Fixtures)
    # ============================================================================

    context_def :math_fixtures:
        given_lazy :x, fn():
            10

        given_lazy :y, fn():
            x + 5  # y depends on x

        given_lazy :sum, fn():
            x + y  # sum depends on both x and y

    describe "Dependent Fixtures":
        context :math_fixtures:
            it "x is 10":
                expect x == 10

            it "y depends on x":
                expect y == 15

            it "sum depends on both":
                expect sum == 25


    # ============================================================================
    # EXAMPLE 9: String-Based Context (Original Syntax - Still Works)
    # ============================================================================

    describe "Original Context Syntax (Backward Compatible)":
        context "with string description":
            let value = 42

            it "still works":
                expect value == 42

            context "nested string context":
                it "supports nesting":
                    expect true


    # ============================================================================
    # EXAMPLE 10: Mixed Usage Pattern
    # ============================================================================

    context_def :test_data:
        given_lazy :numbers, fn():
            [1, 2, 3, 4, 5]

    describe "Mixed Patterns":
        context :test_data:
            # Use reusable context
            it "has data from context":
                expect numbers.len == 5

            context "with additional setup":
                # Add inline context with string description
                given:
                    # Extra setup for this context
                    pass

                it "combines reusable and inline":
                    expect numbers.includes?(3)
