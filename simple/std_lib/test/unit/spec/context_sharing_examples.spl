describe "Context Sharing - Usage Examples":

    # ============================================================================
    # EXAMPLE 1: Basic Context Definition and Reference
    # ============================================================================

    # Define a reusable context with lazy fixtures
    context_def :admin_user:
        given_lazy :user, \:
            # Simulate creating an admin user
            "admin@example.com"

        given_lazy :permissions, \:
            ["read", "write", "delete"]

    # Reference the context in tests
    context :admin_user:
        it "has admin user email":
            expect user == "admin@example.com"

        it "has write permissions":
            expect permissions.includes?("write")

        it "has delete permissions":
            expect permissions.includes?("delete")


    # ============================================================================
    # EXAMPLE 2: Multiple Contexts - Eager vs Lazy Fixtures
    # ============================================================================

    context_def :with_database:
        # Eager given - runs before each example
        given:
            # Simulate database setup (runs before each example)
            # In real code: db.connect(), db.migrate(), db.clear()
            # For demo: we just validate the connection is available
            pass

        # Lazy given - memoized per example
        given_lazy :db_connection, \:
            "database://localhost:5432"

    context_def :with_logging:
        given_lazy :logs, \:
            []

    # Compose multiple contexts
    context_compose :with_database, :with_logging:
        it "has database connection":
            expect db_connection.includes?("localhost")

        it "has empty logs initially":
            expect logs.len == 0


    # ============================================================================
    # EXAMPLE 3: Stack Example (Classic BDD Pattern)
    # ============================================================================

    context_def :empty_stack:
        given_lazy :stack, \:
            # Stack is empty when created
            []

    context_def :stack_with_items:
        given_lazy :stack, \:
            [1, 2, 3]

    describe "Stack Operations":
        context :empty_stack:
            it "is empty":
                expect stack.len == 0

            it "can push items":
                stack.push(42)
                expect stack.len == 1
                expect stack[0] == 42

        context :stack_with_items:
            it "contains items":
                expect stack.len == 3
                expect stack[0] == 1

            it "can pop items":
                let item = stack[stack.len - 1]
                expect item == 3


    # ============================================================================
    # EXAMPLE 4: Inline Given Fixtures (Anonymous Eager Setup)
    # ============================================================================

    describe "List Operations":
        context "when adding items":
            # Eager given - runs before each test (prepare environment)
            given:
                # Setup runs before each example
                # In real code: validate_list_environment(), setup_allocator()
                pass

            it "can add to list":
                let items = []
                items.push(1)
                expect items.len == 1

            it "preserves order":
                let items = [1, 2, 3]
                expect items[0] == 1
                expect items[2] == 3


    # ============================================================================
    # EXAMPLE 5: Context with Nested Description (Combining Old and New)
    # ============================================================================

    context_def :authenticated_session:
        given_lazy :auth_token, \:
            "token_abc123"

        given_lazy :user_id, \:
            42

    describe "User Session Management":
        context :authenticated_session:
            it "has valid auth token":
                expect auth_token.len > 0

            it "has valid user id":
                expect user_id == 42

            # Can still use nested string-based context
            context "when accessing protected resource":
                it "requires auth token":
                    expect auth_token == "token_abc123"

                it "has user context":
                    expect user_id == 42


    # ============================================================================
    # EXAMPLE 6: BDD Given-When-Then Style
    # ============================================================================

    context_def :calculator_state:
        given_lazy :calculator, \:
            0  # Start with zero

    describe "Calculator (Given-When-Then)":
        context :calculator_state:
            it "starts at zero":
                expect calculator == 0

            # Different scenario: multiply by 2
            context "when multiplying by 2":
                given:
                    # When: perform multiplication
                    # Note: Given context has calculator = 0
                    # Multiplying 0 by 2 = 0
                    pass

                # Then: verify result
                it "result is 0":
                    expect calculator == 0


    # ============================================================================
    # EXAMPLE 7: Multi-Context Composition with Setup
    # ============================================================================

    context_def :base_user:
        given_lazy :user, \:
            "user@example.com"

    context_def :with_api_key:
        given_lazy :api_key, \:
            "key_xyz789"

    context_def :with_rate_limit:
        given_lazy :rate_limit, \:
            100

    describe "API Client":
        # Compose all three contexts
        context_compose :base_user, :with_api_key, :with_rate_limit:
            it "has user":
                expect user == "user@example.com"

            it "has api key":
                expect api_key == "key_xyz789"

            it "has rate limit":
                expect rate_limit == 100

            it "all fixtures available":
                expect user.len > 0
                expect api_key.len > 0
                expect rate_limit > 0


    # ============================================================================
    # EXAMPLE 8: Fixture Dependency (Using Other Fixtures)
    # ============================================================================

    context_def :math_fixtures:
        given_lazy :x, \:
            10

        given_lazy :y, \:
            x + 5  # y depends on x

        given_lazy :sum, \:
            x + y  # sum depends on both x and y

    describe "Dependent Fixtures":
        context :math_fixtures:
            it "x is 10":
                expect x == 10

            it "y depends on x":
                expect y == 15

            it "sum depends on both":
                expect sum == 25


    # ============================================================================
    # EXAMPLE 9: String-Based Context (Original Syntax - Still Works)
    # ============================================================================

    describe "Original Context Syntax (Backward Compatible)":
        context "with string description":
            let value = 42

            it "still works":
                expect value == 42

            context "nested string context":
                it "supports nesting":
                    expect true


    # ============================================================================
    # EXAMPLE 10: Mixed Usage Pattern
    # ============================================================================

    context_def :test_data:
        given_lazy :numbers, \:
            [1, 2, 3, 4, 5]

    describe "Mixed Patterns":
        context :test_data:
            # Use reusable context
            it "has data from context":
                expect numbers.len == 5

            context "with additional setup":
                # Add inline context with string description
                given:
                    # Extra setup for this context
                    pass

                it "combines reusable and inline":
                    expect numbers.includes?(3)


    # ============================================================================
    # EXAMPLE 11: Inline given_lazy (Lazy Fixtures in Regular Context)
    # ============================================================================

    describe "Inline Lazy Fixtures":
        context "with lazy user":
            # Define lazy fixture inline (memoized per example)
            given_lazy :user, \:
                { id: 1, name: "Alice", role: "admin" }

            it "has user from lazy fixture":
                expect user.name == "Alice"

            it "lazy fixture is same instance":
                # Same user object within this example
                expect user.id == 1


    # ============================================================================
    # EXAMPLE 12: Combining Inline given/given_lazy
    # ============================================================================

    describe "Mixed Setup Styles":
        context "with setup and fixture":
            # Unnamed eager setup - runs before each example
            given:
                pass  # Placeholder: validate_environment()

            # Lazy fixture - memoized per example
            given_lazy :counter, \:
                0

            it "has fresh counter":
                expect counter == 0

            it "counter is memoized in example":
                expect counter == 0


    # ============================================================================
    # EXAMPLE 13: Named Eager Fixtures (given :name)
    # ============================================================================

    describe "Named Eager Setup":
        context "with named setup blocks":
            let state = { db: false, cache: false }

            # Named eager fixture - database setup
            given :database_setup, \:
                state.db = true

            # Named eager fixture - cache setup
            given :cache_setup, \:
                state.cache = true

            it "both named setups run":
                expect state.db
                expect state.cache

            it "state is fresh each example":
                expect state.db
                expect state.cache

        context "with named eager and lazy combined":
            let initialized = false

            # Named eager setup
            given :initialize_api, \:
                initialized = true

            # Named lazy fixture
            given_lazy :api_client, \:
                { initialized: initialized, endpoint: "api.example.com" }

            it "eager runs before lazy":
                expect api_client.initialized
                expect api_client.endpoint.len > 0

            it "lazy is memoized across assertions":
                expect api_client.endpoint == "api.example.com"
