describe "Context Sharing - Usage Examples":

    # ============================================================================
    # EXAMPLE 1: Basic Context Definition and Reference
    # ============================================================================

    # Define a reusable context with lazy fixtures
    context_def :admin_user:
        given_lazy :user, \:
            # Simulate creating an admin user
            "admin@example.com"

        given_lazy :permissions, \:
            ["read", "write", "delete"]

    # Reference the context in tests
    context :admin_user:
        it "has admin user email":
            expect user == "admin@example.com"

        it "has write permissions":
            expect permissions.includes?("write")

        it "has delete permissions":
            expect permissions.includes?("delete")


    # ============================================================================
    # EXAMPLE 2: BDD - Given Setup vs When Actions
    # ============================================================================

    context_def :with_database:
        # Given: database is setup (eager - runs before each test)
        given:
            # When: user code runs, database should be ready
            # Simulate: db.connect(), db.migrate(), db.clear()
            pass

        # Given: we have a database connection (lazy fixture)
        given_lazy :db_connection, \:
            "database://localhost:5432"

    context_def :with_logging:
        # Given: empty logs (lazy fixture)
        given_lazy :logs, \:
            []

    # Compose multiple contexts: database + logging available
    context_compose :with_database, :with_logging:
        # Then: verify database connection
        it "has database connection":
            expect db_connection.includes?("localhost")

        # Then: verify logging is ready
        it "has empty logs initially":
            expect logs.len == 0


    # ============================================================================
    # EXAMPLE 3: Stack Example (BDD - Given, When, Then)
    # ============================================================================

    context_def :empty_stack:
        # Given: an empty stack
        given_lazy :stack, \:
            []

    context_def :stack_with_items:
        # Given: a stack with items
        given_lazy :stack, \:
            [1, 2, 3]

    describe "Stack Operations":
        # Scenario 1: Empty stack
        context :empty_stack:
            # Then: verify it's empty
            it "is empty":
                expect stack.len == 0

            # When: push item, Then: verify length and value
            it "can push items":
                stack.push(42)
                expect stack.len == 1
                expect stack[0] == 42

        # Scenario 2: Stack with items
        context :stack_with_items:
            # Then: verify contents
            it "contains items":
                expect stack.len == 3
                expect stack[0] == 1

            # Then: verify access
            it "can access items":
                let item = stack[stack.len - 1]
                expect item == 3


    # ============================================================================
    # EXAMPLE 4: BDD Pattern - Inline Given (When Setup)
    # ============================================================================

    describe "List Operations":
        context "when adding items":
            # When: prepare list environment (eager setup)
            given:
                # Setup code before each test
                # In real code: validate_list_environment(), setup_allocator()
                pass

            # Then: verify we can add items
            it "can add to list":
                let items = []
                items.push(1)
                expect items.len == 1

            # Then: verify order is preserved
            it "preserves order":
                let items = [1, 2, 3]
                expect items[0] == 1
                expect items[2] == 3


    # ============================================================================
    # EXAMPLE 5: Context with Nested Description (Combining Old and New)
    # ============================================================================

    context_def :authenticated_session:
        given_lazy :auth_token, \:
            "token_abc123"

        given_lazy :user_id, \:
            42

    describe "User Session Management":
        context :authenticated_session:
            it "has valid auth token":
                expect auth_token.len > 0

            it "has valid user id":
                expect user_id == 42

            # Can still use nested string-based context
            context "when accessing protected resource":
                it "requires auth token":
                    expect auth_token == "token_abc123"

                it "has user context":
                    expect user_id == 42


    # ============================================================================
    # EXAMPLE 6: BDD Given-When-Then Style
    # ============================================================================

    context_def :calculator_with_value:
        # Given: calculator state
        given_lazy :value, \:
            0

    describe "Calculator (Given-When-Then)":
        # Given: we have a calculator starting at zero
        context :calculator_with_value:
            # Test 1: Initial state
            it "starts with value zero":
                expect value == 0

        # Scenario: Adding to calculator
        context :calculator_with_value:
            # When: we add 5
            given:
                # Simulate: value = value + 5
                # In a real test: perform the addition operation
                pass

            # Then: verify the result
            it "can add and increment value":
                # After adding 5 to 0, we should have 5
                expect true

        # Scenario: Multiplying calculator
        context :calculator_with_value:
            # When: we multiply by 2
            given:
                # Simulate: value = value * 2
                # In a real test: perform the multiplication operation
                pass

            # Then: verify the result
            it "multiplying zero gives zero":
                # 0 * 2 = 0
                expect value == 0


    # ============================================================================
    # EXAMPLE 7: Multi-Context Composition with Setup
    # ============================================================================

    context_def :base_user:
        given_lazy :user, \:
            "user@example.com"

    context_def :with_api_key:
        given_lazy :api_key, \:
            "key_xyz789"

    context_def :with_rate_limit:
        given_lazy :rate_limit, \:
            100

    describe "API Client":
        # Compose all three contexts
        context_compose :base_user, :with_api_key, :with_rate_limit:
            it "has user":
                expect user == "user@example.com"

            it "has api key":
                expect api_key == "key_xyz789"

            it "has rate limit":
                expect rate_limit == 100

            it "all fixtures available":
                expect user.len > 0
                expect api_key.len > 0
                expect rate_limit > 0


    # ============================================================================
    # EXAMPLE 8: Fixture Dependency (Using Other Fixtures)
    # ============================================================================

    context_def :math_fixtures:
        given_lazy :x, \:
            10

        given_lazy :y, \:
            x + 5  # y depends on x

        given_lazy :sum, \:
            x + y  # sum depends on both x and y

    describe "Dependent Fixtures":
        context :math_fixtures:
            it "x is 10":
                expect x == 10

            it "y depends on x":
                expect y == 15

            it "sum depends on both":
                expect sum == 25


    # ============================================================================
    # EXAMPLE 9: String-Based Context (Original Syntax - Still Works)
    # ============================================================================

    describe "Original Context Syntax (Backward Compatible)":
        context "with string description":
            let value = 42

            it "still works":
                expect value == 42

            context "nested string context":
                it "supports nesting":
                    expect true


    # ============================================================================
    # EXAMPLE 10: Mixed Usage Pattern
    # ============================================================================

    context_def :test_data:
        given_lazy :numbers, \:
            [1, 2, 3, 4, 5]

    describe "Mixed Patterns":
        context :test_data:
            # Use reusable context
            it "has data from context":
                expect numbers.len == 5

            context "with additional setup":
                # Add inline context with string description
                given:
                    # Extra setup for this context
                    pass

                it "combines reusable and inline":
                    expect numbers.includes?(3)


    # ============================================================================
    # EXAMPLE 11: Inline given_lazy (Lazy Fixtures in Regular Context)
    # ============================================================================

    describe "Inline Lazy Fixtures":
        context "with lazy user":
            # Define lazy fixture inline (memoized per example)
            given_lazy :user, \:
                { id: 1, name: "Alice", role: "admin" }

            it "has user from lazy fixture":
                expect user.name == "Alice"

            it "lazy fixture is same instance":
                # Same user object within this example
                expect user.id == 1


    # ============================================================================
    # EXAMPLE 12: Combining Inline given/given_lazy
    # ============================================================================

    describe "Mixed Setup Styles":
        context "with setup and fixture":
            # Unnamed eager setup - runs before each example
            given:
                pass  # Placeholder: validate_environment()

            # Lazy fixture - memoized per example
            given_lazy :counter, \:
                0

            it "has fresh counter":
                expect counter == 0

            it "counter is memoized in example":
                expect counter == 0


    # ============================================================================
    # EXAMPLE 13: BDD with Named Eager Fixtures (given :name)
    # ============================================================================

    describe "Named Eager Setup":
        context "with named setup blocks":
            let state = { db: false, cache: false }

            # When: setup database (named eager)
            given :database_setup, \:
                state.db = true

            # When: setup cache (named eager)
            given :cache_setup, \:
                state.cache = true

            # Then: verify both setups ran
            it "both named setups run":
                expect state.db
                expect state.cache

            # Then: verify fresh state each example
            it "state is fresh each example":
                expect state.db
                expect state.cache

        context "with named eager and lazy combined":
            let initialized = false

            # When: initialize API (eager setup)
            given :initialize_api, \:
                initialized = true

            # Given: we have an API client (lazy fixture)
            given_lazy :api_client, \:
                { initialized: initialized, endpoint: "api.example.com" }

            # Then: verify eager runs before lazy
            it "eager runs before lazy":
                expect api_client.initialized
                expect api_client.endpoint.len > 0

            # Then: verify lazy is memoized
            it "lazy is memoized across assertions":
                expect api_client.endpoint == "api.example.com"


    # ============================================================================
    # EXAMPLE 14: Given Block with Context References and Sequential Variables
    # ============================================================================

    context_def :user_fixtures:
        # Given: test users
        given_lazy :admin_user, \:
            { email: "admin@example.com", role: "admin" }

        given_lazy :regular_user, \:
            { email: "user@example.com", role: "user" }

    context_def :database_setup:
        # When: setup database
        given:
            # Simulate: db.connect(), db.migrate()
            pass

    describe "Sequential given block with context refs and variables":
        context "composing contexts and defining variables":
            # When: complex setup with sequential steps
            given:
                # Step 1: Reference database_setup context
                given :database_setup

                # Step 2: Reference user_fixtures context
                given :user_fixtures

                # Step 3: Define derived variables from fixtures
                let api_key = "key_" + admin_user.email
                let cache_key = "user_" + regular_user.role

            # Then: verify everything is available
            it "has admin user from context_def":
                expect admin_user.role == "admin"

            it "has regular user from context_def":
                expect regular_user.role == "user"

            it "has derived api_key from fixture":
                expect api_key.includes?("admin@example.com")

            it "has derived cache_key from fixture":
                expect cache_key == "user_user"
