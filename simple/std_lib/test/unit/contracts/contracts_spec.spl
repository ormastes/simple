# Contract System Tests
# Tests for Design by Contract features: CTR-001 through CTR-062

describe "Contract System":
    describe "CTR-001: Preconditions (in:)":
        it "passes when precondition is true":
            fn div_safe(a: i64, b: i64) -> i64:
                in:
                    b != 0
                return a / b

            expect div_safe(10, 2) == 5

        it "raises ContractViolation when precondition is false":
            fn requires_positive(x: i64) -> i64:
                in:
                    x > 0
                return x * 2

            # This should raise ContractViolation.Pre
            expect_raises ContractViolation:
                requires_positive(-1)

    describe "CTR-002: Postconditions (out(ret):)":
        it "verifies return value meets postcondition":
            fn abs_val(x: i64) -> i64:
                if x < 0:
                    return -x
                return x
                out(ret):
                    ret >= 0

            expect abs_val(-5) == 5
            expect abs_val(3) == 3
            expect abs_val(0) == 0

        it "binds ret to return value":
            fn double(x: i64) -> i64:
                return x * 2
                out(ret):
                    ret == x * 2
                    ret >= x  # For positive x

            expect double(5) == 10

    describe "CTR-003: Error Postconditions (out_err(err):)":
        it "verifies error value meets error postcondition":
            struct DivError:
                msg: Str

            fn safe_div(a: i64, b: i64) -> (i64 | DivError):
                if b == 0:
                    return DivError(msg: "division by zero")
                return a / b
                out(ret):
                    ret * b == a
                out_err(err):
                    err.msg != ""

            expect safe_div(10, 2) == 5
            let result = safe_div(10, 0)
            expect result is DivError

    describe "CTR-004: Routine Invariants (invariant:)":
        it "checks invariant at entry and exit":
            fn bounded_op(x: i64, max: i64) -> i64:
                invariant:
                    max > 0

                if x > max:
                    return max
                return x

            expect bounded_op(5, 100) == 5
            expect bounded_op(150, 100) == 100

    describe "CTR-005: old(expr) Snapshots":
        it "captures value at function entry":
            fn increment(x: i64) -> i64:
                let result = x + 1
                return result
                out(ret):
                    ret == old(x) + 1

            expect increment(5) == 6
            expect increment(0) == 1

        it "preserves old value across mutations":
            fn double_and_verify(x: i64) -> i64:
                let doubled = x * 2
                return doubled
                out(ret):
                    ret == old(x) * 2
                    ret > old(x)  # For positive x

            expect double_and_verify(5) == 10

    describe "CTR-010: Class Invariants":
        it "checks invariant after constructor":
            class Counter:
                value: i64

                invariant:
                    value >= 0

                fn new(initial: i64) -> Counter:
                    in:
                        initial >= 0
                    return Counter(value: initial)

            let c = Counter.new(0)
            expect c.value == 0

        it "checks invariant after public methods":
            class Account:
                balance: i64

                invariant:
                    balance >= 0

                fn new(initial: i64) -> Account:
                    in:
                        initial >= 0
                    return Account(balance: initial)

                fn deposit(amount: i64) -> i64:
                    in:
                        amount > 0
                    balance += amount
                    return balance

                fn withdraw(amount: i64) -> (i64 | Str):
                    in:
                        amount > 0
                    if amount > balance:
                        return "insufficient funds"
                    balance -= amount
                    return balance

            let acc = Account.new(100)
            expect acc.deposit(50) == 150
            expect acc.withdraw(30) == 120

        it "raises ContractViolation when invariant violated":
            class BrokenCounter:
                value: i64

                invariant:
                    value >= 0

                fn new() -> BrokenCounter:
                    return BrokenCounter(value: 0)

                fn decrement() -> i64:
                    value -= 1
                    return value

            let bc = BrokenCounter.new()
            # This should violate the invariant
            expect_raises ContractViolation:
                bc.decrement()

    describe "CTR-020: Union Return Type Detection":
        it "distinguishes success from error exits":
            struct NotFound:
                key: Str

            fn find_value(key: Str, map: Dict[Str, i64]) -> (i64 | NotFound):
                if key not in map:
                    return NotFound(key: key)
                return map[key]
                out(ret):
                    key in map
                out_err(err):
                    err.key == key
                    key not in map

            let data = {"a": 1, "b": 2}
            expect find_value("a", data) == 1
            let err = find_value("c", data)
            expect err is NotFound
            expect err.key == "c"

    describe "Combined Contract Features":
        it "supports all contract types together":
            class Stack:
                items: List[i64]
                max_size: i64

                invariant:
                    len(items) <= max_size
                    max_size > 0

                fn new(max: i64) -> Stack:
                    in:
                        max > 0
                    return Stack(items: [], max_size: max)

                fn push(value: i64) -> (i64 | Str):
                    in:
                        value != 0  # Non-zero values only

                    invariant:
                        max_size > 0

                    if len(items) >= max_size:
                        return "stack full"

                    items.append(value)
                    return len(items)

                    out(ret):
                        ret == old(len(items)) + 1
                        ret <= max_size
                    out_err(err):
                        len(items) == max_size

                fn pop() -> (i64 | Str):
                    if len(items) == 0:
                        return "stack empty"

                    let value = items.pop()
                    return value

                    out(ret):
                        len(items) == old(len(items)) - 1
                    out_err(err):
                        old(len(items)) == 0

            let stack = Stack.new(3)
            expect stack.push(1) == 1
            expect stack.push(2) == 2
            expect stack.push(3) == 3
            expect stack.push(4) == "stack full"
            expect stack.pop() == 3
            expect stack.pop() == 2
