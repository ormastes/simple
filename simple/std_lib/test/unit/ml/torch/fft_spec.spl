# FFT Operations Test Suite
# Tests for Simple Math #1950-#1959 FFT features
# Tests: fft, ifft, rfft, irfft, fftn, fftshift, ifftshift

import spec
import ml.torch as torch

describe "FFT: 1D forward and inverse":
    it "should perform FFT-IFFT roundtrip":
        # Create simple signal
        x = torch.from_data([[1.0, 2.0, 3.0, 4.0]])

        # Forward FFT
        X = torch.fft.fft(x, n=-1, dim=1, norm=0)  # norm=0 means no normalization

        # Inverse FFT
        x_reconstructed = torch.fft.ifft(X, n=-1, dim=1, norm=0)

        # Should recover original signal (real part, imaginary part should be ~0)
        spec.expect(x_reconstructed.real().allclose(x, rtol=1e-5, atol=1e-5)).to_be(True)

    it "should compute FFT of constant signal":
        # Constant signal: all ones
        x = torch.ones([1, 8])

        X = torch.fft.fft(x, n=-1, dim=1, norm=0)

        # FFT of constant = [N, 0, 0, ..., 0]
        # DC component (first element) should be 8.0
        dc = X.select(1, 0).abs().item()
        spec.expect(dc).to_be_close(8.0, tolerance=1e-5)

        # Other components should be ~0
        ac = X.select(1, 1).abs().item()
        spec.expect(ac).to_be_close(0.0, tolerance=1e-5)

    it "should handle different normalization modes":
        x = torch.from_data([[1.0, 0.0, 0.0, 0.0]])

        # Forward normalization (norm=1)
        X_forward = torch.fft.fft(x, n=-1, dim=1, norm=1)

        # Ortho normalization (norm=3)
        X_ortho = torch.fft.fft(x, n=-1, dim=1, norm=3)

        # Forward and ortho should give different results
        spec.expect(X_forward.allclose(X_ortho)).to_be(False)

describe "FFT: real FFT for real-valued signals":
    it "should compute RFFT for real signal":
        # Real signal
        x = torch.from_data([[1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0, 0.0]])

        # Real FFT (only positive frequencies)
        X = torch.fft.rfft(x, n=-1, dim=1, norm=0)

        # RFFT output size = floor(n/2) + 1 = 5 for n=8
        spec.expect(X.shape()[1]).to_equal(5)

    it "should perform RFFT-IRFFT roundtrip":
        # Real signal
        x = torch.from_data([[1.0, 2.0, 3.0, 4.0]])

        # Forward RFFT
        X = torch.fft.rfft(x, n=-1, dim=1, norm=0)

        # Inverse RFFT
        x_reconstructed = torch.fft.irfft(X, n=4, dim=1, norm=0)

        # Should recover original signal
        spec.expect(x_reconstructed.allclose(x, rtol=1e-5, atol=1e-5)).to_be(True)

    it "should handle even and odd length signals":
        # Even length
        x_even = torch.from_data([[1.0, 2.0, 3.0, 4.0]])
        X_even = torch.fft.rfft(x_even, n=-1, dim=1, norm=0)
        spec.expect(X_even.shape()[1]).to_equal(3)  # floor(4/2) + 1

        # Odd length
        x_odd = torch.from_data([[1.0, 2.0, 3.0, 4.0, 5.0]])
        X_odd = torch.fft.rfft(x_odd, n=-1, dim=1, norm=0)
        spec.expect(X_odd.shape()[1]).to_equal(3)  # floor(5/2) + 1

describe "FFT: N-dimensional FFT":
    it "should compute 2D FFT":
        # 2D signal (2x4)
        x = torch.from_data([[1.0, 2.0, 3.0, 4.0],
                          [5.0, 6.0, 7.0, 8.0]])

        # 2D FFT on both dimensions
        dims = [0, 1]  # Transform both dimensions
        X = torch.fft.fftn(x, dims, 2, norm=0)

        # Output shape should match input
        spec.expect(X.shape()).to_equal([2, 4])

    it "should perform 2D FFT-IFFT roundtrip":
        # 2D signal
        x = torch.ones([3, 4])

        dims = [0, 1]
        X = torch.fft.fftn(x, dims, 2, norm=0)

        # Note: IFFT not available in fftn, use regular fft with inverse
        # For this test, just verify shape
        spec.expect(X.shape()).to_equal([3, 4])

    it "should compute FFT along specific dimensions":
        # 3D tensor
        x = torch.ones([2, 3, 4])

        # FFT only along last dimension
        dims = [2]
        X = torch.fft.fftn(x, dims, 1, norm=0)

        spec.expect(X.shape()).to_equal([2, 3, 4])

describe "FFT: frequency shifting":
    it "should shift zero-frequency to center":
        # Create spectrum with DC at position 0
        X = torch.from_data([[8.0, 1.0, 2.0, 1.0]])

        # Shift zero-frequency to center
        X_shifted = torch.fft.fftshift(X, dim=1)

        # For n=4, shift by n/2=2 positions
        # Original: [8, 1, 2, 1] → Shifted: [2, 1, 8, 1]
        spec.expect(X_shifted.select(1, 2).item()).to_be_close(8.0, tolerance=1e-5)

    it "should perform fftshift-ifftshift roundtrip":
        X = torch.from_data([[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]])

        # Shift and unshift
        X_shifted = torch.fft.fftshift(X, dim=1)
        X_original = torch.fft.ifftshift(X_shifted, dim=1)

        # Should recover original
        spec.expect(X_original.allclose(X)).to_be(True)

    it "should shift all dimensions when dim=-1":
        # 2D tensor
        X = torch.from_data([[1.0, 2.0, 3.0, 4.0],
                          [5.0, 6.0, 7.0, 8.0]])

        # Shift all dimensions
        X_shifted = torch.fft.fftshift(X, dim=-1)

        # Should still have same shape
        spec.expect(X_shifted.shape()).to_equal([2, 4])

    it "should work with odd-sized arrays":
        X = torch.from_data([[1.0, 2.0, 3.0, 4.0, 5.0]])

        X_shifted = torch.fft.fftshift(X, dim=1)

        # For odd n=5, center is at index (n-1)/2=2
        # Shift pattern: [1,2,3,4,5] → [4,5,1,2,3]
        spec.expect(X_shifted.select(1, 2).item()).to_be_close(1.0, tolerance=1e-5)

describe "FFT: integration tests":
    it "should analyze frequency content of sinusoid":
        # Create simple sine wave (frequency = 1 cycle over 8 samples)
        import math
        t = torch.arange(0.0, 8.0, 1.0)
        freq = 1.0
        x = torch.sin(2.0 * math.pi * freq * t / 8.0)

        # FFT
        X = torch.fft.fft(x.unsqueeze(0), n=-1, dim=1, norm=0)

        # Magnitude spectrum
        magnitude = X.abs()

        # Peak should be at frequency bin 1 (and 7 for negative frequency)
        peak1 = magnitude.select(1, 1).item()
        peak7 = magnitude.select(1, 7).item()

        # Both peaks should be significant and equal
        spec.expect(peak1).to_be_greater_than(3.0)
        spec.expect(peak7).to_be_greater_than(3.0)
        spec.expect(peak1).to_be_close(peak7, tolerance=1e-3)

    it "should preserve Parseval's theorem (energy conservation)":
        # Random signal
        x = torch.from_data([[1.0, 2.0, 1.5, 3.0]])

        # Energy in time domain
        energy_time = (x * x).sum().item()

        # FFT
        X = torch.fft.fft(x, n=-1, dim=1, norm=0)

        # Energy in frequency domain (Parseval's theorem)
        # E_freq = sum(|X|^2) / N
        energy_freq = (X.abs() ** 2).sum().item() / 4.0

        # Energies should match
        spec.expect(energy_freq).to_be_close(energy_time, tolerance=1e-3)

    it "should combine RFFT with fftshift for spectrum analysis":
        # Real signal
        x = torch.from_data([[1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0]])

        # Real FFT
        X = torch.fft.rfft(x, n=-1, dim=1, norm=0)

        # Shift (only works on full spectrum, but we can verify shape)
        spec.expect(X.shape()[1]).to_equal(5)  # floor(8/2) + 1

        # Verify DC component
        dc = X.select(1, 0).abs().item()
        spec.expect(dc).to_be_close(0.0, tolerance=1e-5)  # Balanced signal
