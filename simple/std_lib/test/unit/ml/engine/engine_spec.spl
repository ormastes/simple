# Training Engine Unit Tests

import ml.engine.{Engine, Events, State, Loss}


# ============================================================================
# Test: Engine Execution
# ============================================================================

print("=" * 70)
print("TRAINING ENGINE UNIT TESTS")
print("=" * 70)

var passed = 0
var failed = 0


# Test 1: Create engine
print("\n<Test 1> Create engine")
var counter = {"count": 0}

fn test_process(engine: Engine, batch: any) -> {str: any}:
    counter["count"] += 1
    return {"value": batch}

val engine = Engine(test_process)

if engine.state.epoch == 0:
    print("  ✓ PASS: Engine state initialized")
    passed += 1
else:
    print("  ✗ FAIL: Engine state not initialized")
    failed += 1


# Test 2: Event handlers
print("\n<Test 2> Event handlers")
var events_fired = []

@engine.on(Events.STARTED)
fn on_start(e: Engine):
    events_fired.append("started")

@engine.on(Events.ITERATION_COMPLETED)
fn on_iter(e: Engine):
    events_fired.append("iter")

@engine.on(Events.EPOCH_COMPLETED)
fn on_epoch(e: Engine):
    events_fired.append("epoch")

@engine.on(Events.COMPLETED)
fn on_complete(e: Engine):
    events_fired.append("completed")

print("  ✓ PASS: Event handlers attached")
passed += 1


# Test 3: Run engine
print("\n<Test 3> Run engine")
counter["count"] = 0
val test_data = [1, 2, 3]

engine.run(test_data, max_epochs=2)

if counter["count"] == 6:  # 3 batches × 2 epochs
    print(f"  ✓ PASS: Process function called correct number of times ({counter['count']})")
    passed += 1
else:
    print(f"  ✗ FAIL: Process function called {counter['count']} times, expected 6")
    failed += 1


# Test 4: Check events
print("\n<Test 4> Check events")
val expected_events = ["started", "iter", "iter", "iter", "epoch", "iter", "iter", "iter", "epoch", "completed"]

if events_fired.len() == expected_events.len():
    print("  ✓ PASS: Correct number of events fired")
    passed += 1
else:
    print(f"  ✗ FAIL: {events_fired.len()} events fired, expected {expected_events.len()}")
    failed += 1


# Test 5: Engine state
print("\n<Test 5> Engine state")

if engine.state.epoch == 2:
    print("  ✓ PASS: Final epoch state correct")
    passed += 1
else:
    print(f"  ✗ FAIL: Final epoch is {engine.state.epoch}, expected 2")
    failed += 1

if engine.state.iteration == 6:
    print("  ✓ PASS: Final iteration state correct")
    passed += 1
else:
    print(f"  ✗ FAIL: Final iteration is {engine.state.iteration}, expected 6")
    failed += 1


# Test 6: Metrics
print("\n<Test 6> Metrics")
fn loss_process(engine: Engine, batch: any) -> {str: any}:
    return {"loss": 1.0 - (engine.state.iteration * 0.1)}

val loss_engine = Engine(loss_process)
val loss_metric = Loss()
loss_engine.add_metric(loss_metric, "loss")

loss_engine.run([1, 2, 3], max_epochs=1)

if "loss" in loss_engine.state.metrics:
    print("  ✓ PASS: Metric computed")
    passed += 1
else:
    print("  ✗ FAIL: Metric not computed")
    failed += 1


# Summary
print("\n" + "=" * 70)
print("SUMMARY")
print("=" * 70)
print(f"Passed: {passed}")
print(f"Failed: {failed}")
print(f"Total:  {passed + failed}")

if failed == 0:
    print("\n✓ All tests passed!")
else:
    print(f"\n✗ {failed} test(s) failed")

print("=" * 70)
