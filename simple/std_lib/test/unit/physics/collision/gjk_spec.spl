# Physics GJK Collision Detection Tests
#
# Tests for GJK (Gilbert-Johnson-Keerthi) algorithm for convex collision detection.

import spec
import physics.core as core
import physics.collision as collision


describe "GJK Collision Detection":
    describe "Convex hull support function":
        it "should compute support point for sphere":
            let sphere_pos = core.Vector3(0.0, 0.0, 0.0)
            let sphere_radius = 1.0
            let direction = core.Vector3(1.0, 0.0, 0.0)

            let support = collision.gjk_sphere_support(sphere_pos, sphere_radius, direction)

            # Support point should be at (1, 0, 0)
            spec.expect(support.x).to_be_close_to(1.0, 0.001)
            spec.expect(support.y).to_be_close_to(0.0, 0.001)
            spec.expect(support.z).to_be_close_to(0.0, 0.001)

        it "should compute support point for box":
            let box_center = core.Vector3(0.0, 0.0, 0.0)
            let box_halfsize = core.Vector3(1.0, 1.0, 1.0)
            let direction = core.Vector3(1.0, 1.0, 0.0).normalized()

            let support = collision.gjk_box_support(box_center, box_halfsize, direction)

            # Support point should be at corner (1, 1, ?)
            spec.expect(support.x).to_be_close_to(1.0, 0.001)
            spec.expect(support.y).to_be_close_to(1.0, 0.001)

        it "should compute support point in all directions":
            let center = core.Vector3(0.0, 0.0, 0.0)
            let halfsize = core.Vector3(2.0, 2.0, 2.0)

            # Test all 8 corners
            let directions = [
                core.Vector3(1.0, 1.0, 1.0),
                core.Vector3(-1.0, 1.0, 1.0),
                core.Vector3(1.0, -1.0, 1.0),
                core.Vector3(1.0, 1.0, -1.0),
                core.Vector3(-1.0, -1.0, 1.0),
                core.Vector3(-1.0, 1.0, -1.0),
                core.Vector3(1.0, -1.0, -1.0),
                core.Vector3(-1.0, -1.0, -1.0)
            ]

            for dir in directions:
                let support = collision.gjk_box_support(center, halfsize, dir.normalized())
                # Support point should be on the box surface
                let dist = support.distance_to(center)
                spec.expect(dist).to_be_less_than_or_equal(halfsize.magnitude() + 0.01)

    describe "Simplex operations":
        it "should create initial simplex":
            let simplex = collision.GJKSimplex()
            spec.expect(simplex.size()).to_be(0)

        it "should add point to simplex":
            let simplex = collision.GJKSimplex()
            let point = core.Vector3(1.0, 0.0, 0.0)

            simplex.add(point)

            spec.expect(simplex.size()).to_be(1)

        it "should handle line simplex":
            let simplex = collision.GJKSimplex()
            simplex.add(core.Vector3(0.0, 0.0, 0.0))
            simplex.add(core.Vector3(1.0, 0.0, 0.0))

            spec.expect(simplex.size()).to_be(2)

        it "should handle triangle simplex":
            let simplex = collision.GJKSimplex()
            simplex.add(core.Vector3(0.0, 0.0, 0.0))
            simplex.add(core.Vector3(1.0, 0.0, 0.0))
            simplex.add(core.Vector3(0.0, 1.0, 0.0))

            spec.expect(simplex.size()).to_be(3)

        it "should handle tetrahedron simplex":
            let simplex = collision.GJKSimplex()
            simplex.add(core.Vector3(0.0, 0.0, 0.0))
            simplex.add(core.Vector3(1.0, 0.0, 0.0))
            simplex.add(core.Vector3(0.0, 1.0, 0.0))
            simplex.add(core.Vector3(0.0, 0.0, 1.0))

            spec.expect(simplex.size()).to_be(4)

    describe "GJK algorithm":
        it "should detect sphere-sphere collision":
            let sphere1_pos = core.Vector3(0.0, 0.0, 0.0)
            let sphere1_radius = 1.0
            let sphere2_pos = core.Vector3(1.5, 0.0, 0.0)
            let sphere2_radius = 1.0

            let colliding = collision.gjk_test(
                collision.SphereShape(sphere1_pos, sphere1_radius),
                collision.SphereShape(sphere2_pos, sphere2_radius)
            )

            spec.expect(colliding).to_be(true)

        it "should detect sphere-sphere separation":
            let sphere1_pos = core.Vector3(0.0, 0.0, 0.0)
            let sphere1_radius = 1.0
            let sphere2_pos = core.Vector3(5.0, 0.0, 0.0)
            let sphere2_radius = 1.0

            let colliding = collision.gjk_test(
                collision.SphereShape(sphere1_pos, sphere1_radius),
                collision.SphereShape(sphere2_pos, sphere2_radius)
            )

            spec.expect(colliding).to_be(false)

        it "should detect box-box collision":
            let box1 = collision.BoxShape(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0)
            )
            let box2 = collision.BoxShape(
                core.Vector3(1.5, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0)
            )

            let colliding = collision.gjk_test(box1, box2)

            spec.expect(colliding).to_be(true)

        it "should detect box-box separation":
            let box1 = collision.BoxShape(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0)
            )
            let box2 = collision.BoxShape(
                core.Vector3(5.0, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0)
            )

            let colliding = collision.gjk_test(box1, box2)

            spec.expect(colliding).to_be(false)

        it "should detect sphere-box collision":
            let sphere = collision.SphereShape(
                core.Vector3(0.0, 0.0, 0.0),
                1.0
            )
            let box = collision.BoxShape(
                core.Vector3(1.5, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0)
            )

            let colliding = collision.gjk_test(sphere, box)

            spec.expect(colliding).to_be(true)

        it "should handle edge cases":
            # Exact touching (edge case)
            let sphere1 = collision.SphereShape(
                core.Vector3(0.0, 0.0, 0.0),
                1.0
            )
            let sphere2 = collision.SphereShape(
                core.Vector3(2.0, 0.0, 0.0),
                1.0
            )

            # May or may not collide depending on tolerance
            let colliding = collision.gjk_test(sphere1, sphere2)
            # Just verify it doesn't crash
            spec.expect(colliding).to_be_one_of([true, false])

    describe "GJK with different orientations":
        it "should detect rotated box collision":
            let box1 = collision.BoxShape(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0),
                rotation=core.Quaternion::from_euler(0.0, 0.0, 0.0)
            )
            let box2 = collision.BoxShape(
                core.Vector3(1.0, 1.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0),
                rotation=core.Quaternion::from_euler(0.0, 0.0, 45.0)
            )

            let colliding = collision.gjk_test(box1, box2)

            spec.expect(colliding).to_be(true)

    describe "GJK performance":
        it "should converge quickly for simple cases":
            let sphere1 = collision.SphereShape(
                core.Vector3(0.0, 0.0, 0.0),
                1.0
            )
            let sphere2 = collision.SphereShape(
                core.Vector3(0.5, 0.0, 0.0),
                1.0
            )

            let (colliding, iterations) = collision.gjk_test_with_stats(sphere1, sphere2)

            # Should converge in < 10 iterations for simple overlap
            spec.expect(iterations).to_be_less_than(10)

        it "should handle complex geometries":
            # Multiple boxes in various configurations
            let boxes = []
            for i in range(5):
                let box = collision.BoxShape(
                    core.Vector3(i as f64 * 1.5, 0.0, 0.0),
                    core.Vector3(1.0, 1.0, 1.0)
                )
                boxes.append(box)

            # Test all pairs
            let mut collision_count = 0
            for i in range(len(boxes)):
                for j in range(i + 1, len(boxes)):
                    if collision.gjk_test(boxes[i], boxes[j]):
                        collision_count = collision_count + 1

            # Adjacent boxes should collide
            spec.expect(collision_count).to_be_greater_than(0)
