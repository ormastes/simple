# Physics AABB Collision Tests

import physics.core as core
import physics.collision as collision

describe "AABB":
    describe "creation":
        it "creates AABB from min and max":
            let min = core.Vector3(0.0, 0.0, 0.0)
            let max = core.Vector3(1.0, 1.0, 1.0)
            let aabb = collision.AABB(min, max)
            expect aabb.min.x == 0.0
            expect aabb.max.x == 1.0

        it "creates AABB from center and size":
            let center = core.Vector3(0.0, 0.0, 0.0)
            let size = core.Vector3(2.0, 2.0, 2.0)
            let aabb = collision.AABB::from_center_size(center, size)
            expect aabb.min.x == -1.0
            expect aabb.max.x == 1.0

    describe "intersection":
        it "detects overlapping AABBs":
            let aabb1 = collision.AABB::from_center_size(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(2.0, 2.0, 2.0)
            )
            let aabb2 = collision.AABB::from_center_size(
                core.Vector3(1.0, 0.0, 0.0),
                core.Vector3(2.0, 2.0, 2.0)
            )
            expect aabb1.intersects(aabb2) == true

        it "detects non-overlapping AABBs":
            let aabb1 = collision.AABB::from_center_size(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0)
            )
            let aabb2 = collision.AABB::from_center_size(
                core.Vector3(5.0, 0.0, 0.0),
                core.Vector3(1.0, 1.0, 1.0)
            )
            expect aabb1.intersects(aabb2) == false

    describe "point containment":
        it "detects point inside AABB":
            let aabb = collision.AABB::from_center_size(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(2.0, 2.0, 2.0)
            )
            let point = core.Vector3(0.5, 0.5, 0.5)
            expect aabb.contains_point(point) == true

        it "detects point outside AABB":
            let aabb = collision.AABB::from_center_size(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(2.0, 2.0, 2.0)
            )
            let point = core.Vector3(5.0, 5.0, 5.0)
            expect aabb.contains_point(point) == false

    describe "properties":
        it "computes center":
            let aabb = collision.AABB(
                core.Vector3(-1.0, -1.0, -1.0),
                core.Vector3(1.0, 1.0, 1.0)
            )
            let center = aabb.center()
            expect center.x == 0.0
            expect center.y == 0.0
            expect center.z == 0.0

        it "computes size":
            let aabb = collision.AABB(
                core.Vector3(-1.0, -1.0, -1.0),
                core.Vector3(1.0, 1.0, 1.0)
            )
            let size = aabb.size()
            expect size.x == 2.0
            expect size.y == 2.0
            expect size.z == 2.0

describe "Detector":
    describe "sphere collision":
        it "detects sphere-sphere collision":
            let pos1 = core.Vector3(0.0, 0.0, 0.0)
            let pos2 = core.Vector3(1.0, 0.0, 0.0)
            let colliding = collision.Detector::sphere_sphere(pos1, 1.0, pos2, 1.0)
            expect colliding == true

        it "detects sphere-sphere separation":
            let pos1 = core.Vector3(0.0, 0.0, 0.0)
            let pos2 = core.Vector3(10.0, 0.0, 0.0)
            let colliding = collision.Detector::sphere_sphere(pos1, 1.0, pos2, 1.0)
            expect colliding == false

    describe "AABB collision":
        it "detects AABB-AABB collision":
            let aabb1 = collision.AABB::from_center_size(
                core.Vector3(0.0, 0.0, 0.0),
                core.Vector3(2.0, 2.0, 2.0)
            )
            let aabb2 = collision.AABB::from_center_size(
                core.Vector3(1.0, 0.0, 0.0),
                core.Vector3(2.0, 2.0, 2.0)
            )
            expect collision.Detector::aabb_aabb(aabb1, aabb2) == true

    describe "sphere-AABB collision":
        it "detects sphere-AABB collision":
            let sphere_pos = core.Vector3(0.0, 0.0, 0.0)
            let aabb = collision.AABB::from_center_size(
                core.Vector3(1.0, 0.0, 0.0),
                core.Vector3(2.0, 2.0, 2.0)
            )
            expect collision.Detector::sphere_aabb(sphere_pos, 1.5, aabb) == true

describe "Material":
    describe "presets":
        it "creates rubber material":
            let rubber = collision.Material::rubber()
            expect rubber.friction >= 0.8
            expect rubber.restitution >= 0.7

        it "creates metal material":
            let metal = collision.Material::metal()
            expect metal.friction >= 0.2
            expect metal.friction <= 0.4

        it "creates ice material":
            let ice = collision.Material::ice()
            expect ice.friction <= 0.1
