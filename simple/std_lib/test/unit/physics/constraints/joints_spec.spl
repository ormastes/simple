# Physics Constraints and Joints Tests
#
# Tests for physics constraints including distance, hinge, slider, and fixed joints.

import spec
import physics.core as core
import physics.dynamics as dynamics
import physics.constraints as constraints


describe "Physics Constraints":
    describe "Distance Constraint":
        it "should create distance constraint":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(2.0, 0.0, 0.0))

            let constraint = constraints.DistanceConstraint(
                body1=body1,
                body2=body2,
                distance=2.0
            )

            spec.expect(constraint.distance).to_be_close_to(2.0, 0.001)

        it "should maintain fixed distance":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(2.0, 0.0, 0.0))

            let constraint = constraints.DistanceConstraint(
                body1=body1,
                body2=body2,
                distance=2.0
            )

            # Apply constraint (should keep bodies at distance 2.0)
            constraint.solve(dt=0.016)

            let actual_distance = body1.position.distance_to(body2.position)
            spec.expect(actual_distance).to_be_close_to(2.0, 0.1)

        it "should support rope-like constraint (max distance)":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.DistanceConstraint(
                body1=body1,
                body2=body2,
                max_distance=3.0,
                min_distance=0.0
            )

            # Bodies closer than max_distance should not be affected
            constraint.solve(dt=0.016)

            let actual_distance = body1.position.distance_to(body2.position)
            spec.expect(actual_distance).to_be_less_than_or_equal(3.0)

        it "should support spring-like constraint":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(3.0, 0.0, 0.0))

            let constraint = constraints.DistanceConstraint(
                body1=body1,
                body2=body2,
                distance=2.0,
                stiffness=0.5,  # Soft constraint
                damping=0.1
            )

            # Soft constraint allows some deviation
            constraint.solve(dt=0.016)

            let actual_distance = body1.position.distance_to(body2.position)
            # Should move towards target distance but not reach it immediately
            spec.expect(actual_distance).to_be_less_than(3.0)
            spec.expect(actual_distance).to_be_greater_than(2.0)

    describe "Hinge Constraint":
        it "should create hinge constraint":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.HingeConstraint(
                body1=body1,
                body2=body2,
                pivot=core.Vector3(0.5, 0.0, 0.0),
                axis=core.Vector3(0.0, 1.0, 0.0)  # Rotate around Y axis
            )

            spec.expect(constraint.pivot.x).to_be_close_to(0.5, 0.001)

        it "should allow rotation around axis":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.HingeConstraint(
                body1=body1,
                body2=body2,
                pivot=core.Vector3(0.5, 0.0, 0.0),
                axis=core.Vector3(0.0, 1.0, 0.0)
            )

            # Apply angular velocity
            body2.angular_velocity = core.Vector3(0.0, 1.0, 0.0)

            # Constraint should allow rotation
            constraint.solve(dt=0.016)

            # Body2 should have rotated
            spec.expect(body2.angular_velocity.magnitude()).to_be_greater_than(0.0)

        it "should restrict translation":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.HingeConstraint(
                body1=body1,
                body2=body2,
                pivot=core.Vector3(0.5, 0.0, 0.0),
                axis=core.Vector3(0.0, 1.0, 0.0)
            )

            # Try to move body2 away
            body2.position = core.Vector3(2.0, 0.0, 0.0)

            constraint.solve(dt=0.016)

            # Constraint should pull body2 back towards pivot
            let distance = body1.position.distance_to(body2.position)
            spec.expect(distance).to_be_less_than(2.0)

        it "should support angle limits":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.HingeConstraint(
                body1=body1,
                body2=body2,
                pivot=core.Vector3(0.5, 0.0, 0.0),
                axis=core.Vector3(0.0, 1.0, 0.0),
                min_angle=-45.0,  # -45 degrees
                max_angle=45.0    # +45 degrees
            )

            spec.expect(constraint.has_limits()).to_be(true)
            spec.expect(constraint.min_angle).to_be_close_to(-45.0, 0.1)
            spec.expect(constraint.max_angle).to_be_close_to(45.0, 0.1)

    describe "Slider Constraint":
        it "should create slider constraint":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.SliderConstraint(
                body1=body1,
                body2=body2,
                axis=core.Vector3(1.0, 0.0, 0.0)  # Slide along X axis
            )

            spec.expect(constraint.axis.x).to_be_close_to(1.0, 0.001)

        it "should allow translation along axis":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.SliderConstraint(
                body1=body1,
                body2=body2,
                axis=core.Vector3(1.0, 0.0, 0.0)
            )

            # Move body2 along X axis
            body2.position = core.Vector3(2.0, 0.0, 0.0)

            constraint.solve(dt=0.016)

            # Should maintain alignment with axis
            spec.expect(body2.position.y).to_be_close_to(0.0, 0.1)
            spec.expect(body2.position.z).to_be_close_to(0.0, 0.1)

        it "should restrict rotation":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.SliderConstraint(
                body1=body1,
                body2=body2,
                axis=core.Vector3(1.0, 0.0, 0.0)
            )

            # Try to rotate body2
            body2.angular_velocity = core.Vector3(0.0, 1.0, 0.0)

            constraint.solve(dt=0.016)

            # Rotation should be restricted
            spec.expect(body2.angular_velocity.magnitude()).to_be_close_to(0.0, 0.1)

        it "should support distance limits":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.SliderConstraint(
                body1=body1,
                body2=body2,
                axis=core.Vector3(1.0, 0.0, 0.0),
                min_distance=0.5,
                max_distance=2.0
            )

            spec.expect(constraint.has_limits()).to_be(true)

    describe "Fixed Constraint":
        it "should create fixed constraint":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.FixedConstraint(
                body1=body1,
                body2=body2
            )

            spec.expect(constraint).to_not_be(None)

        it "should lock relative position":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.FixedConstraint(
                body1=body1,
                body2=body2
            )

            # Record initial offset
            let initial_offset = body2.position - body1.position

            # Move body1
            body1.position = core.Vector3(5.0, 5.0, 5.0)

            constraint.solve(dt=0.016)

            # Body2 should move with body1
            let current_offset = body2.position - body1.position
            spec.expect(current_offset.x).to_be_close_to(initial_offset.x, 0.1)

        it "should lock relative rotation":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1.0, 0.0, 0.0))

            let constraint = constraints.FixedConstraint(
                body1=body1,
                body2=body2
            )

            # Rotate body1
            body1.rotation = core.Quaternion::from_euler(0.0, 90.0, 0.0)

            constraint.solve(dt=0.016)

            # Body2 should rotate with body1
            spec.expect(body2.rotation).to_not_be(core.Quaternion::identity())

    describe "Constraint solving":
        it "should solve single constraint":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(3.0, 0.0, 0.0))

            let constraint = constraints.DistanceConstraint(
                body1=body1,
                body2=body2,
                distance=2.0
            )

            # Solve with multiple iterations
            for i in range(10):
                constraint.solve(dt=0.016)

            let final_distance = body1.position.distance_to(body2.position)
            spec.expect(final_distance).to_be_close_to(2.0, 0.01)

        it "should solve multiple constraints":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(2.0, 0.0, 0.0))
            let body3 = dynamics.RigidBody(mass=1.0, position=core.Vector3(4.0, 0.0, 0.0))

            # Chain of distance constraints
            let constraint1 = constraints.DistanceConstraint(body1=body1, body2=body2, distance=1.5)
            let constraint2 = constraints.DistanceConstraint(body1=body2, body2=body3, distance=1.5)

            let solver = constraints.ConstraintSolver()
            solver.add_constraint(constraint1)
            solver.add_constraint(constraint2)

            # Solve all constraints
            solver.solve(dt=0.016, iterations=10)

            # Check distances
            let dist1 = body1.position.distance_to(body2.position)
            let dist2 = body2.position.distance_to(body3.position)

            spec.expect(dist1).to_be_close_to(1.5, 0.1)
            spec.expect(dist2).to_be_close_to(1.5, 0.1)

    describe "Constraint breaking":
        it "should break constraint under excessive force":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(2.0, 0.0, 0.0))

            let constraint = constraints.DistanceConstraint(
                body1=body1,
                body2=body2,
                distance=2.0,
                break_force=100.0  # Break if force exceeds 100N
            )

            # Apply large force to body2
            body2.apply_force(core.Vector3(200.0, 0.0, 0.0))

            # Solve constraint
            let broken = constraint.solve(dt=0.016)

            # Constraint should break
            spec.expect(broken).to_be(true)

        it "should maintain weak constraints":
            let body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0.0, 0.0, 0.0))
            let body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(2.0, 0.0, 0.0))

            let constraint = constraints.DistanceConstraint(
                body1=body1,
                body2=body2,
                distance=2.0,
                break_force=1000.0  # High break threshold
            )

            # Apply moderate force
            body2.apply_force(core.Vector3(50.0, 0.0, 0.0))

            let broken = constraint.solve(dt=0.016)

            # Should not break
            spec.expect(broken).to_be(false)

    describe "Complex constraint systems":
        it "should create ragdoll-like constraint chain":
            # Create chain of bodies
            let bodies = []
            for i in range(5):
                let body = dynamics.RigidBody(
                    mass=1.0,
                    position=core.Vector3(i as f64, 0.0, 0.0)
                )
                bodies.append(body)

            # Connect with hinge joints
            let constraints = []
            for i in range(4):
                let constraint = constraints.HingeConstraint(
                    body1=bodies[i],
                    body2=bodies[i + 1],
                    pivot=core.Vector3((i as f64) + 0.5, 0.0, 0.0),
                    axis=core.Vector3(0.0, 0.0, 1.0)
                )
                constraints.append(constraint)

            spec.expect(len(constraints)).to_be(4)

        it "should simulate rope with distance constraints":
            # Create rope segments
            let num_segments = 10
            let bodies = []

            for i in range(num_segments):
                let body = dynamics.RigidBody(
                    mass=0.1,
                    position=core.Vector3(i as f64 * 0.5, 0.0, 0.0)
                )
                bodies.append(body)

            # Connect with distance constraints
            let constraints = []
            for i in range(num_segments - 1):
                let constraint = constraints.DistanceConstraint(
                    body1=bodies[i],
                    body2=bodies[i + 1],
                    distance=0.5
                )
                constraints.append(constraint)

            # Fix first body (anchor point)
            bodies[0].mass = 0.0  # Infinite mass = static

            spec.expect(len(constraints)).to_be(num_segments - 1)
