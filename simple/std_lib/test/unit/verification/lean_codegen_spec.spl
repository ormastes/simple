# Lean Code Generation Tests
#
# Tests for the verification module Lean code generation.

import spec
import verification.lean.codegen as codegen
import verification.lean.types as types
import verification.lean.emitter as emit

describe "Lean Code Generation":
    context "Basic Types":
        it "generates int type":
            ty = codegen.make_int_type()
            expect(ty.to_lean()).to_equal("Int")

        it "generates bool type":
            ty = codegen.make_bool_type()
            expect(ty.to_lean()).to_equal("Bool")

        it "generates string type":
            ty = codegen.make_string_type()
            expect(ty.to_lean()).to_equal("String")

        it "generates list type":
            ty = codegen.make_list_type(codegen.make_int_type())
            expect(ty.to_lean()).to_equal("List (Int)")

        it "generates option type":
            ty = codegen.make_option_type(codegen.make_string_type())
            expect(ty.to_lean()).to_equal("Option (String)")

    context "Enum Generation":
        it "generates simple enum":
            enum = codegen.build_enum("Color", [
                ("Red", []),
                ("Green", []),
                ("Blue", [])
            ])

            gen = codegen.LeanCodegen.new("Test")
            gen = gen.add_inductive(enum)
            result = gen.emit()

            expect(result).to_include("inductive Color where")
            expect(result).to_include("| Red : Color")
            expect(result).to_include("| Green : Color")
            expect(result).to_include("| Blue : Color")

        it "generates enum with parameters":
            enum = codegen.build_enum("Option", [
                ("None", []),
                ("Some", [("value", codegen.make_int_type())])
            ])

            gen = codegen.LeanCodegen.new("Test")
            gen = gen.add_inductive(enum)
            result = gen.emit()

            expect(result).to_include("inductive Option where")
            expect(result).to_include("| None : Option")
            expect(result).to_include("| Some : Int â†’ Option")

    context "Structure Generation":
        it "generates simple structure":
            cls = codegen.build_class("Point", [
                ("x", codegen.make_int_type()),
                ("y", codegen.make_int_type())
            ])

            gen = codegen.LeanCodegen.new("Test")
            gen = gen.add_structure(cls)
            result = gen.emit()

            expect(result).to_include("structure Point where")
            expect(result).to_include("x : Int")
            expect(result).to_include("y : Int")

    context "Function Generation":
        it "generates simple function":
            func = codegen.build_function(
                "add",
                [
                    ("a", codegen.make_int_type()),
                    ("b", codegen.make_int_type())
                ],
                codegen.make_int_type(),
                "a + b"
            )

            gen = codegen.LeanCodegen.new("Test")
            gen = gen.add_function(func)
            result = gen.emit()

            expect(result).to_include("def add")
            expect(result).to_include("(a : Int)")
            expect(result).to_include("(b : Int)")
            expect(result).to_include(": Int :=")
            expect(result).to_include("a + b")

    context "Theorem Generation":
        it "generates theorem stub":
            thm = codegen.build_theorem(
                "example_theorem",
                [("n", "Int")],
                "n + 0 = n"
            )

            gen = codegen.LeanCodegen.new("Test")
            gen = gen.add_theorem(thm)
            result = gen.emit()

            expect(result).to_include("theorem example_theorem")
            expect(result).to_include("(n : Int)")
            expect(result).to_include("n + 0 = n := by")
            expect(result).to_include("sorry")

        it "generates theorem with proof":
            thm = codegen.build_theorem(
                "rfl_theorem",
                [("n", "Int")],
                "n = n",
                "rfl"
            )

            gen = codegen.LeanCodegen.new("Test")
            gen = gen.add_theorem(thm)
            result = gen.emit()

            expect(result).to_include("rfl")
            expect(result).not_to_include("sorry")

    context "Complete Module":
        it "generates complete module with all elements":
            gen = codegen.LeanCodegen.new("Complete")

            # Add enum
            color = codegen.build_enum("Color", [
                ("Red", []),
                ("Blue", [])
            ])
            gen = gen.add_inductive(color)

            # Add structure
            point = codegen.build_class("Point", [
                ("x", codegen.make_int_type()),
                ("color", codegen.make_simple_type("Color"))
            ])
            gen = gen.add_structure(point)

            # Add function
            make_red = codegen.build_function(
                "makeRed",
                [("x", codegen.make_int_type())],
                codegen.make_simple_type("Point"),
                "{ x := x, color := Color.Red }"
            )
            gen = gen.add_function(make_red)

            result = gen.emit()

            expect(result).to_include("inductive Color")
            expect(result).to_include("structure Point")
            expect(result).to_include("def makeRed")
            expect(result).to_include("Do not edit directly")
