# Unit tests for DAP protocol types

import spec.{describe, it, expect}
import dap.protocol as protocol

describe "Source":
    it "creates source with path":
        let source = protocol.Source.with_path("test.spl")

        expect(source.path.is_some()).to_be(true)
        match source.path:
            case Some(path):
                expect path == "test.spl"
            case None:
                fail("Expected path to be Some")

    it "creates source with name":
        let source = protocol.Source.with_name("Main")

        expect(source.name.is_some()).to_be(true)

describe "Breakpoint":
    it "creates breakpoint":
        let bp = protocol.Breakpoint.new(1, true, 42)

        expect bp.id == 1
        expect(bp.verified).to_be(true)
        expect bp.line.unwrap() == 42

    it "creates unverified breakpoint":
        let bp = protocol.Breakpoint.new(2, false, None)

        expect(bp.verified).to_be(false)
        expect(bp.line.is_none()).to_be(true)

    it "converts to JSON":
        let bp = protocol.Breakpoint.new(1, true, 42)
        let json = bp.to_json()

        expect json.get("id").unwrap() == 1
        expect json.get("verified").unwrap() == true
        expect json.get("line").unwrap() == 42

describe "SourceBreakpoint":
    it "creates source breakpoint":
        let bp = protocol.SourceBreakpoint.new(10)

        expect bp.line == 10
        expect(bp.condition.is_none()).to_be(true)
        expect(bp.hit_condition.is_none()).to_be(true)

    it "creates breakpoint with condition":
        let bp = protocol.SourceBreakpoint.new(10)
            .with_condition("x > 0")

        expect(bp.condition.is_some()).to_be(true)
        match bp.condition:
            case Some(cond):
                expect cond == "x > 0"
            case None:
                fail("Expected condition")

    it "creates breakpoint with hit condition":
        let bp = protocol.SourceBreakpoint.new(10)
            .with_hit_condition("5")

        expect(bp.hit_condition.is_some()).to_be(true)

    it "parses from JSON":
        let json = {
            "line": 20,
            "condition": "y == 42",
            "hitCondition": "3"
        }

        let bp = protocol.SourceBreakpoint.from_json(json).unwrap()

        expect bp.line == 20
        expect bp.condition.unwrap() == "y == 42"
        expect bp.hit_condition.unwrap() == "3"

describe "StackFrame":
    it "creates stack frame":
        let frame = protocol.StackFrame.new(1, "main", 10, 4)

        expect frame.id == 1
        expect frame.name == "main"
        expect frame.line == 10
        expect frame.column == 4

    it "adds source to frame":
        let source = protocol.Source.with_path("test.spl")
        let frame = protocol.StackFrame.new(1, "foo", 20, 0)
            .with_source(source)

        expect(frame.source.is_some()).to_be(true)

    it "converts to JSON":
        let frame = protocol.StackFrame.new(1, "main", 10, 4)
        let json = frame.to_json()

        expect json.get("id").unwrap() == 1
        expect json.get("name").unwrap() == "main"
        expect json.get("line").unwrap() == 10
        expect json.get("column").unwrap() == 4

describe "Thread":
    it "creates thread":
        let thread = protocol.Thread.new(1, "Main Thread")

        expect thread.id == 1
        expect thread.name == "Main Thread"

    it "converts to JSON":
        let thread = protocol.Thread.new(2, "Worker")
        let json = thread.to_json()

        expect json.get("id").unwrap() == 2
        expect json.get("name").unwrap() == "Worker"

describe "Scope":
    it "creates scope":
        let scope = protocol.Scope.new("Local", 1)

        expect scope.name == "Local"
        expect scope.variables_reference == 1
        expect(scope.expensive).to_be(false)

    it "creates expensive scope":
        let scope = protocol.Scope.new("Heap", 10)
            .set_expensive(true)

        expect(scope.expensive).to_be(true)

    it "converts to JSON":
        let scope = protocol.Scope.new("Global", 2)
        let json = scope.to_json()

        expect json.get("name").unwrap() == "Global"
        expect json.get("variablesReference").unwrap() == 2

describe "Variable":
    it "creates variable":
        let var = protocol.Variable.new("x", "42")

        expect var.name == "x"
        expect var.value == "42"
        expect(var.type_name.is_none()).to_be(true)
        expect var.variables_reference == 0

    it "creates variable with type":
        let var = protocol.Variable.new("count", "10")
            .with_type("Int")

        expect(var.type_name.is_some()).to_be(true)
        expect var.type_name.unwrap() == "Int"

    it "creates variable with children":
        let var = protocol.Variable.new("obj", "Object{...}")
            .with_children(5)

        expect var.variables_reference > 0

    it "converts to JSON":
        let var = protocol.Variable.new("name", "\"test\"")
            .with_type("String")
        let json = var.to_json()

        expect json.get("name").unwrap() == "name"
        expect json.get("value").unwrap() == "\"test\""
        expect json.get("type").unwrap() == "String"

describe "Capabilities":
    it "creates default capabilities":
        let caps = protocol.Capabilities.default()

        expect(caps.get("supportsConfigurationDoneRequest").unwrap()).to_be(true)
        expect(caps.get("supportsConditionalBreakpoints").unwrap()).to_be(true)
        expect(caps.get("supportsHitConditionalBreakpoints").unwrap()).to_be(true)

describe "StopReason":
    it "converts to string":
        expect protocol.StopReason.Step.to_string() == "step"
        expect protocol.StopReason.Breakpoint.to_string() == "breakpoint"
        expect protocol.StopReason.Exception.to_string() == "exception"
        expect protocol.StopReason.Pause.to_string() == "pause"

describe "DapRequest":
    it "creates request":
        let req = protocol.DapRequest.new(1, "initialize", None)

        expect req.id == 1
        expect req.command == "initialize"
        expect(req.arguments.is_none()).to_be(true)

    it "creates request with arguments":
        let args = {"program": "test.spl"}
        let req = protocol.DapRequest.new(2, "launch", Some(args))

        expect(req.arguments.is_some()).to_be(true)

    it "parses from JSON":
        let json = {
            "type": "request",
            "seq": 1,
            "command": "setBreakpoints",
            "arguments": {"source": {"path": "test.spl"}}
        }

        let req = protocol.DapRequest.from_json(json).unwrap()

        expect req.id == 1
        expect req.command == "setBreakpoints"
        expect(req.arguments.is_some()).to_be(true)

describe "DapResponse":
    it "creates success response":
        let resp = protocol.DapResponse.success(1, "initialize", None)

        expect resp.request_seq == 1
        expect(resp.success).to_be(true)
        expect resp.command == "initialize"

    it "creates failure response":
        let resp = protocol.DapResponse.failure(2, "launch", "Failed to launch")

        expect(resp.success).to_be(false)
        expect(resp.message.is_some()).to_be(true)

    it "creates response with body":
        let body = {"breakpoints": []}
        let resp = protocol.DapResponse.success(3, "setBreakpoints", Some(body))

        expect(resp.body.is_some()).to_be(true)

describe "DapEvent":
    it "creates event":
        let event = protocol.DapEvent.new("initialized", {})

        expect event.event == "initialized"

    it "creates stopped event":
        let body = {
            "reason": "breakpoint",
            "threadId": 1
        }
        let event = protocol.DapEvent.new("stopped", body)

        expect event.body.get("reason").unwrap() == "breakpoint"
