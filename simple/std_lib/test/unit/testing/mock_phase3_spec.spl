"""
# Mock Phase 3 Specification - Advanced Features

**Feature IDs:** Testing Infrastructure - Mock Advanced Features
**Category:** Testing
**Status:** Phase 3 (Advanced)
**Priority:** High

## Overview

Phase 3 of the mock library adds advanced features including matcher composition,
call analysis, sequential returns with repetition control, and spy functionality
for sophisticated testing scenarios.

## Features Tested

- Matcher composition (and, or, not)
- Custom predicate matchers
- Call pattern analysis
- Sequential return values with repetition
- Spy functionality
"""

import std.spec
import mock

describe "Mock Library - Phase 3 (Advanced Features)":
    context "Matcher Composition - AND":
        it "combines two matchers with AND logic"':
            val m1 = mock.Matcher.gt(5)
            val m2 = mock.Matcher.lt(100)
            val combined = mock.Matcher.and_matcher(m1, m2)
            expect combined.matches("50")
            expect combined.matches("10")
            expect not combined.matches("2")
            expect not combined.matches("150")

        it "AND fails if either matcher fails":
            val m1 = mock.Matcher.contains("error")
            val m2 = mock.Matcher.starts_with("WARN")
            val combined = mock.Matcher.and_matcher(m1, m2)
            expect not combined.matches("error")
            expect not combined.matches("WARNING error")
            expect combined.matches("WARN error")

    context "Matcher Composition - OR":
        it "combines two matchers with OR logic":
            val m1 = mock.Matcher.eq("user")
            val m2 = mock.Matcher.eq("admin")
            val combined = mock.Matcher.or_matcher(m1, m2)
            expect combined.matches("user")
            expect combined.matches("admin")
            expect not combined.matches("guest")

        it "OR succeeds if either matcher matches":
            val m1 = mock.Matcher.contains("GET")
            val m2 = mock.Matcher.contains("POST")
            val combined = mock.Matcher.or_matcher(m1, m2)
            expect combined.matches("GET /users")
            expect combined.matches("POST /users")
            expect not combined.matches("DELETE /users")

    context "Matcher Composition - NOT":
        it "negates a matcher":
            val m = mock.Matcher.eq("admin")
            val negated = mock.Matcher.not_matcher(m)
            expect not negated.matches("admin")
            expect negated.matches("user")
            expect negated.matches("")

        it "NOT inverts boolean logic":
            val m = mock.Matcher.contains("error")
            val negated = mock.Matcher.not_matcher(m)
            expect not negated.matches("fatal error")
            expect negated.matches("success")

    context "Custom Predicate Matchers":
        it "creates matcher from custom predicate":
            val is_even = fn(s: text) -> bool:
                match s.parse_int():
                    Some(n): n % 2 == 0
                    nil: false
            val predicate_m = mock.Matcher.predicate(is_even)
            expect predicate_m.matches("4")
            expect predicate_m.matches("100")
            expect not predicate_m.matches("3")
            expect not predicate_m.matches("99")

        it "uses custom predicate for complex logic":
            val has_numbers = fn(s: text) -> bool:
                for c in s:
                    if c >= "0" and c <= "9":
                        return true
                false
            val pred_m = mock.Matcher.predicate(has_numbers)
            expect pred_m.matches("user123")
            expect pred_m.matches("abc456")
            expect not pred_m.matches("xyz")

    context "CallAnalyzer - Call Counting":
        it "counts calls with specific arguments":
            val fn = mock.MockFunction.new("service")
            fn.record_call(["save", "doc1"])
            fn.record_call(["save", "doc1"])
            fn.record_call(["save", "doc2"])
            val analyzer = mock.CallAnalyzer.new(fn)
            expect analyzer.count_calls_with(["save", "doc1"]) == 2
            expect analyzer.count_calls_with(["save", "doc2"]) == 1
            expect analyzer.count_calls_with(["delete"]) == 0

        it "returns zero for non-matching calls":
            val fn = mock.MockFunction.new("handler")
            fn.record_call(["init"])
            fn.record_call(["start"])
            val analyzer = mock.CallAnalyzer.new(fn)
            expect analyzer.count_calls_with(["stop"]) == 0
            expect analyzer.count_calls_with(["cleanup"]) == 0

    context "CallAnalyzer - Pattern Matching":
        it "gets first call made":
            val fn = mock.MockFunction.new("sequence")
            fn.record_call(["first"])
            fn.record_call(["second"])
            fn.record_call(["third"])
            val analyzer = mock.CallAnalyzer.new(fn)
            val first = analyzer.get_first_call()
            expect first.is_some()
            match first:
                Some(call): expect call.args[0] == "first"
                nil: fail "Should have first call"

        it "returns nil if no calls made":
            val fn = mock.MockFunction.new("unused")
            val analyzer = mock.CallAnalyzer.new(fn)
            expect analyzer.get_first_call().is_none()

    context "CallAnalyzer - Call Range Queries":
        it "gets calls between indices":
            val fn = mock.MockFunction.new("api")
            fn.record_call(["call0"])
            fn.record_call(["call1"])
            fn.record_call(["call2"])
            fn.record_call(["call3"])
            fn.record_call(["call4"])
            val analyzer = mock.CallAnalyzer.new(fn)
            val range = analyzer.get_calls_between(1, 4)
            expect range.len() == 3
            expect range[0].args[0] == "call1"
            expect range[1].args[0] == "call2"
            expect range[2].args[0] == "call3"

        it "handles boundary indices":
            val fn = mock.MockFunction.new("bounded")
            fn.record_call(["a"])
            fn.record_call(["b"])
            fn.record_call(["c"])
            val analyzer = mock.CallAnalyzer.new(fn)
            val range = analyzer.get_calls_between(0, 3)
            expect range.len() == 3

    context "CallAnalyzer - Predicate Matching":
        it "gets calls matching custom predicate":
            val fn = mock.MockFunction.new("log")
            fn.record_call(["INFO", "Started"])
            fn.record_call(["ERROR", "Failed"])
            fn.record_call(["INFO", "Completed"])
            val analyzer = mock.CallAnalyzer.new(fn)
            val has_error = fn(call: mock.CallRecord) -> bool:
                call.args.len() > 0 and call.args[0] == "ERROR"
            val errors = analyzer.get_calls_matching(has_error)
            expect errors.len() == 1
            expect errors[0].args[1] == "Failed"

        it "returns empty list if no matches":
            val fn = mock.MockFunction.new("checker")
            fn.record_call(["safe"])
            fn.record_call(["ok"])
            val analyzer = mock.CallAnalyzer.new(fn)
            val has_panic = fn(call: mock.CallRecord) -> bool:
                call.args.len() > 0 and call.args[0].contains("panic")
            val panics = analyzer.get_calls_matching(has_panic)
            expect panics.len() == 0

    context "SequentialReturns - Basic Usage":
        it "returns values in sequence":
            val seq = mock.SequentialReturns.new()
            seq.add_return("first", 1)
            seq.add_return("second", 1)
            seq.add_return("third", 1)
            expect seq.next_value() == Some("first")
            expect seq.next_value() == Some("second")
            expect seq.next_value() == Some("third")
            expect seq.next_value().is_none()

        it "repeats values based on count":
            val seq = mock.SequentialReturns.new()
            seq.add_return("value_a", 3)
            seq.add_return("value_b", 2)
            expect seq.next_value() == Some("value_a")
            expect seq.next_value() == Some("value_a")
            expect seq.next_value() == Some("value_a")
            expect seq.next_value() == Some("value_b")
            expect seq.next_value() == Some("value_b")
            expect seq.next_value().is_none()

    context "SequentialReturns - add_return_once":
        it "adds single return value":
            val seq = mock.SequentialReturns.new()
            seq.add_return_once("only_once")
            expect seq.next_value() == Some("only_once")
            expect seq.next_value().is_none()

        it "chains multiple once calls":
            val seq = mock.SequentialReturns.new()
            seq.add_return_once("alpha")
            seq.add_return_once("beta")
            seq.add_return_once("gamma")
            expect seq.next_value() == Some("alpha")
            expect seq.next_value() == Some("beta")
            expect seq.next_value() == Some("gamma")
            expect seq.next_value().is_none()

    context "SequentialReturns - Reset":
        it "resets to beginning":
            val seq = mock.SequentialReturns.new()
            seq.add_return_once("first")
            seq.add_return_once("second")
            expect seq.next_value() == Some("first")
            expect seq.next_value() == Some("second")
            seq.reset()
            expect seq.next_value() == Some("first")
            expect seq.next_value() == Some("second")

    context "Spy - Basic Call Recording":
        it "records method calls":
            val spy = mock.Spy.new("user_service")
            spy.record_call("get_user", ["id_123"])
            spy.record_call("save_user", ["id_456", "John"])
            expect spy.total_calls() == 2
            expect spy.method_called("get_user")
            expect spy.method_called("save_user")

        it "tracks method call count":
            val spy = mock.Spy.new("cache")
            spy.record_call("get", ["key1"])
            spy.record_call("get", ["key2"])
            spy.record_call("get", ["key3"])
            spy.record_call("set", ["key", "value"])
            expect spy.method_call_count("get") == 3
            expect spy.method_call_count("set") == 1
            expect spy.method_call_count("delete") == 0

    context "Spy - Call Retrieval":
        it "gets all calls to a method":
            val spy = mock.Spy.new("database")
            spy.record_call("query", ["SELECT", "users"])
            spy.record_call("query", ["SELECT", "posts"])
            spy.record_call("execute", ["INSERT"])
            val queries = spy.get_calls("query")
            expect queries.len() == 2
            expect queries[0].args[1] == "SELECT"
            expect queries[1].args[1] == "SELECT"

        it "returns empty list for untracked methods":
            val spy = mock.Spy.new("logger")
            spy.record_call("info", ["message"])
            val debug_calls = spy.get_calls("debug")
            expect debug_calls.len() == 0

    context "Spy - Method Verification":
        it "verifies method was called":
            val spy = mock.Spy.new("handler")
            spy.record_call("process", ["data"])
            expect spy.method_called("process")
            expect not spy.method_called("cleanup")

        it "tracks total calls across all methods":
            val spy = mock.Spy.new("api")
            spy.record_call("GET", [])
            spy.record_call("POST", [])
            spy.record_call("PUT", [])
            spy.record_call("DELETE", [])
            expect spy.total_calls() == 4

    context "Spy - Summary":
        it "generates summary of calls":
            val spy = mock.Spy.new("test_spy")
            spy.record_call("init", [])
            spy.record_call("process", ["data"])
            val summary = spy.summary()
            expect summary.contains("test_spy")
            expect summary.contains("2")

    context "Complex Scenarios":
        it "combines matcher composition with call analysis":
            val fn = mock.MockFunction.new("validator")
            fn.record_call(["email@test.com"])
            fn.record_call(["user123"])
            fn.record_call(["admin@test.com"])
            val analyzer = mock.CallAnalyzer.new(fn)
            val has_email = fn(call: mock.CallRecord) -> bool:
                call.args.len() > 0 and call.args[0].contains("@")
            val emails = analyzer.get_calls_matching(has_email)
            expect emails.len() == 2
            val contains_test = mock.Matcher.contains("test")
            expect contains_test.matches(emails[0].args[0])

        it "uses sequential returns with spy":
            val seq = mock.SequentialReturns.new()
            seq.add_return("initialized", 1)
            seq.add_return("processing", 2)
            seq.add_return("completed", 1)
            val spy = mock.Spy.new("workflow")
            spy.record_call("status", [])
            spy.record_call("status", [])
            spy.record_call("status", [])
            spy.record_call("status", [])
            expect spy.method_call_count("status") == 4
            expect spy.total_calls() == 4

        it "uses all three matcher composition types":
            val m_contains_error = mock.Matcher.contains("error")
            val m_not_success = mock.Matcher.not_matcher(mock.Matcher.eq("success"))
            val m_combined = mock.Matcher.and_matcher(m_contains_error, m_not_success)
            expect m_combined.matches("fatal error")
            expect not m_combined.matches("success")
            expect not m_combined.matches("no problem")
