"""
# Mock Verification Specification - Phase 2

**Feature IDs:** Testing Infrastructure - Mock Verification
**Category:** Testing
**Status:** Ready (Phase 2)
**Priority:** High

## Overview

Phase 2 of the mock library adds comprehensive verification capabilities for checking
that mocks were called with expected arguments and frequencies.

## Features Tested

- Expectation setting and verification
- Call counting verification
- Argument matching
- Custom matchers (any, eq, gt, lt, contains, starts_with, ends_with)
- Verification error messages
"""

import std.spec
import mock

describe "Mock Library - Phase 2 (Verification)":
    context "Expectations":
        it "sets expectation for call count":
            val fn = mock.MockFunction.new("handler")
            fn.expect_call(2)
            fn.record_call([])
            fn.record_call([])
            val result = fn.verify()
            expect result.is_ok()

        it "fails verification when call count mismatches":
            val fn = mock.MockFunction.new("process")
            fn.expect_call(3)
            fn.record_call([])
            fn.record_call([])
            val result = fn.verify()
            expect result.is_err()

        it "sets expectation for call arguments":
            val fn = mock.MockFunction.new("save")
            fn.expect_call_with(["id_123", "data"])
            fn.record_call(["id_123", "data"])
            val result = fn.verify()
            expect result.is_ok()

        it "fails when arguments don't match":
            val fn = mock.MockFunction.new("update")
            fn.expect_call_with(["old_value"])
            fn.record_call(["new_value"])
            val result = fn.verify()
            expect result.is_err()

    context "VerificationResult":
        it "returns success result":
            val result = mock.VerificationResult.success()
            expect result.is_ok()
            expect not result.is_err()

        it "returns failure result with message":
            val result = mock.VerificationResult.failure("Test failed")
            expect result.is_err()
            expect not result.is_ok()
            expect result.unwrap_err() == "Test failed"

    context "Argument Matchers - Equality":
        it "uses eq matcher for exact match":
            val matcher = mock.Matcher.eq("hello")
            expect matcher.matches("hello")
            expect not matcher.matches("world")

        it "uses any matcher for wildcard":
            val matcher = mock.Matcher.any()
            expect matcher.matches("anything")
            expect matcher.matches("123")
            expect matcher.matches("")

    context "Argument Matchers - Numeric":
        it "uses gt matcher for greater than":
            val matcher = mock.Matcher.gt(10)
            expect matcher.matches("15")
            expect matcher.matches("100")
            expect not matcher.matches("5")
            expect not matcher.matches("10")

        it "uses lt matcher for less than":
            val matcher = mock.Matcher.lt(10)
            expect matcher.matches("5")
            expect matcher.matches("0")
            expect not matcher.matches("10")
            expect not matcher.matches("15")

        it "uses gte matcher for greater or equal":
            val matcher = mock.Matcher.gte(10)
            expect matcher.matches("10")
            expect matcher.matches("15")
            expect not matcher.matches("9")

        it "uses lte matcher for less or equal":
            val matcher = mock.Matcher.lte(10)
            expect matcher.matches("10")
            expect matcher.matches("5")
            expect not matcher.matches("11")

    context "Argument Matchers - String Operations":
        it "uses contains matcher":
            val matcher = mock.Matcher.contains("error")
            expect matcher.matches("fatal error occurred")
            expect matcher.matches("error")
            expect not matcher.matches("warning")

        it "uses starts_with matcher":
            val matcher = mock.Matcher.starts_with("HTTP")
            expect matcher.matches("HTTP/1.1")
            expect matcher.matches("HTTPS")
            expect not matcher.matches("GET HTTP")

        it "uses ends_with matcher":
            val matcher = mock.Matcher.ends_with(".json")
            expect matcher.matches("config.json")
            expect matcher.matches("data.json")
            expect not matcher.matches("config.yaml")

    context "Call Verification":
        it "verifies no calls were made":
            val fn = mock.MockFunction.new("unused")
            expect not fn.was_called()

        it "verifies single call":
            val fn = mock.MockFunction.new("called_once")
            fn.record_call([])
            expect fn.was_called()
            expect fn.was_called_n_times(1)

        it "verifies specific call count":
            val fn = mock.MockFunction.new("counter")
            fn.record_call([])
            fn.record_call([])
            fn.record_call([])
            expect fn.was_called_n_times(3)

        it "gets call by index":
            val fn = mock.MockFunction.new("api")
            fn.record_call(["GET", "/users"])
            fn.record_call(["POST", "/users"])
            val first = fn.get_call(0)
            expect first.is_some()
            match first:
                Some(call): expect call.args[0] == "GET"
                nil: fail "Should have call"

        it "gets last call":
            val fn = mock.MockFunction.new("sequence")
            fn.record_call(["first"])
            fn.record_call(["second"])
            fn.record_call(["third"])
            val last = fn.get_last_call()
            expect last.is_some()
            match last:
                Some(call): expect call.args[0] == "third"
                nil: fail "Should have last call"

    context "Verification Error Messages":
        it "provides error message for call count mismatch":
            val fn = mock.MockFunction.new("test_fn")
            fn.expect_call(2)
            fn.record_call([])
            val result = fn.verify()
            expect result.is_err()
            val msg = result.unwrap_err()
            expect msg.contains("test_fn")
            expect msg.contains("2")
            expect msg.contains("1")

        it "provides error message for argument mismatch":
            val fn = mock.MockFunction.new("service")
            fn.expect_call_with(["expected_arg"])
            fn.record_call(["actual_arg"])
            val result = fn.verify()
            expect result.is_err()
            val msg = result.unwrap_err()
            expect msg.contains("service")
            expect msg.contains("expected_arg")

    context "Multiple Expectations":
        it "verifies multiple expectations":
            val fn = mock.MockFunction.new("multi")
            fn.expect_call(2)
            fn.record_call([])
            fn.record_call([])
            val result = fn.verify()
            expect result.is_ok()

        it "resets expectations on reset":
            val fn = mock.MockFunction.new("resettable")
            fn.expect_call(1)
            fn.reset()
            fn.record_call([])
            fn.record_call([])
            val result = fn.verify()
            expect result.is_ok()
