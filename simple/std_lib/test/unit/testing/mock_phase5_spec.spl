"""Mock Phase 5 Specification - Trait-Based Mocking (Generics Workaround)

**Feature IDs:** Testing Infrastructure - Trait-Based Mocking
**Category:** Testing
**Status:** Phase 5 (Trait-Based Mocking)
**Priority:** High

## Overview

Phase 5 implements trait-based mocking patterns using generics and closures
instead of trait objects. Provides fluent when/returns API and protocol mocking
for simulating method-based interfaces.

## Features Tested

- Fluent when/returns expectations
- Method protocol mocking
- Automatic mock setup
- Method call recording and verification
- Generic method mocking
"""

import std.spec
import mock

describe "Mock Library - Phase 5 (Trait-Based Mocking)":
    context "Fluent Expectations":
        it "creates fluent expectation for mock":
            val mockfn = mock.MockFunction.new("service")
            val fluent = mock.FluentExpectation.new(mockfn)
            expect fluent.mockfn.name == "service"
            expect fluent.when_args.is_none()

        it "sets when clause":
            val mockfn = mock.MockFunction.new("api")
            val fluent = mock.FluentExpectation.new(mockfn)
            val with_when = fluent.when_called_with(["GET", "/users"])
            expect with_when.when_args.is_some()

        it "chains when with returns":
            val mockfn = mock.MockFunction.new("fetch")
            val fluent = mock.FluentExpectation.new(mockfn)
            fluent.when_called_with(["data"]).returns("result")
            expect mockfn.return_values.len() > 0

    context "When Builder":
        it "creates when builder for mock":
            val mockfn = mock.MockFunction.new("handler")
            val when = mock.WhenBuilder.new(mockfn)
            expect when.mockfn.name == "handler"

        it "sets predicate condition":
            val mockfn = mock.MockFunction.new("validator")
            val when = mock.WhenBuilder.new(mockfn)
            val with_condition = when.when(fn(args: List<text>) -> bool:
                args.len() > 0 and args[0] == "valid"
            )
            expect with_condition.mockfn.name == "validator"

        it "chains when with returns":
            val mockfn = mock.MockFunction.new("processor")
            val when = mock.WhenBuilder.new(mockfn)
            when.when(fn(args: List<text>) -> bool:
                args.len() == 1
            ).returns("processed")

    context "Protocol Mock - Basic":
        it "creates protocol mock":
            val proto = mock.ProtocolMock.new()
            expect proto.method_mocks.len() == 0
            expect proto.recorded_calls.len() == 0

        it "mocks method with return value":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("getName", [], "John")
            expect proto.method_mocks.len() == 1

        it "records method call":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("getValue", ["key"], "value")
            val result = proto.record_method_call("getValue", ["key"])
            expect result == "value"

        it "returns empty string for unmocked method":
            val proto = mock.ProtocolMock.new()
            val result = proto.record_method_call("unmocked", [])
            expect result == ""

    context "Protocol Mock - Verification":
        it "verifies method was called":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("process", ["data"], "done")
            proto.record_method_call("process", ["data"])
            expect proto.verify_method_called("process")
            expect not proto.verify_method_called("other")

        it "gets all calls to a method":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("compute", ["a"], "result_a")
            proto.mock_method("compute", ["b"], "result_b")
            proto.record_method_call("compute", ["a"])
            proto.record_method_call("compute", ["a"])
            val calls = proto.get_method_calls("compute")
            expect calls.len() == 2

        it "resets protocol mock":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("test", [], "value")
            expect proto.method_mocks.len() == 1
            proto.reset()
            expect proto.method_mocks.len() == 0

    context "Protocol Mock - Argument Matching":
        it "matches exact arguments":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("api", ["GET", "/users"], "data")
            val result1 = proto.record_method_call("api", ["GET", "/users"])
            val result2 = proto.record_method_call("api", ["POST", "/users"])
            expect result1 == "data"
            expect result2 == ""

        it "handles multiple method signatures":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("save", ["user"], "saved")
            proto.mock_method("save", ["user", "timestamp"], "saved_with_time")
            val r1 = proto.record_method_call("save", ["user"])
            val r2 = proto.record_method_call("save", ["user", "timestamp"])
            expect r1 == "saved"
            expect r2 == "saved_with_time"

    context "Auto Mock - Setup":
        it "creates auto mock":
            val auto = mock.AutoMock.new("User")
            expect auto.name == "User"
            expect auto.properties.len() == 0
            expect auto.methods.len() == 0

        it "adds properties":
            val auto = mock.AutoMock.new("Service")
            auto.add_property("config")
            auto.add_property("state")
            expect auto.properties.len() == 2
            expect auto.get_properties()[0] == "config"

        it "sets up methods":
            val auto = mock.AutoMock.new("Handler")
            auto.setup_method("process", ["data"], "result")
            auto.setup_method("validate", ["input"], "valid")
            expect auto.methods.len() == 2

    context "Auto Mock - Method Calls":
        it "calls mocked method":
            val auto = mock.AutoMock.new("Calculator")
            auto.setup_method("add", ["1", "2"], "3")
            val result = auto.call_method("add", ["1", "2"])
            expect result == "3"

        it "returns empty for unmocked method":
            val auto = mock.AutoMock.new("Service")
            val result = auto.call_method("unknown", [])
            expect result == ""

        it "distinguishes between method signatures":
            val auto = mock.AutoMock.new("Store")
            auto.setup_method("get", ["key"], "value")
            auto.setup_method("get", ["key", "default"], "value_or_default")
            val r1 = auto.call_method("get", ["key"])
            val r2 = auto.call_method("get", ["key", "default"])
            expect r1 == "value"
            expect r2 == "value_or_default"

    context "Auto Mock - Retrieval":
        it "gets all properties":
            val auto = mock.AutoMock.new("Entity")
            auto.add_property("id")
            auto.add_property("name")
            auto.add_property("email")
            val props = auto.get_properties()
            expect props.len() == 3

        it "gets all methods":
            val auto = mock.AutoMock.new("Interface")
            auto.setup_method("method1", [], "r1")
            auto.setup_method("method2", ["arg"], "r2")
            auto.setup_method("method3", ["a", "b"], "r3")
            val methods = auto.get_methods()
            expect methods.len() == 3

        it "generates auto mock summary":
            val auto = mock.AutoMock.new("Service")
            auto.add_property("config")
            auto.setup_method("init", [], "initialized")
            val summary = auto.summary()
            expect summary.contains("Service")
            expect summary.contains("1")

    context "Complex Phase 5 Scenarios":
        it "combines protocol mock with fluent expectation":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("fetch", ["id"], "record")
            proto.record_method_call("fetch", ["id"])
            expect proto.verify_method_called("fetch")

        it "auto mock with multiple method signatures":
            val auto = mock.AutoMock.new("API")
            auto.setup_method("request", ["GET"], "success")
            auto.setup_method("request", ["POST", "data"], "created")
            auto.setup_method("request", ["DELETE", "id"], "deleted")
            val calls = [
                auto.call_method("request", ["GET"]),
                auto.call_method("request", ["POST", "data"]),
                auto.call_method("request", ["DELETE", "id"])
            ]
            expect calls.len() == 3
            expect calls[0] == "success"

        it "protocol mock for complex workflow":
            val proto = mock.ProtocolMock.new()
            proto.mock_method("authenticate", ["user", "pass"], "token_123")
            proto.mock_method("authorize", ["token"], "allowed")
            proto.mock_method("execute", ["command"], "success")
            val auth = proto.record_method_call("authenticate", ["user", "pass"])
            val authz = proto.record_method_call("authorize", [auth])
            val exec = proto.record_method_call("execute", ["cmd"])
            expect auth == "token_123"
            expect authz == "allowed"
            expect exec == "success"

        it "creates mock interface simulation":
            val auto = mock.AutoMock.new("Database")
            auto.setup_method("connect", ["host", "port"], "connected")
            auto.setup_method("query", ["SELECT *"], "rows")
            auto.setup_method("disconnect", [], "closed")
            expect auto.call_method("connect", ["host", "port"]) == "connected"
            expect auto.call_method("query", ["SELECT *"]) == "rows"
            expect auto.call_method("disconnect", []) == "closed"
            val summary = auto.summary()
            expect summary.contains("Database")
