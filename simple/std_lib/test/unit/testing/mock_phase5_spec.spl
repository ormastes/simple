"""
Mock Phase 5 Specification - Trait-Based Mocking

Trait-based mocking capabilities including fluent expectations, when builders,
protocol mocks for interface simulation, and auto mocks for automatic mock generation.

Feature IDs: Testing Infrastructure - Trait-Based Mocking
Category: Testing
"""

# ============================================================================
# Local Definitions (workaround for module import limitation)
# ============================================================================

struct CallRecord:
    args: [text]
    timestamp: i64
    call_number: i32

struct Expectation:
    method_name: text
    expected_times: i32
    expected_args: Option<[text]>

class VerificationResult:
    passed: bool
    error_message: text

    static fn success() -> VerificationResult:
        VerificationResult(passed: true, error_message: "")

    static fn failure(message: text) -> VerificationResult:
        VerificationResult(passed: false, error_message: message)

    fn is_ok() -> bool:
        self.passed

    fn is_err() -> bool:
        not self.passed

class MockFunction:
    name: text
    calls: [CallRecord]
    return_values: [text]
    return_index: i32
    should_panic: bool
    panic_message: text
    expectations: [Expectation]

    static fn new(name: text) -> MockFunction:
        MockFunction(
            name: name,
            calls: [],
            return_values: [],
            return_index: 0,
            should_panic: false,
            panic_message: "",
            expectations: []
        )

    me record_call(args: [text]):
        val record = CallRecord(
            args: args,
            timestamp: 0,
            call_number: self.calls.len() as i32
        )
        var calls = self.calls
        calls.append(record)
        self.calls = calls

    me set_return_values(values: [text]):
        self.return_values = values
        self.return_index = 0

    fn call_count() -> i32:
        self.calls.len() as i32

    fn was_called() -> bool:
        self.calls.len() > 0

    fn was_called_with(expected_args: [text]) -> bool:
        for call in self.calls:
            if call.args.len() == expected_args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != expected_args[i]:
                        matches = false
                        break
                if matches:
                    return true
        false

    fn was_called_n_times(times: i32) -> bool:
        self.call_count() == times

    fn get_call(index: i32) -> Option<CallRecord>:
        if index >= 0 and index < self.calls.len() as i32:
            Some(self.calls[index])
        else:
            nil

    fn get_last_call() -> Option<CallRecord>:
        if self.calls.len() > 0:
            Some(self.calls[self.calls.len() - 1])
        else:
            nil

    me reset():
        self.calls = []
        self.return_values = []
        self.return_index = 0
        self.should_panic = false
        self.panic_message = ""
        self.expectations = []

    fn verify() -> VerificationResult:
        for expectation in self.expectations:
            if expectation.expected_times == 0:
                match expectation.expected_args:
                    Some(args):
                        if not self.was_called_with(args):
                            val msg = "Expected '{self.name}' to be called with {args}, but was not"
                            return VerificationResult.failure(msg)
                    nil: true
            else:
                if not self.was_called_n_times(expectation.expected_times):
                    val msg = "Expected '{self.name}' to be called {expectation.expected_times} times, but was called {self.call_count()} times"
                    return VerificationResult.failure(msg)
            match expectation.expected_args:
                Some(args):
                    if not self.was_called_with(args):
                        val msg = "Expected '{self.name}' to be called with {args}, but was not"
                        return VerificationResult.failure(msg)
                nil: true

        VerificationResult.success()

    me expect_call(times: i32):
        var expectations = self.expectations
        expectations.append(Expectation(
            method_name: self.name,
            expected_times: times,
            expected_args: nil
        ))
        self.expectations = expectations

    me expect_call_with(args: [text]):
        var expectations = self.expectations
        expectations.append(Expectation(
            method_name: self.name,
            expected_times: 0,
            expected_args: Some(args)
        ))
        self.expectations = expectations

    fn summary() -> text:
        if self.calls.len() == 0:
            return "Mock '{self.name}': not called"
        var result = "Mock '{self.name}': called {self.call_count()} time(s)\n"
        for call in self.calls:
            result = result + "  {call.args}\n"
        result

# ============================================================================
# Phase 4: ConditionalReturns (needed by WhenBuilder)
# ============================================================================

struct ConditionalReturn:
    condition: fn([text]) -> bool
    value: text

class ConditionalReturns:
    conditions: [ConditionalReturn]
    default_value: text

    static fn new() -> ConditionalReturns:
        ConditionalReturns(conditions: [], default_value: "")

    me add_condition(condition: fn([text]) -> bool, value: text):
        var conditions = self.conditions
        conditions.append(ConditionalReturn(condition: condition, value: value))
        self.conditions = conditions

    me set_default(value: text):
        self.default_value = value

    fn evaluate(args: [text]) -> text:
        for cond_return in self.conditions:
            val cond_fn = cond_return.condition
            if cond_fn(args):
                return cond_return.value
        self.default_value

# ============================================================================
# Phase 5: Trait-Based Mocking
# ============================================================================

class FluentExpectation:
    mockfn: MockFunction
    when_args: Option<[text]>

    static fn new(mockfn: MockFunction) -> FluentExpectation:
        FluentExpectation(mockfn: mockfn, when_args: nil)

    me when_called_with(args: [text]) -> FluentExpectation:
        self.when_args = Some(args)
        self

    me returns(value: text):
        match self.when_args:
            Some(args):
                var existing_values: [text] = []
                for call in self.mockfn.calls:
                    if call.args.len() == args.len():
                        var matches = true
                        for i in 0..call.args.len():
                            if call.args[i] != args[i]:
                                matches = false
                                break
                        if matches:
                            return
                self.mockfn.set_return_values([value])
            nil:
                self.mockfn.set_return_values([value])

class WhenBuilder:
    mockfn: MockFunction
    condition: fn([text]) -> bool

    static fn new(mockfn: MockFunction) -> WhenBuilder:
        WhenBuilder(
            mockfn: mockfn,
            condition: \args: true
        )

    me when(predicate: fn([text]) -> bool) -> WhenBuilder:
        self.condition = predicate
        self

    me returns(value: text):
        val cond_returns = ConditionalReturns.new()
        cond_returns.add_condition(self.condition, value)
        cond_returns.set_default("")

struct MethodCall:
    method_name: text
    arguments: [text]
    return_value: text
    call_time: i64

class ProtocolMock:
    method_mocks: [MethodCall]
    recorded_calls: [MethodCall]

    static fn new() -> ProtocolMock:
        ProtocolMock(method_mocks: [], recorded_calls: [])

    me mock_method(name: text, args: [text], return_value: text):
        var method_mocks = self.method_mocks
        method_mocks.append(MethodCall(
            method_name: name,
            arguments: args,
            return_value: return_value,
            call_time: 0
        ))
        self.method_mocks = method_mocks

    me record_method_call(name: text, args: [text]) -> text:
        for method_mock in self.method_mocks:
            if method_mock.method_name == name:
                if method_mock.arguments.len() == args.len():
                    var matches = true
                    for i in 0..method_mock.arguments.len():
                        if method_mock.arguments[i] != args[i]:
                            matches = false
                            break
                    if matches:
                        var recorded_calls = self.recorded_calls
                        recorded_calls.append(MethodCall(
                            method_name: name,
                            arguments: args,
                            return_value: method_mock.return_value,
                            call_time: 0
                        ))
                        self.recorded_calls = recorded_calls
                        return method_mock.return_value
        ""

    fn verify_method_called(name: text) -> bool:
        for call in self.recorded_calls:
            if call.method_name == name:
                return true
        false

    fn get_method_calls(name: text) -> [MethodCall]:
        var result: [MethodCall] = []
        for call in self.recorded_calls:
            if call.method_name == name:
                result.append(call)
        result

    me reset():
        self.method_mocks = []
        self.recorded_calls = []

class AutoMock:
    name: text
    properties: [text]
    methods: [MethodCall]

    static fn new(name: text) -> AutoMock:
        AutoMock(name: name, properties: [], methods: [])

    me add_property(prop_name: text):
        var properties = self.properties
        properties.append(prop_name)
        self.properties = properties

    me setup_method(method_name: text, args: [text], return_value: text):
        var methods = self.methods
        methods.append(MethodCall(
            method_name: method_name,
            arguments: args,
            return_value: return_value,
            call_time: 0
        ))
        self.methods = methods

    fn call_method(method_name: text, args: [text]) -> text:
        for method in self.methods:
            if method.method_name == method_name:
                if method.arguments.len() == args.len():
                    var matches = true
                    for i in 0..method.arguments.len():
                        if method.arguments[i] != args[i]:
                            matches = false
                            break
                    if matches:
                        return method.return_value
        ""

    fn get_properties() -> [text]:
        self.properties

    fn get_methods() -> [MethodCall]:
        self.methods

    fn summary() -> text:
        var result = "AutoMock '{self.name}':\n"
        result = result + "  Properties: {self.properties.len()}\n"
        result = result + "  Methods: {self.methods.len()}\n"
        result

# ============================================================================
# Test Suite
# ============================================================================

describe "Mock Library - Phase 5 (Trait-Based Mocking)":
    """
    Test suite for Phase 5 of the Mock Library focusing on trait-based mocking.

    Tests cover:
    - Fluent Expectations: Creating fluent expectation chains, when clauses, returns chaining
    - When Builder: Building conditional mock behavior with predicates and return values
    - Protocol Mock - Basic: Creating protocol mocks, mocking methods, recording calls
    - Protocol Mock - Verification: Verifying method calls, getting all calls, reset functionality
    - Protocol Mock - Argument Matching: Exact argument matching, multiple method signatures
    - Auto Mock - Setup: Creating auto mocks, adding properties, setting up methods
    - Auto Mock - Method Calls: Calling mocked methods, handling unmocked methods, distinguishing signatures
    - Auto Mock - Retrieval: Getting properties and methods, generating summaries
    - Complex Scenarios: Combining protocol mocks with fluent expectations, multi-signature methods,
      complex workflows simulating authentication/authorization, interface simulations
    """
    context "Fluent Expectations":
        it "creates fluent expectation for mock":
            val mockfn = MockFunction.new("service")
            val fluent = FluentExpectation.new(mockfn)
            expect fluent.mockfn.name == "service"
            val has_when_args = match fluent.when_args:
                Some(_): true
                nil: false
            expect not has_when_args

        it "sets when clause":
            val mockfn = MockFunction.new("api")
            val fluent = FluentExpectation.new(mockfn)
            val with_when = fluent.when_called_with(["GET", "/users"])
            expect with_when.when_args.is_some()

        it "chains when with returns":
            val mockfn = MockFunction.new("fetch")
            val fluent = FluentExpectation.new(mockfn)
            fluent.when_called_with(["data"]).returns("result")
            expect mockfn.return_values.len() > 0

    context "When Builder":
        it "creates when builder for mock":
            val mockfn = MockFunction.new("handler")
            val when = WhenBuilder.new(mockfn)
            expect when.mockfn.name == "handler"

        it "sets predicate condition":
            val mockfn = MockFunction.new("validator")
            val when_builder = WhenBuilder.new(mockfn)
            val cond = \args: args.len() > 0 and args[0] == "valid"
            val with_condition = when_builder.when(cond)
            expect with_condition.mockfn.name == "validator"

        it "chains when with returns":
            val mockfn = MockFunction.new("processor")
            val when_builder = WhenBuilder.new(mockfn)
            val cond = \args: args.len() == 1
            when_builder.when(cond).returns("processed")

    context "Protocol Mock - Basic":
        it "creates protocol mock":
            val proto = ProtocolMock.new()
            expect proto.method_mocks.len() == 0
            expect proto.recorded_calls.len() == 0

        it "mocks method with return value":
            val proto = ProtocolMock.new()
            proto.mock_method(name="getName", args=[], return_value="John")
            expect proto.method_mocks.len() == 1

        it "records method call":
            val proto = ProtocolMock.new()
            proto.mock_method(name="getValue", args=["key"], return_value="value")
            val result = proto.record_method_call("getValue", ["key"])
            expect result == "value"

        it "returns empty string for unmocked method":
            val proto = ProtocolMock.new()
            val result = proto.record_method_call("unmocked", [])
            expect result == ""

    context "Protocol Mock - Verification":
        it "verifies method was called":
            val proto = ProtocolMock.new()
            proto.mock_method(name="process", args=["data"], return_value="done")
            proto.record_method_call("process", ["data"])
            expect proto.verify_method_called("process")
            expect not proto.verify_method_called("other")

        it "gets all calls to a method":
            val proto = ProtocolMock.new()
            proto.mock_method(name="compute", args=["a"], return_value="result_a")
            proto.mock_method(name="compute", args=["b"], return_value="result_b")
            proto.record_method_call("compute", ["a"])
            proto.record_method_call("compute", ["a"])
            val calls = proto.get_method_calls("compute")
            expect calls.len() == 2

        it "resets protocol mock":
            val proto = ProtocolMock.new()
            proto.mock_method(name="test", args=[], return_value="value")
            expect proto.method_mocks.len() == 1
            proto.reset()
            expect proto.method_mocks.len() == 0

    context "Protocol Mock - Argument Matching":
        it "matches exact arguments":
            val proto = ProtocolMock.new()
            proto.mock_method(name="api", args=["GET", "/users"], return_value="data")
            val result1 = proto.record_method_call("api", ["GET", "/users"])
            val result2 = proto.record_method_call("api", ["POST", "/users"])
            expect result1 == "data"
            expect result2 == ""

        it "handles multiple method signatures":
            val proto = ProtocolMock.new()
            proto.mock_method(name="save", args=["user"], return_value="saved")
            proto.mock_method(name="save", args=["user", "timestamp"], return_value="saved_with_time")
            val r1 = proto.record_method_call("save", ["user"])
            val r2 = proto.record_method_call("save", ["user", "timestamp"])
            expect r1 == "saved"
            expect r2 == "saved_with_time"

    context "Auto Mock - Setup":
        it "creates auto mock":
            val auto_mock = AutoMock.new("User")
            expect auto_mock.name == "User"
            expect auto_mock.properties.len() == 0
            expect auto_mock.methods.len() == 0

        it "adds properties":
            val auto_mock = AutoMock.new("Service")
            auto_mock.add_property("config")
            auto_mock.add_property("state")
            expect auto_mock.properties.len() == 2
            expect auto_mock.get_properties()[0] == "config"

        it "sets up methods":
            val auto_mock = AutoMock.new("Handler")
            auto_mock.setup_method(method_name="process", args=["data"], return_value="result")
            auto_mock.setup_method(method_name="validate", args=["input"], return_value="valid")
            expect auto_mock.methods.len() == 2

    context "Auto Mock - Method Calls":
        it "calls mocked method":
            val auto_mock = AutoMock.new("Calculator")
            auto_mock.setup_method(method_name="add", args=["1", "2"], return_value="3")
            val result = auto_mock.call_method("add", ["1", "2"])
            expect result == "3"

        it "returns empty for unmocked method":
            val auto_mock = AutoMock.new("Service")
            val result = auto_mock.call_method("unknown", [])
            expect result == ""

        it "distinguishes between method signatures":
            val auto_mock = AutoMock.new("Store")
            auto_mock.setup_method(method_name="get", args=["key"], return_value="value")
            auto_mock.setup_method(method_name="get", args=["key", "default"], return_value="value_or_default")
            val r1 = auto_mock.call_method("get", ["key"])
            val r2 = auto_mock.call_method("get", ["key", "default"])
            expect r1 == "value"
            expect r2 == "value_or_default"

    context "Auto Mock - Retrieval":
        it "gets all properties":
            val auto_mock = AutoMock.new("Entity")
            auto_mock.add_property("id")
            auto_mock.add_property("name")
            auto_mock.add_property("email")
            val props = auto_mock.get_properties()
            expect props.len() == 3

        it "gets all methods":
            val auto_mock = AutoMock.new("Interface")
            auto_mock.setup_method(method_name="method1", args=[], return_value="r1")
            auto_mock.setup_method(method_name="method2", args=["arg"], return_value="r2")
            auto_mock.setup_method(method_name="method3", args=["a", "b"], return_value="r3")
            val methods = auto_mock.get_methods()
            expect methods.len() == 3

        it "generates auto mock summary":
            val auto_mock = AutoMock.new("Service")
            auto_mock.add_property("config")
            auto_mock.setup_method(method_name="init", args=[], return_value="initialized")
            val summary = auto_mock.summary()
            expect summary.contains("Service")
            expect summary.contains("1")

    context "Complex Phase 5 Scenarios":
        it "combines protocol mock with fluent expectation":
            val proto = ProtocolMock.new()
            proto.mock_method(name="fetch", args=["id"], return_value="record")
            proto.record_method_call("fetch", ["id"])
            expect proto.verify_method_called("fetch")

        it "auto mock with multiple method signatures":
            val auto_mock = AutoMock.new("API")
            auto_mock.setup_method(method_name="request", args=["GET"], return_value="success")
            auto_mock.setup_method(method_name="request", args=["POST", "data"], return_value="created")
            auto_mock.setup_method(method_name="request", args=["DELETE", "id"], return_value="deleted")
            val calls = [
                auto_mock.call_method("request", ["GET"]),
                auto_mock.call_method("request", ["POST", "data"]),
                auto_mock.call_method("request", ["DELETE", "id"])
            ]
            expect calls.len() == 3
            expect calls[0] == "success"

        it "protocol mock for complex workflow":
            val proto = ProtocolMock.new()
            proto.mock_method(name="authenticate", args=["user", "pass"], return_value="token_123")
            proto.mock_method(name="authorize", args=["token_123"], return_value="allowed")
            proto.mock_method(name="execute", args=["cmd"], return_value="success")
            val auth = proto.record_method_call("authenticate", ["user", "pass"])
            val authz = proto.record_method_call("authorize", [auth])
            val exec = proto.record_method_call("execute", ["cmd"])
            expect auth == "token_123"
            expect authz == "allowed"
            expect exec == "success"

        it "creates mock interface simulation":
            val auto_mock = AutoMock.new("Database")
            auto_mock.setup_method(method_name="connect", args=["host", "port"], return_value="connected")
            auto_mock.setup_method(method_name="query", args=["SELECT *"], return_value="rows")
            auto_mock.setup_method(method_name="disconnect", args=[], return_value="closed")
            expect auto_mock.call_method("connect", ["host", "port"]) == "connected"
            expect auto_mock.call_method("query", ["SELECT *"]) == "rows"
            expect auto_mock.call_method("disconnect", []) == "closed"
            val summary = auto_mock.summary()
            expect summary.contains("Database")
