"""Mock Phase 4 Specification - Advanced Patterns

**Feature IDs:** Testing Infrastructure - Mock Advanced Patterns
**Category:** Testing
**Status:** Phase 4 (Advanced Patterns)
**Priority:** High

## Overview

Phase 4 adds practical advanced patterns including conditional returns, call chaining,
state-based behavior, mock composition, and snapshots for sophisticated testing scenarios.
These features work within current language constraints without requiring trait objects.

## Features Tested

- Conditional return values based on arguments
- Call chain tracking for parent/child relationships
- State-based behavior sequences
- Mock composition and batch verification
- Call history snapshots
"""

import std.spec
import mocking

describe "Mock Library - Phase 4 (Advanced Patterns)":
    context "Conditional Returns":
        it "returns value based on argument condition":
            val cond_returns = mocking.ConditionalReturns.new()
            cond_returns.add_condition(
                fn(args: List<text>) -> bool: args.len() > 0 and args[0] == "user",
                "user_data"
            )
            cond_returns.set_default("unknown")
            expect cond_returns.evaluate(["user"]) == "user_data"
            expect cond_returns.evaluate(["admin"]) == "unknown"

        it "checks multiple conditions in order":
            val cond = mocking.ConditionalReturns.new()
            cond.add_condition(
                fn(args: List<text>) -> bool: args.len() > 0 and args[0] == "GET",
                "retrieve"
            )
            cond.add_condition(
                fn(args: List<text>) -> bool: args.len() > 0 and args[0] == "POST",
                "create"
            )
            cond.set_default("other")
            expect cond.evaluate(["GET"]) == "retrieve"
            expect cond.evaluate(["POST"]) == "create"
            expect cond.evaluate(["DELETE"]) == "other"

        it "returns default when no conditions match":
            val cond = mocking.ConditionalReturns.new()
            cond.add_condition(
                fn(args: List<text>) -> bool: args.len() == 0,
                "empty"
            )
            cond.set_default("fallback")
            expect cond.evaluate(["something"]) == "fallback"

    context "Call Chain Tracking":
        it "tracks parent-child call relationships":
            val tracker = mocking.CallChainTracker.new()
            val call1 = mocking.CallRecord(args: ["parent"], timestamp: 0, call_number: 0)
            val id1 = tracker.start_chain(-1, call1)
            expect id1 == 0
            val call2 = mocking.CallRecord(args: ["child"], timestamp: 0, call_number: 1)
            val id2 = tracker.start_chain(id1, call2)
            expect id2 == 1
            tracker.add_child(id1, id2)
            val all_chains = tracker.get_all_chains()
            expect all_chains.len() == 2

        it "retrieves chain by parent id":
            val tracker = mocking.CallChainTracker.new()
            val call = mocking.CallRecord(args: ["test"], timestamp: 0, call_number: 0)
            val id = tracker.start_chain(5, call)
            expect tracker.get_chain(5).is_some()

        it "starts multiple independent chains":
            val tracker = mocking.CallChainTracker.new()
            val call1 = mocking.CallRecord(args: ["a"], timestamp: 0, call_number: 0)
            val call2 = mocking.CallRecord(args: ["b"], timestamp: 0, call_number: 1)
            val id1 = tracker.start_chain(-1, call1)
            val id2 = tracker.start_chain(-1, call2)
            expect id1 != id2
            expect tracker.get_all_chains().len() == 2

    context "State-Based Behavior Sequences":
        it "transitions through behavior states":
            val behavior = mocking.BehaviorSequence.new("init")
            behavior.add_state("init", "initializing", Some("ready"))
            behavior.add_state("ready", "operational", Some("shutdown"))
            behavior.add_state("shutdown", "stopped", nil)
            expect behavior.transition() == Some("initializing")
            expect behavior.get_current_state() == "ready"
            expect behavior.transition() == Some("operational")
            expect behavior.get_current_state() == "shutdown"

        it "handles terminal states":
            val behavior = mocking.BehaviorSequence.new("start")
            behavior.add_state("start", "started", Some("end"))
            behavior.add_state("end", "finished", nil)
            behavior.transition()
            expect behavior.get_current_state() == "end"
            behavior.transition()
            expect behavior.get_current_state() == "end"

        it "resets to initial state":
            val behavior = mocking.BehaviorSequence.new("a")
            behavior.add_state("a", "value_a", Some("b"))
            behavior.add_state("b", "value_b", nil)
            behavior.transition()
            expect behavior.get_current_state() == "b"
            behavior.reset_to("a")
            expect behavior.get_current_state() == "a"

        it "manages complex state machines":
            val behavior = mocking.BehaviorSequence.new("idle")
            behavior.add_state("idle", "waiting", Some("running"))
            behavior.add_state("running", "executing", Some("paused"))
            behavior.add_state("paused", "suspended", Some("running"))
            expect behavior.transition() == Some("waiting")
            expect behavior.transition() == Some("executing")
            expect behavior.transition() == Some("suspended")

    context "Mock Snapshots":
        it "captures mock state at a point in time":
            val mockfn = mocking.MockFunction.new("service")
            mockfn.record_call(["arg1"])
            mockfn.record_call(["arg2"])
            val snapshot = mocking.MockSnapshot.from_mock(mockfn)
            expect snapshot.call_count == 2
            expect snapshot.last_args[0] == "arg2"

        it "tracks expectation satisfaction in snapshot":
            val mockfn = mocking.MockFunction.new("verified")
            mockfn.expect_call(1)
            mockfn.record_call([])
            val snapshot = mocking.MockSnapshot.from_mock(mockfn)
            expect snapshot.expectations_met == true

        it "shows when expectations are not met":
            val mockfn = mocking.MockFunction.new("unverified")
            mockfn.expect_call(2)
            mockfn.record_call([])
            val snapshot = mocking.MockSnapshot.from_mock(mockfn)
            expect snapshot.expectations_met == false

        it "generates snapshot summary":
            val mockfn = mocking.MockFunction.new("test")
            mockfn.record_call([])
            val snapshot = mocking.MockSnapshot.from_mock(mockfn)
            val summary = snapshot.summary()
            expect summary.contains("1")
            expect summary.contains("Snapshot")

    context "Mock Composition":
        it "groups multiple mocks":
            val composition = mocking.MockComposition.new()
            val m1 = mocking.MockFunction.new("fn1")
            val m2 = mocking.MockFunction.new("fn2")
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.mocks.len() == 2

        it "verifies all mocks in composition":
            val composition = mocking.MockComposition.new()
            val m1 = mocking.MockFunction.new("fn1")
            val m2 = mocking.MockFunction.new("fn2")
            m1.expect_call(1)
            m2.expect_call(1)
            m1.record_call([])
            m2.record_call([])
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.verify_all() == true

        it "fails verification if any mock fails":
            val composition = mocking.MockComposition.new()
            val m1 = mocking.MockFunction.new("fn1")
            val m2 = mocking.MockFunction.new("fn2")
            m1.expect_call(1)
            m2.expect_call(2)
            m1.record_call([])
            m2.record_call([])
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.verify_all() == false

        it "counts total calls across all mocks":
            val composition = mocking.MockComposition.new()
            val m1 = mocking.MockFunction.new("fn1")
            val m2 = mocking.MockFunction.new("fn2")
            m1.record_call([])
            m1.record_call([])
            m2.record_call([])
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.get_total_calls() == 3

        it "resets all mocks in composition":
            val composition = mocking.MockComposition.new()
            val m1 = mocking.MockFunction.new("fn1")
            val m2 = mocking.MockFunction.new("fn2")
            m1.record_call([])
            m2.record_call([])
            expect composition.get_total_calls() == 2
            composition.reset_all()
            expect composition.get_total_calls() == 0

        it "generates composition summary":
            val composition = mocking.MockComposition.new()
            val m1 = mocking.MockFunction.new("api")
            val m2 = mocking.MockFunction.new("db")
            m1.record_call(["GET"])
            m2.record_call(["SELECT"])
            composition.add_mock(m1)
            composition.add_mock(m2)
            val summary = composition.summary()
            expect summary.contains("2")
            expect summary.contains("mocks")
            expect summary.contains("2")

    context "Complex Phase 4 Scenarios":
        it "combines conditional returns with snapshots":
            val cond = mocking.ConditionalReturns.new()
            cond.add_condition(
                fn(args: List<text>) -> bool: args.len() > 0 and args[0] == "cache",
                "cached_value"
            )
            cond.set_default("fresh_value")
            expect cond.evaluate(["cache"]) == "cached_value"
            expect cond.evaluate(["fetch"]) == "fresh_value"

        it "uses state machine with mock composition":
            val composition = mocking.MockComposition.new()
            val behavior = mocking.BehaviorSequence.new("init")
            behavior.add_state("init", "starting", Some("running"))
            behavior.add_state("running", "operational", nil)
            val m1 = mocking.MockFunction.new("startup")
            val m2 = mocking.MockFunction.new("service")
            composition.add_mock(m1)
            composition.add_mock(m2)
            m1.record_call([])
            m2.record_call([])
            expect composition.get_total_calls() == 2
            expect behavior.transition() == Some("starting")

        it "chains calls and tracks with snapshots":
            val tracker = mocking.CallChainTracker.new()
            val mockfn = mocking.MockFunction.new("main")
            val call1 = mocking.CallRecord(args: ["init"], timestamp: 0, call_number: 0)
            val call2 = mocking.CallRecord(args: ["process"], timestamp: 0, call_number: 1)
            val id1 = tracker.start_chain(-1, call1)
            val id2 = tracker.start_chain(id1, call2)
            tracker.add_child(id1, id2)
            mockfn.record_call(["init"])
            mockfn.record_call(["process"])
            val snapshot = mocking.MockSnapshot.from_mock(mockfn)
            expect snapshot.call_count == 2

        it "manages complex multi-mock workflow":
            val api_mock = mocking.MockFunction.new("api")
            val db_mock = mocking.MockFunction.new("db")
            val cache_mock = mocking.MockFunction.new("cache")
            val composition = mocking.MockComposition.new()
            composition.add_mock(api_mock)
            composition.add_mock(db_mock)
            composition.add_mock(cache_mock)
            api_mock.record_call(["GET", "/users"])
            db_mock.record_call(["SELECT", "users"])
            cache_mock.record_call(["get", "users"])
            expect composition.get_total_calls() == 3
            val summary = composition.summary()
            expect summary.contains("3")
