# Contract Testing Framework Tests
# Tests for Pact-style consumer-driven contract testing

import std.spec
import std.testing.contract as ct

describe "Contract Testing":

    # =========================================================================
    # Group 1: ContractBuilder Core (3 tests)
    # =========================================================================

    context "ContractBuilder (Consumer side)":
        it "creates contract for consumer and provider":
            val builder = ct.ContractBuilder.new("web-app", "user-api")
            assert builder.consumer == "web-app"
            assert builder.provider == "user-api"

        it "defines provider state":
            val builder = ct.ContractBuilder.new("web-app", "user-api")
            builder.given("user 123 exists")
            assert builder.current_state.is_some()

        it "defines interaction":
            val contract = ct.ContractBuilder.new("web-app", "user-api")
                .given("user 123 exists")
                .upon_receiving("request for user 123")
                .with_request("GET", "/users/123")
                .will_respond_with()
                .status(200)
                .build()

            assert contract.interactions.size() == 1

    # =========================================================================
    # Group 2: Request Building (3 tests)
    # =========================================================================

    context "Request building":
        it "builds GET request":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("data exists")
                .upon_receiving("get request")
                .with_request("GET", "/data")
                .will_respond_with()
                .status(200)
                .build()

            val interaction = contract.interactions[0]
            assert interaction.request.method == "GET"
            assert interaction.request.path == "/data"

        it "builds POST request with body":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("ready to create")
                .upon_receiving("create request")
                .with_request("POST", "/users")
                .with_body("" + "{" + "\"name\": \"Alice\", \"email\": \"alice@example.com\"" + "}")
                .will_respond_with()
                .status(201)
                .build()

            val req = contract.interactions[0].request
            assert req.body.is_some()

        it "adds request headers":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("authenticated")
                .upon_receiving("authorized request")
                .with_request("GET", "/protected")
                .with_header("Authorization", "Bearer token123")
                .will_respond_with()
                .status(200)
                .build()

            val headers = contract.interactions[0].request.headers
            assert headers["Authorization"] == "Bearer token123"

    # =========================================================================
    # Group 3: Response Building (3 tests)
    # =========================================================================

    context "Response building":
        it "builds response with status":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("exists")
                .upon_receiving("request")
                .with_request("GET", "/resource")
                .will_respond_with()
                .status(200)
                .build()

            assert contract.interactions[0].response.status == 200

        it "builds response with body":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("user exists")
                .upon_receiving("get user")
                .with_request("GET", "/users/1")
                .will_respond_with()
                .status(200)
                .with_response_body("" + "{" + "\"id\": 1, \"name\": \"Alice\"" + "}")
                .build()

            val body = contract.interactions[0].response.body
            assert body.is_some()

        it "adds response headers":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("exists")
                .upon_receiving("request")
                .with_request("GET", "/data")
                .will_respond_with()
                .status(200)
                .with_response_header("Content-Type", "application/json")
                .build()

            val headers = contract.interactions[0].response.headers
            assert headers["Content-Type"] == "application/json"

    # =========================================================================
    # Group 4: Matchers (3 tests)
    # =========================================================================

    context "Matchers (flexible matching)":
        it "like() matches type not value":
            val matcher = ct.Matcher.like("Alice")
            assert matcher.match_type == "like"
            assert matcher.example == "Alice"

        it "term() matches regex pattern":
            val matcher = ct.Matcher.term("\\d{3}", "123")
            assert matcher.match_type == "term"
            assert matcher.regex.is_some()

        it "each_like() matches array structure":
            val json_str = "" + "{" + "\"id\": 1, \"name\": \"Example\"" + "}"
            val matcher = ct.Matcher.each_like(json_str)
            assert matcher.match_type == "each_like"
            assert matcher.example == json_str

    # =========================================================================
    # Group 5: Persistence (2 tests)
    # =========================================================================

    context "Contract persistence":
        it "saves contract to JSON file":
            val contract = ct.ContractBuilder.new("web-app", "user-api")
                .given("user exists")
                .upon_receiving("get user")
                .with_request("GET", "/users/1")
                .will_respond_with()
                .status(200)
                .build()

            val result = contract.save("/tmp/test-contract.json")
            assert result.is_ok()

        it "generates Pact-compatible JSON":
            val contract = ct.ContractBuilder.new("consumer", "provider")
                .given("state")
                .upon_receiving("request")
                .with_request("GET", "/api")
                .will_respond_with()
                .status(200)
                .build()

            val json = contract.to_pact_json()
            assert json.contains("consumer")
            assert json.contains("provider")
            assert json.contains("interactions")


    # =========================================================================
    # Group 6: Mock Server (3 tests)
    # =========================================================================

    context "Mock server":
        it "creates mock server from contract":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request("GET", "/test")
                .will_respond_with()
                .status(200)
                .with_response_body("" + "{" + "\"result\": \"ok\"" + "}")
                .build()

            val mock_server = ct.MockServer.new(contract)
            assert mock_server.get_url() == "http://mock.local:0"

        it "mock server responds to requests":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request("GET", "/data")
                .will_respond_with()
                .status(200)
                .with_response_body("" + "{" + "\"data\": \"value\"" + "}")
                .build()

            val mock_srv = ct.MockServer.new(contract)
            val resp = mock_srv.simulate_request("GET", "/data")
            assert resp.status == 200

        it "verifies all interactions matched":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("ready")
                .upon_receiving("must call this")
                .with_request("GET", "/required")
                .will_respond_with()
                .status(200)
                .build()

            val mock_srv = ct.MockServer.new(contract)
            mock_srv.simulate_request("GET", "/required")
            assert mock_srv.verify()

    # =========================================================================
    # Group 7: Provider Verification (2 tests)
    # =========================================================================

    context "Provider verification":
        it "verifies provider against contract":
            val verifier = ct.ContractVerifier.new()
            verifier
                .with_provider("user-api")
                .with_contract_file("pacts/web-app-user-api.json")
                .with_provider_base_url("http://localhost:8080")

            val result = verifier.verify()
            assert result

        it "sets up provider states":
            val verifier = ct.ContractVerifier.new()
            verifier
                .with_provider("user-api")
                .with_contract_file("pacts/web-app-user-api.json")
                .with_provider_base_url("http://localhost:8080")

            val result = verifier.verify()
            assert result

    # =========================================================================
    # Group 8: Pact Broker integration (3 tests)
    # =========================================================================

    context "Pact Broker integration":
        it "publishes contract to broker":
            val contract = ct.ContractBuilder.new("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request("GET", "/api")
                .will_respond_with()
                .status(200)
                .build()

            val broker = ct.PactBroker.new("https://broker.example.com")
            val result = broker.publish(contract, "1.0.0")
            assert result.is_ok()

        it "fetches contracts from broker":
            val broker = ct.PactBroker.new("https://broker.example.com")
            val contract = ct.ContractBuilder.new("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request("GET", "/api")
                .will_respond_with()
                .status(200)
                .build()

            broker.publish(contract, "1.0.0")
            val contracts = broker.fetch_for_provider("api")
            assert contracts.size() == 1

        it "counts contracts in broker":
            val broker = ct.PactBroker.new("https://broker.example.com")
            val contract = ct.ContractBuilder.new("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request("GET", "/api")
                .will_respond_with()
                .status(200)
                .build()

            broker.publish(contract, "1.0.0")
            assert broker.count() == 1
