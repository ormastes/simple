# Set<T> Type Test Specification
# Comprehensive tests for hash set implementation

use testing
use set

describe "Set<T>":
    context "Construction":
        it "creates empty set with new()":
            val s = Set.new()
            testing.assert_eq(s.len(), 0, "New set should be empty")
            testing.assert_true(s.is_empty(), "New set should report empty")

        it "creates empty set with capacity":
            val s = Set.with_capacity(32)
            testing.assert_eq(s.len(), 0, "Set with capacity should be empty")
            testing.assert_true(s.is_empty(), "Set with capacity should report empty")

    context "Basic operations":
        it "inserts element into set":
            val s = Set.new()
            val inserted = s.insert("Alice")
            testing.assert_true(inserted, "Should return true for new element")
            testing.assert_eq(s.len(), 1, "Set should have 1 element")

        it "insert returns false for duplicate":
            val s = Set.new()
            s.insert("Alice")
            val inserted = s.insert("Alice")
            testing.assert_false(inserted, "Should return false for duplicate")
            testing.assert_eq(s.len(), 1, "Set should still have 1 element")

        it "contains finds existing element":
            val s = Set.new()
            s.insert("Alice")
            testing.assert_true(s.contains("Alice"), "Should find inserted element")

        it "contains returns false for missing element":
            val s = Set.new()
            testing.assert_false(s.contains("Alice"), "Should not find missing element")

        it "removes existing element":
            val s = Set.new()
            s.insert("Alice")
            val removed = s.remove("Alice")
            testing.assert_true(removed, "Should return true for removed element")
            testing.assert_eq(s.len(), 0, "Set should be empty after removal")

        it "remove returns false for missing element":
            val s = Set.new()
            val removed = s.remove("Alice")
            testing.assert_false(removed, "Should return false for missing element")

        it "clear removes all elements":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")
            s.insert("Charlie")
            s.clear()
            testing.assert_eq(s.len(), 0, "Set should be empty after clear")
            testing.assert_true(s.is_empty(), "Set should report empty after clear")

    context "Multiple elements":
        it "handles multiple unique elements":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")
            s.insert("Charlie")
            testing.assert_eq(s.len(), 3, "Should have 3 elements")
            testing.assert_true(s.contains("Alice"), "Should contain Alice")
            testing.assert_true(s.contains("Bob"), "Should contain Bob")
            testing.assert_true(s.contains("Charlie"), "Should contain Charlie")

        it "deduplicates elements":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")
            s.insert("Alice")  # Duplicate
            s.insert("Bob")    # Duplicate
            testing.assert_eq(s.len(), 2, "Should have only 2 unique elements")

    context "Conversion":
        it "converts to list":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")
            s.insert("Charlie")
            val list = s.to_list()
            testing.assert_eq(list.len(), 3, "List should have 3 elements")

        it "to_list contains all elements":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")
            val list = s.to_list()
            testing.assert_contains(list, "Alice", "List should contain Alice")
            testing.assert_contains(list, "Bob", "List should contain Bob")

    context "Iteration":
        it "for_each executes action for all elements":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")
            s.insert("Charlie")

            var count = 0
            s.for_each(\item:
                count = count + 1
            )
            testing.assert_eq(count, 3, "Should execute action 3 times")

    context "Set operations - union":
        it "union combines two sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Charlie")
            s2.insert("David")

            val result = s1.union(s2)
            testing.assert_eq(result.len(), 4, "Union should have 4 elements")
            testing.assert_true(result.contains("Alice"), "Should contain Alice")
            testing.assert_true(result.contains("Bob"), "Should contain Bob")
            testing.assert_true(result.contains("Charlie"), "Should contain Charlie")
            testing.assert_true(result.contains("David"), "Should contain David")

        it "union handles overlapping sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")
            s1.insert("Charlie")

            val s2 = Set.new()
            s2.insert("Bob")
            s2.insert("Charlie")
            s2.insert("David")

            val result = s1.union(s2)
            testing.assert_eq(result.len(), 4, "Union should have 4 unique elements")

        it "union doesn't modify original sets":
            val s1 = Set.new()
            s1.insert("Alice")

            val s2 = Set.new()
            s2.insert("Bob")

            val result = s1.union(s2)
            testing.assert_eq(s1.len(), 1, "Original s1 should be unchanged")
            testing.assert_eq(s2.len(), 1, "Original s2 should be unchanged")

    context "Set operations - intersection":
        it "intersection finds common elements":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")
            s1.insert("Charlie")

            val s2 = Set.new()
            s2.insert("Bob")
            s2.insert("Charlie")
            s2.insert("David")

            val result = s1.intersection(s2)
            testing.assert_eq(result.len(), 2, "Intersection should have 2 elements")
            testing.assert_true(result.contains("Bob"), "Should contain Bob")
            testing.assert_true(result.contains("Charlie"), "Should contain Charlie")

        it "intersection returns empty for disjoint sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Charlie")
            s2.insert("David")

            val result = s1.intersection(s2)
            testing.assert_eq(result.len(), 0, "Intersection should be empty")

        it "intersection doesn't modify original sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Bob")

            val result = s1.intersection(s2)
            testing.assert_eq(s1.len(), 2, "Original s1 should be unchanged")
            testing.assert_eq(s2.len(), 1, "Original s2 should be unchanged")

    context "Set operations - difference":
        it "difference finds elements in first but not second":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")
            s1.insert("Charlie")

            val s2 = Set.new()
            s2.insert("Bob")
            s2.insert("Charlie")
            s2.insert("David")

            val result = s1.difference(s2)
            testing.assert_eq(result.len(), 1, "Difference should have 1 element")
            testing.assert_true(result.contains("Alice"), "Should contain Alice")
            testing.assert_false(result.contains("Bob"), "Should not contain Bob")
            testing.assert_false(result.contains("Charlie"), "Should not contain Charlie")

        it "difference returns empty when second is superset":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Alice")
            s2.insert("Bob")
            s2.insert("Charlie")

            val result = s1.difference(s2)
            testing.assert_eq(result.len(), 0, "Difference should be empty")

    context "Set operations - symmetric difference":
        it "symmetric_difference finds elements in either but not both":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")
            s1.insert("Charlie")

            val s2 = Set.new()
            s2.insert("Bob")
            s2.insert("Charlie")
            s2.insert("David")

            val result = s1.symmetric_difference(s2)
            testing.assert_eq(result.len(), 2, "Symmetric difference should have 2 elements")
            testing.assert_true(result.contains("Alice"), "Should contain Alice")
            testing.assert_true(result.contains("David"), "Should contain David")
            testing.assert_false(result.contains("Bob"), "Should not contain Bob")
            testing.assert_false(result.contains("Charlie"), "Should not contain Charlie")

        it "symmetric_difference returns union for disjoint sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Charlie")
            s2.insert("David")

            val result = s1.symmetric_difference(s2)
            testing.assert_eq(result.len(), 4, "Symmetric difference should have all elements")

    context "Set predicates - subset":
        it "is_subset returns true when all elements in other":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Alice")
            s2.insert("Bob")
            s2.insert("Charlie")

            testing.assert_true(s1.is_subset(s2), "s1 should be subset of s2")

        it "is_subset returns true for equal sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Alice")
            s2.insert("Bob")

            testing.assert_true(s1.is_subset(s2), "Equal sets are subsets")

        it "is_subset returns false when element not in other":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")
            s1.insert("Charlie")

            val s2 = Set.new()
            s2.insert("Alice")
            s2.insert("Bob")

            testing.assert_false(s1.is_subset(s2), "s1 should not be subset of s2")

    context "Set predicates - superset":
        it "is_superset returns true when contains all elements":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")
            s1.insert("Charlie")

            val s2 = Set.new()
            s2.insert("Alice")
            s2.insert("Bob")

            testing.assert_true(s1.is_superset(s2), "s1 should be superset of s2")

        it "is_superset returns false when missing element":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Alice")
            s2.insert("Bob")
            s2.insert("Charlie")

            testing.assert_false(s1.is_superset(s2), "s1 should not be superset of s2")

    context "Set predicates - disjoint":
        it "is_disjoint returns true for no overlap":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Charlie")
            s2.insert("David")

            testing.assert_true(s1.is_disjoint(s2), "Sets should be disjoint")

        it "is_disjoint returns false when sets overlap":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Bob")
            s2.insert("Charlie")

            testing.assert_false(s1.is_disjoint(s2), "Sets should not be disjoint")

    context "Functional operations - filter":
        it "filter keeps matching elements":
            val s = Set.new()
            s.insert("1")
            s.insert("2")
            s.insert("3")
            s.insert("4")
            s.insert("5")

            val result = s.filter(\x: x.parse_int() % 2 == 0)
            testing.assert_eq(result.len(), 2, "Should have 2 even numbers")
            testing.assert_true(result.contains("2"), "Should contain 2")
            testing.assert_true(result.contains("4"), "Should contain 4")

        it "filter returns empty when no matches":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")

            val result = s.filter(\x: x == "Charlie")
            testing.assert_eq(result.len(), 0, "Should be empty")

    context "Functional operations - map":
        it "map transforms all elements":
            val s = Set.new()
            s.insert("1")
            s.insert("2")
            s.insert("3")

            val result = s.map(\x: x.parse_int() * 2)
            testing.assert_eq(result.len(), 3, "Should have 3 elements")
            testing.assert_true(result.contains(2), "Should contain 2")
            testing.assert_true(result.contains(4), "Should contain 4")
            testing.assert_true(result.contains(6), "Should contain 6")

        it "map deduplicates transformed values":
            val s = Set.new()
            s.insert("1")
            s.insert("2")
            s.insert("3")

            # All map to same value
            val result = s.map(\x: 42)
            testing.assert_eq(result.len(), 1, "Should have 1 element after deduplication")
            testing.assert_true(result.contains(42), "Should contain 42")

    context "Functional operations - any":
        it "any returns true when element matches":
            val s = Set.new()
            s.insert("1")
            s.insert("2")
            s.insert("3")

            val result = s.any(\x: x.parse_int() > 2)
            testing.assert_true(result, "Should find element > 2")

        it "any returns false when no element matches":
            val s = Set.new()
            s.insert("1")
            s.insert("2")
            s.insert("3")

            val result = s.any(\x: x.parse_int() > 10)
            testing.assert_false(result, "Should not find element > 10")

        it "any returns false for empty set":
            val s = Set.new()
            val result = s.any(\x: true)
            testing.assert_false(result, "Empty set should return false")

    context "Functional operations - all":
        it "all returns true when all elements match":
            val s = Set.new()
            s.insert("1")
            s.insert("2")
            s.insert("3")

            val result = s.all(\x: x.parse_int() > 0)
            testing.assert_true(result, "All elements > 0")

        it "all returns false when one element doesn't match":
            val s = Set.new()
            s.insert("1")
            s.insert("2")
            s.insert("3")

            val result = s.all(\x: x.parse_int() > 1)
            testing.assert_false(result, "Not all elements > 1")

        it "all returns true for empty set":
            val s = Set.new()
            val result = s.all(\x: false)
            testing.assert_true(result, "Empty set should return true (vacuous truth)")

    context "Utility operations":
        it "clone creates independent copy":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = s1.clone()
            s2.insert("Charlie")

            testing.assert_eq(s1.len(), 2, "Original should have 2 elements")
            testing.assert_eq(s2.len(), 3, "Clone should have 3 elements")
            testing.assert_false(s1.contains("Charlie"), "Original should not have Charlie")

        it "extend adds all items from list":
            val s = Set.new()
            s.insert("Alice")

            s.extend(["Bob", "Charlie", "David"])
            testing.assert_eq(s.len(), 4, "Should have 4 elements")
            testing.assert_true(s.contains("Bob"), "Should contain Bob")
            testing.assert_true(s.contains("Charlie"), "Should contain Charlie")
            testing.assert_true(s.contains("David"), "Should contain David")

        it "extend deduplicates items from list":
            val s = Set.new()
            s.insert("Alice")

            s.extend(["Alice", "Bob", "Alice", "Charlie", "Bob"])
            testing.assert_eq(s.len(), 3, "Should have 3 unique elements")

    context "Helper functions":
        it "set_from_list creates set from list":
            val list = ["Alice", "Bob", "Charlie", "Alice", "Bob"]
            val s = set.set_from_list(list)
            testing.assert_eq(s.len(), 3, "Should have 3 unique elements")
            testing.assert_true(s.contains("Alice"), "Should contain Alice")
            testing.assert_true(s.contains("Bob"), "Should contain Bob")
            testing.assert_true(s.contains("Charlie"), "Should contain Charlie")

        it "intersect_all finds common elements in multiple sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")
            s1.insert("Charlie")

            val s2 = Set.new()
            s2.insert("Bob")
            s2.insert("Charlie")
            s2.insert("David")

            val s3 = Set.new()
            s3.insert("Charlie")
            s3.insert("David")
            s3.insert("Eve")

            val result = set.intersect_all([s1, s2, s3])
            testing.assert_eq(result.len(), 1, "Should have 1 common element")
            testing.assert_true(result.contains("Charlie"), "Should contain Charlie")

        it "intersect_all returns empty for empty list":
            val result = set.intersect_all([])
            testing.assert_eq(result.len(), 0, "Should be empty")

        it "union_all combines all sets":
            val s1 = Set.new()
            s1.insert("Alice")
            s1.insert("Bob")

            val s2 = Set.new()
            s2.insert("Bob")
            s2.insert("Charlie")

            val s3 = Set.new()
            s3.insert("Charlie")
            s3.insert("David")

            val result = set.union_all([s1, s2, s3])
            testing.assert_eq(result.len(), 4, "Should have 4 unique elements")
            testing.assert_true(result.contains("Alice"), "Should contain Alice")
            testing.assert_true(result.contains("Bob"), "Should contain Bob")
            testing.assert_true(result.contains("Charlie"), "Should contain Charlie")
            testing.assert_true(result.contains("David"), "Should contain David")

    context "Edge cases":
        it "handles many elements":
            val s = Set.with_capacity(128)
            for i in 0..100:
                s.insert("item{i}")
            testing.assert_eq(s.len(), 100, "Should have 100 elements")

        it "handles element removal during iteration":
            val s = Set.new()
            s.insert("Alice")
            s.insert("Bob")
            s.insert("Charlie")

            val items = s.to_list()
            for item in items:
                s.remove(item)

            testing.assert_eq(s.len(), 0, "Should be empty after removing all")

        it "handles empty set operations":
            val s1 = Set.new()
            val s2 = Set.new()

            val union_result = s1.union(s2)
            testing.assert_eq(union_result.len(), 0, "Union of empty sets should be empty")

            val intersect_result = s1.intersection(s2)
            testing.assert_eq(intersect_result.len(), 0, "Intersection of empty sets should be empty")

            testing.assert_true(s1.is_subset(s2), "Empty set is subset of empty set")
            testing.assert_true(s1.is_disjoint(s2), "Empty sets are disjoint")
