# Tests for Base64 encoding/decoding utilities

use tooling.base64_utils.*

# =====================================
# Alphabet Tests
# =====================================

fn test_base64_alphabet():
    val alphabet = base64_alphabet()
    assert(alphabet.len() == 64)
    assert(alphabet.starts_with("ABC"))
    assert(alphabet.ends_with("+/"))

# =====================================
# Character/Byte Conversion Tests
# =====================================

fn test_char_to_byte_letters():
    assert(char_to_byte("A") == 65)
    assert(char_to_byte("B") == 66)
    assert(char_to_byte("a") == 97)
    assert(char_to_byte("b") == 98)

fn test_char_to_byte_digits():
    assert(char_to_byte("0") == 48)
    assert(char_to_byte("1") == 49)
    assert(char_to_byte("2") == 50)

fn test_char_to_byte_special():
    assert(char_to_byte(" ") == 32)
    assert(char_to_byte("!") == 33)

fn test_byte_to_char_letters():
    assert(byte_to_char(65) == "A")
    assert(byte_to_char(66) == "B")
    assert(byte_to_char(97) == "a")
    assert(byte_to_char(98) == "b")

fn test_byte_to_char_digits():
    assert(byte_to_char(48) == "0")
    assert(byte_to_char(49) == "1")
    assert(byte_to_char(50) == "2")

fn test_byte_to_char_special():
    assert(byte_to_char(32) == " ")
    assert(byte_to_char(33) == "!")

# =====================================
# Find Index Tests
# =====================================

fn test_find_base64_index_found():
    val alphabet = base64_alphabet()
    match find_base64_index("A", alphabet):
        Some(idx) => assert(idx == 0)
        None => assert(false)

fn test_find_base64_index_middle():
    val alphabet = base64_alphabet()
    match find_base64_index("a", alphabet):
        Some(idx) => assert(idx == 26)
        None => assert(false)

fn test_find_base64_index_end():
    val alphabet = base64_alphabet()
    match find_base64_index("/", alphabet):
        Some(idx) => assert(idx == 63)
        None => assert(false)

fn test_find_base64_index_not_found():
    val alphabet = base64_alphabet()
    match find_base64_index("@", alphabet):
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# Encoding Tests (Limited Character Set)
# =====================================

fn test_encode_base64_single_char():
    val result = encode_base64("A")
    assert(result.len() > 0)
    assert(result.contains("="))

fn test_encode_base64_two_chars():
    val result = encode_base64("AB")
    assert(result.len() == 4)
    assert(result.ends_with("="))

fn test_encode_base64_three_chars():
    val result = encode_base64("ABC")
    assert(result.len() == 4)
    # No padding needed for 3 chars
    assert(not result.contains("="))

fn test_encode_base64_multiple_chars():
    val result = encode_base64("ABCD")
    assert(result.len() > 4)

fn test_encode_base64_empty():
    val result = encode_base64("")
    assert(result == "")

# =====================================
# Decoding Tests
# =====================================

fn test_decode_base64_valid():
    # Encode then decode
    val encoded = encode_base64("ABC")
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == "ABC")
        None => assert(false)

fn test_decode_base64_with_padding():
    val encoded = encode_base64("AB")
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == "AB")
        None => assert(false)

fn test_decode_base64_empty():
    match decode_base64(""):
        Some(decoded) => assert(decoded == "")
        None => assert(false)

fn test_decode_base64_invalid_char():
    match decode_base64("@#$%"):
        Some(_) => assert(false)
        None => assert(true)

fn test_decode_base64_incomplete():
    # Only 1 character (need at least 2)
    match decode_base64("A"):
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# Round-trip Tests
# =====================================

fn test_roundtrip_single_char():
    val original = "A"
    val encoded = encode_base64(original)
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

fn test_roundtrip_two_chars():
    val original = "AB"
    val encoded = encode_base64(original)
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

fn test_roundtrip_three_chars():
    val original = "ABC"
    val encoded = encode_base64(original)
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

fn test_roundtrip_multiple():
    val original = "ABCDE"
    val encoded = encode_base64(original)
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

# =====================================
# URL-Safe Encoding Tests
# =====================================

fn test_encode_base64_url():
    val result = encode_base64_url("ABC")
    # Should not contain standard Base64 special chars
    assert(not result.contains("+"))
    assert(not result.contains("/"))
    assert(not result.contains("="))

fn test_encode_base64_url_vs_standard():
    val original = "ABC"
    val standard = encode_base64(original)
    val url_safe = encode_base64_url(original)

    # URL-safe should not have padding
    assert(not url_safe.contains("="))

    # Standard might have different chars
    assert(standard.len() >= url_safe.len())

fn test_decode_base64_url_valid():
    val original = "ABC"
    val encoded = encode_base64_url(original)
    match decode_base64_url(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

fn test_roundtrip_url_safe():
    val original = "ABCDE"
    val encoded = encode_base64_url(original)
    match decode_base64_url(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

# =====================================
# Validation Tests
# =====================================

fn test_is_valid_base64_simple():
    assert(is_valid_base64("ABCD"))

fn test_is_valid_base64_with_padding():
    assert(is_valid_base64("AB=="))

fn test_is_valid_base64_with_numbers():
    assert(is_valid_base64("ABC123"))

fn test_is_valid_base64_with_special():
    assert(is_valid_base64("AB+/"))

fn test_is_valid_base64_empty():
    assert(is_valid_base64(""))

fn test_is_valid_base64_invalid_char():
    assert(not is_valid_base64("ABC@"))

fn test_is_valid_base64_too_much_padding():
    assert(not is_valid_base64("A==="))

fn test_is_valid_base64_encoded_string():
    val encoded = encode_base64("ABC")
    assert(is_valid_base64(encoded))

# =====================================
# Edge Cases
# =====================================

fn test_encode_decode_lowercase():
    val original = "abc"
    val encoded = encode_base64(original)
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

fn test_encode_decode_digits():
    val original = "012"
    val encoded = encode_base64(original)
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

fn test_encode_decode_space():
    val original = "A B"
    val encoded = encode_base64(original)
    match decode_base64(encoded):
        Some(decoded) => assert(decoded == original)
        None => assert(false)

fn test_encode_multiple_blocks():
    val original = "ABCDEF"
    val encoded = encode_base64(original)
    # 6 bytes = 2 full blocks = 8 chars
    assert(encoded.len() == 8)

# =====================================
# Character Set Limitation Tests
# =====================================

fn test_char_to_byte_unknown():
    # Unknown chars should return 0
    val result = char_to_byte("@")
    assert(result == 0)

fn test_byte_to_char_unknown():
    # Unknown bytes should return "?"
    val result = byte_to_char(255)
    assert(result == "?")

# =====================================
# Padding Tests
# =====================================

fn test_padding_one_char():
    val encoded = encode_base64("A")
    # 1 byte needs 2 padding chars
    val padding_count = encoded.chars().filter(\c: c == "=").len()
    assert(padding_count == 2)

fn test_padding_two_chars():
    val encoded = encode_base64("AB")
    # 2 bytes need 1 padding char
    val padding_count = encoded.chars().filter(\c: c == "=").len()
    assert(padding_count == 1)

fn test_padding_three_chars():
    val encoded = encode_base64("ABC")
    # 3 bytes need no padding
    val padding_count = encoded.chars().filter(\c: c == "=").len()
    assert(padding_count == 0)

# =====================================
# Complex URL-Safe Tests
# =====================================

fn test_decode_base64_url_with_padding():
    # Test decoding URL-safe with manually added padding
    val encoded = "QUJD"  # "ABC" in Base64
    match decode_base64_url(encoded):
        Some(decoded) => assert(decoded == "ABC")
        None => assert(false)

fn test_url_safe_no_standard_chars():
    val original = "ABCDEFGH"
    val url_encoded = encode_base64_url(original)

    # URL-safe should not have +, /, or =
    assert(not url_encoded.contains("+"))
    assert(not url_encoded.contains("/"))
    assert(not url_encoded.contains("="))
