# Tests for URL utilities

use tooling.url_utils.*

# =====================================
# URL Encoding Tests
# =====================================

fn test_url_encode_simple():
    assert(url_encode("hello") == "hello")

fn test_url_encode_space():
    val result = url_encode("hello world")
    assert(result.contains("%20"))

fn test_url_encode_special_chars():
    val result = url_encode("a+b")
    assert(result.contains("%"))

fn test_url_decode_simple():
    assert(url_decode("hello") == "hello")

fn test_url_decode_space():
    assert(url_decode("hello%20world") == "hello world")

fn test_url_decode_plus():
    assert(url_decode("hello+world") == "hello world")

fn test_url_encode_decode_roundtrip():
    val original = "hello world"
    val encoded = url_encode(original)
    val decoded = url_decode(encoded)
    assert(decoded == original)

# =====================================
# Character Code Tests
# =====================================

fn test_char_code_letters():
    assert(char_code("A") == 65)
    assert(char_code("a") == 97)
    assert(char_code("Z") == 90)
    assert(char_code("z") == 122)

fn test_char_code_digits():
    assert(char_code("0") == 48)
    assert(char_code("9") == 57)

fn test_from_char_code():
    assert(from_char_code(65) == "A")
    assert(from_char_code(97) == "a")
    assert(from_char_code(48) == "0")

fn test_char_code_roundtrip():
    val code = char_code("A")
    val ch = from_char_code(code)
    assert(ch == "A")

# =====================================
# Hex Conversion Tests
# =====================================

fn test_to_hex():
    assert(to_hex(0) == "00")
    assert(to_hex(15) == "0F")
    assert(to_hex(255) == "FF")

fn test_hex_digit():
    assert(hex_digit(0) == "0")
    assert(hex_digit(9) == "9")
    assert(hex_digit(10) == "A")
    assert(hex_digit(15) == "F")

fn test_from_hex_valid():
    match from_hex("00"):
        Some(n) => assert(n == 0)
        None => assert(false)

    match from_hex("FF"):
        Some(n) => assert(n == 255)
        None => assert(false)

fn test_from_hex_invalid():
    match from_hex("GG"):
        Some(_) => assert(false)
        None => assert(true)

fn test_hex_digit_value():
    match hex_digit_value("0"):
        Some(n) => assert(n == 0)
        None => assert(false)

    match hex_digit_value("F"):
        Some(n) => assert(n == 15)
        None => assert(false)

    match hex_digit_value("f"):
        Some(n) => assert(n == 15)
        None => assert(false)

# =====================================
# URL Parsing Tests
# =====================================

fn test_parse_url_simple():
    match parse_url("http://example.com"):
        Some(url) =>
            assert(url.scheme == "http")
            assert(url.host == "example.com")
            assert(url.path == "/")
        None => assert(false)

fn test_parse_url_with_path():
    match parse_url("https://example.com/path/to/resource"):
        Some(url) =>
            assert(url.scheme == "https")
            assert(url.host == "example.com")
            assert(url.path == "/path/to/resource")
        None => assert(false)

fn test_parse_url_with_port():
    match parse_url("http://example.com:8080/"):
        Some(url) =>
            assert(url.host == "example.com")
            match url.port:
                Some(p) => assert(p == 8080)
                None => assert(false)
        None => assert(false)

fn test_parse_url_with_query():
    match parse_url("http://example.com/path?key=value"):
        Some(url) =>
            assert(url.path == "/path")
            assert(url.query == "key=value")
        None => assert(false)

fn test_parse_url_with_fragment():
    match parse_url("http://example.com/page#section"):
        Some(url) =>
            assert(url.path == "/page")
            assert(url.fragment == "section")
        None => assert(false)

fn test_parse_url_with_username():
    match parse_url("http://user@example.com/"):
        Some(url) =>
            assert(url.username == "user")
            assert(url.host == "example.com")
        None => assert(false)

fn test_parse_url_with_credentials():
    match parse_url("ftp://user:pass@example.com/"):
        Some(url) =>
            assert(url.username == "user")
            assert(url.password == "pass")
            assert(url.host == "example.com")
        None => assert(false)

fn test_parse_url_complete():
    match parse_url("https://user:pass@example.com:443/path?key=val#frag"):
        Some(url) =>
            assert(url.scheme == "https")
            assert(url.username == "user")
            assert(url.password == "pass")
            assert(url.host == "example.com")
            match url.port:
                Some(p) => assert(p == 443)
                None => assert(false)
            assert(url.path == "/path")
            assert(url.query == "key=val")
            assert(url.fragment == "frag")
        None => assert(false)

fn test_parse_url_invalid():
    match parse_url("not-a-url"):
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# URL Building Tests
# =====================================

fn test_build_url_simple():
    val url = Url(
        scheme: "http",
        username: "",
        password: "",
        host: "example.com",
        port: None,
        path: "/",
        query: "",
        fragment: ""
    )
    val result = build_url(url)
    assert(result == "http://example.com/")

fn test_build_url_with_port():
    val url = Url(
        scheme: "http",
        username: "",
        password: "",
        host: "example.com",
        port: Some(8080),
        path: "/",
        query: "",
        fragment: ""
    )
    val result = build_url(url)
    assert(result.contains(":8080"))

fn test_build_url_default_port_omitted():
    val url = Url(
        scheme: "http",
        username: "",
        password: "",
        host: "example.com",
        port: Some(80),
        path: "/",
        query: "",
        fragment: ""
    )
    val result = build_url(url)
    assert(not result.contains(":80"))

fn test_build_url_with_query():
    val url = Url(
        scheme: "https",
        username: "",
        password: "",
        host: "example.com",
        port: None,
        path: "/search",
        query: "q=test",
        fragment: ""
    )
    val result = build_url(url)
    assert(result.contains("?q=test"))

fn test_is_default_port():
    assert(is_default_port("http", 80))
    assert(is_default_port("https", 443))
    assert(is_default_port("ftp", 21))
    assert(not is_default_port("http", 8080))

# =====================================
# Query String Tests
# =====================================

fn test_parse_query_string_simple():
    val params = parse_query_string("key=value")
    assert(params.len() == 1)
    assert(params[0].0 == "key")
    assert(params[0].1 == "value")

fn test_parse_query_string_multiple():
    val params = parse_query_string("a=1&b=2&c=3")
    assert(params.len() == 3)
    assert(params[0].0 == "a")
    assert(params[1].0 == "b")
    assert(params[2].0 == "c")

fn test_parse_query_string_empty_value():
    val params = parse_query_string("key=")
    assert(params.len() == 1)
    assert(params[0].0 == "key")
    assert(params[0].1 == "")

fn test_parse_query_string_no_value():
    val params = parse_query_string("flag")
    assert(params.len() == 1)
    assert(params[0].0 == "flag")
    assert(params[0].1 == "")

fn test_parse_query_string_empty():
    val params = parse_query_string("")
    assert(params.len() == 0)

fn test_build_query_string_simple():
    val params = [("key", "value")]
    val result = build_query_string(params)
    assert(result == "key=value")

fn test_build_query_string_multiple():
    val params = [("a", "1"), ("b", "2"), ("c", "3")]
    val result = build_query_string(params)
    assert(result.contains("a=1"))
    assert(result.contains("b=2"))
    assert(result.contains("c=3"))
    assert(result.contains("&"))

fn test_build_query_string_with_encoding():
    val params = [("key", "hello world")]
    val result = build_query_string(params)
    assert(result.contains("%20"))

fn test_add_query_param_empty():
    val result = add_query_param("", "key", "value")
    assert(result == "key=value")

fn test_add_query_param_existing():
    val result = add_query_param("a=1", "b", "2")
    assert(result.contains("a=1"))
    assert(result.contains("b=2"))
    assert(result.contains("&"))

# =====================================
# URL Validation Tests
# =====================================

fn test_is_valid_url_valid():
    assert(is_valid_url("http://example.com"))
    assert(is_valid_url("https://example.com/path"))
    assert(is_valid_url("ftp://files.example.com"))

fn test_is_valid_url_invalid():
    assert(not is_valid_url("example.com"))
    assert(not is_valid_url("/path/to/file"))
    assert(not is_valid_url("http:example.com"))

fn test_is_absolute_url():
    assert(is_absolute_url("http://example.com"))
    assert(is_absolute_url("https://example.com/path"))
    assert(not is_absolute_url("/path/to/file"))
    assert(not is_absolute_url("relative/path"))

fn test_is_relative_url():
    assert(is_relative_url("/path/to/file"))
    assert(is_relative_url("relative/path"))
    assert(not is_relative_url("http://example.com"))

# =====================================
# URL Operations Tests
# =====================================

fn test_get_base_url():
    val url = Url(
        scheme: "https",
        username: "",
        password: "",
        host: "example.com",
        port: None,
        path: "/path",
        query: "key=value",
        fragment: "section"
    )
    val base = get_base_url(url)
    assert(base == "https://example.com")

fn test_get_base_url_with_port():
    val url = Url(
        scheme: "http",
        username: "",
        password: "",
        host: "example.com",
        port: Some(8080),
        path: "/",
        query: "",
        fragment: ""
    )
    val base = get_base_url(url)
    assert(base.contains(":8080"))

fn test_get_full_path():
    val url = Url(
        scheme: "https",
        username: "",
        password: "",
        host: "example.com",
        port: None,
        path: "/path",
        query: "key=value",
        fragment: "section"
    )
    val full_path = get_full_path(url)
    assert(full_path == "/path?key=value#section")

fn test_join_url_absolute():
    val result = join_url("http://example.com", "https://other.com/path")
    assert(result == "https://other.com/path")

fn test_join_url_relative_with_slash():
    val result = join_url("http://example.com/", "/path")
    assert(result == "http://example.com/path")

fn test_join_url_relative_without_slash():
    val result = join_url("http://example.com", "path")
    assert(result == "http://example.com/path")

fn test_join_url_both_slashes():
    val result = join_url("http://example.com/", "/path")
    assert(not result.contains("//path"))

# =====================================
# Integer Parsing Tests
# =====================================

fn test_parse_int_valid():
    match parse_int("123"):
        Some(n) => assert(n == 123)
        None => assert(false)

fn test_parse_int_zero():
    match parse_int("0"):
        Some(n) => assert(n == 0)
        None => assert(false)

fn test_parse_int_invalid():
    match parse_int("abc"):
        Some(_) => assert(false)
        None => assert(true)

fn test_parse_int_empty():
    match parse_int(""):
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# Unreserved Character Tests
# =====================================

fn test_is_unreserved_alphanumeric():
    assert(is_unreserved("A"))
    assert(is_unreserved("z"))
    assert(is_unreserved("0"))
    assert(is_unreserved("9"))

fn test_is_unreserved_special():
    assert(is_unreserved("-"))
    assert(is_unreserved("."))
    assert(is_unreserved("_"))
    assert(is_unreserved("~"))

fn test_is_unreserved_reserved():
    assert(not is_unreserved("!"))
    assert(not is_unreserved("@"))
    assert(not is_unreserved(" "))

# =====================================
# Round-trip Tests
# =====================================

fn test_parse_build_roundtrip():
    val original = "https://user:pass@example.com:8080/path?key=val#frag"
    match parse_url(original):
        Some(url) =>
            val rebuilt = build_url(url)
            # Should have all the same components
            assert(rebuilt.contains("https://"))
            assert(rebuilt.contains("user:pass@"))
            assert(rebuilt.contains("example.com"))
            assert(rebuilt.contains(":8080"))
            assert(rebuilt.contains("/path"))
            assert(rebuilt.contains("?key=val"))
            assert(rebuilt.contains("#frag"))
        None => assert(false)

fn test_query_parse_build_roundtrip():
    val original = "a=1&b=2&c=3"
    val params = parse_query_string(original)
    val rebuilt = build_query_string(params)

    assert(rebuilt.contains("a=1"))
    assert(rebuilt.contains("b=2"))
    assert(rebuilt.contains("c=3"))
