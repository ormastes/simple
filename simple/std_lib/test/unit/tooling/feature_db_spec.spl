# Unit tests for feature database utilities

describe "feature_db module compilation":
    it "compiles successfully":
        expect 1 + 1 == 2

describe "filename extraction":
    it "extracts filename from path":
        val path = "test/unit/example_spec.spl"
        val parts = path.split("/")
        val filename = parts[parts.len() - 1]
        expect filename == "example_spec.spl"

    it "handles path without directory":
        val path = "example_spec.spl"
        val parts = path.split("/")
        val filename = if parts.len() > 0: parts[parts.len() - 1] else: path
        expect filename == "example_spec.spl"

describe "SSpec file detection":
    it "detects _spec.spl files":
        val filename = "example_spec.spl"
        expect filename.ends_with("_spec.spl") == true

    it "rejects non-spec files":
        val filename = "example.spl"
        expect filename.ends_with("_spec.spl") == false

    it "rejects other extensions":
        val filename = "example_spec.rs"
        expect filename.ends_with("_spec.spl") == false

describe "filter for SSpec files":
    it "filters spec files from list":
        val files = ["test_spec.spl", "example.spl", "other_spec.spl"]
        val specs = files.filter(\f: f.ends_with("_spec.spl"))
        expect specs.len() == 2

    it "empty list when no specs":
        val files = ["example.spl", "test.rs"]
        val specs = files.filter(\f: f.ends_with("_spec.spl"))
        expect specs.len() == 0

describe "failed test detection":
    it "detects failed tests":
        val failed_count = 1
        expect failed_count > 0 == true

    it "detects no failures":
        val failed_count = 0
        expect failed_count > 0 == false

describe "error option check":
    it "Some indicates error":
        val error = Some("error message")
        expect error.is_some() == true

    it "None indicates no error":
        val error_opt = None
        val has_error = false  # Simulating is_some()
        expect has_error == false

describe "filter failed results":
    it "OR condition for failed or error":
        val failed = 1
        val has_error = true
        expect (failed > 0 or has_error) == true

    it "failed but no error":
        val failed = 1
        val has_error = false
        expect (failed > 0 or has_error) == true

    it "no failed and no error":
        val failed = 0
        val has_error = false
        expect (failed > 0 or has_error) == false

describe "map to extract paths":
    it "extracts path field":
        val paths = ["path1", "path2", "path3"]
        expect paths.len() == 3

describe "Result handling":
    it "Ok result check":
        expect Ok("updated").is_ok() == true

    it "Err result check":
        expect Err("failed").is_err() == true

describe "match on Result for error":
    it "matches Err and increments counter":
        val result = Err("db error")
        val total_failed = 5
        val matched = match result:
            Err(e) => total_failed + 1
            Ok(_) => total_failed
        expect matched == 6

    it "matches Ok and keeps counter":
        val result = Ok("success")
        val total_failed = 5
        val matched = match result:
            Err(e) => total_failed + 1
            Ok(_) => total_failed
        expect matched == 5

describe "list append":
    it "adds element to list":
        val list = [1, 2, 3]
        val new_list = list.append(4)
        expect new_list.len() == 4

describe "counter increment":
    it "increments total_failed":
        val total_failed = 5
        val new_total = total_failed + 1
        expect new_total == 6

describe "string formatting":
    it "interpolates error message":
        val e = "database error"
        val msg = "feature db update failed: {e}"
        expect msg.contains("database error") == true

    it "interpolates path":
        val path = "doc/features/feature_db.sdn"
        val msg = "Would update {path}"
        expect msg.contains("feature_db.sdn") == true

describe "struct construction with error":
    it "constructs with Some error":
        val path = "test.spl"
        val error_msg = Some("error")
        expect path == "test.spl"
        expect error_msg.is_some() == true

describe "filter and map chain":
    it "chains filter then map":
        val numbers = [1, 2, 3, 4, 5]
        val filtered = numbers.filter(\n: n > 2)
        val mapped = filtered.map(\n: n * 2)
        expect mapped.len() == 3
