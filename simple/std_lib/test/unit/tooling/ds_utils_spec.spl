# Tests for Data Structure utilities

use tooling.ds_utils.*

# =====================================
# Stack Tests
# =====================================

fn test_stack_new():
    val stack: Stack<i32> = Stack.new()
    assert(stack.is_empty())
    assert(stack.size() == 0)

fn test_stack_push():
    var stack: Stack<i32> = Stack.new()
    stack.push(1)
    stack.push(2)
    stack.push(3)

    assert(stack.size() == 3)
    assert(not stack.is_empty())

fn test_stack_pop():
    var stack: Stack<i32> = Stack.new()
    stack.push(1)
    stack.push(2)
    stack.push(3)

    match stack.pop():
        Some(value) => assert(value == 3)
        None => assert(false)

    match stack.pop():
        Some(value) => assert(value == 2)
        None => assert(false)

    assert(stack.size() == 1)

fn test_stack_pop_empty():
    var stack: Stack<i32> = Stack.new()

    match stack.pop():
        Some(_) => assert(false)
        None => assert(true)

fn test_stack_peek():
    var stack: Stack<i32> = Stack.new()
    stack.push(1)
    stack.push(2)

    match stack.peek():
        Some(value) => assert(value == 2)
        None => assert(false)

    # Peek doesn't remove
    assert(stack.size() == 2)

fn test_stack_clear():
    var stack: Stack<i32> = Stack.new()
    stack.push(1)
    stack.push(2)
    stack.clear()

    assert(stack.is_empty())
    assert(stack.size() == 0)

fn test_stack_to_list():
    var stack: Stack<i32> = Stack.new()
    stack.push(1)
    stack.push(2)
    stack.push(3)

    val list = stack.to_list()
    assert(list.len() == 3)
    assert(list[0] == 1)
    assert(list[2] == 3)

# =====================================
# Queue Tests
# =====================================

fn test_queue_new():
    val queue: Queue<i32> = Queue.new()
    assert(queue.is_empty())
    assert(queue.size() == 0)

fn test_queue_enqueue():
    var queue: Queue<i32> = Queue.new()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)

    assert(queue.size() == 3)
    assert(not queue.is_empty())

fn test_queue_dequeue():
    var queue: Queue<i32> = Queue.new()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)

    match queue.dequeue():
        Some(value) => assert(value == 1)
        None => assert(false)

    match queue.dequeue():
        Some(value) => assert(value == 2)
        None => assert(false)

    assert(queue.size() == 1)

fn test_queue_dequeue_empty():
    var queue: Queue<i32> = Queue.new()

    match queue.dequeue():
        Some(_) => assert(false)
        None => assert(true)

fn test_queue_peek():
    var queue: Queue<i32> = Queue.new()
    queue.enqueue(1)
    queue.enqueue(2)

    match queue.peek():
        Some(value) => assert(value == 1)
        None => assert(false)

    # Peek doesn't remove
    assert(queue.size() == 2)

fn test_queue_clear():
    var queue: Queue<i32> = Queue.new()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.clear()

    assert(queue.is_empty())
    assert(queue.size() == 0)

fn test_queue_fifo_order():
    var queue: Queue<i32> = Queue.new()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)

    match queue.dequeue():
        Some(value) => assert(value == 1)
        None => assert(false)

# =====================================
# Deque Tests
# =====================================

fn test_deque_new():
    val deque: Deque<i32> = Deque.new()
    assert(deque.is_empty())
    assert(deque.size() == 0)

fn test_deque_push_front():
    var deque: Deque<i32> = Deque.new()
    deque.push_front(1)
    deque.push_front(2)
    deque.push_front(3)

    assert(deque.size() == 3)

    match deque.peek_front():
        Some(value) => assert(value == 3)
        None => assert(false)

fn test_deque_push_back():
    var deque: Deque<i32> = Deque.new()
    deque.push_back(1)
    deque.push_back(2)
    deque.push_back(3)

    assert(deque.size() == 3)

    match deque.peek_back():
        Some(value) => assert(value == 3)
        None => assert(false)

fn test_deque_pop_front():
    var deque: Deque<i32> = Deque.new()
    deque.push_back(1)
    deque.push_back(2)
    deque.push_back(3)

    match deque.pop_front():
        Some(value) => assert(value == 1)
        None => assert(false)

    assert(deque.size() == 2)

fn test_deque_pop_back():
    var deque: Deque<i32> = Deque.new()
    deque.push_back(1)
    deque.push_back(2)
    deque.push_back(3)

    match deque.pop_back():
        Some(value) => assert(value == 3)
        None => assert(false)

    assert(deque.size() == 2)

fn test_deque_pop_empty():
    var deque: Deque<i32> = Deque.new()

    match deque.pop_front():
        Some(_) => assert(false)
        None => assert(true)

    match deque.pop_back():
        Some(_) => assert(false)
        None => assert(true)

fn test_deque_peek():
    var deque: Deque<i32> = Deque.new()
    deque.push_back(1)
    deque.push_back(2)

    match deque.peek_front():
        Some(value) => assert(value == 1)
        None => assert(false)

    match deque.peek_back():
        Some(value) => assert(value == 2)
        None => assert(false)

fn test_deque_clear():
    var deque: Deque<i32> = Deque.new()
    deque.push_back(1)
    deque.push_back(2)
    deque.clear()

    assert(deque.is_empty())

# =====================================
# Priority Queue Tests
# =====================================

fn test_priority_queue_new():
    val pq: PriorityQueue<text> = PriorityQueue.new()
    assert(pq.is_empty())
    assert(pq.size() == 0)

fn test_priority_queue_insert():
    var pq: PriorityQueue<text> = PriorityQueue.new()
    pq.insert(3, "low")
    pq.insert(1, "high")
    pq.insert(2, "medium")

    assert(pq.size() == 3)

fn test_priority_queue_extract_min():
    var pq: PriorityQueue<text> = PriorityQueue.new()
    pq.insert(3, "low")
    pq.insert(1, "high")
    pq.insert(2, "medium")

    match pq.extract_min():
        Some(value) => assert(value == "high")
        None => assert(false)

    match pq.extract_min():
        Some(value) => assert(value == "medium")
        None => assert(false)

    assert(pq.size() == 1)

fn test_priority_queue_peek_min():
    var pq: PriorityQueue<text> = PriorityQueue.new()
    pq.insert(3, "low")
    pq.insert(1, "high")

    match pq.peek_min():
        Some(value) => assert(value == "high")
        None => assert(false)

    # Peek doesn't remove
    assert(pq.size() == 2)

fn test_priority_queue_extract_empty():
    var pq: PriorityQueue<i32> = PriorityQueue.new()

    match pq.extract_min():
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# Circular Buffer Tests
# =====================================

fn test_circular_buffer_new():
    val buf: CircularBuffer<i32> = CircularBuffer.new(5)
    assert(buf.is_empty())
    assert(buf.size() == 0)
    assert(buf.get_capacity() == 5)

fn test_circular_buffer_write_read():
    var buf: CircularBuffer<i32> = CircularBuffer.new(3)
    buf.write(1)
    buf.write(2)
    buf.write(3)

    assert(buf.size() == 3)
    assert(buf.is_full())

    match buf.read():
        Some(value) => assert(value == 1)
        None => assert(false)

    assert(buf.size() == 2)

fn test_circular_buffer_overwrite():
    var buf: CircularBuffer<i32> = CircularBuffer.new(3)
    buf.write(1)
    buf.write(2)
    buf.write(3)
    buf.write(4)  # Overwrites 1

    # Should read 2, 3, 4
    match buf.read():
        Some(value) => assert(value == 2)
        None => assert(false)

fn test_circular_buffer_peek():
    var buf: CircularBuffer<i32> = CircularBuffer.new(3)
    buf.write(1)
    buf.write(2)

    match buf.peek():
        Some(value) => assert(value == 1)
        None => assert(false)

    # Peek doesn't remove
    assert(buf.size() == 2)

fn test_circular_buffer_clear():
    var buf: CircularBuffer<i32> = CircularBuffer.new(3)
    buf.write(1)
    buf.write(2)
    buf.clear()

    assert(buf.is_empty())
    assert(buf.size() == 0)

fn test_circular_buffer_read_empty():
    var buf: CircularBuffer<i32> = CircularBuffer.new(3)

    match buf.read():
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# Helper Function Tests
# =====================================

fn test_stack_from_list():
    val stack = stack_from_list([1, 2, 3])
    assert(stack.size() == 3)

    match stack.peek():
        Some(value) => assert(value == 3)
        None => assert(false)

fn test_queue_from_list():
    val queue = queue_from_list([1, 2, 3])
    assert(queue.size() == 3)

    match queue.peek():
        Some(value) => assert(value == 1)
        None => assert(false)

fn test_deque_from_list():
    val deque = deque_from_list([1, 2, 3])
    assert(deque.size() == 3)

fn test_reverse_stack():
    val stack = stack_from_list([1, 2, 3])
    val reversed = reverse_stack(stack)

    match reversed.peek():
        Some(value) => assert(value == 1)
        None => assert(false)

fn test_merge_queues():
    val q1 = queue_from_list([1, 2])
    val q2 = queue_from_list([3, 4])
    val merged = merge_queues(q1, q2)

    assert(merged.size() == 4)

fn test_stack_get():
    val stack = stack_from_list([1, 2, 3])

    match stack_get(stack, 0):
        Some(value) => assert(value == 3)  # Top
        None => assert(false)

    match stack_get(stack, 2):
        Some(value) => assert(value == 1)  # Bottom
        None => assert(false)

fn test_stack_get_out_of_bounds():
    val stack = stack_from_list([1, 2, 3])

    match stack_get(stack, 10):
        Some(_) => assert(false)
        None => assert(true)

fn test_queue_get():
    val queue = queue_from_list([1, 2, 3])

    match queue_get(queue, 0):
        Some(value) => assert(value == 1)  # Front
        None => assert(false)

    match queue_get(queue, 2):
        Some(value) => assert(value == 3)  # Back
        None => assert(false)

fn test_queue_get_out_of_bounds():
    val queue = queue_from_list([1, 2, 3])

    match queue_get(queue, 10):
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# Complex Scenarios
# =====================================

fn test_stack_multiple_operations():
    var stack: Stack<i32> = Stack.new()
    stack.push(1)
    stack.push(2)
    stack.pop()
    stack.push(3)
    stack.push(4)

    assert(stack.size() == 3)

    match stack.pop():
        Some(value) => assert(value == 4)
        None => assert(false)

fn test_queue_multiple_operations():
    var queue: Queue<i32> = Queue.new()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.dequeue()
    queue.enqueue(3)
    queue.enqueue(4)

    assert(queue.size() == 3)

    match queue.dequeue():
        Some(value) => assert(value == 2)
        None => assert(false)

fn test_deque_mixed_operations():
    var deque: Deque<i32> = Deque.new()
    deque.push_back(1)
    deque.push_front(2)
    deque.push_back(3)
    deque.pop_front()

    # Should be [1, 3]
    assert(deque.size() == 2)

fn test_priority_queue_multiple_priorities():
    var pq: PriorityQueue<text> = PriorityQueue.new()
    pq.insert(5, "lowest")
    pq.insert(1, "highest")
    pq.insert(3, "medium")
    pq.insert(2, "high")
    pq.insert(4, "low")

    # Extract in priority order
    match pq.extract_min():
        Some(value) => assert(value == "highest")
        None => assert(false)

    match pq.extract_min():
        Some(value) => assert(value == "high")
        None => assert(false)

fn test_circular_buffer_wrap_around():
    var buf: CircularBuffer<i32> = CircularBuffer.new(3)
    buf.write(1)
    buf.write(2)
    buf.write(3)

    # Read one
    buf.read()

    # Write two more (wraps around)
    buf.write(4)
    buf.write(5)

    assert(buf.is_full())

    # Should read 2, 3, 4
    match buf.read():
        Some(value) => assert(value == 2)
        None => assert(false)
