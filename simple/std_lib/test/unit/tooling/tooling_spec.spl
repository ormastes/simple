# Multi-Language Tooling Tests
# Tests for build, test, and deploy features

use spec.{describe, context, it, expect}
use tooling.*
use tooling.core.project.{Language, ProjectConfig, ProjectDetector}
use tooling.core.incremental.{IncrementalCache, FileEntry}
use tooling.core.dependency.{DependencyGraph, DependencyType}
use tooling.core.errors.ErrorAggregator
use tooling.compiler.{LanguageCompiler, CompilationMode, CompilationResult}
use tooling.testing.{TestRunner, TestConfig, TestRunResult}
use tooling.deployment.{DeploymentPipeline, Environment, DeploymentStrategy}

describe("Multi-Language Tooling"):
    context("Project Detection"):
        it("detects Simple projects"):
            # Create mock project structure
            project = ProjectConfig {
                name: "test_project",
                root_path: "/tmp/test",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            expect(project.name).to_equal("test_project")
            expect(project.languages.len()).to_equal(1)
            expect(project.languages[0]).to_equal(Language.Simple)

        it("detects multi-language projects"):
            project = ProjectConfig {
                name: "polyglot",
                root_path: "/tmp/polyglot",
                languages: [Language.Simple, Language.Rust, Language.Python],
                version: "1.0.0"
            }

            expect(project.languages.len()).to_equal(3)
            expect(Language.Rust in project.languages).to_be_true()

        it("validates project configuration"):
            project = ProjectConfig {
                name: "valid_project",
                root_path: "/tmp/valid",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            expect(project.name.len() > 0).to_be_true()
            expect(project.languages.len() > 0).to_be_true()

    context("Incremental Compilation"):
        it("tracks file changes"):
            cache = IncrementalCache.new("/tmp/cache")

            entry1 = FileEntry {
                path: "/tmp/test.spl",
                hash: "abc123",
                timestamp: 1000,
                dependencies: []
            }

            cache.add_entry(entry1)
            expect(cache.has_entry("/tmp/test.spl")).to_be_true()

        it("detects file modifications"):
            cache = IncrementalCache.new("/tmp/cache")

            # Original file
            entry1 = FileEntry {
                path: "/tmp/test.spl",
                hash: "abc123",
                timestamp: 1000,
                dependencies: []
            }
            cache.add_entry(entry1)

            # Modified file (different hash)
            entry2 = FileEntry {
                path: "/tmp/test.spl",
                hash: "def456",
                timestamp: 2000,
                dependencies: []
            }

            changed = cache.is_changed(entry2)
            expect(changed).to_be_true()

        it("identifies files needing recompilation"):
            cache = IncrementalCache.new("/tmp/cache")

            # Add files with dependencies
            file_a = FileEntry {
                path: "/tmp/a.spl",
                hash: "hash_a",
                timestamp: 1000,
                dependencies: []
            }

            file_b = FileEntry {
                path: "/tmp/b.spl",
                hash: "hash_b",
                timestamp: 1000,
                dependencies: ["/tmp/a.spl"]  # b depends on a
            }

            cache.add_entry(file_a)
            cache.add_entry(file_b)

            # If a.spl changes, b.spl needs recompilation
            modified_a = FileEntry {
                path: "/tmp/a.spl",
                hash: "new_hash_a",
                timestamp: 2000,
                dependencies: []
            }

            needs_rebuild = cache.get_affected_files(modified_a)
            expect("/tmp/b.spl" in needs_rebuild).to_be_true()

    context("Dependency Tracking"):
        it("builds dependency graph"):
            graph = DependencyGraph.new()

            graph.add_dependency("/tmp/a.spl", "/tmp/b.spl", DependencyType.Import)
            graph.add_dependency("/tmp/b.spl", "/tmp/c.spl", DependencyType.Import)

            expect(graph.has_dependency("/tmp/a.spl", "/tmp/b.spl")).to_be_true()

        it("detects circular dependencies"):
            graph = DependencyGraph.new()

            graph.add_dependency("/tmp/a.spl", "/tmp/b.spl", DependencyType.Import)
            graph.add_dependency("/tmp/b.spl", "/tmp/c.spl", DependencyType.Import)
            graph.add_dependency("/tmp/c.spl", "/tmp/a.spl", DependencyType.Import)

            has_cycle = graph.has_cycle()
            expect(has_cycle).to_be_true()

        it("computes topological order"):
            graph = DependencyGraph.new()

            graph.add_dependency("/tmp/a.spl", "/tmp/b.spl", DependencyType.Import)
            graph.add_dependency("/tmp/b.spl", "/tmp/c.spl", DependencyType.Import)

            order = graph.topological_sort()

            # c should come before b, b before a
            idx_c = order.index("/tmp/c.spl")
            idx_b = order.index("/tmp/b.spl")
            idx_a = order.index("/tmp/a.spl")

            expect(idx_c < idx_b).to_be_true()
            expect(idx_b < idx_a).to_be_true()

    context("Error Aggregation"):
        it("collects errors from multiple languages"):
            aggregator = ErrorAggregator.new()

            # Add errors from different languages
            aggregator.add_error(Language.Simple, "syntax error", "/tmp/test.spl", 10)
            aggregator.add_error(Language.Rust, "type mismatch", "/tmp/lib.rs", 42)

            errors = aggregator.get_all_errors()
            expect(errors.len()).to_equal(2)

        it("normalizes error formats"):
            aggregator = ErrorAggregator.new()

            # Different error formats from different compilers
            aggregator.add_error(Language.Simple, "error: undefined variable 'x'", "/tmp/a.spl", 5)
            aggregator.add_error(Language.Rust, "error[E0425]: cannot find value `x`", "/tmp/lib.rs", 10)

            normalized = aggregator.get_normalized_errors()

            # Both should be normalized to similar format
            expect(normalized.len()).to_equal(2)
            expect(normalized[0].file.len() > 0).to_be_true()
            expect(normalized[0].line > 0).to_be_true()

        it("groups errors by file"):
            aggregator = ErrorAggregator.new()

            aggregator.add_error(Language.Simple, "error 1", "/tmp/test.spl", 10)
            aggregator.add_error(Language.Simple, "error 2", "/tmp/test.spl", 20)
            aggregator.add_error(Language.Rust, "error 3", "/tmp/lib.rs", 5)

            grouped = aggregator.group_by_file()

            expect(grouped["/tmp/test.spl"].len()).to_equal(2)
            expect(grouped["/tmp/lib.rs"].len()).to_equal(1)

    context("Test Runner"):
        it("creates test configuration"):
            config = TestConfig.new()

            expect(config.parallel).to_be_false()
            expect(config.fail_fast).to_be_false()
            expect(config.timeout_seconds).to_equal(300)

        it("configures parallel execution"):
            config = TestConfig {
                parallel: true,
                fail_fast: false,
                verbose: false,
                coverage: false,
                timeout_seconds: 300,
                filter_pattern: ""
            }

            expect(config.parallel).to_be_true()

        it("creates test result"):
            result = TestRunResult {
                total_tests: 10,
                passed: 8,
                failed: 2,
                skipped: 0,
                duration_ms: 5000,
                failures: []
            }

            expect(result.total_tests).to_equal(10)
            expect(result.passed).to_equal(8)
            expect(result.is_success()).to_be_false()

        it("generates test summary"):
            result = TestRunResult {
                total_tests: 10,
                passed: 10,
                failed: 0,
                skipped: 0,
                duration_ms: 5000,
                failures: []
            }

            summary = result.summary()
            expect("10/10" in summary).to_be_true()
            expect("passed" in summary).to_be_true()

    context("Deployment Pipeline"):
        it("creates deployment pipeline"):
            project = ProjectConfig {
                name: "test_app",
                root_path: "/tmp/app",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            pipeline = DeploymentPipeline.new(project, Environment.Production)

            expect(pipeline.project.name).to_equal("test_app")
            expect(pipeline.environment).to_equal(Environment.Production)

        it("adds pipeline stages"):
            project = ProjectConfig {
                name: "test_app",
                root_path: "/tmp/app",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            pipeline = DeploymentPipeline.new(project, Environment.Staging)

            pipeline.add_stage("build", () -> Ok(()))
            pipeline.add_stage("test", () -> Ok(()))
            pipeline.add_stage("deploy", () -> Ok(()))

            expect(pipeline.stages.len()).to_equal(3)

        it("executes pipeline stages"):
            project = ProjectConfig {
                name: "test_app",
                root_path: "/tmp/app",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            pipeline = DeploymentPipeline.new(project, Environment.Development)

            stage_executed = false
            pipeline.add_stage("test_stage", () -> {
                stage_executed = true
                Ok(())
            })

            result = pipeline.execute()

            expect(result.success).to_be_true()
            expect(stage_executed).to_be_true()

    context("Compilation Modes"):
        it("supports debug mode"):
            mode = CompilationMode.Debug
            expect(mode).to_equal(CompilationMode.Debug)

        it("supports release mode"):
            mode = CompilationMode.Release
            expect(mode).to_equal(CompilationMode.Release)

    context("Language Support"):
        it("recognizes all supported languages"):
            languages = [
                Language.Simple,
                Language.Rust,
                Language.Python,
                Language.JavaScript,
                Language.TypeScript,
                Language.Go,
                Language.C,
                Language.Cpp
            ]

            expect(languages.len()).to_equal(8)

        it("converts language to string"):
            expect(Language.Simple.to_string()).to_equal("Simple")
            expect(Language.Rust.to_string()).to_equal("Rust")
            expect(Language.Python.to_string()).to_equal("Python")

    context("Compilation Results"):
        it("creates successful compilation result"):
            result = CompilationResult {
                status: "success",
                output_path: "/tmp/output",
                duration_ms: 1000,
                errors: [],
                warnings: []
            }

            expect(result.status).to_equal("success")
            expect(result.errors.len()).to_equal(0)

        it("creates failed compilation result"):
            result = CompilationResult {
                status: "error",
                output_path: "",
                duration_ms: 500,
                errors: ["syntax error on line 10"],
                warnings: []
            }

            expect(result.status).to_equal("error")
            expect(result.errors.len()).to_equal(1)

    context("Integration"):
        it("builds multi-language project"):
            # This would test actual compilation
            # Skipped in unit tests (requires real compilers)
            expect(true).to_be_true()

        it("runs multi-language tests"):
            # This would test actual test execution
            # Skipped in unit tests (requires real test frameworks)
            expect(true).to_be_true()

        it("deploys multi-language project"):
            # This would test actual deployment
            # Skipped in unit tests (requires deployment infrastructure)
            expect(true).to_be_true()
