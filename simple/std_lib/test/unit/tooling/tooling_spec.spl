# Multi-Language Tooling Tests
# Tests for build, test, and deploy features

use spec.{describe, context, it, expect}
use tooling.*
use tooling.core.project.{Language, ProjectConfig, ProjectDetector}
use tooling.core.incremental.{IncrementalCache, FileEntry}
use tooling.core.dependency.{DependencyGraph, DependencyType}
use tooling.core.errors.ErrorAggregator
use tooling.compiler.{LanguageCompiler, CompilationMode, CompilationResult}
use tooling.testing.{TestRunner, TestConfig, TestRunResult}
use tooling.deployment.{DeploymentPipeline, Environment, DeploymentStrategy}

describe "Multi-Language Tooling":
    context("Project Detection"):
        it "detects Simple projects":
            # Create mock project structure
            project = ProjectConfig {
                name: "test_project",
                root_path: "/tmp/test",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            expect project.name == "test_project"
            expect project.languages.len() == 1
            expect project.languages[0] == Language.Simple

        it "detects multi-language projects":
            project = ProjectConfig {
                name: "polyglot",
                root_path: "/tmp/polyglot",
                languages: [Language.Simple, Language.Rust, Language.Python],
                version: "1.0.0"
            }

            expect project.languages.len() == 3
            expect Language.Rust in project.languages

        it "validates project configuration":
            project = ProjectConfig {
                name: "valid_project",
                root_path: "/tmp/valid",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            expect project.name.len() > 0
            expect project.languages.len() > 0

    context("Incremental Compilation"):
        it "tracks file changes":
            cache = IncrementalCache.new("/tmp/cache")

            entry1 = FileEntry {
                path: "/tmp/test.spl",
                hash: "abc123",
                timestamp: 1000,
                dependencies: []
            }

            cache.add_entry(entry1)
            expect cache.has_entry("/tmp/test.spl")

        it "detects file modifications":
            cache = IncrementalCache.new("/tmp/cache")

            # Original file
            entry1 = FileEntry {
                path: "/tmp/test.spl",
                hash: "abc123",
                timestamp: 1000,
                dependencies: []
            }
            cache.add_entry(entry1)

            # Modified file (different hash)
            entry2 = FileEntry {
                path: "/tmp/test.spl",
                hash: "def456",
                timestamp: 2000,
                dependencies: []
            }

            changed = cache.is_changed(entry2)
            expect changed

        it "identifies files needing recompilation":
            cache = IncrementalCache.new("/tmp/cache")

            # Add files with dependencies
            file_a = FileEntry {
                path: "/tmp/a.spl",
                hash: "hash_a",
                timestamp: 1000,
                dependencies: []
            }

            file_b = FileEntry {
                path: "/tmp/b.spl",
                hash: "hash_b",
                timestamp: 1000,
                dependencies: ["/tmp/a.spl"]  # b depends on a
            }

            cache.add_entry(file_a)
            cache.add_entry(file_b)

            # If a.spl changes, b.spl needs recompilation
            modified_a = FileEntry {
                path: "/tmp/a.spl",
                hash: "new_hash_a",
                timestamp: 2000,
                dependencies: []
            }

            needs_rebuild = cache.get_affected_files(modified_a)
            expect "/tmp/b.spl" in needs_rebuild

    context("Dependency Tracking"):
        it "builds dependency graph":
            graph = DependencyGraph.new()

            graph.add_dependency("/tmp/a.spl", "/tmp/b.spl", DependencyType.Import)
            graph.add_dependency("/tmp/b.spl", "/tmp/c.spl", DependencyType.Import)

            expect graph.has_dependency("/tmp/a.spl", "/tmp/b.spl")

        it "detects circular dependencies":
            graph = DependencyGraph.new()

            graph.add_dependency("/tmp/a.spl", "/tmp/b.spl", DependencyType.Import)
            graph.add_dependency("/tmp/b.spl", "/tmp/c.spl", DependencyType.Import)
            graph.add_dependency("/tmp/c.spl", "/tmp/a.spl", DependencyType.Import)

            has_cycle = graph.has_cycle()
            expect has_cycle

        it "computes topological order":
            graph = DependencyGraph.new()

            graph.add_dependency("/tmp/a.spl", "/tmp/b.spl", DependencyType.Import)
            graph.add_dependency("/tmp/b.spl", "/tmp/c.spl", DependencyType.Import)

            order = graph.topological_sort()

            # c should come before b, b before a
            idx_c = order.index("/tmp/c.spl")
            idx_b = order.index("/tmp/b.spl")
            idx_a = order.index("/tmp/a.spl")

            expect idx_c < idx_b
            expect idx_b < idx_a

    context("Error Aggregation"):
        it "collects errors from multiple languages":
            aggregator = ErrorAggregator.new()

            # Add errors from different languages
            aggregator.add_error(Language.Simple, "syntax error", "/tmp/test.spl", 10)
            aggregator.add_error(Language.Rust, "type mismatch", "/tmp/lib.rs", 42)

            errors = aggregator.get_all_errors()
            expect errors.len() == 2

        it "normalizes error formats":
            aggregator = ErrorAggregator.new()

            # Different error formats from different compilers
            aggregator.add_error(Language.Simple, "error: undefined variable 'x'", "/tmp/a.spl", 5)
            aggregator.add_error(Language.Rust, "error[E0425]: cannot find value `x`", "/tmp/lib.rs", 10)

            normalized = aggregator.get_normalized_errors()

            # Both should be normalized to similar format
            expect normalized.len() == 2
            expect normalized[0].file.len() > 0
            expect normalized[0].line > 0

        it "groups errors by file":
            aggregator = ErrorAggregator.new()

            aggregator.add_error(Language.Simple, "error 1", "/tmp/test.spl", 10)
            aggregator.add_error(Language.Simple, "error 2", "/tmp/test.spl", 20)
            aggregator.add_error(Language.Rust, "error 3", "/tmp/lib.rs", 5)

            grouped = aggregator.group_by_file()

            expect grouped["/tmp/test.spl"].len() == 2
            expect grouped["/tmp/lib.rs"].len() == 1

    context("Test Runner"):
        it "creates test configuration":
            config = TestConfig.new()

            expect not config.parallel
            expect not config.fail_fast
            expect config.timeout_seconds == 300

        it "configures parallel execution":
            config = TestConfig {
                parallel: true,
                fail_fast: false,
                verbose: false,
                coverage: false,
                timeout_seconds: 300,
                filter_pattern: ""
            }

            expect config.parallel

        it "creates test result":
            result = TestRunResult {
                total_tests: 10,
                passed: 8,
                failed: 2,
                skipped: 0,
                duration_ms: 5000,
                failures: []
            }

            expect result.total_tests == 10
            expect result.passed == 8
            expect not result.is_success()

        it "generates test summary":
            result = TestRunResult {
                total_tests: 10,
                passed: 10,
                failed: 0,
                skipped: 0,
                duration_ms: 5000,
                failures: []
            }

            summary = result.summary()
            expect "10/10" in summary
            expect "passed" in summary

    context("Deployment Pipeline"):
        it "creates deployment pipeline":
            project = ProjectConfig {
                name: "test_app",
                root_path: "/tmp/app",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            pipeline = DeploymentPipeline.new(project, Environment.Production)

            expect pipeline.project.name == "test_app"
            expect pipeline.environment == Environment.Production

        it "adds pipeline stages":
            project = ProjectConfig {
                name: "test_app",
                root_path: "/tmp/app",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            pipeline = DeploymentPipeline.new(project, Environment.Staging)

            pipeline.add_stage("build", () -> Ok(()))
            pipeline.add_stage("test", () -> Ok(()))
            pipeline.add_stage("deploy", () -> Ok(()))

            expect pipeline.stages.len() == 3

        it "executes pipeline stages":
            project = ProjectConfig {
                name: "test_app",
                root_path: "/tmp/app",
                languages: [Language.Simple],
                version: "1.0.0"
            }

            pipeline = DeploymentPipeline.new(project, Environment.Development)

            stage_executed = false
            pipeline.add_stage("test_stage", () -> {
                stage_executed = true
                Ok(())
            })

            result = pipeline.execute()

            expect result.success
            expect stage_executed

    context("Compilation Modes"):
        it "supports debug mode":
            mode = CompilationMode.Debug
            expect mode == CompilationMode.Debug

        it "supports release mode":
            mode = CompilationMode.Release
            expect mode == CompilationMode.Release

    context("Language Support"):
        it "recognizes all supported languages":
            languages = [
                Language.Simple,
                Language.Rust,
                Language.Python,
                Language.JavaScript,
                Language.TypeScript,
                Language.Go,
                Language.C,
                Language.Cpp
            ]

            expect languages.len() == 8

        it "converts language to string":
            expect Language.Simple.to_string() == "Simple"
            expect Language.Rust.to_string() == "Rust"
            expect Language.Python.to_string() == "Python"

    context("Compilation Results"):
        it "creates successful compilation result":
            result = CompilationResult {
                status: "success",
                output_path: "/tmp/output",
                duration_ms: 1000,
                errors: [],
                warnings: []
            }

            expect result.status == "success"
            expect result.errors.len() == 0

        it "creates failed compilation result":
            result = CompilationResult {
                status: "error",
                output_path: "",
                duration_ms: 500,
                errors: ["syntax error on line 10"],
                warnings: []
            }

            expect result.status == "error"
            expect result.errors.len() == 1

    context("Integration"):
        it "builds multi-language project":
            # This would test actual compilation
            # Skipped in unit tests (requires real compilers)
            expect true

        it "runs multi-language tests":
            # This would test actual test execution
            # Skipped in unit tests (requires real test frameworks)
            expect true

        it "deploys multi-language project":
            # This would test actual deployment
            # Skipped in unit tests (requires deployment infrastructure)
            expect true
