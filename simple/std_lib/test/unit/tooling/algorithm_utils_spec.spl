# Tests for Algorithm utilities

use tooling.algorithm_utils.*

# =====================================
# Sorting Algorithm Tests
# =====================================

fn test_bubble_sort_simple():
    val unsorted = [3, 1, 4, 1, 5, 9, 2, 6]
    val sorted = bubble_sort(unsorted)
    assert(is_sorted(sorted))
    assert(sorted[0] == 1)
    assert(sorted[sorted.len() - 1] == 9)

fn test_bubble_sort_already_sorted():
    val list = [1, 2, 3, 4, 5]
    val sorted = bubble_sort(list)
    assert(lists_equal(sorted, list))

fn test_bubble_sort_reverse():
    val list = [5, 4, 3, 2, 1]
    val sorted = bubble_sort(list)
    assert(sorted[0] == 1)
    assert(sorted[4] == 5)

fn test_selection_sort():
    val unsorted = [64, 25, 12, 22, 11]
    val sorted = selection_sort(unsorted)
    assert(is_sorted(sorted))
    assert(sorted[0] == 11)
    assert(sorted[4] == 64)

fn test_insertion_sort():
    val unsorted = [12, 11, 13, 5, 6]
    val sorted = insertion_sort(unsorted)
    assert(is_sorted(sorted))
    assert(sorted[0] == 5)

fn test_quick_sort():
    val unsorted = [10, 7, 8, 9, 1, 5]
    val sorted = quick_sort(unsorted)
    assert(is_sorted(sorted))
    assert(sorted[0] == 1)
    assert(sorted[5] == 10)

fn test_merge_sort():
    val unsorted = [38, 27, 43, 3, 9, 82, 10]
    val sorted = merge_sort(unsorted)
    assert(is_sorted(sorted))
    assert(sorted[0] == 3)

fn test_merge_sorted_lists():
    val left = [1, 3, 5]
    val right = [2, 4, 6]
    val merged = merge_sorted(left, right)
    assert(merged == [1, 2, 3, 4, 5, 6])

fn test_is_sorted_true():
    assert(is_sorted([1, 2, 3, 4, 5]))

fn test_is_sorted_false():
    assert(not is_sorted([1, 3, 2, 4, 5]))

fn test_is_sorted_empty():
    assert(is_sorted([]))

# =====================================
# Searching Algorithm Tests
# =====================================

fn test_linear_search_found():
    val list = [10, 20, 30, 40, 50]
    match linear_search(list, 30):
        Some(idx) => assert(idx == 2)
        None => assert(false)

fn test_linear_search_not_found():
    val list = [10, 20, 30, 40, 50]
    match linear_search(list, 25):
        Some(_) => assert(false)
        None => assert(true)

fn test_binary_search_found():
    val list = [1, 3, 5, 7, 9, 11, 13]
    match binary_search(list, 7):
        Some(idx) => assert(idx == 3)
        None => assert(false)

fn test_binary_search_not_found():
    val list = [1, 3, 5, 7, 9, 11, 13]
    match binary_search(list, 6):
        Some(_) => assert(false)
        None => assert(true)

fn test_find_min():
    val list = [5, 2, 8, 1, 9]
    match find_min(list):
        Some(min_value) => assert(min_value == 1)
        None => assert(false)

fn test_find_max():
    val list = [5, 2, 8, 1, 9]
    match find_max(list):
        Some(max_value) => assert(max_value == 9)
        None => assert(false)

fn test_find_min_index():
    val list = [5, 2, 8, 1, 9]
    match find_min_index(list):
        Some(idx) => assert(idx == 3)
        None => assert(false)

fn test_find_max_index():
    val list = [5, 2, 8, 1, 9]
    match find_max_index(list):
        Some(idx) => assert(idx == 4)
        None => assert(false)

# =====================================
# List Manipulation Tests
# =====================================

fn test_reverse_list():
    val list = [1, 2, 3, 4, 5]
    val reversed = reverse_list(list)
    assert(reversed == [5, 4, 3, 2, 1])

fn test_rotate_left():
    val list = [1, 2, 3, 4, 5]
    val rotated = rotate_left(list, 2)
    assert(rotated == [3, 4, 5, 1, 2])

fn test_rotate_right():
    val list = [1, 2, 3, 4, 5]
    val rotated = rotate_right(list, 2)
    assert(rotated == [4, 5, 1, 2, 3])

fn test_remove_duplicates():
    val list = [1, 2, 2, 3, 3, 3, 4]
    val unique = remove_duplicates(list)
    assert(unique == [1, 2, 3, 4])

fn test_partition():
    val list = [1, 2, 3, 4, 5, 6]
    val (evens, odds) = partition(list, \x: x % 2 == 0)
    assert(evens == [2, 4, 6])
    assert(odds == [1, 3, 5])

fn test_take():
    val list = [1, 2, 3, 4, 5]
    val taken = take(list, 3)
    assert(taken == [1, 2, 3])

fn test_drop():
    val list = [1, 2, 3, 4, 5]
    val dropped = drop(list, 2)
    assert(dropped == [3, 4, 5])

fn test_take_while():
    val list = [1, 2, 3, 4, 5]
    val taken = take_while(list, \x: x < 4)
    assert(taken == [1, 2, 3])

fn test_drop_while():
    val list = [1, 2, 3, 4, 5]
    val dropped = drop_while(list, \x: x < 3)
    assert(dropped == [3, 4, 5])

# =====================================
# Statistical Function Tests
# =====================================

fn test_sum():
    val list = [1, 2, 3, 4, 5]
    assert(sum(list) == 15)

fn test_sum_empty():
    val list: List<i32> = []
    assert(sum(list) == 0)

fn test_average():
    val list = [10, 20, 30, 40, 50]
    match average(list):
        Some(avg) => assert(avg == 30)
        None => assert(false)

fn test_average_empty():
    val list: List<i32> = []
    match average(list):
        Some(_) => assert(false)
        None => assert(true)

fn test_median_odd():
    val list = [1, 2, 3, 4, 5]
    match median(list):
        Some(med) => assert(med == 3)
        None => assert(false)

fn test_median_even():
    val list = [1, 2, 3, 4]
    match median(list):
        Some(med) => assert(med == 2)  # (2+3)/2 = 2 (integer division)
        None => assert(false)

fn test_mode():
    val list = [1, 2, 2, 3, 3, 3, 4]
    match mode(list):
        Some(m) => assert(m == 3)
        None => assert(false)

fn test_range_value():
    val list = [1, 5, 3, 9, 2]
    match range_value(list):
        Some(r) => assert(r == 8)  # 9 - 1
        None => assert(false)

# =====================================
# Combinatorics Tests
# =====================================

fn test_all_pairs():
    val list = [1, 2, 3]
    val pairs = all_pairs(list)
    assert(pairs.len() == 3)  # (1,2), (1,3), (2,3)

fn test_cartesian_product():
    val list1 = [1, 2]
    val list2 = [3, 4]
    val product = cartesian_product(list1, list2)
    assert(product.len() == 4)  # (1,3), (1,4), (2,3), (2,4)

fn test_flatten():
    val nested = [[1, 2], [3, 4], [5]]
    val flattened = flatten(nested)
    assert(flattened == [1, 2, 3, 4, 5])

fn test_chunk():
    val list = [1, 2, 3, 4, 5, 6, 7]
    val chunks = chunk(list, 3)
    assert(chunks.len() == 3)
    assert(chunks[0] == [1, 2, 3])
    assert(chunks[1] == [4, 5, 6])
    assert(chunks[2] == [7])

fn test_sliding_window():
    val list = [1, 2, 3, 4, 5]
    val windows = sliding_window(list, 3)
    assert(windows.len() == 3)
    assert(windows[0] == [1, 2, 3])
    assert(windows[1] == [2, 3, 4])
    assert(windows[2] == [3, 4, 5])

fn test_interleave():
    val list1 = [1, 3, 5]
    val list2 = [2, 4, 6]
    val interleaved = interleave(list1, list2)
    assert(interleaved == [1, 2, 3, 4, 5, 6])

fn test_interleave_different_lengths():
    val list1 = [1, 2]
    val list2 = [3, 4, 5]
    val interleaved = interleave(list1, list2)
    assert(interleaved == [1, 3, 2, 4, 5])

# =====================================
# Comparison Utility Tests
# =====================================

fn test_lists_equal_true():
    assert(lists_equal([1, 2, 3], [1, 2, 3]))

fn test_lists_equal_false():
    assert(not lists_equal([1, 2, 3], [1, 2, 4]))

fn test_lists_equal_different_length():
    assert(not lists_equal([1, 2], [1, 2, 3]))

fn test_is_prefix_true():
    assert(is_prefix([1, 2], [1, 2, 3, 4]))

fn test_is_prefix_false():
    assert(not is_prefix([1, 3], [1, 2, 3, 4]))

fn test_is_suffix_true():
    assert(is_suffix([3, 4], [1, 2, 3, 4]))

fn test_is_suffix_false():
    assert(not is_suffix([2, 3], [1, 2, 3, 4]))

fn test_find_sublist_found():
    val haystack = [1, 2, 3, 4, 5, 6]
    val needle = [3, 4, 5]
    match find_sublist(haystack, needle):
        Some(idx) => assert(idx == 2)
        None => assert(false)

fn test_find_sublist_not_found():
    val haystack = [1, 2, 3, 4, 5]
    val needle = [3, 5]
    match find_sublist(haystack, needle):
        Some(_) => assert(false)
        None => assert(true)

fn test_count_occurrences():
    val list = [1, 2, 2, 3, 2, 4]
    assert(count_occurrences(list, 2) == 3)

fn test_count_occurrences_none():
    val list = [1, 2, 3, 4]
    assert(count_occurrences(list, 5) == 0)

fn test_find_all_indices():
    val list = [1, 2, 2, 3, 2, 4]
    val indices = find_all_indices(list, 2)
    assert(indices == [1, 2, 4])

fn test_find_all_indices_none():
    val list = [1, 2, 3, 4]
    val indices = find_all_indices(list, 5)
    assert(indices.len() == 0)

# =====================================
# Edge Case Tests
# =====================================

fn test_sort_empty_list():
    val empty: List<i32> = []
    val sorted = quick_sort(empty)
    assert(sorted.len() == 0)

fn test_sort_single_element():
    val single = [42]
    val sorted = merge_sort(single)
    assert(sorted == [42])

fn test_reverse_empty():
    val empty: List<i32> = []
    val reversed = reverse_list(empty)
    assert(reversed.len() == 0)

fn test_chunk_empty():
    val empty: List<i32> = []
    val chunks = chunk(empty, 3)
    assert(chunks.len() == 0)

fn test_take_more_than_length():
    val list = [1, 2, 3]
    val taken = take(list, 10)
    assert(taken == [1, 2, 3])

fn test_drop_more_than_length():
    val list = [1, 2, 3]
    val dropped = drop(list, 10)
    assert(dropped.len() == 0)

# =====================================
# Performance Comparison Tests
# =====================================

fn test_all_sorts_produce_same_result():
    val unsorted = [5, 2, 8, 1, 9, 3]

    val bubble = bubble_sort(unsorted)
    val selection = selection_sort(unsorted)
    val insertion = insertion_sort(unsorted)
    val quick = quick_sort(unsorted)
    val merge = merge_sort(unsorted)

    assert(lists_equal(bubble, selection))
    assert(lists_equal(selection, insertion))
    assert(lists_equal(insertion, quick))
    assert(lists_equal(quick, merge))

# =====================================
# Complex Scenario Tests
# =====================================

fn test_sort_with_duplicates():
    val list = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]
    val sorted = quick_sort(list)
    assert(is_sorted(sorted))
    assert(sorted[0] == 1)
    assert(sorted[1] == 1)

fn test_partition_then_sort():
    val list = [5, 2, 8, 1, 9, 3, 6, 4, 7]
    val (less_than_five, greater_or_equal) = partition(list, \x: x < 5)

    val sorted_less = quick_sort(less_than_five)
    val sorted_greater = quick_sort(greater_or_equal)

    assert(is_sorted(sorted_less))
    assert(is_sorted(sorted_greater))

fn test_sliding_window_then_sum():
    val list = [1, 2, 3, 4, 5]
    val windows = sliding_window(list, 3)

    var sums = []
    for window in windows:
        sums.push(sum(window))

    assert(sums == [6, 9, 12])  # 1+2+3, 2+3+4, 3+4+5

fn test_chunk_then_sum():
    val list = [1, 2, 3, 4, 5, 6]
    val chunks = chunk(list, 2)

    var sums = []
    for chunk_item in chunks:
        sums.push(sum(chunk_item))

    assert(sums == [3, 7, 11])  # 1+2, 3+4, 5+6
