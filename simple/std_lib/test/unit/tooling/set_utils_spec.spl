# Tests for set utilities

use tooling.set_utils.*

# =====================================
# Basic Set Operations Tests
# =====================================

fn test_contains():
    val set = [1, 2, 3, 4, 5]
    assert(contains(set, 3))
    assert(not contains(set, 10))

fn test_add():
    val set = [1, 2, 3]
    val result = add(set, 4)
    assert(contains(result, 4))
    assert(result.len() == 4)

    # Adding existing element shouldn't duplicate
    val result2 = add(set, 2)
    assert(result2.len() == 3)

fn test_remove():
    val set = [1, 2, 3, 4]
    val result = remove(set, 3)
    assert(not contains(result, 3))
    assert(result.len() == 3)

# =====================================
# Set Algebra Tests
# =====================================

fn test_set_union():
    val set1 = [1, 2, 3]
    val set2 = [3, 4, 5]
    val result = set_union(set1, set2)

    assert(contains(result, 1))
    assert(contains(result, 2))
    assert(contains(result, 3))
    assert(contains(result, 4))
    assert(contains(result, 5))
    assert(result.len() == 5)

fn test_set_intersection():
    val set1 = [1, 2, 3, 4]
    val set2 = [3, 4, 5, 6]
    val result = set_intersection(set1, set2)

    assert(contains(result, 3))
    assert(contains(result, 4))
    assert(result.len() == 2)

fn test_set_difference():
    val set1 = [1, 2, 3, 4]
    val set2 = [3, 4, 5]
    val result = set_difference(set1, set2)

    assert(contains(result, 1))
    assert(contains(result, 2))
    assert(not contains(result, 3))
    assert(result.len() == 2)

fn test_symmetric_set_difference():
    val set1 = [1, 2, 3]
    val set2 = [2, 3, 4]
    val result = symmetric_set_difference(set1, set2)

    assert(contains(result, 1))
    assert(contains(result, 4))
    assert(not contains(result, 2))
    assert(not contains(result, 3))

# =====================================
# Set Predicates Tests
# =====================================

fn test_is_subset():
    val set1 = [1, 2]
    val set2 = [1, 2, 3, 4]

    assert(is_subset(set1, set2))
    assert(not is_subset(set2, set1))

fn test_is_superset():
    val set1 = [1, 2, 3, 4]
    val set2 = [2, 3]

    assert(is_superset(set1, set2))
    assert(not is_superset(set2, set1))

fn test_is_disjoint():
    val set1 = [1, 2, 3]
    val set2 = [4, 5, 6]
    val set3 = [3, 4, 5]

    assert(is_disjoint(set1, set2))
    assert(not is_disjoint(set1, set3))

# =====================================
# Set Properties Tests
# =====================================

fn test_cardinality():
    val set = [1, 2, 3, 4, 5]
    assert(cardinality(set) == 5)

fn test_power_set_small():
    val set = [1, 2]
    val result = power_set(set)

    # Power set of {1,2} is {∅, {1}, {2}, {1,2}}
    assert(result.len() == 4)

fn test_power_set_empty():
    val empty: List<i32> = []
    val result = power_set(empty)

    # Power set of ∅ is {∅}
    assert(result.len() == 1)

fn test_power_set_too_large():
    val large = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    val result = power_set(large)

    # Should return empty for too large sets
    assert(result.len() == 1)  # Just [[]]

fn test_cartesian_product():
    val set1 = [1, 2]
    val set2 = ["a", "b"]
    val result = cartesian_product(set1, set2)

    # Should have 2 * 2 = 4 pairs
    assert(result.len() == 4)

# =====================================
# Multiset Operations Tests
# =====================================

fn test_count_occurrences():
    val bag = [1, 2, 2, 3, 3, 3]
    assert(count_occurrences(bag, 1) == 1)
    assert(count_occurrences(bag, 2) == 2)
    assert(count_occurrences(bag, 3) == 3)
    assert(count_occurrences(bag, 4) == 0)

fn test_multiset_set_union():
    val bag1 = [1, 1, 2]
    val bag2 = [1, 2, 2]
    val result = multiset_set_union(bag1, bag2)

    # Max count: 1 appears 2 times, 2 appears 2 times
    assert(count_occurrences(result, 1) == 2)
    assert(count_occurrences(result, 2) == 2)

fn test_multiset_set_intersection():
    val bag1 = [1, 1, 2, 2, 2]
    val bag2 = [1, 2, 2]
    val result = multiset_set_intersection(bag1, bag2)

    # Min count: 1 appears 1 time, 2 appears 2 times
    assert(count_occurrences(result, 1) == 1)
    assert(count_occurrences(result, 2) == 2)

fn test_unique():
    val list = [1, 2, 2, 3, 3, 3]
    val result = unique(list)

    assert(result.len() == 3)
    assert(contains(result, 1))
    assert(contains(result, 2))
    assert(contains(result, 3))

# =====================================
# Partition Tests
# =====================================

fn test_partition_by():
    val list = [1, 2, 3, 4, 5, 6]
    val (evens, odds) = partition_by(list, \x: x % 2 == 0)

    assert(evens.len() == 3)
    assert(odds.len() == 3)

fn test_group_by():
    val list = [1, 2, 3, 4, 5, 6]
    val groups = group_by(list, \x: x % 3)

    # Should have 3 groups (0, 1, 2)
    assert(groups.len() == 3)

# =====================================
# Frequency Analysis Tests
# =====================================

fn test_frequency_count():
    val list = [1, 2, 2, 3, 3, 3]
    val freqs = frequency_count(list)

    assert(freqs.len() == 3)

fn test_most_common():
    val list = [1, 2, 2, 3, 3, 3]
    match most_common(list):
        Some(item) =>
            assert(item == 3)
        None =>
            assert(false)

fn test_most_common_empty():
    val empty: List<i32> = []
    match most_common(empty):
        Some(_) =>
            assert(false)
        None =>
            assert(true)

fn test_least_common():
    val list = [1, 2, 2, 3, 3, 3]
    match least_common(list):
        Some(item) =>
            assert(item == 1)
        None =>
            assert(false)

# =====================================
# Ranking Tests
# =====================================

fn test_rank():
    val sorted = [10, 20, 30, 40, 50]
    match rank(sorted, 30):
        Some(idx) =>
            assert(idx == 2)
        None =>
            assert(false)

fn test_rank_not_found():
    val sorted = [10, 20, 30]
    match rank(sorted, 100):
        Some(_) =>
            assert(false)
        None =>
            assert(true)

fn test_percentile_rank():
    val sorted = [10, 20, 30, 40, 50]
    match percentile_rank(sorted, 30):
        Some(pct) =>
            # Index 2 out of 5 = 40th percentile
            assert(pct > 39.0 and pct < 41.0)
        None =>
            assert(false)

# =====================================
# Sampling Tests
# =====================================

fn test_sample_every_nth():
    val list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    val result = sample_every_nth(list, 3)

    assert(result.len() == 4)  # 1, 4, 7, 10
    assert(result[0] == 1)
    assert(result[1] == 4)
    assert(result[2] == 7)

fn test_take():
    val list = [1, 2, 3, 4, 5]
    val result = take(list, 3)

    assert(result.len() == 3)
    assert(result[0] == 1)
    assert(result[1] == 2)
    assert(result[2] == 3)

fn test_take_more_than_length():
    val list = [1, 2, 3]
    val result = take(list, 10)
    assert(result.len() == 3)

fn test_skip():
    val list = [1, 2, 3, 4, 5]
    val result = skip(list, 2)

    assert(result.len() == 3)
    assert(result[0] == 3)
    assert(result[1] == 4)

fn test_take_while():
    val list = [1, 2, 3, 4, 5]
    val result = take_while(list, \x: x < 4)

    assert(result.len() == 3)
    assert(result[0] == 1)
    assert(result[1] == 2)
    assert(result[2] == 3)

fn test_skip_while():
    val list = [1, 2, 3, 4, 5]
    val result = skip_while(list, \x: x < 3)

    assert(result.len() == 3)
    assert(result[0] == 3)
    assert(result[1] == 4)
    assert(result[2] == 5)
