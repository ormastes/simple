# BDD Tests for DateTime Module
# Feature #210-219: Date and Time features

use spec.describe
use spec.it
use spec.expect
use datetime

describe("DateTime module"):
    describe("Duration"):
        it("should create duration from components"):
            let d = Duration.new(days=1, hours=2, minutes=30, seconds=45)

            expect(d.days).to_equal(1)
            expect(d.seconds).to_be_greater_than(0)

        it("should normalize duration components"):
            let d = Duration.new(hours=25, minutes=90)

            # 25 hours = 1 day + 1 hour = 1 day + 3600 seconds
            # 90 minutes = 1 hour + 30 minutes = 5400 seconds
            # Total: 1 day + 8400 seconds (2 hours 20 minutes)
            expect(d.days).to_equal(1)
            expect(d.seconds).to_equal(9000)  # 2.5 hours in seconds

        it("should calculate total seconds"):
            let d = Duration.new(days=1, hours=2, minutes=30)
            let total = d.total_seconds()

            # 1 day = 86400, 2 hours = 7200, 30 min = 1800
            # Total = 95400
            expect(total).to_equal(95400)

        it("should add durations"):
            let d1 = Duration.new(hours=1, minutes=30)
            let d2 = Duration.new(hours=2, minutes=45)
            let result = d1.add(d2)

            expect(result.total_seconds()).to_equal(15300)  # 4h 15m = 15300s

        it("should subtract durations"):
            let d1 = Duration.new(hours=5)
            let d2 = Duration.new(hours=2)
            let result = d1.subtract(d2)

            expect(result.total_seconds()).to_equal(10800)  # 3 hours

        it("should multiply duration by scalar"):
            let d = Duration.new(hours=2, minutes=30)
            let result = d.multiply(3)

            expect(result.total_seconds()).to_equal(27000)  # 7.5 hours

    describe("Time"):
        it("should create time with hour, minute, second"):
            let t = Time.new(14, 30, 45)

            expect(t.hour).to_equal(14)
            expect(t.minute).to_equal(30)
            expect(t.second).to_equal(45)

        it("should validate hour range"):
            let t = Time.new(25, 0, 0)  # Invalid hour

            expect(t.hour).to_equal(0)  # Should default to 0

        it("should convert to seconds since midnight"):
            let t = Time.new(2, 30, 15)
            let seconds = t.to_seconds()

            # 2*3600 + 30*60 + 15 = 7200 + 1800 + 15 = 9015
            expect(seconds).to_equal(9015)

        it("should format as HH:MM:SS"):
            let t = Time.new(9, 5, 3)
            let formatted = t.to_string()

            expect(formatted).to_equal("09:05:03")

        it("should format with microseconds"):
            let t = Time.new(14, 30, 45, 123456)
            let iso = t.to_iso_format()

            expect(iso).to_contain("14:30:45")
            expect(iso).to_contain("123456")

    describe("Date"):
        it("should create date with year, month, day"):
            let d = Date.new(2025, 12, 29)

            expect(d.year).to_equal(2025)
            expect(d.month).to_equal(12)
            expect(d.day).to_equal(29)

        it("should detect leap years"):
            expect(Date.is_leap_year(2000)).to_be_true()   # Divisible by 400
            expect(Date.is_leap_year(1900)).to_be_false()  # Divisible by 100 but not 400
            expect(Date.is_leap_year(2024)).to_be_true()   # Divisible by 4
            expect(Date.is_leap_year(2023)).to_be_false()  # Not divisible by 4

        it("should calculate days in month"):
            let jan = Date.new(2025, 1, 1)
            let feb_leap = Date.new(2024, 2, 1)
            let feb_normal = Date.new(2025, 2, 1)
            let april = Date.new(2025, 4, 1)

            expect(jan.days_in_month()).to_equal(31)
            expect(feb_leap.days_in_month()).to_equal(29)
            expect(feb_normal.days_in_month()).to_equal(28)
            expect(april.days_in_month()).to_equal(30)

        it("should calculate weekday"):
            # 2025-12-29 is a Monday
            let d = Date.new(2025, 12, 29)

            expect(d.weekday()).to_equal(0)  # Monday
            expect(d.weekday_name()).to_equal("Monday")

        it("should format as ISO date"):
            let d = Date.new(2025, 3, 5)
            let iso = d.to_iso_format()

            expect(iso).to_equal("2025-03-05")

        it("should add days"):
            let d = Date.new(2025, 1, 15)
            let result = d.add_days(10)

            expect(result.day).to_equal(25)

    describe("DateTime"):
        it("should create datetime with all components"):
            let dt = DateTime.new(2025, 12, 29, 14, 30, 45, 123456)

            expect(dt.year).to_equal(2025)
            expect(dt.month).to_equal(12)
            expect(dt.day).to_equal(29)
            expect(dt.hour).to_equal(14)
            expect(dt.minute).to_equal(30)
            expect(dt.second).to_equal(45)
            expect(dt.microsecond).to_equal(123456)

        it("should extract date component"):
            let dt = DateTime.new(2025, 12, 29, 14, 30, 45)
            let d = dt.date()

            expect(d.year).to_equal(2025)
            expect(d.month).to_equal(12)
            expect(d.day).to_equal(29)

        it("should extract time component"):
            let dt = DateTime.new(2025, 12, 29, 14, 30, 45, 123456)
            let t = dt.time()

            expect(t.hour).to_equal(14)
            expect(t.minute).to_equal(30)
            expect(t.second).to_equal(45)
            expect(t.microsecond).to_equal(123456)

        it("should add duration to datetime"):
            let dt = DateTime.new(2025, 1, 15, 10, 0, 0)
            let duration = Duration.new(days=5, hours=3)
            let result = dt.add(duration)

            expect(result.day).to_equal(20)
            expect(result.hour).to_equal(13)

        it("should format as ISO 8601"):
            let dt = DateTime.new(2025, 3, 5, 14, 30, 45)
            let iso = dt.to_iso_format()

            expect(iso).to_equal("2025-03-05T14:30:45")

        it("should format with custom format string"):
            let dt = DateTime.new(2025, 12, 29, 14, 30, 45)
            let formatted = dt.format("%Y-%m-%d %H:%M:%S")

            expect(formatted).to_equal("2025-12-29 14:30:45")

        it("should handle year format"):
            let dt = DateTime.new(2025, 1, 1, 0, 0, 0)
            let year = dt.format("%Y")

            expect(year).to_equal("2025")

        it("should handle month format with leading zero"):
            let dt = DateTime.new(2025, 3, 1, 0, 0, 0)
            let month = dt.format("%m")

            expect(month).to_equal("03")

# Feature metadata registration
use spec.feature_doc.FeatureMetadata

let datetime_test_features = [
    FeatureMetadata {
        id: 210,
        name: "DateTime Type",
        category: "Date and Time",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/host/async_nogc_mut/datetime.spl"],
        tests: ["simple/std_lib/test/unit/host/datetime_spec.spl"],
        description: "Date and time representation with ISO 8601 support.",
        code_examples: ['DateTime.now()', 'DateTime.new(2025, 12, 29, 14, 30, 0)'],
        dependencies: [],
        required_by: [211, 212, 213],
        notes: "BDD test-driven implementation in progress"
    },

    FeatureMetadata {
        id: 211,
        name: "Date Type",
        category: "Date and Time",
        difficulty: 2,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/host/async_nogc_mut/datetime.spl"],
        tests: ["simple/std_lib/test/unit/host/datetime_spec.spl"],
        description: "Date-only representation with weekday calculation and leap year support.",
        code_examples: ['Date.today()', 'Date.new(2025, 12, 29)', 'date.weekday_name()'],
        dependencies: [210],
        required_by: [],
        notes: "BDD test-driven implementation in progress"
    },

    FeatureMetadata {
        id: 212,
        name: "Time Type",
        category: "Date and Time",
        difficulty: 2,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/host/async_nogc_mut/datetime.spl"],
        tests: ["simple/std_lib/test/unit/host/datetime_spec.spl"],
        description: "Time-only representation with microsecond precision.",
        code_examples: ['Time.now()', 'Time.new(14, 30, 0)', 'time.to_iso_format()'],
        dependencies: [210],
        required_by: [],
        notes: "BDD test-driven implementation in progress"
    },

    FeatureMetadata {
        id: 213,
        name: "Duration Type",
        category: "Date and Time",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/host/async_nogc_mut/datetime.spl"],
        tests: ["simple/std_lib/test/unit/host/datetime_spec.spl"],
        description: "Time duration for date/time arithmetic with automatic normalization.",
        code_examples: ['Duration.new(hours=2, minutes=30)', 'dt + duration', 'd1.add(d2)'],
        dependencies: [210],
        required_by: [214],
        notes: "BDD test-driven implementation with add, subtract, multiply"
    }
]

# Register features when test runs
for meta in datetime_test_features:
    feature_metadata(meta)
