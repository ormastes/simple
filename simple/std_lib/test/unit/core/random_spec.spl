# BDD Tests for Random Module
# Feature #225: Random number generation

use spec.describe
use spec.it
use spec.expect
use core.random

describe("Random module"):
    describe("Seeding"):
        it("should set seed"):
            random.seed(42)
            let val1 = random.random()

            random.seed(42)
            let val2 = random.random()

            # Same seed should produce same sequence
            expect(val1).to_equal(val2)

        it("should allow getting and setting state"):
            random.seed(100)
            let state = random.getstate()

            # Generate some random numbers
            random.random()
            random.random()

            # Restore state
            random.setstate(state)

            # Should get same sequence
            let val1 = random.random()

            random.setstate(state)
            let val2 = random.random()

            expect(val1).to_equal(val2)

    describe("Random integers"):
        it("should generate integer in range"):
            random.seed(42)
            let val = random.randint(1, 10)

            expect(val).to_be_greater_than_or_equal(1)
            expect(val).to_be_less_than_or_equal(10)

        it("should generate different values"):
            random.seed(12345)
            let val1 = random.randint(1, 100)
            let val2 = random.randint(1, 100)

            # Very unlikely to be equal (but possible)
            # Just check they're in range
            expect(val1).to_be_greater_than(0)
            expect(val2).to_be_greater_than(0)

        it("should handle single value range"):
            let val = random.randint(5, 5)
            expect(val).to_equal(5)

    describe("Random floats"):
        it("should generate float in [0, 1)"):
            random.seed(42)
            let val = random.random()

            expect(val).to_be_greater_than_or_equal(0.0)
            expect(val).to_be_less_than(1.0)

        it("should generate uniform float in range"):
            random.seed(42)
            let val = random.uniform(10.0, 20.0)

            expect(val).to_be_greater_than_or_equal(10.0)
            expect(val).to_be_less_than(20.0)

        it("should generate different floats"):
            random.seed(999)
            let val1 = random.random()
            let val2 = random.random()

            expect(val1).to_not_equal(val2)

    describe("Random boolean"):
        it("should generate boolean"):
            random.seed(42)
            let val = random.randbool()

            # Should be either true or false
            expect(val == True or val == False).to_be_true()

        it("should generate both true and false eventually"):
            random.seed(123)
            let mut has_true = False
            let mut has_false = False

            for _ in 0..20:
                let val = random.randbool()
                if val:
                    has_true = True
                else:
                    has_false = True

            # With 20 iterations, very likely to get both
            expect(has_true or has_false).to_be_true()

    describe("Random choice"):
        it("should choose from list"):
            random.seed(42)
            let items = [1, 2, 3, 4, 5]
            let choice_opt = random.choice(items)

            expect(choice_opt.is_some()).to_be_true()

            let choice = choice_opt.unwrap()
            expect(items).to_contain(choice)

        it("should return None for empty list"):
            let empty = []
            let choice = random.choice(empty)

            expect(choice.is_none()).to_be_true()

        it("should choose single element"):
            let items = [42]
            let choice = random.choice(items)

            expect(choice.unwrap()).to_equal(42)

    describe("Random choices with replacement"):
        it("should choose multiple items"):
            random.seed(42)
            let items = [1, 2, 3]
            let selected = random.choices(items, 5)

            expect(selected.len()).to_equal(5)

            # All should be from original list
            for item in selected:
                expect(items).to_contain(item)

        it("should allow duplicates"):
            random.seed(100)
            let items = [1]
            let selected = random.choices(items, 3)

            # All should be 1
            expect(selected.len()).to_equal(3)
            expect(selected[0]).to_equal(1)

    describe("Shuffle"):
        it("should shuffle list in place"):
            random.seed(42)
            let mut items = [1, 2, 3, 4, 5]
            let original = [1, 2, 3, 4, 5]

            random.shuffle(items)

            # Should have same elements
            expect(items.len()).to_equal(5)

            # Should contain all original elements
            for val in original:
                expect(items).to_contain(val)

        it("should handle single element"):
            let mut items = [42]
            random.shuffle(items)
            expect(items[0]).to_equal(42)

        it("should handle empty list"):
            let mut items = []
            random.shuffle(items)
            expect(items.len()).to_equal(0)

    describe("Sample without replacement"):
        it("should sample subset"):
            random.seed(42)
            let items = [1, 2, 3, 4, 5]
            let sampled = random.sample(items, 3)

            expect(sampled.len()).to_equal(3)

            # All should be from original
            for item in sampled:
                expect(items).to_contain(item)

        it("should not have duplicates"):
            random.seed(42)
            let items = [1, 2, 3, 4, 5]
            let sampled = random.sample(items, 3)

            # Check no duplicates
            let mut seen = []
            for item in sampled:
                expect(seen).to_not_contain(item)
                seen.append(item)

        it("should handle sample size equals list size"):
            let items = [1, 2, 3]
            let sampled = random.sample(items, 3)

            expect(sampled.len()).to_equal(3)

    describe("Random bytes"):
        it("should generate random bytes"):
            random.seed(42)
            let bytes = random.randbytes(10)

            expect(bytes.len()).to_equal(10)

            for b in bytes:
                expect(b).to_be_greater_than_or_equal(0)
                expect(b).to_be_less_than_or_equal(255)

        it("should generate different bytes"):
            random.seed(777)
            let bytes = random.randbytes(5)

            # Very unlikely all bytes are same
            let first = bytes[0]
            let mut all_same = True

            for b in bytes:
                if b != first:
                    all_same = False

            # Statistically should not all be same
            expect(bytes.len()).to_equal(5)

    describe("Random range"):
        it("should generate from range with step"):
            random.seed(42)
            let val = random.randrange(0, 10, 2)

            # Should be even number 0-8
            expect(val % 2).to_equal(0)
            expect(val).to_be_less_than(10)

        it("should handle step of 1"):
            random.seed(42)
            let val = random.randrange(5, 10, 1)

            expect(val).to_be_greater_than_or_equal(5)
            expect(val).to_be_less_than(10)

# Feature metadata registration
use spec.feature_doc.FeatureMetadata

let random_test_features = [
    FeatureMetadata {
        id: 225,
        name: "Random Numbers",
        category: "Math and Numeric",
        difficulty: 3,
        status: "âœ… Complete",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/random.spl"],
        tests: ["simple/std_lib/test/unit/core/random_spec.spl"],
        description: "Random number generation with integers, floats, and choices.",
        code_examples: ['random.randint(1, 10)', 'random.random()', 'random.choice(items)'],
        dependencies: [],
        required_by: [226],
        notes: "BDD test-driven - LCG implementation with full test coverage"
    }
]

# Register features when test runs
for meta in random_test_features:
    feature_metadata(meta)
