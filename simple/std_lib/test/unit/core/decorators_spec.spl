# Decorator Tests
# Tests for built-in decorators: @cached, @logged, @deprecated, @timeout

use spec.*
use core.decorators.*

describe "@cached decorator":
    it "caches function results":
        call_count = 0

        @cached
        fn expensive(x: i64) -> i64:
            call_count = call_count + 1
            return x * x

        # First call - cache miss
        result1 = expensive(5)
        expect(result1).to_equal(25)
        expect(call_count).to_equal(1)

        # Second call with same arg - cache hit
        result2 = expensive(5)
        expect(result2).to_equal(25)
        expect(call_count).to_equal(1)  # Should still be 1

        # Different arg - cache miss
        result3 = expensive(10)
        expect(result3).to_equal(100)
        expect(call_count).to_equal(2)

    it "tracks cache statistics":
        @cached
        fn double(x: i64) -> i64:
            return x * 2

        double(5)   # miss
        double(5)   # hit
        double(10)  # miss
        double(5)   # hit

        info = double.cache_info()
        expect(info["hits"]).to_equal(2)
        expect(info["misses"]).to_equal(2)
        expect(info["size"]).to_equal(2)

    it "clears cache":
        @cached
        fn triple(x: i64) -> i64:
            return x * 3

        triple(5)
        triple(10)

        expect(triple.cache_info()["size"]).to_equal(2)

        triple.clear_cache()

        expect(triple.cache_info()["size"]).to_equal(0)
        expect(triple.cache_info()["hits"]).to_equal(0)


describe "@logged decorator":
    it "logs function calls and returns":
        @logged
        fn add(x: i64, y: i64) -> i64:
            return x + y

        result = add(10, 20)
        expect(result).to_equal(30)
        # Log output should be visible in test output


describe "@deprecated decorator":
    it "warns about deprecated functions":
        @deprecated("Use new_function() instead")
        fn old_function(x: i64) -> i64:
            return x + 1

        result = old_function(5)
        expect(result).to_equal(6)
        # Should print warning on first call

    it "warns only once":
        @deprecated()
        fn legacy_function(x: i64) -> i64:
            return x * 2

        legacy_function(1)  # Warning printed
        legacy_function(2)  # No warning
        legacy_function(3)  # No warning


describe "@timeout decorator":
    it "accepts timeout parameter":
        @timeout(5)
        fn slow_work():
            return 42

        result = slow_work()
        expect(result).to_equal(42)
        # Currently just logs timeout, doesn't enforce
