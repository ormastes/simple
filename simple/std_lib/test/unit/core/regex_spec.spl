# BDD Tests for Regex Module
# Feature #230-239: Regular expression features

use spec.describe
use spec.it
use spec.expect
use core.regex

describe("Regex module"):
    describe("Pattern compilation"):
        it("should compile a pattern"):
            let pattern = regex.compile("hello")
            expect(pattern.pattern).to_equal("hello")

        it("should compile empty pattern"):
            let pattern = regex.compile("")
            expect(pattern.pattern).to_equal("")

    describe("Literal matching"):
        it("should match at start of string"):
            let result = regex.match("hello", "hello world")
            expect(result.is_some()).to_be_true()

            let m = result.unwrap()
            expect(m.matched_text()).to_equal("hello")

        it("should not match if pattern not at start"):
            let result = regex.match("world", "hello world")
            expect(result.is_none()).to_be_true()

        it("should match empty string"):
            let result = regex.match("", "anything")
            expect(result.is_some()).to_be_true()

    describe("Search anywhere"):
        it("should find pattern in middle of string"):
            let result = regex.search("world", "hello world")
            expect(result.is_some()).to_be_true()

            let m = result.unwrap()
            expect(m.matched_text()).to_equal("world")
            expect(m.start).to_equal(6)

        it("should find pattern at start"):
            let result = regex.search("hello", "hello world")
            expect(result.is_some()).to_be_true()

        it("should return None if not found"):
            let result = regex.search("xyz", "hello world")
            expect(result.is_none()).to_be_true()

    describe("Full match"):
        it("should match entire string"):
            let result = regex.fullmatch("hello", "hello")
            expect(result.is_some()).to_be_true()

        it("should not match partial string"):
            let result = regex.fullmatch("hello", "hello world")
            expect(result.is_none()).to_be_true()

        it("should match empty string"):
            let result = regex.fullmatch("", "")
            expect(result.is_some()).to_be_true()

    describe("Find all matches"):
        it("should find all occurrences"):
            let matches = regex.findall("l", "hello")
            expect(matches.len()).to_equal(2)

        it("should find multiple word occurrences"):
            let matches = regex.findall("the", "the cat and the dog")
            expect(matches.len()).to_equal(2)

        it("should return empty list if no matches"):
            let matches = regex.findall("xyz", "hello world")
            expect(matches.len()).to_equal(0)

        it("should handle overlapping matches"):
            let matches = regex.findall("aa", "aaaa")
            # Non-overlapping: should find 2 matches
            expect(matches.len()).to_be_greater_than(0)

    describe("Substitution"):
        it("should replace all occurrences"):
            let result = regex.sub("cat", "dog", "the cat and the cat")
            expect(result).to_contain("dog")
            expect(result).to_not_contain("cat")

        it("should replace first N occurrences"):
            let result = regex.sub("cat", "dog", "cat cat cat", 2)
            # Should have one "cat" remaining
            expect(result).to_contain("dog")

        it("should handle no matches"):
            let result = regex.sub("xyz", "abc", "hello world")
            expect(result).to_equal("hello world")

    describe("Split by pattern"):
        it("should split by literal"):
            let parts = regex.split(",", "a,b,c")
            expect(parts.len()).to_equal(3)

        it("should split by whitespace"):
            let parts = regex.split(" ", "hello world test")
            expect(parts.len()).to_equal(3)

        it("should handle string with no separator"):
            let parts = regex.split(",", "hello")
            expect(parts.len()).to_equal(1)

    describe("Escape special characters"):
        it("should escape backslash"):
            let escaped = regex.escape("\\")
            expect(escaped).to_contain("\\\\")

        it("should escape dot"):
            let escaped = regex.escape(".")
            expect(escaped).to_equal("\\.")

        it("should escape multiple special chars"):
            let escaped = regex.escape("a.b*c+")
            expect(escaped).to_contain("\\.")
            expect(escaped).to_contain("\\*")
            expect(escaped).to_contain("\\+")

        it("should not escape regular characters"):
            let escaped = regex.escape("abc123")
            expect(escaped).to_equal("abc123")

    describe("Pattern building helpers"):
        it("should create digit pattern"):
            let pattern = regex.digit()
            expect(pattern).to_equal("[0-9]")

        it("should create word pattern"):
            let pattern = regex.word()
            expect(pattern).to_equal("[a-zA-Z0-9_]")

        it("should create whitespace pattern"):
            let pattern = regex.whitespace()
            expect(pattern).to_contain(" ")

        it("should create zero-or-more quantifier"):
            let pattern = regex.zero_or_more("a")
            expect(pattern).to_equal("a*")

        it("should create one-or-more quantifier"):
            let pattern = regex.one_or_more("a")
            expect(pattern).to_equal("a+")

        it("should create optional quantifier"):
            let pattern = regex.optional("a")
            expect(pattern).to_equal("a?")

        it("should create exact count quantifier"):
            let pattern = regex.exactly("a", 3)
            expect(pattern).to_contain("3")

        it("should create at-least quantifier"):
            let pattern = regex.at_least("a", 2)
            expect(pattern).to_contain("2")

        it("should create range quantifier"):
            let pattern = regex.between("a", 2, 5)
            expect(pattern).to_contain("2")
            expect(pattern).to_contain("5")

    describe("Anchor helpers"):
        it("should create start anchor"):
            let anchor = regex.start_of_line()
            expect(anchor).to_equal("^")

        it("should create end anchor"):
            let anchor = regex.end_of_line()
            expect(anchor).to_equal("$")

        it("should create word boundary"):
            let boundary = regex.word_boundary()
            expect(boundary).to_contain("b")

    describe("Match object"):
        it("should return matched text"):
            let m = Match.new("test", 0, 4)
            expect(m.matched_text()).to_equal("test")

        it("should return span"):
            let m = Match.new("test", 5, 9)
            let span = m.span()
            expect(span.0).to_equal(5)
            expect(span.1).to_equal(9)

        it("should handle groups"):
            let mut m = Match.new("test", 0, 4)
            m.groups.append("group1")
            m.groups.append("group2")

            expect(m.all_groups().len()).to_equal(2)

        it("should get group by index"):
            let mut m = Match.new("test", 0, 4)
            m.groups.append("first")

            let g = m.group(0)
            expect(g.is_some()).to_be_true()
            expect(g.unwrap()).to_equal("first")

        it("should return None for invalid group index"):
            let m = Match.new("test", 0, 4)
            let g = m.group(0)
            expect(g.is_none()).to_be_true()

    describe("Convenience functions"):
        it("should check if pattern matches"):
            expect(regex.is_match("hello", "hello world")).to_be_true()
            expect(regex.is_match("xyz", "hello world")).to_be_false()

        it("should extract text from match"):
            let m = Match.new("extracted", 0, 9)
            let text = regex.extract_text(m)
            expect(text).to_equal("extracted")

    describe("Compiled pattern methods"):
        it("should match using compiled pattern"):
            let pattern = regex.compile("test")
            let result = pattern.match("test123")
            expect(result.is_some()).to_be_true()

        it("should search using compiled pattern"):
            let pattern = regex.compile("world")
            let result = pattern.search("hello world")
            expect(result.is_some()).to_be_true()

        it("should fullmatch using compiled pattern"):
            let pattern = regex.compile("exact")
            expect(pattern.fullmatch("exact").is_some()).to_be_true()
            expect(pattern.fullmatch("exact match").is_none()).to_be_true()

        it("should findall using compiled pattern"):
            let pattern = regex.compile("o")
            let matches = pattern.findall("hello world")
            expect(matches.len()).to_equal(2)

        it("should substitute using compiled pattern"):
            let pattern = regex.compile("cat")
            let result = pattern.sub("dog", "the cat sat")
            expect(result).to_contain("dog")

        it("should split using compiled pattern"):
            let pattern = regex.compile(" ")
            let parts = pattern.split("a b c")
            expect(parts.len()).to_equal(3)

# Feature metadata registration
use spec.feature_doc.FeatureMetadata

let regex_test_features = [
    FeatureMetadata {
        id: 230,
        name: "Regex Compilation",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Compile and reuse regex patterns for performance.",
        code_examples: ['pattern = regex.compile("test")', 'pattern.match(text)'],
        dependencies: [],
        required_by: [231, 232, 233],
        notes: "BDD test-driven - literal matching implemented, full regex engine TODO"
    },

    FeatureMetadata {
        id: 231,
        name: "Pattern Matching",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Match patterns with match, search, and fullmatch operations.",
        code_examples: ['regex.match(pattern, text)', 'regex.search(pattern, text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - basic matching working"
    },

    FeatureMetadata {
        id: 233,
        name: "Find All Matches",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Find all pattern occurrences in string.",
        code_examples: ['regex.findall(pattern, text)', 'pattern.findall(text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - literal findall working"
    },

    FeatureMetadata {
        id: 234,
        name: "String Substitution",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Replace pattern matches with replacement text.",
        code_examples: ['regex.sub(pattern, replacement, text)', 'pattern.sub(repl, text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - basic substitution working"
    },

    FeatureMetadata {
        id: 235,
        name: "Split by Pattern",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Split string by regex pattern.",
        code_examples: ['regex.split(pattern, text)', 'pattern.split(text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - literal split working"
    }
]

# Register features when test runs
for meta in regex_test_features:
    feature_metadata(meta)
