# BDD Tests for Regex Module
# Feature #230-239: Regular expression features

use core.regex

describe "Regex module":
    describe "Pattern compilation":
        it "should compile a pattern":
            let pattern = regex.compile("hello")
            expect pattern.pattern == "hello"

        it "should compile empty pattern":
            let pattern = regex.compile("")
            expect pattern.pattern == ""

    describe "Literal matching":
        it "should match at start of string":
            let result = regex.match("hello", "hello world")
            expect result.is_some()

            let m = result.unwrap()
            expect m.matched_text() == "hello"

        it "should not match if pattern not at start":
            let result = regex.match("world", "hello world")
            expect result.is_none()

        it "should match empty string":
            let result = regex.match("", "anything")
            expect result.is_some()

    describe "Search anywhere":
        it "should find pattern in middle of string":
            let result = regex.search("world", "hello world")
            expect result.is_some()

            let m = result.unwrap()
            expect m.matched_text() == "world"
            expect m.start == 6

        it "should find pattern at start":
            let result = regex.search("hello", "hello world")
            expect result.is_some()

        it "should return None if not found":
            let result = regex.search("xyz", "hello world")
            expect result.is_none()

    describe "Full match":
        it "should match entire string":
            let result = regex.fullmatch("hello", "hello")
            expect result.is_some()

        it "should not match partial string":
            let result = regex.fullmatch("hello", "hello world")
            expect result.is_none()

        it "should match empty string":
            let result = regex.fullmatch("", "")
            expect result.is_some()

    describe "Find all matches":
        it "should find all occurrences":
            let matches = regex.findall("l", "hello")
            expect matches.len() == 2

        it "should find multiple word occurrences":
            let matches = regex.findall("the", "the cat and the dog")
            expect matches.len() == 2

        it "should return empty list if no matches":
            let matches = regex.findall("xyz", "hello world")
            expect matches.len() == 0

        it "should handle overlapping matches":
            let matches = regex.findall("aa", "aaaa")
            # Non-overlapping: should find 2 matches
            expect matches.len() > 0

    describe "Substitution":
        it "should replace all occurrences":
            let result = regex.sub("cat", "dog", "the cat and the cat")
            expect "dog" in result
            expect(result).to_not_contain("cat")

        it "should replace first N occurrences":
            let result = regex.sub("cat", "dog", "cat cat cat", 2)
            # Should have one "cat" remaining
            expect "dog" in result

        it "should handle no matches":
            let result = regex.sub("xyz", "abc", "hello world")
            expect result == "hello world"

    describe "Split by pattern":
        it "should split by literal":
            let parts = regex.split(",", "a,b,c")
            expect parts.len() == 3

        it "should split by whitespace":
            let parts = regex.split(" ", "hello world test")
            expect parts.len() == 3

        it "should handle string with no separator":
            let parts = regex.split(",", "hello")
            expect parts.len() == 1

    describe "Escape special characters":
        it "should escape backslash":
            let escaped = regex.escape("\\")
            expect "\\\\" in escaped

        it "should escape dot":
            let escaped = regex.escape(".")
            expect escaped == "\\."

        it "should escape multiple special chars":
            let escaped = regex.escape("a.b*c+")
            expect "\\." in escaped
            expect "\\*" in escaped
            expect "\\+" in escaped

        it "should not escape regular characters":
            let escaped = regex.escape("abc123")
            expect escaped == "abc123"

    describe "Pattern building helpers":
        it "should create digit pattern":
            let pattern = regex.digit()
            expect pattern == "[0-9]"

        it "should create word pattern":
            let pattern = regex.word()
            expect pattern == "[a-zA-Z0-9_]"

        it "should create whitespace pattern":
            let pattern = regex.whitespace()
            expect " " in pattern

        it "should create zero-or-more quantifier":
            let pattern = regex.zero_or_more("a")
            expect pattern == "a*"

        it "should create one-or-more quantifier":
            let pattern = regex.one_or_more("a")
            expect pattern == "a+"

        it "should create optional quantifier":
            let pattern = regex.optional("a")
            expect pattern == "a?"

        it "should create exact count quantifier":
            let pattern = regex.exactly("a", 3)
            expect "3" in pattern

        it "should create at-least quantifier":
            let pattern = regex.at_least("a", 2)
            expect "2" in pattern

        it "should create range quantifier":
            let pattern = regex.between("a", 2, 5)
            expect "2" in pattern
            expect "5" in pattern

    describe "Anchor helpers":
        it "should create start anchor":
            let anchor = regex.start_of_line()
            expect anchor == "^"

        it "should create end anchor":
            let anchor = regex.end_of_line()
            expect anchor == "$"

        it "should create word boundary":
            let boundary = regex.word_boundary()
            expect "b" in boundary

    describe "Match object":
        it "should return matched text":
            let m = Match.new("test", 0, 4)
            expect m.matched_text() == "test"

        it "should return span":
            let m = Match.new("test", 5, 9)
            let span = m.span()
            expect span.0 == 5
            expect span.1 == 9

        it "should handle groups":
            let mut m = Match.new("test", 0, 4)
            m.groups.append("group1")
            m.groups.append("group2")

            expect m.all_groups().len() == 2

        it "should get group by index":
            let mut m = Match.new("test", 0, 4)
            m.groups.append("first")

            let g = m.group(0)
            expect g.is_some()
            expect g.unwrap() == "first"

        it "should return None for invalid group index":
            let m = Match.new("test", 0, 4)
            let g = m.group(0)
            expect g.is_none()

    describe "Convenience functions":
        it "should check if pattern matches":
            expect regex.is_match("hello", "hello world")
            expect not regex.is_match("xyz", "hello world")

        it "should extract text from match":
            let m = Match.new("extracted", 0, 9)
            let text = regex.extract_text(m)
            expect text == "extracted"

    describe "Compiled pattern methods":
        it "should match using compiled pattern":
            let pattern = regex.compile("test")
            let result = pattern.match("test123")
            expect result.is_some()

        it "should search using compiled pattern":
            let pattern = regex.compile("world")
            let result = pattern.search("hello world")
            expect result.is_some()

        it "should fullmatch using compiled pattern":
            let pattern = regex.compile("exact")
            expect pattern.fullmatch("exact").is_some()
            expect pattern.fullmatch("exact match").is_none()

        it "should findall using compiled pattern":
            let pattern = regex.compile("o")
            let matches = pattern.findall("hello world")
            expect matches.len() == 2

        it "should substitute using compiled pattern":
            let pattern = regex.compile("cat")
            let result = pattern.sub("dog", "the cat sat")
            expect "dog" in result

        it "should split using compiled pattern":
            let pattern = regex.compile(" ")
            let parts = pattern.split("a b c")
            expect parts.len() == 3

# Feature metadata registration
use spec.feature_doc.FeatureMetadata

let regex_test_features = [
    FeatureMetadata {
        id: 230,
        name: "Regex Compilation",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Compile and reuse regex patterns for performance.",
        code_examples: ['pattern = regex.compile("test")', 'pattern.match(text)'],
        dependencies: [],
        required_by: [231, 232, 233],
        notes: "BDD test-driven - literal matching implemented, full regex engine TODO"
    },

    FeatureMetadata {
        id: 231,
        name: "Pattern Matching",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Match patterns with match, search, and fullmatch operations.",
        code_examples: ['regex.match(pattern, text)', 'regex.search(pattern, text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - basic matching working"
    },

    FeatureMetadata {
        id: 233,
        name: "Find All Matches",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Find all pattern occurrences in string.",
        code_examples: ['regex.findall(pattern, text)', 'pattern.findall(text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - literal findall working"
    },

    FeatureMetadata {
        id: 234,
        name: "String Substitution",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Replace pattern matches with replacement text.",
        code_examples: ['regex.sub(pattern, replacement, text)', 'pattern.sub(repl, text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - basic substitution working"
    },

    FeatureMetadata {
        id: 235,
        name: "Split by Pattern",
        category: "Regular Expressions",
        difficulty: 3,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/regex.spl"],
        tests: ["simple/std_lib/test/unit/core/regex_spec.spl"],
        description: "Split string by regex pattern.",
        code_examples: ['regex.split(pattern, text)', 'pattern.split(text)'],
        dependencies: [230],
        required_by: [],
        notes: "BDD test-driven - literal split working"
    }
]

# Register features when test runs
for meta in regex_test_features:
    feature_metadata(meta)
