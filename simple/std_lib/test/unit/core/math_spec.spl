# BDD Tests for Math Module
# Feature #220-229: Math and Numeric features

use spec.describe
use spec.it
use spec.expect
use core.math

describe("Math module"):
    describe("Constants"):
        it("should provide PI constant"):
            expect(math.PI).to_be_close_to(3.14159, 0.0001)

        it("should provide E constant"):
            expect(math.E).to_be_close_to(2.71828, 0.0001)

        it("should provide TAU constant"):
            expect(math.TAU).to_be_close_to(6.28318, 0.0001)

    describe("Basic operations"):
        it("should calculate absolute value"):
            expect(math.abs(-5.5)).to_equal(5.5)
            expect(math.abs(5.5)).to_equal(5.5)
            expect(math.abs(0.0)).to_equal(0.0)

        it("should calculate integer absolute value"):
            expect(math.abs_int(-42)).to_equal(42)
            expect(math.abs_int(42)).to_equal(42)

        it("should calculate sign"):
            expect(math.sign(5.5)).to_equal(1.0)
            expect(math.sign(-5.5)).to_equal(-1.0)
            expect(math.sign(0.0)).to_equal(0.0)

        it("should floor numbers"):
            expect(math.floor(3.7)).to_equal(3)
            expect(math.floor(3.2)).to_equal(3)
            expect(math.floor(-3.7)).to_equal(-4)

        it("should ceil numbers"):
            expect(math.ceil(3.2)).to_equal(4)
            expect(math.ceil(3.7)).to_equal(4)
            expect(math.ceil(-3.2)).to_equal(-3)

        it("should round numbers"):
            expect(math.round(3.4)).to_equal(3)
            expect(math.round(3.5)).to_equal(4)
            expect(math.round(3.6)).to_equal(4)

    describe("Square root"):
        it("should calculate square root"):
            let result = math.sqrt(4.0)
            expect(result).to_be_close_to(2.0, 0.0001)

        it("should calculate square root of 9"):
            let result = math.sqrt(9.0)
            expect(result).to_be_close_to(3.0, 0.0001)

        it("should calculate square root of 2"):
            let result = math.sqrt(2.0)
            expect(result).to_be_close_to(1.41421, 0.0001)

        it("should return NaN for negative numbers"):
            let result = math.sqrt(-1.0)
            expect(math.isnan(result)).to_be_true()

    describe("Exponential"):
        it("should calculate e^0"):
            let result = math.exp(0.0)
            expect(result).to_be_close_to(1.0, 0.0001)

        it("should calculate e^1"):
            let result = math.exp(1.0)
            expect(result).to_be_close_to(2.71828, 0.001)

        it("should calculate e^2"):
            let result = math.exp(2.0)
            expect(result).to_be_close_to(7.38906, 0.01)

    describe("Trigonometry"):
        it("should calculate sin(0)"):
            let result = math.sin(0.0)
            expect(result).to_be_close_to(0.0, 0.0001)

        it("should calculate sin(Ï€/2)"):
            let result = math.sin(math.PI / 2.0)
            expect(result).to_be_close_to(1.0, 0.001)

        it("should calculate sin(Ï€)"):
            let result = math.sin(math.PI)
            expect(result).to_be_close_to(0.0, 0.001)

        it("should calculate cos(0)"):
            let result = math.cos(0.0)
            expect(result).to_be_close_to(1.0, 0.001)

        it("should calculate cos(Ï€/2)"):
            let result = math.cos(math.PI / 2.0)
            expect(result).to_be_close_to(0.0, 0.001)

        it("should calculate cos(Ï€)"):
            let result = math.cos(math.PI)
            expect(result).to_be_close_to(-1.0, 0.001)

        it("should calculate tan"):
            let result = math.tan(math.PI / 4.0)  # tan(45Â°) = 1
            expect(result).to_be_close_to(1.0, 0.01)

    describe("Min/Max"):
        it("should find minimum of two floats"):
            expect(math.min(3.5, 7.2)).to_equal(3.5)
            expect(math.min(7.2, 3.5)).to_equal(3.5)

        it("should find maximum of two floats"):
            expect(math.max(3.5, 7.2)).to_equal(7.2)
            expect(math.max(7.2, 3.5)).to_equal(7.2)

        it("should find minimum of two integers"):
            expect(math.min_int(3, 7)).to_equal(3)
            expect(math.min_int(7, 3)).to_equal(3)

        it("should find maximum of two integers"):
            expect(math.max_int(3, 7)).to_equal(7)
            expect(math.max_int(7, 3)).to_equal(7)

    describe("Clamp"):
        it("should clamp values within range"):
            expect(math.clamp(5.0, 0.0, 10.0)).to_equal(5.0)
            expect(math.clamp(-5.0, 0.0, 10.0)).to_equal(0.0)
            expect(math.clamp(15.0, 0.0, 10.0)).to_equal(10.0)

        it("should clamp integer values"):
            expect(math.clamp_int(5, 0, 10)).to_equal(5)
            expect(math.clamp_int(-5, 0, 10)).to_equal(0)
            expect(math.clamp_int(15, 0, 10)).to_equal(10)

    describe("Degree/Radian conversion"):
        it("should convert degrees to radians"):
            let rad = math.radians(180.0)
            expect(rad).to_be_close_to(math.PI, 0.0001)

        it("should convert radians to degrees"):
            let deg = math.degrees(math.PI)
            expect(deg).to_be_close_to(180.0, 0.0001)

    describe("Integer operations"):
        it("should calculate factorial"):
            expect(math.factorial(0)).to_equal(1)
            expect(math.factorial(1)).to_equal(1)
            expect(math.factorial(5)).to_equal(120)
            expect(math.factorial(6)).to_equal(720)

        it("should calculate GCD"):
            expect(math.gcd(48, 18)).to_equal(6)
            expect(math.gcd(100, 50)).to_equal(50)
            expect(math.gcd(17, 19)).to_equal(1)  # Coprime

        it("should calculate LCM"):
            expect(math.lcm(4, 6)).to_equal(12)
            expect(math.lcm(21, 6)).to_equal(42)

    describe("Floating-point utilities"):
        it("should check if numbers are close"):
            expect(math.isclose(1.0, 1.0000001)).to_be_true()
            expect(math.isclose(1.0, 1.1)).to_be_false()

        it("should detect NaN"):
            expect(math.isnan(math.NAN)).to_be_true()
            expect(math.isnan(1.0)).to_be_false()

        it("should detect infinity"):
            expect(math.isinf(math.INF)).to_be_true()
            expect(math.isinf(1.0)).to_be_false()

        it("should detect finite numbers"):
            expect(math.isfinite(1.0)).to_be_true()
            expect(math.isfinite(math.INF)).to_be_false()
            expect(math.isfinite(math.NAN)).to_be_false()

# Feature metadata registration
use spec.feature_doc.FeatureMetadata

let math_test_features = [
    FeatureMetadata {
        id: 220,
        name: "Math Functions",
        category: "Math and Numeric",
        difficulty: 2,
        status: "ðŸ”„ In Progress",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/math.spl"],
        tests: ["simple/std_lib/test/unit/core/math_spec.spl"],
        description: "Standard math functions with trigonometry, exponentials, and utilities.",
        code_examples: ['math.sin(x)', 'math.sqrt(x)', 'math.floor(x)'],
        dependencies: [],
        required_by: [221, 222],
        notes: "BDD test-driven with Taylor series implementations"
    },

    FeatureMetadata {
        id: 221,
        name: "Constants",
        category: "Math and Numeric",
        difficulty: 1,
        status: "âœ… Complete",
        impl_type: "Simple",
        spec_ref: "doc/spec/stdlib.md",
        files: ["simple/std_lib/src/core/math.spl"],
        tests: ["simple/std_lib/test/unit/core/math_spec.spl"],
        description: "Mathematical constants: PI, E, TAU, INF, NAN.",
        code_examples: ['math.PI', 'math.E', 'math.TAU'],
        dependencies: [220],
        required_by: [],
        notes: "Constants defined and tested"
    }
]

# Register features when test runs
for meta in math_test_features:
    feature_metadata(meta)
