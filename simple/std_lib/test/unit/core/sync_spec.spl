# Synchronization Primitives Tests
# Comprehensive tests for Atomic, Mutex, RwLock, and Semaphore
#
# Tests the thread-safe synchronization primitives implemented with
# FFI bindings to the Rust runtime.

import test.unit.*
import std.spec
from core.sync import Atomic, Mutex, RwLock, Semaphore

describe "Atomic[T]":
    context "creation and basic operations":
        it "creates atomic with initial value":
            val counter = Atomic(0)
            expect counter.load() == 0

        it "stores and loads values":
            val atomic = Atomic(10)
            atomic.store(20)
            expect atomic.load() == 20

        it "loads value with acquire ordering":
            val atomic = Atomic(42)
            val value = atomic.load()
            expect value == 42

    context "atomic swap operations":
        it "swaps value and returns old value":
            val atomic = Atomic(5)
            val old = atomic.swap(10)
            expect old == 5
            expect atomic.load() == 10

        it "swap is atomic with AcqRel ordering":
            val atomic = Atomic(100)
            val old1 = atomic.swap(200)
            val old2 = atomic.swap(300)
            expect old1 == 100
            expect old2 == 200
            expect atomic.load() == 300

    context "compare and swap (CAS)":
        it "succeeds when value matches expected":
            val atomic = Atomic(10)
            val (success, old) = atomic.compare_and_swap(10, 20)
            expect success == true
            expect old == 10
            expect atomic.load() == 20

        it "fails when value does not match expected":
            val atomic = Atomic(10)
            val (success, current) = atomic.compare_and_swap(5, 20)
            expect success == false
            expect current == 10
            expect atomic.load() == 10

        it "CAS is fundamental for lock-free algorithms":
            val atomic = Atomic(0)
            # Simulate lock-free increment
            while true:
                val current = atomic.load()
                val (success, _) = atomic.compare_and_swap(current, current + 1)
                if success:
                    break
            expect atomic.load() == 1

    context "fetch arithmetic operations":
        it "fetch_add returns old value and increments":
            val atomic = Atomic(10)
            val old = atomic.fetch_add(5)
            expect old == 10
            expect atomic.load() == 15

        it "fetch_sub returns old value and decrements":
            val atomic = Atomic(20)
            val old = atomic.fetch_sub(7)
            expect old == 20
            expect atomic.load() == 13

        it "fetch_add with negative delta":
            val atomic = Atomic(10)
            val old = atomic.fetch_add(-3)
            expect old == 10
            expect atomic.load() == 7

        it "fetch_sub with negative delta":
            val atomic = Atomic(5)
            val old = atomic.fetch_sub(-2)
            expect old == 5
            expect atomic.load() == 7

    context "fetch bitwise operations":
        it "fetch_and performs bitwise AND":
            val atomic = Atomic(0b1111)
            val old = atomic.fetch_and(0b1010)
            expect old == 0b1111
            expect atomic.load() == 0b1010

        it "fetch_or performs bitwise OR":
            val atomic = Atomic(0b1010)
            val old = atomic.fetch_or(0b0101)
            expect old == 0b1010
            expect atomic.load() == 0b1111

        it "fetch_and can clear bits":
            val atomic = Atomic(0xFF)
            atomic.fetch_and(0x0F)
            expect atomic.load() == 0x0F

        it "fetch_or can set bits":
            val atomic = Atomic(0x00)
            atomic.fetch_or(0xF0)
            expect atomic.load() == 0xF0

    context "concurrent counter (simulated)":
        it "atomic increment is thread-safe":
            val counter = Atomic(0)
            # Simulate multiple increments
            counter.fetch_add(1)
            counter.fetch_add(1)
            counter.fetch_add(1)
            expect counter.load() == 3

        it "maintains consistency across operations":
            val atomic = Atomic(100)
            atomic.fetch_add(10)
            atomic.fetch_sub(5)
            atomic.fetch_add(20)
            expect atomic.load() == 125

describe "Mutex[T]":
    context "creation and locking":
        it "creates mutex with initial value":
            val mutex = Mutex(42)
            expect mutex.into_inner() == 42

        it "acquires lock and accesses value":
            val mutex = Mutex(10)
            val guard = mutex.lock()
            expect guard.value == 10

        it "lock provides mutual exclusion":
            val mutex = Mutex(0)
            val guard = mutex.lock()
            # Value is accessible through guard
            expect guard.value == 0

    context "try_lock operations":
        it "try_lock succeeds when unlocked":
            val mutex = Mutex(5)
            val guard_opt = mutex.try_lock()
            match guard_opt:
                case Some(guard):
                    expect guard.value == 5
                case None:
                    fail "try_lock should succeed on unlocked mutex"

        it "try_lock returns None when locked":
            val mutex = Mutex(10)
            val guard1 = mutex.lock()
            val guard2_opt = mutex.try_lock()
            match guard2_opt:
                case Some(_):
                    fail "try_lock should fail on locked mutex"
                case None:
                    pass  # Expected

    context "lock guard RAII semantics":
        it "guard provides read access to value":
            val mutex = Mutex(42)
            with mutex.lock() as guard:
                expect guard.value == 42

        it "guard automatically releases lock on exit":
            val mutex = Mutex(10)
            with mutex.lock() as guard:
                # Lock is held here
                pass
            # Lock is released here
            val guard2_opt = mutex.try_lock()
            match guard2_opt:
                case Some(_):
                    pass  # Lock was properly released
                case None:
                    fail "Lock should be released after guard exits"

    context "value modification":
        it "modifies value through guard":
            val mutex = Mutex(0)
            with mutex.lock() as guard:
                guard.value = 10
            val guard2 = mutex.lock()
            expect guard2.value == 10

        it "maintains consistency across lock/unlock cycles":
            val mutex = Mutex(100)
            with mutex.lock() as guard:
                guard.value = 200
            with mutex.lock() as guard:
                guard.value = guard.value + 50
            with mutex.lock() as guard:
                expect guard.value == 250

    context "protecting shared data":
        it "protects integer counter":
            val counter = Mutex(0)
            with counter.lock() as guard:
                guard.value = guard.value + 1
            with counter.lock() as guard:
                guard.value = guard.value + 1
            with counter.lock() as guard:
                expect guard.value == 2

        it "protects complex data structures":
            val data = Mutex([1, 2, 3])
            with data.lock() as guard:
                guard.value.push(4)
            with data.lock() as guard:
                expect guard.value.len() == 4

describe "RwLock[T]":
    context "creation and read locks":
        it "creates rwlock with initial value":
            val rwlock = RwLock(42)
            val guard = rwlock.read()
            expect guard.value == 42

        it "acquires read lock":
            val rwlock = RwLock([1, 2, 3])
            val guard = rwlock.read()
            expect guard.value.len() == 3

        it "multiple readers can access concurrently":
            val rwlock = RwLock(100)
            val guard1 = rwlock.read()
            val guard2 = rwlock.read()
            expect guard1.value == 100
            expect guard2.value == 100

    context "write locks":
        it "acquires write lock":
            val rwlock = RwLock(10)
            val guard = rwlock.write()
            expect guard.value == 10

        it "write lock provides exclusive access":
            val rwlock = RwLock(50)
            with rwlock.write() as guard:
                guard.value = 100
            val read_guard = rwlock.read()
            expect read_guard.value == 100

        it "modifies value through write guard":
            val rwlock = RwLock(0)
            with rwlock.write() as guard:
                guard.value = 42
            with rwlock.read() as guard:
                expect guard.value == 42

    context "try read and write":
        it "try_read succeeds when no writers":
            val rwlock = RwLock(5)
            val guard_opt = rwlock.try_read()
            match guard_opt:
                case Some(guard):
                    expect guard.value == 5
                case None:
                    fail "try_read should succeed"

        it "try_write succeeds when unlocked":
            val rwlock = RwLock(10)
            val guard_opt = rwlock.try_write()
            match guard_opt:
                case Some(guard):
                    expect guard.value == 10
                case None:
                    fail "try_write should succeed"

    context "read-write semantics":
        it "allows concurrent reads":
            val rwlock = RwLock(42)
            with rwlock.read() as guard1:
                with rwlock.read() as guard2:
                    expect guard1.value == guard2.value

        it "write blocks other operations":
            val rwlock = RwLock(10)
            with rwlock.write() as guard:
                guard.value = 20
            # After write completes, read sees new value
            with rwlock.read() as guard:
                expect guard.value == 20

    context "RAII guard semantics":
        it "read guard releases on exit":
            val rwlock = RwLock(5)
            with rwlock.read() as guard:
                expect guard.value == 5
            # Lock released, write should succeed
            with rwlock.write() as guard:
                guard.value = 10

        it "write guard releases on exit":
            val rwlock = RwLock(10)
            with rwlock.write() as guard:
                guard.value = 20
            # Lock released, read should succeed
            with rwlock.read() as guard:
                expect guard.value == 20

    context "protecting shared state":
        it "protects read-heavy workload":
            val config = RwLock({"timeout": 30, "retries": 3})
            # Many readers
            with config.read() as guard:
                expect guard.value["timeout"] == 30
            with config.read() as guard:
                expect guard.value["retries"] == 3

        it "protects occasional writes":
            val cache = RwLock([])
            with cache.write() as guard:
                guard.value.push("item1")
            with cache.write() as guard:
                guard.value.push("item2")
            with cache.read() as guard:
                expect guard.value.len() == 2

describe "Semaphore":
    context "creation and basic operations":
        it "creates semaphore with permits":
            val sem = Semaphore(3)
            expect sem.permits.load() == 3

        it "acquire decrements permits":
            val sem = Semaphore(5)
            sem.acquire()
            expect sem.permits.load() == 4

        it "release increments permits":
            val sem = Semaphore(2)
            sem.acquire()
            sem.release()
            expect sem.permits.load() == 2

    context "limiting concurrent access":
        it "limits to permit count":
            val sem = Semaphore(2)
            sem.acquire()
            sem.acquire()
            # All permits consumed
            expect sem.permits.load() == 0

        it "blocks when no permits available":
            val sem = Semaphore(1)
            sem.acquire()
            expect sem.permits.load() == 0
            # Next acquire would block (simulated)

    context "RAII semantics with context manager":
        it "acquires on enter and releases on exit":
            val sem = Semaphore(3)
            with sem:
                # Permit acquired
                expect sem.permits.load() == 2
            # Permit released
            expect sem.permits.load() == 3

        it "maintains permit count across context":
            val sem = Semaphore(5)
            with sem:
                with sem:
                    expect sem.permits.load() == 3
                expect sem.permits.load() == 4
            expect sem.permits.load() == 5

    context "concurrent access control":
        it "simulates rate limiting":
            val rate_limiter = Semaphore(3)
            # Simulate 3 concurrent operations
            rate_limiter.acquire()
            rate_limiter.acquire()
            rate_limiter.acquire()
            expect rate_limiter.permits.load() == 0

        it "simulates connection pool":
            val pool = Semaphore(10)
            # Acquire connections
            pool.acquire()
            pool.acquire()
            expect pool.permits.load() == 8
            # Release connections
            pool.release()
            pool.release()
            expect pool.permits.load() == 10

describe "Synchronization Integration":
    context "Atomic + Mutex patterns":
        it "combines atomic flag with mutex":
            val flag = Atomic(0)
            val data = Mutex(0)

            # Set flag atomically
            flag.store(1)

            # Lock and modify data
            with data.lock() as guard:
                guard.value = 42

            expect flag.load() == 1
            with data.lock() as guard:
                expect guard.value == 42

    context "RwLock for shared config":
        it "readers see consistent config":
            val config = RwLock({"version": 1, "debug": false})

            # Multiple readers
            with config.read() as r1:
                with config.read() as r2:
                    expect r1.value["version"] == r2.value["version"]

            # Writer updates config
            with config.write() as guard:
                guard.value["version"] = 2

            # Readers see new version
            with config.read() as guard:
                expect guard.value["version"] == 2

    context "Semaphore for resource pooling":
        it "limits concurrent database connections":
            val db_pool = Semaphore(5)
            val active_conns = Atomic(0)

            # Acquire 3 connections
            with db_pool:
                active_conns.fetch_add(1)
            with db_pool:
                active_conns.fetch_add(1)
            with db_pool:
                active_conns.fetch_add(1)

            expect active_conns.load() == 3
            expect db_pool.permits.load() == 5  # All released

describe "Memory Ordering Semantics":
    context "Acquire-Release ordering":
        it "atomic store with Release ordering":
            val atomic = Atomic(0)
            atomic.store(42)  # Release ordering
            expect atomic.load() == 42  # Acquire ordering

        it "atomic swap with AcqRel ordering":
            val atomic = Atomic(10)
            val old = atomic.swap(20)  # AcqRel ordering
            expect old == 10
            expect atomic.load() == 20

    context "Lock-based synchronization":
        it "mutex provides synchronization":
            val mutex = Mutex(0)
            with mutex.lock() as guard:
                guard.value = 100
            # Lock release synchronizes
            with mutex.lock() as guard:
                expect guard.value == 100

        it "rwlock read synchronizes with write":
            val rwlock = RwLock(0)
            with rwlock.write() as guard:
                guard.value = 200
            # Write synchronizes with read
            with rwlock.read() as guard:
                expect guard.value == 200
