/// Comprehensive tests for stdlib collections
/// Tests Option, Result, Array, List, and Dictionary operations

import test.unit.*
import std.spec

describe "Option Type":
    context "creation and checks":
        it "creates Some value":
            val opt = Some(42)
            expect opt.is_some == true

        it "creates None value":
            val opt = None
            expect opt.is_none == true

        it "is_some returns true for Some":
            val opt = Some(10)
            expect opt.is_some == true

        it "is_none returns true for None":
            val opt = None
            expect opt.is_none == true

    context "unwrap operations":
        it "unwrap extracts Some value":
            val opt = Some(42)
            expect opt.unwrap() == 42

        it "expect returns value with message":
            val opt = Some(99)
            expect opt.expect("Should have value") == 99

        it "unwrap_or returns default for None":
            val opt = None
            expect opt.unwrap_or(0) == 0

        it "unwrap_or returns Some value":
            val opt = Some(5)
            expect opt.unwrap_or(0) == 5

    context "or and conversion":
        it "or returns self if Some":
            val opt1 = Some(1)
            val opt2 = Some(2)
            expect opt1.or(opt2).unwrap() == 1

        it "or returns other if None":
            val opt1 = None
            val opt2 = Some(2)
            expect opt1.or(opt2).unwrap() == 2

        it "ok_or converts Some to Ok":
            val opt = Some(42)
            val res_obj = opt.ok_or("error")
            expect res_obj.is_ok == true

        it "ok_or converts None to Err":
            val opt = None
            val res_obj = opt.ok_or("error")
            expect res_obj.is_err == true

describe "Result Type":
    context "creation and checks":
        it "creates Ok value":
            val res_obj = Ok(42)
            expect res_obj.is_ok == true

        it "creates Err value":
            val res_obj = Err("error")
            expect res_obj.is_err == true

        it "is_ok returns true for Ok":
            val res_obj = Ok(10)
            expect res_obj.is_ok == true

        it "is_err returns true for Err":
            val res_obj = Err("error")
            expect res_obj.is_err == true

    context "unwrap operations":
        it "unwrap extracts Ok value":
            val res_obj = Ok(42)
            expect res_obj.unwrap() == 42

        it "unwrap_err extracts Err value":
            val res_obj = Err("failure")
            expect res_obj.unwrap_err() == "failure"

        it "unwrap_or returns default for Err":
            val res_obj = Err("error")
            expect res_obj.unwrap_or(0) == 0

        it "unwrap_or returns Ok value":
            val res_obj = Ok(5)
            expect res_obj.unwrap_or(0) == 5

        it "expect returns value with message":
            val res_obj = Ok(99)
            expect res_obj.expect("Should succeed") == 99

    context "or operations":
        it "or returns self if Ok":
            val res1 = Ok(1)
            val res2 = Err("error2")
            expect res1.or(res2).unwrap() == 1

        it "or returns other if Err":
            val res1 = Err("error1")
            val res2 = Ok(2)
            expect res1.or(res2).unwrap() == 2

    context "conversion operations":
        it "ok converts Ok to Some":
            val res_obj = Ok(42)
            val opt = res_obj.ok()
            expect opt.is_some == true
            expect opt.unwrap() == 42

        it "ok converts Err to None":
            val res_obj = Err("error")
            val opt = res_obj.ok()
            expect opt.is_none == true

        it "err converts Err to Some":
            val res_obj = Err("error")
            val opt = res_obj.err()
            expect opt.is_some == true
            expect opt.unwrap() == "error"

        it "err converts Ok to None":
            val res_obj = Ok(42)
            val opt = res_obj.err()
            expect opt.is_none == true

describe "Array Type":
    context "creation and access":
        it "creates array with literals":
            val arr = [1, 2, 3, 4, 5]
            expect arr.len == 5

        it "accesses elements by index":
            val arr = [10, 20, 30]
            expect arr[0] == 10
            expect arr[1] == 20
            expect arr[2] == 30

        it "creates empty array":
            val empty = []
            expect empty.len == 0

    context "array methods":
        skip "push adds element":
            # TODO: [stdlib][P3] Array mutation requires runtime FFI support
            var arr = [1, 2]
            arr.push(3)
            expect arr.len == 3
            expect arr[2] == 3

        skip "pop removes last element":
            # TODO: [stdlib][P3] Array mutation requires runtime FFI support
            var arr = [1, 2, 3]
            val item = arr.pop()
            expect item == 3
            expect arr.len == 2

        it "contains checks for element":
            val arr = [1, 2, 3]
            expect arr.contains(2) == true
            expect arr.contains(5) == false

        it "is_empty checks length":
            val empty_arr = []
            expect empty_arr.is_empty == true
            val full = [1]
            expect full.is_empty == false

describe "List Type":
    context "creation and operations":
        skip "creates empty list":
            # TODO: [stdlib][P3] List class requires runtime FFI support
            val list = List.new()
            expect list.is_empty == true

        skip "append adds elements":
            # TODO: [stdlib][P3] List mutation requires runtime FFI support
            var list = List.new()
            list.append(1)
            list.append(2)
            expect list.len == 2

        skip "length tracking":
            # TODO: [stdlib][P3] List mutation requires runtime FFI support
            var list = List.new()
            expect list.len == 0
            list.append(1)
            expect list.len == 1

        skip "access elements":
            # TODO: [stdlib][P3] List mutation requires runtime FFI support
            var list = List.new()
            list.append(10)
            list.append(20)
            expect list[0] == 10
            expect list[1] == 20

    context "list methods":
        skip "contains checks membership":
            # TODO: [stdlib][P3] List mutation requires runtime FFI support
            var list = List.new()
            list.append(1)
            list.append(2)
            list.append(3)
            expect list.contains(2) == true
            expect list.contains(5) == false

        skip "is_empty returns correct status":
            # TODO: [stdlib][P3] List mutation requires runtime FFI support
            var list = List.new()
            expect list.is_empty == true
            list.append(1)
            expect list.is_empty == false

describe "Dictionary (Dict) Type":
    context "creation and operations":
        it "creates empty dict":
            val dict = {}
            expect dict.is_empty == true

        skip "inserts and retrieves values":
            # TODO: [stdlib][P3] Dict mutation requires runtime FFI support
            var dict = {}
            dict["key1"] = 10
            expect dict["key1"] == 10

        skip "checks for key existence":
            # TODO: [stdlib][P3] Dict mutation requires runtime FFI support
            var dict = {}
            dict["exists"] = 1
            expect dict.contains("exists") == true
            expect dict.contains("missing") == false

        skip "counts items":
            # TODO: [stdlib][P3] Dict mutation requires runtime FFI support
            var dict = {}
            dict["a"] = 1
            dict["b"] = 2
            expect dict.len == 2

    context "dict methods":
        skip "keys returns all keys":
            # TODO: [stdlib][P3] Dict mutation requires runtime FFI support
            var dict = {}
            dict["x"] = 1
            dict["y"] = 2
            val keys = dict.keys()
            expect keys.len == 2

        skip "values returns all values":
            # TODO: [stdlib][P3] Dict mutation requires runtime FFI support
            var dict = {}
            dict["a"] = 10
            dict["b"] = 20
            val values = dict.values()
            expect values.len == 2

        skip "remove deletes entries":
            # TODO: [stdlib][P3] Dict mutation requires runtime FFI support
            var dict = {}
            dict["key"] = 1
            expect dict.len == 1
            dict.remove("key")
            expect dict.len == 0

        skip "clear removes all entries":
            # TODO: [stdlib][P3] Dict mutation requires runtime FFI support
            var dict = {}
            dict["a"] = 1
            dict["b"] = 2
            dict.clear()
            expect dict.is_empty == true
