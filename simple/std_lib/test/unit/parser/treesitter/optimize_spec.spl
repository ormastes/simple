# Unit tests for tree-sitter optimization module

import spec.{describe, it, expect}
import parser.treesitter.optimize as optimize

describe "StringInterner":
    it "interns new strings":
        let mut interner = optimize.StringInterner.new()

        let id1 = interner.intern("function")
        let id2 = interner.intern("variable")

        expect id1 == 0
        expect id2 == 1

    it "returns same ID for duplicate strings":
        let mut interner = optimize.StringInterner.new()

        let id1 = interner.intern("function")
        let id2 = interner.intern("function")

        expect id1 == id2

    it "looks up strings by ID":
        let mut interner = optimize.StringInterner.new()

        let id = interner.intern("keyword")
        let result = interner.lookup(id)

        expect(result.is_some()).to_be(true)

        match result:
            case Some(s):
                expect s == "keyword"
            case None:
                expect(false).to_be(true)

    it "returns None for unknown ID":
        let interner = optimize.StringInterner.new()

        let result = interner.lookup(999)

        expect(result.is_none()).to_be(true)

    it "gets ID for string":
        let mut interner = optimize.StringInterner.new()

        interner.intern("identifier")

        let id = interner.get_id("identifier")

        expect(id.is_some()).to_be(true)

    it "returns None for unknown string":
        let interner = optimize.StringInterner.new()

        let id = interner.get_id("unknown")

        expect(id.is_none()).to_be(true)

    it "tracks size correctly":
        let mut interner = optimize.StringInterner.new()

        interner.intern("a")
        interner.intern("b")
        interner.intern("a")  # Duplicate

        expect interner.size() == 2

describe "QueryCache":
    it "creates cache with max size":
        let cache = optimize.QueryCache.new(100)

        expect cache.max_size == 100

    it "caches query results":
        let mut cache = optimize.QueryCache.new(10)

        let matches = []
        cache.put("query1", matches)

        let result = cache.get("query1")

        expect(result.is_some()).to_be(true)

    it "returns None for cache miss":
        let cache = optimize.QueryCache.new(10)

        let result = cache.get("unknown")

        expect(result.is_none()).to_be(true)

    it "evicts entries when at capacity":
        let mut cache = optimize.QueryCache.new(2)

        # Fill cache
        cache.put("q1", [])
        cache.put("q2", [])

        # This should evict q1 (least recently used)
        cache.put("q3", [])

        expect cache.size() == 2

    it "updates access count on get":
        let mut cache = optimize.QueryCache.new(10)

        cache.put("query1", [])

        # Access multiple times
        cache.get("query1")
        cache.get("query1")

        let count = cache.access_count.get("query1").unwrap_or(0)
        expect count > 1

    it "clears cache":
        let mut cache = optimize.QueryCache.new(10)

        cache.put("q1", [])
        cache.put("q2", [])

        cache.clear()

        expect cache.size() == 0

describe "ArenaOptimizer":
    it "creates optimizer with pool and block size":
        let optimizer = optimize.ArenaOptimizer.new(1000, 100)

        expect optimizer.pool_size == 1000
        expect optimizer.block_size == 100

    it "estimates nodes needed for source":
        let optimizer = optimize.ArenaOptimizer.new(1000, 100)

        # 1000 chars â‰ˆ 100 nodes * 1.2 = 120 nodes
        let estimate = optimizer.estimate_nodes_needed(1000)

        expect estimate > 0

    it "recommends pool size":
        let optimizer = optimize.ArenaOptimizer.new(1000, 100)

        let pool_size = optimizer.recommend_pool_size(1000)

        # Should be rounded to block size
        expect pool_size % optimizer.block_size == 0

    it "allocates pool":
        let mut optimizer = optimize.ArenaOptimizer.new(1000, 100)

        optimizer.allocate_pool(150)

        expect optimizer.total_nodes == 150
        expect optimizer.allocated_blocks > 0

    it "provides statistics":
        let mut optimizer = optimize.ArenaOptimizer.new(1000, 100)

        optimizer.allocate_pool(200)

        let stats = optimizer.get_statistics()

        expect(stats.contains_key("pool_size")).to_be(true)
        expect(stats.contains_key("total_nodes")).to_be(true)
        expect stats["total_nodes"] == 200

describe "QueryOptimizer":
    it "compiles and caches query":
        let mut optimizer = optimize.QueryOptimizer.new()

        # First compilation
        let result1 = optimizer.get_or_compile("simple", "")

        expect(result1.is_ok()).to_be(true)

        # Second call should use cache
        let result2 = optimizer.get_or_compile("simple", "")

        expect(result2.is_ok()).to_be(true)
        expect optimizer.cache_size() == 1

    it "tracks query stats":
        let mut optimizer = optimize.QueryOptimizer.new()

        # Compile query
        optimizer.get_or_compile("simple", "")

        # Access from cache
        optimizer.get_or_compile("simple", "")
        optimizer.get_or_compile("simple", "")

        let stats = optimizer.get_stats("simple", "")

        expect(stats.is_some()).to_be(true)

        match stats:
            case Some(s):
                expect s.hit_count > 0
            case None:
                expect(false).to_be(true)

    it "clears cache":
        let mut optimizer = optimize.QueryOptimizer.new()

        optimizer.get_or_compile("simple", "")
        optimizer.get_or_compile("simple", "query2")

        optimizer.clear_cache()

        expect optimizer.cache_size() == 0

    it "returns error for invalid query":
        let mut optimizer = optimize.QueryOptimizer.new()

        # Invalid query should fail
        let result = optimizer.get_or_compile("invalid_language", "bad query")

        # May or may not error depending on implementation
        # Just ensure it doesn't crash

describe "Debouncer":
    it "creates debouncer with delay":
        let debouncer = optimize.Debouncer.new(300)

        expect debouncer.delay_ms == 300

    it "triggers on first call":
        let mut debouncer = optimize.Debouncer.new(300)

        let should_trigger = debouncer.should_trigger(0)

        expect(should_trigger).to_be(true)

    it "does not trigger if too soon":
        let mut debouncer = optimize.Debouncer.new(300)

        debouncer.should_trigger(0)

        # 100ms later (< 300ms delay)
        let should_trigger = debouncer.should_trigger(100)

        expect(should_trigger).to_be(false)

    it "triggers after delay expires":
        let mut debouncer = optimize.Debouncer.new(300)

        debouncer.should_trigger(0)

        # 400ms later (> 300ms delay)
        let should_trigger = debouncer.should_trigger(400)

        expect(should_trigger).to_be(true)

    it "marks as pending":
        let mut debouncer = optimize.Debouncer.new(300)

        debouncer.mark_pending()

        expect(debouncer.has_pending()).to_be(true)

    it "resets pending state":
        let mut debouncer = optimize.Debouncer.new(300)

        debouncer.mark_pending()
        debouncer.reset()

        expect(debouncer.has_pending()).to_be(false)

describe "PerformanceMetrics":
    it "records parse times":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_parse(10.5)
        metrics.record_parse(12.3)

        expect metrics.parse_times.len() == 2

    it "records incremental parse times":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_incremental_parse(2.5)
        metrics.record_incremental_parse(3.1)

        expect metrics.incremental_parse_times.len() == 2

    it "records query times":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_query(5.2)

        expect metrics.query_times.len() == 1

    it "records memory usage":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_memory(1024000)

        expect metrics.memory_usage.len() == 1

    it "computes parse stats":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_parse(10.0)
        metrics.record_parse(20.0)
        metrics.record_parse(15.0)

        let stats = metrics.get_parse_stats()

        expect stats.avg == 15.0
        expect stats.min == 10.0
        expect stats.max == 20.0
        expect stats.count == 3

    it "computes incremental parse stats":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_incremental_parse(2.0)
        metrics.record_incremental_parse(4.0)

        let stats = metrics.get_incremental_parse_stats()

        expect stats.avg == 3.0

    it "computes query stats":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_query(5.0)
        metrics.record_query(7.0)

        let stats = metrics.get_query_stats()

        expect stats.avg == 6.0

    it "computes memory stats":
        let mut metrics = optimize.PerformanceMetrics.new()

        metrics.record_memory(1024 * 1024)  # 1 MB
        metrics.record_memory(2 * 1024 * 1024)  # 2 MB

        let mem_stats = metrics.get_memory_stats()

        expect mem_stats.avg_mb > 0.0
        expect mem_stats.max_bytes == 2 * 1024 * 1024

    it "handles empty metrics gracefully":
        let metrics = optimize.PerformanceMetrics.new()

        let stats = metrics.get_parse_stats()

        expect stats.count == 0
        expect stats.avg == 0.0

    it "handles empty memory metrics":
        let metrics = optimize.PerformanceMetrics.new()

        let mem_stats = metrics.get_memory_stats()

        expect mem_stats.avg_bytes == 0

describe "Integration":
    it "combines string interning with query caching":
        let mut interner = optimize.StringInterner.new()
        let mut cache = optimize.QueryCache.new(10)

        # Intern node kinds
        let id1 = interner.intern("function")
        let id2 = interner.intern("variable")

        # Cache query results
        cache.put("query1", [])

        # Verify both work
        expect interner.size() == 2
        expect cache.size() == 1

    it "tracks metrics with optimizer":
        let mut metrics = optimize.PerformanceMetrics.new()
        let mut optimizer = optimize.ArenaOptimizer.new(1000, 100)

        # Allocate pool
        optimizer.allocate_pool(200)

        # Record timing
        metrics.record_parse(15.5)

        # Get stats
        let arena_stats = optimizer.get_statistics()
        let parse_stats = metrics.get_parse_stats()

        expect arena_stats["total_nodes"] == 200
        expect parse_stats.avg == 15.5

describe "Edge Cases":
    it "handles debouncer with zero delay":
        let mut debouncer = optimize.Debouncer.new(0)

        # Should always trigger
        expect(debouncer.should_trigger(0)).to_be(true)
        expect(debouncer.should_trigger(1)).to_be(true)

    it "handles cache with size 1":
        let mut cache = optimize.QueryCache.new(1)

        cache.put("q1", [])
        cache.put("q2", [])

        # Should only have 1 entry
        expect cache.size() == 1

    it "handles arena with small block size":
        let mut optimizer = optimize.ArenaOptimizer.new(100, 1)

        optimizer.allocate_pool(10)

        # Should allocate 10 blocks of size 1
        expect optimizer.allocated_blocks == 10
