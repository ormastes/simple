# Unit tests for incremental parsing
# Phase 2: Incremental update tests

import spec.{describe, it, expect}
import parser.treesitter.{TreeSitterParser, Tree}
import parser.treesitter.edits.{InputEdit, Point, compute_edits}

describe "Incremental Parsing":
    it "returns same tree when no edits":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42"
        let old_tree = parser.parse(source).unwrap()

        # No edits
        let edits: [InputEdit] = []
        let new_tree = parser.parse_incremental(source, old_tree, edits).unwrap()

        expect new_tree.version == old_tree.version + 1
        expect new_tree.source == source

    it "reparses after single character change":
        let parser = TreeSitterParser.new("simple").unwrap()
        let old_source = "let x = 42"
        let old_tree = parser.parse(old_source).unwrap()

        # Change 42 to 43
        let new_source = "let x = 43"
        let edits = compute_edits(old_source, new_source)

        let new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect new_tree.version == old_tree.version + 1
        expect new_tree.source == new_source
        expect(new_tree.root().is_some()).to_be(true)

    it "reparses after adding new statement":
        let parser = TreeSitterParser.new("simple").unwrap()
        let old_source = "let x = 1"
        let old_tree = parser.parse(old_source).unwrap()

        # Add new statement
        let new_source = "let x = 1\nlet y = 2"
        let edits = compute_edits(old_source, new_source)

        let new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect new_tree.version == old_tree.version + 1
        expect new_tree.source == new_source

    it "reparses after removing statement":
        let parser = TreeSitterParser.new("simple").unwrap()
        let old_source = "let x = 1\nlet y = 2"
        let old_tree = parser.parse(old_source).unwrap()

        # Remove second statement
        let new_source = "let x = 1"
        let edits = compute_edits(old_source, new_source)

        let new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect new_tree.version == old_tree.version + 1
        expect new_tree.source == new_source

    it "reparses after changing function name":
        let parser = TreeSitterParser.new("simple").unwrap()
        let old_source = "fn foo(): return 1"
        let old_tree = parser.parse(old_source).unwrap()

        # Rename function
        let new_source = "fn bar(): return 1"
        let edits = compute_edits(old_source, new_source)

        let new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect new_tree.version == old_tree.version + 1
        expect new_tree.source == new_source

    it "handles multiple sequential edits":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source1 = "let x = 1"
        let tree1 = parser.parse(source1).unwrap()

        # First edit: change value
        let source2 = "let x = 2"
        let edits1 = compute_edits(source1, source2)
        let tree2 = parser.parse_incremental(source2, tree1, edits1).unwrap()

        # Second edit: add statement
        let source3 = "let x = 2\nlet y = 3"
        let edits2 = compute_edits(source2, source3)
        let tree3 = parser.parse_incremental(source3, tree2, edits2).unwrap()

        expect tree3.version == 2  # Two incremental parses
        expect tree3.source == source3

describe "compute_edits":
    it "returns empty for identical texts":
        let edits = compute_edits("hello", "hello")
        expect edits.len() == 0

    it "computes full document replacement":
        let old_text = "let x = 1"
        let new_text = "let y = 2"
        let edits = compute_edits(old_text, new_text)

        expect edits.len() == 1

        let edit = edits[0]
        expect edit.start_byte == 0
        expect edit.old_end_byte == old_text.len()
        expect edit.new_end_byte == new_text.len()

    it "tracks line and column positions":
        let old_text = "line1\nline2"
        let new_text = "line1\nmodified"
        let edits = compute_edits(old_text, new_text)

        expect edits.len() == 1

        let edit = edits[0]
        expect edit.start_point.line == 1
        expect edit.start_point.column == 1

describe "InputEdit":
    it "detects affected spans":
        let edit = InputEdit.new(
            start_byte: 5,
            old_end_byte: 10,
            new_end_byte: 15,
            start_point: Point.new(1, 5),
            old_end_point: Point.new(1, 10),
            new_end_point: Point.new(1, 15)
        )

        # Span before edit: not affected
        let span_before = Span(
            start_byte: 0, end_byte: 4,
            start_line: 1, end_line: 1,
            start_column: 0, end_column: 4
        )
        expect(edit.affects_span(span_before)).to_be(false)

        # Span during edit: affected
        let span_during = Span(
            start_byte: 5, end_byte: 10,
            start_line: 1, end_line: 1,
            start_column: 5, end_column: 10
        )
        expect(edit.affects_span(span_during)).to_be(true)

        # Span after edit: not affected
        let span_after = Span(
            start_byte: 20, end_byte: 25,
            start_line: 1, end_line: 1,
            start_column: 20, end_column: 25
        )
        expect(edit.affects_span(span_after)).to_be(false)

    it "adjusts byte offsets correctly":
        let edit = InputEdit.new(
            start_byte: 10,
            old_end_byte: 15,
            new_end_byte: 20,
            start_point: Point.new(1, 10),
            old_end_point: Point.new(1, 15),
            new_end_point: Point.new(1, 20)
        )

        # Before edit: unchanged
        expect edit.adjust_byte(5) == 5

        # Inside edit: maps to start
        expect edit.adjust_byte(12) == 10

        # After edit: shifted by delta (+5)
        expect edit.adjust_byte(20) == 25

    it "adjusts points correctly for single-line edits":
        let edit = InputEdit.new(
            start_byte: 10,
            old_end_byte: 15,
            new_end_byte: 18,
            start_point: Point.new(1, 10),
            old_end_point: Point.new(1, 15),
            new_end_point: Point.new(1, 18)
        )

        # Before edit
        let before = Point.new(1, 5)
        let adjusted_before = edit.adjust_point(before)
        expect adjusted_before.line == 1
        expect adjusted_before.column == 5

        # After edit (same line)
        let after = Point.new(1, 20)
        let adjusted_after = edit.adjust_point(after)
        expect adjusted_after.line == 1
        expect adjusted_after.column == 23  # 20 + (18 - 15) = 23

describe "Point":
    it "compares points correctly":
        let p1 = Point.new(1, 5)
        let p2 = Point.new(1, 10)
        let p3 = Point.new(2, 5)

        expect(p1.is_before(p2)).to_be(true)
        expect(p2.is_after(p1)).to_be(true)
        expect(p1.is_before(p3)).to_be(true)
        expect(p3.is_after(p1)).to_be(true)

    it "detects equality":
        let p1 = Point.new(1, 5)
        let p2 = Point.new(1, 5)
        let p3 = Point.new(1, 6)

        expect(p1.equals(p2)).to_be(true)
        expect(p1.equals(p3)).to_be(false)
