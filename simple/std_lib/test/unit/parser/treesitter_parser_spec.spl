# Unit tests for tree-sitter parser
# Phase 1: Basic parsing tests

import spec.{describe, it, expect}
import parser.treesitter.{TreeSitterParser, Tree, Node}

describe "TreeSitterParser":
    it "creates parser for Simple language":
        let result = TreeSitterParser.new("simple")
        expect(result.is_ok()).to_be(true)

    it "rejects unsupported languages":
        let result = TreeSitterParser.new("python")
        expect(result.is_err()).to_be(true)

    it "parses empty source":
        let parser = TreeSitterParser.new("simple").unwrap()
        let result = parser.parse("")
        expect(result.is_ok()).to_be(true)

    it "parses simple integer literal":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "42"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

        let tree = result.unwrap()
        expect tree.source == source

    it "parses identifier":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "foo"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it "parses binary expression":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "1 + 2"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it "parses let statement":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it "parses return statement":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "return 42"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it "parses simple function - Phase 1 deliverable":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn add(x: i32): return x + 1"
        let result = parser.parse(source)

        # This is the Phase 1 deliverable: parse this successfully
        expect(result.is_ok()).to_be(true)

        let tree = result.unwrap()
        expect tree.source == source

        # Verify we have a root node
        match tree.root():
            case Some(root):
                expect root.kind == "module"
            case None:
                # Fail the test
                expect(false).to_be(true)

    it "parses function with multiple parameters":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn multiply(x: i32, y: i32): return x * y"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it "parses function with no return type":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn print_hello(): return nil"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it "parses nested expressions":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "(1 + 2) * 3"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it "parses comparison operators":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "x < 10"
        let result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

describe "Tree":
    it "provides root node access":
        let parser = TreeSitterParser.new("simple").unwrap()
        let tree = parser.parse("42").unwrap()

        match tree.root():
            case Some(root):
                expect root.kind == "module"
            case None:
                expect(false).to_be(true)

    it "allows node traversal":
        let parser = TreeSitterParser.new("simple").unwrap()
        let tree = parser.parse("1 + 2").unwrap()

        let cursor = tree.walk()
        match cursor.node():
            case Some(node):
                expect node.kind == "module"
                expect node.child_count() > 0
            case None:
                expect(false).to_be(true)
