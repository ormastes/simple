# Tests for Tree-sitter Highlight Queries
# Validates highlights.scm captures all Simple language constructs

import spec.{describe, it, expect, before_each}
import parser.treesitter.{TreeSitterParser, Query, QueryCursor}

describe "Tree-sitter Highlight Queries":
    let parser: TreeSitterParser?
    let query: Query?

    before_each():
        parser = TreeSitterParser.new("simple")

        # Load highlight query from queries/highlights.scm
        query = Query.new("simple", "highlights")

    describe "Keyword Captures":
        it "captures fn keyword":
            let code = "fn main(): void"

            if parser == none or query == none:
                expect not true
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            # Find 'fn' keyword capture
            let found_fn = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "keyword" and capture.node.text(code) == "fn":
                        found_fn = true

            expect found_fn

        it "captures control flow keywords":
            let code = "if x > 0:\n    return x\nelse:\n    return 0"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let keywords_found = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "keyword.control":
                        keywords_found.append(capture.node.text(code))

            expect "if" in keywords_found
            expect "else" in keywords_found
            expect "return" in keywords_found

        it "captures async keywords":
            let code = "async fn fetch(): void\nawait result"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let async_keywords = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "keyword.async":
                        async_keywords.append(capture.node.text(code))

            expect "async" in async_keywords
            expect "await" in async_keywords

    describe "Function Captures":
        it "captures function definitions":
            let code = "fn calculate(x: i32): i32 = x * 2"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_definition = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "function.definition":
                        expect capture.node.text(code) == "calculate"
                        found_definition = true

            expect found_definition

        it "captures function calls":
            let code = "let result = calculate(10)"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_call = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "function.call":
                        expect capture.node.text(code) == "calculate"
                        found_call = true

            expect found_call

        it "captures builtin functions":
            let code = "print(\"Hello\")\nlen(items)\nrange(10)"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let builtins = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "function.builtin":
                        builtins.append(capture.node.text(code))

            expect "print" in builtins
            expect "len" in builtins
            expect "range" in builtins

    describe "Type Captures":
        it "captures primitive types":
            let code = "let x: i32 = 10\nlet y: f64 = 3.14\nlet flag: bool = true"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let types_found = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "type.builtin":
                        types_found.append(capture.node.text(code))

            expect "i32" in types_found
            expect "f64" in types_found
            expect "bool" in types_found

        it "captures user-defined types":
            let code = "class Point:\n    x: i32\n    y: i32"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_class_def = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "type.class.definition":
                        expect capture.node.text(code) == "Point"
                        found_class_def = true

            expect found_class_def

        it "captures type parameters":
            let code = "fn identity<T>(x: T): T = x"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_type_param = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "type.parameter":
                        expect capture.node.text(code) == "T"
                        found_type_param = true

            expect found_type_param

    describe "Variable and Parameter Captures":
        it "captures parameters with higher priority":
            let code = "fn add(x: i32, y: i32): i32 = x + y"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let parameters = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "parameter":
                        parameters.append(capture.node.text(code))

            expect "x" in parameters
            expect "y" in parameters
            expect parameters.len() == 2

        it "captures variable definitions":
            let code = "let count = 0\nlet name = \"Alice\""

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let variables = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "variable.definition":
                        variables.append(capture.node.text(code))

            expect "count" in variables
            expect "name" in variables

        it "captures field access":
            let code = "point.x\nobj.field_name"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let properties = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "property":
                        properties.append(capture.node.text(code))

            expect "x" in properties
            expect "field_name" in properties

    describe "Literal Captures":
        it "captures integer literals":
            let code = "let x = 42\nlet y = 0xFF\nlet z = 0b1010"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let numbers = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "number":
                        numbers.append(capture.node.text(code))

            expect "42" in numbers
            expect "0xFF" in numbers
            expect "0b1010" in numbers

        it "captures string literals":
            let code = "let s1 = \"hello\"\nlet s2 = 'world'"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_strings = 0
            for match in matches:
                for capture in match.captures:
                    if capture.name == "string":
                        found_strings += 1

            expect found_strings >= 2

        it "captures f-strings as special":
            let code = "let msg = f\"Hello, {name}!\""

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_fstring = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "string.special":
                        found_fstring = true

            expect found_fstring

        it "captures boolean literals":
            let code = "let flag1 = true\nlet flag2 = false"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let booleans = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "boolean":
                        booleans.append(capture.node.text(code))

            expect "true" in booleans
            expect "false" in booleans

    describe "Operator Captures":
        it "captures arithmetic operators":
            let code = "x + y - z * 2 / 3 % 4"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let operators = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "operator.arithmetic":
                        operators.append(capture.node.text(code))

            expect "+" in operators
            expect "-" in operators
            expect "*" in operators
            expect "/" in operators
            expect "%" in operators

        it "captures comparison operators":
            let code = "x == y\na != b\nc < d\ne > f\ng <= h\ni >= j"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let comparisons = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "operator.comparison":
                        comparisons.append(capture.node.text(code))

            expect comparisons.len() >= 6

        it "captures logical operators":
            let code = "x and y\na or b\nnot c"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let logical = []
            for match in matches:
                for capture in match.captures:
                    if capture.name == "operator.logical":
                        logical.append(capture.node.text(code))

            expect "and" in logical
            expect "or" in logical
            expect "not" in logical

    describe "Comment Captures":
        it "captures line comments":
            let code = "# This is a comment\nlet x = 10  # inline comment"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_comments = 0
            for match in matches:
                for capture in match.captures:
                    if capture.name == "comment":
                        found_comments += 1

            expect found_comments >= 2

        it "captures doc comments":
            let code = "\"\"\"This is a doc comment\"\"\"\nfn foo(): void"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let found_doc_comment = false
            for match in matches:
                for capture in match.captures:
                    if capture.name == "comment.documentation":
                        found_doc_comment = true

            expect found_doc_comment

    describe "Priority System":
        it "parameters have higher priority than variables":
            # In a function parameter, 'x' should be captured as parameter, not variable
            let code = "fn test(x: i32): void"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let x_captures = []
            for match in matches:
                for capture in match.captures:
                    if capture.node.text(code) == "x":
                        x_captures.append(capture.name)

            # Should capture as parameter, possibly also as variable (lower priority)
            expect "parameter" in x_captures

        it "function definitions have higher priority than calls":
            # Function name in definition should be captured as definition
            let code = "fn calculate(x: i32): i32 = x"

            if parser == none or query == none:
                return

            let tree = parser!.parse(code).unwrap()
            let cursor = QueryCursor.new(query!, tree)
            let matches = cursor.all_matches()

            let calculate_captures = []
            for match in matches:
                for capture in match.captures:
                    if capture.node.text(code) == "calculate":
                        calculate_captures.append(capture.name)

            expect "function.definition" in calculate_captures
