# Unit tests for LSP references handler

import spec.{describe, it, expect}
import lsp.handlers.references as references
import parser.treesitter.{TreeSitterParser, Span, NodeId}

describe "References Handler":
    it "finds all references to a variable":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\nlet y = x + 2\nreturn x"
        let tree = parser.parse(source).unwrap()

        # Find references to "x"
        let refs = references.find_all_references(tree, "x", true)

        # Should find: definition (let x) + 2 references (x + 2, return x)
        expect refs.len() >= 1

    it "finds all references to a function":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo(): return 1\nlet x = foo()\nlet y = foo()"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "foo", true)

        # Should find: definition (fn foo) + 2 calls (foo(), foo())
        expect refs.len() >= 1

    it "excludes declaration when requested":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\nreturn x"
        let tree = parser.parse(source).unwrap()

        # Without declaration
        let refs_no_decl = references.find_all_references(tree, "x", false)

        # With declaration
        let refs_with_decl = references.find_all_references(tree, "x", true)

        # Should have at least one more reference when including declaration
        expect refs_with_decl.len() >= refs_no_decl.len()

    it "handles symbol not found":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1"
        let tree = parser.parse(source).unwrap()

        # Find references to non-existent symbol
        let refs = references.find_all_references(tree, "nonexistent", true)

        expect refs.len() == 0

    it "handles empty source":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = ""
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "x", true)

        expect refs.len() == 0

    it "determines definition context correctly":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\nreturn x"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "x", true)

        # At least one should be a definition
        let mut has_definition = false
        for ref in refs:
            if ref.context == "definition":
                has_definition = true

        expect(has_definition).to_be(true)

    it "determines reference context correctly":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\nlet y = x + 1"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "x", true)

        # At least one should be a reference (not definition)
        let mut has_reference = false
        for ref in refs:
            if ref.context == "reference":
                has_reference = true

        expect(has_reference).to_be(true)

    it "converts references to LSP locations":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\nreturn x"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "x", true)
        let locations = references.references_to_locations(refs)

        expect locations.len() == refs.len()

        # Each location should have a range
        for location in locations:
            expect(location.contains_key("range")).to_be(true)

            let range = location["range"]
            expect(range.contains_key("start")).to_be(true)
            expect(range.contains_key("end")).to_be(true)

    it "handles references request for valid position":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\nreturn x"
        let tree = parser.parse(source).unwrap()

        # Position at "x" in "let x = 1" (line 0, column 4)
        let result = references.handle_references(tree, source, 0, 4, true).unwrap()

        expect(result.is_some()).to_be(true)

    it "returns None for references outside source":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1"
        let tree = parser.parse(source).unwrap()

        let result = references.handle_references(tree, source, 100, 100, true).unwrap()

        expect(result.is_none()).to_be(true)

    it "returns None for non-identifier nodes":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42"
        let tree = parser.parse(source).unwrap()

        # Position at "42" (not an identifier)
        let result = references.handle_references(tree, source, 0, 8, true).unwrap()

        # Should return None for non-identifier
        # (or Some([]) if it finds the number literal)
        # Either is acceptable

describe "Reference Context Detection":
    it "detects function definition context":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo(): return 1"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "foo", true)

        # Should find the function name as a definition
        let mut found_definition = false
        for ref in refs:
            if ref.context == "definition":
                found_definition = true

        expect(found_definition).to_be(true)

    it "detects variable definition context":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "x", true)

        # Should find the variable as a definition
        expect refs.len() > 0

        let first_ref = refs[0]
        expect first_ref.context == "definition"

    it "detects parameter definition context":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo(x: i32): return x"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "x", true)

        # Should find: parameter definition + reference in return
        expect refs.len() >= 1

describe "Reference Locations":
    it "includes correct span information":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let foo = 1\nlet bar = foo"
        let tree = parser.parse(source).unwrap()

        let refs = references.find_all_references(tree, "foo", true)

        expect refs.len() > 0

        # All references should have valid spans
        for ref in refs:
            expect ref.span.start_line >= 0
            expect ref.span.start_column >= 0
            expect ref.span.end_line >= ref.span.start_line

    it "distinguishes between different symbols":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 1\nlet y = 2\nreturn x + y"
        let tree = parser.parse(source).unwrap()

        let x_refs = references.find_all_references(tree, "x", true)
        let y_refs = references.find_all_references(tree, "y", true)

        # x and y should have different reference counts
        # (each appears at least once)
        expect x_refs.len() > 0
        expect y_refs.len() > 0
