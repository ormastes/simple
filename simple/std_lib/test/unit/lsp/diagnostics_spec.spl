# Unit tests for LSP diagnostics handler

import spec.{describe, it, expect}
import lsp.handlers.diagnostics as diagnostics
import lsp.protocol as protocol
import parser.treesitter.{TreeSitterParser, Node}

describe "Diagnostics Handler":
    it "finds error nodes in tree":
        let parser = TreeSitterParser.new("simple").unwrap()
        # Parse broken syntax
        let source = "fn broken("  # Missing closing paren and colon
        let tree = parser.parse(source).unwrap()

        let error_nodes = diagnostics.find_error_nodes(tree)

        # Should have found error nodes
        expect error_nodes.len() > 0

    it "generates diagnostics from error nodes":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo() return 1"  # Missing colon
        let tree = parser.parse(source).unwrap()

        let diagnostics_list = diagnostics.generate_diagnostics(tree)

        # Should have diagnostics
        expect diagnostics_list.len() > 0

    it "converts error node to diagnostic with range":
        # Create a test error node
        let node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "ERROR",
            span: Span(
                start_byte: 0,
                end_byte: 5,
                start_line: 0,
                end_line: 0,
                start_column: 0,
                end_column: 5
            ),
            children: [],
            fields: {},
            has_error: true,
            text: "error"
        )

        let diagnostic = diagnostics.node_to_diagnostic(node)

        # Should have range
        expect(diagnostic.contains_key("range")).to_be(true)
        expect(diagnostic.contains_key("severity")).to_be(true)
        expect(diagnostic.contains_key("message")).to_be(true)
        expect(diagnostic.contains_key("source")).to_be(true)

        # Check severity is Error
        expect diagnostic["severity"] == protocol.DiagnosticSeverity.Error.to_int()

        # Check source
        expect diagnostic["source"] == "simple-lsp"

    it "creates helpful error messages":
        # Node with text
        let node_with_text = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "ERROR",
            span: Span(start_byte: 0, end_byte: 3, start_line: 0, end_line: 0, start_column: 0, end_column: 3),
            children: [],
            fields: {},
            has_error: true,
            text: "foo"
        )

        let diagnostic = diagnostics.node_to_diagnostic(node_with_text)
        expect "foo" in diagnostic["message"]

        # Node without text
        let node_no_text = Node(
            id: NodeId(index: 1, generation: 0),
            kind: "ERROR",
            span: Span(start_byte: 0, end_byte: 0, start_line: 0, end_line: 0, start_column: 0, end_column: 0),
            children: [],
            fields: {},
            has_error: true,
            text: ""
        )

        let diagnostic2 = diagnostics.node_to_diagnostic(node_no_text)
        expect diagnostic2["message"] == "Syntax error"

    it "handles valid source with no errors":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn foo(): return 1"
        let tree = parser.parse(source).unwrap()

        let error_nodes = diagnostics.find_error_nodes(tree)

        # Valid source should have no errors
        expect error_nodes.len() == 0

    it "generates empty diagnostics for valid source":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "let x = 42"
        let tree = parser.parse(source).unwrap()

        let diagnostics_list = diagnostics.generate_diagnostics(tree)

        # No errors = no diagnostics
        expect diagnostics_list.len() == 0

    it "traverses nested error nodes":
        let parser = TreeSitterParser.new("simple").unwrap()
        # Multiple syntax errors
        let source = "fn foo(\nfn bar("
        let tree = parser.parse(source).unwrap()

        let error_nodes = diagnostics.find_error_nodes(tree)

        # Should find multiple errors
        expect error_nodes.len() > 0

describe "Error Node Detection":
    it "detects nodes with ERROR kind":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "fn incomplete"  # Missing params and body
        let tree = parser.parse(source).unwrap()

        let errors = diagnostics.find_error_nodes(tree)

        # Should detect ERROR nodes
        for error_node in errors:
            let is_error = error_node.kind == "ERROR" or error_node.has_error
            expect(is_error).to_be(true)

    it "includes position information":
        let parser = TreeSitterParser.new("simple").unwrap()
        let source = "bad syntax here"
        let tree = parser.parse(source).unwrap()

        let diagnostics_list = diagnostics.generate_diagnostics(tree)

        if diagnostics_list.len() > 0:
            let diagnostic = diagnostics_list[0]
            let range = diagnostic["range"]

            # Should have start and end positions
            expect(range.contains_key("start")).to_be(true)
            expect(range.contains_key("end")).to_be(true)

            let start = range["start"]
            expect(start.contains_key("line")).to_be(true)
            expect(start.contains_key("character")).to_be(true)
