# Vulkan Renderer System Test
#
# End-to-end system tests for Vulkan renderer with widget builder pattern.
# Tests the complete rendering pipeline: Widget → Element → Vulkan → GPU
#
# Run with:
#   ./target/debug/simple simple/std_lib/test/system/ui/vulkan_renderer_spec.spl

use spec.*
use ui.widget.*
use ui.layout.*
use ui.interactive.*
use ui.display.*
use ui.state.*
use ui.renderer.*
use ui.gui.vulkan_async.*
use ui.widget_renderer.*
use ui.viewport.*

describe "Vulkan Renderer System Tests":
    # Test 1: Viewport creation
    it "creates viewport for Vulkan rendering":
        let viewport = Viewport::new(1920, 1080, 1.0)

        expect(viewport.width).to(equal(1920))
        expect(viewport.height).to(equal(1080))
        expect(viewport.dpr).to(equal(1.0))

    # Test 2: Viewport with high DPI
    it "creates viewport with device pixel ratio":
        let viewport = Viewport::new(1920, 1080, 2.0)

        expect(viewport.logical_width).to(equal(960.0))
        expect(viewport.logical_height).to(equal(540.0))
        expect(viewport.dpr).to(equal(2.0))

    # Test 3: Basic widget for GPU rendering
    it "renders simple text widget for Vulkan":
        let text_widget = Text::new("Vulkan Rendered Text")
            .style(TextStyle::new()
                .font_size(24)
                .color(Color::white()))

        let mut build_ctx = BuildContext::new()
        let widget_node = text_widget.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Text))
        expect(widget_node.root.text).to(equal(Some("Vulkan Rendered Text".to_string())))

    # Test 4: GPU-accelerated layout
    it "renders column layout for GPU":
        let column = Column::new()
            .spacing(16)
            .padding(EdgeInsets::all(32))
            .children([
                Text::new("Header").style(TextStyle::new().bold().font_size(32)),
                Text::new("Subheader").style(TextStyle::new().font_size(18)),
                Container::new()
                    .width(400)
                    .height(300)
                    .background(Color::rgba(100, 150, 200, 255))
            ])

        let mut build_ctx = BuildContext::new()
        let widget_node = column.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Column))
        expect(widget_node.children.len()).to(equal(3))

    # Test 5: Image widget for GPU texture
    it "renders image widget for GPU texture loading":
        let image = Image::new("assets/logo.png")
            .width(512)
            .height(512)
            .fit(ImageFit::Cover)

        let mut build_ctx = BuildContext::new()
        let widget_node = image.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Image))
        expect(widget_node.root.attrs.get("src"))
            .to(equal(Some(&"assets/logo.png".to_string())))

    # Test 6: Button with GPU styling
    it "renders styled button for Vulkan":
        let button = Button::new("GPU Accelerated")
            .primary()
            .width(200)
            .height(48)

        let mut build_ctx = BuildContext::new()
        let widget_node = button.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Button))

    # Test 7: Container with gradient background
    it "renders container with visual styling":
        let container = Container::new()
            .width(800)
            .height(600)
            .background(Color::rgba(50, 50, 50, 255))
            .border(BorderStyle::solid(2, Color::white()))
            .border_radius(8)
            .child(Text::new("Styled Container"))

        let mut build_ctx = BuildContext::new()
        let widget_node = container.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Div))

    # Test 8: Complex UI for GPU rendering
    it "renders complex dashboard layout":
        let dashboard = Column::new()
            .width(1920)
            .height(1080)
            .padding(EdgeInsets::all(24))
            .children([
                # Header
                Row::new()
                    .height(80)
                    .justify(JustifyContent::SpaceBetween)
                    .children([
                        Text::new("Dashboard").style(TextStyle::new().bold().font_size(32)),
                        Button::new("Settings").outlined()
                    ]),

                # Content area
                Row::new()
                    .flex(1)
                    .gap(24)
                    .children([
                        # Sidebar
                        Column::new()
                            .width(300)
                            .background(Color::rgba(30, 30, 30, 255))
                            .padding(EdgeInsets::all(16))
                            .children([
                                Text::new("Navigation"),
                                Divider::new(),
                                Button::new("Home").text_align(Align::Start),
                                Button::new("Profile").text_align(Align::Start),
                                Button::new("Settings").text_align(Align::Start)
                            ]),

                        # Main content
                        Column::new()
                            .flex(1)
                            .children([
                                Text::new("Main Content Area"),
                                Grid::new()
                                    .columns(3)
                                    .gap(16)
                                    .children([
                                        Container::new().width(200).height(200).background(Color::blue()),
                                        Container::new().width(200).height(200).background(Color::green()),
                                        Container::new().width(200).height(200).background(Color::red()),
                                        Container::new().width(200).height(200).background(Color::yellow()),
                                        Container::new().width(200).height(200).background(Color::magenta()),
                                        Container::new().width(200).height(200).background(Color::cyan())
                                    ])
                            ])
                    ])
            ])

        let mut build_ctx = BuildContext::new()
        let widget_node = dashboard.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Column))
        expect(widget_node.children.len()).to(equal(2))

    # Test 9: Stack layout with z-index
    it "renders overlapping elements with stack":
        let stack = Stack::new()
            .width(400)
            .height(400)
            .children([
                # Background
                Container::new()
                    .width(400)
                    .height(400)
                    .background(Color::rgba(0, 0, 0, 200)),

                # Centered content
                Column::new()
                    .align(Align::Center)
                    .justify(JustifyContent::Center)
                    .children([
                        Text::new("Overlay Text")
                            .style(TextStyle::new().color(Color::white()).font_size(24)),
                        Button::new("Close").primary()
                    ])
            ])

        let mut build_ctx = BuildContext::new()
        let widget_node = stack.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Stack))
        expect(widget_node.children.len()).to(equal(2))

    # Test 10: Responsive design with breakpoints
    it "creates responsive widget with breakpoints":
        let viewport_mobile = Viewport::new(375, 667, 2.0)
        let viewport_desktop = Viewport::new(1920, 1080, 1.0)

        let breakpoints = Breakpoints::default()

        expect(breakpoints.current_breakpoint(&viewport_mobile))
            .to(equal(BreakpointSize::XS))

        expect(breakpoints.current_breakpoint(&viewport_desktop))
            .to(equal(BreakpointSize::XL))

    # Test 11: Animated progress bar
    it "renders animated progress bar":
        let progress = ProgressBar::new()
            .value(0.5)
            .animated(true)
            .color(Color::green())
            .height(8)

        let mut build_ctx = BuildContext::new()
        let widget_node = progress.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::ProgressBar))

    # Test 12: Badge with icon
    it "renders badge with notification":
        let badge = Badge::new("5")
            .variant(BadgeVariant::Error)
            .position(BadgePosition::TopRight)

        let mut build_ctx = BuildContext::new()
        let widget_node = badge.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Badge))

    # Test 13: Form layout
    it "renders form with multiple inputs":
        let form = Column::new()
            .spacing(16)
            .padding(EdgeInsets::all(24))
            .children([
                Text::new("Login Form").style(TextStyle::new().bold().font_size(24)),

                TextField::new()
                    .placeholder("Username")
                    .width(300),

                TextField::new()
                    .placeholder("Password")
                    .password(true)
                    .width(300),

                Checkbox::new("Remember me"),

                Row::new()
                    .spacing(8)
                    .justify(JustifyContent::End)
                    .children([
                        Button::new("Cancel").secondary(),
                        Button::new("Login").primary()
                    ])
            ])

        let mut build_ctx = BuildContext::new()
        let widget_node = form.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Column))
        expect(widget_node.children.len()).to(equal(5))

    # Test 14: Card layout
    it "renders card with shadow":
        let card = Container::new()
            .width(400)
            .height(300)
            .background(Color::white())
            .border_radius(12)
            .shadow(Shadow::new(0, 4, 8, Color::rgba(0, 0, 0, 50)))
            .padding(EdgeInsets::all(24))
            .child(
                Column::new()
                    .spacing(16)
                    .children([
                        Text::new("Card Title").style(TextStyle::new().bold().font_size(20)),
                        Text::new("Card content goes here..."),
                        Button::new("Action").primary()
                    ])
            )

        let mut build_ctx = BuildContext::new()
        let widget_node = card.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Div))

    # Test 15: Element tree conversion for GPU
    it "converts complex widget to element tree for Vulkan":
        let app = Column::new()
            .children([
                Text::new("GPU Accelerated UI"),
                Row::new()
                    .children([
                        Button::new("Button 1"),
                        Button::new("Button 2"),
                        Button::new("Button 3")
                    ])
            ])

        let mut build_ctx = BuildContext::new()
        let widget_node = app.build(&mut build_ctx)
        let element_tree = widget_node.to_element_tree()

        expect(element_tree.root().kind).to(equal(ElementKind::Column))
        expect(element_tree.root().children.len()).to_be_greater_than(0)

    # Test 16: State-driven rendering
    it "updates widget based on state changes":
        let count = State::new(0)

        # Initial render
        let app1 = Text::new(format!("Count: {}", count.get()))
        let mut build_ctx1 = BuildContext::new()
        let widget1 = app1.build(&mut build_ctx1)
        expect(widget1.root.text).to(equal(Some("Count: 0".to_string())))

        # Update state
        count.set(42)

        # Re-render with new state
        let app2 = Text::new(format!("Count: {}", count.get()))
        let mut build_ctx2 = BuildContext::new()
        let widget2 = app2.build(&mut build_ctx2)
        expect(widget2.root.text).to(equal(Some("Count: 42".to_string())))

    # Test 17: Vulkan renderer capabilities
    context "Vulkan Renderer Capabilities":
        it "reports GPU capabilities":
            # Placeholder for async Vulkan renderer test
            # Would check: supports_transparency, supports_shadows, max_texture_size, etc.
            expect(true).to_be_true()

        it "initializes Vulkan instance":
            # Placeholder for async Vulkan renderer test
            expect(true).to_be_true()

    # Test 18: Performance - large widget tree
    it "handles large widget tree efficiently":
        let mut items: Array[Box[dyn Widget]] = []
        for i in 0..100:
            items.push(Text::new(format!("Item {}", i)))

        let large_tree = Column::new().children(items)

        let mut build_ctx = BuildContext::new()
        let widget_node = large_tree.build(&mut build_ctx)

        expect(widget_node.children.len()).to(equal(100))

    # Test 19: Custom widget composition
    it "composes custom widget from primitives":
        fn create_custom_button(label: &str) -> Box[dyn Widget]:
            return Container::new()
                .padding(EdgeInsets::symmetric(16, 32))
                .background(Color::blue())
                .border_radius(8)
                .child(
                    Text::new(label)
                        .style(TextStyle::new().color(Color::white()).bold())
                )

        let custom_btn = create_custom_button("Custom")
        let mut build_ctx = BuildContext::new()
        let widget_node = custom_btn.build(&mut build_ctx)

        expect(widget_node.root.kind).to(equal(ElementKind::Div))

    # Test 20: Responsive layout adaptation
    it "adapts layout based on viewport size":
        let create_responsive_layout = fn(is_mobile: bool) -> Box[dyn Widget]:
            if is_mobile:
                return Column::new()
                    .children([
                        Text::new("Mobile Layout"),
                        Button::new("Menu").width(100, Percent)
                    ])
            else:
                return Row::new()
                    .children([
                        Text::new("Desktop Layout"),
                        Button::new("Menu").width(200)
                    ])

        # Mobile layout
        let mobile = create_responsive_layout(true)
        let mut ctx1 = BuildContext::new()
        let mobile_node = mobile.build(&mut ctx1)
        expect(mobile_node.root.kind).to(equal(ElementKind::Column))

        # Desktop layout
        let desktop = create_responsive_layout(false)
        let mut ctx2 = BuildContext::new()
        let desktop_node = desktop.build(&mut ctx2)
        expect(desktop_node.root.kind).to(equal(ElementKind::Row))

# Run the specs
spec_main()
