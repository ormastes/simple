# CLI Automatic File Staging Demo - Python argparse-style
#
# This example demonstrates automatic file staging:
# - File arguments are automatically validated during parse()
# - No manual validation needed - files ready to use
# - File errors reported as parse errors
# - Both relative and absolute paths supported
#
# Usage:
#   ./simple cli_auto_stage_demo.spl --input main.spl file1.spl file2.spl
#   ./simple cli_auto_stage_demo.spl -i config.json --output result.txt
#   ./simple cli_auto_stage_demo.spl --help

use cli
use cli.file as file

fn main():
    # Create parser with automatic file staging
    let parser = cli.ArgParser::new("auto_stage_demo", "Automatic file staging demo")
        .flag("verbose", "v", "Enable verbose output")

        # File option - automatically staged and validated
        .file_option("input", "i", "Input file (must exist, readable)",
                     required: true, must_exist: true)

        # Output file option - can be created
        .file_option("output", "o", "Output file (writable)",
                     required: false, must_exist: false)

        # File positionals - all automatically staged
        .file_positional("files", "Additional files to process (must exist)",
                         required: false)

    # Parse arguments - files are automatically staged!
    match parser.parse(sys_get_args()):
        case Ok(args):
            # Files are already validated and staged - ready to use!
            process_files(args)

        case Err(error):
            # File validation errors are included here
            print(f"Error: {error}")
            print("")
            parser.print_help()
            sys_exit(1)

fn process_files(args: cli.ParsedArgs):
    let verbose = args.get_flag("verbose")

    if verbose:
        print("=== Automatic File Staging Demo ===")
        print("")

    # All files are pre-validated and staged
    let staged = args.files

    if verbose:
        print(f"Total files staged: {staged.count()}")
        print("")

    # Check for any staging errors (should be empty if parse succeeded)
    if staged.has_errors():
        print("File staging errors:")
        for error in staged.get_errors():
            print(f"  - {error}")
        sys_exit(1)

    # Process all staged files
    print("Processing files:")
    for file_info in staged.staged():
        print(f"  âœ“ {file_info.path}")

        if verbose:
            print(f"    - Absolute path: {file_info.absolute_path}")
            print(f"    - Exists: {file_info.exists}")
            print(f"    - Readable: {file_info.is_readable}")
            print(f"    - Extension: {file.get_file_extension(file_info.path)}")
            print("")

    # Get specific file options
    let input_file = args.get_option("input")
    let output_file = args.get_option("output")

    if verbose:
        print("=== File Options ===")
        match input_file:
            case Some(path):
                print(f"Input file: {path}")
            case None:
                print("No input file specified")

        match output_file:
            case Some(path):
                print(f"Output file: {path}")
            case None:
                print("No output file specified (will use default)")
        print("")

    # Demonstrate accessing staged input file
    if input_file.is_some():
        let input_path = input_file.unwrap()

        # Find the staged file info
        for file_info in staged.staged():
            if file_info.path == input_path:
                print(f"Input file ready: {file_info.absolute_path}")
                # File is validated - can safely open and read
                # process_input_file(file_info.absolute_path)
                break

    print("")
    print("=== Demo Complete ===")
    print("")
    print("Key Features Demonstrated:")
    print("  1. Files automatically staged during parse()")
    print("  2. No manual validation needed")
    print("  3. File errors caught before processing")
    print("  4. Relative/absolute paths both supported")
    print("  5. Files ready to use immediately")
