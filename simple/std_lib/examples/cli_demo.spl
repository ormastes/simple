# CLI Library Demo - Command-Line Argument Parsing Example
#
# This example demonstrates the CLI library's features:
# - Boolean flags (--verbose, -v)
# - String options (--output, -o)
# - Required vs optional options
# - Default values
# - Positional arguments
# - Automatic help generation
#
# Try running with different arguments:
#   ./simple cli_demo.spl input.txt --output out.txt -v
#   ./simple cli_demo.spl --help
#   ./simple cli_demo.spl input.txt -o out.txt --count 5
#   ./simple cli_demo.spl input.txt  # Missing required --output

use cli

fn main():
    # Create argument parser with program name and description
    let parser = cli.ArgParser::new("cli_demo", "Demo application for CLI argument parsing")
        # Add boolean flags
        .flag("verbose", "v", "Enable verbose output")
        .flag("debug", "d", "Enable debug mode")
        .flag("quiet", "q", "Suppress all output except errors")

        # Add required option
        .required_option("output", "o", "Output file path (required)")

        # Add optional options with defaults
        .optional_option("format", "f", "Output format", "json")
        .optional_option("count", "c", "Number of items to process", "10")

        # Add optional option without default
        .option("config", "", "Configuration file path", false, None)

        # Add required positional argument
        .required_positional("input", "Input file path")

    # Get command-line arguments (excluding program name)
    let args = sys_get_args()

    # Parse arguments
    match parser.parse(args):
        case Ok(parsed):
            # Process parsed arguments
            process_args(parsed)

        case Err(error):
            # Print error and help message
            print(f"Error: {error}")
            print("")
            parser.print_help()
            sys_exit(1)

fn process_args(args: cli.ParsedArgs):
    print("=== CLI Demo - Parsed Arguments ===")
    print("")

    # Access flags
    let verbose = args.get_flag("verbose")
    let debug = args.get_flag("debug")
    let quiet = args.get_flag("quiet")

    if verbose:
        print("[VERBOSE] Verbose mode enabled")
    if debug:
        print("[DEBUG] Debug mode enabled")
    if quiet:
        print("[QUIET] Quiet mode enabled")

    # Access required option
    let output = args.get_option("output")
    match output:
        case Some(path):
            print(f"Output file: {path}")
        case None:
            print("Error: Output option not found (should not happen if required)")

    # Access optional options with defaults
    let format = args.get_option_or("format", "json")
    let count_str = args.get_option_or("count", "10")

    print(f"Output format: {format}")
    print(f"Item count: {count_str}")

    # Access optional option without default
    let config = args.get_option("config")
    match config:
        case Some(path):
            print(f"Config file: {path}")
        case None:
            print("Config file: (not specified)")

    # Access positional argument
    let input = args.get_positional_at(0)
    match input:
        case Some(path):
            print(f"Input file: {path}")
        case None:
            print("Error: Input file not found")

    # Show all positionals
    let positionals = args.get_all_positionals()
    print(f"Total positional arguments: {positionals.len()}")

    print("")
    print("=== Processing Complete ===")

    # Example processing logic based on flags
    if not quiet:
        print("")
        print("Processing files...")

        if verbose:
            print(f"  Reading from: {input.unwrap_or('unknown')}")
            print(f"  Writing to: {output.unwrap_or('unknown')}")
            print(f"  Format: {format}")
            print(f"  Count: {count_str}")

        if debug:
            print(f"  Debug info:")
            print(f"    Flags: verbose={verbose}, debug={debug}, quiet={quiet}")
            print(f"    All positionals: {positionals}")

        print("Done!")
