# CLI Integration Example
#
# Demonstrates how file I/O integrates with CLI argument parsing using unified io.fs API.

use cli
use io.fs as fs
use std.io

async fn main():
    # Parse arguments - this validates file paths (sync)
    let parser = cli.ArgParser::new("processor", "Process input files")
        .file_option("input", "i", "Input file", required: true, must_exist: true)
        .file_option("output", "o", "Output file", required: false)
        .help()

    match parser.parse(sys_get_args()):
        case Ok(args):
            # Get the validated file paths
            let input_path = args.get_option("input")?
            let output_path = args.get_option("output").unwrap_or("output.txt"_filepath)

            # Use async file loading to read the file (zero-copy mmap)
            io.println("Loading input file: {input_path}")
            async with await fs.open_mmap(input_path) as mmap:
                let data = mmap.as_bytes()
                io.println("Read {data.len()} bytes")

                # Process the data
                let processed = process_data(data)

                # Write output using async API
                await fs.write(output_path, processed)?
                io.println("Wrote output to: {output_path}")

        case Err(error):
            io.eprintln("Error: {error}")
            exit(1)

fn process_data(data: &[u8]) -> &[u8]:
    # Process the data (example: just return it)
    return data

# Note: write_output is now done inline with fs.write

fn sys_get_args() -> Array[String]:
    # TODO: Get command line arguments
    return ["processor", "-i", "input.txt", "-o", "output.txt"]

fn exit(code: i32):
    # TODO: Exit process
    pass
