# Vector Addition - Basic GPU Kernel Example
#
# This example demonstrates the simplest GPU kernel: element-wise addition
# of two arrays. This is the "Hello World" of GPU computing.
#
# Compilation: ./simple examples/gpu/vulkan/vector_add.spl
# Run with: --gpu vulkan (automatic backend selection)

import std.gpu
import std.io

# GPU kernel - runs on device
#[gpu]
fn vector_add_kernel(a: []f32, b: []f32, result: []f32):
    """
    Add corresponding elements from arrays a and b, store in result.
    Each GPU thread processes one element.
    """
    # Get global thread ID (which element this thread processes)
    idx = gpu.global_id(0)

    # Bounds check (kernel may launch more threads than elements)
    if idx < len(result):
        result[idx] = a[idx] + b[idx]

# Host function - runs on CPU
fn vector_add_example():
    """
    Example: Add two arrays of 1024 elements using GPU
    """
    size = 1024

    # Create input data on CPU
    a = [f32(i) for i in range(size)]  # [0.0, 1.0, 2.0, ...]
    b = [f32(i * 2) for i in range(size)]  # [0.0, 2.0, 4.0, ...]

    io.println("Vector Addition Example")
    io.println("Size: " + str(size) + " elements")
    io.println("")

    # Check if Vulkan is available
    if !gpu.device_available():
        io.println("Error: Vulkan not available on this system")
        io.println("Please install Vulkan drivers")
        return

    # Create GPU device context
    device = gpu.Device()

    # Allocate GPU buffers
    buf_a = device.alloc_buffer(a)  # Upload a to GPU
    buf_b = device.alloc_buffer(b)  # Upload b to GPU
    buf_result = device.alloc_buffer_like(a)  # Allocate output buffer

    # Launch kernel
    # - 1024 global work items (one per element)
    # - Automatically chooses optimal work group size (typically 256)
    device.launch_1d(
        vector_add_kernel,
        [buf_a, buf_b, buf_result],
        global_size=size
    )

    # Download results from GPU to CPU
    result = device.download(buf_result)

    # Verify results
    io.println("Verification:")
    errors = 0
    for i in range(min(10, size)):
        expected = a[i] + b[i]
        actual = result[i]
        status = "✓" if abs(actual - expected) < 0.001 else "✗"
        io.println("  [" + str(i) + "] " + str(a[i]) + " + " + str(b[i]) +
                   " = " + str(actual) + " (expected " + str(expected) + ") " + status)
        if abs(actual - expected) >= 0.001:
            errors += 1

    if errors == 0:
        io.println("")
        io.println("✓ All results correct!")
    else:
        io.println("")
        io.println("✗ " + str(errors) + " errors found")

    # Cleanup happens automatically when device goes out of scope

fn main():
    vector_add_example()
