# CLI File Validation Demo - Python argparse-style automatic file staging
#
# This example demonstrates automatic file validation:
# - Files automatically validated during parse()
# - File existence checking (relative or absolute paths)
# - File type validation with extensions
# - Input/output file validation
# - Error handling for missing/invalid files
# - No manual validation needed!
#
# Usage:
#   ./simple cli_file_demo.spl --input src/main.spl --output build/out.txt file1.spl file2.spl
#   ./simple cli_file_demo.spl -i config.json
#   ./simple cli_file_demo.spl --help

use cli
use cli.file as file

fn main():
    # Create argument parser with automatic file staging
    let parser = cli.ArgParser::new("file_processor", "Process source files with automatic validation")
        .flag("verbose", "v", "Enable verbose output")

        # File options - automatically validated!
        .file_option("input", "i", "Primary input file (must exist)",
                     required: true, must_exist: true)
                     .with_extensions(["spl", "rs", "py", "js", "ts"])

        .file_option("output", "o", "Output file path (writable)",
                     required: false, must_exist: false)

        .file_option("config", "c", "Configuration file (JSON/TOML/YAML)",
                     required: false, must_exist: true)
                     .with_extensions(["json", "toml", "yaml", "yml"])

        # File positionals - also automatically validated
        .file_positional("files", "Additional files to process", required: false)

    # Parse arguments - files are automatically staged!
    match parser.parse(sys_get_args()):
        case Ok(args):
            # Files already validated - ready to use!
            process_files(args)

        case Err(error):
            # File validation errors included here
            print(f"Error: {error}")
            parser.print_help()
            sys_exit(1)

fn process_files(args: cli.ParsedArgs):
    let verbose = args.get_flag("verbose")

    if verbose:
        print("=== File Processor - Automatic Validation Demo ===")
        print("")

    # All files are pre-validated and ready!
    let staged = args.files

    # Check for staging errors (should be empty if parse succeeded)
    if staged.has_errors():
        print("File staging errors:")
        for error in staged.get_errors():
            print(f"  ✗ {error}")
        sys_exit(1)

    # Display all staged files
    if verbose:
        print(f"Total files staged: {staged.count()}")
        print("")

    # Access specific file options
    let input_path = args.get_option("input").unwrap_or("")
    let output_path = args.get_option("output")
    let config_path = args.get_option("config")

    # Input file (required, already validated)
    if input_path != "":
        print(f"✓ Input file: {input_path}")
        if verbose:
            # Find in staged files for details
            for file_info in staged.staged():
                if file_info.path == input_path:
                    print(f"  - Absolute: {file_info.absolute_path}")
                    print(f"  - Exists: {file_info.exists}")
                    print(f"  - Readable: {file_info.is_readable}")
                    print(f"  - Extension: {file.get_file_extension(file_info.path)}")
                    break

    # Output file (optional, validated if provided)
    match output_path:
        case Some(path):
            print(f"✓ Output file: {path}")
            if verbose:
                for file_info in staged.staged():
                    if file_info.path == path:
                        if not file_info.exists:
                            print(f"  - Will be created")
                        else:
                            print(f"  - Will be overwritten")
                        break
        case None:
            if verbose:
                print("No output file specified (default: output.txt)")

    # Config file (optional, validated if provided)
    match config_path:
        case Some(path):
            print(f"✓ Config file: {path}")
            if verbose:
                for file_info in staged.staged():
                    if file_info.path == path:
                        print(f"  - Format: {file.get_file_extension(file_info.path)}")
                        break
        case None:
            if verbose:
                print("No config file specified")

    # Additional files (positionals, all validated)
    let positionals = args.get_all_positionals()
    if positionals.len() > 0:
        print("")
        print(f"Additional files ({positionals.len()}):")
        for path in positionals:
            print(f"  ✓ {path}")
            if verbose:
                for file_info in staged.staged():
                    if file_info.path == path:
                        print(f"    - Directory: {file.get_directory(file_info.path)}")
                        print(f"    - Filename: {file.get_filename(file_info.path)}")
                        print(f"    - Basename: {file.get_basename(file_info.path)}")
                        print(f"    - Extension: {file.get_file_extension(file_info.path)}")
                        break

    # Demonstrate path utilities
    if verbose and input_path != "":
        print("")
        print("=== Path Utilities Demo ===")
        demo_path_utilities(input_path)

    print("")
    print("=== Processing Complete ===")
    print("")
    print("Key Features:")
    print("  ✓ Files automatically staged during parse()")
    print("  ✓ No manual validation required")
    print("  ✓ Extension filtering enforced")
    print("  ✓ Relative/absolute paths handled")
    print("  ✓ File errors caught before processing")

fn demo_path_utilities(path: String):
    print(f"Path: {path}")
    print(f"  - Is absolute: {file.is_absolute_path(path)}")
    print(f"  - Is relative: {file.is_relative_path(path)}")
    print(f"  - Normalized: {file.normalize_path(path)}")
    print(f"  - Directory: {file.get_directory(path)}")
    print(f"  - Filename: {file.get_filename(path)}")
    print(f"  - Basename: {file.get_basename(path)}")
    print(f"  - Extension: {file.get_file_extension(path)}")

    # Demonstrate path joining
    let base_dir = file.get_directory(path)
    let new_file = file.join_paths(base_dir, "newfile.txt")
    print(f"  - Joined path: {new_file}")
