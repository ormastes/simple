///
Simple Build System

Self-hosted build script for Simple development tools.
Reads configuration from simple.sdn and builds all targets.

Usage:
    simple build.spl                  # Build all targets
    simple build.spl --target=fmt     # Build specific target
    simple build.spl --clean          # Clean build artifacts
    simple build.spl --watch          # Watch and rebuild on changes
///

import std.io
import std.fs
import std.process
import std.args
import sdn.document.SdnDocument

fn main():
    io.println("=== Simple Build System ===")
    io.println("")

    # Parse command-line arguments
    val argv = args.get_args()
    val config = parse_args(argv)

    # Load project configuration
    val project_config = load_config("simple.sdn")

    match config.mode:
        case BuildMode.Clean:
            clean_build(project_config)
        case BuildMode.BuildAll:
            build_all(project_config)
        case BuildMode.BuildTarget(target):
            build_target(project_config, target)
        case BuildMode.Watch:
            watch_and_build(project_config)

enum BuildMode:
    Clean
    BuildAll
    BuildTarget(String)
    Watch

struct BuildConfig:
    mode: BuildMode
    verbose: Bool
    parallel: Bool

struct ProjectConfig:
    name: String
    targets: Dict[String, TargetConfig]
    build: BuildSettings
    paths: PathConfig

struct TargetConfig:
    source: String
    output: String
    build_dir: String
    type: String
    description: String

struct BuildSettings:
    parallel: Bool
    max_jobs: Int
    incremental: Bool

struct PathConfig:
    bin: String
    build: String
    source: String

### Command-line argument parsing

fn parse_args(argv: List[String]) -> BuildConfig:
    var mode = BuildMode.BuildAll
    var verbose = False
    var parallel = True

    for arg in argv[1..]:
        match arg:
            case "--clean":
                mode = BuildMode.Clean
            case "--watch":
                mode = BuildMode.Watch
            case "--verbose":
                verbose = True
            case "--no-parallel":
                parallel = False
            case arg if arg.starts_with("--target="):
                val target = arg.split("=")[1]
                mode = BuildMode.BuildTarget(target)
            case "--help":
                print_help()
                process.exit(0)
            case _:
                io.eprintln("Unknown argument: ${arg}")
                print_help()
                process.exit(1)

    return BuildConfig(mode: mode, verbose: verbose, parallel: parallel)

fn print_help():
    io.println("Simple Build System")
    io.println("")
    io.println("USAGE:")
    io.println("    simple build.spl [OPTIONS]")
    io.println("")
    io.println("OPTIONS:")
    io.println("    --clean              Clean build artifacts")
    io.println("    --target=<name>      Build specific target (fmt, lint, sdn, lsp, dap)")
    io.println("    --watch              Watch files and rebuild on changes")
    io.println("    --verbose            Verbose output")
    io.println("    --no-parallel        Disable parallel builds")
    io.println("    --help               Print this help message")
    io.println("")
    io.println("EXAMPLES:")
    io.println("    simple build.spl                  # Build all targets")
    io.println("    simple build.spl --target=fmt     # Build formatter only")
    io.println("    simple build.spl --clean          # Clean build artifacts")
    io.println("    simple build.spl --watch          # Watch and auto-rebuild")

### Configuration loading

fn load_config(path: String) -> ProjectConfig:
    """Load project configuration from simple.sdn"""
    io.println("Loading configuration from ${path}...")

    match SdnDocument.from_file(path):
        case Ok(doc):
            # Extract project info
            val name = doc.get("project.name")
                .flatmap(|v| v.as_str())
                .unwrap_or("Simple")

            # Extract targets
            var targets = {}
            val target_names = ["formatter", "linter", "sdn", "lsp", "dap"]

            for target_name in target_names:
                val source = doc.get("targets.${target_name}.source")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                val output = doc.get("targets.${target_name}.output")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                val build_dir = doc.get("targets.${target_name}.build_dir")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                val target_type = doc.get("targets.${target_name}.type")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("executable")

                val description = doc.get("targets.${target_name}.description")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                targets[target_name] = TargetConfig(
                    source: source,
                    output: output,
                    build_dir: build_dir,
                    type: target_type,
                    description: description
                )

            # Extract build settings
            val parallel = doc.get("build.parallel")
                .flatmap(|v| v.as_bool())
                .unwrap_or(True)

            val max_jobs = doc.get("build.max_jobs")
                .flatmap(|v| v.as_i64())
                .unwrap_or(4)

            val incremental = doc.get("build.incremental")
                .flatmap(|v| v.as_bool())
                .unwrap_or(True)

            val build = BuildSettings(
                parallel: parallel,
                max_jobs: max_jobs,
                incremental: incremental
            )

            # Extract paths
            val bin = doc.get("paths.bin")
                .flatmap(|v| v.as_str())
                .unwrap_or("simple/bin_simple")

            val build_path = doc.get("paths.build")
                .flatmap(|v| v.as_str())
                .unwrap_or("simple/build")

            val source = doc.get("paths.source")
                .flatmap(|v| v.as_str())
                .unwrap_or("simple/app")

            val paths = PathConfig(
                bin: bin,
                build: build_path,
                source: source
            )

            return ProjectConfig(
                name: name,
                targets: targets,
                build: build,
                paths: paths
            )

        case Err(e):
            io.eprintln("Failed to load config: ${e}")
            process.exit(1)

### Build operations

fn build_all(config: ProjectConfig):
    """Build all targets"""
    io.println("Building all targets...")
    io.println("")

    # Create output directories
    create_build_dirs(config)

    # Build each target
    val target_order = ["formatter", "linter", "sdn", "lsp", "dap"]

    for target_name in target_order:
        match config.targets.get(target_name):
            case Some(target):
                build_target_impl(target_name, target)
            case None:
                io.println("⚠ Target ${target_name} not found in config")

    io.println("")
    io.println("=== Build Complete ===")
    print_summary(config)

fn build_target(config: ProjectConfig, target_name: String):
    """Build specific target"""
    io.println("Building target: ${target_name}...")
    io.println("")

    create_build_dirs(config)

    match config.targets.get(target_name):
        case Some(target):
            build_target_impl(target_name, target)
            io.println("")
            io.println("=== Build Complete ===")
        case None:
            io.eprintln("Error: Target '${target_name}' not found")
            io.eprintln("")
            io.eprintln("Available targets: formatter, linter, sdn, lsp, dap")
            process.exit(1)

fn build_target_impl(name: String, target: TargetConfig):
    """Build a single target"""
    io.println("Building ${name}...")
    io.println("  Source: ${target.source}")
    io.println("  Output: ${target.output}")

    # Find compiler
    val compiler = find_compiler()

    match compiler:
        case Some(compiler_path):
            # Build command
            val result = process.run_command(
                compiler_path,
                [
                    "compile",
                    target.source,
                    "--output",
                    target.output,
                    "--build-dir",
                    target.build_dir
                ]
            )

            match result:
                case Ok(output):
                    if output.exit_code == 0:
                        io.println("✓ ${name} built successfully: ${target.output}")
                    else:
                        io.eprintln("✗ ${name} build failed:")
                        io.eprintln(output.stderr)
                        process.exit(1)
                case Err(e):
                    io.eprintln("✗ Failed to run compiler: ${e}")
                    process.exit(1)
        case None:
            io.eprintln("Error: Simple compiler not found")
            io.eprintln("Please build the compiler first: cargo build")
            process.exit(1)

fn clean_build(config: ProjectConfig):
    """Clean build artifacts"""
    io.println("Cleaning build artifacts...")

    # Remove build directory
    if fs.exists(config.paths.build):
        match fs.remove_dir_all(config.paths.build):
            case Ok(_):
                io.println("✓ Removed ${config.paths.build}")
            case Err(e):
                io.eprintln("Failed to remove build dir: ${e}")

    # Remove binaries
    if fs.exists(config.paths.bin):
        match fs.remove_dir_all(config.paths.bin):
            case Ok(_):
                io.println("✓ Removed ${config.paths.bin}")
            case Err(e):
                io.eprintln("Failed to remove bin dir: ${e}")

    io.println("")
    io.println("=== Clean Complete ===")

fn watch_and_build(config: ProjectConfig):
    """Watch files and rebuild on changes"""
    io.println("Watch mode enabled")
    io.println("Watching for changes in ${config.paths.source}...")
    io.println("")

    # Initial build
    build_all(config)

    # Watch loop (simplified - real implementation would use file watcher)
    io.println("")
    io.println("Watching for changes... (Press Ctrl+C to exit)")

    loop:
        # Sleep for a bit
        process.sleep(1000)

        # Check for changes (simplified)
        # Real implementation would use fs.watch() or similar
        # For now, just rebuild periodically
        # TODO: [compiler][P1] Implement proper file watching

### Helper functions

fn create_build_dirs(config: ProjectConfig):
    """Create build directories"""
    fs.create_dir_all(config.paths.bin)
    fs.create_dir_all(config.paths.build)

    for (name, target) in config.targets.items():
        fs.create_dir_all(target.build_dir)

fn find_compiler() -> Option[String]:
    """Find Simple compiler binary"""
    val candidates = [
        "target/debug/simple",
        "./target/debug/simple",
        "simple/bin/simple"
    ]

    for path in candidates:
        if fs.exists(path):
            return Some(path)

    return None

fn print_summary(config: ProjectConfig):
    """Print build summary"""
    io.println("")
    io.println("Built executables:")

    for (name, target) in config.targets.items():
        io.println("  ${target.output} - ${target.description}")

    io.println("")
    io.println("Usage:")
    io.println("  Formatter:  ${config.paths.bin}/simple_fmt <file.spl> [--check|--write]")
    io.println("  Linter:     ${config.paths.bin}/simple_lint <file.spl> [--deny-all]")
    io.println("  SDN CLI:    ${config.paths.bin}/simple_sdn <command> <args>")
    io.println("  LSP Server: ${config.paths.bin}/simple_lsp")
    io.println("  DAP Server: ${config.paths.bin}/simple_dap")
