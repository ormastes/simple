#!/usr/bin/env simple
# Standalone Physics Collision Test Program
# Tests collision detection without spec DSL

import physics.core as core
import physics.collision as collision

fn test_aabb_creation():
    print("Testing AABB creation...")

    # Test from min/max
    val min = core.Vector3(0.0, 0.0, 0.0)
    val max = core.Vector3(1.0, 1.0, 1.0)
    val aabb = collision.AABB(min, max)
    assert aabb.min.x == 0.0, "AABB min.x should be 0.0"
    assert aabb.max.x == 1.0, "AABB max.x should be 1.0"
    print("  ✓ AABB from min/max works")

    # Test from center/size
    val center = core.Vector3::zero()
    val size = core.Vector3(2.0, 2.0, 2.0)
    val aabb2 = collision.AABB::from_center_size(center, size)
    assert aabb2.min.x == -1.0, "AABB min.x should be -1.0"
    assert aabb2.max.x == 1.0, "AABB max.x should be 1.0"
    print("  ✓ AABB from center/size works")

fn test_aabb_intersection():
    print("Testing AABB intersection...")

    # Overlapping AABBs
    val aabb1 = collision.AABB::from_center_size(
        core.Vector3::zero(),
        core.Vector3(2.0, 2.0, 2.0)
    )
    val aabb2 = collision.AABB::from_center_size(
        core.Vector3(1.0, 0.0, 0.0),
        core.Vector3(2.0, 2.0, 2.0)
    )
    assert aabb1.intersects(aabb2), "AABBs should intersect"
    print("  ✓ Overlapping AABB detection works")

    # Non-overlapping AABBs
    val aabb3 = collision.AABB::from_center_size(
        core.Vector3::zero(),
        core.Vector3(1.0, 1.0, 1.0)
    )
    val aabb4 = collision.AABB::from_center_size(
        core.Vector3(5.0, 0.0, 0.0),
        core.Vector3(1.0, 1.0, 1.0)
    )
    assert not aabb3.intersects(aabb4), "AABBs should not intersect"
    print("  ✓ Non-overlapping AABB detection works")

fn test_aabb_point_containment():
    print("Testing AABB point containment...")

    val aabb = collision.AABB::from_center_size(
        core.Vector3::zero(),
        core.Vector3(2.0, 2.0, 2.0)
    )

    # Point inside
    val inside = core.Vector3(0.5, 0.5, 0.5)
    assert aabb.contains_point(inside), "Point should be inside AABB"
    print("  ✓ Point inside detection works")

    # Point outside
    val outside = core.Vector3(5.0, 5.0, 5.0)
    assert not aabb.contains_point(outside), "Point should be outside AABB"
    print("  ✓ Point outside detection works")

fn test_sphere_collision():
    print("Testing sphere-sphere collision...")

    # Colliding spheres
    val pos1 = core.Vector3::zero()
    val pos2 = core.Vector3(1.0, 0.0, 0.0)
    val colliding = collision.Detector::sphere_sphere(pos1, 1.0, pos2, 1.0)
    assert colliding, "Spheres should collide"
    print("  ✓ Colliding sphere detection works")

    # Non-colliding spheres
    val pos3 = core.Vector3::zero()
    val pos4 = core.Vector3(10.0, 0.0, 0.0)
    val not_colliding = collision.Detector::sphere_sphere(pos3, 1.0, pos4, 1.0)
    assert not not_colliding, "Spheres should not collide"
    print("  ✓ Non-colliding sphere detection works")

fn test_materials():
    print("Testing material presets...")

    # Rubber material
    val rubber = collision.Material::rubber()
    assert rubber.friction >= 0.8, "Rubber friction should be high"
    assert rubber.restitution >= 0.7, "Rubber restitution should be high"
    print("  ✓ Rubber material preset works")

    # Metal material
    val metal = collision.Material::metal()
    assert metal.friction >= 0.2, "Metal friction should be moderate"
    assert metal.friction <= 0.4, "Metal friction should be moderate"
    print("  ✓ Metal material preset works")

    # Ice material
    val ice = collision.Material::ice()
    assert ice.friction <= 0.1, "Ice friction should be very low"
    print("  ✓ Ice material preset works")

fn main():
    print("=== Physics Collision Test Suite ===\n")

    test_aabb_creation()
    test_aabb_intersection()
    test_aabb_point_containment()
    test_sphere_collision()
    test_materials()

    print("\n✅ All physics collision tests passed!")
    return 0
