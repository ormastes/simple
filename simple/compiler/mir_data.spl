# MIR - Mid-level Intermediate Representation (Data Structures)
#
# Lower-level IR between HIR and native code generation.
# Features:
# - Explicit control flow (basic blocks, terminators)
# - Explicit memory operations (load, store, alloc)
# - SSA form (each value defined once)
# - Type-annotated values
# - Ready for optimization and codegen
#
# This module contains:
# - MIR module structure and function definitions
# - MIR type system
# - Basic block and instruction definitions
# - MIR builder API for constructing MIR

use hir.SymbolId
use lexer.Span
use blocks.value.BlockValue

# ============================================================================
# MIR Module Structure
# ============================================================================

struct MirModule:
    """Complete MIR module."""
    name: text
    functions: Dict<SymbolId, MirFunction>
    statics: Dict<SymbolId, MirStatic>
    constants: Dict<SymbolId, MirConstant>
    types: Dict<SymbolId, MirTypeDef>

struct MirFunction:
    """Function in MIR."""
    symbol: SymbolId
    name: text
    signature: MirSignature
    locals: [MirLocal]
    blocks: [MirBlock]
    entry_block: BlockId
    span: Span

    # Generic template metadata for .smf template storage
    generic_params: [text]
    is_generic_template: bool
    specialization_of: text?
    type_bindings: Dict<text, HirType>

struct MirSignature:
    """Function signature."""
    params: [MirType]
    return_type: MirType
    is_variadic: bool

struct MirLocal:
    """Local variable slot."""
    id: LocalId
    name: text?
    type_: MirType
    kind: LocalKind

struct LocalId:
    """Local variable identifier."""
    id: i64

"""Kind of local variable."""
enum LocalKind:
    Arg(index: i64)     # Function argument
    Var                  # Regular variable
    Temp                 # Temporary (SSA)
    Return               # Return slot

struct MirStatic:
    """Static/global variable."""
    symbol: SymbolId
    name: text
    type_: MirType
    init: MirConstant?
    is_mutable: bool

struct MirConstant:
    """Compile-time constant."""
    symbol: SymbolId
    name: text
    type_: MirType
    value: MirConstValue

"""Constant value."""
enum MirConstValue:
    Int(value: i64)
    Float(value: f64)
    Bool(value: bool)
    Str(value: text)
    Array(elements: [MirConstValue])
    Tuple(elements: [MirConstValue])
    Struct(fields: Dict<text, MirConstValue>)
    Zero                 # Zero-initialized

struct MirTypeDef:
    """Type definition."""
    symbol: SymbolId
    name: text
    kind: MirTypeDefKind

"""Type definition kind."""
enum MirTypeDefKind:
    Struct(fields: [MirFieldDef])
    Enum(variants: [MirVariantDef])
    Union(variants: [MirType])

struct MirFieldDef:
    """Struct field definition."""
    name: text
    type_: MirType
    offset: i64

struct MirVariantDef:
    """Enum variant definition."""
    name: text
    discriminant: i64
    payload: MirType?

# ============================================================================
# MIR Types
# ============================================================================

struct MirType:
    """MIR type."""
    kind: MirTypeKind

"""MIR type kind."""
enum MirTypeKind:
    # Primitives
    I8, I16, I32, I64
    U8, U16, U32, U64
    F32, F64
    Bool
    Char
    Unit

    # Pointers and references
    Ptr(pointee: MirType, mutable: bool)
    Ref(referent: MirType, mutable: bool)
    FuncPtr(signature: MirSignature)

    # Aggregates
    Array(element: MirType, size: i64)
    Slice(element: MirType)
    Tuple(elements: [MirType])
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId)

    # Special
    Never              # !
    Opaque(name: text) # Foreign type

impl MirType:
    static fn i64() -> MirType:
        MirType(kind: MirTypeKind.I64)

    static fn f64() -> MirType:
        MirType(kind: MirTypeKind.F64)

    static fn bool() -> MirType:
        MirType(kind: MirTypeKind.Bool)

    static fn unit() -> MirType:
        MirType(kind: MirTypeKind.Unit)

    static fn ptr(pointee: MirType, mutable: bool) -> MirType:
        MirType(kind: MirTypeKind.Ptr(pointee, mutable))

    fn size_bytes() -> i64:
        """Get size in bytes."""
        match self.kind:
            case I8 | U8 | Bool: 1
            case I16 | U16 | Char: 2
            case I32 | U32 | F32: 4
            case I64 | U64 | F64 | Ptr(_, _) | Ref(_, _) | FuncPtr(_): 8
            case Unit | Never: 0
            case Array(elem, size): elem.size_bytes() * size
            case Tuple(elements):
                var total = 0
                for e in elements:
                    total = total + e.size_bytes()
                total
            case _: 8  # Default pointer size

    fn alignment() -> i64:
        """Get alignment in bytes."""
        match self.kind:
            case I8 | U8 | Bool: 1
            case I16 | U16 | Char: 2
            case I32 | U32 | F32: 4
            case I64 | U64 | F64 | Ptr(_, _) | Ref(_, _) | FuncPtr(_): 8
            case Unit | Never: 1
            case Array(elem, _): elem.alignment()
            case Tuple(elements):
                var max_align = 1
                for e in elements:
                    val align = e.alignment()
                    if align > max_align:
                        max_align = align
                max_align
            case _: 8

# ============================================================================
# MIR Basic Blocks
# ============================================================================

struct BlockId:
    """Basic block identifier."""
    id: i64

impl BlockId:
    static fn new(id: i64) -> BlockId:
        BlockId(id: id)

    static fn entry() -> BlockId:
        BlockId(id: 0)

struct MirBlock:
    """Basic block."""
    id: BlockId
    label: text?
    instructions: [MirInst]
    terminator: MirTerminator

# ============================================================================
# MIR Instructions
# ============================================================================

struct MirInst:
    """MIR instruction."""
    kind: MirInstKind
    span: Span?

"""MIR instruction kind."""
enum MirInstKind:
    # Constants
    Const(dest: LocalId, value: MirConstValue, type_: MirType)

    # Moves and copies
    Copy(dest: LocalId, src: LocalId)
    Move(dest: LocalId, src: LocalId)

    # Arithmetic
    BinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)
    UnaryOp(dest: LocalId, op: MirUnaryOp, operand: MirOperand)
    CheckedBinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)

    # Memory
    Alloc(dest: LocalId, type_: MirType)
    Load(dest: LocalId, ptr: MirOperand)
    Store(ptr: MirOperand, value: MirOperand)
    GetElementPtr(dest: LocalId, base: MirOperand, indices: [MirOperand])

    # Aggregates
    Aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand])
    GetField(dest: LocalId, base: MirOperand, field: i64)
    SetField(base: MirOperand, field: i64, value: MirOperand)

    # Casts
    Cast(dest: LocalId, operand: MirOperand, target: MirType)
    Bitcast(dest: LocalId, operand: MirOperand, target: MirType)

    # Function calls
    Call(dest: LocalId?, func: MirOperand, args: [MirOperand])
    CallIndirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature)

    # Intrinsics
    Intrinsic(dest: LocalId?, name: text, args: [MirOperand])

    # Pipeline operators (require runtime function dispatch)
    PipeForward(dest: LocalId, value: MirOperand, func: MirOperand)
    Compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool)
    Parallel(dest: LocalId, funcs: [MirOperand])
    LayerConnect(dest: LocalId, layer1: MirOperand, layer2: MirOperand)

    # Debug
    DebugValue(local: LocalId, name: text)
    Nop

"""Binary operation."""
enum MirBinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Rem
    Pow                         # **
    # Matrix operations
    MatMul                      # @
    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr
    # Comparison
    Eq, Ne, Lt, Le, Gt, Ge
    # Broadcast operations (dotted operators)
    BroadcastAdd                # .+
    BroadcastSub                # .-
    BroadcastMul                # .*
    BroadcastDiv                # ./
    BroadcastPow                # .^
    # Offset
    Offset  # Pointer arithmetic

"""Unary operation."""
enum MirUnaryOp:
    Neg
    Not
    BitNot
    Transpose   # ' (postfix, m{} only)

"""Aggregate construction kind."""
enum AggregateKind:
    Array(type_: MirType)
    Tuple
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId, variant: i64)

struct MirOperand:
    """Instruction operand."""
    kind: MirOperandKind

"""Operand kind."""
enum MirOperandKind:
    Copy(local: LocalId)
    Move(local: LocalId)
    Const(value: MirConstValue, type_: MirType)

# Free functions for MirOperand construction (workaround for bootstrap)
fn mir_operand_copy(local: LocalId) -> MirOperand:
    MirOperand(kind: MirOperandKind.Copy(local))

fn mir_operand_move(local: LocalId) -> MirOperand:
    MirOperand(kind: MirOperandKind.Move(local))

fn mir_operand_const_int(value: i64) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Int(value), MirType.i64()))

fn mir_operand_const_float(value: f64) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Float(value), MirType.f64()))

fn mir_operand_const_bool(value: bool) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Bool(value), MirType.bool()))

impl MirOperand:
    static fn copy(local: LocalId) -> MirOperand:
        mir_operand_copy(local)

    static fn move(local: LocalId) -> MirOperand:
        mir_operand_move(local)

    static fn const_int(value: i64) -> MirOperand:
        mir_operand_const_int(value)

    static fn const_float(value: f64) -> MirOperand:
        mir_operand_const_float(value)

    static fn const_bool(value: bool) -> MirOperand:
        mir_operand_const_bool(value)

# ============================================================================
# MIR Terminators
# ============================================================================

"""Block terminator."""
enum MirTerminator:
    # Unconditional
    Goto(target: BlockId)
    Return(value: MirOperand?)

    # Conditional
    If(cond: MirOperand, then_: BlockId, else_: BlockId)
    Switch(value: MirOperand, targets: [(i64, BlockId)], default: BlockId)

    # Exceptional
    Unreachable
    Abort(message: text)

    # Call terminators (for unwinding)
    CallTerminator(
        dest: LocalId?,
        func: MirOperand,
        args: [MirOperand],
        normal: BlockId,
        unwind: BlockId?
    )

# ============================================================================
# MIR Builder
# ============================================================================

struct MirBuilder:
    """Builder for constructing MIR."""
    module: MirModule
    current_function: MirFunction?
    current_block: BlockId
    next_local_id: i64
    next_block_id: i64
    locals: [MirLocal]
    blocks: [MirBlock]
    instructions: [MirInst]

impl MirBuilder:
    static fn new() -> MirBuilder:
        MirBuilder(
            module: MirModule(
                name: "",
                functions: {},
                statics: {},
                constants: {},
                types: {}
            ),
            current_function: nil,
            current_block: BlockId.entry(),
            next_local_id: 0,
            next_block_id: 1,
            locals: [],
            blocks: [],
            instructions: []
        )

    # ========================================================================
    # Function Building
    # ========================================================================

    me begin_function(symbol: SymbolId, name: text, signature: MirSignature, span: Span):
        """Begin building a new function."""
        self.current_function = Some(MirFunction(
            symbol: symbol,
            name: name,
            signature: signature,
            locals: [],
            blocks: [],
            entry_block: BlockId.entry(),
            span: span,
            generic_params: [],
            is_generic_template: false,
            specialization_of: nil,
            type_bindings: {}
        ))
        self.next_local_id = 0
        self.next_block_id = 1
        self.locals = []
        self.blocks = []
        self.instructions = []
        self.current_block = BlockId.entry()

        # Create entry block
        self.blocks = self.blocks.push(MirBlock(
            id: BlockId.entry(),
            label: Some("entry"),
            instructions: [],
            terminator: MirTerminator.Unreachable  # Placeholder
        ))

        # Create return local
        if signature.return_type.kind != MirTypeKind.Unit:
            self.new_local(Some("_return"), signature.return_type, LocalKind.Return)

        # Create parameter locals
        for i in 0..signature.params.len():
            self.new_local(nil, signature.params[i], LocalKind.Arg(i))

    me end_function() -> MirFunction:
        """Finish building current function and return it."""
        # Finalize current block
        self.finalize_block()

        var fn_ = self.current_function.unwrap()
        fn_.locals = self.locals
        fn_.blocks = self.blocks
        self.current_function = None
        fn_

    me add_function(fn_: MirFunction):
        """Add a completed function to the module."""
        var functions = self.module.functions
        functions[fn_.symbol] = fn_
        self.module.functions = functions

    # ========================================================================
    # Local Variables
    # ========================================================================

    me new_local(name: text?, type_: MirType, kind: LocalKind) -> LocalId:
        """Create a new local variable."""
        val id = LocalId(id: self.next_local_id)
        self.next_local_id = self.next_local_id + 1

        self.locals = self.locals.push(MirLocal(
            id: id,
            name: name,
            type_: type_,
            kind: kind
        ))

        id

    me new_temp(type_: MirType) -> LocalId:
        """Create a new temporary."""
        self.new_local(nil, type_, LocalKind.Temp)

    # ========================================================================
    # Basic Blocks
    # ========================================================================

    me new_block(label: text?) -> BlockId:
        """Create a new basic block."""
        val id = BlockId(id: self.next_block_id)
        self.next_block_id = self.next_block_id + 1

        self.blocks = self.blocks.push(MirBlock(
            id: id,
            label: label,
            instructions: [],
            terminator: MirTerminator.Unreachable  # Placeholder
        ))

        id

    me switch_to_block(block: BlockId):
        """Switch to building a different block."""
        self.finalize_block()
        self.current_block = block
        self.instructions = []

    me finalize_block():
        """Finalize current block with accumulated instructions."""
        if self.instructions.is_empty():
            return

        # Find and update current block
        for i in 0..self.blocks.len():
            if self.blocks[i].id.id == self.current_block.id:
                var block = self.blocks[i]
                block.instructions = self.instructions
                self.blocks[i] = block
                break

        self.instructions = []

    # ========================================================================
    # Instructions
    # ========================================================================

    me emit(inst: MirInst):
        """Emit an instruction to current block."""
        self.instructions = self.instructions.push(inst)

    me emit_const(dest: LocalId, value: MirConstValue, type_: MirType):
        """Emit a constant load."""
        self.emit(MirInst(
            kind: MirInstKind.Const(dest, value, type_),
            span: nil
        ))

    me emit_const_int(value: i64) -> LocalId:
        """Emit an integer constant and return its local."""
        val dest = self.new_temp(MirType.i64())
        self.emit_const(dest, MirConstValue.Int(value), MirType.i64())
        dest

    me emit_const_float(value: f64) -> LocalId:
        """Emit a float constant and return its local."""
        val dest = self.new_temp(MirType.f64())
        self.emit_const(dest, MirConstValue.Float(value), MirType.f64())
        dest

    me emit_const_bool(value: bool) -> LocalId:
        """Emit a boolean constant and return its local."""
        val dest = self.new_temp(MirType.bool())
        self.emit_const(dest, MirConstValue.Bool(value), MirType.bool())
        dest

    me emit_copy(dest: LocalId, src: LocalId):
        """Emit a copy instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Copy(dest, src),
            span: nil
        ))

    me emit_move(dest: LocalId, src: LocalId):
        """Emit a move instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Move(dest, src),
            span: nil
        ))

    me emit_binop(op: MirBinOp, left: MirOperand, right: MirOperand, type_: MirType) -> LocalId:
        """Emit a binary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.BinOp(dest, op, left, right),
            span: nil
        ))
        dest

    me emit_unary(op: MirUnaryOp, operand: MirOperand, type_: MirType) -> LocalId:
        """Emit a unary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.UnaryOp(dest, op, operand),
            span: nil
        ))
        dest

    me emit_load(ptr: MirOperand, type_: MirType) -> LocalId:
        """Emit a load instruction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.Load(dest, ptr),
            span: nil
        ))
        dest

    me emit_store(ptr: MirOperand, value: MirOperand):
        """Emit a store instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Store(ptr, value),
            span: nil
        ))

    me emit_alloc(type_: MirType) -> LocalId:
        """Emit an allocation."""
        val dest = self.new_temp(MirType.ptr(type_, true))
        self.emit(MirInst(
            kind: MirInstKind.Alloc(dest, type_),
            span: nil
        ))
        dest

    me emit_call(func: MirOperand, args: [MirOperand], return_type: MirType) -> LocalId?:
        """Emit a function call."""
        var dest: LocalId? = None
        if return_type.kind != MirTypeKind.Unit:
            dest = Some(self.new_temp(return_type))

        self.emit(MirInst(
            kind: MirInstKind.Call(dest, func, args),
            span: nil
        ))

        dest

    me emit_call_indirect(ptr: MirOperand, args: [MirOperand], sig: MirSignature, return_type: MirType) -> LocalId?:
        """Emit an indirect function call (through closure or function pointer)."""
        var dest: LocalId? = None
        if return_type.kind != MirTypeKind.Unit:
            dest = Some(self.new_temp(return_type))

        self.emit(MirInst(
            kind: MirInstKind.CallIndirect(dest, ptr, args, sig),
            span: nil
        ))

        dest

    me emit_cast(operand: MirOperand, target: MirType) -> LocalId:
        """Emit a type cast."""
        val dest = self.new_temp(target)
        self.emit(MirInst(
            kind: MirInstKind.Cast(dest, operand, target),
            span: nil
        ))
        dest

    me emit_aggregate(kind: AggregateKind, operands: [MirOperand], type_: MirType) -> LocalId:
        """Emit aggregate construction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.Aggregate(dest, kind, operands),
            span: nil
        ))
        dest

    me emit_get_field(base: MirOperand, field: i64, type_: MirType) -> LocalId:
        """Emit field access."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.GetField(dest, base, field),
            span: nil
        ))
        dest

    me emit_set_field(base: MirOperand, field: i64, value: MirOperand):
        """Emit field assignment."""
        self.emit(MirInst(
            kind: MirInstKind.SetField(base, field, value),
            span: nil
        ))

    # ========================================================================
    # Terminators
    # ========================================================================

    me terminate_goto(target: BlockId):
        """Terminate current block with unconditional jump."""
        self.set_terminator(MirTerminator.Goto(target))

    me terminate_return(value: MirOperand?):
        """Terminate current block with return."""
        self.set_terminator(MirTerminator.Return(value))

    me terminate_if(cond: MirOperand, then_: BlockId, else_: BlockId):
        """Terminate current block with conditional branch."""
        self.set_terminator(MirTerminator.If(cond, then_, else_))

    me terminate_switch(value: MirOperand, targets: [(i64, BlockId)], default: BlockId):
        """Terminate current block with switch."""
        self.set_terminator(MirTerminator.Switch(value, targets, default))

    me terminate_unreachable():
        """Terminate current block as unreachable."""
        self.set_terminator(MirTerminator.Unreachable)

    me set_terminator(term: MirTerminator):
        """Set terminator for current block."""
        self.finalize_block()

        for i in 0..self.blocks.len():
            if self.blocks[i].id.id == self.current_block.id:
                var block = self.blocks[i]
                block.terminator = term
                self.blocks[i] = block
                break

# ============================================================================
# Exports
# ============================================================================

export MirModule, MirFunction, MirSignature, MirLocal, LocalId, LocalKind
export MirStatic, MirConstant, MirConstValue
export MirTypeDef, MirTypeDefKind, MirFieldDef, MirVariantDef
export MirType, MirTypeKind
export BlockId, MirBlock
export MirInst, MirInstKind, MirBinOp, MirUnaryOp, AggregateKind
export MirOperand, MirOperandKind
export MirTerminator
export MirBuilder
export mir_operand_copy, mir_operand_move, mir_operand_const_int, mir_operand_const_float, mir_operand_const_bool
