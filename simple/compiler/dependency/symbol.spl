# Symbol Table - Cross-module symbol tracking
#
# This module provides symbol table management for tracking symbols
# across modules, their visibility, and handling import resolution.
#
# Corresponds to Rust: src/rust/dependency_tracker/src/symbol.rs

use compiler.dependency.visibility.{Visibility}

# The kind of a symbol entry
enum SymbolKind:
    Function    # Function definition
    Type        # Type definition (struct, class, enum)
    Constant    # Constant value
    Variable    # Variable
    MacroKind   # Macro definition
    Module      # Module

impl SymbolKind:
    # Check if this is a macro
    fn is_macro() -> bool:
        match self:
            case SymbolKind.MacroKind:
                true
            case SymbolKind.Function:
                false
            case SymbolKind.Type:
                false
            case SymbolKind.Constant:
                false
            case SymbolKind.Variable:
                false
            case SymbolKind.Module:
                false

    # String representation
    fn to_string() -> text:
        match self:
            case SymbolKind.Function:
                "Function"
            case SymbolKind.Type:
                "Type"
            case SymbolKind.Constant:
                "Constant"
            case SymbolKind.Variable:
                "Variable"
            case SymbolKind.MacroKind:
                "Macro"
            case SymbolKind.Module:
                "Module"

# A symbol entry in the symbol table
struct SymbolEntry:
    name: text              # Local name
    qualified_name: text    # Fully qualified (e.g., "crate.sys.http.Router")
    kind: SymbolKind        # Kind of symbol
    visibility: Visibility  # Public or Private
    source_module: text     # Source module path
    is_imported: bool       # Imported vs locally defined
    original_name: text     # Original name if aliased (empty if not aliased)

impl SymbolEntry:
    # Create a new locally-defined symbol
    static fn local(name: text, qualified_name: text, kind: SymbolKind,
                   visibility: Visibility, source_module: text) -> SymbolEntry:
        SymbolEntry(
            name: name,
            qualified_name: qualified_name,
            kind: kind,
            visibility: visibility,
            source_module: source_module,
            is_imported: false,
            original_name: ""
        )

    # Create an imported symbol
    static fn imported(name: text, qualified_name: text, kind: SymbolKind,
                      visibility: Visibility, source_module: text) -> SymbolEntry:
        SymbolEntry(
            name: name,
            qualified_name: qualified_name,
            kind: kind,
            visibility: visibility,
            source_module: source_module,
            is_imported: true,
            original_name: ""
        )

    # Create an aliased import (e.g., `use foo.Bar as Baz`)
    static fn aliased(alias: text, original: text, qualified_name: text,
                     kind: SymbolKind, visibility: Visibility, source_module: text) -> SymbolEntry:
        SymbolEntry(
            name: alias,
            qualified_name: qualified_name,
            kind: kind,
            visibility: visibility,
            source_module: source_module,
            is_imported: true,
            original_name: original
        )

    # Get the symbol name
    fn get_name() -> text:
        self.name

    # Get the qualified name
    fn get_qualified_name() -> text:
        self.qualified_name

    # Get the symbol kind
    fn get_kind() -> SymbolKind:
        self.kind

    # Get visibility
    fn get_visibility() -> Visibility:
        self.visibility

    # Get source module
    fn get_source_module() -> text:
        self.source_module

    # Check if imported
    fn is_imported_symbol() -> bool:
        self.is_imported

    # Get original name (for aliases)
    fn get_original_name() -> text:
        self.original_name

    # Check if aliased
    fn is_aliased() -> bool:
        self.original_name != ""

    # Check if public
    fn is_public() -> bool:
        val vis_str = self.visibility.to_string()
        vis_str == "Public"

# Symbol conflict error
struct SymbolConflictError:
    name: text                  # The conflicting name
    existing_qualified: text    # Existing symbol's qualified name
    new_qualified: text         # New symbol's qualified name

impl SymbolConflictError:
    # Create a new conflict error
    static fn new(name: text, existing: text, new_sym: text) -> SymbolConflictError:
        SymbolConflictError(
            name: name,
            existing_qualified: existing,
            new_qualified: new_sym
        )

    # Format as error message
    fn to_string() -> text:
        "Symbol conflict: '{self.name}' already defined as '{self.existing_qualified}', cannot redefine as '{self.new_qualified}'"

# A symbol table for a single module
struct SymbolTable:
    module_path: text                       # Module path (e.g., "crate.sys.http")
    symbols: Dict<text, SymbolEntry>        # Symbols keyed by local name

impl SymbolTable:
    # Create a new symbol table for a module
    static fn new(module_path: text) -> SymbolTable:
        SymbolTable(module_path: module_path, symbols: {})

    # Define a new symbol in this module
    # Returns None on success, Some(error) on conflict
    me define(entry: SymbolEntry) -> Option<SymbolConflictError>:
        val entry_name = entry.get_name()
        if self.symbols.contains_key(entry_name):
            val existing = self.symbols[entry_name]
            val existing_qual = existing.get_qualified_name()
            val new_qual = entry.get_qualified_name()
            return Some(SymbolConflictError.new(entry_name, existing_qual, new_qual))

        self.symbols[entry_name] = entry
        nil

    # Define or replace a symbol (for re-exports)
    me define_or_replace(entry: SymbolEntry):
        val entry_name = entry.get_name()
        self.symbols[entry_name] = entry

    # Look up a symbol by name
    fn lookup(name: text) -> Option<SymbolEntry>:
        if self.symbols.contains_key(name):
            Some(self.symbols[name])
        else:
            nil

    # Get all symbols in this module
    fn all_symbols() -> List<SymbolEntry>:
        var result: List<SymbolEntry> = []
        for key in self.symbols.keys():
            result.push(self.symbols[key])
        result

    # Get all public symbols in this module
    fn public_symbols() -> List<SymbolEntry>:
        var result: List<SymbolEntry> = []
        for key in self.symbols.keys():
            val sym = self.symbols[key]
            if sym.is_public():
                result.push(sym)
        result

    # Get count of symbols
    fn count() -> i64:
        self.symbols.len()

    # Check if a symbol exists
    fn has_symbol(name: text) -> bool:
        self.symbols.contains_key(name)

# Public exports
export SymbolKind
export SymbolEntry
export SymbolConflictError
export SymbolTable
