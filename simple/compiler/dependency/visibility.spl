# Visibility and Export Model
#
# Implements the visibility and export rules verified in:
# verification/visibility_export/src/VisibilityExport.lean
#
# Proven Properties (Lean theorems):
# 1. private_stays_private: A private symbol cannot become public
# 2. private_module_restricts: A symbol in a private module cannot become public
# 3. must_be_exported: A symbol must be explicitly exported to be visible externally
# 4. meet_comm, meet_assoc: Visibility meet is commutative and associative
# 5. any_private_means_private: If any ancestor is private, result is private
# 6. all_public_means_public: All public ancestors means public result
#
# Key Properties:
# 1. Visibility is the **intersection** of declaration visibility and ancestor visibility
# 2. A directory's public API consists only of:
#    - Child modules declared as `pub mod` in its `__init__.spl`
#    - Symbols listed in `export use` inside that same `__init__.spl`
# 3. Nothing inside a child `.spl` file can make itself "more public" than its directory allows

# Visibility of a declaration or module
#
# Corresponds to Lean: `inductive Visibility | pub | priv`
enum Visibility:
    Public
    Private

impl Visibility:
    # Check if this visibility is public
    fn is_public() -> bool:
        match self:
            case Visibility.Public:
                true
            case Visibility.Private:
                false

    # Check if this visibility is private
    fn is_private() -> bool:
        match self:
            case Visibility.Public:
                false
            case Visibility.Private:
                true

    # Convert to string for debugging
    fn to_string() -> text:
        match self:
            case Visibility.Public:
                "Public"
            case Visibility.Private:
                "Private"

# A symbol identifier
#
# Corresponds to Lean: `structure SymbolId where name : String`
struct SymbolId:
    name: text

impl SymbolId:
    # Create a new symbol identifier
    static fn new(name: text) -> SymbolId:
        SymbolId(name: name)

    # Get the symbol name
    fn name() -> text:
        self.name

    # Check if two symbol IDs are equal
    fn equals(other: SymbolId) -> bool:
        self.name == other.name

# A symbol with visibility
#
# Corresponds to Lean: `structure Symbol where id : SymbolId; visibility : Visibility`
struct Symbol:
    id: SymbolId
    visibility: Visibility

impl Symbol:
    # Create a new symbol
    static fn new(name: text, visibility: Visibility) -> Symbol:
        Symbol(id: SymbolId.new(name), visibility: visibility)

    # Create a public symbol
    static fn public(name: text) -> Symbol:
        Symbol.new(name, Visibility.Public)

    # Create a private symbol
    static fn private(name: text) -> Symbol:
        Symbol.new(name, Visibility.Private)

    # Get the symbol ID
    fn id() -> SymbolId:
        self.id

    # Get the visibility
    fn visibility() -> Visibility:
        self.visibility

# A module declaration in __init__.spl
#
# Corresponds to Lean: `structure ModDecl where name : String; isPub : Bool`
struct ModDecl:
    name: text
    is_pub: bool

impl ModDecl:
    # Create a new module declaration
    static fn new(name: text, is_pub: bool) -> ModDecl:
        ModDecl(name: name, is_pub: is_pub)

    # Create a public module declaration
    static fn public(name: text) -> ModDecl:
        ModDecl.new(name, true)

    # Create a private module declaration
    static fn private(name: text) -> ModDecl:
        ModDecl.new(name, false)

    # Get the module name
    fn name() -> text:
        self.name

    # Check if the module is public
    fn is_pub() -> bool:
        self.is_pub

# A directory manifest (__init__.spl)
#
# Corresponds to Lean: `structure DirManifest where name : String; children : List ModDecl; exports : List SymbolId`
struct DirManifest:
    name: text
    children: List<ModDecl>
    exports: List<SymbolId>

impl DirManifest:
    # Create a new directory manifest
    static fn new(name: text) -> DirManifest:
        DirManifest(name: name, children: [], exports: [])

    # Check if a child module is declared public in the manifest
    #
    # Corresponds to Lean: `def DirManifest.isChildPublic`
    fn is_child_public(child_name: text) -> bool:
        for decl in self.children:
            if decl.name() == child_name and decl.is_pub():
                return true
        false

    # Check if a symbol is explicitly exported
    #
    # Corresponds to Lean: `def DirManifest.isExported`
    fn is_exported(sym: SymbolId) -> bool:
        for exported in self.exports:
            if exported.equals(sym):
                return true
        false

    # Add a child module declaration
    me add_child(decl: ModDecl):
        self.children.push(decl)

    # Add an export
    me add_export(sym: SymbolId):
        self.exports.push(sym)

# Module contents: symbols defined in a module file
#
# Corresponds to Lean: `structure ModuleContents where symbols : List Symbol`
struct ModuleContents:
    symbols: List<Symbol>

impl ModuleContents:
    # Create a new empty module contents
    static fn new() -> ModuleContents:
        ModuleContents(symbols: [])

    # Add a symbol to the module
    me add_symbol(symbol: Symbol):
        self.symbols.push(symbol)

    # Get visibility of a symbol from module contents
    #
    # Corresponds to Lean: `def ModuleContents.symbolVisibility`
    fn symbol_visibility(sym: SymbolId) -> Visibility?:
        for symbol in self.symbols:
            if symbol.id().equals(sym):
                return Some(symbol.visibility())
        nil

# Effective visibility combines declaration visibility with directory control
#
# A symbol is externally visible only if:
# 1. It is declared `pub` in its module
# 2. Its module is declared `pub mod` in the directory's __init__.spl
# 3. It's in the export list
#
# Corresponds to Lean: `def effectiveVisibility`
fn effective_visibility(
    manifest: DirManifest,
    module_name: text,
    mc: ModuleContents,
    sym: SymbolId
) -> Visibility:
    match mc.symbol_visibility(sym):
        case nil:
            # Symbol not found
            Visibility.Private
        case Some(Visibility.Private):
            # Declaration is private
            Visibility.Private
        case Some(Visibility.Public):
            # Symbol is declared public; check if directory allows export
            if manifest.is_child_public(module_name):
                if manifest.is_exported(sym):
                    Visibility.Public
                else:
                    Visibility.Private  # Not in export list
            else:
                Visibility.Private  # Module not public

# Visibility meet operation (intersection)
#
# Corresponds to Lean: `def visibilityMeet`
#
# This is the key operation: visibility is the intersection of all visibility levels
fn visibility_meet(v1: Visibility, v2: Visibility) -> Visibility:
    match v1:
        case Visibility.Public:
            match v2:
                case Visibility.Public:
                    Visibility.Public
                case Visibility.Private:
                    Visibility.Private
        case Visibility.Private:
            Visibility.Private

# Ancestor visibility through a path
#
# Corresponds to Lean: `def ancestorVisibility (path : List Visibility) : Visibility`
#
# This computes the effective visibility by folding visibility_meet over the path
fn ancestor_visibility(path: List<Visibility>) -> Visibility:
    var result = Visibility.Public
    for v in path:
        result = visibility_meet(result, v)
    result

# Public exports
export Visibility
export SymbolId
export Symbol
export ModDecl
export DirManifest
export ModuleContents
export effective_visibility
export visibility_meet
export ancestor_visibility
