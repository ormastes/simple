# HIR - High-level Intermediate Representation
#
# Shared IR between interpreter, compiler, and SDN backends.
# Lowered from AST with:
# - Name resolution (identifiers -> symbols)
# - Type information (inferred or explicit)
# - Desugaring (comprehensions, operators, etc.)
#
# The Backend trait processes HIR differently:
# - Interpreter: Tree-walks and evaluates
# - Compiler: Lowers to MIR then codegen
# - SDN: Blocks code execution, only allows data

import compiler.parser.*
import compiler.lexer.Span

# ============================================================================
# HIR Module Structure
# ============================================================================

struct HirModule:
    """Complete HIR module."""
    name: text
    path: text
    imports: [HirImport]
    exports: [text]
    symbols: SymbolTable
    functions: Dict<SymbolId, HirFunction>
    classes: Dict<SymbolId, HirClass>
    structs: Dict<SymbolId, HirStruct>
    enums: Dict<SymbolId, HirEnum>
    traits: Dict<SymbolId, HirTrait>
    impls: [HirImpl]
    constants: Dict<SymbolId, HirConst>

struct HirImport:
    """Import declaration."""
    module_path: text
    items: [HirImportItem]
    span: Span

struct HirImportItem:
    """Single imported item."""
    name: text
    alias: text?
    resolved: SymbolId?     # Resolved after linking

# ============================================================================
# Symbol Table
# ============================================================================

struct SymbolId:
    """Unique identifier for a symbol."""
    id: i64

impl SymbolId:
    static fn new(id: i64) -> SymbolId:
        SymbolId(id: id)

    fn is_valid() -> bool:
        self.id >= 0

struct Symbol:
    """Symbol table entry."""
    id: SymbolId
    name: text
    kind: SymbolKind
    type_: HirType?
    scope: ScopeId
    span: Span
    is_public: bool
    is_mutable: bool

enum SymbolKind:
    """Kind of symbol."""
    Function
    Method
    Variable
    Parameter
    Field
    Class
    Struct
    Enum
    EnumVariant
    Trait
    TypeAlias
    TypeParam
    Const
    Module
    Import

struct ScopeId:
    """Unique identifier for a scope."""
    id: i64

struct Scope:
    """Lexical scope."""
    id: ScopeId
    parent: ScopeId?
    kind: ScopeKind
    symbols: Dict<text, SymbolId>

enum ScopeKind:
    """Kind of scope."""
    Module
    Function
    Block
    Loop
    Match
    Class
    Impl

struct SymbolTable:
    """Symbol table for name resolution."""
    symbols: Dict<i64, Symbol>
    scopes: Dict<i64, Scope>
    current_scope: ScopeId
    next_symbol_id: i64
    next_scope_id: i64

impl SymbolTable:
    static fn new() -> SymbolTable:
        var table = SymbolTable(
            symbols: {},
            scopes: {},
            current_scope: ScopeId(id: 0),
            next_symbol_id: 0,
            next_scope_id: 1
        )
        # Create root scope
        table.scopes[0] = Scope(
            id: ScopeId(id: 0),
            parent: None,
            kind: ScopeKind.Module,
            symbols: {}
        )
        table

    me define(name: text, kind: SymbolKind, type_: HirType?, span: Span, is_public: bool, is_mutable: bool) -> SymbolId:
        """Define a new symbol in current scope."""
        val id = SymbolId.new(self.next_symbol_id)
        self.next_symbol_id = self.next_symbol_id + 1

        val symbol = Symbol(
            id: id,
            name: name,
            kind: kind,
            type_: type_,
            scope: self.current_scope,
            span: span,
            is_public: is_public,
            is_mutable: is_mutable
        )

        self.symbols[id.id] = symbol

        val scope = self.scopes[self.current_scope.id]
        scope.symbols[name] = id

        id

    fn lookup(name: text) -> SymbolId?:
        """Look up a symbol by name, searching up scope chain."""
        var scope_id = self.current_scope

        loop:
            val scope = self.scopes[scope_id.id]
            if scope.symbols[name].?:
                return Some(scope.symbols[name])

            if scope.parent.?:
                scope_id = scope.parent.unwrap()
            else:
                break

        None

    fn get(id: SymbolId) -> Symbol?:
        """Get symbol by ID."""
        self.symbols[id.id]

    me push_scope(kind: ScopeKind) -> ScopeId:
        """Push a new scope."""
        val id = ScopeId(id: self.next_scope_id)
        self.next_scope_id = self.next_scope_id + 1

        self.scopes[id.id] = Scope(
            id: id,
            parent: Some(self.current_scope),
            kind: kind,
            symbols: {}
        )

        self.current_scope = id
        id

    me pop_scope():
        """Pop current scope."""
        val scope = self.scopes[self.current_scope.id]
        if scope.parent.?:
            self.current_scope = scope.parent.unwrap()

# ============================================================================
# HIR Types
# ============================================================================

struct HirType:
    """Type in HIR."""
    kind: HirTypeKind
    span: Span

enum HirTypeKind:
    """Type kind."""
    # Primitive types
    Int(bits: i64, signed: bool)    # i8, i16, i32, i64, u8, u16, u32, u64
    Float(bits: i64)                 # f32, f64
    Bool
    Char
    Str
    Unit                             # ()

    # Composite types
    Tuple(elements: [HirType])
    Array(element: HirType, size: i64?)
    Slice(element: HirType)
    Dict(key: HirType, value: HirType)

    # Reference types
    Ref(inner: HirType, mutable: bool)
    Ptr(inner: HirType, mutable: bool)
    Optional(inner: HirType)
    Result(ok: HirType, err: HirType)

    # User-defined types
    Named(symbol: SymbolId, args: [HirType])
    TypeParam(name: text, bounds: [HirType])

    # Function types
    Function(params: [HirType], ret: HirType, effects: [Effect])

    # Special
    # Type inference variable with level for HM generalization
    # - id: unique identifier for the variable
    # - level: scope level at which the variable was created
    #   Higher level = more recently introduced, can be generalized
    Infer(id: i64, level: i64)
    Error
    Never                            # ! type (never returns)

struct Effect:
    """Effect annotation."""
    kind: EffectKind
    span: Span

enum EffectKind:
    """Effect kind."""
    Pure            # No side effects
    IO              # I/O operations
    Async           # Async operations
    Throws(type_: HirType)  # Can throw error
    Mutates         # Mutates state
    Allocates       # Heap allocation
    Custom(name: text)

# ============================================================================
# HIR Definitions
# ============================================================================

struct HirFunction:
    """Function definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    params: [HirParam]
    return_type: HirType
    body: HirBlock
    effects: [Effect]
    is_async: bool
    is_static: bool
    is_public: bool
    is_method: bool
    is_mutable: bool        # 'me' method
    doc_comment: text?
    span: Span

struct HirTypeParam:
    """Generic type parameter."""
    symbol: SymbolId
    name: text
    bounds: [HirType]
    default: HirType?
    span: Span

struct HirParam:
    """Function parameter."""
    symbol: SymbolId
    name: text
    type_: HirType
    default: HirExpr?
    span: Span

struct HirClass:
    """Class definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    fields: [HirField]
    methods: Dict<text, SymbolId>
    is_public: bool
    doc_comment: text?
    span: Span

struct HirStruct:
    """Struct definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    fields: [HirField]
    is_public: bool
    doc_comment: text?
    span: Span

struct HirField:
    """Struct/class field."""
    symbol: SymbolId
    name: text
    type_: HirType
    default: HirExpr?
    is_public: bool
    span: Span

struct HirEnum:
    """Enum definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    variants: [HirVariant]
    is_public: bool
    doc_comment: text?
    span: Span

struct HirVariant:
    """Enum variant."""
    symbol: SymbolId
    name: text
    kind: HirVariantKind
    span: Span

enum HirVariantKind:
    """Enum variant kind."""
    Unit
    Tuple(types: [HirType])
    Struct(fields: [HirField])

struct HirTrait:
    """Trait definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    methods: [HirFunction]
    is_public: bool
    doc_comment: text?
    span: Span

struct HirImpl:
    """Impl block in HIR."""
    type_: HirType
    trait_: HirType?
    methods: Dict<text, SymbolId>
    span: Span

struct HirConst:
    """Module-level constant."""
    symbol: SymbolId
    name: text
    type_: HirType
    value: HirExpr
    is_mutable: bool
    is_public: bool
    span: Span

# ============================================================================
# HIR Expressions
# ============================================================================

struct HirExpr:
    """Expression in HIR."""
    kind: HirExprKind
    type_: HirType?         # Resolved type (filled during type checking)
    span: Span

enum HirExprKind:
    """Expression kind."""
    # Literals
    IntLit(value: i64, suffix: text?)
    FloatLit(value: f64, suffix: text?)
    StringLit(value: text, interpolations: [HirInterpolation]?)
    BoolLit(value: bool)
    CharLit(value: char)
    UnitLit
    NilLit

    # Collections
    ArrayLit(elements: [HirExpr], type_: HirType?)
    TupleLit(elements: [HirExpr])
    DictLit(entries: [(HirExpr, HirExpr)], key_type: HirType?, value_type: HirType?)

    # Variables and access
    Var(symbol: SymbolId)
    Field(base: HirExpr, field: text, resolved: SymbolId?)
    Index(base: HirExpr, index: HirExpr)
    TupleIndex(base: HirExpr, index: i64)

    # Optional operations
    OptionalChain(base: HirExpr, field: text)
    NullCoalesce(left: HirExpr, right: HirExpr)
    ExistsCheck(base: HirExpr)
    Unwrap(base: HirExpr)           # expr!

    # Operators
    Binary(op: HirBinOp, left: HirExpr, right: HirExpr)
    Unary(op: HirUnaryOp, operand: HirExpr)

    # Calls
    Call(callee: HirExpr, args: [HirCallArg], type_args: [HirType])
    MethodCall(receiver: HirExpr, method: text, args: [HirCallArg], resolved: SymbolId?)

    # Control flow
    If(cond: HirExpr, then_: HirBlock, else_: HirBlock?)
    Match(scrutinee: HirExpr, arms: [HirMatchArm])
    Loop(body: HirBlock, label: text?)
    While(cond: HirExpr, body: HirBlock, label: text?)
    For(var_: SymbolId, iter: HirExpr, body: HirBlock, label: text?)

    # Closures
    Lambda(params: [HirParam], body: HirExpr, captures: [SymbolId])
    Block(block: HirBlock)

    # Control transfer
    Return(value: HirExpr?)
    Break(label: text?, value: HirExpr?)
    Continue(label: text?)
    Throw(value: HirExpr)
    Try(expr: HirExpr)              # expr?

    # Async
    Await(expr: HirExpr)
    Yield(value: HirExpr?)

    # Construction
    StructLit(type_: HirType, fields: [(text, HirExpr)])
    EnumLit(type_: HirType, variant: text, payload: HirEnumPayload?)

    # Casts and conversions
    Cast(expr: HirExpr, target: HirType)
    As(expr: HirExpr, target: HirType)      # Safe cast (returns Option)

    # Special
    Range(start: HirExpr?, end: HirExpr?, inclusive: bool, step: HirExpr?)
    Comprehension(kind: HirComprehensionKind, expr: HirExpr, clauses: [HirCompClause])

    # Error recovery
    Error

struct HirInterpolation:
    """String interpolation."""
    expr: HirExpr
    format: text?
    span: Span

struct HirCallArg:
    """Function call argument."""
    name: text?
    value: HirExpr
    span: Span

struct HirMatchArm:
    """Match arm."""
    pattern: HirPattern
    guard: HirExpr?
    body: HirBlock
    span: Span

enum HirEnumPayload:
    """Enum construction payload."""
    Tuple(values: [HirExpr])
    Struct(fields: [(text, HirExpr)])

enum HirComprehensionKind:
    """Comprehension kind."""
    List
    Dict
    Set
    Generator

struct HirCompClause:
    """Comprehension clause."""
    kind: HirCompClauseKind
    span: Span

enum HirCompClauseKind:
    """Comprehension clause kind."""
    For(var_: SymbolId, iter: HirExpr)
    If(cond: HirExpr)

# ============================================================================
# HIR Operators
# ============================================================================

enum HirBinOp:
    """Binary operator."""
    # Arithmetic
    Add, Sub, Mul, Div, Mod, Pow

    # Comparison
    Eq, NotEq, Lt, LtEq, Gt, GtEq

    # Logical
    And, Or

    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr

    # Other
    In, NotIn
    Is, IsNot
    Concat         # ++

enum HirUnaryOp:
    """Unary operator."""
    Neg            # -
    Not            # not, !
    BitNot         # ~
    Ref            # &
    RefMut         # &mut
    Deref          # *

# ============================================================================
# HIR Patterns
# ============================================================================

struct HirPattern:
    """Pattern in HIR."""
    kind: HirPatternKind
    type_: HirType?
    span: Span

enum HirPatternKind:
    """Pattern kind."""
    Wildcard
    Literal(value: HirExpr)
    Binding(symbol: SymbolId, mutable: bool)
    Tuple(elements: [HirPattern])
    Array(elements: [HirPattern], rest: SymbolId?)
    Struct(type_: HirType, fields: [(text, HirPattern)])
    Enum(type_: HirType, variant: text, payload: HirPatternPayload?)
    Or(patterns: [HirPattern])
    Range(start: HirExpr?, end: HirExpr?, inclusive: bool)
    Error

enum HirPatternPayload:
    """Enum pattern payload."""
    Tuple(patterns: [HirPattern])
    Struct(fields: [(text, HirPattern)])

# ============================================================================
# HIR Statements
# ============================================================================

struct HirStmt:
    """Statement in HIR."""
    kind: HirStmtKind
    span: Span

enum HirStmtKind:
    """Statement kind."""
    Expr(expr: HirExpr)
    Let(symbol: SymbolId, type_: HirType?, init: HirExpr)
    Assign(target: HirExpr, op: HirAssignOp?, value: HirExpr)
    Block(block: HirBlock)

enum HirAssignOp:
    """Compound assignment operator."""
    Add, Sub, Mul, Div, Mod
    BitAnd, BitOr, BitXor, Shl, Shr

struct HirBlock:
    """Block of statements."""
    stmts: [HirStmt]
    value: HirExpr?     # Final expression (for block expressions)
    span: Span

# ============================================================================
# AST to HIR Lowering
# ============================================================================

struct HirLowering:
    """Lowers AST to HIR."""
    symbols: SymbolTable
    errors: [LoweringError]
    current_function: SymbolId?
    loop_depth: i64

struct LoweringError:
    """Error during lowering."""
    message: text
    span: Span
    kind: LoweringErrorKind

enum LoweringErrorKind:
    """Lowering error kind."""
    UnresolvedName
    DuplicateDefinition
    TypeMismatch
    InvalidPattern
    InvalidExpression
    Other

impl HirLowering:
    static fn new() -> HirLowering:
        HirLowering(
            symbols: SymbolTable.new(),
            errors: [],
            current_function: None,
            loop_depth: 0
        )

    me lower_module(module: Module) -> HirModule:
        """Lower a parsed module to HIR."""

        # First pass: declare all top-level symbols
        self.declare_module_symbols(module)

        # Second pass: lower definitions
        var functions: Dict<SymbolId, HirFunction> = {}
        var classes: Dict<SymbolId, HirClass> = {}
        var structs: Dict<SymbolId, HirStruct> = {}
        var enums: Dict<SymbolId, HirEnum> = {}
        var traits: Dict<SymbolId, HirTrait> = {}
        var impls: [HirImpl] = []
        var constants: Dict<SymbolId, HirConst> = {}

        for name, fn_ in module.functions:
            val hir_fn = self.lower_function(fn_)
            functions[hir_fn.symbol] = hir_fn

        for name, class_ in module.classes:
            val hir_class = self.lower_class(class_)
            classes[hir_class.symbol] = hir_class

        for name, struct_ in module.structs:
            val hir_struct = self.lower_struct(struct_)
            structs[hir_struct.symbol] = hir_struct

        for name, enum_ in module.enums:
            val hir_enum = self.lower_enum(enum_)
            enums[hir_enum.symbol] = hir_enum

        for name, trait_ in module.traits:
            val hir_trait = self.lower_trait(trait_)
            traits[hir_trait.symbol] = hir_trait

        for impl_ in module.impls:
            impls = impls.push(self.lower_impl(impl_))

        for name, const_ in module.constants:
            val hir_const = self.lower_const(const_)
            constants[hir_const.symbol] = hir_const

        # Lower imports
        var imports: [HirImport] = []
        for imp in module.imports:
            imports = imports.push(self.lower_import(imp))

        # Collect exports
        var exports: [text] = []
        for exp in module.exports:
            for item in exp.items:
                exports = exports.push(item)

        HirModule(
            name: module.name,
            path: "",
            imports: imports,
            exports: exports,
            symbols: self.symbols,
            functions: functions,
            classes: classes,
            structs: structs,
            enums: enums,
            traits: traits,
            impls: impls,
            constants: constants
        )

    me declare_module_symbols(module: Module):
        """Declare all top-level symbols."""
        for name, fn_ in module.functions:
            self.symbols.define(name, SymbolKind.Function, None, fn_.span, fn_.is_public, false)

        for name, class_ in module.classes:
            self.symbols.define(name, SymbolKind.Class, None, class_.span, class_.is_public, false)

        for name, struct_ in module.structs:
            self.symbols.define(name, SymbolKind.Struct, None, struct_.span, struct_.is_public, false)

        for name, enum_ in module.enums:
            self.symbols.define(name, SymbolKind.Enum, None, enum_.span, enum_.is_public, false)

        for name, trait_ in module.traits:
            self.symbols.define(name, SymbolKind.Trait, None, trait_.span, trait_.is_public, false)

        for name, const_ in module.constants:
            self.symbols.define(name, SymbolKind.Const, None, const_.span, const_.is_public, const_.is_mutable)

    me lower_import(imp: Import) -> HirImport:
        """Lower import declaration."""
        var items: [HirImportItem] = []
        for item in imp.items:
            items = items.push(HirImportItem(
                name: item.name,
                alias: item.alias,
                resolved: None
            ))

        HirImport(
            module_path: imp.module,
            items: items,
            span: imp.span
        )

    me lower_function(fn_: Function) -> HirFunction:
        """Lower function to HIR."""
        val symbol = self.symbols.lookup(fn_.name).unwrap()
        self.current_function = Some(symbol)

        # Push function scope
        self.symbols.push_scope(ScopeKind.Function)

        # Lower type parameters
        var type_params: [HirTypeParam] = []
        for tp in fn_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        # Lower parameters
        var params: [HirParam] = []
        for p in fn_.params:
            params = params.push(self.lower_param(p))

        # Lower return type
        val return_type = fn_.return_type.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Unit, span: fn_.span)

        # Lower body
        val body = self.lower_block(fn_.body)

        self.symbols.pop_scope()
        self.current_function = None

        HirFunction(
            symbol: symbol,
            name: fn_.name,
            type_params: type_params,
            params: params,
            return_type: return_type,
            body: body,
            effects: [],
            is_async: fn_.is_async,
            is_static: fn_.is_static,
            is_public: fn_.is_public,
            is_method: fn_.is_method,
            is_mutable: fn_.is_mutable,
            doc_comment: fn_.doc_comment,
            span: fn_.span
        )

    me lower_type_param(tp: TypeParam) -> HirTypeParam:
        """Lower type parameter."""
        val symbol = self.symbols.define(tp.name, SymbolKind.TypeParam, None, tp.span, false, false)

        var bounds: [HirType] = []
        for b in tp.bounds:
            bounds = bounds.push(self.lower_type(b))

        HirTypeParam(
            symbol: symbol,
            name: tp.name,
            bounds: bounds,
            default: tp.default.map(\t: self.lower_type(t)),
            span: tp.span
        )

    me lower_param(p: Param) -> HirParam:
        """Lower function parameter."""
        val type_ = p.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: p.span)
        val symbol = self.symbols.define(p.name, SymbolKind.Parameter, Some(type_), p.span, false, false)

        HirParam(
            symbol: symbol,
            name: p.name,
            type_: type_,
            default: p.default.map(\e: self.lower_expr(e)),
            span: p.span
        )

    me lower_type(t: Type) -> HirType:
        """Lower type expression."""
        val kind = match t.kind:
            case Named(name, args):
                var hir_args: [HirType] = []
                for arg in args:
                    hir_args = hir_args.push(self.lower_type(arg))

                # Check for builtin types
                match name:
                    case "i8": HirTypeKind.Int(8, true)
                    case "i16": HirTypeKind.Int(16, true)
                    case "i32": HirTypeKind.Int(32, true)
                    case "i64": HirTypeKind.Int(64, true)
                    case "u8": HirTypeKind.Int(8, false)
                    case "u16": HirTypeKind.Int(16, false)
                    case "u32": HirTypeKind.Int(32, false)
                    case "u64": HirTypeKind.Int(64, false)
                    case "f32": HirTypeKind.Float(32)
                    case "f64": HirTypeKind.Float(64)
                    case "bool": HirTypeKind.Bool
                    case "char": HirTypeKind.Char
                    case "text" | "str" | "String": HirTypeKind.Str
                    case _:
                        val symbol = self.symbols.lookup(name)
                        if symbol.?:
                            HirTypeKind.Named(symbol.unwrap(), hir_args)
                        else:
                            self.error("unresolved type: {name}", t.span)
                            HirTypeKind.Error

            case Tuple(elements):
                if elements.is_empty():
                    HirTypeKind.Unit
                else:
                    var hir_elements: [HirType] = []
                    for e in elements:
                        hir_elements = hir_elements.push(self.lower_type(e))
                    HirTypeKind.Tuple(hir_elements)

            case Array(element, size):
                val hir_element = self.lower_type(element)
                HirTypeKind.Array(hir_element, None)

            case Function(params, ret):
                var hir_params: [HirType] = []
                for p in params:
                    hir_params = hir_params.push(self.lower_type(p))
                val hir_ret = self.lower_type(ret)
                HirTypeKind.Function(hir_params, hir_ret, [])

            case Optional(inner):
                HirTypeKind.Optional(self.lower_type(inner))

            case Reference(inner, mutable):
                HirTypeKind.Ref(self.lower_type(inner), mutable)

            case Infer:
                HirTypeKind.Infer(0, 0)

            case Error:
                HirTypeKind.Error

        HirType(kind: kind, span: t.span)

    me lower_class(class_: Class) -> HirClass:
        """Lower class to HIR."""
        val symbol = self.symbols.lookup(class_.name).unwrap()

        self.symbols.push_scope(ScopeKind.Class)

        var type_params: [HirTypeParam] = []
        for tp in class_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in class_.fields:
            fields = fields.push(self.lower_field(f))

        var methods: Dict<text, SymbolId> = {}
        for name, fn_ in class_.methods:
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        self.symbols.pop_scope()

        HirClass(
            symbol: symbol,
            name: class_.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: class_.is_public,
            doc_comment: class_.doc_comment,
            span: class_.span
        )

    me lower_struct(struct_: Struct) -> HirStruct:
        """Lower struct to HIR."""
        val symbol = self.symbols.lookup(struct_.name).unwrap()

        var type_params: [HirTypeParam] = []
        for tp in struct_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in struct_.fields:
            fields = fields.push(self.lower_field(f))

        HirStruct(
            symbol: symbol,
            name: struct_.name,
            type_params: type_params,
            fields: fields,
            is_public: struct_.is_public,
            doc_comment: struct_.doc_comment,
            span: struct_.span
        )

    me lower_field(f: Field) -> HirField:
        """Lower field to HIR."""
        val type_ = self.lower_type(f.type_)
        val symbol = self.symbols.define(f.name, SymbolKind.Field, Some(type_), f.span, f.is_public, false)

        HirField(
            symbol: symbol,
            name: f.name,
            type_: type_,
            default: f.default.map(\e: self.lower_expr(e)),
            is_public: f.is_public,
            span: f.span
        )

    me lower_enum(enum_: Enum) -> HirEnum:
        """Lower enum to HIR."""
        val symbol = self.symbols.lookup(enum_.name).unwrap()

        var type_params: [HirTypeParam] = []
        for tp in enum_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var variants: [HirVariant] = []
        for v in enum_.variants:
            variants = variants.push(self.lower_variant(v))

        HirEnum(
            symbol: symbol,
            name: enum_.name,
            type_params: type_params,
            variants: variants,
            is_public: enum_.is_public,
            doc_comment: enum_.doc_comment,
            span: enum_.span
        )

    me lower_variant(v: Variant) -> HirVariant:
        """Lower enum variant."""
        val symbol = self.symbols.define(v.name, SymbolKind.EnumVariant, None, v.span, true, false)

        val kind = match v.kind:
            case Unit:
                HirVariantKind.Unit
            case Tuple(types):
                var hir_types: [HirType] = []
                for t in types:
                    hir_types = hir_types.push(self.lower_type(t))
                HirVariantKind.Tuple(hir_types)
            case Struct(fields):
                var hir_fields: [HirField] = []
                for f in fields:
                    hir_fields = hir_fields.push(self.lower_field(f))
                HirVariantKind.Struct(hir_fields)

        HirVariant(
            symbol: symbol,
            name: v.name,
            kind: kind,
            span: v.span
        )

    me lower_trait(trait_: Trait) -> HirTrait:
        """Lower trait to HIR."""
        val symbol = self.symbols.lookup(trait_.name).unwrap()

        self.symbols.push_scope(ScopeKind.Class)

        var type_params: [HirTypeParam] = []
        for tp in trait_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var methods: [HirFunction] = []
        for m in trait_.methods:
            methods = methods.push(self.lower_function(m))

        self.symbols.pop_scope()

        HirTrait(
            symbol: symbol,
            name: trait_.name,
            type_params: type_params,
            methods: methods,
            is_public: trait_.is_public,
            doc_comment: trait_.doc_comment,
            span: trait_.span
        )

    me lower_impl(impl_: Impl) -> HirImpl:
        """Lower impl block to HIR."""
        self.symbols.push_scope(ScopeKind.Impl)

        val type_ = self.lower_type(impl_.type_)
        val trait_ = impl_.trait_.map(\t: self.lower_type(t))

        var methods: Dict<text, SymbolId> = {}
        for name, fn_ in impl_.methods:
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        self.symbols.pop_scope()

        HirImpl(
            type_: type_,
            trait_: trait_,
            methods: methods,
            span: impl_.span
        )

    me lower_const(const_: Const) -> HirConst:
        """Lower constant to HIR."""
        val symbol = self.symbols.lookup(const_.name).unwrap()
        val type_ = const_.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: const_.span)
        val value = self.lower_expr(const_.value)

        HirConst(
            symbol: symbol,
            name: const_.name,
            type_: type_,
            value: value,
            is_mutable: const_.is_mutable,
            is_public: const_.is_public,
            span: const_.span
        )

    # ========================================================================
    # Expression Lowering
    # ========================================================================

    me lower_expr(e: Expr) -> HirExpr:
        """Lower expression to HIR."""
        val kind = match e.kind:
            case IntLit(value):
                HirExprKind.IntLit(value, None)

            case FloatLit(value):
                HirExprKind.FloatLit(value, None)

            case StringLit(value, interps):
                var hir_interps: [HirInterpolation]? = None
                if interps.?:
                    var list: [HirInterpolation] = []
                    for i in interps.unwrap():
                        list = list.push(HirInterpolation(
                            expr: self.lower_expr(i.expr),
                            format: i.format,
                            span: i.span
                        ))
                    hir_interps = Some(list)
                HirExprKind.StringLit(value, hir_interps)

            case BoolLit(value):
                HirExprKind.BoolLit(value)

            case NilLit:
                HirExprKind.NilLit

            case ArrayLit(elements):
                var hir_elements: [HirExpr] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_expr(elem))
                HirExprKind.ArrayLit(hir_elements, None)

            case TupleLit(elements):
                var hir_elements: [HirExpr] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_expr(elem))
                HirExprKind.TupleLit(hir_elements)

            case DictLit(entries):
                var hir_entries: [(HirExpr, HirExpr)] = []
                for entry in entries:
                    hir_entries = hir_entries.push((
                        self.lower_expr(entry.0),
                        self.lower_expr(entry.1)
                    ))
                HirExprKind.DictLit(hir_entries, None, None)

            case Ident(name):
                val symbol = self.symbols.lookup(name)
                if symbol.?:
                    HirExprKind.Var(symbol.unwrap())
                else:
                    self.error("unresolved name: {name}", e.span)
                    HirExprKind.Error

            case Field(base, field):
                HirExprKind.Field(self.lower_expr(base), field, None)

            case Index(base, index):
                HirExprKind.Index(self.lower_expr(base), self.lower_expr(index))

            case OptionalChain(base, field):
                HirExprKind.OptionalChain(self.lower_expr(base), field)

            case NullCoalesce(left, right):
                HirExprKind.NullCoalesce(self.lower_expr(left), self.lower_expr(right))

            case ExistsCheck(base):
                HirExprKind.ExistsCheck(self.lower_expr(base))

            case Binary(op, left, right):
                val hir_op = self.lower_binop(op)
                HirExprKind.Binary(hir_op, self.lower_expr(left), self.lower_expr(right))

            case Unary(op, operand):
                val hir_op = self.lower_unaryop(op)
                HirExprKind.Unary(hir_op, self.lower_expr(operand))

            case Call(callee, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                HirExprKind.Call(self.lower_expr(callee), hir_args, [])

            case MethodCall(receiver, method, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                HirExprKind.MethodCall(self.lower_expr(receiver), method, hir_args, None)

            case If(cond, then_, else_):
                HirExprKind.If(
                    self.lower_expr(cond),
                    self.lower_block(then_),
                    else_.map(\b: self.lower_block(b))
                )

            case Match(scrutinee, arms):
                var hir_arms: [HirMatchArm] = []
                for arm in arms:
                    hir_arms = hir_arms.push(HirMatchArm(
                        pattern: self.lower_pattern(arm.pattern),
                        guard: arm.guard.map(\g: self.lower_expr(g)),
                        body: self.lower_block(arm.body),
                        span: arm.span
                    ))
                HirExprKind.Match(self.lower_expr(scrutinee), hir_arms)

            case Lambda(params, body):
                self.symbols.push_scope(ScopeKind.Function)
                var hir_params: [HirParam] = []
                for p in params:
                    val type_ = p.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: p.span)
                    val symbol = self.symbols.define(p.name, SymbolKind.Parameter, Some(type_), p.span, false, false)
                    hir_params = hir_params.push(HirParam(
                        symbol: symbol,
                        name: p.name,
                        type_: type_,
                        default: None,
                        span: p.span
                    ))
                val hir_body = self.lower_expr(body)
                self.symbols.pop_scope()
                HirExprKind.Lambda(hir_params, hir_body, [])

            case Block(block):
                HirExprKind.Block(self.lower_block(block))

            case Return(value):
                HirExprKind.Return(value.map(\v: self.lower_expr(v)))

            case Break(label):
                HirExprKind.Break(label, None)

            case Continue(label):
                HirExprKind.Continue(label)

            case Yield(value):
                HirExprKind.Yield(value.map(\v: self.lower_expr(v)))

            case Throw(value):
                HirExprKind.Throw(self.lower_expr(value))

            case Await(expr):
                HirExprKind.Await(self.lower_expr(expr))

            case Try(expr):
                HirExprKind.Try(self.lower_expr(expr))

            case Range(start, end, inclusive, step):
                HirExprKind.Range(
                    start.map(\s: self.lower_expr(s)),
                    end.map(\e: self.lower_expr(e)),
                    inclusive,
                    step.map(\s: self.lower_expr(s))
                )

            case ListComprehension(expr, clauses):
                var hir_clauses: [HirCompClause] = []
                for clause in clauses:
                    val hir_kind = match clause.kind:
                        case For(var_, iter):
                            val symbol = self.symbols.define(var_, SymbolKind.Variable, None, clause.span, false, false)
                            HirCompClauseKind.For(symbol, self.lower_expr(iter))
                        case If(cond):
                            HirCompClauseKind.If(self.lower_expr(cond))
                    hir_clauses = hir_clauses.push(HirCompClause(kind: hir_kind, span: clause.span))
                HirExprKind.Comprehension(HirComprehensionKind.List, self.lower_expr(expr), hir_clauses)

            case StructLit(type_, fields):
                var hir_fields: [(text, HirExpr)] = []
                for field in fields:
                    hir_fields = hir_fields.push((field.0, self.lower_expr(field.1)))
                val symbol = self.symbols.lookup(type_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                HirExprKind.StructLit(hir_type, hir_fields)

            case EnumLit(enum_, variant, payload):
                val symbol = self.symbols.lookup(enum_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                val hir_payload = payload.map(\p: match p:
                    case Tuple(values):
                        var hir_values: [HirExpr] = []
                        for v in values:
                            hir_values = hir_values.push(self.lower_expr(v))
                        HirEnumPayload.Tuple(hir_values)
                    case Struct(fields):
                        var hir_fields: [(text, HirExpr)] = []
                        for f in fields:
                            hir_fields = hir_fields.push((f.0, self.lower_expr(f.1)))
                        HirEnumPayload.Struct(hir_fields)
                )
                HirExprKind.EnumLit(hir_type, variant, hir_payload)

            case Error:
                HirExprKind.Error

            case _:
                self.error("unsupported expression kind", e.span)
                HirExprKind.Error

        HirExpr(kind: kind, type_: None, span: e.span)

    me lower_binop(op: BinOp) -> HirBinOp:
        """Lower binary operator."""
        match op:
            case Add: HirBinOp.Add
            case Sub: HirBinOp.Sub
            case Mul: HirBinOp.Mul
            case Div: HirBinOp.Div
            case Mod: HirBinOp.Mod
            case Pow: HirBinOp.Pow
            case Eq: HirBinOp.Eq
            case NotEq: HirBinOp.NotEq
            case Lt: HirBinOp.Lt
            case LtEq: HirBinOp.LtEq
            case Gt: HirBinOp.Gt
            case GtEq: HirBinOp.GtEq
            case And: HirBinOp.And
            case Or: HirBinOp.Or
            case BitAnd: HirBinOp.BitAnd
            case BitOr: HirBinOp.BitOr
            case BitXor: HirBinOp.BitXor
            case Shl: HirBinOp.Shl
            case Shr: HirBinOp.Shr
            case In: HirBinOp.In
            case NotIn: HirBinOp.NotIn
            case Is: HirBinOp.Is
            case IsNot: HirBinOp.IsNot

    me lower_unaryop(op: UnaryOp) -> HirUnaryOp:
        """Lower unary operator."""
        match op:
            case Neg: HirUnaryOp.Neg
            case Not: HirUnaryOp.Not
            case BitNot: HirUnaryOp.BitNot
            case Ref: HirUnaryOp.Ref
            case Deref: HirUnaryOp.Deref

    me lower_pattern(p: Pattern) -> HirPattern:
        """Lower pattern to HIR."""
        val kind = match p.kind:
            case Wildcard:
                HirPatternKind.Wildcard

            case Literal(value):
                HirPatternKind.Literal(self.lower_expr(value))

            case Binding(name, mutable):
                val symbol = self.symbols.define(name, SymbolKind.Variable, None, p.span, false, mutable)
                HirPatternKind.Binding(symbol, mutable)

            case Tuple(elements):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_pattern(elem))
                HirPatternKind.Tuple(hir_elements)

            case Array(elements, rest):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_pattern(elem))
                var rest_symbol: SymbolId? = None
                if rest.?:
                    rest_symbol = Some(self.symbols.define(rest.unwrap(), SymbolKind.Variable, None, p.span, false, false))
                HirPatternKind.Array(hir_elements, rest_symbol)

            case Struct(type_, fields):
                val symbol = self.symbols.lookup(type_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                var hir_fields: [(text, HirPattern)] = []
                for field in fields:
                    hir_fields = hir_fields.push((field.0, self.lower_pattern(field.1)))
                HirPatternKind.Struct(hir_type, hir_fields)

            case Enum(enum_, variant, payload):
                val symbol = self.symbols.lookup(enum_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                val hir_payload = payload.map(\pl: match pl:
                    case Tuple(patterns):
                        var hir_patterns: [HirPattern] = []
                        for pat in patterns:
                            hir_patterns = hir_patterns.push(self.lower_pattern(pat))
                        HirPatternPayload.Tuple(hir_patterns)
                    case Struct(fields):
                        var hir_fields: [(text, HirPattern)] = []
                        for f in fields:
                            hir_fields = hir_fields.push((f.0, self.lower_pattern(f.1)))
                        HirPatternPayload.Struct(hir_fields)
                )
                HirPatternKind.Enum(hir_type, variant, hir_payload)

            case Or(patterns):
                var hir_patterns: [HirPattern] = []
                for pat in patterns:
                    hir_patterns = hir_patterns.push(self.lower_pattern(pat))
                HirPatternKind.Or(hir_patterns)

            case Range(start, end, inclusive):
                HirPatternKind.Range(
                    start.map(\s: self.lower_expr(s)),
                    end.map(\e: self.lower_expr(e)),
                    inclusive
                )

            case Error:
                HirPatternKind.Error

            case _:
                self.error("unsupported pattern kind", p.span)
                HirPatternKind.Error

        HirPattern(kind: kind, type_: None, span: p.span)

    me lower_block(b: Block) -> HirBlock:
        """Lower block to HIR."""
        self.symbols.push_scope(ScopeKind.Block)

        var stmts: [HirStmt] = []
        for s in b.stmts:
            stmts = stmts.push(self.lower_stmt(s))

        self.symbols.pop_scope()

        # Check if last statement is an expression (for block value)
        var value: HirExpr? = None
        if stmts.len() > 0:
            val last = stmts[stmts.len() - 1]
            match last.kind:
                case Expr(expr):
                    value = Some(expr)
                    stmts = stmts[0:stmts.len() - 1]  # Remove last stmt
                case _:
                    pass

        HirBlock(stmts: stmts, value: value, span: b.span)

    me lower_stmt(s: Stmt) -> HirStmt:
        """Lower statement to HIR."""
        val kind = match s.kind:
            case Expr(expr):
                HirStmtKind.Expr(self.lower_expr(expr))

            case Val(name, type_, init):
                val hir_type = type_.map(\t: self.lower_type(t))
                val hir_init = self.lower_expr(init)
                val symbol = self.symbols.define(name, SymbolKind.Variable, hir_type, s.span, false, false)
                HirStmtKind.Let(symbol, hir_type, hir_init)

            case Var(name, type_, init):
                val hir_type = type_.map(\t: self.lower_type(t))
                val hir_init = init.map(\i: self.lower_expr(i)) ?? HirExpr(kind: HirExprKind.NilLit, type_: None, span: s.span)
                val symbol = self.symbols.define(name, SymbolKind.Variable, hir_type, s.span, false, true)
                HirStmtKind.Let(symbol, hir_type, hir_init)

            case Assign(target, op, value):
                val hir_op = op.map(\o: match o:
                    case Add: HirAssignOp.Add
                    case Sub: HirAssignOp.Sub
                    case Mul: HirAssignOp.Mul
                    case Div: HirAssignOp.Div
                    case Mod: HirAssignOp.Mod
                )
                HirStmtKind.Assign(self.lower_expr(target), hir_op, self.lower_expr(value))

            case For(var_, iter, body):
                self.symbols.push_scope(ScopeKind.Loop)
                self.loop_depth = self.loop_depth + 1
                val symbol = self.symbols.define(var_, SymbolKind.Variable, None, s.span, false, false)
                val hir_iter = self.lower_expr(iter)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                self.symbols.pop_scope()
                # Desugar to loop
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.For(symbol, hir_iter, hir_body, None),
                    type_: None,
                    span: s.span
                ))

            case While(cond, body):
                self.loop_depth = self.loop_depth + 1
                val hir_cond = self.lower_expr(cond)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.While(hir_cond, hir_body, None),
                    type_: None,
                    span: s.span
                ))

            case Loop(body):
                self.loop_depth = self.loop_depth + 1
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Loop(hir_body, None),
                    type_: None,
                    span: s.span
                ))

            case Return(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Return(value.map(\v: self.lower_expr(v))),
                    type_: None,
                    span: s.span
                ))

            case Break(label):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Break(label, None),
                    type_: None,
                    span: s.span
                ))

            case Continue(label):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Continue(label),
                    type_: None,
                    span: s.span
                ))

            case Yield(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Yield(value.map(\v: self.lower_expr(v))),
                    type_: None,
                    span: s.span
                ))

            case Throw(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Throw(self.lower_expr(value)),
                    type_: None,
                    span: s.span
                ))

        HirStmt(kind: kind, span: s.span)

    me error(message: text, span: Span):
        """Record a lowering error."""
        self.errors = self.errors.push(LoweringError(
            message: message,
            span: span,
            kind: LoweringErrorKind.Other
        ))

# ============================================================================
# Exports
# ============================================================================

export HirModule, HirImport, HirImportItem
export SymbolId, Symbol, SymbolKind, ScopeId, Scope, ScopeKind, SymbolTable
export HirType, HirTypeKind, Effect, EffectKind
export HirFunction, HirTypeParam, HirParam
export HirClass, HirStruct, HirField, HirEnum, HirVariant, HirVariantKind
export HirTrait, HirImpl, HirConst
export HirExpr, HirExprKind, HirInterpolation, HirCallArg, HirMatchArm
export HirEnumPayload, HirComprehensionKind, HirCompClause, HirCompClauseKind
export HirBinOp, HirUnaryOp
export HirPattern, HirPatternKind, HirPatternPayload
export HirStmt, HirStmtKind, HirAssignOp, HirBlock
export HirLowering, LoweringError, LoweringErrorKind
