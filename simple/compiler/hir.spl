# HIR - High-level Intermediate Representation
#
# Shared IR between interpreter, compiler, and SDN backends.
# Lowered from AST with:
# - Name resolution (identifiers -> symbols)
# - Type information (inferred or explicit)
# - Desugaring (comprehensions, operators, etc.)
#
# The Backend trait processes HIR differently:
# - Interpreter: Tree-walks and evaluates
# - Compiler: Lowers to MIR then codegen
# - SDN: Blocks code execution, only allows data

use parser.*
use lexer.Span
use blocks.{BlockValue, BlockRegistry, block_registry}

# ============================================================================
# HIR Module Structure
# ============================================================================

struct HirModule:
    """Complete HIR module."""
    name: text
    path: text
    imports: [HirImport]
    exports: [text]
    symbols: SymbolTable
    functions: Dict<SymbolId, HirFunction>
    classes: Dict<SymbolId, HirClass>
    structs: Dict<SymbolId, HirStruct>
    enums: Dict<SymbolId, HirEnum>
    traits: Dict<SymbolId, HirTrait>
    impls: [HirImpl]
    constants: Dict<SymbolId, HirConst>

struct HirImport:
    """Import declaration."""
    module_path: text
    items: [HirImportItem]
    span: Span

struct HirImportItem:
    """Single imported item."""
    name: text
    alias: text?
    resolved: SymbolId?     # Resolved after linking

# ============================================================================
# Symbol Table
# ============================================================================

struct SymbolId:
    """Unique identifier for a symbol."""
    id: i64

impl SymbolId:
    static fn new(id: i64) -> SymbolId:
        SymbolId(id: id)

    fn is_valid() -> bool:
        self.id >= 0

struct Symbol:
    """Symbol table entry."""
    id: SymbolId
    name: text
    kind: SymbolKind
    type_: HirType?
    scope: ScopeId
    span: Span
    is_public: bool
    is_mutable: bool

"""Kind of symbol."""
enum SymbolKind:
    Function
    Method
    Variable
    Parameter
    Field
    Class
    Struct
    Enum
    EnumVariant
    Trait
    TypeAlias
    TypeParam
    Const
    Module
    Import

# ============================================================================
# Method Resolution (UFCS Support)
# ============================================================================

"""How a method call was resolved.

Supports UFCS (Uniform Function Call Syntax) where `x.method()` can resolve to:
1. Instance method on x's type (highest priority)
2. Trait method implemented by x's type
3. Free function `method(x)` where first param matches x's type (UFCS)

Examples:
    x.map()  ->  InstanceMethod if x's class has map()
    x.map()  ->  TraitMethod if x implements trait with map()
    x.map()  ->  FreeFunction(map) if map(x) exists and first param matches
"""
enum MethodResolution:
    # Direct method on the receiver's type
    InstanceMethod(type_id: SymbolId, method_id: SymbolId)

    # Method from an implemented trait
    TraitMethod(trait_id: SymbolId, method_id: SymbolId)

    # UFCS: Free function where receiver becomes first argument
    # x.method(a, b) -> method(x, a, b)
    FreeFunction(func_id: SymbolId)

    # Not yet resolved (before resolution pass)
    Unresolved

impl MethodResolution:
    fn is_resolved() -> bool:
        """Check if method has been resolved."""
        match self:
            case Unresolved: false
            case _: true

    fn is_ufcs() -> bool:
        """Check if this is a UFCS resolution (free function)."""
        match self:
            case FreeFunction(_): true
            case _: false

    fn get_symbol_id() -> SymbolId?:
        """Get the resolved symbol ID if available."""
        match self:
            case InstanceMethod(_, method_id): Some(method_id)
            case TraitMethod(_, method_id): Some(method_id)
            case FreeFunction(func_id): Some(func_id)
            case Unresolved: nil

struct ScopeId:
    """Unique identifier for a scope."""
    id: i64

struct Scope:
    """Lexical scope."""
    id: ScopeId
    parent: ScopeId?
    kind: ScopeKind
    symbols: Dict<text, SymbolId>

"""Kind of scope."""
enum ScopeKind:
    Module
    Function
    Block
    Loop
    Match
    Class
    Impl

class SymbolTable:
    """Symbol table for name resolution."""
    symbols: Dict<i64, Symbol>
    scopes: Dict<i64, Scope>
    current_scope: ScopeId
    next_symbol_id: i64
    next_scope_id: i64

impl SymbolTable:
    static fn new() -> SymbolTable:
        var table = SymbolTable(
            symbols: {},
            scopes: {},
            current_scope: ScopeId(id: 0),
            next_symbol_id: 0,
            next_scope_id: 1
        )
        # Create root scope
        table.scopes[0] = Scope(
            id: ScopeId(id: 0),
            parent: nil,
            kind: ScopeKind.Module,
            symbols: {}
        )
        table

    me define(name: text, kind: SymbolKind, type_: HirType?, span: Span, is_public: bool, is_mutable: bool) -> SymbolId:
        """Define a new symbol in current scope."""
        val id = SymbolId.new(self.next_symbol_id)
        self.next_symbol_id = self.next_symbol_id + 1

        val symbol = Symbol(
            id: id,
            name: name,
            kind: kind,
            type_: type_,
            scope: self.current_scope,
            span: span,
            is_public: is_public,
            is_mutable: is_mutable
        )

        self.symbols[id.id] = symbol

        # Get scope, modify, and put back (value semantics)
        var scope = self.scopes[self.current_scope.id]
        var scope_symbols = scope.symbols
        scope_symbols[name] = id
        scope.symbols = scope_symbols
        self.scopes[self.current_scope.id] = scope

        id

    fn lookup(name: text) -> SymbolId?:
        """Look up a symbol by name, searching up scope chain."""
        var scope_id = self.current_scope

        loop:
            val scope = self.scopes[scope_id.id]
            # Use contains_key to check if key exists before accessing
            if scope.symbols.contains_key(name):
                return Some(scope.symbols[name])

            if scope.parent.?:
                scope_id = scope.parent.unwrap()
            else:
                break

        nil

    fn get(id: SymbolId) -> Symbol?:
        """Get symbol by ID."""
        self.symbols[id.id]

    me push_scope(kind: ScopeKind) -> ScopeId:
        """Push a new scope."""
        val id = ScopeId(id: self.next_scope_id)
        self.next_scope_id = self.next_scope_id + 1

        self.scopes[id.id] = Scope(
            id: id,
            parent: Some(self.current_scope),
            kind: kind,
            symbols: {}
        )

        self.current_scope = id
        id

    me pop_scope():
        """Pop current scope."""
        val scope = self.scopes[self.current_scope.id]
        if scope.parent.?:
            self.current_scope = scope.parent.unwrap()

    # ========================================================================
    # Method Resolution Helpers (for UFCS support)
    # ========================================================================

    fn lookup_function(name: text) -> SymbolId?:
        """Look up a free function by name."""
        val sym_id = self.lookup(name)
        if sym_id.?:
            val sym = self.get(sym_id.unwrap())
            if sym.?:
                match sym.unwrap().kind:
                    case Function: return sym_id
                    case _: pass
        nil

    fn lookup_method_in_type(type_id: SymbolId, method_name: text) -> SymbolId?:
        """Look up a method in a class/struct type.

        Searches for a method named `method_name` defined in the type
        identified by `type_id`.
        """
        # Get the type's scope (class or struct body)
        val type_sym = self.get(type_id)
        if not type_sym.?:
            return None

        # Look for a Method symbol with matching name in the type's members
        # This requires traversing impl blocks associated with the type
        # For now, use a naming convention: Type::method
        val qualified_name = "{type_sym.unwrap().name}::{method_name}"
        for entry in self.symbols:
            val sym = entry.1
            if sym.name == qualified_name:
                match sym.kind:
                    case Method: return Some(sym.id)
                    case Function: return Some(sym.id)  # Static methods
                    case _: pass

        nil

    fn lookup_trait_method(trait_id: SymbolId, method_name: text) -> SymbolId?:
        """Look up a method in a trait.

        Searches for a method named `method_name` defined in the trait
        identified by `trait_id`.
        """
        val trait_sym = self.get(trait_id)
        if not trait_sym.?:
            return None

        # Look for trait method using qualified name
        val qualified_name = "{trait_sym.unwrap().name}::{method_name}"
        for entry in self.symbols:
            val sym = entry.1
            if sym.name == qualified_name:
                match sym.kind:
                    case Method: return Some(sym.id)
                    case _: pass

        nil

    fn get_symbol_type(id: SymbolId) -> HirType?:
        """Get the type of a symbol."""
        val sym = self.get(id)
        if sym.?:
            sym.unwrap().type_
        else:
            nil

    fn is_function(id: SymbolId) -> bool:
        """Check if symbol is a function."""
        val sym = self.get(id)
        if sym.?:
            match sym.unwrap().kind:
                case Function: true
                case _: false
        else:
            false

    fn is_method(id: SymbolId) -> bool:
        """Check if symbol is a method."""
        val sym = self.get(id)
        if sym.?:
            match sym.unwrap().kind:
                case Method: true
                case _: false
        else:
            false

    fn get_methods_for_type(type_id: SymbolId) -> [text]:
        """Get all method names for a type (for error suggestions)."""
        var methods: [text] = []
        val type_sym = self.get(type_id)
        if not type_sym.?:
            return methods

        val type_name = type_sym.unwrap().name
        val prefix = "{type_name}::"

        for entry in self.symbols:
            val sym = entry.1
            if not sym.?:
                pass
            elif not sym.name.?:
                pass
            elif sym.name.starts_with(prefix):
                match sym.kind:
                    case Method:
                        # Extract method name from qualified name
                        val method_name = sym.name[prefix.len():]
                        methods = methods.push(method_name)
                    case _: pass

        methods

    fn get_all_functions() -> [text]:
        """Get all function names (for error suggestions)."""
        var functions: [text] = []

        for entry in self.symbols:
            val sym = entry.1
            match sym.kind:
                case Function:
                    # Only include non-qualified names (free functions)
                    if not sym.name.contains("::"):
                        functions = functions.push(sym.name)
                case _: pass

        functions

# ============================================================================
# HIR Types
# ============================================================================

struct HirType:
    """Type in HIR."""
    kind: HirTypeKind
    span: Span

"""Type kind."""
enum HirTypeKind:
    # Primitive types
    Int(bits: i64, signed: bool)    # i8, i16, i32, i64, u8, u16, u32, u64
    Float(bits: i64)                 # f32, f64
    Bool
    Char
    Str
    Unit                             # ()

    # Composite types
    Tuple(elements: [HirType])
    Array(element: HirType, size: i64?)
    Slice(element: HirType)
    Dict(key: HirType, value: HirType)

    # Reference types
    Ref(inner: HirType, mutable: bool)
    Ptr(inner: HirType, mutable: bool)
    Optional(inner: HirType)
    Result(ok: HirType, err: HirType)

    # User-defined types
    Named(symbol: SymbolId, args: [HirType])
    TypeParam(name: text, bounds: [HirType])

    # Function types
    Function(params: [HirType], ret: HirType, effects: [Effect])

    # Special
    # Type inference variable with level for HM generalization
    # - id: unique identifier for the variable
    # - level: scope level at which the variable was created
    #   Higher level = more recently introduced, can be generalized
    Infer(id: i64, level: i64)
    Error
    Never                            # ! type (never returns)

    # Tensor and Layer types (for dimension checking)
    Tensor(element: HirType, dims: [DimExpr], device: DeviceType?)
    Layer(input: [DimExpr], output: [DimExpr])

# ============================================================================
# Dimension Types (for compile-time dimension checking)
# ============================================================================

struct DimExpr:
    """Dimension expression for tensor shape checking."""
    kind: DimExprKind
    span: Span

"""Dimension expression kind."""
enum DimExprKind:
    Literal(value: i64)                     # 784
    Named(name: text, lo: i64?, hi: i64?)   # batch: 1..128
    Var(id: i64)                            # Inference variable
    Dynamic                                  # Runtime only
    Broadcast                                # Broadcasting dimension
    ConstParam(name: text)                  # Reference to const generic
    # Arithmetic operations
    Add(left: DimExpr, right: DimExpr)
    Mul(left: DimExpr, right: DimExpr)
    Div(left: DimExpr, right: DimExpr)

impl DimExpr:
    static fn literal(value: i64, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Literal(value), span: span)

    static fn named(name: text, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Named(name, nil, nil), span: span)

    static fn named_range(name: text, lo: i64, hi: i64, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Named(name, Some(lo), Some(hi)), span: span)

    static fn var(id: i64, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Var(id), span: span)

    static fn dynamic(span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Dynamic, span: span)

    fn is_literal() -> bool:
        match self.kind:
            case Literal(_): true
            case _: false

    fn get_literal() -> i64?:
        match self.kind:
            case Literal(v): Some(v)
            case _: nil

"""Device type for tensors."""
enum DeviceType:
    CPU
    GPU
    CUDA(id: i64)

struct LayerType:
    """Type for neural network layers with input/output shapes."""
    input_shape: [DimExpr]
    output_shape: [DimExpr]
    params: [ParamShape]
    device: DeviceType?

struct ParamShape:
    """Shape of a trainable parameter in a layer."""
    name: text
    shape: [DimExpr]
    trainable: bool

impl LayerType:
    static fn new(input: [DimExpr], output: [DimExpr]) -> LayerType:
        LayerType(
            input_shape: input,
            output_shape: output,
            params: [],
            device: nil
        )

    fn with_device(device: DeviceType) -> LayerType:
        LayerType(
            input_shape: self.input_shape,
            output_shape: self.output_shape,
            params: self.params,
            device: Some(device)
        )

struct Effect:
    """Effect annotation."""
    kind: EffectKind
    span: Span

"""Effect kind."""
enum EffectKind:
    Pure            # No side effects
    IO              # I/O operations
    Async           # Async operations
    Throws(type_: HirType)  # Can throw error
    Mutates         # Mutates state
    Allocates       # Heap allocation
    Custom(name: text)

# ============================================================================
# HIR Definitions
# ============================================================================

struct HirFunction:
    """Function definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    params: [HirParam]
    return_type: HirType
    body: HirBlock
    effects: [Effect]
    is_async: bool
    is_static: bool
    is_public: bool
    is_method: bool
    is_mutable: bool        # 'me' method
    doc_comment: text?
    span: Span

struct HirTypeParam:
    """Generic type parameter."""
    symbol: SymbolId
    name: text
    bounds: [HirType]
    default: HirType?
    span: Span

struct HirParam:
    """Function parameter."""
    symbol: SymbolId
    name: text
    type_: HirType
    default: HirExpr?
    span: Span

struct HirClass:
    """Class definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    fields: [HirField]
    methods: Dict<text, SymbolId>
    is_public: bool
    doc_comment: text?
    span: Span

struct HirStruct:
    """Struct definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    fields: [HirField]
    is_public: bool
    doc_comment: text?
    span: Span

struct HirField:
    """Struct/class field."""
    symbol: SymbolId
    name: text
    type_: HirType
    default: HirExpr?
    is_public: bool
    span: Span

struct HirEnum:
    """Enum definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    variants: [HirVariant]
    is_public: bool
    doc_comment: text?
    span: Span

struct HirVariant:
    """Enum variant."""
    symbol: SymbolId
    name: text
    kind: HirVariantKind
    span: Span

"""Enum variant kind."""
enum HirVariantKind:
    Unit
    Tuple(types: [HirType])
    Struct(fields: [HirField])

struct HirTrait:
    """Trait definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    methods: [HirFunction]
    is_public: bool
    doc_comment: text?
    span: Span

struct HirImpl:
    """Impl block in HIR."""
    type_: HirType
    trait_: HirType?
    methods: Dict<text, SymbolId>
    span: Span

struct HirConst:
    """Module-level constant."""
    symbol: SymbolId
    name: text
    type_: HirType
    value: HirExpr
    is_mutable: bool
    is_public: bool
    span: Span

# ============================================================================
# HIR Expressions
# ============================================================================

struct HirExpr:
    """Expression in HIR."""
    kind: HirExprKind
    type_: HirType?         # Resolved type (filled during type checking)
    span: Span

"""Expression kind."""
enum HirExprKind:
    # Literals
    IntLit(value: i64, suffix: text?)
    FloatLit(value: f64, suffix: text?)
    StringLit(value: text, interpolations: [HirInterpolation]?)
    BoolLit(value: bool)
    CharLit(value: char)
    UnitLit
    NilLit

    # Collections
    ArrayLit(elements: [HirExpr], type_: HirType?)
    TupleLit(elements: [HirExpr])
    DictLit(entries: [(HirExpr, HirExpr)], key_type: HirType?, value_type: HirType?)

    # Variables and access
    Var(symbol: SymbolId)
    Field(base: HirExpr, field: text, resolved: SymbolId?)
    Index(base: HirExpr, index: HirExpr)
    TupleIndex(base: HirExpr, index: i64)

    # Optional operations
    OptionalChain(base: HirExpr, field: text)
    NullCoalesce(left: HirExpr, right: HirExpr)
    ExistsCheck(base: HirExpr)
    Unwrap(base: HirExpr)           # expr!

    # Operators
    Binary(op: HirBinOp, left: HirExpr, right: HirExpr)
    Unary(op: HirUnaryOp, operand: HirExpr)

    # Calls
    Call(callee: HirExpr, args: [HirCallArg], type_args: [HirType])
    MethodCall(receiver: HirExpr, method: text, args: [HirCallArg], resolution: MethodResolution)

    # Control flow
    If(cond: HirExpr, then_: HirBlock, else_: HirBlock?)
    Match(scrutinee: HirExpr, arms: [HirMatchArm])
    Loop(body: HirBlock, label: text?)
    While(cond: HirExpr, body: HirBlock, label: text?)
    For(var_: SymbolId, iter: HirExpr, body: HirBlock, label: text?)

    # Closures
    Lambda(params: [HirParam], body: HirExpr, captures: [SymbolId])
    Block(block: HirBlock)

    # Control transfer
    Return(value: HirExpr?)
    Break(label: text?, value: HirExpr?)
    Continue(label: text?)
    Throw(value: HirExpr)
    Try(expr: HirExpr)              # expr?

    # Async
    Await(expr: HirExpr)
    Yield(value: HirExpr?)

    # Construction
    StructLit(type_: HirType, fields: [(text, HirExpr)])
    EnumLit(type_: HirType, variant: text, payload: HirEnumPayload?)

    # Casts and conversions
    Cast(expr: HirExpr, target: HirType)
    As(expr: HirExpr, target: HirType)      # Safe cast (returns Option)

    # Special
    Range(start: HirExpr?, end: HirExpr?, inclusive: bool, step: HirExpr?)
    Comprehension(kind: HirComprehensionKind, expr: HirExpr, clauses: [HirCompClause])

    # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
    CustomBlock(kind: text, value: BlockValue)

    # Math/DL blocks (built-in with special semantics)
    LossBlock(body: HirBlock)           # loss{ ... } - autograd + auto-backward
    NogradBlock(body: HirBlock)         # nograd{ ... } - disable gradients

    # Error recovery
    Error

struct HirInterpolation:
    """String interpolation."""
    expr: HirExpr
    format: text?
    span: Span

struct HirCallArg:
    """Function call argument."""
    name: text?
    value: HirExpr
    span: Span

struct HirMatchArm:
    """Match arm."""
    pattern: HirPattern
    guard: HirExpr?
    body: HirBlock
    span: Span

"""Enum construction payload."""
enum HirEnumPayload:
    Tuple(values: [HirExpr])
    Struct(fields: [(text, HirExpr)])

"""Comprehension kind."""
enum HirComprehensionKind:
    List
    Dict
    Set
    Generator

struct HirCompClause:
    """Comprehension clause."""
    kind: HirCompClauseKind
    span: Span

"""Comprehension clause kind."""
enum HirCompClauseKind:
    For(var_: SymbolId, iter: HirExpr)
    If(cond: HirExpr)

# ============================================================================
# HIR Operators
# ============================================================================

"""Binary operator."""
enum HirBinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Mod, Pow

    # Matrix operations
    MatMul              # @

    # Comparison
    Eq, NotEq, Lt, LtEq, Gt, GtEq

    # Logical
    And, Or

    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr

    # Broadcast operations (dotted operators)
    BroadcastAdd        # .+
    BroadcastSub        # .-
    BroadcastMul        # .*
    BroadcastDiv        # ./
    BroadcastPow        # .^

    # Pipeline/Composition operators
    PipeForward         # |>
    Compose             # >>
    ComposeBack         # <<
    Parallel            # //
    LayerConnect        # ~>

    # Other
    In, NotIn
    Is, IsNot
    Concat         # ++

"""Unary operator."""
enum HirUnaryOp:
    Neg            # -
    Not            # not, !
    BitNot         # ~
    Ref            # &
    RefMut         # &mut
    Deref          # *
    Transpose      # ' (postfix, m{} only)

# ============================================================================
# HIR Patterns
# ============================================================================

struct HirPattern:
    """Pattern in HIR."""
    kind: HirPatternKind
    type_: HirType?
    span: Span

"""Pattern kind."""
enum HirPatternKind:
    Wildcard
    Literal(value: HirExpr)
    Binding(symbol: SymbolId, mutable: bool)
    Tuple(elements: [HirPattern])
    Array(elements: [HirPattern], rest: SymbolId?)
    Struct(type_: HirType, fields: [(text, HirPattern)])
    Enum(type_: HirType, variant: text, payload: HirPatternPayload?)
    Or(patterns: [HirPattern])
    Range(start: HirExpr?, end: HirExpr?, inclusive: bool)
    Error

"""Enum pattern payload."""
enum HirPatternPayload:
    Tuple(patterns: [HirPattern])
    Struct(fields: [(text, HirPattern)])

# ============================================================================
# HIR Statements
# ============================================================================

struct HirStmt:
    """Statement in HIR."""
    kind: HirStmtKind
    span: Span

"""Statement kind."""
enum HirStmtKind:
    Expr(expr: HirExpr)
    Let(symbol: SymbolId, type_: HirType?, init: HirExpr)
    Assign(target: HirExpr, op: HirAssignOp?, value: HirExpr)
    Block(block: HirBlock)

"""Compound assignment operator."""
enum HirAssignOp:
    Add, Sub, Mul, Div, Mod
    BitAnd, BitOr, BitXor, Shl, Shr

struct HirBlock:
    """Block of statements."""
    stmts: [HirStmt]
    value: HirExpr?     # Final expression (for block expressions)
    span: Span

# ============================================================================
# AST to HIR Lowering
# ============================================================================

class HirLowering:
    """Lowers AST to HIR."""
    symbols: SymbolTable
    errors: [LoweringError]
    current_function: SymbolId?
    loop_depth: i64

struct LoweringError:
    """Error during lowering."""
    message: text
    span: Span
    kind: LoweringErrorKind

"""Lowering error kind."""
enum LoweringErrorKind:
    UnresolvedName
    DuplicateDefinition
    TypeMismatch
    InvalidPattern
    InvalidExpression
    Other

impl HirLowering:
    static fn new() -> HirLowering:
        HirLowering(
            symbols: SymbolTable.new(),
            errors: [],
            current_function: nil,
            loop_depth: 0
        )

    me lower_module(module: Module) -> HirModule:
        """Lower a parsed module to HIR."""
        # First pass: declare all top-level symbols
        self.declare_module_symbols(module)

        # Second pass: lower definitions
        var functions: Dict<SymbolId, HirFunction> = {}
        var classes: Dict<SymbolId, HirClass> = {}
        var structs: Dict<SymbolId, HirStruct> = {}
        var enums: Dict<SymbolId, HirEnum> = {}
        var traits: Dict<SymbolId, HirTrait> = {}
        var impls: [HirImpl] = []
        var constants: Dict<SymbolId, HirConst> = {}

        for name in module.functions.keys():
            val fn_ = module.functions[name]
            val hir_fn = self.lower_function(fn_)
            functions[hir_fn.symbol] = hir_fn

        for name in module.classes.keys():
            val class_ = module.classes[name]
            val hir_class = self.lower_class(class_)
            classes[hir_class.symbol] = hir_class

        for name in module.structs.keys():
            val struct_ = module.structs[name]
            val hir_struct = self.lower_struct(struct_)
            structs[hir_struct.symbol] = hir_struct

        for name in module.enums.keys():
            val enum_ = module.enums[name]
            val hir_enum = self.lower_enum(enum_)
            enums[hir_enum.symbol] = hir_enum

        for name in module.traits.keys():
            val trait_ = module.traits[name]
            val hir_trait = self.lower_trait(trait_)
            traits[hir_trait.symbol] = hir_trait

        for impl_ in module.impls:
            impls = impls.push(self.lower_impl(impl_))

        for name in module.constants.keys():
            val const_ = module.constants[name]
            val hir_const = self.lower_const(const_)
            constants[hir_const.symbol] = hir_const

        # Lower imports
        var imports: [HirImport] = []
        for imp in module.imports:
            imports = imports.push(self.lower_import(imp))

        # Collect exports
        var exports: [text] = []
        for exp in module.exports:
            for item in exp.items:
                exports = exports.push(item)

        HirModule(
            name: module.name,
            path: "",
            imports: imports,
            exports: exports,
            symbols: self.symbols,
            functions: functions,
            classes: classes,
            structs: structs,
            enums: enums,
            traits: traits,
            impls: impls,
            constants: constants
        )

    me declare_module_symbols(module: Module):
        """Declare all top-level symbols."""
        # Workaround: Store symbols table in local var to avoid interpreter bug
        var symbols_table = self.symbols

        for name in module.functions.keys():
            val fn_ = module.functions[name]
            symbols_table.define(name, SymbolKind.Function, nil, fn_.span, fn_.is_public, false)

        for name in module.classes.keys():
            val class_ = module.classes[name]
            symbols_table.define(name, SymbolKind.Class, nil, class_.span, class_.is_public, false)

        for name in module.structs.keys():
            val struct_ = module.structs[name]
            symbols_table.define(name, SymbolKind.Struct, nil, struct_.span, struct_.is_public, false)

        for name in module.enums.keys():
            val enum_ = module.enums[name]
            symbols_table.define(name, SymbolKind.Enum, nil, enum_.span, enum_.is_public, false)

        for name in module.traits.keys():
            val trait_ = module.traits[name]
            symbols_table.define(name, SymbolKind.Trait, nil, trait_.span, trait_.is_public, false)

        for name in module.constants.keys():
            val const_ = module.constants[name]
            symbols_table.define(name, SymbolKind.Const, nil, const_.span, const_.is_public, const_.is_mutable)

        # Declare impl methods
        for impl_ in module.impls:
            for name in impl_.methods.keys():
                val fn_ = impl_.methods[name]
                symbols_table.define(name, SymbolKind.Method, nil, fn_.span, fn_.is_public, false)

        self.symbols = symbols_table

    me lower_import(imp: Import) -> HirImport:
        """Lower import declaration."""
        var items: [HirImportItem] = []
        for item in imp.items:
            items = items.push(HirImportItem(
                name: item.name,
                alias: item.alias,
                resolved: nil
            ))

        HirImport(
            module_path: imp.module,
            items: items,
            span: imp.span
        )

    me lower_function(fn_: Function) -> HirFunction:
        """Lower function to HIR."""
        # Workaround: Store symbols in local var first to avoid interpreter bug
        # where chained method calls corrupt 'self'
        var symbols_table = self.symbols
        val fn_symbol_id = symbols_table.lookup(fn_.name).unwrap()

        # Workaround: Create the Some value separately to avoid interpreter bug
        val opt_fn_id: SymbolId? = Some(fn_symbol_id)
        self.current_function = opt_fn_id

        # Re-get symbols from self after field modification
        symbols_table = self.symbols
        symbols_table.push_scope(ScopeKind.Function)
        self.symbols = symbols_table

        # Lower type parameters
        var type_params: [HirTypeParam] = []
        for tp in fn_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        # Lower parameters
        var params: [HirParam] = []
        for p in fn_.params:
            params = params.push(self.lower_param(p))

        # Lower return type
        val return_type = fn_.return_type.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Unit, span: fn_.span)

        # Lower body
        val body = self.lower_block(fn_.body)

        # Workaround: Store symbols in local var to avoid interpreter bug
        symbols_table = self.symbols
        symbols_table.pop_scope()
        self.symbols = symbols_table
        self.current_function = None

        HirFunction(
            symbol: fn_symbol_id,
            name: fn_.name,
            type_params: type_params,
            params: params,
            return_type: return_type,
            body: body,
            effects: [],
            is_async: fn_.is_async,
            is_static: fn_.is_static,
            is_public: fn_.is_public,
            is_method: fn_.is_method,
            is_mutable: fn_.is_mutable,
            doc_comment: fn_.doc_comment,
            span: fn_.span
        )

    me lower_type_param(tp: TypeParam) -> HirTypeParam:
        """Lower type parameter."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.define(tp.name, SymbolKind.TypeParam, nil, tp.span, false, false)
        self.symbols = symbols_table

        var bounds: [HirType] = []
        for b in tp.bounds:
            bounds = bounds.push(self.lower_type(b))

        HirTypeParam(
            symbol: symbol,
            name: tp.name,
            bounds: bounds,
            default: tp.default.map(\t: self.lower_type(t)),
            span: tp.span
        )

    me lower_param(p: Param) -> HirParam:
        """Lower function parameter."""
        val type_ = p.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: p.span)
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.define(p.name, SymbolKind.Parameter, Some(type_), p.span, false, false)
        self.symbols = symbols_table

        HirParam(
            symbol: symbol,
            name: p.name,
            type_: type_,
            default: p.default.map(\e: self.lower_expr(e)),
            span: p.span
        )

    me lower_type(t: Type) -> HirType:
        """Lower type expression."""
        val kind = match t.kind:
            case Named(name, args):
                var hir_args: [HirType] = []
                for arg in args:
                    hir_args = hir_args.push(self.lower_type(arg))

                # Check for builtin types
                match name:
                    case "i8": HirTypeKind.Int(8, true)
                    case "i16": HirTypeKind.Int(16, true)
                    case "i32": HirTypeKind.Int(32, true)
                    case "i64": HirTypeKind.Int(64, true)
                    case "u8": HirTypeKind.Int(8, false)
                    case "u16": HirTypeKind.Int(16, false)
                    case "u32": HirTypeKind.Int(32, false)
                    case "u64": HirTypeKind.Int(64, false)
                    case "f32": HirTypeKind.Float(32)
                    case "f64": HirTypeKind.Float(64)
                    case "bool": HirTypeKind.Bool
                    case "char": HirTypeKind.Char
                    case "text" | "str" | "String": HirTypeKind.Str
                    case _:
                        val symbol = self.symbols.lookup(name)
                        if symbol.?:
                            HirTypeKind.Named(symbol.unwrap(), hir_args)
                        else:
                            self.error("unresolved type: {name}", t.span)
                            HirTypeKind.Error

            case Tuple(elements):
                if elements.is_empty():
                    HirTypeKind.Unit
                else:
                    var hir_elements: [HirType] = []
                    for e in elements:
                        hir_elements = hir_elements.push(self.lower_type(e))
                    HirTypeKind.Tuple(hir_elements)

            case Array(element, size):
                val hir_element = self.lower_type(element)
                HirTypeKind.Array(hir_element, nil)

            case Function(params, ret):
                var hir_params: [HirType] = []
                for p in params:
                    hir_params = hir_params.push(self.lower_type(p))
                val hir_ret = self.lower_type(ret)
                HirTypeKind.Function(hir_params, hir_ret, [])

            case Optional(inner):
                HirTypeKind.Optional(self.lower_type(inner))

            case Reference(inner, mutable):
                HirTypeKind.Ref(self.lower_type(inner), mutable)

            case Infer:
                HirTypeKind.Infer(0, 0)

            case Error:
                HirTypeKind.Error

        HirType(kind: kind, span: t.span)

    me lower_class(class_: Class) -> HirClass:
        """Lower class to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.lookup(class_.name).unwrap()

        symbols_table.push_scope(ScopeKind.Class)
        self.symbols = symbols_table

        var type_params: [HirTypeParam] = []
        for tp in class_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in class_.fields:
            fields = fields.push(self.lower_field(f))

        var methods: Dict<text, SymbolId> = {}
        for name in class_.methods.keys():
            val fn_ = class_.methods[name]
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        symbols_table = self.symbols
        symbols_table.pop_scope()
        self.symbols = symbols_table

        HirClass(
            symbol: symbol,
            name: class_.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: class_.is_public,
            doc_comment: class_.doc_comment,
            span: class_.span
        )

    me lower_struct(struct_: Struct) -> HirStruct:
        """Lower struct to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.lookup(struct_.name).unwrap()
        self.symbols = symbols_table

        var type_params: [HirTypeParam] = []
        for tp in struct_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in struct_.fields:
            fields = fields.push(self.lower_field(f))

        HirStruct(
            symbol: symbol,
            name: struct_.name,
            type_params: type_params,
            fields: fields,
            is_public: struct_.is_public,
            doc_comment: struct_.doc_comment,
            span: struct_.span
        )

    me lower_field(f: Field) -> HirField:
        """Lower field to HIR."""
        val type_ = self.lower_type(f.type_)
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.define(f.name, SymbolKind.Field, Some(type_), f.span, f.is_public, false)
        self.symbols = symbols_table

        HirField(
            symbol: symbol,
            name: f.name,
            type_: type_,
            default: f.default.map(\e: self.lower_expr(e)),
            is_public: f.is_public,
            span: f.span
        )

    me lower_enum(enum_: Enum) -> HirEnum:
        """Lower enum to HIR."""
        val symbol = self.symbols.lookup(enum_.name).unwrap()

        var type_params: [HirTypeParam] = []
        for tp in enum_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var variants: [HirVariant] = []
        for v in enum_.variants:
            variants = variants.push(self.lower_variant(v))

        HirEnum(
            symbol: symbol,
            name: enum_.name,
            type_params: type_params,
            variants: variants,
            is_public: enum_.is_public,
            doc_comment: enum_.doc_comment,
            span: enum_.span
        )

    me lower_variant(v: Variant) -> HirVariant:
        """Lower enum variant."""
        val symbol = self.symbols.define(v.name, SymbolKind.EnumVariant, nil, v.span, true, false)

        val kind = match v.kind:
            case Unit:
                HirVariantKind.Unit
            case Tuple(types):
                var hir_types: [HirType] = []
                for t in types:
                    hir_types = hir_types.push(self.lower_type(t))
                HirVariantKind.Tuple(hir_types)
            case Struct(fields):
                var hir_fields: [HirField] = []
                for f in fields:
                    hir_fields = hir_fields.push(self.lower_field(f))
                HirVariantKind.Struct(hir_fields)

        HirVariant(
            symbol: symbol,
            name: v.name,
            kind: kind,
            span: v.span
        )

    me lower_trait(trait_: Trait) -> HirTrait:
        """Lower trait to HIR."""
        val symbol = self.symbols.lookup(trait_.name).unwrap()

        self.symbols.push_scope(ScopeKind.Class)

        var type_params: [HirTypeParam] = []
        for tp in trait_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var methods: [HirFunction] = []
        for m in trait_.methods:
            methods = methods.push(self.lower_function(m))

        self.symbols.pop_scope()

        HirTrait(
            symbol: symbol,
            name: trait_.name,
            type_params: type_params,
            methods: methods,
            is_public: trait_.is_public,
            doc_comment: trait_.doc_comment,
            span: trait_.span
        )

    me lower_impl(impl_: Impl) -> HirImpl:
        """Lower impl block to HIR."""
        self.symbols.push_scope(ScopeKind.Impl)

        val type_ = self.lower_type(impl_.type_)
        val trait_ = impl_.trait_.map(\t: self.lower_type(t))

        var methods: Dict<text, SymbolId> = {}
        for name in impl_.methods.keys():
            val fn_ = impl_.methods[name]
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        self.symbols.pop_scope()

        HirImpl(
            type_: type_,
            trait_: trait_,
            methods: methods,
            span: impl_.span
        )

    me lower_const(const_: Const) -> HirConst:
        """Lower constant to HIR."""
        val symbol = self.symbols.lookup(const_.name).unwrap()
        val type_ = const_.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: const_.span)
        val value = self.lower_expr(const_.value)

        HirConst(
            symbol: symbol,
            name: const_.name,
            type_: type_,
            value: value,
            is_mutable: const_.is_mutable,
            is_public: const_.is_public,
            span: const_.span
        )

    # ========================================================================
    # Expression Lowering
    # ========================================================================

    me lower_expr(e: Expr) -> HirExpr:
        """Lower expression to HIR."""
        val kind = match e.kind:
            case IntLit(value):
                HirExprKind.IntLit(value, nil)

            case FloatLit(value):
                HirExprKind.FloatLit(value, nil)

            case StringLit(value, interps):
                var hir_interps: [HirInterpolation]? = None
                if interps.?:
                    var list: [HirInterpolation] = []
                    for i in interps.unwrap():
                        list = list.push(HirInterpolation(
                            expr: self.lower_expr(i.expr),
                            format: i.format,
                            span: i.span
                        ))
                    hir_interps = Some(list)
                HirExprKind.StringLit(value, hir_interps)

            case BoolLit(value):
                HirExprKind.BoolLit(value)

            case NilLit:
                HirExprKind.NilLit

            case ArrayLit(elements):
                var hir_elements: [HirExpr] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_expr(elem))
                HirExprKind.ArrayLit(hir_elements, nil)

            case TupleLit(elements):
                var hir_elements: [HirExpr] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_expr(elem))
                HirExprKind.TupleLit(hir_elements)

            case DictLit(entries):
                var hir_entries: [(HirExpr, HirExpr)] = []
                for entry in entries:
                    hir_entries = hir_entries.push((
                        self.lower_expr(entry.0),
                        self.lower_expr(entry.1)
                    ))
                HirExprKind.DictLit(hir_entries, nil, nil)

            case Ident(name):
                val symbol = self.symbols.lookup(name)
                if symbol.?:
                    HirExprKind.Var(symbol.unwrap())
                else:
                    self.error("unresolved name: {name}", e.span)
                    HirExprKind.Error

            case Field(base, field):
                HirExprKind.Field(self.lower_expr(base), field, nil)

            case Index(base, index):
                HirExprKind.Index(self.lower_expr(base), self.lower_expr(index))

            case OptionalChain(base, field):
                HirExprKind.OptionalChain(self.lower_expr(base), field)

            case NullCoalesce(left, right):
                HirExprKind.NullCoalesce(self.lower_expr(left), self.lower_expr(right))

            case ExistsCheck(base):
                HirExprKind.ExistsCheck(self.lower_expr(base))

            case Binary(op, left, right):
                val hir_op = self.lower_binop(op)
                HirExprKind.Binary(hir_op, self.lower_expr(left), self.lower_expr(right))

            case Unary(op, operand):
                val hir_op = self.lower_unaryop(op)
                HirExprKind.Unary(hir_op, self.lower_expr(operand))

            case Call(callee, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                HirExprKind.Call(self.lower_expr(callee), hir_args, [])

            case MethodCall(receiver, method, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                HirExprKind.MethodCall(self.lower_expr(receiver), method, hir_args, MethodResolution.Unresolved)

            case If(cond, then_, else_):
                HirExprKind.If(
                    self.lower_expr(cond),
                    self.lower_block(then_),
                    else_.map(\b: self.lower_block(b))
                )

            case Match(scrutinee, arms):
                var hir_arms: [HirMatchArm] = []
                for arm in arms:
                    hir_arms = hir_arms.push(HirMatchArm(
                        pattern: self.lower_pattern(arm.pattern),
                        guard: arm.guard.map(\g: self.lower_expr(g)),
                        body: self.lower_block(arm.body),
                        span: arm.span
                    ))
                HirExprKind.Match(self.lower_expr(scrutinee), hir_arms)

            case Lambda(params, body):
                self.symbols.push_scope(ScopeKind.Function)
                var hir_params: [HirParam] = []
                for p in params:
                    val type_ = p.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: p.span)
                    val symbol = self.symbols.define(p.name, SymbolKind.Parameter, Some(type_), p.span, false, false)
                    hir_params = hir_params.push(HirParam(
                        symbol: symbol,
                        name: p.name,
                        type_: type_,
                        default: nil,
                        span: p.span
                    ))
                val hir_body = self.lower_expr(body)
                self.symbols.pop_scope()
                HirExprKind.Lambda(hir_params, hir_body, [])

            case Block(block):
                HirExprKind.Block(self.lower_block(block))

            case Return(value):
                HirExprKind.Return(value.map(\v: self.lower_expr(v)))

            case Break(label):
                HirExprKind.Break(label, nil)

            case Continue(label):
                HirExprKind.Continue(label)

            case Yield(value):
                HirExprKind.Yield(value.map(\v: self.lower_expr(v)))

            case Throw(value):
                HirExprKind.Throw(self.lower_expr(value))

            case Await(expr):
                HirExprKind.Await(self.lower_expr(expr))

            case Try(expr):
                HirExprKind.Try(self.lower_expr(expr))

            case Range(start, end, inclusive, step):
                HirExprKind.Range(
                    start.map(\s: self.lower_expr(s)),
                    end.map(\e: self.lower_expr(e)),
                    inclusive,
                    step.map(\s: self.lower_expr(s))
                )

            case ListComprehension(expr, clauses):
                var hir_clauses: [HirCompClause] = []
                for clause in clauses:
                    val hir_kind = match clause.kind:
                        case For(var_, iter):
                            val symbol = self.symbols.define(var_, SymbolKind.Variable, nil, clause.span, false, false)
                            HirCompClauseKind.For(symbol, self.lower_expr(iter))
                        case If(cond):
                            HirCompClauseKind.If(self.lower_expr(cond))
                    hir_clauses = hir_clauses.push(HirCompClause(kind: hir_kind, span: clause.span))
                HirExprKind.Comprehension(HirComprehensionKind.List, self.lower_expr(expr), hir_clauses)

            case StructLit(type_, fields):
                var hir_fields: [(text, HirExpr)] = []
                for field in fields:
                    hir_fields = hir_fields.push((field.0, self.lower_expr(field.1)))
                val symbol = self.symbols.lookup(type_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                HirExprKind.StructLit(hir_type, hir_fields)

            case EnumLit(enum_, variant, payload):
                val symbol = self.symbols.lookup(enum_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                val hir_payload = payload.map(\p: match p:
                    case Tuple(values):
                        var hir_values: [HirExpr] = []
                        for v in values:
                            hir_values = hir_values.push(self.lower_expr(v))
                        HirEnumPayload.Tuple(hir_values)
                    case Struct(fields):
                        var hir_fields: [(text, HirExpr)] = []
                        for f in fields:
                            hir_fields = hir_fields.push((f.0, self.lower_expr(f.1)))
                        HirEnumPayload.Struct(hir_fields)
                )
                HirExprKind.EnumLit(hir_type, variant, hir_payload)

            # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
            case CustomBlock(kind, value):
                HirExprKind.CustomBlock(kind, value)

            # Math/DL blocks with special semantics
            case LossBlock(body):
                HirExprKind.LossBlock(self.lower_block(body))

            case NogradBlock(body):
                HirExprKind.NogradBlock(self.lower_block(body))

            case Error:
                HirExprKind.Error

            case _:
                self.error("unsupported expression kind", e.span)
                HirExprKind.Error

        HirExpr(kind: kind, type_: nil, span: e.span)

    me lower_binop(op: BinOp) -> HirBinOp:
        """Lower binary operator."""
        match op:
            case Add: HirBinOp.Add
            case Sub: HirBinOp.Sub
            case Mul: HirBinOp.Mul
            case Div: HirBinOp.Div
            case Mod: HirBinOp.Mod
            case Pow: HirBinOp.Pow
            case MatMul: HirBinOp.MatMul
            case Eq: HirBinOp.Eq
            case NotEq: HirBinOp.NotEq
            case Lt: HirBinOp.Lt
            case LtEq: HirBinOp.LtEq
            case Gt: HirBinOp.Gt
            case GtEq: HirBinOp.GtEq
            case And: HirBinOp.And
            case Or: HirBinOp.Or
            case BitAnd: HirBinOp.BitAnd
            case BitOr: HirBinOp.BitOr
            case BitXor: HirBinOp.BitXor
            case Shl: HirBinOp.Shl
            case Shr: HirBinOp.Shr
            case BroadcastAdd: HirBinOp.BroadcastAdd
            case BroadcastSub: HirBinOp.BroadcastSub
            case BroadcastMul: HirBinOp.BroadcastMul
            case BroadcastDiv: HirBinOp.BroadcastDiv
            case BroadcastPow: HirBinOp.BroadcastPow
            case PipeForward: HirBinOp.PipeForward
            case Compose: HirBinOp.Compose
            case ComposeBack: HirBinOp.ComposeBack
            case Parallel: HirBinOp.Parallel
            case LayerConnect: HirBinOp.LayerConnect
            case In: HirBinOp.In
            case NotIn: HirBinOp.NotIn
            case Is: HirBinOp.Is
            case IsNot: HirBinOp.IsNot

    me lower_unaryop(op: UnaryOp) -> HirUnaryOp:
        """Lower unary operator."""
        match op:
            case Neg: HirUnaryOp.Neg
            case Not: HirUnaryOp.Not
            case BitNot: HirUnaryOp.BitNot
            case Ref: HirUnaryOp.Ref
            case Deref: HirUnaryOp.Deref
            case Transpose: HirUnaryOp.Transpose

    me lower_pattern(p: Pattern) -> HirPattern:
        """Lower pattern to HIR."""
        val kind = match p.kind:
            case Wildcard:
                HirPatternKind.Wildcard

            case Literal(value):
                HirPatternKind.Literal(self.lower_expr(value))

            case Binding(name, mutable):
                val symbol = self.symbols.define(name, SymbolKind.Variable, nil, p.span, false, mutable)
                HirPatternKind.Binding(symbol, mutable)

            case Tuple(elements):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_pattern(elem))
                HirPatternKind.Tuple(hir_elements)

            case Array(elements, rest):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_pattern(elem))
                var rest_symbol: SymbolId? = None
                if rest.?:
                    rest_symbol = Some(self.symbols.define(rest.unwrap(), SymbolKind.Variable, nil, p.span, false, false))
                HirPatternKind.Array(hir_elements, rest_symbol)

            case Struct(type_, fields):
                val symbol = self.symbols.lookup(type_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                var hir_fields: [(text, HirPattern)] = []
                for field in fields:
                    hir_fields = hir_fields.push((field.0, self.lower_pattern(field.1)))
                HirPatternKind.Struct(hir_type, hir_fields)

            case Enum(enum_, variant, payload):
                val symbol = self.symbols.lookup(enum_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                val hir_payload = payload.map(\pl: match pl:
                    case Tuple(patterns):
                        var hir_patterns: [HirPattern] = []
                        for pat in patterns:
                            hir_patterns = hir_patterns.push(self.lower_pattern(pat))
                        HirPatternPayload.Tuple(hir_patterns)
                    case Struct(fields):
                        var hir_fields: [(text, HirPattern)] = []
                        for f in fields:
                            hir_fields = hir_fields.push((f.0, self.lower_pattern(f.1)))
                        HirPatternPayload.Struct(hir_fields)
                )
                HirPatternKind.Enum(hir_type, variant, hir_payload)

            case Or(patterns):
                var hir_patterns: [HirPattern] = []
                for pat in patterns:
                    hir_patterns = hir_patterns.push(self.lower_pattern(pat))
                HirPatternKind.Or(hir_patterns)

            case Range(start, end, inclusive):
                HirPatternKind.Range(
                    start.map(\s: self.lower_expr(s)),
                    end.map(\e: self.lower_expr(e)),
                    inclusive
                )

            case Error:
                HirPatternKind.Error

            case _:
                self.error("unsupported pattern kind", p.span)
                HirPatternKind.Error

        HirPattern(kind: kind, type_: nil, span: p.span)

    me lower_block(b: Block) -> HirBlock:
        """Lower block to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        # where chained method calls corrupt 'self'
        var symbols_table = self.symbols
        symbols_table.push_scope(ScopeKind.Block)
        self.symbols = symbols_table

        var stmts: [HirStmt] = []
        for s in b.stmts:
            stmts = stmts.push(self.lower_stmt(s))

        symbols_table = self.symbols
        symbols_table.pop_scope()
        self.symbols = symbols_table

        # Check if last statement is an expression (for block value)
        var value: HirExpr? = None
        if stmts.len() > 0:
            val last = stmts[stmts.len() - 1]
            match last.kind:
                case Expr(expr):
                    value = Some(expr)
                    stmts = stmts[0:stmts.len() - 1]  # Remove last stmt
                case _:
                    pass

        HirBlock(stmts: stmts, value: value, span: b.span)

    me lower_stmt(s: Stmt) -> HirStmt:
        """Lower statement to HIR."""
        # Workaround: Capture self reference to ensure it's available in match arms
        val lowerer = self
        val kind = match s.kind:
            case StmtKind.Expr(expr):
                HirStmtKind.Expr(self.lower_expr(expr))

            case StmtKind.Val(name, type_, init):
                val hir_type = type_.map(\t: self.lower_type(t))
                val hir_init = self.lower_expr(init)
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                val symbol = symbols_table.define(name, SymbolKind.Variable, hir_type, s.span, false, false)
                self.symbols = symbols_table
                HirStmtKind.Let(symbol, hir_type, hir_init)

            case StmtKind.Var(name, type_, init):
                val hir_type = type_.map(\t: self.lower_type(t))
                val hir_init = init.map(\i: self.lower_expr(i)) ?? HirExpr(kind: HirExprKind.NilLit, type_: nil, span: s.span)
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                val symbol = symbols_table.define(name, SymbolKind.Variable, hir_type, s.span, false, true)
                self.symbols = symbols_table
                HirStmtKind.Let(symbol, hir_type, hir_init)

            case StmtKind.Assign(target, op, value):
                val hir_op = op.map(\o: match o:
                    case AssignOp.Add: HirAssignOp.Add
                    case AssignOp.Sub: HirAssignOp.Sub
                    case AssignOp.Mul: HirAssignOp.Mul
                    case AssignOp.Div: HirAssignOp.Div
                    case AssignOp.Mod: HirAssignOp.Mod
                )
                HirStmtKind.Assign(self.lower_expr(target), hir_op, self.lower_expr(value))

            case StmtKind.For(var_, iter, body):
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                symbols_table.push_scope(ScopeKind.Loop)
                self.symbols = symbols_table
                self.loop_depth = self.loop_depth + 1
                symbols_table = self.symbols
                val symbol = symbols_table.define(var_, SymbolKind.Variable, nil, s.span, false, false)
                self.symbols = symbols_table
                val hir_iter = self.lower_expr(iter)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                symbols_table = self.symbols
                symbols_table.pop_scope()
                self.symbols = symbols_table
                # Desugar to loop
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.For(symbol, hir_iter, hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.While(cond, body):
                self.loop_depth = self.loop_depth + 1
                val hir_cond = self.lower_expr(cond)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.While(hir_cond, hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Loop(body):
                self.loop_depth = self.loop_depth + 1
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Loop(hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Return(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Return(value.map(\v: self.lower_expr(v))),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Break(label):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Break(label, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Continue(label):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Continue(label),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Yield(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Yield(value.map(\v: self.lower_expr(v))),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Throw(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Throw(self.lower_expr(value)),
                    type_: nil,
                    span: s.span
                ))

            case _:
                # Fallback for unhandled statement kinds
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.NilLit,
                    type_: nil,
                    span: s.span
                ))

        HirStmt(kind: kind, span: s.span)

    me error(message: text, span: Span):
        """Record a lowering error."""
        self.errors = self.errors.push(LoweringError(
            message: message,
            span: span,
            kind: LoweringErrorKind.Other
        ))

# ============================================================================
# Exports
# ============================================================================

export HirModule, HirImport, HirImportItem
export SymbolId, Symbol, SymbolKind, ScopeId, Scope, ScopeKind, SymbolTable
export HirType, HirTypeKind, Effect, EffectKind
export DimExpr, DimExprKind, DeviceType, LayerType, ParamShape
export HirFunction, HirTypeParam, HirParam
export HirClass, HirStruct, HirField, HirEnum, HirVariant, HirVariantKind
export HirTrait, HirImpl, HirConst
export HirExpr, HirExprKind, HirInterpolation, HirCallArg, HirMatchArm
export HirEnumPayload, HirComprehensionKind, HirCompClause, HirCompClauseKind
export HirBinOp, HirUnaryOp
export HirPattern, HirPatternKind, HirPatternPayload
export HirStmt, HirStmtKind, HirAssignOp, HirBlock
export HirLowering, LoweringError, LoweringErrorKind
