# HIR Lowering - AST to HIR Transformation
#
# This module handles lowering from AST (Abstract Syntax Tree) to HIR.
# It converts:
# - Name resolution (identifiers -> symbols)
# - Type annotations
# - Desugaring (comprehensions, operators, control flow)

use hir_types.*
use hir_definitions.*
use parser.*
use lexer.Span
use blocks.{BlockValue, BlockRegistry, block_registry}
use config.{TypeInferenceConfig, TypeDefault}

# AST to HIR Lowering
# ============================================================================

class HirLowering:
    """Lowers AST to HIR."""
    symbols: SymbolTable
    errors: [LoweringError]
    current_function: SymbolId?
    loop_depth: i64
    type_inference_config: TypeInferenceConfig?

struct LoweringError:
    """Error during lowering."""
    message: text
    span: Span
    kind: LoweringErrorKind

"""Lowering error kind."""
enum LoweringErrorKind:
    UnresolvedName
    DuplicateDefinition
    TypeMismatch
    InvalidPattern
    InvalidExpression
    Other

impl HirLowering:
    static fn new() -> HirLowering:
        HirLowering(
            symbols: SymbolTable.new(),
            errors: [],
            current_function: nil,
            loop_depth: 0,
            type_inference_config: nil
        )

    static fn with_config(config: TypeInferenceConfig) -> HirLowering:
        HirLowering(
            symbols: SymbolTable.new(),
            errors: [],
            current_function: nil,
            loop_depth: 0,
            type_inference_config: Some(config)
        )

    me set_type_inference_config(config: TypeInferenceConfig):
        """Set the type inference configuration."""
        self.type_inference_config = Some(config)

    fn get_empty_array_default() -> HirType:
        """Get the default element type for empty arrays."""
        val default_type = if self.type_inference_config.?:
            self.type_inference_config.unwrap().empty_array_default
        else:
            TypeDefault.I32

        # Convert TypeDefault to HirType
        val span = Span.empty()
        match default_type:
            case TypeDefault.Void: HirType(kind: HirTypeKind.Unit, span: span)
            case TypeDefault.Bool: HirType(kind: HirTypeKind.Bool, span: span)
            case TypeDefault.I8: HirType(kind: HirTypeKind.Int(8, true), span: span)
            case TypeDefault.I16: HirType(kind: HirTypeKind.Int(16, true), span: span)
            case TypeDefault.I32: HirType(kind: HirTypeKind.Int(32, true), span: span)
            case TypeDefault.I64: HirType(kind: HirTypeKind.Int(64, true), span: span)
            case TypeDefault.U8: HirType(kind: HirTypeKind.Int(8, false), span: span)
            case TypeDefault.U16: HirType(kind: HirTypeKind.Int(16, false), span: span)
            case TypeDefault.U32: HirType(kind: HirTypeKind.Int(32, false), span: span)
            case TypeDefault.U64: HirType(kind: HirTypeKind.Int(64, false), span: span)
            case TypeDefault.F32: HirType(kind: HirTypeKind.Float(32), span: span)
            case TypeDefault.F64: HirType(kind: HirTypeKind.Float(64), span: span)
            case TypeDefault.String: HirType(kind: HirTypeKind.Str, span: span)
            case TypeDefault.Nil: HirType(kind: HirTypeKind.Unit, span: span)
            case TypeDefault.Any: HirType(kind: HirTypeKind.Error, span: span)  # Any not yet represented
            case _: HirType(kind: HirTypeKind.Int(32, true), span: span)  # Default to i32

    fn is_strict_empty_collections() -> bool:
        """Check if strict mode is enabled for empty collections."""
        if self.type_inference_config.?:
            self.type_inference_config.unwrap().strict_empty_collections
        else:
            false

    me lower_module(module: Module) -> HirModule:
        """Lower a parsed module to HIR."""
        # First pass: declare all top-level symbols
        self.declare_module_symbols(module)

        # Second pass: lower definitions
        var functions: Dict<SymbolId, HirFunction> = {}
        var classes: Dict<SymbolId, HirClass> = {}
        var structs: Dict<SymbolId, HirStruct> = {}
        var enums: Dict<SymbolId, HirEnum> = {}
        var traits: Dict<SymbolId, HirTrait> = {}
        var impls: [HirImpl] = []
        var constants: Dict<SymbolId, HirConst> = {}

        for name in module.functions.keys():
            val fn_ = module.functions[name]
            val hir_fn = self.lower_function(fn_)
            functions[hir_fn.symbol] = hir_fn

        for name in module.classes.keys():
            val class_ = module.classes[name]
            val hir_class = self.lower_class(class_)
            classes[hir_class.symbol] = hir_class

        for name in module.structs.keys():
            val struct_ = module.structs[name]
            val hir_struct = self.lower_struct(struct_)
            structs[hir_struct.symbol] = hir_struct

        for name in module.enums.keys():
            val enum_ = module.enums[name]
            val hir_enum = self.lower_enum(enum_)
            enums[hir_enum.symbol] = hir_enum

        for name in module.traits.keys():
            val trait_ = module.traits[name]
            val hir_trait = self.lower_trait(trait_)
            traits[hir_trait.symbol] = hir_trait

        for impl_ in module.impls:
            impls = impls.push(self.lower_impl(impl_))

        for name in module.constants.keys():
            val const_ = module.constants[name]
            val hir_const = self.lower_const(const_)
            constants[hir_const.symbol] = hir_const

        # Lower imports
        var imports: [HirImport] = []
        for imp in module.imports:
            imports = imports.push(self.lower_import(imp))

        # Collect exports
        var exports: [text] = []
        for exp in module.exports:
            for item in exp.items:
                exports = exports.push(item)

        HirModule(
            name: module.name,
            path: "",
            imports: imports,
            exports: exports,
            symbols: self.symbols,
            functions: functions,
            classes: classes,
            structs: structs,
            enums: enums,
            traits: traits,
            impls: impls,
            constants: constants
        )

    me declare_module_symbols(module: Module):
        """Declare all top-level symbols."""
        # Workaround: Store symbols table in local var to avoid interpreter bug
        var symbols_table = self.symbols

        for name in module.functions.keys():
            val fn_ = module.functions[name]
            symbols_table.define(name, SymbolKind.Function, nil, fn_.span, fn_.is_public, false)

        for name in module.classes.keys():
            val class_ = module.classes[name]
            symbols_table.define(name, SymbolKind.Class, nil, class_.span, class_.is_public, false)

        for name in module.structs.keys():
            val struct_ = module.structs[name]
            symbols_table.define(name, SymbolKind.Struct, nil, struct_.span, struct_.is_public, false)

        for name in module.enums.keys():
            val enum_ = module.enums[name]
            symbols_table.define(name, SymbolKind.Enum, nil, enum_.span, enum_.is_public, false)

        for name in module.traits.keys():
            val trait_ = module.traits[name]
            symbols_table.define(name, SymbolKind.Trait, nil, trait_.span, trait_.is_public, false)

        for name in module.constants.keys():
            val const_ = module.constants[name]
            symbols_table.define(name, SymbolKind.Const, nil, const_.span, const_.is_public, const_.is_mutable)

        # Declare impl methods
        for impl_ in module.impls:
            for name in impl_.methods.keys():
                val fn_ = impl_.methods[name]
                symbols_table.define(name, SymbolKind.Method, nil, fn_.span, fn_.is_public, false)

        self.symbols = symbols_table

    me lower_import(imp: Import) -> HirImport:
        """Lower import declaration."""
        var items: [HirImportItem] = []
        for item in imp.items:
            items = items.push(HirImportItem(
                name: item.name,
                alias: item.alias,
                resolved: nil
            ))

        HirImport(
            module_path: imp.module,
            items: items,
            span: imp.span
        )

    me lower_function(fn_: Function) -> HirFunction:
        """Lower function to HIR."""
        # Workaround: Store symbols in local var first to avoid interpreter bug
        # where chained method calls corrupt 'self'
        var symbols_table = self.symbols
        val fn_symbol_id = symbols_table.lookup(fn_.name).unwrap()

        # Workaround: Create the Some value separately to avoid interpreter bug
        val opt_fn_id: SymbolId? = Some(fn_symbol_id)
        self.current_function = opt_fn_id

        # Re-get symbols from self after field modification
        symbols_table = self.symbols
        symbols_table.push_scope(ScopeKind.Function)
        self.symbols = symbols_table

        # Lower type parameters
        var type_params: [HirTypeParam] = []
        for tp in fn_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        # Lower parameters
        var params: [HirParam] = []
        for p in fn_.params:
            params = params.push(self.lower_param(p))

        # Lower return type â€” use explicit check instead of .map() ?? default
        # to avoid crash with null coalescing on Option.map result
        var return_type = HirType(kind: HirTypeKind.Unit, span: fn_.span)
        if fn_.return_type.?:
            val mapped = fn_.return_type.map(\t: self.lower_type(t))
            if mapped.?:
                return_type = mapped.unwrap()

        # Lower body
        val body = self.lower_block(fn_.body)

        # Workaround: Store symbols in local var to avoid interpreter bug
        symbols_table = self.symbols
        symbols_table.pop_scope()
        self.symbols = symbols_table
        self.current_function = None

        HirFunction(
            symbol: fn_symbol_id,
            name: fn_.name,
            type_params: type_params,
            params: params,
            return_type: return_type,
            body: body,
            effects: [],
            is_async: fn_.is_async,
            is_static: fn_.is_static,
            is_public: fn_.is_public,
            is_method: fn_.is_method,
            is_mutable: fn_.is_mutable,
            doc_comment: fn_.doc_comment,
            span: fn_.span
        )

    me lower_type_param(tp: TypeParam) -> HirTypeParam:
        """Lower type parameter."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.define(tp.name, SymbolKind.TypeParam, nil, tp.span, false, false)
        self.symbols = symbols_table

        var bounds: [HirType] = []
        for b in tp.bounds:
            bounds = bounds.push(self.lower_type(b))

        HirTypeParam(
            symbol: symbol,
            name: tp.name,
            bounds: bounds,
            default: tp.default.map(\t: self.lower_type(t)),
            span: tp.span
        )

    me lower_param(p: Param) -> HirParam:
        """Lower function parameter."""
        val type_ = p.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: p.span)
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.define(p.name, SymbolKind.Parameter, Some(type_), p.span, false, false)
        self.symbols = symbols_table

        HirParam(
            symbol: symbol,
            name: p.name,
            type_: type_,
            default: p.default.map(\e: self.lower_expr(e)),
            span: p.span
        )

    me lower_type_list(types: [Type]) -> [HirType]:
        """Lower a list of types to HIR."""
        var result: [HirType] = []
        for t in types:
            result = result.push(self.lower_type(t))
        result

    me lower_expr_list(exprs: [Expr]) -> [HirExpr]:
        """Lower a list of expressions to HIR."""
        var result: [HirExpr] = []
        for e in exprs:
            result = result.push(self.lower_expr(e))
        result

    me lower_interpolation_list(interps: [Interpolation]) -> [HirInterpolation]:
        """Lower a list of interpolations to HIR."""
        var result: [HirInterpolation] = []
        for i in interps:
            result = result.push(HirInterpolation(
                expr: self.lower_expr(i.expr),
                format: i.format,
                span: i.span
            ))
        result

    me lower_dict_entry(entry: (Expr, Expr)) -> (HirExpr, HirExpr):
        """Lower a single dict entry to HIR."""
        val (key, value) = entry
        (self.lower_expr(key), self.lower_expr(value))

    me lower_dict_entries(entries: [(Expr, Expr)]) -> [(HirExpr, HirExpr)]:
        """Lower dict entries to HIR."""
        var result: [(HirExpr, HirExpr)] = []
        for entry in entries:
            result = result.push(self.lower_dict_entry(entry))
        result

    me lower_struct_field(field: (text, Expr)) -> (text, HirExpr):
        """Lower a single struct field to HIR."""
        val (name, value) = field
        (name, self.lower_expr(value))

    me lower_struct_fields(fields: [(text, Expr)]) -> [(text, HirExpr)]:
        """Lower struct fields to HIR."""
        var result: [(text, HirExpr)] = []
        for field in fields:
            result = result.push(self.lower_struct_field(field))
        result

    me lower_type(t: Type) -> HirType:
        """Lower type expression."""
        val kind = match t.kind:
            case Named(name, args):
                val hir_args = self.lower_type_list(args)

                # Check for builtin types
                match name:
                    case "i8": HirTypeKind.Int(8, true)
                    case "i16": HirTypeKind.Int(16, true)
                    case "i32": HirTypeKind.Int(32, true)
                    case "i64": HirTypeKind.Int(64, true)
                    case "u8": HirTypeKind.Int(8, false)
                    case "u16": HirTypeKind.Int(16, false)
                    case "u32": HirTypeKind.Int(32, false)
                    case "u64": HirTypeKind.Int(64, false)
                    case "f32": HirTypeKind.Float(32)
                    case "f64": HirTypeKind.Float(64)
                    case "bool": HirTypeKind.Bool
                    case "char": HirTypeKind.Char
                    case "text" | "str" | "String": HirTypeKind.Str
                    case _:
                        val symbol = self.symbols.lookup(name)
                        if symbol.?:
                            HirTypeKind.Named(symbol.unwrap(), hir_args)
                        else:
                            self.error("unresolved type: {name}", t.span)
                            HirTypeKind.Error

            case Tuple(elements):
                if elements.is_empty():
                    HirTypeKind.Unit
                else:
                    HirTypeKind.Tuple(self.lower_type_list(elements))

            case Array(element, size):
                val hir_element = self.lower_type(element)
                HirTypeKind.Array(hir_element, nil)

            case Function(params, ret):
                val hir_params = self.lower_type_list(params)
                val hir_ret = self.lower_type(ret)
                HirTypeKind.Function(hir_params, hir_ret, [])

            case Optional(inner):
                HirTypeKind.Optional(self.lower_type(inner))

            case Reference(inner, mutable):
                HirTypeKind.Ref(self.lower_type(inner), mutable)

            case Infer:
                HirTypeKind.Infer(0, 0)

            case Error:
                HirTypeKind.Error

        HirType(kind: kind, span: t.span)

    me lower_class(class_: Class) -> HirClass:
        """Lower class to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.lookup(class_.name).unwrap()

        symbols_table.push_scope(ScopeKind.Class)
        self.symbols = symbols_table

        var type_params: [HirTypeParam] = []
        for tp in class_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in class_.fields:
            fields = fields.push(self.lower_field(f))

        var methods: Dict<text, SymbolId> = {}
        for name in class_.methods.keys():
            val fn_ = class_.methods[name]
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        symbols_table = self.symbols
        symbols_table.pop_scope()
        self.symbols = symbols_table

        HirClass(
            symbol: symbol,
            name: class_.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: class_.is_public,
            doc_comment: class_.doc_comment,
            span: class_.span,
            is_generic_template: false,
            specialization_of: nil,
            type_bindings: {}
        )

    me lower_struct(struct_: Struct) -> HirStruct:
        """Lower struct to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.lookup(struct_.name).unwrap()
        self.symbols = symbols_table

        var type_params: [HirTypeParam] = []
        for tp in struct_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in struct_.fields:
            fields = fields.push(self.lower_field(f))

        HirStruct(
            symbol: symbol,
            name: struct_.name,
            type_params: type_params,
            fields: fields,
            is_public: struct_.is_public,
            doc_comment: struct_.doc_comment,
            span: struct_.span,
            is_generic_template: false,
            specialization_of: nil,
            type_bindings: {}
        )

    me lower_field(f: Field) -> HirField:
        """Lower field to HIR."""
        val type_ = self.lower_type(f.type_)
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table.define(f.name, SymbolKind.Field, Some(type_), f.span, f.is_public, false)
        self.symbols = symbols_table

        HirField(
            symbol: symbol,
            name: f.name,
            type_: type_,
            default: f.default.map(\e: self.lower_expr(e)),
            is_public: f.is_public,
            span: f.span
        )

    me lower_enum(enum_: Enum) -> HirEnum:
        """Lower enum to HIR."""
        val symbol = self.symbols.lookup(enum_.name).unwrap()

        var type_params: [HirTypeParam] = []
        for tp in enum_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var variants: [HirVariant] = []
        for v in enum_.variants:
            variants = variants.push(self.lower_variant(v))

        HirEnum(
            symbol: symbol,
            name: enum_.name,
            type_params: type_params,
            variants: variants,
            is_public: enum_.is_public,
            doc_comment: enum_.doc_comment,
            span: enum_.span,
            is_generic_template: false,
            specialization_of: nil,
            type_bindings: {}
        )

    me lower_variant(v: Variant) -> HirVariant:
        """Lower enum variant."""
        val symbol = self.symbols.define(v.name, SymbolKind.EnumVariant, nil, v.span, true, false)

        val kind = match v.kind:
            case Unit:
                HirVariantKind.Unit
            case Tuple(types):
                var hir_types: [HirType] = []
                for t in types:
                    hir_types = hir_types.push(self.lower_type(t))
                HirVariantKind.Tuple(hir_types)
            case Struct(fields):
                var hir_fields: [HirField] = []
                for f in fields:
                    hir_fields = hir_fields.push(self.lower_field(f))
                HirVariantKind.Struct(hir_fields)

        HirVariant(
            symbol: symbol,
            name: v.name,
            kind: kind,
            span: v.span
        )

    me lower_trait(trait_: Trait) -> HirTrait:
        """Lower trait to HIR."""
        val symbol = self.symbols.lookup(trait_.name).unwrap()

        self.symbols.push_scope(ScopeKind.Class)

        var type_params: [HirTypeParam] = []
        for tp in trait_.type_params:
            type_params = type_params.push(self.lower_type_param(tp))

        var methods: [HirFunction] = []
        for m in trait_.methods:
            methods = methods.push(self.lower_function(m))

        self.symbols.pop_scope()

        HirTrait(
            symbol: symbol,
            name: trait_.name,
            type_params: type_params,
            methods: methods,
            is_public: trait_.is_public,
            doc_comment: trait_.doc_comment,
            span: trait_.span,
            is_generic_template: false,
            specialization_of: nil,
            type_bindings: {}
        )

    me lower_impl(impl_: Impl) -> HirImpl:
        """Lower impl block to HIR."""
        self.symbols.push_scope(ScopeKind.Impl)

        val type_ = self.lower_type(impl_.type_)
        val trait_ = impl_.trait_.map(\t: self.lower_type(t))

        var methods: Dict<text, SymbolId> = {}
        for name in impl_.methods.keys():
            val fn_ = impl_.methods[name]
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        self.symbols.pop_scope()

        HirImpl(
            type_: type_,
            trait_: trait_,
            methods: methods,
            span: impl_.span
        )

    me lower_const(const_: Const) -> HirConst:
        """Lower constant to HIR."""
        val symbol = self.symbols.lookup(const_.name).unwrap()
        val type_ = const_.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: const_.span)
        val value = self.lower_expr(const_.value)

        HirConst(
            symbol: symbol,
            name: const_.name,
            type_: type_,
            value: value,
            is_mutable: const_.is_mutable,
            is_public: const_.is_public,
            span: const_.span
        )

    # ========================================================================
    # Expression Lowering
    # ========================================================================

    me lower_expr(e: Expr) -> HirExpr:
        """Lower expression to HIR."""
        val kind = match e.kind:
            case IntLit(value):
                HirExprKind.IntLit(value, nil)

            case FloatLit(value):
                HirExprKind.FloatLit(value, nil)

            case StringLit(value, interps):
                val hir_interps = interps.map(\i: self.lower_interpolation_list(i))
                HirExprKind.StringLit(value, hir_interps)

            case BoolLit(value):
                HirExprKind.BoolLit(value)

            case NilLit:
                HirExprKind.NilLit

            case ArrayLit(elements):
                val hir_elements = self.lower_expr_list(elements)
                # For empty arrays, use configured default element type
                val elem_type = if hir_elements.is_empty():
                    if self.is_strict_empty_collections():
                        self.error("empty array requires explicit type annotation", e.span)
                        nil
                    else:
                        Some(self.get_empty_array_default())
                else:
                    nil  # Type will be inferred from elements
                HirExprKind.ArrayLit(hir_elements, elem_type)

            case TupleLit(elements):
                HirExprKind.TupleLit(self.lower_expr_list(elements))

            case DictLit(entries):
                HirExprKind.DictLit(self.lower_dict_entries(entries), nil, nil)

            case Ident(name):
                val symbol = self.symbols.lookup(name)
                if symbol.?:
                    HirExprKind.Var(symbol.unwrap())
                else:
                    self.error("unresolved name: {name}", e.span)
                    HirExprKind.Error

            case Field(base, field):
                HirExprKind.Field(self.lower_expr(base), field, nil)

            case Index(base, index):
                HirExprKind.Index(self.lower_expr(base), self.lower_expr(index))

            case OptionalChain(base, field):
                HirExprKind.OptionalChain(self.lower_expr(base), field)

            case NullCoalesce(left, right):
                HirExprKind.NullCoalesce(self.lower_expr(left), self.lower_expr(right))

            case ExistsCheck(base):
                HirExprKind.ExistsCheck(self.lower_expr(base))

            case Binary(op, left, right):
                val hir_op = self.lower_binop(op)
                HirExprKind.Binary(hir_op, self.lower_expr(left), self.lower_expr(right))

            case Unary(op, operand):
                val hir_op = self.lower_unaryop(op)
                HirExprKind.Unary(hir_op, self.lower_expr(operand))

            case Call(callee, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                HirExprKind.Call(self.lower_expr(callee), hir_args, [])

            case MethodCall(receiver, method, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                HirExprKind.MethodCall(self.lower_expr(receiver), method, hir_args, MethodResolution.Unresolved)

            case If(cond, then_, else_):
                HirExprKind.If(
                    self.lower_expr(cond),
                    self.lower_block(then_),
                    else_.map(\b: self.lower_block(b))
                )

            case Match(scrutinee, arms):
                var hir_arms: [HirMatchArm] = []
                for arm in arms:
                    hir_arms = hir_arms.push(HirMatchArm(
                        pattern: self.lower_pattern(arm.pattern),
                        guard: arm.guard.map(\g: self.lower_expr(g)),
                        body: self.lower_block(arm.body),
                        span: arm.span
                    ))
                HirExprKind.Match(self.lower_expr(scrutinee), hir_arms)

            case Lambda(params, body):
                self.symbols.push_scope(ScopeKind.Function)
                var hir_params: [HirParam] = []
                for p in params:
                    val type_ = p.type_.map(\t: self.lower_type(t)) ?? HirType(kind: HirTypeKind.Infer(0, 0), span: p.span)
                    val symbol = self.symbols.define(p.name, SymbolKind.Parameter, Some(type_), p.span, false, false)
                    hir_params = hir_params.push(HirParam(
                        symbol: symbol,
                        name: p.name,
                        type_: type_,
                        default: nil,
                        span: p.span
                    ))
                val hir_body = self.lower_expr(body)
                self.symbols.pop_scope()
                HirExprKind.Lambda(hir_params, hir_body, [])

            case Block(block):
                HirExprKind.Block(self.lower_block(block))

            case Return(value):
                HirExprKind.Return(value.map(\v: self.lower_expr(v)))

            case Break(label):
                HirExprKind.Break(label, nil)

            case Continue(label):
                HirExprKind.Continue(label)

            case Yield(value):
                HirExprKind.Yield(value.map(\v: self.lower_expr(v)))

            case Throw(value):
                HirExprKind.Throw(self.lower_expr(value))

            case Await(expr):
                HirExprKind.Await(self.lower_expr(expr))

            case Try(expr):
                HirExprKind.Try(self.lower_expr(expr))

            case Range(start, end, inclusive, step):
                HirExprKind.Range(
                    start.map(\s: self.lower_expr(s)),
                    end.map(\e: self.lower_expr(e)),
                    inclusive,
                    step.map(\s: self.lower_expr(s))
                )

            case ListComprehension(expr, clauses):
                var hir_clauses: [HirCompClause] = []
                for clause in clauses:
                    val hir_kind = match clause.kind:
                        case For(var_, iter):
                            val symbol = self.symbols.define(var_, SymbolKind.Variable, nil, clause.span, false, false)
                            HirCompClauseKind.For(symbol, self.lower_expr(iter))
                        case If(cond):
                            HirCompClauseKind.If(self.lower_expr(cond))
                    hir_clauses = hir_clauses.push(HirCompClause(kind: hir_kind, span: clause.span))
                HirExprKind.Comprehension(HirComprehensionKind.List, self.lower_expr(expr), hir_clauses)

            case StructLit(type_, fields):
                var hir_fields: [(text, HirExpr)] = []
                for (name, value) in fields:
                    hir_fields = hir_fields.push((name, self.lower_expr(value)))
                val symbol = self.symbols.lookup(type_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                HirExprKind.StructLit(hir_type, hir_fields)

            case EnumLit(enum_, variant, payload):
                val symbol = self.symbols.lookup(enum_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                val hir_payload = payload.map(\p: match p:
                    case Tuple(values):
                        var hir_values: [HirExpr] = []
                        for v in values:
                            hir_values = hir_values.push(self.lower_expr(v))
                        HirEnumPayload.Tuple(hir_values)
                    case Struct(fields):
                        var hir_fields: [(text, HirExpr)] = []
                        for (fname, fvalue) in fields:
                            hir_fields = hir_fields.push((fname, self.lower_expr(fvalue)))
                        HirEnumPayload.Struct(hir_fields)
                )
                HirExprKind.EnumLit(hir_type, variant, hir_payload)

            # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
            case CustomBlock(kind, value):
                HirExprKind.CustomBlock(kind, value)

            # Math/DL blocks with special semantics
            case LossBlock(body):
                HirExprKind.LossBlock(self.lower_block(body))

            case NogradBlock(body):
                HirExprKind.NogradBlock(self.lower_block(body))

            case Error:
                HirExprKind.Error

            case _:
                self.error("unsupported expression kind", e.span)
                HirExprKind.Error

        HirExpr(kind: kind, type_: nil, span: e.span)

    me lower_binop(op: BinOp) -> HirBinOp:
        """Lower binary operator."""
        match op:
            case Add: HirBinOp.Add
            case Sub: HirBinOp.Sub
            case Mul: HirBinOp.Mul
            case Div: HirBinOp.Div
            case Mod: HirBinOp.Mod
            case Pow: HirBinOp.Pow
            case MatMul: HirBinOp.MatMul
            case Eq: HirBinOp.Eq
            case NotEq: HirBinOp.NotEq
            case Lt: HirBinOp.Lt
            case LtEq: HirBinOp.LtEq
            case Gt: HirBinOp.Gt
            case GtEq: HirBinOp.GtEq
            case And: HirBinOp.And
            case Or: HirBinOp.Or
            case BitAnd: HirBinOp.BitAnd
            case BitOr: HirBinOp.BitOr
            case BitXor: HirBinOp.BitXor
            case Shl: HirBinOp.Shl
            case Shr: HirBinOp.Shr
            case BroadcastAdd: HirBinOp.BroadcastAdd
            case BroadcastSub: HirBinOp.BroadcastSub
            case BroadcastMul: HirBinOp.BroadcastMul
            case BroadcastDiv: HirBinOp.BroadcastDiv
            case BroadcastPow: HirBinOp.BroadcastPow
            case PipeForward: HirBinOp.PipeForward
            case Compose: HirBinOp.Compose
            case ComposeBack: HirBinOp.ComposeBack
            case Parallel: HirBinOp.Parallel
            case LayerConnect: HirBinOp.LayerConnect
            case In: HirBinOp.In
            case NotIn: HirBinOp.NotIn
            case Is: HirBinOp.Is
            case IsNot: HirBinOp.IsNot

    me lower_unaryop(op: UnaryOp) -> HirUnaryOp:
        """Lower unary operator."""
        match op:
            case Neg: HirUnaryOp.Neg
            case Not: HirUnaryOp.Not
            case BitNot: HirUnaryOp.BitNot
            case Ref: HirUnaryOp.Ref
            case Deref: HirUnaryOp.Deref
            case Transpose: HirUnaryOp.Transpose

    me lower_pattern(p: Pattern) -> HirPattern:
        """Lower pattern to HIR."""
        val kind = match p.kind:
            case Wildcard:
                HirPatternKind.Wildcard

            case Literal(value):
                HirPatternKind.Literal(self.lower_expr(value))

            case Binding(name, mutable):
                val symbol = self.symbols.define(name, SymbolKind.Variable, nil, p.span, false, mutable)
                HirPatternKind.Binding(symbol, mutable)

            case Tuple(elements):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_pattern(elem))
                HirPatternKind.Tuple(hir_elements)

            case Array(elements, rest):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements.push(self.lower_pattern(elem))
                var rest_symbol: SymbolId? = None
                if rest.?:
                    rest_symbol = Some(self.symbols.define(rest.unwrap(), SymbolKind.Variable, nil, p.span, false, false))
                HirPatternKind.Array(hir_elements, rest_symbol)

            case Struct(type_, fields):
                val symbol = self.symbols.lookup(type_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                var hir_fields: [(text, HirPattern)] = []
                for (fname, fpat) in fields:
                    hir_fields = hir_fields.push((fname, self.lower_pattern(fpat)))
                HirPatternKind.Struct(hir_type, hir_fields)

            case Enum(enum_, variant, payload):
                val symbol = self.symbols.lookup(enum_)
                val hir_type = if symbol.?:
                    HirType(kind: HirTypeKind.Named(symbol.unwrap(), []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                val hir_payload = payload.map(\pl: match pl:
                    case Tuple(patterns):
                        var hir_patterns: [HirPattern] = []
                        for pat in patterns:
                            hir_patterns = hir_patterns.push(self.lower_pattern(pat))
                        HirPatternPayload.Tuple(hir_patterns)
                    case Struct(fields):
                        var hir_fields: [(text, HirPattern)] = []
                        for (fname, fpat) in fields:
                            hir_fields = hir_fields.push((fname, self.lower_pattern(fpat)))
                        HirPatternPayload.Struct(hir_fields)
                )
                HirPatternKind.Enum(hir_type, variant, hir_payload)

            case Or(patterns):
                var hir_patterns: [HirPattern] = []
                for pat in patterns:
                    hir_patterns = hir_patterns.push(self.lower_pattern(pat))
                HirPatternKind.Or(hir_patterns)

            case Range(start, end, inclusive):
                HirPatternKind.Range(
                    start.map(\s: self.lower_expr(s)),
                    end.map(\e: self.lower_expr(e)),
                    inclusive
                )

            case Error:
                HirPatternKind.Error

            case _:
                self.error("unsupported pattern kind", p.span)
                HirPatternKind.Error

        HirPattern(kind: kind, type_: nil, span: p.span)

    me lower_block(b: Block) -> HirBlock:
        """Lower block to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        # where chained method calls corrupt 'self'
        var symbols_table = self.symbols
        symbols_table.push_scope(ScopeKind.Block)
        self.symbols = symbols_table

        var stmts: [HirStmt] = []
        for s in b.stmts:
            stmts = stmts.push(self.lower_stmt(s))

        symbols_table = self.symbols
        symbols_table.pop_scope()
        self.symbols = symbols_table

        # Check if last statement is an expression (for block value)
        var value: HirExpr? = None
        if stmts.len() > 0:
            val last = stmts[stmts.len() - 1]
            match last.kind:
                case Expr(expr):
                    value = Some(expr)
                    stmts = stmts[0:stmts.len() - 1]  # Remove last stmt
                case _:
                    pass

        HirBlock(stmts: stmts, value: value, span: b.span)

    me lower_stmt(s: Stmt) -> HirStmt:
        """Lower statement to HIR."""
        # Workaround: Capture self reference to ensure it's available in match arms
        val lowerer = self
        val kind = match s.kind:
            case StmtKind.Expr(expr):
                HirStmtKind.Expr(self.lower_expr(expr))

            case StmtKind.Val(name, type_, init):
                val hir_type = type_.map(\t: self.lower_type(t))
                val hir_init = self.lower_expr(init)
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                val symbol = symbols_table.define(name, SymbolKind.Variable, hir_type, s.span, false, false)
                self.symbols = symbols_table
                HirStmtKind.Let(symbol, hir_type, hir_init)

            case StmtKind.Var(name, type_, init):
                val hir_type = type_.map(\t: self.lower_type(t))
                val hir_init = init.map(\i: self.lower_expr(i)) ?? HirExpr(kind: HirExprKind.NilLit, type_: nil, span: s.span)
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                val symbol = symbols_table.define(name, SymbolKind.Variable, hir_type, s.span, false, true)
                self.symbols = symbols_table
                HirStmtKind.Let(symbol, hir_type, hir_init)

            case StmtKind.Assign(target, op, value):
                val hir_op = op.map(\o: match o:
                    case AssignOp.Add: HirAssignOp.Add
                    case AssignOp.Sub: HirAssignOp.Sub
                    case AssignOp.Mul: HirAssignOp.Mul
                    case AssignOp.Div: HirAssignOp.Div
                    case AssignOp.Mod: HirAssignOp.Mod
                )
                HirStmtKind.Assign(self.lower_expr(target), hir_op, self.lower_expr(value))

            case StmtKind.For(var_, iter, body):
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                symbols_table.push_scope(ScopeKind.Loop)
                self.symbols = symbols_table
                self.loop_depth = self.loop_depth + 1
                symbols_table = self.symbols
                val symbol = symbols_table.define(var_, SymbolKind.Variable, nil, s.span, false, false)
                self.symbols = symbols_table
                val hir_iter = self.lower_expr(iter)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                symbols_table = self.symbols
                symbols_table.pop_scope()
                self.symbols = symbols_table
                # Desugar to loop
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.For(symbol, hir_iter, hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.While(cond, body):
                self.loop_depth = self.loop_depth + 1
                val hir_cond = self.lower_expr(cond)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.While(hir_cond, hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Loop(body):
                self.loop_depth = self.loop_depth + 1
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Loop(hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Return(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Return(value.map(\v: self.lower_expr(v))),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Break(label):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Break(label, nil),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Continue(label):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Continue(label),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Yield(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Yield(value.map(\v: self.lower_expr(v))),
                    type_: nil,
                    span: s.span
                ))

            case StmtKind.Throw(value):
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Throw(self.lower_expr(value)),
                    type_: nil,
                    span: s.span
                ))

            case _:
                self.error("unsupported statement kind", s.span)
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Error,
                    type_: nil,
                    span: s.span
                ))

        HirStmt(kind: kind, span: s.span)

    me error(message: text, span: Span):
        """Record a lowering error."""
        self.errors = self.errors.push(LoweringError(
            message: message,
            span: span,
            kind: LoweringErrorKind.Other
        ))


# ============================================================================
# Exports
# ============================================================================

export HirLowering, LoweringError, LoweringErrorKind
