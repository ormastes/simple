# Parser - Simple Language Parser
#
# Parses Simple source code into an Abstract Syntax Tree (AST).
# Uses tree-sitter for outline parsing, then detailed token-based parsing.
#
# AST type definitions are in parser_types.spl

use lexer.*
use treesitter.*
use blocks.*
use parser_types.*

impl Parser:
    static fn new(source: text) -> Parser:
        var p = Parser(
            source: source,
            lexer: Lexer.new(source),
            current: Token.eof(0, 1),
            previous: Token.eof(0, 1),
            errors: [],
            outline: nil,
            resolved_blocks: nil
        )
        p.advance()
        p

    static fn with_resolved_blocks(source: text, resolved: ResolvedModule) -> Parser:
        """Create parser with pre-resolved blocks."""
        var p = Parser(
            source: source,
            lexer: Lexer.new(source),
            current: Token.eof(0, 1),
            previous: Token.eof(0, 1),
            errors: [],
            outline: Some(resolved.outline),
            resolved_blocks: Some(resolved)
        )
        p.advance()
        p

    # ========================================================================
    # Main Entry Point
    # ========================================================================

    me parse() -> Module:
        """Parse source into a full Module."""
        # Pass 1: Get outline (reuse from resolved_blocks if available)
        if not self.outline.?:
            val ts = TreeSitter.new(self.source)
            self.outline = Some(ts.parse_outline())

        # Pass 2: Fill in bodies
        self.parse_full()

    me parse_full() -> Module:
        """Parse full module using outline."""
        val outline = self.outline.unwrap()

        var module = Module(
            name: outline.name,
            imports: [],
            exports: [],
            functions: {},
            classes: {},
            structs: {},
            enums: {},
            traits: {},
            impls: [],
            type_aliases: {},
            constants: {}
        )

        # Convert imports
        for imp in outline.imports:
            module.imports = module.imports.push(self.convert_import(imp))

        # Convert exports
        for exp in outline.exports:
            module.exports = module.exports.push(Export(
                items: exp.items,
                span: exp.span
            ))

        # Parse function bodies
        var fn_idx = 0
        while fn_idx < outline.functions.len():
            val fn_outline = outline.functions[fn_idx]
            val fn_ = self.parse_function_body(fn_outline)
            var fns = module.functions
            fns[fn_.name] = fn_
            module.functions = fns
            fn_idx = fn_idx + 1

        # Parse class bodies
        for class_outline in outline.classes:
            val class_ = self.parse_class_body(class_outline)
            module.classes[class_.name] = class_

        # Parse struct bodies
        for struct_outline in outline.structs:
            val struct_ = self.convert_struct(struct_outline)
            module.structs[struct_.name] = struct_

        # Parse enum bodies
        for enum_outline in outline.enums:
            val enum_ = self.convert_enum(enum_outline)
            module.enums[enum_.name] = enum_

        # Parse trait bodies
        for trait_outline in outline.traits:
            val trait_ = self.parse_trait_body(trait_outline)
            module.traits[trait_.name] = trait_

        # Parse impl bodies
        for impl_outline in outline.impls:
            val impl_ = self.parse_impl_body(impl_outline)
            module.impls = module.impls.push(impl_)

        # Convert type aliases
        for alias_outline in outline.type_aliases:
            val alias = self.convert_type_alias(alias_outline)
            module.type_aliases[alias.name] = alias

        # Parse constant values
        for const_outline in outline.constants:
            val const_ = self.parse_const_body(const_outline)
            module.constants[const_.name] = const_

        module

    # ========================================================================
    # Token Handling (for body parsing)
    # ========================================================================

    me advance() -> Token:
        self.previous = self.current
        # Copy-modify-reassign: nested field mutations don't propagate in interpreter
        var lexer = self.lexer
        self.current = lexer.next_token()
        self.lexer = lexer
        self.previous

    me peek() -> TokenKind:
        self.current.kind

    me check(kind: TokenKind) -> bool:
        self.current.kind == kind

    me match_token(kind: TokenKind) -> bool:
        if self.check(kind):
            self.advance()
            true
        else:
            false

    me expect(kind: TokenKind, message: text) -> bool:
        if self.check(kind):
            self.advance()
            true
        else:
            self.error(message)
            false

    me is_at_end() -> bool:
        # Handle nil token as end of input
        if not self.current.kind.?:
            return true
        self.current.kind == TokenKind.Eof

    me skip_newlines():
        while self.check(TokenKind.Newline):
            self.advance()

    me error(message: text):
        self.errors = self.errors.push(ParseError(
            message: message,
            span: self.current.span,
            severity: ErrorSeverity.Error
        ))

    me reset_to_span(span: Span):
        """Reset lexer to parse from a specific span."""
        var lexer = Lexer.new(self.source)
        lexer.pos = span.start

        # Skip to the right position
        while lexer.pos < span.start and not lexer.is_at_end():
            lexer.advance()

        self.current = lexer.next_token()
        self.lexer = lexer
        self.previous = Token.eof(0, 1)

    # ========================================================================
    # Outline Conversion
    # ========================================================================

    # Helper: convert a list of TypeOutline to [Type]
    me convert_type_list(outlines: [TypeOutline]) -> [Type]:
        var result: [Type] = []
        for outline in outlines:
            result = result.push(self.convert_type(outline))
        result

    # Helper: convert a list of FieldOutline to [Field]
    me convert_field_list(outlines: [FieldOutline]) -> [Field]:
        var result: [Field] = []
        for outline in outlines:
            result = result.push(self.convert_field(outline))
        result

    me convert_import(outline: ImportOutline) -> Import:
        var items: [ImportItem] = []
        for item in outline.items:
            items = items.push(ImportItem(name: item, alias: nil))

        Import(
            module: outline.module,
            items: items,
            span: outline.span
        )

    me convert_type(outline: TypeOutline) -> Type:
        val kind = match outline.kind:
            case Named(name, args):
                TypeKind.Named(name, self.convert_type_list(args))
            case Tuple(elements):
                TypeKind.Tuple(self.convert_type_list(elements))
            case Array(element):
                TypeKind.Array(self.convert_type(element), nil)
            case Function(params, ret):
                TypeKind.Function(self.convert_type_list(params), self.convert_type(ret))
            case Optional(inner):
                TypeKind.Optional(self.convert_type(inner))
            case Reference(inner, mutable):
                TypeKind.Reference(self.convert_type(inner), mutable)
            case Infer:
                TypeKind.Infer

        Type(kind: kind, span: outline.span)

    me convert_type_param(outline: TypeParamOutline) -> TypeParam:
        var bounds: [Type] = []
        for b in outline.bounds:
            bounds = bounds.push(self.convert_type(b))

        TypeParam(
            name: outline.name,
            bounds: bounds,
            default: outline.default.map(\t: self.convert_type(t)),
            span: outline.span
        )

    me convert_param(outline: ParamOutline) -> Param:
        var default_expr: Expr? = None
        if outline.default_span.?:
            default_expr = Some(self.parse_expr_at_span(outline.default_span.unwrap()))

        val type_result = outline.type_.map(\t: self.convert_type(t))
        Param(
            name: outline.name,
            type_: type_result,
            default: default_expr,
            span: outline.span
        )

    me convert_field(outline: FieldOutline) -> Field:
        var default_expr: Expr? = None
        if outline.default_span.?:
            default_expr = Some(self.parse_expr_at_span(outline.default_span.unwrap()))

        Field(
            name: outline.name,
            type_: self.convert_type(outline.type_),
            default: default_expr,
            is_public: outline.is_public,
            span: outline.span
        )

    me convert_struct(outline: StructOutline) -> Struct:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields.push(self.convert_field(f))

        Struct(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me convert_enum(outline: EnumOutline) -> Enum:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var variants: [Variant] = []
        for v in outline.variants:
            val kind = match v.payload:
                case None:
                    VariantKind.Unit
                case Some(Tuple(types)):
                    VariantKind.Tuple(self.convert_type_list(types))
                case Some(Struct(fields)):
                    VariantKind.Struct(self.convert_field_list(fields))

            variants = variants.push(Variant(
                name: v.name,
                kind: kind,
                span: v.span
            ))

        Enum(
            name: outline.name,
            type_params: type_params,
            variants: variants,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me convert_type_alias(outline: TypeAliasOutline) -> TypeAlias:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        TypeAlias(
            name: outline.name,
            type_params: type_params,
            type_: self.convert_type(outline.type_),
            is_public: outline.is_public,
            span: outline.span
        )

    # ========================================================================
    # Body Parsing
    # ========================================================================

    me parse_function_body(outline: FunctionOutline) -> Function:
        """Parse function body from outline."""
        var type_params: [TypeParam] = []

        var params: [Param] = []
        var pi = 0
        while pi < outline.params.len():
            val p = outline.params[pi]
            params = params.push(self.convert_param(p))
            pi = pi + 1

        var body = Block(stmts: [], span: outline.body_span)
        if outline.body_span.len() > 0:
            body = self.parse_block_at_span(outline.body_span)

        Function(
            name: outline.name,
            type_params: type_params,
            params: params,
            return_type: outline.return_type.map(\t: self.convert_type(t)),
            body: body,
            is_async: outline.is_async,
            is_static: outline.is_static,
            is_public: outline.is_public,
            is_method: outline.is_method,
            is_mutable: outline.is_mutable,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me parse_class_body(outline: ClassOutline) -> Class:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields.push(self.convert_field(f))

        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        Class(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me parse_trait_body(outline: TraitOutline) -> Trait:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var methods: [Function] = []
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods = methods.push(fn_)

        Trait(
            name: outline.name,
            type_params: type_params,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me parse_impl_body(outline: ImplOutline) -> Impl:
        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        Impl(
            type_: self.convert_type(outline.type_),
            trait_: outline.trait_.map(\t: self.convert_type(t)),
            methods: methods,
            span: outline.span
        )

    me parse_const_body(outline: ConstOutline) -> Const:
        val value = self.parse_expr_at_span(outline.value_span)

        Const(
            name: outline.name,
            type_: outline.type_.map(\t: self.convert_type(t)),
            value: value,
            is_mutable: outline.is_mutable,
            is_public: outline.is_public,
            span: outline.span
        )

    # ========================================================================
    # Expression Parsing
    # ========================================================================

    me parse_expr_at_span(span: Span) -> Expr:
        """Parse an expression at a specific span."""
        self.reset_to_span(span)
        self.parse_expr()

    me parse_block_at_span(span: Span) -> Block:
        """Parse a block at a specific span."""
        self.reset_to_span(span)
        self.parse_block()

    me parse_expr() -> Expr:
        """Parse an expression."""
        self.parse_pipeline_expr()

    me parse_pipeline_expr() -> Expr:
        """Parse pipeline expression (|>, ~>).

        Pipeline operators have lowest precedence and are left-associative.
        - |> : Forward pipe, passes left value as first argument to right function
        - ~> : Layer connect, composes neural network layers with dimension checking
        """
        var left = self.parse_parallel_expr()

        loop:
            if self.match_token(TokenKind.PipeForward):
                val right = self.parse_parallel_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.PipeForward, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.LayerConnect):
                val right = self.parse_parallel_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.LayerConnect, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_parallel_expr() -> Expr:
        """Parse parallel expression (//).

        Parallel operator combines branches for concurrent/parallel execution.
        Left-associative.
        """
        var left = self.parse_composition_expr()

        while self.match_token(TokenKind.Parallel):
            val right = self.parse_composition_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.Parallel, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_composition_expr() -> Expr:
        """Parse composition expression (>>, <<).

        Composition operators are right-associative (like Haskell's . operator).
        - >> : Forward compose, f >> g means g(f(x))
        - << : Backward compose, f << g means f(g(x))
        """
        val left = self.parse_or_expr()

        if self.match_token(TokenKind.Compose):
            val right = self.parse_composition_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.Compose, left, right),
                span: left.span.merge(right.span)
            )

        if self.match_token(TokenKind.ComposeBack):
            val right = self.parse_composition_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.ComposeBack, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_or_expr() -> Expr:
        """Parse logical or expression."""
        var left = self.parse_xor_expr()

        while self.match_token(TokenKind.KwOr) or self.match_token(TokenKind.PipePipe):
            val right = self.parse_xor_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.Or, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_xor_expr() -> Expr:
        """Parse bitwise xor expression."""
        var left = self.parse_and_expr()

        while self.match_token(TokenKind.KwXor):
            val right = self.parse_and_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.BitXor, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_and_expr() -> Expr:
        """Parse logical and expression."""
        var left = self.parse_equality_expr()

        while self.match_token(TokenKind.KwAnd) or self.match_token(TokenKind.AmpAmp):
            val right = self.parse_equality_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.And, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_equality_expr() -> Expr:
        """Parse equality expression."""
        var left = self.parse_comparison_expr()

        loop:
            if self.match_token(TokenKind.Eq):
                val right = self.parse_comparison_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Eq, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.NotEq):
                val right = self.parse_comparison_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.NotEq, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_comparison_expr() -> Expr:
        """Parse comparison expression."""
        var left = self.parse_range_expr()

        loop:
            if self.match_token(TokenKind.Lt):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Lt, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.LtEq):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.LtEq, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Gt):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Gt, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.GtEq):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.GtEq, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.KwIn):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.In, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.KwIs):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Is, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_range_expr() -> Expr:
        """Parse range expression."""
        val left = self.parse_additive_expr()

        if self.match_token(TokenKind.DotDot):
            var inclusive = false
            if self.match_token(TokenKind.Assign):  # ..=
                inclusive = true
            val right = self.parse_additive_expr()
            return Expr(
                kind: ExprKind.Range(Some(left), Some(right), inclusive, nil),
                span: left.span.merge(right.span)
            )

        left

    me parse_additive_expr() -> Expr:
        """Parse additive expression (including broadcast .+ and .-)."""
        var left = self.parse_matmul_expr()

        loop:
            if self.match_token(TokenKind.Plus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Add, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Minus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Sub, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotPlus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastAdd, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotMinus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastSub, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_matmul_expr() -> Expr:
        """Parse matrix multiplication expression (@)."""
        var left = self.parse_multiplicative_expr()

        while self.match_token(TokenKind.At):
            val right = self.parse_multiplicative_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.MatMul, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_multiplicative_expr() -> Expr:
        """Parse multiplicative expression (including broadcast .* and ./)."""
        var left = self.parse_power_expr()

        loop:
            if self.match_token(TokenKind.Star):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Mul, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Slash):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Div, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Percent):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Mod, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotStar):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastMul, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotSlash):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastDiv, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.ImplicitMul):
                # Implicit multiplication (m{} only): 2x, 2(x+1), (a)(b)
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Mul, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_power_expr() -> Expr:
        """Parse power expression (right-associative, including .^ broadcast)."""
        val left = self.parse_unary_expr()

        if self.match_token(TokenKind.StarStar):
            val right = self.parse_power_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.Pow, left, right),
                span: left.span.merge(right.span)
            )

        if self.match_token(TokenKind.DotCaret):
            val right = self.parse_power_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.BroadcastPow, left, right),
                span: left.span.merge(right.span)
            )

        if self.match_token(TokenKind.Caret):
            val right = self.parse_power_expr()  # Right-associative (inside m{})
            return Expr(
                kind: ExprKind.Binary(BinOp.Pow, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_unary_expr() -> Expr:
        """Parse unary expression."""
        val start = self.current.span

        if self.match_token(TokenKind.Minus):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.Neg, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.KwNot) or self.match_token(TokenKind.Bang):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.Not, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.Tilde):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.BitNot, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.Ampersand):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.Ref, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.KwAwait):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Await(operand),
                span: start.merge(operand.span)
            )

        self.parse_postfix_expr()

    me parse_postfix_expr() -> Expr:
        """Parse postfix expression (calls, indexing, field access)."""
        var expr = self.parse_primary_expr()

        loop:
            if self.match_token(TokenKind.LParen):
                # Function call
                val args = self.parse_call_args()
                self.expect(TokenKind.RParen, "expected ')' after arguments")
                expr = Expr(
                    kind: ExprKind.Call(expr, args),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.LBracket):
                # Index
                val index = self.parse_expr()
                self.expect(TokenKind.RBracket, "expected ']' after index")
                expr = Expr(
                    kind: ExprKind.Index(expr, index),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.Dot):
                # Field access or method call
                val field = self.parse_identifier()
                if self.match_token(TokenKind.LParen):
                    val args = self.parse_call_args()
                    self.expect(TokenKind.RParen, "expected ')' after arguments")
                    expr = Expr(
                        kind: ExprKind.MethodCall(expr, field, args),
                        span: expr.span.merge(self.previous.span)
                    )
                else:
                    expr = Expr(
                        kind: ExprKind.Field(expr, field),
                        span: expr.span.merge(self.previous.span)
                    )
            elif self.match_token(TokenKind.QuestionDot):
                # Optional chaining
                val field = self.parse_identifier()
                expr = Expr(
                    kind: ExprKind.OptionalChain(expr, field),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.DotQuestion):
                # Exists check
                expr = Expr(
                    kind: ExprKind.ExistsCheck(expr),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.Question):
                # Try operator
                expr = Expr(
                    kind: ExprKind.Try(expr),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.QuestionQuestion):
                # Null coalesce
                val right = self.parse_unary_expr()
                expr = Expr(
                    kind: ExprKind.NullCoalesce(expr, right),
                    span: expr.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Transpose):
                # Postfix transpose (m{} only)
                expr = Expr(
                    kind: ExprKind.Unary(UnaryOp.Transpose, expr),
                    span: expr.span.merge(self.previous.span)
                )
            else:
                break

        expr

    me parse_primary_expr() -> Expr:
        """Parse primary expression."""
        val start = self.current.span

        match self.peek():
            case IntLit:
                val text = self.current.text
                self.advance()
                val value = parse_int_literal(text)
                Expr(kind: ExprKind.IntLit(value), span: start)

            case FloatLit:
                val text = self.current.text
                self.advance()
                val value = parse_float_literal(text)
                Expr(kind: ExprKind.FloatLit(value), span: start)

            case StringLit:
                self.parse_string_literal()

            case BoolLit:
                val value = self.current.text == "true"
                self.advance()
                Expr(kind: ExprKind.BoolLit(value), span: start)

            case NilLit:
                self.advance()
                Expr(kind: ExprKind.NilLit, span: start)

            case Ident:
                val name = self.current.text
                self.advance()
                Expr(kind: ExprKind.Ident(name), span: start)

            case LParen:
                self.advance()
                if self.check(TokenKind.RParen):
                    # Unit tuple ()
                    self.advance()
                    Expr(kind: ExprKind.TupleLit([]), span: start.merge(self.previous.span))
                else:
                    val expr = self.parse_expr()
                    if self.match_token(TokenKind.Comma):
                        # Tuple literal
                        var elements = [expr]
                        if not self.check(TokenKind.RParen):
                            elements = elements.push(self.parse_expr())
                            while self.match_token(TokenKind.Comma):
                                if self.check(TokenKind.RParen):
                                    break
                                elements = elements.push(self.parse_expr())
                        self.expect(TokenKind.RParen, "expected ')' after tuple")
                        Expr(kind: ExprKind.TupleLit(elements), span: start.merge(self.previous.span))
                    else:
                        # Grouped expression
                        self.expect(TokenKind.RParen, "expected ')'")
                        expr

            case LBracket:
                self.parse_array_or_comprehension()

            case LBrace:
                self.parse_dict_literal()

            case Backslash:
                self.parse_lambda()

            case KwIf:
                self.parse_if_expr()

            case KwMatch:
                self.parse_match_expr()

            case KwReturn:
                self.advance()
                var value: Expr? = None
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                Expr(kind: ExprKind.Return(value), span: start.merge(self.previous.span))

            case KwBreak:
                self.advance()
                Expr(kind: ExprKind.Break(nil), span: start)

            case KwContinue:
                self.advance()
                Expr(kind: ExprKind.Continue(nil), span: start)

            case KwYield:
                self.advance()
                var value: Expr? = None
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                Expr(kind: ExprKind.Yield(value), span: start.merge(self.previous.span))

            case KwThrow:
                self.advance()
                val value = self.parse_expr()
                Expr(kind: ExprKind.Throw(value), span: start.merge(value.span))

            case KwLoss:
                self.parse_loss_block()

            case KwNograd:
                self.parse_nograd_block()

            case BlockStart:
                # Custom block (sh{}, sql{}, re{}, etc.)
                val kind = self.current.text
                self.parse_resolved_block(kind)

            case _:
                self.error("expected expression")
                self.advance()
                Expr(kind: ExprKind.Error, span: start)

    me parse_string_literal() -> Expr:
        """Parse string literal with interpolation."""
        val start = self.current.span
        val text = self.current.text
        self.advance()

        # TODO: Parse interpolations
        Expr(kind: ExprKind.StringLit(text, nil), span: start)

    me parse_array_or_comprehension() -> Expr:
        """Parse array literal or list comprehension.

        Handles suffix notation for tensor types:
        - [1, 2, 3]f32        - f32 array
        - [1, 2, 3]_f32_gpu   - f32 tensor on GPU
        - [1, 2, 3]f32_tr_cuda - trainable f32 tensor on CUDA
        """
        val start = self.current.span
        self.advance()  # Consume '['

        # Check for empty array: [] or []f32
        if self.check(TokenKind.RBracket):
            self.advance()
            return Expr(kind: ExprKind.ArrayLit([]), span: start.merge(self.previous.span))
        if self.check(TokenKind.ArraySuffix):
            val suffix_text = self.current.text
            self.advance()
            val suffix = TensorSuffix.from_string(suffix_text)
            return Expr(
                kind: ExprKind.ArrayLitSuffix([], suffix),
                span: start.merge(self.previous.span)
            )

        # Check for comprehension
        if self.check(TokenKind.KwFor):
            return self.parse_list_comprehension(start)

        # Array literal
        var elements: [Expr] = []
        elements = elements.push(self.parse_expr())

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBracket) or self.check(TokenKind.ArraySuffix):
                break
            elements = elements.push(self.parse_expr())

        # Check for suffix (ArraySuffix token includes the ] and suffix)
        if self.check(TokenKind.ArraySuffix):
            val suffix_text = self.current.text
            self.advance()
            val suffix = TensorSuffix.from_string(suffix_text)
            return Expr(
                kind: ExprKind.ArrayLitSuffix(elements, suffix),
                span: start.merge(self.previous.span)
            )

        # Regular array, expect RBracket
        self.expect(TokenKind.RBracket, "expected ']' after array elements")
        Expr(kind: ExprKind.ArrayLit(elements), span: start.merge(self.previous.span))

    me parse_list_comprehension(start: Span) -> Expr:
        """Parse list comprehension [for x in y if cond: expr]."""
        var clauses: [ComprehensionClause] = []

        while self.match_token(TokenKind.KwFor):
            val var_start = self.current.span
            val var_ = self.parse_identifier()
            self.expect(TokenKind.KwIn, "expected 'in' in comprehension")
            val iter = self.parse_expr()
            clauses = clauses.push(ComprehensionClause(
                kind: ComprehensionKind.For(var_, iter),
                span: var_start.merge(iter.span)
            ))

            while self.match_token(TokenKind.KwIf):
                val cond_start = self.previous.span
                val cond = self.parse_expr()
                clauses = clauses.push(ComprehensionClause(
                    kind: ComprehensionKind.If(cond),
                    span: cond_start.merge(cond.span)
                ))

        self.expect(TokenKind.Colon, "expected ':' in comprehension")
        val expr = self.parse_expr()
        self.expect(TokenKind.RBracket, "expected ']' after comprehension")

        Expr(kind: ExprKind.ListComprehension(expr, clauses), span: start.merge(self.previous.span))

    me parse_dict_literal() -> Expr:
        """Parse dict literal {key: value, ...}."""
        val start = self.current.span
        self.advance()  # Consume '{'

        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr(kind: ExprKind.DictLit([]), span: start.merge(self.previous.span))

        var entries: [(Expr, Expr)] = []
        val key = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after dict key")
        val value = self.parse_expr()
        entries = entries.push((key, value))

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBrace):
                break
            val k = self.parse_expr()
            self.expect(TokenKind.Colon, "expected ':' after dict key")
            val v = self.parse_expr()
            entries = entries.push((k, v))

        self.expect(TokenKind.RBrace, "expected '}' after dict entries")
        Expr(kind: ExprKind.DictLit(entries), span: start.merge(self.previous.span))

    me parse_lambda() -> Expr:
        """Parse lambda expression \x, y: expr."""
        val start = self.current.span
        self.advance()  # Consume '\'

        var params: [LambdaParam] = []

        if not self.check(TokenKind.Colon):
            params = params.push(self.parse_lambda_param())
            while self.match_token(TokenKind.Comma):
                params = params.push(self.parse_lambda_param())

        self.expect(TokenKind.Colon, "expected ':' after lambda parameters")
        val body = self.parse_expr()

        Expr(kind: ExprKind.Lambda(params, body), span: start.merge(body.span))

    me parse_lambda_param() -> LambdaParam:
        """Parse lambda parameter."""
        val start = self.current.span
        val name = self.parse_identifier()

        var type_: Type? = None
        if self.match_token(TokenKind.Colon):
            type_ = Some(self.parse_type())

        LambdaParam(name: name, type_: type_, span: start.merge(self.previous.span))

    me parse_if_expr() -> Expr:
        """Parse if expression."""
        val start = self.current.span
        self.advance()  # Consume 'if'

        val cond = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after if condition")
        val then_ = self.parse_block()

        var else_: Block? = None
        if self.match_token(TokenKind.KwElse):
            self.expect(TokenKind.Colon, "expected ':' after else")
            else_ = Some(self.parse_block())
        elif self.match_token(TokenKind.KwElif):
            # elif is sugar for else if
            val elif_expr = self.parse_if_expr()
            else_ = Some(Block(stmts: [Stmt(kind: StmtKind.Expr(elif_expr), span: elif_expr.span)], span: elif_expr.span))

        Expr(kind: ExprKind.If(cond, then_, else_), span: start.merge(self.previous.span))

    me parse_match_expr() -> Expr:
        """Parse match expression."""
        val start = self.current.span
        self.advance()  # Consume 'match'

        val scrutinee = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after match scrutinee")
        self.skip_newlines()
        self.expect(TokenKind.Indent, "expected indented match arms")

        var arms: [MatchArm] = []

        while not self.check(TokenKind.Dedent) and not self.is_at_end():
            self.skip_newlines()
            if self.check(TokenKind.Dedent):
                break

            # Support both syntaxes:
            # - `case pattern:` (traditional)
            # - `| pattern ->` (Erlang-style, preferred)
            val is_pipe_syntax = self.check(TokenKind.Pipe)
            if is_pipe_syntax:
                self.advance()  # consume `|`
            elif self.check(TokenKind.KwCase):
                self.advance()  # consume `case`
            else:
                self.error("expected 'case' or '|' in match arm")

            val pattern = self.parse_pattern()

            var guard: Expr? = None
            if self.match_token(TokenKind.KwIf):
                guard = Some(self.parse_expr())

            # For `| pattern ->` syntax, expect `->`
            # For `case pattern:` syntax, accept `:` or `->`
            if is_pipe_syntax:
                self.expect(TokenKind.Arrow, "expected '->' after pattern in | syntax")
            elif self.check(TokenKind.Arrow):
                self.advance()
            else:
                self.expect(TokenKind.Colon, "expected ':' or '->' after pattern")

            val body = self.parse_block()

            arms = arms.push(MatchArm(
                pattern: pattern,
                guard: guard,
                body: body,
                span: pattern.span.merge(body.span)
            ))

        self.match_token(TokenKind.Dedent)

        Expr(kind: ExprKind.Match(scrutinee, arms), span: start.merge(self.previous.span))

    me parse_loss_block() -> Expr:
        """Parse loss{ ... } block.

        Loss blocks enable gradient tracking and auto-backward.
        They inherit m{} math block features (^, ', implicit mul).
        """
        val start = self.current.span
        self.advance()  # Consume 'loss' (math mode already enabled by lexer)
        self.expect(TokenKind.LBrace, "expected '{' after 'loss'")
        val body = self.parse_block()
        self.expect(TokenKind.RBrace, "expected '}' after loss block")
        Expr(kind: ExprKind.LossBlock(body), span: start.merge(self.previous.span))

    me parse_nograd_block() -> Expr:
        """Parse nograd{ ... } block.

        Nograd blocks disable gradient tracking for faster inference.
        They inherit m{} math block features (^, ', implicit mul).
        """
        val start = self.current.span
        self.advance()  # Consume 'nograd' (math mode already enabled by lexer)
        self.expect(TokenKind.LBrace, "expected '{' after 'nograd'")
        val body = self.parse_block()
        self.expect(TokenKind.RBrace, "expected '}' after nograd block")
        Expr(kind: ExprKind.NogradBlock(body), span: start.merge(self.previous.span))

    # ========================================================================
    # Custom Block Parsing
    # ========================================================================

    me parse_resolved_block(kind: text) -> Expr:
        """Parse a custom block using pre-resolved value.

        Called when a BlockStart token is encountered. Looks up the
        pre-resolved value and skips the payload tokens.

        Args:
            kind: The block kind (e.g., "sh", "sql", "re")
        """
        val start = self.current.span
        self.advance()  # Consume BlockStart

        # Look up pre-resolved value
        if self.resolved_blocks.?:
            val resolved = self.resolved_blocks.unwrap()
            val block = resolved.lookup(start)

            if block.?:
                val rb = block.unwrap()
                # Skip payload tokens (already processed by BlockResolver)
                self.skip_to_block_end()

                # Consume the closing brace/BlockEnd
                if self.check(TokenKind.BlockEnd):
                    self.advance()
                elif self.check(TokenKind.RBrace):
                    self.advance()

                return Expr(
                    kind: ExprKind.CustomBlock(rb.kind, rb.value),
                    span: start.merge(self.previous.span)
                )

        # Fallback: inline parsing (block not pre-resolved)
        self.parse_block_inline(kind, start)

    me parse_block_inline(kind: text, start: Span) -> Expr:
        """Parse a block inline when not pre-resolved.

        This is a fallback for when blocks are parsed without going
        through the BlockResolver phase.
        """
        # Expect opening brace
        self.expect(TokenKind.LBrace, "expected '{{' after block keyword '{kind}'")

        # For inline parsing, we treat it as a raw block
        # Skip until matching closing brace
        var brace_depth = 1
        val payload_start = self.current.span.start

        while brace_depth > 0 and not self.is_at_end():
            match self.peek():
                case LBrace:
                    brace_depth = brace_depth + 1
                    self.advance()
                case RBrace:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                case BlockEnd:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                case _:
                    self.advance()

        val payload_end = self.previous.span.end
        val payload = self.source[payload_start:payload_end]

        # Consume closing brace
        if self.check(TokenKind.RBrace) or self.check(TokenKind.BlockEnd):
            self.advance()

        # Create a Raw block value for inline parsing
        Expr(
            kind: ExprKind.CustomBlock(kind, BlockValue.Raw(payload)),
            span: start.merge(self.previous.span)
        )

    me skip_to_block_end():
        """Skip tokens until reaching the end of a block.

        Used when the block payload has been pre-processed by BlockResolver.
        """
        var brace_depth = 1

        while brace_depth > 0 and not self.is_at_end():
            match self.peek():
                case LBrace:
                    brace_depth = brace_depth + 1
                    self.advance()
                case RBrace:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                    # Don't consume the final }
                case BlockEnd:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                    # Don't consume the final BlockEnd
                case BlockPayload:
                    # Skip raw payload token
                    self.advance()
                case _:
                    self.advance()

    me parse_call_args() -> [CallArg]:
        """Parse function call arguments."""
        var args: [CallArg] = []

        if not self.check(TokenKind.RParen):
            args = args.push(self.parse_call_arg())
            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RParen):
                    break
                args = args.push(self.parse_call_arg())

        args

    me parse_call_arg() -> CallArg:
        """Parse single call argument."""
        val start = self.current.span

        # Check for named argument
        if self.check(TokenKind.Ident):
            val name = self.current.text
            self.advance()
            if self.match_token(TokenKind.Colon):
                val value = self.parse_expr()
                return CallArg(name: Some(name), value: value, span: start.merge(value.span))
            else:
                # Not a named argument, parse as expression
                val expr = Expr(kind: ExprKind.Ident(name), span: start)
                return CallArg(name: nil, value: expr, span: start)

        val value = self.parse_expr()
        CallArg(name: nil, value: value, span: start.merge(value.span))

    me parse_identifier() -> text:
        if self.check(TokenKind.Ident):
            val name = self.current.text
            self.advance()
            name
        else:
            self.error("expected identifier")
            "<error>"

    me parse_type() -> Type:
        """Parse a type expression (reuses outline type parsing logic)."""
        # Create temporary TreeSitter to parse type
        var ts = TreeSitter.new(self.source)
        var ts_lexer = ts.lexer
        ts_lexer.pos = self.lexer.pos
        ts.lexer = ts_lexer
        ts.current = self.current
        ts.previous = self.previous

        val outline = ts.parse_type_outline()
        self.current = ts.current
        self.previous = ts.previous
        var my_lexer = self.lexer
        my_lexer.pos = ts.lexer.pos
        self.lexer = my_lexer

        self.convert_type(outline)

    # ========================================================================
    # Pattern Parsing
    # ========================================================================

    me parse_pattern() -> Pattern:
        """Parse a pattern."""
        val start = self.current.span

        match self.peek():
            case Underscore:
                self.advance()
                Pattern(kind: PatternKind.Wildcard, span: start)

            case IntLit | FloatLit | StringLit | BoolLit | NilLit:
                val expr = self.parse_primary_expr()
                Pattern(kind: PatternKind.Literal(expr), span: start.merge(expr.span))

            case Ident:
                val name = self.current.text
                self.advance()

                if self.match_token(TokenKind.LParen):
                    # Enum pattern
                    self.parse_enum_pattern(name, start)
                elif self.match_token(TokenKind.LBrace):
                    # Struct pattern
                    self.parse_struct_pattern(name, start)
                else:
                    # Binding pattern
                    Pattern(kind: PatternKind.Binding(name, false), span: start)

            case KwVar:
                self.advance()
                val name = self.parse_identifier()
                Pattern(kind: PatternKind.Binding(name, true), span: start.merge(self.previous.span))

            case LParen:
                self.advance()
                if self.check(TokenKind.RParen):
                    self.advance()
                    Pattern(kind: PatternKind.Tuple([]), span: start.merge(self.previous.span))
                else:
                    var elements: [Pattern] = []
                    elements = elements.push(self.parse_pattern())
                    while self.match_token(TokenKind.Comma):
                        if self.check(TokenKind.RParen):
                            break
                        elements = elements.push(self.parse_pattern())
                    self.expect(TokenKind.RParen, "expected ')' after tuple pattern")
                    Pattern(kind: PatternKind.Tuple(elements), span: start.merge(self.previous.span))

            case LBracket:
                self.parse_array_pattern(start)

            case _:
                self.error("expected pattern")
                self.advance()
                Pattern(kind: PatternKind.Error, span: start)

    me parse_enum_pattern(enum_name: text, start: Span) -> Pattern:
        """Parse enum pattern Enum.Variant(...)."""
        var variant = enum_name
        var enum_ = ""

        # Check for Enum.Variant form
        if self.previous.kind == TokenKind.Dot:
            enum_ = enum_name
            variant = self.parse_identifier()

        var payload: EnumPatternPayload? = None

        if not self.check(TokenKind.RParen):
            var patterns: [Pattern] = []
            patterns = patterns.push(self.parse_pattern())
            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RParen):
                    break
                patterns = patterns.push(self.parse_pattern())
            payload = Some(EnumPatternPayload.Tuple(patterns))

        self.expect(TokenKind.RParen, "expected ')' after enum pattern")

        Pattern(
            kind: PatternKind.Enum(enum_, variant, payload),
            span: start.merge(self.previous.span)
        )

    me parse_struct_pattern(type_name: text, start: Span) -> Pattern:
        """Parse struct pattern Type { field, field: pattern }."""
        var fields: [(text, Pattern)] = []

        if not self.check(TokenKind.RBrace):
            val field = self.parse_identifier()
            var pattern: Pattern
            if self.match_token(TokenKind.Colon):
                pattern = self.parse_pattern()
            else:
                pattern = Pattern(kind: PatternKind.Binding(field, false), span: self.previous.span)
            fields = fields.push((field, pattern))

            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RBrace):
                    break
                val f = self.parse_identifier()
                var p: Pattern
                if self.match_token(TokenKind.Colon):
                    p = self.parse_pattern()
                else:
                    p = Pattern(kind: PatternKind.Binding(f, false), span: self.previous.span)
                fields = fields.push((f, p))

        self.expect(TokenKind.RBrace, "expected '}' after struct pattern")

        Pattern(
            kind: PatternKind.Struct(type_name, fields),
            span: start.merge(self.previous.span)
        )

    me parse_array_pattern(start: Span) -> Pattern:
        """Parse array pattern [a, b, ..rest]."""
        self.advance()  # Consume '['

        var elements: [Pattern] = []
        var rest: text? = None

        if not self.check(TokenKind.RBracket):
            if self.match_token(TokenKind.DotDot):
                rest = Some(self.parse_identifier())
            else:
                elements = elements.push(self.parse_pattern())

            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RBracket):
                    break
                if self.match_token(TokenKind.DotDot):
                    rest = Some(self.parse_identifier())
                    break
                elements = elements.push(self.parse_pattern())

        self.expect(TokenKind.RBracket, "expected ']' after array pattern")

        Pattern(
            kind: PatternKind.Array(elements, rest),
            span: start.merge(self.previous.span)
        )

    # ========================================================================
    # Statement and Block Parsing
    # ========================================================================

    me parse_block() -> Block:
        """Parse a block of statements."""
        val start = self.current.span
        var stmts: [Stmt] = []

        self.skip_newlines()

        if self.match_token(TokenKind.Indent):
            while not self.check(TokenKind.Dedent) and not self.is_at_end():
                self.skip_newlines()
                if self.check(TokenKind.Dedent):
                    break
                stmts = stmts.push(self.parse_stmt())
            self.match_token(TokenKind.Dedent)
        else:
            # Single-line block
            stmts = stmts.push(self.parse_stmt())

        Block(stmts: stmts, span: start.merge(self.previous.span))

    me parse_stmt() -> Stmt:
        """Parse a statement."""
        # Guard against nil token
        if not self.current.kind.?:
            val empty_span = Span(start: 0, end: 0, line: 1, col: 1)
            val empty_expr = Expr(kind: ExprKind.Error("unexpected nil token"), span: empty_span)
            return Stmt(kind: StmtKind.Expr(empty_expr), span: empty_span)

        val start = self.current.span

        match self.peek():
            case KwVal:
                self.parse_val_stmt()
            case KwVar:
                self.parse_var_stmt()
            case KwFor:
                self.parse_for_stmt()
            case KwWhile:
                self.parse_while_stmt()
            case KwLoop:
                self.parse_loop_stmt()
            case KwReturn:
                self.advance()
                var value: Expr? = None
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                self.skip_newlines()
                Stmt(kind: StmtKind.Return(value), span: start.merge(self.previous.span))
            case KwBreak:
                self.advance()
                self.skip_newlines()
                Stmt(kind: StmtKind.Break(nil), span: start)
            case KwContinue:
                self.advance()
                self.skip_newlines()
                Stmt(kind: StmtKind.Continue(nil), span: start)
            case KwYield:
                self.advance()
                var value: Expr? = None
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                self.skip_newlines()
                Stmt(kind: StmtKind.Yield(value), span: start.merge(self.previous.span))
            case KwThrow:
                self.advance()
                val value = self.parse_expr()
                self.skip_newlines()
                Stmt(kind: StmtKind.Throw(value), span: start.merge(value.span))
            case _:
                self.parse_expr_or_assign_stmt()

    me parse_val_stmt() -> Stmt:
        """Parse val statement.
        Supports continuation on next line: val x = \n    expr
        """
        val start = self.current.span
        self.advance()  # Consume 'val'

        val name = self.parse_identifier()

        var type_: Type? = None
        if self.match_token(TokenKind.Colon):
            type_ = Some(self.parse_type())

        self.expect(TokenKind.Assign, "expected '=' in val declaration")
        # Skip newlines after = to allow continuation on next line
        self.skip_newlines()
        # Track if we consumed an indent (need to consume matching dedent)
        var consumed_indent = false
        if self.match_token(TokenKind.Indent):
            consumed_indent = true
        val init = self.parse_expr()
        # Consume matching dedent if we consumed an indent
        if consumed_indent:
            self.skip_newlines()
            self.match_token(TokenKind.Dedent)
        self.skip_newlines()

        Stmt(kind: StmtKind.Val(name, type_, init), span: start.merge(init.span))

    me parse_var_stmt() -> Stmt:
        """Parse var statement.
        Supports continuation on next line: var x = \n    expr
        """
        val start = self.current.span
        self.advance()  # Consume 'var'

        val name = self.parse_identifier()

        var type_: Type? = None
        if self.match_token(TokenKind.Colon):
            type_ = Some(self.parse_type())

        var init: Expr? = None
        if self.match_token(TokenKind.Assign):
            # Skip newlines after = to allow continuation on next line
            self.skip_newlines()
            # Track if we consumed an indent (need to consume matching dedent)
            var consumed_indent = false
            if self.match_token(TokenKind.Indent):
                consumed_indent = true
            init = Some(self.parse_expr())
            # Consume matching dedent if we consumed an indent
            if consumed_indent:
                self.skip_newlines()
                self.match_token(TokenKind.Dedent)

        self.skip_newlines()

        Stmt(kind: StmtKind.Var(name, type_, init), span: start.merge(self.previous.span))

    me parse_for_stmt() -> Stmt:
        """Parse for statement."""
        val start = self.current.span
        self.advance()  # Consume 'for'

        val var_ = self.parse_identifier()
        self.expect(TokenKind.KwIn, "expected 'in' in for loop")
        val iter = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after for header")
        val body = self.parse_block()

        Stmt(kind: StmtKind.For(var_, iter, body), span: start.merge(body.span))

    me parse_while_stmt() -> Stmt:
        """Parse while statement."""
        val start = self.current.span
        self.advance()  # Consume 'while'

        val cond = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after while condition")
        val body = self.parse_block()

        Stmt(kind: StmtKind.While(cond, body), span: start.merge(body.span))

    me parse_loop_stmt() -> Stmt:
        """Parse loop statement."""
        val start = self.current.span
        self.advance()  # Consume 'loop'

        self.expect(TokenKind.Colon, "expected ':' after loop")
        val body = self.parse_block()

        Stmt(kind: StmtKind.Loop(body), span: start.merge(body.span))

    me parse_expr_or_assign_stmt() -> Stmt:
        """Parse expression or assignment statement."""
        val start = self.current.span
        val expr = self.parse_expr()

        # Check for assignment
        if self.check(TokenKind.Assign):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, nil, value), span: start.merge(value.span))

        if self.check(TokenKind.PlusEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Add), value), span: start.merge(value.span))

        if self.check(TokenKind.MinusEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Sub), value), span: start.merge(value.span))

        if self.check(TokenKind.StarEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Mul), value), span: start.merge(value.span))

        if self.check(TokenKind.SlashEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Div), value), span: start.merge(value.span))

        if self.check(TokenKind.PercentEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Mod), value), span: start.merge(value.span))

        self.skip_newlines()
        Stmt(kind: StmtKind.Expr(expr), span: expr.span)

# ============================================================================
# Helper Functions
# ============================================================================

fn parse_int_literal(text: text) -> i64:
    """Parse integer literal."""
    # Handle different bases
    if text.starts_with("0x") or text.starts_with("0X"):
        # Hex
        parse_int_base(text[2:], 16)
    elif text.starts_with("0b") or text.starts_with("0B"):
        # Binary
        parse_int_base(text[2:], 2)
    elif text.starts_with("0o") or text.starts_with("0O"):
        # Octal
        parse_int_base(text[2:], 8)
    else:
        # Decimal
        parse_int_base(text, 10)

fn parse_int_base(text: text, base: i64) -> i64:
    """Parse integer in given base."""
    # TODO: Implement proper parsing
    0


# ============================================================================
# Exports
# ============================================================================

export Parser
