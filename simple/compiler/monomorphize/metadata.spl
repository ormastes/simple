# Monomorphization metadata for tracking generic specializations.
#
# This module provides data structures to track:
# - Generic template definitions (functions, structs, enums, traits)
# - Specialization instances and their type bindings
# - Mapping between templates and specialized instances

use hir.{HirType, SymbolId}

# ============================================================================
# Monomorphization Metadata
# ============================================================================

struct MonomorphizationMetadata:
    """Complete monomorphization metadata for a module.

    Stores all generic templates and their specializations for serialization to .smf files.
    """
    functions: Dict<text, GenericFunctionMeta>
    structs: Dict<text, GenericStructMeta>
    enums: Dict<text, GenericEnumMeta>
    traits: Dict<text, GenericTraitMeta>

impl MonomorphizationMetadata:
    static fn new() -> MonomorphizationMetadata:
        """Create a new empty metadata collection."""
        MonomorphizationMetadata { functions: {}, structs: {}, enums: {}, traits: {} }

    fn is_empty() -> bool:
        """Check if metadata is empty (no generic constructs)."""
        self.functions.is_empty() and self.structs.is_empty() and self.enums.is_empty() and self.traits.is_empty()

# ============================================================================
# Generic Template Metadata
# ============================================================================

struct GenericFunctionMeta:
    """Metadata for a generic function template."""
    base_name: text
    generic_params: [text]
    specializations: [SpecializationEntry]

impl GenericFunctionMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericFunctionMeta:
        GenericFunctionMeta { base_name: base_name, generic_params: generic_params, specializations: [] }

struct GenericStructMeta:
    """Metadata for a generic struct template."""
    base_name: text
    generic_params: [text]
    specializations: [SpecializationEntry]

impl GenericStructMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericStructMeta:
        GenericStructMeta { base_name: base_name, generic_params: generic_params, specializations: [] }

struct GenericEnumMeta:
    """Metadata for a generic enum template."""
    base_name: text
    generic_params: [text]
    specializations: [SpecializationEntry]

impl GenericEnumMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericEnumMeta:
        GenericEnumMeta { base_name: base_name, generic_params: generic_params, specializations: [] }

struct GenericTraitMeta:
    """Metadata for a generic trait template."""
    base_name: text
    generic_params: [text]
    impl_specializations: [TraitImplEntry]

impl GenericTraitMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericTraitMeta:
        GenericTraitMeta { base_name: base_name, generic_params: generic_params, impl_specializations: [] }

# ============================================================================
# Specialization Entries
# ============================================================================

struct SpecializationEntry:
    """A single specialization instance.

    Tracks concrete type arguments and the mangled name for a specific
    specialization of a generic template.

    Example: identity<Int> has type_args=[Int], mangled_name="identity$Int"
    """
    type_args: [ConcreteType]
    mangled_name: text
    bindings: Dict<text, ConcreteType>

    # TODO: Add optimization_level field for future profile-guided optimization
    # optimization_level: OptimizationLevel

impl SpecializationEntry:
    static fn new(type_args: [ConcreteType], mangled_name: text, bindings: Dict<text, ConcreteType>) -> SpecializationEntry:
        """Create a specialization entry with explicit bindings."""
        SpecializationEntry { type_args: type_args, mangled_name: mangled_name, bindings: bindings }

    static fn from_key(key: SpecializationKey) -> SpecializationEntry:
        """Create a new specialization entry from a key. Bindings will be filled in later."""
        SpecializationEntry { type_args: key.type_args, mangled_name: key.mangled_name(), bindings: {} }

struct TraitImplEntry:
    """Trait implementation entry.

    Tracks implementations of generic traits for specific types.

    Example: Iterator<Int> impl for List<Int>
      trait_name="Iterator<T>", type_args=[Int], impl_for_type="List<Int>"
    """
    trait_name: text
    type_args: [ConcreteType]
    impl_for_type: text
    mangled_name: text

impl TraitImplEntry:
    static fn new(trait_name: text, type_args: [ConcreteType], impl_for_type: text, mangled_name: text) -> TraitImplEntry:
        TraitImplEntry { trait_name: trait_name, type_args: type_args, impl_for_type: impl_for_type, mangled_name: mangled_name }

# ============================================================================
# Concrete Types and Specialization Keys
# ============================================================================

"""Concrete type for specialization.

Represents a fully-resolved type with no type parameters.
Used as arguments when instantiating generic templates.
"""
enum ConcreteType:
    # Primitives
    Int
    Float
    Bool
    String
    Unit

    # Composite
    Array(element: ConcreteType)
    Tuple(elements: [ConcreteType])

    # User-defined (with fully specialized type arguments)
    Named(name: text, args: [ConcreteType])

    # Special
    Any
    Never

impl ConcreteType:
    fn to_string() -> text:
        """Convert concrete type to string representation."""
        match self:
            case Int: "Int"
            case Float: "Float"
            case Bool: "Bool"
            case String: "String"
            case Unit: "Unit"
            case Array(elem): "[{elem.to_string()}]"
            case Tuple(elems):
                val elem_strs = elems.map(\e: e.to_string()).join(", ")
                "({elem_strs})"
            case Named(name, args):
                if args.is_empty():
                    name
                else:
                    val arg_strs = args.map(\a: a.to_string()).join(", ")
                    "{name}<{arg_strs}>"
            case Any: "Any"
            case Never: "Never"

struct SpecializationKey:
    """Key for identifying a unique specialization.

    Combines base template name with concrete type arguments.
    Used for caching and deduplication of specializations.

    Example: ("identity", [Int]) identifies the Int specialization of identity<T>
    """
    base_name: text
    type_args: [ConcreteType]

impl SpecializationKey:
    static fn new(base_name: text, type_args: [ConcreteType]) -> SpecializationKey:
        SpecializationKey { base_name: base_name, type_args: type_args }

    fn mangled_name() -> text:
        """Generate mangled name for this specialization.

        Format: base_name$type1$type2$...
        Example: identity<Int> -> "identity$Int"
                 map<Int,Float> -> "map$Int$Float"
        """
        if self.type_args.is_empty():
            self.base_name
        else:
            val type_strs = self.type_args.map(\t: t.to_string()).join("$")
            "{self.base_name}${type_strs}"

    fn to_string() -> text:
        """Human-readable string representation."""
        if self.type_args.is_empty():
            self.base_name
        else:
            val type_strs = self.type_args.map(\t: t.to_string()).join(", ")
            "{self.base_name}<{type_strs}>"

# ============================================================================
# Exports
# ============================================================================

pub use MonomorphizationMetadata
pub use GenericFunctionMeta, GenericStructMeta, GenericEnumMeta, GenericTraitMeta
pub use SpecializationEntry, TraitImplEntry
pub use ConcreteType, SpecializationKey
