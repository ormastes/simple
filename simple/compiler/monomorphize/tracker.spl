# Compile-time tracking of generic instantiations.
#
# This module tracks instantiations during compilation to populate
# the note.sdn section for lazy instantiation and dependency analysis.
#
# Phase 3: Compile-Time Tracking

use note_sdn.*
use cycle_detector.*

# ============================================================================
# Instantiation Tracker
# ============================================================================

struct InstantiationTracker:
    """Tracks instantiations during compilation."""
    metadata: NoteSdnMetadata
    next_inst_id: i32
    tracked_names: Set<text>
    current_file: text
    current_obj: text
    pending_deps: [(text, text, DependencyKind)]

impl InstantiationTracker:
    static fn new(source_file: text, obj_file: text) -> InstantiationTracker:
        """Create a new tracker for a compilation unit."""
        InstantiationTracker(
            metadata: NoteSdnMetadata.new(),
            next_inst_id: 0,
            tracked_names: {},
            current_file: source_file,
            current_obj: obj_file,
            pending_deps: []
        )

    fn current_file() -> text:
        """Get the current source file."""
        self.current_file

    me set_current_file(file: text):
        """Set the current source file."""
        self.current_file = file

    me track_instantiation(
        template: text,
        type_args: [text],
        mangled_name: text,
        source_loc: text,
        status: InstantiationStatus
    ):
        """Track a compiled instantiation."""
        # Skip if already tracked
        if self.tracked_names.contains(mangled_name):
            return

        val entry = InstantiationEntry(
            template: template,
            type_args: type_args.join(","),
            mangled_name: mangled_name,
            from_file: self.current_file,
            from_loc: source_loc,
            to_obj: self.current_obj,
            status: status
        )

        self.metadata = self.metadata.add_instantiation(entry)
        self.tracked_names = self.tracked_names.insert(mangled_name)
        self.next_inst_id = self.next_inst_id + 1

        # Process pending dependencies
        self.flush_pending_deps()

    me track_possible(
        template: text,
        type_args: [text],
        mangled_name: text,
        required_by: text,
        can_defer: bool
    ):
        """Track a possible (deferrable) instantiation."""
        # Skip if already tracked as compiled
        if self.tracked_names.contains(mangled_name):
            return

        val entry = PossibleInstantiationEntry(
            template: template,
            type_args: type_args.join(","),
            mangled_name: mangled_name,
            required_by: required_by,
            can_defer: can_defer
        )

        self.metadata = self.metadata.add_possible(entry)

    me track_type_inference(
        inferred_type: text,
        expr: text,
        context: text,
        source_loc: text
    ):
        """Track a type inference event."""
        val entry = TypeInferenceEntry(
            inferred_type: inferred_type,
            expr: expr,
            context: context,
            from_file: self.current_file,
            from_loc: source_loc
        )

        self.metadata = self.metadata.add_type_inference(entry)

    me track_dependency(
        from_inst: text,
        to_inst: text,
        dep_kind: DependencyKind
    ):
        """Track a dependency between instantiations."""
        # If from_inst is not yet tracked, queue the dependency
        if not self.tracked_names.contains(from_inst):
            self.pending_deps = self.pending_deps.push((from_inst, to_inst, dep_kind))
            return

        val edge = DependencyEdge(
            from_inst: from_inst,
            to_inst: to_inst,
            dep_kind: dep_kind
        )

        self.metadata = self.metadata.add_dependency(edge)

    me flush_pending_deps():
        """Flush pending dependencies that can now be added."""
        var remaining: [(text, text, DependencyKind)] = []

        for (from, to, kind) in self.pending_deps:
            if self.tracked_names.contains(from):
                val edge = DependencyEdge(
                    from_inst: from,
                    to_inst: to,
                    dep_kind: kind
                )
                self.metadata = self.metadata.add_dependency(edge)
            else:
                remaining = remaining.push((from, to, kind))

        self.pending_deps = remaining

    me analyze_cycles():
        """Analyze for circular dependencies and update metadata."""
        self.metadata = analyze_and_update_cycles(self.metadata)

    fn has_circular_errors() -> bool:
        """Check if there are any circular errors."""
        not self.metadata.circular_errors.is_empty()

    fn circular_errors() -> [CircularError]:
        """Get circular errors."""
        self.metadata.circular_errors

    fn circular_warnings() -> [CircularWarning]:
        """Get circular warnings."""
        self.metadata.circular_warnings

    fn finalize() -> NoteSdnMetadata:
        """Finalize tracking and return the metadata."""
        # Flush any remaining pending deps
        self.flush_pending_deps()
        # Analyze cycles
        self.analyze_cycles()
        self.metadata

    fn get_metadata() -> NoteSdnMetadata:
        """Get a reference to the current metadata (for inspection)."""
        self.metadata

    me merge(other: NoteSdnMetadata):
        """Merge metadata from another tracker (for multi-file compilation)."""
        for inst in other.instantiations:
            if not self.tracked_names.contains(inst.mangled_name):
                self.tracked_names = self.tracked_names.insert(inst.mangled_name)
                self.metadata = self.metadata.add_instantiation(inst)

        for poss in other.possible:
            if not self.tracked_names.contains(poss.mangled_name):
                self.metadata = self.metadata.add_possible(poss)

        for inf in other.type_inferences:
            self.metadata = self.metadata.add_type_inference(inf)

        for dep in other.dependencies:
            self.metadata = self.metadata.add_dependency(dep)

        # Re-analyze cycles after merge
        self.analyze_cycles()

# ============================================================================
# Tracking Context
# ============================================================================

struct TrackingContext:
    """Builder for tracking instantiations during monomorphization."""
    tracker: InstantiationTracker
    current_template: text
    current_type_args: [text]
    current_mangled: text

impl TrackingContext:
    static fn start(
        tracker: InstantiationTracker,
        template: text,
        type_args: [text],
        mangled_name: text
    ) -> TrackingContext:
        """Start tracking a new instantiation."""
        TrackingContext(
            tracker: tracker,
            current_template: template,
            current_type_args: type_args,
            current_mangled: mangled_name
        )

    me depends_on(to_inst: text, kind: DependencyKind):
        """Record that this instantiation depends on another type."""
        self.tracker.track_dependency(self.current_mangled, to_inst, kind)

    me depends_on_type_param(type_name: text):
        """Record a type parameter dependency."""
        self.depends_on(type_name, DependencyKind.TypeParam)

    me depends_on_field_type(type_name: text):
        """Record a field type dependency."""
        self.depends_on(type_name, DependencyKind.FieldType)

    fn complete(source_loc: text, status: InstantiationStatus) -> InstantiationTracker:
        """Complete the instantiation tracking."""
        self.tracker.track_instantiation(
            self.current_template,
            self.current_type_args,
            self.current_mangled,
            source_loc,
            status
        )
        self.tracker

    fn get_tracker() -> InstantiationTracker:
        """Get the tracker (for chaining)."""
        self.tracker

# ============================================================================
# Exports
# ============================================================================

export InstantiationTracker
export TrackingContext
