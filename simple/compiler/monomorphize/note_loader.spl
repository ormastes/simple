# note.sdn section loader for SMF files.
#
# This module reads and parses the note.sdn section from SMF files,
# enabling lazy instantiation and circular dependency detection.
#
# Phase 2: note.sdn Reading (Loader)

# ============================================================================
# Constants
# ============================================================================

val NOTE_SDN_TERMINATOR = "\n# END_NOTE\n"

# ============================================================================
# Loaded Data Structures
# ============================================================================

struct LoadedNoteSdn:
    """Loaded note.sdn metadata from an SMF file."""
    instantiations: [LoadedInstantiation]
    possible: [LoadedPossible]
    type_inferences: [LoadedTypeInference]
    dependencies: [LoadedDependency]
    circular_warnings: [LoadedCircularWarning]
    circular_errors: [LoadedCircularError]

impl LoadedNoteSdn:
    static fn new() -> LoadedNoteSdn:
        LoadedNoteSdn(
            instantiations: [],
            possible: [],
            type_inferences: [],
            dependencies: [],
            circular_warnings: [],
            circular_errors: []
        )

    fn is_empty() -> bool:
        self.instantiations.is_empty() and
        self.possible.is_empty() and
        self.type_inferences.is_empty() and
        self.dependencies.is_empty() and
        self.circular_warnings.is_empty() and
        self.circular_errors.is_empty()

    fn find_instantiation(mangled_name: text) -> LoadedInstantiation?:
        """Find an instantiation by mangled name."""
        for inst in self.instantiations:
            if inst.mangled_name == mangled_name:
                return Some(inst)
        None

    fn find_possible(mangled_name: text) -> LoadedPossible?:
        """Find a possible instantiation by mangled name."""
        for poss in self.possible:
            if poss.mangled_name == mangled_name:
                return Some(poss)
        None

    fn get_dependencies_from(from_inst: text) -> [LoadedDependency]:
        """Get all dependencies from a given instantiation."""
        self.dependencies.filter(\d: d.from_inst == from_inst)

    fn get_dependencies_to(to_inst: text) -> [LoadedDependency]:
        """Get all dependencies to a given instantiation."""
        self.dependencies.filter(\d: d.to_inst == to_inst)

    fn has_circular_errors() -> bool:
        not self.circular_errors.is_empty()

    fn build_dependency_graph() -> Dict<text, [text]>:
        """Build a dependency graph as adjacency list."""
        var graph: Dict<text, [text]> = {}
        for dep in self.dependencies:
            if graph.contains_key(dep.from_inst):
                graph[dep.from_inst] = graph[dep.from_inst].push(dep.to_inst)
            else:
                graph[dep.from_inst] = [dep.to_inst]
        graph

struct LoadedInstantiation:
    """A loaded instantiation entry."""
    id: i32
    template: text
    type_args: text
    mangled_name: text
    from_file: text
    from_loc: text
    to_obj: text
    status: text

struct LoadedPossible:
    """A loaded possible instantiation entry."""
    id: i32
    template: text
    type_args: text
    mangled_name: text
    required_by: text
    can_defer: bool

struct LoadedTypeInference:
    """A loaded type inference entry."""
    id: i32
    inferred_type: text
    expr: text
    context: text
    from_file: text
    from_loc: text

struct LoadedDependency:
    """A loaded dependency edge."""
    from_inst: text
    to_inst: text
    dep_kind: text

struct LoadedCircularWarning:
    """A loaded circular warning."""
    id: i32
    cycle_path: text
    severity: text

struct LoadedCircularError:
    """A loaded circular error."""
    id: i32
    cycle_path: text
    error_code: text

# ============================================================================
# Parsing Functions
# ============================================================================

fn parse_note_sdn(content: text) -> Result<LoadedNoteSdn, text>:
    """Parse SDN content into LoadedNoteSdn."""
    var result = LoadedNoteSdn.new()
    var current_table: text? = None
    var columns: [text] = []

    for line in content.lines():
        val trimmed = line.trim()

        # Skip empty lines and comments
        if trimmed.is_empty() or (trimmed.starts_with("#") and not trimmed.contains("|")):
            continue

        # Check for table header
        if trimmed.contains("|") and not trimmed.starts_with("\"") and not trimmed[0].is_digit():
            val parts = trimmed.split("|", limit: 2)
            if parts.len() >= 2:
                val table_name = parts[0].trim()
                val cols_str = parts[1].trim_end("|")
                columns = cols_str.split(",").map(\s: s.trim())
                current_table = match table_name:
                    case "instantiations": Some("instantiations")
                    case "possible": Some("possible")
                    case "type_inferences": Some("type_inferences")
                    case "dependencies": Some("dependencies")
                    case "circular_warnings": Some("circular_warnings")
                    case "circular_errors": Some("circular_errors")
                    case _: None
            continue

        # Parse data row
        if current_table.?:
            val values = parse_sdn_row(trimmed)?
            val table = current_table.unwrap()

            match table:
                case "instantiations":
                    if values.len() >= 8:
                        result.instantiations = result.instantiations.push(LoadedInstantiation(
                            id: values[0].parse_int() ?? 0,
                            template: unescape_sdn(values[1]),
                            type_args: unescape_sdn(values[2]),
                            mangled_name: unescape_sdn(values[3]),
                            from_file: unescape_sdn(values[4]),
                            from_loc: unescape_sdn(values[5]),
                            to_obj: unescape_sdn(values[6]),
                            status: unescape_sdn(values[7])
                        ))

                case "possible":
                    if values.len() >= 6:
                        result.possible = result.possible.push(LoadedPossible(
                            id: values[0].parse_int() ?? 0,
                            template: unescape_sdn(values[1]),
                            type_args: unescape_sdn(values[2]),
                            mangled_name: unescape_sdn(values[3]),
                            required_by: unescape_sdn(values[4]),
                            can_defer: values[5].trim() == "true"
                        ))

                case "type_inferences":
                    if values.len() >= 6:
                        result.type_inferences = result.type_inferences.push(LoadedTypeInference(
                            id: values[0].parse_int() ?? 0,
                            inferred_type: unescape_sdn(values[1]),
                            expr: unescape_sdn(values[2]),
                            context: unescape_sdn(values[3]),
                            from_file: unescape_sdn(values[4]),
                            from_loc: unescape_sdn(values[5])
                        ))

                case "dependencies":
                    if values.len() >= 3:
                        result.dependencies = result.dependencies.push(LoadedDependency(
                            from_inst: unescape_sdn(values[0]),
                            to_inst: unescape_sdn(values[1]),
                            dep_kind: unescape_sdn(values[2])
                        ))

                case "circular_warnings":
                    if values.len() >= 3:
                        result.circular_warnings = result.circular_warnings.push(LoadedCircularWarning(
                            id: values[0].parse_int() ?? 0,
                            cycle_path: unescape_sdn(values[1]),
                            severity: unescape_sdn(values[2])
                        ))

                case "circular_errors":
                    if values.len() >= 3:
                        result.circular_errors = result.circular_errors.push(LoadedCircularError(
                            id: values[0].parse_int() ?? 0,
                            cycle_path: unescape_sdn(values[1]),
                            error_code: unescape_sdn(values[2])
                        ))

                case _: pass

    Ok(result)

fn parse_sdn_row(line: text) -> Result<[text], text>:
    """Parse an SDN data row into values."""
    var values: [text] = []
    var current = ""
    var in_quotes = false
    var escape_next = false

    for ch in line.chars():
        if escape_next:
            current = current + ch.to_string()
            escape_next = false
            continue

        match ch:
            case '\\':
                escape_next = true
            case '"':
                in_quotes = not in_quotes
            case ',':
                if not in_quotes:
                    values = values.push(current.trim())
                    current = ""
                else:
                    current = current + ch.to_string()
            case _:
                current = current + ch.to_string()

    # Don't forget the last value
    if not current.is_empty():
        values = values.push(current.trim())

    Ok(values)

fn unescape_sdn(s: text) -> text:
    """Unescape SDN string values."""
    var result = s.trim()

    # Remove surrounding quotes
    if result.starts_with("\"") and result.ends_with("\""):
        result = result[1:-1]

    result
        .replace("\\\"", "\"")
        .replace("\\\\", "\\")
        .replace("\\n", "\n")
        .replace("\\r", "\r")
        .replace("\\t", "\t")

fn read_until_terminator(content: text, terminator: text) -> text?:
    """Read content until terminator is found."""
    val pos = content.index_of(terminator)
    if pos.?:
        Some(content[0:pos.unwrap() + terminator.len()])
    else:
        None

# ============================================================================
# Exports
# ============================================================================

export LoadedNoteSdn
export LoadedInstantiation, LoadedPossible, LoadedTypeInference
export LoadedDependency, LoadedCircularWarning, LoadedCircularError
export parse_note_sdn, parse_sdn_row, unescape_sdn
export NOTE_SDN_TERMINATOR
