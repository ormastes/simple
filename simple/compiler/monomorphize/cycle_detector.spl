# Circular dependency detection for template instantiations.
#
# This module analyzes the dependency graph from note.sdn to detect:
# - Hard cycles (E0420): Direct circular dependencies that are not allowed
# - Soft cycles (warning): Cycles broken by indirection (e.g., through Option<T>)
#
# Phase 6: Circular Dependency Detection

import note_sdn.*

# ============================================================================
# Result Types
# ============================================================================

struct CycleDetectionResult:
    """Result of cycle detection analysis."""
    errors: [CircularError]
    warnings: [CircularWarning]
    all_cycles: [[text]]

impl CycleDetectionResult:
    static fn new() -> CycleDetectionResult:
        CycleDetectionResult(
            errors: [],
            warnings: [],
            all_cycles: []
        )

    fn has_errors() -> bool:
        not self.errors.is_empty()

    fn has_warnings() -> bool:
        not self.warnings.is_empty()

    fn is_clean() -> bool:
        self.errors.is_empty() and self.warnings.is_empty()

    fn add_error(error: CircularError):
        self.errors = self.errors.push(error)

    fn add_warning(warning: CircularWarning):
        self.warnings = self.warnings.push(warning)

    fn add_cycle(cycle: [text]):
        self.all_cycles = self.all_cycles.push(cycle)

# ============================================================================
# Cycle Detection
# ============================================================================

fn detect_cycles(metadata: NoteSdnMetadata) -> CycleDetectionResult:
    """Detect circular dependencies in the instantiation graph."""
    var result = CycleDetectionResult.new()

    # Build adjacency list from dependencies
    val graph = build_graph(metadata.dependencies)

    # Find all cycles using DFS
    val cycles = find_all_cycles(graph)

    # Classify each cycle as hard error or soft warning
    for cycle in cycles:
        val cycle_path = cycle.join("->")

        if is_hard_cycle(cycle, metadata.dependencies):
            result.add_error(CircularError.new(cycle_path, "E0420"))
        else:
            result.add_warning(CircularWarning.new(cycle_path, "warning"))

        result.add_cycle(cycle)

    result

fn build_graph(dependencies: [DependencyEdge]) -> Dict<text, [text]>:
    """Build adjacency list from dependency edges."""
    var graph: Dict<text, [text]> = {}

    for dep in dependencies:
        if graph.contains_key(dep.from_inst):
            graph[dep.from_inst] = graph[dep.from_inst].push(dep.to_inst)
        else:
            graph[dep.from_inst] = [dep.to_inst]

    graph

fn find_all_cycles(graph: Dict<text, [text]>) -> [[text]]:
    """Find all cycles in the graph using DFS."""
    var cycles: [[text]] = []
    var visited: Set<text> = {}
    var rec_stack: Set<text> = {}
    var path: [text] = []

    # Get all nodes
    var all_nodes: Set<text> = {}
    for key in graph.keys():
        all_nodes = all_nodes.insert(key)
    for edges in graph.values():
        for edge in edges:
            all_nodes = all_nodes.insert(edge)

    # DFS from each node
    for node in all_nodes:
        if not visited.contains(node):
            val found_cycles = find_cycles_dfs(node, graph, visited, rec_stack, path)
            for cycle in found_cycles:
                cycles = cycles.push(cycle)
            visited = visited.insert(node)

    cycles

fn find_cycles_dfs(
    node: text,
    graph: Dict<text, [text]>,
    visited: Set<text>,
    rec_stack: Set<text>,
    path: [text]
) -> [[text]]:
    """DFS helper to find cycles."""
    var cycles: [[text]] = []
    var local_visited = visited.insert(node)
    var local_rec_stack = rec_stack.insert(node)
    var local_path = path.push(node)

    if graph.contains_key(node):
        for neighbor in graph[node]:
            if not local_visited.contains(neighbor):
                val found = find_cycles_dfs(neighbor, graph, local_visited, local_rec_stack, local_path)
                for cycle in found:
                    cycles = cycles.push(cycle)
            elif local_rec_stack.contains(neighbor):
                # Found a cycle! Extract it from the path
                var cycle_start_idx = 0
                for i in 0..local_path.len():
                    if local_path[i] == neighbor:
                        cycle_start_idx = i
                        break
                var cycle: [text] = []
                for i in cycle_start_idx..local_path.len():
                    cycle = cycle.push(local_path[i])
                cycle = cycle.push(neighbor)  # Complete the cycle
                cycles = cycles.push(cycle)

    cycles

fn is_hard_cycle(cycle: [text], dependencies: [DependencyEdge]) -> bool:
    """Determine if a cycle is a 'hard' cycle (error) or 'soft' cycle (warning).

    A cycle is 'soft' if it's broken by an indirection type like Option<T>,
    which allows the cycle to exist at runtime through null/None values.
    """
    # Check if any edge in the cycle goes through an indirection type
    for i in 0..(cycle.len() - 1):
        val from = cycle[i]
        val to = cycle[i + 1]

        # Find the dependency edge
        for dep in dependencies:
            if dep.from_inst == from and dep.to_inst == to:
                # InnerType dependency through Option/Result breaks the cycle
                if dep.dep_kind == DependencyKind.InnerType:
                    # Check if it's through an Option or similar nullable type
                    if from.contains("Option") or from.contains("Result") or from.contains("Nullable"):
                        return false  # Soft cycle
                break

    # No indirection found - hard cycle
    true

# ============================================================================
# Type Inference Cycle Detection
# ============================================================================

fn detect_type_inference_cycles(inference_deps: [(text, text)]) -> [CircularError]:
    """Detect cycles specifically for type inference dependencies."""
    var errors: [CircularError] = []

    # Build graph
    var graph: Dict<text, [text]> = {}
    for (from, to) in inference_deps:
        if graph.contains_key(from):
            graph[from] = graph[from].push(to)
        else:
            graph[from] = [to]

    # Find cycles
    val cycles = find_all_cycles(graph)

    # All type inference cycles are errors (E0421)
    for cycle in cycles:
        val cycle_path = cycle.join("->")
        errors = errors.push(CircularError.new(cycle_path, "E0421"))

    errors

# ============================================================================
# Metadata Update
# ============================================================================

fn analyze_and_update_cycles(metadata: NoteSdnMetadata) -> NoteSdnMetadata:
    """Analyze metadata and update it with detected cycles."""
    var result = metadata
    val detection = detect_cycles(metadata)

    # Add detected errors and warnings to metadata
    for error in detection.errors:
        result = result.add_circular_error(error)

    for warning in detection.warnings:
        result = result.add_circular_warning(warning)

    result

# ============================================================================
# Cycle Prevention
# ============================================================================

fn would_create_cycle(
    metadata: NoteSdnMetadata,
    new_from: text,
    new_to: text
) -> [text]?:
    """Check if adding a new dependency would create a cycle."""
    # Build graph with the new edge
    var graph = build_graph(metadata.dependencies)
    if graph.contains_key(new_from):
        graph[new_from] = graph[new_from].push(new_to)
    else:
        graph[new_from] = [new_to]

    # Check for path from new_to back to new_from (which would create cycle)
    var visited: Set<text> = {}
    var path: [text] = [new_to]

    if has_path_dfs(new_to, new_from, graph, visited, path):
        Some(path)
    else:
        None

fn has_path_dfs(
    current: text,
    target: text,
    graph: Dict<text, [text]>,
    visited: Set<text>,
    path: [text]
) -> bool:
    """Check if there's a path from current to target."""
    if current == target:
        return true

    if visited.contains(current):
        return false

    var local_visited = visited.insert(current)

    if graph.contains_key(current):
        for neighbor in graph[current]:
            var local_path = path.push(neighbor)
            if has_path_dfs(neighbor, target, graph, local_visited, local_path):
                return true

    false

# ============================================================================
# Topological Sort
# ============================================================================

fn topological_sort(metadata: NoteSdnMetadata) -> [text]?:
    """Topological sort of the dependency graph.

    Returns None if the graph has cycles.
    """
    val graph = build_graph(metadata.dependencies)

    # Calculate in-degrees
    var in_degree: Dict<text, i32> = {}
    var all_nodes: Set<text> = {}

    for key in graph.keys():
        all_nodes = all_nodes.insert(key)

    for edges in graph.values():
        for edge in edges:
            all_nodes = all_nodes.insert(edge)
            val current = in_degree.get(edge) ?? 0
            in_degree[edge] = current + 1

    # Initialize in-degrees for nodes with no incoming edges
    for node in all_nodes:
        if not in_degree.contains_key(node):
            in_degree[node] = 0

    # Kahn's algorithm
    var queue: [text] = []
    for (node, deg) in in_degree:
        if deg == 0:
            queue = queue.push(node)

    var result: [text] = []

    while not queue.is_empty():
        val node = queue[0]
        queue = queue[1:]
        result = result.push(node)

        if graph.contains_key(node):
            for neighbor in graph[node]:
                if in_degree.contains_key(neighbor):
                    val new_deg = in_degree[neighbor] - 1
                    in_degree[neighbor] = new_deg
                    if new_deg == 0:
                        queue = queue.push(neighbor)

    # If we processed all nodes, no cycle exists
    if result.len() == all_nodes.len():
        Some(result)
    else:
        None  # Cycle detected

# ============================================================================
# Exports
# ============================================================================

export CycleDetectionResult
export detect_cycles, detect_type_inference_cycles
export analyze_and_update_cycles, would_create_cycle
export topological_sort
