# MIR - Mid-level Intermediate Representation
#
# Lower-level IR between HIR and native code generation.
# Features:
# - Explicit control flow (basic blocks, terminators)
# - Explicit memory operations (load, store, alloc)
# - SSA form (each value defined once)
# - Type-annotated values
# - Ready for optimization and codegen
#
# HIR -> MIR lowering:
# - Flatten nested expressions to SSA
# - Convert control flow to basic blocks
# - Make memory operations explicit
# - Insert drops and moves

use hir.*
use lexer.Span
use blocks.value.BlockValue

# ============================================================================
# MIR Module Structure
# ============================================================================

struct MirModule:
    """Complete MIR module."""
    name: text
    functions: Dict<SymbolId, MirFunction>
    statics: Dict<SymbolId, MirStatic>
    constants: Dict<SymbolId, MirConstant>
    types: Dict<SymbolId, MirTypeDef>

struct MirFunction:
    """Function in MIR."""
    symbol: SymbolId
    name: text
    signature: MirSignature
    locals: [MirLocal]
    blocks: [MirBlock]
    entry_block: BlockId
    span: Span

struct MirSignature:
    """Function signature."""
    params: [MirType]
    return_type: MirType
    is_variadic: bool

struct MirLocal:
    """Local variable slot."""
    id: LocalId
    name: text?
    type_: MirType
    kind: LocalKind

struct LocalId:
    """Local variable identifier."""
    id: i64

"""Kind of local variable."""
enum LocalKind:
    Arg(index: i64)     # Function argument
    Var                  # Regular variable
    Temp                 # Temporary (SSA)
    Return               # Return slot

struct MirStatic:
    """Static/global variable."""
    symbol: SymbolId
    name: text
    type_: MirType
    init: MirConstant?
    is_mutable: bool

struct MirConstant:
    """Compile-time constant."""
    symbol: SymbolId
    name: text
    type_: MirType
    value: MirConstValue

"""Constant value."""
enum MirConstValue:
    Int(value: i64)
    Float(value: f64)
    Bool(value: bool)
    Str(value: text)
    Array(elements: [MirConstValue])
    Tuple(elements: [MirConstValue])
    Struct(fields: Dict<text, MirConstValue>)
    Zero                 # Zero-initialized

struct MirTypeDef:
    """Type definition."""
    symbol: SymbolId
    name: text
    kind: MirTypeDefKind

"""Type definition kind."""
enum MirTypeDefKind:
    Struct(fields: [MirFieldDef])
    Enum(variants: [MirVariantDef])
    Union(variants: [MirType])

struct MirFieldDef:
    """Struct field definition."""
    name: text
    type_: MirType
    offset: i64

struct MirVariantDef:
    """Enum variant definition."""
    name: text
    discriminant: i64
    payload: MirType?

# ============================================================================
# MIR Types
# ============================================================================

struct MirType:
    """MIR type."""
    kind: MirTypeKind

"""MIR type kind."""
enum MirTypeKind:
    # Primitives
    I8, I16, I32, I64
    U8, U16, U32, U64
    F32, F64
    Bool
    Char
    Unit

    # Pointers and references
    Ptr(pointee: MirType, mutable: bool)
    Ref(referent: MirType, mutable: bool)
    FuncPtr(signature: MirSignature)

    # Aggregates
    Array(element: MirType, size: i64)
    Slice(element: MirType)
    Tuple(elements: [MirType])
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId)

    # Special
    Never              # !
    Opaque(name: text) # Foreign type

impl MirType:
    static fn i64() -> MirType:
        MirType(kind: MirTypeKind.I64)

    static fn f64() -> MirType:
        MirType(kind: MirTypeKind.F64)

    static fn bool() -> MirType:
        MirType(kind: MirTypeKind.Bool)

    static fn unit() -> MirType:
        MirType(kind: MirTypeKind.Unit)

    static fn ptr(pointee: MirType, mutable: bool) -> MirType:
        MirType(kind: MirTypeKind.Ptr(pointee, mutable))

    fn size_bytes() -> i64:
        """Get size in bytes."""
        match self.kind:
            case I8 | U8 | Bool: 1
            case I16 | U16 | Char: 2
            case I32 | U32 | F32: 4
            case I64 | U64 | F64 | Ptr(_, _) | Ref(_, _) | FuncPtr(_): 8
            case Unit | Never: 0
            case Array(elem, size): elem.size_bytes() * size
            case Tuple(elements):
                var total = 0
                for e in elements:
                    total = total + e.size_bytes()
                total
            case _: 8  # Default pointer size

    fn alignment() -> i64:
        """Get alignment in bytes."""
        match self.kind:
            case I8 | U8 | Bool: 1
            case I16 | U16 | Char: 2
            case I32 | U32 | F32: 4
            case I64 | U64 | F64 | Ptr(_, _) | Ref(_, _) | FuncPtr(_): 8
            case Unit | Never: 1
            case Array(elem, _): elem.alignment()
            case Tuple(elements):
                var max_align = 1
                for e in elements:
                    val align = e.alignment()
                    if align > max_align:
                        max_align = align
                max_align
            case _: 8

# ============================================================================
# MIR Basic Blocks
# ============================================================================

struct BlockId:
    """Basic block identifier."""
    id: i64

impl BlockId:
    static fn new(id: i64) -> BlockId:
        BlockId(id: id)

    static fn entry() -> BlockId:
        BlockId(id: 0)

struct MirBlock:
    """Basic block."""
    id: BlockId
    label: text?
    instructions: [MirInst]
    terminator: MirTerminator

# ============================================================================
# MIR Instructions
# ============================================================================

struct MirInst:
    """MIR instruction."""
    kind: MirInstKind
    span: Span?

"""MIR instruction kind."""
enum MirInstKind:
    # Constants
    Const(dest: LocalId, value: MirConstValue, type_: MirType)

    # Moves and copies
    Copy(dest: LocalId, src: LocalId)
    Move(dest: LocalId, src: LocalId)

    # Arithmetic
    BinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)
    UnaryOp(dest: LocalId, op: MirUnaryOp, operand: MirOperand)
    CheckedBinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)

    # Memory
    Alloc(dest: LocalId, type_: MirType)
    Load(dest: LocalId, ptr: MirOperand)
    Store(ptr: MirOperand, value: MirOperand)
    GetElementPtr(dest: LocalId, base: MirOperand, indices: [MirOperand])

    # Aggregates
    Aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand])
    GetField(dest: LocalId, base: MirOperand, field: i64)
    SetField(base: MirOperand, field: i64, value: MirOperand)

    # Casts
    Cast(dest: LocalId, operand: MirOperand, target: MirType)
    Bitcast(dest: LocalId, operand: MirOperand, target: MirType)

    # Function calls
    Call(dest: LocalId?, func: MirOperand, args: [MirOperand])
    CallIndirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature)

    # Intrinsics
    Intrinsic(dest: LocalId?, name: text, args: [MirOperand])

    # Debug
    DebugValue(local: LocalId, name: text)
    Nop

"""Binary operation."""
enum MirBinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Rem
    Pow                         # **
    # Matrix operations
    MatMul                      # @
    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr
    # Comparison
    Eq, Ne, Lt, Le, Gt, Ge
    # Broadcast operations (dotted operators)
    BroadcastAdd                # .+
    BroadcastSub                # .-
    BroadcastMul                # .*
    BroadcastDiv                # ./
    BroadcastPow                # .^
    # Offset
    Offset  # Pointer arithmetic

"""Unary operation."""
enum MirUnaryOp:
    Neg
    Not
    BitNot
    Transpose   # ' (postfix, m{} only)

"""Aggregate construction kind."""
enum AggregateKind:
    Array(type_: MirType)
    Tuple
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId, variant: i64)

struct MirOperand:
    """Instruction operand."""
    kind: MirOperandKind

"""Operand kind."""
enum MirOperandKind:
    Copy(local: LocalId)
    Move(local: LocalId)
    Const(value: MirConstValue, type_: MirType)

impl MirOperand:
    static fn copy(local: LocalId) -> MirOperand:
        MirOperand(kind: MirOperandKind.Copy(local))

    static fn move(local: LocalId) -> MirOperand:
        MirOperand(kind: MirOperandKind.Move(local))

    static fn const_int(value: i64) -> MirOperand:
        MirOperand(kind: MirOperandKind.Const(MirConstValue.Int(value), MirType.i64()))

    static fn const_float(value: f64) -> MirOperand:
        MirOperand(kind: MirOperandKind.Const(MirConstValue.Float(value), MirType.f64()))

    static fn const_bool(value: bool) -> MirOperand:
        MirOperand(kind: MirOperandKind.Const(MirConstValue.Bool(value), MirType.bool()))

# ============================================================================
# MIR Terminators
# ============================================================================

"""Block terminator."""
enum MirTerminator:
    # Unconditional
    Goto(target: BlockId)
    Return(value: MirOperand?)

    # Conditional
    If(cond: MirOperand, then_: BlockId, else_: BlockId)
    Switch(value: MirOperand, targets: [(i64, BlockId)], default: BlockId)

    # Exceptional
    Unreachable
    Abort(message: text)

    # Call terminators (for unwinding)
    CallTerminator(
        dest: LocalId?,
        func: MirOperand,
        args: [MirOperand],
        normal: BlockId,
        unwind: BlockId?
    )

# ============================================================================
# MIR Builder
# ============================================================================

struct MirBuilder:
    """Builder for constructing MIR."""
    module: MirModule
    current_function: MirFunction?
    current_block: BlockId
    next_local_id: i64
    next_block_id: i64
    locals: [MirLocal]
    blocks: [MirBlock]
    instructions: [MirInst]

impl MirBuilder:
    static fn new() -> MirBuilder:
        MirBuilder(
            module: MirModule(
                name: "",
                functions: {},
                statics: {},
                constants: {},
                types: {}
            ),
            current_function: nil,
            current_block: BlockId.entry(),
            next_local_id: 0,
            next_block_id: 1,
            locals: [],
            blocks: [],
            instructions: []
        )

    # ========================================================================
    # Function Building
    # ========================================================================

    me begin_function(symbol: SymbolId, name: text, signature: MirSignature, span: Span):
        """Begin building a new function."""
        self.current_function = Some(MirFunction(
            symbol: symbol,
            name: name,
            signature: signature,
            locals: [],
            blocks: [],
            entry_block: BlockId.entry(),
            span: span
        ))
        self.next_local_id = 0
        self.next_block_id = 1
        self.locals = []
        self.blocks = []
        self.instructions = []
        self.current_block = BlockId.entry()

        # Create entry block
        self.blocks = self.blocks.push(MirBlock(
            id: BlockId.entry(),
            label: Some("entry"),
            instructions: [],
            terminator: MirTerminator.Unreachable  # Placeholder
        ))

        # Create return local
        if signature.return_type.kind != MirTypeKind.Unit:
            self.new_local(Some("_return"), signature.return_type, LocalKind.Return)

        # Create parameter locals
        for i in 0..signature.params.len():
            self.new_local(nil, signature.params[i], LocalKind.Arg(i))

    me end_function() -> MirFunction:
        """Finish building current function and return it."""
        # Finalize current block
        self.finalize_block()

        var fn_ = self.current_function.unwrap()
        fn_.locals = self.locals
        fn_.blocks = self.blocks
        self.current_function = None
        fn_

    me add_function(fn_: MirFunction):
        """Add a completed function to the module."""
        self.module.functions[fn_.symbol] = fn_

    # ========================================================================
    # Local Variables
    # ========================================================================

    me new_local(name: text?, type_: MirType, kind: LocalKind) -> LocalId:
        """Create a new local variable."""
        val id = LocalId(id: self.next_local_id)
        self.next_local_id = self.next_local_id + 1

        self.locals = self.locals.push(MirLocal(
            id: id,
            name: name,
            type_: type_,
            kind: kind
        ))

        id

    me new_temp(type_: MirType) -> LocalId:
        """Create a new temporary."""
        self.new_local(nil, type_, LocalKind.Temp)

    # ========================================================================
    # Basic Blocks
    # ========================================================================

    me new_block(label: text?) -> BlockId:
        """Create a new basic block."""
        val id = BlockId(id: self.next_block_id)
        self.next_block_id = self.next_block_id + 1

        self.blocks = self.blocks.push(MirBlock(
            id: id,
            label: label,
            instructions: [],
            terminator: MirTerminator.Unreachable  # Placeholder
        ))

        id

    me switch_to_block(block: BlockId):
        """Switch to building a different block."""
        self.finalize_block()
        self.current_block = block
        self.instructions = []

    me finalize_block():
        """Finalize current block with accumulated instructions."""
        if self.instructions.is_empty():
            return

        # Find and update current block
        for i in 0..self.blocks.len():
            if self.blocks[i].id.id == self.current_block.id:
                var block = self.blocks[i]
                block.instructions = self.instructions
                self.blocks[i] = block
                break

        self.instructions = []

    # ========================================================================
    # Instructions
    # ========================================================================

    me emit(inst: MirInst):
        """Emit an instruction to current block."""
        self.instructions = self.instructions.push(inst)

    me emit_const(dest: LocalId, value: MirConstValue, type_: MirType):
        """Emit a constant load."""
        self.emit(MirInst(
            kind: MirInstKind.Const(dest, value, type_),
            span: nil
        ))

    me emit_const_int(value: i64) -> LocalId:
        """Emit an integer constant and return its local."""
        val dest = self.new_temp(MirType.i64())
        self.emit_const(dest, MirConstValue.Int(value), MirType.i64())
        dest

    me emit_const_float(value: f64) -> LocalId:
        """Emit a float constant and return its local."""
        val dest = self.new_temp(MirType.f64())
        self.emit_const(dest, MirConstValue.Float(value), MirType.f64())
        dest

    me emit_const_bool(value: bool) -> LocalId:
        """Emit a boolean constant and return its local."""
        val dest = self.new_temp(MirType.bool())
        self.emit_const(dest, MirConstValue.Bool(value), MirType.bool())
        dest

    me emit_copy(dest: LocalId, src: LocalId):
        """Emit a copy instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Copy(dest, src),
            span: nil
        ))

    me emit_move(dest: LocalId, src: LocalId):
        """Emit a move instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Move(dest, src),
            span: nil
        ))

    me emit_binop(op: MirBinOp, left: MirOperand, right: MirOperand, type_: MirType) -> LocalId:
        """Emit a binary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.BinOp(dest, op, left, right),
            span: nil
        ))
        dest

    me emit_unary(op: MirUnaryOp, operand: MirOperand, type_: MirType) -> LocalId:
        """Emit a unary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.UnaryOp(dest, op, operand),
            span: nil
        ))
        dest

    me emit_load(ptr: MirOperand, type_: MirType) -> LocalId:
        """Emit a load instruction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.Load(dest, ptr),
            span: nil
        ))
        dest

    me emit_store(ptr: MirOperand, value: MirOperand):
        """Emit a store instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Store(ptr, value),
            span: nil
        ))

    me emit_alloc(type_: MirType) -> LocalId:
        """Emit an allocation."""
        val dest = self.new_temp(MirType.ptr(type_, true))
        self.emit(MirInst(
            kind: MirInstKind.Alloc(dest, type_),
            span: nil
        ))
        dest

    me emit_call(func: MirOperand, args: [MirOperand], return_type: MirType) -> LocalId?:
        """Emit a function call."""
        var dest: LocalId? = None
        if return_type.kind != MirTypeKind.Unit:
            dest = Some(self.new_temp(return_type))

        self.emit(MirInst(
            kind: MirInstKind.Call(dest, func, args),
            span: nil
        ))

        dest

    me emit_cast(operand: MirOperand, target: MirType) -> LocalId:
        """Emit a type cast."""
        val dest = self.new_temp(target)
        self.emit(MirInst(
            kind: MirInstKind.Cast(dest, operand, target),
            span: nil
        ))
        dest

    me emit_aggregate(kind: AggregateKind, operands: [MirOperand], type_: MirType) -> LocalId:
        """Emit aggregate construction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.Aggregate(dest, kind, operands),
            span: nil
        ))
        dest

    me emit_get_field(base: MirOperand, field: i64, type_: MirType) -> LocalId:
        """Emit field access."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.GetField(dest, base, field),
            span: nil
        ))
        dest

    # ========================================================================
    # Terminators
    # ========================================================================

    me terminate_goto(target: BlockId):
        """Terminate current block with unconditional jump."""
        self.set_terminator(MirTerminator.Goto(target))

    me terminate_return(value: MirOperand?):
        """Terminate current block with return."""
        self.set_terminator(MirTerminator.Return(value))

    me terminate_if(cond: MirOperand, then_: BlockId, else_: BlockId):
        """Terminate current block with conditional branch."""
        self.set_terminator(MirTerminator.If(cond, then_, else_))

    me terminate_switch(value: MirOperand, targets: [(i64, BlockId)], default: BlockId):
        """Terminate current block with switch."""
        self.set_terminator(MirTerminator.Switch(value, targets, default))

    me terminate_unreachable():
        """Terminate current block as unreachable."""
        self.set_terminator(MirTerminator.Unreachable)

    me set_terminator(term: MirTerminator):
        """Set terminator for current block."""
        self.finalize_block()

        for i in 0..self.blocks.len():
            if self.blocks[i].id.id == self.current_block.id:
                var block = self.blocks[i]
                block.terminator = term
                self.blocks[i] = block
                break

# ============================================================================
# HIR to MIR Lowering
# ============================================================================

struct MirLowering:
    """Lowers HIR to MIR."""
    builder: MirBuilder
    symbols: SymbolTable
    local_map: Dict<SymbolId, LocalId>
    loop_stack: [(BlockId, BlockId)]  # (continue_block, break_block)
    errors: [MirError]

struct MirError:
    """MIR lowering error."""
    message: text
    span: Span?

impl MirLowering:
    static fn new(symbols: SymbolTable) -> MirLowering:
        MirLowering(
            builder: MirBuilder.new(),
            symbols: symbols,
            local_map: {},
            loop_stack: [],
            errors: []
        )

    me lower_module(module: HirModule) -> MirModule:
        """Lower HIR module to MIR."""
        var builder_module = self.builder.module
        builder_module.name = module.name
        self.builder.module = builder_module

        # Lower functions
        for symbol, fn_ in module.functions:
            val mir_fn = self.lower_function(fn_)
            self.builder.add_function(mir_fn)

        # Lower constants
        for symbol, const_ in module.constants:
            self.lower_const(const_)

        self.builder.module

    me lower_function(fn_: HirFunction) -> MirFunction:
        """Lower HIR function to MIR."""
        self.local_map = {}

        # Build signature
        var params: [MirType] = []
        for p in fn_.params:
            params = params.push(self.lower_type(p.type_))

        val return_type = self.lower_type(fn_.return_type)
        val signature = MirSignature(
            params: params,
            return_type: return_type,
            is_variadic: false
        )

        # Begin function
        self.builder.begin_function(fn_.symbol, fn_.name, signature, fn_.span)

        # Map parameters to locals
        for i in 0..fn_.params.len():
            val param = fn_.params[i]
            val local = LocalId(id: i + 1)  # +1 for return slot
            self.local_map[param.symbol] = local

        # Lower body
        val result = self.lower_block(fn_.body)

        # Return result
        if result.?:
            self.builder.terminate_return(Some(MirOperand.copy(result.unwrap())))
        else:
            self.builder.terminate_return(nil)

        self.builder.end_function()

    me lower_const(const_: HirConst):
        """Lower HIR constant to MIR static."""
        val value = self.lower_const_expr(const_.value)
        if value.?:
            self.builder.module.constants[const_.symbol] = MirConstant(
                symbol: const_.symbol,
                name: const_.name,
                type_: self.lower_type(const_.type_),
                value: value.unwrap()
            )

    me lower_type(type_: HirType) -> MirType:
        """Lower HIR type to MIR type."""
        match type_.kind:
            case Int(bits, signed):
                if signed:
                    match bits:
                        case 8: MirType(kind: MirTypeKind.I8)
                        case 16: MirType(kind: MirTypeKind.I16)
                        case 32: MirType(kind: MirTypeKind.I32)
                        case _: MirType(kind: MirTypeKind.I64)
                else:
                    match bits:
                        case 8: MirType(kind: MirTypeKind.U8)
                        case 16: MirType(kind: MirTypeKind.U16)
                        case 32: MirType(kind: MirTypeKind.U32)
                        case _: MirType(kind: MirTypeKind.U64)
            case Float(bits):
                match bits:
                    case 32: MirType(kind: MirTypeKind.F32)
                    case _: MirType(kind: MirTypeKind.F64)
            case Bool:
                MirType(kind: MirTypeKind.Bool)
            case Char:
                MirType(kind: MirTypeKind.Char)
            case Str:
                # String is a fat pointer (ptr, len)
                MirType(kind: MirTypeKind.Tuple([
                    MirType(kind: MirTypeKind.Ptr(MirType(kind: MirTypeKind.U8), false)),
                    MirType(kind: MirTypeKind.U64)
                ]))
            case Unit:
                MirType(kind: MirTypeKind.Unit)
            case Tuple(elements):
                var mir_elements: [MirType] = []
                for e in elements:
                    mir_elements = mir_elements.push(self.lower_type(e))
                MirType(kind: MirTypeKind.Tuple(mir_elements))
            case Array(element, size):
                MirType(kind: MirTypeKind.Array(self.lower_type(element), size ?? 0))
            case Ref(inner, mutable):
                MirType(kind: MirTypeKind.Ref(self.lower_type(inner), mutable))
            case Optional(inner):
                # Optional is enum { None, Some(T) }
                MirType(kind: MirTypeKind.Tuple([
                    MirType(kind: MirTypeKind.Bool),  # has_value
                    self.lower_type(inner)
                ]))
            case Named(symbol, _):
                MirType(kind: MirTypeKind.Struct(symbol))
            case Never:
                MirType(kind: MirTypeKind.Never)
            case _:
                # Default to i64 for unhandled types
                MirType(kind: MirTypeKind.I64)

    me lower_block(block: HirBlock) -> LocalId?:
        """Lower HIR block to MIR, return result local if any."""
        for stmt in block.stmts:
            self.lower_stmt(stmt)

        if block.value.?:
            Some(self.lower_expr(block.value.unwrap()))
        else:
            nil

    me lower_stmt(stmt: HirStmt):
        """Lower HIR statement to MIR."""
        match stmt.kind:
            case Expr(expr):
                self.lower_expr(expr)

            case Let(symbol, type_, init):
                val mir_type = type_.map(\t: self.lower_type(t)) ?? MirType.i64()
                val local = self.builder.new_local(nil, mir_type, LocalKind.Var)
                self.local_map[symbol] = local

                val init_local = self.lower_expr(init)
                self.builder.emit_copy(local, init_local)

            case Assign(target, op, value):
                val value_local = self.lower_expr(value)
                self.lower_assign(target, op, value_local)

            case Block(block):
                self.lower_block(block)

    me lower_assign(target: HirExpr, op: HirAssignOp?, value_local: LocalId):
        """Lower assignment."""
        match target.kind:
            case Var(symbol):
                val local = self.local_map[symbol]
                if local.?:
                    if op.?:
                        # Compound assignment
                        val current = MirOperand.copy(local.unwrap())
                        val new_val = MirOperand.copy(value_local)
                        val mir_op = self.lower_assign_op(op.unwrap())
                        val result = self.builder.emit_binop(mir_op, current, new_val, MirType.i64())
                        self.builder.emit_copy(local.unwrap(), result)
                    else:
                        self.builder.emit_copy(local.unwrap(), value_local)
            case _:
                self.error("unsupported assignment target", Some(target.span))

    me lower_assign_op(op: HirAssignOp) -> MirBinOp:
        """Convert assignment op to binary op."""
        match op:
            case Add: MirBinOp.Add
            case Sub: MirBinOp.Sub
            case Mul: MirBinOp.Mul
            case Div: MirBinOp.Div
            case Mod: MirBinOp.Rem
            case _: MirBinOp.Add

    me lower_expr(expr: HirExpr) -> LocalId:
        """Lower HIR expression to MIR, return result local."""
        match expr.kind:
            case IntLit(value, _):
                self.builder.emit_const_int(value)

            case FloatLit(value, _):
                self.builder.emit_const_float(value)

            case BoolLit(value):
                self.builder.emit_const_bool(value)

            case StringLit(value, _):
                # TODO: Proper string handling
                self.builder.emit_const_int(0)

            case NilLit | UnitLit:
                self.builder.new_temp(MirType.unit())

            case Var(symbol):
                val local = self.local_map[symbol]
                if local.?:
                    local.unwrap()
                else:
                    self.error("undefined variable", Some(expr.span))
                    self.builder.new_temp(MirType.i64())

            case Binary(op, left, right):
                val left_local = self.lower_expr(left)
                val right_local = self.lower_expr(right)
                val mir_op = self.lower_binop(op)
                val result_type = self.infer_binop_type(op)
                self.builder.emit_binop(mir_op, MirOperand.copy(left_local), MirOperand.copy(right_local), result_type)

            case Unary(op, operand):
                val operand_local = self.lower_expr(operand)
                val mir_op = self.lower_unaryop(op)
                self.builder.emit_unary(mir_op, MirOperand.copy(operand_local), MirType.i64())

            case If(cond, then_, else_):
                self.lower_if(cond, then_, else_)

            case Call(callee, args, _):
                self.lower_call(callee, args)

            case MethodCall(receiver, method, args, resolution):
                self.lower_method_call(receiver, method, args, resolution)

            case ArrayLit(elements, _):
                self.lower_array_lit(elements)

            case TupleLit(elements):
                self.lower_tuple_lit(elements)

            case Block(block):
                val result = self.lower_block(block)
                result ?? self.builder.new_temp(MirType.unit())

            case Loop(body, _):
                self.lower_loop(body)

            case While(cond, body, _):
                self.lower_while(cond, body)

            case For(var_, iter, body, _):
                self.lower_for(var_, iter, body)

            case Return(value):
                if value.?:
                    val result = self.lower_expr(value.unwrap())
                    self.builder.terminate_return(Some(MirOperand.copy(result)))
                else:
                    self.builder.terminate_return(nil)
                self.builder.new_temp(MirType.unit())

            case Break(_, _):
                if self.loop_stack.len() > 0:
                    val break_block = self.loop_stack[self.loop_stack.len() - 1].1
                    self.builder.terminate_goto(break_block)
                self.builder.new_temp(MirType.unit())

            case Continue(_):
                if self.loop_stack.len() > 0:
                    val continue_block = self.loop_stack[self.loop_stack.len() - 1].0
                    self.builder.terminate_goto(continue_block)
                self.builder.new_temp(MirType.unit())

            # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
            case CustomBlock(kind, value):
                self.lower_custom_block(kind, value, expr.span)

            # Math/DL blocks with special semantics
            case LossBlock(body):
                self.lower_loss_block(body)

            case NogradBlock(body):
                self.lower_nograd_block(body)

            case _:
                self.error("unsupported expression in MIR lowering", Some(expr.span))
                self.builder.new_temp(MirType.i64())

    me lower_binop(op: HirBinOp) -> MirBinOp:
        """Convert HIR binary op to MIR binary op."""
        match op:
            case Add: MirBinOp.Add
            case Sub: MirBinOp.Sub
            case Mul: MirBinOp.Mul
            case Div: MirBinOp.Div
            case Mod: MirBinOp.Rem
            case Pow: MirBinOp.Pow
            case MatMul: MirBinOp.MatMul
            case BitAnd: MirBinOp.BitAnd
            case BitOr: MirBinOp.BitOr
            case BitXor: MirBinOp.BitXor
            case Shl: MirBinOp.Shl
            case Shr: MirBinOp.Shr
            case Eq: MirBinOp.Eq
            case NotEq: MirBinOp.Ne
            case Lt: MirBinOp.Lt
            case LtEq: MirBinOp.Le
            case Gt: MirBinOp.Gt
            case GtEq: MirBinOp.Ge
            case BroadcastAdd: MirBinOp.BroadcastAdd
            case BroadcastSub: MirBinOp.BroadcastSub
            case BroadcastMul: MirBinOp.BroadcastMul
            case BroadcastDiv: MirBinOp.BroadcastDiv
            case BroadcastPow: MirBinOp.BroadcastPow
            case _: MirBinOp.Add

    me lower_unaryop(op: HirUnaryOp) -> MirUnaryOp:
        """Convert HIR unary op to MIR unary op."""
        match op:
            case Neg: MirUnaryOp.Neg
            case Not: MirUnaryOp.Not
            case BitNot: MirUnaryOp.BitNot
            case Transpose: MirUnaryOp.Transpose
            case _: MirUnaryOp.Neg

    me infer_binop_type(op: HirBinOp) -> MirType:
        """Infer result type of binary operation."""
        match op:
            case Eq | NotEq | Lt | LtEq | Gt | GtEq:
                MirType.bool()
            case _:
                MirType.i64()  # Default to i64

    me lower_if(cond: HirExpr, then_: HirBlock, else_: HirBlock?) -> LocalId:
        """Lower if expression."""
        val cond_local = self.lower_expr(cond)

        val then_block = self.builder.new_block(Some("then"))
        val else_block = self.builder.new_block(Some("else"))
        val merge_block = self.builder.new_block(Some("merge"))

        val result = self.builder.new_temp(MirType.i64())

        self.builder.terminate_if(MirOperand.copy(cond_local), then_block, else_block)

        # Then block
        self.builder.switch_to_block(then_block)
        val then_result = self.lower_block(then_)
        if then_result.?:
            self.builder.emit_copy(result, then_result.unwrap())
        self.builder.terminate_goto(merge_block)

        # Else block
        self.builder.switch_to_block(else_block)
        if else_.?:
            val else_result = self.lower_block(else_.unwrap())
            if else_result.?:
                self.builder.emit_copy(result, else_result.unwrap())
        self.builder.terminate_goto(merge_block)

        # Merge block
        self.builder.switch_to_block(merge_block)

        result

    me lower_loop(body: HirBlock) -> LocalId:
        """Lower loop expression."""
        val loop_block = self.builder.new_block(Some("loop"))
        val exit_block = self.builder.new_block(Some("loop_exit"))

        self.loop_stack = self.loop_stack.push((loop_block, exit_block))

        self.builder.terminate_goto(loop_block)
        self.builder.switch_to_block(loop_block)

        self.lower_block(body)
        self.builder.terminate_goto(loop_block)

        self.loop_stack = self.loop_stack[0:self.loop_stack.len() - 1]

        self.builder.switch_to_block(exit_block)
        self.builder.new_temp(MirType.unit())

    me lower_while(cond: HirExpr, body: HirBlock) -> LocalId:
        """Lower while expression."""
        val cond_block = self.builder.new_block(Some("while_cond"))
        val body_block = self.builder.new_block(Some("while_body"))
        val exit_block = self.builder.new_block(Some("while_exit"))

        self.loop_stack = self.loop_stack.push((cond_block, exit_block))

        self.builder.terminate_goto(cond_block)
        self.builder.switch_to_block(cond_block)

        val cond_local = self.lower_expr(cond)
        self.builder.terminate_if(MirOperand.copy(cond_local), body_block, exit_block)

        self.builder.switch_to_block(body_block)
        self.lower_block(body)
        self.builder.terminate_goto(cond_block)

        self.loop_stack = self.loop_stack[0:self.loop_stack.len() - 1]

        self.builder.switch_to_block(exit_block)
        self.builder.new_temp(MirType.unit())

    me lower_for(var_: SymbolId, iter: HirExpr, body: HirBlock) -> LocalId:
        """Lower for expression."""
        # TODO: Proper iterator lowering
        # For now, treat as simple range loop
        self.lower_while(
            HirExpr(kind: HirExprKind.BoolLit(true), type_: nil, span: body.span),
            body
        )

    me lower_call(callee: HirExpr, args: [HirCallArg]) -> LocalId:
        """Lower function call."""
        val callee_local = self.lower_expr(callee)

        var arg_operands: [MirOperand] = []
        for arg in args:
            val arg_local = self.lower_expr(arg.value)
            arg_operands = arg_operands.push(MirOperand.copy(arg_local))

        val result = self.builder.emit_call(MirOperand.copy(callee_local), arg_operands, MirType.i64())
        result ?? self.builder.new_temp(MirType.unit())

    me lower_method_call(receiver: HirExpr, method: text, args: [HirCallArg], resolution: MethodResolution) -> LocalId:
        """Lower method call based on resolution.

        UFCS: For FreeFunction resolution, receiver becomes first argument.
        """
        match resolution:
            case InstanceMethod(type_id, method_id):
                # Direct method call on type
                # Lower receiver and args
                val receiver_local = self.lower_expr(receiver)
                var arg_operands: [MirOperand] = [MirOperand.copy(receiver_local)]
                for arg in args:
                    val arg_local = self.lower_expr(arg.value)
                    arg_operands = arg_operands.push(MirOperand.copy(arg_local))

                # Emit call to method (use method_id to get function symbol)
                val method_operand = self.symbol_to_operand(method_id)
                val result = self.builder.emit_call(method_operand, arg_operands, MirType.i64())
                result ?? self.builder.new_temp(MirType.unit())

            case TraitMethod(trait_id, method_id):
                # Virtual dispatch through trait vtable
                # For now, lower as direct call (TODO: proper vtable dispatch)
                val receiver_local = self.lower_expr(receiver)
                var arg_operands: [MirOperand] = [MirOperand.copy(receiver_local)]
                for arg in args:
                    val arg_local = self.lower_expr(arg.value)
                    arg_operands = arg_operands.push(MirOperand.copy(arg_local))

                val method_operand = self.symbol_to_operand(method_id)
                val result = self.builder.emit_call(method_operand, arg_operands, MirType.i64())
                result ?? self.builder.new_temp(MirType.unit())

            case FreeFunction(func_id):
                # UFCS: x.method(a, b) -> method(x, a, b)
                # Receiver becomes first argument
                val receiver_local = self.lower_expr(receiver)
                var arg_operands: [MirOperand] = [MirOperand.copy(receiver_local)]
                for arg in args:
                    val arg_local = self.lower_expr(arg.value)
                    arg_operands = arg_operands.push(MirOperand.copy(arg_local))

                val func_operand = self.symbol_to_operand(func_id)
                val result = self.builder.emit_call(func_operand, arg_operands, MirType.i64())
                result ?? self.builder.new_temp(MirType.unit())

            case Unresolved:
                # Method was not resolved - emit error and return dummy
                self.error("unresolved method call: {method}", nil)
                self.builder.new_temp(MirType.unit())

    me symbol_to_operand(symbol: SymbolId) -> MirOperand:
        """Convert a symbol to a function pointer operand."""
        # Create a constant referencing the function symbol
        # In codegen, this will be resolved to the actual function address
        MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(symbol.id),
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))

    me lower_array_lit(elements: [HirExpr]) -> LocalId:
        """Lower array literal."""
        var operands: [MirOperand] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands.push(MirOperand.copy(local))

        val elem_type = MirType.i64()  # TODO: Infer element type
        val array_type = MirType(kind: MirTypeKind.Array(elem_type, elements.len()))

        self.builder.emit_aggregate(
            AggregateKind.Array(elem_type),
            operands,
            array_type
        )

    me lower_tuple_lit(elements: [HirExpr]) -> LocalId:
        """Lower tuple literal."""
        var operands: [MirOperand] = []
        var types: [MirType] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands.push(MirOperand.copy(local))
            types = types.push(MirType.i64())  # TODO: Infer types

        val tuple_type = MirType(kind: MirTypeKind.Tuple(types))
        self.builder.emit_aggregate(AggregateKind.Tuple, operands, tuple_type)

    me lower_const_expr(expr: HirExpr) -> MirConstValue?:
        """Lower constant expression."""
        match expr.kind:
            case IntLit(value, _):
                Some(MirConstValue.Int(value))
            case FloatLit(value, _):
                Some(MirConstValue.Float(value))
            case BoolLit(value):
                Some(MirConstValue.Bool(value))
            case StringLit(value, _):
                Some(MirConstValue.Str(value))
            case _:
                nil

    # ========================================================================
    # Custom Block Lowering
    # ========================================================================

    me lower_custom_block(kind: text, value: BlockValue, span: Span) -> LocalId:
        """Lower custom block to MIR.

        Custom blocks are lowered by calling a runtime handler function
        that processes the block value and returns a result.
        """
        # Create a local to hold the block kind string
        val kind_local = self.builder.emit_const_int(0)  # TODO: String handling

        # Emit call to runtime block handler
        # rt_eval_block(kind: text, value: BlockValue) -> Any
        val result = self.builder.new_temp(MirType.i64())

        # For now, blocks that produce values just return unit
        # The actual evaluation happens at runtime via the interpreter
        # This is a placeholder for when we add full codegen support
        result

    me lower_loss_block(body: HirBlock) -> LocalId:
        """Lower loss block to MIR.

        Loss blocks:
        1. Enable gradient tracking
        2. Evaluate the body
        3. Call backward() on the result
        4. Restore gradient tracking state
        """
        # Emit call to enable autograd
        # rt_autograd_push(enabled: bool)
        val _push_result = self.builder.new_temp(MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to backward
        # rt_backward(value: Tensor)
        if body_result.?:
            pass  # Would emit: rt_backward(body_result.unwrap())

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder.new_temp(MirType.unit())

        body_result ?? self.builder.new_temp(MirType.unit())

    me lower_nograd_block(body: HirBlock) -> LocalId:
        """Lower nograd block to MIR.

        Nograd blocks:
        1. Disable gradient tracking
        2. Evaluate the body
        3. Restore gradient tracking state
        """
        # Emit call to disable autograd
        # rt_autograd_push(enabled: false)
        val _push_result = self.builder.new_temp(MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder.new_temp(MirType.unit())

        body_result ?? self.builder.new_temp(MirType.unit())

    me error(message: text, span: Span?):
        """Record a lowering error."""
        self.errors = self.errors.push(MirError(message: message, span: span))

# ============================================================================
# Exports
# ============================================================================

export MirModule, MirFunction, MirSignature, MirLocal, LocalId, LocalKind
export MirStatic, MirConstant, MirConstValue
export MirTypeDef, MirTypeDefKind, MirFieldDef, MirVariantDef
export MirType, MirTypeKind
export BlockId, MirBlock
export MirInst, MirInstKind, MirBinOp, MirUnaryOp, AggregateKind
export MirOperand, MirOperandKind
export MirTerminator
export MirBuilder
export MirLowering, MirError
