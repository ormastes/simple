# Backend - HIR Processing Backend Trait
#
# The Backend trait is the core abstraction for processing HIR.
# Different implementations handle HIR differently:
#
# - InterpreterBackend: Tree-walks HIR and evaluates directly
# - CompilerBackend: Lowers HIR to MIR then generates native code
# - SdnBackend: Blocks code execution, only allows data construction
#
# The HirVisitor walks the HIR tree and calls the appropriate backend methods.

use hir.*
use lexer.Span
use std_lib.di.Container, std_lib.di.get_container
use mir.{MirLowering, MirModule}
use codegen.{CodegenPipeline, CodegenTarget, CodegenMode, CompiledModule, CodegenError}

# ============================================================================
# Backend Trait
# ============================================================================

trait Backend:
    """Interface for processing HIR.

    Backends are injected via DI and determine how code is executed:
    - Interpreter: Direct evaluation
    - Compiler: Code generation
    - SDN: Data-only (blocks execution)
    """

    fn name() -> text
    fn kind() -> BackendKind

    # Module processing
    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>

    # Definition processing
    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>
    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>
    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>
    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>
    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>
    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>

    # Expression evaluation
    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>

    # Statement execution
    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>

    # Instruction checking (for SDN safety)
    fn is_allowed(expr: HirExpr) -> bool
    fn is_allowed_stmt(stmt: HirStmt) -> bool

"""Type of backend."""
enum BackendKind:
    Interpreter
    Compiler
    Sdn
    Custom(name: text)

# ============================================================================
# Backend Results and Errors
# ============================================================================

"""Result of backend processing."""
enum BackendResult:
    Value(value: Value)
    CompiledUnit(unit: CompiledUnit)
    SdnData(data: SdnValue)
    Unit

struct BackendError:
    """Error during backend processing."""
    message: text
    span: Span?
    kind: BackendErrorKind

"""Backend error kind."""
enum BackendErrorKind:
    NotAllowed          # Operation not allowed (SDN mode)
    TypeError           # Type mismatch
    RuntimeError        # Runtime error
    CompileError        # Compilation error
    NotImplemented      # Feature not implemented
    Internal            # Internal error

impl BackendError:
    static fn not_allowed(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.NotAllowed)

    static fn type_error(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.TypeError)

    static fn runtime_error(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.RuntimeError)

    static fn compile_error(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.CompileError)

    static fn not_implemented(message: text) -> BackendError:
        BackendError(message: message, span: nil, kind: BackendErrorKind.NotImplemented)

    static fn internal(message: text) -> BackendError:
        BackendError(message: message, span: nil, kind: BackendErrorKind.Internal)

# ============================================================================
# Compiled Unit (for Compiler Backend)
# ============================================================================

struct CompiledUnit:
    """Result of compilation."""
    name: text
    code: [u8]
    symbols: Dict<text, CompiledSymbol>
    entry_point: text?
    relocations: [Relocation]

struct CompiledSymbol:
    """Symbol in compiled unit."""
    name: text
    address: i64
    size: i64
    kind: CompiledSymbolKind

enum CompiledSymbolKind:
    Function
    Data
    External

struct Relocation:
    """Relocation entry."""
    offset: i64
    symbol: text
    kind: RelocKind

enum RelocKind:
    Absolute
    Relative
    PltRelative

# ============================================================================
# SDN Value (for SDN Backend)
# ============================================================================

struct SdnValue:
    """Data-only value from SDN parsing."""
    kind: SdnValueKind

"""SDN value kind."""
enum SdnValueKind:
    Nil
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    String(value: text)
    Array(elements: [SdnValue])
    Dict(entries: Dict<text, SdnValue>)
    Table(headers: [text], rows: [[SdnValue]])

impl SdnValue:
    static fn make_nil() -> SdnValue:
        SdnValue(kind: SdnValueKind.Nil)

    static fn bool(value: bool) -> SdnValue:
        SdnValue(kind: SdnValueKind.Bool(value))

    static fn int(value: i64) -> SdnValue:
        SdnValue(kind: SdnValueKind.Int(value))

    static fn float(value: f64) -> SdnValue:
        SdnValue(kind: SdnValueKind.Float(value))

    static fn string(value: text) -> SdnValue:
        SdnValue(kind: SdnValueKind.String(value))

    static fn array(elements: [SdnValue]) -> SdnValue:
        SdnValue(kind: SdnValueKind.Array(elements))

    static fn dict(entries: Dict<text, SdnValue>) -> SdnValue:
        SdnValue(kind: SdnValueKind.Dict(entries))

    static fn table(headers: [text], rows: [[SdnValue]]) -> SdnValue:
        SdnValue(kind: SdnValueKind.Table(headers, rows))

# ============================================================================
# Runtime Value (for Interpreter Backend)
# ============================================================================

"""Runtime value for interpreter."""
enum Value:
    Nil
    Unit
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    Char(value: char)
    String(value: text)
    Array(elements: [Value])
    Tuple(elements: [Value])
    Dict(entries: Dict<text, Value>)
    Struct(type_: text, fields: Dict<text, Value>)
    Enum(type_: text, variant: text, payload: EnumPayloadValue?)
    Function(fn_: FunctionValue)
    Closure(closure: ClosureValue)
    Object(obj: ObjectValue)
    Ref(target: Value, mutable: bool)
    Option(value: Value?)
    Result(ok: Value?, err: Value?)
    TraitType(trait_name: text)

enum EnumPayloadValue:
    Tuple(values: [Value])
    Struct(fields: Dict<text, Value>)

struct FunctionValue:
    """Function value."""
    symbol: SymbolId
    name: text

struct ClosureValue:
    """Closure value with captured environment."""
    params: [HirParam]
    body: HirExpr
    captures: Dict<SymbolId, Value>

struct ObjectValue:
    """Object instance."""
    class_: SymbolId
    fields: Dict<text, Value>

impl Value:
    static fn make_nil() -> Value:
        Value.Nil

    static fn bool(value: bool) -> Value:
        Value.Bool(value)

    static fn int(value: i64) -> Value:
        Value.Int(value)

    static fn float(value: f64) -> Value:
        Value.Float(value)

    static fn string(value: text) -> Value:
        Value.String(value)

    static fn some(value: Value) -> Value:
        Value.Option(Some(value))

    static fn none() -> Value:
        Value.Option(nil)

    static fn ok(value: Value) -> Value:
        Value.Result(Some(value), nil)

    static fn err(value: Value) -> Value:
        Value.Result(nil, Some(value))

    fn is_truthy() -> bool:
        match self:
            case Nil: false
            case Bool(b): b
            case Int(i): i != 0
            case Float(f): f != 0.0
            case String(s): not s.is_empty()
            case Array(a): not a.is_empty()
            case Option(v): v.?
            case _: true

    fn type_name() -> text:
        match self:
            case Nil: "nil"
            case Unit: "unit"
            case Bool(_): "bool"
            case Int(_): "i64"
            case Float(_): "f64"
            case Char(_): "char"
            case String(_): "text"
            case Array(_): "array"
            case Tuple(_): "tuple"
            case Dict(_): "dict"
            case Struct(t, _): t
            case Enum(t, _, _): t
            case Function(_): "function"
            case Closure(_): "closure"
            case Object(o): "object"
            case Ref(_, _): "ref"
            case Option(_): "option"
            case Result(_, _): "result"
            case TraitType(_): "trait_type"
            case _: "unknown"

# ============================================================================
# Evaluation Context
# ============================================================================

struct EvalContext:
    """Context for expression evaluation."""
    env: Environment
    module: HirModule
    backend: Backend

struct Environment:
    """Variable environment for evaluation."""
    scopes: [Dict<SymbolId, Value>]
    globals: Dict<SymbolId, Value>

fn empty_env_scope() -> Dict<SymbolId, Value>:
    """Create an empty scope dict (typed for bootstrap inference)."""
    var result: Dict<SymbolId, Value> = {}
    result

impl Environment:
    static fn new() -> Environment:
        Environment(scopes: [empty_env_scope()], globals: empty_env_scope())

    me push_scope():
        self.scopes = self.scopes.push(empty_env_scope())

    me pop_scope():
        if self.scopes.len() > 1:
            self.scopes = self.scopes[0:self.scopes.len() - 1]

    me define(symbol: SymbolId, value: Value):
        val scope = self.scopes[self.scopes.len() - 1]
        scope[symbol] = value

    me assign(symbol: SymbolId, value: Value) -> bool:
        # Search from innermost scope
        for i in (self.scopes.len() - 1)..=0:
            val scope = self.scopes[i]
            if scope.contains_key(symbol):
                scope[symbol] = value
                return true

        # Check globals
        if self.globals.contains_key(symbol):
            self.globals[symbol] = value
            return true

        false

    fn lookup(symbol: SymbolId) -> Value?:
        # Search from innermost scope
        for i in (self.scopes.len() - 1)..=0:
            val scope = self.scopes[i]
            if scope.contains_key(symbol):
                return Some(scope[symbol])

        # Check globals
        if self.globals.contains_key(symbol):
            return Some(self.globals[symbol])
        nil

    me define_global(symbol: SymbolId, value: Value):
        self.globals[symbol] = value

# ============================================================================
# HIR Visitor
# ============================================================================

struct HirVisitor:
    """Visitor that walks HIR and calls backend methods."""
    backend: Backend
    ctx: EvalContext

impl HirVisitor:
    static fn new(backend: Backend, module: HirModule) -> HirVisitor:
        HirVisitor(
            backend: backend,
            ctx: EvalContext(
                env: Environment.new(),
                module: module,
                backend: backend
            )
        )

    me visit_module() -> Result<BackendResult, BackendError>:
        """Visit entire module."""
        self.backend.process_module(self.ctx.module)

    me visit_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        """Visit function definition."""
        self.backend.process_function(fn_)

    me visit_expr(expr: HirExpr) -> Result<Value, BackendError>:
        """Visit expression."""
        # Check if allowed
        if not self.backend.is_allowed(expr):
            return Err(BackendError.not_allowed(
                "expression not allowed in {self.backend.name()} mode",
                Some(expr.span)
            ))

        self.backend.eval_expr(expr, self.ctx)

    me visit_stmt(stmt: HirStmt) -> Result<(), BackendError>:
        """Visit statement."""
        if not self.backend.is_allowed_stmt(stmt):
            return Err(BackendError.not_allowed(
                "statement not allowed in {self.backend.name()} mode",
                Some(stmt.span)
            ))

        self.backend.exec_stmt(stmt, self.ctx)

    me visit_block(block: HirBlock) -> Result<Value, BackendError>:
        """Visit block."""
        self.ctx.env.push_scope()

        for stmt in block.stmts:
            self.visit_stmt(stmt)?

        val result = if block.value.?:
            self.visit_expr(block.value.unwrap())?
        else:
            Value.make_nil()

        self.ctx.env.pop_scope()
        Ok(result)

# ============================================================================
# Backend Factory
# ============================================================================

pub fn create_backend(kind: BackendKind) -> Backend:
    """Create a backend by kind."""
    match kind:
        case Interpreter:
            InterpreterBackendImpl()
        case Compiler:
            CompilerBackendImpl()
        case Sdn:
            SdnBackendImpl()
        case Custom(name):
            # Try to resolve from DI container
            val container = get_container()
            val result = container.resolve("Backend")
            if result.is_ok():
                result.unwrap()
            else:
                # Fall back to interpreter
                InterpreterBackendImpl()

pub fn get_backend() -> Backend:
    """Get the backend from DI container."""
    val container = get_container()
    val result = container.resolve("Backend")
    if result.is_ok():
        result.unwrap()
    else:
        # Default to interpreter
        InterpreterBackendImpl()

# ============================================================================
# Interpreter Backend Implementation
# ============================================================================

struct InterpreterBackendImpl:
    """Tree-walking interpreter backend."""

impl Backend for InterpreterBackendImpl:
    fn name() -> text:
        "interpreter"

    fn kind() -> BackendKind:
        BackendKind.Interpreter

    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>:
        print "[interp] process_module start"
        # Create evaluation context
        val env = Environment.new()
        print "[interp] env created"
        val ctx = EvalContext(env: env, module: module, backend: self)
        print "[interp] ctx created"

        # Register all functions as global values
        for symbol in module.functions.keys():
            val fn_ = module.functions[symbol]
            print "[interp] registering function: {fn_.name}"
            ctx.env.define_global(symbol, Value.Function(FunctionValue(symbol: symbol, name: fn_.name)))

        print "[interp] functions registered, now registering builtins..."

        # Register builtin functions from symbol table
        for sym_id in module.symbols.symbols.keys():
            val sym = module.symbols.symbols[sym_id]
            print "[interp] checking symbol: {sym.name}"
            if sym.kind == SymbolKind.Function and not module.functions.contains_key(sym.id):
                print "[interp] registering builtin: {sym.name}"
                ctx.env.define_global(sym.id, Value.Function(FunctionValue(symbol: sym.id, name: sym.name)))

        print "[interp] builtins registered, finding main..."

        # Find and call main function
        var main_fn: HirFunction? = nil
        for symbol in module.functions.keys():
            val fn_ = module.functions[symbol]
            if fn_.name == "main":
                main_fn = Some(fn_)

        print "[interp] main search done"

        if main_fn.?:
            print "[interp] calling main..."
            val result = self.call_hir_function(main_fn.unwrap(), [], ctx)?
            print "[interp] main returned"
            Ok(BackendResult.Value(result))
        else:
            print "[interp] no main function found"
            Ok(BackendResult.Unit)

    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        match expr.kind:
            case IntLit(value, _):
                Ok(Value.int(value))

            case FloatLit(value, _):
                Ok(Value.float(value))

            case StringLit(value, _):
                Ok(Value.string(value))

            case BoolLit(value):
                Ok(Value.bool(value))

            case NilLit:
                Ok(Value.make_nil())

            case UnitLit:
                Ok(Value.make_nil())

            case Var(symbol):
                val value = ctx.env.lookup(symbol)
                if value.?:
                    Ok(value.unwrap())
                else:
                    Err(BackendError.runtime_error("undefined variable", Some(expr.span)))

            case ArrayLit(elements, _):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Array(values))

            case TupleLit(elements):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Tuple(values))

            case DictLit(entries, _, _):
                var dict: Dict<text, Value> = {}
                for (key_expr, value_expr) in entries:
                    val key = self.eval_expr(key_expr, ctx)?
                    val value = self.eval_expr(value_expr, ctx)?
                    match key:
                        case String(k):
                            dict[k] = value
                        case _:
                            return Err(BackendError.type_error("dict key must be string", Some(expr.span)))
                Ok(Value.Dict(dict))

            case Binary(op, left, right):
                val lv = self.eval_expr(left, ctx)?
                val rv = self.eval_expr(right, ctx)?
                self.eval_binop(op, lv, rv, expr.span)

            case Unary(op, operand):
                val v = self.eval_expr(operand, ctx)?
                self.eval_unaryop(op, v, expr.span)

            case If(cond, then_, else_):
                val cv = self.eval_expr(cond, ctx)?
                if cv.is_truthy():
                    self.eval_block(then_, ctx)
                elif else_.?:
                    self.eval_block(else_.unwrap(), ctx)
                else:
                    Ok(Value.make_nil())

            case Call(callee, args, _):
                val fn_value = self.eval_expr(callee, ctx)?
                var arg_values: [Value] = []
                for arg in args:
                    val v = self.eval_expr(arg.value, ctx)?
                    arg_values = arg_values.push(v)
                self.call_function(fn_value, arg_values, ctx, expr.span)

            case Lambda(params, body, _):
                var captures: Dict<SymbolId, Value> = {}
                # TODO: Capture free variables
                Ok(Value.Closure(ClosureValue(
                    params: params,
                    body: body,
                    captures: captures
                )))

            case Block(block):
                self.eval_block(block, ctx)

            case _:
                Err(BackendError.not_implemented("expression kind not implemented"))

    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>:
        match stmt.kind:
            case Expr(expr):
                self.eval_expr(expr, ctx)?
                Ok(())

            case Let(symbol, _, init):
                val value = self.eval_expr(init, ctx)?
                ctx.env.define(symbol, value)
                Ok(())

            case Assign(target, op, value):
                val new_value = self.eval_expr(value, ctx)?
                match target.kind:
                    case Var(symbol):
                        if op.?:
                            val old_value = ctx.env.lookup(symbol)
                            if old_value.is_none():
                                return Err(BackendError.runtime_error("undefined variable", Some(stmt.span)))
                            val combined = self.apply_assign_op(op.unwrap(), old_value.unwrap(), new_value, stmt.span)?
                            ctx.env.assign(symbol, combined)
                        else:
                            ctx.env.assign(symbol, new_value)
                        Ok(())
                    case _:
                        Err(BackendError.not_implemented("assignment target not implemented"))

            case Block(block):
                self.eval_block(block, ctx)?
                Ok(())

    fn is_allowed(expr: HirExpr) -> bool:
        # Interpreter allows all expressions
        true

    fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # Interpreter allows all statements
        true

impl InterpreterBackendImpl:
    fn eval_block(block: HirBlock, ctx: EvalContext) -> Result<Value, BackendError>:
        ctx.env.push_scope()

        for stmt in block.stmts:
            self.exec_stmt(stmt, ctx)?

        val result = if block.value.?:
            self.eval_expr(block.value.unwrap(), ctx)?
        else:
            Value.make_nil()

        ctx.env.pop_scope()
        Ok(result)

    fn eval_binop(op: HirBinOp, left: Value, right: Value, span: Span) -> Result<Value, BackendError>:
        match op:
            case Add:
                match (left, right):
                    case (Int(l), Int(r)): Ok(Value.int(l + r))
                    case (Float(l), Float(r)): Ok(Value.float(l + r))
                    case (Int(l), Float(r)): Ok(Value.float(l.to_f64() + r))
                    case (Float(l), Int(r)): Ok(Value.float(l + r.to_f64()))
                    case (String(l), String(r)): Ok(Value.string(l + r))
                    case _: Err(BackendError.type_error("invalid operands for +", Some(span)))

            case Sub:
                match (left, right):
                    case (Int(l), Int(r)): Ok(Value.int(l - r))
                    case (Float(l), Float(r)): Ok(Value.float(l - r))
                    case _: Err(BackendError.type_error("invalid operands for -", Some(span)))

            case Mul:
                match (left, right):
                    case (Int(l), Int(r)): Ok(Value.int(l * r))
                    case (Float(l), Float(r)): Ok(Value.float(l * r))
                    case _: Err(BackendError.type_error("invalid operands for *", Some(span)))

            case Div:
                match (left, right):
                    case (Int(l), Int(r)):
                        if r == 0:
                            Err(BackendError.runtime_error("division by zero", Some(span)))
                        else:
                            Ok(Value.int(l / r))
                    case (Float(l), Float(r)): Ok(Value.float(l / r))
                    case _: Err(BackendError.type_error("invalid operands for /", Some(span)))

            case Mod:
                match (left, right):
                    case (Int(l), Int(r)):
                        if r == 0:
                            Err(BackendError.runtime_error("modulo by zero", Some(span)))
                        else:
                            Ok(Value.int(l % r))
                    case _: Err(BackendError.type_error("invalid operands for %", Some(span)))

            case Eq:
                Ok(Value.bool(self.values_equal(left, right)))

            case NotEq:
                Ok(Value.bool(not self.values_equal(left, right)))

            case Lt:
                match (left, right):
                    case (Int(l), Int(r)): Ok(Value.bool(l < r))
                    case (Float(l), Float(r)): Ok(Value.bool(l < r))
                    case (String(l), String(r)): Ok(Value.bool(l < r))
                    case _: Err(BackendError.type_error("invalid operands for <", Some(span)))

            case LtEq:
                match (left, right):
                    case (Int(l), Int(r)): Ok(Value.bool(l <= r))
                    case (Float(l), Float(r)): Ok(Value.bool(l <= r))
                    case _: Err(BackendError.type_error("invalid operands for <=", Some(span)))

            case Gt:
                match (left, right):
                    case (Int(l), Int(r)): Ok(Value.bool(l > r))
                    case (Float(l), Float(r)): Ok(Value.bool(l > r))
                    case _: Err(BackendError.type_error("invalid operands for >", Some(span)))

            case GtEq:
                match (left, right):
                    case (Int(l), Int(r)): Ok(Value.bool(l >= r))
                    case (Float(l), Float(r)): Ok(Value.bool(l >= r))
                    case _: Err(BackendError.type_error("invalid operands for >=", Some(span)))

            case And:
                Ok(Value.bool(left.is_truthy() and right.is_truthy()))

            case Or:
                Ok(Value.bool(left.is_truthy() or right.is_truthy()))

            case _:
                Err(BackendError.not_implemented("binary operator not implemented"))

    fn eval_unaryop(op: HirUnaryOp, operand: Value, span: Span) -> Result<Value, BackendError>:
        match op:
            case Neg:
                match operand:
                    case Int(i): Ok(Value.int(-i))
                    case Float(f): Ok(Value.float(-f))
                    case _: Err(BackendError.type_error("invalid operand for -", Some(span)))

            case Not:
                Ok(Value.bool(not operand.is_truthy()))

            case _:
                Err(BackendError.not_implemented("unary operator not implemented"))

    fn values_equal(left: Value, right: Value) -> bool:
        match (left, right):
            case (Nil, Nil): true
            case (Bool(l), Bool(r)): l == r
            case (Int(l), Int(r)): l == r
            case (Float(l), Float(r)): l == r
            case (String(l), String(r)): l == r
            case _: false

    fn call_function(fn_value: Value, args: [Value], ctx: EvalContext, span: Span) -> Result<Value, BackendError>:
        match fn_value:
            case Function(f):
                # Check for builtin functions first
                val builtin_result = self.try_call_builtin(f.name, args)
                if builtin_result.?:
                    return builtin_result.unwrap()

                # Look up function in module
                if not ctx.module.functions.contains_key(f.symbol):
                    return Err(BackendError.runtime_error("function '{f.name}' not found", Some(span)))

                val fn_ = ctx.module.functions[f.symbol]
                self.call_hir_function(fn_, args, ctx)

            case Closure(c):
                self.call_closure(c, args, ctx)

            case _:
                Err(BackendError.type_error("value is not callable", Some(span)))

    fn call_hir_function(fn_: HirFunction, args: [Value], ctx: EvalContext) -> Result<Value, BackendError>:
        ctx.env.push_scope()

        # Bind parameters
        for i in 0..fn_.params.len():
            val param = fn_.params[i]
            val value = if i < args.len():
                args[i]
            elif param.default.?:
                self.eval_expr(param.default.unwrap(), ctx)?
            else:
                return Err(BackendError.runtime_error("missing argument for parameter {param.name}", Some(fn_.span)))

            ctx.env.define(param.symbol, value)

        # Execute body
        val result = self.eval_block(fn_.body, ctx)?

        ctx.env.pop_scope()
        Ok(result)

    fn call_closure(closure: ClosureValue, args: [Value], ctx: EvalContext) -> Result<Value, BackendError>:
        ctx.env.push_scope()

        # Bind captured variables
        for symbol in closure.captures.keys():
            val value = closure.captures[symbol]
            ctx.env.define(symbol, value)

        # Bind parameters
        for i in 0..closure.params.len():
            val param = closure.params[i]
            val value = if i < args.len():
                args[i]
            else:
                return Err(BackendError.runtime_error("missing argument for parameter", nil))

            ctx.env.define(param.symbol, value)

        # Evaluate body
        val result = self.eval_expr(closure.body, ctx)?

        ctx.env.pop_scope()
        Ok(result)

    fn apply_assign_op(op: HirAssignOp, left: Value, right: Value, span: Span) -> Result<Value, BackendError>:
        match op:
            case Add: self.eval_binop(HirBinOp.Add, left, right, span)
            case Sub: self.eval_binop(HirBinOp.Sub, left, right, span)
            case Mul: self.eval_binop(HirBinOp.Mul, left, right, span)
            case Div: self.eval_binop(HirBinOp.Div, left, right, span)
            case Mod: self.eval_binop(HirBinOp.Mod, left, right, span)
            case _: Err(BackendError.not_implemented("assignment operator not implemented"))

    fn try_call_builtin(name: text, args: [Value]) -> Result<Value, BackendError>?:
        """Try to call a builtin function. Returns None if not a builtin."""
        match name:
            case "print":
                if args.len() > 0:
                    val msg = self.value_to_string(args[0])
                    print msg
                else:
                    print ""
                Some(Ok(Value.Unit))
            case "println":
                if args.len() > 0:
                    val msg = self.value_to_string(args[0])
                    print msg
                else:
                    print ""
                Some(Ok(Value.Unit))
            case "to_string":
                if args.len() > 0:
                    Some(Ok(Value.string(self.value_to_string(args[0]))))
                else:
                    Some(Ok(Value.string("")))
            case _:
                nil

    fn value_to_string(value: Value) -> text:
        """Convert a Value to its string representation."""
        match value:
            case Nil: "nil"
            case Unit: "()"
            case Bool(b): if b: "true" else: "false"
            case Int(i): "{i}"
            case Float(f): "{f}"
            case Char(c): "{c}"
            case String(s): s
            case Array(elements):
                var parts: [text] = []
                for elem in elements:
                    parts = parts.push(self.value_to_string(elem))
                "[{parts.join(\", \")}]"
            case _: "<{value.type_name()}>"

# ============================================================================
# Compiler Backend Implementation
# ============================================================================

struct CompilerBackendImpl:
    """Compiling backend (HIR -> MIR -> codegen).

    Compiles HIR modules by:
    1. Lowering HIR to MIR
    2. Generating native code via Cranelift
    3. Either executing (JIT) or emitting object file (AOT)
    """
    mode: CodegenMode
    output_path: text?

impl CompilerBackendImpl:
    static fn jit() -> CompilerBackendImpl:
        """Create JIT compilation backend."""
        CompilerBackendImpl(mode: CodegenMode.Jit, output_path: nil)

    static fn aot(output: text) -> CompilerBackendImpl:
        """Create AOT compilation backend."""
        CompilerBackendImpl(mode: CodegenMode.Aot, output_path: Some(output))

impl Backend for CompilerBackendImpl:
    fn name() -> text:
        "compiler"

    fn kind() -> BackendKind:
        BackendKind.Compiler

    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>:
        # 1. Lower HIR to MIR
        var lowering = MirLowering.new(module.symbols)
        val mir_module = lowering.lower_module(module)

        # Check for lowering errors
        if lowering.errors.len() > 0:
            val first_error = lowering.errors[0]
            return Err(BackendError.compile_error(first_error.message, first_error.span))

        # 2. Create codegen pipeline based on mode
        val pipeline = match self.mode:
            case Jit: CodegenPipeline.jit()
            case Aot: CodegenPipeline.aot(CodegenTarget.Native)

        # 3. Compile MIR to native code
        val compile_result = pipeline.compile_module(mir_module)
        match compile_result:
            case Ok(compiled):
                match self.mode:
                    case Jit:
                        # JIT: Execute main function and return result
                        val call_result = compiled.call("main", [])
                        match call_result:
                            case Ok(value):
                                compiled.cleanup()
                                Ok(BackendResult.Value(Value.int(value)))
                            case Err(e):
                                compiled.cleanup()
                                Err(BackendError.runtime_error(e.message, e.span))
                    case Aot:
                        # AOT: Emit object file
                        val path = self.output_path ?? "a.o"
                        val emit_result = compiled.emit_object(path)
                        match emit_result:
                            case Ok(_):
                                compiled.cleanup()
                                Ok(BackendResult.Unit)
                            case Err(e):
                                compiled.cleanup()
                                Err(BackendError.compile_error(e.message, e.span))
            case Err(e):
                Err(BackendError.compile_error(e.message, e.span))

    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        Err(BackendError.not_implemented("compiler backend evaluates via generated code"))

    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>:
        Err(BackendError.not_implemented("compiler backend executes via generated code"))

    fn is_allowed(expr: HirExpr) -> bool:
        true

    fn is_allowed_stmt(stmt: HirStmt) -> bool:
        true

# ============================================================================
# SDN Backend Implementation
# ============================================================================

struct SdnBackendImpl:
    """No-op backend for SDN parsing.

    Blocks ALL code execution. Only allows:
    - Literal values (int, float, string, bool, nil)
    - Array and dict construction
    - No function calls, no control flow, no side effects
    """

impl Backend for SdnBackendImpl:
    fn name() -> text:
        "sdn"

    fn kind() -> BackendKind:
        BackendKind.Sdn

    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>:
        # SDN modules can't have functions
        if not module.functions.is_empty():
            return Err(BackendError.not_allowed("functions not allowed in SDN mode", nil))
        Ok(BackendResult.Unit)

    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("functions not allowed in SDN mode", Some(fn_.span)))

    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("classes not allowed in SDN mode", Some(class_.span)))

    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>:
        # Structs as data definitions are OK
        Ok(BackendResult.Unit)

    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>:
        # Enums as data definitions are OK
        Ok(BackendResult.Unit)

    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("traits not allowed in SDN mode", Some(trait_.span)))

    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("impls not allowed in SDN mode", Some(impl_.span)))

    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        if not self.is_allowed(expr):
            return Err(BackendError.not_allowed(
                "expression not allowed in SDN mode",
                Some(expr.span)
            ))

        match expr.kind:
            case IntLit(value, _):
                Ok(Value.int(value))
            case FloatLit(value, _):
                Ok(Value.float(value))
            case StringLit(value, _):
                Ok(Value.string(value))
            case BoolLit(value):
                Ok(Value.bool(value))
            case NilLit:
                Ok(Value.make_nil())
            case ArrayLit(elements, _):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Array(values))
            case DictLit(entries, _, _):
                var dict: Dict<text, Value> = {}
                for (key_expr, value_expr) in entries:
                    val key = self.eval_expr(key_expr, ctx)?
                    val value = self.eval_expr(value_expr, ctx)?
                    match key:
                        case String(k):
                            dict[k] = value
                        case _:
                            return Err(BackendError.type_error("dict key must be string", Some(expr.span)))
                Ok(Value.Dict(dict))
            case TupleLit(elements):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Tuple(values))
            case _:
                Err(BackendError.not_allowed("expression not allowed in SDN mode", Some(expr.span)))

    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>:
        Err(BackendError.not_allowed("statements not allowed in SDN mode", Some(stmt.span)))

    fn is_allowed(expr: HirExpr) -> bool:
        """Check if expression is allowed in SDN mode."""
        match expr.kind:
            # Only literal data construction is allowed
            case IntLit(_, _) | FloatLit(_, _) | StringLit(_, _)
               | BoolLit(_) | NilLit | UnitLit:
                true
            case ArrayLit(elements, _):
                elements.all(\e: self.is_allowed(e))
            case TupleLit(elements):
                elements.all(\e: self.is_allowed(e))
            case DictLit(entries, _, _):
                self.all_dict_entries_allowed(entries)
            # Everything else is blocked
            case _:
                false

    fn all_dict_entries_allowed(entries: [(HirExpr, HirExpr)]) -> bool:
        """Check if all dict entries are allowed in SDN mode."""
        for entry in entries:
            val (key, value) = entry
            if not self.is_allowed(key) or not self.is_allowed(value):
                return false
        true

    fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # No statements allowed in SDN mode
        false

# ============================================================================
# Exports
# ============================================================================

export Backend, BackendKind, BackendResult, BackendError, BackendErrorKind
export CompiledUnit, CompiledSymbol, CompiledSymbolKind, Relocation, RelocKind
export SdnValue, SdnValueKind
export Value, EnumPayloadValue, FunctionValue, ClosureValue, ObjectValue
export EvalContext, Environment
export HirVisitor
export create_backend, get_backend
export InterpreterBackendImpl, CompilerBackendImpl, SdnBackendImpl
