# Builtin Block Implementations
#
# Standard block types provided by the Simple language.
#
# Blocks:
#   - m{}      : Math block with power (^), transpose ('), implicit mul
#   - loss{}   : Math block with auto-backward for gradients
#   - nograd{} : Math block with gradient tracking disabled
#   - sh{}     : Shell command block
#   - sql{}    : SQL query block
#   - re{}     : Regular expression block
#   - json{}   : JSON literal block
#   - md{}     : Markdown block

use blocks.definition.{BlockDefinition, HighlightToken, HighlightKind, Completion, CompletionKind, HoverInfo, BlockExample, ConstValue, Type}
use blocks.modes.{LexerMode, LexerConfig, SyntaxFeatures, Span}
use blocks.context.{BlockContext, BlockError, BlockErrorKind}
use blocks.value.{BlockValue, ShellCommands, ShellCommand, Redirect, RedirectKind, SqlQuery, SqlKind, SqlParam, RegexPattern, JsonValue, JsonKind}

# ============================================================================
# Math Block (m{})
# ============================================================================

struct MathBlockDef(BlockDefinition):
    r"""Math block: enables math-like syntax.

    Features:
    - ^ as power operator (x^2)
    - ' as transpose operator (A')
    - Implicit multiplication (2x, (a)(b))
    - Broadcast operators (.+ .- .* ./ .^)
    - Matrix multiplication (@)

    Example:
        val result = m{ x^2 + 2*x*y + y^2 }
        val norm = m{ sqrt(x'x) }
    """

impl MathBlockDef:
    fn kind() -> text:
        "m"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Math blocks return raw payload - parsed with math mode by parser
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.math()

    fn description() -> text:
        "Math block with power (^), transpose ('), and implicit multiplication"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "m\{ x^2 + y^2 }",
                description: "Power operator",
                output: nil
            ),
            BlockExample(
                code: "m\{ A' @ A }",
                description: "Transpose and matrix multiply",
                output: nil
            ),
            BlockExample(
                code: "m\{ 2x + 3y }",
                description: "Implicit multiplication",
                output: nil
            )
        ]

    fn highlight(payload: text) -> [HighlightToken]:
        # Basic highlighting for math expressions
        var tokens: [HighlightToken] = []
        var i = 0
        while i < payload.len():
            val c = payload[i]
            match c:
                case '^' | '\'' | '@' | '+' | '-' | '*' | '/':
                    tokens = tokens.push(HighlightToken(
                        start: i,
                        end: i + 1,
                        kind: HighlightKind.Operator
                    ))
                case '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9':
                    val start = i
                    while i < payload.len() and payload[i].is_digit():
                        i = i + 1
                    tokens = tokens.push(HighlightToken(
                        start: start,
                        end: i,
                        kind: HighlightKind.Number
                    ))
                    continue
                case _:
                    pass
            i = i + 1
        tokens

# ============================================================================
# Loss Block (loss{})
# ============================================================================

struct LossBlockDef(BlockDefinition):
    r"""Loss block: math mode with automatic backward pass.

    Inherits all math block features plus:
    - Automatic gradient tracking
    - Calls .backward() on the result

    Example:
        loss{
            pred = model(x)
            cross_entropy(pred, y)
        }
    """

impl LossBlockDef:
    fn kind() -> text:
        "loss"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Loss blocks return raw payload - converted to LossBlock by parser
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.loss()

    fn description() -> text:
        "Loss computation with auto-backward"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "loss\{ mse(pred, target) }",
                description: "MSE loss with auto-backward",
                output: nil
            ),
            BlockExample(
                code: "loss\{\n    logits = model(x)\n    cross_entropy(logits, y)\n}",
                description: "Multi-line loss computation",
                output: nil
            )
        ]

# ============================================================================
# Nograd Block (nograd{})
# ============================================================================

struct NogradBlockDef(BlockDefinition):
    r"""Nograd block: math mode with gradient tracking disabled.

    Inherits all math block features plus:
    - Disables gradient tracking
    - Used for inference/evaluation

    Example:
        nograd{
            val pred = model(x)
            accuracy(pred, y)
        }
    """

impl NogradBlockDef:
    fn kind() -> text:
        "nograd"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Nograd blocks return raw payload - converted to NogradBlock by parser
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.nograd()

    fn description() -> text:
        "Computation with gradient tracking disabled"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "nograd\{ model(test_data) }",
                description: "Inference without gradients",
                output: nil
            )
        ]

# ============================================================================
# Shell Block (sh{})
# ============================================================================

struct ShellBlockDef(BlockDefinition):
    r"""Shell command block: execute shell commands.

    Features:
    - Raw text capture (no tokenization)
    - Supports pipes, redirects, variables
    - Returns command output as text

    Example:
        val files = sh{ ls -la }
        val result = sh{ cat file.txt | grep pattern }
    """

impl ShellBlockDef:
    fn kind() -> text:
        "sh"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        val trimmed = payload.trim()
        if trimmed.is_empty():
            return Err(BlockError.parse("Empty shell command"))

        # Parse shell commands
        val commands = parse_shell_commands(trimmed)
        Ok(BlockValue.Shell(commands))

    fn lexer_mode() -> LexerMode:
        LexerMode.Raw

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn description() -> text:
        "Shell command execution"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "sh\{ ls -la }",
                description: "List files",
                output: nil
            ),
            BlockExample(
                code: "sh\{ cat file.txt | grep pattern | wc -l }",
                description: "Pipeline with pipes",
                output: nil
            ),
            BlockExample(
                code: "sh\{ echo \"hello\" > output.txt }",
                description: "Redirect to file",
                output: nil
            )
        ]

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        # Check for dangerous commands
        match value:
            case Shell(commands):
                var errors: [BlockError] = []
                for cmd in commands.commands:
                    if cmd.program == "rm" and "-rf" in cmd.args:
                        errors = errors.push(
                            BlockError.validation("Potentially dangerous: rm -rf")
                                .with_suggestion("Consider using 'rm -i' for interactive deletion")
                        )
                errors
            case _:
                []

    fn highlight(payload: text) -> [HighlightToken]:
        var tokens: [HighlightToken] = []
        var i = 0
        var in_string = false
        var string_char = '"'

        while i < payload.len():
            val c = payload[i]

            # String handling
            if c == '"' or c == '\'':
                if not in_string:
                    in_string = true
                    string_char = c
                    val start = i
                    i = i + 1
                    while i < payload.len() and payload[i] != string_char:
                        i = i + 1
                    tokens = tokens.push(HighlightToken(
                        start: start,
                        end: i + 1,
                        kind: HighlightKind.String
                    ))
                    in_string = false
                i = i + 1
                continue

            # Operators
            if c == '|' or c == '>' or c == '<' or c == '&':
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 1,
                    kind: HighlightKind.Operator
                ))
                i = i + 1
                continue

            # Variable
            if c == '$':
                val start = i
                i = i + 1
                while i < payload.len() and (payload[i].is_alphanumeric() or payload[i] == '_'):
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i,
                    kind: HighlightKind.Variable
                ))
                continue

            i = i + 1

        tokens

# ============================================================================
# SQL Block (sql{})
# ============================================================================

struct SqlBlockDef(BlockDefinition):
    r"""SQL query block: write SQL queries.

    Features:
    - Raw text capture
    - SQL syntax highlighting
    - Parameter placeholders ($1, :name)
    - Query validation

    Example:
        val users = sql{ SELECT * FROM users WHERE age > 18 }
        val result = sql{ INSERT INTO logs (msg) VALUES ($1) }
    """

impl SqlBlockDef:
    fn kind() -> text:
        "sql"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        val trimmed = payload.trim()
        if trimmed.is_empty():
            return Err(BlockError.parse("Empty SQL query"))

        # Parse SQL query
        val query = parse_sql_query(trimmed)
        Ok(BlockValue.Sql(query))

    fn lexer_mode() -> LexerMode:
        LexerMode.Raw

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn description() -> text:
        "SQL query with parameter support"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "sql\{ SELECT * FROM users }",
                description: "Simple select",
                output: nil
            ),
            BlockExample(
                code: "sql\{ SELECT name, age FROM users WHERE id = $1 }",
                description: "Parameterized query",
                output: nil
            ),
            BlockExample(
                code: "sql\{\n    INSERT INTO users (name, email)\n    VALUES ($1, $2)\n    RETURNING id\n}",
                description: "Insert with returning",
                output: nil
            )
        ]

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        match value:
            case Sql(query):
                var errors: [BlockError] = []
                # Check for SQL injection patterns
                val raw = query.raw.lower()
                if "'; --" in raw or "1=1" in raw:
                    errors = errors.push(
                        BlockError.validation("Potential SQL injection pattern")
                            .with_note("Use parameterized queries instead")
                    )
                errors
            case _:
                []

    fn highlight(payload: text) -> [HighlightToken]:
        var tokens: [HighlightToken] = []
        val keywords = sql_keywords()

        # Simple word-based highlighting
        var i = 0
        while i < payload.len():
            # Skip whitespace
            while i < payload.len() and payload[i].is_whitespace():
                i = i + 1

            if i >= payload.len():
                break

            # String literals
            if payload[i] == '\'':
                val start = i
                i = i + 1
                while i < payload.len() and payload[i] != '\'':
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i + 1,
                    kind: HighlightKind.String
                ))
                i = i + 1
                continue

            # Parameters ($1, :name)
            if payload[i] == '$' or payload[i] == ':':
                val start = i
                i = i + 1
                while i < payload.len() and (payload[i].is_alphanumeric() or payload[i] == '_'):
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i,
                    kind: HighlightKind.Variable
                ))
                continue

            # Numbers
            if payload[i].is_digit():
                val start = i
                while i < payload.len() and (payload[i].is_digit() or payload[i] == '.'):
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i,
                    kind: HighlightKind.Number
                ))
                continue

            # Words (check for keywords)
            if payload[i].is_alphabetic():
                val start = i
                while i < payload.len() and (payload[i].is_alphanumeric() or payload[i] == '_'):
                    i = i + 1
                val word = payload[start:i].upper()
                if word in keywords:
                    tokens = tokens.push(HighlightToken(
                        start: start,
                        end: i,
                        kind: HighlightKind.Keyword
                    ))
                continue

            # Operators
            if payload[i] == '=' or payload[i] == '<' or payload[i] == '>' or payload[i] == '*':
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 1,
                    kind: HighlightKind.Operator
                ))

            i = i + 1

        tokens

    fn completions(payload: text, cursor: i64) -> [Completion]:
        # Basic SQL completions
        [
            Completion(label: "SELECT" + "", kind: CompletionKind.Keyword, detail: Some("Query data" + ""), insert_text: Some("SELECT " + ""), documentation: Some("Select columns from a table" + "")),
            Completion(label: "FROM" + "", kind: CompletionKind.Keyword, detail: Some("Specify table" + ""), insert_text: Some("FROM " + ""), documentation: nil),
            Completion(label: "WHERE" + "", kind: CompletionKind.Keyword, detail: Some("Filter results" + ""), insert_text: Some("WHERE " + ""), documentation: nil),
            Completion(label: "INSERT INTO" + "", kind: CompletionKind.Snippet, detail: Some("Insert data" + ""), insert_text: Some("INSERT INTO $\{1:table} ($\{2:columns}) VALUES ($\{3:values})"), documentation: nil),
            Completion(label: "UPDATE" + "", kind: CompletionKind.Keyword, detail: Some("Update data" + ""), insert_text: Some("UPDATE " + ""), documentation: nil),
            Completion(label: "DELETE FROM" + "", kind: CompletionKind.Snippet, detail: Some("Delete data" + ""), insert_text: Some("DELETE FROM $\{1:table} WHERE $\{2:condition}"), documentation: nil)
        ]

# ============================================================================
# Regex Block (re{})
# ============================================================================

struct RegexBlockDef(BlockDefinition):
    r"""Regular expression block: compile regex patterns.

    Features:
    - Raw text capture
    - Compile-time regex validation
    - Regex syntax highlighting

    Example:
        val pattern = re{ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ }
        val ip = re{ \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} }
    """

impl RegexBlockDef:
    fn kind() -> text:
        "re"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        val trimmed = payload.trim()
        if trimmed.is_empty():
            return Err(BlockError.parse("Empty regex pattern"))

        # Validate regex syntax
        match validate_regex(trimmed):
            case Ok(_):
                Ok(BlockValue.Regex(RegexPattern(raw: trimmed, _handle: 0)))
            case Err(msg):
                Err(BlockError.parse("Invalid regex: {msg}"))

    fn lexer_mode() -> LexerMode:
        LexerMode.Raw

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn description() -> text:
        "Compiled regular expression"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "re\{ [a-z]+ }",
                description: "Match lowercase letters",
                output: nil
            ),
            BlockExample(
                code: "re\{ ^\\d\{4}-\\d\{2}-\\d\{2}$ }",
                description: "Match date format YYYY-MM-DD",
                output: nil
            ),
            BlockExample(
                code: "re\{ (?P<name>\\w+)@(?P<domain>\\w+\\.\\w+) }",
                description: "Named capture groups",
                output: nil
            )
        ]

    fn eval_const(value: BlockValue) -> ConstValue?:
        # Regex can be evaluated at compile time
        match value:
            case Regex(pattern):
                Some(ConstValue.Regex(pattern.raw))
            case _:
                nil

    fn result_type(value: BlockValue) -> Type?:
        Some(Type(name: "Regex", args: []))

    fn highlight(payload: text) -> [HighlightToken]:
        var tokens: [HighlightToken] = []
        var i = 0

        while i < payload.len():
            val c = payload[i]

            # Character classes
            if c == '[':
                val start = i
                i = i + 1
                while i < payload.len() and payload[i] != ']':
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i + 1,
                    kind: HighlightKind.String
                ))
                i = i + 1
                continue

            # Groups
            if c == '(':
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 1,
                    kind: HighlightKind.Keyword
                ))
                # Check for named group
                if i + 2 < payload.len() and payload[i+1] == '?' and payload[i+2] == 'P':
                    val group_start = i
                    while i < payload.len() and payload[i] != '>':
                        i = i + 1
                    tokens = tokens.push(HighlightToken(
                        start: group_start,
                        end: i + 1,
                        kind: HighlightKind.Variable
                    ))
                i = i + 1
                continue

            if c == ')':
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 1,
                    kind: HighlightKind.Keyword
                ))
                i = i + 1
                continue

            # Quantifiers and anchors
            if c == '*' or c == '+' or c == '?' or c == '{' or c == '}' or c == '^' or c == '$':
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 1,
                    kind: HighlightKind.Operator
                ))
                i = i + 1
                continue

            # Escape sequences
            if c == '\\' and i + 1 < payload.len():
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 2,
                    kind: HighlightKind.Constant
                ))
                i = i + 2
                continue

            i = i + 1

        tokens

# ============================================================================
# JSON Block (json{})
# ============================================================================

struct JsonBlockDef(BlockDefinition):
    r"""JSON literal block: embed JSON data.

    Features:
    - Raw text capture
    - JSON syntax validation
    - Parsed to native Simple values

    Example:
        val config = json{
            "name": "myapp",
            "version": "1.0.0",
            "features": ["logging", "metrics"]
        }
    """

impl JsonBlockDef:
    fn kind() -> text:
        "json"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        val trimmed = payload.trim()
        if trimmed.is_empty():
            return Err(BlockError.parse("Empty JSON"))

        # Parse JSON
        match parse_json(trimmed):
            case Ok(value):
                Ok(BlockValue.Json(value))
            case Err(msg):
                Err(BlockError.parse("Invalid JSON: {msg}"))

    fn lexer_mode() -> LexerMode:
        LexerMode.Raw

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn description() -> text:
        "JSON literal"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "json\{ \{\"key\": \"value\"} }",
                description: "Object literal",
                output: nil
            ),
            BlockExample(
                code: "json\{ [1, 2, 3] }",
                description: "Array literal",
                output: nil
            )
        ]

    fn eval_const(value: BlockValue) -> ConstValue?:
        match value:
            case Json(jv):
                Some(json_to_const(jv))
            case _:
                nil

# ============================================================================
# Markdown Block (md{})
# ============================================================================

struct MarkdownBlockDef(BlockDefinition):
    r"""Markdown block: embed markdown text.

    Features:
    - Raw text capture
    - Markdown syntax highlighting
    - Can be rendered to HTML

    Example:
        val readme = md{
            # My Project

            A **simple** project with _markdown_ support.

            - Item 1
            - Item 2
        }
    """

impl MarkdownBlockDef:
    fn kind() -> text:
        "md"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Markdown is captured as raw text
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Raw

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn description() -> text:
        "Markdown text"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "md\{ # Heading }",
                description: "Markdown heading",
                output: nil
            )
        ]

# ============================================================================
# Helper Functions
# ============================================================================

fn sql_keywords() -> [text]:
    """Return SQL keywords for syntax highlighting."""
    val s = "SELECT"
    val f = "FROM"
    val w = "WHERE"
    [s, f, w, "INSERT", "INTO", "VALUES",
     "UPDATE", "SET", "DELETE", "CREATE", "TABLE", "DROP",
     "ALTER", "INDEX", "JOIN", "LEFT", "RIGHT", "INNER",
     "OUTER", "ON", "AND", "OR", "NOT", "NULL", "IS",
     "ORDER", "BY", "ASC", "DESC", "LIMIT", "OFFSET",
     "GROUP", "HAVING", "AS", "DISTINCT", "COUNT", "SUM",
     "AVG", "MIN", "MAX", "RETURNING", "CASCADE", "PRIMARY",
     "KEY", "FOREIGN", "REFERENCES", "DEFAULT", "UNIQUE"]

fn parse_shell_commands(raw: text) -> ShellCommands:
    """Parse shell command string into structured commands."""
    var commands: [ShellCommand] = []

    # Split by pipes first
    val parts = raw.split("|")

    for part in parts:
        val trimmed = part.trim()
        if trimmed.is_empty():
            continue

        # Split by whitespace for args
        val tokens = trimmed.split(" ").filter(\s: not s.is_empty())
        if tokens.is_empty():
            continue

        val program = tokens[0]
        var args: [text] = []
        var redirects: [Redirect] = []

        var i = 1
        while i < tokens.len():
            val tok = tokens[i]
            if tok == ">":
                if i + 1 < tokens.len():
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StdoutToFile,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == ">>":
                if i + 1 < tokens.len():
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StdoutAppend,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == "<":
                if i + 1 < tokens.len():
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StdinFromFile,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == "2>":
                if i + 1 < tokens.len():
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StderrToFile,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == "2>&1":
                redirects = redirects.push(Redirect(
                    kind: RedirectKind.StderrToStdout,
                    target: ""
                ))
                i = i + 1
                continue
            else:
                args = args.push(tok)
            i = i + 1

        commands = commands.push(ShellCommand(
            program: program,
            args: args,
            redirects: redirects,
            pipe_to: nil
        ))

    # Link commands in pipeline (build new array to avoid in-place mutation issue)
    var linked_commands: [ShellCommand] = []
    var i = 0
    while i < commands.len():
        val cmd = commands[i]
        val next_cmd = if i + 1 < commands.len(): Some(commands[i + 1]) else: nil
        linked_commands = linked_commands.push(ShellCommand(
            program: cmd.program,
            args: cmd.args,
            redirects: cmd.redirects,
            pipe_to: next_cmd
        ))
        i = i + 1

    ShellCommands(raw: raw, commands: linked_commands)

fn parse_sql_query(raw: text) -> SqlQuery:
    """Parse SQL query string."""
    val upper = raw.upper().trim()

    # Determine query kind
    val kind = if upper.starts_with("SELECT" + ""):
        SqlKind.Select
    else if upper.starts_with("INSERT" + ""):
        SqlKind.Insert
    else if upper.starts_with("UPDATE" + ""):
        SqlKind.Update
    else if upper.starts_with("DELETE" + ""):
        SqlKind.Delete
    else if upper.starts_with("CREATE" + ""):
        SqlKind.Create
    else if upper.starts_with("ALTER" + ""):
        SqlKind.Alter
    else if upper.starts_with("DROP" + ""):
        SqlKind.Drop
    else:
        SqlKind.Other

    # Extract table names (simple heuristic)
    var tables: [text] = []
    val words = raw.split(" ").filter(\s: not s.is_empty())
    var i = 0
    while i < words.len():
        val word = words[i].upper()
        if word == "FROM" + "" or word == "INTO" + "" or word == "UPDATE" + "" or word == "JOIN" + "":
            if i + 1 < words.len():
                tables = tables.push(words[i + 1].replace("," + "", "" + ""))
        i = i + 1

    # Extract parameters ($1, $2, :name)
    var params: [SqlParam] = []
    var pos = 0
    i = 0
    while i < raw.len():
        if raw[i] == '$' and i + 1 < raw.len() and raw[i + 1].is_digit():
            val start = i + 1
            var end = start
            while end < raw.len() and raw[end].is_digit():
                end = end + 1
            val num = raw[start:end].parse_i64() ?? (pos + 1)
            params = params.push(SqlParam(name: "${num}", position: pos))
            pos = pos + 1
            i = end
            continue
        else if raw[i] == ':' and i + 1 < raw.len() and raw[i + 1].is_alphabetic():
            val start = i + 1
            var end = start
            while end < raw.len() and (raw[end].is_alphanumeric() or raw[end] == '_'):
                end = end + 1
            val name = raw[start:end]
            params = params.push(SqlParam(name: name, position: pos))
            pos = pos + 1
            i = end
            continue
        i = i + 1

    SqlQuery(
        raw: raw,
        kind: kind,
        tables: tables,
        columns: [],  # TODO: Extract columns
        params: params
    )

fn validate_regex(pattern: text) -> Result<(), text>:
    """Validate regex pattern syntax."""
    # Basic validation - check balanced brackets/parens
    var paren_depth = 0
    var bracket_depth = 0
    var i = 0

    while i < pattern.len():
        val c = pattern[i]

        # Handle escape sequences
        if c == '\\' and i + 1 < pattern.len():
            i = i + 2
            continue

        match c:
            case '(':
                paren_depth = paren_depth + 1
            case ')':
                paren_depth = paren_depth - 1
                if paren_depth < 0:
                    return Err("Unmatched closing parenthesis")
            case '[':
                bracket_depth = bracket_depth + 1
            case ']':
                bracket_depth = bracket_depth - 1
                if bracket_depth < 0:
                    return Err("Unmatched closing bracket")
            case _:
                pass

        i = i + 1

    if paren_depth != 0:
        return Err("Unmatched opening parenthesis")
    if bracket_depth != 0:
        return Err("Unmatched opening bracket")

    Ok(())

# Helper struct for JSON parsing (avoids nested functions)
struct JsonParser:
    input: text
    pos: i64

impl JsonParser:
    me skip_whitespace():
        """Skip whitespace characters."""
        while self.pos < self.input.len() and self.input[self.pos].is_whitespace():
            self.pos = self.pos + 1

    me parse_value() -> Result<JsonValue, text>:
        """Parse a JSON value."""
        self.skip_whitespace()
        if self.pos >= self.input.len():
            return Err("Unexpected end of JSON")

        val c = self.input[self.pos]

        # Null
        if c == 'n' and self.input[self.pos:].starts_with("null"):
            self.pos = self.pos + 4
            return Ok(JsonValue(kind: JsonKind.Null))

        # Boolean
        if c == 't' and self.input[self.pos:].starts_with("true"):
            self.pos = self.pos + 4
            return Ok(JsonValue(kind: JsonKind.Bool(true)))
        if c == 'f' and self.input[self.pos:].starts_with("false"):
            self.pos = self.pos + 5
            return Ok(JsonValue(kind: JsonKind.Bool(false)))

        # String
        if c == '"':
            self.pos = self.pos + 1
            val start = self.pos
            while self.pos < self.input.len() and self.input[self.pos] != '"':
                if self.input[self.pos] == '\\' and self.pos + 1 < self.input.len():
                    self.pos = self.pos + 2
                else:
                    self.pos = self.pos + 1
            if self.pos >= self.input.len():
                return Err("Unterminated string")
            val s = self.input[start:self.pos]
            self.pos = self.pos + 1
            return Ok(JsonValue(kind: JsonKind.String(s)))

        # Number
        if c == '-' or c.is_digit():
            val start = self.pos
            if c == '-':
                self.pos = self.pos + 1
            while self.pos < self.input.len() and self.input[self.pos].is_digit():
                self.pos = self.pos + 1
            if self.pos < self.input.len() and self.input[self.pos] == '.':
                self.pos = self.pos + 1
                while self.pos < self.input.len() and self.input[self.pos].is_digit():
                    self.pos = self.pos + 1
            val num = self.input[start:self.pos].parse_f64() ?? 0.0
            return Ok(JsonValue(kind: JsonKind.Number(num)))

        # Array
        if c == '[':
            self.pos = self.pos + 1
            var elements: [JsonValue] = []
            self.skip_whitespace()
            if self.pos < self.input.len() and self.input[self.pos] == ']':
                self.pos = self.pos + 1
                return Ok(JsonValue(kind: JsonKind.Array(elements)))
            while true:
                match self.parse_value():
                    case Ok(v):
                        elements = elements.push(v)
                    case Err(e):
                        return Err(e)
                self.skip_whitespace()
                if self.pos >= self.input.len():
                    return Err("Unterminated array")
                if self.input[self.pos] == ']':
                    self.pos = self.pos + 1
                    return Ok(JsonValue(kind: JsonKind.Array(elements)))
                if self.input[self.pos] != ',':
                    return Err("Expected ',' or ']' in array")
                self.pos = self.pos + 1

        # Object
        if c == '{':
            self.pos = self.pos + 1
            var fields: [(text, JsonValue)] = []
            self.skip_whitespace()
            if self.pos < self.input.len() and self.input[self.pos] == '}':
                self.pos = self.pos + 1
                return Ok(JsonValue(kind: JsonKind.Object(fields)))
            while true:
                self.skip_whitespace()
                if self.pos >= self.input.len() or self.input[self.pos] != '"':
                    return Err("Expected string key in object")
                self.pos = self.pos + 1
                val key_start = self.pos
                while self.pos < self.input.len() and self.input[self.pos] != '"':
                    self.pos = self.pos + 1
                if self.pos >= self.input.len():
                    return Err("Unterminated key string")
                val key = self.input[key_start:self.pos]
                self.pos = self.pos + 1
                self.skip_whitespace()
                if self.pos >= self.input.len() or self.input[self.pos] != ':':
                    return Err("Expected ':' after key")
                self.pos = self.pos + 1
                match self.parse_value():
                    case Ok(v):
                        fields = fields.push((key, v))
                    case Err(e):
                        return Err(e)
                self.skip_whitespace()
                if self.pos >= self.input.len():
                    return Err("Unterminated object")
                if self.input[self.pos] == '}':
                    self.pos = self.pos + 1
                    return Ok(JsonValue(kind: JsonKind.Object(fields)))
                if self.input[self.pos] != ',':
                    return Err("Expected ',' or '}' in object")
                self.pos = self.pos + 1

        Err("Invalid JSON value at position {self.pos}")

fn parse_json(raw: text) -> Result<JsonValue, text>:
    """Parse JSON string to JsonValue."""
    val trimmed = raw.trim()
    if trimmed.is_empty():
        return Err("Empty JSON")

    var parser = JsonParser(input: trimmed, pos: 0)
    parser.parse_value()

fn json_field_to_const(field: (text, JsonValue)) -> (text, ConstValue):
    """Convert a JSON field tuple to a const field tuple."""
    val (name, value) = field
    (name, json_to_const(value))

fn json_to_const(jv: JsonValue) -> ConstValue:
    """Convert JsonValue to ConstValue."""
    match jv.kind:
        case Null:
            ConstValue.Nil
        case Bool(b):
            ConstValue.Bool(b)
        case Number(n):
            ConstValue.Float(n)
        case String(s):
            ConstValue.String(s)
        case Array(elements):
            ConstValue.Array(elements.map(\e: json_to_const(e)))
        case Object(fields):
            ConstValue.Struct("JsonObject", fields.map(\f: json_field_to_const(f)))

# ============================================================================
# Registration
# ============================================================================

fn register_builtin_blocks(registry: BlockRegistry):
    """Register all builtin blocks with the given registry."""
    registry.register(MathBlockDef())
    registry.register(LossBlockDef())
    registry.register(NogradBlockDef())
    registry.register(ShellBlockDef())
    registry.register(SqlBlockDef())
    registry.register(RegexBlockDef())
    registry.register(JsonBlockDef())
    registry.register(MarkdownBlockDef())

# ============================================================================
# Exports
# ============================================================================

export MathBlockDef, LossBlockDef, NogradBlockDef
export ShellBlockDef, SqlBlockDef, RegexBlockDef
export JsonBlockDef, MarkdownBlockDef
export register_builtin_blocks
