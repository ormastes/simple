# Loss Block Definition
#
# The loss{} block for differentiable computation with auto-backward.

use blocks.definition.{BlockDefinition, HighlightToken, BlockExample}
use blocks.modes.{LexerMode, SyntaxFeatures}
use blocks.context.{BlockContext, BlockError}
use blocks.value.{BlockValue}
use parser.{Parser, Block}

# ============================================================================
# Loss Block Definition
# ============================================================================

struct LossBlockDef: BlockDefinition:
    """Loss block definition for loss{} expressions.

    Inherits all math block features (^, ', implicit mul) and adds:
    - Automatic gradient tracking (autograd enabled)
    - Automatic backward() call on the result

    The loss block is designed for machine learning training loops
    where you want gradients computed automatically.

    Example:
        val total_loss = loss{
            pred = model(x)
            cross_entropy(pred, target)
        }
        # Gradients are automatically computed

        # Equivalent to:
        val total_loss = m{
            pred = model(x)
            cross_entropy(pred, target)
        }
        total_loss.backward()
    """

impl BlockDefinition for LossBlockDef:
    fn kind() -> text:
        "loss"

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.loss()

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        """Parse loss block payload as a block of statements.

        Unlike m{} which parses a single expression, loss{} parses
        a block of statements where the last expression is the loss value.
        """
        val parser = Parser.new(payload)

        match parser.parse_block():
            case Ok(block):
                if parser.has_errors():
                    val errors = parser.errors()
                    if errors.len() > 0:
                        return Err(BlockError.parse(errors[0].message))
                Ok(BlockValue.LossBlock(block))

            case Err(e):
                Err(BlockError.parse(e.message))

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        """Validate that the loss block ends with an expression."""
        match value:
            case LossBlock(block):
                if block.stmts.len() == 0:
                    return [BlockError.validation("loss block must contain at least one statement")]

                # Check that the last statement is an expression (the loss value)
                val last = block.stmts[block.stmts.len() - 1]
                match last.kind:
                    case StmtKind.Expr(_):
                        []  # OK
                    case _:
                        [BlockError.validation("loss block must end with an expression (the loss value)")
                            .with_suggestion("Add the loss expression at the end of the block")]
            case _:
                [BlockError.type_error("Expected LossBlock value")]

    fn description() -> text:
        "Loss block with auto-backward for gradient computation"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "loss{ cross_entropy(pred, target) }",
                description: "Simple loss computation with auto-backward",
                output: nil
            ),
            BlockExample(
                code: """loss{
    pred = model(x)
    ce = cross_entropy(pred, target)
    reg = 0.01 * W.norm()^2
    ce + reg
}""",
                description: "Complex loss with regularization",
                output: nil
            ),
            BlockExample(
                code: """for batch in train_loader:
    val l = loss{
        y = W @ batch.x + b
        mse(y, batch.y)
    }
    optimizer.step()""",
                description: "Training loop with loss block",
                output: nil
            )
        ]

# ============================================================================
# Exports
# ============================================================================

export LossBlockDef
