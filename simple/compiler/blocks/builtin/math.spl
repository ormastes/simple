# Math Block Definition
#
# The m{} block for mathematical expressions with special syntax.

use blocks.definition.{BlockDefinition, HighlightToken, HighlightKind, Completion, CompletionKind, BlockExample}
use blocks.modes.{LexerMode, SyntaxFeatures}
use blocks.context.{BlockContext, BlockError}
use blocks.value.{BlockValue}
use parser.{Parser, Expr}

# ============================================================================
# Math Block Definition
# ============================================================================

struct MathBlockDef: BlockDefinition:
    """Math block definition for m{} expressions.

    Enables mathematical notation:
    - ^ for power (instead of ** outside blocks)
    - ' for transpose (postfix)
    - Implicit multiplication (2x, (a)(b))
    - Broadcast operators (.+, .-, .*, ./, .^)
    - Matrix multiplication (@)

    Example:
        val result = m{ x^2 + 2*x + 1 }
        val y = m{ A' @ x }  # A^T * x
        val quad = m{ ax^2 + bx + c }  # Implicit mul
    """

impl BlockDefinition for MathBlockDef:
    fn kind() -> text:
        "m"

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.math()

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        """Parse math block payload as an expression.

        The payload is tokenized in math mode by the lexer,
        so ^, ', and implicit multiplication are already handled.
        """
        val parser = Parser.new(payload)
        # Note: Lexer already set to math mode, parser uses normal rules

        match parser.parse_expr():
            case Ok(expr):
                if parser.has_errors():
                    val errors = parser.errors()
                    if errors.len() > 0:
                        return Err(BlockError.parse(errors[0].message))
                Ok(BlockValue.Expr(expr))

            case Err(e):
                Err(BlockError.parse(e.message))

    fn highlight(payload: text) -> [HighlightToken]:
        """Syntax highlighting for math expressions."""
        var tokens: [HighlightToken] = []

        # Simple tokenization for highlighting
        var i = 0
        while i < payload.len():
            val c = payload[i]

            # Operators
            if c == '^' or c == '@' or c == '+' or c == '-' or c == '*' or c == '/' or c == '\'':
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 1,
                    kind: HighlightKind.Operator
                ))
                i = i + 1
                continue

            # Dotted operators
            if c == '.' and i + 1 < payload.len():
                val next = payload[i + 1]
                if next == '+' or next == '-' or next == '*' or next == '/' or next == '^':
                    tokens = tokens.push(HighlightToken(
                        start: i,
                        end: i + 2,
                        kind: HighlightKind.Operator
                    ))
                    i = i + 2
                    continue

            # Numbers
            if c >= '0' and c <= '9':
                val start = i
                while i < payload.len() and ((payload[i] >= '0' and payload[i] <= '9') or payload[i] == '.'):
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i,
                    kind: HighlightKind.Number
                ))
                continue

            # Identifiers
            if (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or c == '_':
                val start = i
                while i < payload.len():
                    val ch = payload[i]
                    if not ((ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or (ch >= '0' and ch <= '9') or ch == '_'):
                        break
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i,
                    kind: HighlightKind.Variable
                ))
                continue

            i = i + 1

        tokens

    fn completions(payload: text, cursor: i64) -> [Completion]:
        """Provide completions for math expressions."""
        # Common math functions
        [
            Completion(
                label: "sqrt",
                kind: CompletionKind.Function,
                detail: Some("Square root"),
                insert_text: Some("sqrt("),
                documentation: Some("Returns the square root of the argument")
            ),
            Completion(
                label: "sin",
                kind: CompletionKind.Function,
                detail: Some("Sine"),
                insert_text: Some("sin("),
                documentation: Some("Returns the sine of the argument (in radians)")
            ),
            Completion(
                label: "cos",
                kind: CompletionKind.Function,
                detail: Some("Cosine"),
                insert_text: Some("cos("),
                documentation: Some("Returns the cosine of the argument (in radians)")
            ),
            Completion(
                label: "exp",
                kind: CompletionKind.Function,
                detail: Some("Exponential"),
                insert_text: Some("exp("),
                documentation: Some("Returns e raised to the power of the argument")
            ),
            Completion(
                label: "log",
                kind: CompletionKind.Function,
                detail: Some("Natural logarithm"),
                insert_text: Some("log("),
                documentation: Some("Returns the natural logarithm of the argument")
            ),
            Completion(
                label: "abs",
                kind: CompletionKind.Function,
                detail: Some("Absolute value"),
                insert_text: Some("abs("),
                documentation: Some("Returns the absolute value of the argument")
            )
        ]

    fn description() -> text:
        "Math block with power (^), transpose ('), and implicit multiplication"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "m{ x^2 + 2*x + 1 }",
                description: "Quadratic expression using ^ for power",
                output: nil
            ),
            BlockExample(
                code: "m{ A' @ x }",
                description: "Matrix transpose and multiplication",
                output: nil
            ),
            BlockExample(
                code: "m{ 2x + 3y }",
                description: "Implicit multiplication",
                output: nil
            ),
            BlockExample(
                code: "m{ a .+ b }",
                description: "Broadcast addition",
                output: nil
            )
        ]

# ============================================================================
# Exports
# ============================================================================

export MathBlockDef
