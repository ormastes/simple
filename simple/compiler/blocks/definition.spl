# Block Definition Trait
#
# Interface for defining custom block types.

use blocks.modes.{LexerMode, SyntaxFeatures}
use blocks.context.{BlockContext, BlockError}
use blocks.value.{BlockValue}

# ============================================================================
# Block Definition Trait
# ============================================================================

trait BlockDefinition:
    """Definition for a custom block type.

    Implement this trait to create a new block type that can be
    registered with the BlockRegistry.

    Example:
    ```simple
    struct MyBlockDef: BlockDefinition:
        fn kind() -> text: "myblock"

        fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
            # Parse the payload
            val result = my_parser(payload)?
            Ok(BlockValue.Custom("MyBlock", result))
    ```
    """

    # ========================================================================
    # Required: Identity
    # ========================================================================

    fn kind() -> text:
        """Block keyword (e.g., "m", "loss", "sh", "sql").

        This is the identifier that triggers the block.
        Must be a valid Simple identifier.
        """

    # ========================================================================
    # Required: Parsing
    # ========================================================================

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        """Parse the block payload into a typed value.

        Args:
            payload: Raw text between { and } (braces not included)
            ctx: Context with source location, parent scope, etc.

        Returns:
            BlockValue containing typed AST or value, or BlockError on failure.

        Example for math block:
        ```simple
        fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
            val parser = Parser.new(payload)
            parser.set_mode(ParseMode.Math)
            match parser.parse_expr():
                case Ok(expr): Ok(BlockValue.Expr(expr))
                case Err(e): Err(BlockError.parse(e.message))
        ```
        """

    # ========================================================================
    # Optional: Lexer Mode
    # ========================================================================

    fn lexer_mode() -> LexerMode:
        """Return the lexer mode for this block's content.

        Controls how the block payload is tokenized:
        - Normal: Standard Simple tokenization
        - Math: Enables ^, ', implicit multiplication
        - Raw: No tokenization, capture as raw text
        - Custom: Fine-grained control via LexerConfig

        Default: LexerMode.Normal
        """
        LexerMode.Normal

    # ========================================================================
    # Optional: Syntax Features
    # ========================================================================

    fn syntax_features() -> SyntaxFeatures:
        """Return enabled syntax features for this block.

        Controls which special syntax elements are available:
        - power_caret: ^ as power operator
        - transpose_quote: ' as transpose
        - implicit_multiplication: 2x means 2*x
        - broadcast_ops: .+ .- .* ./ .^
        - matrix_mul: @ operator
        - auto_backward: call .backward() on result
        - disable_grad: disable gradient tracking

        Default: No special features
        """
        SyntaxFeatures.default()

    # ========================================================================
    # Optional: IDE Support
    # ========================================================================

    fn highlight(payload: text) -> [HighlightToken]:
        """Return syntax highlighting tokens for IDE.

        Default: No highlighting (treated as plain text)
        """
        []

    fn completions(payload: text, cursor: i64) -> [Completion]:
        """Return completions at cursor position.

        Args:
            payload: Current payload text
            cursor: Cursor position (byte offset)

        Default: No completions
        """
        []

    fn hover(payload: text, cursor: i64) -> HoverInfo?:
        """Return hover information at cursor position.

        Default: No hover info
        """
        nil

    fn signature_help(payload: text, cursor: i64) -> SignatureHelp?:
        """Return signature help at cursor position.

        Default: No signature help
        """
        nil

    # ========================================================================
    # Optional: Validation
    # ========================================================================

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        """Perform additional validation after parsing.

        Called after parse_payload succeeds. Can return additional
        errors or warnings.

        Default: No additional validation
        """
        []

    # ========================================================================
    # Optional: Compile-Time Evaluation
    # ========================================================================

    fn eval_const(value: BlockValue) -> ConstValue?:
        """Evaluate block at compile time if possible.

        If the block can be fully evaluated at compile time,
        return the constant value. This enables optimizations.

        Default: None (runtime evaluation only)
        """
        nil

    # ========================================================================
    # Optional: Code Generation
    # ========================================================================

    fn result_type(value: BlockValue) -> Type?:
        """Return the type of the block's result.

        Used for type checking and inference.

        Default: None (infer from value)
        """
        nil

    # ========================================================================
    # Optional: Documentation
    # ========================================================================

    fn description() -> text:
        """Return a short description of this block type.

        Used in error messages and documentation.

        Default: Empty string
        """
        ""

    fn examples() -> [BlockExample]:
        """Return usage examples for this block type.

        Used in documentation and IDE hints.

        Default: No examples
        """
        []

# ============================================================================
# IDE Support Types
# ============================================================================

struct HighlightToken:
    """Syntax highlighting token."""
    start: i64          # Start offset in payload
    end: i64            # End offset (exclusive)
    kind: HighlightKind

enum HighlightKind:
    Keyword
    Operator
    Number
    String
    Comment
    Function
    Variable
    Type
    Constant
    Error

struct Completion:
    """Completion suggestion."""
    label: text             # Display text
    kind: CompletionKind
    detail: text?           # Additional detail
    insert_text: text?      # Text to insert (if different from label)
    documentation: text?    # Documentation

enum CompletionKind:
    Keyword
    Function
    Variable
    Field
    Type
    Constant
    Operator
    Snippet

struct HoverInfo:
    """Hover information."""
    contents: text          # Markdown content
    range: (i64, i64)?      # Optional range in payload

struct SignatureHelp:
    """Signature help for function calls."""
    signatures: [Signature]
    active_signature: i64
    active_parameter: i64

struct Signature:
    """Function signature."""
    label: text
    documentation: text?
    parameters: [Parameter]

struct Parameter:
    """Function parameter."""
    label: text
    documentation: text?

# ============================================================================
# Compile-Time Values
# ============================================================================

"""Compile-time constant value."""
enum ConstValue:
    Nil
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    String(value: text)
    Array(elements: [ConstValue])
    Tuple(elements: [ConstValue])
    Struct(name: text, fields: [(text, ConstValue)])
    Regex(pattern: text)

# ============================================================================
# Type Placeholder
# ============================================================================

struct Type:
    """Type representation (placeholder - use actual compiler type)."""
    name: text
    args: [Type]

# ============================================================================
# Block Example
# ============================================================================

struct BlockExample:
    """Usage example for a block type."""
    code: text          # Example code
    description: text   # What the example demonstrates
    output: text?       # Expected output (if applicable)

# ============================================================================
# Exports
# ============================================================================

pub use BlockDefinition
pub use HighlightToken, HighlightKind
pub use Completion, CompletionKind
pub use HoverInfo, SignatureHelp, Signature, Parameter
pub use ConstValue, Type, BlockExample
