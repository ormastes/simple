# Block Resolver
#
# Resolves blocks from outline to typed values.
# This is a phase between TreeSitter (outline) and Parser (full AST).

use blocks.registry.{BlockRegistry, block_registry}
use blocks.definition.{BlockDefinition}
use blocks.context.{BlockContext, BlockError, Diagnostic, DiagnosticLevel}
use blocks.value.{BlockValue, ResolvedBlock}
use blocks.modes.{Span}
use treesitter.{OutlineModule, BlockOutline}

# ============================================================================
# Resolved Module
# ============================================================================

struct ResolvedModule:
    """Module outline with resolved blocks.

    Contains the original outline plus all blocks that have been
    parsed and resolved to typed values.
    """
    outline: OutlineModule
    blocks: [ResolvedBlock]
    block_map: Dict<Span, ResolvedBlock>  # Lookup by span for parser

impl ResolvedModule:
    static fn new(outline: OutlineModule, blocks: [ResolvedBlock]) -> ResolvedModule:
        # Build span -> block map for efficient lookup
        var block_map: Dict<Span, ResolvedBlock> = {}
        for block in blocks:
            block_map = block_map.insert(block.span, block)

        ResolvedModule(
            outline: outline,
            blocks: blocks,
            block_map: block_map
        )

    fn lookup(span: Span) -> ResolvedBlock?:
        """Look up a resolved block by its span."""
        self.block_map.get(span)

    fn has_blocks() -> bool:
        """Check if any blocks were found."""
        self.blocks.len() > 0

    fn block_count() -> i64:
        """Return number of resolved blocks."""
        self.blocks.len()

# ============================================================================
# Block Resolver
# ============================================================================

struct BlockResolver:
    """Resolves blocks from outline to typed values.

    Takes block outlines captured by TreeSitter and calls the appropriate
    block handlers to parse their payloads.

    Usage:
        val ts = TreeSitter.new(source)
        val outline = ts.parse_outline()

        val (resolved, diagnostics) = BlockResolver.resolve_module(outline)
        if diagnostics.has_errors():
            return Err(diagnostics)

        val parser = Parser.new(source, resolved)
    """
    registry: BlockRegistry
    diagnostics: [Diagnostic]
    file_path: text?
    module_name: text?

impl BlockResolver:
    static fn new() -> BlockResolver:
        BlockResolver(
            registry: block_registry(),
            diagnostics: [],
            file_path: nil,
            module_name: nil
        )

    static fn with_registry(registry: BlockRegistry) -> BlockResolver:
        BlockResolver(
            registry: registry,
            diagnostics: [],
            file_path: nil,
            module_name: nil
        )

    me with_file(path: text) -> BlockResolver:
        self.file_path = Some(path)
        self

    me with_module(name: text) -> BlockResolver:
        self.module_name = Some(name)
        self

    # ========================================================================
    # Main Entry Points
    # ========================================================================

    static fn resolve_module(outline: OutlineModule) -> (ResolvedModule, [Diagnostic]):
        """Resolve all blocks in an outline module.

        Returns the resolved module and any diagnostics encountered.
        """
        var resolver = BlockResolver(
            registry: block_registry(),
            diagnostics: [],
            file_path: nil,
            module_name: nil
        )
        resolver.resolve_outline(outline)

    me resolve(outline: OutlineModule) -> (ResolvedModule, [Diagnostic]):
        """Resolve all blocks in an outline module.

        Instance method version for custom configuration.
        """
        var resolved: [ResolvedBlock] = []

        for block in outline.inline_blocks:
            match self.resolve_block(block):
                case Ok(rb):
                    resolved = resolved.push(rb)
                case Err(_):
                    pass  # Error already recorded in diagnostics

        (ResolvedModule.new(outline, resolved), self.diagnostics)

    me resolve_block(block: BlockOutline) -> Result<ResolvedBlock, ()>:
        """Resolve a single block outline to a typed value."""
        # Look up block definition
        val blk_def = self.registry.lookup(block.kind)
        if not blk_def.?:
            self.add_error(
                "Unknown block type: '{block.kind}'",
                block.span
            )
            return Err(())

        val handler = blk_def.unwrap()

        # Build context for the block handler
        val ctx = self.make_context(block)

        # Parse the payload
        match handler.parse_payload(block.payload, ctx):
            case Ok(value):
                # Optionally validate
                val validation_errors = handler.validate(value, ctx)
                for err in validation_errors:
                    self.add_diagnostic(err.to_diagnostic(ctx))

                if validation_errors.len() > 0:
                    # Still return the value but mark as having errors
                    pass

                Ok(ResolvedBlock.new(
                    block.kind,
                    value,
                    block.span,
                    block.payload_span
                ))

            case Err(err):
                self.add_diagnostic(err.to_diagnostic(ctx))
                Err(())

    # ========================================================================
    # Context Building
    # ========================================================================

    me make_context(block: BlockOutline) -> BlockContext:
        """Build a BlockContext for a block outline."""
        var ctx = BlockContext.new(
            block.payload,
            block.payload_span,
            block.span
        )

        if self.file_path.?:
            ctx = ctx.with_file(self.file_path.unwrap())

        if self.module_name.?:
            ctx = ctx.with_module(self.module_name.unwrap())

        if block.parent_context.?:
            ctx = ctx.inside_block(block.parent_context.unwrap())

        ctx

    # ========================================================================
    # Diagnostic Helpers
    # ========================================================================

    me add_error(message: text, span: Span):
        """Add an error diagnostic."""
        self.diagnostics = self.diagnostics.push(
            Diagnostic.error(message, span)
        )

    me add_warning(message: text, span: Span):
        """Add a warning diagnostic."""
        self.diagnostics = self.diagnostics.push(
            Diagnostic.warning(message, span)
        )

    me add_diagnostic(diag: Diagnostic):
        """Add a diagnostic directly."""
        self.diagnostics = self.diagnostics.push(diag)

    fn has_errors() -> bool:
        """Check if any error diagnostics were recorded."""
        for diag in self.diagnostics:
            if diag.is_error():
                return true
        false

    fn error_count() -> i64:
        """Count error diagnostics."""
        var count = 0
        for diag in self.diagnostics:
            if diag.is_error():
                count = count + 1
        count

# ============================================================================
# Resolution Result Helpers
# ============================================================================

struct ResolutionResult:
    """Result of block resolution with convenient accessors."""
    module: ResolvedModule
    diagnostics: [Diagnostic]

impl ResolutionResult:
    fn is_ok() -> bool:
        """Check if resolution succeeded without errors."""
        for diag in self.diagnostics:
            if diag.is_error():
                return false
        true

    fn is_err() -> bool:
        not self.is_ok()

    fn errors() -> [Diagnostic]:
        """Return only error diagnostics."""
        var errors: [Diagnostic] = []
        for diag in self.diagnostics:
            if diag.is_error():
                errors = errors.push(diag)
        errors

    fn warnings() -> [Diagnostic]:
        """Return only warning diagnostics."""
        var warnings: [Diagnostic] = []
        for diag in self.diagnostics:
            match diag.level:
                case DiagnosticLevel.Warning:
                    warnings = warnings.push(diag)
                case _:
                    pass
        warnings

# ============================================================================
# Convenience Functions
# ============================================================================

fn make_block_resolver() -> BlockResolver:
    """Create a new BlockResolver with default settings."""
    BlockResolver(
        registry: block_registry(),
        diagnostics: [],
        file_path: nil,
        module_name: nil
    )

fn resolve_blocks(outline: OutlineModule) -> (ResolvedModule, [Diagnostic]):
    """Resolve all blocks in an outline module.

    Convenience function using the global block registry.
    """
    var resolver = make_block_resolver()
    resolver.resolve(outline)

fn resolve_blocks_with_registry(
    outline: OutlineModule,
    registry: BlockRegistry
) -> (ResolvedModule, [Diagnostic]):
    """Resolve all blocks using a custom registry."""
    var resolver = BlockResolver(
        registry: registry,
        diagnostics: [],
        file_path: nil,
        module_name: nil
    )
    resolver.resolve(outline)

# ============================================================================
# Exports
# ============================================================================

pub use BlockResolver, ResolvedModule, ResolutionResult
pub use resolve_blocks, resolve_blocks_with_registry, make_block_resolver
