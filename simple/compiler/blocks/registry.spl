# Block Registry
#
# Central registry for block definitions.

import .definition.{BlockDefinition}
import .modes.{LexerMode, SyntaxFeatures}

# ============================================================================
# Block Registry
# ============================================================================

struct BlockRegistry:
    """Central registry for block definitions.

    The registry maps block keywords to their definitions.
    Use `BlockRegistry.default()` to get a registry with built-in blocks.

    Example:
    ```simple
    val registry = BlockRegistry.default()

    # Check if a keyword is a block
    if registry.is_block_keyword("sql"):
        val def = registry.lookup("sql").unwrap()
        val mode = def.lexer_mode()
    ```
    """
    blocks: Dict<text, BlockDefinition>

impl BlockRegistry:
    static fn new() -> BlockRegistry:
        """Create an empty registry."""
        BlockRegistry(blocks: {})

    static fn default() -> BlockRegistry:
        """Create a registry with all built-in blocks.

        Built-in blocks:
        - Math/ML: m, loss, nograd
        - DSL: sh, sql, re, json, md

        Built-in blocks are registered in simple/compiler/blocks/builtin.spl.
        """
        var reg = BlockRegistry.new()

        # Import and register built-in blocks
        import .builtin.{
            MathBlockDef, LossBlockDef, NogradBlockDef,
            ShellBlockDef, SqlBlockDef, RegexBlockDef,
            JsonBlockDef, MarkdownBlockDef
        }

        # Math/ML blocks
        reg.register(MathBlockDef())
        reg.register(LossBlockDef())
        reg.register(NogradBlockDef())

        # DSL blocks
        reg.register(ShellBlockDef())
        reg.register(SqlBlockDef())
        reg.register(RegexBlockDef())
        reg.register(JsonBlockDef())
        reg.register(MarkdownBlockDef())

        reg

    me register(def: BlockDefinition):
        """Register a block definition.

        Args:
            def: The block definition to register

        Note: If a block with the same kind is already registered,
        it will be replaced.
        """
        self.blocks[def.kind()] = def

    me unregister(kind: text) -> bool:
        """Unregister a block by keyword.

        Returns true if the block was found and removed.
        """
        if self.blocks.contains_key(kind):
            self.blocks = self.blocks.remove(kind)
            true
        else:
            false

    fn lookup(kind: text) -> BlockDefinition?:
        """Look up a block definition by keyword.

        Returns None if the keyword is not registered.
        """
        self.blocks.get(kind)

    fn is_block_keyword(word: text) -> bool:
        """Check if a word is a registered block keyword."""
        self.blocks.contains_key(word)

    fn all_keywords() -> [text]:
        """Return all registered block keywords."""
        self.blocks.keys()

    fn count() -> i64:
        """Return the number of registered blocks."""
        self.blocks.len()

    me clear():
        """Remove all registered blocks."""
        self.blocks = {}

    fn lexer_mode_for(kind: text) -> LexerMode:
        """Get the lexer mode for a block, or Normal if not found."""
        match self.lookup(kind):
            case Some(def): def.lexer_mode()
            case None: LexerMode.Normal

    fn syntax_features_for(kind: text) -> SyntaxFeatures:
        """Get syntax features for a block, or default if not found."""
        match self.lookup(kind):
            case Some(def): def.syntax_features()
            case None: SyntaxFeatures.default()

# ============================================================================
# Global Registry
# ============================================================================

# Global registry instance for convenience
# Use `block_registry()` to access
var _global_registry: BlockRegistry? = None

fn block_registry() -> BlockRegistry:
    """Get the global block registry.

    Initializes with default blocks on first access.
    """
    if not _global_registry.?:
        _global_registry = Some(BlockRegistry.default())
    _global_registry.unwrap()

fn register_block(def: BlockDefinition):
    """Register a block in the global registry."""
    block_registry().register(def)

fn unregister_block(kind: text) -> bool:
    """Unregister a block from the global registry."""
    block_registry().unregister(kind)

fn is_block(kind: text) -> bool:
    """Check if a keyword is a registered block."""
    block_registry().is_block_keyword(kind)

# ============================================================================
# Registry Builder (for configuration)
# ============================================================================

struct RegistryBuilder:
    """Builder for creating a custom BlockRegistry.

    Example:
    ```simple
    val registry = RegistryBuilder.new()
        .with_builtin()
        .register(MyBlockDef())
        .without("nograd")
        .build()
    ```
    """
    registry: BlockRegistry
    include_builtin: bool

impl RegistryBuilder:
    static fn new() -> RegistryBuilder:
        RegistryBuilder(
            registry: BlockRegistry.new(),
            include_builtin: false
        )

    me with_builtin() -> RegistryBuilder:
        """Include built-in blocks (m, loss, nograd, sh, sql, re, json, md)."""
        self.include_builtin = true
        self

    me register(def: BlockDefinition) -> RegistryBuilder:
        """Register a block definition."""
        self.registry.register(def)
        self

    me without(kind: text) -> RegistryBuilder:
        """Exclude a block (useful after with_builtin)."""
        self.registry.unregister(kind)
        self

    fn build() -> BlockRegistry:
        """Build the final registry."""
        if self.include_builtin:
            import .builtin.{
                MathBlockDef, LossBlockDef, NogradBlockDef,
                ShellBlockDef, SqlBlockDef, RegexBlockDef,
                JsonBlockDef, MarkdownBlockDef
            }
            # Math/ML blocks
            self.registry.register(MathBlockDef())
            self.registry.register(LossBlockDef())
            self.registry.register(NogradBlockDef())
            # DSL blocks
            self.registry.register(ShellBlockDef())
            self.registry.register(SqlBlockDef())
            self.registry.register(RegexBlockDef())
            self.registry.register(JsonBlockDef())
            self.registry.register(MarkdownBlockDef())

        self.registry

# ============================================================================
# Exports
# ============================================================================

export BlockRegistry, RegistryBuilder
export block_registry, register_block, unregister_block, is_block
