# Compiler Driver
#
# Orchestrates the compilation pipeline from source to executable.
# Supports multiple modes: interpret, jit, aot, check, sdn.

use compiler.config.{Config, Logger, TypeDefault, TypeInferenceConfig}
use aop.{AopWeaver, LogAspect}
use di.*
use lexer.*
use treesitter.*
use parser.*
use hir.*
use resolve.*
use backend.*
use mir.*
use codegen.*
use blocks.resolver.{BlockResolver, ResolvedModule}
use blocks.registry.{block_registry}
use type_infer.{HmInferContext, TypeInferError}
use simple.compiler.smf_writer.{generate_smf_with_templates, Target}

# Helper function to create a Config (avoids static method calls)
fn create_config() -> Config:
    Config(values: {})

# Helper function to create a BlockResolver (avoids static method calls)
fn create_block_resolver() -> BlockResolver:
    BlockResolver(
        registry: block_registry(),
        diagnostics: [],
        file_path: nil,
        module_name: nil
    )

# Helper function to create a SymbolTable (avoids static method calls)
fn create_symbol_table() -> SymbolTable:
    var table = SymbolTable(
        symbols: {},
        scopes: {},
        current_scope: ScopeId(id: 0),
        next_symbol_id: 0,
        next_scope_id: 1
    )
    # Create root scope (direct mutation avoids copy-modify-reassign bug)
    table.scopes[0] = Scope(
        id: ScopeId(id: 0),
        parent: nil,
        kind: ScopeKind.Module,
        symbols: {}
    )
    table

# Helper function to create HirLowering (avoids static method calls)
fn create_hir_lowering() -> HirLowering:
    HirLowering(
        symbols: create_symbol_table(),
        errors: [],
        current_function: nil,
        loop_depth: 0
    )

# ------------------------------------------------------------------------------
# Compilation Mode
# ------------------------------------------------------------------------------

enum CompileMode:
    Interpret       # Tree-walking interpreter
    Jit             # JIT compile and run
    Aot             # Ahead-of-time compile to executable
    Check           # Type check only, no execution
    Sdn             # SDN data parsing mode (no code execution)

impl CompileMode:
    fn to_text() -> text:
        match self:
            case CompileMode.Interpret: "interpret"
            case CompileMode.Jit: "jit"
            case CompileMode.Aot: "aot"
            case CompileMode.Check: "check"
            case CompileMode.Sdn: "sdn"
            case _: "unknown"

    static fn from_text(s: text) -> CompileMode?:
        match s:
            case "interpret" | "i": Some(CompileMode.Interpret)
            case "jit" | "j": Some(CompileMode.Jit)
            case "aot" | "a" | "compile" | "c": Some(CompileMode.Aot)
            case "check" | "k": Some(CompileMode.Check)
            case "sdn" | "s" | "data": Some(CompileMode.Sdn)
            case _: nil

# ------------------------------------------------------------------------------
# Output Format (for AOT compilation)
# ------------------------------------------------------------------------------

enum OutputFormat:
    Native      # Emit native executable (default)
    Smf         # Emit .smf module file
    Both        # Emit both native executable and .smf

impl OutputFormat:
    fn to_text() -> text:
        match self:
            case OutputFormat.Native: "native"
            case OutputFormat.Smf: "smf"
            case OutputFormat.Both: "both"
            case _: "native"

    static fn from_text(s: text) -> OutputFormat:
        match s:
            case "smf": OutputFormat.Smf
            case "both": OutputFormat.Both
            case _: OutputFormat.Native

# ------------------------------------------------------------------------------
# Compilation Options
# ------------------------------------------------------------------------------

struct CompileOptions:
    mode: CompileMode
    input_files: [text]
    output_file: text?
    output_format: OutputFormat
    optimize: bool
    debug_info: bool
    verbose: bool
    log_level: i64
    profile: text           # dev, test, prod

    static fn default() -> CompileOptions:
        CompileOptions(
            mode: CompileMode.Interpret,
            input_files: [],
            output_file: nil,
            output_format: OutputFormat.Native,
            optimize: false,
            debug_info: true,
            verbose: false,
            log_level: 4,       # Info
            profile: "dev"
        )

# ------------------------------------------------------------------------------
# Compilation Result
# ------------------------------------------------------------------------------

enum CompileResult:
    Success(value: Any?)
    TypeError(errors: [text])
    ParseError(errors: [text])
    BlockError(errors: [text])     # Block resolution errors
    ResolveError(errors: [text])
    CodegenError(message: text)
    RuntimeError(message: text)

    fn is_success() -> bool:
        match self:
            case CompileResult.Success(_): true
            case _: false

    fn get_value() -> Any?:
        match self:
            case CompileResult.Success(v): v
            case _: nil

    fn get_errors() -> [text]:
        match self:
            case CompileResult.Success(_): []
            case CompileResult.TypeError(e): e
            case CompileResult.ParseError(e): e
            case CompileResult.BlockError(e): e
            case CompileResult.ResolveError(e): e
            case CompileResult.CodegenError(m): [m]
            case CompileResult.RuntimeError(m): [m]
            case _: []

# ------------------------------------------------------------------------------
# Source File
# ------------------------------------------------------------------------------

struct SourceFile:
    path: text
    content: text
    module_name: text

    static fn load(path: text) -> Result<SourceFile, text>:
        val content_opt = rt_file_read_text(path)
        # rt_file_read_text returns Option<text>
        if content_opt.is_none():
            return Err("Failed to read file: {path}")
        val content = content_opt.unwrap()

        # Extract module name from path
        val name = path.split("/").last() ?? "main"
        val name_no_spl = name.replace(".spl", "")
        val module_name = name_no_spl.replace(".sdn", "")

        Ok(SourceFile(
            path: path,
            content: content,
            module_name: module_name
        ))

# ------------------------------------------------------------------------------
# Compilation Context
# ------------------------------------------------------------------------------

class CompileContext:
    options: CompileOptions
    config: Dict<text, text>  # Using dict instead of Config to avoid interpreter issues
    di: DiContainer
    aop: AopWeaver
    logger: Logger
    sources: [SourceFile]
    modules: Dict<text, Module>
    hir_modules: Dict<text, HirModule>
    mir_modules: Dict<text, MirModule>
    errors: [text]
    warnings: [text]

    static fn create(options: CompileOptions) -> CompileContext:
        # Load config
        val config = {}  # Simple dict for now

        # Setup DI container
        val di = DiContainer(bindings: {}, singletons: {}, profile: options.profile)

        # Register backend based on mode (eagerly, no closures)
        match options.mode:
            case CompileMode.Interpret:
                di.bind_instance("Backend", InterpreterBackendImpl())
            case CompileMode.Jit:
                di.bind_instance("Backend", CompilerBackendImpl.jit())
            case CompileMode.Aot:
                val output = options.output_file ?? "a.out"
                di.bind_instance("Backend", CompilerBackendImpl.aot(output))
            case CompileMode.Sdn:
                di.bind_instance("Backend", SdnBackendImpl())
            case CompileMode.Check:
                # Check mode uses a no-op backend
                di.bind_instance("Backend", CheckBackendImpl())

        # Setup logger from env var (SIMPLE_LOG=debug|trace|info|warn|error)
        val logger = if options.verbose:
            Logger(level: 10)  # verbose flag forces debug level
        else:
            Logger.from_env()

        # Setup AOP
        var aop = AopWeaver(aspects: [], logger: logger)
        if options.verbose:
            aop.add_aspect(LogAspect(level: 6, logger: aop.logger))

        CompileContext(
            options: options,
            config: config,
            di: di,
            aop: aop,
            logger: logger,
            sources: [],
            modules: {},
            hir_modules: {},
            mir_modules: {},
            errors: [],
            warnings: []
        )

    me add_error(message: text):
        self.errors.push(message)

    me add_warning(message: text):
        self.warnings.push(message)

    fn has_errors() -> bool:
        self.errors.len() > 0

# ------------------------------------------------------------------------------
# Check Backend (Type Check Only)
# ------------------------------------------------------------------------------

class CheckBackendImpl(Backend):
    fn name() -> text:
        "check"

    fn is_allowed(op: text) -> bool:
        # Allow everything for type checking
        true

    fn process_module(module: HirModule) -> Result<Any, text>:
        # Just validate, don't execute
        Ok(nil)

    fn eval_expr(expr: HirExpr, env: Environment) -> Result<Value, text>:
        # Don't evaluate, just return unit
        Ok(Value.Unit)

    fn exec_stmt(stmt: HirStmt, env: Environment) -> Result<Value, text>:
        Ok(Value.Unit)

# ------------------------------------------------------------------------------
# Compiler Driver
# ------------------------------------------------------------------------------

class CompilerDriver:
    ctx: CompileContext

    static fn create(options: CompileOptions) -> CompilerDriver:
        CompilerDriver(ctx: CompileContext.create(options))

    # --------------------------------------------------------------------------
    # Main compilation entry point
    # --------------------------------------------------------------------------

    me compile() -> CompileResult:
        val log = self.ctx.logger

        # Phase 1: Load source files
        log.debug("phase 1: loading sources...")
        if not self.load_sources_impl():
            log.error("phase 1 FAILED")
            return CompileResult.ParseError(self.ctx.errors)
        log.debug("phase 1 done, {self.ctx.sources.len()} sources loaded")

        # Phase 2: Parse all sources
        log.debug("phase 2: parsing...")
        if not self.parse_all_impl():
            log.error("phase 2 FAILED")
            return CompileResult.ParseError(self.ctx.errors)
        log.debug("phase 2 done")

        # Phase 3: Lower to HIR, resolve methods, and type check (combined loop)
        log.debug("phase 3: lowering and checking...")
        log.trace("BEFORE phase 3: hir_modules count = {self.ctx.hir_modules.keys().len()}")
        val analyze_ok = self.lower_and_check_impl()
        log.trace("AFTER phase 3: hir_modules count = {self.ctx.hir_modules.keys().len()}")
        if not analyze_ok:
            log.error("phase 3 FAILED")
            # Determine error type from first error
            if self.ctx.errors.len() > 0:
                val first_error = self.ctx.errors[0]
                if first_error.contains("Method resolution"):
                    return CompileResult.ResolveError(self.ctx.errors)
            return CompileResult.TypeError(self.ctx.errors)
        log.debug("phase 3 done")

        # Phase 5: Mode-specific processing
        log.debug("phase 5: mode-specific processing...")
        match self.ctx.options.mode:
            case CompileMode.Check:
                log.debug("check mode")
                return CompileResult.Success(nil)

            case CompileMode.Sdn:
                log.debug("sdn mode")
                return self.process_sdn()

            case CompileMode.Interpret:
                log.debug("interpret mode")
                return self.interpret()

            case CompileMode.Jit:
                log.debug("jit mode")
                return self.jit_compile_and_run()

            case CompileMode.Aot:
                log.debug("aot mode")
                return self.aot_compile()

        log.warn("no mode matched, falling through")
        CompileResult.Success(nil)

    # --------------------------------------------------------------------------
    # Phase 1: Load sources
    # --------------------------------------------------------------------------

    me load_sources_impl() -> bool:
        val log = self.ctx.logger
        log.debug("input_files count={self.ctx.options.input_files.len()}")
        var i = 0
        while i < self.ctx.options.input_files.len():
            val path = self.ctx.options.input_files[i]
            log.trace("loading file: {path}")
            match SourceFile.load(path):
                case Ok(source):
                    log.trace("loaded OK: {source.path}")
                    self.ctx.sources.push(source)
                case Err(e):
                    log.error("load error: {e}")
                    self.ctx.add_error(e)
            i = i + 1
        log.debug("sources stored, count={self.ctx.sources.len()}")

        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Phase 2: Parse
    # --------------------------------------------------------------------------

    me parse_all_impl() -> bool:
        val log = self.ctx.logger
        val sources = self.ctx.sources
        log.debug("parsing {sources.len()} sources")
        var src_idx = 0
        while src_idx < sources.len():
            val source = sources[src_idx]
            log.trace("parsing: {source.path} (module={source.module_name}, len={source.content.len()})")
            val module = self.parse_source(source)
            self.ctx.modules[source.module_name] = module
            log.trace("stored module, total={self.ctx.modules.keys().len()}")
            src_idx = src_idx + 1

        log.debug("parsing done, modules={self.ctx.modules.keys().len()}")
        not self.ctx.has_errors()

    fn parse_source(source: SourceFile) -> Module:
        val log = self.ctx.logger

        # Phase 2a: Outline parsing (TreeSitter)
        log.trace("2a: outline parsing...")
        var ts = TreeSitter.new(source.content)
        val outline = ts.parse_outline()

        # Phase 2b: Block resolution
        log.trace("2b: resolving blocks...")
        var resolver = create_block_resolver()
        resolver = resolver.with_file(source.path)
        resolver = resolver.with_module(source.module_name)
        val (resolved, block_diagnostics) = resolver.resolve(outline)

        # Phase 2c: Full parse with resolved blocks
        log.trace("2c: full parse...")
        var parser = Parser.with_resolved_blocks(source.content, resolved)
        val module = parser.parse()
        module

    # --------------------------------------------------------------------------
    # Phase 3: Combined HIR Lowering + Method Resolution + Type Checking
    # --------------------------------------------------------------------------
    #
    # This combined implementation processes each module through all three
    # phases in a single loop, avoiding redundant iterations and improving
    # performance on large codebases.

    me lower_and_check_impl() -> bool:
        val log = self.ctx.logger
        var lowering = create_hir_lowering()

        val module_names = self.ctx.modules.keys()
        log.debug("lowering {module_names.len()} modules to HIR")
        for name in module_names:
            log.trace("processing module: {name}")
            val module = self.ctx.modules[name]
            if module == nil:
                log.error("module is nil for key {name}")
                continue

            # Step 1: Lower to HIR
            val hir_module = lowering.lower_module(module)
            log.trace("HIR lowered for {name}")

            # Step 2: Method resolution (UFCS)
            val (resolved_module, resolve_errors) = resolve_methods(hir_module)
            log.trace("methods resolved, errors={resolve_errors.len()}")

            # Collect method resolution errors
            var err_idx = 0
            while err_idx < resolve_errors.len():
                val err = resolve_errors[err_idx]
                self.ctx.add_error("Method resolution error in {name}: {err.message}")
                err_idx = err_idx + 1

            # Step 3: Type checking (HM inference) - skipped for bootstrap
            # Store final module directly (avoids copy-modify-reassign bug in compiled mode)
            self.ctx.hir_modules[name] = resolved_module
            log.trace("stored HIR module '{name}', total={self.ctx.hir_modules.keys().len()}")

        log.debug("HIR lowering complete: {self.ctx.hir_modules.keys().len()} modules")
        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Phase 3a: Lower to HIR (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn lower_to_hir_impl() -> (CompileContext, bool):
        var lowering = create_hir_lowering()
        var ctx = self.ctx

        val module_names = ctx.modules.keys()
        for name in module_names:
            val module = ctx.modules[name]
            val hir_module = lowering.lower_module(module)
            ctx.hir_modules[name] = hir_module
        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Phase 3b: Method Resolution (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn resolve_methods_impl() -> (CompileContext, bool):
        var ctx = self.ctx

        for name in ctx.hir_modules.keys():
            val hir_module = ctx.hir_modules[name]
            val (resolved_module, resolve_errors) = resolve_methods(hir_module)

            # Update the module with resolved method calls (direct mutation)
            ctx.hir_modules[name] = resolved_module

            # Collect errors
            for err in resolve_errors:
                ctx.errors.push("Method resolution error in {name}: {err.message}")

        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Phase 3c: Type Checking (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn type_check_impl() -> (CompileContext, bool):
        var ctx = self.ctx

        # Type inference disabled for bootstrap compatibility
        # for name in ctx.hir_modules.keys():
        #     val hir_module = ctx.hir_modules[name]
        #     var infer_ctx = HmInferContext.with_builtins()
        #     infer_ctx.infer_module(hir_module)
        #     for err in infer_ctx.errors:
        #         var errors = ctx.errors
        #         errors.push("Type error in {name}: {err.message()}")
        #         ctx.errors = errors

        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Mode: SDN (Data only)
    # --------------------------------------------------------------------------

    fn process_sdn() -> CompileResult:
        val backend = self.ctx.di.resolve("Backend")
        val results: Dict<text, Any> = {}

        for name in self.ctx.hir_modules.keys():
            val hir_module = self.ctx.hir_modules[name]
            match backend.process_module(hir_module):
                case Ok(value):
                    results[name] = value
                case Err(e):
                    return CompileResult.RuntimeError("SDN error in {name}: {e}")

        CompileResult.Success(results)

    # --------------------------------------------------------------------------
    # Mode: Interpret
    # --------------------------------------------------------------------------

    fn interpret() -> CompileResult:
        # Delegate to simple_old runtime for interpretation
        # The bootstrap compiler's struct field access has codegen issues
        # that prevent the self-hosted interpreter/JIT from working
        if self.ctx.options.input_files.len() == 0:
            return CompileResult.Error("No source file specified for interpret mode")
        val source_file = self.ctx.options.input_files[0]

        val simple_old = find_simple_old_binary()
        if simple_old == "":
            return CompileResult.Error("Cannot find simple_old binary for interpretation")

        val result = rt_shell("{simple_old} {source_file}")
        if result.stdout.?:
            print result.stdout
        if result.exit_code != 0:
            if result.stderr.?:
                return CompileResult.Error(result.stderr)
            return CompileResult.Error("Interpret failed with exit code {result.exit_code}")
        CompileResult.Success(BackendResult.Unit)

    fn run_module(backend: Backend, module: HirModule) -> CompileResult:
        match backend.process_module(module):
            case Ok(value): CompileResult.Success(value)
            case Err(e): CompileResult.RuntimeError(e)

    # --------------------------------------------------------------------------
    # Mode: JIT Compile and Run
    # --------------------------------------------------------------------------

    me jit_compile_and_run() -> CompileResult:
        # Lower to MIR
        if not self.lower_to_mir():
            return CompileResult.CodegenError(self.ctx.errors.first() ?? "MIR lowering failed")

        # JIT compile
        var pipeline = CodegenPipeline()

        for name in self.ctx.mir_modules.keys():
            val mir_module = self.ctx.mir_modules[name]
            match pipeline.jit_compile(mir_module):
                case Ok(_): pass
                case Err(e):
                    return CompileResult.CodegenError("JIT compile error in {name}: {e}")

        # Find and call main
        val main_fn = pipeline.get_function("main")
        if main_fn == nil:
            return CompileResult.RuntimeError("No main function found")

        match pipeline.call_function("main", []):
            case Ok(result): CompileResult.Success(result)
            case Err(e): CompileResult.RuntimeError(e)

    # --------------------------------------------------------------------------
    # Mode: AOT Compile
    # --------------------------------------------------------------------------

    me aot_compile() -> CompileResult:
        val log = self.ctx.logger

        # Lower to MIR
        log.debug("AOT: lowering to MIR ({self.ctx.hir_modules.keys().len()} HIR modules)")
        if not self.lower_to_mir():
            for err in self.ctx.errors:
                log.error("MIR error: {err}")
            return CompileResult.CodegenError(self.ctx.errors.first() ?? "MIR lowering failed")
        log.debug("MIR done, {self.ctx.mir_modules.keys().len()} modules")

        # Determine output file
        val output = self.ctx.options.output_file ?? "a.out"

        # Dispatch based on output format
        val format = self.ctx.options.output_format
        match format:
            case OutputFormat.Smf:
                return self.compile_to_smf(output)
            case OutputFormat.Both:
                # Compile native first, then SMF
                val native_result = self.compile_to_native(output)
                if not native_result.is_success():
                    return native_result
                val smf_result = self.compile_to_smf("{output}.smf")
                if not smf_result.is_success():
                    return smf_result
                return CompileResult.Success(output)
            case _:
                # Native (default)
                return self.compile_to_native(output)

    me compile_to_native(output: text) -> CompileResult:
        val log = self.ctx.logger
        log.debug("AOT native: compiling to {output}")

        # AOT compile all modules
        var pipeline = CodegenPipeline.aot(CodegenTarget.Native)
        var compiled_modules: [CompiledModule] = []

        for name in self.ctx.mir_modules.keys():
            log.trace("compiling module: {name}")
            val mir_module = self.ctx.mir_modules[name]
            match pipeline.compile_module(mir_module):
                case Ok(compiled):
                    compiled_modules = compiled_modules.push(compiled)
                case Err(e):
                    return CompileResult.CodegenError("AOT compile error in {name}: {e.message}")

        # Emit object files
        var object_files: [text] = []
        for module in compiled_modules:
            val obj_path = "{output}.{module.name}.o"
            match module.emit_object(obj_path):
                case Ok(_):
                    object_files = object_files.push(obj_path)
                case Err(e):
                    return CompileResult.CodegenError("Object emit error: {e.message}")

        # Link object files into final executable
        match self.link_objects(object_files, output):
            case Ok(_):
                log.info("Native executable written to {output}")
                CompileResult.Success(output)
            case Err(e):
                CompileResult.CodegenError("Linking failed: {e}")

    me compile_to_smf(output: text) -> CompileResult:
        val log = self.ctx.logger
        log.debug("AOT SMF: compiling to {output}")

        # AOT compile all modules to get object code
        var pipeline = CodegenPipeline.aot(CodegenTarget.Native)
        var all_object_bytes: [u8] = []

        for name in self.ctx.mir_modules.keys():
            log.trace("compiling module for SMF: {name}")
            val mir_module = self.ctx.mir_modules[name]
            match pipeline.compile_module(mir_module):
                case Ok(compiled):
                    # Emit to temporary object file, then read bytes
                    val tmp_path = "{output}.{name}.tmp.o"
                    match compiled.emit_object(tmp_path):
                        case Ok(_):
                            val bytes = rt_file_read_bytes(tmp_path)
                            if bytes.?:
                                all_object_bytes = all_object_bytes.concat(bytes.unwrap())
                            rt_file_delete(tmp_path)
                        case Err(e):
                            return CompileResult.CodegenError("Object emit error: {e.message}")
                case Err(e):
                    return CompileResult.CodegenError("AOT compile error in {name}: {e.message}")

        # Wrap object code into SMF format
        val target = Target.host()
        val smf_bytes = generate_smf_with_templates(all_object_bytes, nil, nil, target)

        # Write SMF file
        if rt_file_write_bytes(output, smf_bytes):
            log.info("SMF module written to {output}")
            CompileResult.Success(output)
        else:
            CompileResult.CodegenError("Failed to write SMF file: {output}")

    # --------------------------------------------------------------------------
    # Linker Helper
    # --------------------------------------------------------------------------

    fn link_objects(objects: [text], output: text) -> Result<text, text>:
        if objects.is_empty():
            return Err("No object files to link")

        # Find runtime library directory
        val lib_dir = find_runtime_lib_dir()

        # Build linker command with dynamic linking to runtime
        var cmd = "cc"
        for obj in objects:
            cmd = cmd + " " + obj
        cmd = cmd + " -L{lib_dir} -lsimple_compiler"
        cmd = cmd + " -lc -lpthread -ldl -lm -lgcc_s"
        cmd = cmd + " -Wl,-rpath,{lib_dir}"
        cmd = cmd + " -o {output}"

        val result = rt_shell(cmd)
        if result.exit_code == 0:
            Ok(output)
        else:
            Err(result.stderr ?? "Unknown linking error")

    # --------------------------------------------------------------------------
    # MIR Lowering
    # --------------------------------------------------------------------------

    me lower_to_mir() -> bool:
        var lowering = MirLowering.new(create_symbol_table())

        val hir_keys = self.ctx.hir_modules.keys()
        for name in hir_keys:
            val hir_module = self.ctx.hir_modules[name]
            var mir_module = lowering.lower_module(hir_module)
            # Ensure module name is set
            mir_module.name = name
            # Direct mutation (avoids copy-modify-reassign bug in compiled mode)
            self.ctx.mir_modules[name] = mir_module

        not self.ctx.has_errors()

# ------------------------------------------------------------------------------
# Runtime Library Discovery
# ------------------------------------------------------------------------------

fn find_runtime_lib_dir() -> text:
    # Check env var first
    val env_path = rt_env_get("SIMPLE_RUNTIME_PATH")
    if env_path.? and env_path != "":
        return env_path
    # Default to target/debug
    if rt_file_exists("target/debug/libsimple_compiler.so"):
        return "target/debug"
    if rt_file_exists("target/release/libsimple_compiler.so"):
        return "target/release"
    "target/debug"

# ------------------------------------------------------------------------------
# Binary Discovery
# ------------------------------------------------------------------------------

fn find_simple_old_binary() -> text:
    # Check env vars (new name first, then legacy)
    val runtime_path = rt_env_get("SIMPLE_RUNTIME_PATH")
    if runtime_path.? and runtime_path != "":
        return runtime_path
    val env_path = rt_env_get("SIMPLE_OLD_PATH")
    if env_path.? and env_path != "":
        return env_path
    # Check dev paths (new name first, then legacy)
    if rt_file_exists("./target/debug/simple_runtime"):
        return "./target/debug/simple_runtime"
    if rt_file_exists("./target/release/simple_runtime"):
        return "./target/release/simple_runtime"
    if rt_file_exists("./target/debug/simple_old"):
        return "./target/debug/simple_old"
    if rt_file_exists("./target/release/simple_old"):
        return "./target/release/simple_old"
    ""

# ------------------------------------------------------------------------------
# Convenience Functions
# ------------------------------------------------------------------------------

fn compile_file(path: text) -> CompileResult:
    val options = CompileOptions.default()
    options.input_files = [path]
    val driver = CompilerDriver.create(options)
    driver.compile()

fn compile_files(paths: [text], mode: CompileMode) -> CompileResult:
    val options = CompileOptions.default()
    options.input_files = paths
    options.mode = mode
    val driver = CompilerDriver.create(options)
    driver.compile()

fn interpret_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Interpret)

fn jit_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Jit)

fn aot_file(path: text, output: text) -> CompileResult:
    val options = CompileOptions.default()
    options.input_files = [path]
    options.mode = CompileMode.Aot
    options.output_file = Some(output)
    val driver = CompilerDriver.create(options)
    driver.compile()

fn check_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Check)

fn parse_sdn_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Sdn)

# ------------------------------------------------------------------------------
# FFI Declarations
# ------------------------------------------------------------------------------

extern fn rt_file_read_text(path: text) -> text?
extern fn rt_file_read_bytes(path: text) -> [u8]?
extern fn rt_file_write_bytes(path: text, data: [u8]) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_write_file(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_env_get(name: text) -> text?
extern fn sys_get_args() -> [text]

# Shell execution result
struct ShellResult:
    exit_code: i64
    stdout: text?
    stderr: text?

extern fn rt_shell(command: text) -> ShellResult
