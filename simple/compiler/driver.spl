# Compiler Driver
#
# Orchestrates the compilation pipeline from source to executable.
# Supports multiple modes: interpret, jit, aot, check, sdn.

use compiler.config.{Config, Logger, TypeDefault, TypeInferenceConfig}
use aop.{AopWeaver, LogAspect}
use di.*
use lexer.*
use treesitter.*
use parser.*
use hir.*
use resolve.*
use backend.*
use mir.*
use codegen.*
use blocks.resolver.{BlockResolver, ResolvedModule}
use blocks.registry.{block_registry}
use type_infer.{HmInferContext, TypeInferError}

# Helper function to create a Config (avoids static method calls)
fn create_config() -> Config:
    Config(values: {})

# Helper function to create a BlockResolver (avoids static method calls)
fn create_block_resolver() -> BlockResolver:
    BlockResolver(
        registry: block_registry(),
        diagnostics: [],
        file_path: nil,
        module_name: nil
    )

# Helper function to create a SymbolTable (avoids static method calls)
fn create_symbol_table() -> SymbolTable:
    var table = SymbolTable(
        symbols: {},
        scopes: {},
        current_scope: ScopeId(id: 0),
        next_symbol_id: 0,
        next_scope_id: 1
    )
    # Create root scope
    var scopes = table.scopes
    scopes[0] = Scope(
        id: ScopeId(id: 0),
        parent: nil,
        kind: ScopeKind.Module,
        symbols: {}
    )
    table.scopes = scopes
    table

# Helper function to create HirLowering (avoids static method calls)
fn create_hir_lowering() -> HirLowering:
    HirLowering(
        symbols: create_symbol_table(),
        errors: [],
        current_function: nil,
        loop_depth: 0
    )

# ------------------------------------------------------------------------------
# Compilation Mode
# ------------------------------------------------------------------------------

enum CompileMode:
    Interpret       # Tree-walking interpreter
    Jit             # JIT compile and run
    Aot             # Ahead-of-time compile to executable
    Check           # Type check only, no execution
    Sdn             # SDN data parsing mode (no code execution)

impl CompileMode:
    fn to_text() -> text:
        match self:
            case CompileMode.Interpret: "interpret"
            case CompileMode.Jit: "jit"
            case CompileMode.Aot: "aot"
            case CompileMode.Check: "check"
            case CompileMode.Sdn: "sdn"
            case _: "unknown"

    static fn from_text(s: text) -> CompileMode?:
        match s:
            case "interpret" | "i": Some(CompileMode.Interpret)
            case "jit" | "j": Some(CompileMode.Jit)
            case "aot" | "a" | "compile" | "c": Some(CompileMode.Aot)
            case "check" | "k": Some(CompileMode.Check)
            case "sdn" | "s" | "data": Some(CompileMode.Sdn)
            case _: nil

# ------------------------------------------------------------------------------
# Compilation Options
# ------------------------------------------------------------------------------

struct CompileOptions:
    mode: CompileMode
    input_files: [text]
    output_file: text?
    optimize: bool
    debug_info: bool
    verbose: bool
    log_level: i64
    profile: text           # dev, test, prod

    static fn default() -> CompileOptions:
        CompileOptions(
            mode: CompileMode.Interpret,
            input_files: [],
            output_file: nil,
            optimize: false,
            debug_info: true,
            verbose: false,
            log_level: 4,       # Info
            profile: "dev"
        )

# ------------------------------------------------------------------------------
# Compilation Result
# ------------------------------------------------------------------------------

enum CompileResult:
    Success(value: Any?)
    TypeError(errors: [text])
    ParseError(errors: [text])
    BlockError(errors: [text])     # Block resolution errors
    ResolveError(errors: [text])
    CodegenError(message: text)
    RuntimeError(message: text)

    fn is_success() -> bool:
        match self:
            case CompileResult.Success(_): true
            case _: false

    fn get_value() -> Any?:
        match self:
            case CompileResult.Success(v): v
            case _: nil

    fn get_errors() -> [text]:
        match self:
            case CompileResult.Success(_): []
            case CompileResult.TypeError(e): e
            case CompileResult.ParseError(e): e
            case CompileResult.BlockError(e): e
            case CompileResult.ResolveError(e): e
            case CompileResult.CodegenError(m): [m]
            case CompileResult.RuntimeError(m): [m]
            case _: []

# ------------------------------------------------------------------------------
# Source File
# ------------------------------------------------------------------------------

struct SourceFile:
    path: text
    content: text
    module_name: text

    static fn load(path: text) -> Result<SourceFile, text>:
        val content_opt = rt_file_read_text(path)
        # rt_file_read_text returns Option<text>
        if content_opt.is_none():
            return Err("Failed to read file: {path}")
        val content = content_opt.unwrap()

        # Extract module name from path
        val name = path.split("/").last() ?? "main"
        val name_no_spl = name.replace(".spl", "")
        val module_name = name_no_spl.replace(".sdn", "")

        Ok(SourceFile(
            path: path,
            content: content,
            module_name: module_name
        ))

# ------------------------------------------------------------------------------
# Compilation Context
# ------------------------------------------------------------------------------

class CompileContext:
    options: CompileOptions
    config: Dict<text, text>  # Using dict instead of Config to avoid interpreter issues
    di: DiContainer
    aop: AopWeaver
    sources: [SourceFile]
    modules: Dict<text, Module>
    hir_modules: Dict<text, HirModule>
    mir_modules: Dict<text, MirModule>
    errors: [text]
    warnings: [text]

    static fn create(options: CompileOptions) -> CompileContext:
        # Load config
        val config = {}  # Simple dict for now

        # Setup DI container
        val di = DiContainer(bindings: {}, singletons: {}, profile: options.profile)

        # Register backend based on mode (eagerly, no closures)
        match options.mode:
            case CompileMode.Interpret:
                di.bind_instance("Backend", InterpreterBackendImpl())
            case CompileMode.Jit:
                di.bind_instance("Backend", CompilerBackendImpl.jit())
            case CompileMode.Aot:
                val output = options.output_file ?? "a.out"
                di.bind_instance("Backend", CompilerBackendImpl.aot(output))
            case CompileMode.Sdn:
                di.bind_instance("Backend", SdnBackendImpl())
            case CompileMode.Check:
                # Check mode uses a no-op backend
                di.bind_instance("Backend", CheckBackendImpl())

        # Setup AOP
        var aop = AopWeaver(aspects: [], logger: Logger(level: options.log_level))
        if options.verbose:
            aop.add_aspect(LogAspect(level: 6, logger: aop.logger))

        CompileContext(
            options: options,
            config: config,
            di: di,
            aop: aop,
            sources: [],
            modules: {},
            hir_modules: {},
            mir_modules: {},
            errors: [],
            warnings: []
        )

    me add_error(message: text):
        self.errors.push(message)

    me add_warning(message: text):
        self.warnings.push(message)

    fn has_errors() -> bool:
        self.errors.len() > 0

# ------------------------------------------------------------------------------
# Check Backend (Type Check Only)
# ------------------------------------------------------------------------------

class CheckBackendImpl(Backend):
    fn name() -> text:
        "check"

    fn is_allowed(op: text) -> bool:
        # Allow everything for type checking
        true

    fn process_module(module: HirModule) -> Result<Any, text>:
        # Just validate, don't execute
        Ok(nil)

    fn eval_expr(expr: HirExpr, env: Environment) -> Result<Value, text>:
        # Don't evaluate, just return unit
        Ok(Value.Unit)

    fn exec_stmt(stmt: HirStmt, env: Environment) -> Result<Value, text>:
        Ok(Value.Unit)

# ------------------------------------------------------------------------------
# Compiler Driver
# ------------------------------------------------------------------------------

class CompilerDriver:
    ctx: CompileContext

    static fn create(options: CompileOptions) -> CompilerDriver:
        CompilerDriver(ctx: CompileContext.create(options))

    # --------------------------------------------------------------------------
    # Main compilation entry point
    # --------------------------------------------------------------------------

    me compile() -> CompileResult:
        # Phase 1: Load source files
        print "[compile] phase 1: loading sources..."
        if not self.load_sources_impl():
            print "[compile] phase 1 FAILED"
            return CompileResult.ParseError(self.ctx.errors)
        print "[compile] phase 1 done, {self.ctx.sources.len()} sources loaded"

        # Phase 2: Parse all sources
        print "[compile] phase 2: parsing..."
        if not self.parse_all_impl():
            print "[compile] phase 2 FAILED"
            return CompileResult.ParseError(self.ctx.errors)
        print "[compile] phase 2 done"

        # Phase 3: Lower to HIR, resolve methods, and type check (combined loop)
        print "[compile] phase 3: lowering and checking..."
        print "[compile] BEFORE phase 3: hir_modules count = {self.ctx.hir_modules.keys().len()}"
        val analyze_ok = self.lower_and_check_impl()
        print "[compile] AFTER phase 3: self.ctx.hir_modules count = {self.ctx.hir_modules.keys().len()}"
        if not analyze_ok:
            print "[compile] phase 3 FAILED"
            # Determine error type from first error
            if self.ctx.errors.len() > 0:
                val first_error = self.ctx.errors[0]
                if first_error.contains("Method resolution"):
                    return CompileResult.ResolveError(self.ctx.errors)
            return CompileResult.TypeError(self.ctx.errors)
        print "[compile] phase 3 done"

        # Phase 5: Mode-specific processing
        print "[compile] phase 5: mode-specific processing..."
        match self.ctx.options.mode:
            case CompileMode.Check:
                print "[compile] check mode"
                return CompileResult.Success(nil)

            case CompileMode.Sdn:
                print "[compile] sdn mode"
                return self.process_sdn()

            case CompileMode.Interpret:
                print "[compile] interpret mode"
                return self.interpret()

            case CompileMode.Jit:
                print "[compile] jit mode"
                return self.jit_compile_and_run()

            case CompileMode.Aot:
                print "[compile] aot mode"
                return self.aot_compile()

        print "[compile] WARNING: no mode matched, falling through"
        CompileResult.Success(nil)

    # --------------------------------------------------------------------------
    # Phase 1: Load sources
    # --------------------------------------------------------------------------

    me load_sources_impl() -> bool:
        print "[load] input_files count={self.ctx.options.input_files.len()}"
        var sources = self.ctx.sources
        var i = 0
        while i < self.ctx.options.input_files.len():
            val path = self.ctx.options.input_files[i]
            print "[load] loading file: {path}"
            match SourceFile.load(path):
                case Ok(source):
                    print "[load] loaded OK: {source.path}"
                    sources.push(source)
                case Err(e):
                    print "[load] error: {e}"
                    self.ctx.add_error(e)
            i = i + 1
        self.ctx.sources = sources
        print "[load] sources stored, count={self.ctx.sources.len()}"

        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Phase 2: Parse
    # --------------------------------------------------------------------------

    me parse_all_impl() -> bool:
        val sources = self.ctx.sources
        print "[parse_all] sources count={sources.len()}"
        var modules = self.ctx.modules
        var src_idx = 0
        while src_idx < sources.len():
            val source = sources[src_idx]
            val spath = source.path
            val smod = source.module_name
            val scontent = source.content
            print "[parse_all] spath={spath}"
            print "[parse_all] smod={smod}"
            print "[parse_all] content_len={scontent.len()}"
            val module = self.parse_source(source)
            print "[parse_all] parse_source returned"
            modules[smod] = module
            print "[parse_all] stored, total={modules.keys().len()}"
            src_idx = src_idx + 1
        self.ctx.modules = modules

        print "[parse_all] done, modules={self.ctx.modules.keys().len()}"
        not self.ctx.has_errors()

    fn parse_source(source: SourceFile) -> Module:
        # Phase 2a: Outline parsing (TreeSitter)
        print "[parse] 2a: creating TreeSitter..."
        var ts = TreeSitter.new(source.content)
        print "[parse] 2a: parsing outline..."
        val outline = ts.parse_outline()
        print "[parse] 2a: outline done"

        # Phase 2b: Block resolution
        print "[parse] 2b: resolving blocks..."
        var resolver = create_block_resolver()
        resolver = resolver.with_file(source.path)
        resolver = resolver.with_module(source.module_name)
        val (resolved, block_diagnostics) = resolver.resolve(outline)
        print "[parse] 2b: blocks resolved"

        # Phase 2c: Full parse with resolved blocks
        print "[parse] 2c: full parse..."
        var parser = Parser.with_resolved_blocks(source.content, resolved)
        val module = parser.parse()
        print "[parse] 2c: done"
        module

    # --------------------------------------------------------------------------
    # Phase 3: Combined HIR Lowering + Method Resolution + Type Checking
    # --------------------------------------------------------------------------
    #
    # This combined implementation processes each module through all three
    # phases in a single loop, avoiding redundant iterations and improving
    # performance on large codebases.

    me lower_and_check_impl() -> bool:
        var lowering = create_hir_lowering()
        var hir_modules = self.ctx.hir_modules

        print "[phase3] parsed modules count={self.ctx.modules.keys().len()}"
        val module_names = self.ctx.modules.keys()
        print "[phase3] entering loop over {module_names.len()} modules"
        print "[phase3] DEBUG: module_names = {module_names}"
        for name in module_names:
            print "[phase3] processing module: {name}"
            val module = self.ctx.modules[name]
            if module == nil:
                print "[phase3] ERROR: module is nil for key {name}"
                continue
            print "[phase3] got module (not nil), lowering to HIR..."

            # Step 1: Lower to HIR
            val hir_module = lowering.lower_module(module)
            print "[phase3] HIR lowered"

            # Step 2: Method resolution (UFCS)
            print "[phase3] resolving methods..."
            val (resolved_module, resolve_errors) = resolve_methods(hir_module)
            print "[phase3] methods resolved"

            # Collect method resolution errors
            print "[phase3] resolve_errors count={resolve_errors.len()}"
            var err_idx = 0
            while err_idx < resolve_errors.len():
                val err = resolve_errors[err_idx]
                self.ctx.add_error("Method resolution error in {name}: {err.message}")
                err_idx = err_idx + 1

            # Step 3: Type checking (HM inference)
            print "[phase3] skipping type inference for now..."
            print "[phase3] inference skipped"

            # Store final module in local dict
            hir_modules[name] = resolved_module
            print "[phase3] stored HIR module '{name}', total now: {hir_modules.keys().len()}"

        self.ctx.hir_modules = hir_modules
        print "[phase3] loop complete. HIR modules keys: {self.ctx.hir_modules.keys()}"
        print "[phase3] returning with {self.ctx.hir_modules.keys().len()} HIR modules"
        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Phase 3a: Lower to HIR (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn lower_to_hir_impl() -> (CompileContext, bool):
        var lowering = create_hir_lowering()
        var ctx = self.ctx

        val module_names = ctx.modules.keys()
        for name in module_names:
            val module = ctx.modules[name]
            val hir_module = lowering.lower_module(module)
            var hir_modules = ctx.hir_modules
            hir_modules[name] = hir_module
            ctx.hir_modules = hir_modules
        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Phase 3b: Method Resolution (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn resolve_methods_impl() -> (CompileContext, bool):
        var ctx = self.ctx

        for name in ctx.hir_modules.keys():
            val hir_module = ctx.hir_modules[name]
            val (resolved_module, resolve_errors) = resolve_methods(hir_module)

            # Update the module with resolved method calls
            var hir_modules = ctx.hir_modules
            hir_modules[name] = resolved_module
            ctx.hir_modules = hir_modules

            # Collect errors
            for err in resolve_errors:
                var errors = ctx.errors
                errors.push("Method resolution error in {name}: {err.message}")
                ctx.errors = errors

        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Phase 3c: Type Checking (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn type_check_impl() -> (CompileContext, bool):
        var ctx = self.ctx

        # Type inference disabled for bootstrap compatibility
        # for name in ctx.hir_modules.keys():
        #     val hir_module = ctx.hir_modules[name]
        #     var infer_ctx = HmInferContext.with_builtins()
        #     infer_ctx.infer_module(hir_module)
        #     for err in infer_ctx.errors:
        #         var errors = ctx.errors
        #         errors.push("Type error in {name}: {err.message()}")
        #         ctx.errors = errors

        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Mode: SDN (Data only)
    # --------------------------------------------------------------------------

    fn process_sdn() -> CompileResult:
        val backend = self.ctx.di.resolve("Backend")
        val results: Dict<text, Any> = {}

        for name in self.ctx.hir_modules.keys():
            val hir_module = self.ctx.hir_modules[name]
            match backend.process_module(hir_module):
                case Ok(value):
                    results[name] = value
                case Err(e):
                    return CompileResult.RuntimeError("SDN error in {name}: {e}")

        CompileResult.Success(results)

    # --------------------------------------------------------------------------
    # Mode: Interpret
    # --------------------------------------------------------------------------

    fn interpret() -> CompileResult:
        # Delegate to simple_old runtime for interpretation
        # The bootstrap compiler's struct field access has codegen issues
        # that prevent the self-hosted interpreter/JIT from working
        if self.ctx.options.input_files.len() == 0:
            return CompileResult.Error("No source file specified for interpret mode")
        val source_file = self.ctx.options.input_files[0]

        val simple_old = find_simple_old_binary()
        if simple_old == "":
            return CompileResult.Error("Cannot find simple_old binary for interpretation")

        val result = rt_shell("{simple_old} {source_file}")
        if result.stdout.?:
            print result.stdout
        if result.exit_code != 0:
            if result.stderr.?:
                return CompileResult.Error(result.stderr)
            return CompileResult.Error("Interpret failed with exit code {result.exit_code}")
        CompileResult.Success(BackendResult.Unit)

    fn run_module(backend: Backend, module: HirModule) -> CompileResult:
        match backend.process_module(module):
            case Ok(value): CompileResult.Success(value)
            case Err(e): CompileResult.RuntimeError(e)

    # --------------------------------------------------------------------------
    # Mode: JIT Compile and Run
    # --------------------------------------------------------------------------

    me jit_compile_and_run() -> CompileResult:
        # Lower to MIR
        if not self.lower_to_mir():
            return CompileResult.CodegenError(self.ctx.errors.first() ?? "MIR lowering failed")

        # JIT compile
        var pipeline = CodegenPipeline()

        for name in self.ctx.mir_modules.keys():
            val mir_module = self.ctx.mir_modules[name]
            match pipeline.jit_compile(mir_module):
                case Ok(_): pass
                case Err(e):
                    return CompileResult.CodegenError("JIT compile error in {name}: {e}")

        # Find and call main
        val main_fn = pipeline.get_function("main")
        if main_fn == nil:
            return CompileResult.RuntimeError("No main function found")

        match pipeline.call_function("main", []):
            case Ok(result): CompileResult.Success(result)
            case Err(e): CompileResult.RuntimeError(e)

    # --------------------------------------------------------------------------
    # Mode: AOT Compile
    # --------------------------------------------------------------------------

    me aot_compile() -> CompileResult:
        # Lower to MIR
        print "[aot] DEBUG: ctx.hir_modules count = {self.ctx.hir_modules.keys().len()}"
        print "[aot] lowering to MIR..."
        if not self.lower_to_mir():
            print "[aot] MIR lowering failed, errors:"
            var ei = 0
            while ei < self.ctx.errors.len():
                print "[aot] error: {self.ctx.errors[ei]}"
                ei = ei + 1
            return CompileResult.CodegenError(self.ctx.errors.first() ?? "MIR lowering failed")
        print "[aot] MIR done, {self.ctx.mir_modules.keys().len()} modules"

        # Determine output file
        val output = self.ctx.options.output_file ?? "a.out"
        print "[aot] output={output}"

        # AOT compile all modules
        var pipeline = CodegenPipeline.aot(CodegenTarget.Native)
        var compiled_modules: [CompiledModule] = []

        for name in self.ctx.mir_modules.keys():
            val mir_module = self.ctx.mir_modules[name]
            match pipeline.compile_module(mir_module):
                case Ok(compiled):
                    compiled_modules = compiled_modules.push(compiled)
                case Err(e):
                    return CompileResult.CodegenError("AOT compile error in {name}: {e.message}")

        # Emit object files
        var object_files: [text] = []
        for module in compiled_modules:
            val obj_path = "{output}.{module.name}.o"
            match module.emit_object(obj_path):
                case Ok(_):
                    object_files = object_files.push(obj_path)
                case Err(e):
                    return CompileResult.CodegenError("Object emit error: {e.message}")

        # Link object files into final executable
        match self.link_objects(object_files, output):
            case Ok(_):
                CompileResult.Success(output)
            case Err(e):
                CompileResult.CodegenError("Linking failed: {e}")

    # --------------------------------------------------------------------------
    # Linker Helper
    # --------------------------------------------------------------------------

    fn link_objects(objects: [text], output: text) -> Result<text, text>:
        if objects.is_empty():
            return Err("No object files to link")

        # Find runtime library directory
        val lib_dir = find_runtime_lib_dir()

        # Build linker command with dynamic linking to runtime
        var cmd = "cc"
        for obj in objects:
            cmd = cmd + " " + obj
        cmd = cmd + " -L{lib_dir} -lsimple_compiler"
        cmd = cmd + " -lc -lpthread -ldl -lm -lgcc_s"
        cmd = cmd + " -Wl,-rpath,{lib_dir}"
        cmd = cmd + " -o {output}"

        val result = rt_shell(cmd)
        if result.exit_code == 0:
            Ok(output)
        else:
            Err(result.stderr ?? "Unknown linking error")

    # --------------------------------------------------------------------------
    # MIR Lowering
    # --------------------------------------------------------------------------

    me lower_to_mir() -> bool:
        var lowering = MirLowering.new(create_symbol_table())

        val hir_keys = self.ctx.hir_modules.keys()
        for name in hir_keys:
            val hir_module = self.ctx.hir_modules[name]
            var mir_module = lowering.lower_module(hir_module)
            # Ensure module name is set (workaround for nested field mutation)
            mir_module.name = name
            # Copy-modify-reassign for self.ctx.mir_modules
            var ctx = self.ctx
            var mir_modules = ctx.mir_modules
            mir_modules[name] = mir_module
            ctx.mir_modules = mir_modules
            self.ctx = ctx

        not self.ctx.has_errors()

# ------------------------------------------------------------------------------
# Runtime Library Discovery
# ------------------------------------------------------------------------------

fn find_runtime_lib_dir() -> text:
    # Check env var first
    val env_path = rt_env_get("SIMPLE_RUNTIME_PATH")
    if env_path.? and env_path != "":
        return env_path
    # Default to target/debug
    if rt_file_exists("target/debug/libsimple_compiler.so"):
        return "target/debug"
    if rt_file_exists("target/release/libsimple_compiler.so"):
        return "target/release"
    "target/debug"

# ------------------------------------------------------------------------------
# Binary Discovery
# ------------------------------------------------------------------------------

fn find_simple_old_binary() -> text:
    val env_path = rt_env_get("SIMPLE_OLD_PATH")
    if env_path.? and env_path != "":
        return env_path
    if rt_file_exists("./target/debug/simple_old"):
        return "./target/debug/simple_old"
    if rt_file_exists("./target/release/simple_old"):
        return "./target/release/simple_old"
    ""

# ------------------------------------------------------------------------------
# Convenience Functions
# ------------------------------------------------------------------------------

fn compile_file(path: text) -> CompileResult:
    val options = CompileOptions.default()
    options.input_files = [path]
    val driver = CompilerDriver.create(options)
    driver.compile()

fn compile_files(paths: [text], mode: CompileMode) -> CompileResult:
    val options = CompileOptions.default()
    options.input_files = paths
    options.mode = mode
    val driver = CompilerDriver.create(options)
    driver.compile()

fn interpret_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Interpret)

fn jit_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Jit)

fn aot_file(path: text, output: text) -> CompileResult:
    val options = CompileOptions.default()
    options.input_files = [path]
    options.mode = CompileMode.Aot
    options.output_file = Some(output)
    val driver = CompilerDriver.create(options)
    driver.compile()

fn check_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Check)

fn parse_sdn_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Sdn)

# ------------------------------------------------------------------------------
# FFI Declarations
# ------------------------------------------------------------------------------

extern fn rt_file_read_text(path: text) -> text?
extern fn rt_write_file(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_env_get(name: text) -> text?
extern fn sys_get_args() -> [text]

# Shell execution result
struct ShellResult:
    exit_code: i64
    stdout: text?
    stderr: text?

extern fn rt_shell(command: text) -> ShellResult
