# Compiler Integration Tests
#
# End-to-end tests for the Simple compiler.
# These tests verify complete compilation scenarios from
# source code through codegen and execution.
#
# Test categories:
# - Basic compilation: Variables, expressions, control flow
# - Type system: Type checking, inference, generics
# - Functions: Calls, closures, methods
# - Memory: Allocation, GC interaction
# - Error messages: Diagnostics quality

use test.integration.mod.*
use std.text.{NL}

# ============================================================================
# Basic Compilation Tests
# ============================================================================

fn basic_compilation_suite() -> IntegrationTestSuite:
    """Tests for basic compilation functionality."""
    var suite = IntegrationTestSuite.create("Basic Compilation")

    # Hello World
    suite.add_test(
        output_test("hello_world",
            "print \"Hello, World!\"",
            "Hello, World!{NL}"
        )
    )

    # Variable declarations
    suite.add_test(
        output_test("val_declaration",
            "val x = 42{NL}print x",
            "42{NL}"
        )
    )

    suite.add_test(
        output_test("var_declaration",
            "var x = 10{NL}x = x + 5{NL}print x",
            "15{NL}"
        )
    )

    # String interpolation
    suite.add_test(
        output_test("string_interpolation",
            "val name = \"Alice\"{NL}print \"Hello, {name}!\"",
            "Hello, Alice!{NL}"
        )
    )

    # Basic arithmetic
    suite.add_test(
        output_test("arithmetic",
            "print (2 + 3) * 4",
            "20{NL}"
        )
    )

    suite

# ============================================================================
# Control Flow Tests
# ============================================================================

fn control_flow_suite() -> IntegrationTestSuite:
    """Tests for control flow constructs."""
    var suite = IntegrationTestSuite.create("Control Flow")

    # If expression
    suite.add_test(
        output_test("if_expression",
            "val x = 5{NL}val result = if x > 3: \"big\" else: \"small\"{NL}print result",
            "big{NL}"
        )
    )

    # If statement
    suite.add_test(
        output_test("if_statement",
            "val x = 10{NL}if x > 5:{NL}    print \"greater\"",
            "greater{NL}"
        )
    )

    # Match expression
    suite.add_test(
        output_test("match_basic",
            "val x = 2{NL}match x:{NL}    case 1: print \"one\"{NL}    case 2: print \"two\"{NL}    case _: print \"other\"",
            "two{NL}"
        )
    )

    # While loop
    suite.add_test(
        output_test("while_loop",
            "var i = 0{NL}while i < 3:{NL}    print i{NL}    i = i + 1",
            "0{NL}1{NL}2{NL}"
        )
    )

    # For loop
    suite.add_test(
        output_test("for_loop",
            "for i in 0..3:{NL}    print i",
            "0{NL}1{NL}2{NL}"
        )
    )

    suite

# ============================================================================
# Function Tests
# ============================================================================

fn function_suite() -> IntegrationTestSuite:
    """Tests for functions and closures."""
    var suite = IntegrationTestSuite.create("Functions")

    # Basic function
    suite.add_test(
        output_test("basic_function",
            "fn add(a: i64, b: i64) -> i64:{NL}    a + b{NL}{NL}print add(2, 3)",
            "5{NL}"
        )
    )

    # Function with implicit return
    suite.add_test(
        output_test("implicit_return",
            "fn square(x: i64) -> i64:{NL}    x * x{NL}{NL}print square(7)",
            "49{NL}"
        )
    )

    # Recursive function
    suite.add_test(
        output_test("recursive_function",
            "fn factorial(n: i64) -> i64:{NL}    if n <= 1: 1 else: n * factorial(n - 1){NL}{NL}print factorial(5)",
            "120{NL}"
        )
    )

    # Lambda expression
    suite.add_test(
        output_test("lambda",
            "val double = \\x: x * 2{NL}print double(21)",
            "42{NL}"
        )
    )

    # Higher-order function
    suite.add_test(
        output_test("higher_order",
            "fn apply(f: fn(i64) -> i64, x: i64) -> i64:{NL}    f(x){NL}{NL}print apply(\\x: x + 10, 32)",
            "42{NL}"
        )
    )

    suite

# ============================================================================
# Type System Tests
# ============================================================================

fn type_system_suite() -> IntegrationTestSuite:
    """Tests for type system features."""
    var suite = IntegrationTestSuite.create("Type System")

    # Type inference
    suite.add_test(
        output_test("type_inference",
            "val x = 42{NL}val y = 3.14{NL}val z = \"hello\"{NL}print \"types ok\"",
            "types ok{NL}"
        )
    )

    # Optional type
    suite.add_test(
        output_test("optional_some",
            "val opt: i64? = Some(42){NL}match opt:{NL}    case Some(x): print x{NL}    case None: print \"none\"",
            "42{NL}"
        )
    )

    suite.add_test(
        output_test("optional_none",
            "val opt: i64? = nil{NL}match opt:{NL}    case Some(x): print x{NL}    case None: print \"none\"",
            "none{NL}"
        )
    )

    # Result type
    suite.add_test(
        output_test("result_ok",
            "fn safe_div(a: i64, b: i64) -> Result<i64, text>:{NL}    if b == 0: Err(\"div by zero\") else: Ok(a / b){NL}{NL}match safe_div(10, 2):{NL}    case Ok(x): print x{NL}    case Err(e): print e",
            "5{NL}"
        )
    )

    suite

# ============================================================================
# Struct and Method Tests
# ============================================================================

fn struct_suite() -> IntegrationTestSuite:
    """Tests for structs and methods."""
    var suite = IntegrationTestSuite.create("Structs and Methods")

    # Basic struct
    suite.add_test(
        output_test("basic_struct",
            "struct Point:{NL}    x: i64{NL}    y: i64{NL}{NL}val p = Point(x: 3, y: 4){NL}print p.x",
            "3{NL}"
        )
    )

    # Struct with method
    suite.add_test(
        output_test("struct_method",
            "struct Point:{NL}    x: i64{NL}    y: i64{NL}{NL}impl Point:{NL}    fn sum() -> i64:{NL}        self.x + self.y{NL}{NL}val p = Point(x: 3, y: 4){NL}print p.sum()",
            "7{NL}"
        )
    )

    # Static method
    suite.add_test(
        output_test("static_method",
            "struct Point:{NL}    x: i64{NL}    y: i64{NL}{NL}impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0){NL}{NL}val p = Point.origin(){NL}print p.x",
            "0{NL}"
        )
    )

    # Mutable method
    suite.add_test(
        output_test("mutable_method",
            "class Counter:{NL}    value: i64{NL}{NL}impl Counter:{NL}    me increment():{NL}        self.value = self.value + 1{NL}{NL}var c = Counter(value: 0){NL}c.increment(){NL}c.increment(){NL}print c.value",
            "2{NL}"
        )
    )

    suite

# ============================================================================
# Enum Tests
# ============================================================================

fn enum_suite() -> IntegrationTestSuite:
    """Tests for enums and pattern matching."""
    var suite = IntegrationTestSuite.create("Enums")

    # Simple enum
    suite.add_test(
        output_test("simple_enum",
            "enum Color:{NL}    Red{NL}    Green{NL}    Blue{NL}{NL}val c = Color.Red{NL}match c:{NL}    case Red: print \"red\"{NL}    case Green: print \"green\"{NL}    case Blue: print \"blue\"",
            "red{NL}"
        )
    )

    # Enum with data
    suite.add_test(
        output_test("enum_with_data",
            "enum Shape:{NL}    Circle(radius: f64){NL}    Rectangle(width: f64, height: f64){NL}{NL}val s = Shape.Circle(3.14){NL}match s:{NL}    case Circle(r): print \"circle\"{NL}    case Rectangle(w, h): print \"rect\"",
            "circle{NL}"
        )
    )

    suite

# ============================================================================
# Collection Tests
# ============================================================================

fn collection_suite() -> IntegrationTestSuite:
    """Tests for collections."""
    var suite = IntegrationTestSuite.create("Collections")

    # Array literal
    suite.add_test(
        output_test("array_literal",
            "val arr = [1, 2, 3]{NL}print arr[0]",
            "1{NL}"
        )
    )

    # Array map
    suite.add_test(
        output_test("array_map",
            "val arr = [1, 2, 3]{NL}val doubled = arr.map(\\x: x * 2){NL}print doubled[1]",
            "4{NL}"
        )
    )

    # Array filter
    suite.add_test(
        output_test("array_filter",
            "val arr = [1, 2, 3, 4, 5]{NL}val evens = arr.filter(\\x: x % 2 == 0){NL}print evens.len()",
            "2{NL}"
        )
    )

    # Range
    suite.add_test(
        output_test("range",
            "var sum = 0{NL}for i in 1..=5:{NL}    sum = sum + i{NL}print sum",
            "15{NL}"
        )
    )

    suite

# ============================================================================
# Error Message Tests
# ============================================================================

fn error_message_suite() -> IntegrationTestSuite:
    """Tests for error message quality."""
    var suite = IntegrationTestSuite.create("Error Messages")

    # Type mismatch
    suite.add_test(
        error_test("type_mismatch",
            "val x: i64 = \"hello\"",
            "type mismatch"
        )
    )

    # Undefined variable
    suite.add_test(
        error_test("undefined_variable",
            "print undefined_var",
            "undefined"
        )
    )

    # Wrong number of arguments
    suite.add_test(
        error_test("wrong_arity",
            "fn add(a: i64, b: i64) -> i64:{NL}    a + b{NL}{NL}print add(1)",
            "argument"
        )
    )

    # Missing field
    suite.add_test(
        error_test("missing_field",
            "struct Point:{NL}    x: i64{NL}    y: i64{NL}{NL}val p = Point(x: 1)",
            "field"
        )
    )

    suite

# ============================================================================
# Run All Suites
# ============================================================================

fn run_all_compiler_tests() -> [IntegrationSuiteResult]:
    """Run all compiler integration test suites."""
    var results: [IntegrationSuiteResult] = []

    results = results.push(basic_compilation_suite().run_all())
    results = results.push(control_flow_suite().run_all())
    results = results.push(function_suite().run_all())
    results = results.push(type_system_suite().run_all())
    results = results.push(struct_suite().run_all())
    results = results.push(enum_suite().run_all())
    results = results.push(collection_suite().run_all())
    results = results.push(error_message_suite().run_all())

    results

fn format_all_results(results: [IntegrationSuiteResult]) -> text:
    """Format results from all suites."""
    var output = "Compiler Integration Test Results{NL}"
    output = "{output}═══════════════════════════════════════════════════════════{NL}{NL}"

    var total_passed = 0
    var total_failed = 0

    for suite_result in results:
        output = "{output}{suite_result.format_summary()}{NL}"
        total_passed = total_passed + suite_result.total_passed
        total_failed = total_failed + suite_result.total_failed

    output = "{output}{NL}═══════════════════════════════════════════════════════════{NL}"
    output = "{output}Total Passed: {total_passed}{NL}"
    output = "{output}Total Failed: {total_failed}{NL}"

    if total_failed == 0:
        output = "{output}{NL}✓ All tests passed!{NL}"
    else:
        output = "{output}{NL}✗ Some tests failed!{NL}"

    output

# ============================================================================
# Exports
# ============================================================================

export basic_compilation_suite, control_flow_suite, function_suite
export type_system_suite, struct_suite, enum_suite
export collection_suite, error_message_suite
export run_all_compiler_tests, format_all_results
