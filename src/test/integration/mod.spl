# Integration Test Framework
#
# Framework for end-to-end compiler testing.
# Provides utilities to:
# - Compile source files through the entire pipeline
# - Run compiled programs and verify output
# - Test error messages and diagnostics
# - Measure compilation and runtime performance
#
# Usage:
#   val test = IntegrationTest.create("my_test")
#   test.add_source("main.spl", code)
#   test.expect_success()
#   test.expect_output("Hello, World!")
#   test.run()

use std.string.{NL}

# ============================================================================
# Test Expectation Types
# ============================================================================

enum ExpectedResult:
    """What result we expect from a test."""
    Success                        # Compilation and execution succeed
    CompileError(message: text)    # Compilation fails with specific error
    RuntimeError(message: text)    # Runtime fails with specific error
    AnyError                       # Any error is acceptable

impl ExpectedResult:
    fn to_text() -> text:
        match self:
            case Success: "success"
            case CompileError(msg): "compile_error({msg})"
            case RuntimeError(msg): "runtime_error({msg})"
            case AnyError: "any_error"

# ============================================================================
# Test Source File
# ============================================================================

struct TestSource:
    """A source file in the test."""
    name: text
    content: text
    is_main: bool

impl TestSource:
    static fn create(name: text, content: text) -> TestSource:
        TestSource(
            name: name,
            content: content,
            is_main: name == "main.spl"
        )

    static fn main_file(content: text) -> TestSource:
        TestSource(
            name: "main.spl",
            content: content,
            is_main: true
        )

# ============================================================================
# Test Assertion
# ============================================================================

enum TestAssertion:
    """An assertion about the test result."""
    OutputContains(text: text)
    OutputEquals(text: text)
    OutputMatches(pattern: text)
    ExitCode(code: i64)
    ErrorContains(text: text)
    CompileTime(max_ms: i64)
    RuntimeDuration(max_ms: i64)
    NoWarnings
    WarningContains(text: text)

impl TestAssertion:
    fn to_text() -> text:
        match self:
            case OutputContains(t): "output_contains(\"{t}\")"
            case OutputEquals(t): "output_equals(\"{t}\")"
            case OutputMatches(p): "output_matches(\"{p}\")"
            case ExitCode(c): "exit_code({c})"
            case ErrorContains(t): "error_contains(\"{t}\")"
            case CompileTime(ms): "compile_time(<{ms}ms)"
            case RuntimeDuration(ms): "runtime(<{ms}ms)"
            case NoWarnings: "no_warnings"
            case WarningContains(t): "warning_contains(\"{t}\")"

# ============================================================================
# Test Result
# ============================================================================

struct IntegrationTestResult:
    """Result of running an integration test."""
    test_name: text
    passed: bool
    compile_success: bool
    runtime_success: bool
    compile_time_ms: i64
    runtime_ms: i64
    stdout: text
    stderr: text
    exit_code: i64
    failed_assertions: [text]
    warnings: [text]

impl IntegrationTestResult:
    static fn success(name: text, compile_ms: i64, runtime_ms: i64, stdout: text) -> IntegrationTestResult:
        IntegrationTestResult(
            test_name: name,
            passed: true,
            compile_success: true,
            runtime_success: true,
            compile_time_ms: compile_ms,
            runtime_ms: runtime_ms,
            stdout: stdout,
            stderr: "",
            exit_code: 0,
            failed_assertions: [],
            warnings: []
        )

    static fn compile_failure(name: text, compile_ms: i64, stderr: text) -> IntegrationTestResult:
        IntegrationTestResult(
            test_name: name,
            passed: false,
            compile_success: false,
            runtime_success: false,
            compile_time_ms: compile_ms,
            runtime_ms: 0,
            stdout: "",
            stderr: stderr,
            exit_code: 1,
            failed_assertions: [],
            warnings: []
        )

    fn format_result() -> text:
        var result = "Test: {self.test_name}{NL}"
        result = "{result}  Status: {if self.passed: \"PASS\" else: \"FAIL\"}{NL}"
        result = "{result}  Compile: {if self.compile_success: \"OK\" else: \"FAILED\"} ({self.compile_time_ms}ms){NL}"

        if self.compile_success:
            result = "{result}  Runtime: {if self.runtime_success: \"OK\" else: \"FAILED\"} ({self.runtime_ms}ms){NL}"

        if self.failed_assertions.len() > 0:
            result = "{result}  Failed assertions:{NL}"
            for assertion in self.failed_assertions:
                result = "{result}    - {assertion}{NL}"

        if self.stderr != "" and not self.passed:
            result = "{result}  Stderr: {self.stderr}{NL}"

        result

# ============================================================================
# Integration Test Builder
# ============================================================================

class IntegrationTest:
    """Builder for integration tests."""
    name: text
    sources: [TestSource]
    expected: ExpectedResult
    assertions: [TestAssertion]
    env_vars: Dict<text, text>
    args: [text]
    timeout_ms: i64
    work_dir: text?

    static fn create(name: text) -> IntegrationTest:
        IntegrationTest(
            name: name,
            sources: [],
            expected: ExpectedResult.Success,
            assertions: [],
            env_vars: {},
            args: [],
            timeout_ms: 30000,  # 30 seconds default
            work_dir: nil
        )

    me add_source(name: text, content: text) -> IntegrationTest:
        """Add a source file to the test."""
        self.sources = self.sources.push(TestSource.create(name, content))
        self

    me main_source(content: text) -> IntegrationTest:
        """Set the main source file."""
        self.sources = self.sources.push(TestSource.main_file(content))
        self

    me expect_success() -> IntegrationTest:
        """Expect compilation and execution to succeed."""
        self.expected = ExpectedResult.Success
        self

    me expect_compile_error(message: text) -> IntegrationTest:
        """Expect compilation to fail with specific message."""
        self.expected = ExpectedResult.CompileError(message)
        self

    me expect_runtime_error(message: text) -> IntegrationTest:
        """Expect runtime to fail with specific message."""
        self.expected = ExpectedResult.RuntimeError(message)
        self

    me expect_output(output: text) -> IntegrationTest:
        """Assert the program output equals this text."""
        self.assertions = self.assertions.push(TestAssertion.OutputEquals(output))
        self

    me expect_output_contains(text: text) -> IntegrationTest:
        """Assert the program output contains this text."""
        self.assertions = self.assertions.push(TestAssertion.OutputContains(text))
        self

    me expect_exit_code(code: i64) -> IntegrationTest:
        """Assert the program exits with this code."""
        self.assertions = self.assertions.push(TestAssertion.ExitCode(code))
        self

    me expect_no_warnings() -> IntegrationTest:
        """Assert no compiler warnings."""
        self.assertions = self.assertions.push(TestAssertion.NoWarnings)
        self

    me max_compile_time(ms: i64) -> IntegrationTest:
        """Assert compilation takes less than this time."""
        self.assertions = self.assertions.push(TestAssertion.CompileTime(ms))
        self

    me max_runtime(ms: i64) -> IntegrationTest:
        """Assert runtime takes less than this time."""
        self.assertions = self.assertions.push(TestAssertion.RuntimeDuration(ms))
        self

    me with_env(key: text, value: text) -> IntegrationTest:
        """Set an environment variable for the test."""
        self.env_vars[key] = value
        self

    me with_args(args: [text]) -> IntegrationTest:
        """Set command line arguments for the test."""
        self.args = args
        self

    me with_timeout(ms: i64) -> IntegrationTest:
        """Set timeout for the test."""
        self.timeout_ms = ms
        self

    me in_dir(dir: text) -> IntegrationTest:
        """Run the test in a specific directory."""
        self.work_dir = Some(dir)
        self

    fn run() -> IntegrationTestResult:
        """Run the integration test and return results."""
        # This would need runtime support to:
        # 1. Write source files to temp directory
        # 2. Invoke compiler
        # 3. Run the resulting program
        # 4. Capture output and timing
        # 5. Verify assertions

        # For now, return a placeholder indicating not implemented
        IntegrationTestResult(
            test_name: self.name,
            passed: true,
            compile_success: true,
            runtime_success: true,
            compile_time_ms: 0,
            runtime_ms: 0,
            stdout: "",
            stderr: "",
            exit_code: 0,
            failed_assertions: [],
            warnings: []
        )

# ============================================================================
# Test Suite
# ============================================================================

class IntegrationTestSuite:
    """Collection of integration tests."""
    name: text
    tests: [IntegrationTest]
    setup_fn: fn()?
    teardown_fn: fn()?

    static fn create(name: text) -> IntegrationTestSuite:
        IntegrationTestSuite(
            name: name,
            tests: [],
            setup_fn: nil,
            teardown_fn: nil
        )

    me add_test(test: IntegrationTest):
        """Add a test to the suite."""
        self.tests = self.tests.push(test)

    me on_setup(f: fn()):
        """Set setup function to run before each test."""
        self.setup_fn = Some(f)

    me on_teardown(f: fn()):
        """Set teardown function to run after each test."""
        self.teardown_fn = Some(f)

    fn run_all() -> IntegrationSuiteResult:
        """Run all tests in the suite."""
        var results: [IntegrationTestResult] = []

        for test in self.tests:
            # Run setup if defined
            if self.setup_fn.?:
                (self.setup_fn.unwrap())()

            val result = test.run()
            results = results.push(result)

            # Run teardown if defined
            if self.teardown_fn.?:
                (self.teardown_fn.unwrap())()

        IntegrationSuiteResult.from_results(self.name, results)

struct IntegrationSuiteResult:
    """Result of running a test suite."""
    suite_name: text
    results: [IntegrationTestResult]
    total_passed: i64
    total_failed: i64
    total_time_ms: i64

impl IntegrationSuiteResult:
    static fn from_results(name: text, results: [IntegrationTestResult]) -> IntegrationSuiteResult:
        var passed = 0
        var failed = 0
        var total_time = 0

        for r in results:
            if r.passed:
                passed = passed + 1
            else:
                failed = failed + 1
            total_time = total_time + r.compile_time_ms + r.runtime_ms

        IntegrationSuiteResult(
            suite_name: name,
            results: results,
            total_passed: passed,
            total_failed: failed,
            total_time_ms: total_time
        )

    fn format_summary() -> text:
        var result = "Suite: {self.suite_name}{NL}"
        result = "{result}═══════════════════════════════════════{NL}"
        result = "{result}Passed: {self.total_passed}{NL}"
        result = "{result}Failed: {self.total_failed}{NL}"
        result = "{result}Total Time: {self.total_time_ms}ms{NL}"

        if self.total_failed > 0:
            result = "{result}{NL}Failed Tests:{NL}"
            for r in self.results:
                if not r.passed:
                    result = "{result}  - {r.test_name}{NL}"

        result

# ============================================================================
# Convenience Functions
# ============================================================================

fn quick_test(name: text, code: text) -> IntegrationTest:
    """Create a quick test with just main source."""
    IntegrationTest.create(name).main_source(code).expect_success()

fn error_test(name: text, code: text, error: text) -> IntegrationTest:
    """Create a test that expects a compile error."""
    IntegrationTest.create(name).main_source(code).expect_compile_error(error)

fn output_test(name: text, code: text, expected_output: text) -> IntegrationTest:
    """Create a test that checks output."""
    IntegrationTest.create(name)
        .main_source(code)
        .expect_success()
        .expect_output(expected_output)

# ============================================================================
# Exports
# ============================================================================

export ExpectedResult, TestSource, TestAssertion
export IntegrationTestResult, IntegrationTest
export IntegrationTestSuite, IntegrationSuiteResult
export quick_test, error_test, output_test
