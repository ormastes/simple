# Property-Based Testing Framework
#
# QuickCheck-style property-based testing for Simple.
# Generates random test inputs and checks properties,
# then shrinks failing inputs to minimal counter-examples.
#
# Usage:
#   property "addition is commutative":
#       forall a: Int, b: Int:
#           a + b == b + a
#
# Features:
# - Random value generators for all basic types
# - Shrinking for minimal counter-examples
# - Configurable test count and seed
# - Integration with describe/it framework

# ============================================================================
# Random Number Generator
# ============================================================================

class Rng:
    """Simple pseudo-random number generator (xorshift64)."""
    state: i64

    static fn create(seed: i64) -> Rng:
        Rng(state: if seed == 0: 1 else: seed)

    static fn from_time() -> Rng:
        # Would use current time as seed
        Rng__create(12345)

    me next() -> i64:
        """Generate next random i64."""
        var x = self.state
        x = x xor (x << 13)
        x = x xor (x >> 7)
        x = x xor (x << 17)
        self.state = x
        x

    me next_u64() -> i64:
        """Generate next random unsigned i64."""
        val n = self.next()
        if n < 0: -n else: n

    me next_in_range(min: i64, max: i64) -> i64:
        """Generate random i64 in range [min, max)."""
        if max <= min:
            min
        else:
            min + (self.next_u64() % (max - min))

    me next_bool() -> bool:
        """Generate random bool."""
        self.next() > 0

    me next_f64() -> f64:
        """Generate random f64 in [0.0, 1.0)."""
        val n = self.next_u64()
        n.to_f64() / 9223372036854775807.0  # i64.max

# ============================================================================
# Generator Trait
# ============================================================================

trait Gen<T>:
    """Generator for random values of type T."""
    fn generate(rng: Rng) -> T
    fn shrink(value: T) -> [T]

# ============================================================================
# Built-in Generators
# ============================================================================

class IntGen:
    """Generator for integers."""
    min_value: i64
    max_value: i64

    static fn full_range() -> IntGen:
        IntGen(min_value: -1000000, max_value: 1000000)

    static fn positive() -> IntGen:
        IntGen(min_value: 0, max_value: 1000000)

    static fn small() -> IntGen:
        IntGen(min_value: -100, max_value: 100)

    static fn in_range(min: i64, max: i64) -> IntGen:
        IntGen(min_value: min, max_value: max)

    fn generate(rng: Rng) -> i64:
        rng.next_in_range(self.min_value, self.max_value)

    fn shrink(value: i64) -> [i64]:
        """Shrink integer towards zero."""
        if value == 0:
            []
        elif value < 0:
            [0, value + 1, value / 2]
        else:
            [0, value - 1, value / 2]

class BoolGen:
    """Generator for booleans."""

    static fn create() -> BoolGen:
        BoolGen()

    fn generate(rng: Rng) -> bool:
        rng.next_bool()

    fn shrink(value: bool) -> [bool]:
        if value: [false] else: []

class FloatGen:
    """Generator for floats."""
    min_value: f64
    max_value: f64

    static fn unit() -> FloatGen:
        FloatGen(min_value: 0.0, max_value: 1.0)

    static fn standard() -> FloatGen:
        FloatGen(min_value: -1000.0, max_value: 1000.0)

    fn generate(rng: Rng) -> f64:
        val t = rng.next_f64()
        self.min_value + t * (self.max_value - self.min_value)

    fn shrink(value: f64) -> [f64]:
        if value == 0.0:
            []
        elif value < 0.0:
            [0.0, value + 1.0, value / 2.0]
        else:
            [0.0, value - 1.0, value / 2.0]

class StringGen:
    """Generator for strings."""
    min_length: i64
    max_length: i64
    alphabet: text

    static fn ascii() -> StringGen:
        StringGen(
            min_length: 0,
            max_length: 20,
            alphabet: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        )

    static fn alpha() -> StringGen:
        StringGen(
            min_length: 0,
            max_length: 20,
            alphabet: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        )

    static fn digits() -> StringGen:
        StringGen(
            min_length: 0,
            max_length: 10,
            alphabet: "0123456789"
        )

    fn generate(rng: Rng) -> text:
        val len = rng.next_in_range(self.min_length, self.max_length + 1)
        var result = ""
        for _ in 0..len:
            val idx = rng.next_in_range(0, self.alphabet.len())
            result = "{result}{self.alphabet[idx]}"
        result

    fn shrink(value: text) -> [text]:
        if value.is_empty():
            []
        else:
            # Remove characters from end
            var results: [text] = [""]
            for i in 1..value.len():
                results = results.push(value.slice(0, i))
            results

class ListGen<T>:
    """Generator for lists."""
    element_gen: fn(Rng) -> T
    min_length: i64
    max_length: i64

    static fn of_ints(gen: IntGen) -> ListGen<i64>:
        ListGen(
            element_gen: \rng: gen.generate(rng),
            min_length: 0,
            max_length: 20
        )

    fn generate(rng: Rng) -> [T]:
        val len = rng.next_in_range(self.min_length, self.max_length + 1)
        var result: [T] = []
        for _ in 0..len:
            result = result.push((self.element_gen)(rng))
        result

    fn shrink(value: [T]) -> [[T]]:
        if value.is_empty():
            []
        else:
            # Remove elements
            var results: [[T]] = [[]]
            for i in 0..value.len():
                # Remove element at index i
                var without_i: [T] = []
                for j in 0..value.len():
                    if j != i:
                        without_i = without_i.push(value[j])
                results = results.push(without_i)
            results

# ============================================================================
# Property Definition
# ============================================================================

struct Property<A>:
    """A property to test."""
    name: text
    generator: fn(Rng) -> A
    predicate: fn(A) -> bool
    shrinker: fn(A) -> [A]?

impl Property:
    static fn create<A>(name: text, gen: fn(Rng) -> A, pred: fn(A) -> bool) -> Property<A>:
        Property(
            name: name,
            generator: gen,
            predicate: pred,
            shrinker: nil
        )

    fn with_shrinker(shrink: fn(A) -> [A]) -> Property<A>:
        Property(
            name: self.name,
            generator: self.generator,
            predicate: self.predicate,
            shrinker: Some(shrink)
        )

# ============================================================================
# Property Result
# ============================================================================

enum PropertyResult<A>:
    """Result of testing a property."""
    Passed(iterations: i64)
    Failed(counterexample: A, iteration: i64, shrunk: bool)
    Exhausted(iterations: i64)

impl PropertyResult:
    fn is_passed() -> bool:
        match self:
            case Passed(_): true
            case _: false

    fn is_failed() -> bool:
        match self:
            case Failed(_, _, _): true
            case _: false

# ============================================================================
# Property Checker
# ============================================================================

struct PropertyConfig:
    """Configuration for property checking."""
    iterations: i64
    max_shrink_depth: i64
    seed: i64?
    verbose: bool

impl PropertyConfig:
    static fn default_config() -> PropertyConfig:
        PropertyConfig(
            iterations: 100,
            max_shrink_depth: 50,
            seed: nil,
            verbose: false
        )

    static fn quick() -> PropertyConfig:
        PropertyConfig(
            iterations: 20,
            max_shrink_depth: 20,
            seed: nil,
            verbose: false
        )

    static fn thorough() -> PropertyConfig:
        PropertyConfig(
            iterations: 1000,
            max_shrink_depth: 100,
            seed: nil,
            verbose: true
        )

class PropertyChecker<A>:
    """Checks properties against random inputs."""
    config: PropertyConfig
    rng: Rng

    static fn create(config: PropertyConfig) -> PropertyChecker<A>:
        val seed = config.seed ?? 12345
        PropertyChecker(config: config, rng: Rng__create(seed))

    static fn default_checker() -> PropertyChecker<A>:
        PropertyChecker__create(PropertyConfig__default_config())

    me check(prop: Property<A>) -> PropertyResult<A>:
        """Check a property."""
        for i in 0..self.config.iterations:
            val input = (prop.generator)(self.rng)

            if not (prop.predicate)(input):
                # Found a failing case - try to shrink
                if prop.shrinker.?:
                    val shrunk = self.shrink_input(input, prop.predicate, prop.shrinker.unwrap())
                    return PropertyResult.Failed(shrunk, i, true)
                else:
                    return PropertyResult.Failed(input, i, false)

        PropertyResult.Passed(self.config.iterations)

    fn shrink_input(initial: A, pred: fn(A) -> bool, shrink: fn(A) -> [A]) -> A:
        """Shrink a failing input to a minimal counter-example."""
        var current = initial
        var depth = 0

        while depth < self.config.max_shrink_depth:
            val candidates = (shrink)(current)

            var found_smaller = false
            for candidate in candidates:
                if not (pred)(candidate):
                    # Found a smaller failing case
                    current = candidate
                    found_smaller = true
                    break

            if not found_smaller:
                # No smaller failing case found
                break

            depth = depth + 1

        current

# ============================================================================
# Property DSL
# ============================================================================

fn forall_int<R>(test: fn(i64) -> R) -> fn(Rng) -> (i64, R):
    """Create a generator that tests a property on integers."""
    \rng:
        val gen = IntGen__full_range()
        val value = gen.generate(rng)
        (value, test(value))

fn forall_bool<R>(test: fn(bool) -> R) -> fn(Rng) -> (bool, R):
    """Create a generator that tests a property on booleans."""
    \rng:
        val gen = BoolGen__create()
        val value = gen.generate(rng)
        (value, test(value))

fn forall_string<R>(test: fn(text) -> R) -> fn(Rng) -> (text, R):
    """Create a generator that tests a property on strings."""
    \rng:
        val gen = StringGen__ascii()
        val value = gen.generate(rng)
        (value, test(value))

# ============================================================================
# Test Integration
# ============================================================================

struct PropertyTest:
    """A property test for integration with test framework."""
    name: text
    passed: bool
    iterations: i64
    counterexample: text?
    shrunk: bool

impl PropertyTest:
    fn format_result() -> text:
        if self.passed:
            "Property '{self.name}' passed after {self.iterations} iterations"
        else:
            var result = "Property '{self.name}' FAILED"
            if self.counterexample.?:
                result = "{result}\n  Counterexample: {self.counterexample.unwrap()}"
            if self.shrunk:
                result = "{result} (shrunk)"
            result

fn check_property(name: text, gen: fn(Rng) -> i64, pred: fn(i64) -> bool) -> PropertyTest:
    """Check an integer property and return test result."""
    val prop = Property__create(name, gen, pred).with_shrinker(\x: IntGen__full_range().shrink(x))
    var checker: PropertyChecker<i64> = PropertyChecker__default_checker()

    match checker.check(prop):
        case Passed(iters):
            PropertyTest(
                name: name,
                passed: true,
                iterations: iters,
                counterexample: nil,
                shrunk: false
            )
        case Failed(ce, iter, shrunk):
            PropertyTest(
                name: name,
                passed: false,
                iterations: iter,
                counterexample: Some("{ce}"),
                shrunk: shrunk
            )
        case Exhausted(iters):
            PropertyTest(
                name: name,
                passed: true,
                iterations: iters,
                counterexample: nil,
                shrunk: false
            )

# ============================================================================
# Example Properties
# ============================================================================

fn addition_commutative() -> PropertyTest:
    """Property: a + b == b + a."""
    val gen = \rng:
        val g = IntGen__small()
        g.generate(rng)

    val pred = \a:
        val rng2 = Rng__create(a + 1000)  # Derive second value
        val b = IntGen__small().generate(rng2)
        a + b == b + a

    check_property("addition is commutative", gen, pred)

fn multiplication_by_zero() -> PropertyTest:
    """Property: a * 0 == 0."""
    val gen = \rng: IntGen__full_range().generate(rng)
    val pred = \a: a * 0 == 0

    check_property("multiplication by zero is zero", gen, pred)

fn double_negation() -> PropertyTest:
    """Property: --a == a."""
    val gen = \rng: IntGen__full_range().generate(rng)
    val pred = \a: -(-a) == a

    check_property("double negation is identity", gen, pred)

# ============================================================================
# Exports
# ============================================================================

export Rng
export IntGen, BoolGen, FloatGen, StringGen, ListGen
export Property, PropertyResult, PropertyConfig, PropertyChecker
export forall_int, forall_bool, forall_string
export PropertyTest, check_property
export addition_commutative, multiplication_by_zero, double_negation
