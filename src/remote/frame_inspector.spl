# Frame Navigation and Variable Inspector
# Wraps GDB MI stack and variable commands for detailed frame inspection.
# Supports frame selection, local/argument reading, variable modification,
# and expression evaluation within specific stack frames.

use remote.protocol.gdb_mi.GdbMiClient
use remote.protocol.gdb_mi_parser.{GdbMiParser, parse_hex_value}

# Detailed information about a single stack frame
class FrameDetail:
    index: i64
    function_name: text
    file: text
    line: i64
    address: i64
    full_path: text

    static fn of(index: i64, function_name: text, file: text, line: i64) -> FrameDetail:
        FrameDetail(
            index: index,
            function_name: function_name,
            file: file,
            line: line,
            address: 0,
            full_path: ""
        )

    static fn full(index: i64, function_name: text, file: text, line: i64, address: i64, full_path: text) -> FrameDetail:
        FrameDetail(
            index: index,
            function_name: function_name,
            file: file,
            line: line,
            address: address,
            full_path: full_path
        )

    fn to_string() -> text:
        var addr_str = ""
        if self.address > 0:
            addr_str = " (0x{self.address})"
        "#{self.index} {self.function_name} at {self.file}:{self.line}{addr_str}"

    # Serialize to compact text format
    fn serialize() -> text:
        "{self.index}|{self.function_name}|{self.file}|{self.line}|{self.address}|{self.full_path}"

# Variable information with type details
class VariableDetail:
    name: text
    value: text
    var_type: text
    num_children: i64
    is_argument: bool

    static fn of(name: text, value: text, var_type: text) -> VariableDetail:
        VariableDetail(
            name: name,
            value: value,
            var_type: var_type,
            num_children: 0,
            is_argument: false
        )

    static fn arg(name: text, value: text, var_type: text) -> VariableDetail:
        VariableDetail(
            name: name,
            value: value,
            var_type: var_type,
            num_children: 0,
            is_argument: true
        )

    fn to_string() -> text:
        var type_str = ""
        if self.var_type.len() > 0:
            type_str = " : {self.var_type}"
        var arg_str = ""
        if self.is_argument:
            arg_str = " [arg]"
        "{self.name} = {self.value}{type_str}{arg_str}"

    # Serialize to compact text format
    fn serialize() -> text:
        var arg_flag = "0"
        if self.is_argument:
            arg_flag = "1"
        "{self.name}|{self.value}|{self.var_type}|{self.num_children}|{arg_flag}"

# Frame inspector wrapping GDB MI stack/variable commands
class FrameInspector:
    gdb: GdbMiClient
    current_frame: i64
    cached_depth: i64

impl FrameInspector:
    # Create a new frame inspector for a GDB MI client
    static fn create(gdb: GdbMiClient) -> FrameInspector:
        FrameInspector(
            gdb: gdb,
            current_frame: 0,
            cached_depth: -1
        )

    # Select a stack frame by index for subsequent operations.
    # Frame 0 is the innermost (current) frame.
    me select_frame(index: i64) -> Result<text, text>:
        self.gdb.send_command("stack-select-frame {index}")?
        self.current_frame = index
        Ok("frame {index} selected")

    # Get the currently selected frame index.
    fn get_selected_frame() -> i64:
        self.current_frame

    # Get detailed info about the current (selected) frame.
    fn get_current_frame() -> Result<FrameDetail, text>:
        val data = self.gdb.send_command("stack-info-frame")?
        val frame_raw = data.get("frame") ?? "{}"
        val frame = GdbMiParser.parse_key_values(frame_raw)

        val index = (frame.get("level") ?? "0").parse_int() ?? 0
        val func = frame.get("func") ?? "??"
        val file = frame.get("file") ?? ""
        val full_path = frame.get("fullname") ?? file
        val line = (frame.get("line") ?? "0").parse_int() ?? 0
        val addr_str = frame.get("addr") ?? "0x0"
        val addr = parse_hex_value(addr_str)

        Ok(FrameDetail.full(index, func, file, line, addr, full_path))

    # Get the full stack trace with detailed frame info.
    fn get_all_frames() -> Result<[FrameDetail], text>:
        val data = self.gdb.send_command("stack-list-frames")?
        val frames_raw = data.get("stack") ?? "[]"
        val tuples = GdbMiParser.parse_tuple_list(frames_raw)
        var result: [FrameDetail] = []

        for t in tuples:
            val index = (t.get("level") ?? "0").parse_int() ?? 0
            val func = t.get("func") ?? "??"
            val file = t.get("file") ?? ""
            val full_path = t.get("fullname") ?? file
            val line = (t.get("line") ?? "0").parse_int() ?? 0
            val addr_str = t.get("addr") ?? "0x0"
            val addr = parse_hex_value(addr_str)
            result.push(FrameDetail.full(index, func, file, line, addr, full_path))

        Ok(result)

    # Get the stack depth (number of frames).
    me get_stack_depth() -> Result<i64, text>:
        val data = self.gdb.send_command("stack-info-depth")?
        val depth = (data.get("depth") ?? "0").parse_int() ?? 0
        self.cached_depth = depth
        Ok(depth)

    # Get local variables for a specific frame.
    fn get_frame_locals(frame_index: i64) -> Result<[VariableDetail], text>:
        # Use --thread and --frame to specify context
        val data = self.gdb.send_command("stack-list-locals --all-values --frame {frame_index}")?
        val locals_raw = data.get("locals") ?? "[]"
        val tuples = GdbMiParser.parse_tuple_list(locals_raw)
        var result: [VariableDetail] = []

        for t in tuples:
            val name = t.get("name") ?? "?"
            val value = t.get("value") ?? "?"
            val type_name = t.get("type") ?? ""
            result.push(VariableDetail.of(name, value, type_name))

        Ok(result)

    # Get function arguments for a specific frame.
    fn get_frame_arguments(frame_index: i64) -> Result<[VariableDetail], text>:
        # Request arguments for a specific frame range
        val data = self.gdb.send_command("stack-list-arguments --all-values {frame_index} {frame_index}")?
        val args_raw = data.get("stack-args") ?? "[]"
        val frames = GdbMiParser.parse_tuple_list(args_raw)
        var result: [VariableDetail] = []

        for frame in frames:
            val args_list = frame.get("args") ?? "[]"
            val args = GdbMiParser.parse_tuple_list(args_list)
            for a in args:
                val name = a.get("name") ?? "?"
                val value = a.get("value") ?? "?"
                val type_name = a.get("type") ?? ""
                result.push(VariableDetail.arg(name, value, type_name))

        Ok(result)

    # Get all variables (locals + arguments) for a specific frame.
    fn get_frame_variables(frame_index: i64) -> Result<[VariableDetail], text>:
        var result: [VariableDetail] = []

        # Get arguments first
        val args_result = self.get_frame_arguments(frame_index)
        match args_result:
            Ok(args):
                for a in args:
                    result.push(a)
            Err(_):
                pass_dn  # arguments might not be available

        # Then locals
        val locals_result = self.get_frame_locals(frame_index)
        match locals_result:
            Ok(locals):
                for local in locals:
                    result.push(local)
            Err(_):
                pass_dn  # locals might not be available

        Ok(result)

    # Set a variable's value in a specific frame.
    # Returns true on success.
    fn set_variable(name: text, value: text, frame_index: i64) -> Result<bool, text>:
        # Select the target frame first
        self.gdb.send_command("stack-select-frame {frame_index}")?
        # Use data-evaluate-expression with assignment
        val assign_expr = "{name}={value}"
        self.gdb.send_command("data-evaluate-expression \"{assign_expr}\"")?
        Ok(true)

    # Evaluate an expression in the context of a specific frame.
    fn eval_expression(expr: text, frame_index: i64) -> Result<text, text>:
        # Select the target frame
        self.gdb.send_command("stack-select-frame {frame_index}")?
        # Evaluate the expression
        val data = self.gdb.send_command("data-evaluate-expression \"{expr}\"")?
        val value = data.get("value") ?? ""
        Ok(value)

    # Get a specific frame by index without changing the selected frame.
    fn get_frame_at(index: i64) -> Result<FrameDetail, text>:
        val all = self.get_all_frames()?
        if index < 0 or index >= all.len():
            return Err("frame index {index} out of range (0..{all.len()})")
        Ok(all[index])

    # Navigate to the caller frame (one level up).
    me frame_up() -> Result<FrameDetail, text>:
        val new_index = self.current_frame + 1
        self.select_frame(new_index)?
        self.get_current_frame()

    # Navigate to the callee frame (one level down).
    me frame_down() -> Result<FrameDetail, text>:
        if self.current_frame <= 0:
            return Err("already at innermost frame")
        val new_index = self.current_frame - 1
        self.select_frame(new_index)?
        self.get_current_frame()

    # Navigate to the innermost (current) frame.
    me frame_bottom() -> Result<FrameDetail, text>:
        self.select_frame(0)?
        self.get_current_frame()

    # Navigate to the outermost frame.
    me frame_top() -> Result<FrameDetail, text>:
        val depth_result = self.get_stack_depth()
        match depth_result:
            Ok(depth):
                if depth <= 0:
                    return Err("no frames available")
                self.select_frame(depth - 1)?
                self.get_current_frame()
            Err(e):
                Err(e)

    # Serialize full frame + variables state for transport
    fn serialize_frame_state(frame_index: i64) -> Result<text, text>:
        var parts: [text] = []

        # Frame info
        val frame_result = self.get_frame_at(frame_index)
        match frame_result:
            Ok(frame):
                parts.push("FRAME:" + frame.serialize())
            Err(e):
                return Err(e)

        # Variables
        val vars_result = self.get_frame_variables(frame_index)
        match vars_result:
            Ok(vars):
                for v in vars:
                    parts.push("VAR:" + v.serialize())
            Err(_):
                pass_dn  # variables might not be available

        Ok(parts.join("\n"))

# --- Exports ---

export FrameDetail
export VariableDetail
export FrameInspector
