# Trace32 GDB Bridge
# Translates Trace32 commands to GDB MI commands.
# Allows using Trace32-style operations when connected to QEMU via GDB.

use remote.protocol.gdb_mi.GdbMiClient
use app.debug.coordinator.{VarInfo, FrameInfo}

# Bridge that translates Trace32 commands to GDB MI
class Trace32GdbBridge:
    gdb: GdbMiClient

impl Trace32GdbBridge:
    # --- System Commands ---

    # T32: "SYStem.Up" → GDB: already connected
    fn system_up() -> Result<text, text>:
        # When using GDB bridge, connection is already established
        Ok("system up (via GDB)")

    # T32: "SYStem.Mode Attach" → GDB: already attached
    fn system_mode_attach() -> Result<text, text>:
        Ok("attached (via GDB)")

    # --- Execution Control ---

    # T32: "Go" → GDB: -exec-continue
    fn go() -> Result<text, text>:
        self.gdb.resume()

    # T32: "Go.direct" → GDB: -exec-continue (no breakpoint checking)
    fn go_direct() -> Result<text, text>:
        self.gdb.resume()

    # T32: "Break" → GDB: -exec-interrupt
    fn break_() -> Result<text, text>:
        self.gdb.halt()

    # T32: "Step" → GDB: -exec-step
    fn step() -> Result<text, text>:
        self.gdb.single_step()

    # T32: "Step.Over" → GDB: -exec-next
    fn step_over() -> Result<text, text>:
        self.gdb.step_over()

    # T32: "Step.Out" → GDB: -exec-finish
    fn step_out() -> Result<text, text>:
        self.gdb.step_out()

    # --- Breakpoints ---

    # T32: "Break.Set 0x1000 /Program" → GDB: -break-insert *0x1000
    fn break_set(addr: i64, flags: text) -> Result<text, text>:
        val location = "*0x{addr}"
        val id = self.gdb.set_breakpoint(location)?
        Ok("breakpoint {id} set at 0x{addr}")

    # T32: "Break.Set func /Program" → GDB: -break-insert func
    fn break_set_func(func_name: text) -> Result<text, text>:
        val id = self.gdb.set_breakpoint(func_name)?
        Ok("breakpoint {id} set at {func_name}")

    # T32: "Break.Delete 0x1000" → GDB: -break-delete N
    fn break_delete(bp_id: i32) -> Result<text, text>:
        self.gdb.delete_breakpoint(bp_id)

    # T32: "Break.Set 0x1000 /Write" → GDB: -break-watch *0x1000
    fn break_set_watch(addr: i64, access: text) -> Result<text, text>:
        val id = self.gdb.set_watchpoint("*0x{addr}", access)?
        Ok("watchpoint {id} set at 0x{addr}")

    # --- Memory Operations ---

    # T32: "Data.dump 0x20000000" → GDB: -data-read-memory-bytes
    fn data_dump(addr: i64, size: i32) -> Result<[i32], text>:
        self.gdb.read_memory(addr, size)

    # T32: "Data.Set 0x20000000 %Long 0x12345678" → GDB: -data-write-memory-bytes
    fn data_set(addr: i64, data: [i32]) -> Result<text, text>:
        self.gdb.write_memory(addr, data)

    # T32: "Data.Long(D:0x20000000)" → GDB: read 4 bytes
    fn data_long(addr: i64) -> Result<i64, text>:
        val bytes = self.gdb.read_memory(addr, 4)?
        if bytes.len() < 4:
            return Err("insufficient data")
        # Little-endian 32-bit word
        val word = bytes[0]
            + (bytes[1] * 256)
            + (bytes[2] * 65536)
            + (bytes[3] * 16777216)
        Ok(word)

    # --- Register Operations ---

    # T32: "Register.view /SpotLight" → GDB: -data-list-register-values
    fn register_read(name: text) -> Result<i64, text>:
        self.gdb.read_register(name)

    # T32: "Register.Set PC 0x80000000" → GDB: register write
    fn register_set(name: text, value: i64) -> Result<text, text>:
        self.gdb.write_register(name, value)

    # T32: "Register.view" → GDB: read all registers
    fn register_view() -> Result<Dict<text, i64>, text>:
        self.gdb.read_all_registers()

    # --- Variable Inspection ---

    # T32: "Var.View %Open locals" → GDB: -stack-list-locals
    fn var_view(scope: text) -> Result<[VarInfo], text>:
        match scope:
            "locals":
                self.gdb.read_locals()
            "arguments":
                self.gdb.read_arguments()
            "globals":
                self.gdb.read_globals()
            _:
                # Treat as expression
                val value = self.gdb.evaluate(scope)?
                Ok([VarInfo.of(scope, value, "")])

    # T32: "Var.Value var_name" → GDB: -data-evaluate-expression
    fn var_value(name: text) -> Result<text, text>:
        self.gdb.evaluate(name)

    # T32: "Eval expression" → GDB: -data-evaluate-expression
    fn eval_expression(expr: text) -> Result<text, text>:
        self.gdb.evaluate(expr)

    # --- Stack Operations ---

    # T32: "Frame.view /Locals" → GDB: -stack-list-frames
    fn frame_view() -> Result<[FrameInfo], text>:
        self.gdb.stack_trace()

    # T32: "Frame.GOTO N" → GDB: -stack-select-frame N
    fn frame_goto(level: i32) -> Result<text, text>:
        self.gdb.select_frame(level)

    # --- Symbol Operations ---

    # T32: "sYmbol.LOAD.ELF path.elf" → GDB: -file-exec-and-symbols
    fn symbol_load_elf(path: text) -> Result<text, text>:
        self.gdb.send_command("file-exec-and-symbols {path}")?
        Ok("symbols loaded from {path}")

    # --- Utility ---

    # T32: "PRINT Register(PC)" → GDB: read register + format
    fn print_register(name: text) -> Result<text, text>:
        val value = self.gdb.read_register(name)?
        Ok("{name} = 0x{value}")

    # T32: "PRINT Data.Long(D:addr)" → GDB: read memory + format
    fn print_data_long(addr: i64) -> Result<text, text>:
        val word = self.data_long(addr)?
        Ok("D:0x{addr} = 0x{word}")
