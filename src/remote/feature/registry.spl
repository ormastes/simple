# Feature Registry
# Routes debug operations to the best available handler based on rank.
# Each backend registers handlers at numeric ranks; lowest rank wins.

use remote.feature.features.{FeatureId, FeatureRank}

# A registered handler for a single feature
class FeatureHandler:
    feat: FeatureId
    rank: i32
    backend_name: text
    handler_fn: fn([text]) -> Result<text, text>
    description: text

    static fn of(feat: FeatureId, rank: i32, backend_name: text,
                 handler_fn: fn([text]) -> Result<text, text>,
                 description: text) -> FeatureHandler:
        FeatureHandler(
            feat: feat,
            rank: rank,
            backend_name: backend_name,
            handler_fn: handler_fn,
            description: description
        )

# Registry holding all feature handlers, sorted by rank per feature
class FeatureRegistry:
    handlers: Dict<text, [FeatureHandler]>

    static fn empty() -> FeatureRegistry:
        FeatureRegistry(handlers: {})

impl FeatureRegistry:
    # Register a handler. Inserted sorted by rank (ascending).
    # BUG-RT-002: Dict.get() returns raw value, not Option. Use nil check.
    me register(handler: FeatureHandler):
        val key = handler.feat.to_string()
        val existing = self.handlers.get(key)
        if existing != nil:
            # Insert sorted by rank
            var list = existing
            var inserted = false
            var result: [FeatureHandler] = []
            for h in list:
                if not inserted and handler.rank < h.rank:
                    result.push(handler)
                    inserted = true
                result.push(h)
            if not inserted:
                result.push(handler)
            self.handlers[key] = result
        else:
            self.handlers[key] = [handler]

    # Return the lowest-rank (best) handler for a feature
    fn best_handler(feat: FeatureId) -> Result<FeatureHandler, text>:
        val key = feat.to_string()
        val list = self.handlers.get(key)
        if list != nil and list.len() > 0:
            Ok(list[0])
        else:
            Err("no handler for feature: {key}")

    # Return all handlers for a feature, sorted by rank
    fn all_handlers(feat: FeatureId) -> [FeatureHandler]:
        val key = feat.to_string()
        val list = self.handlers.get(key)
        if list != nil:
            list
        else:
            []

    # Return all features that have at least one handler
    fn supported_features() -> [text]:
        var result: [text] = []
        for key in self.handlers.keys():
            val list = self.handlers[key]
            if list.len() > 0:
                result.push(key)
        result

    # Check if a feature is supported
    fn is_supported(feat: FeatureId) -> bool:
        val key = feat.to_string()
        val list = self.handlers.get(key)
        if list != nil:
            list.len() > 0
        else:
            false

    # Execute the best handler for a feature
    fn execute(feat: FeatureId, args: [text]) -> Result<text, text>:
        val handler = self.best_handler(feat)?
        val callback = handler.handler_fn
        callback(args)

    # Generate a human-readable capabilities report
    fn capabilities_report() -> text:
        var lines: [text] = []
        lines.push("Feature Capabilities Report")
        lines.push("=" * 60)
        lines.push("")

        val features = self.supported_features()
        for feature_name in features:
            val handlers = self.handlers[feature_name]
            lines.push("  {feature_name}:")
            for h in handlers:
                val rank_label = match h.rank:
                    0: "native"
                    1: "bridge"
                    2: "secondary"
                    3: "external"
                    4: "emulated"
                    _: "rank-{h.rank}"
                lines.push("    [{rank_label}] {h.backend_name}: {h.description}")
            lines.push("")

        lines.push("Total features: {features.len()}")
        lines.join("\n")

    # Count total registered handlers
    fn handler_count() -> i32:
        var count = 0
        for key in self.handlers.keys():
            count = count + self.handlers[key].len()
        count
