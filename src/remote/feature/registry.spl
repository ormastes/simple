# Feature Registry
# Routes debug operations to the best available handler based on rank.
# Each backend registers handlers at numeric ranks; lowest rank wins.

use remote.feature.features.{FeatureId, FeatureRank}

# A registered handler for a single feature
class FeatureHandler:
    feature: FeatureId
    rank: i32
    backend_name: text
    handler_fn: fn(args: [text]) -> Result<text, text>
    description: text

    static fn of(feature: FeatureId, rank: i32, backend_name: text,
                 handler_fn: fn(args: [text]) -> Result<text, text>,
                 description: text) -> FeatureHandler:
        FeatureHandler(
            feature: feature,
            rank: rank,
            backend_name: backend_name,
            handler_fn: handler_fn,
            description: description
        )

# Registry holding all feature handlers, sorted by rank per feature
class FeatureRegistry:
    handlers: Dict<text, [FeatureHandler]>

    static fn empty() -> FeatureRegistry:
        FeatureRegistry(handlers: {})

impl FeatureRegistry:
    # Register a handler. Inserted sorted by rank (ascending).
    me register(handler: FeatureHandler):
        val key = handler.feature.to_string()
        match self.handlers.get(key):
            Some(existing):
                # Insert sorted by rank
                var list = existing
                var inserted = false
                var result: [FeatureHandler] = []
                for h in list:
                    if not inserted and handler.rank < h.rank:
                        result.push(handler)
                        inserted = true
                    result.push(h)
                if not inserted:
                    result.push(handler)
                self.handlers[key] = result
            None:
                self.handlers[key] = [handler]

    # Return the lowest-rank (best) handler for a feature
    fn best_handler(feature: FeatureId) -> Result<FeatureHandler, text>:
        val key = feature.to_string()
        match self.handlers.get(key):
            Some(list):
                if list.len() > 0:
                    Ok(list[0])
                else:
                    Err("no handler for feature: {key}")
            None:
                Err("no handler for feature: {key}")

    # Return all handlers for a feature, sorted by rank
    fn all_handlers(feature: FeatureId) -> [FeatureHandler]:
        val key = feature.to_string()
        match self.handlers.get(key):
            Some(list): list
            None: []

    # Return all features that have at least one handler
    fn supported_features() -> [text]:
        var result: [text] = []
        for key in self.handlers.keys():
            val list = self.handlers[key]
            if list.len() > 0:
                result.push(key)
        result

    # Check if a feature is supported
    fn is_supported(feature: FeatureId) -> bool:
        val key = feature.to_string()
        match self.handlers.get(key):
            Some(list): list.len() > 0
            None: false

    # Execute the best handler for a feature
    fn execute(feature: FeatureId, args: [text]) -> Result<text, text>:
        val handler = self.best_handler(feature)?
        handler.handler_fn(args)

    # Generate a human-readable capabilities report
    fn capabilities_report() -> text:
        var lines: [text] = []
        lines.push("Feature Capabilities Report")
        lines.push("=" * 60)
        lines.push("")

        val features = self.supported_features()
        for feature_name in features:
            val handlers = self.handlers[feature_name]
            lines.push("  {feature_name}:")
            for h in handlers:
                val rank_label = match h.rank:
                    0: "native"
                    1: "bridge"
                    2: "secondary"
                    3: "external"
                    4: "emulated"
                    _: "rank-{h.rank}"
                lines.push("    [{rank_label}] {h.backend_name}: {h.description}")
            lines.push("")

        lines.push("Total features: {features.len()}")
        lines.join("\n")

    # Count total registered handlers
    fn handler_count() -> i32:
        var count = 0
        for key in self.handlers.keys():
            count = count + self.handlers[key].len()
        count
