# Emulated Feature Handlers
# Fallback implementations for features when native support isn't available.
# These register at higher ranks (3-4) and synthesize responses from
# lower-level operations (memory reads, register reads, etc.)

use remote.feature.features.{FeatureId, FeatureRank}
use remote.feature.registry.{FeatureHandler, FeatureRegistry}
use remote.protocol.gdb_mi.GdbMiClient
use remote.target.riscv32.RiscV32Target
use app.debug.coordinator.VarInfo
use app.io.{shell, ProcessResult}

# Register all emulation fallback features
fn register_emulation_features(registry: FeatureRegistry, gdb: GdbMiClient, target: RiscV32Target):
    # ReadLocals emulated via stack frame + DWARF info (rank 4)
    registry.register(FeatureHandler.of(
        FeatureId.ReadLocals, FeatureRank.EMULATED, "emulation",
        \args: emulate_read_locals(gdb, target),
        "Emulated locals via stack frame memory + DWARF"
    ))

    # ReadArguments emulated via register reads + ABI convention (rank 4)
    registry.register(FeatureHandler.of(
        FeatureId.ReadArguments, FeatureRank.EMULATED, "emulation",
        \args: emulate_read_arguments(gdb, target),
        "Emulated args via a0-a7 registers"
    ))

    # ReadGlobals emulated via symbol table (rank 4)
    registry.register(FeatureHandler.of(
        FeatureId.ReadGlobals, FeatureRank.EMULATED, "emulation",
        \args: emulate_read_globals(gdb),
        "Emulated globals via symbol evaluation"
    ))

    # ReadStackTrace emulated via frame pointer walking (rank 4)
    registry.register(FeatureHandler.of(
        FeatureId.ReadStackTrace, FeatureRank.EMULATED, "emulation",
        \args: emulate_read_stack_trace(gdb, target),
        "Emulated stack trace via frame pointer walk"
    ))

    # ProfileSample emulated via PC sampling (rank 3)
    registry.register(FeatureHandler.of(
        FeatureId.ProfileSample, FeatureRank.EXTERNAL, "emulation",
        \args: emulate_profile_sample(gdb, args),
        "PC sampling profiler via repeated halt/read-PC/resume"
    ))

    # FlashProgram emulated via OpenOCD (rank 3)
    registry.register(FeatureHandler.of(
        FeatureId.FlashProgram, FeatureRank.EXTERNAL, "emulation",
        \args: emulate_flash_program(args),
        "Flash via OpenOCD memory write"
    ))

    # SystemReset emulated via GDB monitor command (rank 3)
    registry.register(FeatureHandler.of(
        FeatureId.SystemReset, FeatureRank.EXTERNAL, "emulation",
        \args: emulate_system_reset(gdb),
        "Reset via GDB monitor reset"
    ))

# --- Emulated implementations ---

# Emulate local variable reading via frame pointer + stack memory
fn emulate_read_locals(gdb: GdbMiClient, target: RiscV32Target) -> Result<text, text>:
    # Read frame pointer (s0/x8) to find stack frame
    val fp = gdb.read_register("s0")?

    # Read stack frame memory (64 bytes above and below FP)
    val frame_size = 64
    val frame_addr = fp - frame_size
    val frame_data = gdb.read_memory(frame_addr, frame_size * 2)?

    # Without DWARF info, we can only show raw stack slots
    var vars: [VarInfo] = []
    var offset = 0
    var slot_idx = 0
    while offset < frame_data.len() - 3:
        # Read 4 bytes as a 32-bit word (little-endian)
        val word = frame_data[offset]
            + (frame_data[offset + 1] * 256)
            + (frame_data[offset + 2] * 65536)
            + (frame_data[offset + 3] * 16777216)

        val addr = frame_addr + offset
        vars.push(VarInfo.of(
            "[fp{if offset < frame_size: "-" else: "+"}{if offset < frame_size: frame_size - offset else: offset - frame_size}]",
            "0x{word}",
            "i32"
        ))
        offset = offset + 4
        slot_idx = slot_idx + 1

        # Limit to 16 slots to avoid flooding
        if slot_idx >= 16:
            break

    # Serialize
    var parts: [text] = []
    for v in vars:
        parts.push("{v.name}={v.value}:{v.type_name}")
    Ok(parts.join(";"))

# Emulate argument reading via register ABI convention
fn emulate_read_arguments(gdb: GdbMiClient, target: RiscV32Target) -> Result<text, text>:
    # RISC-V calling convention: a0-a7 (x10-x17) are argument registers
    val arg_regs = target.arg_registers()
    var vars: [VarInfo] = []

    for i in 0..arg_regs.len():
        val reg_idx = arg_regs[i]
        val reg_name = target.register_name(reg_idx)
        val value = gdb.read_register(reg_name)?
        vars.push(VarInfo.of(
            "a{i}",
            "{value}",
            "i32"
        ))

    var parts: [text] = []
    for v in vars:
        parts.push("{v.name}={v.value}:{v.type_name}")
    Ok(parts.join(";"))

# Emulate global variable reading via symbol evaluation
fn emulate_read_globals(gdb: GdbMiClient) -> Result<text, text>:
    # Try GDB's info variables to get global symbols
    # This is a console command, not MI, so we use -interpreter-exec
    val data = gdb.send_command("interpreter-exec console \"info variables\"")?
    # The output comes as stream records, which we may not capture well
    # Return empty for now - GDB MI read_globals is the better option
    Ok("")

# Emulate stack trace via frame pointer walking
fn emulate_read_stack_trace(gdb: GdbMiClient, target: RiscV32Target) -> Result<text, text>:
    var frames: [text] = []
    var depth = 0
    val max_depth = 32

    # Read current PC and FP
    val pc = gdb.read_register("pc")?
    var fp = gdb.read_register("s0")?
    var ra = gdb.read_register("ra")?

    # First frame: current PC
    frames.push("{depth}:0x{pc}::0")
    depth = depth + 1

    # Walk frame pointers
    while depth < max_depth and fp != 0:
        # Frame layout (RISC-V standard):
        #   fp-4: saved ra (return address)
        #   fp-8: saved fp (previous frame pointer)
        val saved_ra_addr = fp - 4
        val saved_fp_addr = fp - 8

        # Read saved RA and FP
        val ra_bytes = gdb.read_memory(saved_ra_addr, 4)?
        if ra_bytes.len() < 4:
            break

        val saved_ra = ra_bytes[0]
            + (ra_bytes[1] * 256)
            + (ra_bytes[2] * 65536)
            + (ra_bytes[3] * 16777216)

        val fp_bytes = gdb.read_memory(saved_fp_addr, 4)?
        if fp_bytes.len() < 4:
            break

        val saved_fp = fp_bytes[0]
            + (fp_bytes[1] * 256)
            + (fp_bytes[2] * 65536)
            + (fp_bytes[3] * 16777216)

        if saved_ra == 0:
            break

        frames.push("{depth}:0x{saved_ra}::0")
        depth = depth + 1

        # Move to previous frame
        fp = saved_fp

    Ok(frames.join(";"))

# Emulate profiling via PC sampling
fn emulate_profile_sample(gdb: GdbMiClient, args: [text]) -> Result<text, text>:
    val sample_count = if args.len() > 0: args[0].parse_int() ?? 100 else: 100
    val delay_ms = if args.len() > 1: args[1].parse_int() ?? 10 else: 10

    var pc_counts: Dict<text, i32> = {}

    for i in 0..sample_count:
        # Halt target
        gdb.halt()?

        # Read PC
        val pc = gdb.read_register("pc")?
        val pc_hex = "0x{pc}"

        # Count PC hits
        val current = pc_counts.get(pc_hex) ?? 0
        pc_counts[pc_hex] = current + 1

        # Resume and wait
        gdb.resume()?
        shell("sleep 0.{delay_ms}")

    # Halt at the end
    gdb.halt()?

    # Format results: sorted by count descending
    var entries: [text] = []
    for pc in pc_counts.keys():
        val count = pc_counts[pc]
        val pct = (count * 100) / sample_count
        entries.push("{pc}: {count} ({pct}%)")

    Ok(entries.join("\n"))

# Emulate flash programming via OpenOCD
fn emulate_flash_program(args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("FlashProgram requires [elf_path]")

    val elf_path = args[0]

    # Check if OpenOCD is available
    val check = shell("which openocd 2>/dev/null")
    if check.exit_code != 0:
        return Err("OpenOCD not found - install with: apt install openocd")

    # Use OpenOCD to flash
    val flash_result = shell("openocd -f interface/ftdi/olimex-arm-usb-ocd-h.cfg -f target/riscv32.cfg -c 'program {elf_path} verify reset exit'")
    if flash_result.exit_code != 0:
        return Err("flash failed: {flash_result.stderr}")

    Ok("flashed {elf_path}")

# Emulate system reset via GDB monitor command
fn emulate_system_reset(gdb: GdbMiClient) -> Result<text, text>:
    # Send monitor reset to OpenOCD/GDB server
    gdb.send_command("interpreter-exec console \"monitor reset halt\"")?
    Ok("system reset")
