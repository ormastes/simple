# Trace32 Feature Registration
# Registers all Trace32 native handlers at rank 0 (native).
# Mirrors register_gdb.spl for the Trace32 backend.

use remote.feature.features.{FeatureId, FeatureRank}
use remote.feature.registry.{FeatureHandler, FeatureRegistry}
use remote.protocol.trace32.{Trace32Client, Trace32Parser}
use app.debug.coordinator.VarInfo

# Register all Trace32 native features at rank 0
fn register_trace32_features(registry: FeatureRegistry, t32: Trace32Client):
    # Execution control
    registry.register(FeatureHandler.of(
        FeatureId.Halt, FeatureRank.NATIVE(), "trace32",
        \args: t32.halt(),
        "T32 Break"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.Resume, FeatureRank.NATIVE(), "trace32",
        \args: t32.resume(),
        "T32 Go"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.SingleStep, FeatureRank.NATIVE(), "trace32",
        \args: t32.single_step(),
        "T32 Step"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.StepOver, FeatureRank.NATIVE(), "trace32",
        \args: t32.step_over(),
        "T32 Step.Over"
    ))

    # Memory
    registry.register(FeatureHandler.of(
        FeatureId.ReadMemory, FeatureRank.NATIVE(), "trace32",
        \args: t32_read_memory(t32, args),
        "T32 Data.dump"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.WriteMemory, FeatureRank.NATIVE(), "trace32",
        \args: t32_write_memory(t32, args),
        "T32 Data.Set"
    ))

    # Registers
    registry.register(FeatureHandler.of(
        FeatureId.ReadRegister, FeatureRank.NATIVE(), "trace32",
        \args: t32_read_register(t32, args),
        "T32 Register(name)"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.WriteRegister, FeatureRank.NATIVE(), "trace32",
        \args: t32_write_register(t32, args),
        "T32 Register.Set"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.ReadAllRegisters, FeatureRank.NATIVE(), "trace32",
        \args: t32_read_all_registers(t32),
        "T32 Register /All"
    ))

    # Breakpoints
    registry.register(FeatureHandler.of(
        FeatureId.SetBreakpoint, FeatureRank.NATIVE(), "trace32",
        \args: t32_set_breakpoint(t32, args),
        "T32 Break.Set"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.ClearBreakpoint, FeatureRank.NATIVE(), "trace32",
        \args: t32_clear_breakpoint(t32, args),
        "T32 Break.Delete"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.SetWatchpoint, FeatureRank.NATIVE(), "trace32",
        \args: t32_set_watchpoint(t32, args),
        "T32 Break.Set /Read|Write"
    ))

    # Inspection
    registry.register(FeatureHandler.of(
        FeatureId.ReadLocals, FeatureRank.NATIVE(), "trace32",
        \args: t32_read_locals(t32),
        "T32 Var.View %Local"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.ReadArguments, FeatureRank.NATIVE(), "trace32",
        \args: t32_read_arguments(t32),
        "T32 Var.View %Argument"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.ReadGlobals, FeatureRank.NATIVE(), "trace32",
        \args: t32_read_globals(t32),
        "T32 Var.View %Global"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.EvaluateExpression, FeatureRank.NATIVE(), "trace32",
        \args: t32_evaluate(t32, args),
        "T32 Var.VALUE(expr)"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.ReadStackTrace, FeatureRank.NATIVE(), "trace32",
        \args: t32_read_stack_trace(t32),
        "T32 Frame.View /Caller"
    ))

    # System operations - native support (rank 0, vs GDB emulation at rank 3)
    registry.register(FeatureHandler.of(
        FeatureId.SystemReset, FeatureRank.NATIVE(), "trace32",
        \args: t32.system_reset(),
        "T32 SYStem.Up"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.FlashProgram, FeatureRank.NATIVE(), "trace32",
        \args: t32_flash_program(t32, args),
        "T32 FLASH.ReProgram"
    ))

    # Trace32-unique features (rank 0)
    registry.register(FeatureHandler.of(
        FeatureId.TraceCapture, FeatureRank.NATIVE(), "trace32",
        \args: t32_trace_capture(t32, args),
        "T32 Trace.Arm + Trace.List"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.CoverageCollect, FeatureRank.NATIVE(), "trace32",
        \args: t32_coverage_collect(t32, args),
        "T32 COVerage.ListFunc"
    ))

# --- Handler adapters (convert [text] args to typed calls) ---

fn t32_read_memory(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 2:
        return Err("ReadMemory requires [addr, size]")
    val addr = args[0].parse_int() ?? 0
    val size = args[1].parse_int() ?? 0
    val bytes = t32.read_memory(addr, size)?
    Ok(bytes.map(\b: "{b}").join(","))

fn t32_write_memory(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 2:
        return Err("WriteMemory requires [addr, data...]")
    val addr = args[0].parse_int() ?? 0
    var data: [i32] = []
    for i in 1..args.len():
        data.push(args[i].parse_int() ?? 0)
    t32.write_memory(addr, data)

fn t32_read_register(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("ReadRegister requires [name]")
    val value = t32.read_register(args[0])?
    Ok("{value}")

fn t32_write_register(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 2:
        return Err("WriteRegister requires [name, value]")
    val value = args[1].parse_int() ?? 0
    t32.write_register(args[0], value)

fn t32_read_all_registers(t32: Trace32Client) -> Result<text, text>:
    val regs = t32.read_all_registers()?
    var parts: [text] = []
    for key in regs.keys():
        parts.push("{key}={regs[key]}")
    Ok(parts.join(","))

fn t32_set_breakpoint(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("SetBreakpoint requires [location]")
    val id = t32.set_breakpoint(args[0])?
    Ok("{id}")

fn t32_clear_breakpoint(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("ClearBreakpoint requires [id]")
    val id = args[0].parse_int() ?? 0
    t32.delete_breakpoint(id)

fn t32_set_watchpoint(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("SetWatchpoint requires [expr, access?]")
    val access = if args.len() > 1: args[1] else: "write"
    val id = t32.set_watchpoint(args[0], access)?
    Ok("{id}")

fn t32_read_locals(t32: Trace32Client) -> Result<text, text>:
    val vars = t32.read_locals()?
    Ok(serialize_t32_vars(vars))

fn t32_read_arguments(t32: Trace32Client) -> Result<text, text>:
    val vars = t32.read_arguments()?
    Ok(serialize_t32_vars(vars))

fn t32_read_globals(t32: Trace32Client) -> Result<text, text>:
    val vars = t32.read_globals()?
    Ok(serialize_t32_vars(vars))

fn t32_evaluate(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("EvaluateExpression requires [expr]")
    t32.evaluate(args[0])

fn t32_read_stack_trace(t32: Trace32Client) -> Result<text, text>:
    val frames = t32.stack_trace()?
    var parts: [text] = []
    for f in frames:
        parts.push("{f.index}:{f.function_name}:{f.file}:{f.line}")
    Ok(parts.join(";"))

fn t32_flash_program(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("FlashProgram requires [elf_path]")
    t32.flash_program(args[0])

fn t32_trace_capture(t32: Trace32Client, args: [text]) -> Result<text, text>:
    val duration = if args.len() > 0: args[0].parse_int() ?? 1000 else: 1000
    t32.trace_capture(duration)

fn t32_coverage_collect(t32: Trace32Client, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("CoverageCollect requires [module]")
    t32.coverage_collect(args[0])

# Serialize VarInfo list to text format (same as GDB serialization)
fn serialize_t32_vars(vars: [VarInfo]) -> text:
    var parts: [text] = []
    for v in vars:
        parts.push("{v.name}={v.value}:{v.type_name}")
    parts.join(";")

# --- Exports ---

export register_trace32_features
export serialize_t32_vars
