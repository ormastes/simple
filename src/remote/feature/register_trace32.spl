# Trace32 Feature Registration
# Registers Trace32 handlers at appropriate ranks.

use remote.feature.features.{FeatureId, FeatureRank}
use remote.feature.registry.{FeatureHandler, FeatureRegistry}
use remote.protocol.trace32_gdb_bridge.Trace32GdbBridge
use remote.protocol.trace32_native.Trace32NativeClient

# Register Trace32 GDB bridge features at rank 1
fn register_trace32_bridge_features(registry: FeatureRegistry, bridge: Trace32GdbBridge):
    # Execution control (translated through GDB)
    registry.register(FeatureHandler.of(
        FeatureId.Halt, FeatureRank.BRIDGE, "trace32-gdb",
        \args: bridge.break_(),
        "T32 Break → GDB -exec-interrupt"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.Resume, FeatureRank.BRIDGE, "trace32-gdb",
        \args: bridge.go(),
        "T32 Go → GDB -exec-continue"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.SingleStep, FeatureRank.BRIDGE, "trace32-gdb",
        \args: bridge.step(),
        "T32 Step → GDB -exec-step"
    ))

    # Memory
    registry.register(FeatureHandler.of(
        FeatureId.ReadMemory, FeatureRank.BRIDGE, "trace32-gdb",
        \args: t32_bridge_read_memory(bridge, args),
        "T32 Data.dump → GDB -data-read-memory-bytes"
    ))

    # Registers
    registry.register(FeatureHandler.of(
        FeatureId.ReadRegister, FeatureRank.BRIDGE, "trace32-gdb",
        \args: t32_bridge_read_register(bridge, args),
        "T32 Register.view → GDB register read"
    ))

    # Breakpoints
    registry.register(FeatureHandler.of(
        FeatureId.SetBreakpoint, FeatureRank.BRIDGE, "trace32-gdb",
        \args: t32_bridge_set_breakpoint(bridge, args),
        "T32 Break.Set → GDB -break-insert"
    ))

    # Inspection
    registry.register(FeatureHandler.of(
        FeatureId.ReadLocals, FeatureRank.BRIDGE, "trace32-gdb",
        \args: t32_bridge_read_locals(bridge),
        "T32 Var.View → GDB -stack-list-locals"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.ReadStackTrace, FeatureRank.BRIDGE, "trace32-gdb",
        \args: t32_bridge_stack_trace(bridge),
        "T32 Frame.view → GDB -stack-list-frames"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.EvaluateExpression, FeatureRank.BRIDGE, "trace32-gdb",
        \args: t32_bridge_evaluate(bridge, args),
        "T32 Eval → GDB -data-evaluate-expression"
    ))

# Register Trace32 native features at rank 0 for unique capabilities
fn register_trace32_native_features(registry: FeatureRegistry, client: Trace32NativeClient):
    registry.register(FeatureHandler.of(
        FeatureId.FlashProgram, FeatureRank.NATIVE, "trace32-native",
        \args: t32_native_flash(client, args),
        "T32 FLASH.ReProgram + Data.LOAD.Elf"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.TraceCapture, FeatureRank.NATIVE, "trace32-native",
        \args: t32_native_trace_capture(client),
        "T32 Trace.Init + Trace.ON/OFF"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.CoverageCollect, FeatureRank.NATIVE, "trace32-native",
        \args: t32_native_coverage(client),
        "T32 COVerage.ON + COVerage.ListFunc"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.ProfileSample, FeatureRank.NATIVE, "trace32-native",
        \args: t32_native_profile(client),
        "T32 Analyzer.AutoFocus + Analyzer.List"
    ))
    registry.register(FeatureHandler.of(
        FeatureId.SystemReset, FeatureRank.NATIVE, "trace32-native",
        \args: client.system_reset(),
        "T32 SYStem.RESetTarget"
    ))

# --- Bridge handler adapters ---

fn t32_bridge_read_memory(bridge: Trace32GdbBridge, args: [text]) -> Result<text, text>:
    if args.len() < 2:
        return Err("ReadMemory requires [addr, size]")
    val addr = args[0].parse_int() ?? 0
    val size = args[1].parse_int() ?? 0
    val bytes = bridge.data_dump(addr, size)?
    Ok(bytes.map(\b: "{b}").join(","))

fn t32_bridge_read_register(bridge: Trace32GdbBridge, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("ReadRegister requires [name]")
    val value = bridge.register_read(args[0])?
    Ok("{value}")

fn t32_bridge_set_breakpoint(bridge: Trace32GdbBridge, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("SetBreakpoint requires [addr]")
    val addr = args[0].parse_int() ?? 0
    bridge.break_set(addr, "/Program")

fn t32_bridge_read_locals(bridge: Trace32GdbBridge) -> Result<text, text>:
    val vars = bridge.var_view("locals")?
    var parts: [text] = []
    for v in vars:
        parts.push("{v.name}={v.value}:{v.type_name}")
    Ok(parts.join(";"))

fn t32_bridge_stack_trace(bridge: Trace32GdbBridge) -> Result<text, text>:
    val frames = bridge.frame_view()?
    var parts: [text] = []
    for f in frames:
        parts.push("{f.index}:{f.function_name}:{f.file}:{f.line}")
    Ok(parts.join(";"))

fn t32_bridge_evaluate(bridge: Trace32GdbBridge, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("EvaluateExpression requires [expr]")
    bridge.eval_expression(args[0])

# --- Native handler adapters ---

fn t32_native_flash(client: Trace32NativeClient, args: [text]) -> Result<text, text>:
    if args.len() < 1:
        return Err("FlashProgram requires [elf_path, addr?]")
    val elf_path = args[0]
    val addr: i64 = if args.len() > 1: args[1].parse_int() ?? 0 else: 0
    client.flash_program(elf_path, addr)

fn t32_native_trace_capture(client: Trace32NativeClient) -> Result<text, text>:
    client.trace_capture_start()?
    Ok("trace capture started")

fn t32_native_coverage(client: Trace32NativeClient) -> Result<text, text>:
    val data = client.coverage_collect()?
    Ok(data)

fn t32_native_profile(client: Trace32NativeClient) -> Result<text, text>:
    val data = client.profile_sample()?
    Ok(data)
