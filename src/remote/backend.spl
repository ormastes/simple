# Remote RISC-V 32 Debug Backend
# Implements DebugBackend trait from debug coordinator.
# Routes all operations through the Feature Registry.

use app.debug.coordinator.{DebugBackend, VarInfo, FrameInfo, LocationInfo}
use remote.types.{DebugConfig, Architecture}
use remote.target.riscv32.RiscV32Target
use remote.feature.features.FeatureId
use remote.feature.registry.{FeatureRegistry, FeatureHandler}
use remote.feature.register_gdb.{register_gdb_features, serialize_vars}
use remote.protocol.gdb_mi.GdbMiClient

# Remote RISC-V 32-bit debug backend
class RemoteRiscV32Backend:
    config: DebugConfig
    registry: FeatureRegistry
    gdb: Option<GdbMiClient>
    target: RiscV32Target
    attached: bool

impl RemoteRiscV32Backend:
    # GDB-only connection (for QEMU testing)
    static fn gdb_only(config: DebugConfig) -> Result<RemoteRiscV32Backend, text>:
        val gdb = GdbMiClient.connect(config)?
        var registry = FeatureRegistry.empty()
        register_gdb_features(registry, gdb)

        Ok(RemoteRiscV32Backend(
            config: config,
            registry: registry,
            gdb: Some(gdb),
            target: RiscV32Target.create(),
            attached: true
        ))

    # Add emulation fallbacks
    me add_emulation():
        use remote.feature.emulation.register_emulation_features
        match self.gdb:
            Some(gdb):
                register_emulation_features(self.registry, gdb, self.target)
            nil:
                pass

    # Get capabilities report
    fn capabilities() -> text:
        self.registry.capabilities_report()

    # Check if a feature is supported
    fn supports(feat: FeatureId) -> bool:
        self.registry.is_supported(feat)

    # --- DebugBackend trait implementation ---

    fn name() -> String:
        "remote-riscv32"

    fn attach(program_path: String, args: [String]) -> Result<Nil, String>:
        # For remote targets, attaching means loading symbols
        match self.gdb:
            Some(gdb):
                if program_path.len() > 0:
                    gdb.send_command("file-exec-and-symbols {program_path}")?
                self.attached = true
                Ok(nil)
            nil:
                Err("no GDB connection")

    fn detach() -> Result<Nil, String>:
        match self.gdb:
            Some(gdb):
                gdb.disconnect()
                self.attached = false
            nil:
                pass
        Ok(nil)

    fn run() -> Result<Nil, String>:
        self.registry.execute(FeatureId.Resume, [])?
        Ok(nil)

    fn pause() -> Result<Nil, String>:
        self.registry.execute(FeatureId.Halt, [])?
        Ok(nil)

    fn resume() -> Result<Nil, String>:
        self.registry.execute(FeatureId.Resume, [])?
        Ok(nil)

    fn step_over() -> Result<Nil, String>:
        self.registry.execute(FeatureId.StepOver, [])?
        Ok(nil)

    fn step_in() -> Result<Nil, String>:
        self.registry.execute(FeatureId.SingleStep, [])?
        Ok(nil)

    fn step_out() -> Result<Nil, String>:
        # Step out uses GDB's finish command
        match self.gdb:
            Some(gdb):
                gdb.step_out()?
                Ok(nil)
            nil:
                Err("step_out requires GDB connection")

    fn add_breakpoint(file: String, line: Int) -> Result<Int, String>:
        val location = "{file}:{line}"
        val result = self.registry.execute(FeatureId.SetBreakpoint, [location])?
        val id = result.parse_int() ?? 0
        Ok(id)

    fn remove_breakpoint(file: String, line: Int) -> Result<Nil, String>:
        # Need to find breakpoint ID first - for simplicity, use location
        match self.gdb:
            Some(gdb):
                # GDB can delete by ID; here we just pass it through
                gdb.send_command("break-delete {line}")?
                Ok(nil)
            nil:
                Err("no GDB connection")

    fn stack_trace() -> Result<[FrameInfo], String>:
        match self.gdb:
            Some(gdb):
                gdb.stack_trace()
            nil:
                val result = self.registry.execute(FeatureId.ReadStackTrace, [])?
                parse_stack_trace(result)

    fn locals() -> Result<[VarInfo], String>:
        match self.gdb:
            Some(gdb):
                gdb.read_locals()
            nil:
                val result = self.registry.execute(FeatureId.ReadLocals, [])?
                parse_vars(result)

    fn evaluate(expr: String) -> Result<String, String>:
        self.registry.execute(FeatureId.EvaluateExpression, [expr])

    fn current_location() -> Result<LocationInfo, String>:
        match self.gdb:
            Some(gdb):
                val frames = gdb.stack_trace()?
                if frames.len() > 0:
                    val f = frames[0]
                    Ok(LocationInfo.at(f.file, f.line, f.function_name))
                else:
                    Err("no frames available")
            nil:
                Err("no GDB connection")

    # --- Extended remote operations ---

    fn read_memory(addr: i64, size: i32) -> Result<[i32], text>:
        match self.gdb:
            Some(gdb): gdb.read_memory(addr, size)
            nil: Err("no GDB connection")

    fn write_memory(addr: i64, data: [i32]) -> Result<text, text>:
        match self.gdb:
            Some(gdb): gdb.write_memory(addr, data)
            nil: Err("no GDB connection")

    fn read_register(name: text) -> Result<i64, text>:
        match self.gdb:
            Some(gdb): gdb.read_register(name)
            nil: Err("no GDB connection")

    fn read_all_registers() -> Result<Dict<text, i64>, text>:
        match self.gdb:
            Some(gdb): gdb.read_all_registers()
            nil: Err("no GDB connection")

    fn set_breakpoint_at_addr(addr: i64) -> Result<i32, text>:
        match self.gdb:
            Some(gdb): gdb.set_breakpoint_at_addr(addr)
            nil: Err("no GDB connection")

# --- Helper parsers ---

fn parse_stack_trace(raw: text) -> Result<[FrameInfo], String>:
    var result: [FrameInfo] = []
    for entry in raw.split(";"):
        val parts = entry.split(":")
        if parts.len() >= 4:
            val index = parts[0].parse_int() ?? 0
            val func = parts[1]
            val file = parts[2]
            val line = parts[3].parse_int() ?? 0
            result.push(FrameInfo.of(index, func, file, line))
    Ok(result)

fn parse_vars(raw: text) -> Result<[VarInfo], String>:
    var result: [VarInfo] = []
    for entry in raw.split(";"):
        # BUG-RT-011: index_of() returns Option, not i32. Use split() instead.
        val eq_parts = entry.split("=")
        if eq_parts.len() >= 2:
            val name = eq_parts[0]
            # Rejoin remaining parts in case value contained =
            var rest = eq_parts[1]
            var ei = 2
            while ei < eq_parts.len():
                rest = rest + "=" + eq_parts[ei]
                ei = ei + 1
            val colon_parts = rest.split(":")
            if colon_parts.len() >= 2:
                val value = colon_parts[0]
                val type_name = colon_parts[1]
                result.push(VarInfo.of(name, value, type_name))
            else:
                result.push(VarInfo.of(name, rest, ""))
    Ok(result)
