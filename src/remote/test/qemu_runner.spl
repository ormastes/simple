# QEMU Test Runner for Remote Debugging
# Manages QEMU instances for integration testing of remote debug features.
# Uses the unified QEMU library (lib/qemu) for shared functionality.

use lib.qemu.{QemuArch, QemuConfig, QemuInstance, is_qemu_available, is_gdb_available, find_rv32_gcc, build_rv32_binary}

# Convenience wrapper for remote debugging QEMU instances
class QemuRunner:
    instance: QemuInstance   # Underlying QEMU instance

impl QemuRunner:
    # Start QEMU with a RISC-V 32 binary, halted, with GDB stub
    static fn start(elf_path: text, port: i32) -> Result<QemuRunner, text>:
        # Create config for remote debugging
        val config = QemuConfig.for_remote_debug(QemuArch.RiscV32, elf_path, port)

        # Start QEMU instance
        val result = QemuInstance.start(config)
        match result:
            case Ok(instance):
                Ok(QemuRunner(instance: instance))
            case Err(msg):
                Err(msg)

    # Start with custom QEMU arguments
    static fn start_custom(elf_path: text, port: i32, extra_args: text) -> Result<QemuRunner, text>:
        var config = QemuConfig.for_remote_debug(QemuArch.RiscV32, elf_path, port)

        # Parse extra args and add to config
        val args_list = extra_args.split(" ").filter(\s: s.len() > 0)
        config.extra_args = args_list

        # Start QEMU instance
        val result = QemuInstance.start(config)
        match result:
            case Ok(instance):
                Ok(QemuRunner(instance: instance))
            case Err(msg):
                Err(msg)

    # Start with specific architecture
    static fn start_arch(arch: QemuArch, elf_path: text, port: i32) -> Result<QemuRunner, text>:
        val config = QemuConfig.for_remote_debug(arch, elf_path, port)

        val result = QemuInstance.start(config)
        match result:
            case Ok(instance):
                Ok(QemuRunner(instance: instance))
            case Err(msg):
                Err(msg)

    # Stop QEMU
    me stop():
        self.instance.stop()

    # Check if QEMU is still running
    fn is_running() -> bool:
        self.instance.is_running()

    # Wait for QEMU to exit with timeout
    fn wait_exit(timeout_ms: i32) -> Result<i32, text>:
        self.instance.wait_exit(timeout_ms as i64)

    # Get QEMU PID
    fn pid() -> text:
        self.instance.get_pid()

    # Get GDB port
    fn gdb_port() -> i32:
        self.instance.get_gdb_port()

    # Get monitor output (if any)
    fn monitor_output() -> text:
        # QEMU writes to stdout which we redirected
        ""

# Re-export utility functions for backward compatibility
fn build_rv32_test(asm_path: text, output_path: text) -> Result<text, text>:
    build_rv32_binary(asm_path, output_path)

fn is_rv32_gcc_available() -> bool:
    find_rv32_gcc().len() > 0

# Parameterless wrappers for RV32-specific checks
fn is_rv32_qemu_available() -> bool:
    is_qemu_available(QemuArch.RiscV32)

fn is_rv32_gdb_available() -> bool:
    is_gdb_available(QemuArch.RiscV32)
