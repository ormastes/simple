# Text Formatter for Terminal Output
#
# Provides rich, colored diagnostic output similar to rustc.

use std.text.{NL}
use diagnostics.{Diagnostic, Severity, Span, Label}

# ANSI color codes
val RESET = "\033[0m"
val BOLD = "\033[1m"
val BLUE = "\033[34m"
val CYAN = "\033[36m"
val GREEN = "\033[32m"

# Text formatter for terminal output with color support
struct TextFormatter:
    use_color: bool

impl TextFormatter:
    # Create a new text formatter with colors
    static fn new() -> TextFormatter:
        TextFormatter(use_color: true)

    # Create a formatter without colors (for piping/redirected output)
    static fn without_color() -> TextFormatter:
        TextFormatter(use_color: false)

    # Format a diagnostic with source code context
    fn format(diagnostic: Diagnostic, source: text) -> text:
        var output = ""

        # Header: severity[code]: message
        output = output + self.format_header(diagnostic)

        # Source code snippet with labels
        if diagnostic.span.?:
            output = output + NL
            output = output + self.format_source_snippet(diagnostic.span.unwrap(), source, diagnostic)

        # Labels for additional spans
        for label in diagnostic.labels:
            # Check if this label is the primary span (avoid unwrap on nil)
            var is_primary = false
            if diagnostic.span.?:
                is_primary = label.span == diagnostic.span.unwrap()

            if not is_primary:
                output = output + NL
                output = output + self.format_label_snippet(label.span, source, label.message, diagnostic.severity)

        # Notes
        for note in diagnostic.notes:
            output = output + NL
            output = output + self.format_note(note)

        # Help
        if diagnostic.help.?:
            output = output + NL
            output = output + self.format_help(diagnostic.help.unwrap())

        output

    # Format the diagnostic header
    fn format_header(diagnostic: Diagnostic) -> text:
        val severity_str = diagnostic.severity.to_string()
        val color = if self.use_color: diagnostic.severity.color() else: ""
        val reset = if self.use_color: RESET else: ""
        val bold = if self.use_color: BOLD else: ""

        if diagnostic.code.?:
            "{color}{bold}{severity_str}[{diagnostic.code.unwrap()}]{reset}: {diagnostic.message}"
        else:
            "{color}{bold}{severity_str}{reset}: {diagnostic.message}"

    # Format source snippet with underline
    fn format_source_snippet(span: Span, source: text, diagnostic: Diagnostic) -> text:
        val lines = source.split(NL)

        # Check bounds (1-indexed)
        if span.line <= 0 or span.line > lines.len():
            return ""

        val line_idx = span.line - 1
        val line_text = lines[line_idx]

        # Line number width for alignment
        val line_num_width = max(span.line.to_string().len(), 2)

        val blue = if self.use_color: BLUE else: ""
        val reset = if self.use_color: RESET else: ""
        val bold = if self.use_color: BOLD else: ""
        val color = if self.use_color: diagnostic.severity.color() else: ""

        var output = ""

        # Location line: "  --> <source>:line:column"
        val padding1 = repeat_space(line_num_width)
        output = output + "{padding1} {blue}{bold}-->{reset} <source>:{span.line}:{span.column}\n"

        # Empty line
        output = output + "{padding1} {blue}|{reset}\n"

        # Source line with line number
        val line_num_padded = pad_left(span.line.to_string(), line_num_width)
        output = output + "{blue}{line_num_padded} |{reset} {line_text}\n"

        # Underline/caret line
        val start_col = max(span.column - 1, 0)
        val underline_len = max(span.len(), 1)
        val spaces = repeat_space(start_col)
        val carets = repeat_char("^", underline_len)

        output = output + "{padding1} {blue}|{reset} {spaces}{color}{bold}{carets}{reset}"

        # Primary label (if any match the main span)
        for label in diagnostic.labels:
            if label.span == span:
                output = output + " {color}{bold}{label.message}{reset}"
                break

        output = output + NL
        output

    # Format additional label snippet
    fn format_label_snippet(span: Span, source: text, label_msg: text, severity: Severity) -> text:
        val lines = source.split(NL)

        if span.line <= 0 or span.line > lines.len():
            return ""

        val line_idx = span.line - 1
        val line_text = lines[line_idx]

        val line_num_width = max(span.line.to_string().len(), 2)

        val blue = if self.use_color: BLUE else: ""
        val reset = if self.use_color: RESET else: ""
        val bold = if self.use_color: BOLD else: ""
        val color = if self.use_color: severity.color() else: ""

        var output = ""

        val padding = repeat_space(line_num_width)
        output = output + "{padding} {blue}|{reset}\n"

        val line_num_padded = pad_left(span.line.to_string(), line_num_width)
        output = output + "{blue}{line_num_padded} |{reset} {line_text}\n"

        val start_col = max(span.column - 1, 0)
        val underline_len = max(span.len(), 1)
        val spaces = repeat_space(start_col)
        val carets = repeat_char("^", underline_len)

        output = output + "{padding} {blue}|{reset} {spaces}{color}{bold}{carets}{reset} {color}{bold}{label_msg}{reset}\n"
        output

    # Format note message
    fn format_note(note: text) -> text:
        val cyan = if self.use_color: CYAN else: ""
        val reset = if self.use_color: RESET else: ""
        val bold = if self.use_color: BOLD else: ""

        "{cyan}{bold}note{reset}: {note}"

    # Format help message
    fn format_help(help: text) -> text:
        val green = if self.use_color: GREEN else: ""
        val reset = if self.use_color: RESET else: ""
        val bold = if self.use_color: BOLD else: ""

        "{green}{bold}help{reset}: {help}"

# Helper functions

fn repeat_space(count: i64) -> text:
    """Repeat space character count times"""
    " ".repeat(count)

fn repeat_char(ch: text, count: i64) -> text:
    """Repeat character count times"""
    ch.repeat(count)

fn pad_left(s: text, width: i64) -> text:
    """Pad string to width with leading spaces"""
    val len = s.len()
    if len >= width:
        return s

    val padding = repeat_space(width - len)
    "{padding}{s}"

fn max(a: i64, b: i64) -> i64:
    """Return maximum of two values"""
    if a > b: a else: b

# Public exports
export TextFormatter
