# Core Interpreter — Module Root
#
# Re-exports all core interpreter modules.
# Entry points:
#   core_interpret(source, path) → value_id       (pure tree-walk)
#   core_jit_interpret(source, path, threshold) → value_id  (JIT-enabled)
#
# Usage (seed compilation):
#   seed tokens.spl lexer.spl parser.spl ast.spl \
#        interpreter/value.spl interpreter/env.spl \
#        interpreter/ops.spl interpreter/eval.spl \
#        interpreter/jit.spl interpreter/mod.spl > interp.cpp

# All modules share globals when compiled by seed, so no explicit imports needed.
# This file provides the top-level entry points.

fn core_interpret(source: text, path: text) -> i64:
    # Initialize all subsystems (pure tree-walk, no JIT)
    jit_init(999999, 0)
    eval_init()
    ast_reset()

    # Lex and parse
    lex_init(source)
    parser_init(source)
    parse_module(source, path)

    # Check for parse errors
    if par_had_error:
        eval_set_error("parse error")
        return -1

    # Evaluate
    eval_module()

fn core_jit_interpret(source: text, path: text, threshold: i64) -> i64:
    # Initialize with JIT enabled
    jit_init(threshold, 0)
    eval_init()
    ast_reset()

    # Lex and parse
    lex_init(source)
    parser_init(source)
    parse_module(source, path)

    # Check for parse errors
    if par_had_error:
        eval_set_error("parse error")
        return -1

    # Evaluate (eval_function_call uses JIT tracking internally)
    eval_module()

fn core_jit_interpret_verbose(source: text, path: text, threshold: i64, backend: text) -> i64:
    # Initialize with JIT enabled + verbose + specific backend
    jit_init_with_backend(threshold, 1, backend)
    eval_init()
    ast_reset()

    # Lex and parse
    lex_init(source)
    parser_init(source)
    parse_module(source, path)

    # Check for parse errors
    if par_had_error:
        eval_set_error("parse error")
        return -1

    # Evaluate
    val result = eval_module()
    jit_cleanup()
    result

fn core_interpret_expr(source: text) -> i64:
    # Initialize subsystems
    eval_init()
    ast_reset()

    # Lex and parse a single expression
    lex_init(source)
    parser_init(source)
    val eid = parse_expr()

    if par_had_error:
        eval_set_error("parse error")
        return -1

    eval_expr(eid)

export core_interpret, core_jit_interpret, core_jit_interpret_verbose
export core_interpret_expr
