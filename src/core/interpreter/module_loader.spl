# Core Interpreter — Runtime Module Loader
#
# Enables runtime resolution of `use` statements without requiring symlinks.
# Mirrors compile-time module loading but operates within interpreter context.
#
# Key responsibilities:
# 1. Resolve module paths (std.string → src/std/string.spl)
# 2. Load and parse module source files
# 3. Extract exported functions from module AST
# 4. Register functions in interpreter's function table
#
# Module Path Resolution (in order):
# 1. Local directory (relative to current file)
# 2. SIMPLE_LIB environment variable path
# 3. Fallback to src/std/ (standard library)

extern fn rt_file_read_text(path: text) -> text
extern fn rt_env_get(key: text) -> text
extern fn rt_file_exists(path: text) -> i64
extern fn rt_path_join(base: text, rel: text) -> text
extern fn rt_path_dirname(path: text) -> text

# AST Declaration Tags (from ast.spl)
val DECL_FN = 1
val DECL_EXTERN_FN = 2
val DECL_STRUCT = 3
val DECL_VAL = 4
val DECL_VAR = 5
val DECL_USE = 6
val DECL_EXPORT = 7
val DECL_ENUM = 8

# Helper struct for building CoreDecl (defined in ast_types.spl)
# Since we can't use generics at runtime, we construct these manually
struct ModuleDeclInfo:
    tag: i64
    name: text
    imports: [text]
    ret_type: i64

fn make_decl_info(tag: i64, name: text, imports: [text], ret_type: i64) -> ModuleDeclInfo:
    ModuleDeclInfo(tag: tag, name: name, imports: imports, ret_type: ret_type)

fn get_decl_info(did: i64) -> ModuleDeclInfo:
    # Build ModuleDeclInfo from AST arena using accessor functions
    val tag = decl_get_tag(did)
    val name = decl_get_name(did)
    val imports = decl_get_imports(did)
    val ret_type = decl_get_ret_type(did)
    make_decl_info(tag, name, imports, ret_type)

# ===== Loaded Module Tracking =====

# Parallel arrays to track loaded modules (no generics at runtime)
var loaded_module_paths: [text] = []
var loaded_module_exports: [[text]] = []
# Dict for O(1) module loaded check
var loaded_module_set = {}

fn module_loader_init():
    loaded_module_paths = []
    loaded_module_exports = []
    loaded_module_set = {}

fn module_is_loaded(module_path: text) -> i64:
    if loaded_module_set.contains_key(module_path):
        return 1
    0

fn module_mark_loaded(module_path: text, exports: [text]):
    loaded_module_paths.push(module_path)
    loaded_module_exports.push(exports)
    loaded_module_set[module_path] = true

# ===== Module Path Resolution =====

fn resolve_module_path(module_name: text, current_file: text) -> text:
    # Convert dotted name to file path
    # std.string → std/string.spl
    # app.io.mod → app/io/mod.spl

    var path_parts: [text] = []
    var current = ""
    var i: i64 = 0
    for char in module_name:
        if char == ".":
            if current != "":
                path_parts.push(current)
                current = ""
        else:
            current = current + char
        i = i + 1

    # Add final part
    if current != "":
        path_parts.push(current)

    # Join parts with /
    var relative_path = ""
    var pi: i64 = 0
    for part in path_parts:
        if pi > 0:
            relative_path = relative_path + "/"
        relative_path = relative_path + part
        pi = pi + 1

    relative_path = relative_path + ".spl"

    # Try resolution strategies:

    # 1. Local directory (relative to current file)
    val current_dir = rt_path_dirname(current_file)
    val local_path = rt_path_join(current_dir, relative_path)
    if rt_file_exists(local_path) == 1:
        return local_path

    # 2. SIMPLE_LIB environment variable
    val simple_lib = rt_env_get("SIMPLE_LIB")
    val has_simple_lib = simple_lib != ""
    val lib_not_nil = simple_lib != nil
    (
        val should_check_lib = has_simple_lib and lib_not_nil
    )
    if should_check_lib:
        val lib_path = rt_path_join(simple_lib, relative_path)
        if rt_file_exists(lib_path) == 1:
            return lib_path

    # 3. Fallback to src/ directory
    val src_path = rt_path_join("src", relative_path)
    if rt_file_exists(src_path) == 1:
        return src_path

    # Return attempted path even if not found (will error later)
    relative_path

# ===== Module Loading =====

fn load_module_source(file_path: text) -> text:
    # Read module source file
    val source = rt_file_read_text(file_path)
    if source == nil:
        return ""
    source

fn parse_module_ast(source: text, path: text) -> i64:
    # Parse module into AST
    # Returns 1 on success, 0 on failure

    # Save current parser state
    val saved_had_error = par_had_error

    # Initialize lexer and parser for module
    lex_init(source)
    parser_init(source)
    parse_module(source, path)

    # Check for errors
    if par_had_error:
        # Restore parser state and fail
        par_had_error = saved_had_error
        return 0

    # Restore parser state
    par_had_error = saved_had_error
    1

fn extract_module_exports() -> [text]:
    # Extract exported function names from parsed module
    # Scans all declarations for DECL_EXPORT statements

    var exports: [text] = []
    var export_all = 0

    val decls = module_get_decls()

    # First pass: check for export statements
    for did in decls:
        val tag = decl_get_tag(did)

        if tag == DECL_EXPORT:
            # Get exported names from decl_imports field
            val names = decl_get_imports(did)
            for name in names:
                exports.push(name)

    # If no explicit exports found, export all functions
    if exports.len() == 0:
        export_all = 1

    if export_all == 1:
        for did in decls:
            val tag = decl_get_tag(did)

            if tag == DECL_FN:
                val name = decl_get_name(did)
                exports.push(name)

    exports

fn register_module_functions():
    # Register all module functions in interpreter's function table
    # This makes them available for calls

    val decls = module_get_decls()

    for did in decls:
        val tag = decl_get_tag(did)

        if tag == DECL_FN:
            val name = decl_get_name(did)
            val ret_type = decl_get_ret_type(did)
            func_table_register(name, did)
            func_register_return_type(name, ret_type)

        if tag == DECL_EXTERN_FN:
            val name = decl_get_name(did)
            val ret_type = decl_get_ret_type(did)
            func_register_return_type(name, ret_type)

# ===== Public API =====

fn load_module(module_name: text, current_file: text) -> i64:
    # Load a module by name and register its exports
    # Returns 1 on success, 0 on failure

    # Check if already loaded
    if module_is_loaded(module_name) == 1:
        return 1

    # Resolve module path
    val resolved_path = resolve_module_path(module_name, current_file)

    # Load source
    val source = load_module_source(resolved_path)
    if source == "":
        return 0

    # Parse module
    val parse_ok = parse_module_ast(source, resolved_path)
    if parse_ok == 0:
        return 0

    # Extract exports
    val exports = extract_module_exports()

    # Register functions
    register_module_functions()

    # Mark as loaded
    module_mark_loaded(module_name, exports)

    1

fn load_module_selective(module_name: text, imported_names: [text], current_file: text) -> i64:
    # Load module and verify requested names are exported
    # Returns 1 on success, 0 on failure

    # Load the module (full load)
    val load_ok = load_module(module_name, current_file)
    if load_ok == 0:
        return 0

    # Find module exports
    var module_exports: [text] = []
    var i: i64 = 0
    for path in loaded_module_paths:
        if path == module_name:
            module_exports = loaded_module_exports[i]
        i = i + 1

    # Verify all requested names are available
    # (For now, we trust the exports - full validation would require checking function table)

    1

export module_loader_init
export load_module, load_module_selective
export resolve_module_path
