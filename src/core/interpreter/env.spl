# Core Interpreter — Hash Map Environment
#
# Seed-compilable scope/variable management using hash maps.
# Each scope has a chained hash table for O(1) average variable lookup.
# Scopes form a stack (innermost last). Globals stored in separate hash map.
#
# Uses fixed-capacity scope array to avoid O(depth) rebuild on pop.

# ===== Scope Stack (Hash Maps) =====
# Each scope has: keys, vals, buckets, nexts (chained hash table)
var scope_hm_keys: [[text]] = []
var scope_hm_vals: [[i64]] = []
var scope_hm_buckets: [[i64]] = []
var scope_hm_nexts: [[i64]] = []
var env_depth: i64 = 0

# ===== Globals (Hash Map) =====
var gl_keys: [text] = []
var gl_vals: [i64] = []
var gl_buckets: [i64] = []
var gl_nexts: [i64] = []

# ===== Environment Init/Reset =====

fn env_init():
    scope_hm_keys = []
    scope_hm_vals = []
    scope_hm_buckets = []
    scope_hm_nexts = []
    env_depth = 0
    gl_keys = []
    gl_vals = []
    gl_buckets = hm_make_global_buckets()
    gl_nexts = []
    # Start with one scope (module-level)
    env_push_scope()

fn env_reset():
    env_init()

# ===== Scope Management =====

fn env_push_scope():
    if env_depth < scope_hm_keys.len():
        # Reuse existing slot — just clear it
        scope_hm_keys[env_depth] = []
        scope_hm_vals[env_depth] = []
        scope_hm_buckets[env_depth] = hm_make_scope_buckets()
        scope_hm_nexts[env_depth] = []
    else:
        # Grow arrays
        scope_hm_keys.push([])
        scope_hm_vals.push([])
        scope_hm_buckets.push(hm_make_scope_buckets())
        scope_hm_nexts.push([])
    env_depth = env_depth + 1

fn env_pop_scope():
    # O(1) — just decrement depth, no array rebuild
    if env_depth > 1:
        env_depth = env_depth - 1

fn env_scope_depth() -> i64:
    env_depth

# ===== Variable Definition =====

fn env_define(name: text, value_id: i64):
    val top = env_depth - 1
    val bucket = hm_hash_text(name) % SCOPE_HM_SIZE
    # Check if already defined in current scope
    var keys = scope_hm_keys[top]
    var vals = scope_hm_vals[top]
    var buckets = scope_hm_buckets[top]
    var nexts = scope_hm_nexts[top]
    var idx = buckets[bucket]
    while idx != -1:
        if keys[idx] == name:
            vals[idx] = value_id
            scope_hm_vals[top] = vals
            return
        idx = nexts[idx]
    # New binding
    val new_idx = keys.len()
    keys.push(name)
    vals.push(value_id)
    nexts.push(buckets[bucket])
    buckets[bucket] = new_idx
    scope_hm_keys[top] = keys
    scope_hm_vals[top] = vals
    scope_hm_buckets[top] = buckets
    scope_hm_nexts[top] = nexts

# ===== Variable Assignment (search outward) =====

fn env_assign(name: text, value_id: i64) -> bool:
    val hash_val = hm_hash_text(name)
    # Search from innermost scope outward
    var si = env_depth - 1
    while si >= 0:
        val bucket = hash_val % SCOPE_HM_SIZE
        val keys = scope_hm_keys[si]
        var vals = scope_hm_vals[si]
        val buckets = scope_hm_buckets[si]
        val nexts = scope_hm_nexts[si]
        var idx = buckets[bucket]
        while idx != -1:
            if keys[idx] == name:
                vals[idx] = value_id
                scope_hm_vals[si] = vals
                return true
            idx = nexts[idx]
        si = si - 1
    # Check globals
    val gl_bucket = hash_val % HM_SIZE
    var gl_idx = gl_buckets[gl_bucket]
    while gl_idx != -1:
        if gl_keys[gl_idx] == name:
            gl_vals[gl_idx] = value_id
            return true
        gl_idx = gl_nexts[gl_idx]
    false

# ===== Variable Lookup =====

fn env_lookup(name: text) -> i64:
    val hash_val = hm_hash_text(name)
    # Search from innermost scope outward
    var si = env_depth - 1
    while si >= 0:
        val bucket = hash_val % SCOPE_HM_SIZE
        val keys = scope_hm_keys[si]
        val vals = scope_hm_vals[si]
        val buckets = scope_hm_buckets[si]
        val nexts = scope_hm_nexts[si]
        var idx = buckets[bucket]
        while idx != -1:
            if keys[idx] == name:
                return vals[idx]
            idx = nexts[idx]
        si = si - 1
    # Check globals
    val gl_bucket = hash_val % HM_SIZE
    var gl_idx = gl_buckets[gl_bucket]
    while gl_idx != -1:
        if gl_keys[gl_idx] == name:
            return gl_vals[gl_idx]
        gl_idx = gl_nexts[gl_idx]
    # VAL_NONE sentinel
    -1

# ===== Global Variables =====

fn env_define_global(name: text, value_id: i64):
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = gl_buckets[bucket]
    while idx != -1:
        if gl_keys[idx] == name:
            gl_vals[idx] = value_id
            return
        idx = gl_nexts[idx]
    # New global
    val new_idx = gl_keys.len()
    gl_keys.push(name)
    gl_vals.push(value_id)
    gl_nexts.push(gl_buckets[bucket])
    gl_buckets[bucket] = new_idx

fn env_lookup_global(name: text) -> i64:
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = gl_buckets[bucket]
    while idx != -1:
        if gl_keys[idx] == name:
            return gl_vals[idx]
        idx = gl_nexts[idx]
    -1

export env_init, env_reset
export env_push_scope, env_pop_scope, env_scope_depth
export env_define, env_assign, env_lookup
export env_define_global, env_lookup_global
