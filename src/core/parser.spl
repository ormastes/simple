# Core Simple — Recursive Descent Parser
#
# Shared core library: parses tokens into an AST stored in the arena.
# Handles function/struct/enum declarations, val/var bindings, use/export,
# expressions, statements, and indentation-based blocks.
#
# Design: All state in module-level vars. Functions modify state.
# Works when compiled to C; NOT in the interpreter (closure bug).

use core.tokens.{tok_kind_name, tok_precedence, tok_is_right_assoc}
use core.tokens.{TOK_INT_LIT, TOK_FLOAT_LIT, TOK_STRING_LIT}
use core.tokens.{TOK_BOOL_LIT, TOK_NIL_LIT, TOK_IDENT}
use core.tokens.{TOK_KW_FN, TOK_KW_VAL, TOK_KW_VAR}
use core.tokens.{TOK_KW_IF, TOK_KW_ELIF, TOK_KW_ELSE}
use core.tokens.{TOK_KW_FOR, TOK_KW_WHILE, TOK_KW_IN}
use core.tokens.{TOK_KW_MATCH, TOK_KW_CASE}
use core.tokens.{TOK_KW_RETURN, TOK_KW_BREAK, TOK_KW_CONTINUE}
use core.tokens.{TOK_KW_STRUCT, TOK_KW_ENUM}
use core.tokens.{TOK_KW_EXTERN, TOK_KW_USE, TOK_KW_EXPORT, TOK_KW_IMPORT, TOK_KW_TRAIT}
use core.tokens.{TOK_KW_TYPE, TOK_KW_ASM}
use core.tokens.{TOK_KW_AND, TOK_KW_OR, TOK_KW_NOT}
use core.tokens.{TOK_KW_TRUE, TOK_KW_FALSE, TOK_KW_NIL}
use core.tokens.{TOK_KW_PASS, TOK_KW_IS}
use core.tokens.{TOK_KW_SELF, TOK_KW_CLASS, TOK_KW_IMPL, TOK_KW_STATIC, TOK_KW_ME}
use core.tokens.{TOK_KW_ASYNC, TOK_KW_AWAIT, TOK_KW_YIELD, TOK_KW_SPAWN}
use core.tokens.{TOK_PLUS, TOK_MINUS, TOK_STAR, TOK_SLASH, TOK_PERCENT}
use core.tokens.{TOK_EQ, TOK_NEQ, TOK_LT, TOK_GT, TOK_LEQ, TOK_GEQ}
use core.tokens.{TOK_ASSIGN, TOK_PLUS_ASSIGN, TOK_MINUS_ASSIGN}
use core.tokens.{TOK_STAR_ASSIGN, TOK_SLASH_ASSIGN}
use core.tokens.{TOK_AND, TOK_OR, TOK_NOT}
use core.tokens.{TOK_LPAREN, TOK_RPAREN, TOK_LBRACKET, TOK_RBRACKET}
use core.tokens.{TOK_LBRACE, TOK_RBRACE}
use core.tokens.{TOK_COLON, TOK_COMMA, TOK_DOT, TOK_DOTDOT}
use core.tokens.{TOK_ARROW, TOK_PIPE}
use core.tokens.{TOK_QUESTION, TOK_QUESTION_DOT, TOK_DOUBLE_QUESTION}
use core.tokens.{TOK_NEWLINE, TOK_INDENT, TOK_DEDENT, TOK_EOF, TOK_ERROR}
use core.tokens.{TOK_DOTDOT_EQ, TOK_DOUBLE_STAR, TOK_UNDERSCORE}
use core.tokens.{TOK_PIPE_FORWARD, TOK_SEMICOLON}
use core.tokens.{TOK_SUFFIXED_INT, TOK_SUFFIXED_FLOAT}
use core.lexer.{lex_init, lex_next, lex_cur_kind, lex_cur_text, lex_cur_line, lex_cur_col, lex_cur_suffix}
use core.ast.{EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT}
use core.ast.{EXPR_BOOL_LIT, EXPR_NIL_LIT, EXPR_IDENT}
use core.ast.{EXPR_BINARY, EXPR_UNARY, EXPR_CALL, EXPR_INDEX}
use core.ast.{EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT}
use core.ast.{EXPR_IF, EXPR_MATCH, EXPR_FOR, EXPR_WHILE}
use core.ast.{EXPR_RETURN, EXPR_BREAK, EXPR_CONTINUE, EXPR_RANGE}
use core.ast.{EXPR_ASSIGN, EXPR_COMPOUND_ASSIGN, EXPR_UNIT, EXPR_PASS}
use core.ast.{EXPR_NULL_COALESCE, EXPR_SLICE, EXPR_INTERPOLATED_STRING}
use core.ast.{EXPR_AWAIT, EXPR_YIELD, EXPR_SPAWN}
use core.ast.{expr_int_lit, expr_float_lit, expr_string_lit}
use core.ast.{expr_bool_lit, expr_nil_lit, expr_ident}
use core.ast.{expr_binary, expr_unary, expr_call, expr_index}
use core.ast.{expr_field_access, expr_method_call, expr_array_lit}
use core.ast.{expr_if_expr, expr_for_expr, expr_while_expr}
use core.ast.{expr_return_expr, expr_break_expr, expr_continue_expr}
use core.ast.{expr_range, expr_assign, expr_compound_assign}
use core.ast.{expr_unit, expr_pass, expr_null_coalesce, expr_slice}
use core.ast.{expr_dict_lit}
use core.ast.{expr_suffixed_int, expr_suffixed_float, expr_suffixed_bool}
use core.ast.{expr_match_expr, expr_block}
use core.ast.{expr_await, expr_yield, expr_spawn}
use core.ast.{STMT_EXPR, STMT_VAL_DECL, STMT_VAR_DECL}
use core.ast.{STMT_RETURN, STMT_IF, STMT_FOR, STMT_WHILE}
use core.ast.{STMT_MATCH, STMT_BREAK, STMT_CONTINUE, STMT_COMPOUND_ASSIGN}
use core.ast.{stmt_expr_stmt, stmt_val_decl, stmt_var_decl}
use core.ast.{stmt_return_stmt, stmt_if_stmt, stmt_for_stmt, stmt_while_stmt}
use core.ast.{stmt_match_stmt, stmt_break_stmt, stmt_continue_stmt}
use core.ast.{stmt_assign_stmt, stmt_compound_assign_stmt}
use core.ast.{DECL_FN, DECL_EXTERN_FN, DECL_STRUCT, DECL_USE, DECL_EXPORT}
use core.ast.{DECL_VAL, DECL_VAR, DECL_ENUM}
use core.ast.{decl_fn, decl_extern_fn, decl_struct_def}
use core.ast.{decl_val_binding, decl_var_binding}
use core.ast.{decl_use_import, decl_export_names, decl_enum_def}
use core.ast.{decl_impl_block}
use core.ast.{arm_new}
use core.ast.{elif_new}
use core.ast.{module_set_path, module_add_decl}
use core.ast.{ast_reset}
use core.types.{TYPE_I64, TYPE_F64, TYPE_TEXT, TYPE_BOOL, TYPE_VOID}
use core.types.{TYPE_ARRAY_I64, TYPE_ARRAY_TEXT, TYPE_ARRAY_BOOL}
use core.types.{TYPE_NIL}
use core.types.{TYPE_OPTION, TYPE_OPTION_I64, TYPE_OPTION_F64, TYPE_OPTION_TEXT, TYPE_OPTION_BOOL}
use core.types.{TYPE_RESULT, TYPE_NAMED_BASE}
use core.types.{int_to_str}
use core.types.{named_type_register, named_type_find}

# ===== Parser State =====

var par_kind: i64 = 0
var par_text: text = ""
var par_line: i64 = 0
var par_col: i64 = 0
var par_errors: [text] = []
var par_had_error: bool = false
var par_struct_names: [text] = []

# ===== Parser Init =====

fn parser_init(source: text):
    lex_init(source)
    ast_reset()
    par_errors = []
    par_had_error = false
    parser_advance()

fn parser_advance():
    par_kind = lex_next()
    par_text = lex_cur_text
    par_line = lex_cur_line
    par_col = lex_cur_col

# ===== Token Checking =====

fn parser_check(expected: i64) -> bool:
    par_kind == expected

fn parser_match_tok(expected: i64) -> bool:
    if par_kind != expected:
        return false
    parser_advance()
    true

fn parser_expect(expected: i64) -> bool:
    if par_kind == expected:
        parser_advance()
        return true
    val msg = "line " + int_to_str(par_line) + ":" + int_to_str(par_col) + ": expected " + tok_kind_name(expected) + ", got " + tok_kind_name(par_kind) + " '" + par_text + "'"
    par_errors.push(msg)
    par_had_error = true
    false

fn parser_error(msg: text):
    val full = "line " + int_to_str(par_line) + ":" + int_to_str(par_col) + ": " + msg
    par_errors.push(full)
    par_had_error = true

# ===== Skip Newlines =====

fn parser_skip_newlines():
    for i in 0..10000:
        if par_kind != TOK_NEWLINE:
            break
        parser_advance()

fn parser_skip_newlines_and_semicolons():
    for i in 0..10000:
        val is_nl = par_kind == TOK_NEWLINE
        val is_semi = par_kind == TOK_SEMICOLON
        val should_skip = is_nl or is_semi
        if not should_skip:
            break
        parser_advance()

# ===== Type Annotation Parsing =====

fn parser_parse_type() -> i64:
    val type_name = par_text
    if par_kind == TOK_IDENT:
        parser_advance()
        # Check for generic type: Option<T>, Result<T, E>, Dict<K,V>, etc.
        if par_kind == TOK_LT:
            parser_advance()
            val inner_type = parser_parse_type()
            # Handle multi-param generics: Dict<K, V>, Result<T, E>
            for i in 0..10:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                val extra_type = parser_parse_type()
            parser_expect(TOK_GT)
            # Handle Option<T>
            if type_name == "Option":
                if inner_type == TYPE_I64:
                    return TYPE_OPTION_I64
                if inner_type == TYPE_F64:
                    return TYPE_OPTION_F64
                if inner_type == TYPE_TEXT:
                    return TYPE_OPTION_TEXT
                if inner_type == TYPE_BOOL:
                    return TYPE_OPTION_BOOL
                return TYPE_OPTION
            # Handle Result<T, E> (simplified - just return TYPE_RESULT)
            if type_name == "Result":
                return TYPE_RESULT
            # Dict<K,V> -> TYPE_DICT
            if type_name == "Dict":
                return TYPE_DICT
            # Unknown generic type - check if base is a named struct
            val gid = named_type_find(type_name)
            if gid >= 0:
                return TYPE_NAMED_BASE + gid
            return TYPE_VOID
        # Check for postfix ? for Option shorthand: i64? -> Option<i64>
        if par_kind == TOK_QUESTION:
            parser_advance()
            if type_name == "i64":
                return TYPE_OPTION_I64
            if type_name == "f64":
                return TYPE_OPTION_F64
            if type_name == "text":
                return TYPE_OPTION_TEXT
            if type_name == "bool":
                return TYPE_OPTION_BOOL
            return TYPE_OPTION
        # Simple primitive types
        if type_name == "i64":
            return TYPE_I64
        if type_name == "f64":
            return TYPE_F64
        if type_name == "text":
            return TYPE_TEXT
        if type_name == "bool":
            return TYPE_BOOL
        if type_name == "Option":
            return TYPE_OPTION
        if type_name == "Result":
            return TYPE_RESULT
        # Check for struct type
        val sid = named_type_find(type_name)
        if sid >= 0:
            return TYPE_NAMED_BASE + sid
        return TYPE_VOID
    if par_kind == TOK_LBRACKET:
        # Array type: [i64], [text], etc.
        parser_advance()
        val elem_type = parser_parse_type()
        parser_expect(TOK_RBRACKET)
        # Nested array types [[T]] -> TYPE_ARRAY_ANY
        val is_nested = elem_type == TYPE_ARRAY_I64
        val is_nested2 = elem_type == TYPE_ARRAY_TEXT
        val is_nested3 = elem_type == TYPE_ARRAY_BOOL
        val is_nested4 = elem_type == TYPE_ARRAY_ANY
        val any_nested = is_nested or is_nested2
        val any_nested2 = any_nested or is_nested3
        val any_nested3 = any_nested2 or is_nested4
        if any_nested3:
            return TYPE_ARRAY_ANY
        if elem_type == TYPE_I64:
            return TYPE_ARRAY_I64
        if elem_type == TYPE_TEXT:
            return TYPE_ARRAY_TEXT
        if elem_type == TYPE_BOOL:
            return TYPE_ARRAY_BOOL
        return TYPE_ARRAY_I64
    # Function type: fn(T, T) -> T
    if par_kind == TOK_KW_FN:
        parser_advance()
        parser_expect(TOK_LPAREN)
        if par_kind != TOK_RPAREN:
            parser_parse_type()
            for i in 0..100:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                if par_kind == TOK_RPAREN:
                    break
                parser_parse_type()
        parser_expect(TOK_RPAREN)
        if par_kind == TOK_ARROW:
            parser_advance()
            parser_parse_type()
        return TYPE_FN
    # Tuple type: (T, T)
    if par_kind == TOK_LPAREN:
        parser_advance()
        if par_kind != TOK_RPAREN:
            parser_parse_type()
            for i in 0..100:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                if par_kind == TOK_RPAREN:
                    break
                parser_parse_type()
        parser_expect(TOK_RPAREN)
        return TYPE_ANY
    # Dict type: {K: V}
    if par_kind == TOK_LBRACE:
        parser_advance()
        if par_kind != TOK_RBRACE:
            parser_parse_type()
            if par_kind == TOK_COLON:
                parser_advance()
                parser_parse_type()
        parser_expect(TOK_RBRACE)
        return TYPE_DICT
    parser_error("expected type annotation")
    TYPE_VOID

# ===== Expression Parsing =====

fn parse_expr() -> i64:
    parse_assignment()

fn parse_assignment() -> i64:
    val left = parse_or()
    if par_kind == TOK_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_assign(left, right, 0)
    if par_kind == TOK_PLUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_PLUS, left, right, 0)
    if par_kind == TOK_MINUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_MINUS, left, right, 0)
    if par_kind == TOK_STAR_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_STAR, left, right, 0)
    if par_kind == TOK_SLASH_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_SLASH, left, right, 0)
    left

fn parse_or() -> i64:
    var left = parse_and()
    for i in 0..1000:
        val is_or = par_kind == TOK_KW_OR
        val is_or2 = par_kind == TOK_OR
        val match_or = is_or or is_or2
        if not match_or:
            break
        parser_advance()
        val right = parse_and()
        left = expr_binary(TOK_OR, left, right, 0)
    left

fn parse_and() -> i64:
    var left = parse_not()
    for i in 0..1000:
        val is_and = par_kind == TOK_KW_AND
        val is_and2 = par_kind == TOK_AND
        val match_and = is_and or is_and2
        if not match_and:
            break
        parser_advance()
        val right = parse_not()
        left = expr_binary(TOK_AND, left, right, 0)
    left

fn parse_not() -> i64:
    val is_not = par_kind == TOK_KW_NOT
    val is_not2 = par_kind == TOK_NOT
    val match_not = is_not or is_not2
    if match_not:
        parser_advance()
        val operand = parse_not()
        return expr_unary(TOK_NOT, operand, 0)
    parse_comparison()

fn parse_comparison() -> i64:
    var left = parse_null_coalesce()
    for i in 0..100:
        if par_kind == TOK_EQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_EQ, left, right, 0)
        elif par_kind == TOK_NEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_NEQ, left, right, 0)
        elif par_kind == TOK_LT:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_LT, left, right, 0)
        elif par_kind == TOK_GT:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_GT, left, right, 0)
        elif par_kind == TOK_LEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_LEQ, left, right, 0)
        elif par_kind == TOK_GEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_GEQ, left, right, 0)
        else:
            break
    left

fn parse_null_coalesce() -> i64:
    var left = parse_range()
    for i in 0..100:
        if par_kind == TOK_DOUBLE_QUESTION:
            parser_advance()
            val right = parse_range()
            left = expr_null_coalesce(left, right, 0)
        else:
            break
    left

fn parse_range() -> i64:
    val left = parse_addition()
    if par_kind == TOK_DOTDOT:
        parser_advance()
        val right = parse_addition()
        return expr_range(left, right, 0, 0)
    if par_kind == TOK_DOTDOT_EQ:
        parser_advance()
        val right = parse_addition()
        return expr_range(left, right, 1, 0)
    left

fn parse_addition() -> i64:
    var left = parse_multiplication()
    for i in 0..1000:
        if par_kind == TOK_PLUS:
            parser_advance()
            val right = parse_multiplication()
            left = expr_binary(TOK_PLUS, left, right, 0)
        elif par_kind == TOK_MINUS:
            parser_advance()
            val right = parse_multiplication()
            left = expr_binary(TOK_MINUS, left, right, 0)
        else:
            break
    left

fn parse_multiplication() -> i64:
    var left = parse_unary()
    for i in 0..1000:
        if par_kind == TOK_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_STAR, left, right, 0)
        elif par_kind == TOK_SLASH:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_SLASH, left, right, 0)
        elif par_kind == TOK_PERCENT:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_PERCENT, left, right, 0)
        elif par_kind == TOK_DOUBLE_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_DOUBLE_STAR, left, right, 0)
        else:
            break
    left

fn parse_unary() -> i64:
    if par_kind == TOK_MINUS:
        parser_advance()
        val operand = parse_unary()
        return expr_unary(TOK_MINUS, operand, 0)
    if par_kind == TOK_KW_NOT:
        parser_advance()
        val operand = parse_unary()
        return expr_unary(TOK_NOT, operand, 0)
    parse_postfix()

fn parse_binary_from(base: i64) -> i64:
    # Continue binary expression parsing from an already-parsed base.
    # Used by parse_call_arg when ident is already consumed.
    # Handles: *, /, %, **, +, -, .., ..=, ??, comparisons, and, or
    var left = base
    # Multiplication level
    for i in 0..1000:
        if par_kind == TOK_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_STAR, left, right, 0)
        elif par_kind == TOK_SLASH:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_SLASH, left, right, 0)
        elif par_kind == TOK_PERCENT:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_PERCENT, left, right, 0)
        elif par_kind == TOK_DOUBLE_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_DOUBLE_STAR, left, right, 0)
        elif par_kind == TOK_PIPE:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_PIPE, left, right, 0)
        else:
            break
    # Addition level
    var add_left = left
    for i in 0..1000:
        if par_kind == TOK_PLUS:
            parser_advance()
            val right = parse_multiplication()
            add_left = expr_binary(TOK_PLUS, add_left, right, 0)
        elif par_kind == TOK_MINUS:
            parser_advance()
            val right = parse_multiplication()
            add_left = expr_binary(TOK_MINUS, add_left, right, 0)
        else:
            break
    left = add_left
    # Range
    if par_kind == TOK_DOTDOT:
        parser_advance()
        val right = parse_addition()
        left = expr_range(left, right, 0, 0)
    if par_kind == TOK_DOTDOT_EQ:
        parser_advance()
        val right = parse_addition()
        left = expr_range(left, right, 1, 0)
    # Null coalesce
    for i in 0..100:
        if par_kind == TOK_DOUBLE_QUESTION:
            parser_advance()
            val right = parse_range()
            left = expr_null_coalesce(left, right, 0)
        else:
            break
    # Comparisons
    for i in 0..100:
        if par_kind == TOK_EQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_EQ, left, right, 0)
        elif par_kind == TOK_NEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_NEQ, left, right, 0)
        elif par_kind == TOK_LT:
            parser_advance()
            if par_kind == TOK_LT:
                parser_advance()
                val lshift_right = parse_null_coalesce()
                left = expr_binary(TOK_LT, left, lshift_right, 0)
            else:
                val right = parse_null_coalesce()
                left = expr_binary(TOK_LT, left, right, 0)
        elif par_kind == TOK_GT:
            parser_advance()
            if par_kind == TOK_GT:
                parser_advance()
                val rshift_right = parse_null_coalesce()
                left = expr_binary(TOK_GT, left, rshift_right, 0)
            else:
                val right = parse_null_coalesce()
                left = expr_binary(TOK_GT, left, right, 0)
        elif par_kind == TOK_LEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_LEQ, left, right, 0)
        elif par_kind == TOK_GEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_GEQ, left, right, 0)
        elif par_kind == TOK_KW_IN:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_method_call(right, "contains", [], 0)
        elif par_kind == TOK_KW_IS:
            parser_advance()
            val cast_type = parser_parse_type()
            val dummy_bf = cast_type
        else:
            break
    # And
    for i in 0..1000:
        val is_and = par_kind == TOK_KW_AND
        val is_and2 = par_kind == TOK_AND
        val match_and = is_and or is_and2
        if not match_and:
            break
        parser_advance()
        val right = parse_not()
        left = expr_binary(TOK_AND, left, right, 0)
    # Or
    for i in 0..1000:
        val is_or = par_kind == TOK_KW_OR
        val is_or2 = par_kind == TOK_OR
        val match_or = is_or or is_or2
        if not match_or:
            break
        parser_advance()
        val right = parse_and()
        left = expr_binary(TOK_OR, left, right, 0)
    left

fn parse_call_arg() -> i64:
    # Check for bool-suffixed identifiers: true_abs, false_mut
    if par_kind == TOK_IDENT:
        val ident = par_text
        val ident_len = ident.len()
        if ident_len > 5:
            val prefix5 = ident[0:5]
            if prefix5 == "true_":
                val suffix = ident[5:]
                parser_advance()
                return expr_suffixed_bool(1, suffix, 0)
        if ident_len > 6:
            val prefix6 = ident[0:6]
            if prefix6 == "false_":
                val suffix = ident[6:]
                parser_advance()
                return expr_suffixed_bool(0, suffix, 0)
        # Named argument: ident COLON expr -> strip name, return value
        parser_advance()
        if par_kind == TOK_COLON:
            parser_advance()
            return parse_expr()
        # Not a named arg: already consumed ident, continue with postfix+binary
        val ident_node = expr_ident(ident, 0)
        val postfix_result = parse_postfix_on(ident_node)
        return parse_binary_from(postfix_result)
    parse_expr()

fn parse_postfix_on(base_expr: i64) -> i64:
    # Continue postfix parsing from an already-parsed base expression
    var base = base_expr
    for i in 0..1000:
        if par_kind == TOK_DOT:
            parser_advance()
            val field_name = par_text
            if par_kind != TOK_IDENT:
                parser_error("expected field name after '.'")
                break
            parser_advance()
            if par_kind == TOK_LPAREN:
                parser_advance()
                var call_args: [i64] = []
                if par_kind != TOK_RPAREN:
                    call_args.push(parse_call_arg())
                    for j in 0..100:
                        if par_kind != TOK_COMMA:
                            break
                        parser_advance()
                        call_args.push(parse_call_arg())
                parser_expect(TOK_RPAREN)
                base = expr_method_call(base, field_name, call_args, 0)
            else:
                base = expr_field_access(base, field_name, 0)
        elif par_kind == TOK_LBRACKET:
            parser_advance()
            if par_kind == TOK_COLON:
                parser_advance()
                val end_idx = parse_expr()
                parser_expect(TOK_RBRACKET)
                val zero = expr_int_lit(0, 0)
                base = expr_slice(base, zero, end_idx, 0)
            else:
                val index_expr = parse_expr()
                if par_kind == TOK_COLON:
                    parser_advance()
                    if par_kind == TOK_RBRACKET:
                        parser_advance()
                        val neg1 = expr_int_lit(-1, 0)
                        base = expr_slice(base, index_expr, neg1, 0)
                    else:
                        val end_idx = parse_expr()
                        parser_expect(TOK_RBRACKET)
                        base = expr_slice(base, index_expr, end_idx, 0)
                else:
                    parser_expect(TOK_RBRACKET)
                    base = expr_index(base, index_expr, 0)
        elif par_kind == TOK_LPAREN:
            parser_advance()
            var call_args: [i64] = []
            if par_kind != TOK_RPAREN:
                call_args.push(parse_call_arg())
                for j in 0..100:
                    if par_kind != TOK_COMMA:
                        break
                    parser_advance()
                    call_args.push(parse_call_arg())
            parser_expect(TOK_RPAREN)
            base = expr_call(base, call_args, 0)
        elif par_kind == TOK_QUESTION_DOT:
            parser_advance()
            val field_name = par_text
            parser_expect(TOK_IDENT)
            base = expr_field_access(base, field_name, 0)
        else:
            break
    # Continue with assignment operators
    if par_kind == TOK_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_assign(base, right, 0)
    if par_kind == TOK_PLUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_PLUS, base, right, 0)
    if par_kind == TOK_MINUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_MINUS, base, right, 0)
    base

fn parse_postfix() -> i64:
    var base = parse_primary()
    for i in 0..1000:
        if par_kind == TOK_DOT:
            parser_advance()
            val field_name = par_text
            if par_kind != TOK_IDENT:
                parser_error("expected field name after '.'")
                break
            parser_advance()
            # Check for method call: obj.method(args)
            if par_kind == TOK_LPAREN:
                parser_advance()
                var call_args: [i64] = []
                if par_kind != TOK_RPAREN:
                    call_args.push(parse_call_arg())
                    for j in 0..100:
                        if par_kind != TOK_COMMA:
                            break
                        parser_advance()
                        call_args.push(parse_call_arg())
                parser_expect(TOK_RPAREN)
                base = expr_method_call(base, field_name, call_args, 0)
            else:
                base = expr_field_access(base, field_name, 0)
        elif par_kind == TOK_LBRACKET:
            parser_advance()
            # Check for slice: a[start:end]
            if par_kind == TOK_COLON:
                parser_advance()
                val end_idx = parse_expr()
                parser_expect(TOK_RBRACKET)
                val zero = expr_int_lit(0, 0)
                base = expr_slice(base, zero, end_idx, 0)
            else:
                val index_expr = parse_expr()
                if par_kind == TOK_COLON:
                    # Slice: a[start:end]
                    parser_advance()
                    if par_kind == TOK_RBRACKET:
                        # a[start:] — open-ended
                        parser_advance()
                        val neg1 = expr_int_lit(-1, 0)
                        base = expr_slice(base, index_expr, neg1, 0)
                    else:
                        val end_idx = parse_expr()
                        parser_expect(TOK_RBRACKET)
                        base = expr_slice(base, index_expr, end_idx, 0)
                else:
                    parser_expect(TOK_RBRACKET)
                    base = expr_index(base, index_expr, 0)
        elif par_kind == TOK_LPAREN:
            # Function call: f(args)
            parser_advance()
            var call_args: [i64] = []
            if par_kind != TOK_RPAREN:
                call_args.push(parse_call_arg())
                for j in 0..100:
                    if par_kind != TOK_COMMA:
                        break
                    parser_advance()
                    call_args.push(parse_call_arg())
            parser_expect(TOK_RPAREN)
            base = expr_call(base, call_args, 0)
        elif par_kind == TOK_QUESTION_DOT:
            # Optional chaining: x?.field
            parser_advance()
            val field_name = par_text
            parser_expect(TOK_IDENT)
            base = expr_field_access(base, field_name, 0)
        else:
            break
    base

fn parse_primary() -> i64:
    if par_kind == TOK_INT_LIT:
        val int_text = par_text
        parser_advance()
        # Parse integer from text
        var int_val = 0
        if int_text.len() > 2:
            val prefix = int_text[0:2]
            if prefix == "0x":
                # Hex — for bootstrap, just store as 0 (C codegen will handle)
                return expr_int_lit(0, 0)
            if prefix == "0b":
                return expr_int_lit(0, 0)
            if prefix == "0o":
                return expr_int_lit(0, 0)
        # Decimal
        int_val = int(int_text)
        return expr_int_lit(int_val, 0)

    if par_kind == TOK_FLOAT_LIT:
        val float_text = par_text
        parser_advance()
        return expr_float_lit(float_text, 0)

    if par_kind == TOK_SUFFIXED_INT:
        val suf_text = par_text
        val suf_name = lex_cur_suffix
        parser_advance()
        val int_val = int(suf_text)
        return expr_suffixed_int(int_val, suf_name, 0)

    if par_kind == TOK_SUFFIXED_FLOAT:
        val suf_text = par_text
        val suf_name = lex_cur_suffix
        parser_advance()
        return expr_suffixed_float(suf_text, suf_name, 0)

    if par_kind == TOK_STRING_LIT:
        val str_text = par_text
        parser_advance()
        return expr_string_lit(str_text, 0)

    if par_kind == TOK_BOOL_LIT:
        val bool_text = par_text
        parser_advance()
        if bool_text == "true":
            return expr_bool_lit(1, 0)
        return expr_bool_lit(0, 0)

    if par_kind == TOK_NIL_LIT:
        parser_advance()
        return expr_nil_lit(0)

    if par_kind == TOK_IDENT:
        val id_name = par_text
        parser_advance()
        return expr_ident(id_name, 0)

    if par_kind == TOK_KW_SELF:
        parser_advance()
        return expr_ident("self", 0)

    if par_kind == TOK_KW_AWAIT:
        parser_advance()
        val future_expr = parse_expr()
        return expr_await(future_expr, 0)

    if par_kind == TOK_KW_YIELD:
        parser_advance()
        val value_expr = parse_expr()
        return expr_yield(value_expr, 0)

    if par_kind == TOK_KW_SPAWN:
        parser_advance()
        val call_expr = parse_expr()
        return expr_spawn(call_expr, 0)

    if par_kind == TOK_LPAREN:
        parser_advance()
        if par_kind == TOK_RPAREN:
            parser_advance()
            return expr_unit(0)
        val inner = parse_expr()
        parser_expect(TOK_RPAREN)
        return inner

    if par_kind == TOK_LBRACKET:
        # Array literal: [1, 2, 3]
        parser_advance()
        var elements: [i64] = []
        if par_kind != TOK_RBRACKET:
            elements.push(parse_expr())
            for i in 0..10000:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                if par_kind == TOK_RBRACKET:
                    break
                elements.push(parse_expr())
        parser_expect(TOK_RBRACKET)
        return expr_array_lit(elements, 0)

    if par_kind == TOK_KW_RETURN:
        parser_advance()
        val is_nl = par_kind == TOK_NEWLINE
        val is_ded = par_kind == TOK_DEDENT
        val is_eof = par_kind == TOK_EOF
        val no_value = is_nl or is_ded
        val no_val2 = no_value or is_eof
        if no_val2:
            return expr_return_expr(-1, 0)
        val ret_val = parse_expr()
        return expr_return_expr(ret_val, 0)

    if par_kind == TOK_KW_BREAK:
        parser_advance()
        return expr_break_expr(0)

    if par_kind == TOK_KW_CONTINUE:
        parser_advance()
        return expr_continue_expr(0)

    if par_kind == TOK_KW_PASS:
        parser_advance()
        return expr_pass(0)

    if par_kind == TOK_KW_NOT:
        parser_advance()
        val operand = parse_not()
        return expr_unary(TOK_NOT, operand, 0)

    if par_kind == TOK_MINUS:
        parser_advance()
        val operand = parse_unary()
        return expr_unary(TOK_MINUS, operand, 0)

    if par_kind == TOK_UNDERSCORE:
        parser_advance()
        return expr_ident("_", 0)

    # Dict literal: {key: value, ...} or empty {}
    if par_kind == TOK_LBRACE:
        parser_advance()
        var key_exprs: [i64] = []
        var value_exprs: [i64] = []

        # Check for empty dict {}
        if par_kind == TOK_RBRACE:
            parser_advance()
            return expr_dict_lit(key_exprs, value_exprs, 0)

        # Parse key-value pairs
        for i in 0..10000:
            # Parse key
            val key = parse_expr()
            key_exprs.push(key)

            # Expect colon
            parser_expect(TOK_COLON)

            # Parse value
            val value = parse_expr()
            value_exprs.push(value)

            # Check for comma or closing brace
            if par_kind == TOK_COMMA:
                parser_advance()
                # Allow trailing comma before }
                if par_kind == TOK_RBRACE:
                    parser_advance()
                    break
            elif par_kind == TOK_RBRACE:
                parser_advance()
                break
            else:
                parser_error("expected , or } in dict literal")
                break

        return expr_dict_lit(key_exprs, value_exprs, 0)

    # Lambda: \x: expr or \x, y: expr
    if par_kind == TOK_ERROR:
        if par_text == "unexpected character: \\":
            parser_advance()
            # Skip lambda params
            for i in 0..100:
                if par_kind == TOK_COLON:
                    parser_advance()
                    break
                if par_kind == TOK_EOF:
                    break
                if par_kind == TOK_NEWLINE:
                    break
                parser_advance()
            val lbody = parse_expr()
            return lbody

    # Handle keywords that may appear in expression position
    if par_kind == TOK_KW_MATCH:
        return parse_match_stmt()
    if par_kind == TOK_KW_IF:
        return parse_if_expr()

    parser_error("unexpected token in expression: " + tok_kind_name(par_kind) + " '" + par_text + "'")
    parser_advance()
    expr_nil_lit(0)

# ===== Statement Parsing =====

fn parse_block() -> [i64]:
    var stmts: [i64] = []
    parser_skip_newlines()
    if par_kind == TOK_INDENT:
        # Multi-line indented block
        parser_advance()
        for i in 0..100000:
            parser_skip_newlines()
            if par_kind == TOK_DEDENT:
                parser_advance()
                break
            if par_kind == TOK_EOF:
                break
            val s = parse_statement()
            stmts.push(s)
            parser_skip_newlines_and_semicolons()
        return stmts
    # Single-line body (no indent): parse one statement
    val s = parse_statement()
    stmts.push(s)
    stmts

fn parse_statement() -> i64:
    if par_kind == TOK_KW_VAL:
        return parse_val_decl_stmt()

    if par_kind == TOK_KW_VAR:
        return parse_var_decl_stmt()

    if par_kind == TOK_KW_RETURN:
        parser_advance()
        val is_nl = par_kind == TOK_NEWLINE
        val is_ded = par_kind == TOK_DEDENT
        val no_value = is_nl or is_ded
        if no_value:
            return stmt_return_stmt(-1, 0)
        val ret_val = parse_expr()
        return stmt_return_stmt(ret_val, 0)

    if par_kind == TOK_KW_IF:
        return parse_if_stmt()

    if par_kind == TOK_KW_FOR:
        return parse_for_stmt()

    if par_kind == TOK_KW_WHILE:
        return parse_while_stmt()

    if par_kind == TOK_KW_MATCH:
        return parse_match_stmt()

    if par_kind == TOK_KW_BREAK:
        parser_advance()
        return stmt_break_stmt(0)

    if par_kind == TOK_KW_CONTINUE:
        parser_advance()
        return stmt_continue_stmt(0)

    if par_kind == TOK_KW_PASS:
        parser_advance()
        return stmt_expr_stmt(expr_pass(0), 0)

    # Handle bare 'print' keyword (print expr — no parens)
    if par_kind == TOK_IDENT:
        if par_text == "print":
            parser_advance()
            val is_nl = par_kind == TOK_NEWLINE
            val is_ded = par_kind == TOK_DEDENT
            val is_eof = par_kind == TOK_EOF
            val no_arg = is_nl or is_ded
            val no_arg2 = no_arg or is_eof
            if no_arg2:
                val callee0 = expr_ident("print", 0)
                var args0: [i64] = []
                val call0 = expr_call(callee0, args0, 0)
                return stmt_expr_stmt(call0, 0)
            val print_arg = parse_expr()
            val callee1 = expr_ident("print", 0)
            var args1: [i64] = []
            args1.push(print_arg)
            val call1 = expr_call(callee1, args1, 0)
            return stmt_expr_stmt(call1, 0)

    # Expression statement (including assignment)
    val expression = parse_expr()
    stmt_expr_stmt(expression, 0)

fn parse_val_decl_stmt() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    # Optional type annotation: val x: i64 = ...
    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    stmt_val_decl(name, type_tag, init, 0)

fn parse_var_decl_stmt() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    stmt_var_decl(name, type_tag, init, 0)

fn parse_if_stmt() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val then_body = parse_block()

    # Handle elif/else
    parser_skip_newlines()
    var else_body: [i64] = []

    if par_kind == TOK_KW_ELIF:
        # Elif is parsed as nested if in else
        val nested_if = parse_if_stmt()
        else_body.push(nested_if)
    elif par_kind == TOK_KW_ELSE:
        parser_advance()
        parser_expect(TOK_COLON)
        else_body = parse_block()

    # Store elif chain using elif arena
    val elif_idx = elif_new(cond, then_body, else_body)
    stmt_if_stmt(cond, then_body, elif_idx, 0)

fn parse_for_stmt() -> i64:
    parser_advance()
    val iter_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_KW_IN)
    val iterable = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    stmt_for_stmt(iter_name, iterable, body, 0)

fn parse_while_stmt() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    stmt_while_stmt(cond, body, 0)

fn parse_match_stmt() -> i64:
    parser_advance()
    val scrutinee = parse_expr()
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var arm_indices: [i64] = []
    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        if par_kind == TOK_KW_CASE:
            parser_advance()

            # Support multi-pattern: case X | Y | Z:
            # Parse first pattern
            var patterns: [i64] = []
            patterns.push(parse_expr())

            # Check for pipe separator and collect additional patterns
            # Support multi-line patterns by skipping newlines/indents before pipes
            for skip_idx in 0..100:
                val is_nl = par_kind == TOK_NEWLINE
                val is_indent = par_kind == TOK_INDENT
                val should_skip = is_nl or is_indent
                if not should_skip:
                    break
                parser_advance()

            while par_kind == TOK_PIPE:
                parser_advance()
                # Skip newlines/indents after pipe
                for skip_idx in 0..100:
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_indent = par_kind == TOK_INDENT
                    val should_skip = is_nl or is_indent
                    if not should_skip:
                        break
                    parser_advance()
                patterns.push(parse_expr())
                # Skip newlines/indents after pattern
                for skip_idx in 0..100:
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_indent = par_kind == TOK_INDENT
                    val should_skip = is_nl or is_indent
                    if not should_skip:
                        break
                    parser_advance()

            # Expect colon after all patterns
            parser_expect(TOK_COLON)
            val arm_body = parse_block()

            # Create an arm for each pattern (they share the same body)
            for i in 0..patterns.len():
                val pattern_idx = patterns[i]
                val arm_idx = arm_new(pattern_idx, -1, arm_body)
                arm_indices.push(arm_idx)
        else:
            parser_error("expected 'case' in match block")
            parser_advance()

    stmt_match_stmt(scrutinee, arm_indices, 0)

# ===== Declaration Parsing =====

fn parser_expect_param_name():
    # Accept IDENT or SELF as parameter name
    val is_ident: bool = par_kind == TOK_IDENT
    val is_self: bool = par_kind == TOK_KW_SELF
    val is_valid: bool = is_ident or is_self
    if is_valid:
        parser_advance()
    else:
        parser_error("expected parameter name")
        parser_advance()

fn parse_fn_decl(is_async: i64) -> i64:
    parser_advance()
    val fn_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        # First parameter
        val pname = par_text
        parser_expect_param_name()
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            if par_kind == TOK_RPAREN:
                break
            val pn = par_text
            parser_expect_param_name()
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    # Return type
    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type()

    # Function body
    parser_expect(TOK_COLON)
    val body = parse_block()

    decl_fn(fn_name, param_names, param_types, ret_type, body, is_async, 0)

fn parse_extern_fn_decl() -> i64:
    # Already consumed 'extern'
    parser_expect(TOK_KW_FN)
    val fn_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        val pname = par_text
        parser_expect_param_name()
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            if par_kind == TOK_RPAREN:
                break
            val pn = par_text
            parser_expect_param_name()
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type()

    decl_extern_fn(fn_name, param_names, param_types, ret_type, 0)

fn parse_struct_decl() -> i64:
    parser_advance()
    val struct_name = par_text
    parser_expect(TOK_IDENT)
    par_struct_names.push(struct_name)
    # Pre-register struct name so type references resolve during parsing
    named_type_register(struct_name, [], [])
    # Handle struct inheritance: struct X(Parent):
    if par_kind == TOK_LPAREN:
        parser_advance()
        # Skip parent type name(s)
        for i in 0..10:
            if par_kind == TOK_RPAREN:
                break
            parser_advance()
        parser_expect(TOK_RPAREN)
    # Handle "with" mixin: struct X with Y:
    if par_kind == TOK_IDENT:
        if par_text == "with":
            parser_advance()
            parser_expect(TOK_IDENT)
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var field_names: [text] = []
    var field_types: [i64] = []
    var class_method_ids: [i64] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in class/struct body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue

        # Handle methods in class/struct body
        if par_kind == TOK_KW_STATIC:
            val sm_id = parse_class_body_method(struct_name, true, false)
            if sm_id >= 0:
                class_method_ids.push(sm_id)
            continue
        if par_kind == TOK_KW_FN:
            val fm_id = parse_class_body_method(struct_name, false, false)
            if fm_id >= 0:
                class_method_ids.push(fm_id)
            continue
        if par_kind == TOK_KW_ME:
            val mm_id = parse_class_body_method(struct_name, false, true)
            if mm_id >= 0:
                class_method_ids.push(mm_id)
            continue

        val fname = par_text
        parser_expect(TOK_IDENT)
        parser_expect(TOK_COLON)
        val ftype = parser_parse_type()
        field_names.push(fname)
        field_types.push(ftype)
        parser_skip_newlines_and_semicolons()

    val struct_d = decl_struct_def(struct_name, field_names, field_types, 0)

    # If class had methods, create an impl block for them
    if class_method_ids.len() > 0:
        val impl_d = decl_impl_block(struct_name, class_method_ids, 0)
        module_add_decl(impl_d)

    struct_d

fn parse_enum_decl() -> i64:
    parser_advance()
    val enum_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var variant_names: [text] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in enum body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue

        # Skip comments that may appear as idents
        val vname = par_text
        parser_expect(TOK_IDENT)
        # Handle enum variant data: Variant(field: type, ...)
        if par_kind == TOK_LPAREN:
            parser_advance()
            for j in 0..100:
                if par_kind == TOK_RPAREN:
                    break
                if par_kind == TOK_EOF:
                    break
                # Skip field_name: type pairs
                if par_kind == TOK_IDENT:
                    parser_advance()
                    if par_kind == TOK_COLON:
                        parser_advance()
                        parser_parse_type()
                        # Handle optional ? after type
                        if par_kind == TOK_QUESTION:
                            parser_advance()
                elif par_kind == TOK_LBRACKET:
                    parser_parse_type()
                else:
                    parser_advance()
                if par_kind == TOK_COMMA:
                    parser_advance()
            parser_expect(TOK_RPAREN)
        variant_names.push(vname)
        parser_skip_newlines_and_semicolons()

    decl_enum_def(enum_name, variant_names, 0)

fn parse_use_decl() -> i64:
    parser_advance()
    # Handle relative imports: use .X or use ..X
    var module_path: text = ""
    if par_kind == TOK_DOTDOT:
        parser_advance()
        module_path = ".."
        if par_kind == TOK_DOT:
            parser_advance()
            module_path = "..."
    elif par_kind == TOK_DOT:
        parser_advance()
        module_path = "."

    # Parse module path: a.b.c
    if par_kind == TOK_IDENT:
        if module_path != "":
            module_path = module_path + par_text
        else:
            module_path = par_text
        parser_advance()
    for i in 0..100:
        if par_kind != TOK_DOT:
            break
        parser_advance()
        # Check for {name1, name2} import list
        if par_kind == TOK_LBRACE:
            break
        if par_kind == TOK_LPAREN:
            break
        # Wildcard import: use X.*
        if par_kind == TOK_STAR:
            parser_advance()
            return decl_use_import(module_path, [], 0)
        module_path = module_path + "." + par_text
        parser_expect(TOK_IDENT)
        # Check for trailing * without dot: use ffi.io*
        if par_kind == TOK_STAR:
            parser_advance()
            return decl_use_import(module_path, [], 0)

    # Optional import list: .{name1, name2} or .(name1, name2)
    var imported_names: [text] = []
    val has_brace: bool = par_kind == TOK_LBRACE
    val has_paren: bool = par_kind == TOK_LPAREN
    val has_import_list: bool = has_brace or has_paren
    if has_import_list:
        parser_advance()
        for i in 0..100:
            val at_c1: bool = par_kind == TOK_RBRACE
            val at_c2: bool = par_kind == TOK_RPAREN
            val at_c: bool = at_c1 or at_c2
            if at_c:
                break
            if par_kind == TOK_EOF:
                break
            if par_kind == TOK_IDENT:
                imported_names.push(par_text)
                parser_advance()
            if par_kind == TOK_COMMA:
                parser_advance()
        # Consume closing ) or }
        val is_rb: bool = par_kind == TOK_RBRACE
        val is_rp: bool = par_kind == TOK_RPAREN
        val is_close: bool = is_rb or is_rp
        if is_close:
            parser_advance()

    decl_use_import(module_path, imported_names, 0)

fn parse_export_decl() -> i64:
    parser_advance()
    var names: [text] = []
    names.push(par_text)
    parser_expect(TOK_IDENT)
    for i in 0..100:
        if par_kind != TOK_COMMA:
            break
        parser_advance()
        names.push(par_text)
        parser_expect(TOK_IDENT)
    decl_export_names(names, 0)

fn parse_val_decl() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    decl_val_binding(name, type_tag, init, 0)

fn parse_var_decl() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    decl_var_binding(name, type_tag, init, 0)

# ===== Expression-Level Control Flow (for module-level statements) =====

fn parse_if_expr() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val then_body = parse_block()
    val then_expr = expr_block(then_body, -1, 0)
    parser_skip_newlines()
    var else_expr: i64 = expr_unit(0)
    if par_kind == TOK_KW_ELIF:
        else_expr = parse_if_expr()
    elif par_kind == TOK_KW_ELSE:
        parser_advance()
        parser_expect(TOK_COLON)
        val else_body = parse_block()
        else_expr = expr_block(else_body, -1, 0)
    expr_if_expr(cond, then_expr, else_expr, 0)

fn parse_for_expr() -> i64:
    parser_advance()
    val iter_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_KW_IN)
    val iterable = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    expr_for_expr(iter_name, iterable, body, 0)

fn parse_while_expr() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    expr_while_expr(cond, body, 0)

# ===== Class/Impl Method Parsing =====

fn parse_class_body_method(struct_name: text, is_static: bool, is_me: bool) -> i64:
    # Advance past leading keyword (static fn / fn / me)
    if is_static:
        if par_kind == TOK_KW_STATIC:
            parser_advance()
        if par_kind == TOK_KW_FN:
            parser_advance()
    elif is_me:
        parser_advance()
    else:
        if par_kind == TOK_KW_FN:
            parser_advance()

    val method_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        val pname = par_text
        parser_expect(TOK_IDENT)
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            val pn = par_text
            parser_expect(TOK_IDENT)
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type()

    parser_expect(TOK_COLON)
    val body = parse_block()

    val mangled_name: text = struct_name + "__" + method_name
    # static_flag: 0=fn (immutable self), 1=static (no self), 2=me (mutable self)
    var static_flag: i64 = 0
    if is_static:
        static_flag = 1
    if is_me:
        static_flag = 2
    val mid = decl_fn(mangled_name, param_names, param_types, ret_type, body, static_flag, 0)
    return mid

fn parse_impl_decl() -> i64:
    # impl StructName:
    parser_advance()
    val target_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var method_ids: [i64] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in impl body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue
        if par_kind == TOK_KW_STATIC:
            val sm_id = parse_class_body_method(target_name, true, false)
            if sm_id >= 0:
                method_ids.push(sm_id)
        elif par_kind == TOK_KW_FN:
            val fm_id = parse_class_body_method(target_name, false, false)
            if fm_id >= 0:
                method_ids.push(fm_id)
        elif par_kind == TOK_KW_ME:
            val mm_id = parse_class_body_method(target_name, false, true)
            if mm_id >= 0:
                method_ids.push(mm_id)
        else:
            # Skip unknown tokens in impl body gracefully
            parser_advance()

    decl_impl_block(target_name, method_ids, 0)

# ===== Top-Level Module Parsing =====

fn parse_module_body():
    for i in 0..100000:
        parser_skip_newlines_and_semicolons()
        if par_kind == TOK_EOF:
            break
        if par_kind == TOK_DEDENT:
            # Stray dedent at module level — skip it
            parser_advance()
        elif par_kind == TOK_KW_ASYNC:
            # Async function: async fn name()
            parser_advance()
            if par_kind == TOK_KW_FN:
                val d = parse_fn_decl(1)  # 1 = is_async
                module_add_decl(d)
            else:
                parser_error("expected 'fn' after 'async'")
        elif par_kind == TOK_KW_FN:
            val d = parse_fn_decl(0)  # 0 = not async
            module_add_decl(d)
        elif par_kind == TOK_KW_EXTERN:
            parser_advance()
            val d = parse_extern_fn_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_STRUCT:
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_ENUM:
            val d = parse_enum_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_CLASS:
            # class is treated like struct (fields + methods)
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_IMPL:
            val d = parse_impl_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_USE:
            val d = parse_use_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_EXPORT:
            val d = parse_export_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_VAL:
            val d = parse_val_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_VAR:
            val d = parse_var_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_IF:
            val if_expr = parse_if_expr()
            val d = decl_val_binding("_if_" + int_to_str(i), -1, if_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_FOR:
            val for_expr = parse_for_expr()
            val d = decl_val_binding("_for_" + int_to_str(i), -1, for_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_WHILE:
            val while_expr = parse_while_expr()
            val d = decl_val_binding("_while_" + int_to_str(i), -1, while_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_IMPORT:
            # import X.{Y, Z} — treat like use
            val d = parse_use_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_TRAIT:
            # trait is parsed like struct (skip body)
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_STRING_LIT:
            # Skip module-level docstrings
            parser_advance()
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_KW_TYPE:
            # Type alias: type X = Y — skip it
            parser_advance()
            # Skip until newline
            for j in 0..1000:
                val type_is_nl: bool = par_kind == TOK_NEWLINE
                val type_is_ded: bool = par_kind == TOK_DEDENT
                val type_is_eof: bool = par_kind == TOK_EOF
                val type_done: bool = type_is_nl or type_is_ded
                val type_done2: bool = type_done or type_is_eof
                if type_done2:
                    break
                parser_advance()
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_KW_ASM:
            # asm block — skip it
            parser_advance()
            # Skip the asm block (usually triple-quoted string + body)
            for j in 0..10000:
                val asm_is_nl: bool = par_kind == TOK_NEWLINE
                val asm_is_ded: bool = par_kind == TOK_DEDENT
                val asm_is_eof: bool = par_kind == TOK_EOF
                val asm_done: bool = asm_is_nl or asm_is_ded
                val asm_done2: bool = asm_done or asm_is_eof
                if asm_done2:
                    break
                parser_advance()
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_INDENT:
            # Stray indent at module level — skip it
            parser_advance()
        else:
            # Handle bare 'print' and 'from' at module level
            if par_kind == TOK_IDENT:
                if par_text == "from":
                    # from X import {Y, Z}
                    parser_advance()
                    var from_path: text = ""
                    if par_kind == TOK_IDENT:
                        from_path = par_text
                        parser_advance()
                    for j in 0..100:
                        if par_kind != TOK_DOT:
                            break
                        parser_advance()
                        if par_kind == TOK_IDENT:
                            from_path = from_path + "." + par_text
                            parser_advance()
                        else:
                            break
                    # Expect 'import' keyword
                    if par_kind == TOK_KW_IMPORT:
                        parser_advance()
                    # Parse import list {name1, name2}
                    var from_names: [text] = []
                    val from_has_brace: bool = par_kind == TOK_LBRACE
                    val from_has_paren: bool = par_kind == TOK_LPAREN
                    val from_has_list: bool = from_has_brace or from_has_paren
                    if from_has_list:
                        parser_advance()
                        for j in 0..100:
                            val from_at_end1: bool = par_kind == TOK_RBRACE
                            val from_at_end2: bool = par_kind == TOK_RPAREN
                            val from_at_end: bool = from_at_end1 or from_at_end2
                            if from_at_end:
                                break
                            if par_kind == TOK_EOF:
                                break
                            if par_kind == TOK_IDENT:
                                from_names.push(par_text)
                                parser_advance()
                            if par_kind == TOK_COMMA:
                                parser_advance()
                        parser_advance()
                    val fd = decl_use_import(from_path, from_names, 0)
                    module_add_decl(fd)
                    parser_skip_newlines_and_semicolons()
                elif par_text == "print":
                    parser_advance()
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_ded = par_kind == TOK_DEDENT
                    val is_eof = par_kind == TOK_EOF
                    val no_arg = is_nl or is_ded
                    val no_arg2 = no_arg or is_eof
                    var print_call: i64 = 0
                    if no_arg2:
                        val callee0 = expr_ident("print", 0)
                        var args0: [i64] = []
                        print_call = expr_call(callee0, args0, 0)
                    else:
                        val print_arg = parse_expr()
                        val callee1 = expr_ident("print", 0)
                        var args1: [i64] = []
                        args1.push(print_arg)
                        print_call = expr_call(callee1, args1, 0)
                    val d = decl_val_binding("_expr_" + int_to_str(i), -1, print_call, 0)
                    module_add_decl(d)
                    parser_skip_newlines_and_semicolons()
                else:
                    val expression = parse_expr()
                    val d = decl_val_binding("_expr_" + int_to_str(i), -1, expression, 0)
                    module_add_decl(d)
                    parser_skip_newlines_and_semicolons()
            else:
                # Module-level expression/statement
                val expression = parse_expr()
                val d = decl_val_binding("_expr_" + int_to_str(i), -1, expression, 0)
                module_add_decl(d)
                parser_skip_newlines_and_semicolons()

fn parse_module(source: text, path: text):
    parser_init(source)
    module_set_path(path)
    parse_module_body()

fn parse_module_file(source: text, path: text):
    # Parse additional file without resetting AST
    lex_init(source)
    par_errors = []
    par_had_error = false
    parser_advance()
    module_set_path(path)
    parse_module_body()

fn parser_has_errors() -> bool:
    par_had_error

fn parser_get_errors() -> [text]:
    par_errors

fn parser_error_count() -> i64:
    par_errors.len()

# ===== Exports =====

export parser_init, parser_advance, parser_check, parser_match_tok, parser_expect
export parser_error, parser_skip_newlines, parser_skip_newlines_and_semicolons
export parser_parse_type
export parse_expr, parse_assignment, parse_or, parse_and, parse_not
export parse_comparison, parse_null_coalesce, parse_range
export parse_addition, parse_multiplication, parse_unary, parse_postfix, parse_primary
export parse_call_arg, parse_postfix_on, parse_binary_from
export parse_block, parse_statement
export parse_val_decl_stmt, parse_var_decl_stmt
export parse_if_stmt, parse_for_stmt, parse_while_stmt, parse_match_stmt
export parse_if_expr, parse_for_expr, parse_while_expr
export parse_fn_decl, parse_extern_fn_decl, parse_struct_decl, parse_enum_decl
export parse_impl_decl, parse_class_body_method
export parse_use_decl, parse_export_decl, parse_val_decl, parse_var_decl
export parse_module, parse_module_file, parse_module_body
export parser_has_errors, parser_get_errors, parser_error_count
export par_kind, par_text, par_line, par_col, par_errors, par_had_error
