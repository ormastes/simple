# Core Simple â€” Runtime Generic Monomorphization
#
# Integrates AST cloning and type substitution to provide runtime generics.
# This enables generic functions to work in interpreter mode, not just compiled.
#
# Architecture:
# 1. Cache specialized function versions by signature
# 2. On first call with concrete types: clone + substitute + cache
# 3. On subsequent calls: lookup in cache and execute
#
# Example:
#   fn identity<T>(x: T) -> T: x
#   identity(42)      # Creates identity__i64 specialization
#   identity("hello") # Creates identity__text specialization
#   identity(99)      # Reuses identity__i64 from cache

use core.ast_clone.{ast_clone_decl, ast_clone_is_generic, ast_clone_get_type_params}
use core.type_subst.{type_subst_reset, type_subst_add, subst_type_in_decl}
use core.types.{TYPE_I64, TYPE_F64, TYPE_TEXT, TYPE_BOOL, TYPE_UNIT}
use core.ast.{decl_get}

# ===== Specialization Cache =====
# Maps: (decl_id, type_signature) -> specialized_decl_id
var cache_keys: [[i64]] = []        # Each entry is [decl_id, type1, type2, ...]
var cache_values: [i64] = []        # Corresponding specialized decl IDs

fn generic_cache_reset():
    """Clear the specialization cache"""
    cache_keys = []
    cache_values = []

fn generic_cache_make_key(decl_id: i64, type_tags: [i64]) -> [i64]:
    """Create a cache key from decl_id and type tags"""
    var key: [i64] = [decl_id]
    for tag in type_tags:
        key.push(tag)
    key

fn generic_cache_keys_equal(k1: [i64], k2: [i64]) -> bool:
    """Check if two cache keys are equal"""
    if k1.len() != k2.len():
        return false

    var i: i64 = 0
    for val1 in k1:
        if val1 != k2[i]:
            return false
        i = i + 1

    true

fn generic_cache_lookup(decl_id: i64, type_tags: [i64]) -> i64:
    """Look up a specialized version in the cache

    Returns specialized decl_id if found, -1 otherwise.
    """
    val search_key = generic_cache_make_key(decl_id, type_tags)

    var i: i64 = 0
    for key in cache_keys:
        if generic_cache_keys_equal(key, search_key):
            return cache_values[i]
        i = i + 1

    -1

fn generic_cache_insert(decl_id: i64, type_tags: [i64], specialized_id: i64):
    """Insert a specialization into the cache"""
    val key = generic_cache_make_key(decl_id, type_tags)
    cache_keys.push(key)
    cache_values.push(specialized_id)

# ===== Type Inference =====

fn generic_infer_type_from_value(value: text) -> i64:
    """Infer type tag from a runtime value

    This is a simplified implementation. A full version would
    examine the actual runtime value representation.
    For now, we use heuristics based on string content.
    """
    # Check for common patterns
    if value == "true":
        return TYPE_BOOL
    if value == "false":
        return TYPE_BOOL
    if value == "nil":
        return TYPE_UNIT

    # Check if it looks like a number
    # This is simplified - real implementation would parse the value
    val first_char = value[0:1]
    if first_char == "0":
        return TYPE_I64
    if first_char == "1":
        return TYPE_I64
    if first_char == "2":
        return TYPE_I64
    if first_char == "3":
        return TYPE_I64
    if first_char == "4":
        return TYPE_I64
    if first_char == "5":
        return TYPE_I64
    if first_char == "6":
        return TYPE_I64
    if first_char == "7":
        return TYPE_I64
    if first_char == "8":
        return TYPE_I64
    if first_char == "9":
        return TYPE_I64

    # Default to text for other strings
    TYPE_TEXT

fn generic_infer_types_from_args(args: [text]) -> [i64]:
    """Infer type tags from a list of argument values"""
    var types: [i64] = []
    for arg in args:
        types.push(generic_infer_type_from_value(arg))
    types

# ===== Monomorphization =====

fn generic_monomorphize(decl_id: i64, type_tags: [i64]) -> i64:
    """Create a specialized version of a generic function

    Steps:
    1. Check if already cached
    2. If not, clone the declaration
    3. Apply type substitutions
    4. Cache the result
    5. Return specialized decl_id

    Returns: specialized decl_id (new or cached)
    """
    # Check cache first
    val cached = generic_cache_lookup(decl_id, type_tags)
    if cached >= 0:
        return cached

    # Not in cache - need to specialize
    # Get type parameter names
    val type_params = ast_clone_get_type_params(decl_id)

    # Clone the declaration
    val cloned_id = ast_clone_decl(decl_id)

    # Set up substitution mappings
    type_subst_reset()
    var i: i64 = 0
    for param_name in type_params:
        if i < type_tags.len():
            type_subst_add(param_name, type_tags[i])
        i = i + 1

    # Apply substitutions in-place
    subst_type_in_decl(cloned_id)

    # Cache the specialized version
    generic_cache_insert(decl_id, type_tags, cloned_id)

    cloned_id

fn generic_specialize_for_call(decl_id: i64, arg_values: [text]) -> i64:
    """Specialize a generic function for a specific call

    Infers types from argument values and creates/retrieves
    the appropriate specialization.

    Returns: specialized decl_id to execute
    """
    # Check if this is actually a generic function
    if not ast_clone_is_generic(decl_id):
        # Not generic - just return the original
        return decl_id

    # Infer types from arguments
    val type_tags = generic_infer_types_from_args(arg_values)

    # Monomorphize
    generic_monomorphize(decl_id, type_tags)

# ===== Statistics =====

fn generic_cache_size() -> i64:
    """Get the current size of the specialization cache"""
    cache_keys.len()

fn generic_cache_has(decl_id: i64, type_tags: [i64]) -> bool:
    """Check if a specialization exists in cache"""
    val result = generic_cache_lookup(decl_id, type_tags)
    result >= 0

# ===== Debugging =====

fn generic_dump_cache():
    """Print cache contents (for debugging)"""
    print "Generic cache: {cache_keys.len()} specializations"
    var i: i64 = 0
    for key in cache_keys:
        print "  [{i}] decl={key[0]} types={key[1:]} -> {cache_values[i]}"
        i = i + 1

# ===== Public API =====

export generic_cache_reset, generic_cache_lookup, generic_cache_insert
export generic_infer_type_from_value, generic_infer_types_from_args
export generic_monomorphize, generic_specialize_for_call
export generic_cache_size, generic_cache_has
export generic_dump_cache
