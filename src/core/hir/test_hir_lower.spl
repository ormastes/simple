# Core Simple â€” HIR Lowering Tests
#
# Seed-compiled test: parse a snippet, run HIR lowering, check expr types.

use core.lexer.{lex_init}
use core.parser.{parser_init, parse_module}
use core.ast.{ast_reset, expr_count}
use core.types.{reset_all_pools}
use core.hir.lowering.{hir_lower_module, hir_expr_type, hir_pool_get, hir_pool_count}
use core.hir.lowering.{TI_VOID, TI_BOOL, TI_I64, TI_F64, TI_TEXT, TI_ANY, TI_NIL}
use core.hir.lowering.{hir_get_struct_count, hir_find_struct}
use core.hir_types.{HIR_TYPE_VOID, HIR_TYPE_BOOL, HIR_TYPE_I64, HIR_TYPE_F64, HIR_TYPE_TEXT}
use core.hir_types.{HIR_TYPE_ARRAY, HIR_TYPE_STRUCT, HIR_TYPE_FN, HIR_TYPE_ANY, HIR_TYPE_NIL}
use core.hir_types.{hir_type_kind_name}

var test_pass_count: i64 = 0
var test_fail_count: i64 = 0

fn check_type_tag(label: text, expr_idx: i64, expected_tag: i64) -> i64:
    val ti = hir_expr_type(expr_idx)
    if ti < 0:
        print "FAIL: {label} - expr {expr_idx} has no type (ti={ti})"
        test_fail_count = test_fail_count + 1
        return 0
    val ht = hir_pool_get(ti)
    if ht.tag == expected_tag:
        test_pass_count = test_pass_count + 1
    else:
        val expected_name = hir_type_kind_name(expected_tag)
        val actual_name = hir_type_kind_name(ht.tag)
        print "FAIL: {label} - expected {expected_name}, got {actual_name} (ti={ti})"
        test_fail_count = test_fail_count + 1
    0

fn lower_source(source: text):
    reset_all_pools()
    ast_reset()
    parse_module(source, "test")
    hir_lower_module()

# === Test 1: Integer literals ===
print "--- Test 1: Integer literals ---"
lower_source("val x = 42")
# expr 0 = IntLit(42)
check_type_tag("int lit", 0, HIR_TYPE_I64)

# === Test 2: Float literals ===
print "--- Test 2: Float literals ---"
lower_source("val x = 3.14")
check_type_tag("float lit", 0, HIR_TYPE_F64)

# === Test 3: String literals ===
print "--- Test 3: String literals ---"
lower_source("val x = \"hello\"")
check_type_tag("string lit", 0, HIR_TYPE_TEXT)

# === Test 4: Bool literals ===
print "--- Test 4: Bool literals ---"
lower_source("val x = true")
check_type_tag("bool lit", 0, HIR_TYPE_BOOL)

# === Test 5: Binary arithmetic ===
print "--- Test 5: Binary arithmetic ---"
lower_source("val x = 2 + 3")
# Find the binary expr - typically expr 2 (after two int lits at 0,1)
check_type_tag("int add", 2, HIR_TYPE_I64)

# === Test 6: Comparison ===
print "--- Test 6: Comparison ---"
lower_source("val x = 5 > 3")
check_type_tag("comparison", 2, HIR_TYPE_BOOL)

# === Test 7: Function return type ===
print "--- Test 7: Function return type ---"
lower_source("fn square(x: i64) -> i64:\n    x * x\nval y = square(5)")
# After lowering, the call expr should resolve to i64
# (exact expr indices depend on parser output)
val ec7 = expr_count()
# The call expression is near the end
check_type_tag("fn call", ec7 - 2, HIR_TYPE_I64)

# === Test 8: Struct ===
print "--- Test 8: Struct ---"
lower_source("struct Point:\n    x: i64\n    y: i64")
val sc = hir_get_struct_count()
if sc >= 1:
    val si = hir_find_struct("Point")
    if si >= 0:
        test_pass_count = test_pass_count + 1
        print "  struct Point registered at index {si}"
    else:
        print "FAIL: struct Point not found"
        test_fail_count = test_fail_count + 1
else:
    print "FAIL: no structs registered"
    test_fail_count = test_fail_count + 1

# === Test 9: Type pool has primitives ===
print "--- Test 9: Type pool primitives ---"
lower_source("val x = 1")
val pool_count = hir_pool_count()
if pool_count >= 7:
    test_pass_count = test_pass_count + 1
else:
    print "FAIL: type pool has {pool_count} entries, expected >= 7"
    test_fail_count = test_fail_count + 1

# === Summary ===
print ""
val total = test_pass_count + test_fail_count
print "=== HIR Lowering Tests: {test_pass_count}/{total} passed ==="
if test_fail_count > 0:
    print "FAILURES: {test_fail_count}"
