# Core Simple â€” Arena-Based AST
#
# Shared core library: AST nodes stored in parallel arrays (arena pattern).
# Each node is referenced by an i64 index. No structs, no enums with
# payloads, no generics, no me methods.
#
# Node types:
#   - Expr (expressions): integer tags in EXPR_* constants
#   - Stmt (statements): integer tags in STMT_* constants
#   - Decl (declarations): integer tags in DECL_* constants
#   - Param (function parameters)
#   - Field (struct fields)
#   - MatchArm (match case arms)

# ===== Expression Kind Tags =====
val EXPR_INT_LIT = 1
val EXPR_FLOAT_LIT = 2
val EXPR_STRING_LIT = 3
val EXPR_BOOL_LIT = 4
val EXPR_NIL_LIT = 5
val EXPR_IDENT = 6
val EXPR_BINARY = 7
val EXPR_UNARY = 8
val EXPR_CALL = 9
val EXPR_INDEX = 10
val EXPR_FIELD_ACCESS = 11
val EXPR_METHOD_CALL = 12
val EXPR_ARRAY_LIT = 13
val EXPR_IF = 14
val EXPR_MATCH = 15
val EXPR_FOR = 16
val EXPR_WHILE = 17
val EXPR_BLOCK = 18
val EXPR_RETURN = 19
val EXPR_BREAK = 20
val EXPR_CONTINUE = 21
val EXPR_RANGE = 22
val EXPR_ASSIGN = 23
val EXPR_COMPOUND_ASSIGN = 24
val EXPR_DICT_LIT = 25
val EXPR_LAMBDA = 26
val EXPR_STRUCT_LIT = 27
val EXPR_TUPLE = 28
val EXPR_SLICE = 29
val EXPR_NULL_COALESCE = 30
val EXPR_OPTIONAL_CHAIN = 31
val EXPR_CAST = 32
val EXPR_UNIT = 33
val EXPR_INTERPOLATED_STRING = 34
val EXPR_PASS = 35
val EXPR_PASS_TODO = 40
val EXPR_PASS_DO_NOTHING = 41
val EXPR_PASS_DN = 43
val EXPR_SUFFIXED_LIT = 36
val EXPR_AWAIT = 37       # await future_expr
val EXPR_YIELD = 38       # yield value
val EXPR_SPAWN = 39       # spawn fn_call
val EXPR_ASYNC_BLOCK = 42 # async { ... }

# ===== Expression Arena Pools =====
# Each expression has:
#   - tag:    EXPR_* kind
#   - span:   span pool index
#   - i_val:  integer value (for int/bool literals, operator kind)
#   - f_val:  float value (stored as text to avoid precision issues)
#   - s_val:  string value (for string literals, identifiers, field names)
#   - left:   left child expression index (-1 = none)
#   - right:  right child expression index (-1 = none)
#   - extra:  extra expression index (else branch, etc.) (-1 = none)
#   - args:   argument list (indices into expr pool)
#   - stmts:  statement list (indices into stmt pool)

var expr_tag: [i64] = []
var expr_span: [i64] = []
var expr_i_val: [i64] = []
var expr_f_val: [text] = []
var expr_s_val: [text] = []
var expr_left: [i64] = []
var expr_right: [i64] = []
var expr_extra: [i64] = []
var expr_args: [[i64]] = []
var expr_stmts: [[i64]] = []

fn expr_count() -> i64:
    expr_tag.len()

# Allocate a new expression node, returns its index
fn expr_alloc(tag: i64, span_id: i64) -> i64:
    val idx = expr_tag.len()
    expr_tag.push(tag)
    expr_span.push(span_id)
    expr_i_val.push(0)
    expr_f_val.push("")
    expr_s_val.push("")
    expr_left.push(-1)
    expr_right.push(-1)
    expr_extra.push(-1)
    expr_args.push([])
    expr_stmts.push([])
    idx

# ===== Expression Constructors =====

fn expr_int_lit(value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_INT_LIT, span_id)
    expr_i_val[idx] = value
    idx

fn expr_float_lit(value: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_FLOAT_LIT, span_id)
    expr_f_val[idx] = value
    idx

fn expr_string_lit(value: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_STRING_LIT, span_id)
    expr_s_val[idx] = value
    idx

fn expr_bool_lit(value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_BOOL_LIT, span_id)
    expr_i_val[idx] = value
    idx

fn expr_nil_lit(span_id: i64) -> i64:
    expr_alloc(EXPR_NIL_LIT, span_id)

fn expr_ident(name: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_IDENT, span_id)
    expr_s_val[idx] = name
    expr_i_val[idx] = -1
    idx

fn expr_binary(op: i64, left_idx: i64, right_idx: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_BINARY, span_id)
    expr_i_val[idx] = op
    expr_left[idx] = left_idx
    expr_right[idx] = right_idx
    idx

fn expr_unary(op: i64, operand: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_UNARY, span_id)
    expr_i_val[idx] = op
    expr_left[idx] = operand
    idx

fn expr_call(callee: i64, call_args: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_CALL, span_id)
    expr_left[idx] = callee
    expr_args[idx] = call_args
    idx

fn expr_index(base: i64, index_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_INDEX, span_id)
    expr_left[idx] = base
    expr_right[idx] = index_expr
    idx

fn expr_field_access(base: i64, field_name: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_FIELD_ACCESS, span_id)
    expr_left[idx] = base
    expr_s_val[idx] = field_name
    expr_i_val[idx] = -1
    idx

fn expr_method_call(receiver: i64, method_name: text, call_args: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_METHOD_CALL, span_id)
    expr_left[idx] = receiver
    expr_s_val[idx] = method_name
    expr_args[idx] = call_args
    idx

fn expr_array_lit(elements: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_ARRAY_LIT, span_id)
    expr_args[idx] = elements
    idx

fn expr_if_expr(cond: i64, then_branch: i64, else_branch: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_IF, span_id)
    expr_left[idx] = cond
    expr_right[idx] = then_branch
    expr_extra[idx] = else_branch
    idx

fn expr_match_expr(scrutinee: i64, arms: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_MATCH, span_id)
    expr_left[idx] = scrutinee
    expr_args[idx] = arms
    idx

fn expr_for_expr(iter_var: text, iterable: i64, body_stmts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_FOR, span_id)
    expr_s_val[idx] = iter_var
    expr_left[idx] = iterable
    expr_stmts[idx] = body_stmts
    idx

fn expr_while_expr(cond: i64, body_stmts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_WHILE, span_id)
    expr_left[idx] = cond
    expr_stmts[idx] = body_stmts
    idx

fn expr_block(body_stmts: [i64], value_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_BLOCK, span_id)
    expr_stmts[idx] = body_stmts
    expr_left[idx] = value_expr
    idx

fn expr_return_expr(value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_RETURN, span_id)
    expr_left[idx] = value
    idx

fn expr_break_expr(span_id: i64) -> i64:
    expr_alloc(EXPR_BREAK, span_id)

fn expr_continue_expr(span_id: i64) -> i64:
    expr_alloc(EXPR_CONTINUE, span_id)

fn expr_await(future_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_AWAIT, span_id)
    expr_left[idx] = future_expr
    idx

fn expr_yield(value_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_YIELD, span_id)
    expr_left[idx] = value_expr
    idx

fn expr_spawn(call_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SPAWN, span_id)
    expr_left[idx] = call_expr
    idx

fn expr_range(start_expr: i64, end_expr: i64, inclusive: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_RANGE, span_id)
    expr_left[idx] = start_expr
    expr_right[idx] = end_expr
    expr_i_val[idx] = inclusive
    idx

fn expr_assign(target: i64, value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_ASSIGN, span_id)
    expr_left[idx] = target
    expr_right[idx] = value
    idx

fn expr_compound_assign(op: i64, target: i64, value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_COMPOUND_ASSIGN, span_id)
    expr_i_val[idx] = op
    expr_left[idx] = target
    expr_right[idx] = value
    idx

fn expr_dict_lit(key_exprs: [i64], value_exprs: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_DICT_LIT, span_id)
    expr_args[idx] = key_exprs
    expr_stmts[idx] = value_exprs
    idx

fn expr_lambda(param_names: [i64], body_stmts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_LAMBDA, span_id)
    expr_args[idx] = param_names
    expr_stmts[idx] = body_stmts
    idx

fn expr_struct_lit(type_name: text, field_names: [i64], field_values: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_STRUCT_LIT, span_id)
    expr_s_val[idx] = type_name
    expr_args[idx] = field_names
    expr_stmts[idx] = field_values
    idx

fn expr_tuple(elements: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_TUPLE, span_id)
    expr_args[idx] = elements
    idx

fn expr_slice(base: i64, start_expr: i64, end_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SLICE, span_id)
    expr_left[idx] = base
    expr_right[idx] = start_expr
    expr_extra[idx] = end_expr
    idx

fn expr_null_coalesce(left_idx: i64, right_idx: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_NULL_COALESCE, span_id)
    expr_left[idx] = left_idx
    expr_right[idx] = right_idx
    idx

fn expr_optional_chain(base: i64, field_name: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_OPTIONAL_CHAIN, span_id)
    expr_left[idx] = base
    expr_s_val[idx] = field_name
    idx

fn expr_cast(value: i64, type_tag: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_CAST, span_id)
    expr_left[idx] = value
    expr_i_val[idx] = type_tag
    idx

fn expr_unit(span_id: i64) -> i64:
    expr_alloc(EXPR_UNIT, span_id)

fn expr_interpolated_string(parts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_INTERPOLATED_STRING, span_id)
    expr_args[idx] = parts
    idx

fn expr_pass(span_id: i64) -> i64:
    expr_alloc(EXPR_PASS, span_id)

fn expr_pass_with_msg(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_pass_todo(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS_TODO, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_pass_do_nothing(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS_DO_NOTHING, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_pass_dn(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS_DN, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_suffixed_int(value: i64, suffix: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SUFFIXED_LIT, span_id)
    expr_i_val[idx] = value
    expr_s_val[idx] = suffix
    idx

fn expr_suffixed_float(value: text, suffix: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SUFFIXED_LIT, span_id)
    expr_f_val[idx] = value
    expr_s_val[idx] = suffix
    idx

fn expr_suffixed_bool(value: i64, suffix: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SUFFIXED_LIT, span_id)
    expr_i_val[idx] = value
    expr_extra[idx] = 1
    expr_s_val[idx] = suffix
    idx

# ===== Expression Accessors =====

fn expr_get_tag(idx: i64) -> i64:
    expr_tag[idx]

fn expr_get_span(idx: i64) -> i64:
    expr_span[idx]

fn expr_get_int(idx: i64) -> i64:
    expr_i_val[idx]

fn expr_get_float(idx: i64) -> text:
    expr_f_val[idx]

fn expr_get_str(idx: i64) -> text:
    expr_s_val[idx]

fn expr_get_left(idx: i64) -> i64:
    expr_left[idx]

fn expr_get_right(idx: i64) -> i64:
    expr_right[idx]

fn expr_get_extra(idx: i64) -> i64:
    expr_extra[idx]

fn expr_get_args(idx: i64) -> [i64]:
    expr_args[idx]

fn expr_get_stmts(idx: i64) -> [i64]:
    expr_stmts[idx]

# ===== Statement Kind Tags =====
val STMT_EXPR = 1
val STMT_VAL_DECL = 2
val STMT_VAR_DECL = 3
val STMT_ASSIGN = 4
val STMT_RETURN = 5
val STMT_IF = 6
val STMT_FOR = 7
val STMT_WHILE = 8
val STMT_MATCH = 9
val STMT_BLOCK = 10
val STMT_BREAK = 11
val STMT_CONTINUE = 12
val STMT_COMPOUND_ASSIGN = 13

# ===== Statement Arena Pools =====
var stmt_tag: [i64] = []
var stmt_span: [i64] = []
var stmt_expr: [i64] = []
var stmt_name: [text] = []
var stmt_type_tag: [i64] = []
var stmt_body: [[i64]] = []

fn stmt_count() -> i64:
    stmt_tag.len()

fn stmt_alloc(tag: i64, span_id: i64) -> i64:
    val idx = stmt_tag.len()
    stmt_tag.push(tag)
    stmt_span.push(span_id)
    stmt_expr.push(-1)
    stmt_name.push("")
    stmt_type_tag.push(0)
    stmt_body.push([])
    idx

# ===== Statement Constructors =====

fn stmt_expr_stmt(expression: i64, span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_EXPR, span_id)
    stmt_expr[idx] = expression
    idx

fn stmt_val_decl(name: text, type_tag: i64, init_expr: i64, span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_VAL_DECL, span_id)
    stmt_name[idx] = name
    stmt_type_tag[idx] = type_tag
    stmt_expr[idx] = init_expr
    idx

fn stmt_var_decl(name: text, type_tag: i64, init_expr: i64, span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_VAR_DECL, span_id)
    stmt_name[idx] = name
    stmt_type_tag[idx] = type_tag
    stmt_expr[idx] = init_expr
    idx

fn stmt_assign_stmt(target_expr: i64, value_expr: i64, span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_ASSIGN, span_id)
    stmt_expr[idx] = target_expr
    var body: [i64] = []
    body.push(value_expr)
    stmt_body[idx] = body
    idx

fn stmt_return_stmt(value_expr: i64, span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_RETURN, span_id)
    stmt_expr[idx] = value_expr
    idx

fn stmt_if_stmt(cond_expr: i64, then_stmts: [i64], elif_idx: i64, span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_IF, span_id)
    stmt_expr[idx] = cond_expr
    stmt_body[idx] = then_stmts
    stmt_type_tag[idx] = elif_idx
    idx

fn stmt_for_stmt(iter_name: text, iterable: i64, body_stmts: [i64], span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_FOR, span_id)
    stmt_name[idx] = iter_name
    stmt_expr[idx] = iterable
    stmt_body[idx] = body_stmts
    idx

fn stmt_while_stmt(cond_expr: i64, body_stmts: [i64], span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_WHILE, span_id)
    stmt_expr[idx] = cond_expr
    stmt_body[idx] = body_stmts
    idx

fn stmt_match_stmt(scrutinee: i64, arm_indices: [i64], span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_MATCH, span_id)
    stmt_expr[idx] = scrutinee
    stmt_body[idx] = arm_indices
    idx

fn stmt_block_stmt(body_stmts: [i64], span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_BLOCK, span_id)
    stmt_body[idx] = body_stmts
    idx

fn stmt_break_stmt(span_id: i64) -> i64:
    stmt_alloc(STMT_BREAK, span_id)

fn stmt_continue_stmt(span_id: i64) -> i64:
    stmt_alloc(STMT_CONTINUE, span_id)

fn stmt_compound_assign_stmt(op: i64, target_expr: i64, value_expr: i64, span_id: i64) -> i64:
    val idx = stmt_alloc(STMT_COMPOUND_ASSIGN, span_id)
    stmt_expr[idx] = target_expr
    stmt_type_tag[idx] = op
    var body: [i64] = []
    body.push(value_expr)
    stmt_body[idx] = body
    idx

# ===== Statement Accessors =====

fn stmt_get_tag(idx: i64) -> i64:
    stmt_tag[idx]

fn stmt_get_span(idx: i64) -> i64:
    stmt_span[idx]

fn stmt_get_expr(idx: i64) -> i64:
    stmt_expr[idx]

fn stmt_get_name(idx: i64) -> text:
    stmt_name[idx]

fn stmt_get_type(idx: i64) -> i64:
    stmt_type_tag[idx]

fn stmt_get_body(idx: i64) -> [i64]:
    stmt_body[idx]

# ===== Declaration Kind Tags =====
val DECL_FN = 1
val DECL_EXTERN_FN = 2
val DECL_STRUCT = 3
val DECL_VAL = 4
val DECL_VAR = 5
val DECL_USE = 6
val DECL_EXPORT = 7
val DECL_ENUM = 8
val DECL_IMPL = 9
val DECL_CLASS = 10

# ===== Declaration Arena Pools =====
var decl_tag: [i64] = []
var decl_span: [i64] = []
var decl_name: [text] = []
var decl_params: [[i64]] = []
var decl_param_names: [[text]] = []
var decl_param_types: [[i64]] = []
var decl_ret_type: [i64] = []
var decl_body_stmts: [[i64]] = []
var decl_field_names: [[text]] = []
var decl_field_types: [[i64]] = []
var decl_imports: [[text]] = []
var decl_is_pub: [i64] = []
var decl_is_async: [i64] = []
var decl_type_params: [[text]] = []

fn decl_count() -> i64:
    decl_tag.len()

fn decl_alloc(tag: i64, span_id: i64) -> i64:
    val idx = decl_tag.len()
    decl_tag.push(tag)
    decl_span.push(span_id)
    decl_name.push("")
    decl_params.push([])
    decl_param_names.push([])
    decl_param_types.push([])
    decl_ret_type.push(0)
    decl_body_stmts.push([])
    decl_field_names.push([])
    decl_field_types.push([])
    decl_imports.push([])
    decl_is_pub.push(0)
    decl_is_async.push(0)
    decl_type_params.push([])
    idx

# ===== Declaration Constructors =====

fn decl_fn(name: text, param_names: [text], param_types: [i64], ret_type: i64, body: [i64], is_async: i64, type_params: [text], span_id: i64) -> i64:
    val idx = decl_alloc(DECL_FN, span_id)
    decl_name[idx] = name
    decl_param_names[idx] = param_names
    decl_param_types[idx] = param_types
    decl_ret_type[idx] = ret_type
    decl_body_stmts[idx] = body
    decl_is_async[idx] = is_async
    decl_type_params[idx] = type_params
    idx

fn decl_extern_fn(name: text, param_names: [text], param_types: [i64], ret_type: i64, type_params: [text], span_id: i64) -> i64:
    val idx = decl_alloc(DECL_EXTERN_FN, span_id)
    decl_name[idx] = name
    decl_param_names[idx] = param_names
    decl_param_types[idx] = param_types
    decl_ret_type[idx] = ret_type
    decl_type_params[idx] = type_params
    idx

fn decl_struct_def(name: text, field_names: [text], field_types: [i64], span_id: i64) -> i64:
    val idx = decl_alloc(DECL_STRUCT, span_id)
    decl_name[idx] = name
    decl_field_names[idx] = field_names
    decl_field_types[idx] = field_types
    idx

fn decl_val_binding(name: text, type_tag: i64, init_expr: i64, span_id: i64) -> i64:
    val idx = decl_alloc(DECL_VAL, span_id)
    decl_name[idx] = name
    decl_ret_type[idx] = type_tag
    var body: [i64] = []
    body.push(init_expr)
    decl_body_stmts[idx] = body
    idx

fn decl_var_binding(name: text, type_tag: i64, init_expr: i64, span_id: i64) -> i64:
    val idx = decl_alloc(DECL_VAR, span_id)
    decl_name[idx] = name
    decl_ret_type[idx] = type_tag
    var body: [i64] = []
    body.push(init_expr)
    decl_body_stmts[idx] = body
    idx

fn decl_use_import(module_path: text, imported_names: [text], span_id: i64) -> i64:
    val idx = decl_alloc(DECL_USE, span_id)
    decl_name[idx] = module_path
    decl_imports[idx] = imported_names
    idx

fn decl_export_names(names: [text], span_id: i64) -> i64:
    val idx = decl_alloc(DECL_EXPORT, span_id)
    decl_imports[idx] = names
    idx

fn decl_enum_def(name: text, variant_names: [text], span_id: i64) -> i64:
    val idx = decl_alloc(DECL_ENUM, span_id)
    decl_name[idx] = name
    decl_field_names[idx] = variant_names
    idx

fn decl_impl_block(target_name: text, method_decl_ids: [i64], span_id: i64) -> i64:
    val idx = decl_alloc(DECL_IMPL, span_id)
    decl_name[idx] = target_name
    decl_body_stmts[idx] = method_decl_ids
    idx

# ===== Declaration Accessors =====

fn decl_get_tag(idx: i64) -> i64:
    decl_tag[idx]

fn decl_get_span(idx: i64) -> i64:
    decl_span[idx]

fn decl_get_name(idx: i64) -> text:
    decl_name[idx]

fn decl_get_param_names(idx: i64) -> [text]:
    decl_param_names[idx]

fn decl_get_param_types(idx: i64) -> [i64]:
    decl_param_types[idx]

fn decl_get_ret_type(idx: i64) -> i64:
    decl_ret_type[idx]

fn decl_get_body(idx: i64) -> [i64]:
    decl_body_stmts[idx]

fn decl_get_fields(idx: i64) -> [text]:
    decl_field_names[idx]

fn decl_get_field_types(idx: i64) -> [i64]:
    decl_field_types[idx]

fn decl_get_imports(idx: i64) -> [text]:
    decl_imports[idx]

fn decl_get_is_pub(idx: i64) -> bool:
    decl_is_pub[idx] == 1

fn decl_get_is_async(idx: i64) -> i64:
    decl_is_async[idx]

fn decl_get_type_params(idx: i64) -> [text]:
    decl_type_params[idx]

fn decl_set_type_params(idx: i64, params: [text]):
    decl_type_params[idx] = params

# ===== Match Arm Arena =====
# A match arm is (pattern_expr, guard_expr, body_stmts)

var arm_pattern: [i64] = []
var arm_guard: [i64] = []
var arm_body: [[i64]] = []

fn arm_new(pattern: i64, guard: i64, body: [i64]) -> i64:
    val idx = arm_pattern.len()
    arm_pattern.push(pattern)
    arm_guard.push(guard)
    arm_body.push(body)
    idx

fn arm_get_pattern(idx: i64) -> i64:
    arm_pattern[idx]

fn arm_get_guard(idx: i64) -> i64:
    arm_guard[idx]

fn arm_get_body(idx: i64) -> [i64]:
    arm_body[idx]

# ===== If Branch Arena =====
# For elif chains: (cond_expr, then_stmts)
# Stored separately from main if to support multiple elif branches.

var elif_cond: [i64] = []
var elif_body: [[i64]] = []
var elif_else: [[i64]] = []

fn elif_new(cond: i64, body: [i64], else_body: [i64]) -> i64:
    val idx = elif_cond.len()
    elif_cond.push(cond)
    elif_body.push(body)
    elif_else.push(else_body)
    idx

fn elif_get_cond(idx: i64) -> i64:
    elif_cond[idx]

fn elif_get_body(idx: i64) -> [i64]:
    elif_body[idx]

fn elif_get_else(idx: i64) -> [i64]:
    elif_else[idx]

# ===== Module (Top-Level AST) =====
# A module is a list of declarations.

var module_path: text = ""
var module_decls: [i64] = []

fn module_set_path(path: text):
    module_path = path

fn module_get_path() -> text:
    module_path

fn module_add_decl(decl_idx: i64):
    module_decls.push(decl_idx)

fn module_get_decls() -> [i64]:
    module_decls

# ===== AST Reset =====

fn ast_reset():
    expr_tag = []
    expr_span = []
    expr_i_val = []
    expr_f_val = []
    expr_s_val = []
    expr_left = []
    expr_right = []
    expr_extra = []
    expr_args = []
    expr_stmts = []
    stmt_tag = []
    stmt_span = []
    stmt_expr = []
    stmt_name = []
    stmt_type_tag = []
    stmt_body = []
    decl_tag = []
    decl_span = []
    decl_name = []
    decl_params = []
    decl_param_names = []
    decl_param_types = []
    decl_ret_type = []
    decl_body_stmts = []
    decl_field_names = []
    decl_field_types = []
    decl_imports = []
    decl_is_pub = []
    decl_type_params = []
    arm_pattern = []
    arm_guard = []
    arm_body = []
    elif_cond = []
    elif_body = []
    elif_else = []
    module_path = ""
    module_decls = []

# ===== Struct Builders for Interpreter =====
# These functions construct Core* structs from the arena arrays
# Needed by the interpreter which expects struct-based access

fn expr_get(idx: i64) -> CoreExpr:
    CoreExpr(
        tag: expr_tag[idx],
        span_id: expr_span[idx],
        i_val: expr_i_val[idx],
        f_val: expr_f_val[idx],
        s_val: expr_s_val[idx],
        left: expr_left[idx],
        right: expr_right[idx],
        extra: expr_extra[idx],
        args: expr_args[idx],
        stmts: expr_stmts[idx]
    )

fn stmt_get(idx: i64) -> CoreStmt:
    CoreStmt(
        tag: stmt_tag[idx],
        span_id: stmt_span[idx],
        expr_idx: stmt_expr[idx],
        name: stmt_name[idx],
        type_tag: stmt_type_tag[idx],
        body: stmt_body[idx]
    )

fn decl_get(idx: i64) -> CoreDecl:
    CoreDecl(
        tag: decl_tag[idx],
        span_id: decl_span[idx],
        name: decl_name[idx],
        param_names: decl_param_names[idx],
        param_types: decl_param_types[idx],
        ret_type: decl_ret_type[idx],
        body_stmts: decl_body_stmts[idx],
        field_names: decl_field_names[idx],
        field_types: decl_field_types[idx],
        imports: decl_imports[idx],
        is_pub: decl_is_pub[idx],
        type_params: decl_type_params[idx]
    )

# ===== Expression Kind Names (for debugging) =====

fn expr_kind_name(tag: i64) -> text:
    if tag == EXPR_INT_LIT: return "IntLit"
    if tag == EXPR_FLOAT_LIT: return "FloatLit"
    if tag == EXPR_STRING_LIT: return "StringLit"
    if tag == EXPR_BOOL_LIT: return "BoolLit"
    if tag == EXPR_NIL_LIT: return "NilLit"
    if tag == EXPR_IDENT: return "Ident"
    if tag == EXPR_BINARY: return "Binary"
    if tag == EXPR_UNARY: return "Unary"
    if tag == EXPR_CALL: return "Call"
    if tag == EXPR_INDEX: return "Index"
    if tag == EXPR_FIELD_ACCESS: return "FieldAccess"
    if tag == EXPR_METHOD_CALL: return "MethodCall"
    if tag == EXPR_ARRAY_LIT: return "ArrayLit"
    if tag == EXPR_IF: return "If"
    if tag == EXPR_MATCH: return "Match"
    if tag == EXPR_FOR: return "For"
    if tag == EXPR_WHILE: return "While"
    if tag == EXPR_BLOCK: return "Block"
    if tag == EXPR_RETURN: return "Return"
    if tag == EXPR_BREAK: return "Break"
    if tag == EXPR_CONTINUE: return "Continue"
    if tag == EXPR_RANGE: return "Range"
    if tag == EXPR_ASSIGN: return "Assign"
    if tag == EXPR_COMPOUND_ASSIGN: return "CompoundAssign"
    if tag == EXPR_DICT_LIT: return "DictLit"
    if tag == EXPR_LAMBDA: return "Lambda"
    if tag == EXPR_STRUCT_LIT: return "StructLit"
    if tag == EXPR_TUPLE: return "Tuple"
    if tag == EXPR_SLICE: return "Slice"
    if tag == EXPR_NULL_COALESCE: return "NullCoalesce"
    if tag == EXPR_OPTIONAL_CHAIN: return "OptionalChain"
    if tag == EXPR_CAST: return "Cast"
    if tag == EXPR_UNIT: return "Unit"
    if tag == EXPR_INTERPOLATED_STRING: return "InterpolatedString"
    if tag == EXPR_PASS: return "Pass"
    if tag == EXPR_PASS_TODO: return "PassTodo"
    if tag == EXPR_PASS_DO_NOTHING: return "PassDoNothing"
    if tag == EXPR_PASS_DN: return "PassDn"
    if tag == EXPR_SUFFIXED_LIT: return "SuffixedLit"
    "Unknown"

export EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT, EXPR_BOOL_LIT, EXPR_NIL_LIT
export EXPR_IDENT, EXPR_BINARY, EXPR_UNARY, EXPR_CALL, EXPR_INDEX
export EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT
export EXPR_IF, EXPR_MATCH, EXPR_FOR, EXPR_WHILE, EXPR_BLOCK
export EXPR_RETURN, EXPR_BREAK, EXPR_CONTINUE, EXPR_RANGE
export EXPR_ASSIGN, EXPR_COMPOUND_ASSIGN, EXPR_DICT_LIT, EXPR_LAMBDA
export EXPR_STRUCT_LIT, EXPR_TUPLE, EXPR_SLICE
export EXPR_NULL_COALESCE, EXPR_OPTIONAL_CHAIN, EXPR_CAST
export EXPR_UNIT, EXPR_INTERPOLATED_STRING, EXPR_PASS, EXPR_PASS_TODO, EXPR_PASS_DO_NOTHING, EXPR_PASS_DN, EXPR_SUFFIXED_LIT
export expr_count, expr_alloc
export expr_int_lit, expr_float_lit, expr_string_lit, expr_bool_lit, expr_nil_lit
export expr_ident, expr_binary, expr_unary, expr_call, expr_index
export expr_field_access, expr_method_call, expr_array_lit
export expr_if_expr, expr_match_expr, expr_for_expr, expr_while_expr, expr_block
export expr_return_expr, expr_break_expr, expr_continue_expr, expr_range
export expr_assign, expr_compound_assign, expr_dict_lit, expr_lambda
export expr_struct_lit, expr_tuple, expr_slice
export expr_null_coalesce, expr_optional_chain, expr_cast
export expr_unit, expr_interpolated_string, expr_pass, expr_pass_with_msg, expr_pass_todo, expr_pass_do_nothing, expr_pass_dn
export expr_suffixed_int, expr_suffixed_float, expr_suffixed_bool
export expr_get_tag, expr_get_span, expr_get_int, expr_get_float, expr_get_str
export expr_get_left, expr_get_right, expr_get_extra, expr_get_args, expr_get_stmts
export STMT_EXPR, STMT_VAL_DECL, STMT_VAR_DECL, STMT_ASSIGN, STMT_RETURN
export STMT_IF, STMT_FOR, STMT_WHILE, STMT_MATCH, STMT_BLOCK
export STMT_BREAK, STMT_CONTINUE, STMT_COMPOUND_ASSIGN
export stmt_count, stmt_alloc
export stmt_expr_stmt, stmt_val_decl, stmt_var_decl, stmt_assign_stmt
export stmt_return_stmt, stmt_if_stmt, stmt_for_stmt, stmt_while_stmt
export stmt_match_stmt, stmt_block_stmt, stmt_break_stmt, stmt_continue_stmt
export stmt_compound_assign_stmt
export stmt_get_tag, stmt_get_span, stmt_get_expr, stmt_get_name
export stmt_get_type, stmt_get_body
export DECL_FN, DECL_EXTERN_FN, DECL_STRUCT, DECL_VAL, DECL_VAR
export DECL_USE, DECL_EXPORT, DECL_ENUM, DECL_IMPL, DECL_CLASS
export decl_count, decl_alloc
export decl_fn, decl_extern_fn, decl_struct_def
export decl_val_binding, decl_var_binding
export decl_use_import, decl_export_names, decl_enum_def, decl_impl_block
export decl_get_tag, decl_get_span, decl_get_name
export decl_get_param_names, decl_get_param_types, decl_get_ret_type
export decl_get_body, decl_get_fields, decl_get_field_types
export decl_get_imports, decl_get_is_pub, decl_get_is_async
export decl_get_type_params, decl_set_type_params
export arm_new, arm_get_pattern, arm_get_guard, arm_get_body
export elif_new, elif_get_cond, elif_get_body, elif_get_else
export module_set_path, module_get_path, module_add_decl, module_get_decls
export ast_reset, expr_kind_name
export expr_get, stmt_get, decl_get
