# Core Simple — AST-to-C++ Code Generator
#
# Walks the Core AST (struct pools) and emits C++ code compatible
# with the spl_runtime library (seed/runtime.h).
#
# Two-pass design:
#   Pass 1: Register all structs, enums, function signatures
#   Pass 2: Emit C++ (preamble, types, forward decls, functions, module init, main)
#
# Compiled by seed (Core Simple subset): no generics, no closures, no lambdas.
#
# Usage: called by driver.spl via codegen_program()

use std.text.{NL}
use core.ast.{expr_get, expr_get_tag, expr_get_int, expr_get_float, expr_get_str}
use core.ast.{expr_get_left, expr_get_right, expr_get_extra, expr_get_args, expr_get_stmts}
use core.ast.{stmt_get, stmt_get_tag, stmt_get_expr, stmt_get_name, stmt_get_type, stmt_get_body}
use core.ast.{decl_get, decl_get_tag, decl_get_name, decl_get_param_names, decl_get_param_types}
use core.ast.{decl_get_ret_type, decl_get_body, decl_get_fields, decl_get_field_types}
use core.ast.{decl_get_imports, decl_count, decl_get_is_async}
use core.ast.{module_get_decls}
use core.ast.{elif_get_cond, elif_get_body, elif_get_else}
use core.ast.{arm_get_pattern, arm_get_body}
use core.ast.{EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT, EXPR_BOOL_LIT, EXPR_NIL_LIT}
use core.ast.{EXPR_IDENT, EXPR_BINARY, EXPR_UNARY, EXPR_CALL, EXPR_INDEX}
use core.ast.{EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT, EXPR_DICT_LIT}
use core.ast.{EXPR_IF, EXPR_MATCH, EXPR_FOR, EXPR_WHILE, EXPR_BLOCK}
use core.ast.{EXPR_RETURN, EXPR_BREAK, EXPR_CONTINUE, EXPR_RANGE}
use core.ast.{EXPR_ASSIGN, EXPR_COMPOUND_ASSIGN, EXPR_STRUCT_LIT}
use core.ast.{EXPR_UNIT, EXPR_PASS, EXPR_PASS_TODO, EXPR_PASS_DO_NOTHING, EXPR_PASS_DN, EXPR_INTERPOLATED_STRING}
use core.ast.{EXPR_SLICE, EXPR_NULL_COALESCE, EXPR_CAST}
use core.ast.{STMT_EXPR, STMT_VAL_DECL, STMT_VAR_DECL, STMT_ASSIGN, STMT_RETURN}
use core.ast.{STMT_IF, STMT_FOR, STMT_WHILE, STMT_MATCH, STMT_BLOCK}
use core.ast.{STMT_BREAK, STMT_CONTINUE, STMT_COMPOUND_ASSIGN}
use core.ast.{DECL_FN, DECL_EXTERN_FN, DECL_STRUCT, DECL_VAL, DECL_VAR}
use core.ast.{DECL_USE, DECL_EXPORT, DECL_ENUM, DECL_IMPL, DECL_CLASS}
use core.tokens.{TOK_PLUS, TOK_MINUS, TOK_STAR, TOK_SLASH, TOK_PERCENT, TOK_STAR_STAR}
use core.tokens.{TOK_EQ, TOK_NOT_EQ, TOK_LT, TOK_GT, TOK_LT_EQ, TOK_GT_EQ}
use core.tokens.{TOK_KW_AND, TOK_KW_OR, TOK_KW_NOT}
use core.tokens.{TOK_PLUS_EQ, TOK_MINUS_EQ, TOK_STAR_EQ, TOK_SLASH_EQ, TOK_PERCENT_EQ}
use core.tokens.{TOK_AMPERSAND, TOK_PIPE, TOK_CARET, TOK_TILDE}
use core.types.{TYPE_VOID, TYPE_BOOL, TYPE_I64, TYPE_F64, TYPE_TEXT}
use core.types.{TYPE_ARRAY_I64, TYPE_ARRAY_TEXT, TYPE_ARRAY_BOOL, TYPE_ARRAY_ANY}
use core.types.{TYPE_STRUCT, TYPE_FN, TYPE_ANY, TYPE_NIL}
use core.types.{TYPE_OPTION, TYPE_RESULT, TYPE_NAMED_BASE}
use core.types.{type_tag_to_c, type_tag_name}
use core.types.{named_type_register, named_type_update, named_type_find, named_type_name, named_type_fields, named_type_field_type_tags}
# named_type_set_enum, named_type_check_enum — not yet in types.spl
use core.types.{fn_sig_register, fn_sig_find, fn_sig_ret_type}
use core.types.{fn_sig_param_count, fn_sig_get_param_names, fn_sig_get_param_types}
use core.types.{int_to_str}

# ===== Output Buffer =====

var cg_output: text = ""
var cg_indent: i64 = 0

fn cg_emit(s: text):
    cg_output = cg_output + s

fn cg_emit_line(s: text):
    for i in range(0, cg_indent):
        cg_output = cg_output + "    "
    cg_output = cg_output + s + NL

fn cg_emit_blank():
    cg_output = cg_output + NL

# ===== Variable Type Tracking =====
# Track local variable types for codegen decisions (string vs int operations).

var vt_names: [text] = []
var vt_types: [i64] = []
var vt_depths: [i64] = []
var vt_scope: i64 = 0

fn vt_reset():
    vt_names = []
    vt_types = []
    vt_depths = []
    vt_scope = 0

fn vt_push_scope():
    vt_scope = vt_scope + 1

fn vt_pop_scope():
    # Remove variables from current scope
    var new_names: [text] = []
    var new_types: [i64] = []
    var new_depths: [i64] = []
    for i in range(0, vt_names.len()):
        if vt_depths[i] < vt_scope:
            new_names.push(vt_names[i])
            new_types.push(vt_types[i])
            new_depths.push(vt_depths[i])
    vt_names = new_names
    vt_types = new_types
    vt_depths = new_depths
    vt_scope = vt_scope - 1

fn vt_add(name: text, type_tag: i64):
    vt_names.push(name)
    vt_types.push(type_tag)
    vt_depths.push(vt_scope)

fn vt_find(name: text) -> i64:
    # Search from end for shadowing
    val count = vt_names.len()
    if count == 0:
        return -1
    for i in range(0, count):
        val rev = count - 1 - i
        if vt_names[rev] == name:
            return vt_types[rev]
    -1

# ===== Struct Type Tracking =====
# Track which variables hold struct types, and which struct name.

var st_var_names: [text] = []
var st_struct_names: [text] = []

fn st_reset():
    st_var_names = []
    st_struct_names = []

fn st_add(var_name: text, struct_name: text):
    st_var_names.push(var_name)
    st_struct_names.push(struct_name)

fn st_find(var_name: text) -> text:
    val count = st_var_names.len()
    if count == 0:
        return ""
    for i in range(0, count):
        val rev = count - 1 - i
        if st_var_names[rev] == var_name:
            return st_struct_names[rev]
    ""

# ===== Struct Array Tracking =====
# Track which variables are [StructType] (use std::vector)

var sa_var_names: [text] = []
var sa_struct_names: [text] = []

fn sa_reset():
    sa_var_names = []
    sa_struct_names = []

fn sa_add(var_name: text, struct_name: text):
    sa_var_names.push(var_name)
    sa_struct_names.push(struct_name)

fn sa_find(var_name: text) -> text:
    val count = sa_var_names.len()
    if count == 0:
        return ""
    for i in range(0, count):
        val rev = count - 1 - i
        if sa_var_names[rev] == var_name:
            return sa_struct_names[rev]
    ""

# ===== Type Tag Helpers =====

fn is_text_type(tag: i64) -> bool:
    tag == TYPE_TEXT

fn is_array_type(tag: i64) -> bool:
    if tag == TYPE_ARRAY_I64: return true
    if tag == TYPE_ARRAY_TEXT: return true
    if tag == TYPE_ARRAY_BOOL: return true
    if tag == TYPE_ARRAY_ANY: return true
    false

fn is_struct_type(tag: i64) -> bool:
    tag == TYPE_STRUCT

# ===== Type Inference for Untyped Declarations =====

fn cg_infer_expr_type(idx: i64) -> i64:
    if idx < 0:
        return TYPE_VOID
    val tag = expr_get_tag(idx)
    if tag == EXPR_INT_LIT:
        return TYPE_I64
    if tag == EXPR_FLOAT_LIT:
        return TYPE_F64
    if tag == EXPR_STRING_LIT:
        return TYPE_TEXT
    if tag == EXPR_BOOL_LIT:
        return TYPE_BOOL
    if tag == EXPR_NIL_LIT:
        return TYPE_NIL
    if tag == EXPR_INTERPOLATED_STRING:
        return TYPE_TEXT
    if tag == EXPR_IDENT:
        val name = expr_get_str(idx)
        val vtype = vt_find(name)
        if vtype >= 0:
            return vtype
        return TYPE_I64
    if tag == EXPR_CALL:
        val callee_idx = expr_get_left(idx)
        if expr_get_tag(callee_idx) == EXPR_IDENT:
            val callee_name = expr_get_str(callee_idx)
            if callee_name == "int":
                return TYPE_I64
            if callee_name == "float":
                return TYPE_F64
            if callee_name == "str":
                return TYPE_TEXT
            if callee_name == "Some":
                return TYPE_OPTION
            if callee_name == "SplSome":
                return TYPE_OPTION
            if callee_name == "SplNone":
                return TYPE_OPTION
            if callee_name == "Ok":
                return TYPE_RESULT
            if callee_name == "Err":
                return TYPE_RESULT
            # Look up function return type
            val sig_id = fn_sig_find(callee_name)
            if sig_id >= 0:
                return fn_sig_ret_type(sig_id)
            # Check if struct constructor
            val struct_id = named_type_find(callee_name)
            if struct_id >= 0:
                return TYPE_STRUCT
        return TYPE_I64
    if tag == EXPR_BINARY:
        val op = expr_get_int(idx)
        # Comparison operators return bool
        if op == TOK_EQ: return TYPE_BOOL
        if op == TOK_NOT_EQ: return TYPE_BOOL
        if op == TOK_LT: return TYPE_BOOL
        if op == TOK_GT: return TYPE_BOOL
        if op == TOK_LT_EQ: return TYPE_BOOL
        if op == TOK_GT_EQ: return TYPE_BOOL
        if op == TOK_KW_AND: return TYPE_BOOL
        if op == TOK_KW_OR: return TYPE_BOOL
        # String concat: if left is text
        if op == TOK_PLUS:
            val left_type = cg_infer_expr_type(expr_get_left(idx))
            if left_type == TYPE_TEXT:
                return TYPE_TEXT
        # Arithmetic inherits from operands
        val left_type = cg_infer_expr_type(expr_get_left(idx))
        if left_type == TYPE_F64:
            return TYPE_F64
        return TYPE_I64
    if tag == EXPR_UNARY:
        val op = expr_get_int(idx)
        if op == TOK_KW_NOT:
            return TYPE_BOOL
        return cg_infer_expr_type(expr_get_left(idx))
    if tag == EXPR_FIELD_ACCESS:
        # Try to look up struct field type
        val fa_base = expr_get_left(idx)
        val fa_field = expr_get_str(idx)
        if expr_get_tag(fa_base) == EXPR_IDENT:
            val fa_var = expr_get_str(fa_base)
            val fa_sname = st_find(fa_var)
            if fa_sname != "":
                val fa_nid = named_type_find(fa_sname)
                if fa_nid >= 0:
                    val fa_fields = named_type_fields(fa_nid)
                    val fa_ftypes = named_type_field_type_tags(fa_nid)
                    for fa_i in range(0, fa_fields.len()):
                        if fa_fields[fa_i] == fa_field:
                            return fa_ftypes[fa_i]
        return TYPE_I64
    if tag == EXPR_METHOD_CALL:
        val method_name = expr_get_str(idx)
        if method_name == "len":
            return TYPE_I64
        if method_name == "contains":
            return TYPE_BOOL
        if method_name == "starts_with":
            return TYPE_BOOL
        if method_name == "ends_with":
            return TYPE_BOOL
        if method_name == "index_of":
            return TYPE_I64
        if method_name == "replace":
            return TYPE_TEXT
        if method_name == "trim":
            return TYPE_TEXT
        if method_name == "slice":
            return TYPE_TEXT
        # Look up struct method return type
        val mc_recv = expr_get_left(idx)
        if expr_get_tag(mc_recv) == EXPR_IDENT:
            val mc_recv_name = expr_get_str(mc_recv)
            val mc_sname = st_find(mc_recv_name)
            if mc_sname != "":
                val mc_mangled = mc_sname + "__" + method_name
                val mc_sig = fn_sig_find(mc_mangled)
                if mc_sig >= 0:
                    return fn_sig_ret_type(mc_sig)
            # Check static method call: Point.origin()
            val mc_type_id = named_type_find(mc_recv_name)
            if mc_type_id >= 0:
                val mc_mangled2 = mc_recv_name + "__" + method_name
                val mc_sig2 = fn_sig_find(mc_mangled2)
                if mc_sig2 >= 0:
                    return fn_sig_ret_type(mc_sig2)
        return TYPE_I64
    if tag == EXPR_INDEX:
        val base_idx = expr_get_left(idx)
        val base_type = cg_infer_expr_type(base_idx)
        if base_type == TYPE_ARRAY_TEXT:
            return TYPE_TEXT
        if base_type == TYPE_ARRAY_BOOL:
            return TYPE_BOOL
        if base_type == TYPE_ARRAY_ANY:
            return TYPE_ARRAY_I64
        return TYPE_I64
    if tag == EXPR_ARRAY_LIT:
        return TYPE_ARRAY_I64
    if tag == EXPR_RANGE:
        return TYPE_I64
    if tag == EXPR_SLICE:
        return TYPE_TEXT
    # Default
    TYPE_I64

# ===== Type-Aware SplValue Wrapping =====

fn cg_spl_wrap(value_c: text, value_type: i64) -> text:
    # Wrap a C++ value in the appropriate SplValue constructor
    if value_type == TYPE_TEXT:
        return "spl_str(" + value_c + ")"
    if value_type == TYPE_ARRAY_I64:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_ARRAY_TEXT:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_ARRAY_BOOL:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_ARRAY_ANY:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_F64:
        return "spl_float(" + value_c + ")"
    if value_type == TYPE_BOOL:
        return "spl_bool(" + value_c + ")"
    "spl_int(" + value_c + ")"

fn cg_spl_access(array_type: i64) -> text:
    # Return the appropriate SplValue accessor for array element type
    if array_type == TYPE_ARRAY_TEXT:
        return ".as_str"
    if array_type == TYPE_ARRAY_ANY:
        return ".as_array"
    ".as_int"

# ===== C++ String Escaping =====

fn cg_escape_string(s: text) -> text:
    # Use replace chain instead of character iteration
    # (character indexing on strings generates wrong types in seed)
    var r0: text = s.replace("\\", "\\\\")
    var r1: text = r0.replace("\"", "\\\"")
    var r2: text = r1.replace(NL, "\\n")
    var r3: text = r2.replace("\t", "\\t")
    var r4: text = r3.replace("\r", "\\r")
    var r5: text = r4.replace("\0", "\\0")
    r5

# ===== Binary Operator to C++ =====

fn cg_binop_to_c(op: i64) -> text:
    if op == TOK_PLUS: return "+"
    if op == TOK_MINUS: return "-"
    if op == TOK_STAR: return "*"
    if op == TOK_SLASH: return "/"
    if op == TOK_PERCENT: return "%"
    if op == TOK_EQ: return "=="
    if op == TOK_NOT_EQ: return "!="
    if op == TOK_LT: return "<"
    if op == TOK_GT: return ">"
    if op == TOK_LT_EQ: return "<="
    if op == TOK_GT_EQ: return ">="
    if op == TOK_KW_AND: return "&&"
    if op == TOK_KW_OR: return "||"
    if op == TOK_AMPERSAND: return "&"
    if op == TOK_PIPE: return "|"
    if op == TOK_CARET: return "^"
    "/* unknown_op */"

fn cg_compound_op_to_c(op: i64) -> text:
    if op == TOK_PLUS_EQ: return "+="
    if op == TOK_MINUS_EQ: return "-="
    if op == TOK_STAR_EQ: return "*="
    if op == TOK_SLASH_EQ: return "/="
    if op == TOK_PERCENT_EQ: return "%="
    "/* unknown_compound_op */"

# ===== Expression Codegen =====

fn cg_expr(idx: i64) -> text:
    val tag = expr_get_tag(idx)

    if tag == EXPR_INT_LIT:
        val v = expr_get_int(idx)
        return int_to_str(v)

    if tag == EXPR_FLOAT_LIT:
        return expr_get_float(idx)

    if tag == EXPR_STRING_LIT:
        val raw = expr_get_str(idx)
        val escaped = cg_escape_string(raw)
        return "\"" + escaped + "\""

    if tag == EXPR_BOOL_LIT:
        val v = expr_get_int(idx)
        if v != 0:
            return "true"
        return "false"

    if tag == EXPR_NIL_LIT:
        return "SplValue{}"

    if tag == EXPR_UNIT:
        return "/* unit */"

    if tag == EXPR_PASS:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* pass */"
        return "/* pass: " + msg + " */"

    if tag == EXPR_PASS_TODO:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* TODO */"
        return "/* TODO: " + msg + " */"

    if tag == EXPR_PASS_DO_NOTHING:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* intentional no-op */"
        return "/* no-op: " + msg + " */"

    if tag == EXPR_PASS_DN:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* intentional no-op */"
        return "/* no-op: " + msg + " */"

    if tag == EXPR_IDENT:
        return expr_get_str(idx)

    if tag == EXPR_BINARY:
        return cg_binary_expr(idx)

    if tag == EXPR_UNARY:
        return cg_unary_expr(idx)

    if tag == EXPR_CALL:
        return cg_call_expr(idx)

    if tag == EXPR_INDEX:
        return cg_index_expr(idx)

    if tag == EXPR_FIELD_ACCESS:
        return cg_field_access_expr(idx)

    if tag == EXPR_METHOD_CALL:
        return cg_method_call_expr(idx)

    if tag == EXPR_ARRAY_LIT:
        return cg_array_lit_expr(idx)

    if tag == EXPR_DICT_LIT:
        return cg_dict_lit_expr(idx)

    if tag == EXPR_STRUCT_LIT:
        return cg_struct_lit_expr(idx)

    if tag == EXPR_IF:
        return cg_if_expr(idx)

    if tag == EXPR_RETURN:
        val left = expr_get_left(idx)
        if left >= 0:
            return "return " + cg_expr(left)
        return "return"

    if tag == EXPR_BREAK:
        return "break"

    if tag == EXPR_CONTINUE:
        return "continue"

    if tag == EXPR_RANGE:
        return cg_range_expr(idx)

    if tag == EXPR_ASSIGN:
        val assign_left = expr_get_left(idx)
        val assign_right = expr_get_right(idx)
        val left_tag = expr_get_tag(assign_left)
        if left_tag == EXPR_INDEX:
            # Array element assignment: arr[i] = value -> spl_array_set(arr, i, wrapped(value))
            val a_base = expr_get_left(assign_left)
            val a_index = expr_get_right(assign_left)
            val a_base_c = cg_expr(a_base)
            val a_index_c = cg_expr(a_index)
            val a_value_c = cg_expr(assign_right)
            val a_val_type = cg_infer_expr_type(assign_right)
            # Also check the array's element type for better inference
            if expr_get_tag(a_base) == EXPR_IDENT:
                val arr_name = expr_get_str(a_base)
                val arr_type = vt_find(arr_name)
                if arr_type == TYPE_ARRAY_TEXT:
                    return "spl_array_set(" + a_base_c + ", " + a_index_c + ", spl_str(" + a_value_c + "))"
                if arr_type == TYPE_ARRAY_ANY:
                    return "spl_array_set(" + a_base_c + ", " + a_index_c + ", spl_array_val(" + a_value_c + "))"
            val a_wrapped = cg_spl_wrap(a_value_c, a_val_type)
            return "spl_array_set(" + a_base_c + ", " + a_index_c + ", " + a_wrapped + ")"
        val target = cg_expr(assign_left)
        val value = cg_expr(assign_right)
        return target + " = " + value

    if tag == EXPR_COMPOUND_ASSIGN:
        val op = expr_get_int(idx)
        val target = cg_expr(expr_get_left(idx))
        val value = cg_expr(expr_get_right(idx))
        return target + " " + cg_compound_op_to_c(op) + " " + value

    if tag == EXPR_INTERPOLATED_STRING:
        return cg_interpolated_string_expr(idx)

    if tag == EXPR_SLICE:
        return cg_slice_expr(idx)

    if tag == EXPR_NULL_COALESCE:
        val left_c = cg_expr(expr_get_left(idx))
        val right_c = cg_expr(expr_get_right(idx))
        return "(" + left_c + ".has_value ? " + left_c + ".value : " + right_c + ")"

    if tag == EXPR_CAST:
        val src = cg_expr(expr_get_left(idx))
        val target_type = expr_get_int(idx)
        val c_type = type_tag_to_c(target_type)
        return "((" + c_type + ")(" + src + "))"

    if tag == EXPR_BLOCK:
        return cg_block_expr(idx)

    if tag == EXPR_FOR:
        return cg_for_expr(idx)

    if tag == EXPR_WHILE:
        return cg_while_expr(idx)

    if tag == EXPR_MATCH:
        return cg_match_expr(idx)

    # Fallback
    return "/* unhandled_expr */"

# ===== Binary Expression =====

fn cg_binary_expr(idx: i64) -> text:
    val op = expr_get_int(idx)
    val left_idx = expr_get_left(idx)
    val right_idx = expr_get_right(idx)

    # Handle nil comparison: expr == nil or expr != nil
    val right_tag = expr_get_tag(right_idx)
    if right_tag == EXPR_NIL_LIT:
        val left_c2 = cg_expr(left_idx)
        val left_type = cg_infer_expr_type(left_idx)
        if left_type == TYPE_TEXT:
            if op == TOK_EQ: return "(" + left_c2 + " == nullptr)"
            if op == TOK_NOT_EQ: return "(" + left_c2 + " != nullptr)"
        if left_type == TYPE_I64:
            if op == TOK_EQ: return "(" + left_c2 + " == -1)"
            if op == TOK_NOT_EQ: return "(" + left_c2 + " != -1)"
        if is_array_type(left_type):
            if op == TOK_EQ: return "(" + left_c2 + " == nullptr)"
            if op == TOK_NOT_EQ: return "(" + left_c2 + " != nullptr)"

    val left_c = cg_expr(left_idx)
    val right_c = cg_expr(right_idx)

    # String concatenation: text + text -> spl_str_concat
    val left_tag = expr_get_tag(left_idx)
    val is_left_str = left_tag == EXPR_STRING_LIT
    if is_left_str:
        if op == TOK_PLUS:
            return "spl_str_concat(" + left_c + ", " + right_c + ")"

    # Check if left is a known text variable
    if left_tag == EXPR_IDENT:
        val left_name = expr_get_str(left_idx)
        val left_type = vt_find(left_name)
        if left_type == TYPE_TEXT:
            if op == TOK_PLUS:
                return "spl_str_concat(" + left_c + ", " + right_c + ")"
            if op == TOK_EQ:
                return "spl_str_eq(" + left_c + ", " + right_c + ")"
            if op == TOK_NOT_EQ:
                return "(!spl_str_eq(" + left_c + ", " + right_c + "))"

    # String literal equality
    if is_left_str:
        if op == TOK_EQ:
            return "spl_str_eq(" + left_c + ", " + right_c + ")"
        if op == TOK_NOT_EQ:
            return "(!spl_str_eq(" + left_c + ", " + right_c + "))"

    # General text concat/compare: infer left type for expressions like spl_str_concat(a,b) + c
    if op == TOK_PLUS:
        val left_inferred = cg_infer_expr_type(left_idx)
        if left_inferred == TYPE_TEXT:
            return "spl_str_concat(" + left_c + ", " + right_c + ")"
    if op == TOK_EQ:
        val left_inferred2 = cg_infer_expr_type(left_idx)
        if left_inferred2 == TYPE_TEXT:
            return "spl_str_eq(" + left_c + ", " + right_c + ")"
    if op == TOK_NOT_EQ:
        val left_inferred3 = cg_infer_expr_type(left_idx)
        if left_inferred3 == TYPE_TEXT:
            return "(!spl_str_eq(" + left_c + ", " + right_c + "))"

    # Power operator -> pow()
    if op == TOK_STAR_STAR:
        return "pow(" + left_c + ", " + right_c + ")"

    val c_op = cg_binop_to_c(op)
    return "(" + left_c + " " + c_op + " " + right_c + ")"

# ===== Unary Expression =====

fn cg_unary_expr(idx: i64) -> text:
    val op = expr_get_int(idx)
    val operand = cg_expr(expr_get_left(idx))
    if op == TOK_MINUS:
        return "(-" + operand + ")"
    if op == TOK_KW_NOT:
        return "(!" + operand + ")"
    if op == TOK_TILDE:
        return "(~" + operand + ")"
    return "(/* unknown_unary */" + operand + ")"

# ===== Function Call Expression =====

fn cg_call_expr(idx: i64) -> text:
    val callee_idx = expr_get_left(idx)
    val call_args = expr_get_args(idx)
    val callee_tag = expr_get_tag(callee_idx)

    var callee_name: text = ""
    if callee_tag == EXPR_IDENT:
        callee_name = expr_get_str(callee_idx)

    # Built-in function mapping
    if callee_name == "print":
        return cg_print_call(call_args)

    if callee_name == "range":
        return cg_range_call(call_args)

    if callee_name == "int":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            val arg_type = cg_infer_expr_type(call_args[0])
            if arg_type == TYPE_TEXT:
                return "atoll(" + arg_c + ")"
            return "((int64_t)(" + arg_c + "))"

    if callee_name == "float":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "((double)(" + arg_c + "))"

    if callee_name == "str":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_i64_to_str(" + arg_c + ")"

    if callee_name == "int_to_str":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_to_str(" + arg_c + ")"

    # Option/Result constructors
    if callee_name == "Some":
        if call_args.len() > 0:
            val some_arg = cg_expr(call_args[0])
            val some_type = cg_infer_expr_type(call_args[0])
            val wrapped = cg_spl_wrap(some_arg, some_type)
            return "SplSome(" + wrapped + ")"
        return "SplSome(spl_int(0))"
    if callee_name == "None":
        return "SplNone()"
    if callee_name == "Ok":
        if call_args.len() > 0:
            val ok_arg = cg_expr(call_args[0])
            return "Ok(" + ok_arg + ")"
        return "Ok()"
    if callee_name == "Err":
        if call_args.len() > 0:
            val err_arg = cg_expr(call_args[0])
            return "Err(" + err_arg + ")"
        return "Err(\"\")"

    # Check if callee is a struct constructor
    if callee_name != "":
        val struct_id = named_type_find(callee_name)
        if struct_id >= 0:
            return cg_struct_construct(callee_name, call_args)

    # General function call
    val callee_c = cg_expr(callee_idx)
    var args_c: text = ""
    for i in range(0, call_args.len()):
        if i > 0:
            args_c = args_c + ", "
        args_c = args_c + cg_expr(call_args[i])
    return callee_c + "(" + args_c + ")"

fn cg_print_call(call_args: [i64]) -> text:
    if call_args.len() == 0:
        return "spl_println(\"\")"
    val arg_idx = call_args[0]
    val arg_tag = expr_get_tag(arg_idx)
    val arg_c = cg_expr(arg_idx)

    # String literal or text variable -> spl_println
    if arg_tag == EXPR_STRING_LIT:
        return "spl_println(" + arg_c + ")"
    if arg_tag == EXPR_INTERPOLATED_STRING:
        return "spl_println(" + arg_c + ")"

    # Check if known text variable
    if arg_tag == EXPR_IDENT:
        val name = expr_get_str(arg_idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return "spl_println(" + arg_c + ")"
        if vtype == TYPE_F64:
            return "printf(\"%g\\n\", " + arg_c + ")"
        if vtype == TYPE_BOOL:
            return "printf(\"%s\\n\", " + arg_c + " ? \"true\" : \"false\")"

    # Infer type for complex expressions (binary ops, function calls, etc.)
    val inferred = cg_infer_expr_type(arg_idx)
    if inferred == TYPE_TEXT:
        return "spl_println(" + arg_c + ")"
    if inferred == TYPE_F64:
        return "printf(\"%g\\n\", " + arg_c + ")"
    if inferred == TYPE_BOOL:
        return "printf(\"%s\\n\", " + arg_c + " ? \"true\" : \"false\")"

    # Default: assume integer
    return "printf(\"%lld\\n\", (long long)" + arg_c + ")"

fn cg_range_call(call_args: [i64]) -> text:
    # range() is handled at the for-loop level, not as a standalone call
    return "/* range */"

# ===== Struct Construction =====

fn cg_struct_construct(struct_name: text, call_args: [i64]) -> text:
    # Named field construction: StructName(field: value, ...)
    # For seed compat, use C99/C++ brace initialization
    var result: text = struct_name + "{"
    for i in range(0, call_args.len()):
        if i > 0:
            result = result + ", "
        result = result + cg_expr(call_args[i])
    result = result + "}"
    result

# ===== Struct Literal Expression =====

fn cg_struct_lit_expr(idx: i64) -> text:
    val type_name = expr_get_str(idx)
    val field_name_indices = expr_get_args(idx)
    val field_value_indices = expr_get_stmts(idx)
    # Use brace initialization (field order must match struct declaration)
    var result: text = type_name + "{"
    for i in range(0, field_value_indices.len()):
        if i > 0:
            result = result + ", "
        result = result + cg_expr(field_value_indices[i])
    result = result + "}"
    result

# ===== Index Expression =====

fn cg_index_expr(idx: i64) -> text:
    val base_idx = expr_get_left(idx)
    val index_idx = expr_get_right(idx)
    val base_c = cg_expr(base_idx)
    val index_c = cg_expr(index_idx)

    # Check if base is a text variable -> spl_str_index_char
    if expr_get_tag(base_idx) == EXPR_IDENT:
        val name = expr_get_str(base_idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return "spl_str_index_char(" + base_c + ", " + index_c + ")"
        # Check if struct array
        val sa = sa_find(name)
        if sa != "":
            return base_c + "[" + index_c + "]"
        if is_array_type(vtype):
            val accessor = cg_spl_access(vtype)
            return "spl_array_get(" + base_c + ", " + index_c + ")" + accessor

    # Fallback: infer type for complex base expressions
    val base_type = cg_infer_expr_type(base_idx)
    if base_type == TYPE_TEXT:
        return "spl_str_index_char(" + base_c + ", " + index_c + ")"

    return base_c + "[" + index_c + "]"

# ===== Field Access Expression =====

fn cg_field_access_expr(idx: i64) -> text:
    val base_idx = expr_get_left(idx)
    val field_name = expr_get_str(idx)
    val base_c = cg_expr(base_idx)
    # self.field -> self->field (self is a pointer in impl methods)
    if base_c == "self":
        return "self->" + field_name
    return base_c + "." + field_name

# ===== Method Call Expression =====

fn cg_method_call_expr(idx: i64) -> text:
    val receiver_idx = expr_get_left(idx)
    val method_name = expr_get_str(idx)
    val call_args = expr_get_args(idx)
    val recv_c = cg_expr(receiver_idx)

    # Built-in string methods
    if method_name == "len":
        return cg_method_len(receiver_idx, recv_c)
    if method_name == "push":
        return cg_method_push(receiver_idx, recv_c, call_args)
    if method_name == "pop":
        return cg_method_pop(receiver_idx, recv_c)
    if method_name == "contains":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            # Check receiver type - array uses spl_array_contains_str
            if expr_get_tag(receiver_idx) == EXPR_IDENT:
                val contains_name = expr_get_str(receiver_idx)
                val contains_type = vt_find(contains_name)
                if is_array_type(contains_type):
                    return "spl_array_contains_str(" + recv_c + ", " + arg_c + ")"
            val contains_inferred = cg_infer_expr_type(receiver_idx)
            if is_array_type(contains_inferred):
                return "spl_array_contains_str(" + recv_c + ", " + arg_c + ")"
            return "spl_str_contains(" + recv_c + ", " + arg_c + ")"
    if method_name == "starts_with":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_starts_with(" + recv_c + ", " + arg_c + ")"
    if method_name == "ends_with":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_ends_with(" + recv_c + ", " + arg_c + ")"
    if method_name == "index_of":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_index_of(" + recv_c + ", " + arg_c + ")"
    if method_name == "replace":
        if call_args.len() >= 2:
            val arg1 = cg_expr(call_args[0])
            val arg2 = cg_expr(call_args[1])
            return "spl_str_replace(" + recv_c + ", " + arg1 + ", " + arg2 + ")"
    if method_name == "trim":
        return "spl_str_trim(" + recv_c + ")"
    if method_name == "slice":
        if call_args.len() >= 2:
            val arg1 = cg_expr(call_args[0])
            val arg2 = cg_expr(call_args[1])
            return "spl_str_slice(" + recv_c + ", " + arg1 + ", " + arg2 + ")"

    if method_name == "is_empty":
        val ie_inferred = cg_infer_expr_type(receiver_idx)
        if ie_inferred == TYPE_TEXT:
            return "(spl_str_len(" + recv_c + ") == 0)"
        if is_array_type(ie_inferred):
            return "(spl_array_len(" + recv_c + ") == 0)"
        return "(spl_str_len(" + recv_c + ") == 0)"

    if method_name == "unwrap":
        return "spl_option_unwrap(" + recv_c + ")"

    if method_name == "last_index_of":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_last_index_of(" + recv_c + ", " + arg_c + ")"

    if method_name == "to_upper":
        return "spl_str_to_upper(" + recv_c + ")"
    if method_name == "to_lower":
        return "spl_str_to_lower(" + recv_c + ")"

    if method_name == "split":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_split(" + recv_c + ", " + arg_c + ")"

    if method_name == "join":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_join(" + recv_c + ", " + arg_c + ")"

    # Check if receiver is a known struct instance -> mangled method call
    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val recv_name = expr_get_str(receiver_idx)
        val sn = st_find(recv_name)
        if sn != "":
            var args_c: text = "&" + recv_c
            for i in range(0, call_args.len()):
                args_c = args_c + ", " + cg_expr(call_args[i])
            return sn + "__" + method_name + "(" + args_c + ")"
        # Check if receiver is a struct type name -> static method call
        val type_id = named_type_find(recv_name)
        if type_id >= 0:
            var args_c: text = ""
            for i in range(0, call_args.len()):
                if i > 0:
                    args_c = args_c + ", "
                args_c = args_c + cg_expr(call_args[i])
            return recv_name + "__" + method_name + "(" + args_c + ")"

    # Generic method call -> mangled name guess
    var args_c: text = ""
    for i in range(0, call_args.len()):
        if i > 0:
            args_c = args_c + ", "
        args_c = args_c + cg_expr(call_args[i])
    return recv_c + "." + method_name + "(" + args_c + ")"

fn cg_method_len(receiver_idx: i64, recv_c: text) -> text:
    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val name = expr_get_str(receiver_idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return "spl_str_len(" + recv_c + ")"
        val sa = sa_find(name)
        if sa != "":
            return "(int64_t)" + recv_c + ".size()"
        if is_array_type(vtype):
            return "spl_array_len(" + recv_c + ")"
    # Fallback: infer type for non-identifier receivers (e.g. self.field)
    val len_inferred = cg_infer_expr_type(receiver_idx)
    if len_inferred == TYPE_TEXT:
        return "spl_str_len(" + recv_c + ")"
    if is_array_type(len_inferred):
        return "spl_array_len(" + recv_c + ")"
    # Default: assume array
    return "spl_array_len(" + recv_c + ")"

fn cg_method_push(receiver_idx: i64, recv_c: text, call_args: [i64]) -> text:
    if call_args.len() == 0:
        return recv_c + ".push(/* missing arg */)"
    val arg_c = cg_expr(call_args[0])

    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val name = expr_get_str(receiver_idx)
        val sa = sa_find(name)
        if sa != "":
            return recv_c + ".push_back(" + arg_c + ")"
        # Type-aware SplArray push
        val arr_type = vt_find(name)
        if arr_type == TYPE_ARRAY_TEXT:
            return "spl_array_push(" + recv_c + ", spl_str(" + arg_c + "))"
        if arr_type == TYPE_ARRAY_ANY:
            return "spl_array_push(" + recv_c + ", spl_array_val(" + arg_c + "))"
        # Infer from argument type as fallback
        val arg_type = cg_infer_expr_type(call_args[0])
        val wrapped = cg_spl_wrap(arg_c, arg_type)
        return "spl_array_push(" + recv_c + ", " + wrapped + ")"
    # Unknown receiver: infer from argument type
    val arg_type2 = cg_infer_expr_type(call_args[0])
    val wrapped2 = cg_spl_wrap(arg_c, arg_type2)
    return "spl_array_push(" + recv_c + ", " + wrapped2 + ")"

fn cg_method_pop(receiver_idx: i64, recv_c: text) -> text:
    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val name = expr_get_str(receiver_idx)
        val arr_type = vt_find(name)
        val accessor = cg_spl_access(arr_type)
        return "spl_array_pop(" + recv_c + ")" + accessor
    return "spl_array_pop(" + recv_c + ").as_int"

# ===== Array Literal Expression =====

fn cg_array_lit_expr(idx: i64) -> text:
    val elements = expr_get_args(idx)
    if elements.len() == 0:
        return "spl_array_new()"
    # Use inline init helper — infer element type from first element
    var result: text = "({SplArray* __arr = spl_array_new();"
    for i in range(0, elements.len()):
        val elem_c = cg_expr(elements[i])
        val elem_type = cg_infer_expr_type(elements[i])
        val wrapped = cg_spl_wrap(elem_c, elem_type)
        result = result + " spl_array_push(__arr, " + wrapped + ");"
    result = result + " __arr;})"
    result

fn cg_dict_lit_expr(idx: i64) -> text:
    val keys = expr_get_args(idx)
    val values = expr_get_stmts(idx)
    if keys.len() == 0:
        return "spl_dict_new()"
    # Use inline init helper
    var result: text = "({SplDict* __dict = spl_dict_new();"
    for i in range(0, keys.len()):
        val key_c = cg_expr(keys[i])
        val val_c = cg_expr(values[i])
        val val_type = cg_infer_expr_type(values[i])
        val wrapped = cg_spl_wrap(val_c, val_type)
        result = result + " spl_dict_set(__dict, " + key_c + ", " + wrapped + ");"
    result = result + " __dict;})"
    result

# ===== If Expression =====

fn cg_if_expr(idx: i64) -> text:
    val cond = cg_expr(expr_get_left(idx))
    val then_idx = expr_get_right(idx)
    val else_idx = expr_get_extra(idx)
    val then_c = cg_expr(then_idx)
    if else_idx >= 0:
        val else_c = cg_expr(else_idx)
        return "(" + cond + " ? " + then_c + " : " + else_c + ")"
    return "(" + cond + " ? " + then_c + " : SplValue{})"

# ===== Module-level If as Statement =====

fn cg_emit_if_as_stmt(idx: i64):
    val cond_c = cg_expr(expr_get_left(idx))
    cg_emit_line("if (" + cond_c + ") {")
    cg_indent = cg_indent + 1
    val then_block = expr_get_right(idx)
    val then_stmts = expr_get_stmts(then_block)
    for i in range(0, then_stmts.len()):
        cg_stmt(then_stmts[i])
    cg_indent = cg_indent - 1
    val else_block = expr_get_extra(idx)
    val else_tag = expr_get_tag(else_block)
    if else_tag == EXPR_BLOCK:
        val else_stmts = expr_get_stmts(else_block)
        if else_stmts.len() > 0:
            cg_emit_line("} else {")
            cg_indent = cg_indent + 1
            for i in range(0, else_stmts.len()):
                cg_stmt(else_stmts[i])
            cg_indent = cg_indent - 1
    cg_emit_line("}")

# ===== Range Expression =====

fn cg_range_expr(idx: i64) -> text:
    # Range is typically used in for loops, not as standalone expression
    val start = cg_expr(expr_get_left(idx))
    val end_val = cg_expr(expr_get_right(idx))
    return "/* range(" + start + ", " + end_val + ") */"

# ===== Interpolated String Expression =====

fn cg_interpolated_string_expr(idx: i64) -> text:
    val parts = expr_get_args(idx)
    if parts.len() == 0:
        return "\"\""
    if parts.len() == 1:
        val part_tag = expr_get_tag(parts[0])
        if part_tag == EXPR_STRING_LIT:
            return cg_expr(parts[0])
        return "spl_i64_to_str(" + cg_expr(parts[0]) + ")"

    # Build spl_str_concat chain
    var result: text = cg_interpolated_part(parts[0])
    for i in range(1, parts.len()):
        val part_c = cg_interpolated_part(parts[i])
        result = "spl_str_concat(" + result + ", " + part_c + ")"
    result

fn cg_interpolated_part(idx: i64) -> text:
    val tag = expr_get_tag(idx)
    if tag == EXPR_STRING_LIT:
        return cg_expr(idx)
    # Non-string part: convert to string
    val part_c = cg_expr(idx)
    # Check if it's a known text variable
    if tag == EXPR_IDENT:
        val name = expr_get_str(idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return part_c
        if vtype == TYPE_BOOL:
            return "(" + part_c + " ? \"true\" : \"false\")"
        if vtype == TYPE_F64:
            return "spl_f64_to_str(" + part_c + ")"
    return "spl_i64_to_str(" + part_c + ")"

# ===== Slice Expression =====

fn cg_slice_expr(idx: i64) -> text:
    val base = cg_expr(expr_get_left(idx))
    val start = cg_expr(expr_get_right(idx))
    val end_val = cg_expr(expr_get_extra(idx))
    return "spl_str_slice(" + base + ", " + start + ", " + end_val + ")"

# ===== Block Expression =====

fn cg_block_expr(idx: i64) -> text:
    val body_stmts = expr_get_stmts(idx)
    val value_idx = expr_get_left(idx)
    # Use GCC statement expression ({...})
    var result: text = "({"
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    if value_idx >= 0:
        result = result + cg_expr(value_idx) + ";"
    result = result + "})"
    result

# ===== For Expression (for codegen in expression context) =====

fn cg_for_expr(idx: i64) -> text:
    # For in expression context is unusual; emit as statement
    return "/* for_expr */"

fn cg_emit_for_as_stmt(idx: i64):
    val iter_name = expr_get_str(idx)
    val iterable = expr_get_left(idx)
    val body_stmts = expr_get_stmts(idx)
    val iter_tag = expr_get_tag(iterable)
    vt_push_scope()
    vt_add(iter_name, TYPE_I64)
    # range(start, end) pattern
    if iter_tag == EXPR_CALL:
        val callee_idx = expr_get_left(iterable)
        if expr_get_tag(callee_idx) == EXPR_IDENT:
            val callee_name = expr_get_str(callee_idx)
            if callee_name == "range":
                val range_args = expr_get_args(iterable)
                if range_args.len() == 2:
                    val start_c = cg_expr(range_args[0])
                    val end_c = cg_expr(range_args[1])
                    cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent = cg_indent + 1
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    vt_pop_scope()
                    return
                if range_args.len() == 1:
                    val end_c = cg_expr(range_args[0])
                    cg_emit_line("for (int64_t " + iter_name + " = 0; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent = cg_indent + 1
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    vt_pop_scope()
                    return
    # Range expression: for i in start..end
    if iter_tag == EXPR_RANGE:
        val start_c = cg_expr(expr_get_left(iterable))
        val end_c = cg_expr(expr_get_right(iterable))
        val inclusive = expr_get_int(iterable)
        var cmp: text = "<"
        if inclusive != 0:
            cmp = "<="
        cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " " + cmp + " " + end_c + "; " + iter_name + "++) {")
        cg_indent = cg_indent + 1
        for i in range(0, body_stmts.len()):
            cg_stmt(body_stmts[i])
        cg_indent = cg_indent - 1
        cg_emit_line("}")
        vt_pop_scope()
        return
    # Array iteration fallback
    val iter_c = cg_expr(iterable)
    cg_emit_line("for (int64_t __" + iter_name + "_i = 0; __" + iter_name + "_i < spl_array_len(" + iter_c + "); __" + iter_name + "_i++) {")
    cg_indent = cg_indent + 1
    cg_emit_line("int64_t " + iter_name + " = spl_array_get(" + iter_c + ", __" + iter_name + "_i).as_int;")
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent = cg_indent - 1
    cg_emit_line("}")
    vt_pop_scope()

# ===== While Expression =====

fn cg_while_expr(idx: i64) -> text:
    return "/* while_expr */"

fn cg_emit_while_as_stmt(idx: i64):
    val cond = expr_get_left(idx)
    val body_stmts = expr_get_stmts(idx)
    val cond_c = cg_expr(cond)
    cg_emit_line("while (" + cond_c + ") {")
    cg_indent = cg_indent + 1
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent = cg_indent - 1
    cg_emit_line("}")

# ===== Match Expression =====

fn cg_match_expr(idx: i64) -> text:
    return "/* match_expr */"

# ===== Statement Codegen =====

fn cg_stmt(idx: i64):
    val tag = stmt_get_tag(idx)

    if tag == STMT_EXPR:
        val e = stmt_get_expr(idx)
        if e >= 0:
            cg_emit_line(cg_expr(e) + ";")
        return

    if tag == STMT_VAL_DECL:
        cg_val_decl_stmt(idx)
        return

    if tag == STMT_VAR_DECL:
        cg_var_decl_stmt(idx)
        return

    if tag == STMT_ASSIGN:
        cg_assign_stmt(idx)
        return

    if tag == STMT_RETURN:
        val e = stmt_get_expr(idx)
        if e >= 0:
            cg_emit_line("return " + cg_expr(e) + ";")
        else:
            cg_emit_line("return;")
        return

    if tag == STMT_IF:
        cg_if_stmt(idx)
        return

    if tag == STMT_FOR:
        cg_for_stmt(idx)
        return

    if tag == STMT_WHILE:
        cg_while_stmt(idx)
        return

    if tag == STMT_MATCH:
        cg_match_stmt(idx)
        return

    if tag == STMT_BLOCK:
        cg_block_stmt(idx)
        return

    if tag == STMT_BREAK:
        cg_emit_line("break;")
        return

    if tag == STMT_CONTINUE:
        cg_emit_line("continue;")
        return

    if tag == STMT_COMPOUND_ASSIGN:
        cg_compound_assign_stmt(idx)
        return

    cg_emit_line("/* unhandled_stmt */")

# ===== Variable Declaration Statements =====

fn cg_val_decl_stmt(idx: i64):
    val name = stmt_get_name(idx)
    var type_tag = stmt_get_type(idx)
    val init_expr = stmt_get_expr(idx)

    # Infer type if not explicitly annotated
    if type_tag == TYPE_VOID:
        if init_expr >= 0:
            type_tag = cg_infer_expr_type(init_expr)
    val c_type = type_tag_to_c(type_tag)

    # Track variable type
    vt_add(name, type_tag)

    if is_array_type(type_tag):
        cg_emit_array_init(name, type_tag, init_expr, true)
        return

    if init_expr >= 0:
        val init_c = cg_expr(init_expr)
        # Check if init is a struct literal
        val init_tag = expr_get_tag(init_expr)
        if init_tag == EXPR_STRUCT_LIT:
            val sname = expr_get_str(init_expr)
            st_add(name, sname)
            cg_emit_line(sname + " " + name + " = " + init_c + ";")
            return
        # Check if init is a struct constructor call: val a = Dog()
        if init_tag == EXPR_CALL:
            val callee = expr_get_left(init_expr)
            if expr_get_tag(callee) == EXPR_IDENT:
                val cn = expr_get_str(callee)
                val sid = named_type_find(cn)
                if sid >= 0:
                    st_add(name, cn)
                    cg_emit_line(cn + " " + name + " = " + init_c + ";")
                    return
        # Check if inferred type is a named struct type
        if type_tag >= TYPE_NAMED_BASE:
            val nid = type_tag - TYPE_NAMED_BASE
            val sname = named_type_name(nid)
            if sname != "":
                st_add(name, sname)
                cg_emit_line(sname + " " + name + " = " + init_c + ";")
                return
        # Skip const prefix for TYPE_TEXT (already const char*)
        var prefix: text = "const "
        if type_tag == TYPE_TEXT:
            prefix = ""
        cg_emit_line(prefix + c_type + " " + name + " = " + init_c + ";")
    else:
        var prefix2: text = "const "
        if type_tag == TYPE_TEXT:
            prefix2 = ""
        cg_emit_line(prefix2 + c_type + " " + name + " = {};")

fn cg_var_decl_stmt(idx: i64):
    val name = stmt_get_name(idx)
    var type_tag = stmt_get_type(idx)
    val init_expr = stmt_get_expr(idx)

    # Infer type if not explicitly annotated
    if type_tag == TYPE_VOID:
        if init_expr >= 0:
            type_tag = cg_infer_expr_type(init_expr)
    val c_type = type_tag_to_c(type_tag)

    # Track variable type
    vt_add(name, type_tag)

    if is_array_type(type_tag):
        cg_emit_array_init(name, type_tag, init_expr, false)
        return

    if init_expr >= 0:
        val init_c = cg_expr(init_expr)
        val init_tag = expr_get_tag(init_expr)
        if init_tag == EXPR_STRUCT_LIT:
            val sname = expr_get_str(init_expr)
            st_add(name, sname)
            cg_emit_line(sname + " " + name + " = " + init_c + ";")
            return
        # Check struct constructor call: var a = Dog()
        if init_tag == EXPR_CALL:
            val callee = expr_get_left(init_expr)
            if expr_get_tag(callee) == EXPR_IDENT:
                val cn = expr_get_str(callee)
                val sid = named_type_find(cn)
                if sid >= 0:
                    st_add(name, cn)
                    cg_emit_line(cn + " " + name + " = " + init_c + ";")
                    return
        # Check if inferred type is a named struct type
        if type_tag >= TYPE_NAMED_BASE:
            val nid = type_tag - TYPE_NAMED_BASE
            val sname = named_type_name(nid)
            if sname != "":
                st_add(name, sname)
                cg_emit_line(sname + " " + name + " = " + init_c + ";")
                return
        cg_emit_line(c_type + " " + name + " = " + init_c + ";")
    else:
        cg_emit_line(c_type + " " + name + " = {};")

fn cg_emit_array_init(name: text, type_tag: i64, init_expr: i64, is_const: bool):
    if init_expr >= 0:
        val init_tag = expr_get_tag(init_expr)
        if init_tag == EXPR_ARRAY_LIT:
            val elements = expr_get_args(init_expr)
            cg_emit_line("SplArray* " + name + " = spl_array_new();")
            for i in range(0, elements.len()):
                val elem_c = cg_expr(elements[i])
                # Type-aware element wrapping
                if type_tag == TYPE_ARRAY_TEXT:
                    cg_emit_line("spl_array_push(" + name + ", spl_str(" + elem_c + "));")
                elif type_tag == TYPE_ARRAY_ANY:
                    cg_emit_line("spl_array_push(" + name + ", spl_array_val(" + elem_c + "));")
                else:
                    val elem_type = cg_infer_expr_type(elements[i])
                    val wrapped = cg_spl_wrap(elem_c, elem_type)
                    cg_emit_line("spl_array_push(" + name + ", " + wrapped + ");")
            return
        val init_c = cg_expr(init_expr)
        cg_emit_line("SplArray* " + name + " = " + init_c + ";")
    else:
        cg_emit_line("SplArray* " + name + " = spl_array_new();")

# ===== Assignment Statement =====

fn cg_assign_stmt(idx: i64):
    val target_expr = stmt_get_expr(idx)
    val body = stmt_get_body(idx)
    if body.len() > 0:
        val value_idx = body[0]
        val target_c = cg_expr(target_expr)
        val value_c = cg_expr(value_idx)

        # Check for array element assignment: arr[i] = value
        val target_tag = expr_get_tag(target_expr)
        if target_tag == EXPR_INDEX:
            val base_idx = expr_get_left(target_expr)
            val index_idx = expr_get_right(target_expr)
            val base_c = cg_expr(base_idx)
            val index_c = cg_expr(index_idx)
            cg_emit_line("spl_array_set(" + base_c + ", " + index_c + ", spl_int(" + value_c + "));")
            return

        cg_emit_line(target_c + " = " + value_c + ";")

# ===== Compound Assignment Statement =====

fn cg_compound_assign_stmt(idx: i64):
    val target_expr = stmt_get_expr(idx)
    val op = stmt_get_type(idx)
    val body = stmt_get_body(idx)
    if body.len() > 0:
        val value_idx = body[0]
        val target_c = cg_expr(target_expr)
        val value_c = cg_expr(value_idx)
        val c_op = cg_compound_op_to_c(op)
        cg_emit_line(target_c + " " + c_op + " " + value_c + ";")

# ===== If Statement =====

fn cg_if_stmt(idx: i64):
    val cond_expr = stmt_get_expr(idx)
    val then_body = stmt_get_body(idx)
    val elif_idx = stmt_get_type(idx)

    val cond_c = cg_expr(cond_expr)
    cg_emit_line("if (" + cond_c + ") {")
    cg_indent = cg_indent + 1
    for i in range(0, then_body.len()):
        cg_stmt(then_body[i])
    cg_indent = cg_indent - 1

    # Check for else branch via elif pool
    if elif_idx >= 0:
        val else_body = elif_get_else(elif_idx)
        if else_body.len() > 0:
            cg_emit_line("} else {")
            cg_indent = cg_indent + 1
            for i in range(0, else_body.len()):
                cg_stmt(else_body[i])
            cg_indent = cg_indent - 1
    cg_emit_line("}")

# ===== For Statement =====

fn cg_for_stmt(idx: i64):
    val iter_name = stmt_get_name(idx)
    val iterable = stmt_get_expr(idx)
    val body_stmts = stmt_get_body(idx)

    # Track loop variable
    vt_push_scope()
    vt_add(iter_name, TYPE_I64)

    val iter_tag = expr_get_tag(iterable)

    # range(start, end) pattern
    if iter_tag == EXPR_CALL:
        val callee_idx = expr_get_left(iterable)
        if expr_get_tag(callee_idx) == EXPR_IDENT:
            val callee_name = expr_get_str(callee_idx)
            if callee_name == "range":
                val range_args = expr_get_args(iterable)
                if range_args.len() == 2:
                    val start_c = cg_expr(range_args[0])
                    val end_c = cg_expr(range_args[1])
                    cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent = cg_indent + 1
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    vt_pop_scope()
                    return
                if range_args.len() == 1:
                    val end_c = cg_expr(range_args[0])
                    cg_emit_line("for (int64_t " + iter_name + " = 0; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent = cg_indent + 1
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    vt_pop_scope()
                    return

    # Range expression: for i in start..end
    if iter_tag == EXPR_RANGE:
        val start_c = cg_expr(expr_get_left(iterable))
        val end_c = cg_expr(expr_get_right(iterable))
        val inclusive = expr_get_int(iterable)
        var cmp: text = "<"
        if inclusive != 0:
            cmp = "<="
        cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " " + cmp + " " + end_c + "; " + iter_name + "++) {")
        cg_indent = cg_indent + 1
        for i in range(0, body_stmts.len()):
            cg_stmt(body_stmts[i])
        cg_indent = cg_indent - 1
        cg_emit_line("}")
        vt_pop_scope()
        return

    # Array iteration: for item in array
    val iter_c = cg_expr(iterable)

    # Check if iterating over a struct array
    if iter_tag == EXPR_IDENT:
        val arr_name = expr_get_str(iterable)
        val sa = sa_find(arr_name)
        if sa != "":
            st_add(iter_name, sa)
            cg_emit_line("for (size_t __" + iter_name + "_i = 0; __" + iter_name + "_i < " + iter_c + ".size(); __" + iter_name + "_i++) {")
            cg_indent = cg_indent + 1
            cg_emit_line(sa + " " + iter_name + " = " + iter_c + "[__" + iter_name + "_i];")
            for i in range(0, body_stmts.len()):
                cg_stmt(body_stmts[i])
            cg_indent = cg_indent - 1
            cg_emit_line("}")
            vt_pop_scope()
            return

    # Generic SplArray iteration — type-aware
    var iter_elem_type: text = "int64_t"
    var iter_accessor: text = ".as_int"
    if iter_tag == EXPR_IDENT:
        val iterable_name = expr_get_str(iterable)
        val iterable_type = vt_find(iterable_name)
        if iterable_type == TYPE_ARRAY_TEXT:
            iter_elem_type = "const char*"
            iter_accessor = ".as_str"
            vt_add(iter_name, TYPE_TEXT)
        elif iterable_type == TYPE_ARRAY_ANY:
            iter_elem_type = "SplArray*"
            iter_accessor = ".as_array"

    cg_emit_line("for (int64_t __" + iter_name + "_i = 0; __" + iter_name + "_i < spl_array_len(" + iter_c + "); __" + iter_name + "_i++) {")
    cg_indent = cg_indent + 1
    cg_emit_line(iter_elem_type + " " + iter_name + " = spl_array_get(" + iter_c + ", __" + iter_name + "_i)" + iter_accessor + ";")
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent = cg_indent - 1
    cg_emit_line("}")
    vt_pop_scope()

# ===== While Statement =====

fn cg_while_stmt(idx: i64):
    val cond_expr = stmt_get_expr(idx)
    val body_stmts = stmt_get_body(idx)

    val cond_c = cg_expr(cond_expr)
    cg_emit_line("while (" + cond_c + ") {")
    cg_indent = cg_indent + 1
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent = cg_indent - 1
    cg_emit_line("}")

# ===== Match Statement =====

fn cg_match_stmt(idx: i64):
    val scrutinee = stmt_get_expr(idx)
    val arm_indices = stmt_get_body(idx)

    val scrut_c = cg_expr(scrutinee)
    cg_emit_line("switch (" + scrut_c + ") {")
    cg_indent = cg_indent + 1
    for i in range(0, arm_indices.len()):
        val arm_idx = arm_indices[i]
        val pattern_idx = arm_get_pattern(arm_idx)
        val arm_body = arm_get_body(arm_idx)
        val pat_tag = expr_get_tag(pattern_idx)

        # Wildcard pattern
        if pat_tag == EXPR_IDENT:
            val pat_name = expr_get_str(pattern_idx)
            if pat_name == "_":
                cg_emit_line("default: {")
            else:
                cg_emit_line("case " + cg_expr(pattern_idx) + ": {")
        elif pat_tag == EXPR_INT_LIT:
            cg_emit_line("case " + cg_expr(pattern_idx) + ": {")
        else:
            cg_emit_line("case " + cg_expr(pattern_idx) + ": {")

        cg_indent = cg_indent + 1
        for j in range(0, arm_body.len()):
            cg_stmt(arm_body[j])
        cg_emit_line("break;")
        cg_indent = cg_indent - 1
        cg_emit_line("}")
    cg_indent = cg_indent - 1
    cg_emit_line("}")

# ===== Block Statement =====

fn cg_block_stmt(idx: i64):
    val body_stmts = stmt_get_body(idx)
    cg_emit_line("{")
    cg_indent = cg_indent + 1
    vt_push_scope()
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    vt_pop_scope()
    cg_indent = cg_indent - 1
    cg_emit_line("}")

# ===== Declaration Codegen =====

fn cg_register_pass():
    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)

        if tag == DECL_STRUCT:
            val name = decl_get_name(decl_idx)
            val fields = decl_get_fields(decl_idx)
            val ftypes = decl_get_field_types(decl_idx)
            val existing_id = named_type_find(name)
            if existing_id >= 0:
                named_type_update(existing_id, fields, ftypes)
            else:
                named_type_register(name, fields, ftypes)

        if tag == DECL_FN:
            val name = decl_get_name(decl_idx)
            val ptypes = decl_get_param_types(decl_idx)
            val ret = decl_get_ret_type(decl_idx)
            fn_sig_register(name, decl_get_param_names(decl_idx), ptypes, ret, 0)

        if tag == DECL_EXTERN_FN:
            val name = decl_get_name(decl_idx)
            val ptypes = decl_get_param_types(decl_idx)
            val ret = decl_get_ret_type(decl_idx)
            fn_sig_register(name, decl_get_param_names(decl_idx), ptypes, ret, 1)

        if tag == DECL_IMPL:
            # Register impl method signatures
            val impl_name = decl_get_name(decl_idx)
            val impl_methods = decl_get_body(decl_idx)
            for mi in range(0, impl_methods.len()):
                val m_idx = impl_methods[mi]
                val m_name = decl_get_name(m_idx)
                val m_ptypes = decl_get_param_types(m_idx)
                val m_ret = decl_get_ret_type(m_idx)
                fn_sig_register(m_name, decl_get_param_names(m_idx), m_ptypes, m_ret, 0)

fn cg_emit_preamble():
    val lb = "{"
    val rb = "}"
    cg_emit_line("#include <cstdio>")
    cg_emit_line("#include <cstdlib>")
    cg_emit_line("#include <cstring>")
    cg_emit_line("#include <cstdint>")
    cg_emit_line("#include <cmath>")
    cg_emit_line("#include <vector>")
    cg_emit_blank()
    cg_emit_line("#define asm asm_spl")
    cg_emit_line("#define assert spl_assert")
    cg_emit_line("#define template template_spl")
    cg_emit_line("#define register register_spl")
    cg_emit_blank()
    cg_emit_line("extern \"C\" " + lb)
    cg_emit_line("#include \"runtime.h\"")
    cg_emit_line(rb)
    cg_emit_blank()
    cg_emit_line("static int has_field = 0;")
    cg_emit_line("static int64_t _ = 0;")
    cg_emit_blank()
    # Type aliases
    cg_emit_line("typedef float f32;")
    cg_emit_line("typedef double f64;")
    cg_emit_line("typedef int8_t i8;")
    cg_emit_line("typedef int16_t i16;")
    cg_emit_line("typedef int32_t i32;")
    cg_emit_line("typedef uint8_t u8;")
    cg_emit_line("typedef uint16_t u16;")
    cg_emit_line("typedef uint32_t u32;")
    cg_emit_line("typedef uint64_t u64;")
    cg_emit_blank()
    # spl_to_str overloads
    cg_emit_line("inline const char* spl_to_str(int64_t n) " + lb + " return spl_i64_to_str(n); " + rb)
    cg_emit_line("inline const char* spl_to_str(const char* s) " + lb + " return s; " + rb)
    cg_emit_line("inline const char* spl_to_str(double d) " + lb + " return spl_f64_to_str(d); " + rb)
    cg_emit_blank()
    # SplOption / SplResult
    cg_emit_line("struct SplOption " + lb)
    cg_emit_line("    int has_value;")
    cg_emit_line("    SplValue value;")
    cg_emit_line(rb + ";")
    cg_emit_blank()
    cg_emit_line("struct SplResult " + lb)
    cg_emit_line("    int is_ok;")
    cg_emit_line("    SplValue value;")
    cg_emit_line("    const char* error;")
    cg_emit_line(rb + ";")
    cg_emit_blank()
    # Assert
    cg_emit_line("inline void spl_assert(int cond) " + lb + " if (!cond) " + lb + " fprintf(stderr, \"Assertion failed\\n\"); exit(1); " + rb + " " + rb)
    cg_emit_blank()
    # Ok/Err helpers
    cg_emit_line("inline SplResult* Ok(SplValue v) " + lb + " auto* r = new SplResult; r->is_ok = 1; r->value = v; r->error = \"\"; return r; " + rb)
    cg_emit_line("inline SplResult* Ok() " + lb + " return Ok(spl_int(0)); " + rb)
    cg_emit_line("inline SplResult* Ok(int64_t v) " + lb + " return Ok(spl_int(v)); " + rb)
    cg_emit_line("inline SplResult* Ok(const char* v) " + lb + " return Ok(spl_str(v)); " + rb)
    cg_emit_line("inline SplResult* Ok(double v) " + lb + " return Ok(spl_float(v)); " + rb)
    cg_emit_line("inline SplResult* Err(const char* msg) " + lb + " auto* r = new SplResult; r->is_ok = 0; r->value = " + lb + rb + "; r->error = msg; return r; " + rb)
    cg_emit_line("inline SplValue spl_result_unwrap(SplResult* r) " + lb + " if (r && r->is_ok) return r->value; fprintf(stderr, \"unwrap failed\\n\"); exit(1); " + rb)
    cg_emit_blank()
    # SplSome / SplNone helpers
    cg_emit_line("inline SplOption* SplSome(SplValue v) " + lb + " auto* o = new SplOption; o->has_value = 1; o->value = v; return o; " + rb)
    cg_emit_line("inline SplOption* SplNone() " + lb + " auto* o = new SplOption; o->has_value = 0; o->value = " + lb + rb + "; return o; " + rb)
    cg_emit_line("inline SplValue spl_option_unwrap(SplOption* o) " + lb + " if (o && o->has_value) return o->value; fprintf(stderr, \"unwrap failed\\n\"); exit(1); " + rb)
    cg_emit_blank()
    # C++ overloads for int64_t-based dispatch
    cg_emit_line("inline int64_t spl_array_len(int64_t a) " + lb + " return spl_array_len((SplArray*)(intptr_t)a); " + rb)
    cg_emit_line("inline SplValue spl_array_get(int64_t a, int64_t i) " + lb + " return spl_array_get((SplArray*)(intptr_t)a, i); " + rb)
    cg_emit_line("inline void spl_array_set(int64_t a, int64_t i, SplValue v) " + lb + " spl_array_set((SplArray*)(intptr_t)a, i, v); " + rb)
    cg_emit_line("inline void spl_array_push(int64_t a, SplValue v) " + lb + " spl_array_push((SplArray*)(intptr_t)a, v); " + rb)
    cg_emit_line("inline int spl_str_contains(int64_t s, const char* n) " + lb + " return spl_str_contains((const char*)(intptr_t)s, n); " + rb)
    cg_emit_line("inline void spl_dict_set(int64_t d, const char* k, SplValue v) " + lb + " spl_dict_set((SplDict*)(intptr_t)d, k, v); " + rb)
    cg_emit_line("inline void spl_dict_set(int64_t d, int64_t k, SplValue v) " + lb + " spl_dict_set((SplDict*)(intptr_t)d, (const char*)(intptr_t)k, v); " + rb)
    cg_emit_line("inline SplValue spl_dict_get(int64_t d, const char* k) " + lb + " return spl_dict_get((SplDict*)(intptr_t)d, k); " + rb)
    cg_emit_line("inline int spl_str_eq(int64_t a, const char* b) " + lb + " return spl_str_eq((const char*)(intptr_t)a, b); " + rb)
    cg_emit_line("inline int spl_str_eq(const char* a, int64_t b) " + lb + " return spl_str_eq(a, (const char*)(intptr_t)b); " + rb)
    cg_emit_line("inline int spl_str_eq(int64_t a, int64_t b) " + lb + " return spl_str_eq((const char*)(intptr_t)a, (const char*)(intptr_t)b); " + rb)
    cg_emit_line("inline const char* spl_str_concat(int64_t a, const char* b) " + lb + " return spl_str_concat((const char*)(intptr_t)a, b); " + rb)
    cg_emit_line("inline const char* spl_str_concat(const char* a, int64_t b) " + lb + " return spl_str_concat(a, (const char*)(intptr_t)b); " + rb)
    cg_emit_line("inline const char* spl_str_concat(int64_t a, int64_t b) " + lb + " return spl_str_concat((const char*)(intptr_t)a, (const char*)(intptr_t)b); " + rb)
    cg_emit_line("inline int spl_str_starts_with(int64_t s, const char* p) " + lb + " return spl_str_starts_with((const char*)(intptr_t)s, p); " + rb)
    cg_emit_line("inline int spl_str_starts_with(int64_t s, int64_t p) " + lb + " return spl_str_starts_with((const char*)(intptr_t)s, (const char*)(intptr_t)p); " + rb)
    cg_emit_line("inline int spl_str_ends_with(int64_t s, const char* p) " + lb + " return spl_str_ends_with((const char*)(intptr_t)s, p); " + rb)
    cg_emit_line("inline int spl_str_ends_with(int64_t s, int64_t p) " + lb + " return spl_str_ends_with((const char*)(intptr_t)s, (const char*)(intptr_t)p); " + rb)
    cg_emit_line("inline SplArray* spl_str_split(int64_t s, const char* d) " + lb + " return spl_str_split((const char*)(intptr_t)s, d); " + rb)
    cg_emit_line("inline SplArray* spl_str_split(int64_t s, int64_t d) " + lb + " return spl_str_split((const char*)(intptr_t)s, (const char*)(intptr_t)d); " + rb)
    cg_emit_line("inline char* spl_str_join(int64_t a, const char* d) " + lb + " return spl_str_join((SplArray*)(intptr_t)a, d); " + rb)
    cg_emit_line("inline char* spl_str_join(int64_t a, int64_t d) " + lb + " return spl_str_join((SplArray*)(intptr_t)a, (const char*)(intptr_t)d); " + rb)
    cg_emit_line("inline char* spl_str_join(SplArray* a, int64_t d) " + lb + " return spl_str_join(a, (const char*)(intptr_t)d); " + rb)
    cg_emit_line("inline char* spl_str_slice(int64_t s, int64_t start, int64_t end) " + lb + " return spl_str_slice((const char*)(intptr_t)s, start, end); " + rb)
    cg_emit_line("inline char* spl_str_replace(int64_t s, const char* o, const char* n) " + lb + " return spl_str_replace((const char*)(intptr_t)s, o, n); " + rb)
    cg_emit_line("inline char* spl_str_replace(int64_t s, int64_t o, int64_t n) " + lb + " return spl_str_replace((const char*)(intptr_t)s, (const char*)(intptr_t)o, (const char*)(intptr_t)n); " + rb)
    cg_emit_line("inline char* spl_str_trim(int64_t s) " + lb + " return spl_str_trim((const char*)(intptr_t)s); " + rb)
    cg_emit_line("inline int64_t spl_str_index_of(int64_t s, const char* n) " + lb + " return spl_str_index_of((const char*)(intptr_t)s, n); " + rb)
    cg_emit_line("inline int64_t spl_str_index_of(int64_t s, int64_t n) " + lb + " return spl_str_index_of((const char*)(intptr_t)s, (const char*)(intptr_t)n); " + rb)
    cg_emit_line("inline int64_t spl_str_len(int64_t s) " + lb + " return spl_str_len((const char*)(intptr_t)s); " + rb)
    cg_emit_line("inline char* spl_str_to_upper(int64_t s) " + lb + " return spl_str_to_upper((const char*)(intptr_t)s); " + rb)
    cg_emit_line("inline char* spl_str_to_lower(int64_t s) " + lb + " return spl_str_to_lower((const char*)(intptr_t)s); " + rb)
    cg_emit_line("inline int spl_str_contains(int64_t s, int64_t n) " + lb + " return spl_str_contains((const char*)(intptr_t)s, (const char*)(intptr_t)n); " + rb)
    cg_emit_line("inline int64_t spl_str_last_index_of(int64_t s, const char* n) " + lb + " return spl_str_last_index_of((const char*)(intptr_t)s, n); " + rb)
    cg_emit_line("inline char* spl_str_index_char(int64_t s, int64_t i) " + lb + " return spl_str_index_char((const char*)(intptr_t)s, i); " + rb)
    cg_emit_line("inline const char* spl_to_str(int n) " + lb + " return spl_i64_to_str((int64_t)n); " + rb)
    cg_emit_line("inline const char* spl_to_str(bool b) " + lb + " return b ? \"true\" : \"false\"; " + rb)
    cg_emit_line("inline const char* spl_to_str(SplValue v) " + lb + " return spl_i64_to_str(v.as_int); " + rb)
    cg_emit_line("inline SplResult* Ok(int v) " + lb + " return Ok((int64_t)v); " + rb)
    cg_emit_line("inline SplResult* Ok(bool v) " + lb + " return Ok(spl_int(v ? 1 : 0)); " + rb)
    cg_emit_line("inline void spl_array_set(int64_t a, const char* k, SplValue v) " + lb + " spl_dict_set((SplDict*)(intptr_t)a, k, v); " + rb)
    cg_emit_line("inline void spl_array_set(SplArray* a, const char* k, SplValue v) " + lb + " spl_dict_set((SplDict*)a, k, v); " + rb)
    cg_emit_line("inline SplArray* spl_array_slice(int64_t a, int64_t s, int64_t e) " + lb + " return spl_array_slice((SplArray*)(intptr_t)a, s, e); " + rb)
    cg_emit_line("inline SplArray* spl_array_concat(int64_t a, int64_t b) " + lb + " return spl_array_concat((SplArray*)(intptr_t)a, (SplArray*)(intptr_t)b); " + rb)
    cg_emit_line("inline SplValue spl_array_pop(int64_t a) " + lb + " return spl_array_pop((SplArray*)(intptr_t)a); " + rb)
    cg_emit_line("inline int spl_array_contains_str(int64_t a, const char* s) " + lb + " return spl_array_contains_str((SplArray*)(intptr_t)a, s); " + rb)
    cg_emit_line("inline SplValue spl_dict_get(int64_t d, int64_t k) " + lb + " return spl_dict_get((SplDict*)(intptr_t)d, (const char*)(intptr_t)k); " + rb)
    cg_emit_line("inline int spl_dict_contains(int64_t d, const char* k) " + lb + " return spl_dict_contains((SplDict*)(intptr_t)d, k); " + rb)
    cg_emit_line("inline int spl_dict_contains(int64_t d, int64_t k) " + lb + " return spl_dict_contains((SplDict*)(intptr_t)d, (const char*)(intptr_t)k); " + rb)
    cg_emit_line("inline SplArray* spl_dict_keys(int64_t d) " + lb + " return spl_dict_keys((SplDict*)(intptr_t)d); " + rb)
    cg_emit_line("inline SplArray* spl_dict_values(int64_t d) " + lb + " return spl_dict_values((SplDict*)(intptr_t)d); " + rb)
    cg_emit_line("inline int64_t spl_dict_len(int64_t d) " + lb + " return spl_dict_len((SplDict*)(intptr_t)d); " + rb)
    cg_emit_line("inline void spl_dict_remove(int64_t d, const char* k) " + lb + " spl_dict_remove((SplDict*)(intptr_t)d, k); " + rb)
    # Native pointer overloads
    cg_emit_line("inline void spl_dict_set(SplDict* d, const char* k, SplValue v) " + lb + " spl_dict_set(d, k, v); " + rb)
    cg_emit_line("inline void spl_dict_set(SplDict* d, int64_t k, SplValue v) " + lb + " spl_dict_set(d, (const char*)(intptr_t)k, v); " + rb)
    cg_emit_line("inline SplValue spl_dict_get(SplDict* d, const char* k) " + lb + " return spl_dict_get(d, k); " + rb)
    cg_emit_line("inline SplValue spl_dict_get(SplDict* d, int64_t k) " + lb + " return spl_dict_get(d, (const char*)(intptr_t)k); " + rb)
    cg_emit_line("inline int spl_dict_contains(SplDict* d, const char* k) " + lb + " return spl_dict_contains(d, k); " + rb)
    cg_emit_line("inline int spl_dict_contains(SplDict* d, int64_t k) " + lb + " return spl_dict_contains(d, (const char*)(intptr_t)k); " + rb)
    cg_emit_line("inline SplArray* spl_dict_keys(SplDict* d) " + lb + " return spl_dict_keys(d); " + rb)
    cg_emit_line("inline SplArray* spl_dict_values(SplDict* d) " + lb + " return spl_dict_values(d); " + rb)
    cg_emit_line("inline int64_t spl_dict_len(SplDict* d) " + lb + " return spl_dict_len(d); " + rb)
    cg_emit_line("inline void spl_dict_remove(SplDict* d, const char* k) " + lb + " spl_dict_remove(d, k); " + rb)
    cg_emit_line("inline void spl_array_set(SplArray* a, int64_t i, SplValue v) " + lb + " spl_array_set(a, i, v); " + rb)
    cg_emit_line("inline void spl_array_push(SplArray* a, SplValue v) " + lb + " spl_array_push(a, v); " + rb)
    cg_emit_line("inline int64_t spl_array_len(SplArray* a) " + lb + " return spl_array_len(a); " + rb)
    cg_emit_line("inline SplValue spl_array_get(SplArray* a, int64_t i) " + lb + " return spl_array_get(a, i); " + rb)
    cg_emit_line("inline SplValue spl_array_pop(SplArray* a) " + lb + " return spl_array_pop(a); " + rb)
    cg_emit_line("inline SplArray* spl_array_slice(SplArray* a, int64_t s, int64_t e) " + lb + " return spl_array_slice(a, s, e); " + rb)
    cg_emit_line("inline SplArray* spl_array_concat(SplArray* a, SplArray* b) " + lb + " return spl_array_concat(a, b); " + rb)
    cg_emit_line("inline int spl_array_contains_str(SplArray* a, const char* s) " + lb + " return spl_array_contains_str(a, s); " + rb)
    cg_emit_blank()

fn cg_emit_structs():
    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)
        if tag == DECL_STRUCT:
            val name = decl_get_name(decl_idx)
            val fields = decl_get_fields(decl_idx)
            val ftypes = decl_get_field_types(decl_idx)
            cg_emit_line("struct " + name + " {")
            cg_indent = cg_indent + 1
            for j in range(0, fields.len()):
                val c_type = type_tag_to_c(ftypes[j])
                val f_name: text = fields[j]
                var field_line: text = c_type + " "
                field_line = field_line + f_name
                field_line = field_line + ";"
                cg_emit_line(field_line)
            cg_indent = cg_indent - 1
            cg_emit_line("};")
            cg_emit_blank()

fn cg_emit_enums():
    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)
        if tag == DECL_ENUM:
            val name = decl_get_name(decl_idx)
            val variants = decl_get_fields(decl_idx)
            cg_emit_line("/* enum " + name + " */")
            for j in range(0, variants.len()):
                val v_name: text = variants[j]
                var enum_line: text = "static const int64_t " + name + "_"
                enum_line = enum_line + v_name
                enum_line = enum_line + " = "
                enum_line = enum_line + int_to_str(j)
                enum_line = enum_line + ";"
                cg_emit_line(enum_line)
            cg_emit_blank()

fn cg_emit_forward_decls():
    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)

        if tag == DECL_EXTERN_FN:
            val name = decl_get_name(decl_idx)
            val pnames = decl_get_param_names(decl_idx)
            val ptypes = decl_get_param_types(decl_idx)
            val ret = decl_get_ret_type(decl_idx)
            val ret_c = type_tag_to_c(ret)
            var params_c: text = ""
            for j in range(0, pnames.len()):
                if j > 0:
                    params_c = params_c + ", "
                val p_type_c: text = type_tag_to_c(ptypes[j])
                val p_name: text = pnames[j]
                params_c = params_c + p_type_c
                params_c = params_c + " "
                params_c = params_c + p_name
            var ext_line: text = "extern \"C\" " + ret_c
            ext_line = ext_line + " "
            ext_line = ext_line + name
            ext_line = ext_line + "("
            ext_line = ext_line + params_c
            ext_line = ext_line + ");"
            cg_emit_line(ext_line)

        if tag == DECL_USE:
            # Emit forward declarations for imported functions
            # In whole-program compilation, imported functions are in the same C++ file
            # but may be defined later, so we need forward declarations
            val imports = decl_get_imports(decl_idx)
            for j in range(0, imports.len()):
                val import_name = imports[j]
                val sig_id = fn_sig_find(import_name)
                if sig_id >= 0:
                    # Function signature is registered, emit proper forward declaration
                    val ret_type = fn_sig_ret_type(sig_id)
                    val ret_c = type_tag_to_c(ret_type)
                    val pnames = fn_sig_get_param_names(sig_id)
                    val ptypes = fn_sig_get_param_types(sig_id)
                    var params_c: text = ""
                    for k in range(0, pnames.len()):
                        if k > 0:
                            params_c = params_c + ", "
                        val p_type_c: text = type_tag_to_c(ptypes[k])
                        val p_name: text = pnames[k]
                        params_c = params_c + p_type_c
                        params_c = params_c + " "
                        params_c = params_c + p_name
                    var use_line: text = ret_c + " "
                    use_line = use_line + import_name
                    use_line = use_line + "("
                    use_line = use_line + params_c
                    use_line = use_line + ");"
                    cg_emit_line(use_line)

        if tag == DECL_FN:
            val name = decl_get_name(decl_idx)
            val pnames = decl_get_param_names(decl_idx)
            val ptypes = decl_get_param_types(decl_idx)
            val ret = decl_get_ret_type(decl_idx)
            val ret_c = type_tag_to_c(ret)
            var params_c: text = ""
            for j in range(0, pnames.len()):
                if j > 0:
                    params_c = params_c + ", "
                val p_type_c: text = type_tag_to_c(ptypes[j])
                val p_name: text = pnames[j]
                params_c = params_c + p_type_c
                params_c = params_c + " "
                params_c = params_c + p_name
            var emit_name: text = name
            if name == "main":
                emit_name = "spl_main"
            var fn_line: text = ret_c + " "
            fn_line = fn_line + emit_name
            fn_line = fn_line + "("
            fn_line = fn_line + params_c
            fn_line = fn_line + ");"
            cg_emit_line(fn_line)

        if tag == DECL_IMPL:
            # Forward declare impl methods
            val impl_methods = decl_get_body(decl_idx)
            val impl_target = decl_get_name(decl_idx)
            for mi in range(0, impl_methods.len()):
                val m_idx = impl_methods[mi]
                val m_name = decl_get_name(m_idx)
                val m_pnames = decl_get_param_names(m_idx)
                val m_ptypes = decl_get_param_types(m_idx)
                val m_ret = decl_get_ret_type(m_idx)
                val m_mflag = decl_get_is_async(m_idx)
                val m_ret_c = type_tag_to_c(m_ret)
                var m_params_c: text = ""
                # Add self parameter for non-static methods
                if m_mflag != 1:
                    if m_mflag == 2:
                        m_params_c = impl_target + "* self"
                    else:
                        m_params_c = "const " + impl_target + "* self"
                for mj in range(0, m_pnames.len()):
                    if m_params_c != "":
                        m_params_c = m_params_c + ", "
                    val mp_type: text = type_tag_to_c(m_ptypes[mj])
                    val mp_name: text = m_pnames[mj]
                    m_params_c = m_params_c + mp_type + " " + mp_name
                cg_emit_line(m_ret_c + " " + m_name + "(" + m_params_c + ");")
    cg_emit_blank()

fn cg_emit_functions():
    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)
        if tag == DECL_FN:
            cg_emit_function(decl_idx)

fn cg_emit_impl_methods():
    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)
        if tag == DECL_IMPL:
            val impl_target = decl_get_name(decl_idx)
            val impl_methods = decl_get_body(decl_idx)
            for mi in range(0, impl_methods.len()):
                val m_idx = impl_methods[mi]
                val m_name = decl_get_name(m_idx)
                val m_pnames = decl_get_param_names(m_idx)
                val m_ptypes = decl_get_param_types(m_idx)
                val m_ret = decl_get_ret_type(m_idx)
                val m_body = decl_get_body(m_idx)
                val m_mflag = decl_get_is_async(m_idx)
                val m_ret_c = type_tag_to_c(m_ret)
                # Build params with self
                var m_params_c: text = ""
                if m_mflag != 1:
                    if m_mflag == 2:
                        m_params_c = impl_target + "* self"
                    else:
                        m_params_c = "const " + impl_target + "* self"
                for mj in range(0, m_pnames.len()):
                    if m_params_c != "":
                        m_params_c = m_params_c + ", "
                    val mp_type: text = type_tag_to_c(m_ptypes[mj])
                    val mp_name: text = m_pnames[mj]
                    m_params_c = m_params_c + mp_type + " " + mp_name
                cg_emit_line(m_ret_c + " " + m_name + "(" + m_params_c + ") " + "{")
                cg_indent = cg_indent + 1
                # Track self as struct type
                vt_push_scope()
                if m_mflag != 1:
                    st_add("self", impl_target)
                    # Track self's fields as accessible types
                    val self_nid = named_type_find(impl_target)
                    if self_nid >= 0:
                        val self_fields = named_type_fields(self_nid)
                        val self_ftypes = named_type_field_type_tags(self_nid)
                        for sf in range(0, self_fields.len()):
                            vt_add("self_" + self_fields[sf], self_ftypes[sf])
                # Track params
                for mj in range(0, m_pnames.len()):
                    val pn: text = m_pnames[mj]
                    vt_add(pn, m_ptypes[mj])
                # Emit body
                for si in range(0, m_body.len()):
                    val is_last = si == m_body.len() - 1
                    if is_last:
                        if m_ret != TYPE_VOID:
                            val s_tag = stmt_get_tag(m_body[si])
                            if s_tag == STMT_EXPR:
                                val inner = stmt_get_expr(m_body[si])
                                if inner >= 0:
                                    val inner_tag = expr_get_tag(inner)
                                    val is_ret = inner_tag == EXPR_RETURN
                                    val is_assign = inner_tag == EXPR_ASSIGN
                                    val is_comp = inner_tag == EXPR_COMPOUND_ASSIGN
                                    if not is_ret:
                                        if not is_assign:
                                            if not is_comp:
                                                cg_emit_line("return " + cg_expr(inner) + ";")
                                                vt_pop_scope()
                                                cg_indent = cg_indent - 1
                                                cg_emit_line("}")
                                                cg_emit_blank()
                                                return
                    cg_stmt(m_body[si])
                vt_pop_scope()
                cg_indent = cg_indent - 1
                cg_emit_line("}")
                cg_emit_blank()

fn cg_emit_function(decl_idx: i64):
    val name = decl_get_name(decl_idx)
    val pnames = decl_get_param_names(decl_idx)
    val ptypes = decl_get_param_types(decl_idx)
    val ret = decl_get_ret_type(decl_idx)
    val body_stmts = decl_get_body(decl_idx)
    val ret_c = type_tag_to_c(ret)

    var params_c: text = ""
    for j in range(0, pnames.len()):
        if j > 0:
            params_c = params_c + ", "
        val p_type_c: text = type_tag_to_c(ptypes[j])
        val p_name: text = pnames[j]
        params_c = params_c + p_type_c
        params_c = params_c + " "
        params_c = params_c + p_name

    var emit_name: text = name
    if name == "main":
        emit_name = "spl_main"
    var fn_header: text = ret_c + " "
    fn_header = fn_header + emit_name
    fn_header = fn_header + "("
    fn_header = fn_header + params_c
    fn_header = fn_header + ") {"
    cg_emit_line(fn_header)
    cg_indent = cg_indent + 1

    # Track parameter types
    vt_push_scope()
    for j in range(0, pnames.len()):
        val pn: text = pnames[j]
        vt_add(pn, ptypes[j])

    # Emit body statements
    for i in range(0, body_stmts.len()):
        val is_last = i == body_stmts.len() - 1

        # Auto-return for last statement in non-void functions
        if is_last:
            val needs_return = ret != TYPE_VOID
            if needs_return:
                val s_tag = stmt_get_tag(body_stmts[i])
                val is_expr_stmt = s_tag == STMT_EXPR
                val is_return = s_tag == STMT_RETURN
                val is_control = s_tag == STMT_IF
                val is_loop = s_tag == STMT_FOR
                val is_loop2 = s_tag == STMT_WHILE
                val is_match = s_tag == STMT_MATCH
                if is_expr_stmt:
                    # Check if already has return/assign/print
                    val inner_expr = stmt_get_expr(body_stmts[i])
                    if inner_expr >= 0:
                        val inner_tag = expr_get_tag(inner_expr)
                        val is_ret = inner_tag == EXPR_RETURN
                        val is_assign = inner_tag == EXPR_ASSIGN
                        val is_comp = inner_tag == EXPR_COMPOUND_ASSIGN
                        val needs_wrap = not is_ret
                        val skip_for_assign = is_assign or is_comp
                        if needs_wrap:
                            if not skip_for_assign:
                                cg_emit_line("return " + cg_expr(inner_expr) + ";")
                                vt_pop_scope()
                                cg_indent = cg_indent - 1
                                cg_emit_line("}")
                                cg_emit_blank()
                                return
                if is_return:
                    cg_stmt(body_stmts[i])
                    vt_pop_scope()
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    cg_emit_blank()
                    return
                if is_control:
                    cg_stmt(body_stmts[i])
                    vt_pop_scope()
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    cg_emit_blank()
                    return
                if is_loop:
                    cg_stmt(body_stmts[i])
                    vt_pop_scope()
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    cg_emit_blank()
                    return
                if is_loop2:
                    cg_stmt(body_stmts[i])
                    vt_pop_scope()
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    cg_emit_blank()
                    return
                if is_match:
                    cg_stmt(body_stmts[i])
                    vt_pop_scope()
                    cg_indent = cg_indent - 1
                    cg_emit_line("}")
                    cg_emit_blank()
                    return

        cg_stmt(body_stmts[i])

    vt_pop_scope()
    cg_indent = cg_indent - 1
    cg_emit_line("}")
    cg_emit_blank()

fn cg_resolve_type(type_tag: i64, init_expr: i64) -> text:
    # If type is annotated, use it
    if type_tag != TYPE_VOID:
        return type_tag_to_c(type_tag)
    # Infer type from init expression
    if init_expr >= 0:
        val etag = expr_get_tag(init_expr)
        if etag == EXPR_INT_LIT: return "int64_t"
        if etag == EXPR_FLOAT_LIT: return "double"
        if etag == EXPR_STRING_LIT: return "const char*"
        if etag == EXPR_BOOL_LIT: return "int"
        if etag == EXPR_NIL_LIT: return "int64_t"
        if etag == EXPR_ARRAY_LIT: return "SplArray*"
        if etag == EXPR_BINARY: return "int64_t"
        if etag == EXPR_INTERPOLATED_STRING: return "const char*"
        if etag == EXPR_CALL:
            val callee_idx = expr_get_left(init_expr)
            if expr_get_tag(callee_idx) == EXPR_IDENT:
                val cname = expr_get_str(callee_idx)
                val sig = fn_sig_find(cname)
                if sig >= 0:
                    return type_tag_to_c(fn_sig_ret_type(sig))
            return "int64_t"
    # Default
    "int64_t"

fn cg_emit_globals():
    # Emit global variable declarations for all module-level val/var
    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)
        if tag == DECL_VAL:
            val name = decl_get_name(decl_idx)
            var eff_type = decl_get_ret_type(decl_idx)
            val body = decl_get_body(decl_idx)
            var init_expr: i64 = -1
            if body.len() > 0:
                init_expr = body[0]
            # Skip synthetic module-level statements (type_tag == -1)
            if eff_type != -1:
                # Infer effective type for vt tracking
                if eff_type == TYPE_VOID:
                    if init_expr >= 0:
                        eff_type = cg_infer_expr_type(init_expr)
                    if eff_type == TYPE_VOID:
                        eff_type = TYPE_I64
                val c_type = cg_resolve_type(eff_type, init_expr)
                vt_add(name, eff_type)
                cg_emit_line("static " + c_type + " " + name + ";")
        if tag == DECL_VAR:
            val name = decl_get_name(decl_idx)
            var eff_type = decl_get_ret_type(decl_idx)
            val body = decl_get_body(decl_idx)
            var init_expr: i64 = -1
            if body.len() > 0:
                init_expr = body[0]
            # Infer effective type for vt tracking
            if eff_type == TYPE_VOID:
                if init_expr >= 0:
                    eff_type = cg_infer_expr_type(init_expr)
                if eff_type == TYPE_VOID:
                    eff_type = TYPE_I64
            val c_type = cg_resolve_type(eff_type, init_expr)
            vt_add(name, eff_type)
            cg_emit_line("static " + c_type + " " + name + ";")
    cg_emit_blank()

fn cg_emit_module_init():
    cg_emit_line("static void __module_init(void) {")
    cg_indent = cg_indent + 1

    val decls = module_get_decls()
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)

        # Module-level val/var bindings — assign (already declared as globals)
        if tag == DECL_VAL:
            val name = decl_get_name(decl_idx)
            val ret_type = decl_get_ret_type(decl_idx)
            val body = decl_get_body(decl_idx)
            if body.len() > 0:
                val init_expr = body[0]
                if ret_type == -1:
                    # Synthetic module-level statement
                    val init_tag = expr_get_tag(init_expr)
                    if init_tag == EXPR_IF:
                        cg_emit_if_as_stmt(init_expr)
                    elif init_tag == EXPR_FOR:
                        cg_emit_for_as_stmt(init_expr)
                    elif init_tag == EXPR_WHILE:
                        cg_emit_while_as_stmt(init_expr)
                    else:
                        val init_c = cg_expr(init_expr)
                        cg_emit_line(init_c + ";")
                else:
                    val init_c = cg_expr(init_expr)
                    cg_emit_line(name + " = " + init_c + ";")

        if tag == DECL_VAR:
            val name = decl_get_name(decl_idx)
            val body = decl_get_body(decl_idx)
            if body.len() > 0:
                val init_expr = body[0]
                val init_c = cg_expr(init_expr)
                cg_emit_line(name + " = " + init_c + ";")

    cg_indent = cg_indent - 1
    cg_emit_line("}")
    cg_emit_blank()

fn cg_emit_main():
    cg_emit_line("int main(int argc, char** argv) {")
    cg_indent = cg_indent + 1
    cg_emit_line("spl_init_args(argc, argv);")
    cg_emit_line("__module_init();")

    # Call user entry point if it exists
    val decls = module_get_decls()
    var found_entry: bool = false
    for i in range(0, decls.len()):
        val decl_idx = decls[i]
        val tag = decl_get_tag(decl_idx)
        if tag == DECL_FN:
            val name = decl_get_name(decl_idx)
            if name == "main" or name == "spl_main":
                val ret = decl_get_ret_type(decl_idx)
                if ret == TYPE_VOID:
                    cg_emit_line("spl_main();")
                else:
                    cg_emit_line("return (int)spl_main();")
                found_entry = true
            elif name == "main_test":
                cg_emit_line("main_test();")
                found_entry = true
            elif name == "main_entry":
                cg_emit_line("main_entry();")
                found_entry = true

    cg_emit_line("return 0;")
    cg_indent = cg_indent - 1
    cg_emit_line("}")

# ===== Main Entry Point =====

fn codegen_program() -> text:
    cg_output = ""
    cg_indent = 0
    vt_reset()
    st_reset()
    sa_reset()

    # Pass 1: Register structs and function signatures
    cg_register_pass()

    # Pass 2: Emit C++ code
    cg_emit_preamble()
    cg_emit_structs()
    cg_emit_enums()
    cg_emit_forward_decls()
    cg_emit_globals()
    cg_emit_functions()
    cg_emit_impl_methods()
    cg_emit_module_init()
    cg_emit_main()

    cg_output

export codegen_program
