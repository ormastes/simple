# Core Simple â€” Compiler Driver
#
# Entry point for the Core Simple compiler.
# Reads one or more .spl files, lexes, parses, and emits C++ code to stdout.
#
# Usage:
#   core_compiler input1.spl input2.spl ... > output.cpp
#   clang++ -std=c++17 -Itools/seed output.cpp tools/seed/.build-coverage/libspl_runtime.a -o output
#
# Multi-file: All files are parsed into a single AST, then codegen produces
# one combined C++ output. Declarations accumulate across files.
#
# Note: spl_file_read, spl_arg_count, spl_get_arg are declared in runtime.h
# (included via generated C code). We do NOT redeclare them as extern fn
# because the seed compiler maps text->const char* which conflicts with
# runtime.h's char* return types. Instead we use explicit type annotations.

use core.lexer.{lex_init}
use core.parser.{parser_init, parse_module, parse_module_file}
use core.parser.{parser_has_errors, parser_get_errors}
use core.ast.{ast_reset}
use core.types.{reset_all_pools}
use core.compiler.c_codegen.{codegen_program}

extern fn spl_eprintln(msg: text)

# Main driver
# spl_arg_count/spl_get_arg/spl_file_read are available from runtime.h
val argc: i64 = spl_arg_count()
if argc < 2:
    print "Usage: core_compiler input1.spl [input2.spl ...] [> output.cpp]"
    print "  Compiles Core Simple source to C++ code."
else:
    # Reset all pools once at startup
    reset_all_pools()
    ast_reset()

    var had_parse_errors: bool = false

    # Parse each input file, accumulating declarations
    for file_idx in range(1, argc):
        val input_path: text = spl_get_arg(file_idx)
        val source: text = spl_file_read(input_path)

        if file_idx == 1:
            # First file: full init (resets AST)
            parse_module(source, input_path)
        else:
            # Subsequent files: init lexer/parser only, keep AST
            parse_module_file(source, input_path)

        if parser_has_errors():
            had_parse_errors = true
            spl_eprintln("error: parse errors in " + input_path)
            val errs: [text] = parser_get_errors()
            for i in range(0, errs.len()):
                val err_msg: text = errs[i]
                spl_eprintln(err_msg)

    if not had_parse_errors:
        val cpp_code: text = codegen_program()
        print cpp_code
