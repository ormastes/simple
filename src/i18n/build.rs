/// Build script for compile-time i18n catalog generation
///
/// This script parses the default locale catalog files (English) at build time
/// and generates Rust code with perfect hash maps (phf::Map) embedded in the binary.
/// This provides zero-cost access to default locale messages.
///
/// Files processed:
/// - i18n/__init__.spl -> DEFAULT_SEVERITY (common UI strings)
/// - i18n/parser.spl -> DEFAULT_PARSER_MESSAGES (parser errors E0001-E0012)
///
/// Generated file: src/generated.rs (included via include! macro in lib.rs)

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    // Find the workspace root (where i18n/ directory is located)
    let workspace_root = find_workspace_root();
    let i18n_dir = workspace_root.join("i18n");

    // Check if i18n directory exists
    if !i18n_dir.exists() {
        eprintln!("Warning: i18n directory not found at {:?}", i18n_dir);
        eprintln!("Skipping catalog generation - will use bootstrap messages only");
        return;
    }

    // Tell cargo to rerun if catalog files change
    println!("cargo:rerun-if-changed={}", i18n_dir.join("__init__.spl").display());
    println!("cargo:rerun-if-changed={}", i18n_dir.join("parser.spl").display());

    // Parse default locale catalog files
    let severity_catalog = parse_catalog_file(&i18n_dir.join("__init__.spl"), "common");
    let parser_catalog = parse_catalog_file(&i18n_dir.join("parser.spl"), "parser");

    // Generate Rust code
    let out_dir = env::var("OUT_DIR").unwrap();
    let generated_path = Path::new(&out_dir).join("generated.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n\n");
    code.push_str("use phf;\n\n");

    // Generate DEFAULT_SEVERITY map
    if let Some(catalog) = severity_catalog {
        generate_severity_map(&mut code, &catalog);
    }

    // Generate DEFAULT_PARSER_MESSAGES map
    if let Some(catalog) = parser_catalog {
        generate_messages_map(&mut code, "PARSER", &catalog);
    }

    fs::write(&generated_path, code).expect("Failed to write generated.rs");
}

/// Find the workspace root by looking for Cargo.toml with [workspace]
fn find_workspace_root() -> PathBuf {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let mut current = PathBuf::from(manifest_dir);

    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists() {
            if let Ok(content) = fs::read_to_string(&cargo_toml) {
                if content.contains("[workspace]") {
                    return current;
                }
            }
        }

        if !current.pop() {
            panic!("Could not find workspace root");
        }
    }
}

/// Simple catalog representation for build script
#[derive(Debug)]
struct SimpleCatalog {
    messages: Vec<(String, CatalogMessage)>,
}

#[derive(Debug)]
struct CatalogMessage {
    id: String,
    title: String,
    message: String,
    label: Option<String>,
    help: Option<String>,
    note: Option<String>,
}

/// Parse a catalog file and extract messages
///
/// This is a simplified parser that doesn't use the full Simple parser
/// to avoid circular dependencies. It uses simple JSON-like text parsing
/// for the dictionary structure.
///
/// NOTE: This is a temporary implementation. In the future, we could use
/// the Simple parser, but for now we keep it simple to avoid build dependencies.
fn parse_catalog_file(path: &Path, domain: &str) -> Option<SimpleCatalog> {
    if !path.exists() {
        eprintln!("Warning: Catalog file not found: {:?}", path);
        return None;
    }

    let content = fs::read_to_string(path).ok()?;

    // For common domain (severity), we expect simpler structure
    if domain == "common" {
        return parse_severity_catalog(&content);
    }

    // For other domains (parser, compiler), we expect message dictionaries
    parse_message_catalog(&content)
}

/// Parse severity catalog (simple key-value pairs)
fn parse_severity_catalog(content: &str) -> Option<SimpleCatalog> {
    // Look for lines like: "error": "error",
    let mut messages = Vec::new();

    for line in content.lines() {
        let trimmed = line.trim();

        // Skip comments and empty lines
        if trimmed.starts_with('#') || trimmed.is_empty() {
            continue;
        }

        // Look for key-value pairs: "key": "value"
        if let Some((key, value)) = parse_key_value_pair(trimmed) {
            messages.push((
                key.clone(),
                CatalogMessage {
                    id: key.clone(),
                    title: value,
                    message: key,
                    label: None,
                    help: None,
                    note: None,
                },
            ));
        }
    }

    if messages.is_empty() {
        None
    } else {
        Some(SimpleCatalog { messages })
    }
}

/// Parse message catalog (nested dictionaries with id, title, message, etc.)
fn parse_message_catalog(content: &str) -> Option<SimpleCatalog> {
    let mut messages = Vec::new();
    let mut current_id: Option<String> = None;
    let mut current_msg = CatalogMessage {
        id: String::new(),
        title: String::new(),
        message: String::new(),
        label: None,
        help: None,
        note: None,
    };

    for line in content.lines() {
        let trimmed = line.trim();

        // Skip comments and empty lines
        if trimmed.starts_with('#') || trimmed.is_empty() {
            continue;
        }

        // Look for message ID start: "E0001": {
        if trimmed.ends_with(": {") {
            // Save previous message if any
            if let Some(id) = current_id.take() {
                messages.push((id, current_msg));
                current_msg = CatalogMessage {
                    id: String::new(),
                    title: String::new(),
                    message: String::new(),
                    label: None,
                    help: None,
                    note: None,
                };
            }

            // Extract new message ID
            let id_part = &trimmed[..trimmed.len() - 3]; // Remove ": {"
            if let Some(id) = extract_string_literal(id_part) {
                current_id = Some(id.clone());
                current_msg.id = id;
            }
            continue;
        }

        // Parse field within message: "field": "value"
        if let Some((field, value)) = parse_key_value_pair(trimmed) {
            match field.as_str() {
                "id" => current_msg.id = value,
                "title" => current_msg.title = value,
                "message" => current_msg.message = value,
                "label" => current_msg.label = Some(value),
                "help" => current_msg.help = Some(value),
                "note" => current_msg.note = Some(value),
                _ => {}
            }
        }
    }

    // Save last message
    if let Some(id) = current_id {
        messages.push((id, current_msg));
    }

    if messages.is_empty() {
        None
    } else {
        Some(SimpleCatalog { messages })
    }
}

/// Parse a key-value pair from a line like: "key": "value",
fn parse_key_value_pair(line: &str) -> Option<(String, String)> {
    let line = line.trim_end_matches(',').trim();

    // Find the colon separator
    let colon_pos = line.find(':')?;
    let key_part = &line[..colon_pos].trim();
    let value_part = &line[colon_pos + 1..].trim();

    let key = extract_string_literal(key_part)?;
    let value = extract_string_literal(value_part)?;

    Some((key, value))
}

/// Extract string content from a quoted string literal
fn extract_string_literal(s: &str) -> Option<String> {
    let s = s.trim();

    // Handle quoted strings: "text" or 'text'
    if (s.starts_with('"') && s.ends_with('"')) || (s.starts_with('\'') && s.ends_with('\'')) {
        let content = &s[1..s.len() - 1];
        // Simple unescaping (not complete, but sufficient for our catalogs)
        let unescaped = content.replace("\\n", "\n").replace("\\\"", "\"");
        Some(unescaped)
    } else {
        None
    }
}

/// Generate phf::Map for severity names (common domain)
fn generate_severity_map(code: &mut String, catalog: &SimpleCatalog) {
    code.push_str("/// Default locale severity names (embedded at compile time)\n");
    code.push_str("pub static DEFAULT_SEVERITY: phf::Map<&'static str, &'static str> = phf::phf_map! {\n");

    for (key, msg) in &catalog.messages {
        code.push_str(&format!("    {:?} => {:?},\n", key, msg.title));
    }

    code.push_str("};\n\n");
}

/// Generate phf::Map for error messages
fn generate_messages_map(code: &mut String, domain: &str, catalog: &SimpleCatalog) {
    let map_name = format!("DEFAULT_{}_MESSAGES", domain.to_uppercase());

    code.push_str(&format!("/// Default locale {} messages (embedded at compile time)\n", domain));
    code.push_str(&format!("pub static {}: phf::Map<&'static str, (&'static str, &'static str, Option<&'static str>, Option<&'static str>, Option<&'static str>)> = phf::phf_map! {{\n", map_name));

    for (key, msg) in &catalog.messages {
        code.push_str(&format!(
            "    {:?} => ({:?}, {:?}, {}, {}, {}),\n",
            key,
            msg.title,
            msg.message,
            format_option(&msg.label),
            format_option(&msg.help),
            format_option(&msg.note)
        ));
    }

    code.push_str("};\n\n");
}

/// Format Option<String> as Rust code
fn format_option(opt: &Option<String>) -> String {
    match opt {
        Some(s) => format!("Some({:?})", s),
        None => "None".to_string(),
    }
}
