//! Program argument handling for compiled code.
//!
//! This module provides global storage for program arguments (argc/argv)
//! that can be set at program startup and accessed from Simple code via
//! the `sys_get_args()` builtin function.
//!
//! ## Architecture
//!
//! - **Global Storage**: `PROGRAM_ARGS` is a mutex-protected vector of strings
//! - **Set Once**: `rt_set_args()` is called once at program startup (main wrapper)
//! - **Read Many**: `rt_get_args()` returns a RuntimeValue array handle
//!
//! ## Usage Modes
//!
//! 1. **Standalone Binary**: OS passes argc/argv to generated main(), which calls rt_set_args()
//! 2. **SMF Loader**: Driver sets args before executing loaded module
//! 3. **JIT/Interpreter**: Driver sets args from command line before evaluation

use parking_lot::Mutex;
use std::ffi::CStr;

use super::{rt_array_new, rt_array_push, rt_string_new, RuntimeValue};

/// Global program arguments storage.
///
/// This is set once at program startup via `rt_set_args()` and then
/// remains read-only for the duration of the program.
///
/// Uses `parking_lot::Mutex` for lock-free fast path (uncontended case).
static PROGRAM_ARGS: Mutex<Vec<String>> = Mutex::new(Vec::new());

/// Set program arguments from argc/argv (called once at startup).
///
/// # Safety
///
/// - `argv` must point to a valid array of at least `argc` pointers
/// - Each pointer in `argv` must point to a valid null-terminated C string
/// - The strings must remain valid for the duration of this call
/// - This function should be called exactly once at program startup
///
/// # Parameters
///
/// - `argc`: Number of arguments (including program name at argv[0])
/// - `argv`: Pointer to array of C string pointers
///
/// # Example
///
/// ```c
/// // Generated by codegen for standalone binaries
/// extern "C" int main(int argc, char** argv) {
///     rt_set_args(argc, argv);
///     return __user_main();
/// }
/// ```
#[no_mangle]
pub extern "C" fn rt_set_args(argc: i32, argv: *const *const u8) {
    let mut args = Vec::new();

    // Validate inputs
    if argc <= 0 || argv.is_null() {
        // No arguments - store empty vector
        *PROGRAM_ARGS.lock() = args;
        return;
    }

    // Convert C argc/argv to Vec<String>
    unsafe {
        for i in 0..argc {
            let arg_ptr = *argv.offset(i as isize);
            if arg_ptr.is_null() {
                continue;
            }

            // Convert C string to Rust String
            let c_str = CStr::from_ptr(arg_ptr as *const i8);
            match c_str.to_str() {
                Ok(s) => args.push(s.to_string()),
                Err(e) => {
                    tracing::warn!(
                        index = i,
                        error = %e,
                        "Failed to decode argument as UTF-8, skipping"
                    );
                }
            }
        }
    }

    // Store in global storage (replacing any previous value)
    let arg_count = args.len();
    *PROGRAM_ARGS.lock() = args;

    tracing::debug!(arg_count, "Program arguments set");
}

/// Set program arguments from Vec<String> (convenience for driver).
///
/// This is a Rust-friendly version of `rt_set_args()` for use by the
/// driver when invoking SMF modules or JIT-compiled code.
///
/// # Example
///
/// ```rust
/// use simple_runtime::value::rt_set_args_vec;
///
/// // Driver code (exec_core.rs)
/// let args = vec!["program".to_string(), "arg1".to_string()];
/// rt_set_args_vec(&args);
/// ```
pub fn rt_set_args_vec(args: &[String]) {
    *PROGRAM_ARGS.lock() = args.to_vec();
    tracing::debug!(arg_count = args.len(), "Program arguments set from Vec");
}

/// Get program arguments as a RuntimeValue array.
///
/// Returns a heap-allocated RuntimeArray containing RuntimeString values.
/// Each string is a separate heap allocation.
///
/// # Returns
///
/// RuntimeValue handle representing an array of strings.
/// If no arguments have been set, returns an empty array.
///
/// # Safety
///
/// This function is safe to call from compiled code. The returned handle
/// is a valid RuntimeValue that can be used like any other array.
///
/// # Example (Simple code)
///
/// ```simple
/// # Access from Simple via sys_get_args()
/// let args = sys_get_args()  # Returns array of strings
/// print(args[0])             # Program name
/// ```
#[no_mangle]
pub extern "C" fn rt_get_args() -> RuntimeValue {
    // Auto-initialize from std::env::args() if not already set
    // (for standalone binaries)
    auto_init_args_if_empty();

    // Lock and clone the arguments
    let args = PROGRAM_ARGS.lock().clone();

    // Create empty array
    let array_handle = rt_array_new(args.len() as u64);

    // Push each argument as a string
    for arg in &args {
        let str_value = rt_string_new(arg.as_ptr(), arg.len() as u64);
        rt_array_push(array_handle, str_value);
    }

    tracing::trace!(arg_count = args.len(), "Arguments retrieved");

    array_handle
}

/// Get argument count (for debugging/diagnostics).
///
/// Returns the number of arguments currently stored.
#[no_mangle]
pub extern "C" fn rt_get_argc() -> i32 {
    PROGRAM_ARGS.lock().len() as i32
}

/// Clear program arguments (for testing/REPL reset).
///
/// This is primarily used in testing environments where you want to
/// reset state between test runs.
#[no_mangle]
pub extern "C" fn rt_clear_args() {
    PROGRAM_ARGS.lock().clear();
    tracing::debug!("Program arguments cleared");
}

/// Auto-initialize arguments from std::env::args() if not already set.
///
/// This is called automatically by rt_get_args() for standalone binaries
/// that don't explicitly set arguments via rt_set_args().
///
/// For SMF/JIT modes, arguments are explicitly set by the driver, so this
/// function does nothing (args are already initialized).
fn auto_init_args_if_empty() {
    let mut args_lock = PROGRAM_ARGS.lock();

    // If already initialized, do nothing
    if !args_lock.is_empty() {
        return;
    }

    // Initialize from std::env::args()
    let args: Vec<String> = std::env::args().collect();

    if !args.is_empty() {
        tracing::debug!(
            arg_count = args.len(),
            "Auto-initialized arguments from std::env::args()"
        );
        *args_lock = args;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::ffi::CString;

    #[test]
    fn test_set_and_get_args_empty() {
        rt_clear_args();

        // Set empty args
        rt_set_args(0, std::ptr::null());

        assert_eq!(rt_get_argc(), 0);
    }

    #[test]
    fn test_set_and_get_args_vec() {
        rt_clear_args();

        let args = vec![
            "program".to_string(),
            "arg1".to_string(),
            "arg2".to_string(),
        ];

        rt_set_args_vec(&args);

        assert_eq!(rt_get_argc(), 3);

        // Get args as runtime array
        let array_handle = rt_get_args();
        assert_ne!(array_handle.to_raw(), 0);
    }

    #[test]
    fn test_set_args_from_c_strings() {
        rt_clear_args();

        let c_args = vec![
            CString::new("program").unwrap(),
            CString::new("foo").unwrap(),
            CString::new("bar").unwrap(),
        ];

        let argv: Vec<*const u8> = c_args.iter().map(|s| s.as_ptr() as *const u8).collect();

        rt_set_args(argv.len() as i32, argv.as_ptr());

        assert_eq!(rt_get_argc(), 3);
    }

    #[test]
    fn test_multiple_set_args_replaces() {
        rt_clear_args();

        // Set first batch
        let args1 = vec!["prog".to_string(), "a".to_string()];
        rt_set_args_vec(&args1);
        assert_eq!(rt_get_argc(), 2);

        // Set second batch (should replace)
        let args2 = vec!["prog".to_string(), "b".to_string(), "c".to_string()];
        rt_set_args_vec(&args2);
        assert_eq!(rt_get_argc(), 3);
    }
}
