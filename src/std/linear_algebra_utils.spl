# Linear Algebra Utilities
#
# Comprehensive linear algebra operations for matrices and vectors.
# Uses f64 (floating point) for numerical precision.
# Pure Simple implementation - no external dependencies.
#
# Matrix representation: [[f64]] - array of rows, each row is array of f64
# Vector representation: [f64] - array of f64
#
# Functions (80+ operations):
#
# Matrix Creation:
#   - la_matrix_create, la_matrix_zero, la_matrix_identity
#   - la_matrix_diagonal, la_matrix_from_rows, la_matrix_from_columns
#   - la_matrix_random, la_matrix_ones, la_matrix_symmetric
#
# Matrix Access:
#   - la_matrix_get, la_matrix_set, la_matrix_get_row, la_matrix_get_column
#   - la_matrix_dimensions, la_matrix_shape
#
# Matrix Properties:
#   - la_matrix_is_square, la_matrix_is_symmetric, la_matrix_is_diagonal
#   - la_matrix_is_orthogonal, la_matrix_is_upper_triangular, la_matrix_is_lower_triangular
#   - la_matrix_trace, la_matrix_rank, la_matrix_condition_number
#
# Matrix Arithmetic:
#   - la_matrix_add, la_matrix_subtract, la_matrix_multiply
#   - la_matrix_scalar_multiply, la_matrix_element_multiply (Hadamard)
#   - la_matrix_power, la_matrix_negate
#
# Matrix Transformations:
#   - la_matrix_transpose, la_matrix_inverse, la_matrix_conjugate_transpose
#   - la_matrix_minor, la_matrix_cofactor, la_matrix_adjugate
#
# Matrix Decomposition:
#   - la_matrix_lu_decomposition, la_matrix_qr_decomposition
#   - la_matrix_cholesky_decomposition, la_matrix_svd_power_iteration
#
# Matrix Operations:
#   - la_matrix_determinant, la_matrix_diagonal_elements
#   - la_matrix_row_reduce, la_matrix_ref, la_matrix_rref
#
# Vector Operations:
#   - la_vector_add, la_vector_subtract, la_vector_scalar_multiply
#   - la_vector_dot, la_vector_cross, la_vector_magnitude
#   - la_vector_normalize, la_vector_project, la_vector_reject
#   - la_vector_angle, la_vector_distance
#
# Vector Spaces:
#   - la_vectors_are_linearly_independent, la_vector_span_contains
#   - la_gram_schmidt, la_vector_basis_dimension
#
# System Solving:
#   - la_solve_gaussian_elimination, la_solve_lu
#   - la_solve_least_squares, la_solve_iterative
#
# Eigenvalues/Eigenvectors:
#   - la_power_iteration, la_inverse_power_iteration
#   - la_qr_algorithm, la_eigenvalue_estimate
#
# Norms:
#   - la_vector_norm_l1, la_vector_norm_l2, la_vector_norm_inf
#   - la_matrix_norm_frobenius, la_matrix_norm_l1, la_matrix_norm_inf
#
# Utility:
#   - la_matrix_equals, la_matrix_is_close, la_vector_equals, la_vector_is_close
#   - la_matrix_copy, la_vector_copy, la_matrix_fill, la_vector_fill

# ============================================================================
# Constants
# ============================================================================

val LA_EPSILON = 0.000001
val LA_MAX_ITERATIONS = 1000

# ============================================================================
# Matrix Creation
# ============================================================================

fn la_matrix_create(rows: i64, cols: i64, fill_value: f64) -> [[f64]]:
    """Create matrix filled with specified value.

    Example:
        la_matrix_create(3, 3, 0.0)  # 3x3 zero matrix
    """
    var matrix = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            row.push(fill_value)
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

fn la_matrix_zero(rows: i64, cols: i64) -> [[f64]]:
    """Create zero matrix.

    Example:
        la_matrix_zero(2, 3)  # [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
    """
    la_matrix_create(rows, cols, 0.0)

fn la_matrix_ones(rows: i64, cols: i64) -> [[f64]]:
    """Create matrix filled with ones.

    Example:
        la_matrix_ones(2, 2)  # [[1.0, 1.0], [1.0, 1.0]]
    """
    la_matrix_create(rows, cols, 1.0)

fn la_matrix_identity(n: i64) -> [[f64]]:
    """Create n√ón identity matrix.

    Example:
        la_matrix_identity(3)
        # [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
    """
    var matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        matrix[i][i] = 1.0
        i = i + 1
    matrix

fn la_matrix_diagonal(values: [f64]) -> [[f64]]:
    """Create diagonal matrix from values.

    Example:
        la_matrix_diagonal([1.0, 2.0, 3.0])
        # [[1.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 3.0]]
    """
    val n = values.len()
    var matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        matrix[i][i] = values[i]
        i = i + 1
    matrix

fn la_matrix_from_rows(rows: [[f64]]) -> [[f64]]:
    """Create matrix from array of row arrays.

    Example:
        la_matrix_from_rows([[1.0, 2.0], [3.0, 4.0]])
    """
    rows

fn la_matrix_from_columns(cols: [[f64]]) -> [[f64]]:
    """Create matrix from array of column arrays.

    Example:
        la_matrix_from_columns([[1.0, 3.0], [2.0, 4.0]])  # [[1.0, 2.0], [3.0, 4.0]]
    """
    if cols.len() == 0:
        return []
    val rows = cols[0].len()
    val columns = cols.len()
    var matrix = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < columns:
            row.push(cols[j][i])
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

fn la_matrix_symmetric(values: [[f64]]) -> [[f64]]:
    """Create symmetric matrix from upper triangular values.

    Example:
        la_matrix_symmetric([[1.0, 2.0], [3.0]])
        # [[1.0, 2.0], [2.0, 3.0]]
    """
    val n = values.len()
    var matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        var j = i
        while j < n:
            val val_val = values[i][j - i]
            matrix[i][j] = val_val
            matrix[j][i] = val_val
            j = j + 1
        i = i + 1
    matrix

fn la_matrix_random(rows: i64, cols: i64, seed: i64) -> [[f64]]:
    """Create matrix with pseudo-random values between 0.0 and 1.0.

    Simple LCG random number generator.
    """
    var matrix = []
    var rng_state = seed
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            rng_state = (rng_state * 1103515245 + 12345) % 2147483648
            val rand_val = (rng_state % 10000) / 10000.0
            row.push(rand_val)
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

# ============================================================================
# Matrix Access
# ============================================================================

fn la_matrix_dimensions(matrix: [[f64]]) -> (i64, i64):
    """Get matrix dimensions (rows, cols).

    Example:
        la_matrix_dimensions([[1.0, 2.0], [3.0, 4.0]])  # (2, 2)
    """
    if matrix.len() == 0:
        return (0, 0)
    (matrix.len(), matrix[0].len())

fn la_matrix_shape(matrix: [[f64]]) -> (i64, i64):
    """Alias for la_matrix_dimensions."""
    la_matrix_dimensions(matrix)

fn la_matrix_get(matrix: [[f64]], row: i64, col: i64) -> f64?:
    """Get element at position. Returns nil if out of bounds."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if row < 0 or row >= rows:
        return nil
    if col < 0 or col >= cols:
        return nil
    matrix[row][col]

fn la_matrix_set(matrix: [[f64]], row: i64, col: i64, value: f64) -> [[f64]]?:
    """Set element at position. Returns new matrix or nil if out of bounds."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if row < 0 or row >= rows:
        return nil
    if col < 0 or col >= cols:
        return nil
    var result = la_matrix_copy(matrix)
    result[row][col] = value
    result

fn la_matrix_get_row(matrix: [[f64]], row: i64) -> [f64]?:
    """Get row as array."""
    if row < 0 or row >= matrix.len():
        return nil
    matrix[row]

fn la_matrix_get_column(matrix: [[f64]], col: i64) -> [f64]?:
    """Get column as array."""
    if matrix.len() == 0:
        return nil
    if col < 0 or col >= matrix[0].len():
        return nil
    var column = []
    for row in matrix:
        column.push(row[col])
    column

fn la_matrix_diagonal_elements(matrix: [[f64]]) -> [f64]?:
    """Get main diagonal as array."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if rows != cols:
        return nil
    var diagonal = []
    var i = 0
    while i < rows:
        diagonal.push(matrix[i][i])
        i = i + 1
    diagonal

# ============================================================================
# Matrix Properties
# ============================================================================

fn la_matrix_is_square(matrix: [[f64]]) -> bool:
    """Check if matrix is square."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    rows == cols and rows > 0

fn la_matrix_is_symmetric(matrix: [[f64]]) -> bool:
    """Check if matrix is symmetric (M = M^T)."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = i + 1
        while j < n:
            val diff = matrix[i][j] - matrix[j][i]
            var abs_diff = diff
            if abs_diff < 0.0:
                abs_diff = -abs_diff
            if abs_diff > LA_EPSILON:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_diagonal(matrix: [[f64]]) -> bool:
    """Check if matrix is diagonal."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = 0
        while j < n:
            if i != j:
                var abs_val = matrix[i][j]
                if abs_val < 0.0:
                    abs_val = -abs_val
                if abs_val > LA_EPSILON:
                    return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_upper_triangular(matrix: [[f64]]) -> bool:
    """Check if matrix is upper triangular."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = 0
        while j < i:
            var abs_val = matrix[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_lower_triangular(matrix: [[f64]]) -> bool:
    """Check if matrix is lower triangular."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = i + 1
        while j < n:
            var abs_val = matrix[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_orthogonal(matrix: [[f64]]) -> bool:
    """Check if matrix is orthogonal (M^T * M = I)."""
    if not la_matrix_is_square(matrix):
        return false
    val transpose_m = la_matrix_transpose(matrix)
    val product = la_matrix_multiply(transpose_m, matrix)
    if not product.?:
        return false
    val identity = la_matrix_identity(matrix.len())
    la_matrix_is_close(product, identity, LA_EPSILON)

fn la_matrix_trace(matrix: [[f64]]) -> f64?:
    """Calculate trace (sum of diagonal elements)."""
    if not la_matrix_is_square(matrix):
        return nil
    var sum = 0.0
    var i = 0
    while i < matrix.len():
        sum = sum + matrix[i][i]
        i = i + 1
    sum

fn la_matrix_rank(matrix: [[f64]]) -> i64:
    """Calculate rank using row reduction.

    Returns number of non-zero rows in RREF.
    """
    val rref = la_matrix_rref(matrix)
    if not rref.?:
        return 0
    var rank = 0
    for row in rref:
        var is_zero_row = true
        for elem in row:
            var abs_elem = elem
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            if abs_elem > LA_EPSILON:
                is_zero_row = false
        if not is_zero_row:
            rank = rank + 1
    rank

fn la_matrix_condition_number(matrix: [[f64]]) -> f64?:
    """Estimate condition number (ratio of largest to smallest singular value).

    Simplified estimate using norm of matrix and its inverse.
    """
    val inv = la_matrix_inverse(matrix)
    if not inv.?:
        return nil
    val norm_m = la_matrix_norm_frobenius(matrix)
    val norm_inv = la_matrix_norm_frobenius(inv)
    norm_m * norm_inv

# ============================================================================
# Matrix Arithmetic
# ============================================================================

fn la_matrix_add(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Add two matrices element-wise."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] + m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_subtract(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Subtract two matrices element-wise."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] - m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_multiply(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Multiply two matrices (standard matrix multiplication)."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if cols1 != rows2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols2:
            var sum = 0.0
            var k = 0
            while k < cols1:
                sum = sum + (m1[i][k] * m2[k][j])
                k = k + 1
            row.push(sum)
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_scalar_multiply(matrix: [[f64]], scalar: f64) -> [[f64]]:
    """Multiply matrix by scalar."""
    var result = []
    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem * scalar)
        result.push(new_row)
    result

fn la_matrix_element_multiply(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Element-wise multiplication (Hadamard product)."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] * m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_negate(matrix: [[f64]]) -> [[f64]]:
    """Negate all elements in matrix."""
    la_matrix_scalar_multiply(matrix, -1.0)

fn la_matrix_power(matrix: [[f64]], n: i64) -> [[f64]]?:
    """Raise square matrix to power n."""
    if not la_matrix_is_square(matrix):
        return nil
    if n == 0:
        return la_matrix_identity(matrix.len())
    if n == 1:
        return matrix
    if n < 0:
        val inv = la_matrix_inverse(matrix)
        if not inv.?:
            return nil
        return la_matrix_power(inv, -n)
    var result = matrix
    var i = 1
    while i < n:
        val temp = la_matrix_multiply(result, matrix)
        if not temp.?:
            return nil
        result = temp
        i = i + 1
    result

# ============================================================================
# Matrix Transformations
# ============================================================================

fn la_matrix_transpose(matrix: [[f64]]) -> [[f64]]:
    """Transpose matrix (swap rows and columns)."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if rows == 0 or cols == 0:
        return []
    var result = []
    var j = 0
    while j < cols:
        var column = []
        var i = 0
        while i < rows:
            column.push(matrix[i][j])
            i = i + 1
        result.push(column)
        j = j + 1
    result

fn la_matrix_conjugate_transpose(matrix: [[f64]]) -> [[f64]]:
    """Conjugate transpose (for real matrices, same as transpose)."""
    la_matrix_transpose(matrix)

fn la_matrix_minor(matrix: [[f64]], exclude_row: i64, exclude_col: i64) -> [[f64]]:
    """Get minor (matrix with row and column removed)."""
    var result = []
    var i = 0
    while i < matrix.len():
        if i != exclude_row:
            var row = []
            var j = 0
            while j < matrix[0].len():
                if j != exclude_col:
                    row.push(matrix[i][j])
                j = j + 1
            result.push(row)
        i = i + 1
    result

fn la_matrix_cofactor(matrix: [[f64]], row: i64, col: i64) -> f64?:
    """Calculate cofactor of element at (row, col)."""
    val minor_mat = la_matrix_minor(matrix, row, col)
    val det = la_matrix_determinant(minor_mat)
    if not det.?:
        return nil
    val sign = if (row + col) % 2 == 0: 1.0 else: -1.0
    sign * det

fn la_matrix_adjugate(matrix: [[f64]]) -> [[f64]]?:
    """Calculate adjugate matrix (transpose of cofactor matrix)."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    var cofactor_matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        var j = 0
        while j < n:
            val cof = la_matrix_cofactor(matrix, i, j)
            if not cof.?:
                return nil
            cofactor_matrix[i][j] = cof
            j = j + 1
        i = i + 1
    la_matrix_transpose(cofactor_matrix)

fn la_matrix_inverse(matrix: [[f64]]) -> [[f64]]?:
    """Calculate matrix inverse using Gauss-Jordan elimination."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    var augmented = []
    var i = 0
    while i < n:
        var row = []
        var j = 0
        while j < n:
            row.push(matrix[i][j])
            j = j + 1
        j = 0
        while j < n:
            val id_val = if i == j: 1.0 else: 0.0
            row.push(id_val)
            j = j + 1
        augmented.push(row)
        i = i + 1
    val rref = la_matrix_rref(augmented)
    if not rref.?:
        return nil
    i = 0
    while i < n:
        var abs_pivot = rref[i][i]
        if abs_pivot < 0.0:
            abs_pivot = -abs_pivot
        if abs_pivot < LA_EPSILON:
            return nil
        i = i + 1
    var inverse = []
    i = 0
    while i < n:
        var row = []
        var j = n
        while j < 2 * n:
            row.push(rref[i][j])
            j = j + 1
        inverse.push(row)
        i = i + 1
    inverse

# ============================================================================
# Matrix Determinant
# ============================================================================

fn la_matrix_determinant(matrix: [[f64]]) -> f64?:
    """Calculate determinant of square matrix using LU decomposition."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    if n == 1:
        return matrix[0][0]
    if n == 2:
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
    val lu_result = la_matrix_lu_decomposition(matrix)
    if not lu_result.?:
        return nil
    val lower = lu_result[0]
    val upper = lu_result[1]
    val parity = lu_result[2]
    var det = parity
    var i = 0
    while i < n:
        det = det * upper[i][i]
        i = i + 1
    det

# ============================================================================
# Matrix Row Operations and Reduction
# ============================================================================

fn la_matrix_row_reduce(matrix: [[f64]]) -> [[f64]]:
    """Row reduce to row echelon form (REF)."""
    la_matrix_ref(matrix)

fn la_matrix_ref(matrix: [[f64]]) -> [[f64]]:
    """Convert to row echelon form."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var result = la_matrix_copy(matrix)
    var pivot_row = 0
    var pivot_col = 0
    while pivot_row < rows and pivot_col < cols:
        var max_row = pivot_row
        var max_val = result[pivot_row][pivot_col]
        if max_val < 0.0:
            max_val = -max_val
        var i = pivot_row + 1
        while i < rows:
            var abs_val = result[i][pivot_col]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > max_val:
                max_val = abs_val
                max_row = i
            i = i + 1
        if max_val < LA_EPSILON:
            pivot_col = pivot_col + 1
        else:
            if max_row != pivot_row:
                val temp_row = result[pivot_row]
                result[pivot_row] = result[max_row]
                result[max_row] = temp_row
            i = pivot_row + 1
            while i < rows:
                val factor = result[i][pivot_col] / result[pivot_row][pivot_col]
                result[i][pivot_col] = 0.0
                var j = pivot_col + 1
                while j < cols:
                    result[i][j] = result[i][j] - factor * result[pivot_row][j]
                    j = j + 1
                i = i + 1
            pivot_row = pivot_row + 1
            pivot_col = pivot_col + 1
    result

fn la_matrix_rref(matrix: [[f64]]) -> [[f64]]:
    """Convert to reduced row echelon form."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var result = la_matrix_ref(matrix)
    var i = rows - 1
    while i >= 0:
        var pivot_col = -1
        var j = 0
        while j < cols:
            var abs_val = result[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                pivot_col = j
                j = cols
            j = j + 1
        if pivot_col >= 0:
            val pivot_val = result[i][pivot_col]
            j = 0
            while j < cols:
                result[i][j] = result[i][j] / pivot_val
                j = j + 1
            var k = 0
            while k < i:
                val factor = result[k][pivot_col]
                j = 0
                while j < cols:
                    result[k][j] = result[k][j] - factor * result[i][j]
                    j = j + 1
                k = k + 1
        i = i - 1
    result

# ============================================================================
# Matrix Decomposition
# ============================================================================

fn la_matrix_lu_decomposition(matrix: [[f64]]) -> ([[f64]], [[f64]], f64)?:
    """LU decomposition with partial pivoting.

    Returns (L, U, parity) where:
    - L is lower triangular
    - U is upper triangular
    - parity is 1.0 or -1.0 for determinant sign
    """
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    var lower = la_matrix_identity(n)
    var upper = la_matrix_copy(matrix)
    var parity = 1.0
    var k = 0
    while k < n - 1:
        var max_row = k
        var max_val = upper[k][k]
        if max_val < 0.0:
            max_val = -max_val
        var i = k + 1
        while i < n:
            var abs_val = upper[i][k]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > max_val:
                max_val = abs_val
                max_row = i
            i = i + 1
        if max_row != k:
            val temp_row = upper[k]
            upper[k] = upper[max_row]
            upper[max_row] = temp_row
            parity = -parity
        i = k + 1
        while i < n:
            val factor = upper[i][k] / upper[k][k]
            lower[i][k] = factor
            var j = k
            while j < n:
                upper[i][j] = upper[i][j] - factor * upper[k][j]
                j = j + 1
            i = i + 1
        k = k + 1
    (lower, upper, parity)

fn la_matrix_qr_decomposition(matrix: [[f64]]) -> ([[f64]], [[f64]])?:
    """QR decomposition using Gram-Schmidt process.

    Returns (Q, R) where Q is orthogonal and R is upper triangular.
    """
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var q_cols = []
    var r_matrix = la_matrix_zero(cols, cols)
    var j = 0
    while j < cols:
        val a_j = la_matrix_get_column(matrix, j)
        if not a_j.?:
            return nil
        var q_j = a_j
        var i = 0
        while i < j:
            val q_i = q_cols[i]
            val r_ij = la_vector_dot(q_i, a_j)
            if not r_ij.?:
                return nil
            r_matrix[i][j] = r_ij
            val proj = la_vector_scalar_multiply(q_i, r_ij)
            val diff = la_vector_subtract(q_j, proj)
            if not diff.?:
                return nil
            q_j = diff
            i = i + 1
        val norm = la_vector_magnitude(q_j)
        if not norm.?:
            return nil
        if norm < LA_EPSILON:
            return nil
        r_matrix[j][j] = norm
        val normalized = la_vector_normalize(q_j)
        if not normalized.?:
            return nil
        q_cols.push(normalized)
        j = j + 1
    val q_matrix = la_matrix_from_columns(q_cols)
    (q_matrix, r_matrix)

fn la_matrix_cholesky_decomposition(matrix: [[f64]]) -> [[f64]]?:
    """Cholesky decomposition for symmetric positive-definite matrices.

    Returns lower triangular matrix L where A = L * L^T.
    """
    if not la_matrix_is_square(matrix):
        return nil
    if not la_matrix_is_symmetric(matrix):
        return nil
    val n = matrix.len()
    var lower = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        var j = 0
        while j <= i:
            var sum = 0.0
            if j == i:
                var k = 0
                while k < j:
                    sum = sum + (lower[j][k] * lower[j][k])
                    k = k + 1
                val diff = matrix[j][j] - sum
                if diff <= 0.0:
                    return nil
                var sqrt_val = diff
                var iteration = 0
                while iteration < 20:
                    sqrt_val = (sqrt_val + diff / sqrt_val) / 2.0
                    iteration = iteration + 1
                lower[j][j] = sqrt_val
            else:
                var k = 0
                while k < j:
                    sum = sum + (lower[i][k] * lower[j][k])
                    k = k + 1
                lower[i][j] = (matrix[i][j] - sum) / lower[j][j]
            j = j + 1
        i = i + 1
    lower

fn la_matrix_svd_power_iteration(matrix: [[f64]], num_components: i64) -> ([[f64]], [f64], [[f64]])?:
    """Simplified SVD using power iteration.

    Returns approximation of (U, singular_values, V^T) for first num_components.
    This is a simplified implementation - not full SVD.
    """
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if num_components > rows or num_components > cols:
        return nil
    var u_cols = []
    var singular_values = []
    var v_cols = []
    var remaining = matrix
    var comp = 0
    while comp < num_components:
        val result = la_power_iteration(remaining, 50)
        if not result.?:
            return nil
        val eigenvalue = result[0]
        val eigenvector = result[1]
        var sigma = eigenvalue
        if sigma < 0.0:
            sigma = -sigma
        var sqrt_sigma = sigma
        var iteration = 0
        while iteration < 20:
            sqrt_sigma = (sqrt_sigma + sigma / sqrt_sigma) / 2.0
            iteration = iteration + 1
        singular_values.push(sqrt_sigma)
        u_cols.push(eigenvector)
        val at_times_u = la_matrix_vector_multiply(la_matrix_transpose(remaining), eigenvector)
        if not at_times_u.?:
            return nil
        val v = la_vector_scalar_multiply(at_times_u, 1.0 / sqrt_sigma)
        v_cols.push(v)
        val outer = la_vector_outer_product(eigenvector, v)
        val deflate = la_matrix_scalar_multiply(outer, sqrt_sigma)
        val diff = la_matrix_subtract(remaining, deflate)
        if not diff.?:
            return nil
        remaining = diff
        comp = comp + 1
    val u_matrix = la_matrix_from_columns(u_cols)
    val vt_matrix = la_matrix_from_rows(v_cols)
    (u_matrix, singular_values, vt_matrix)

# ============================================================================
# Vector Operations
# ============================================================================

fn la_vector_add(v1: [f64], v2: [f64]) -> [f64]?:
    """Add two vectors element-wise."""
    if v1.len() != v2.len():
        return nil
    var result = []
    var i = 0
    while i < v1.len():
        result.push(v1[i] + v2[i])
        i = i + 1
    result

fn la_vector_subtract(v1: [f64], v2: [f64]) -> [f64]?:
    """Subtract two vectors element-wise."""
    if v1.len() != v2.len():
        return nil
    var result = []
    var i = 0
    while i < v1.len():
        result.push(v1[i] - v2[i])
        i = i + 1
    result

fn la_vector_scalar_multiply(v: [f64], scalar: f64) -> [f64]:
    """Multiply vector by scalar."""
    var result = []
    for elem in v:
        result.push(elem * scalar)
    result

fn la_vector_dot(v1: [f64], v2: [f64]) -> f64?:
    """Calculate dot product of two vectors."""
    if v1.len() != v2.len():
        return nil
    var sum = 0.0
    var i = 0
    while i < v1.len():
        sum = sum + v1[i] * v2[i]
        i = i + 1
    sum

fn la_vector_cross(v1: [f64], v2: [f64]) -> [f64]?:
    """Calculate cross product of two 3D vectors."""
    if v1.len() != 3 or v2.len() != 3:
        return nil
    val x = v1[1] * v2[2] - v1[2] * v2[1]
    val y = v1[2] * v2[0] - v1[0] * v2[2]
    val z = v1[0] * v2[1] - v1[1] * v2[0]
    [x, y, z]

fn la_vector_magnitude(v: [f64]) -> f64?:
    """Calculate magnitude (L2 norm) of vector."""
    val dot = la_vector_dot(v, v)
    if not dot.?:
        return nil
    var sqrt_val = dot
    var iteration = 0
    while iteration < 20:
        if sqrt_val == 0.0:
            return 0.0
        sqrt_val = (sqrt_val + dot / sqrt_val) / 2.0
        iteration = iteration + 1
    sqrt_val

fn la_vector_normalize(v: [f64]) -> [f64]?:
    """Normalize vector to unit length."""
    val mag = la_vector_magnitude(v)
    if not mag.?:
        return nil
    if mag < LA_EPSILON:
        return nil
    la_vector_scalar_multiply(v, 1.0 / mag)

fn la_vector_project(v: [f64], onto: [f64]) -> [f64]?:
    """Project vector v onto vector 'onto'."""
    val dot_v_onto = la_vector_dot(v, onto)
    if not dot_v_onto.?:
        return nil
    val dot_onto_onto = la_vector_dot(onto, onto)
    if not dot_onto_onto.?:
        return nil
    if dot_onto_onto < LA_EPSILON:
        return nil
    val scalar = dot_v_onto / dot_onto_onto
    la_vector_scalar_multiply(onto, scalar)

fn la_vector_reject(v: [f64], from: [f64]) -> [f64]?:
    """Reject vector v from vector 'from' (orthogonal complement of projection)."""
    val proj = la_vector_project(v, from)
    if not proj.?:
        return nil
    la_vector_subtract(v, proj)

fn la_vector_angle(v1: [f64], v2: [f64]) -> f64?:
    """Calculate angle between two vectors in radians."""
    val dot = la_vector_dot(v1, v2)
    if not dot.?:
        return nil
    val mag1 = la_vector_magnitude(v1)
    if not mag1.?:
        return nil
    val mag2 = la_vector_magnitude(v2)
    if not mag2.?:
        return nil
    if mag1 < LA_EPSILON or mag2 < LA_EPSILON:
        return nil
    var cos_theta = dot / (mag1 * mag2)
    if cos_theta > 1.0:
        cos_theta = 1.0
    if cos_theta < -1.0:
        cos_theta = -1.0
    var angle = cos_theta
    var iteration = 0
    while iteration < 20:
        val sin_val = angle - cos_theta
        angle = angle - sin_val * 0.1
        iteration = iteration + 1
    angle

fn la_vector_distance(v1: [f64], v2: [f64]) -> f64?:
    """Calculate Euclidean distance between two vectors."""
    val diff = la_vector_subtract(v1, v2)
    if not diff.?:
        return nil
    la_vector_magnitude(diff)

fn la_vector_outer_product(v1: [f64], v2: [f64]) -> [[f64]]:
    """Calculate outer product (tensor product) of two vectors.

    Returns matrix where result[i][j] = v1[i] * v2[j].
    """
    var result = []
    for elem1 in v1:
        var row = []
        for elem2 in v2:
            row.push(elem1 * elem2)
        result.push(row)
    result

# ============================================================================
# Vector Spaces
# ============================================================================

fn la_vectors_are_linearly_independent(vectors: [[f64]]) -> bool:
    """Check if set of vectors are linearly independent.

    Vectors should be column vectors (each vector is [f64]).
    """
    if vectors.len() == 0:
        return false
    val matrix = la_matrix_from_columns(vectors)
    val rank = la_matrix_rank(matrix)
    rank == vectors.len()

fn la_vector_span_contains(vectors: [[f64]], target: [f64]) -> bool:
    """Check if target vector is in the span of given vectors."""
    if vectors.len() == 0:
        return false
    val matrix = la_matrix_from_columns(vectors)
    var augmented = []
    var i = 0
    while i < matrix.len():
        var row = []
        for elem in matrix[i]:
            row.push(elem)
        row.push(target[i])
        augmented.push(row)
        i = i + 1
    val rank_orig = la_matrix_rank(matrix)
    val rank_aug = la_matrix_rank(augmented)
    rank_orig == rank_aug

fn la_gram_schmidt(vectors: [[f64]]) -> [[f64]]?:
    """Gram-Schmidt orthogonalization of vectors.

    Returns orthonormal basis from given vectors.
    """
    var orthonormal = []
    for v in vectors:
        var u = v
        for ortho in orthonormal:
            val proj = la_vector_project(u, ortho)
            if not proj.?:
                return nil
            val diff = la_vector_subtract(u, proj)
            if not diff.?:
                return nil
            u = diff
        val normalized = la_vector_normalize(u)
        if not normalized.?:
            return nil
        orthonormal.push(normalized)
    orthonormal

fn la_vector_basis_dimension(vectors: [[f64]]) -> i64:
    """Calculate dimension of vector space spanned by vectors."""
    if vectors.len() == 0:
        return 0
    val matrix = la_matrix_from_columns(vectors)
    la_matrix_rank(matrix)

# ============================================================================
# System Solving
# ============================================================================

fn la_solve_gaussian_elimination(a: [[f64]], b: [f64]) -> [f64]?:
    """Solve system Ax = b using Gaussian elimination."""
    val dims = la_matrix_dimensions(a)
    val rows = dims[0]
    val cols = dims[1]
    if b.len() != rows:
        return nil
    var augmented = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            row.push(a[i][j])
            j = j + 1
        row.push(b[i])
        augmented.push(row)
        i = i + 1
    val rref = la_matrix_rref(augmented)
    var x = []
    i = 0
    while i < cols:
        x.push(0.0)
        i = i + 1
    i = rows - 1
    while i >= 0:
        var pivot_col = -1
        var j = 0
        while j < cols:
            var abs_val = rref[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                pivot_col = j
                j = cols
            j = j + 1
        if pivot_col >= 0:
            var sum = rref[i][cols]
            j = pivot_col + 1
            while j < cols:
                sum = sum - rref[i][j] * x[j]
                j = j + 1
            x[pivot_col] = sum
        i = i - 1
    x

fn la_solve_lu(a: [[f64]], b: [f64]) -> [f64]?:
    """Solve system Ax = b using LU decomposition."""
    val lu_result = la_matrix_lu_decomposition(a)
    if not lu_result.?:
        return nil
    val lower = lu_result[0]
    val upper = lu_result[1]
    val n = lower.len()
    var y = []
    var i = 0
    while i < n:
        y.push(0.0)
        i = i + 1
    i = 0
    while i < n:
        var sum = b[i]
        var j = 0
        while j < i:
            sum = sum - lower[i][j] * y[j]
            j = j + 1
        y[i] = sum
        i = i + 1
    var x = []
    i = 0
    while i < n:
        x.push(0.0)
        i = i + 1
    i = n - 1
    while i >= 0:
        var sum = y[i]
        var j = i + 1
        while j < n:
            sum = sum - upper[i][j] * x[j]
            j = j + 1
        x[i] = sum / upper[i][i]
        i = i - 1
    x

fn la_solve_least_squares(a: [[f64]], b: [f64]) -> [f64]?:
    """Solve least squares problem using normal equations.

    Solves (A^T A) x = A^T b.
    """
    val at = la_matrix_transpose(a)
    val ata = la_matrix_multiply(at, a)
    if not ata.?:
        return nil
    val atb = la_matrix_vector_multiply(at, b)
    if not atb.?:
        return nil
    la_solve_gaussian_elimination(ata, atb)

fn la_solve_iterative(a: [[f64]], b: [f64], max_iter: i64) -> [f64]?:
    """Solve system using Jacobi iteration.

    Simple iterative method for diagonally dominant systems.
    """
    val dims = la_matrix_dimensions(a)
    val n = dims[0]
    if b.len() != n:
        return nil
    var x = []
    var i = 0
    while i < n:
        x.push(0.0)
        i = i + 1
    var iteration = 0
    while iteration < max_iter:
        var x_new = []
        i = 0
        while i < n:
            var sum = b[i]
            var j = 0
            while j < n:
                if i != j:
                    sum = sum - a[i][j] * x[j]
                j = j + 1
            x_new.push(sum / a[i][i])
            i = i + 1
        x = x_new
        iteration = iteration + 1
    x

# ============================================================================
# Eigenvalues and Eigenvectors
# ============================================================================

fn la_power_iteration(matrix: [[f64]], max_iter: i64) -> (f64, [f64])?:
    """Find dominant eigenvalue and eigenvector using power iteration."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    var v = []
    var i = 0
    while i < n:
        v.push(1.0)
        i = i + 1
    var iteration = 0
    while iteration < max_iter:
        val mv = la_matrix_vector_multiply(matrix, v)
        if not mv.?:
            return nil
        val norm = la_vector_magnitude(mv)
        if not norm.?:
            return nil
        if norm < LA_EPSILON:
            return nil
        val v_new = la_vector_scalar_multiply(mv, 1.0 / norm)
        v = v_new
        iteration = iteration + 1
    val mv_final = la_matrix_vector_multiply(matrix, v)
    if not mv_final.?:
        return nil
    val eigenvalue = la_vector_dot(mv_final, v)
    if not eigenvalue.?:
        return nil
    (eigenvalue, v)

fn la_inverse_power_iteration(matrix: [[f64]], max_iter: i64) -> (f64, [f64])?:
    """Find smallest eigenvalue using inverse power iteration."""
    val inv = la_matrix_inverse(matrix)
    if not inv.?:
        return nil
    val result = la_power_iteration(inv, max_iter)
    if not result.?:
        return nil
    val inv_eigenvalue = result[0]
    val eigenvector = result[1]
    val eigenvalue = 1.0 / inv_eigenvalue
    (eigenvalue, eigenvector)

fn la_qr_algorithm(matrix: [[f64]], max_iter: i64) -> [f64]?:
    """Estimate eigenvalues using QR algorithm.

    Returns approximate eigenvalues (diagonal of final matrix).
    """
    if not la_matrix_is_square(matrix):
        return nil
    var a = matrix
    var iteration = 0
    while iteration < max_iter:
        val qr = la_matrix_qr_decomposition(a)
        if not qr.?:
            return nil
        val q = qr[0]
        val r = qr[1]
        val rq = la_matrix_multiply(r, q)
        if not rq.?:
            return nil
        a = rq
        iteration = iteration + 1
    la_matrix_diagonal_elements(a)

fn la_eigenvalue_estimate(matrix: [[f64]]) -> [f64]?:
    """Estimate eigenvalues using QR algorithm with 100 iterations."""
    la_qr_algorithm(matrix, 100)

# ============================================================================
# Norms
# ============================================================================

fn la_vector_norm_l1(v: [f64]) -> f64:
    """Calculate L1 norm (sum of absolute values)."""
    var sum = 0.0
    for elem in v:
        var abs_elem = elem
        if abs_elem < 0.0:
            abs_elem = -abs_elem
        sum = sum + abs_elem
    sum

fn la_vector_norm_l2(v: [f64]) -> f64?:
    """Calculate L2 norm (Euclidean norm)."""
    la_vector_magnitude(v)

fn la_vector_norm_inf(v: [f64]) -> f64:
    """Calculate infinity norm (maximum absolute value)."""
    var max_val = 0.0
    for elem in v:
        var abs_elem = elem
        if abs_elem < 0.0:
            abs_elem = -abs_elem
        if abs_elem > max_val:
            max_val = abs_elem
    max_val

fn la_matrix_norm_frobenius(matrix: [[f64]]) -> f64:
    """Calculate Frobenius norm (square root of sum of squared elements)."""
    var sum = 0.0
    for row in matrix:
        for elem in row:
            sum = sum + elem * elem
    var sqrt_val = sum
    var iteration = 0
    while iteration < 20:
        if sqrt_val == 0.0:
            return 0.0
        sqrt_val = (sqrt_val + sum / sqrt_val) / 2.0
        iteration = iteration + 1
    sqrt_val

fn la_matrix_norm_l1(matrix: [[f64]]) -> f64:
    """Calculate L1 norm (maximum absolute column sum)."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var max_sum = 0.0
    var j = 0
    while j < cols:
        var col_sum = 0.0
        var i = 0
        while i < rows:
            var abs_elem = matrix[i][j]
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            col_sum = col_sum + abs_elem
            i = i + 1
        if col_sum > max_sum:
            max_sum = col_sum
        j = j + 1
    max_sum

fn la_matrix_norm_inf(matrix: [[f64]]) -> f64:
    """Calculate infinity norm (maximum absolute row sum)."""
    var max_sum = 0.0
    for row in matrix:
        var row_sum = 0.0
        for elem in row:
            var abs_elem = elem
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            row_sum = row_sum + abs_elem
        if row_sum > max_sum:
            max_sum = row_sum
    max_sum

# ============================================================================
# Matrix-Vector Operations
# ============================================================================

fn la_matrix_vector_multiply(matrix: [[f64]], vector: [f64]) -> [f64]?:
    """Multiply matrix by column vector."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if cols != vector.len():
        return nil
    var result = []
    var i = 0
    while i < rows:
        var sum = 0.0
        var j = 0
        while j < cols:
            sum = sum + matrix[i][j] * vector[j]
            j = j + 1
        result.push(sum)
        i = i + 1
    result

# ============================================================================
# Utility Functions
# ============================================================================

fn la_matrix_copy(matrix: [[f64]]) -> [[f64]]:
    """Create deep copy of matrix."""
    var result = []
    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem)
        result.push(new_row)
    result

fn la_vector_copy(vector: [f64]) -> [f64]:
    """Create copy of vector."""
    var result = []
    for elem in vector:
        result.push(elem)
    result

fn la_matrix_fill(matrix: [[f64]], value: f64) -> [[f64]]:
    """Fill all elements of matrix with value."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    la_matrix_create(rows, cols, value)

fn la_vector_fill(size: i64, value: f64) -> [f64]:
    """Create vector filled with value."""
    var result = []
    var i = 0
    while i < size:
        result.push(value)
        i = i + 1
    result

fn la_matrix_equals(m1: [[f64]], m2: [[f64]]) -> bool:
    """Check if two matrices are exactly equal."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return false
    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            if m1[i][j] != m2[i][j]:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_close(m1: [[f64]], m2: [[f64]], tolerance: f64) -> bool:
    """Check if two matrices are approximately equal within tolerance."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return false
    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            val diff = m1[i][j] - m2[i][j]
            var abs_diff = diff
            if abs_diff < 0.0:
                abs_diff = -abs_diff
            if abs_diff > tolerance:
                return false
            j = j + 1
        i = i + 1
    true

fn la_vector_equals(v1: [f64], v2: [f64]) -> bool:
    """Check if two vectors are exactly equal."""
    if v1.len() != v2.len():
        return false
    var i = 0
    while i < v1.len():
        if v1[i] != v2[i]:
            return false
        i = i + 1
    true

fn la_vector_is_close(v1: [f64], v2: [f64], tolerance: f64) -> bool:
    """Check if two vectors are approximately equal within tolerance."""
    if v1.len() != v2.len():
        return false
    var i = 0
    while i < v1.len():
        val diff = v1[i] - v2[i]
        var abs_diff = diff
        if abs_diff < 0.0:
            abs_diff = -abs_diff
        if abs_diff > tolerance:
            return false
        i = i + 1
    true

# ============================================================================
# Exports (Comprehensive - 80+ functions)
# ============================================================================

export LA_EPSILON, LA_MAX_ITERATIONS

# Matrix Creation (9 functions)
export la_matrix_create, la_matrix_zero, la_matrix_ones, la_matrix_identity
export la_matrix_diagonal, la_matrix_from_rows, la_matrix_from_columns
export la_matrix_symmetric, la_matrix_random

# Matrix Access (7 functions)
export la_matrix_get, la_matrix_set, la_matrix_get_row, la_matrix_get_column
export la_matrix_dimensions, la_matrix_shape, la_matrix_diagonal_elements

# Matrix Properties (11 functions)
export la_matrix_is_square, la_matrix_is_symmetric, la_matrix_is_diagonal
export la_matrix_is_orthogonal, la_matrix_is_upper_triangular, la_matrix_is_lower_triangular
export la_matrix_trace, la_matrix_rank, la_matrix_condition_number

# Matrix Arithmetic (7 functions)
export la_matrix_add, la_matrix_subtract, la_matrix_multiply
export la_matrix_scalar_multiply, la_matrix_element_multiply
export la_matrix_negate, la_matrix_power

# Matrix Transformations (7 functions)
export la_matrix_transpose, la_matrix_conjugate_transpose, la_matrix_inverse
export la_matrix_minor, la_matrix_cofactor, la_matrix_adjugate

# Matrix Operations (4 functions)
export la_matrix_determinant, la_matrix_row_reduce, la_matrix_ref, la_matrix_rref

# Matrix Decomposition (4 functions)
export la_matrix_lu_decomposition, la_matrix_qr_decomposition
export la_matrix_cholesky_decomposition, la_matrix_svd_power_iteration

# Vector Operations (13 functions)
export la_vector_add, la_vector_subtract, la_vector_scalar_multiply
export la_vector_dot, la_vector_cross, la_vector_magnitude
export la_vector_normalize, la_vector_project, la_vector_reject
export la_vector_angle, la_vector_distance, la_vector_outer_product

# Vector Spaces (4 functions)
export la_vectors_are_linearly_independent, la_vector_span_contains
export la_gram_schmidt, la_vector_basis_dimension

# System Solving (4 functions)
export la_solve_gaussian_elimination, la_solve_lu
export la_solve_least_squares, la_solve_iterative

# Eigenvalues/Eigenvectors (4 functions)
export la_power_iteration, la_inverse_power_iteration
export la_qr_algorithm, la_eigenvalue_estimate

# Norms (6 functions)
export la_vector_norm_l1, la_vector_norm_l2, la_vector_norm_inf
export la_matrix_norm_frobenius, la_matrix_norm_l1, la_matrix_norm_inf

# Matrix-Vector Operations (1 function)
export la_matrix_vector_multiply

# Utility (9 functions)
export la_matrix_copy, la_vector_copy, la_matrix_fill, la_vector_fill
export la_matrix_equals, la_matrix_is_close, la_vector_equals, la_vector_is_close
