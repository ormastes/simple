# Quadtree Spatial Partitioning Utilities
# Efficient 2D spatial data structure for point storage and range queries

# Point representation: (x, y, data)
# Bounds representation: (min_x, min_y, max_x, max_y)
# Quadtree node: (tag, bounds, capacity, points, children)
#   tag: "leaf" or "internal"
#   bounds: bounding box tuple
#   capacity: max points before split (leaf only)
#   points: list of points (leaf only)
#   children: (nw, ne, sw, se) quadrants (internal only)

# === Point Operations ===

fn point_new(x, y, data):
    # Create a new point with coordinates and associated data
    (x, y, data)

fn point_x(point):
    # Get x coordinate of point
    val p = point
    p[0]

fn point_y(point):
    # Get y coordinate of point
    val p = point
    p[1]

fn point_data(point):
    # Get associated data from point
    val p = point
    p[2]

fn point_distance(p1, p2):
    # Calculate Euclidean distance between two points
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val dx = x2 - x1
    val dy = y2 - y1
    val sum = dx * dx + dy * dy
    sqrt(sum)

fn point_distance_squared(p1, p2):
    # Calculate squared distance (faster, no sqrt)
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val dx = x2 - x1
    val dy = y2 - y1
    dx * dx + dy * dy

fn point_equals(p1, p2):
    # Check if two points have same coordinates
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val same_x = x1 == x2
    val same_y = y1 == y2
    same_x and same_y

fn point_midpoint(p1, p2):
    # Calculate midpoint between two points
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val mx = (x1 + x2) / 2.0
    val my = (y1 + y2) / 2.0
    point_new(mx, my, nil)

fn point_to_string(point):
    # Convert point to string representation
    val x = point_x(point)
    val y = point_y(point)
    val data = point_data(point)
    "Point({x}, {y}, {data})"

# === Bounds Operations ===

fn bounds_new(min_x, min_y, max_x, max_y):
    # Create a new bounding box
    (min_x, min_y, max_x, max_y)

fn bounds_min_x(bounds):
    # Get minimum x coordinate
    val b = bounds
    b[0]

fn bounds_min_y(bounds):
    # Get minimum y coordinate
    val b = bounds
    b[1]

fn bounds_max_x(bounds):
    # Get maximum x coordinate
    val b = bounds
    b[2]

fn bounds_max_y(bounds):
    # Get maximum y coordinate
    val b = bounds
    b[3]

fn bounds_width(bounds):
    # Calculate width of bounds
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    max_x - min_x

fn bounds_height(bounds):
    # Calculate height of bounds
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)
    max_y - min_y

fn bounds_center_x(bounds):
    # Get center x coordinate
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    (min_x + max_x) / 2.0

fn bounds_center_y(bounds):
    # Get center y coordinate
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)
    (min_y + max_y) / 2.0

fn bounds_center(bounds):
    # Get center point of bounds
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    point_new(cx, cy, nil)

fn bounds_contains_point(bounds, point):
    # Check if bounds contains a point
    val x = point_x(point)
    val y = point_y(point)
    val min_x = bounds_min_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_x = bounds_max_x(bounds)
    val max_y = bounds_max_y(bounds)
    val in_x = x >= min_x and x <= max_x
    val in_y = y >= min_y and y <= max_y
    in_x and in_y

fn bounds_intersects_bounds(b1, b2):
    # Check if two bounds intersect
    val min_x1 = bounds_min_x(b1)
    val max_x1 = bounds_max_x(b1)
    val min_y1 = bounds_min_y(b1)
    val max_y1 = bounds_max_y(b1)
    val min_x2 = bounds_min_x(b2)
    val max_x2 = bounds_max_x(b2)
    val min_y2 = bounds_min_y(b2)
    val max_y2 = bounds_max_y(b2)
    val no_overlap_x = max_x1 < min_x2 or max_x2 < min_x1
    val no_overlap_y = max_y1 < min_y2 or max_y2 < min_y1
    val overlaps = not no_overlap_x
    val overlaps_y = not no_overlap_y
    overlaps and overlaps_y

fn bounds_contains_bounds(outer, inner):
    # Check if outer bounds completely contains inner bounds
    val min_x1 = bounds_min_x(outer)
    val max_x1 = bounds_max_x(outer)
    val min_y1 = bounds_min_y(outer)
    val max_y1 = bounds_max_y(outer)
    val min_x2 = bounds_min_x(inner)
    val max_x2 = bounds_max_x(inner)
    val min_y2 = bounds_min_y(inner)
    val max_y2 = bounds_max_y(inner)
    val contains_x = min_x2 >= min_x1 and max_x2 <= max_x1
    val contains_y = min_y2 >= min_y1 and max_y2 <= max_y1
    contains_x and contains_y

fn bounds_intersects_circle(bounds, center_x, center_y, radius):
    # Check if bounds intersects with a circle
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)

    # Find closest point on bounds to circle center
    var closest_x = center_x
    if center_x < min_x:
        closest_x = min_x
    if center_x > max_x:
        closest_x = max_x

    var closest_y = center_y
    if center_y < min_y:
        closest_y = min_y
    if center_y > max_y:
        closest_y = max_y

    # Check if closest point is within radius
    val dx = center_x - closest_x
    val dy = center_y - closest_y
    val dist_sq = dx * dx + dy * dy
    val radius_sq = radius * radius
    dist_sq <= radius_sq

fn bounds_area(bounds):
    # Calculate area of bounds
    val w = bounds_width(bounds)
    val h = bounds_height(bounds)
    w * h

fn bounds_to_string(bounds):
    # Convert bounds to string representation
    val min_x = bounds_min_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_x = bounds_max_x(bounds)
    val max_y = bounds_max_y(bounds)
    "Bounds({min_x}, {min_y}, {max_x}, {max_y})"

# === Quadrant Operations ===

fn quadrant_nw_bounds(bounds):
    # Get northwest quadrant bounds
    val min_x = bounds_min_x(bounds)
    val min_y = bounds_min_y(bounds)
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    bounds_new(min_x, min_y, cx, cy)

fn quadrant_ne_bounds(bounds):
    # Get northeast quadrant bounds
    val cx = bounds_center_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_x = bounds_max_x(bounds)
    val cy = bounds_center_y(bounds)
    bounds_new(cx, min_y, max_x, cy)

fn quadrant_sw_bounds(bounds):
    # Get southwest quadrant bounds
    val min_x = bounds_min_x(bounds)
    val cy = bounds_center_y(bounds)
    val cx = bounds_center_x(bounds)
    val max_y = bounds_max_y(bounds)
    bounds_new(min_x, cy, cx, max_y)

fn quadrant_se_bounds(bounds):
    # Get southeast quadrant bounds
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    val max_x = bounds_max_x(bounds)
    val max_y = bounds_max_y(bounds)
    bounds_new(cx, cy, max_x, max_y)

fn quadrant_for_point(bounds, point):
    # Determine which quadrant a point belongs to (0=NW, 1=NE, 2=SW, 3=SE)
    val x = point_x(point)
    val y = point_y(point)
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    val is_west = x < cx
    val is_north = y < cy

    if is_north and is_west:
        0  # NW
    else:
        if is_north:
            1  # NE
        else:
            if is_west:
                2  # SW
            else:
                3  # SE

# === Quadtree Node Operations ===

fn node_new_leaf(bounds, capacity):
    # Create a new leaf node
    val tag = "leaf"
    val points = []
    val children = nil
    (tag, bounds, capacity, points, children)

fn node_new_internal(bounds, nw, ne, sw, se):
    # Create a new internal node with four children
    val tag = "internal"
    val capacity = 0
    val points = nil
    val children = (nw, ne, sw, se)
    (tag, bounds, capacity, points, children)

fn node_tag(node):
    # Get node tag (leaf or internal)
    val n = node
    n[0]

fn node_bounds(node):
    # Get node bounds
    val n = node
    n[1]

fn node_capacity(node):
    # Get node capacity (leaf only)
    val n = node
    n[2]

fn node_points(node):
    # Get node points (leaf only)
    val n = node
    n[3]

fn node_children(node):
    # Get node children (internal only)
    val n = node
    n[4]

fn node_is_leaf(node):
    # Check if node is a leaf
    val tag = node_tag(node)
    tag == "leaf"

fn node_is_internal(node):
    # Check if node is internal
    val tag = node_tag(node)
    tag == "internal"

fn node_child_nw(node):
    # Get northwest child
    val children = node_children(node)
    val c = children
    c[0]

fn node_child_ne(node):
    # Get northeast child
    val children = node_children(node)
    val c = children
    c[1]

fn node_child_sw(node):
    # Get southwest child
    val children = node_children(node)
    val c = children
    c[2]

fn node_child_se(node):
    # Get southeast child
    val children = node_children(node)
    val c = children
    c[3]

fn node_point_count(node):
    # Count total points in node and descendants
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        val points = node_points(node)
        len(points)
    else:
        val nw = node_child_nw(node)
        val ne = node_child_ne(node)
        val sw = node_child_sw(node)
        val se = node_child_se(node)
        val count_nw = node_point_count(nw)
        val count_ne = node_point_count(ne)
        val count_sw = node_point_count(sw)
        val count_se = node_point_count(se)
        val sum1 = count_nw + count_ne
        val sum2 = count_sw + count_se
        sum1 + sum2

fn node_depth(node):
    # Calculate depth of tree from this node
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        1
    else:
        val nw = node_child_nw(node)
        val ne = node_child_ne(node)
        val sw = node_child_sw(node)
        val se = node_child_se(node)
        val depth_nw = node_depth(nw)
        val depth_ne = node_depth(ne)
        val depth_sw = node_depth(sw)
        val depth_se = node_depth(se)
        var max_depth = depth_nw
        if depth_ne > max_depth:
            max_depth = depth_ne
        if depth_sw > max_depth:
            max_depth = depth_sw
        if depth_se > max_depth:
            max_depth = depth_se
        max_depth + 1

# === Quadtree Insert Operations ===

fn node_subdivide(node):
    # Subdivide a leaf node into four children
    val bounds = node_bounds(node)
    val capacity = node_capacity(node)
    val points = node_points(node)

    # Create four child nodes
    val nw_bounds = quadrant_nw_bounds(bounds)
    val ne_bounds = quadrant_ne_bounds(bounds)
    val sw_bounds = quadrant_sw_bounds(bounds)
    val se_bounds = quadrant_se_bounds(bounds)

    var nw = node_new_leaf(nw_bounds, capacity)
    var ne = node_new_leaf(ne_bounds, capacity)
    var sw = node_new_leaf(sw_bounds, capacity)
    var se = node_new_leaf(se_bounds, capacity)

    # Redistribute points to children
    var i = 0
    val point_count = len(points)
    while i < point_count:
        val point = points[i]
        val quadrant = quadrant_for_point(bounds, point)
        if quadrant == 0:
            nw = node_insert_point(nw, point)
        else:
            if quadrant == 1:
                ne = node_insert_point(ne, point)
            else:
                if quadrant == 2:
                    sw = node_insert_point(sw, point)
                else:
                    se = node_insert_point(se, point)
        i = i + 1

    # Create internal node
    node_new_internal(bounds, nw, ne, sw, se)

fn node_insert_point(node, point):
    # Insert a point into the node
    val bounds = node_bounds(node)
    val contains = bounds_contains_point(bounds, point)
    if not contains:
        node
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            val capacity = node_capacity(node)
            val count = len(points)
            val has_space = count < capacity
            if has_space:
                val new_points = points + [point]
                val tag = node_tag(node)
                val children = node_children(node)
                (tag, bounds, capacity, new_points, children)
            else:
                # Need to subdivide
                val subdivided = node_subdivide(node)
                node_insert_point(subdivided, point)
        else:
            # Internal node - insert into appropriate child
            val quadrant = quadrant_for_point(bounds, point)
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)

            if quadrant == 0:
                val new_nw = node_insert_point(nw, point)
                node_new_internal(bounds, new_nw, ne, sw, se)
            else:
                if quadrant == 1:
                    val new_ne = node_insert_point(ne, point)
                    node_new_internal(bounds, nw, new_ne, sw, se)
                else:
                    if quadrant == 2:
                        val new_sw = node_insert_point(sw, point)
                        node_new_internal(bounds, nw, ne, new_sw, se)
                    else:
                        val new_se = node_insert_point(se, point)
                        node_new_internal(bounds, nw, ne, sw, new_se)

# === Quadtree Query Operations ===

fn node_query_range_helper(node, range_bounds, result):
    # Helper to collect points within range bounds
    val bounds = node_bounds(node)
    val intersects = bounds_intersects_bounds(bounds, range_bounds)
    if not intersects:
        result
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            var i = 0
            val count = len(points)
            var acc = result
            while i < count:
                val point = points[i]
                val in_range = bounds_contains_point(range_bounds, point)
                if in_range:
                    acc = acc + [point]
                i = i + 1
            acc
        else:
            # Check all four children
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)
            var acc = result
            acc = node_query_range_helper(nw, range_bounds, acc)
            acc = node_query_range_helper(ne, range_bounds, acc)
            acc = node_query_range_helper(sw, range_bounds, acc)
            acc = node_query_range_helper(se, range_bounds, acc)
            acc

fn node_query_range(node, range_bounds):
    # Query all points within a rectangular range
    node_query_range_helper(node, range_bounds, [])

fn node_query_radius_helper(node, center_x, center_y, radius, result):
    # Helper to collect points within circular radius
    val bounds = node_bounds(node)
    val intersects = bounds_intersects_circle(bounds, center_x, center_y, radius)
    if not intersects:
        result
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            var i = 0
            val count = len(points)
            var acc = result
            val radius_sq = radius * radius
            while i < count:
                val point = points[i]
                val px = point_x(point)
                val py = point_y(point)
                val dx = px - center_x
                val dy = py - center_y
                val dist_sq = dx * dx + dy * dy
                val in_radius = dist_sq <= radius_sq
                if in_radius:
                    acc = acc + [point]
                i = i + 1
            acc
        else:
            # Check all four children
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)
            var acc = result
            acc = node_query_radius_helper(nw, center_x, center_y, radius, acc)
            acc = node_query_radius_helper(ne, center_x, center_y, radius, acc)
            acc = node_query_radius_helper(sw, center_x, center_y, radius, acc)
            acc = node_query_radius_helper(se, center_x, center_y, radius, acc)
            acc

fn node_query_radius(node, center_x, center_y, radius):
    # Query all points within a circular radius
    node_query_radius_helper(node, center_x, center_y, radius, [])

fn node_nearest_neighbor_helper(node, target_x, target_y, best_point, best_dist_sq):
    # Helper to find nearest neighbor
    val bounds = node_bounds(node)

    # Early exit if this node can't have a closer point
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)

    var closest_x = target_x
    if target_x < min_x:
        closest_x = min_x
    if target_x > max_x:
        closest_x = max_x

    var closest_y = target_y
    if target_y < min_y:
        closest_y = min_y
    if target_y > max_y:
        closest_y = max_y

    val dx = target_x - closest_x
    val dy = target_y - closest_y
    val min_possible_dist_sq = dx * dx + dy * dy

    val has_best = best_point != nil
    if has_best:
        val too_far = min_possible_dist_sq > best_dist_sq
        if too_far:
            (best_point, best_dist_sq)
        else:
            node_nearest_neighbor_search(node, target_x, target_y, best_point, best_dist_sq)
    else:
        node_nearest_neighbor_search(node, target_x, target_y, best_point, best_dist_sq)

fn node_nearest_neighbor_search(node, target_x, target_y, best_point, best_dist_sq):
    # Core search logic for nearest neighbor
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        val points = node_points(node)
        var i = 0
        val count = len(points)
        var curr_best = best_point
        var curr_best_dist = best_dist_sq
        while i < count:
            val point = points[i]
            val px = point_x(point)
            val py = point_y(point)
            val dx = px - target_x
            val dy = py - target_y
            val dist_sq = dx * dx + dy * dy
            val has_curr = curr_best != nil
            if has_curr:
                val is_closer = dist_sq < curr_best_dist
                if is_closer:
                    curr_best = point
                    curr_best_dist = dist_sq
            else:
                curr_best = point
                curr_best_dist = dist_sq
            i = i + 1
        (curr_best, curr_best_dist)
    else:
        # Check children in order of proximity to target
        val nw = node_child_nw(node)
        val ne = node_child_ne(node)
        val sw = node_child_sw(node)
        val se = node_child_se(node)

        # Determine order by target location
        val bounds = node_bounds(node)
        val cx = bounds_center_x(bounds)
        val cy = bounds_center_y(bounds)
        val is_west = target_x < cx
        val is_north = target_y < cy

        var result = (best_point, best_dist_sq)

        # Search closest quadrant first
        if is_north and is_west:
            result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])
            result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
            result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
            result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
        else:
            if is_north:
                result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
                result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])
                result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
                result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
            else:
                if is_west:
                    result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
                else:
                    result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])

        result

fn node_nearest_neighbor(node, target_x, target_y):
    # Find nearest neighbor to target coordinates
    val result = node_nearest_neighbor_helper(node, target_x, target_y, nil, 0.0)
    result[0]

# === Quadtree Remove Operations ===

fn node_remove_point_helper(node, target_point):
    # Helper to remove a point from the tree
    val bounds = node_bounds(node)
    val contains = bounds_contains_point(bounds, target_point)
    if not contains:
        (node, false)
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            var new_points = []
            var i = 0
            val count = len(points)
            var found = false
            while i < count:
                val point = points[i]
                val is_match = point_equals(point, target_point)
                if is_match and not found:
                    found = true
                else:
                    new_points = new_points + [point]
                i = i + 1

            if found:
                val tag = node_tag(node)
                val capacity = node_capacity(node)
                val children = node_children(node)
                val new_node = (tag, bounds, capacity, new_points, children)
                (new_node, true)
            else:
                (node, false)
        else:
            # Try removing from children
            val quadrant = quadrant_for_point(bounds, target_point)
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)

            if quadrant == 0:
                val result = node_remove_point_helper(nw, target_point)
                val new_nw = result[0]
                val removed = result[1]
                val new_node = node_new_internal(bounds, new_nw, ne, sw, se)
                (new_node, removed)
            else:
                if quadrant == 1:
                    val result = node_remove_point_helper(ne, target_point)
                    val new_ne = result[0]
                    val removed = result[1]
                    val new_node = node_new_internal(bounds, nw, new_ne, sw, se)
                    (new_node, removed)
                else:
                    if quadrant == 2:
                        val result = node_remove_point_helper(sw, target_point)
                        val new_sw = result[0]
                        val removed = result[1]
                        val new_node = node_new_internal(bounds, nw, ne, new_sw, se)
                        (new_node, removed)
                    else:
                        val result = node_remove_point_helper(se, target_point)
                        val new_se = result[0]
                        val removed = result[1]
                        val new_node = node_new_internal(bounds, nw, ne, sw, new_se)
                        (new_node, removed)

fn node_remove_point(node, target_point):
    # Remove a point from the tree
    val result = node_remove_point_helper(node, target_point)
    result[0]

# === Quadtree Public API ===

fn quadtree_new(min_x, min_y, max_x, max_y, capacity):
    # Create a new quadtree with given bounds and capacity
    val bounds = bounds_new(min_x, min_y, max_x, max_y)
    node_new_leaf(bounds, capacity)

fn quadtree_insert(tree, x, y, data):
    # Insert a point into the quadtree
    val point = point_new(x, y, data)
    node_insert_point(tree, point)

fn quadtree_query_range(tree, min_x, min_y, max_x, max_y):
    # Query all points in a rectangular range
    val range_bounds = bounds_new(min_x, min_y, max_x, max_y)
    node_query_range(tree, range_bounds)

fn quadtree_query_radius(tree, center_x, center_y, radius):
    # Query all points within a circular radius
    node_query_radius(tree, center_x, center_y, radius)

fn quadtree_nearest(tree, x, y):
    # Find the nearest point to given coordinates
    node_nearest_neighbor(tree, x, y)

fn quadtree_remove(tree, x, y):
    # Remove a point at given coordinates
    val point = point_new(x, y, nil)
    node_remove_point(tree, point)

fn quadtree_count(tree):
    # Count total points in quadtree
    node_point_count(tree)

fn quadtree_depth(tree):
    # Get depth of quadtree
    node_depth(tree)

fn quadtree_bounds(tree):
    # Get bounds of quadtree
    node_bounds(tree)

# === Collision Detection ===

fn quadtree_find_collisions(tree, radius):
    # Find all pairs of points within radius of each other
    val all_points = node_query_range(tree, node_bounds(tree))
    var collisions = []
    var i = 0
    val count = len(all_points)
    while i < count:
        val p1 = all_points[i]
        val x = point_x(p1)
        val y = point_y(p1)
        val nearby = quadtree_query_radius(tree, x, y, radius)
        var j = 0
        val nearby_count = len(nearby)
        while j < nearby_count:
            val p2 = nearby[j]
            val is_same = point_equals(p1, p2)
            if not is_same:
                val dist = point_distance(p1, p2)
                val colliding = dist <= radius
                if colliding:
                    collisions = collisions + [(p1, p2)]
            j = j + 1
        i = i + 1
    collisions

fn quadtree_k_nearest(tree, x, y, k):
    # Find k nearest neighbors to point (simple implementation)
    val all_points = node_query_range(tree, node_bounds(tree))
    var distances = []
    var i = 0
    val count = len(all_points)
    val target = point_new(x, y, nil)
    while i < count:
        val point = all_points[i]
        val dist = point_distance(target, point)
        distances = distances + [(point, dist)]
        i = i + 1

    # Sort by distance (bubble sort for simplicity)
    var sorted = distances
    var n = len(sorted)
    var swapped = true
    while swapped:
        swapped = false
        var idx = 1
        while idx < n:
            val prev = sorted[idx - 1]
            val curr = sorted[idx]
            val prev_dist = prev[1]
            val curr_dist = curr[1]
            if prev_dist > curr_dist:
                var temp = sorted[idx - 1]
                sorted[idx - 1] = sorted[idx]
                sorted[idx] = temp
                swapped = true
            idx = idx + 1
        n = n - 1

    # Take first k
    var result = []
    var j = 0
    var max_j = k
    val sorted_count = len(sorted)
    if sorted_count < max_j:
        max_j = sorted_count
    while j < max_j:
        val entry = sorted[j]
        val point = entry[0]
        result = result + [point]
        j = j + 1
    result

# === Utility Functions ===

fn quadtree_all_points(tree):
    # Get all points in the quadtree
    val bounds = node_bounds(tree)
    node_query_range(tree, bounds)

fn quadtree_clear(tree):
    # Clear all points from quadtree
    val bounds = node_bounds(tree)
    val capacity = node_capacity(tree)
    node_new_leaf(bounds, capacity)

fn quadtree_to_list(tree):
    # Convert quadtree to flat list of points
    quadtree_all_points(tree)

fn quadtree_from_list(points, min_x, min_y, max_x, max_y, capacity):
    # Build quadtree from list of points
    var tree = quadtree_new(min_x, min_y, max_x, max_y, capacity)
    var i = 0
    val count = len(points)
    while i < count:
        val point = points[i]
        tree = node_insert_point(tree, point)
        i = i + 1
    tree

fn quadtree_is_empty(tree):
    # Check if quadtree is empty
    val count = quadtree_count(tree)
    count == 0

fn quadtree_contains(tree, x, y):
    # Check if quadtree contains a point at coordinates
    val bounds = node_bounds(tree)
    val point = point_new(x, y, nil)
    bounds_contains_point(bounds, point)
