# String Extension Methods
#
# Provides string utility functions not available as built-in methods.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - char_code: Get ASCII code of a single character
# - text_hash: FNV-1a hash for strings
# - text_trim_start_matches: Remove prefix pattern repeatedly
# - text_trim_end_matches: Remove suffix pattern repeatedly
# - text_contains_char: Check if string contains a character
# - text_index_of_char: Find index of character in string

# ============================================================================
# ASCII Character Code Lookup
# ============================================================================

fn char_code(c: text) -> i64:
    """Get ASCII code of a single character. Returns 0 for unknown characters.
    Note: Runtime's .to_int() returns 0 for single chars, so we use a lookup table."""
    if c == " ": return 32
    if c == "!": return 33
    if c == "#": return 35
    if c == "$": return 36
    if c == "%": return 37
    if c == "&": return 38
    if c == "'": return 39
    if c == "(": return 40
    if c == ")": return 41
    if c == "*": return 42
    if c == "+": return 43
    if c == ",": return 44
    if c == "-": return 45
    if c == ".": return 46
    if c == "/": return 47
    if c == "0": return 48
    if c == "1": return 49
    if c == "2": return 50
    if c == "3": return 51
    if c == "4": return 52
    if c == "5": return 53
    if c == "6": return 54
    if c == "7": return 55
    if c == "8": return 56
    if c == "9": return 57
    if c == ":": return 58
    if c == ";": return 59
    if c == "<": return 60
    if c == "=": return 61
    if c == ">": return 62
    if c == "?": return 63
    if c == "@": return 64
    if c == "A": return 65
    if c == "B": return 66
    if c == "C": return 67
    if c == "D": return 68
    if c == "E": return 69
    if c == "F": return 70
    if c == "G": return 71
    if c == "H": return 72
    if c == "I": return 73
    if c == "J": return 74
    if c == "K": return 75
    if c == "L": return 76
    if c == "M": return 77
    if c == "N": return 78
    if c == "O": return 79
    if c == "P": return 80
    if c == "Q": return 81
    if c == "R": return 82
    if c == "S": return 83
    if c == "T": return 84
    if c == "U": return 85
    if c == "V": return 86
    if c == "W": return 87
    if c == "X": return 88
    if c == "Y": return 89
    if c == "Z": return 90
    if c == "[": return 91
    if c == "]": return 93
    if c == "^": return 94
    if c == "_": return 95
    if c == "a": return 97
    if c == "b": return 98
    if c == "c": return 99
    if c == "d": return 100
    if c == "e": return 101
    if c == "f": return 102
    if c == "g": return 103
    if c == "h": return 104
    if c == "i": return 105
    if c == "j": return 106
    if c == "k": return 107
    if c == "l": return 108
    if c == "m": return 109
    if c == "n": return 110
    if c == "o": return 111
    if c == "p": return 112
    if c == "q": return 113
    if c == "r": return 114
    if c == "s": return 115
    if c == "t": return 116
    if c == "u": return 117
    if c == "v": return 118
    if c == "w": return 119
    if c == "x": return 120
    if c == "y": return 121
    if c == "z": return 122
    if c == "{": return 123
    if c == "|": return 124
    if c == "}": return 125
    if c == "~": return 126
    if c == "\n": return 10
    if c == "\t": return 9
    if c == "\r": return 13
    0

# ============================================================================
# String Hashing
# ============================================================================

fn text_hash(s: text) -> i64:
    """FNV-1a hash of a string. Returns a deterministic i64 hash value."""
    var hash = 2166136261
    var i = 0
    while i < s.len():
        val code = char_code(s[i])
        hash = (hash xor code) * 16777619
        i = i + 1
    hash

# ============================================================================
# Trim Matching Patterns
# ============================================================================

fn text_trim_start_matches(s: text, pattern: text) -> text:
    """Remove all occurrences of pattern from the start of the string."""
    if pattern.len() == 0:
        return s
    var result = s
    while result.starts_with(pattern):
        result = result[pattern.len():]
    result

fn text_trim_end_matches(s: text, pattern: text) -> text:
    """Remove all occurrences of pattern from the end of the string."""
    if pattern.len() == 0:
        return s
    var result = s
    while result.ends_with(pattern):
        result = result[0:result.len() - pattern.len()]
    result

# ============================================================================
# Character Search
# ============================================================================

fn text_contains_char(s: text, ch: text) -> bool:
    """Check if string contains the given character."""
    var i = 0
    while i < s.len():
        if s[i] == ch:
            return true
        i = i + 1
    false

fn text_index_of_char(s: text, ch: text) -> i64:
    """Find the index of the first occurrence of ch in s. Returns -1 if not found."""
    var i = 0
    while i < s.len():
        if s[i] == ch:
            return i
        i = i + 1
    -1

# ============================================================================
# Additional String Utilities
# ============================================================================

fn text_repeat(s: text, count: i64) -> text:
    """Repeat a string count times."""
    var result = ""
    var i = 0
    while i < count:
        result = result + s
        i = i + 1
    result

fn text_pad_left(s: text, width: i64, pad_char: text) -> text:
    """Pad string on the left to reach desired width."""
    var result = s
    while result.len() < width:
        result = pad_char + result
    result

fn text_pad_right(s: text, width: i64, pad_char: text) -> text:
    """Pad string on the right to reach desired width."""
    var result = s
    while result.len() < width:
        result = result + pad_char
    result

fn text_is_digit(ch: text) -> bool:
    """Check if a single character is a digit (0-9)."""
    ch == "0" or ch == "1" or ch == "2" or ch == "3" or ch == "4" or ch == "5" or ch == "6" or ch == "7" or ch == "8" or ch == "9"

fn text_is_alpha(ch: text) -> bool:
    """Check if a single character is alphabetic (a-z, A-Z)."""
    val code = char_code(ch)
    (code >= 65 and code <= 90) or (code >= 97 and code <= 122)

fn text_is_alphanumeric(ch: text) -> bool:
    """Check if a single character is alphanumeric."""
    text_is_alpha(ch) or text_is_digit(ch)

# ============================================================================
# String Manipulation (merged from string_utils.spl)
# ============================================================================

fn repeat_str(s: text, n: i64) -> text:
    """Repeat a string n times."""
    if n <= 0:
        return ""
    var result = ""
    for _ in 0..n:
        result = result + s
    result

fn reverse_str(s: text) -> text:
    """Reverse a string."""
    var result = ""
    var i = s.len() - 1
    while i >= 0:
        result = result + s[i:i + 1]
        i = i - 1
    result

fn join_strs(list: [text], sep: text) -> text:
    """Join a list of strings with a separator."""
    if list.len() == 0:
        return ""
    var result = list[0]
    for i in 1..list.len():
        result = result + sep + list[i]
    result

fn contains_char(s: text, c: text) -> bool:
    """Check if string contains a character."""
    if c.len() != 1:
        return false
    for i in 0..s.len():
        if s[i:i + 1] == c:
            return true
    false

fn count_char(s: text, c: text) -> i64:
    """Count occurrences of a character in a string."""
    if c.len() != 1:
        return 0
    var count = 0
    for i in 0..s.len():
        if s[i:i + 1] == c:
            count = count + 1
    count

fn index_of_char(s: text, c: text) -> i64?:
    """Find first index of a character. Returns nil if not found."""
    if c.len() != 1:
        return nil
    for i in 0..s.len():
        if s[i:i + 1] == c:
            return i
    nil

fn last_index_of_char(s: text, c: text) -> i64?:
    """Find last index of a character. Returns nil if not found."""
    if c.len() != 1:
        return nil
    var i = s.len() - 1
    while i >= 0:
        if s[i:i + 1] == c:
            return i
        i = i - 1
    nil

fn starts_with_char(s: text, c: text) -> bool:
    """Check if string starts with a character."""
    if s.len() == 0:
        return false
    if c.len() != 1:
        return false
    s[0:1] == c

fn ends_with_char(s: text, c: text) -> bool:
    """Check if string ends with a character."""
    if s.len() == 0:
        return false
    if c.len() != 1:
        return false
    s[s.len() - 1:s.len()] == c

fn char_at(s: text, index: i64) -> text:
    """Get character at index. Returns empty string if out of bounds."""
    if index < 0 or index >= s.len():
        return ""
    s[index:index + 1]

fn is_whitespace(s: text) -> bool:
    """Check if string contains only whitespace characters."""
    if s.len() == 0:
        return true
    for i in 0..s.len():
        val c = s[i:i + 1]
        if c != " " and c != "\t" and c != "\n" and c != "\r":
            return false
    true

fn is_empty(s: text) -> bool:
    """Check if string is empty."""
    s.len() == 0

fn is_blank(s: text) -> bool:
    """Check if string is empty or contains only whitespace."""
    is_whitespace(s)

fn compare_case_insensitive(a: text, b: text) -> bool:
    """Compare two strings ignoring case."""
    to_lowercase_str(a) == to_lowercase_str(b)

fn to_lowercase_str(s: text) -> text:
    """Convert string to lowercase (ASCII only)."""
    var result = ""
    for i in 0..s.len():
        val c = s[i:i + 1]
        val code = char_code(c)
        if code >= 65 and code <= 90:
            result = result + char_from_code(code + 32)
        else:
            result = result + c
    result

fn to_uppercase_str(s: text) -> text:
    """Convert string to uppercase (ASCII only)."""
    var result = ""
    for i in 0..s.len():
        val c = s[i:i + 1]
        val code = char_code(c)
        if code >= 97 and code <= 122:
            result = result + char_from_code(code - 32)
        else:
            result = result + c
    result

fn capitalize_first(s: text) -> text:
    """Capitalize first letter of string."""
    if s.len() == 0:
        return s
    val first = s[0:1]
    val rest = s[1:]
    to_uppercase_str(first) + rest

fn split_on_char(s: text, c: text) -> [text]:
    """Split string on a character."""
    if c.len() != 1:
        return [s]
    var result: [text] = []
    var current = ""
    for i in 0..s.len():
        val ch = s[i:i + 1]
        if ch == c:
            result = result.push(current)
            current = ""
        else:
            current = current + ch
    result.push(current)

fn str_lines(s: text) -> [text]:
    """Split string into lines."""
    split_on_char(s, "\n")

fn str_words(s: text) -> [text]:
    """Split string into words (on spaces)."""
    var result: [text] = []
    var current = ""
    for i in 0..s.len():
        val c = s[i:i + 1]
        if c == " " or c == "\t" or c == "\n" or c == "\r":
            if current.len() > 0:
                result = result.push(current)
                current = ""
        else:
            current = current + c
    if current.len() > 0:
        result = result.push(current)
    result

fn char_from_code(code: i64) -> text:
    """Convert ASCII code to character."""
    if code == 32: return " "
    if code == 10: return "\n"
    if code == 9: return "\t"
    if code == 13: return "\r"
    if code >= 48 and code <= 57:
        # 0-9
        if code == 48: return "0"
        if code == 49: return "1"
        if code == 50: return "2"
        if code == 51: return "3"
        if code == 52: return "4"
        if code == 53: return "5"
        if code == 54: return "6"
        if code == 55: return "7"
        if code == 56: return "8"
        if code == 57: return "9"
    if code >= 65 and code <= 90:
        # A-Z
        if code == 65: return "A"
        if code == 66: return "B"
        if code == 67: return "C"
        if code == 68: return "D"
        if code == 69: return "E"
        if code == 70: return "F"
        if code == 71: return "G"
        if code == 72: return "H"
        if code == 73: return "I"
        if code == 74: return "J"
        if code == 75: return "K"
        if code == 76: return "L"
        if code == 77: return "M"
        if code == 78: return "N"
        if code == 79: return "O"
        if code == 80: return "P"
        if code == 81: return "Q"
        if code == 82: return "R"
        if code == 83: return "S"
        if code == 84: return "T"
        if code == 85: return "U"
        if code == 86: return "V"
        if code == 87: return "W"
        if code == 88: return "X"
        if code == 89: return "Y"
        if code == 90: return "Z"
    if code >= 97 and code <= 122:
        # a-z
        if code == 97: return "a"
        if code == 98: return "b"
        if code == 99: return "c"
        if code == 100: return "d"
        if code == 101: return "e"
        if code == 102: return "f"
        if code == 103: return "g"
        if code == 104: return "h"
        if code == 105: return "i"
        if code == 106: return "j"
        if code == 107: return "k"
        if code == 108: return "l"
        if code == 109: return "m"
        if code == 110: return "n"
        if code == 111: return "o"
        if code == 112: return "p"
        if code == 113: return "q"
        if code == 114: return "r"
        if code == 115: return "s"
        if code == 116: return "t"
        if code == 117: return "u"
        if code == 118: return "v"
        if code == 119: return "w"
        if code == 120: return "x"
        if code == 121: return "y"
        if code == 122: return "z"
    ""

# ============================================================================
# Integer Parsing
# ============================================================================

# Parse i64 from string with safe fallback (bootstrap runtime compatible)
fn parse_i64_safe(s: text) -> i64:
    var result = 0
    var sign = 1
    var start = 0

    if s.len() > 0 and s[0:1] == "-":
        sign = -1
        start = 1

    for i in start..s.len():
        val ch = s[i:i+1]
        if ch >= "0" and ch <= "9":
            val digit = char_to_digit(ch)
            result = result * 10 + digit
        else:
            break

    result * sign

# Convert single digit character to integer
fn char_to_digit(ch: text) -> i64:
    if ch == "0": 0
    else if ch == "1": 1
    else if ch == "2": 2
    else if ch == "3": 3
    else if ch == "4": 4
    else if ch == "5": 5
    else if ch == "6": 6
    else if ch == "7": 7
    else if ch == "8": 8
    else if ch == "9": 9
    else: 0

# ============================================================================
# Convenience Aliases and Wrappers
# ============================================================================

# Common aliases for compatibility with different naming conventions
fn parse_i64(s: text) -> i64:
    """Alias for parse_i64_safe."""
    parse_i64_safe(s)

fn to_int_or(s: text, default_val: i64) -> i64:
    """Parse string to integer with fallback default."""
    if s.len() == 0:
        return default_val
    parse_i64_safe(s)

fn split_lines(s: text) -> [text]:
    """Alias for str_lines."""
    str_lines(s)

fn string_hash(s: text) -> i64:
    """Alias for text_hash."""
    text_hash(s)

fn string_to_lowercase(s: text) -> text:
    """Alias for to_lowercase_str."""
    to_lowercase_str(s)

fn string_to_uppercase(s: text) -> text:
    """Alias for to_uppercase_str."""
    to_uppercase_str(s)

fn string_trim(s: text) -> text:
    """Trim whitespace from both ends of string."""
    var result = s
    # Trim start
    while result.len() > 0 and is_whitespace_char(result[0:1]):
        result = result[1:]
    # Trim end
    while result.len() > 0 and is_whitespace_char(result[result.len()-1:result.len()]):
        result = result[0:result.len()-1]
    result

fn is_whitespace_char(c: text) -> bool:
    """Check if single character is whitespace."""
    c == " " or c == "\t" or c == "\n" or c == "\r"

fn string_split(s: text, delimiter: text) -> [text]:
    """Split string on delimiter (general version)."""
    if delimiter.len() == 1:
        return split_on_char(s, delimiter)
    # For multi-char delimiters, simple implementation
    var result: [text] = []
    var current = ""
    var i = 0
    while i < s.len():
        if i + delimiter.len() <= s.len() and s[i:i+delimiter.len()] == delimiter:
            result = result.push(current)
            current = ""
            i = i + delimiter.len()
        else:
            current = current + s[i:i+1]
            i = i + 1
    result.push(current)

# ============================================================================
# Exports
# ============================================================================

export char_code, text_hash
export text_trim_start_matches, text_trim_end_matches
export text_contains_char, text_index_of_char
export text_repeat, text_pad_left, text_pad_right
export text_is_digit, text_is_alpha, text_is_alphanumeric
export repeat_str, reverse_str, join_strs
export contains_char, count_char, index_of_char, last_index_of_char
export starts_with_char, ends_with_char, char_at
export is_whitespace, is_empty, is_blank
export compare_case_insensitive, to_lowercase_str, to_uppercase_str, capitalize_first
export split_on_char, str_lines, str_words
export char_from_code
export parse_i64_safe, char_to_digit
# Convenience aliases
export parse_i64, to_int_or, split_lines, string_hash
export string_to_lowercase, string_to_uppercase, string_trim, string_split
