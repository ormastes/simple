# Text Diffing Utilities Module
# Comprehensive diffing algorithms and utilities for comparing text
# Pure Simple implementation with no external dependencies

# ============================================================================
# DATA STRUCTURES (Tuple-based for runtime compatibility)
# ============================================================================

# Change operation: (op: text, content: text, old_line: i64, new_line: i64)
# op can be: "add", "delete", "equal", "change"
fn create_change(op: text, content: text, old_line: i64, new_line: i64):
    (op: op, content: content, old_line: old_line, new_line: new_line)

fn create_add(content: text, new_line: i64):
    create_change("add", content, -1, new_line)

fn create_delete(content: text, old_line: i64):
    create_change("delete", content, old_line, -1)

fn create_equal(content: text, old_line: i64, new_line: i64):
    create_change("equal", content, old_line, new_line)

fn create_modify(old_content: text, new_content: text, old_line: i64, new_line: i64):
    (op: "change", old_content: old_content, new_content: new_content,
     old_line: old_line, new_line: new_line)

# Hunk: (type: text, changes: list, old_start: i64, old_count: i64, new_start: i64, new_count: i64)
fn create_hunk(changes: list, old_start: i64, old_count: i64, new_start: i64, new_count: i64):
    (type: "hunk", changes: changes, old_start: old_start, old_count: old_count,
     new_start: new_start, new_count: new_count)

# Patch: (type: text, file_old: text, file_new: text, hunks: list)
fn create_patch(file_old: text, file_new: text, hunks: list):
    (type: "patch", file_old: file_old, file_new: file_new, hunks: hunks)

# Edit operation: (op: text, pos: i64, char: text)
fn create_edit(op: text, pos: i64, char: text):
    (op: op, pos: pos, char: char)

# DiffStats: (additions: i64, deletions: i64, changes: i64, equals: i64)
fn create_diff_stats(additions: i64, deletions: i64, changes: i64, equals: i64):
    (additions: additions, deletions: deletions, changes: changes, equals: equals)

# ============================================================================
# TEXT SPLITTING UTILITIES
# ============================================================================

fn split_lines(text: text) -> list:
    # Split text into lines, preserving empty lines
    val lines = []
    var current = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        if ch == "\n":
            lines.append(current)
            current = ""
        else:
            current = current + ch
        i = i + 1
    # Add last line if not empty or if text ends with content
    if current.length() > 0 or text.length() > 0:
        lines.append(current)
    lines

fn split_words(text: text) -> list:
    # Split text into words (whitespace-delimited)
    val words = []
    var current = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        val is_space = ch == " " or ch == "\t" or ch == "\n" or ch == "\r"
        if is_space:
            if current.length() > 0:
                words.append(current)
                current = ""
        else:
            current = current + ch
        i = i + 1
    if current.length() > 0:
        words.append(current)
    words

fn split_chars(text: text) -> list:
    # Split text into individual characters
    val chars = []
    var i = 0
    while i < text.length():
        chars.append(text.char_at(i))
        i = i + 1
    chars

fn join_lines(lines: list) -> text:
    # Join lines with newline separator
    var result = ""
    var i = 0
    while i < lines.length():
        if i > 0:
            result = result + "\n"
        result = result + lines.get(i)
        i = i + 1
    result

fn join_with_separator(items: list, sep: text) -> text:
    # Join list items with separator
    var result = ""
    var i = 0
    while i < items.length():
        if i > 0:
            result = result + sep
        result = result + items.get(i)
        i = i + 1
    result

# ============================================================================
# LONGEST COMMON SUBSEQUENCE (LCS)
# ============================================================================

fn lcs_length(seq1: list, seq2: list) -> i64:
    # Compute length of longest common subsequence
    val m = seq1.length()
    val n = seq2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m:
        val row = []
        var j = 0
        while j <= n:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    # Fill DP table
    i = 1
    while i <= m:
        var j = 1
        while j <= n:
            val prev_row = dp.get(i - 1)
            val curr_row = dp.get(i)

            if seq1.get(i - 1) == seq2.get(j - 1):
                val diag = prev_row.get(j - 1)
                curr_row.set(j, diag + 1)
            else:
                val left = curr_row.get(j - 1)
                val up = prev_row.get(j)
                val max_val = if left > up: left else: up
                curr_row.set(j, max_val)
            j = j + 1
        i = i + 1

    val last_row = dp.get(m)
    last_row.get(n)

fn lcs(seq1: list, seq2: list) -> list:
    # Compute longest common subsequence
    val m = seq1.length()
    val n = seq2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m:
        val row = []
        var j = 0
        while j <= n:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    # Fill DP table
    i = 1
    while i <= m:
        var j = 1
        while j <= n:
            val prev_row = dp.get(i - 1)
            val curr_row = dp.get(i)

            if seq1.get(i - 1) == seq2.get(j - 1):
                val diag = prev_row.get(j - 1)
                curr_row.set(j, diag + 1)
            else:
                val left = curr_row.get(j - 1)
                val up = prev_row.get(j)
                val max_val = if left > up: left else: up
                curr_row.set(j, max_val)
            j = j + 1
        i = i + 1

    # Backtrack to find LCS
    val result = []
    i = m
    var j = n
    while i > 0 and j > 0:
        val curr_row = dp.get(i)
        val prev_row = dp.get(i - 1)

        if seq1.get(i - 1) == seq2.get(j - 1):
            result.append(seq1.get(i - 1))
            i = i - 1
            j = j - 1
        else:
            val left = curr_row.get(j - 1)
            val up = prev_row.get(j)
            if up > left:
                i = i - 1
            else:
                j = j - 1

    result.reverse()
    result

# ============================================================================
# MYERS DIFF ALGORITHM
# ============================================================================

fn myers_diff(seq1: list, seq2: list) -> list:
    # Myers O(ND) difference algorithm - finds shortest edit script
    val n = seq1.length()
    val m = seq2.length()
    val max_d = n + m

    # V array stores furthest reaching paths
    val v = []
    var i = 0
    while i <= 2 * max_d + 1:
        v.append(0)
        i = i + 1

    val offset = max_d

    # Iterate through edit distances
    var d = 0
    while d <= max_d:
        var k = -d
        while k <= d:
            # Determine if we go down or right
            val k_offset = k + offset
            val left_offset = k - 1 + offset
            val right_offset = k + 1 + offset

            var x = 0
            if k == -d:
                x = v.get(right_offset)
            else:
                val cond1 = k == d
                if cond1:
                    x = v.get(left_offset) + 1
                else:
                    val left_val = v.get(left_offset)
                    val right_val = v.get(right_offset)
                    if left_val > right_val:
                        x = left_val + 1
                    else:
                        x = right_val

            var y = x - k

            # Follow diagonal
            while x < n and y < m and seq1.get(x) == seq2.get(y):
                x = x + 1
                y = y + 1

            v.set(k_offset, x)

            # Check if we reached the end
            if x >= n and y >= m:
                # Backtrack to construct diff
                return myers_backtrack(seq1, seq2, v, offset, d)

            k = k + 2
        d = d + 1

    # Fallback: return simple diff
    simple_diff(seq1, seq2)

fn myers_backtrack(seq1: list, seq2: list, v: list, offset: i64, d: i64) -> list:
    # Backtrack through Myers algorithm to construct diff
    val changes = []
    var x = seq1.length()
    var y = seq2.length()

    var curr_d = d
    while curr_d > 0 or x > 0 or y > 0:
        val k = x - y
        val k_offset = k + offset

        # Determine direction we came from
        var prev_k = k
        if curr_d == 0:
            if x > 0 and y > 0:
                changes.append(create_equal(seq1.get(x - 1), x - 1, y - 1))
                x = x - 1
                y = y - 1
            else:
                if x > 0:
                    changes.append(create_delete(seq1.get(x - 1), x - 1))
                    x = x - 1
                if y > 0:
                    changes.append(create_add(seq2.get(y - 1), y - 1))
                    y = y - 1
        else:
            val left_offset = k - 1 + offset
            val right_offset = k + 1 + offset

            # Check which direction we came from
            var came_from_left = false
            if k == -curr_d:
                came_from_left = false
            else:
                val cond1 = k == curr_d
                if cond1:
                    came_from_left = true
                else:
                    val left_val = v.get(left_offset)
                    val right_val = v.get(right_offset)
                    came_from_left = left_val > right_val

            if came_from_left:
                prev_k = k - 1
                if x > 0:
                    changes.append(create_delete(seq1.get(x - 1), x - 1))
                    x = x - 1
            else:
                prev_k = k + 1
                if y > 0:
                    changes.append(create_add(seq2.get(y - 1), y - 1))
                    y = y - 1

            curr_d = curr_d - 1

        # Follow diagonal backwards
        while x > 0 and y > 0 and seq1.get(x - 1) == seq2.get(y - 1):
            changes.append(create_equal(seq1.get(x - 1), x - 1, y - 1))
            x = x - 1
            y = y - 1

    changes.reverse()
    changes

# ============================================================================
# SIMPLE DIFF (Fallback)
# ============================================================================

fn simple_diff(seq1: list, seq2: list) -> list:
    # Simple diff using LCS
    val lcs_seq = lcs(seq1, seq2)
    val changes = []

    var i = 0
    var j = 0
    var k = 0

    while i < seq1.length() or j < seq2.length():
        if k < lcs_seq.length():
            val lcs_item = lcs_seq.get(k)

            # Check if current items match LCS
            val i_matches = i < seq1.length() and seq1.get(i) == lcs_item
            val j_matches = j < seq2.length() and seq2.get(j) == lcs_item

            if i_matches and j_matches:
                changes.append(create_equal(seq1.get(i), i, j))
                i = i + 1
                j = j + 1
                k = k + 1
            else:
                if i < seq1.length() and not i_matches:
                    changes.append(create_delete(seq1.get(i), i))
                    i = i + 1
                if j < seq2.length() and not j_matches:
                    changes.append(create_add(seq2.get(j), j))
                    j = j + 1
        else:
            # Past LCS, add remaining items
            if i < seq1.length():
                changes.append(create_delete(seq1.get(i), i))
                i = i + 1
            if j < seq2.length():
                changes.append(create_add(seq2.get(j), j))
                j = j + 1

    changes

# ============================================================================
# PATIENCE DIFF ALGORITHM
# ============================================================================

fn patience_diff(seq1: list, seq2: list) -> list:
    # Patience diff - finds unique common elements as anchors
    val unique_common = find_unique_common_elements(seq1, seq2)

    if unique_common.length() == 0:
        # No unique common elements, fall back to Myers
        return myers_diff(seq1, seq2)

    # Recursively diff around anchors
    val changes = []
    var prev1 = 0
    var prev2 = 0

    var i = 0
    while i < unique_common.length():
        val anchor = unique_common.get(i)
        val pos1 = anchor.pos1
        val pos2 = anchor.pos2

        # Diff before this anchor
        if pos1 > prev1 or pos2 > prev2:
            val sub1 = slice_list(seq1, prev1, pos1)
            val sub2 = slice_list(seq2, prev2, pos2)
            val sub_changes = patience_diff(sub1, sub2)

            # Adjust indices and add changes
            var j = 0
            while j < sub_changes.length():
                val change = sub_changes.get(j)
                val adjusted = adjust_change_indices(change, prev1, prev2)
                changes.append(adjusted)
                j = j + 1

        # Add the anchor as equal
        changes.append(create_equal(seq1.get(pos1), pos1, pos2))

        prev1 = pos1 + 1
        prev2 = pos2 + 1
        i = i + 1

    # Diff after last anchor
    if prev1 < seq1.length() or prev2 < seq2.length():
        val sub1 = slice_list(seq1, prev1, seq1.length())
        val sub2 = slice_list(seq2, prev2, seq2.length())
        val sub_changes = patience_diff(sub1, sub2)

        var j = 0
        while j < sub_changes.length():
            val change = sub_changes.get(j)
            val adjusted = adjust_change_indices(change, prev1, prev2)
            changes.append(adjusted)
            j = j + 1

    changes

fn find_unique_common_elements(seq1: list, seq2: list) -> list:
    # Find elements that appear exactly once in both sequences
    val count1 = count_occurrences(seq1)
    val count2 = count_occurrences(seq2)

    val common = []
    var i = 0
    while i < seq1.length():
        val item = seq1.get(i)
        val c1 = dict_get(count1, item, 0)
        val c2 = dict_get(count2, item, 0)

        if c1 == 1 and c2 == 1:
            # Find position in seq2
            var j = 0
            while j < seq2.length():
                if seq2.get(j) == item:
                    common.append((pos1: i, pos2: j, item: item))
                    j = seq2.length()
                j = j + 1
        i = i + 1

    # Sort by position to maintain order
    common

fn count_occurrences(seq: list) -> list:
    # Count occurrences of each element (simple list-based dict)
    val counts = []
    var i = 0
    while i < seq.length():
        val item = seq.get(i)
        val existing = dict_get(counts, item, -1)
        if existing == -1:
            counts.append((key: item, value: 1))
        else:
            dict_set(counts, item, existing + 1)
        i = i + 1
    counts

fn dict_get(dict: list, key: text, default: i64) -> i64:
    # Get value from simple key-value list
    var i = 0
    while i < dict.length():
        val entry = dict.get(i)
        if entry.key == key:
            return entry.value
        i = i + 1
    default

fn dict_set(dict: list, key: text, value: i64):
    # Set value in simple key-value list
    var i = 0
    while i < dict.length():
        val entry = dict.get(i)
        if entry.key == key:
            dict.set(i, (key: key, value: value))
            return
        i = i + 1

fn slice_list(list: list, start: i64, end: i64) -> list:
    # Extract sublist from start (inclusive) to end (exclusive)
    val result = []
    var i = start
    while i < end and i < list.length():
        result.append(list.get(i))
        i = i + 1
    result

fn adjust_change_indices(change: tuple, offset1: i64, offset2: i64) -> tuple:
    # Adjust change indices by offsets
    val op = change.op

    if op == "equal":
        create_equal(change.content, change.old_line + offset1, change.new_line + offset2)
    else:
        if op == "add":
            create_add(change.content, change.new_line + offset2)
        else:
            if op == "delete":
                create_delete(change.content, change.old_line + offset1)
            else:
                change

# ============================================================================
# HIGH-LEVEL DIFF FUNCTIONS
# ============================================================================

fn diff_lines(text1: text, text2: text) -> list:
    # Diff two texts line by line
    val lines1 = split_lines(text1)
    val lines2 = split_lines(text2)
    myers_diff(lines1, lines2)

fn diff_lines_patience(text1: text, text2: text) -> list:
    # Diff two texts line by line using patience algorithm
    val lines1 = split_lines(text1)
    val lines2 = split_lines(text2)
    patience_diff(lines1, lines2)

fn diff_words(text1: text, text2: text) -> list:
    # Diff two texts word by word
    val words1 = split_words(text1)
    val words2 = split_words(text2)
    myers_diff(words1, words2)

fn diff_chars(text1: text, text2: text) -> list:
    # Diff two texts character by character
    val chars1 = split_chars(text1)
    val chars2 = split_chars(text2)
    myers_diff(chars1, chars2)

# ============================================================================
# EDIT DISTANCE ALGORITHMS
# ============================================================================

fn levenshtein_distance(s1: text, s2: text) -> i64:
    # Compute Levenshtein (edit) distance between two strings
    val m = s1.length()
    val n = s2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m:
        val row = []
        var j = 0
        while j <= n:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    # Initialize first row and column
    i = 0
    while i <= m:
        val row = dp.get(i)
        row.set(0, i)
        i = i + 1

    var j = 0
    while j <= n:
        val row = dp.get(0)
        row.set(j, j)
        j = j + 1

    # Fill DP table
    i = 1
    while i <= m:
        j = 1
        while j <= n:
            val prev_row = dp.get(i - 1)
            val curr_row = dp.get(i)

            val cost = if s1.char_at(i - 1) == s2.char_at(j - 1): 0 else: 1

            val delete_cost = prev_row.get(j) + 1
            val insert_cost = curr_row.get(j - 1) + 1
            val subst_cost = prev_row.get(j - 1) + cost

            val min1 = if delete_cost < insert_cost: delete_cost else: insert_cost
            val min2 = if min1 < subst_cost: min1 else: subst_cost

            curr_row.set(j, min2)
            j = j + 1
        i = i + 1

    val last_row = dp.get(m)
    last_row.get(n)

fn damerau_levenshtein_distance(s1: text, s2: text) -> i64:
    # Compute Damerau-Levenshtein distance (allows transpositions)
    val m = s1.length()
    val n = s2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m + 1:
        val row = []
        var j = 0
        while j <= n + 1:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    val max_dist = m + n
    val first_row = dp.get(0)
    first_row.set(0, max_dist)

    # Initialize first row and column
    i = 1
    while i <= m + 1:
        val row = dp.get(i)
        row.set(0, max_dist)
        row.set(1, i - 1)
        i = i + 1

    var j = 1
    while j <= n + 1:
        val row = dp.get(0)
        row.set(j, max_dist)
        val row1 = dp.get(1)
        row1.set(j, j - 1)
        j = j + 1

    # Fill DP table
    i = 2
    while i <= m + 1:
        j = 2
        while j <= n + 1:
            val cost = if s1.char_at(i - 2) == s2.char_at(j - 2): 0 else: 1

            val curr_row = dp.get(i)
            val prev_row = dp.get(i - 1)
            val prev2_row = dp.get(i - 2)

            val delete_cost = prev_row.get(j) + 1
            val insert_cost = curr_row.get(j - 1) + 1
            val subst_cost = prev_row.get(j - 1) + cost

            val min1 = if delete_cost < insert_cost: delete_cost else: insert_cost
            val min2 = if min1 < subst_cost: min1 else: subst_cost

            var final_cost = min2

            # Check for transposition
            val can_transpose = i > 2 and j > 2
            if can_transpose:
                val chars_match = s1.char_at(i - 2) == s2.char_at(j - 3)
                val chars_swap = s1.char_at(i - 3) == s2.char_at(j - 2)
                if chars_match and chars_swap:
                    val trans_cost = prev2_row.get(j - 2) + cost
                    final_cost = if trans_cost < final_cost: trans_cost else: final_cost

            curr_row.set(j, final_cost)
            j = j + 1
        i = i + 1

    val last_row = dp.get(m + 1)
    last_row.get(n + 1)

fn hamming_distance(s1: text, s2: text) -> i64:
    # Compute Hamming distance (only for equal-length strings)
    if s1.length() != s2.length():
        return -1

    var distance = 0
    var i = 0
    while i < s1.length():
        if s1.char_at(i) != s2.char_at(i):
            distance = distance + 1
        i = i + 1
    distance

# ============================================================================
# SIMILARITY METRICS
# ============================================================================

fn similarity_ratio(s1: text, s2: text) -> i64:
    # Compute similarity ratio (0-100) based on edit distance
    val max_len = if s1.length() > s2.length(): s1.length() else: s2.length()
    if max_len == 0:
        return 100

    val distance = levenshtein_distance(s1, s2)
    val ratio = 100 - (distance * 100 / max_len)
    ratio

fn quick_ratio(s1: text, s2: text) -> i64:
    # Quick upper bound on similarity ratio (faster than full ratio)
    val len1 = s1.length()
    val len2 = s2.length()
    val max_len = if len1 > len2: len1 else: len2

    if max_len == 0:
        return 100

    # Count matching characters (very rough estimate)
    var matches = 0
    var i = 0
    while i < len1 and i < len2:
        if s1.char_at(i) == s2.char_at(i):
            matches = matches + 1
        i = i + 1

    matches * 100 / max_len

# ============================================================================
# DIFF STATISTICS
# ============================================================================

fn diff_stats(changes: list) -> tuple:
    # Compute statistics about a diff
    var additions = 0
    var deletions = 0
    var modifications = 0
    var equals = 0

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "add":
            additions = additions + 1
        else:
            if op == "delete":
                deletions = deletions + 1
            else:
                if op == "change":
                    modifications = modifications + 1
                else:
                    if op == "equal":
                        equals = equals + 1

        i = i + 1

    create_diff_stats(additions, deletions, modifications, equals)

fn count_additions(changes: list) -> i64:
    # Count number of additions in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "add":
            count = count + 1
        i = i + 1
    count

fn count_deletions(changes: list) -> i64:
    # Count number of deletions in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "delete":
            count = count + 1
        i = i + 1
    count

fn count_changes(changes: list) -> i64:
    # Count number of modifications in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "change":
            count = count + 1
        i = i + 1
    count

fn count_equals(changes: list) -> i64:
    # Count number of unchanged lines in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "equal":
            count = count + 1
        i = i + 1
    count

# ============================================================================
# UNIFIED DIFF FORMAT
# ============================================================================

fn format_unified(changes: list, file1: text, file2: text, context_lines: i64) -> text:
    # Format diff in unified format (like diff -u)
    val hunks = create_hunks(changes, context_lines)

    var result = "--- {file1}\n+++ {file2}\n"

    var i = 0
    while i < hunks.length():
        val hunk = hunks.get(i)
        result = result + format_hunk_unified(hunk)
        i = i + 1

    result

fn format_hunk_unified(hunk: tuple) -> text:
    # Format a single hunk in unified format
    val old_start = hunk.old_start + 1
    val old_count = hunk.old_count
    val new_start = hunk.new_start + 1
    val new_count = hunk.new_count

    var result = "@@ -{old_start},{old_count} +{new_start},{new_count} @@\n"

    val changes = hunk.changes
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal":
            result = result + " " + change.content + "\n"
        else:
            if op == "delete":
                result = result + "-" + change.content + "\n"
            else:
                if op == "add":
                    result = result + "+" + change.content + "\n"
                else:
                    if op == "change":
                        result = result + "-" + change.old_content + "\n"
                        result = result + "+" + change.new_content + "\n"

        i = i + 1

    result

fn create_hunks(changes: list, context_lines: i64) -> list:
    # Group changes into hunks with context
    val hunks = []
    var current_changes = []
    var old_start = -1
    var new_start = -1
    var old_count = 0
    var new_count = 0
    var context_before = 0

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal":
            if current_changes.length() == 0:
                # Before any changes, skip or save as context
                context_before = context_before + 1
            else:
                # After changes, might be context or new hunk
                current_changes.append(change)
                old_count = old_count + 1
                new_count = new_count + 1
                context_before = 0
        else:
            # Start new hunk if needed
            if current_changes.length() == 0:
                if op == "delete":
                    old_start = change.old_line
                    new_start = change.new_line
                else:
                    old_start = change.old_line
                    new_start = change.new_line
                old_count = 0
                new_count = 0

            current_changes.append(change)

            if op == "delete":
                old_count = old_count + 1
            else:
                if op == "add":
                    new_count = new_count + 1
                else:
                    if op == "change":
                        old_count = old_count + 1
                        new_count = new_count + 1

            context_before = 0

        i = i + 1

    # Add last hunk
    if current_changes.length() > 0:
        hunks.append(create_hunk(current_changes, old_start, old_count, new_start, new_count))

    hunks

# ============================================================================
# CONTEXT DIFF FORMAT
# ============================================================================

fn format_context(changes: list, file1: text, file2: text, context_lines: i64) -> text:
    # Format diff in context format (like diff -c)
    var result = "*** {file1}\n--- {file2}\n"

    val hunks = create_hunks(changes, context_lines)

    var i = 0
    while i < hunks.length():
        val hunk = hunks.get(i)
        result = result + format_hunk_context(hunk)
        i = i + 1

    result

fn format_hunk_context(hunk: tuple) -> text:
    # Format a single hunk in context format
    val old_start = hunk.old_start + 1
    val old_end = old_start + hunk.old_count - 1
    val new_start = hunk.new_start + 1
    val new_end = new_start + hunk.new_count - 1

    var result = "***************\n"
    result = result + "*** {old_start},{old_end} ****\n"

    val changes = hunk.changes
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal" or op == "delete":
            val prefix = if op == "delete": "- " else: "  "
            result = result + prefix + change.content + "\n"
        else:
            if op == "change":
                result = result + "! " + change.old_content + "\n"

        i = i + 1

    result = result + "--- {new_start},{new_end} ----\n"

    i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal" or op == "add":
            val prefix = if op == "add": "+ " else: "  "
            result = result + prefix + change.content + "\n"
        else:
            if op == "change":
                result = result + "! " + change.new_content + "\n"

        i = i + 1

    result

# ============================================================================
# SIDE-BY-SIDE FORMAT
# ============================================================================

fn format_side_by_side(changes: list, width: i64) -> text:
    # Format diff in side-by-side format
    val col_width = (width - 3) / 2
    var result = ""

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal":
            val left = pad_right(change.content, col_width)
            result = result + left + " | " + change.content + "\n"
        else:
            if op == "delete":
                val left = pad_right(change.content, col_width)
                result = result + left + " <\n"
            else:
                if op == "add":
                    val spaces = pad_right("", col_width)
                    result = result + spaces + " > " + change.content + "\n"
                else:
                    if op == "change":
                        val left = pad_right(change.old_content, col_width)
                        result = result + left + " | " + change.new_content + "\n"

        i = i + 1

    result

fn pad_right(text: text, width: i64) -> text:
    # Pad text to width with spaces on the right
    var result = text
    var len = text.length()
    while len < width:
        result = result + " "
        len = len + 1

    if result.length() > width:
        result = result.substring(0, width)

    result

# ============================================================================
# PATCH GENERATION AND APPLICATION
# ============================================================================

fn create_patch_from_diff(changes: list, file1: text, file2: text) -> tuple:
    # Create a patch from a diff
    val hunks = create_hunks(changes, 3)
    create_patch(file1, file2, hunks)

fn apply_patch(text: text, patch: tuple) -> text:
    # Apply a patch to text
    val lines = split_lines(text)
    val hunks = patch.hunks

    var offset = 0
    var i = 0
    while i < hunks.length():
        val hunk = hunks.get(i)
        val result_tuple = apply_hunk(lines, hunk, offset)
        val new_lines = result_tuple.lines
        offset = result_tuple.offset

        # Update lines reference
        lines.clear()
        var j = 0
        while j < new_lines.length():
            lines.append(new_lines.get(j))
            j = j + 1

        i = i + 1

    join_lines(lines)

fn apply_hunk(lines: list, hunk: tuple, offset: i64) -> tuple:
    # Apply a single hunk to lines
    val start = hunk.old_start + offset
    val changes = hunk.changes

    val new_lines = []
    var line_idx = 0

    # Copy lines before hunk
    while line_idx < start:
        new_lines.append(lines.get(line_idx))
        line_idx = line_idx + 1

    # Apply changes
    var change_offset = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal":
            new_lines.append(change.content)
            line_idx = line_idx + 1
        else:
            if op == "delete":
                line_idx = line_idx + 1
                change_offset = change_offset - 1
            else:
                if op == "add":
                    new_lines.append(change.content)
                    change_offset = change_offset + 1
                else:
                    if op == "change":
                        new_lines.append(change.new_content)
                        line_idx = line_idx + 1

        i = i + 1

    # Copy remaining lines
    while line_idx < lines.length():
        new_lines.append(lines.get(line_idx))
        line_idx = line_idx + 1

    (lines: new_lines, offset: offset + change_offset)

# ============================================================================
# THREE-WAY MERGE
# ============================================================================

fn merge_three_way(base: text, left: text, right: text) -> tuple:
    # Perform three-way merge
    val base_lines = split_lines(base)
    val left_lines = split_lines(left)
    val right_lines = split_lines(right)

    val left_diff = myers_diff(base_lines, left_lines)
    val right_diff = myers_diff(base_lines, right_lines)

    val merged = merge_diffs(base_lines, left_diff, right_diff)
    merged

fn merge_diffs(base: list, left_diff: list, right_diff: list) -> tuple:
    # Merge two diffs against a common base
    val merged_lines = []
    val conflicts = []

    var base_idx = 0
    var left_idx = 0
    var right_idx = 0

    while base_idx < base.length() or left_idx < left_diff.length() or right_idx < right_diff.length():
        # Get current changes
        val left_change = if left_idx < left_diff.length(): left_diff.get(left_idx) else: nil
        val right_change = if right_idx < right_diff.length(): right_diff.get(right_idx) else: nil

        # Check if both changed the same line
        val both_changed = left_change != nil and right_change != nil

        if both_changed:
            val left_op = left_change.op
            val right_op = right_change.op

            val both_not_equal = left_op != "equal" and right_op != "equal"

            if both_not_equal:
                # Conflict
                conflicts.append((base_line: base_idx, left_change: left_change, right_change: right_change))
                merged_lines.append("<<<<<<< LEFT")
                merged_lines.append(left_change.content)
                merged_lines.append("=======")
                merged_lines.append(right_change.content)
                merged_lines.append(">>>>>>> RIGHT")

                left_idx = left_idx + 1
                right_idx = right_idx + 1
                base_idx = base_idx + 1
            else:
                # One or both are equal, take the changed one
                if left_op == "equal":
                    merged_lines.append(right_change.content)
                    right_idx = right_idx + 1
                else:
                    merged_lines.append(left_change.content)
                    left_idx = left_idx + 1

                base_idx = base_idx + 1
        else:
            # Only one side changed (or neither)
            if left_change != nil:
                merged_lines.append(left_change.content)
                left_idx = left_idx + 1
            else:
                if right_change != nil:
                    merged_lines.append(right_change.content)
                    right_idx = right_idx + 1
                else:
                    # Neither changed, copy from base
                    if base_idx < base.length():
                        merged_lines.append(base.get(base_idx))
                    base_idx = base_idx + 1

    val merged_text = join_lines(merged_lines)
    (merged: merged_text, conflicts: conflicts, has_conflicts: conflicts.length() > 0)

fn detect_conflicts(merge_result: tuple) -> list:
    # Extract conflict information from merge result
    merge_result.conflicts

# ============================================================================
# HIGHLIGHTING AND COLORIZATION
# ============================================================================

fn highlight_diff(changes: list, use_color: i64) -> text:
    # Highlight diff with optional ANSI colors
    var result = ""

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if use_color == 1:
            if op == "add":
                result = result + colorize_addition(change.content)
            else:
                if op == "delete":
                    result = result + colorize_deletion(change.content)
                else:
                    if op == "change":
                        result = result + colorize_deletion(change.old_content)
                        result = result + colorize_addition(change.new_content)
                    else:
                        result = result + change.content
        else:
            if op == "add":
                result = result + "+ " + change.content
            else:
                if op == "delete":
                    result = result + "- " + change.content
                else:
                    if op == "change":
                        result = result + "< " + change.old_content + "\n"
                        result = result + "> " + change.new_content
                    else:
                        result = result + "  " + change.content

        result = result + "\n"
        i = i + 1

    result

fn colorize_addition(text: text) -> text:
    # Add green color codes for additions
    "\x1b[32m+ {text}\x1b[0m"

fn colorize_deletion(text: text) -> text:
    # Add red color codes for deletions
    "\x1b[31m- {text}\x1b[0m"

fn colorize_change(text: text) -> text:
    # Add yellow color codes for changes
    "\x1b[33m! {text}\x1b[0m"

# ============================================================================
# DIFF OPTIONS
# ============================================================================

fn diff_with_options(text1: text, text2: text, options: tuple) -> list:
    # Diff with various options
    var t1 = text1
    var t2 = text2

    # Apply ignore whitespace
    if options.ignore_whitespace == 1:
        t1 = remove_whitespace(t1)
        t2 = remove_whitespace(t2)

    # Apply ignore case
    if options.ignore_case == 1:
        t1 = t1.to_lower()
        t2 = t2.to_lower()

    # Choose algorithm
    val result = if options.algorithm == "patience":
        diff_lines_patience(t1, t2)
    else:
        diff_lines(t1, t2)

    result

fn remove_whitespace(text: text) -> text:
    # Remove all whitespace from text
    var result = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        val is_space = ch == " " or ch == "\t" or ch == "\r"
        if not is_space:
            result = result + ch
        i = i + 1
    result

fn create_diff_options(ignore_whitespace: i64, ignore_case: i64, algorithm: text, context: i64) -> tuple:
    # Create diff options tuple
    (ignore_whitespace: ignore_whitespace, ignore_case: ignore_case,
     algorithm: algorithm, context: context)

# ============================================================================
# CHUNKING AND CONTEXT
# ============================================================================

fn chunk_diff(changes: list, context_lines: i64) -> list:
    # Split diff into chunks with context
    create_hunks(changes, context_lines)

fn expand_context(hunk: tuple, additional_lines: i64) -> tuple:
    # Expand context of a hunk
    val old_start = hunk.old_start - additional_lines
    val new_start = hunk.new_start - additional_lines
    val old_count = hunk.old_count + (2 * additional_lines)
    val new_count = hunk.new_count + (2 * additional_lines)

    create_hunk(hunk.changes, old_start, old_count, new_start, new_count)

fn minimize_context(hunk: tuple) -> tuple:
    # Minimize context in hunk (remove leading/trailing equal lines)
    val changes = hunk.changes
    var start = 0
    var end = changes.length()

    # Find first non-equal
    while start < changes.length():
        val change = changes.get(start)
        if change.op != "equal":
            start = changes.length()
        else:
            start = start + 1

    # Find last non-equal
    while end > 0:
        val change = changes.get(end - 1)
        if change.op != "equal":
            end = 0
        else:
            end = end - 1

    # Extract minimized changes
    val min_changes = slice_list(changes, start, end)

    create_hunk(min_changes, hunk.old_start + start, end - start,
                hunk.new_start + start, end - start)

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

fn is_binary_text(text: text) -> i64:
    # Check if text appears to be binary
    var i = 0
    while i < text.length() and i < 8192:
        val ch = text.char_at(i)
        val code = ch.char_code_at(0)

        # Check for null bytes or control characters
        if code == 0 or (code < 32 and code != 9 and code != 10 and code != 13):
            return 1
        i = i + 1
    0

fn normalize_line_endings(text: text) -> text:
    # Normalize line endings to \n
    var result = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        if ch == "\r":
            val next_is_lf = i + 1 < text.length() and text.char_at(i + 1) == "\n"
            if next_is_lf:
                result = result + "\n"
                i = i + 1
            else:
                result = result + "\n"
        else:
            result = result + ch
        i = i + 1
    result

fn trim_trailing_whitespace(text: text) -> text:
    # Remove trailing whitespace from each line
    val lines = split_lines(text)
    val trimmed = []

    var i = 0
    while i < lines.length():
        val line = lines.get(i)
        val trimmed_line = trim_right(line)
        trimmed.append(trimmed_line)
        i = i + 1

    join_lines(trimmed)

fn trim_right(text: text) -> text:
    # Trim whitespace from right side of string
    var end = text.length()
    while end > 0:
        val ch = text.char_at(end - 1)
        val is_space = ch == " " or ch == "\t" or ch == "\r"
        if is_space:
            end = end - 1
        else:
            end = 0

    text.substring(0, end)

# Export main functions for public use
