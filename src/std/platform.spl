# Platform Abstraction Layer
#
# Provides convenient platform-agnostic functions for:
# - Platform detection (Windows/Unix/macOS/Linux)
# - Path handling (separators, normalization) - delegates to std.path
# - Command resolution (executable extensions)
#
# Pure Simple implementation using shell commands (uname) for platform detection.
# Uses direct extern fn calls to avoid bootstrap runtime import issues.

extern fn rt_env_get(key: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

# Import canonical path operations
use std.path.{normalize_path, is_absolute_path, join_path}

export is_windows, is_unix, is_macos, is_linux
export get_host_os, get_host_arch
export dir_sep, path_sep, exe_ext, lib_ext
export resolve_command
# Re-export path operations from std.path
export normalize_path, is_absolute_path, join_path

# ===========================================================================
# Platform Detection - Pure Simple Implementation
# ===========================================================================

fn shell_output_trim(command: text) -> text:
    """Run shell command and return trimmed stdout."""
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    if code == 0:
        stdout.trim()
    else:
        ""

fn is_windows_env() -> bool:
    """Check if running on Windows by checking OS environment variable."""
    val os_env = rt_env_get("OS")
    if os_env == nil:
        false  # Default to Unix/Linux
    else:
        os_env.lower().contains("windows")

fn get_host_os() -> text:
    """Internal helper to get host OS using Pure Simple implementation."""
    if is_windows_env():
        "windows"
    else:
        # Unix: Use uname -s
        val os = shell_output_trim("uname -s")
        if os.len() == 0:
            "linux"  # Default
        else:
            match os:
                case "Linux": "linux"
                case "Darwin": "macos"
                case "FreeBSD": "freebsd"
                case "OpenBSD": "openbsd"
                case "NetBSD": "netbsd"
                case _: os.lower()

fn get_host_arch() -> text:
    """Get host CPU architecture using Pure Simple implementation."""
    if is_windows_env():
        # Windows: Use PROCESSOR_ARCHITECTURE env var
        val arch_env = rt_env_get("PROCESSOR_ARCHITECTURE")
        if arch_env == nil:
            "x86_64"  # Default
        else:
            match arch_env:
                case "AMD64": "x86_64"
                case "ARM64": "aarch64"
                case "x86": "i686"
                case _: arch_env.lower()
    else:
        # Unix: Use uname -m
        val arch = shell_output_trim("uname -m")
        if arch.len() == 0:
            "x86_64"  # Default
        else:
            match arch:
                case "x86_64": "x86_64"
                case "amd64": "x86_64"
                case "arm64": "aarch64"
                case "aarch64": "aarch64"
                case "riscv64": "riscv64"
                case "i686": "i686"
                case "i386": "i686"
                case _: arch

fn is_windows() -> bool:
    """Returns true if running on Windows."""
    get_host_os() == "windows"

fn is_unix() -> bool:
    """Returns true if running on Unix-like system (Linux, macOS, BSD)."""
    val os = get_host_os()
    os == "linux" or os == "macos" or os == "freebsd" or os == "openbsd" or os == "netbsd"

fn is_macos() -> bool:
    """Returns true if running on macOS."""
    get_host_os() == "macos"

fn is_linux() -> bool:
    """Returns true if running on Linux."""
    get_host_os() == "linux"

# ===========================================================================
# Path Separators - Pure Simple Implementation
# ===========================================================================

fn dir_sep() -> text:
    """Returns the directory separator for the current platform."""
    if is_windows():
        "\\"
    else:
        "/"

fn path_sep() -> text:
    """Returns the PATH environment variable separator."""
    if is_windows():
        ";"
    else:
        ":"

fn exe_ext() -> text:
    """Returns the executable extension for the current platform."""
    if is_windows():
        ".exe"
    else:
        ""

fn lib_ext() -> text:
    """Returns the dynamic library extension for the current platform."""
    if is_macos():
        ".dylib"
    elif is_windows():
        ".dll"
    else:
        ".so"  # Linux, FreeBSD, etc.

# ===========================================================================
# Path Normalization (delegates to std.path)
# ===========================================================================
# normalize_path, is_absolute_path, join_path are imported from std.path above

# ===========================================================================
# Command Resolution
# ===========================================================================

fn resolve_command(cmd: text) -> text:
    if not is_windows():
        return cmd  # Unix: use PATH directly

    # Windows: add .exe if missing, search in PATH
    var resolved = cmd
    if not cmd.ends_with(".exe") and not cmd.ends_with(".bat") and not cmd.ends_with(".cmd"):
        resolved = "{cmd}.exe"

    # Check if absolute path
    if is_absolute_path(resolved):
        return resolved

    # Search in PATH
    extern fn rt_env_get(key: text) -> text
    val path_env = rt_env_get("PATH")
    val paths = path_env.split(path_sep())

    for dir in paths:
        val candidate = join_path(dir, resolved)
        extern fn rt_file_exists(path: text) -> bool
        if rt_file_exists(candidate):
            return candidate

    cmd  # Return original if not found
