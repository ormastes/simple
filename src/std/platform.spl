# Platform Abstraction Layer
#
# Provides convenient platform-agnostic functions for:
# - Platform detection (Windows/Unix/macOS/Linux)
# - Path handling (separators, normalization)
# - Command resolution (executable extensions)
#
# Pure Simple implementation using shell commands (uname) for platform detection.
# Uses direct extern fn calls to avoid bootstrap runtime import issues.

extern fn rt_env_get(key: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

export is_windows, is_unix, is_macos, is_linux
export dir_sep, path_sep, exe_ext, lib_ext
export normalize_path, resolve_command, is_absolute_path, join_path

# ===========================================================================
# Platform Detection - Pure Simple Implementation
# ===========================================================================

fn shell_output_trim(command: text) -> text:
    """Run shell command and return trimmed stdout."""
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    if code == 0:
        stdout.trim()
    else:
        ""

fn is_windows_env() -> bool:
    """Check if running on Windows by checking OS environment variable."""
    val os_env = rt_env_get("OS")
    if os_env == nil:
        false  # Default to Unix/Linux
    else:
        os_env.lower().contains("windows")

fn get_host_os() -> text:
    """Internal helper to get host OS using Pure Simple implementation."""
    if is_windows_env():
        "windows"
    else:
        # Unix: Use uname -s
        val os = shell_output_trim("uname -s")
        if os.len() == 0:
            "linux"  # Default
        else:
            match os:
                case "Linux": "linux"
                case "Darwin": "macos"
                case "FreeBSD": "freebsd"
                case "OpenBSD": "openbsd"
                case "NetBSD": "netbsd"
                case _: os.lower()

fn is_windows() -> bool:
    """Returns true if running on Windows."""
    get_host_os() == "windows"

fn is_unix() -> bool:
    """Returns true if running on Unix-like system (Linux, macOS, BSD)."""
    val os = get_host_os()
    os == "linux" or os == "macos" or os == "freebsd" or os == "openbsd" or os == "netbsd"

fn is_macos() -> bool:
    """Returns true if running on macOS."""
    get_host_os() == "macos"

fn is_linux() -> bool:
    """Returns true if running on Linux."""
    get_host_os() == "linux"

# ===========================================================================
# Path Separators - Pure Simple Implementation
# ===========================================================================

fn dir_sep() -> text:
    """Returns the directory separator for the current platform."""
    if is_windows():
        "\\"
    else:
        "/"

fn path_sep() -> text:
    """Returns the PATH environment variable separator."""
    if is_windows():
        ";"
    else:
        ":"

fn exe_ext() -> text:
    """Returns the executable extension for the current platform."""
    if is_windows():
        ".exe"
    else:
        ""

fn lib_ext() -> text:
    """Returns the dynamic library extension for the current platform."""
    if is_macos():
        ".dylib"
    elif is_windows():
        ".dll"
    else:
        ".so"  # Linux, FreeBSD, etc.

# ===========================================================================
# Path Normalization
# ===========================================================================

fn normalize_windows_path(path: text) -> text:
    """Normalize Windows path (convert forward slashes, handle drive letters and UNC paths)."""
    # Convert forward slashes to backslashes
    var normalized = path.replace("/", "\\")

    # Handle drive letters: C:/ → C:\
    if normalized.len() >= 2 and normalized[1] == ':':
        normalized = normalized[0:2] + normalized[2:].replace("/", "\\")

    # Handle UNC paths: //server/share → \\server\share
    if normalized.starts_with("//"):
        normalized = "\\\\" + normalized[2:]

    normalized

fn normalize_path(path: text) -> text:
    """Normalize path for current platform."""
    if is_windows():
        normalize_windows_path(path)
    else:
        path

# ===========================================================================
# Command Resolution
# ===========================================================================

fn resolve_command(cmd: text) -> text:
    if not is_windows():
        return cmd  # Unix: use PATH directly

    # Windows: add .exe if missing, search in PATH
    var resolved = cmd
    if not cmd.ends_with(".exe") and not cmd.ends_with(".bat") and not cmd.ends_with(".cmd"):
        resolved = "{cmd}.exe"

    # Check if absolute path
    if is_absolute_path(resolved):
        return resolved

    # Search in PATH
    extern fn rt_env_get(key: text) -> text
    val path_env = rt_env_get("PATH")
    val paths = path_env.split(path_sep())

    for dir in paths:
        val candidate = join_path(dir, resolved)
        extern fn rt_file_exists(path: text) -> bool
        if rt_file_exists(candidate):
            return candidate

    cmd  # Return original if not found

# ===========================================================================
# Path Utilities
# ===========================================================================

fn is_absolute_path(path: text) -> bool:
    """Check if path is absolute."""
    if is_windows():
        # C:\... or \\server\share or \...
        # WORKAROUND: Bootstrap parser doesn't support multi-line boolean expressions
        val has_drive = path.len() >= 3 and path[1] == ':'
        val is_unc = path.starts_with("\\\\")
        val is_root = path.starts_with("\\")
        has_drive or is_unc or is_root
    else:
        path.starts_with("/")

fn join_path(dir: text, file: text) -> text:
    val sep = dir_sep()
    if dir.ends_with(sep):
        "{dir}{file}"
    else:
        "{dir}{sep}{file}"
