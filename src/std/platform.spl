# Platform Abstraction Layer
#
# Provides convenient platform-agnostic functions for:
# - Platform detection (Windows/Unix/macOS/Linux)
# - Path handling (separators, normalization)
# - Command resolution (executable extensions)
#
# This module wraps src.std.common.target for easier usage.

use src.std.common.target (TargetOS, TargetArch, Target)

export is_windows, is_unix, is_macos, is_linux
export dir_sep, path_sep, exe_ext, lib_ext
export normalize_path, resolve_command, is_absolute_path, join_path

# ===========================================================================
# Platform Detection
# ===========================================================================

fn is_windows() -> bool:
    TargetOS.host().is_windows()

fn is_unix() -> bool:
    TargetOS.host().is_unix()

fn is_macos() -> bool:
    TargetOS.host() == TargetOS.MacOS

fn is_linux() -> bool:
    TargetOS.host() == TargetOS.Linux

# ===========================================================================
# Path Separators
# ===========================================================================

fn dir_sep() -> text:
    TargetOS.host().dir_separator()

fn path_sep() -> text:
    TargetOS.host().path_separator()

fn exe_ext() -> text:
    TargetOS.host().executable_extension()

fn lib_ext() -> text:
    TargetOS.host().library_extension()

# ===========================================================================
# Path Normalization
# ===========================================================================

fn normalize_windows_path(path: text) -> text:
    """Normalize Windows path (convert forward slashes, handle drive letters and UNC paths)."""
    # Convert forward slashes to backslashes
    var normalized = path.replace("/", "\\")

    # Handle drive letters: C:/ → C:\
    if normalized.len() >= 2 and normalized[1] == ':':
        normalized = normalized[0:2] + normalized[2:].replace("/", "\\")

    # Handle UNC paths: //server/share → \\server\share
    if normalized.starts_with("//"):
        normalized = "\\\\" + normalized[2:]

    normalized

fn normalize_path(path: text) -> text:
    """Normalize path for current platform."""
    val os = TargetOS.host()
    if os.is_windows():
        normalize_windows_path(path)
    else:
        path

# ===========================================================================
# Command Resolution
# ===========================================================================

fn resolve_command(cmd: text) -> text:
    if not is_windows():
        return cmd  # Unix: use PATH directly

    # Windows: add .exe if missing, search in PATH
    var resolved = cmd
    if not cmd.ends_with(".exe") and not cmd.ends_with(".bat") and not cmd.ends_with(".cmd"):
        resolved = "{cmd}.exe"

    # Check if absolute path
    if is_absolute_path(resolved):
        return resolved

    # Search in PATH
    extern fn rt_env_get(key: text) -> text
    val path_env = rt_env_get("PATH")
    val paths = path_env.split(path_sep())

    for dir in paths:
        val candidate = join_path(dir, resolved)
        extern fn rt_file_exists(path: text) -> bool
        if rt_file_exists(candidate):
            return candidate

    cmd  # Return original if not found

# ===========================================================================
# Path Utilities
# ===========================================================================

fn is_absolute_path(path: text) -> bool:
    """Check if path is absolute."""
    if is_windows():
        # C:\... or \\server\share or \...
        # WORKAROUND: Bootstrap parser doesn't support multi-line boolean expressions
        val has_drive = path.len() >= 3 and path[1] == ':'
        val is_unc = path.starts_with("\\\\")
        val is_root = path.starts_with("\\")
        has_drive or is_unc or is_root
    else:
        path.starts_with("/")

fn join_path(dir: text, file: text) -> text:
    val sep = dir_sep()
    if dir.ends_with(sep):
        "{dir}{file}"
    else:
        "{dir}{sep}{file}"
