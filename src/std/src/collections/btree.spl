# BTreeMap - Pure Simple Implementation
#
# No FFI, no Rust - 100% Pure Simple
# Sorted list-based ordered map

export BTreeMap

struct Entry:
    """Key-value pair in BTreeMap."""
    key: text
    value: text

class BTreeMap:
    """Pure Simple BTreeMap using sorted list.

    Maintains entries in sorted key order.

    Example:
        var tree = BTreeMap.new()
        tree.insert("apple", "red")
        tree.insert("banana", "yellow")
        val first = tree.first_key()  # Some("apple")
    """
    entries: [Entry]

    static fn new() -> BTreeMap:
        """Create new empty BTreeMap."""
        BTreeMap(entries: [])

    me insert(key: text, value: text):
        """Insert or update key-value pair (maintains sorted order)."""
        # Binary search for insertion point
        var left = 0
        var right = self.entries.len()

        while left < right:
            val mid = (left + right) / 2
            if self.entries[mid].key < key:
                left = mid + 1
            else:
                right = mid

        # Check if key exists at insertion point
        if left < self.entries.len() and self.entries[left].key == key:
            # Update existing
            self.entries[left].value = value
        else:
            # Insert new entry
            var new_entries: [Entry] = []
            for i in 0..left:
                new_entries.push(self.entries[i])
            new_entries.push(Entry(key: key, value: value))
            for i in left..self.entries.len():
                new_entries.push(self.entries[i])
            self.entries = new_entries

    fn get(key: text) -> text?:
        """Get value for key (binary search)."""
        var left = 0
        var right = self.entries.len()

        while left < right:
            val mid = (left + right) / 2
            if self.entries[mid].key == key:
                return Some(self.entries[mid].value)
            else if self.entries[mid].key < key:
                left = mid + 1
            else:
                right = mid

        None

    fn contains_key(key: text) -> bool:
        """Check if key exists."""
        val result = self.get(key)
        result.?

    me remove(key: text) -> text?:
        """Remove key and return value."""
        var left = 0
        var right = self.entries.len()

        while left < right:
            val mid = (left + right) / 2
            if self.entries[mid].key == key:
                # Found - remove it
                val value = self.entries[mid].value
                var new_entries: [Entry] = []
                for i in 0..mid:
                    new_entries.push(self.entries[i])
                for i in (mid + 1)..self.entries.len():
                    new_entries.push(self.entries[i])
                self.entries = new_entries
                return Some(value)
            else if self.entries[mid].key < key:
                left = mid + 1
            else:
                right = mid

        None

    fn keys() -> [text]:
        """Get all keys in sorted order."""
        var result: [text] = []
        for entry in self.entries:
            result.push(entry.key)
        result

    fn values() -> [text]:
        """Get all values in key-sorted order."""
        var result: [text] = []
        for entry in self.entries:
            result.push(entry.value)
        result

    me clear():
        """Remove all entries."""
        self.entries = []

    fn len() -> i64:
        """Get number of entries."""
        self.entries.len()

    fn is_empty() -> bool:
        """Check if empty."""
        self.entries.len() == 0

    fn first_key() -> text?:
        """Get smallest key."""
        if self.entries.len() > 0:
            Some(self.entries[0].key)
        else:
            None

    fn last_key() -> text?:
        """Get largest key."""
        if self.entries.len() > 0:
            Some(self.entries[self.entries.len() - 1].key)
        else:
            None
