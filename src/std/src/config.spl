# Config Module - Configuration loading and management
#
# Loads configuration from SDN files and provides typed access.
# Supports log configuration, DI profiles, and application modes.

use std.text.{parse_i64}

# FFI declarations
extern fn rt_file_read(path_ptr: i64, path_len: i64) -> text
extern fn rt_file_exists(path_ptr: i64, path_len: i64) -> bool
extern fn rt_sdn_parse(content_ptr: i64, content_len: i64) -> SdnValue

# ============================================================================
# Configuration Structures
# ============================================================================

struct LogConfig:
    """Logging configuration."""
    global_level: i64       # Default log level (0-10)
    scopes: Dict<text, i64> # Per-scope log levels
    timestamps: bool        # Include timestamps
    format: text            # Output format: "text" or "json"

struct DiConfig:
    """Dependency injection configuration."""
    profile: text           # Profile name: test, dev, prod, sdn
    bindings: Dict<text, text>  # Type -> implementation bindings

struct LiteralDefinition:
    """Configuration for a collection literal type."""
    kind: text               # "array", "dict", "set", "sorted_set", etc.
    enabled: bool
    prefix: text             # e.g., "s", "arr", "sorted" (empty = no prefix)
    brackets: text           # e.g., "{}", "[]"
    backend_class: text?     # Optional: custom class (e.g., "SortedSet")

struct LiteralsConfig:
    """Configuration for all collection literal types."""
    array: LiteralDefinition
    dict: LiteralDefinition
    set: LiteralDefinition
    custom: Dict<text, LiteralDefinition>

struct ParserConfig:
    """Parser configuration."""
    mode: text              # "outline" or "full"
    error_recovery: bool    # Enable error recovery
    max_errors: i64         # Maximum errors before abort
    literals: LiteralsConfig  # Collection literal syntax config

struct AopConfig:
    """AOP configuration."""
    enabled: bool           # Enable AOP weaving
    log_calls: bool         # Log function calls
    log_errors: bool        # Log errors
    log_level: i64          # AOP logging level

struct ExecutionConfig:
    """Execution mode configuration."""
    mode: text              # "interpret", "jit", or "aot"
    debug: bool             # Enable debug mode
    optimize: i64           # Optimization level (0-3)
    gc_threshold: i64       # GC collection threshold

struct AppConfig:
    """Complete application configuration."""
    log: LogConfig
    di: DiConfig
    parser: ParserConfig
    aop: AopConfig
    execution: ExecutionConfig

# ============================================================================
# Default Configurations
# ============================================================================

impl LogConfig:
    static fn default() -> LogConfig:
        LogConfig(
            global_level: 4,    # INFO
            scopes: {},
            timestamps: true,
            format: "text"
        )

    static fn testing() -> LogConfig:
        """Testing: Debug level, no timestamps."""
        LogConfig(
            global_level: 5,    # DEBUG
            scopes: {},
            timestamps: false,
            format: "text"
        )

    static fn development() -> LogConfig:
        """Development: Debug level with timestamps."""
        LogConfig(
            global_level: 5,    # DEBUG
            scopes: {},
            timestamps: true,
            format: "text"
        )

    static fn production() -> LogConfig:
        """Production: Warn level, JSON format."""
        LogConfig(
            global_level: 3,    # WARN
            scopes: {},
            timestamps: true,
            format: "json"
        )

    static fn sdn() -> LogConfig:
        """SDN parsing: Error level only."""
        LogConfig(
            global_level: 2,    # ERROR
            scopes: {},
            timestamps: false,
            format: "text"
        )

impl DiConfig:
    static fn default() -> DiConfig:
        DiConfig(
            profile: "dev",
            bindings: {}
        )

    static fn with_profile(profile: text) -> DiConfig:
        DiConfig(
            profile: profile,
            bindings: {}
        )

impl LiteralDefinition:
    static fn default_array() -> LiteralDefinition:
        """Default array literal config: [1, 2, 3]"""
        LiteralDefinition(
            kind: "array",
            enabled: true,
            prefix: "",           # No prefix: [1, 2, 3]
            brackets: "[]",
            backend_class: nil
        )

    static fn default_dict() -> LiteralDefinition:
        """Default dict literal config: {"k": "v"}"""
        LiteralDefinition(
            kind: "dict",
            enabled: true,
            prefix: "",           # No prefix: {"k": "v"}
            brackets: "{}",
            backend_class: nil
        )

    static fn default_set() -> LiteralDefinition:
        """Default set literal config: s{1, 2, 3}"""
        LiteralDefinition(
            kind: "set",
            enabled: true,
            prefix: "s",          # Prefix required: s{1, 2}
            brackets: "{}",
            backend_class: nil
        )

impl LiteralsConfig:
    static fn default() -> LiteralsConfig:
        """Default literals configuration."""
        LiteralsConfig(
            array: LiteralDefinition__default_array(),
            dict: LiteralDefinition__default_dict(),
            set: LiteralDefinition__default_set(),
            custom: {}
        )

impl ParserConfig:
    static fn default() -> ParserConfig:
        ParserConfig(
            mode: "full",
            error_recovery: true,
            max_errors: 100,
            literals: LiteralsConfig__default()
        )

    static fn outline() -> ParserConfig:
        """Outline mode for quick parsing (TreeSitter compatible)."""
        ParserConfig(
            mode: "outline",
            error_recovery: true,
            max_errors: 1000,
            literals: LiteralsConfig__default()
        )

impl AopConfig:
    static fn default() -> AopConfig:
        AopConfig(
            enabled: true,
            log_calls: false,
            log_errors: true,
            log_level: 5  # DEBUG
        )

    static fn disabled() -> AopConfig:
        AopConfig(
            enabled: false,
            log_calls: false,
            log_errors: false,
            log_level: 0
        )

impl ExecutionConfig:
    static fn default() -> ExecutionConfig:
        ExecutionConfig(
            mode: "interpret",
            debug: false,
            optimize: 1,
            gc_threshold: 1000000
        )

    static fn interpret() -> ExecutionConfig:
        ExecutionConfig(
            mode: "interpret",
            debug: true,
            optimize: 0,
            gc_threshold: 100000
        )

    static fn jit() -> ExecutionConfig:
        ExecutionConfig(
            mode: "jit",
            debug: false,
            optimize: 2,
            gc_threshold: 1000000
        )

    static fn aot() -> ExecutionConfig:
        ExecutionConfig(
            mode: "aot",
            debug: false,
            optimize: 3,
            gc_threshold: 10000000
        )

impl AppConfig:
    static fn default() -> AppConfig:
        AppConfig(
            log: LogConfig__default(),
            di: DiConfig__default(),
            parser: ParserConfig__default(),
            aop: AopConfig__default(),
            execution: ExecutionConfig__default()
        )

    static fn for_interpreter() -> AppConfig:
        """Configuration optimized for interpreter mode."""
        AppConfig(
            log: LogConfig__development(),
            di: DiConfig__with_profile("dev"),
            parser: ParserConfig__default(),
            aop: AopConfig__default(),
            execution: ExecutionConfig__interpret()
        )

    static fn for_compiler() -> AppConfig:
        """Configuration optimized for compilation."""
        AppConfig(
            log: LogConfig__production(),
            di: DiConfig__with_profile("prod"),
            parser: ParserConfig__default(),
            aop: AopConfig__disabled(),
            execution: ExecutionConfig__aot()
        )

    static fn for_sdn() -> AppConfig:
        """Configuration for SDN parsing (no code execution)."""
        AppConfig(
            log: LogConfig__sdn(),
            di: DiConfig__with_profile("sdn"),
            parser: ParserConfig__outline(),
            aop: AopConfig__disabled(),
            execution: ExecutionConfig(
                mode: "none",
                debug: false,
                optimize: 0,
                gc_threshold: 0
            )
        )

    static fn for_testing() -> AppConfig:
        """Configuration for test execution."""
        AppConfig(
            log: LogConfig__testing(),
            di: DiConfig__with_profile("test"),
            parser: ParserConfig__default(),
            aop: AopConfig__default(),
            execution: ExecutionConfig__interpret()
        )

# ============================================================================
# Configuration Loading
# ============================================================================

pub fn load_config(path: text) -> Result<AppConfig, text>:
    """Load configuration from SDN file."""
    if not file_exists(path):
        return Err("Config file not found: {path}")

    val content = file_read(path)
    val sdn = parse_sdn(content)

    if sdn.is_err():
        return Err("Failed to parse config: {sdn.unwrap_err()}")

    val data = sdn.unwrap()
    parse_app_config(data)

fn parse_app_config(data: SdnValue) -> Result<AppConfig, text>:
    """Parse AppConfig from SDN data."""
    Ok(AppConfig(
        log: parse_log_config(data["log"]),
        di: parse_di_config(data["di"]),
        parser: parse_parser_config(data["parser"]),
        aop: parse_aop_config(data["aop"]),
        execution: parse_execution_config(data["execution"])
    ))

fn parse_log_config(data: SdnValue?) -> LogConfig:
    """Parse LogConfig from SDN data."""
    if data.is_none():
        return LogConfig__default()

    val d = data.unwrap()
    LogConfig(
        global_level: d["global_level"] as i64 ?? 4,
        scopes: parse_scopes(d["scopes"]),
        timestamps: d["timestamps"] as bool ?? true,
        format: d["format"] as text ?? "text"
    )

fn parse_scopes(data: SdnValue?) -> Dict<text, i64>:
    """Parse scope levels from SDN data."""
    var result: Dict<text, i64> = {}
    if data.is_none():
        return result

    val d = data.unwrap()
    for key in d.keys():
        result[key] = d[key] as i64 ?? 4
    result

fn parse_di_config(data: SdnValue?) -> DiConfig:
    """Parse DiConfig from SDN data."""
    if data.is_none():
        return DiConfig__default()

    val d = data.unwrap()
    DiConfig(
        profile: d["profile"] as text ?? "dev",
        bindings: parse_bindings(d["bindings"])
    )

fn parse_bindings(data: SdnValue?) -> Dict<text, text>:
    """Parse DI bindings from SDN data."""
    var result: Dict<text, text> = {}
    if data.is_none():
        return result

    val d = data.unwrap()
    for key in d.keys():
        result[key] = d[key] as text ?? ""
    result

fn parse_parser_config(data: SdnValue?) -> ParserConfig:
    """Parse ParserConfig from SDN data."""
    if data.is_none():
        return ParserConfig__default()

    val d = data.unwrap()
    ParserConfig(
        mode: d["mode"] as text ?? "full",
        error_recovery: d["error_recovery"] as bool ?? true,
        max_errors: d["max_errors"] as i64 ?? 100
    )

fn parse_aop_config(data: SdnValue?) -> AopConfig:
    """Parse AopConfig from SDN data."""
    if data.is_none():
        return AopConfig__default()

    val d = data.unwrap()
    AopConfig(
        enabled: d["enabled"] as bool ?? true,
        log_calls: d["log_calls"] as bool ?? false,
        log_errors: d["log_errors"] as bool ?? true,
        log_level: d["log_level"] as i64 ?? 5
    )

fn parse_execution_config(data: SdnValue?) -> ExecutionConfig:
    """Parse ExecutionConfig from SDN data."""
    if data.is_none():
        return ExecutionConfig__default()

    val d = data.unwrap()
    ExecutionConfig(
        mode: d["mode"] as text ?? "interpret",
        debug: d["debug"] as bool ?? false,
        optimize: d["optimize"] as i64 ?? 1,
        gc_threshold: d["gc_threshold"] as i64 ?? 1000000
    )

# ============================================================================
# Configuration Merging (env, args, files)
# ============================================================================

extern fn rt_env_get(key_ptr: i64, key_len: i64) -> text?
extern fn rt_args_get() -> [text]

struct EnvOverrides:
    """Environment variable overrides for configuration."""
    log_level: text?          # SIMPLE_LOG_LEVEL
    profile: text?            # SIMPLE_PROFILE
    parser_mode: text?        # SIMPLE_PARSER_MODE
    execution_mode: text?     # SIMPLE_EXECUTION_MODE
    debug: text?              # SIMPLE_DEBUG
    optimize: text?           # SIMPLE_OPTIMIZE

struct ArgsOverrides:
    """Command-line argument overrides for configuration."""
    log_level: i64?
    profile: text?
    parser_mode: text?
    execution_mode: text?
    debug: bool?
    optimize: i64?
    config_file: text?

impl EnvOverrides:
    static fn from_env() -> EnvOverrides:
        """Load overrides from environment variables."""
        EnvOverrides(
            log_level: env_get("SIMPLE_LOG_LEVEL"),
            profile: env_get("SIMPLE_PROFILE"),
            parser_mode: env_get("SIMPLE_PARSER_MODE"),
            execution_mode: env_get("SIMPLE_EXECUTION_MODE"),
            debug: env_get("SIMPLE_DEBUG"),
            optimize: env_get("SIMPLE_OPTIMIZE")
        )

impl ArgsOverrides:
    static fn from_args(args: [text]) -> ArgsOverrides:
        """Parse command-line arguments into overrides."""
        var result = ArgsOverrides(
            log_level: nil,
            profile: nil,
            parser_mode: nil,
            execution_mode: nil,
            debug: nil,
            optimize: nil,
            config_file: nil
        )

        var i = 0
        while i < args.len():
            val arg = args[i]
            match arg:
                case "--log-level":
                    if i + 1 < args.len():
                        result.log_level = Some(parse_int(args[i + 1]))
                        i = i + 1
                case "--profile":
                    if i + 1 < args.len():
                        result.profile = Some(args[i + 1])
                        i = i + 1
                case "--parser-mode":
                    if i + 1 < args.len():
                        result.parser_mode = Some(args[i + 1])
                        i = i + 1
                case "--mode":
                    if i + 1 < args.len():
                        result.execution_mode = Some(args[i + 1])
                        i = i + 1
                case "--debug":
                    result.debug = Some(true)
                case "--no-debug":
                    result.debug = Some(false)
                case "--optimize":
                    if i + 1 < args.len():
                        result.optimize = Some(parse_int(args[i + 1]))
                        i = i + 1
                case "--config":
                    if i + 1 < args.len():
                        result.config_file = Some(args[i + 1])
                        i = i + 1
                case _:
                    pass  # Ignore unknown args
            i = i + 1

        result

impl AppConfig:
    fn merge_env(env: EnvOverrides) -> AppConfig:
        """Merge environment variable overrides into config."""
        var config = self

        if env.log_level.?:
            config.log.global_level = parse_log_level(env.log_level.unwrap())

        if env.profile.?:
            config.di.profile = env.profile.unwrap()

        if env.parser_mode.?:
            config.parser.mode = env.parser_mode.unwrap()

        if env.execution_mode.?:
            config.execution.mode = env.execution_mode.unwrap()

        if env.debug.?:
            config.execution.debug = env.debug.unwrap() == "true" or env.debug.unwrap() == "1"

        if env.optimize.?:
            config.execution.optimize = parse_int(env.optimize.unwrap())

        config

    fn merge_args(args: ArgsOverrides) -> AppConfig:
        """Merge command-line argument overrides into config."""
        var config = self

        if args.log_level.?:
            config.log.global_level = args.log_level.unwrap()

        if args.profile.?:
            config.di.profile = args.profile.unwrap()

        if args.parser_mode.?:
            config.parser.mode = args.parser_mode.unwrap()

        if args.execution_mode.?:
            config.execution.mode = args.execution_mode.unwrap()

        if args.debug.?:
            config.execution.debug = args.debug.unwrap()

        if args.optimize.?:
            config.execution.optimize = args.optimize.unwrap()

        config

fn parse_log_level(level: text) -> i64:
    """Parse log level from string."""
    match level.lower():
        case "off": 0
        case "fatal": 1
        case "error": 2
        case "warn" | "warning": 3
        case "info": 4
        case "debug": 5
        case "trace": 6
        case "verbose": 7
        case "all": 10
        case _: parse_int(level) ?? 4

fn parse_int(s: text) -> i64:
    """Parse integer from string."""
    parse_i64(s)

# ============================================================================
# Full Configuration Loading Pipeline
# ============================================================================

pub fn load_full_config(default_path: text) -> Result<AppConfig, text>:
    """Load configuration with full priority chain:
    1. Defaults (based on profile)
    2. Config file (if exists)
    3. Environment variables
    4. Command-line arguments (highest priority)
    """
    # Get args and env
    val args = ArgsOverrides__from_args(get_args())
    val env = EnvOverrides__from_env()

    # Determine config file path
    val config_path = args.config_file ?? env_get("SIMPLE_CONFIG") ?? default_path

    # Start with defaults
    var config = AppConfig__default()

    # Load from file if exists
    if file_exists(config_path):
        val file_config = load_config(config_path)
        if file_config.is_ok():
            config = file_config.unwrap()

    # Apply env overrides
    config = config.merge_env(env)

    # Apply args overrides (highest priority)
    config = config.merge_args(args)

    Ok(config)

pub fn quick_config() -> AppConfig:
    """Load configuration with sensible defaults and overrides."""
    load_full_config("simple.sdn").unwrap_or(AppConfig__default())

# ============================================================================
# Helper Functions
# ============================================================================

fn file_exists(path: text) -> bool:
    """Check if file exists."""
    rt_file_exists(path.ptr(), path.len())

fn file_read(path: text) -> text:
    """Read file contents."""
    rt_file_read(path.ptr(), path.len())

fn parse_sdn(content: text) -> Result<SdnValue, text>:
    """Parse SDN content."""
    Ok(rt_sdn_parse(content.ptr(), content.len()))

fn env_get(key: text) -> text?:
    """Get environment variable."""
    rt_env_get(key.ptr(), key.len())

fn get_args() -> [text]:
    """Get command-line arguments."""
    rt_args_get()

# ============================================================================
# Exports
# ============================================================================

export LogConfig, DiConfig, ParserConfig, AopConfig, ExecutionConfig, AppConfig
export LiteralDefinition, LiteralsConfig
export EnvOverrides, ArgsOverrides
export load_config, load_full_config, quick_config
