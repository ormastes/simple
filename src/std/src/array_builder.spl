# ArrayBuilder - Efficient array construction
#
# Provides pre-allocated array building to avoid O(n²) complexity
# from repeated array reallocations during construction.
#
# Use this instead of repeated .push() when building arrays,
# especially in performance-critical code like persistent collections.

export ArrayBuilder

struct ArrayBuilder<T>:
    """Efficient builder for constructing arrays.

    Pre-allocates capacity and builds array in-place,
    avoiding repeated allocations.

    Example:
        var builder = ArrayBuilder.with_capacity(100)
        for i in 0..100:
            builder.push(i)
        val array = builder.build()

    Performance:
        - Construction: O(1)
        - Push: O(1) amortized
        - Build: O(1) if at capacity, O(n) if slicing needed
    """
    data: [T]           # Pre-allocated backing array
    len: i64            # Current number of elements
    capacity: i64       # Total capacity

impl<T> ArrayBuilder<T>:
    # =========================================================================
    # Construction
    # =========================================================================

    static fn new() -> ArrayBuilder<T>:
        """Create a new builder with default capacity (16).

        Returns:
            Empty builder ready for elements
        """
        ArrayBuilder.with_capacity(16)

    static fn with_capacity(cap: i64) -> ArrayBuilder<T>:
        """Create a builder with specified capacity.

        Pre-allocates space for `cap` elements, avoiding
        reallocations during push operations.

        Args:
            cap: Initial capacity (number of elements)

        Returns:
            Empty builder with pre-allocated capacity

        Example:
            val builder = ArrayBuilder.with_capacity(1000)
        """
        ArrayBuilder(
            data: Array.allocate(cap),
            len: 0,
            capacity: cap
        )

    # =========================================================================
    # Push Operations
    # =========================================================================

    me push(value: T):
        """Push element without reallocation.

        Panics if capacity exceeded. Use push_safe() for auto-growing.

        Args:
            value: Element to add

        Time: O(1)

        Example:
            builder.push(42)
        """
        if self.len >= self.capacity:
            panic("ArrayBuilder capacity exceeded: {self.len} >= {self.capacity}")

        self.data[self.len] = value
        self.len = self.len + 1

    me push_safe(value: T):
        """Push element with automatic growth if needed.

        Grows capacity by 2x when full.

        Args:
            value: Element to add

        Time: O(1) amortized, O(n) when growing

        Example:
            builder.push_safe(42)  # Safe, will grow if needed
        """
        if self.len >= self.capacity:
            self.grow()

        self.push(value)

    me push_unchecked(value: T):
        """Push without bounds checking (unsafe, use only when capacity guaranteed).

        Use this in tight loops where you've pre-allocated exact capacity.

        Args:
            value: Element to add

        SAFETY: Caller must ensure len < capacity
        """
        self.data[self.len] = value
        self.len = self.len + 1

    # =========================================================================
    # Capacity Management
    # =========================================================================

    me grow():
        """Double the capacity.

        Allocates new array with 2x capacity and copies elements.

        Time: O(n)
        """
        val new_cap = if self.capacity == 0: 16 else: self.capacity * 2

        var new_data = Array.allocate(new_cap)

        # Copy existing elements
        for i in 0..self.len:
            new_data[i] = self.data[i]

        self.data = new_data
        self.capacity = new_cap

    me reserve(additional: i64):
        """Ensure space for at least `additional` more elements.

        Grows capacity if needed.

        Args:
            additional: Number of additional elements to reserve space for

        Example:
            builder.reserve(1000)  # Ensure space for 1000 more
        """
        val required = self.len + additional

        if required > self.capacity:
            # Grow to at least required size
            var new_cap = self.capacity
            while new_cap < required:
                new_cap = new_cap * 2

            var new_data = Array.allocate(new_cap)
            for i in 0..self.len:
                new_data[i] = self.data[i]

            self.data = new_data
            self.capacity = new_cap

    # =========================================================================
    # Building
    # =========================================================================

    fn build() -> [T]:
        """Return the built array with exact size.

        If the builder filled to capacity, returns the backing array directly.
        Otherwise, slices to exact length.

        Returns:
            Array containing all pushed elements

        Time: O(1) if at capacity, O(n) if slicing

        Example:
            val array = builder.build()
        """
        if self.len == self.capacity:
            # Exactly at capacity - return directly
            self.data
        else:
            # Slice to exact size
            self.data[0..self.len]

    fn build_move() -> [T]:
        """Build array, consuming the builder.

        Same as build(), but makes intent clear that builder
        should not be used afterward.

        Returns:
            Array containing all pushed elements
        """
        self.build()

    # =========================================================================
    # Queries
    # =========================================================================

    fn len() -> i64:
        """Get current number of elements.

        Returns:
            Number of elements pushed so far
        """
        self.len

    fn capacity() -> i64:
        """Get total capacity.

        Returns:
            Total allocated capacity
        """
        self.capacity

    fn is_empty() -> bool:
        """Check if builder is empty.

        Returns:
            true if no elements pushed
        """
        self.len == 0

    fn is_full() -> bool:
        """Check if builder is at capacity.

        Returns:
            true if len == capacity (next push would need growth)
        """
        self.len >= self.capacity

    fn remaining_capacity() -> i64:
        """Get remaining capacity before growth needed.

        Returns:
            Number of elements that can be pushed without growth
        """
        self.capacity - self.len

    # =========================================================================
    # Modification
    # =========================================================================

    me clear():
        """Clear all elements, resetting length to 0.

        Keeps allocated capacity.
        """
        self.len = 0

    me truncate(new_len: i64):
        """Truncate to specified length.

        Args:
            new_len: New length (must be <= current length)

        Panics if new_len > current length
        """
        if new_len > self.len:
            panic("Cannot truncate to length {new_len} > current {self.len}")

        self.len = new_len

# ============================================================================
# Usage Examples
# ============================================================================

# Basic usage:
#   var builder = ArrayBuilder.new()
#   builder.push(1)
#   builder.push(2)
#   builder.push(3)
#   val array = builder.build()  # [1, 2, 3]
#
# Pre-allocated (most efficient):
#   var builder = ArrayBuilder.with_capacity(1000)
#   for i in 0..1000:
#       builder.push(i)
#   val array = builder.build()
#
# With auto-growth:
#   var builder = ArrayBuilder.new()
#   for item in large_collection:
#       builder.push_safe(item)  # Grows as needed
#   val array = builder.build()
#
# Performance comparison:
#   # BAD - O(n²) due to repeated allocations
#   var arr: [i32] = []
#   for i in 0..1000:
#       arr = arr.push(i)  # Allocates new array each time
#
#   # GOOD - O(n) with single allocation
#   var builder = ArrayBuilder.with_capacity(1000)
#   for i in 0..1000:
#       builder.push(i)  # In-place, no allocation
#   val arr = builder.build()
