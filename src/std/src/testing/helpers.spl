# Test Helper Utilities
# Common utilities for writing tests more easily
# NOTE: This module intentionally uses bare bools and primitive APIs for testing

use time

# ============================================================================
# Assertion Helpers
# ============================================================================

pub fn assert_eq<T>(actual: T, expected: T, message: text):
    """Assert that two values are equal.

    Args:
        actual: Actual value
        expected: Expected value
        message: Error message if not equal

    Example:
        assert_eq(result, 42, "Result should be 42")
    """
    if actual != expected:
        panic("{message}: expected {expected}, got {actual}")

pub fn assert_ne<T>(actual: T, unexpected: T, message: text):
    """Assert that two values are not equal.

    Args:
        actual: Actual value
        unexpected: Value that should not match
        message: Error message if equal

    Example:
        assert_ne(result, 0, "Result should not be zero")
    """
    if actual == unexpected:
        panic("{message}: expected not {unexpected}, but got {actual}")

pub fn assert_true(condition: bool, message: text):
    """Assert that condition is true.

    Args:
        condition: Boolean condition
        message: Error message if false

    Example:
        assert_true(user.is_active(), "User should be active")
    """
    if not condition:
        panic("{message}: expected true, got false")

pub fn assert_false(condition: bool, message: text):
    """Assert that condition is false.

    Args:
        condition: Boolean condition
        message: Error message if true

    Example:
        assert_false(user.is_deleted(), "User should not be deleted")
    """
    if condition:
        panic("{message}: expected false, got true")

pub fn assert_some<T>(option: Option<T>, message: text) -> T:
    """Assert that Option is Some and return value.

    Args:
        option: Option to check
        message: Error message if None

    Returns:
        The unwrapped value

    Example:
        val user = assert_some(find_user("id123"), "User should exist")
    """
    match option:
        Some(v): v
        nil: panic("{message}: expected Some, got nil")

pub fn assert_none<T>(option: Option<T>, message: text):
    """Assert that Option is None.

    Args:
        option: Option to check
        message: Error message if Some

    Example:
        assert_none(find_user("invalid"), "User should not exist")
    """
    match option:
        Some(v): panic("{message}: expected nil, got Some({v})")
        nil: pass

pub fn assert_ok<T, E>(result: Result<T, E>, message: text) -> T:
    """Assert that Result is Ok and return value.

    Args:
        result: Result to check
        message: Error message if Err

    Returns:
        The unwrapped value

    Example:
        val data = assert_ok(load_data(), "Data load should succeed")
    """
    match result:
        Ok(v): v
        Err(e): panic("{message}: expected Ok, got Err({e})")

pub fn assert_err<T, E>(result: Result<T, E>, message: text) -> E:
    """Assert that Result is Err and return error.

    Args:
        result: Result to check
        message: Error message if Ok

    Returns:
        The error value

    Example:
        val error = assert_err(invalid_operation(), "Should fail")
    """
    match result:
        Ok(v): panic("{message}: expected Err, got Ok({v})")
        Err(e): e

# ============================================================================
# Timing Helpers
# ============================================================================

pub fn measure_time<T>(action: fn() -> T) -> (T, i64):
    """Measure execution time of an action.

    Args:
        action: Function to measure

    Returns:
        Tuple of (result, elapsed_microseconds)

    Example:
        val (result, elapsed) = measure_time(\: expensive_operation())
        print "Took {elapsed} μs"
    """
    val start = time.now_micros()
    val result = action()
    val elapsed = time.now_micros() - start
    (result, elapsed)

pub fn assert_fast<T>(action: fn() -> T, max_micros: i64, message: text) -> T:
    """Assert that action completes within time limit.

    Args:
        action: Function to measure
        max_micros: Maximum allowed microseconds
        message: Error message if too slow

    Returns:
        Result of action

    Example:
        val result = assert_fast(\: query_db(), 1000, "Query too slow")
    """
    val (result, elapsed) = measure_time(action)

    if elapsed > max_micros:
        panic("{message}: took {elapsed}μs, limit was {max_micros}μs")

    result

# ============================================================================
# Call Verification Helpers
# ============================================================================

# Note: For creating spies/mocks, use `mocks.create_mock()` directly.
# These helpers work with any object that has the call tracking interface.

pub fn assert_called(spy, times: i32):
    """Assert mock was called specific number of times.

    Args:
        spy: Mock/spy to verify (must have call_count() method)
        times: Expected call count

    Example:
        assert_called(save_mock, 3)
    """
    val actual = spy.call_count()
    if actual != times:
        panic("Expected {times} calls, got {actual}")

pub fn assert_called_with(spy, args: [text]):
    """Assert mock was called with specific arguments.

    Args:
        spy: Mock/spy to verify (must have was_called_with() method)
        args: Expected arguments

    Example:
        assert_called_with(save_mock, ["user123", "Alice"])
    """
    if not spy.was_called_with(args):
        panic("Mock was not called with {args}")

pub fn assert_not_called(spy):
    """Assert mock was never called.

    Args:
        spy: Mock/spy to verify (must have call_count() method)

    Example:
        assert_not_called(delete_mock)
    """
    val count = spy.call_count()
    if count > 0:
        panic("Expected no calls, but got {count}")

# ============================================================================
# Collection Helpers
# ============================================================================

pub fn assert_contains<T>(collection: [T], item: T, message: text):
    """Assert list contains item.

    Args:
        collection: List to check
        item: Item to find
        message: Error message if not found

    Example:
        assert_contains(users, "Alice", "Should contain Alice")
    """
    if not collection.contains(item):
        panic("{message}: {item} not found in collection")

pub fn assert_not_contains<T>(collection: [T], item: T, message: text):
    """Assert list does not contain item.

    Args:
        collection: List to check
        item: Item that should not exist
        message: Error message if found

    Example:
        assert_not_contains(blocked_users, "Alice", "Should not be blocked")
    """
    if collection.contains(item):
        panic("{message}: {item} should not be in collection")

pub fn assert_empty<T>(collection: [T], message: text):
    """Assert collection is empty.

    Args:
        collection: List to check
        message: Error message if not empty

    Example:
        assert_empty(errors, "Should have no errors")
    """
    if collection.len() > 0:
        panic("{message}: expected empty, got {collection.len()} items")

pub fn assert_len<T>(collection: [T], expected_len: i32, message: text):
    """Assert collection has specific length.

    Args:
        collection: List to check
        expected_len: Expected length
        message: Error message if wrong length

    Example:
        assert_len(results, 5, "Should have 5 results")
    """
    val actual_len = collection.len()
    if actual_len != expected_len:
        panic("{message}: expected length {expected_len}, got {actual_len}")

# ============================================================================
# Test Fixtures
# ============================================================================

pub fn with_cleanup<T>(setup: fn() -> T, teardown: fn(T), test: fn(T)):
    """Run test with setup and teardown.

    Args:
        setup: Function to create test fixture
        teardown: Function to clean up fixture
        test: Test function

    Example:
        with_cleanup(
            \: create_temp_file(),
            \file: delete_file(file),
            \file: test_file_operations(file)
        )
    """
    val fixture = setup()
    test(fixture)
    teardown(fixture)

pub fn with_timeout<T>(action: fn() -> T, timeout_secs: f64, message: text) -> T:
    """Run action with timeout.

    Args:
        action: Function to run
        timeout_secs: Timeout in seconds
        message: Error message if timeout

    Returns:
        Result of action

    Example:
        val result = with_timeout(\: slow_operation(), 5.0, "Operation timed out")
    """
    val start = time.now()
    val result = action()
    val elapsed = time.now() - start

    if elapsed > timeout_secs:
        panic("{message}: took {elapsed:.2f}s, limit was {timeout_secs:.2f}s")

    result

# ============================================================================
# Export
# ============================================================================

export assert_eq
export assert_ne
export assert_true
export assert_false
export assert_some
export assert_none
export assert_ok
export assert_err
export measure_time
export assert_fast
export assert_called
export assert_called_with
export assert_not_called
export assert_contains
export assert_not_contains
export assert_empty
export assert_len
export with_cleanup
export with_timeout
