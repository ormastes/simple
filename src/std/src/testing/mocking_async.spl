# ============================================================================
# Mock Library - Async/Await Mocking
# ============================================================================
#
# Asynchronous mocking features including:
# - Async call recording with delays and timeouts
# - Promise sequences and error handling  
# - Timing stats and async spies
# - Async protocol mocks and composition
# - Timing matchers for delay verification
#
# ============================================================================

# ============================================================================
# Phase 6: Async/Await Mocking
# ============================================================================

struct AsyncCallRecord:
    args: [text]
    timestamp: i64
    call_number: i32
    completion_time: i64
    result: Option<text>
    error: Option<text>
    delay_ms: i32

class AsyncMock:
    name: text
    calls: [AsyncCallRecord]
    return_values: [text]
    return_index: i32
    default_delay_ms: i32
    error_mode: bool
    error_message: text

    static fn new(name: text) -> AsyncMock:
        AsyncMock(
            name: name,
            calls: [],
            return_values: [],
            return_index: 0,
            default_delay_ms: 0,
            error_mode: false,
            error_message: ""
        )

    me set_delay(delay_ms: i32):
        self.default_delay_ms = delay_ms

    me set_return_values(values: [text]):
        self.return_values = values
        self.return_index = 0

    me set_error(message: text):
        self.error_mode = true
        self.error_message = message

    me clear_error():
        self.error_mode = false
        self.error_message = ""

    me record_async_call(args: [text]) -> text:
        val call_num = self.calls.len() as i32
        var result_value: Option<text> = nil
        var error_value: Option<text> = nil

        if self.error_mode:
            error_value = Some(self.error_message)
        else if self.return_index < self.return_values.len() as i32:
            result_value = Some(self.return_values[self.return_index as usize])
            self.return_index = self.return_index + 1

        val record = AsyncCallRecord(
            args: args,
            timestamp: 0,
            call_number: call_num,
            completion_time: self.default_delay_ms as i64,
            result: result_value,
            error: error_value,
            delay_ms: self.default_delay_ms
        )
        self.calls.append(record)

        match result_value:
            Some(v): v
            nil: ""

    fn call_count() -> i32:
        self.calls.len() as i32

    fn was_called() -> bool:
        self.calls.len() > 0

    fn was_called_with(expected_args: [text]) -> bool:
        for call in self.calls:
            if call.args.len() == expected_args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != expected_args[i]:
                        matches = false
                        break
                if matches:
                    return true
        false

    # Workaround: Use i64 param + direct indexing (i64 as usize not supported)
    fn get_call(index: i64) -> Option<AsyncCallRecord>:
        if index >= 0 and index < self.calls.len() as i64:
            Some(self.calls[index])
        else:
            nil

    fn get_last_call() -> Option<AsyncCallRecord>:
        if self.calls.len() > 0:
            Some(self.calls[self.calls.len() - 1])
        else:
            nil

    fn get_total_delay() -> i32:
        var total = 0
        for call in self.calls:
            total = total + call.delay_ms
        total

    fn get_calls_with_errors() -> [AsyncCallRecord]:
        var result = []
        for call in self.calls:
            match call.error:
                Some(_): result.append(call)
                nil: true
        result

    me reset():
        self.calls = []
        self.return_values = []
        self.return_index = 0
        self.error_mode = false
        self.error_message = ""

    fn summary() -> text:
        var parts = ["AsyncMock '{self.name}': {self.call_count()} call(s), total delay: {self.get_total_delay()}ms"]
        for call in self.calls:
            match call.error:
                Some(err): parts.push("  [ERR] {call.args} -> {err}")
                nil:
                    match call.result:
                        Some(r): parts.push("  {call.args} -> {r} ({call.delay_ms}ms)")
                        nil: parts.push("  {call.args} -> (no result)")
        parts.join("\n") + "\n"

struct PromiseReturn:
    value: text
    delay_ms: i32
    is_error: bool

class PromiseSequence:
    promises: [PromiseReturn]
    current_idx: i32

    static fn new() -> PromiseSequence:
        PromiseSequence(promises: [], current_idx: 0)

    me add_promise(value: text, delay_ms: i32):
        self.promises.append(PromiseReturn(
            value: value,
            delay_ms: delay_ms,
            is_error: false
        ))

    me add_promise_error(error: text, delay_ms: i32):
        self.promises.append(PromiseReturn(
            value: error,
            delay_ms: delay_ms,
            is_error: true
        ))

    fn next_promise() -> Option<PromiseReturn>:
        if self.current_idx >= self.promises.len() as i32:
            return nil
        val promise = self.promises[self.current_idx as usize]
        self.current_idx = self.current_idx + 1
        Some(promise)

    fn peek_next() -> Option<PromiseReturn>:
        if self.current_idx >= self.promises.len() as i32:
            return nil
        Some(self.promises[self.current_idx as usize])

    fn remaining() -> i32:
        (self.promises.len() as i32) - self.current_idx

    fn total_delay() -> i32:
        var total = 0
        for promise in self.promises:
            total = total + promise.delay_ms
        total

    me reset():
        self.current_idx = 0

struct TimingStats:
    min_ms: i32
    max_ms: i32
    avg_ms: i32
    total_ms: i32
    count: i32

class AsyncSpy:
    name: text
    calls: [AsyncCallRecord]

    static fn new(name: text) -> AsyncSpy:
        AsyncSpy(name: name, calls: [])

    me record_async_call(method: text, args: [text], duration_ms: i32):
        val full_args = [method].merge(args)
        val record = AsyncCallRecord(
            args: full_args,
            timestamp: 0,
            call_number: self.calls.len() as i32,
            completion_time: duration_ms as i64,
            result: nil,
            error: nil,
            delay_ms: duration_ms
        )
        self.calls.append(record)

    fn get_async_calls(method: text) -> [AsyncCallRecord]:
        var result = []
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                result.append(call)
        result

    fn method_called(method: text) -> bool:
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                return true
        false

    fn get_call_timing_stats(method: text) -> TimingStats:
        var min_val = 999999
        var max_val = 0
        var total = 0
        var count = 0
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                if call.delay_ms < min_val:
                    min_val = call.delay_ms
                if call.delay_ms > max_val:
                    max_val = call.delay_ms
                total = total + call.delay_ms
                count = count + 1
        val avg = if count > 0: total / count else: 0
        TimingStats(
            min_ms: if count > 0: min_val else: 0,
            max_ms: max_val,
            avg_ms: avg,
            total_ms: total,
            count: count
        )

    fn total_calls() -> i32:
        self.calls.len() as i32

    fn summary() -> text:
        var parts = ["AsyncSpy '{self.name}': {self.total_calls()} call(s)"]
        for call in self.calls:
            parts.push("  {call.args} ({call.delay_ms}ms)")
        parts.join("\n") + "\n"

struct AsyncMethodMock:
    method_name: text
    arguments: [text]
    return_value: text
    delay_ms: i32

class AsyncProtocolMock:
    method_mocks: [AsyncMethodMock]
    recorded_calls: [AsyncCallRecord]

    static fn new() -> AsyncProtocolMock:
        AsyncProtocolMock(method_mocks: [], recorded_calls: [])

    me mock_async_method(name: text, args: [text], delay_ms: i32, return_value: text):
        self.method_mocks.append(AsyncMethodMock(
            method_name: name,
            arguments: args,
            return_value: return_value,
            delay_ms: delay_ms
        ))

    me record_async_method_call(name: text, args: [text]) -> text:
        for method_mock in self.method_mocks:
            if method_mock.method_name == name:
                if method_mock.arguments.len() == args.len():
                    var matches = true
                    for i in 0..method_mock.arguments.len():
                        if method_mock.arguments[i] != args[i]:
                            matches = false
                            break
                    if matches:
                        self.recorded_calls.append(AsyncCallRecord(
                            args: [name].merge(args),
                            timestamp: 0,
                            call_number: self.recorded_calls.len() as i32,
                            completion_time: method_mock.delay_ms as i64,
                            result: Some(method_mock.return_value),
                            error: nil,
                            delay_ms: method_mock.delay_ms
                        ))
                        return method_mock.return_value
        ""

    fn verify_async_method_called(name: text) -> bool:
        for call in self.recorded_calls:
            if call.args.len() > 0 and call.args[0] == name:
                return true
        false

    fn get_async_method_calls(name: text) -> [AsyncCallRecord]:
        var result = []
        for call in self.recorded_calls:
            if call.args.len() > 0 and call.args[0] == name:
                result.append(call)
        result

    fn get_async_method_timing(name: text) -> [i32]:
        var result = []
        for call in self.recorded_calls:
            if call.args.len() > 0 and call.args[0] == name:
                result.append(call.delay_ms)
        result

    fn get_total_delay() -> i32:
        var total = 0
        for call in self.recorded_calls:
            total = total + call.delay_ms
        total

    fn reset():
        self.method_mocks = []
        self.recorded_calls = []

struct AsyncMockEntry:
    name: text
    mock_instance: AsyncMock

class AsyncMockComposition:
    mocks: [AsyncMockEntry]

    static fn new() -> AsyncMockComposition:
        AsyncMockComposition(mocks: [])

    me add_async_mock(name: text, async_mock: AsyncMock):
        self.mocks.append(AsyncMockEntry(name: name, mock_instance: async_mock))

    fn get_mock(name: text) -> Option<AsyncMock>:
        for entry in self.mocks:
            if entry.name == name:
                return Some(entry.mock_instance)
        nil

    fn verify_all_called() -> bool:
        for entry in self.mocks:
            if not entry.mock_instance.was_called():
                return false
        true

    fn get_total_calls() -> i32:
        var total = 0
        for entry in self.mocks:
            total = total + entry.mock_instance.call_count()
        total

    fn get_total_delay() -> i32:
        var total = 0
        for entry in self.mocks:
            total = total + entry.mock_instance.get_total_delay()
        total

    fn get_concurrent_call_count() -> i32:
        self.mocks.len() as i32

    fn reset_all():
        for entry in self.mocks:
            entry.mock_instance.reset()

    fn summary() -> text:
        var parts = ["AsyncMockComposition: {self.mocks.len()} mocks, {self.get_total_calls()} total calls, {self.get_total_delay()}ms total delay"]
        for entry in self.mocks:
            parts.push("  [{entry.name}] " + entry.mock_instance.summary())
        parts.join("\n")

class AsyncTimingMatcher:
    check_fn: fn(i32) -> bool
    description: text

    static fn within_ms(duration: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual <= duration,
            description: "within {duration}ms"
        )

    static fn at_least_ms(duration: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual >= duration,
            description: "at least {duration}ms"
        )

    static fn between_ms(min_ms: i32, max_ms: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual >= min_ms and actual <= max_ms,
            description: "between {min_ms}ms and {max_ms}ms"
        )

    static fn exactly_ms(duration: i32) -> AsyncTimingMatcher:
        AsyncTimingMatcher(
            check_fn: \actual: actual == duration,
            description: "exactly {duration}ms"
        )

    fn matches(actual_ms: i32) -> bool:
        self.check_fn(actual_ms)

    fn get_description() -> text:
        self.description

fn verify_async_timing(async_mock: AsyncMock, matcher: AsyncTimingMatcher) -> bool:
    val total_delay = async_mock.get_total_delay()
    matcher.matches(total_delay)

fn verify_call_timing(call: AsyncCallRecord, matcher: AsyncTimingMatcher) -> bool:
    matcher.matches(call.delay_ms)


# ============================================================================
# Exports
# ============================================================================

export AsyncCallRecord, AsyncMock
export PromiseReturn, PromiseSequence
export TimingStats, AsyncSpy
export AsyncMethodMock, AsyncProtocolMock
export AsyncMockEntry, AsyncMockComposition
export AsyncTimingMatcher
