# Context Manager Module - Pure Simple Implementation
#
# Provides context manager implementations for resource management
# with automatic cleanup using __enter__ and __exit__ protocol.
#
# NOTE: Pure Simple implementation - no FFI, no extern calls

export TimerContext, Timer, Lock, TransactionContext
export contextmanager, suppress
export time_now

# ============================================================================
# Helper: Current Time (Pure Simple - Simulated)
# ============================================================================

var _simulated_time: f64 = 0.0
var _time_increment: f64 = 0.001

fn time_now() -> f64:
    """Get current time as Unix timestamp in seconds.

    Returns:
        f64 - Current time in seconds (simulated for Pure Simple)

    Note:
        This is a Pure Simple simulation. Each call increments time slightly.
        In production, this would use system time.
    """
    _simulated_time = _simulated_time + _time_increment
    _simulated_time

# ============================================================================
# TimerContext - Time Measurement Context Manager
# ============================================================================

class TimerContext:
    """Context manager for measuring elapsed time of operations.

    Example:
        val timer = TimerContext("database query")
        timer.__enter__()
        # ... do work ...
        timer.__exit__(nil, nil, nil)
        print "Elapsed: {timer.elapsed()}s"
    """
    name: text
    start_time: f64
    end_time: f64?

    me __enter__():
        """Enter context - record start time."""
        self.start_time = time_now()
        print "[TIMER START] {self.name}"
        self

    me __exit__(exc_type, exc_value, traceback):
        """Exit context - record end time and print elapsed."""
        self.end_time = Some(time_now())
        val elapsed = self.elapsed()
        print "[TIMER END] {self.name}: {elapsed:.6f}s"

    fn elapsed() -> f64:
        """Get elapsed time in seconds.

        Returns:
            f64 - Elapsed time, or time since start if not ended
        """
        match self.end_time:
            Some(end):
                end - self.start_time
            None:
                # Still running - return current elapsed
                time_now() - self.start_time

    fn is_running() -> bool:
        """Check if timer is currently running.

        Returns:
            bool - true if timer has started but not ended
        """
        match self.end_time:
            Some(_): false
            None: self.start_time > 0.0

    fn get_elapsed() -> f64:
        """Get elapsed time (alias for elapsed()).

        Returns:
            f64 - Elapsed time in seconds
        """
        self.elapsed()

impl TimerContext:
    static fn create(name: text) -> TimerContext:
        """Create a new timer context.

        Args:
            name - Descriptive name for the timed operation

        Returns:
            TimerContext ready for use
        """
        TimerContext(
            name: name,
            start_time: 0.0,
            end_time: None
        )

    static fn new(name: text) -> TimerContext:
        """Create a new timer context (alias for create).

        Args:
            name - Descriptive name for the timed operation

        Returns:
            TimerContext ready for use
        """
        TimerContext.create(name)

# ============================================================================
# Timer - Alias for TimerContext
# ============================================================================

val Timer = TimerContext

# ============================================================================
# Lock - Mutex/Lock Context Manager
# ============================================================================

class Lock:
    """Context manager for mutual exclusion and thread-safe resource access.

    Example:
        val lock = Lock()
        lock.__enter__()
        # ... critical section ...
        lock.__exit__(nil, nil, nil)
    """
    locked: bool

    me __enter__():
        """Enter context - acquire lock."""
        self.locked = true
        self

    me __exit__(exc_type, exc_value, traceback):
        """Exit context - release lock."""
        self.locked = false
        false  # Don't suppress exceptions

    fn is_locked() -> bool:
        """Check if lock is currently acquired.

        Returns:
            bool - true if locked
        """
        self.locked

    fn is_unlocked() -> bool:
        """Check if lock is currently released.

        Returns:
            bool - true if unlocked
        """
        not self.locked

impl Lock:
    static fn create() -> Lock:
        """Create a new lock in unlocked state.

        Returns:
            Lock - New unlocked lock
        """
        Lock(locked: false)

    static fn new() -> Lock:
        """Create a new lock (alias for create).

        Returns:
            Lock - New unlocked lock
        """
        Lock.create()

# ============================================================================
# TransactionContext - Transaction Management
# ============================================================================

enum TransactionState:
    Pending
    Committed
    RolledBack

class TransactionContext:
    """Context manager for transactional operations with commit/rollback.

    Example:
        val tx = TransactionContext()
        tx.__enter__()
        # ... operations ...
        tx.__exit__(nil, nil, nil)  # Auto-commits if no error
    """
    state: TransactionState

    me __enter__():
        """Enter context - start transaction."""
        self.state = TransactionState.Pending
        self

    me __exit__(exc_type, exc_value, traceback):
        """Exit context - commit if no error, otherwise rollback."""
        match self.state:
            case TransactionState.Pending:
                if exc_type == nil:
                    self.state = TransactionState.Committed
                else:
                    self.state = TransactionState.RolledBack
            _:
                pass  # Already committed or rolled back
        false  # Don't suppress exceptions

    me rollback():
        """Manually rollback the transaction."""
        self.state = TransactionState.RolledBack

    fn is_pending() -> bool:
        """Check if transaction is pending.

        Returns:
            bool - true if not yet committed or rolled back
        """
        match self.state:
            case TransactionState.Pending: true
            _: false

    fn is_committed() -> bool:
        """Check if transaction was committed.

        Returns:
            bool - true if committed
        """
        match self.state:
            case TransactionState.Committed: true
            _: false

    fn is_rolled_back() -> bool:
        """Check if transaction was rolled back.

        Returns:
            bool - true if rolled back
        """
        match self.state:
            case TransactionState.RolledBack: true
            _: false

    fn is_completed() -> bool:
        """Check if transaction is complete (committed or rolled back).

        Returns:
            bool - true if not pending
        """
        not self.is_pending()

impl TransactionContext:
    static fn create() -> TransactionContext:
        """Create a new transaction in pending state.

        Returns:
            TransactionContext - New transaction
        """
        TransactionContext(state: TransactionState.Pending)

    static fn new() -> TransactionContext:
        """Create a new transaction (alias for create).

        Returns:
            TransactionContext - New transaction
        """
        TransactionContext.create()

# ============================================================================
# contextmanager - Helper Function
# ============================================================================

class ContextManagerWrapper:
    """Wrapper that creates a context manager from enter/exit functions."""
    enter_fn: fn()
    exit_fn: fn()

    me __enter__():
        """Call the enter function and return its result."""
        self.enter_fn()

    me __exit__(exc_type, exc_value, traceback):
        """Call the exit function."""
        self.exit_fn(exc_type, exc_value, traceback)

fn contextmanager(enter_fn, exit_fn) -> ContextManagerWrapper:
    """Create a context manager from separate enter and exit functions.

    Args:
        enter_fn - Function to call on __enter__ (takes no arguments, returns text)
        exit_fn - Function to call on __exit__

    Returns:
        ContextManagerWrapper - Context manager wrapping the functions

    Example:
        fn my_enter():
            print "Entering"
            return "resource"

        fn my_exit(exc_type, exc_value, tb):
            print "Exiting"
            return false

        val cm = contextmanager(my_enter, my_exit)
        val resource = cm.__enter__()
        cm.__exit__(nil, nil, nil)
    """
    ContextManagerWrapper(enter_fn: enter_fn, exit_fn: exit_fn)

# ============================================================================
# suppress - Exception Suppression Context Manager
# ============================================================================

class SuppressContext:
    """Context manager that suppresses specified exception types."""
    exception_types: [text]

    me __enter__():
        """Enter context."""
        self

    me __exit__(exc_type, exc_value, traceback) -> bool:
        """Exit context - return true if exception should be suppressed."""
        if exc_type == nil:
            return false

        # Check if exception type should be suppressed
        for ex_type in self.exception_types:
            if exc_type == ex_type:
                return true

        false

fn suppress(type1: text, type2: text) -> SuppressContext:
    """Create a context manager that suppresses two exception types.

    Args:
        type1 - First exception type name to suppress
        type2 - Second exception type name to suppress

    Returns:
        SuppressContext - Context manager that suppresses exceptions

    Example:
        val ctx = suppress("ValueError", "KeyError")
        ctx.__enter__()
        # ... code that might raise ValueError or KeyError ...
        val suppressed = ctx.__exit__("ValueError", "error", nil)
        # suppressed will be true for ValueError
    """
    SuppressContext(exception_types: [type1, type2])

fn suppress_one(type1: text) -> SuppressContext:
    """Create a context manager that suppresses one exception type.

    Args:
        type1 - Exception type name to suppress

    Returns:
        SuppressContext - Context manager that suppresses exceptions
    """
    SuppressContext(exception_types: [type1])

fn suppress_list(exception_types: [text]) -> SuppressContext:
    """Create a context manager that suppresses exception types from a list.

    Args:
        exception_types - List of exception type names to suppress

    Returns:
        SuppressContext - Context manager that suppresses exceptions
    """
    SuppressContext(exception_types: exception_types)
