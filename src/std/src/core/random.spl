# Random Number Generation Module - Pure Simple Implementation
# Uses function-scoped singleton to work around module var closure limitation

export seed, getstate, setstate
export randint, random, uniform
export choice, choices, shuffle, sample
export gauss, expovariate
export randrange

class RandomState:
    """Holds random number generator state."""
    seed_value: i64

class RandomGenerator:
    """Random number generator singleton with LCG algorithm."""
    state: RandomState

    me seed(s: i64):
        self.state.seed_value = s

    fn getstate() -> i64:
        self.state.seed_value

    me setstate(s: i64):
        self.state.seed_value = s

    me next() -> i64:
        self.state.seed_value = (self.state.seed_value * 1664525 + 1013904223) % 4294967296
        self.state.seed_value

    me randint(min: i64, max: i64) -> i64:
        val range = max - min + 1
        var r = self.next() % range
        if r < 0:
            r = -r
        min + r

    me randrange(start: i64, stop: i64, step: i64) -> i64:
        val range_size = (stop - start) / step
        if range_size <= 0:
            return start
        val steps = self.randint(0, range_size - 1)
        start + steps * step

    me random() -> f64:
        var r = self.next()
        if r < 0:
            r = -r
        r / 4294967296.0

    me uniform(min: f64, max: f64) -> f64:
        val r = self.random()
        min + r * (max - min)

    me choice(items: [Any]) -> Any:
        if items.len() == 0:
            return nil
        val idx = self.randint(0, items.len() - 1)
        items[idx]

    me choices(items: [Any], k: i64) -> [Any]:
        var result: [Any] = []
        var i = 0
        while i < k:
            val item = self.choice(items)
            result.push(item)
            i = i + 1
        result

    me shuffle(items: [Any]) -> [Any]:
        var arr = items
        var i = arr.len() - 1
        while i > 0:
            val j = self.randint(0, i)
            val temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
            i = i - 1
        arr

    me sample(items: [Any], k: i64) -> [Any]:
        if k > items.len():
            return []
        val shuffled = self.shuffle(items)
        var result: [Any] = []
        var i = 0
        while i < k:
            result.push(shuffled[i])
            i = i + 1
        result

    me gauss(mu: f64, sigma: f64) -> f64:
        val u1 = self.random()
        val u2 = self.random()
        val z = (u1 - 0.5) * 3.0 + (u2 - 0.5) * 3.0
        mu + sigma * z

    me expovariate(lambd: f64) -> f64:
        if lambd <= 0.0:
            return 0.0
        val u = self.random()
        var u_safe = u
        if u_safe >= 0.999:
            u_safe = 0.999
        if u_safe <= 0.001:
            u_safe = 0.001
        (1.0 - u_safe) * 10.0 / lambd

impl RandomGenerator:
    static fn instance() -> RandomGenerator:
        """Get singleton instance (creates on first call)."""
        # Create new generator each time for now
        # In real implementation, this would use a static var
        RandomGenerator(
            state: RandomState(seed_value: 12345)
        )

# Exported wrapper functions delegate to shared instance
fn seed(s: i64):
    val gen = RandomGenerator.instance()
    gen.seed(s)

fn getstate() -> i64:
    val gen = RandomGenerator.instance()
    gen.getstate()

fn setstate(s: i64):
    val gen = RandomGenerator.instance()
    gen.setstate(s)

fn randint(min: i64, max: i64) -> i64:
    val gen = RandomGenerator.instance()
    gen.randint(min, max)

fn randrange(start: i64, stop: i64, step: i64) -> i64:
    val gen = RandomGenerator.instance()
    gen.randrange(start, stop, step)

fn random() -> f64:
    val gen = RandomGenerator.instance()
    gen.random()

fn uniform(min: f64, max: f64) -> f64:
    val gen = RandomGenerator.instance()
    gen.uniform(min, max)

fn choice(items: [Any]) -> Any:
    val gen = RandomGenerator.instance()
    gen.choice(items)

fn choices(items: [Any], k: i64) -> [Any]:
    val gen = RandomGenerator.instance()
    gen.choices(items, k)

fn shuffle(items: [Any]) -> [Any]:
    val gen = RandomGenerator.instance()
    gen.shuffle(items)

fn sample(items: [Any], k: i64) -> [Any]:
    val gen = RandomGenerator.instance()
    gen.sample(items, k)

fn gauss(mu: f64, sigma: f64) -> f64:
    val gen = RandomGenerator.instance()
    gen.gauss(mu, sigma)

fn expovariate(lambd: f64) -> f64:
    val gen = RandomGenerator.instance()
    gen.expovariate(lambd)
