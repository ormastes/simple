# Experiment Artifact Store - Content-addressed artifacts
#
# Each run can register artifacts (files, checkpoints, models).
# Artifacts are stored as content-addressed blobs (SHA256 dedup).
# Per-run artifacts.sdn tracks references to blobs with metadata.

use std.exp.storage

extern fn rt_file_read_text(path: str) -> str
extern fn rt_file_write_text(path: str, content: str) -> bool
extern fn rt_file_exists(path: str) -> bool
extern fn rt_time_now_unix_micros() -> i64

# ============================================================================
# Artifact Entry
# ============================================================================

struct ArtifactEntry:
    """Reference to a stored artifact."""
    name: text
    blob_hash: text
    kind: text          # "file", "checkpoint", "model", "data"
    metadata: Dict<text, text>
    timestamp: text

impl ArtifactEntry:
    fn to_sdn_line() -> text:
        """Serialize to SDN line."""
        var meta_parts: [text] = []
        for key in self.metadata.keys():
            meta_parts = meta_parts.merge(["{key}=\"{self.metadata[key]}\""])
        val meta_str = meta_parts.join(", ")
        "  {self.name}: hash=\"{self.blob_hash}\", kind=\"{self.kind}\", time=\"{self.timestamp}\", {meta_str}"

# ============================================================================
# Artifact Store
# ============================================================================

struct ArtifactStore:
    """Manages artifacts for a single run."""
    run_id: text
    entries: [ArtifactEntry]

impl ArtifactStore:
    static fn for_run(run_id: text) -> ArtifactStore:
        """Create or load artifact store for a run."""
        val entries = load_artifacts(run_id)
        ArtifactStore(run_id: run_id, entries: entries)

    me register_file(name: text, source_path: text, metadata: Dict<text, text>) -> text:
        """Register a file as an artifact. Returns blob hash."""
        val hash = store_blob_file(source_path)
        val entry = ArtifactEntry(
            name: name,
            blob_hash: hash,
            kind: "file",
            metadata: metadata,
            timestamp: "{rt_time_now_unix_micros()}"
        )
        self.entries = self.entries.merge([entry])
        save_artifacts(self.run_id, self.entries)

        # Log event
        var data: Dict<text, text> = {}
        data["name"] = name
        data["hash"] = hash
        data["kind"] = "file"
        val event = Event(timestamp: entry.timestamp, kind: "artifact", data: data)
        append_event(self.run_id, event)

        hash

    me register_checkpoint(name: text, source_path: text, step: i64, metadata: Dict<text, text>) -> text:
        """Register a checkpoint artifact. Returns blob hash."""
        val hash = store_blob_file(source_path)
        var full_meta = metadata
        full_meta["step"] = "{step}"
        val entry = ArtifactEntry(
            name: name,
            blob_hash: hash,
            kind: "checkpoint",
            metadata: full_meta,
            timestamp: "{rt_time_now_unix_micros()}"
        )
        self.entries = self.entries.merge([entry])
        save_artifacts(self.run_id, self.entries)

        var data: Dict<text, text> = {}
        data["name"] = name
        data["hash"] = hash
        data["kind"] = "checkpoint"
        data["step"] = "{step}"
        val event = Event(timestamp: entry.timestamp, kind: "artifact", data: data)
        append_event(self.run_id, event)

        hash

    me register_data(name: text, content: text, metadata: Dict<text, text>) -> text:
        """Register inline data as an artifact. Returns blob hash."""
        val hash = store_blob(content)
        val entry = ArtifactEntry(
            name: name,
            blob_hash: hash,
            kind: "data",
            metadata: metadata,
            timestamp: "{rt_time_now_unix_micros()}"
        )
        self.entries = self.entries.merge([entry])
        save_artifacts(self.run_id, self.entries)

        hash

    fn get_artifact(name: text) -> ArtifactEntry?:
        """Get artifact entry by name."""
        for entry in self.entries:
            if entry.name == name:
                return Some(entry)
        nil

    fn get_blob(name: text) -> text?:
        """Read artifact blob content by name."""
        val entry = self.get_artifact(name)
        if entry.?:
            read_blob(entry.unwrap().blob_hash)
        else:
            nil

    fn list_artifacts() -> [ArtifactEntry]:
        """List all artifacts for this run."""
        self.entries

    fn referenced_hashes() -> [text]:
        """Get all blob hashes referenced by this run's artifacts."""
        self.entries.map(\e: e.blob_hash)

# ============================================================================
# Persistence
# ============================================================================

fn save_artifacts(run_id: text, entries: [ArtifactEntry]):
    """Save artifacts list to run's artifacts.sdn."""
    var lines: [text] = ["# Artifacts for run {run_id}", "artifacts:"]
    for entry in entries:
        lines = lines.merge([entry.to_sdn_line()])
    val content = lines.join("\n") + "\n"
    val path = "{run_dir_path(run_id)}/artifacts.sdn"
    file_write(path, content)

fn load_artifacts(run_id: text) -> [ArtifactEntry]:
    """Load artifacts from run's artifacts.sdn."""
    val path = "{run_dir_path(run_id)}/artifacts.sdn"
    if not file_exists(path):
        return []
    # TODO: Parse SDN artifacts file
    []

fn file_exists(path: text) -> bool:
    rt_file_exists(path)

fn file_write(path: text, content: text):
    rt_file_write_text(path, content)

# ============================================================================
# Garbage Collection
# ============================================================================

pub fn gc_artifacts() -> i64:
    """Remove unreferenced blobs. Returns number of blobs deleted."""
    # Collect all referenced hashes across all runs
    var referenced: Dict<text, bool> = {}
    val run_ids = list_run_ids()
    for run_id in run_ids:
        val store = ArtifactStore.for_run(run_id)
        for hash in store.referenced_hashes():
            referenced[hash] = true

    # Delete unreferenced blobs
    var deleted = 0
    val all_hashes = list_blob_hashes()
    for hash in all_hashes:
        if not referenced.contains_key(hash):
            if delete_blob(hash):
                deleted = deleted + 1
    deleted

# ============================================================================
# Exports
# ============================================================================

export ArtifactEntry, ArtifactStore
export gc_artifacts
