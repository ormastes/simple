# Map - Hash map / dictionary type
# Basic key-value store with O(1) average lookup

use std.math
use std.hash.Hash

# ============================================================================
# Map Entry
# ============================================================================

struct MapEntry<K, V>:
    key: K
    value: V
    hash: i64

# ============================================================================
# Map Type
# ============================================================================

struct Map<K, V> where K: Hash + Eq:
    buckets: [List<MapEntry<K, V>>]
    size: i32
    capacity: i32

    static fn new() -> Map<K, V>:
        """Create a new empty map.

        Returns:
            Empty map with default capacity

        Example:
            val map = Map.new()
        """
        val capacity = 16
        var buckets = []
        for _ in 0..capacity:
            buckets.append([])

        Map(
            buckets: buckets,
            size: 0,
            capacity: capacity
        )

    static fn with_capacity(capacity: i32) -> Map<K, V>:
        """Create a new map with specified capacity.

        Args:
            capacity: Initial capacity (number of buckets)

        Returns:
            Empty map with specified capacity

        Example:
            val map = Map.with_capacity(32)
        """
        var buckets = []
        for _ in 0..capacity:
            buckets.append([])

        Map(
            buckets: buckets,
            size: 0,
            capacity: capacity
        )

    fn len(self) -> i32:
        """Get number of entries in map.

        Returns:
            Number of key-value pairs

        Example:
            print map.len()
        """
        self.size

    fn is_empty(self) -> bool:
        """Check if map is empty.

        Returns:
            true if map has no entries

        Example:
            if map.is_empty():
                print "Empty map"
        """
        self.size == 0

    fn hash_key(key: K) -> i64:
        """Compute hash for key using Hash trait.

        Args:
            key: Key to hash

        Returns:
            Hash value (64-bit integer)

        The hash function used depends on the key type:
        - text: FNV-1a hash
        - i32/i64: Fibonacci/MurmurHash3
        - Compound types: Combined element hashes
        """
        key.hash()

    me insert(self, key: K, value: V):
        """Insert or update a key-value pair.

        Args:
            key: Key to insert
            value: Value to associate with key

        Example:
            map.insert("name", "Alice")
        """
        val hash = self.hash_key(key)
        val bucket_idx = (hash % self.capacity as i64) as i32

        # Get the bucket - make a mutable copy
        var bucket_ = self.buckets[bucket_idx]

        # Check if key already exists in bucket
        for i in 0..bucket_.len():
            if bucket_[i].key == key:
                # Update existing entry
                bucket_[i] = MapEntry(key: key, value: value, hash: hash)
                # Write back the modified bucket
                self.buckets[bucket_idx] = bucket_
                return

        # Add new entry
        bucket_.append(MapEntry(key: key, value: value, hash: hash))
        # Write back the modified bucket
        self.buckets[bucket_idx] = bucket_
        self.size = self.size + 1

        # Check if we need to rehash
        if self.size > self.capacity * 3 / 4:
            self.rehash()

    fn get(self, key: K) -> Option<V>:
        """Get value for key.

        Args:
            key: Key to look up

        Returns:
            Some(value) if key exists, None otherwise

        Example:
            match map.get("name"):
                Some(v): print v
                nil: print "Not found"
        """
        val hash = self.hash_key(key)
        val bucket_idx = (hash % self.capacity as i64) as i32

        val bucket = self.buckets[bucket_idx]
        for entry in bucket:
            if entry.key == key:
                return Some(entry.value)

        nil

    fn has(self, key: K) -> bool:
        """Check if map contains key.

        Args:
            key: Key to check

        Returns:
            true if key exists

        Example:
            if map.has("name"):
                print "Found!"
        """
        match self.get(key):
            Some(_): true
            nil: false

    @deprecated("Use 'has' instead of 'contains_key'")
    fn contains_key(self, key: K) -> bool:
        """Check if map contains key.

        Args:
            key: Key to check

        Returns:
            true if key exists

        Example:
            if map.contains_key("name"):
                print "Found!"
        """
        self.has(key)

    me remove(self, key: K) -> Option<V>:
        """Remove key-value pair.

        Args:
            key: Key to remove

        Returns:
            Some(value) if key existed, None otherwise

        Example:
            match map.remove("name"):
                Some(v): print "Removed: {v}"
                nil: print "Not found"
        """
        val hash = self.hash_key(key)
        val bucket_idx = (hash % self.capacity as i64) as i32

        var bucket = self.buckets[bucket_idx]
        for i in 0..bucket.len():
            if bucket[i].key == key:
                val value = bucket[i].value
                bucket.remove(i)
                self.size = self.size - 1
                return Some(value)

        nil

    me clear(self):
        """Remove all entries from map.

        Example:
            map.clear()
        """
        for i in 0..self.capacity:
            self.buckets[i] = []
        self.size = 0

    fn keys(self) -> [K]:
        """Get all keys in map.

        Returns:
            List of all keys

        Example:
            for key in map.keys():
                print key
        """
        var result = []
        for bucket in self.buckets:
            for entry in bucket:
                result.append(entry.key)
        result

    fn values(self) -> [V]:
        """Get all values in map.

        Returns:
            List of all values

        Example:
            for value in map.values():
                print value
        """
        var result = []
        for bucket in self.buckets:
            for entry in bucket:
                result.append(entry.value)
        result

    fn entries(self) -> [(K, V)]:
        """Get all key-value pairs.

        Returns:
            List of (key, value) tuples

        Example:
            for (key, value) in map.entries():
                print "{key}: {value}"
        """
        var result = []
        for bucket in self.buckets:
            for entry in bucket:
                result.append((entry.key, entry.value))
        result

    me rehash(self):
        """Resize map to larger capacity.

        Doubles capacity and rehashes all entries.
        """
        val new_capacity = self.capacity * 2
        var new_buckets = []
        for _ in 0..new_capacity:
            new_buckets.append([])

        # Rehash all entries
        for bucket in self.buckets:
            for entry in bucket:
                val bucket_idx = (entry.hash % new_capacity as i64) as i32
                new_buckets[bucket_idx].append(entry)

        self.buckets = new_buckets
        self.capacity = new_capacity

    fn get_or_default(self, key: K, default_value: V) -> V:
        """Get value or return default if key doesn't exist.

        Args:
            key: Key to look up
            default_value: Default value if key not found

        Returns:
            Value if found, otherwise default

        Example:
            val count = map.get_or_default("count", 0)
        """
        match self.get(key):
            Some(v): v
            nil: default_value

    me insert_if_absent(self, key: K, value: V) -> bool:
        """Insert only if key doesn't exist.

        Args:
            key: Key to insert
            value: Value to insert

        Returns:
            true if inserted, false if key already existed

        Example:
            if map.insert_if_absent("key", "value"):
                print "Inserted"
        """
        if self.has(key):
            return false

        self.insert(key, value)
        true

    me update(self, key: K, updater: fn(V) -> V):
        """Update value if key exists.

        Args:
            key: Key to update
            updater: Function to transform value

        Example:
            map.update("count", \v: v + 1)
        """
        match self.get(key):
            Some(v):
                val new_value = updater(v)
                self.insert(key, new_value)
            nil:
                pass

    fn filter(self, predicate: fn(K, V) -> bool) -> Map<K, V>:
        """Create new map with entries matching predicate.

        Args:
            predicate: Function to test each entry

        Returns:
            New map with filtered entries

        Example:
            val filtered = map.filter(\k, v: v > 10)
        """
        val result = Map.with_capacity(self.size)
        for (key, value) in self.entries():
            if predicate(key, value):
                result.insert(key, value)
        result

    fn map_values(self, mapper: fn(V) -> U) -> Map<K, U>:
        """Transform all values.

        Args:
            mapper: Function to transform values

        Returns:
            New map with transformed values

        Example:
            val doubled = map.map_values(\v: v * 2)
        """
        val result = Map.with_capacity(self.size)
        for (key, value) in self.entries():
            result.insert(key, mapper(value))
        result

    fn for_each(self, action: fn(K, V)):
        """Execute action for each entry.

        Args:
            action: Function to execute

        Example:
            map.for_each(\k, v: print "{k}: {v}")
        """
        for (key, value) in self.entries():
            action(key, value)

    me merge(self, other: Map<K, V>):
        """Merge another map into this one.

        Overwrites existing keys with values from other map.

        Args:
            other: Map to merge

        Example:
            map1.merge(map2)
        """
        for (key, value) in other.entries():
            self.insert(key, value)

    fn clone(self) -> Map<K, V>:
        """Create a shallow copy of the map.

        Returns:
            New map with same entries

        Example:
            val copy = map.clone()
        """
        # Direct bucket copy to avoid nested mutation bug with me methods
        var new_buckets_ = []
        for bucket in self.buckets:
            var new_bucket_ = []
            for entry in bucket:
                new_bucket_.append(MapEntry(key: entry.key, value: entry.value, hash: entry.hash))
            new_buckets_.append(new_bucket_)

        Map(
            buckets: new_buckets_,
            size: self.size,
            capacity: self.capacity
        )

# ============================================================================
# Map Literal Support
# ============================================================================

pub fn map_from_entries<K, V>(entries: [(K, V)]) -> Map<K, V>:
    """Create map from list of key-value pairs.

    Args:
        entries: List of (key, value) tuples

    Returns:
        Map containing all entries

    Example:
        val map = map_from_entries([
            ("name", "Alice"),
            ("age", "30")
        ])
    """
    val map = Map.with_capacity(entries.len() * 2)
    for (key, value) in entries:
        map.insert(key, value)
    map

# ============================================================================
# Export
# ============================================================================

export Map
export MapEntry
export map_from_entries
