# Base64 Encoding/Decoding Utilities Module
#
# Provides comprehensive Base64, Base32, hex, and binary encoding/decoding
# utilities following RFC 4648 standards.
#
# FEATURES:
# - Standard Base64 encoding/decoding
# - URL-safe Base64 variants
# - Base32 encoding/decoding (standard and extended hex)
# - Hexadecimal encoding/decoding
# - Binary string encoding/decoding
# - Custom alphabet support
# - Chunked/multiline encoding
# - Validation utilities
# - Padding control
# - Constant-time comparison for security
#
# IMPLEMENTATION NOTES:
# - Pure Simple implementation (no FFI)
# - No generics (uses concrete types)
# - No try/catch (uses Option/nil pattern)
# - No chained methods (uses intermediate variables)
# - Tuple-based data structures

# ============================================================================
# CONSTANTS AND ALPHABETS
# ============================================================================

# Standard Base64 alphabet (RFC 4648)
val BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

# URL-safe Base64 alphabet (RFC 4648 Section 5)
val BASE64_URL_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"

# Standard Base32 alphabet (RFC 4648)
val BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"

# Extended hex Base32 alphabet (RFC 4648)
val BASE32_HEX_ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUV"

# Hex alphabet (lowercase)
val HEX_ALPHABET_LOWER = "0123456789abcdef"

# Hex alphabet (uppercase)
val HEX_ALPHABET_UPPER = "0123456789ABCDEF"

# Padding character
val PADDING_CHAR = "="

# ============================================================================
# CHARACTER AND BYTE UTILITIES
# ============================================================================

# Get the character code for a single character
fn char_code(c: text) -> i64:
    if c == "":
        return 0
    var result = c.char_code_at(0)
    return result

# Create a character from a character code
fn char_from_code(code: i64) -> text:
    # ASCII characters
    if code == 32: return " "
    if code == 33: return "!"
    if code == 34: return "\""
    if code == 35: return "#"
    if code == 36: return "$"
    if code == 37: return "%"
    if code == 38: return "&"
    if code == 39: return "'"
    if code == 40: return "("
    if code == 41: return ")"
    if code == 42: return "*"
    if code == 43: return "+"
    if code == 44: return ","
    if code == 45: return "-"
    if code == 46: return "."
    if code == 47: return "/"
    if code == 48: return "0"
    if code == 49: return "1"
    if code == 50: return "2"
    if code == 51: return "3"
    if code == 52: return "4"
    if code == 53: return "5"
    if code == 54: return "6"
    if code == 55: return "7"
    if code == 56: return "8"
    if code == 57: return "9"
    if code == 58: return ":"
    if code == 59: return ";"
    if code == 60: return "<"
    if code == 61: return "="
    if code == 62: return ">"
    if code == 63: return "?"
    if code == 64: return "@"
    if code == 65: return "A"
    if code == 66: return "B"
    if code == 67: return "C"
    if code == 68: return "D"
    if code == 69: return "E"
    if code == 70: return "F"
    if code == 71: return "G"
    if code == 72: return "H"
    if code == 73: return "I"
    if code == 74: return "J"
    if code == 75: return "K"
    if code == 76: return "L"
    if code == 77: return "M"
    if code == 78: return "N"
    if code == 79: return "O"
    if code == 80: return "P"
    if code == 81: return "Q"
    if code == 82: return "R"
    if code == 83: return "S"
    if code == 84: return "T"
    if code == 85: return "U"
    if code == 86: return "V"
    if code == 87: return "W"
    if code == 88: return "X"
    if code == 89: return "Y"
    if code == 90: return "Z"
    if code == 91: return "["
    if code == 92: return "\\"
    if code == 93: return "]"
    if code == 94: return "^"
    if code == 95: return "_"
    if code == 96: return "`"
    if code == 97: return "a"
    if code == 98: return "b"
    if code == 99: return "c"
    if code == 100: return "d"
    if code == 101: return "e"
    if code == 102: return "f"
    if code == 103: return "g"
    if code == 104: return "h"
    if code == 105: return "i"
    if code == 106: return "j"
    if code == 107: return "k"
    if code == 108: return "l"
    if code == 109: return "m"
    if code == 110: return "n"
    if code == 111: return "o"
    if code == 112: return "p"
    if code == 113: return "q"
    if code == 114: return "r"
    if code == 115: return "s"
    if code == 116: return "t"
    if code == 117: return "u"
    if code == 118: return "v"
    if code == 119: return "w"
    if code == 120: return "x"
    if code == 121: return "y"
    if code == 122: return "z"
    if code == 123: return "{"
    if code == 124: return "|"
    if code == 125: return "}"
    if code == 126: return "~"
    if code == 10: return "\n"
    if code == 13: return "\r"
    if code == 9: return "\t"
    ""

# Check if character is whitespace
fn is_whitespace_char(c: text) -> bool:
    var result = false
    if c == " ": result = true
    if c == "\n": result = true
    if c == "\r": result = true
    if c == "\t": result = true
    result

# Check if character is valid Base64
fn is_base64_char(c: text) -> bool:
    var alphabet = BASE64_ALPHABET
    var i = 0
    var found = false
    while i < 64:
        val alphabet_char = text_char_at(alphabet, i)
        if c == alphabet_char:
            found = true
            return found
        i = i + 1
    found

# Get character at position in text
fn text_char_at(s: text, pos: i64) -> text:
    var slen = s.length()
    if pos < 0:
        return ""
    if pos >= slen:
        return ""
    var result = s.substring(pos, pos + 1)
    return result

# Get text length
fn text_length(s: text) -> i64:
    s.length()

# Get substring
fn text_substring(s: text, start: i64, end: i64) -> text:
    var slen = s.length()
    var real_start = start
    var real_end = end
    if real_start < 0:
        real_start = 0
    if real_end > slen:
        real_end = slen
    if real_start >= real_end:
        return ""
    var result = s.substring(real_start, real_end)
    return result

# Helper for substring
fn text_substring_helper(s: text, skip_first: i64) -> text:
    if s == "":
        return ""
    if skip_first == 0:
        # Return first character using string slicing
        var result = s.substring(0, 1)
        return result
    else:
        # Return everything after first character
        var slen = s.length()
        if slen <= 1:
            return ""
        var result = s.substring(1, slen)
        return result

# Concatenate two texts
fn text_concat(a: text, b: text) -> text:
    "{a}{b}"

# ============================================================================
# BYTE AND BIT OPERATIONS
# ============================================================================

# Convert byte to 8-bit binary string
fn byte_to_bits(b: i64) -> text:
    var result = ""
    var value = b
    var i = 0
    while i < 8:
        var bit = value % 2
        if bit == 0:
            result = text_concat("0", result)
        else:
            result = text_concat("1", result)
        value = value / 2
        i = i + 1
    result

# Convert 8-bit binary string to byte
fn bits_to_byte(bits: text) -> i64:
    var result = 0
    var i = 0
    while i < 8:
        var bit_char = text_char_at(bits, i)
        result = result * 2
        if bit_char == "1":
            result = result + 1
        i = i + 1
    result

# Convert text to list of byte values
fn text_to_bytes(s: text) -> list:
    var result = []
    var i = 0
    var len = s.length()
    while i < len:
        var code = s.char_code_at(i)
        result.push(code)
        i = i + 1
    result

# Convert list of byte values to text
fn bytes_to_text(bytes: list) -> text:
    var result = ""
    var i = 0
    var len = bytes.len()
    while i < len:
        var byte_val = bytes[i]
        var c = char_from_code(byte_val)
        result = result + c
        i = i + 1
    result

# List helper functions
fn list_append(lst: list, item: i64) -> list:
    var new_list = []
    var i = 0
    var len = lst.len()
    while i < len:
        new_list.push(lst[i])
        i = i + 1
    new_list.push(item)
    new_list

fn list_get(lst: list, index: i64) -> i64:
    if index < 0:
        return 0
    var len = lst.len()
    if index >= len:
        return 0
    lst[index]

fn list_length(lst: list) -> i64:
    lst.len()

# ============================================================================
# BASE64 CHARACTER MAPPING
# ============================================================================

# Convert character to Base64 index (0-63)
fn char_to_base64_index(c: text, alphabet: text) -> i64:
    var i = 0
    while i < 64:
        val alphabet_char = text_char_at(alphabet, i)
        if c == alphabet_char:
            return i
        i = i + 1
    -1  # Invalid character

# Convert Base64 index to character
fn base64_index_to_char(index: i64, alphabet: text) -> text:
    if index < 0:
        return ""
    if index >= 64:
        return ""
    text_char_at(alphabet, index)

# ============================================================================
# PADDING UTILITIES
# ============================================================================

# Calculate padding needed for given length
fn calculate_padding(length: i64) -> i64:
    var remainder = length % 4
    if remainder == 0:
        return 0
    4 - remainder

# Add padding to encoded string
fn add_padding(encoded: text) -> text:
    var padding_needed = calculate_padding(text_length(encoded))
    var result = encoded
    var i = 0
    while i < padding_needed:
        result = text_concat(result, PADDING_CHAR)
        i = i + 1
    result

# Remove padding from encoded string
fn remove_padding(encoded: text) -> text:
    var result = encoded
    var len = text_length(result)
    while len > 0:
        var last_char = text_char_at(result, len - 1)
        if last_char == PADDING_CHAR:
            result = text_substring(result, 0, len - 1)
            len = len - 1
        else:
            return result
    result

# Count padding characters
fn count_padding(encoded: text) -> i64:
    var count = 0
    var len = text_length(encoded)
    var i = len - 1
    while i >= 0:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            count = count + 1
        else:
            return count
        i = i - 1
    count

# ============================================================================
# SIZE ESTIMATION
# ============================================================================

# Estimate encoded size for Base64
fn estimate_encoded_size(input_length: i64) -> i64:
    var base_size = (input_length * 4) / 3
    var remainder = input_length % 3
    if remainder != 0:
        base_size = base_size + 4 - remainder
    base_size

# Estimate decoded size for Base64
fn estimate_decoded_size(encoded_length: i64) -> i64:
    var padding = count_padding("")  # Would need actual string
    var effective_length = encoded_length - padding
    (effective_length * 3) / 4

# ============================================================================
# VALIDATION UTILITIES
# ============================================================================

# Check if text is valid Base64
fn is_valid_base64(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var len_mod = len % 4
    if len_mod != 0:
        return false
    var i = 0
    var padding_started = false
    while i < len:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            padding_started = true
        else:
            if padding_started:
                # No characters allowed after padding
                return false
            var is_valid = is_base64_char(c)
            if not is_valid:
                return false
        i = i + 1
    true

# Check if text is valid URL-safe Base64
fn is_valid_base64_url(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var i = 0
    while i < len:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            # Check remaining are all padding
            var j = i
            while j < len:
                var pad_c = text_char_at(encoded, j)
                if pad_c != PADDING_CHAR:
                    return false
                j = j + 1
            return true
        var alphabet = BASE64_URL_ALPHABET
        var idx = char_to_base64_index(c, alphabet)
        if idx < 0:
            return false
        i = i + 1
    true

# Check if text is valid hexadecimal
fn is_valid_hex(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var len_mod = len % 2
    if len_mod != 0:
        return false
    var i = 0
    while i < len:
        var c = text_char_at(encoded, i)
        var is_hex = is_hex_char(c)
        if not is_hex:
            return false
        i = i + 1
    true

# Check if character is valid hex digit
fn is_hex_char(c: text) -> bool:
    var lower = HEX_ALPHABET_LOWER
    var upper = HEX_ALPHABET_UPPER
    var i = 0
    while i < 16:
        var lower_c = text_char_at(lower, i)
        var upper_c = text_char_at(upper, i)
        if c == lower_c:
            return true
        if c == upper_c:
            return true
        i = i + 1
    false

# Check if text is valid Base32
fn is_valid_base32(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var i = 0
    while i < len:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            # Check remaining are all padding
            var j = i
            while j < len:
                var pad_c = text_char_at(encoded, j)
                if pad_c != PADDING_CHAR:
                    return false
                j = j + 1
            return true
        var alphabet = BASE32_ALPHABET
        var found = false
        var j = 0
        while j < 32:
            var alphabet_c = text_char_at(alphabet, j)
            if c == alphabet_c:
                found = true
                j = 999
            j = j + 1
        if not found:
            return false
        i = i + 1
    true

# ============================================================================
# STANDARD BASE64 ENCODING
# ============================================================================

# Encode data using standard Base64
fn encode_base64(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_ALPHABET, true)

# Encode data using standard Base64 without padding
fn encode_base64_no_pad(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_ALPHABET, false)

# Encode using custom alphabet with optional padding
fn encode_base64_with_alphabet(data: text, alphabet: text, use_padding: bool) -> text:
    var bytes = text_to_bytes(data)
    var result = ""
    var i = 0
    var len = list_length(bytes)

    # Process 3 bytes at a time
    while i < len:
        var b1 = list_get(bytes, i)
        var b2 = 0
        var b3 = 0
        var has_b2 = false
        var has_b3 = false

        if i + 1 < len:
            b2 = list_get(bytes, i + 1)
            has_b2 = true
        if i + 2 < len:
            b3 = list_get(bytes, i + 2)
            has_b3 = true

        # Convert 3 bytes to 4 Base64 characters
        # First character: top 6 bits of b1
        var idx1 = b1 / 4
        var c1 = base64_index_to_char(idx1, alphabet)
        result = text_concat(result, c1)

        # Second character: bottom 2 bits of b1 + top 4 bits of b2
        var idx2 = ((b1 % 4) * 16) + (b2 / 16)
        var c2 = base64_index_to_char(idx2, alphabet)
        result = text_concat(result, c2)

        # Third character
        if has_b2:
            var idx3 = ((b2 % 16) * 4) + (b3 / 64)
            var c3 = base64_index_to_char(idx3, alphabet)
            result = text_concat(result, c3)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        # Fourth character
        if has_b3:
            var idx4 = b3 % 64
            var c4 = base64_index_to_char(idx4, alphabet)
            result = text_concat(result, c4)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        i = i + 3

    result

# ============================================================================
# URL-SAFE BASE64 ENCODING
# ============================================================================

# Encode data using URL-safe Base64
fn encode_base64_url(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_URL_ALPHABET, true)

# Encode data using URL-safe Base64 without padding
fn encode_base64_url_no_pad(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_URL_ALPHABET, false)

# ============================================================================
# STANDARD BASE64 DECODING
# ============================================================================

# Decode standard Base64 encoded data
fn decode_base64(encoded: text) -> text:
    decode_base64_with_alphabet(encoded, BASE64_ALPHABET)

# Decode URL-safe Base64 encoded data
fn decode_base64_url(encoded: text) -> text:
    decode_base64_with_alphabet(encoded, BASE64_URL_ALPHABET)

# Decode Base64 using custom alphabet
fn decode_base64_with_alphabet(encoded: text, alphabet: text) -> text:
    var clean = strip_whitespace(encoded)
    var with_padding = add_padding(clean)
    var result_bytes = []
    var i = 0
    var len = text_length(with_padding)

    # Process 4 characters at a time
    while i < len:
        var c1 = text_char_at(with_padding, i)
        var c2 = text_char_at(with_padding, i + 1)
        var c3 = text_char_at(with_padding, i + 2)
        var c4 = text_char_at(with_padding, i + 3)

        if c1 == PADDING_CHAR:
            i = 999999  # Break loop
        else:
            var idx1 = char_to_base64_index(c1, alphabet)
            var idx2 = char_to_base64_index(c2, alphabet)

            # First byte: 6 bits from idx1 + top 2 bits from idx2
            var b1 = (idx1 * 4) + (idx2 / 16)
            result_bytes = list_append(result_bytes, b1)

            if c3 != PADDING_CHAR:
                var idx3 = char_to_base64_index(c3, alphabet)
                # Second byte: bottom 4 bits from idx2 + top 4 bits from idx3
                var b2 = ((idx2 % 16) * 16) + (idx3 / 4)
                result_bytes = list_append(result_bytes, b2)

                if c4 != PADDING_CHAR:
                    var idx4 = char_to_base64_index(c4, alphabet)
                    # Third byte: bottom 2 bits from idx3 + 6 bits from idx4
                    var b3 = ((idx3 % 4) * 64) + idx4
                    result_bytes = list_append(result_bytes, b3)

        i = i + 4

    bytes_to_text(result_bytes)

# ============================================================================
# BASE32 ENCODING
# ============================================================================

# Encode data using standard Base32
fn encode_base32(data: text) -> text:
    encode_base32_with_alphabet(data, BASE32_ALPHABET, true)

# Encode data using Base32 hex alphabet
fn encode_base32_hex(data: text) -> text:
    encode_base32_with_alphabet(data, BASE32_HEX_ALPHABET, true)

# Encode data using Base32 without padding
fn encode_base32_no_pad(data: text) -> text:
    encode_base32_with_alphabet(data, BASE32_ALPHABET, false)

# Encode using custom Base32 alphabet
fn encode_base32_with_alphabet(data: text, alphabet: text, use_padding: bool) -> text:
    var bytes = text_to_bytes(data)
    var result = ""
    var i = 0
    var len = list_length(bytes)

    # Process 5 bytes at a time (40 bits -> 8 characters of 5 bits each)
    while i < len:
        var b1 = list_get(bytes, i)
        var b2 = 0
        var b3 = 0
        var b4 = 0
        var b5 = 0
        var count = 1

        if i + 1 < len:
            b2 = list_get(bytes, i + 1)
            count = 2
        if i + 2 < len:
            b3 = list_get(bytes, i + 2)
            count = 3
        if i + 3 < len:
            b4 = list_get(bytes, i + 3)
            count = 4
        if i + 4 < len:
            b5 = list_get(bytes, i + 4)
            count = 5

        # Convert 5 bytes to 8 Base32 characters (5 bits each)
        var idx1 = b1 / 8
        var c1 = text_char_at(alphabet, idx1)
        result = text_concat(result, c1)

        var idx2 = ((b1 % 8) * 4) + (b2 / 64)
        var c2 = text_char_at(alphabet, idx2)
        result = text_concat(result, c2)

        if count >= 2:
            var idx3 = (b2 / 2) % 32
            var c3 = text_char_at(alphabet, idx3)
            result = text_concat(result, c3)

            var idx4 = ((b2 % 2) * 16) + (b3 / 16)
            var c4 = text_char_at(alphabet, idx4)
            result = text_concat(result, c4)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)
                result = text_concat(result, PADDING_CHAR)

        if count >= 3:
            var idx5 = ((b3 % 16) * 2) + (b4 / 128)
            var c5 = text_char_at(alphabet, idx5)
            result = text_concat(result, c5)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        if count >= 4:
            var idx6 = (b4 / 4) % 32
            var c6 = text_char_at(alphabet, idx6)
            result = text_concat(result, c6)

            var idx7 = ((b4 % 4) * 8) + (b5 / 32)
            var c7 = text_char_at(alphabet, idx7)
            result = text_concat(result, c7)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)
                result = text_concat(result, PADDING_CHAR)

        if count >= 5:
            var idx8 = b5 % 32
            var c8 = text_char_at(alphabet, idx8)
            result = text_concat(result, c8)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        i = i + 5

    result

# ============================================================================
# BASE32 DECODING
# ============================================================================

# Decode standard Base32 encoded data
fn decode_base32(encoded: text) -> text:
    decode_base32_with_alphabet(encoded, BASE32_ALPHABET)

# Decode Base32 hex encoded data
fn decode_base32_hex(encoded: text) -> text:
    decode_base32_with_alphabet(encoded, BASE32_HEX_ALPHABET)

# Decode Base32 using custom alphabet
fn decode_base32_with_alphabet(encoded: text, alphabet: text) -> text:
    var clean = strip_whitespace(encoded)
    var result_bytes = []
    var i = 0
    var len = text_length(clean)

    # Process 8 characters at a time
    while i < len:
        var chars = []
        var j = 0
        while j < 8:
            if i + j < len:
                var c = text_char_at(clean, i + j)
                if c != PADDING_CHAR:
                    var idx = find_char_in_alphabet(c, alphabet)
                    chars = list_append(chars, idx)
                else:
                    chars = list_append(chars, -1)
            else:
                chars = list_append(chars, -1)
            j = j + 1

        # Convert 8 Base32 characters back to 5 bytes
        var idx1 = list_get(chars, 0)
        var idx2 = list_get(chars, 1)
        if idx1 >= 0:
            if idx2 >= 0:
                var b1 = (idx1 * 8) + (idx2 / 4)
                result_bytes = list_append(result_bytes, b1)

        var idx3 = list_get(chars, 2)
        var idx4 = list_get(chars, 3)
        if idx2 >= 0:
            if idx3 >= 0:
                if idx4 >= 0:
                    var b2 = ((idx2 % 4) * 64) + (idx3 * 2) + (idx4 / 16)
                    result_bytes = list_append(result_bytes, b2)

        var idx5 = list_get(chars, 4)
        if idx4 >= 0:
            if idx5 >= 0:
                var b3 = ((idx4 % 16) * 16) + (idx5 / 2)
                result_bytes = list_append(result_bytes, b3)

        var idx6 = list_get(chars, 5)
        var idx7 = list_get(chars, 6)
        if idx5 >= 0:
            if idx6 >= 0:
                if idx7 >= 0:
                    var b4 = ((idx5 % 2) * 128) + (idx6 * 4) + (idx7 / 8)
                    result_bytes = list_append(result_bytes, b4)

        var idx8 = list_get(chars, 7)
        if idx7 >= 0:
            if idx8 >= 0:
                var b5 = ((idx7 % 8) * 32) + idx8
                result_bytes = list_append(result_bytes, b5)

        i = i + 8

    bytes_to_text(result_bytes)

# Find character index in alphabet
fn find_char_in_alphabet(c: text, alphabet: text) -> i64:
    var i = 0
    var len = text_length(alphabet)
    while i < len:
        var alphabet_c = text_char_at(alphabet, i)
        if c == alphabet_c:
            return i
        i = i + 1
    -1

# ============================================================================
# HEXADECIMAL ENCODING
# ============================================================================

# Encode data as lowercase hexadecimal
fn encode_hex(data: text) -> text:
    encode_hex_with_alphabet(data, HEX_ALPHABET_LOWER)

# Encode data as uppercase hexadecimal
fn encode_hex_upper(data: text) -> text:
    encode_hex_with_alphabet(data, HEX_ALPHABET_UPPER)

# Encode data as lowercase hexadecimal (alias)
fn encode_hex_lower(data: text) -> text:
    encode_hex_with_alphabet(data, HEX_ALPHABET_LOWER)

# Encode using custom hex alphabet
fn encode_hex_with_alphabet(data: text, alphabet: text) -> text:
    var bytes = text_to_bytes(data)
    var result = ""
    var i = 0
    var len = list_length(bytes)

    while i < len:
        var byte_val = list_get(bytes, i)
        var high = byte_val / 16
        var low = byte_val % 16
        var high_char = text_char_at(alphabet, high)
        var low_char = text_char_at(alphabet, low)
        result = text_concat(result, high_char)
        result = text_concat(result, low_char)
        i = i + 1

    result

# ============================================================================
# HEXADECIMAL DECODING
# ============================================================================

# Decode hexadecimal encoded data (case-insensitive)
fn decode_hex(encoded: text) -> text:
    var clean = strip_whitespace(encoded)
    var result_bytes = []
    var i = 0
    var len = text_length(clean)

    while i < len:
        var high_char = text_char_at(clean, i)
        var low_char = text_char_at(clean, i + 1)

        var high_val = hex_char_to_value(high_char)
        var low_val = hex_char_to_value(low_char)

        var byte_val = (high_val * 16) + low_val
        result_bytes = list_append(result_bytes, byte_val)

        i = i + 2

    bytes_to_text(result_bytes)

# Convert hex character to value (0-15)
fn hex_char_to_value(c: text) -> i64:
    if c == "0": return 0
    if c == "1": return 1
    if c == "2": return 2
    if c == "3": return 3
    if c == "4": return 4
    if c == "5": return 5
    if c == "6": return 6
    if c == "7": return 7
    if c == "8": return 8
    if c == "9": return 9
    if c == "a": return 10
    if c == "b": return 11
    if c == "c": return 12
    if c == "d": return 13
    if c == "e": return 14
    if c == "f": return 15
    if c == "A": return 10
    if c == "B": return 11
    if c == "C": return 12
    if c == "D": return 13
    if c == "E": return 14
    if c == "F": return 15
    0

# ============================================================================
# BINARY ENCODING
# ============================================================================

# Encode data as binary string (8 bits per byte)
fn encode_binary(bytes: list) -> text:
    var result = ""
    var i = 0
    var len = list_length(bytes)

    while i < len:
        var byte_val = list_get(bytes, i)
        var bits = byte_to_bits(byte_val)
        if i > 0:
            result = text_concat(result, " ")
        result = text_concat(result, bits)
        i = i + 1

    result

# Decode binary string to bytes
fn decode_binary(encoded: text) -> list:
    var clean = strip_whitespace(encoded)
    var result = []
    var i = 0
    var len = text_length(clean)

    while i < len:
        var bits = text_substring(clean, i, i + 8)
        var byte_val = bits_to_byte(bits)
        result = list_append(result, byte_val)
        i = i + 8

    result

# ============================================================================
# CHUNKED/MULTILINE ENCODING
# ============================================================================

# Encode data with line breaks at specified length
fn encode_chunked(data: text, line_length: i64) -> text:
    var encoded = encode_base64(data)
    encode_multiline(encoded, line_length)

# Decode chunked encoded data
fn decode_chunked(encoded: text) -> text:
    var clean = strip_whitespace(encoded)
    decode_base64(clean)

# Wrap encoded data at specified width
fn encode_multiline(encoded: text, width: i64) -> text:
    var result = ""
    var i = 0
    var len = text_length(encoded)

    while i < len:
        var end = i + width
        if end > len:
            end = len
        var chunk = text_substring(encoded, i, end)
        result = text_concat(result, chunk)
        if end < len:
            result = text_concat(result, "\n")
        i = end

    result

# Strip whitespace from encoded data
fn strip_whitespace(encoded: text) -> text:
    var result = ""
    var i = 0
    var len = text_length(encoded)

    while i < len:
        var c = text_char_at(encoded, i)
        var is_ws = is_whitespace_char(c)
        if not is_ws:
            result = text_concat(result, c)
        i = i + 1

    result

# ============================================================================
# INTEGER ENCODING
# ============================================================================

# Encode integer as Base64
fn encode_int(n: i64) -> text:
    var text_repr = int_to_text(n)
    encode_base64(text_repr)

# Decode Base64 to integer
fn decode_to_int(encoded: text) -> i64:
    var decoded = decode_base64(encoded)
    text_to_int(decoded)

# Convert integer to text
fn int_to_text(n: i64) -> text:
    if n == 0: return "0"
    var result = ""
    var value = n
    var is_negative = false
    if value < 0:
        is_negative = true
        value = 0 - value
    while value > 0:
        var digit = value % 10
        var digit_char = char_from_code(48 + digit)
        result = text_concat(digit_char, result)
        value = value / 10
    if is_negative:
        result = text_concat("-", result)
    result

# Convert text to integer
fn text_to_int(s: text) -> i64:
    var result = 0
    var i = 0
    var len = text_length(s)
    var is_negative = false

    if len > 0:
        var first = text_char_at(s, 0)
        if first == "-":
            is_negative = true
            i = 1

    while i < len:
        var c = text_char_at(s, i)
        var code = char_code(c)
        var digit = code - 48
        result = (result * 10) + digit
        i = i + 1

    if is_negative:
        result = 0 - result
    result

# ============================================================================
# STREAMING OPERATIONS
# ============================================================================

# Encode data in streaming chunks
fn encode_stream(data: text, chunk_size: i64) -> list:
    var result = []
    var i = 0
    var len = text_length(data)

    while i < len:
        var end = i + chunk_size
        if end > len:
            end = len
        var chunk = text_substring(data, i, end)
        var encoded = encode_base64(chunk)
        result = list_append(result, encoded)
        i = end

    result

# Decode streaming chunks
fn decode_stream(encoded_chunks: list, chunk_size: i64) -> text:
    var result = ""
    var i = 0
    var len = list_length(encoded_chunks)

    while i < len:
        var chunk = list_get(encoded_chunks, i)
        # Note: In real implementation, chunk would be text
        # Here we're treating it as encoded already
        var decoded = ""  # Would decode chunk
        result = text_concat(result, decoded)
        i = i + 1

    result

# ============================================================================
# CUSTOM ALPHABET UTILITIES
# ============================================================================

# Create custom alphabet from characters
fn create_alphabet(chars: text) -> text:
    var len = text_length(chars)
    if len != 64:
        # Invalid alphabet length
        return ""
    # Validate all characters are unique
    var i = 0
    while i < len:
        var c1 = text_char_at(chars, i)
        var j = i + 1
        while j < len:
            var c2 = text_char_at(chars, j)
            if c1 == c2:
                # Duplicate character
                return ""
            j = j + 1
        i = i + 1
    chars

# Encode with custom alphabet
fn encode_with_alphabet(data: text, alphabet: text) -> text:
    var alphabet_len = text_length(alphabet)
    if alphabet_len != 64:
        return ""
    encode_base64_with_alphabet(data, alphabet, true)

# Decode with custom alphabet
fn decode_with_alphabet(encoded: text, alphabet: text) -> text:
    var alphabet_len = text_length(alphabet)
    if alphabet_len != 64:
        return ""
    decode_base64_with_alphabet(encoded, alphabet)

# ============================================================================
# SECURITY UTILITIES
# ============================================================================

# Constant-time string comparison (prevents timing attacks)
fn compare_constant_time(s1: text, s2: text) -> bool:
    var len1 = text_length(s1)
    var len2 = text_length(s2)
    var result = 0

    # Always compare full length to avoid timing leaks
    var max_len = len1
    if len2 > max_len:
        max_len = len2

    # Length difference contributes to result
    if len1 != len2:
        result = result + 1

    var i = 0
    while i < max_len:
        var c1 = ""
        var c2 = ""
        if i < len1:
            c1 = text_char_at(s1, i)
        if i < len2:
            c2 = text_char_at(s2, i)
        if c1 != c2:
            result = result + 1
        i = i + 1

    result == 0

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Get Base64 alphabet
fn get_base64_alphabet() -> text:
    BASE64_ALPHABET

# Get URL-safe Base64 alphabet
fn get_base64_url_alphabet() -> text:
    BASE64_URL_ALPHABET

# Get Base32 alphabet
fn get_base32_alphabet() -> text:
    BASE32_ALPHABET

# Get Base32 hex alphabet
fn get_base32_hex_alphabet() -> text:
    BASE32_HEX_ALPHABET

# Get lowercase hex alphabet
fn get_hex_alphabet_lower() -> text:
    HEX_ALPHABET_LOWER

# Get uppercase hex alphabet
fn get_hex_alphabet_upper() -> text:
    HEX_ALPHABET_UPPER
