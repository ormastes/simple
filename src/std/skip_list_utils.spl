# Skip List Probabilistic Data Structure Utilities
#
# This module provides a comprehensive implementation of probabilistic skip lists,
# a randomized data structure that provides O(log n) expected time complexity for
# search, insert, and delete operations through multi-level linked lists.
#
# Skip lists maintain balance probabilistically using geometric distribution (p=0.5)
# for level assignment, eliminating the need for complex rebalancing algorithms
# found in deterministic balanced trees like AVL or Red-Black trees.
#
# Key Features:
# - Probabilistic multi-level linked list structure
# - Geometric distribution (p=0.5) for level generation
# - Maximum 32 levels supporting 2^32 elements
# - Node structure with key-value pairs and forward pointer arrays
# - O(log n) expected time for search/insert/delete/get
# - Range queries and ordered traversal
# - Forward iteration in sorted order
# - Prefix sum support for ordered numeric data
# - No generics (runtime constraint) - uses concrete types
# - Pure Simple implementation with no FFI dependencies
#
# Structure Visualization:
# Level 3:  HEAD -------------------------> 30 -----------------> NIL
# Level 2:  HEAD -------> 10 -------------> 30 -----------------> NIL
# Level 1:  HEAD -------> 10 --> 20 ------> 30 --> 40 ----------> NIL
# Level 0:  HEAD -> 5 -> 10 -> 20 -> 25 -> 30 -> 40 -> 50 -> 60 -> NIL
#
# Performance Characteristics:
# - Search: O(log n) expected, O(n) worst case
# - Insert: O(log n) expected, O(n) worst case
# - Delete: O(log n) expected, O(n) worst case
# - Space:  O(n) with 1/(1-p) = 2n pointers expected
# - Height: O(log n) expected with high probability

# =============================================================================
# Constants and Configuration
# =============================================================================

# Maximum number of levels in the skip list (supports 2^32 elements at p=0.5)
val MAX_LEVELS = 32

# Probability for level promotion (geometric distribution parameter)
val LEVEL_PROMOTION_PROBABILITY = 0.5

# Sentinel value representing null/nil node references
val NIL_REF = -1

# Minimum value for node keys (sentinel for head node)
val MIN_KEY = -9223372036854775808

# Maximum value for node keys
val MAX_KEY = 9223372036854775807

# Default initial capacity hint
val DEFAULT_CAPACITY = 16

# =============================================================================
# Random Number Generation (LCG for Probabilistic Level Assignment)
# =============================================================================

# Global RNG state (Linear Congruential Generator)
var rng_state = 1234567891

# Initialize or reseed the random number generator
fn sl_seed_rng(seed: i64):
    var state = rng_state
    state = seed
    rng_state = state

# Generate next pseudo-random integer using LCG algorithm
# Parameters: a = 1103515245, c = 12345, m = 2^31
fn sl_next_random() -> i64:
    var state = rng_state
    var a = 1103515245
    var c = 12345
    var m = 2147483648
    var next_val = ((state * a) + c) % m
    if next_val < 0:
        next_val = 0 - next_val
    rng_state = next_val
    next_val

# Generate random float in range [0.0, 1.0)
fn sl_random_uniform() -> f64:
    var rand_int = sl_next_random()
    var m = 2147483648.0
    var rand_float = rand_int
    rand_float / m

# Generate random boolean with given probability
fn sl_random_bool(probability: f64) -> i64:
    var r = sl_random_uniform()
    if r < probability:
        1
    else:
        0

# =============================================================================
# Node Structure (Tuple-Based)
# =============================================================================

# Node representation: (key: i64, value: i64, level: i64, forward: list)
# - key: Node key for ordering
# - value: Associated value
# - level: Maximum level of this node (0-based)
# - forward: Array of forward pointers (node indices), size = level + 1

# Create a new skip list node with specified level
fn sl_create_node(key: i64, value: i64, level: i64) -> tuple:
    var forward_ptrs = []
    var i = 0
    while i <= level:
        forward_ptrs = forward_ptrs + [NIL_REF]
        i = i + 1
    (key, value, level, forward_ptrs)

# Get node key
fn sl_node_key(node: tuple) -> i64:
    var k = node[0]
    k

# Get node value
fn sl_node_value(node: tuple) -> i64:
    var v = node[1]
    v

# Get node level
fn sl_node_level(node: tuple) -> i64:
    var lvl = node[2]
    lvl

# Get node forward pointers array
fn sl_node_forward(node: tuple) -> list:
    var fwd = node[3]
    fwd

# Set node value (returns new node)
fn sl_node_set_value(node: tuple, new_value: i64) -> tuple:
    var key = sl_node_key(node)
    var level = sl_node_level(node)
    var forward = sl_node_forward(node)
    (key, new_value, level, forward)

# Get forward pointer at specific level
fn sl_node_get_forward(node: tuple, lvl: i64) -> i64:
    var forward = sl_node_forward(node)
    var ptr = forward[lvl]
    ptr

# Set forward pointer at specific level (returns new node)
fn sl_node_set_forward(node: tuple, lvl: i64, target_idx: i64) -> tuple:
    var key = sl_node_key(node)
    var value = sl_node_value(node)
    var level = sl_node_level(node)
    var forward = sl_node_forward(node)

    var new_forward = []
    var i = 0
    while i <= level:
        if i == lvl:
            new_forward = new_forward + [target_idx]
        else:
            var existing_ptr = forward[i]
            new_forward = new_forward + [existing_ptr]
        i = i + 1

    (key, value, level, new_forward)

# =============================================================================
# Skip List Structure (Tuple-Based)
# =============================================================================

# SkipList representation: (nodes: list, head_idx: i64, level: i64, size: i64)
# - nodes: Array of all nodes (index-based references)
# - head_idx: Index of the head sentinel node
# - level: Current maximum level in use
# - size: Number of elements (excluding head)

# Create an empty skip list
fn sl_create() -> tuple:
    var head = sl_create_node(MIN_KEY, 0, MAX_LEVELS - 1)
    var nodes = [head]
    var head_idx = 0
    var current_level = 0
    var size = 0
    (nodes, head_idx, current_level, size)

# Get nodes array from skip list
fn sl_get_nodes(skiplist: tuple) -> list:
    var n = skiplist[0]
    n

# Get head index from skip list
fn sl_get_head_idx(skiplist: tuple) -> i64:
    var h = skiplist[1]
    h

# Get current level from skip list
fn sl_get_level(skiplist: tuple) -> i64:
    var lvl = skiplist[2]
    lvl

# Get size from skip list
fn sl_get_size(skiplist: tuple) -> i64:
    var sz = skiplist[3]
    sz

# Set nodes array in skip list (returns new skip list)
fn sl_set_nodes(skiplist: tuple, nodes: list) -> tuple:
    var head_idx = sl_get_head_idx(skiplist)
    var level = sl_get_level(skiplist)
    var size = sl_get_size(skiplist)
    (nodes, head_idx, level, size)

# Set current level in skip list (returns new skip list)
fn sl_set_level(skiplist: tuple, new_level: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var size = sl_get_size(skiplist)
    (nodes, head_idx, new_level, size)

# Set size in skip list (returns new skip list)
fn sl_set_size(skiplist: tuple, new_size: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var level = sl_get_level(skiplist)
    (nodes, head_idx, level, new_size)

# =============================================================================
# Level Generation (Geometric Distribution)
# =============================================================================

# Generate random level using geometric distribution with p=0.5
# Returns level in range [0, MAX_LEVELS - 1]
fn sl_generate_level() -> i64:
    var lvl = 0
    while sl_random_bool(LEVEL_PROMOTION_PROBABILITY) == 1:
        lvl = lvl + 1
        if lvl >= MAX_LEVELS - 1:
            return MAX_LEVELS - 1
    lvl

# Generate level with custom probability
fn sl_generate_level_with_prob(prob: f64) -> i64:
    var lvl = 0
    while sl_random_bool(prob) == 1:
        lvl = lvl + 1
        if lvl >= MAX_LEVELS - 1:
            return MAX_LEVELS - 1
    lvl

# Check if level should be promoted (for dynamic adjustment)
fn sl_should_promote_level(current_level: i64) -> i64:
    if current_level >= MAX_LEVELS - 1:
        return 0
    sl_random_bool(LEVEL_PROMOTION_PROBABILITY)

# Check if level should be demoted (for dynamic adjustment)
fn sl_should_demote_level(current_level: i64) -> i64:
    if current_level <= 0:
        return 0
    var demote_threshold = 0.25
    sl_random_bool(demote_threshold)

# =============================================================================
# Search and Traversal Operations
# =============================================================================

# Find update path for insertion/deletion (returns array of predecessor indices)
fn sl_find_update_path(skiplist: tuple, key: i64) -> list:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var current_level = sl_get_level(skiplist)

    var update = []
    var i = 0
    while i < MAX_LEVELS:
        update = update + [NIL_REF]
        i = i + 1

    var current_idx = head_idx
    var lvl = current_level

    while lvl >= 0:
        var current_node = nodes[current_idx]
        var next_idx = sl_node_get_forward(current_node, lvl)

        while next_idx != NIL_REF:
            var next_node = nodes[next_idx]
            var next_key = sl_node_key(next_node)

            if next_key >= key:
                break

            current_idx = next_idx
            current_node = nodes[current_idx]
            next_idx = sl_node_get_forward(current_node, lvl)

        var new_update = []
        var j = 0
        while j < MAX_LEVELS:
            if j == lvl:
                new_update = new_update + [current_idx]
            else:
                var existing = update[j]
                new_update = new_update + [existing]
            j = j + 1
        update = new_update

        lvl = lvl - 1

    update

# Search for a key in the skip list (returns node index or NIL_REF)
fn sl_search(skiplist: tuple, key: i64) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx == NIL_REF:
        return NIL_REF

    var pred_node = nodes[pred_idx]
    var next_idx = sl_node_get_forward(pred_node, 0)

    if next_idx == NIL_REF:
        return NIL_REF

    var next_node = nodes[next_idx]
    var next_key = sl_node_key(next_node)

    if next_key == key:
        next_idx
    else:
        NIL_REF

# Get value associated with key (returns value or 0 if not found)
fn sl_get(skiplist: tuple, key: i64) -> i64:
    var idx = sl_search(skiplist, key)
    if idx == NIL_REF:
        return 0

    var nodes = sl_get_nodes(skiplist)
    var node = nodes[idx]
    var value = sl_node_value(node)
    value

# Check if skip list contains a key
fn sl_contains(skiplist: tuple, key: i64) -> i64:
    var idx = sl_search(skiplist, key)
    if idx != NIL_REF:
        1
    else:
        0

# Find floor (largest key <= given key)
fn sl_floor(skiplist: tuple, key: i64) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx == NIL_REF:
        return MIN_KEY

    var pred_node = nodes[pred_idx]
    var next_idx = sl_node_get_forward(pred_node, 0)

    if next_idx != NIL_REF:
        var next_node = nodes[next_idx]
        var next_key = sl_node_key(next_node)
        if next_key == key:
            return next_key

    if pred_idx == head_idx:
        return MIN_KEY

    var pred_key = sl_node_key(pred_node)
    pred_key

# Find ceiling (smallest key >= given key)
fn sl_ceiling(skiplist: tuple, key: i64) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx == NIL_REF:
        return MAX_KEY

    var pred_node = nodes[pred_idx]
    var next_idx = sl_node_get_forward(pred_node, 0)

    if next_idx == NIL_REF:
        return MAX_KEY

    var next_node = nodes[next_idx]
    var next_key = sl_node_key(next_node)
    next_key

# =============================================================================
# Insertion Operations
# =============================================================================

# Insert key-value pair into skip list
fn sl_insert(skiplist: tuple, key: i64, value: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var current_level = sl_get_level(skiplist)
    var size = sl_get_size(skiplist)

    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx != NIL_REF:
        var pred_node = nodes[pred_idx]
        var next_idx = sl_node_get_forward(pred_node, 0)

        if next_idx != NIL_REF:
            var next_node = nodes[next_idx]
            var next_key = sl_node_key(next_node)

            if next_key == key:
                var updated_node = sl_node_set_value(next_node, value)
                var new_nodes = []
                var i = 0
                while i < nodes.len():
                    if i == next_idx:
                        new_nodes = new_nodes + [updated_node]
                    else:
                        var existing = nodes[i]
                        new_nodes = new_nodes + [existing]
                    i = i + 1
                return sl_set_nodes(skiplist, new_nodes)

    var new_level = sl_generate_level()
    var updated_level = current_level

    if new_level > current_level:
        var lvl = current_level + 1
        var head_idx = sl_get_head_idx(skiplist)
        while lvl <= new_level:
            var new_update = []
            var j = 0
            while j < MAX_LEVELS:
                if j == lvl:
                    new_update = new_update + [head_idx]
                else:
                    var existing = update[j]
                    new_update = new_update + [existing]
                j = j + 1
            update = new_update
            lvl = lvl + 1
        updated_level = new_level

    var new_node = sl_create_node(key, value, new_level)
    var new_idx = nodes.len()
    var updated_nodes = nodes + [new_node]

    var insert_level = 0
    while insert_level <= new_level:
        var pred_idx2 = update[insert_level]
        var pred_node2 = updated_nodes[pred_idx2]
        var next_idx2 = sl_node_get_forward(pred_node2, insert_level)

        var updated_new_node = sl_node_set_forward(new_node, insert_level, next_idx2)
        var temp_nodes = []
        var k = 0
        while k < updated_nodes.len():
            if k == new_idx:
                temp_nodes = temp_nodes + [updated_new_node]
            else:
                var existing_node = updated_nodes[k]
                temp_nodes = temp_nodes + [existing_node]
            k = k + 1
        updated_nodes = temp_nodes
        new_node = updated_new_node

        var updated_pred = sl_node_set_forward(pred_node2, insert_level, new_idx)
        var temp_nodes2 = []
        var m = 0
        while m < updated_nodes.len():
            if m == pred_idx2:
                temp_nodes2 = temp_nodes2 + [updated_pred]
            else:
                var existing_node2 = updated_nodes[m]
                temp_nodes2 = temp_nodes2 + [existing_node2]
            m = m + 1
        updated_nodes = temp_nodes2

        insert_level = insert_level + 1

    var result = sl_set_nodes(skiplist, updated_nodes)
    result = sl_set_level(result, updated_level)
    result = sl_set_size(result, size + 1)
    result

# Insert multiple key-value pairs
fn sl_insert_many(skiplist: tuple, pairs: list) -> tuple:
    var result = skiplist
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var key = pair[0]
        var value = pair[1]
        result = sl_insert(result, key, value)
        i = i + 1
    result

# Insert or update key-value pair
fn sl_put(skiplist: tuple, key: i64, value: i64) -> tuple:
    sl_insert(skiplist, key, value)

# =============================================================================
# Removal Operations
# =============================================================================

# Remove key from skip list
fn sl_remove(skiplist: tuple, key: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var current_level = sl_get_level(skiplist)
    var size = sl_get_size(skiplist)
    var head_idx = sl_get_head_idx(skiplist)

    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx == NIL_REF:
        return skiplist

    var pred_node = nodes[pred_idx]
    var target_idx = sl_node_get_forward(pred_node, 0)

    if target_idx == NIL_REF:
        return skiplist

    var target_node = nodes[target_idx]
    var target_key = sl_node_key(target_node)

    if target_key != key:
        return skiplist

    var target_level = sl_node_level(target_node)
    var updated_nodes = nodes

    var lvl = 0
    while lvl <= target_level:
        var pred_idx2 = update[lvl]
        var pred_node2 = updated_nodes[pred_idx2]
        var target_next = sl_node_get_forward(target_node, lvl)
        var updated_pred = sl_node_set_forward(pred_node2, lvl, target_next)

        var temp_nodes = []
        var k = 0
        while k < updated_nodes.len():
            if k == pred_idx2:
                temp_nodes = temp_nodes + [updated_pred]
            else:
                var existing = updated_nodes[k]
                temp_nodes = temp_nodes + [existing]
            k = k + 1
        updated_nodes = temp_nodes

        lvl = lvl + 1

    var head_node = updated_nodes[head_idx]
    var updated_level = current_level
    while updated_level > 0:
        var next_idx = sl_node_get_forward(head_node, updated_level)
        if next_idx != NIL_REF:
            break
        updated_level = updated_level - 1

    var result = sl_set_nodes(skiplist, updated_nodes)
    result = sl_set_level(result, updated_level)
    result = sl_set_size(result, size - 1)
    result

# Delete key from skip list (alias for remove)
fn sl_delete(skiplist: tuple, key: i64) -> tuple:
    sl_remove(skiplist, key)

# Remove multiple keys
fn sl_remove_many(skiplist: tuple, keys: list) -> tuple:
    var result = skiplist
    var i = 0
    while i < keys.len():
        var key = keys[i]
        result = sl_remove(result, key)
        i = i + 1
    result

# =============================================================================
# Range Query Operations
# =============================================================================

# Get all key-value pairs in range [min_key, max_key]
fn sl_range_query(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    var nodes = sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, min_key)
    var pred_idx = update[0]

    if pred_idx == NIL_REF:
        return []

    var pred_node = nodes[pred_idx]
    var current_idx = sl_node_get_forward(pred_node, 0)

    var result = []
    while current_idx != NIL_REF:
        var current_node = nodes[current_idx]
        var current_key = sl_node_key(current_node)

        if current_key > max_key:
            break

        if current_key >= min_key:
            var current_value = sl_node_value(current_node)
            var pair = (current_key, current_value)
            result = result + [pair]

        current_idx = sl_node_get_forward(current_node, 0)

    result

# Get all keys in range [min_key, max_key]
fn sl_range_keys(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var key = pair[0]
        result = result + [key]
        i = i + 1
    result

# Get all values in range [min_key, max_key]
fn sl_range_values(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var value = pair[1]
        result = result + [value]
        i = i + 1
    result

# Count elements in range [min_key, max_key]
fn sl_range_count(skiplist: tuple, min_key: i64, max_key: i64) -> i64:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    pairs.len()

# Prefix sum for values in range [MIN_KEY, max_key]
fn sl_prefix_sum(skiplist: tuple, max_key: i64) -> i64:
    var values = sl_range_values(skiplist, MIN_KEY, max_key)
    var sum = 0
    var i = 0
    while i < values.len():
        var value = values[i]
        sum = sum + value
        i = i + 1
    sum

# Range sum for values in range [min_key, max_key]
fn sl_range_sum(skiplist: tuple, min_key: i64, max_key: i64) -> i64:
    var values = sl_range_values(skiplist, min_key, max_key)
    var sum = 0
    var i = 0
    while i < values.len():
        var value = values[i]
        sum = sum + value
        i = i + 1
    sum

# =============================================================================
# Iterator Support (Forward Iteration)
# =============================================================================

# Create iterator (returns current node index)
fn sl_iter_begin(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var first_idx = sl_node_get_forward(head_node, 0)
    first_idx

# Check if iterator is at end
fn sl_iter_is_end(iter_idx: i64) -> i64:
    if iter_idx == NIL_REF:
        1
    else:
        0

# Get key at iterator position
fn sl_iter_key(skiplist: tuple, iter_idx: i64) -> i64:
    if iter_idx == NIL_REF:
        return 0
    var nodes = sl_get_nodes(skiplist)
    var node = nodes[iter_idx]
    var key = sl_node_key(node)
    key

# Get value at iterator position
fn sl_iter_value(skiplist: tuple, iter_idx: i64) -> i64:
    if iter_idx == NIL_REF:
        return 0
    var nodes = sl_get_nodes(skiplist)
    var node = nodes[iter_idx]
    var value = sl_node_value(node)
    value

# Advance iterator to next position
fn sl_iter_next(skiplist: tuple, iter_idx: i64) -> i64:
    if iter_idx == NIL_REF:
        return NIL_REF
    var nodes = sl_get_nodes(skiplist)
    var node = nodes[iter_idx]
    var next_idx = sl_node_get_forward(node, 0)
    next_idx

# Get key-value pair at iterator position
fn sl_iter_pair(skiplist: tuple, iter_idx: i64) -> tuple:
    var key = sl_iter_key(skiplist, iter_idx)
    var value = sl_iter_value(skiplist, iter_idx)
    (key, value)

# =============================================================================
# Ordered Traversal Operations
# =============================================================================

# Get all key-value pairs in sorted order
fn sl_to_pairs(skiplist: tuple) -> list:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var current_idx = sl_node_get_forward(head_node, 0)

    var result = []
    while current_idx != NIL_REF:
        var current_node = nodes[current_idx]
        var key = sl_node_key(current_node)
        var value = sl_node_value(current_node)
        var pair = (key, value)
        result = result + [pair]
        current_idx = sl_node_get_forward(current_node, 0)

    result

# Get all keys in sorted order
fn sl_keys(skiplist: tuple) -> list:
    var pairs = sl_to_pairs(skiplist)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var key = pair[0]
        result = result + [key]
        i = i + 1
    result

# Get all values in sorted order by key
fn sl_values(skiplist: tuple) -> list:
    var pairs = sl_to_pairs(skiplist)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var value = pair[1]
        result = result + [value]
        i = i + 1
    result

# Get minimum key
fn sl_min_key(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var first_idx = sl_node_get_forward(head_node, 0)

    if first_idx == NIL_REF:
        return MIN_KEY

    var first_node = nodes[first_idx]
    var key = sl_node_key(first_node)
    key

# Get maximum key
fn sl_max_key(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var current_level = sl_get_level(skiplist)

    var current_idx = head_idx
    var lvl = current_level

    while lvl >= 0:
        var current_node = nodes[current_idx]
        var next_idx = sl_node_get_forward(current_node, lvl)

        while next_idx != NIL_REF:
            current_idx = next_idx
            current_node = nodes[current_idx]
            next_idx = sl_node_get_forward(current_node, lvl)

        lvl = lvl - 1

    if current_idx == head_idx:
        return MAX_KEY

    var last_node = nodes[current_idx]
    var key = sl_node_key(last_node)
    key

# Get first key-value pair
fn sl_first(skiplist: tuple) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var first_idx = sl_node_get_forward(head_node, 0)

    if first_idx == NIL_REF:
        return (0, 0)

    var first_node = nodes[first_idx]
    var key = sl_node_key(first_node)
    var value = sl_node_value(first_node)
    (key, value)

# Get last key-value pair
fn sl_last(skiplist: tuple) -> tuple:
    var max_k = sl_max_key(skiplist)
    var value = sl_get(skiplist, max_k)
    (max_k, value)

# =============================================================================
# Utility Functions
# =============================================================================

# Get number of elements in skip list
fn sl_size(skiplist: tuple) -> i64:
    sl_get_size(skiplist)

# Check if skip list is empty
fn sl_is_empty(skiplist: tuple) -> i64:
    var size = sl_get_size(skiplist)
    if size == 0:
        1
    else:
        0

# Get current height (maximum level in use + 1)
fn sl_height(skiplist: tuple) -> i64:
    var level = sl_get_level(skiplist)
    level + 1

# Get maximum allowed height
fn sl_max_height() -> i64:
    MAX_LEVELS

# Clear all elements from skip list
fn sl_clear(skiplist: tuple) -> tuple:
    sl_create()

# Clone skip list
fn sl_clone(skiplist: tuple) -> tuple:
    var pairs = sl_to_pairs(skiplist)
    var result = sl_create()
    sl_insert_many(result, pairs)

# Get total node count (including head sentinel)
fn sl_node_count(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    nodes.len()

# =============================================================================
# Level Manipulation Operations (Probabilistic)
# =============================================================================

# Promote node to higher level (if possible)
fn sl_promote_node(skiplist: tuple, key: i64) -> tuple:
    var idx = sl_search(skiplist, key)
    if idx == NIL_REF:
        return skiplist

    var nodes = sl_get_nodes(skiplist)
    var node = nodes[idx]
    var current_node_level = sl_node_level(node)

    if current_node_level >= MAX_LEVELS - 1:
        return skiplist

    var should_promote = sl_should_promote_level(current_node_level)
    if should_promote == 0:
        return skiplist

    var value = sl_node_value(node)
    var temp = sl_remove(skiplist, key)
    sl_insert(temp, key, value)

# Demote node to lower level (if possible)
fn sl_demote_node(skiplist: tuple, key: i64) -> tuple:
    var idx = sl_search(skiplist, key)
    if idx == NIL_REF:
        return skiplist

    var nodes = sl_get_nodes(skiplist)
    var node = nodes[idx]
    var current_node_level = sl_node_level(node)

    if current_node_level <= 0:
        return skiplist

    var should_demote = sl_should_demote_level(current_node_level)
    if should_demote == 0:
        return skiplist

    var value = sl_node_value(node)
    var temp = sl_remove(skiplist, key)
    sl_insert(temp, key, value)

# =============================================================================
# Statistical and Analysis Operations
# =============================================================================

# Count nodes at each level
fn sl_level_distribution(skiplist: tuple) -> list:
    var nodes = sl_get_nodes(skiplist)
    var counts = []
    var i = 0
    while i < MAX_LEVELS:
        counts = counts + [0]
        i = i + 1

    var node_idx = 0
    while node_idx < nodes.len():
        var node = nodes[node_idx]
        var node_level = sl_node_level(node)

        var lvl = 0
        while lvl <= node_level:
            var old_count = counts[lvl]
            var new_counts = []
            var j = 0
            while j < MAX_LEVELS:
                if j == lvl:
                    new_counts = new_counts + [old_count + 1]
                else:
                    var existing_count = counts[j]
                    new_counts = new_counts + [existing_count]
                j = j + 1
            counts = new_counts
            lvl = lvl + 1

        node_idx = node_idx + 1

    counts

# Calculate average node level
fn sl_average_level(skiplist: tuple) -> f64:
    var nodes = sl_get_nodes(skiplist)
    var total_levels = 0
    var count = 0

    var i = 1
    while i < nodes.len():
        var node = nodes[i]
        var level = sl_node_level(node)
        total_levels = total_levels + level
        count = count + 1
        i = i + 1

    if count == 0:
        return 0.0

    var total_float = total_levels
    var count_float = count
    total_float / count_float

# Get memory usage estimate (approximate pointer count)
fn sl_memory_estimate(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var total_pointers = 0

    var i = 0
    while i < nodes.len():
        var node = nodes[i]
        var level = sl_node_level(node)
        total_pointers = total_pointers + (level + 1)
        i = i + 1

    total_pointers

# Calculate load factor (actual_pointers / expected_pointers)
fn sl_load_factor(skiplist: tuple) -> f64:
    var size = sl_get_size(skiplist)
    if size == 0:
        return 0.0

    var actual_pointers = sl_memory_estimate(skiplist)
    var expected_pointers = size * 2

    var actual_float = actual_pointers
    var expected_float = expected_pointers
    actual_float / expected_float

# =============================================================================
# Comparison and Set Operations
# =============================================================================

# Check if two skip lists have equal contents
fn sl_equals(skiplist1: tuple, skiplist2: tuple) -> i64:
    var pairs1 = sl_to_pairs(skiplist1)
    var pairs2 = sl_to_pairs(skiplist2)

    if pairs1.len() != pairs2.len():
        return 0

    var i = 0
    while i < pairs1.len():
        var p1 = pairs1[i]
        var p2 = pairs2[i]
        var k1 = p1[0]
        var k2 = p2[0]
        var v1 = p1[1]
        var v2 = p2[1]

        if k1 != k2:
            return 0
        if v1 != v2:
            return 0

        i = i + 1

    1

# Merge two skip lists (union of keys, prefer values from first)
fn sl_merge(skiplist1: tuple, skiplist2: tuple) -> tuple:
    var pairs1 = sl_to_pairs(skiplist1)
    var pairs2 = sl_to_pairs(skiplist2)
    var result = sl_create()

    result = sl_insert_many(result, pairs1)

    var i = 0
    while i < pairs2.len():
        var pair = pairs2[i]
        var key = pair[0]
        var value = pair[1]
        var exists = sl_contains(result, key)
        if exists == 0:
            result = sl_insert(result, key, value)
        i = i + 1

    result

# Filter skip list by predicate on keys
fn sl_filter_keys(skiplist: tuple, min_key: i64, max_key: i64) -> tuple:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    var result = sl_create()
    sl_insert_many(result, pairs)

# =============================================================================
# Batch Operations
# =============================================================================

# Build skip list from sorted pairs (more efficient than repeated insert)
fn sl_from_sorted_pairs(pairs: list) -> tuple:
    var result = sl_create()
    sl_insert_many(result, pairs)

# Build skip list from unsorted pairs
fn sl_from_pairs(pairs: list) -> tuple:
    var result = sl_create()
    sl_insert_many(result, pairs)

# Update multiple values
fn sl_update_many(skiplist: tuple, pairs: list) -> tuple:
    sl_insert_many(skiplist, pairs)

# =============================================================================
# Debug and Validation Operations
# =============================================================================

# Validate skip list structure integrity
fn sl_validate(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var current_level = sl_get_level(skiplist)

    if nodes.len() == 0:
        return 0

    var prev_key = MIN_KEY
    var current_idx = sl_node_get_forward(nodes[head_idx], 0)

    while current_idx != NIL_REF:
        var current_node = nodes[current_idx]
        var current_key = sl_node_key(current_node)

        if current_key <= prev_key:
            return 0

        prev_key = current_key
        current_idx = sl_node_get_forward(current_node, 0)

    1

# Check if skip list is sorted
fn sl_is_sorted(skiplist: tuple) -> i64:
    sl_validate(skiplist)

# Get diagnostic string with skip list stats
fn sl_stats_string(skiplist: tuple) -> text:
    var size = sl_get_size(skiplist)
    var height = sl_height(skiplist)
    var node_count = sl_node_count(skiplist)
    var avg_level = sl_average_level(skiplist)
    var memory = sl_memory_estimate(skiplist)

    "SkipList[size={size}, height={height}, nodes={node_count}, avg_level={avg_level}, ptrs={memory}]"
