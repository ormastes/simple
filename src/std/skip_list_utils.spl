# Skip List Probabilistic Data Structure Utilities - Facade
#
# This module provides a comprehensive implementation of probabilistic skip lists,
# a randomized data structure that provides O(log n) expected time complexity for
# search, insert, and delete operations through multi-level linked lists.
#
# Skip lists maintain balance probabilistically using geometric distribution (p=0.5)
# for level assignment, eliminating the need for complex rebalancing algorithms
# found in deterministic balanced trees like AVL or Red-Black trees.
#
# Key Features:
# - Probabilistic multi-level linked list structure
# - Geometric distribution (p=0.5) for level generation
# - Maximum 32 levels supporting 2^32 elements
# - Node structure with key-value pairs and forward pointer arrays
# - O(log n) expected time for search/insert/delete/get
# - Range queries and ordered traversal
# - Forward iteration in sorted order
# - Prefix sum support for ordered numeric data
# - No generics (runtime constraint) - uses concrete types
# - Pure Simple implementation with no FFI dependencies
#
# Structure Visualization:
# Level 3:  HEAD -------------------------> 30 -----------------> NIL
# Level 2:  HEAD -------> 10 -------------> 30 -----------------> NIL
# Level 1:  HEAD -------> 10 --> 20 ------> 30 --> 40 ----------> NIL
# Level 0:  HEAD -> 5 -> 10 -> 20 -> 25 -> 30 -> 40 -> 50 -> 60 -> NIL
#
# Performance Characteristics:
# - Search: O(log n) expected, O(n) worst case
# - Insert: O(log n) expected, O(n) worst case
# - Delete: O(log n) expected, O(n) worst case
# - Space:  O(n) with 1/(1-p) = 2n pointers expected
# - Height: O(log n) expected with high probability

# Import all submodules
import skip_list.types
import skip_list.create
import skip_list.search
import skip_list.insert
import skip_list.delete
import skip_list.traverse
import skip_list.utilities

# Re-export constants from types
val MAX_LEVELS = types.MAX_LEVELS
val LEVEL_PROMOTION_PROBABILITY = types.LEVEL_PROMOTION_PROBABILITY
val NIL_REF = types.NIL_REF
val MIN_KEY = types.MIN_KEY
val MAX_KEY = types.MAX_KEY
val DEFAULT_CAPACITY = types.DEFAULT_CAPACITY

# Re-export RNG functions from types
fn sl_seed_rng(seed: i64):
    types.sl_seed_rng(seed)

fn sl_next_random() -> i64:
    types.sl_next_random()

fn sl_random_uniform() -> f64:
    types.sl_random_uniform()

fn sl_random_bool(probability: f64) -> i64:
    types.sl_random_bool(probability)

# Re-export node functions from types
fn sl_create_node(key: i64, value: i64, level: i64) -> tuple:
    types.sl_create_node(key, value, level)

fn sl_node_key(node: tuple) -> i64:
    types.sl_node_key(node)

fn sl_node_value(node: tuple) -> i64:
    types.sl_node_value(node)

fn sl_node_level(node: tuple) -> i64:
    types.sl_node_level(node)

fn sl_node_forward(node: tuple) -> list:
    types.sl_node_forward(node)

fn sl_node_set_value(node: tuple, new_value: i64) -> tuple:
    types.sl_node_set_value(node, new_value)

fn sl_node_get_forward(node: tuple, lvl: i64) -> i64:
    types.sl_node_get_forward(node, lvl)

fn sl_node_set_forward(node: tuple, lvl: i64, target_idx: i64) -> tuple:
    types.sl_node_set_forward(node, lvl, target_idx)

# Re-export structure functions from types
fn sl_get_nodes(skiplist: tuple) -> list:
    types.sl_get_nodes(skiplist)

fn sl_get_head_idx(skiplist: tuple) -> i64:
    types.sl_get_head_idx(skiplist)

fn sl_get_level(skiplist: tuple) -> i64:
    types.sl_get_level(skiplist)

fn sl_get_size(skiplist: tuple) -> i64:
    types.sl_get_size(skiplist)

fn sl_set_nodes(skiplist: tuple, nodes: list) -> tuple:
    types.sl_set_nodes(skiplist, nodes)

fn sl_set_level(skiplist: tuple, new_level: i64) -> tuple:
    types.sl_set_level(skiplist, new_level)

fn sl_set_size(skiplist: tuple, new_size: i64) -> tuple:
    types.sl_set_size(skiplist, new_size)

# Re-export level generation functions from types
fn sl_generate_level() -> i64:
    types.sl_generate_level()

fn sl_generate_level_with_prob(prob: f64) -> i64:
    types.sl_generate_level_with_prob(prob)

fn sl_should_promote_level(current_level: i64) -> i64:
    types.sl_should_promote_level(current_level)

fn sl_should_demote_level(current_level: i64) -> i64:
    types.sl_should_demote_level(current_level)

# Re-export create functions
fn sl_create() -> tuple:
    create.sl_create()

fn sl_from_sorted_pairs(pairs: list) -> tuple:
    create.sl_from_sorted_pairs(pairs)

fn sl_from_pairs(pairs: list) -> tuple:
    create.sl_from_pairs(pairs)

fn sl_clone(skiplist: tuple) -> tuple:
    create.sl_clone(skiplist)

# Re-export search functions
fn sl_find_update_path(skiplist: tuple, key: i64) -> list:
    search.sl_find_update_path(skiplist, key)

fn sl_search(skiplist: tuple, key: i64) -> i64:
    search.sl_search(skiplist, key)

fn sl_get(skiplist: tuple, key: i64) -> i64:
    search.sl_get(skiplist, key)

fn sl_contains(skiplist: tuple, key: i64) -> i64:
    search.sl_contains(skiplist, key)

fn sl_floor(skiplist: tuple, key: i64) -> i64:
    search.sl_floor(skiplist, key)

fn sl_ceiling(skiplist: tuple, key: i64) -> i64:
    search.sl_ceiling(skiplist, key)

fn sl_range_query(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    search.sl_range_query(skiplist, min_key, max_key)

fn sl_range_keys(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    search.sl_range_keys(skiplist, min_key, max_key)

fn sl_range_values(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    search.sl_range_values(skiplist, min_key, max_key)

fn sl_range_count(skiplist: tuple, min_key: i64, max_key: i64) -> i64:
    search.sl_range_count(skiplist, min_key, max_key)

fn sl_prefix_sum(skiplist: tuple, max_key: i64) -> i64:
    search.sl_prefix_sum(skiplist, max_key)

fn sl_range_sum(skiplist: tuple, min_key: i64, max_key: i64) -> i64:
    search.sl_range_sum(skiplist, min_key, max_key)

fn sl_filter_keys(skiplist: tuple, min_key: i64, max_key: i64) -> tuple:
    search.sl_filter_keys(skiplist, min_key, max_key)

# Re-export insert functions
fn sl_insert(skiplist: tuple, key: i64, value: i64) -> tuple:
    insert.sl_insert(skiplist, key, value)

fn sl_insert_many(skiplist: tuple, pairs: list) -> tuple:
    insert.sl_insert_many(skiplist, pairs)

fn sl_put(skiplist: tuple, key: i64, value: i64) -> tuple:
    insert.sl_put(skiplist, key, value)

fn sl_update_many(skiplist: tuple, pairs: list) -> tuple:
    insert.sl_update_many(skiplist, pairs)

# Re-export delete functions
fn sl_remove(skiplist: tuple, key: i64) -> tuple:
    delete.sl_remove(skiplist, key)

fn sl_delete(skiplist: tuple, key: i64) -> tuple:
    delete.sl_delete(skiplist, key)

fn sl_remove_many(skiplist: tuple, keys: list) -> tuple:
    delete.sl_remove_many(skiplist, keys)

# Re-export traverse functions
fn sl_iter_begin(skiplist: tuple) -> i64:
    traverse.sl_iter_begin(skiplist)

fn sl_iter_is_end(iter_idx: i64) -> i64:
    traverse.sl_iter_is_end(iter_idx)

fn sl_iter_key(skiplist: tuple, iter_idx: i64) -> i64:
    traverse.sl_iter_key(skiplist, iter_idx)

fn sl_iter_value(skiplist: tuple, iter_idx: i64) -> i64:
    traverse.sl_iter_value(skiplist, iter_idx)

fn sl_iter_next(skiplist: tuple, iter_idx: i64) -> i64:
    traverse.sl_iter_next(skiplist, iter_idx)

fn sl_iter_pair(skiplist: tuple, iter_idx: i64) -> tuple:
    traverse.sl_iter_pair(skiplist, iter_idx)

fn sl_to_pairs(skiplist: tuple) -> list:
    traverse.sl_to_pairs(skiplist)

fn sl_keys(skiplist: tuple) -> list:
    traverse.sl_keys(skiplist)

fn sl_values(skiplist: tuple) -> list:
    traverse.sl_values(skiplist)

fn sl_min_key(skiplist: tuple) -> i64:
    traverse.sl_min_key(skiplist)

fn sl_max_key(skiplist: tuple) -> i64:
    traverse.sl_max_key(skiplist)

fn sl_first(skiplist: tuple) -> tuple:
    traverse.sl_first(skiplist)

fn sl_last(skiplist: tuple) -> tuple:
    traverse.sl_last(skiplist)

# Re-export utility functions
fn sl_size(skiplist: tuple) -> i64:
    utilities.sl_size(skiplist)

fn sl_is_empty(skiplist: tuple) -> i64:
    utilities.sl_is_empty(skiplist)

fn sl_height(skiplist: tuple) -> i64:
    utilities.sl_height(skiplist)

fn sl_max_height() -> i64:
    utilities.sl_max_height()

fn sl_clear(skiplist: tuple) -> tuple:
    utilities.sl_clear(skiplist)

fn sl_node_count(skiplist: tuple) -> i64:
    utilities.sl_node_count(skiplist)

fn sl_promote_node(skiplist: tuple, key: i64) -> tuple:
    utilities.sl_promote_node(skiplist, key)

fn sl_demote_node(skiplist: tuple, key: i64) -> tuple:
    utilities.sl_demote_node(skiplist, key)

fn sl_level_distribution(skiplist: tuple) -> list:
    utilities.sl_level_distribution(skiplist)

fn sl_average_level(skiplist: tuple) -> f64:
    utilities.sl_average_level(skiplist)

fn sl_memory_estimate(skiplist: tuple) -> i64:
    utilities.sl_memory_estimate(skiplist)

fn sl_load_factor(skiplist: tuple) -> f64:
    utilities.sl_load_factor(skiplist)

fn sl_equals(skiplist1: tuple, skiplist2: tuple) -> i64:
    utilities.sl_equals(skiplist1, skiplist2)

fn sl_merge(skiplist1: tuple, skiplist2: tuple) -> tuple:
    utilities.sl_merge(skiplist1, skiplist2)

fn sl_validate(skiplist: tuple) -> i64:
    utilities.sl_validate(skiplist)

fn sl_is_sorted(skiplist: tuple) -> i64:
    utilities.sl_is_sorted(skiplist)

fn sl_stats_string(skiplist: tuple) -> text:
    utilities.sl_stats_string(skiplist)
