# XML Parser Module
# Provides tokenization and parsing functionality for XML documents

use std.string.{NL}

# =============================================================================
# Parsing - Tokenization
# =============================================================================

fn xml_tokenize(xml_str: text) -> list:
    # Tokenize XML string
    var tokens = []
    var i = 0
    val len = xml_str.len()
    var line = 1
    var col = 1

    while i < len:
        val ch = xml_str.slice(i, i + 1)

        if ch == "<":
            # Check for comment, CDATA, or processing instruction
            val remaining = xml_str.slice(i, len)

            if remaining.starts_with("<!--"):
                # Comment
                val end_pos = remaining.index("-->")
                var comment_end = 0
                if end_pos >= 0:
                    comment_end = i + end_pos + 3
                else:
                    comment_end = len

                val comment_text = xml_str.slice(i + 4, comment_end - 3)
                val token = ("comment", comment_text, line, col)
                tokens = tokens.append(token)
                i = comment_end
                col = col + (comment_end - i)
            elif remaining.starts_with("<![CDATA["):
                # CDATA
                val end_pos = remaining.index("]]>")
                var cdata_end = 0
                if end_pos >= 0:
                    cdata_end = i + end_pos + 3
                else:
                    cdata_end = len

                val cdata_text = xml_str.slice(i + 9, cdata_end - 3)
                val token = ("cdata", cdata_text, line, col)
                tokens = tokens.append(token)
                i = cdata_end
                col = col + (cdata_end - i)
            elif remaining.starts_with("<?"):
                # Processing instruction
                val end_pos = remaining.index("?>")
                var pi_end = 0
                if end_pos >= 0:
                    pi_end = i + end_pos + 2
                else:
                    pi_end = len

                val pi_text = xml_str.slice(i + 2, pi_end - 2)
                val token = ("pi", pi_text, line, col)
                tokens = tokens.append(token)
                i = pi_end
                col = col + (pi_end - i)
            elif remaining.starts_with("<!DOCTYPE"):
                # DOCTYPE
                val end_pos = remaining.index(">")
                var doctype_end = 0
                if end_pos >= 0:
                    doctype_end = i + end_pos + 1
                else:
                    doctype_end = len

                val doctype_text = xml_str.slice(i + 9, doctype_end - 1)
                val token = ("doctype", doctype_text, line, col)
                tokens = tokens.append(token)
                i = doctype_end
                col = col + (doctype_end - i)
            elif remaining.starts_with("</"):
                # Closing tag
                val end_pos = remaining.index(">")
                var tag_end = 0
                if end_pos >= 0:
                    tag_end = i + end_pos + 1
                else:
                    tag_end = len

                val tag_text = xml_str.slice(i + 2, tag_end - 1)
                val trimmed = tag_text.trim()
                val token = ("close_tag", trimmed, line, col)
                tokens = tokens.append(token)
                i = tag_end
                col = col + (tag_end - i)
            else:
                # Opening tag
                val end_pos = remaining.index(">")
                var tag_end = 0
                if end_pos >= 0:
                    tag_end = i + end_pos + 1
                else:
                    tag_end = len

                val tag_text = xml_str.slice(i + 1, tag_end - 1)
                val token = ("open_tag", tag_text, line, col)
                tokens = tokens.append(token)
                i = tag_end
                col = col + (tag_end - i)
        elif ch == NL:
            # Newline
            line = line + 1
            col = 1
            i = i + 1
        elif ch == " " or ch == "\t" or ch == "\r":
            # Whitespace
            col = col + 1
            i = i + 1
        else:
            # Text content
            var text_start = i
            var text_val = ""

            while i < len:
                val curr = xml_str.slice(i, i + 1)
                if curr == "<":
                    break
                text_val = text_val + curr
                if curr == NL:
                    line = line + 1
                    col = 1
                else:
                    col = col + 1
                i = i + 1

            val trimmed_text = text_val.trim()
            if trimmed_text.len() > 0:
                val token = ("text", trimmed_text, line, col)
                tokens = tokens.append(token)

    tokens

# =============================================================================
# Parsing - Tag and Attribute Parsing
# =============================================================================

fn xml_parse_tag(tag_text: text) -> tuple:
    # Parse tag text to extract name, attributes, and self-closing flag
    # Returns: (tag_name, attributes, is_self_closing)

    val trimmed = tag_text.trim()
    var is_self_closing = false
    var working_text = trimmed

    # Check for self-closing
    if trimmed.ends_with("/"):
        is_self_closing = true
        val new_len = trimmed.len() - 1
        working_text = trimmed.slice(0, new_len)
        working_text = working_text.trim()

    # Split by whitespace to separate tag name from attributes
    val parts = working_text.split(" ")
    var tag_name = ""
    if parts.len() > 0:
        tag_name = parts[0]

    # Parse attributes
    var attrs = []
    if parts.len() > 1:
        var i = 1
        val len = parts.len()
        var attr_text = ""

        while i < len:
            attr_text = attr_text + parts[i] + " "
            i = i + 1

        attrs = xml_parse_attributes(attr_text)

    (tag_name, attrs, is_self_closing)

fn xml_parse_attributes(attr_text: text) -> list:
    # Parse attribute string into list of (name, value) pairs
    var attrs = []
    val trimmed = attr_text.trim()

    if trimmed.len() == 0:
        return attrs

    var i = 0
    val len = trimmed.len()

    while i < len:
        # Skip whitespace
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            var is_space = false
            if ch == " " or ch == "\t" or ch == NL or ch == "\r":
                is_space = true
            if not is_space:
                break
            i = i + 1

        if i >= len:
            break

        # Read attribute name
        var name = ""
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            var should_break = false
            if ch == "=" or ch == " " or ch == "\t":
                should_break = true
            if should_break:
                break
            name = name + ch
            i = i + 1

        # Skip to equals sign
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            if ch == "=":
                i = i + 1
                break
            i = i + 1

        # Skip whitespace and find quote
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            var is_space = false
            if ch == " " or ch == "\t" or ch == NL or ch == "\r":
                is_space = true
            if not is_space:
                break
            i = i + 1

        # Read value
        var value = ""
        var quote_char = ""

        if i < len:
            val ch = trimmed.slice(i, i + 1)
            if ch == "\"" or ch == "'":
                quote_char = ch
                i = i + 1

        while i < len:
            val ch = trimmed.slice(i, i + 1)
            if quote_char.len() > 0:
                if ch == quote_char:
                    i = i + 1
                    break
            else:
                var is_space = false
                if ch == " " or ch == "\t" or ch == NL or ch == "\r":
                    is_space = true
                if is_space:
                    break

            value = value + ch
            i = i + 1

        if name.len() > 0:
            val decoded_value = xml_decode_attr_value(value)
            val attr = (name, decoded_value)
            attrs = attrs.append(attr)

    attrs

# =============================================================================
# Parsing - Element Parsing
# =============================================================================

fn xml_parse(xml_str: text) -> tuple:
    # Parse XML string to element
    val tokens = xml_tokenize(xml_str)
    val result = xml_parse_tokens(tokens, 0)
    result.0

fn xml_parse_tokens(tokens: list, start_index: i64) -> tuple:
    # Parse tokens starting at index, return (element, next_index)
    var i = start_index
    val len = tokens.len()

    # Skip non-tag tokens
    while i < len:
        val token = tokens[i]
        val token_type = token.0
        var is_open = false
        if token_type == "open_tag":
            is_open = true
        if is_open:
            break
        i = i + 1

    if i >= len:
        # No element found, return empty
        val empty_elem = xml_element_simple("")
        return (empty_elem, i)

    # Parse opening tag
    val open_token = tokens[i]
    val tag_text = open_token.1
    val tag_info = xml_parse_tag(tag_text)
    val tag_name = tag_info.0
    val attributes = tag_info.1
    val is_self_closing = tag_info.2

    i = i + 1

    if is_self_closing:
        val elem = xml_element(tag_name, attributes, [], "")
        return (elem, i)

    # Parse children and text
    var children = []
    var text_content = ""

    while i < len:
        val token = tokens[i]
        val token_type = token.0
        val token_value = token.1

        if token_type == "close_tag":
            # Found closing tag
            if token_value == tag_name:
                i = i + 1
                break
            i = i + 1
        elif token_type == "open_tag":
            # Parse child element
            val child_result = xml_parse_tokens(tokens, i)
            val child_elem = child_result.0
            val next_i = child_result.1
            children = children.append(child_elem)
            i = next_i
        elif token_type == "text":
            # Add text content
            text_content = text_content + token_value
            i = i + 1
        elif token_type == "cdata":
            # Add CDATA content
            text_content = text_content + token_value
            i = i + 1
        else:
            # Skip other token types
            i = i + 1

    val elem = xml_element(tag_name, attributes, children, text_content)
    (elem, i)

# =============================================================================
# Helper Functions (imported from utilities)
# =============================================================================

fn xml_element_simple(tag: text) -> tuple:
    val empty_attrs = []
    val empty_children = []
    xml_element(tag, empty_attrs, empty_children, "")

fn xml_element(tag: text, attributes: list, children: list, text_content: text) -> tuple:
    (tag, attributes, children, text_content)

fn xml_decode_attr_value(text_val: text) -> text:
    # Decode attribute value
    xml_decode_entities(text_val)

fn xml_decode_entities(text_val: text) -> text:
    # Decode XML entities
    var result = text_val
    result = result.replace("&lt;", "<")
    result = result.replace("&gt;", ">")
    result = result.replace("&quot;", "\"")
    result = result.replace("&apos;", "'")
    result = result.replace("&amp;", "&")
    result
