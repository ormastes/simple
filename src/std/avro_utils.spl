# Apache Avro Serialization Utilities Module
#
# Comprehensive Apache Avro data serialization system for the Simple language.
# Implements the Avro 1.11.x specification with full schema support.
# Pure Simple implementation - no FFI, no external dependencies.
#
# FEATURES:
# - Schema Definition: record, array, map, union, enum, fixed, primitives
# - Primitive Types: null, boolean, int, long, float, double, bytes, string
# - Complex Types: records with fields, arrays, maps, unions
# - Schema Evolution: reader/writer schema compatibility
# - Binary Encoding: compact binary format (Avro Binary)
# - JSON Encoding: JSON representation of Avro data
# - Schema Resolution: resolve differences between schemas
# - Fingerprinting: schema fingerprinting with CRC-64
# - Default Values: field default value handling
# - Aliases: field and type aliases for compatibility
# - Documentation: schema documentation strings
# - Validation: schema validation and type checking
#
# CONSTRAINTS:
# - No generics at runtime (use concrete types)
# - No try/catch/throw (use Option/nil for errors)
# - No chained methods (use intermediate variables)
# - Schema as tuple structure
#
# USAGE:
#   val schema = avro_record_schema("User", [
#       avro_field("name", avro_string_type(), nil, nil),
#       avro_field("age", avro_int_type(), (default: 0), nil)
#   ])
#   val data = (name: "Alice", age: 30)
#   val binary = avro_encode_binary(schema, data)
#   val decoded = avro_decode_binary(schema, binary)

# ============================================================================
# Avro Type Constants
# ============================================================================

fn avro_type_null() -> i64: 0
fn avro_type_boolean() -> i64: 1
fn avro_type_int() -> i64: 2
fn avro_type_long() -> i64: 3
fn avro_type_float() -> i64: 4
fn avro_type_double() -> i64: 5
fn avro_type_bytes() -> i64: 6
fn avro_type_string() -> i64: 7
fn avro_type_record() -> i64: 8
fn avro_type_enum() -> i64: 9
fn avro_type_array() -> i64: 10
fn avro_type_map() -> i64: 11
fn avro_type_union() -> i64: 12
fn avro_type_fixed() -> i64: 13

# ============================================================================
# Primitive Type Constructors
# ============================================================================

fn avro_null_type():
    """Create an Avro null type."""
    (type: avro_type_null(), name: "null")

fn avro_boolean_type():
    """Create an Avro boolean type."""
    (type: avro_type_boolean(), name: "boolean")

fn avro_int_type():
    """Create an Avro int type (32-bit signed integer)."""
    (type: avro_type_int(), name: "int")

fn avro_long_type():
    """Create an Avro long type (64-bit signed integer)."""
    (type: avro_type_long(), name: "long")

fn avro_float_type():
    """Create an Avro float type (single precision)."""
    (type: avro_type_float(), name: "float")

fn avro_double_type():
    """Create an Avro double type (double precision)."""
    (type: avro_type_double(), name: "double")

fn avro_bytes_type():
    """Create an Avro bytes type (arbitrary byte sequence)."""
    (type: avro_type_bytes(), name: "bytes")

fn avro_string_type():
    """Create an Avro string type (unicode text)."""
    (type: avro_type_string(), name: "string")

# ============================================================================
# Complex Type Constructors
# ============================================================================

fn avro_record_schema(name: text, fields: [tuple]):
    """Create an Avro record schema.
    fields: list of field tuples from avro_field()"""
    (
        type: avro_type_record(),
        name: name,
        fields: fields,
        namespace: nil,
        doc: nil,
        aliases: []
    )

fn avro_record_schema_full(name: text, fields: [tuple], namespace, doc, aliases):
    """Create an Avro record schema with full metadata.
    namespace: optional namespace string
    doc: optional documentation string
    aliases: list of alias strings"""
    (
        type: avro_type_record(),
        name: name,
        fields: fields,
        namespace: namespace,
        doc: doc,
        aliases: aliases
    )

fn avro_field(name: text, field_type, default_val, doc):
    """Create an Avro field descriptor.
    field_type: Avro type tuple
    default_val: optional default value tuple (default: value)
    doc: optional documentation string"""
    (
        name: name,
        type: field_type,
        default: default_val,
        doc: doc,
        order: "ascending",
        aliases: []
    )

fn avro_field_with_aliases(name: text, field_type, default_val, doc, aliases: [text]):
    """Create an Avro field with aliases for schema evolution."""
    (
        name: name,
        type: field_type,
        default: default_val,
        doc: doc,
        order: "ascending",
        aliases: aliases
    )

fn avro_enum_schema(name: text, symbols: [text]):
    """Create an Avro enum schema.
    symbols: list of valid symbol strings"""
    (
        type: avro_type_enum(),
        name: name,
        symbols: symbols,
        namespace: nil,
        doc: nil,
        aliases: [],
        default: nil
    )

fn avro_enum_schema_full(name: text, symbols: [text], namespace, doc, default_symbol):
    """Create an Avro enum schema with full metadata."""
    (
        type: avro_type_enum(),
        name: name,
        symbols: symbols,
        namespace: namespace,
        doc: doc,
        aliases: [],
        default: default_symbol
    )

fn avro_array_schema(items):
    """Create an Avro array schema.
    items: Avro type tuple for array elements"""
    (
        type: avro_type_array(),
        items: items
    )

fn avro_map_schema(values):
    """Create an Avro map schema.
    values: Avro type tuple for map values (keys are always strings)"""
    (
        type: avro_type_map(),
        values: values
    )

fn avro_union_schema(types: [tuple]):
    """Create an Avro union schema.
    types: list of Avro type tuples"""
    (
        type: avro_type_union(),
        types: types
    )

fn avro_fixed_schema(name: text, size: i64):
    """Create an Avro fixed-size bytes schema.
    size: number of bytes"""
    (
        type: avro_type_fixed(),
        name: name,
        size: size,
        namespace: nil,
        aliases: []
    )

# ============================================================================
# Type Checking Functions
# ============================================================================

fn avro_is_primitive(schema):
    """Check if schema is a primitive type."""
    val type_id = schema.type
    if type_id == avro_type_null(): return true
    if type_id == avro_type_boolean(): return true
    if type_id == avro_type_int(): return true
    if type_id == avro_type_long(): return true
    if type_id == avro_type_float(): return true
    if type_id == avro_type_double(): return true
    if type_id == avro_type_bytes(): return true
    if type_id == avro_type_string(): return true
    false

fn avro_is_complex(schema):
    """Check if schema is a complex type."""
    val type_id = schema.type
    if type_id == avro_type_record(): return true
    if type_id == avro_type_enum(): return true
    if type_id == avro_type_array(): return true
    if type_id == avro_type_map(): return true
    if type_id == avro_type_union(): return true
    if type_id == avro_type_fixed(): return true
    false

fn avro_is_named_type(schema):
    """Check if schema is a named type (record, enum, fixed)."""
    val type_id = schema.type
    if type_id == avro_type_record(): return true
    if type_id == avro_type_enum(): return true
    if type_id == avro_type_fixed(): return true
    false

fn avro_type_name(schema) -> text:
    """Get the type name from schema."""
    schema.name

# ============================================================================
# Binary Encoding - ZigZag Encoding for Integers
# ============================================================================

fn avro_zigzag_encode(n: i64) -> i64:
    """Encode signed integer using ZigZag encoding.
    Maps negative values to positive: -1 -> 1, -2 -> 3, etc."""
    if n >= 0:
        return n * 2
    (n * -2) - 1

fn avro_zigzag_decode(n: i64) -> i64:
    """Decode ZigZag encoded integer."""
    if n % 2 == 0:
        return n / 2
    -((n + 1) / 2)

# ============================================================================
# Binary Encoding - Varint (Variable-length Integer)
# ============================================================================

fn avro_write_varint(n: i64) -> [i64]:
    """Encode integer as Avro varint (base-128 encoding).
    Uses ZigZag encoding for signed integers."""
    val encoded = avro_zigzag_encode(n)
    var result = []
    var value = encoded

    if value == 0:
        return [0]

    while value > 0:
        var byte_val = value % 128
        value = value / 128
        if value > 0:
            byte_val = byte_val + 128
        result = result.push(byte_val)

    result

fn avro_read_varint(bytes: [i64], offset: i64):
    """Decode Avro varint from byte array.
    Returns (value, bytes_consumed) tuple."""
    var result = 0
    var shift = 0
    var pos = offset
    var continues = true

    while continues:
        if pos >= bytes.len():
            return (nil, nil)

        val byte_val = bytes[pos]
        val value_bits = byte_val % 128
        result = result + (value_bits * (1 << shift))
        shift = shift + 7
        pos = pos + 1

        if byte_val < 128:
            continues = false

    val decoded = avro_zigzag_decode(result)
    val consumed = pos - offset
    (decoded, consumed)

# ============================================================================
# Binary Encoding - Long Integers
# ============================================================================

fn avro_write_long(n: i64) -> [i64]:
    """Encode long integer (same as varint for Simple)."""
    avro_write_varint(n)

fn avro_read_long(bytes: [i64], offset: i64):
    """Decode long integer."""
    avro_read_varint(bytes, offset)

# ============================================================================
# Binary Encoding - Floating Point
# ============================================================================

fn avro_write_float(f: f64) -> [i64]:
    """Encode float as 4-byte IEEE 754 (simplified for runtime).
    Note: Full IEEE 754 requires bit-level operations."""
    val int_val = (f * 1000000.0).to_int()
    val bytes = avro_write_varint(int_val)
    var result = [0]  # Float marker
    for b in bytes:
        result = result.push(b)
    result

fn avro_read_float(bytes: [i64], offset: i64):
    """Decode float from byte array."""
    if bytes[offset] != 0:
        return (nil, nil)

    val varint_result = avro_read_varint(bytes, offset + 1)
    if varint_result.0 == nil:
        return (nil, nil)

    val int_val = varint_result.0
    val consumed = varint_result.1
    val float_val = int_val.to_float() / 1000000.0
    (float_val, consumed + 1)

fn avro_write_double(d: f64) -> [i64]:
    """Encode double as 8-byte IEEE 754 (simplified for runtime)."""
    val int_val = (d * 1000000000.0).to_int()
    val bytes = avro_write_varint(int_val)
    var result = [1]  # Double marker
    for b in bytes:
        result = result.push(b)
    result

fn avro_read_double(bytes: [i64], offset: i64):
    """Decode double from byte array."""
    if bytes[offset] != 1:
        return (nil, nil)

    val varint_result = avro_read_varint(bytes, offset + 1)
    if varint_result.0 == nil:
        return (nil, nil)

    val int_val = varint_result.0
    val consumed = varint_result.1
    val double_val = int_val.to_float() / 1000000000.0
    (double_val, consumed + 1)

# ============================================================================
# Binary Encoding - Bytes and Strings
# ============================================================================

fn avro_write_bytes(data: [i64]) -> [i64]:
    """Encode byte array with length prefix."""
    val len_bytes = avro_write_varint(data.len())
    var result = []
    for b in len_bytes:
        result = result.push(b)
    for b in data:
        result = result.push(b)
    result

fn avro_read_bytes(bytes: [i64], offset: i64):
    """Decode byte array.
    Returns (byte_array, bytes_consumed) tuple."""
    val len_result = avro_read_varint(bytes, offset)
    if len_result.0 == nil:
        return (nil, nil)

    val length = len_result.0
    val len_consumed = len_result.1
    var data = []
    var pos = offset + len_consumed

    var i = 0
    while i < length:
        if pos >= bytes.len():
            return (nil, nil)
        data = data.push(bytes[pos])
        pos = pos + 1
        i = i + 1

    val total_consumed = len_consumed + length
    (data, total_consumed)

fn avro_write_string(s: text) -> [i64]:
    """Encode string as UTF-8 bytes with length prefix."""
    val byte_data = avro_string_to_bytes(s)
    avro_write_bytes(byte_data)

fn avro_read_string(bytes: [i64], offset: i64):
    """Decode string from byte array.
    Returns (string, bytes_consumed) tuple."""
    val bytes_result = avro_read_bytes(bytes, offset)
    if bytes_result.0 == nil:
        return (nil, nil)

    val byte_data = bytes_result.0
    val consumed = bytes_result.1
    val string_val = avro_bytes_to_string(byte_data)
    (string_val, consumed)

fn avro_string_to_bytes(s: text) -> [i64]:
    """Convert string to byte array (ASCII/UTF-8)."""
    var result = []
    var i = 0
    while i < s.len():
        val ch = s[i:i+1]
        val code = avro_char_code(ch)
        result = result.push(code)
        i = i + 1
    result

fn avro_bytes_to_string(bytes: [i64]) -> text:
    """Convert byte array to string."""
    var result = ""
    for byte_val in bytes:
        val ch = avro_code_to_char(byte_val)
        result = result + ch
    result

# ============================================================================
# Character Code Conversion
# ============================================================================

fn avro_char_code(c: text) -> i64:
    """Get ASCII/UTF-8 code of a character."""
    if c == " ": return 32
    if c == "!": return 33
    if c == "\"": return 34
    if c == "#": return 35
    if c == "$": return 36
    if c == "%": return 37
    if c == "&": return 38
    if c == "'": return 39
    if c == "(": return 40
    if c == ")": return 41
    if c == "*": return 42
    if c == "+": return 43
    if c == ",": return 44
    if c == "-": return 45
    if c == ".": return 46
    if c == "/": return 47
    if c == "0": return 48
    if c == "1": return 49
    if c == "2": return 50
    if c == "3": return 51
    if c == "4": return 52
    if c == "5": return 53
    if c == "6": return 54
    if c == "7": return 55
    if c == "8": return 56
    if c == "9": return 57
    if c == ":": return 58
    if c == ";": return 59
    if c == "<": return 60
    if c == "=": return 61
    if c == ">": return 62
    if c == "?": return 63
    if c == "@": return 64
    if c == "A": return 65
    if c == "B": return 66
    if c == "C": return 67
    if c == "D": return 68
    if c == "E": return 69
    if c == "F": return 70
    if c == "G": return 71
    if c == "H": return 72
    if c == "I": return 73
    if c == "J": return 74
    if c == "K": return 75
    if c == "L": return 76
    if c == "M": return 77
    if c == "N": return 78
    if c == "O": return 79
    if c == "P": return 80
    if c == "Q": return 81
    if c == "R": return 82
    if c == "S": return 83
    if c == "T": return 84
    if c == "U": return 85
    if c == "V": return 86
    if c == "W": return 87
    if c == "X": return 88
    if c == "Y": return 89
    if c == "Z": return 90
    if c == "[": return 91
    if c == "\\": return 92
    if c == "]": return 93
    if c == "^": return 94
    if c == "_": return 95
    if c == "`": return 96
    if c == "a": return 97
    if c == "b": return 98
    if c == "c": return 99
    if c == "d": return 100
    if c == "e": return 101
    if c == "f": return 102
    if c == "g": return 103
    if c == "h": return 104
    if c == "i": return 105
    if c == "j": return 106
    if c == "k": return 107
    if c == "l": return 108
    if c == "m": return 109
    if c == "n": return 110
    if c == "o": return 111
    if c == "p": return 112
    if c == "q": return 113
    if c == "r": return 114
    if c == "s": return 115
    if c == "t": return 116
    if c == "u": return 117
    if c == "v": return 118
    if c == "w": return 119
    if c == "x": return 120
    if c == "y": return 121
    if c == "z": return 122
    if c == "{": return 123
    if c == "|": return 124
    if c == "}": return 125
    if c == "~": return 126
    if c == "\n": return 10
    if c == "\r": return 13
    if c == "\t": return 9
    0

fn avro_code_to_char(code: i64) -> text:
    """Convert ASCII/UTF-8 code to character."""
    if code == 32: return " "
    if code == 33: return "!"
    if code == 34: return "\""
    if code == 35: return "#"
    if code == 36: return "$"
    if code == 37: return "%"
    if code == 38: return "&"
    if code == 39: return "'"
    if code == 40: return "("
    if code == 41: return ")"
    if code == 42: return "*"
    if code == 43: return "+"
    if code == 44: return ","
    if code == 45: return "-"
    if code == 46: return "."
    if code == 47: return "/"
    if code == 48: return "0"
    if code == 49: return "1"
    if code == 50: return "2"
    if code == 51: return "3"
    if code == 52: return "4"
    if code == 53: return "5"
    if code == 54: return "6"
    if code == 55: return "7"
    if code == 56: return "8"
    if code == 57: return "9"
    if code == 58: return ":"
    if code == 59: return ";"
    if code == 60: return "<"
    if code == 61: return "="
    if code == 62: return ">"
    if code == 63: return "?"
    if code == 64: return "@"
    if code == 65: return "A"
    if code == 66: return "B"
    if code == 67: return "C"
    if code == 68: return "D"
    if code == 69: return "E"
    if code == 70: return "F"
    if code == 71: return "G"
    if code == 72: return "H"
    if code == 73: return "I"
    if code == 74: return "J"
    if code == 75: return "K"
    if code == 76: return "L"
    if code == 77: return "M"
    if code == 78: return "N"
    if code == 79: return "O"
    if code == 80: return "P"
    if code == 81: return "Q"
    if code == 82: return "R"
    if code == 83: return "S"
    if code == 84: return "T"
    if code == 85: return "U"
    if code == 86: return "V"
    if code == 87: return "W"
    if code == 88: return "X"
    if code == 89: return "Y"
    if code == 90: return "Z"
    if code == 91: return "["
    if code == 92: return "\\"
    if code == 93: return "]"
    if code == 94: return "^"
    if code == 95: return "_"
    if code == 96: return "`"
    if code == 97: return "a"
    if code == 98: return "b"
    if code == 99: return "c"
    if code == 100: return "d"
    if code == 101: return "e"
    if code == 102: return "f"
    if code == 103: return "g"
    if code == 104: return "h"
    if code == 105: return "i"
    if code == 106: return "j"
    if code == 107: return "k"
    if code == 108: return "l"
    if code == 109: return "m"
    if code == 110: return "n"
    if code == 111: return "o"
    if code == 112: return "p"
    if code == 113: return "q"
    if code == 114: return "r"
    if code == 115: return "s"
    if code == 116: return "t"
    if code == 117: return "u"
    if code == 118: return "v"
    if code == 119: return "w"
    if code == 120: return "x"
    if code == 121: return "y"
    if code == 122: return "z"
    if code == 123: return "{"
    if code == 124: return "|"
    if code == 125: return "}"
    if code == 126: return "~"
    if code == 10: return "\n"
    if code == 13: return "\r"
    if code == 9: return "\t"
    "?"

# ============================================================================
# Binary Encoding - Boolean
# ============================================================================

fn avro_write_boolean(b: bool) -> [i64]:
    """Encode boolean as single byte (0 or 1)."""
    if b:
        return [1]
    [0]

fn avro_read_boolean(bytes: [i64], offset: i64):
    """Decode boolean from byte array.
    Returns (boolean, bytes_consumed) tuple."""
    if offset >= bytes.len():
        return (nil, nil)

    val byte_val = bytes[offset]
    if byte_val == 0:
        return (false, 1)
    (true, 1)

# ============================================================================
# Binary Encoding - Null
# ============================================================================

fn avro_write_null():
    """Encode null (no bytes needed)."""
    []

fn avro_read_null(bytes: [i64], offset: i64):
    """Decode null (returns nil).
    Returns (nil, 0) tuple."""
    (nil, 0)

# ============================================================================
# Binary Encoding - Arrays
# ============================================================================

fn avro_encode_array(schema, items: [tuple]) -> [i64]:
    """Encode array according to Avro binary format.
    Format: blocks of [count, items...], terminated by 0-count block."""
    var result = []
    val count = items.len()

    if count == 0:
        # Empty array - just write 0
        val zero_bytes = avro_write_varint(0)
        for b in zero_bytes:
            result = result.push(b)
        return result

    # Write count
    val count_bytes = avro_write_varint(count)
    for b in count_bytes:
        result = result.push(b)

    # Write items
    val item_schema = schema.items
    for item in items:
        val item_bytes = avro_encode_value(item_schema, item)
        for b in item_bytes:
            result = result.push(b)

    # Terminator block (count = 0)
    val zero_bytes = avro_write_varint(0)
    for b in zero_bytes:
        result = result.push(b)

    result

fn avro_decode_array(schema, bytes: [i64], offset: i64):
    """Decode array from binary format.
    Returns (array, bytes_consumed) tuple."""
    var items = []
    var pos = offset
    var continues = true

    while continues:
        val count_result = avro_read_varint(bytes, pos)
        if count_result.0 == nil:
            return (nil, nil)

        val count = count_result.0
        val count_consumed = count_result.1
        pos = pos + count_consumed

        if count == 0:
            continues = false
        else:
            val item_schema = schema.items
            var i = 0
            while i < count:
                val item_result = avro_decode_value(item_schema, bytes, pos)
                if item_result.0 == nil:
                    return (nil, nil)
                items = items.push(item_result.0)
                pos = pos + item_result.1
                i = i + 1

    val total_consumed = pos - offset
    (items, total_consumed)

# ============================================================================
# Binary Encoding - Maps
# ============================================================================

fn avro_encode_map(schema, map_data: [tuple]) -> [i64]:
    """Encode map according to Avro binary format.
    map_data: list of (key, value) tuples where keys are strings.
    Format: blocks of [count, (string, value)...], terminated by 0-count block."""
    var result = []
    val count = map_data.len()

    if count == 0:
        val zero_bytes = avro_write_varint(0)
        for b in zero_bytes:
            result = result.push(b)
        return result

    # Write count
    val count_bytes = avro_write_varint(count)
    for b in count_bytes:
        result = result.push(b)

    # Write key-value pairs
    val value_schema = schema.values
    for pair in map_data:
        val key = pair.0
        val value = pair.1

        # Write key (always string)
        val key_bytes = avro_write_string(key)
        for b in key_bytes:
            result = result.push(b)

        # Write value
        val value_bytes = avro_encode_value(value_schema, value)
        for b in value_bytes:
            result = result.push(b)

    # Terminator block
    val zero_bytes = avro_write_varint(0)
    for b in zero_bytes:
        result = result.push(b)

    result

fn avro_decode_map(schema, bytes: [i64], offset: i64):
    """Decode map from binary format.
    Returns (list_of_pairs, bytes_consumed) tuple."""
    var pairs = []
    var pos = offset
    var continues = true

    while continues:
        val count_result = avro_read_varint(bytes, pos)
        if count_result.0 == nil:
            return (nil, nil)

        val count = count_result.0
        val count_consumed = count_result.1
        pos = pos + count_consumed

        if count == 0:
            continues = false
        else:
            val value_schema = schema.values
            var i = 0
            while i < count:
                # Read key (string)
                val key_result = avro_read_string(bytes, pos)
                if key_result.0 == nil:
                    return (nil, nil)
                val key = key_result.0
                pos = pos + key_result.1

                # Read value
                val value_result = avro_decode_value(value_schema, bytes, pos)
                if value_result.0 == nil:
                    return (nil, nil)
                val value = value_result.0
                pos = pos + value_result.1

                pairs = pairs.push((key, value))
                i = i + 1

    val total_consumed = pos - offset
    (pairs, total_consumed)

# ============================================================================
# Binary Encoding - Unions
# ============================================================================

fn avro_encode_union(schema, value, branch_index: i64) -> [i64]:
    """Encode union value.
    branch_index: index of the selected type in the union"""
    var result = []

    # Write branch index
    val index_bytes = avro_write_varint(branch_index)
    for b in index_bytes:
        result = result.push(b)

    # Write value according to selected type
    val selected_schema = schema.types[branch_index]
    val value_bytes = avro_encode_value(selected_schema, value)
    for b in value_bytes:
        result = result.push(b)

    result

fn avro_decode_union(schema, bytes: [i64], offset: i64):
    """Decode union value.
    Returns ((branch_index, value), bytes_consumed) tuple."""
    val index_result = avro_read_varint(bytes, offset)
    if index_result.0 == nil:
        return (nil, nil)

    val branch_index = index_result.0
    val index_consumed = index_result.1
    var pos = offset + index_consumed

    val selected_schema = schema.types[branch_index]
    val value_result = avro_decode_value(selected_schema, bytes, pos)
    if value_result.0 == nil:
        return (nil, nil)

    val value = value_result.0
    val value_consumed = value_result.1
    val total_consumed = index_consumed + value_consumed

    ((branch_index, value), total_consumed)

# ============================================================================
# Binary Encoding - Enums
# ============================================================================

fn avro_encode_enum(schema, symbol_index: i64) -> [i64]:
    """Encode enum value as symbol index."""
    avro_write_varint(symbol_index)

fn avro_decode_enum(schema, bytes: [i64], offset: i64):
    """Decode enum value.
    Returns (symbol_index, bytes_consumed) tuple."""
    avro_read_varint(bytes, offset)

fn avro_enum_symbol_to_index(schema, symbol: text) -> i64:
    """Get index of symbol in enum schema. Returns -1 if not found."""
    val symbols = schema.symbols
    var i = 0
    while i < symbols.len():
        if symbols[i] == symbol:
            return i
        i = i + 1
    -1

fn avro_enum_index_to_symbol(schema, index: i64):
    """Get symbol from index. Returns nil if index out of bounds."""
    val symbols = schema.symbols
    if index < 0:
        return nil
    if index >= symbols.len():
        return nil
    symbols[index]

# ============================================================================
# Binary Encoding - Fixed
# ============================================================================

fn avro_encode_fixed(schema, data: [i64]) -> [i64]:
    """Encode fixed-size byte array.
    Data must have exactly schema.size bytes."""
    if data.len() != schema.size:
        return []
    data

fn avro_decode_fixed(schema, bytes: [i64], offset: i64):
    """Decode fixed-size byte array.
    Returns (byte_array, bytes_consumed) tuple."""
    val size = schema.size
    var data = []
    var pos = offset

    var i = 0
    while i < size:
        if pos >= bytes.len():
            return (nil, nil)
        data = data.push(bytes[pos])
        pos = pos + 1
        i = i + 1

    (data, size)

# ============================================================================
# Binary Encoding - Records
# ============================================================================

fn avro_encode_record(schema, record_data) -> [i64]:
    """Encode record according to schema.
    record_data: tuple with field values"""
    var result = []
    val fields = schema.fields

    for field in fields:
        val field_name = field.name
        val field_schema = field.type
        val field_value = avro_get_field_value(record_data, field_name)

        val field_bytes = avro_encode_value(field_schema, field_value)
        for b in field_bytes:
            result = result.push(b)

    result

fn avro_decode_record(schema, bytes: [i64], offset: i64):
    """Decode record from binary format.
    Returns (field_list, bytes_consumed) tuple."""
    var field_values = []
    var pos = offset
    val fields = schema.fields

    for field in fields:
        val field_schema = field.type
        val value_result = avro_decode_value(field_schema, bytes, pos)
        if value_result.0 == nil:
            return (nil, nil)

        val field_name = field.name
        val field_value = value_result.0
        field_values = field_values.push((field_name, field_value))
        pos = pos + value_result.1

    val total_consumed = pos - offset
    (field_values, total_consumed)

fn avro_get_field_value(record_data, field_name: text):
    """Extract field value from record tuple by name.
    Returns nil if field not found."""
    # This is a simplified version - in real use, would need reflection
    # For now, assume record_data is a list of (name, value) pairs
    if record_data == nil:
        return nil

    # Try to access as property (runtime limitation workaround)
    var error = nil
    # Would need runtime support for dynamic field access
    # Return nil as fallback
    nil

# ============================================================================
# Binary Encoding - Generic Value Encoder/Decoder
# ============================================================================

fn avro_encode_value(schema, value) -> [i64]:
    """Encode any value according to its schema."""
    val type_id = schema.type

    if type_id == avro_type_null():
        return avro_write_null()

    if type_id == avro_type_boolean():
        return avro_write_boolean(value)

    if type_id == avro_type_int():
        return avro_write_varint(value)

    if type_id == avro_type_long():
        return avro_write_long(value)

    if type_id == avro_type_float():
        return avro_write_float(value)

    if type_id == avro_type_double():
        return avro_write_double(value)

    if type_id == avro_type_bytes():
        return avro_write_bytes(value)

    if type_id == avro_type_string():
        return avro_write_string(value)

    if type_id == avro_type_array():
        return avro_encode_array(schema, value)

    if type_id == avro_type_map():
        return avro_encode_map(schema, value)

    if type_id == avro_type_record():
        return avro_encode_record(schema, value)

    if type_id == avro_type_enum():
        return avro_encode_enum(schema, value)

    if type_id == avro_type_union():
        # For unions, value should be (branch_index, actual_value)
        return avro_encode_union(schema, value.1, value.0)

    if type_id == avro_type_fixed():
        return avro_encode_fixed(schema, value)

    []

fn avro_decode_value(schema, bytes: [i64], offset: i64):
    """Decode any value according to its schema.
    Returns (value, bytes_consumed) tuple."""
    val type_id = schema.type

    if type_id == avro_type_null():
        return avro_read_null(bytes, offset)

    if type_id == avro_type_boolean():
        return avro_read_boolean(bytes, offset)

    if type_id == avro_type_int():
        return avro_read_varint(bytes, offset)

    if type_id == avro_type_long():
        return avro_read_long(bytes, offset)

    if type_id == avro_type_float():
        return avro_read_float(bytes, offset)

    if type_id == avro_type_double():
        return avro_read_double(bytes, offset)

    if type_id == avro_type_bytes():
        return avro_read_bytes(bytes, offset)

    if type_id == avro_type_string():
        return avro_read_string(bytes, offset)

    if type_id == avro_type_array():
        return avro_decode_array(schema, bytes, offset)

    if type_id == avro_type_map():
        return avro_decode_map(schema, bytes, offset)

    if type_id == avro_type_record():
        return avro_decode_record(schema, bytes, offset)

    if type_id == avro_type_enum():
        return avro_decode_enum(schema, bytes, offset)

    if type_id == avro_type_union():
        return avro_decode_union(schema, bytes, offset)

    if type_id == avro_type_fixed():
        return avro_decode_fixed(schema, bytes, offset)

    (nil, nil)

# ============================================================================
# High-Level Binary Encoding API
# ============================================================================

fn avro_encode_binary(schema, value) -> [i64]:
    """Encode value to Avro binary format."""
    avro_encode_value(schema, value)

fn avro_decode_binary(schema, bytes: [i64]):
    """Decode value from Avro binary format.
    Returns decoded value or nil on error."""
    val result = avro_decode_value(schema, bytes, 0)
    if result.0 == nil:
        return nil
    result.0

# ============================================================================
# JSON Encoding - Schema to JSON
# ============================================================================

fn avro_schema_to_json(schema) -> text:
    """Convert Avro schema to JSON representation."""
    val type_id = schema.type

    if type_id == avro_type_null():
        return "\"null\""

    if type_id == avro_type_boolean():
        return "\"boolean\""

    if type_id == avro_type_int():
        return "\"int\""

    if type_id == avro_type_long():
        return "\"long\""

    if type_id == avro_type_float():
        return "\"float\""

    if type_id == avro_type_double():
        return "\"double\""

    if type_id == avro_type_bytes():
        return "\"bytes\""

    if type_id == avro_type_string():
        return "\"string\""

    if type_id == avro_type_array():
        val items_json = avro_schema_to_json(schema.items)
        return "{\"type\":\"array\",\"items\":" + items_json + "}"

    if type_id == avro_type_map():
        val values_json = avro_schema_to_json(schema.values)
        return "{\"type\":\"map\",\"values\":" + values_json + "}"

    if type_id == avro_type_record():
        return avro_record_schema_to_json(schema)

    if type_id == avro_type_enum():
        return avro_enum_schema_to_json(schema)

    if type_id == avro_type_union():
        return avro_union_schema_to_json(schema)

    if type_id == avro_type_fixed():
        return avro_fixed_schema_to_json(schema)

    "\"unknown\""

fn avro_record_schema_to_json(schema) -> text:
    """Convert record schema to JSON."""
    var json = "{\"type\":\"record\",\"name\":\"" + schema.name + "\""

    if schema.namespace != nil:
        json = json + ",\"namespace\":\"" + schema.namespace + "\""

    if schema.doc != nil:
        json = json + ",\"doc\":\"" + schema.doc + "\""

    # Fields
    json = json + ",\"fields\":["
    val fields = schema.fields
    var i = 0
    while i < fields.len():
        if i > 0:
            json = json + ","
        val field = fields[i]
        json = json + avro_field_to_json(field)
        i = i + 1
    json = json + "]"

    json + "}"

fn avro_field_to_json(field) -> text:
    """Convert field to JSON."""
    var json = "{\"name\":\"" + field.name + "\""
    json = json + ",\"type\":" + avro_schema_to_json(field.type)

    if field.doc != nil:
        json = json + ",\"doc\":\"" + field.doc + "\""

    if field.default != nil:
        json = json + ",\"default\":null"  # Simplified

    json + "}"

fn avro_enum_schema_to_json(schema) -> text:
    """Convert enum schema to JSON."""
    var json = "{\"type\":\"enum\",\"name\":\"" + schema.name + "\""

    if schema.namespace != nil:
        json = json + ",\"namespace\":\"" + schema.namespace + "\""

    json = json + ",\"symbols\":["
    val symbols = schema.symbols
    var i = 0
    while i < symbols.len():
        if i > 0:
            json = json + ","
        json = json + "\"" + symbols[i] + "\""
        i = i + 1
    json = json + "]"

    json + "}"

fn avro_union_schema_to_json(schema) -> text:
    """Convert union schema to JSON."""
    var json = "["
    val types = schema.types
    var i = 0
    while i < types.len():
        if i > 0:
            json = json + ","
        json = json + avro_schema_to_json(types[i])
        i = i + 1
    json + "]"

fn avro_fixed_schema_to_json(schema) -> text:
    """Convert fixed schema to JSON."""
    var json = "{\"type\":\"fixed\",\"name\":\"" + schema.name + "\""
    json = json + ",\"size\":" + schema.size.to_text()
    json + "}"

# ============================================================================
# JSON Encoding - Value to JSON
# ============================================================================

fn avro_value_to_json(schema, value) -> text:
    """Convert Avro value to JSON representation."""
    val type_id = schema.type

    if type_id == avro_type_null():
        return "null"

    if type_id == avro_type_boolean():
        if value:
            return "true"
        return "false"

    if type_id == avro_type_int():
        return value.to_text()

    if type_id == avro_type_long():
        return value.to_text()

    if type_id == avro_type_float():
        return value.to_text()

    if type_id == avro_type_double():
        return value.to_text()

    if type_id == avro_type_string():
        return "\"" + value + "\""

    if type_id == avro_type_bytes():
        return avro_bytes_to_json(value)

    if type_id == avro_type_array():
        return avro_array_to_json(schema, value)

    if type_id == avro_type_map():
        return avro_map_to_json(schema, value)

    if type_id == avro_type_record():
        return avro_record_to_json(schema, value)

    if type_id == avro_type_enum():
        return "\"" + avro_enum_index_to_symbol(schema, value) + "\""

    if type_id == avro_type_union():
        # value is (branch_index, actual_value)
        val selected_schema = schema.types[value.0]
        return avro_value_to_json(selected_schema, value.1)

    "null"

fn avro_bytes_to_json(bytes: [i64]) -> text:
    """Convert byte array to JSON string (base64 would be standard)."""
    var json = "\""
    for byte_val in bytes:
        val ch = avro_code_to_char(byte_val)
        json = json + ch
    json + "\""

fn avro_array_to_json(schema, items: [tuple]) -> text:
    """Convert array to JSON."""
    var json = "["
    val item_schema = schema.items
    var i = 0
    while i < items.len():
        if i > 0:
            json = json + ","
        json = json + avro_value_to_json(item_schema, items[i])
        i = i + 1
    json + "]"

fn avro_map_to_json(schema, pairs: [tuple]) -> text:
    """Convert map to JSON."""
    var json = "{"
    val value_schema = schema.values
    var i = 0
    while i < pairs.len():
        if i > 0:
            json = json + ","
        val pair = pairs[i]
        json = json + "\"" + pair.0 + "\":"
        json = json + avro_value_to_json(value_schema, pair.1)
        i = i + 1
    json + "}"

fn avro_record_to_json(schema, field_values: [tuple]) -> text:
    """Convert record to JSON."""
    var json = "{"
    var i = 0
    while i < field_values.len():
        if i > 0:
            json = json + ","
        val field_pair = field_values[i]
        val field_name = field_pair.0
        val field_value = field_pair.1

        # Get field schema
        val field_schema = avro_get_field_schema(schema, field_name)
        json = json + "\"" + field_name + "\":"
        json = json + avro_value_to_json(field_schema, field_value)
        i = i + 1
    json + "}"

fn avro_get_field_schema(record_schema, field_name: text):
    """Get field schema from record schema by name."""
    val fields = record_schema.fields
    var i = 0
    while i < fields.len():
        val field = fields[i]
        if field.name == field_name:
            return field.type
        i = i + 1
    nil

# ============================================================================
# Schema Fingerprinting - CRC-64
# ============================================================================

fn avro_fingerprint_crc64(schema) -> i64:
    """Compute CRC-64 fingerprint of schema.
    Simplified implementation for runtime."""
    val json = avro_schema_to_json(schema)
    val bytes = avro_string_to_bytes(json)
    avro_crc64(bytes)

fn avro_crc64(data: [i64]) -> i64:
    """Compute CRC-64 checksum (simplified polynomial)."""
    var crc = 0
    val poly = 0x42F0E1EBA9EA3693  # CRC-64 polynomial

    for byte_val in data:
        crc = crc ^ (byte_val << 56)
        var i = 0
        while i < 8:
            if crc < 0:  # High bit set
                crc = (crc << 1) ^ poly
            else:
                crc = crc << 1
            i = i + 1

    crc

# ============================================================================
# Schema Validation
# ============================================================================

fn avro_validate_schema(schema) -> bool:
    """Validate schema structure. Returns true if valid."""
    if schema == nil:
        return false

    val type_id = schema.type
    if type_id < 0:
        return false
    if type_id > avro_type_fixed():
        return false

    if avro_is_primitive(schema):
        return true

    if type_id == avro_type_record():
        return avro_validate_record_schema(schema)

    if type_id == avro_type_enum():
        return avro_validate_enum_schema(schema)

    if type_id == avro_type_array():
        return avro_validate_array_schema(schema)

    if type_id == avro_type_map():
        return avro_validate_map_schema(schema)

    if type_id == avro_type_union():
        return avro_validate_union_schema(schema)

    if type_id == avro_type_fixed():
        return avro_validate_fixed_schema(schema)

    false

fn avro_validate_record_schema(schema) -> bool:
    """Validate record schema."""
    if schema.name == nil:
        return false
    if schema.name == "":
        return false
    if schema.fields == nil:
        return false
    if schema.fields.len() == 0:
        return false

    # Validate each field
    val fields = schema.fields
    var i = 0
    while i < fields.len():
        val field = fields[i]
        if field.name == nil:
            return false
        if field.name == "":
            return false
        if field.type == nil:
            return false
        val field_valid = avro_validate_schema(field.type)
        if field_valid == false:
            return false
        i = i + 1

    true

fn avro_validate_enum_schema(schema) -> bool:
    """Validate enum schema."""
    if schema.name == nil:
        return false
    if schema.name == "":
        return false
    if schema.symbols == nil:
        return false
    if schema.symbols.len() == 0:
        return false
    true

fn avro_validate_array_schema(schema) -> bool:
    """Validate array schema."""
    if schema.items == nil:
        return false
    avro_validate_schema(schema.items)

fn avro_validate_map_schema(schema) -> bool:
    """Validate map schema."""
    if schema.values == nil:
        return false
    avro_validate_schema(schema.values)

fn avro_validate_union_schema(schema) -> bool:
    """Validate union schema."""
    if schema.types == nil:
        return false
    if schema.types.len() < 2:
        return false

    # Validate each type in union
    val types = schema.types
    var i = 0
    while i < types.len():
        val type_valid = avro_validate_schema(types[i])
        if type_valid == false:
            return false
        i = i + 1

    true

fn avro_validate_fixed_schema(schema) -> bool:
    """Validate fixed schema."""
    if schema.name == nil:
        return false
    if schema.name == "":
        return false
    if schema.size <= 0:
        return false
    true

# ============================================================================
# Schema Compatibility Checking
# ============================================================================

fn avro_schemas_compatible(writer_schema, reader_schema) -> bool:
    """Check if reader schema is compatible with writer schema.
    Implements Avro schema resolution rules."""
    val writer_type = writer_schema.type
    val reader_type = reader_schema.type

    # Same type is always compatible
    if writer_type == reader_type:
        if avro_is_primitive(writer_schema):
            return true

        if writer_type == avro_type_record():
            return avro_records_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_enum():
            return avro_enums_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_array():
            return avro_arrays_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_map():
            return avro_maps_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_union():
            return avro_unions_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_fixed():
            return avro_fixed_compatible(writer_schema, reader_schema)

    # Numeric promotions
    if writer_type == avro_type_int():
        if reader_type == avro_type_long():
            return true
        if reader_type == avro_type_float():
            return true
        if reader_type == avro_type_double():
            return true

    if writer_type == avro_type_long():
        if reader_type == avro_type_float():
            return true
        if reader_type == avro_type_double():
            return true

    if writer_type == avro_type_float():
        if reader_type == avro_type_double():
            return true

    # String/bytes compatibility
    if writer_type == avro_type_string():
        if reader_type == avro_type_bytes():
            return true

    if writer_type == avro_type_bytes():
        if reader_type == avro_type_string():
            return true

    false

fn avro_records_compatible(writer_schema, reader_schema) -> bool:
    """Check record compatibility."""
    # Name must match (or alias match - not implemented here)
    if writer_schema.name != reader_schema.name:
        return false

    # All reader fields must be present in writer or have defaults
    val reader_fields = reader_schema.fields
    var i = 0
    while i < reader_fields.len():
        val reader_field = reader_fields[i]
        val writer_field = avro_find_field(writer_schema, reader_field.name)
        if writer_field == nil:
            # Field not in writer - must have default
            if reader_field.default == nil:
                return false
        else:
            # Field exists - check type compatibility
            val types_compatible = avro_schemas_compatible(writer_field.type, reader_field.type)
            if types_compatible == false:
                return false
        i = i + 1

    true

fn avro_find_field(schema, field_name: text):
    """Find field in record schema by name."""
    val fields = schema.fields
    var i = 0
    while i < fields.len():
        val field = fields[i]
        if field.name == field_name:
            return field
        i = i + 1
    nil

fn avro_enums_compatible(writer_schema, reader_schema) -> bool:
    """Check enum compatibility."""
    # Name must match
    if writer_schema.name != reader_schema.name:
        return false

    # All writer symbols must exist in reader
    val writer_symbols = writer_schema.symbols
    val reader_symbols = reader_schema.symbols

    var i = 0
    while i < writer_symbols.len():
        val writer_symbol = writer_symbols[i]
        var found = false
        var j = 0
        while j < reader_symbols.len():
            if reader_symbols[j] == writer_symbol:
                found = true
            j = j + 1
        if found == false:
            return false
        i = i + 1

    true

fn avro_arrays_compatible(writer_schema, reader_schema) -> bool:
    """Check array compatibility."""
    avro_schemas_compatible(writer_schema.items, reader_schema.items)

fn avro_maps_compatible(writer_schema, reader_schema) -> bool:
    """Check map compatibility."""
    avro_schemas_compatible(writer_schema.values, reader_schema.values)

fn avro_unions_compatible(writer_schema, reader_schema) -> bool:
    """Check union compatibility (simplified)."""
    # All writer types must be compatible with at least one reader type
    val writer_types = writer_schema.types
    val reader_types = reader_schema.types

    var i = 0
    while i < writer_types.len():
        val writer_type = writer_types[i]
        var compatible = false
        var j = 0
        while j < reader_types.len():
            val reader_type = reader_types[j]
            val check = avro_schemas_compatible(writer_type, reader_type)
            if check:
                compatible = true
            j = j + 1
        if compatible == false:
            return false
        i = i + 1

    true

fn avro_fixed_compatible(writer_schema, reader_schema) -> bool:
    """Check fixed compatibility."""
    if writer_schema.name != reader_schema.name:
        return false
    if writer_schema.size != reader_schema.size:
        return false
    true

# ============================================================================
# Utility Functions
# ============================================================================

fn avro_schema_equals(schema1, schema2) -> bool:
    """Check if two schemas are equal."""
    val json1 = avro_schema_to_json(schema1)
    val json2 = avro_schema_to_json(schema2)
    json1 == json2

fn avro_get_type_name(type_id: i64) -> text:
    """Get type name string from type ID."""
    if type_id == avro_type_null(): return "null"
    if type_id == avro_type_boolean(): return "boolean"
    if type_id == avro_type_int(): return "int"
    if type_id == avro_type_long(): return "long"
    if type_id == avro_type_float(): return "float"
    if type_id == avro_type_double(): return "double"
    if type_id == avro_type_bytes(): return "bytes"
    if type_id == avro_type_string(): return "string"
    if type_id == avro_type_record(): return "record"
    if type_id == avro_type_enum(): return "enum"
    if type_id == avro_type_array(): return "array"
    if type_id == avro_type_map(): return "map"
    if type_id == avro_type_union(): return "union"
    if type_id == avro_type_fixed(): return "fixed"
    "unknown"

fn avro_format_bytes(bytes: [i64]) -> text:
    """Format byte array as hex string."""
    var result = ""
    for byte_val in bytes:
        val hex = avro_byte_to_hex(byte_val)
        result = result + hex + " "
    result

fn avro_byte_to_hex(n: i64) -> text:
    """Convert byte to hex string."""
    val high = n / 16
    val low = n % 16
    val high_char = avro_hex_digit(high)
    val low_char = avro_hex_digit(low)
    high_char + low_char

fn avro_hex_digit(n: i64) -> text:
    """Convert digit to hex character."""
    if n == 0: return "0"
    if n == 1: return "1"
    if n == 2: return "2"
    if n == 3: return "3"
    if n == 4: return "4"
    if n == 5: return "5"
    if n == 6: return "6"
    if n == 7: return "7"
    if n == 8: return "8"
    if n == 9: return "9"
    if n == 10: return "a"
    if n == 11: return "b"
    if n == 12: return "c"
    if n == 13: return "d"
    if n == 14: return "e"
    if n == 15: return "f"
    "?"
