# Interval Tree - Utility Operations

use interval_tree.types.{node_interval, node_left, node_right, is_red, is_black}
use interval_tree.overlap.{interval_low, interval_high, interval_data, interval_new, interval_length, interval_overlaps, interval_merge, interval_compare}

# ============================================================================
# Tree Properties
# ============================================================================

fn size(tree: any) -> i64:
    if tree == nil:
        0
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(node)
        val right = node_right(node)
        1 + size(left) + size(right)

fn height(tree: any) -> i64:
    if tree == nil:
        0
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(node)
        val right = node_right(node)
        val left_height = height(left)
        val right_height = height(right)
        val max_height = if left_height > right_height: left_height else: right_height
        1 + max_height

fn is_empty(tree: any) -> bool:
    tree == nil

# ============================================================================
# Traversal and Iteration
# ============================================================================

fn inorder_traversal(tree: any) -> list:
    # Return intervals in sorted order by low endpoint
    var result = []
    inorder_helper(tree, result)
    result

fn inorder_helper(node: any, result: list):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(n)
        val right = node_right(n)
        val interval = node_interval(n)

        inorder_helper(left, result)
        result.append(interval)
        inorder_helper(right, result)

fn preorder_traversal(tree: any) -> list:
    var result = []
    preorder_helper(tree, result)
    result

fn preorder_helper(node: any, result: list):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(n)
        val right = node_right(n)
        val interval = node_interval(n)

        result.append(interval)
        preorder_helper(left, result)
        preorder_helper(right, result)

fn postorder_traversal(tree: any) -> list:
    var result = []
    postorder_helper(tree, result)
    result

fn postorder_helper(node: any, result: list):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(n)
        val right = node_right(n)
        val interval = node_interval(n)

        postorder_helper(left, result)
        postorder_helper(right, result)
        result.append(interval)

fn collect_all(tree: any) -> list:
    inorder_traversal(tree)

# ============================================================================
# Helper Functions
# ============================================================================

fn merge_overlapping_intervals(intervals: list) -> list:
    # Merge all overlapping intervals in the list
    if intervals.len() == 0:
        []
    else:
        # Sort intervals by low endpoint
        val sorted = intervals.copy()
        sort_intervals(sorted)

        var result = []
        var current = sorted[0]
        var i = 1
        val n = sorted.len()

        while i < n:
            val next = sorted[i]

            if interval_overlaps(current, next):
                current = interval_merge(current, next)
            else:
                result.append(current)
                current = next

            i = i + 1

        result.append(current)
        result

fn sort_intervals(intervals: list):
    # Bubble sort for intervals (in-place)
    val n = intervals.len()
    var i = 0

    while i < n - 1:
        var j = 0
        while j < n - i - 1:
            val cmp = interval_compare(intervals[j], intervals[j + 1])
            if cmp > 0:
                val temp = intervals[j]
                intervals[j] = intervals[j + 1]
                intervals[j + 1] = temp
            else:
                ()
            j = j + 1
        i = i + 1

fn sort_i64_list(values: list):
    # Bubble sort for i64 values (in-place)
    val n = values.len()
    var i = 0

    while i < n - 1:
        var j = 0
        while j < n - i - 1:
            if values[j] > values[j + 1]:
                val temp = values[j]
                values[j] = values[j + 1]
                values[j + 1] = temp
            else:
                ()
            j = j + 1
        i = i + 1

# ============================================================================
# Advanced Queries
# ============================================================================

fn find_gaps(tree: any, range_low: i64, range_high: i64) -> list:
    # Find gaps (non-covered intervals) in a range
    val intervals = inorder_traversal(tree)
    val n = intervals.len()

    if n == 0:
        [interval_new(range_low, range_high, 0)]
    else:
        var gaps = []
        var current_pos = range_low
        var i = 0

        while i < n:
            val interval = intervals[i]
            val low = interval_low(interval)
            val high = interval_high(interval)

            if low > current_pos:
                val gap_high = if low - 1 < range_high: low - 1 else: range_high
                gaps.append(interval_new(current_pos, gap_high, 0))
            else:
                ()

            val next_pos = high + 1
            current_pos = if next_pos > current_pos: next_pos else: current_pos
            i = i + 1

        if current_pos <= range_high:
            gaps.append(interval_new(current_pos, range_high, 0))
        else:
            ()

        gaps

fn find_maximum_overlap_point(tree: any) -> (i64, i64):
    # Find point with maximum number of overlapping intervals
    # Returns (point, count)
    val intervals = collect_all(tree)
    val n = intervals.len()

    if n == 0:
        (0, 0)
    else:
        # Collect all endpoints
        var endpoints = []
        var i = 0

        while i < n:
            val interval = intervals[i]
            endpoints.append(interval_low(interval))
            endpoints.append(interval_high(interval))
            i = i + 1

        # Sort endpoints
        sort_i64_list(endpoints)

        # Find point with max overlap
        var max_count = 0
        var max_point = endpoints[0]
        var j = 0
        val m = endpoints.len()

        while j < m:
            val point = endpoints[j]
            val overlapping = search_point(tree, point)
            val count = overlapping.len()

            if count > max_count:
                max_count = count
                max_point = point
            else:
                ()

            j = j + 1

        (max_point, max_count)

fn coverage_length(tree: any, range_low: i64, range_high: i64) -> i64:
    # Calculate total coverage length in range
    val intervals = search_range(tree, range_low, range_high)

    if intervals.len() == 0:
        0
    else:
        val merged = merge_overlapping_intervals(intervals)
        var total = 0
        var i = 0
        val n = merged.len()

        while i < n:
            val interval = merged[i]
            var low = interval_low(interval)
            var high = interval_high(interval)

            # Clip to range
            if low < range_low:
                low = range_low
            else:
                ()

            if high > range_high:
                high = range_high
            else:
                ()

            if low <= high:
                total = total + (high - low + 1)
            else:
                ()

            i = i + 1

        total

fn filter_by_data(tree: any, data: i64) -> list:
    # Find all intervals with specific data value
    var result = []
    filter_by_data_helper(tree, data, result)
    result

fn filter_by_data_helper(node: any, data: i64, result: list):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(n)
        val left = node_left(n)
        val right = node_right(n)

        filter_by_data_helper(left, data, result)

        if interval_data(interval) == data:
            result.append(interval)
        else:
            ()

        filter_by_data_helper(right, data, result)

fn get_all_data(tree: any) -> list:
    # Extract all data values from tree
    var result = []
    get_all_data_helper(tree, result)
    result

fn get_all_data_helper(node: any, result: list):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(n)
        val left = node_left(n)
        val right = node_right(n)

        get_all_data_helper(left, result)
        result.append(interval_data(interval))
        get_all_data_helper(right, result)

fn update_data(tree: any, interval: (i64, i64, i64), new_data: i64) -> any:
    # Update data for a specific interval
    if tree == nil:
        nil
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val node_interval = node_interval(node)
        val cmp = interval_compare(interval, node_interval)

        if cmp < 0:
            val left = node_left(node)
            val new_left = update_data(left, interval, new_data)
            node_set_left(node, new_left)
        else: if cmp > 0:
            val right = node_right(node)
            val new_right = update_data(right, interval, new_data)
            node_set_right(node, new_right)
        else:
            val updated_interval = interval_set_data(node_interval, new_data)
            node_set_interval(node, updated_interval)

fn find_nearest(tree: any, interval: (i64, i64, i64)) -> any:
    # Find interval nearest to given interval
    val all_intervals = collect_all(tree)
    val n = all_intervals.len()

    if n == 0:
        nil
    else:
        var min_distance = interval_distance(interval, all_intervals[0])
        var nearest = all_intervals[0]
        var i = 1

        while i < n:
            val candidate = all_intervals[i]
            val dist = interval_distance(interval, candidate)

            if dist < min_distance:
                min_distance = dist
                nearest = candidate
            else:
                ()

            i = i + 1

        nearest

fn total_coverage(tree: any) -> i64:
    # Calculate total coverage across all intervals (with merging)
    val intervals = collect_all(tree)
    val merged = merge_overlapping_intervals(intervals)
    var total = 0
    var i = 0
    val n = merged.len()

    while i < n:
        total = total + interval_length(merged[i])
        i = i + 1

    total

fn average_interval_length(tree: any) -> i64:
    # Calculate average interval length
    val intervals = collect_all(tree)
    val n = intervals.len()

    if n == 0:
        0
    else:
        var total = 0
        var i = 0

        while i < n:
            total = total + interval_length(intervals[i])
            i = i + 1

        total / n

fn min_interval_length(tree: any) -> i64:
    # Find minimum interval length
    val intervals = collect_all(tree)
    val n = intervals.len()

    if n == 0:
        0
    else:
        var min_len = interval_length(intervals[0])
        var i = 1

        while i < n:
            val len = interval_length(intervals[i])
            if len < min_len:
                min_len = len
            else:
                ()
            i = i + 1

        min_len

fn max_interval_length(tree: any) -> i64:
    # Find maximum interval length
    val intervals = collect_all(tree)
    val n = intervals.len()

    if n == 0:
        0
    else:
        var max_len = interval_length(intervals[0])
        var i = 1

        while i < n:
            val len = interval_length(intervals[i])
            if len > max_len:
                max_len = len
            else:
                ()
            i = i + 1

        max_len

fn map_data(tree: any, transform_fn: any) -> any:
    # Transform data in all intervals (returns new tree)
    if tree == nil:
        nil
    else:
        var new_tree = nil
        val intervals = collect_all(tree)
        var i = 0
        val n = intervals.len()

        while i < n:
            val int = intervals[i]
            val transformed = interval_set_data(int, interval_data(int) * 2)
            new_tree = insert(new_tree, transformed)
            i = i + 1

        new_tree

fn count_red_nodes(tree: any) -> i64:
    if tree == nil:
        0
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(node)
        val right = node_right(node)
        val count = if is_red(tree): 1 else: 0
        count + count_red_nodes(left) + count_red_nodes(right)

fn count_black_nodes(tree: any) -> i64:
    if tree == nil:
        0
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(node)
        val right = node_right(node)
        val count = if is_black(tree): 1 else: 0
        count + count_black_nodes(left) + count_black_nodes(right)

fn to_string(tree: any) -> text:
    if tree == nil:
        "nil"
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(node)
        val low = interval_low(interval)
        val high = interval_high(interval)
        val data = interval_data(interval)
        val max_end = node_max_end(node)
        val color = if is_red(tree): "R" else: "B"

        "[{low},{high}]:{data} max={max_end} ({color})"

fn print_tree(tree: any):
    print_tree_helper(tree, 0)

fn print_tree_helper(node: any, depth: i64):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val right = node_right(n)
        val left = node_left(n)

        print_tree_helper(right, depth + 1)

        var indent = ""
        var i = 0
        while i < depth:
            indent = indent + "  "
            i = i + 1

        print "{indent}{to_string(node)}"

        print_tree_helper(left, depth + 1)

# ============================================================================
# Validation
# ============================================================================

fn validate_red_black_properties(tree: any) -> bool:
    # Check if tree maintains Red-Black properties
    if tree == nil:
        true
    else:
        # Root must be black
        if is_red(tree):
            false
        else:
            val node = tree as (i64, (i64, i64, i64), i64, any, any)
            validate_helper(node)

fn validate_helper(node: (i64, (i64, i64, i64), i64, any, any)) -> bool:
    # Check red node has black children
    if is_red(node):
        val left = node_left(node)
        val right = node_right(node)

        if is_red(left) or is_red(right):
            false
        else:
            val left_valid = if left == nil: true else: validate_helper(left as (i64, (i64, i64, i64), i64, any, any))
            val right_valid = if right == nil: true else: validate_helper(right as (i64, (i64, i64, i64), i64, any, any))
            left_valid and right_valid
    else:
        val left = node_left(node)
        val right = node_right(node)
        val left_valid = if left == nil: true else: validate_helper(left as (i64, (i64, i64, i64), i64, any, any))
        val right_valid = if right == nil: true else: validate_helper(right as (i64, (i64, i64, i64), i64, any, any))
        left_valid and right_valid

fn validate_max_end(tree: any) -> bool:
    # Check if max_end augmentation is correct
    if tree == nil:
        true
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(node)
        val stored_max = node_max_end(node)
        val left = node_left(node)
        val right = node_right(node)
        val computed_max = compute_max_end(interval, left, right)

        if stored_max != computed_max:
            false
        else:
            val left_valid = validate_max_end(left)
            val right_valid = validate_max_end(right)
            left_valid and right_valid

fn validate_bst_property(tree: any) -> bool:
    # Check if BST property holds
    validate_bst_helper(tree, nil, nil)

fn validate_bst_helper(node: any, min_interval: any, max_interval: any) -> bool:
    if node == nil:
        true
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(n)

        # Check bounds
        var valid = true

        if min_interval != nil:
            val min_int = min_interval as (i64, i64, i64)
            val cmp = interval_compare(interval, min_int)
            if cmp <= 0:
                valid = false
            else:
                ()
        else:
            ()

        if max_interval != nil:
            val max_int = max_interval as (i64, i64, i64)
            val cmp = interval_compare(interval, max_int)
            if cmp >= 0:
                valid = false
            else:
                ()
        else:
            ()

        if not valid:
            false
        else:
            val left = node_left(n)
            val right = node_right(n)
            val left_valid = validate_bst_helper(left, min_interval, interval)
            val right_valid = validate_bst_helper(right, interval, max_interval)
            left_valid and right_valid

# ============================================================================
# Exports
# ============================================================================

export size, height, is_empty
export inorder_traversal, preorder_traversal, postorder_traversal, collect_all
export merge_overlapping_intervals, sort_intervals, sort_i64_list
export find_gaps, find_maximum_overlap_point, coverage_length
export filter_by_data, get_all_data, update_data, find_nearest
export total_coverage, average_interval_length, min_interval_length, max_interval_length
export map_data, count_red_nodes, count_black_nodes
export to_string, print_tree, print_tree_helper
export validate_red_black_properties, validate_max_end, validate_bst_property
