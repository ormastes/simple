# Interval Tree - Overlap and Comparison Operations

use interval_tree.types.{interval_low, interval_high, interval_data, interval_new}

# ============================================================================
# Interval Comparison and Utility Functions
# ============================================================================

fn interval_overlaps(i1: (i64, i64, i64), i2: (i64, i64, i64)) -> bool:
    # Two intervals overlap if: max(low1, low2) <= min(high1, high2)
    val low1 = interval_low(i1)
    val high1 = interval_high(i1)
    val low2 = interval_low(i2)
    val high2 = interval_high(i2)

    val max_low = if low1 > low2: low1 else: low2
    val min_high = if high1 < high2: high1 else: high2

    max_low <= min_high

fn interval_contains_point(interval: (i64, i64, i64), point: i64) -> bool:
    val low = interval_low(interval)
    val high = interval_high(interval)
    low <= point and point <= high

fn interval_contains_interval(outer: (i64, i64, i64), inner: (i64, i64, i64)) -> bool:
    val outer_low = interval_low(outer)
    val outer_high = interval_high(outer)
    val inner_low = interval_low(inner)
    val inner_high = interval_high(inner)

    outer_low <= inner_low and inner_high <= outer_high

fn interval_compare(i1: (i64, i64, i64), i2: (i64, i64, i64)) -> i64:
    # Compare intervals by low endpoint, then by high endpoint
    val low1 = interval_low(i1)
    val low2 = interval_low(i2)

    if low1 < low2:
        -1
    else: if low1 > low2:
        1
    else:
        val high1 = interval_high(i1)
        val high2 = interval_high(i2)

        if high1 < high2:
            -1
        else: if high1 > high2:
            1
        else:
            0

fn interval_equals(i1: (i64, i64, i64), i2: (i64, i64, i64)) -> bool:
    val cmp = interval_compare(i1, i2)
    cmp == 0

fn interval_merge(i1: (i64, i64, i64), i2: (i64, i64, i64)) -> (i64, i64, i64):
    # Merge two overlapping intervals
    val low1 = interval_low(i1)
    val high1 = interval_high(i1)
    val low2 = interval_low(i2)
    val high2 = interval_high(i2)

    val min_low = if low1 < low2: low1 else: low2
    val max_high = if high1 > high2: high1 else: high2
    val data = interval_data(i1)

    interval_new(min_low, max_high, data)

fn interval_length(interval: (i64, i64, i64)) -> i64:
    val low = interval_low(interval)
    val high = interval_high(interval)
    high - low + 1

fn interval_valid(interval: (i64, i64, i64)) -> bool:
    val low = interval_low(interval)
    val high = interval_high(interval)
    low <= high

fn interval_distance(i1: (i64, i64, i64), i2: (i64, i64, i64)) -> i64:
    # Distance between two intervals (0 if overlapping)
    if interval_overlaps(i1, i2):
        0
    else:
        val low1 = interval_low(i1)
        val high1 = interval_high(i1)
        val low2 = interval_low(i2)
        val high2 = interval_high(i2)

        if high1 < low2:
            low2 - high1 - 1
        else:
            low1 - high2 - 1

# ============================================================================
# Exports
# ============================================================================

export interval_overlaps, interval_contains_point, interval_contains_interval
export interval_compare, interval_equals, interval_merge
export interval_length, interval_valid, interval_distance
