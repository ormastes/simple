# Interval Tree - Query Operations

use interval_tree.types.{
    interval_compare, interval_low, interval_high, interval_contains_point, interval_overlaps,
    node_interval, node_left, node_right, node_max_end
}

# ============================================================================
# Search Operations
# ============================================================================

fn search_exact(tree: any, interval: (i64, i64, i64)) -> any:
    # Search for exact interval match
    if tree == nil:
        nil
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val node_interval = node_interval(node)
        val cmp = interval_compare(interval, node_interval)

        if cmp < 0:
            search_exact(node_left(node), interval)
        else: if cmp > 0:
            search_exact(node_right(node), interval)
        else:
            tree

fn search_point(tree: any, point: i64) -> list:
    # Find all intervals containing the point
    var result = []
    search_point_helper(tree, point, result)
    result

fn search_point_helper(node: any, point: i64, result: list):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(n)
        val left = node_left(n)
        val right = node_right(n)

        # Check left subtree if it might contain overlapping intervals
        val should_check_left = if left == nil:
            false
        else:
            val l = left as (i64, (i64, i64, i64), i64, any, any)
            val left_max = node_max_end(l)
            left_max >= point

        if should_check_left:
            search_point_helper(left, point, result)
        else:
            ()

        # Check current interval
        if interval_contains_point(interval, point):
            result.append(interval)
        else:
            ()

        # Check right subtree if point is to the right of interval start
        val interval_low = interval_low(interval)
        if point >= interval_low:
            search_point_helper(right, point, result)
        else:
            ()

fn search_overlapping(tree: any, interval: (i64, i64, i64)) -> list:
    # Find all intervals overlapping with given interval
    var result = []
    search_overlapping_helper(tree, interval, result)
    result

fn search_overlapping_helper(node: any, interval: (i64, i64, i64), result: list):
    if node == nil:
        ()
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val node_interval = node_interval(n)
        val left = node_left(n)
        val right = node_right(n)

        # Check left subtree if it might contain overlapping intervals
        val should_check_left = if left == nil:
            false
        else:
            val l = left as (i64, (i64, i64, i64), i64, any, any)
            val left_max = node_max_end(l)
            val interval_low = interval_low(interval)
            left_max >= interval_low

        if should_check_left:
            search_overlapping_helper(left, interval, result)
        else:
            ()

        # Check current interval
        if interval_overlaps(node_interval, interval):
            result.append(node_interval)
        else:
            ()

        # Check right subtree if interval extends past node start
        val node_low = interval_low(node_interval)
        val interval_high = interval_high(interval)
        if interval_high >= node_low:
            search_overlapping_helper(right, interval, result)
        else:
            ()

fn search_range(tree: any, low: i64, high: i64) -> list:
    # Find all intervals in range [low, high]
    val search_interval = interval_new(low, high, 0)
    search_overlapping(tree, search_interval)

fn find_min(tree: any) -> any:
    # Find node with minimum interval
    if tree == nil:
        nil
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(node)
        if left == nil:
            tree
        else:
            find_min(left)

fn find_max(tree: any) -> any:
    # Find node with maximum interval
    if tree == nil:
        nil
    else:
        val node = tree as (i64, (i64, i64, i64), i64, any, any)
        val right = node_right(node)
        if right == nil:
            tree
        else:
            find_max(right)

fn contains(tree: any, interval: (i64, i64, i64)) -> bool:
    val found = search_exact(tree, interval)
    found != nil

# ============================================================================
# Exports
# ============================================================================

export search_exact, search_point, search_point_helper
export search_overlapping, search_overlapping_helper, search_range
export find_min, find_max, contains
