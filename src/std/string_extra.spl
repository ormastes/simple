# String Extra Utilities
#
# Additional string utility functions beyond string.spl.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - is_empty: Check if string is empty
# - is_whitespace: Check if string contains only whitespace
# - count_char: Count occurrences of a character
# - repeat_string: Repeat a string n times
# - pad_left: Pad string to length with character
# - pad_right: Pad string to length with character
# - pad_center: Center string in field of length
# - truncate: Truncate string to max length with ellipsis
# - capitalize_first: Capitalize first character only
# - is_ascii: Check if string is all ASCII

# ============================================================================
# String Predicates
# ============================================================================

fn is_empty(s: text) -> bool:
    """Check if string is empty."""
    s.len() == 0

fn is_whitespace(s: text) -> bool:
    """Check if string contains only whitespace characters."""
    if s.len() == 0:
        return true

    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        if ch != " " and ch != "\t" and ch != "\n" and ch != "\r":
            return false
        i = i + 1

    true

fn is_ascii(s: text) -> bool:
    """Check if all characters are ASCII (codes 0-127).
    Note: Runtime limitation - can only check common printable ASCII."""
    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        # Check if it's a common ASCII character
        val is_valid = ch == " " or ch == "!" or ch == "#" or ch == "$" or
                       ch == "%" or ch == "&" or ch == "'" or ch == "(" or
                       ch == ")" or ch == "*" or ch == "+" or ch == "," or
                       ch == "-" or ch == "." or ch == "/" or
                       (ch >= "0" and ch <= "9") or
                       (ch >= "A" and ch <= "Z") or
                       (ch >= "a" and ch <= "z") or
                       ch == ":" or ch == ";" or ch == "<" or ch == "=" or
                       ch == ">" or ch == "?" or ch == "@" or
                       ch == "[" or ch == "]" or ch == "^" or ch == "_" or
                       ch == "{" or ch == "}" or ch == "~"

        if not is_valid:
            return false

        i = i + 1

    true

# ============================================================================
# String Counting
# ============================================================================

fn count_char(s: text, ch: text) -> i64:
    """Count occurrences of a character in string."""
    var count = 0
    var i = 0
    while i < s.len():
        if s[i..i+1] == ch:
            count = count + 1
        i = i + 1
    count

fn count_substring(s: text, substr: text) -> i64:
    """Count non-overlapping occurrences of substring."""
    if substr.len() == 0:
        return 0

    var count = 0
    var pos = 0

    while pos <= s.len() - substr.len():
        var match = true
        var j = 0
        while j < substr.len():
            if s[pos + j..pos + j + 1] != substr[j..j + 1]:
                match = false
                break
            j = j + 1

        if match:
            count = count + 1
            pos = pos + substr.len()
        else:
            pos = pos + 1

    count

# ============================================================================
# String Repetition
# ============================================================================

fn repeat_string(s: text, n: i64) -> text:
    """Repeat string n times."""
    if n <= 0:
        return ""

    var result = ""
    var i = 0
    while i < n:
        result = result + s
        i = i + 1

    result

# ============================================================================
# String Padding
# ============================================================================

fn pad_left(s: text, width: i64, fill: text) -> text:
    """Pad string on the left to reach width.
    fill should be a single character."""
    val current_len = s.len()
    if current_len >= width:
        return s

    val padding_needed = width - current_len
    val padding = repeat_string(fill, padding_needed)
    padding + s

fn pad_right(s: text, width: i64, fill: text) -> text:
    """Pad string on the right to reach width.
    fill should be a single character."""
    val current_len = s.len()
    if current_len >= width:
        return s

    val padding_needed = width - current_len
    val padding = repeat_string(fill, padding_needed)
    s + padding

fn pad_center(s: text, width: i64, fill: text) -> text:
    """Center string in field of width.
    fill should be a single character."""
    val current_len = s.len()
    if current_len >= width:
        return s

    val total_padding = width - current_len
    val left_padding = total_padding / 2
    val right_padding = total_padding - left_padding

    val left = repeat_string(fill, left_padding)
    val right = repeat_string(fill, right_padding)

    left + s + right

# ============================================================================
# String Truncation
# ============================================================================

fn truncate(s: text, max_len: i64) -> text:
    """Truncate string to max length, adding '...' if truncated."""
    if s.len() <= max_len:
        return s

    if max_len <= 3:
        return s[0..max_len]

    s[0..max_len - 3] + "..."

fn truncate_with_ellipsis(s: text, max_len: i64, ellipsis: text) -> text:
    """Truncate string to max length with custom ellipsis."""
    if s.len() <= max_len:
        return s

    val ellipsis_len = ellipsis.len()
    if max_len <= ellipsis_len:
        return s[0..max_len]

    s[0..max_len - ellipsis_len] + ellipsis

# ============================================================================
# String Capitalization
# ============================================================================

fn capitalize_first(s: text) -> text:
    """Capitalize only the first character, leaving rest unchanged."""
    if s.len() == 0:
        return s

    val first = s[0..1]
    val rest = if s.len() > 1: s[1..] else: ""

    val upper_first = to_uppercase_char(first)
    upper_first + rest

fn to_uppercase_char(ch: text) -> text:
    """Convert a single character to uppercase (a-z only)."""
    if ch == "a": return "A"
    if ch == "b": return "B"
    if ch == "c": return "C"
    if ch == "d": return "D"
    if ch == "e": return "E"
    if ch == "f": return "F"
    if ch == "g": return "G"
    if ch == "h": return "H"
    if ch == "i": return "I"
    if ch == "j": return "J"
    if ch == "k": return "K"
    if ch == "l": return "L"
    if ch == "m": return "M"
    if ch == "n": return "N"
    if ch == "o": return "O"
    if ch == "p": return "P"
    if ch == "q": return "Q"
    if ch == "r": return "R"
    if ch == "s": return "S"
    if ch == "t": return "T"
    if ch == "u": return "U"
    if ch == "v": return "V"
    if ch == "w": return "W"
    if ch == "x": return "X"
    if ch == "y": return "Y"
    if ch == "z": return "Z"
    ch

# ============================================================================
# String Splitting Utilities
# ============================================================================

fn split_once(s: text, delimiter: text) -> (text, text)?:
    """Split string at first occurrence of delimiter.
    Returns (before, after) or nil if delimiter not found."""
    var i = 0
    while i <= s.len() - delimiter.len():
        var match = true
        var j = 0
        while j < delimiter.len():
            if s[i + j..i + j + 1] != delimiter[j..j + 1]:
                match = false
                break
            j = j + 1

        if match:
            val before = s[0..i]
            val after = s[i + delimiter.len()..]
            return Some((before, after))

        i = i + 1

    nil

fn lines(s: text) -> [text]:
    """Split string into lines by newline character."""
    s.split("\n")

# ============================================================================
# String Comparison Utilities
# ============================================================================

fn compare_ignore_case(a: text, b: text) -> bool:
    """Compare two strings ignoring case (ASCII only)."""
    if a.len() != b.len():
        return false

    var i = 0
    while i < a.len():
        val ch_a = to_lowercase_char(a[i..i+1])
        val ch_b = to_lowercase_char(b[i..i+1])
        if ch_a != ch_b:
            return false
        i = i + 1

    true

fn to_lowercase_char(ch: text) -> text:
    """Convert a single character to lowercase (A-Z only)."""
    if ch == "A": return "a"
    if ch == "B": return "b"
    if ch == "C": return "c"
    if ch == "D": return "d"
    if ch == "E": return "e"
    if ch == "F": return "f"
    if ch == "G": return "g"
    if ch == "H": return "h"
    if ch == "I": return "i"
    if ch == "J": return "j"
    if ch == "K": return "k"
    if ch == "L": return "l"
    if ch == "M": return "m"
    if ch == "N": return "n"
    if ch == "O": return "o"
    if ch == "P": return "p"
    if ch == "Q": return "q"
    if ch == "R": return "r"
    if ch == "S": return "s"
    if ch == "T": return "t"
    if ch == "U": return "u"
    if ch == "V": return "v"
    if ch == "W": return "w"
    if ch == "X": return "x"
    if ch == "Y": return "y"
    if ch == "Z": return "z"
    ch
