# Standard Library — Traits System (Layer 3)
#
# @tag:api
# @tag:stdlib
# @tag:experimental
#
# Ergonomic wrappers over the @traits compile-time introspection system.
# Provides high-level helper functions built on the core @traits built-ins.
#
# Currently @traits is not yet available in the interpreter, so these functions
# return placeholder values. When @traits support is implemented, these will
# call the equivalent __traits built-in functions.
#
# Usage:
#   use std.traits.{field_count, has_field, is_integral_type}
#   val count = field_count("Point")
#   val has_x = has_field("Point", "x")
#   val is_i64 = is_integral_type("i64")

# ============================================================================
# Field / Member Enumeration
# ============================================================================

fn field_names(type_name: text) -> [text]:
    # Returns all field names of a struct type.
    # Wraps @traits(fields, T) when available.
    # For now: returns empty list.
    val result: [text] = []
    result

fn method_names(type_name: text) -> [text]:
    # Returns all method names of a struct/class type.
    # Wraps @traits(methods, T) when available.
    val result: [text] = []
    result

fn all_member_names(type_name: text) -> [text]:
    # Returns all members (fields + methods) of a type.
    # Wraps @traits(all_members, T) when available.
    val result: [text] = []
    result

fn field_count(type_name: text) -> i64:
    # Returns the number of fields in a struct type.
    val names = field_names(type_name)
    names.len()

fn has_field(type_name: text, field_name: text) -> bool:
    # Returns true if type_name has a field named field_name.
    val names = field_names(type_name)
    for n in names:
        if n == field_name:
            return true
    false

fn has_method(type_name: text, method_name: text) -> bool:
    # Returns true if type_name has a method named method_name.
    val names = method_names(type_name)
    for n in names:
        if n == method_name:
            return true
    false

# ============================================================================
# Type Classification
# ============================================================================

fn is_struct_type(type_name: text) -> bool:
    # Returns true if type_name is a struct type.
    # Placeholder — @traits(is_struct, T) when available.
    false

fn is_class_type(type_name: text) -> bool:
    # Returns true if type_name is a class type.
    # Placeholder — @traits(is_class, T) when available.
    false

fn is_enum_type(type_name: text) -> bool:
    # Returns true if type_name is an enum type.
    # Placeholder — @traits(is_enum, T) when available.
    false

fn enum_variant_names(type_name: text) -> [text]:
    # Returns all variant names of an enum type.
    # Placeholder — @traits(enum_members, T) when available.
    val result: [text] = []
    result

fn enum_variant_count(type_name: text) -> i64:
    # Returns the number of variants in an enum type.
    val names = enum_variant_names(type_name)
    names.len()

# ============================================================================
# Annotation / Attribute Queries
# ============================================================================

fn get_annotations(fn_name: text) -> [text]:
    # Returns annotations on a function (e.g. ["@must_use", "@pure"]).
    # Wraps @traits(get_annotations, sym) when available.
    val result: [text] = []
    result

fn has_annotation(fn_name: text, annotation_name: text) -> bool:
    # Returns true if fn_name has annotation_name.
    val anns = get_annotations(fn_name)
    for a in anns:
        if a == annotation_name:
            return true
    false

# ============================================================================
# Numeric Type Classification
# ============================================================================

fn is_integral_type(type_name: text) -> bool:
    # Returns true if type_name is an integral type.
    if type_name == "i64":
        return true
    if type_name == "i32":
        return true
    if type_name == "i16":
        return true
    if type_name == "i8":
        return true
    if type_name == "u64":
        return true
    if type_name == "u32":
        return true
    if type_name == "u16":
        return true
    if type_name == "u8":
        return true
    false

fn is_float_type(type_name: text) -> bool:
    # Returns true if type_name is a floating-point type.
    if type_name == "f64":
        return true
    if type_name == "f32":
        return true
    false

fn is_numeric_type(type_name: text) -> bool:
    # Returns true if type_name is a numeric type (integral or float).
    if is_integral_type(type_name):
        return true
    if is_float_type(type_name):
        return true
    false

# ============================================================================
# Other Type Classification
# ============================================================================

fn is_text_type(type_name: text) -> bool:
    # Returns true if type_name is the text type.
    type_name == "text"

fn is_bool_type(type_name: text) -> bool:
    # Returns true if type_name is the bool type.
    type_name == "bool"

fn is_array_type(type_name: text) -> bool:
    # Returns true if type_name looks like an array type.
    # Placeholder — @traits(is_array, T) when available.
    # Heuristic: starts with '[' and ends with ']'.
    if type_name.len() < 2:
        return false
    val first = type_name[0:1]
    val last = type_name[type_name.len() - 1:type_name.len()]
    (first == "[") and (last == "]")

fn is_dict_type(type_name: text) -> bool:
    # Returns true if type_name looks like a dict type.
    # Placeholder — @traits(is_dict, T) when available.
    # Heuristic: starts with '{' and ends with '}'.
    if type_name.len() < 2:
        return false
    val first = type_name[0:1]
    val last = type_name[type_name.len() - 1:type_name.len()]
    (first == "{") and (last == "}")

# ============================================================================
# Exports
# ============================================================================

export field_names, method_names, all_member_names, field_count
export has_field, has_method
export is_struct_type, is_class_type, is_enum_type
export enum_variant_names, enum_variant_count
export get_annotations, has_annotation
export is_integral_type, is_float_type, is_numeric_type
export is_text_type, is_bool_type
export is_array_type, is_dict_type
