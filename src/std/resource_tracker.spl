# Resource Usage Tracking
#
# Track and analyze resource consumption per test.
# Integrates with test database for historical analysis.

use std.process_monitor.{ProcessMetrics}
use std.string.{NL}
use app.io.mod.{file_exists, file_read, file_write, file_append}

# ============================================================================
# ResourceUsageRecord - Database record for test resource usage
# ============================================================================

struct ResourceUsageRecord:
    test_file: text
    timestamp_ms: i64
    duration_ms: i64
    max_cpu_percent: f64
    max_memory_mb: i64
    avg_cpu_percent: f64
    avg_memory_mb: i64
    max_open_fds: i64
    max_threads: i64
    sample_count: i64
    violations: text  # Comma-separated: "cpu", "memory", "fds"

# ============================================================================
# Statistics Calculation
# ============================================================================

fn calculate_resource_stats(samples: [ProcessMetrics]) -> ResourceUsageRecord:
    """
    Calculate aggregate statistics from metric samples.

    Args:
        samples: Array of ProcessMetrics snapshots

    Returns:
        ResourceUsageRecord with max/avg values
    """
    if samples.len() == 0:
        return ResourceUsageRecord(
            test_file: "",
            timestamp_ms: 0,
            duration_ms: 0,
            max_cpu_percent: 0.0,
            max_memory_mb: 0,
            avg_cpu_percent: 0.0,
            avg_memory_mb: 0,
            max_open_fds: 0,
            max_threads: 0,
            sample_count: 0,
            violations: ""
        )

    var max_cpu = 0.0
    var max_memory = 0
    var max_fds = 0
    var max_threads = 0
    var sum_cpu = 0.0
    var sum_memory = 0

    for sample in samples:
        if sample.cpu_percent > max_cpu:
            max_cpu = sample.cpu_percent
        if sample.memory_mb > max_memory:
            max_memory = sample.memory_mb
        if sample.open_fds > max_fds:
            max_fds = sample.open_fds
        if sample.thread_count > max_threads:
            max_threads = sample.thread_count

        sum_cpu = sum_cpu + sample.cpu_percent
        sum_memory = sum_memory + sample.memory_mb

    val count = samples.len()
    val avg_cpu = sum_cpu / count
    val avg_memory = sum_memory / count

    # Calculate duration from first to last sample
    val start_time = samples[0].timestamp_ms
    val end_time = samples[count - 1].timestamp_ms
    val duration = end_time - start_time

    ResourceUsageRecord(
        test_file: "",
        timestamp_ms: start_time,
        duration_ms: duration,
        max_cpu_percent: max_cpu,
        max_memory_mb: max_memory,
        avg_cpu_percent: avg_cpu,
        avg_memory_mb: avg_memory,
        max_open_fds: max_fds,
        max_threads: max_threads,
        sample_count: count,
        violations: ""
    )

# ============================================================================
# Violation Detection
# ============================================================================

fn detect_violations(record: ResourceUsageRecord, cpu_limit: f64, memory_limit_mb: i64, fd_limit: i64) -> text:
    """
    Detect resource limit violations.

    Returns:
        Comma-separated violation types: "cpu,memory" or ""
    """
    var violations: [text] = []

    if record.max_cpu_percent > cpu_limit:
        violations.push("cpu")

    if record.max_memory_mb > memory_limit_mb:
        violations.push("memory")

    if record.max_open_fds > fd_limit:
        violations.push("fds")

    violations.join(",")

# ============================================================================
# Database Integration (SDN format)
# ============================================================================

fn resource_db_path() -> text:
    """Return path to resource usage database"""
    "doc/test/resource_usage.sdn"

fn resource_db_init():
    """Initialize resource usage database if it doesn't exist"""
    val db_path = resource_db_path()
    if not file_exists(db_path):
        val header = "# Test Resource Usage Database\n"
        val header2 = "# Auto-generated by test runner\n"
        val header3 = "# Format: SDN (Simple Data Notation)\n\n"
        file_write(db_path, header + header2 + header3)

fn resource_db_record(test_file: text, record: ResourceUsageRecord, violations: text):
    """
    Append resource usage record to database.

    Args:
        test_file: Test file path
        record: ResourceUsageRecord with metrics
        violations: Comma-separated violation types
    """
    resource_db_init()

    # Format as SDN entry
    var entry = "resource_usage {\n"
    entry = entry + "  test_file \"{test_file}\"\n"
    entry = entry + "  timestamp_ms {record.timestamp_ms}\n"
    entry = entry + "  duration_ms {record.duration_ms}\n"
    entry = entry + "  max_cpu_percent {record.max_cpu_percent}\n"
    entry = entry + "  max_memory_mb {record.max_memory_mb}\n"
    entry = entry + "  avg_cpu_percent {record.avg_cpu_percent}\n"
    entry = entry + "  avg_memory_mb {record.avg_memory_mb}\n"
    entry = entry + "  max_open_fds {record.max_open_fds}\n"
    entry = entry + "  max_threads {record.max_threads}\n"
    entry = entry + "  sample_count {record.sample_count}\n"
    entry = entry + "  violations \"{violations}\"\n"
    entry = entry + "}\n\n"

    file_append(resource_db_path(), entry)

fn resource_db_query_worst_cpu(limit: i64) -> [ResourceUsageRecord]:
    """
    Query top N tests by CPU usage.

    Args:
        limit: Number of results to return

    Returns:
        Array of ResourceUsageRecord sorted by max_cpu_percent descending

    Note: Simple implementation - loads all records and sorts in memory.
    """
    val records = resource_db_load_all()

    # Sort by max_cpu_percent descending
    val sorted = sort_by_cpu_desc(records)

    # Take top N
    if sorted.len() <= limit:
        sorted
    else:
        sorted[0:limit]

fn resource_db_query_worst_memory(limit: i64) -> [ResourceUsageRecord]:
    """
    Query top N tests by memory usage.

    Returns:
        Array of ResourceUsageRecord sorted by max_memory_mb descending
    """
    val records = resource_db_load_all()

    # Sort by max_memory_mb descending
    val sorted = sort_by_memory_desc(records)

    # Take top N
    if sorted.len() <= limit:
        sorted
    else:
        sorted[0:limit]

fn resource_db_load_all() -> [ResourceUsageRecord]:
    """
    Load all resource usage records from database.

    Returns:
        Array of ResourceUsageRecord

    Note: Simplified parser - expects exact SDN format from resource_db_record.
    """
    val db_path = resource_db_path()
    if not file_exists(db_path):
        return []

    val content = file_read(db_path)
    parse_resource_db_sdn(content)

fn parse_resource_db_sdn(content: text) -> [ResourceUsageRecord]:
    """
    Parse SDN content into ResourceUsageRecord array.

    Simplified parser - expects specific format from resource_db_record.
    """
    var records: [ResourceUsageRecord] = []
    val lines = content.split(NL)

    var current_record = ResourceUsageRecord(
        test_file: "",
        timestamp_ms: 0,
        duration_ms: 0,
        max_cpu_percent: 0.0,
        max_memory_mb: 0,
        avg_cpu_percent: 0.0,
        avg_memory_mb: 0,
        max_open_fds: 0,
        max_threads: 0,
        sample_count: 0,
        violations: ""
    )
    var in_record = false

    for line in lines:
        val trimmed = line.trim()

        if trimmed.starts_with("resource_usage {"):
            in_record = true
            current_record = ResourceUsageRecord(
                test_file: "",
                timestamp_ms: 0,
                duration_ms: 0,
                max_cpu_percent: 0.0,
                max_memory_mb: 0,
                avg_cpu_percent: 0.0,
                avg_memory_mb: 0,
                max_open_fds: 0,
                max_threads: 0,
                sample_count: 0,
                violations: ""
            )
        elif trimmed == "}" and in_record:
            in_record = false
            records.push(current_record)
        elif in_record:
            # Parse field: name value
            if trimmed.starts_with("test_file "):
                current_record.test_file = extract_quoted_value(trimmed)
            elif trimmed.starts_with("timestamp_ms "):
                current_record.timestamp_ms = extract_int_value(trimmed)
            elif trimmed.starts_with("duration_ms "):
                current_record.duration_ms = extract_int_value(trimmed)
            elif trimmed.starts_with("max_cpu_percent "):
                current_record.max_cpu_percent = extract_float_value(trimmed)
            elif trimmed.starts_with("max_memory_mb "):
                current_record.max_memory_mb = extract_int_value(trimmed)
            elif trimmed.starts_with("avg_cpu_percent "):
                current_record.avg_cpu_percent = extract_float_value(trimmed)
            elif trimmed.starts_with("avg_memory_mb "):
                current_record.avg_memory_mb = extract_int_value(trimmed)
            elif trimmed.starts_with("max_open_fds "):
                current_record.max_open_fds = extract_int_value(trimmed)
            elif trimmed.starts_with("max_threads "):
                current_record.max_threads = extract_int_value(trimmed)
            elif trimmed.starts_with("sample_count "):
                current_record.sample_count = extract_int_value(trimmed)
            elif trimmed.starts_with("violations "):
                current_record.violations = extract_quoted_value(trimmed)

    records

fn extract_quoted_value(line: text) -> text:
    """Extract value from: field "value" """
    val start_idx = line.index_of("\"")
    if start_idx.? == nil:
        return ""
    val start = start_idx ?? 0

    val end_idx = line.last_index_of("\"")
    if end_idx.? == nil:
        return ""
    val end_pos = end_idx ?? (line.len() - 1)

    if end_pos <= start:
        return ""

    line[start + 1:end_pos]

fn extract_int_value(line: text) -> i64:
    """Extract integer from: field value"""
    val parts = line.split(" ")
    if parts.len() < 2:
        return 0

    val value_str = parts[parts.len() - 1].trim()
    to_int(value_str)

fn extract_float_value(line: text) -> f64:
    """Extract float from: field value"""
    val parts = line.split(" ")
    if parts.len() < 2:
        return 0.0

    val value_str = parts[parts.len() - 1].trim()
    to_float(value_str)

# ============================================================================
# Sorting Helpers
# ============================================================================

fn sort_by_cpu_desc(records: [ResourceUsageRecord]) -> [ResourceUsageRecord]:
    """Sort records by max_cpu_percent descending (bubble sort)"""
    if records.len() <= 1:
        return records

    var sorted = records
    var swapped = true

    while swapped:
        swapped = false
        for i in (sorted.len() - 1):
            if sorted[i].max_cpu_percent < sorted[i + 1].max_cpu_percent:
                # Swap
                val temp = sorted[i]
                sorted[i] = sorted[i + 1]
                sorted[i + 1] = temp
                swapped = true

    sorted

fn sort_by_memory_desc(records: [ResourceUsageRecord]) -> [ResourceUsageRecord]:
    """Sort records by max_memory_mb descending (bubble sort)"""
    if records.len() <= 1:
        return records

    var sorted = records
    var swapped = true

    while swapped:
        swapped = false
        for i in (sorted.len() - 1):
            if sorted[i].max_memory_mb < sorted[i + 1].max_memory_mb:
                # Swap
                val temp = sorted[i]
                sorted[i] = sorted[i + 1]
                sorted[i + 1] = temp
                swapped = true

    sorted

# ============================================================================
# Utility Functions
# ============================================================================

fn to_int(s: text) -> i64:
    """Convert string to integer, return 0 on failure"""
    if s == "" or s == nil:
        return 0
    val result = int(s)
    result

fn to_float(s: text) -> f64:
    """Convert string to float, return 0.0 on failure"""
    if s == "" or s == nil:
        return 0.0

    # Simple float parsing
    var num_str = ""
    var has_dot = false
    for i in s.len():
        val ch = s[i:i + 1]
        if ch >= "0" and ch <= "9":
            num_str = num_str + ch
        elif ch == "." and not has_dot:
            num_str = num_str + ch
            has_dot = true
        elif ch == "-" and i == 0:
            num_str = num_str + ch
        else:
            break

    if num_str == "" or num_str == "-" or num_str == ".":
        return 0.0

    # Use integer conversion as base
    if has_dot:
        val parts = num_str.split(".")
        if parts.len() == 2:
            val int_part = to_int(parts[0])
            val frac_str = parts[1]
            val frac_val = to_int(frac_str)
            val divisor = 100.0  # Assume 2 decimal places
            int_part + (frac_val / divisor)
        else:
            to_int(num_str)
    else:
        to_int(num_str)

export ResourceUsageRecord
export calculate_resource_stats, detect_violations
export resource_db_init, resource_db_record
export resource_db_query_worst_cpu, resource_db_query_worst_memory
export resource_db_load_all
