# Set Operations Benchmarks
# Detailed performance analysis of Set<T> operations

import testing.benchmark as bench
import set
import map

# ============================================================================
# Basic Operations Benchmarks
# ============================================================================

fn benchmark_basic_operations():
    print "=== Set Basic Operations ==="
    print ""

    val benchmarks = Map.new()

    // Insert benchmarks - different sizes
    benchmarks.insert("Insert 10 elements", \:
        val s = Set.new()
        for i in 0..10:
            s.insert("item{i}")
    )

    benchmarks.insert("Insert 100 elements", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")
    )

    benchmarks.insert("Insert 1000 elements", \:
        val s = Set.with_capacity(1024)
        for i in 0..1000:
            s.insert("item{i}")
    )

    benchmarks.insert("Insert 10000 elements", \:
        val s = Set.with_capacity(16384)
        for i in 0..10000:
            s.insert("item{i}")
    )

    // Contains benchmarks
    benchmarks.insert("Contains check (100 items, hit)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")

        for i in 0..100:
            s.contains("item{i}")
    )

    benchmarks.insert("Contains check (100 items, miss)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")

        for i in 0..100:
            s.contains("missing{i}")
    )

    // Remove benchmarks
    benchmarks.insert("Remove 50% (from 100)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")

        for i in 0..50:
            s.remove("item{i}")
    )

    benchmarks.insert("Remove all (from 100)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")

        for i in 0..100:
            s.remove("item{i}")
    )

    // Run and display
    val results = bench.compare_default(benchmarks)

    for (name, stats) in results.entries():
        print "{name}:"
        print "  Mean: {bench.BenchmarkStats.format_time(stats.mean_ns)}"
        print "  Median: {bench.BenchmarkStats.format_time(stats.median_ns)}"
        print ""

# ============================================================================
# Set Operations Benchmarks (Union, Intersection, etc.)
# ============================================================================

fn benchmark_set_operations():
    print "=== Set Operations (Union, Intersection, Difference) ==="
    print ""

    val benchmarks = Map.new()

    // Union benchmarks
    benchmarks.insert("Union (50 + 50, no overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("set1_{i}")
            s2.insert("set2_{i}")

        s1.union(s2)
    )

    benchmarks.insert("Union (50 + 50, full overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i}")

        s1.union(s2)
    )

    benchmarks.insert("Union (50 + 50, 50% overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i + 25}")

        s1.union(s2)
    )

    benchmarks.insert("Union (1000 + 1000, 50% overlap)", \:
        val s1 = Set.with_capacity(2048)
        val s2 = Set.with_capacity(2048)

        for i in 0..1000:
            s1.insert("item{i}")
            s2.insert("item{i + 500}")

        s1.union(s2)
    )

    // Intersection benchmarks
    benchmarks.insert("Intersection (50 + 50, no overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("set1_{i}")
            s2.insert("set2_{i}")

        s1.intersection(s2)
    )

    benchmarks.insert("Intersection (50 + 50, full overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i}")

        s1.intersection(s2)
    )

    benchmarks.insert("Intersection (50 + 50, 50% overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i + 25}")

        s1.intersection(s2)
    )

    // Difference benchmarks
    benchmarks.insert("Difference (100 - 50, 50% overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..100:
            s1.insert("item{i}")
        for i in 0..50:
            s2.insert("item{i}")

        s1.difference(s2)
    )

    benchmarks.insert("Difference (100 - 100, full overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..100:
            s1.insert("item{i}")
            s2.insert("item{i}")

        s1.difference(s2)
    )

    // Symmetric difference
    benchmarks.insert("Symmetric Difference (50 + 50, 50% overlap)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i + 25}")

        s1.symmetric_difference(s2)
    )

    // Run and display
    val results = bench.compare_default(benchmarks)

    for (name, stats) in results.entries():
        print "{name}:"
        print "  Mean: {bench.BenchmarkStats.format_time(stats.mean_ns)}"
        print "  Median: {bench.BenchmarkStats.format_time(stats.median_ns)}"
        print ""

# ============================================================================
# Set Predicates Benchmarks
# ============================================================================

fn benchmark_set_predicates():
    print "=== Set Predicates (is_subset, is_superset, is_disjoint) ==="
    print ""

    val benchmarks = Map.new()

    // is_subset benchmarks
    benchmarks.insert("is_subset (50 subset of 100, true)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
        for i in 0..100:
            s2.insert("item{i}")

        s1.is_subset(s2)
    )

    benchmarks.insert("is_subset (50 subset of 100, false)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
        for i in 50..150:
            s2.insert("item{i}")

        s1.is_subset(s2)
    )

    // is_superset benchmarks
    benchmarks.insert("is_superset (100 superset of 50, true)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..100:
            s1.insert("item{i}")
        for i in 0..50:
            s2.insert("item{i}")

        s1.is_superset(s2)
    )

    // is_disjoint benchmarks
    benchmarks.insert("is_disjoint (50 + 50, disjoint)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("set1_{i}")
            s2.insert("set2_{i}")

        s1.is_disjoint(s2)
    )

    benchmarks.insert("is_disjoint (50 + 50, not disjoint)", \:
        val s1 = Set.new()
        val s2 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i + 25}")

        s1.is_disjoint(s2)
    )

    // Run and display
    val results = bench.compare_default(benchmarks)

    for (name, stats) in results.entries():
        print "{name}:"
        print "  Mean: {bench.BenchmarkStats.format_time(stats.mean_ns)}"
        print "  Median: {bench.BenchmarkStats.format_time(stats.median_ns)}"
        print ""

# ============================================================================
# Functional Operations Benchmarks
# ============================================================================

fn benchmark_functional_operations():
    print "=== Set Functional Operations (filter, map, any, all) ==="
    print ""

    val benchmarks = Map.new()

    // Filter benchmarks
    benchmarks.insert("Filter (100 items, 50% match)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.filter(\x: x.parse_int() % 2 == 0)
    )

    benchmarks.insert("Filter (100 items, 10% match)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.filter(\x: x.parse_int() % 10 == 0)
    )

    benchmarks.insert("Filter (1000 items, 50% match)", \:
        val s = Set.with_capacity(1024)
        for i in 0..1000:
            s.insert("{i}")

        s.filter(\x: x.parse_int() % 2 == 0)
    )

    // Map benchmarks
    benchmarks.insert("Map (100 items, unique values)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.map(\x: x.parse_int() * 2)
    )

    benchmarks.insert("Map (100 items, duplicate values)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.map(\x: x.parse_int() / 10)  // Many duplicates
    )

    // Any benchmarks
    benchmarks.insert("Any (100 items, match early)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.any(\x: x.parse_int() < 10)  // Matches early
    )

    benchmarks.insert("Any (100 items, match late)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.any(\x: x.parse_int() > 90)  // Matches late
    )

    benchmarks.insert("Any (100 items, no match)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.any(\x: x.parse_int() > 1000)  // No match
    )

    // All benchmarks
    benchmarks.insert("All (100 items, all true)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.all(\x: x.parse_int() >= 0)  // All true
    )

    benchmarks.insert("All (100 items, fail early)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("{i}")

        s.all(\x: x.parse_int() > 10)  // Fails early
    )

    // Run and display
    val results = bench.compare_default(benchmarks)

    for (name, stats) in results.entries():
        print "{name}:"
        print "  Mean: {bench.BenchmarkStats.format_time(stats.mean_ns)}"
        print "  Median: {bench.BenchmarkStats.format_time(stats.median_ns)}"
        print ""

# ============================================================================
# Utility Operations Benchmarks
# ============================================================================

fn benchmark_utility_operations():
    print "=== Set Utility Operations (clone, extend, to_list) ==="
    print ""

    val benchmarks = Map.new()

    // Clone benchmarks
    benchmarks.insert("Clone (100 items)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")

        s.clone()
    )

    benchmarks.insert("Clone (1000 items)", \:
        val s = Set.with_capacity(1024)
        for i in 0..1000:
            s.insert("item{i}")

        s.clone()
    )

    // Extend benchmarks
    benchmarks.insert("Extend (100 items, no duplicates)", \:
        val s = Set.new()
        var items = []
        for i in 0..100:
            items.append("item{i}")

        s.extend(items)
    )

    benchmarks.insert("Extend (100 items, 50% duplicates)", \:
        val s = Set.new()
        for i in 0..50:
            s.insert("item{i}")

        var items = []
        for i in 0..100:
            items.append("item{i}")

        s.extend(items)
    )

    // to_list benchmarks
    benchmarks.insert("to_list (100 items)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")

        s.to_list()
    )

    benchmarks.insert("to_list (1000 items)", \:
        val s = Set.with_capacity(1024)
        for i in 0..1000:
            s.insert("item{i}")

        s.to_list()
    )

    // for_each benchmarks
    benchmarks.insert("for_each (100 items)", \:
        val s = Set.new()
        for i in 0..100:
            s.insert("item{i}")

        var count = 0
        s.for_each(\item:
            count = count + 1
        )
    )

    // Run and display
    val results = bench.compare_default(benchmarks)

    for (name, stats) in results.entries():
        print "{name}:"
        print "  Mean: {bench.BenchmarkStats.format_time(stats.mean_ns)}"
        print "  Median: {bench.BenchmarkStats.format_time(stats.median_ns)}"
        print ""

# ============================================================================
# Helper Functions Benchmarks
# ============================================================================

fn benchmark_helper_functions():
    print "=== Set Helper Functions ==="
    print ""

    val benchmarks = Map.new()

    // set_from_list benchmarks
    benchmarks.insert("set_from_list (100 items, unique)", \:
        var items = []
        for i in 0..100:
            items.append("item{i}")

        set.set_from_list(items)
    )

    benchmarks.insert("set_from_list (100 items, 50% duplicates)", \:
        var items = []
        for i in 0..100:
            items.append("item{i % 50}")

        set.set_from_list(items)
    )

    // intersect_all benchmarks
    benchmarks.insert("intersect_all (3 sets, 50 items each)", \:
        val s1 = Set.new()
        val s2 = Set.new()
        val s3 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i + 10}")
            s3.insert("item{i + 20}")

        set.intersect_all([s1, s2, s3])
    )

    benchmarks.insert("intersect_all (5 sets, 100 items each)", \:
        var sets = []
        for j in 0..5:
            val s = Set.new()
            for i in 0..100:
                s.insert("item{i + j * 20}")
            sets.append(s)

        set.intersect_all(sets)
    )

    // union_all benchmarks
    benchmarks.insert("union_all (3 sets, 50 items each)", \:
        val s1 = Set.new()
        val s2 = Set.new()
        val s3 = Set.new()

        for i in 0..50:
            s1.insert("item{i}")
            s2.insert("item{i + 25}")
            s3.insert("item{i + 50}")

        set.union_all([s1, s2, s3])
    )

    benchmarks.insert("union_all (5 sets, 100 items each)", \:
        var sets = []
        for j in 0..5:
            val s = Set.new()
            for i in 0..100:
                s.insert("item{i + j * 50}")
            sets.append(s)

        set.union_all(sets)
    )

    // Run and display
    val results = bench.compare_default(benchmarks)

    for (name, stats) in results.entries():
        print "{name}:"
        print "  Mean: {bench.BenchmarkStats.format_time(stats.mean_ns)}"
        print "  Median: {bench.BenchmarkStats.format_time(stats.median_ns)}"
        print ""

# ============================================================================
# Scalability Analysis
# ============================================================================

fn benchmark_scalability():
    print "=== Set Scalability Analysis ==="
    print ""

    val sizes = [10, 100, 1000, 10000]

    for size in sizes:
        print "Size: {size} items"

        // Insert scalability
        val insert_stats = bench.benchmark_default(
            "Insert {size}",
            \:
                val capacity = size * 2
                val s = Set.with_capacity(capacity)
                for i in 0..size:
                    s.insert("item{i}")
        )
        print "  Insert: {bench.BenchmarkStats.format_time(insert_stats.mean_ns)}"

        // Contains scalability
        val contains_stats = bench.benchmark_default(
            "Contains {size}",
            \:
                val s = Set.with_capacity(size * 2)
                for i in 0..size:
                    s.insert("item{i}")

                for i in 0..size:
                    s.contains("item{i}")
        )
        print "  Contains: {bench.BenchmarkStats.format_time(contains_stats.mean_ns)}"

        // Union scalability
        val union_stats = bench.benchmark_default(
            "Union {size}",
            \:
                val s1 = Set.with_capacity(size)
                val s2 = Set.with_capacity(size)

                for i in 0..(size / 2):
                    s1.insert("item{i}")
                    s2.insert("item{i + size / 4}")

                s1.union(s2)
        )
        print "  Union: {bench.BenchmarkStats.format_time(union_stats.mean_ns)}"

        print ""

# ============================================================================
# Main Entry Point
# ============================================================================

fn main():
    print "Set Operations Performance Benchmarks"
    print "=" .repeat(70)
    print ""

    benchmark_basic_operations()
    print "=" .repeat(70)
    print ""

    benchmark_set_operations()
    print "=" .repeat(70)
    print ""

    benchmark_set_predicates()
    print "=" .repeat(70)
    print ""

    benchmark_functional_operations()
    print "=" .repeat(70)
    print ""

    benchmark_utility_operations()
    print "=" .repeat(70)
    print ""

    benchmark_helper_functions()
    print "=" .repeat(70)
    print ""

    benchmark_scalability()
    print "=" .repeat(70)
    print ""

    print "Set operations benchmarking complete! ðŸŽ‰"
