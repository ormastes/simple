# Quadtree Split and Quadrant Operations

from "std/quadtree/types" import bounds_min_x, bounds_min_y, bounds_max_x, bounds_max_y, bounds_center_x, bounds_center_y, bounds_new, node_bounds, node_capacity, node_points, node_new_leaf, node_new_internal, point_x, point_y, point_equals

# === Quadrant Operations ===

fn quadrant_nw_bounds(bounds):
    # Get northwest quadrant bounds
    val min_x = bounds_min_x(bounds)
    val min_y = bounds_min_y(bounds)
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    bounds_new(min_x, min_y, cx, cy)

fn quadrant_ne_bounds(bounds):
    # Get northeast quadrant bounds
    val cx = bounds_center_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_x = bounds_max_x(bounds)
    val cy = bounds_center_y(bounds)
    bounds_new(cx, min_y, max_x, cy)

fn quadrant_sw_bounds(bounds):
    # Get southwest quadrant bounds
    val min_x = bounds_min_x(bounds)
    val cy = bounds_center_y(bounds)
    val cx = bounds_center_x(bounds)
    val max_y = bounds_max_y(bounds)
    bounds_new(min_x, cy, cx, max_y)

fn quadrant_se_bounds(bounds):
    # Get southeast quadrant bounds
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    val max_x = bounds_max_x(bounds)
    val max_y = bounds_max_y(bounds)
    bounds_new(cx, cy, max_x, max_y)

fn quadrant_for_point(bounds, point):
    # Determine which quadrant a point belongs to (0=NW, 1=NE, 2=SW, 3=SE)
    val x = point_x(point)
    val y = point_y(point)
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    val is_west = x < cx
    val is_north = y < cy

    if is_north and is_west:
        0  # NW
    else:
        if is_north:
            1  # NE
        else:
            if is_west:
                2  # SW
            else:
                3  # SE

fn node_subdivide(node):
    # Subdivide a leaf node into four children
    val bounds = node_bounds(node)
    val capacity = node_capacity(node)
    val points = node_points(node)

    # Create four child nodes
    val nw_bounds = quadrant_nw_bounds(bounds)
    val ne_bounds = quadrant_ne_bounds(bounds)
    val sw_bounds = quadrant_sw_bounds(bounds)
    val se_bounds = quadrant_se_bounds(bounds)

    var nw = node_new_leaf(nw_bounds, capacity)
    var ne = node_new_leaf(ne_bounds, capacity)
    var sw = node_new_leaf(sw_bounds, capacity)
    var se = node_new_leaf(se_bounds, capacity)

    # Redistribute points to children
    var i = 0
    val point_count = len(points)
    while i < point_count:
        val point = points[i]
        val quadrant = quadrant_for_point(bounds, point)
        if quadrant == 0:
            nw = node_insert_point(nw, point)
        else:
            if quadrant == 1:
                ne = node_insert_point(ne, point)
            else:
                if quadrant == 2:
                    sw = node_insert_point(sw, point)
                else:
                    se = node_insert_point(se, point)
        i = i + 1

    # Create internal node
    node_new_internal(bounds, nw, ne, sw, se)
