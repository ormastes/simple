# Cryptographically Secure Random Number Generation Utilities
#
# This module provides a comprehensive CSPRNG (Cryptographically Secure
# Pseudo-Random Number Generator) implementation based on ChaCha20 stream cipher.
#
# SECURITY PROPERTIES:
# - Unpredictability: Cannot predict future outputs from past outputs
# - Backtracking resistance: Past outputs don't reveal previous state
# - Forward secrecy: Compromise of state doesn't reveal past outputs
# - Uniform distribution: All values equally likely
#
# IMPLEMENTATION:
# - ChaCha20 stream cipher as core CSPRNG
# - Automatic entropy collection and reseeding
# - Fortuna-inspired multi-pool design
# - Constant-time operations where possible
#
# NOTE: Pure Simple implementation - no FFI or system calls
# Uses timestamps and execution state for entropy

import "platform" as Platform

# =============================================================================
# CONSTANTS
# =============================================================================

# ChaCha20 constants: "expand 32-byte k" in little-endian
val CHACHA_CONST_0 = 0x61707865  # "expa"
val CHACHA_CONST_1 = 0x3320646e  # "nd 3"
val CHACHA_CONST_2 = 0x79622d32  # "2-by"
val CHACHA_CONST_3 = 0x6b206574  # "te k"

# Reseed threshold: reseed after this many bytes generated
val RESEED_THRESHOLD = 1048576  # 1 MB

# Number of entropy pools for Fortuna-style design
val NUM_ENTROPY_POOLS = 32

# ChaCha20 rounds (20 rounds = 10 double-rounds)
val CHACHA_ROUNDS = 20

# =============================================================================
# GLOBAL STATE
# =============================================================================

# Global CSPRNG state - initialized on first use
# Structure: (key: list[8], counter: i64, pool: list, reseed_count: i64,
#             bytes_generated: i64, initialized: bool)
var global_csprng_state = nil

# Entropy pools for Fortuna-style entropy accumulation
# Structure: list of 32 pools, each pool is a list of integers
var entropy_pools = nil

# Pool reseed counters - tracks which pools have been used
var pool_reseed_counter = 0

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Rotate left (circular left shift)
fn rotate_left(value: i64, bits: i64) -> i64:
    # Ensure value is treated as unsigned 32-bit
    var v = value & 0xFFFFFFFF
    var b = bits & 31  # Modulo 32
    var left = (v << b) & 0xFFFFFFFF
    var right = v >> (32 - b)
    (left | right) & 0xFFFFFFFF

# Convert bytes list to hex string
fn bytes_to_hex(bytes: list) -> text:
    var result = ""
    var i = 0
    while i < bytes.length():
        var byte_val = bytes.get(i)
        var high = (byte_val >> 4) & 0x0F
        var low = byte_val & 0x0F
        var hex_chars = "0123456789abcdef"
        var high_char = hex_chars.get(high)
        var low_char = hex_chars.get(low)
        result = result + high_char + low_char
        i = i + 1
    result

# Convert hex string to bytes list
fn hex_to_bytes(hex: text) -> list:
    var result = []
    var i = 0
    var len = hex.length()
    while i < len:
        if i + 1 >= len:
            break
        var high_char = hex.get(i)
        var low_char = hex.get(i + 1)
        var high = hex_char_to_int(high_char)
        var low = hex_char_to_int(low_char)
        if high >= 0:
            if low >= 0:
                var byte_val = (high << 4) | low
                result.append(byte_val)
        i = i + 2
    result

# Convert hex character to integer
fn hex_char_to_int(c: text) -> i64:
    if c >= "0":
        if c <= "9":
            return c.char_at(0) - 48  # '0' = 48
    if c >= "a":
        if c <= "f":
            return c.char_at(0) - 97 + 10  # 'a' = 97
    if c >= "A":
        if c <= "F":
            return c.char_at(0) - 65 + 10  # 'A' = 65
    -1

# XOR two byte arrays
fn xor_bytes(a: list, b: list) -> list:
    var result = []
    var len = a.length()
    var i = 0
    while i < len:
        if i < b.length():
            var xor_val = a.get(i) ^ b.get(i)
            result.append(xor_val & 0xFF)
        else:
            result.append(a.get(i) & 0xFF)
        i = i + 1
    result

# Constant-time comparison (timing-safe)
fn constant_time_compare(a: list, b: list) -> bool:
    if a.length() != b.length():
        return false
    var diff = 0
    var i = 0
    while i < a.length():
        var a_val = a.get(i)
        var b_val = b.get(i)
        diff = diff | (a_val ^ b_val)
        i = i + 1
    diff == 0

# Convert 4 bytes to 32-bit integer (little-endian)
fn bytes_to_u32_le(bytes: list, offset: i64) -> i64:
    var b0 = bytes.get(offset) & 0xFF
    var b1 = bytes.get(offset + 1) & 0xFF
    var b2 = bytes.get(offset + 2) & 0xFF
    var b3 = bytes.get(offset + 3) & 0xFF
    (b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)) & 0xFFFFFFFF

# Convert 32-bit integer to 4 bytes (little-endian)
fn u32_to_bytes_le(value: i64) -> list:
    var result = []
    result.append(value & 0xFF)
    result.append((value >> 8) & 0xFF)
    result.append((value >> 16) & 0xFF)
    result.append((value >> 24) & 0xFF)
    result

# =============================================================================
# ENTROPY COLLECTION
# =============================================================================

# Initialize entropy pools
fn init_entropy_pools():
    if entropy_pools == nil:
        entropy_pools = []
        var i = 0
        while i < NUM_ENTROPY_POOLS:
            entropy_pools.append([])
            i = i + 1

# Collect entropy from timestamp
fn collect_time_entropy() -> list:
    var timestamp = Platform.get_timestamp_ms()
    var entropy = []
    # Break timestamp into bytes
    var i = 0
    while i < 8:
        var byte_val = (timestamp >> (i * 8)) & 0xFF
        entropy.append(byte_val)
        i = i + 1
    entropy

# Collect entropy from execution state
fn collect_execution_entropy() -> list:
    var entropy = []
    # Use timestamp as primary source
    var time_bytes = collect_time_entropy()
    var i = 0
    while i < time_bytes.length():
        entropy.append(time_bytes.get(i))
        i = i + 1
    # Add some variation based on timestamp
    var timestamp = Platform.get_timestamp_ms()
    var mix = timestamp
    var j = 0
    while j < 8:
        var byte_val = (mix >> (j * 8)) & 0xFF
        mix = (mix * 6364136223846793005 + 1442695040888963407) & 0xFFFFFFFFFFFFFFFF
        entropy.append(byte_val)
        j = j + 1
    entropy

# Mix entropy using simple hash function
fn mix_entropy(data: list) -> list:
    var result = []
    var hash = 2166136261  # FNV offset basis
    var i = 0
    while i < data.length():
        var byte_val = data.get(i)
        hash = hash ^ byte_val
        hash = (hash * 16777619) & 0xFFFFFFFF
        i = i + 1
    # Generate 32 bytes from hash
    var j = 0
    while j < 32:
        result.append(hash & 0xFF)
        hash = (hash * 1103515245 + 12345) & 0xFFFFFFFF
        j = j + 1
    result

# Add entropy to a specific pool
fn add_entropy_to_pool(pool_index: i64, data: list):
    init_entropy_pools()
    if pool_index >= 0:
        if pool_index < NUM_ENTROPY_POOLS:
            var pool = entropy_pools.get(pool_index)
            var i = 0
            while i < data.length():
                pool.append(data.get(i))
                i = i + 1

# Add entropy to pools (round-robin distribution)
fn add_entropy(data: list):
    init_entropy_pools()
    var pool_index = pool_reseed_counter % NUM_ENTROPY_POOLS
    add_entropy_to_pool(pool_index, data)
    pool_reseed_counter = pool_reseed_counter + 1

# Get entropy from pools for reseeding
fn get_reseed_entropy() -> list:
    init_entropy_pools()
    var entropy = []
    # Determine which pools to use based on reseed counter
    var reseed_count = pool_reseed_counter / NUM_ENTROPY_POOLS
    var i = 0
    while i < NUM_ENTROPY_POOLS:
        # Use pool i if 2^i divides reseed_count
        var use_pool = false
        if i == 0:
            use_pool = true
        else:
            var divisor = 1 << i
            use_pool = (reseed_count % divisor) == 0
        if use_pool:
            var pool = entropy_pools.get(i)
            var j = 0
            while j < pool.length():
                entropy.append(pool.get(j))
                j = j + 1
            # Clear pool after use
            entropy_pools.set(i, [])
        i = i + 1
    # Add fresh entropy
    var fresh = collect_execution_entropy()
    var k = 0
    while k < fresh.length():
        entropy.append(fresh.get(k))
        k = k + 1
    # Mix all entropy
    mix_entropy(entropy)

# =============================================================================
# CHACHA20 IMPLEMENTATION
# =============================================================================

# ChaCha20 quarter round
# Operates on 4 words of state: a, b, c, d
fn chacha20_quarter_round(state: list, a: i64, b: i64, c: i64, d: i64):
    # a += b; d ^= a; d <<<= 16
    var val_a = state.get(a)
    var val_b = state.get(b)
    var val_c = state.get(c)
    var val_d = state.get(d)
    val_a = (val_a + val_b) & 0xFFFFFFFF
    state.set(a, val_a)
    val_d = val_d ^ val_a
    val_d = rotate_left(val_d, 16)
    state.set(d, val_d)
    # c += d; b ^= c; b <<<= 12
    val_c = (val_c + val_d) & 0xFFFFFFFF
    state.set(c, val_c)
    val_b = val_b ^ val_c
    val_b = rotate_left(val_b, 12)
    state.set(b, val_b)
    # a += b; d ^= a; d <<<= 8
    val_a = state.get(a)
    val_a = (val_a + val_b) & 0xFFFFFFFF
    state.set(a, val_a)
    val_d = state.get(d)
    val_d = val_d ^ val_a
    val_d = rotate_left(val_d, 8)
    state.set(d, val_d)
    # c += d; b ^= c; b <<<= 7
    val_c = state.get(c)
    val_c = (val_c + val_d) & 0xFFFFFFFF
    state.set(c, val_c)
    val_b = state.get(b)
    val_b = val_b ^ val_c
    val_b = rotate_left(val_b, 7)
    state.set(b, val_b)

# ChaCha20 block function
# Generate 64 bytes from key (32 bytes), nonce (12 bytes), counter (4 bytes)
fn chacha20_block(key: list, nonce: list, counter: i64) -> list:
    # Initialize state (16 words = 64 bytes)
    var state = []
    # Constants
    state.append(CHACHA_CONST_0)
    state.append(CHACHA_CONST_1)
    state.append(CHACHA_CONST_2)
    state.append(CHACHA_CONST_3)
    # Key (8 words)
    var i = 0
    while i < 8:
        if i < key.length():
            state.append(key.get(i) & 0xFFFFFFFF)
        else:
            state.append(0)
        i = i + 1
    # Counter (1 word)
    state.append(counter & 0xFFFFFFFF)
    # Nonce (3 words)
    var j = 0
    while j < 3:
        if j < nonce.length():
            state.append(nonce.get(j) & 0xFFFFFFFF)
        else:
            state.append(0)
        j = j + 1
    # Save initial state
    var initial_state = []
    var k = 0
    while k < 16:
        initial_state.append(state.get(k))
        k = k + 1
    # 20 rounds (10 double-rounds)
    var round = 0
    while round < CHACHA_ROUNDS:
        if round % 2 == 0:
            # Column rounds
            chacha20_quarter_round(state, 0, 4, 8, 12)
            chacha20_quarter_round(state, 1, 5, 9, 13)
            chacha20_quarter_round(state, 2, 6, 10, 14)
            chacha20_quarter_round(state, 3, 7, 11, 15)
        else:
            # Diagonal rounds
            chacha20_quarter_round(state, 0, 5, 10, 15)
            chacha20_quarter_round(state, 1, 6, 11, 12)
            chacha20_quarter_round(state, 2, 7, 8, 13)
            chacha20_quarter_round(state, 3, 4, 9, 14)
        round = round + 1
    # Add initial state
    var m = 0
    while m < 16:
        var val = state.get(m)
        var init_val = initial_state.get(m)
        state.set(m, (val + init_val) & 0xFFFFFFFF)
        m = m + 1
    # Convert to bytes (little-endian)
    var output = []
    var n = 0
    while n < 16:
        var word = state.get(n)
        var bytes = u32_to_bytes_le(word)
        var p = 0
        while p < 4:
            output.append(bytes.get(p))
            p = p + 1
        n = n + 1
    output

# =============================================================================
# CSPRNG STATE MANAGEMENT
# =============================================================================

# Initialize CSPRNG state
fn init_csprng_state():
    if global_csprng_state == nil:
        # Collect initial entropy
        init_entropy_pools()
        var entropy = collect_execution_entropy()
        add_entropy(entropy)
        var more_entropy = collect_time_entropy()
        add_entropy(more_entropy)
        # Get seed material
        var seed = get_reseed_entropy()
        # Generate key from seed (8 words = 32 bytes)
        var key = []
        var i = 0
        while i < 8:
            if i * 4 < seed.length():
                var word = bytes_to_u32_le(seed, i * 4)
                key.append(word)
            else:
                key.append(0)
            i = i + 1
        # Initialize state
        # Structure: (key, counter, pool, reseed_count, bytes_generated, initialized)
        global_csprng_state = (key, 0, [], 0, 0, true)

# Get current CSPRNG state
fn get_csprng_state():
    init_csprng_state()
    global_csprng_state

# Reseed CSPRNG if needed
fn reseed_if_needed(state):
    var bytes_generated = state.4
    if bytes_generated >= RESEED_THRESHOLD:
        reseed_csprng(state)

# Force reseed CSPRNG
fn reseed_csprng(state):
    # Collect fresh entropy
    var entropy = collect_execution_entropy()
    add_entropy(entropy)
    var more_entropy = collect_time_entropy()
    add_entropy(more_entropy)
    # Get reseed material
    var reseed_data = get_reseed_entropy()
    # Mix with current key
    var old_key = state.0
    var new_key = []
    var i = 0
    while i < 8:
        var old_word = 0
        if i < old_key.length():
            old_word = old_key.get(i)
        var new_word = 0
        if i * 4 < reseed_data.length():
            new_word = bytes_to_u32_le(reseed_data, i * 4)
        new_key.append((old_word ^ new_word) & 0xFFFFFFFF)
        i = i + 1
    # Update state
    var counter = state.1
    var pool = state.2
    var reseed_count = state.3
    global_csprng_state = (new_key, counter, pool, reseed_count + 1, 0, true)

# =============================================================================
# RANDOM BYTES GENERATION
# =============================================================================

# Generate n random bytes
fn secure_random_bytes(n: i64) -> list:
    init_csprng_state()
    var state = get_csprng_state()
    var result = []
    var bytes_needed = n
    var counter = state.1
    var key = state.0
    # Fixed nonce (could be enhanced with state-based nonce)
    var nonce = [0x12345678, 0x9ABCDEF0, 0x13579BDF]
    while bytes_needed > 0:
        # Generate block
        var block = chacha20_block(key, nonce, counter)
        counter = counter + 1
        # Take bytes from block
        var i = 0
        while i < block.length():
            if bytes_needed > 0:
                result.append(block.get(i))
                bytes_needed = bytes_needed - 1
            i = i + 1
    # Update state
    var pool = state.2
    var reseed_count = state.3
    var bytes_generated = state.4 + n
    global_csprng_state = (key, counter, pool, reseed_count, bytes_generated, true)
    # Check if reseed needed
    reseed_if_needed(global_csprng_state)
    result

# Fill buffer with random bytes
fn fill_random_bytes(buffer: list, n: i64):
    var random_bytes = secure_random_bytes(n)
    var i = 0
    while i < n:
        if i < buffer.length():
            buffer.set(i, random_bytes.get(i))
        else:
            buffer.append(random_bytes.get(i))
        i = i + 1

# =============================================================================
# RANDOM INTEGERS
# =============================================================================

# Generate random u32 (0 to 2^32-1)
fn secure_random_u32() -> i64:
    var bytes = secure_random_bytes(4)
    bytes_to_u32_le(bytes, 0)

# Generate random u64 (0 to 2^64-1)
fn secure_random_u64() -> i64:
    var bytes = secure_random_bytes(8)
    var low = bytes_to_u32_le(bytes, 0)
    var high = bytes_to_u32_le(bytes, 4)
    (high << 32) | low

# Generate random integer in range [min, max] (inclusive)
fn secure_random_int(min: i64, max: i64) -> i64:
    if min >= max:
        return min
    var range = max - min + 1
    # Use rejection sampling to avoid bias
    var bytes_needed = 4
    if range > 0xFFFFFFFF:
        bytes_needed = 8
    var max_valid = 0xFFFFFFFF
    if bytes_needed == 8:
        max_valid = 0xFFFFFFFFFFFFFFFF
    var limit = max_valid - (max_valid % range)
    var attempts = 0
    while attempts < 1000:
        var rand_val = 0
        if bytes_needed == 4:
            rand_val = secure_random_u32()
        else:
            rand_val = secure_random_u64()
        if rand_val < limit:
            return min + (rand_val % range)
        attempts = attempts + 1
    # Fallback if rejection sampling fails (very unlikely)
    var fallback = secure_random_u32()
    min + (fallback % range)

# =============================================================================
# RANDOM FLOATS
# =============================================================================

# Generate random float in [0.0, 1.0)
fn secure_random_float() -> f64:
    var rand = secure_random_u32()
    var divisor = 4294967296.0  # 2^32
    rand / divisor

# Generate random float in [min, max)
fn secure_random_range(min: f64, max: f64) -> f64:
    var rand = secure_random_float()
    min + rand * (max - min)

# Generate random double (higher precision)
fn secure_random_double() -> f64:
    var high = secure_random_u32()
    var low = secure_random_u32()
    var combined = (high << 20) | (low >> 12)
    var divisor = 9007199254740992.0  # 2^53
    combined / divisor

# =============================================================================
# RANDOM CHOICE AND SAMPLING
# =============================================================================

# Choose random element from list
fn secure_choice(items: list):
    if items.length() == 0:
        return nil
    var index = secure_random_int(0, items.length() - 1)
    items.get(index)

# Sample n elements from list (without replacement)
fn secure_sample(items: list, n: i64) -> list:
    if n >= items.length():
        return secure_shuffle(items)
    # Create copy of items
    var remaining = []
    var i = 0
    while i < items.length():
        remaining.append(items.get(i))
        i = i + 1
    # Sample n items
    var result = []
    var count = 0
    while count < n:
        if remaining.length() == 0:
            break
        var index = secure_random_int(0, remaining.length() - 1)
        result.append(remaining.get(index))
        # Remove selected item
        var new_remaining = []
        var j = 0
        while j < remaining.length():
            if j != index:
                new_remaining.append(remaining.get(j))
            j = j + 1
        remaining = new_remaining
        count = count + 1
    result

# Shuffle list (Fisher-Yates shuffle)
fn secure_shuffle(items: list) -> list:
    # Create copy
    var result = []
    var i = 0
    while i < items.length():
        result.append(items.get(i))
        i = i + 1
    # Shuffle
    var n = result.length()
    var j = n - 1
    while j > 0:
        var k = secure_random_int(0, j)
        # Swap j and k
        var temp = result.get(j)
        result.set(j, result.get(k))
        result.set(k, temp)
        j = j - 1
    result

# =============================================================================
# UUID GENERATION
# =============================================================================

# Generate UUID v4 (random UUID)
fn generate_uuid_v4() -> text:
    var bytes = secure_random_bytes(16)
    # Set version (4) and variant (RFC 4122)
    bytes.set(6, (bytes.get(6) & 0x0F) | 0x40)  # Version 4
    bytes.set(8, (bytes.get(8) & 0x3F) | 0x80)  # Variant 10
    # Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    var hex = bytes_to_hex(bytes)
    var part1 = hex.substring(0, 8)
    var part2 = hex.substring(8, 12)
    var part3 = hex.substring(12, 16)
    var part4 = hex.substring(16, 20)
    var part5 = hex.substring(20, 32)
    part1 + "-" + part2 + "-" + part3 + "-" + part4 + "-" + part5

# Generate UUID as hex string (no dashes)
fn generate_uuid_hex() -> text:
    var bytes = secure_random_bytes(16)
    bytes_to_hex(bytes)

# =============================================================================
# TOKEN GENERATION
# =============================================================================

# Generate random token (raw bytes)
fn generate_token(length: i64) -> list:
    secure_random_bytes(length)

# Generate hex token
fn generate_hex_token(length: i64) -> text:
    var bytes = secure_random_bytes(length)
    bytes_to_hex(bytes)

# Generate base64 token
fn generate_base64_token(length: i64) -> text:
    var bytes = secure_random_bytes(length)
    bytes_to_base64(bytes)

# Convert bytes to base64
fn bytes_to_base64(bytes: list) -> text:
    var base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""
    var i = 0
    var len = bytes.length()
    while i < len:
        var b1 = bytes.get(i)
        var b2 = 0
        var b3 = 0
        if i + 1 < len:
            b2 = bytes.get(i + 1)
        if i + 2 < len:
            b3 = bytes.get(i + 2)
        var n = (b1 << 16) | (b2 << 8) | b3
        var c1 = (n >> 18) & 0x3F
        var c2 = (n >> 12) & 0x3F
        var c3 = (n >> 6) & 0x3F
        var c4 = n & 0x3F
        result = result + base64_chars.get(c1)
        result = result + base64_chars.get(c2)
        if i + 1 < len:
            result = result + base64_chars.get(c3)
        else:
            result = result + "="
        if i + 2 < len:
            result = result + base64_chars.get(c4)
        else:
            result = result + "="
        i = i + 3
    result

# =============================================================================
# PASSWORD GENERATION
# =============================================================================

# Generate password with custom character set
fn generate_password(length: i64, charset: text) -> text:
    var result = ""
    var charset_len = charset.length()
    if charset_len == 0:
        return result
    var i = 0
    while i < length:
        var index = secure_random_int(0, charset_len - 1)
        var c = charset.get(index)
        result = result + c
        i = i + 1
    result

# Generate secure password (mixed case, digits, symbols)
fn generate_secure_password(length: i64) -> text:
    var lowercase = "abcdefghijklmnopqrstuvwxyz"
    var uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    var digits = "0123456789"
    var symbols = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    var all_chars = lowercase + uppercase + digits + symbols
    # Ensure at least one of each type
    var result = ""
    if length >= 4:
        var idx1 = secure_random_int(0, lowercase.length() - 1)
        result = result + lowercase.get(idx1)
        var idx2 = secure_random_int(0, uppercase.length() - 1)
        result = result + uppercase.get(idx2)
        var idx3 = secure_random_int(0, digits.length() - 1)
        result = result + digits.get(idx3)
        var idx4 = secure_random_int(0, symbols.length() - 1)
        result = result + symbols.get(idx4)
        # Fill remaining with random chars
        var remaining = length - 4
        var i = 0
        while i < remaining:
            var idx = secure_random_int(0, all_chars.length() - 1)
            result = result + all_chars.get(idx)
            i = i + 1
        # Shuffle result
        var chars = []
        var j = 0
        while j < result.length():
            chars.append(result.get(j))
            j = j + 1
        var shuffled = secure_shuffle(chars)
        result = ""
        var k = 0
        while k < shuffled.length():
            result = result + shuffled.get(k)
            k = k + 1
    else:
        result = generate_password(length, all_chars)
    result

# Generate alphanumeric password
fn generate_alphanumeric_password(length: i64) -> text:
    var charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    generate_password(length, charset)

# Generate PIN (numeric only)
fn generate_pin(length: i64) -> text:
    generate_password(length, "0123456789")

# =============================================================================
# ADDITIONAL UTILITIES
# =============================================================================

# Generate random boolean
fn secure_random_bool() -> bool:
    var rand = secure_random_u32()
    (rand & 1) == 1

# Generate random byte
fn secure_random_byte() -> i64:
    var bytes = secure_random_bytes(1)
    bytes.get(0) & 0xFF

# Generate random bytes as hex string
fn secure_random_hex(n: i64) -> text:
    var bytes = secure_random_bytes(n)
    bytes_to_hex(bytes)

# Generate random alphanumeric string
fn secure_random_alnum(length: i64) -> text:
    var charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    generate_password(length, charset)

# Generate random lowercase string
fn secure_random_lowercase(length: i64) -> text:
    generate_password(length, "abcdefghijklmnopqrstuvwxyz")

# Generate random uppercase string
fn secure_random_uppercase(length: i64) -> text:
    generate_password(length, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")

# Generate random digit string
fn secure_random_digits(length: i64) -> text:
    generate_password(length, "0123456789")

# Weighted random choice
fn secure_weighted_choice(items: list, weights: list):
    if items.length() != weights.length():
        return nil
    if items.length() == 0:
        return nil
    # Calculate total weight
    var total = 0.0
    var i = 0
    while i < weights.length():
        total = total + weights.get(i)
        i = i + 1
    if total <= 0.0:
        return nil
    # Generate random value in [0, total)
    var rand = secure_random_float() * total
    # Find corresponding item
    var cumulative = 0.0
    var j = 0
    while j < items.length():
        cumulative = cumulative + weights.get(j)
        if rand < cumulative:
            return items.get(j)
        j = j + 1
    # Fallback to last item
    items.get(items.length() - 1)

# Generate random permutation of integers [0, n)
fn secure_random_permutation(n: i64) -> list:
    var items = []
    var i = 0
    while i < n:
        items.append(i)
        i = i + 1
    secure_shuffle(items)

# Generate random subset (each element included with probability p)
fn secure_random_subset(items: list, probability: f64) -> list:
    var result = []
    var i = 0
    while i < items.length():
        var rand = secure_random_float()
        if rand < probability:
            result.append(items.get(i))
        i = i + 1
    result

# =============================================================================
# INFORMATION AND DIAGNOSTICS
# =============================================================================

# Get CSPRNG statistics
fn get_csprng_stats():
    init_csprng_state()
    var state = get_csprng_state()
    var reseed_count = state.3
    var bytes_generated = state.4
    (reseed_count, bytes_generated)

# Reset CSPRNG (for testing only - not recommended in production)
fn reset_csprng():
    global_csprng_state = nil
    entropy_pools = nil
    pool_reseed_counter = 0

# Check if CSPRNG is initialized
fn is_csprng_initialized() -> bool:
    if global_csprng_state == nil:
        return false
    var state = global_csprng_state
    state.5

# Get entropy pool sizes
fn get_entropy_pool_sizes() -> list:
    init_entropy_pools()
    var sizes = []
    var i = 0
    while i < NUM_ENTROPY_POOLS:
        var pool = entropy_pools.get(i)
        sizes.append(pool.length())
        i = i + 1
    sizes

# Add custom entropy to CSPRNG
fn add_custom_entropy(data: text):
    var bytes = []
    var i = 0
    while i < data.length():
        var c = data.char_at(i)
        bytes.append(c & 0xFF)
        i = i + 1
    add_entropy(bytes)

# Force immediate reseed
fn force_reseed():
    init_csprng_state()
    reseed_csprng(get_csprng_state())

# =============================================================================
# EXPORT PUBLIC API
# =============================================================================

# Main random bytes generation
export secure_random_bytes
export fill_random_bytes

# Random integers
export secure_random_u32
export secure_random_u64
export secure_random_int

# Random floats
export secure_random_float
export secure_random_range
export secure_random_double

# Random choice and sampling
export secure_choice
export secure_sample
export secure_shuffle

# UUID generation
export generate_uuid_v4
export generate_uuid_hex

# Token generation
export generate_token
export generate_hex_token
export generate_base64_token

# Password generation
export generate_password
export generate_secure_password
export generate_alphanumeric_password
export generate_pin

# Utility functions
export bytes_to_hex
export hex_to_bytes
export xor_bytes
export constant_time_compare

# Additional random utilities
export secure_random_bool
export secure_random_byte
export secure_random_hex
export secure_random_alnum
export secure_random_lowercase
export secure_random_uppercase
export secure_random_digits

# Advanced random operations
export secure_weighted_choice
export secure_random_permutation
export secure_random_subset

# State management
export add_custom_entropy
export force_reseed
export get_csprng_stats
export reset_csprng
export is_csprng_initialized
export get_entropy_pool_sizes

# ChaCha20 core (for advanced users)
export chacha20_block

# Utility conversions
export bytes_to_base64
export bytes_to_u32_le
export u32_to_bytes_le
export rotate_left
