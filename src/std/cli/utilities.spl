# CLI Utilities Module
# Miscellaneous utility functions

# =============================================================================
# Interactive Prompts
# =============================================================================

# Simple text prompt
fn prompt(message: text) -> text:
    print "{message}"
    readln()

# Yes/no prompt (returns true for yes, false for no)
fn prompt_yes_no(message: text) -> bool:
    val response = prompt("{message} (y/n): ")
    val lower = to_lower(response)
    lower == "y"

# Choice prompt (returns index of selected choice)
fn prompt_choice(message: text, choices: list) -> i64:
    print "{message}"
    var i = 0
    while i < len(choices):
        val choice = choices[i]
        val num = i + 1
        print "  {num}. {choice}"
        i = i + 1

    val response = prompt("Enter choice (1-{len(choices)}): ")
    val choice_num = parse_int_or_zero(response)
    choice_num - 1

# Password prompt (note: Simple doesn't support hidden input)
fn prompt_password(message: text) -> text:
    print "{message} (warning: will be visible)"
    readln()

# Confirm password prompt
fn prompt_confirm_password(message: text) -> text:
    val pass1 = prompt_password(message)
    val pass2 = prompt_password("Confirm password: ")
    if pass1 == pass2:
        return pass1
    print_error("Passwords do not match")
    ""

# Multi-select prompt
fn prompt_multi_select(message: text, choices: list) -> list:
    print "{message}"
    print "(Enter numbers separated by spaces, or 'all' for all choices)"
    var i = 0
    while i < len(choices):
        val choice = choices[i]
        val num = i + 1
        print "  {num}. {choice}"
        i = i + 1

    val response = prompt("Enter choices: ")
    if response == "all":
        return choices

    val selected_nums = split_by_space(response)
    var selected = []
    var j = 0
    while j < len(selected_nums):
        val num_str = selected_nums[j]
        val num = parse_int_or_zero(num_str)
        val index = num - 1
        if index >= 0:
            if index < len(choices):
                selected = selected + [choices[index]]
        j = j + 1

    selected

fn to_lower(text: text) -> text:
    var result = ""
    var i = 0
    while i < len(text):
        val ch = substring(text, i, i + 1)
        if ch == "Y":
            result = "{result}y"
        else:
            if ch == "N":
                result = "{result}n"
            else:
                result = "{result}{ch}"
        i = i + 1
    result

fn parse_int_or_zero(text: text) -> i64:
    # Simple integer parsing (positive numbers only)
    var result = 0
    var i = 0
    while i < len(text):
        val ch = substring(text, i, i + 1)
        if ch == "0":
            result = result * 10 + 0
        else:
            if ch == "1":
                result = result * 10 + 1
            else:
                if ch == "2":
                    result = result * 10 + 2
                else:
                    if ch == "3":
                        result = result * 10 + 3
                    else:
                        if ch == "4":
                            result = result * 10 + 4
                        else:
                            if ch == "5":
                                result = result * 10 + 5
                            else:
                                if ch == "6":
                                    result = result * 10 + 6
                                else:
                                    if ch == "7":
                                        result = result * 10 + 7
                                    else:
                                        if ch == "8":
                                            result = result * 10 + 8
                                        else:
                                            if ch == "9":
                                                result = result * 10 + 9
        i = i + 1
    result

# =============================================================================
# Input Validation
# =============================================================================

# Check if input is a valid integer
fn is_integer_input(text: text) -> bool:
    if len(text) == 0:
        return false
    var i = 0
    var is_valid = true
    while i < len(text):
        val ch = substring(text, i, i + 1)
        val is_digit = is_digit_char(ch)
        if not is_digit:
            is_valid = false
            i = len(text)
        i = i + 1
    is_valid

# Check if input looks like an email
fn is_email_input(text: text) -> bool:
    val at_pos = index_of(text, "@")
    if at_pos < 0:
        return false
    val dot_pos = index_of(text, ".")
    dot_pos > at_pos

# Check if input looks like a URL
fn is_url_input(text: text) -> bool:
    val http = starts_with(text, "http://")
    val https = starts_with(text, "https://")
    http or https

# Validate input against a list of choices
fn validate_choice(value: text, choices: list) -> bool:
    var i = 0
    while i < len(choices):
        val choice = choices[i]
        if choice == value:
            return true
        i = i + 1
    false

# Validate that value is not empty
fn validate_not_empty(value: text) -> bool:
    len(value) > 0

# Validate minimum length
fn validate_min_length(value: text, min_len: i64) -> bool:
    len(value) >= min_len

# Validate maximum length
fn validate_max_length(value: text, max_len: i64) -> bool:
    len(value) <= max_len

# Validate range for integer input
fn validate_int_range(value: text, min_val: i64, max_val: i64) -> bool:
    if not is_integer_input(value):
        return false
    val num = parse_int_or_zero(value)
    val is_min = num >= min_val
    val is_max = num <= max_val
    is_min and is_max

fn is_digit_char(ch: text) -> bool:
    val digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    var i = 0
    while i < len(digits):
        if ch == digits[i]:
            return true
        i = i + 1
    false

# =============================================================================
# Utility Functions
# =============================================================================

# Check if list is empty
fn is_empty_list(lst: list) -> bool:
    len(lst) == 0

# Get first element of list (or empty string)
fn first_or_empty(lst: list) -> text:
    if len(lst) > 0:
        return lst[0]
    ""

# Get last element of list (or empty string)
fn last_or_empty(lst: list) -> text:
    val size = len(lst)
    if size > 0:
        return lst[size - 1]
    ""

# Join list elements with separator
fn join_list(lst: list, separator: text) -> text:
    if len(lst) == 0:
        return ""
    var result = lst[0]
    var i = 1
    while i < len(lst):
        val item = lst[i]
        result = "{result}{separator}{item}"
        i = i + 1
    result

# Repeat a string n times
fn repeat_string(text: text, count: i64) -> text:
    var result = ""
    var i = 0
    while i < count:
        result = "{result}{text}"
        i = i + 1
    result

# Count occurrences of substring
fn count_occurrences(text: text, search: text) -> i64:
    var count = 0
    var i = 0
    while i < len(text):
        if i + len(search) <= len(text):
            val sub = substring(text, i, i + len(search))
            if sub == search:
                count = count + 1
        i = i + 1
    count

# Check if text contains substring
fn contains_substring(text: text, search: text) -> bool:
    index_of(text, search) >= 0

# Replace all occurrences of substring
fn replace_all(text: text, search: text, replace: text) -> text:
    var result = ""
    var i = 0
    while i < len(text):
        var found = false
        if i + len(search) <= len(text):
            val sub = substring(text, i, i + len(search))
            if sub == search:
                result = "{result}{replace}"
                i = i + len(search)
                found = true
        if not found:
            val ch = substring(text, i, i + 1)
            result = "{result}{ch}"
            i = i + 1
    result

# =============================================================================
# Environment and System Info
# =============================================================================

# Print environment variable (placeholder - Simple doesn't have env access)
fn print_env_info():
    print_info("Environment information not available in Simple runtime")

# Print system info
fn print_system_info():
    print_info("Simple Language CLI Utilities v1.0.0")
    print_info("Pure Simple implementation")

# =============================================================================
# Exit Helpers
# =============================================================================

# Exit with success message
fn exit_success(message: text):
    print_success(message)
    # Note: Simple doesn't have exit(), just print

# Exit with error message
fn exit_error(message: text):
    print_error(message)
    # Note: Simple doesn't have exit(), just print

# =============================================================================
# Convenience Functions
# =============================================================================

# Create a simple CLI with just flags
fn simple_cli_with_flags(name: text, version: text, flag_defs: list) -> tuple:
    var parser = create_parser(name, version)
    var i = 0
    while i < len(flag_defs):
        val flag_def = flag_defs[i]
        val flag_name = flag_def[0]
        val flag_short = flag_def[1]
        val flag_long = flag_def[2]
        val flag_help = flag_def[3]
        parser = add_flag(parser, flag_name, flag_short, flag_long, flag_help)
        i = i + 1
    parser

# Parse and validate in one step
fn parse_and_validate(parser: tuple, args: list) -> tuple:
    val result = parse_args(parser, args)
    if has_errors(result):
        print_validation_errors(result)
    result

# Print parse result summary
fn print_parse_summary(result: tuple):
    print_info("Parse Result Summary:")

    val flags = result[0]
    if len(flags) > 0:
        print "Flags:"
        var i = 0
        while i < len(flags):
            val flag = flags[i]
            val name = flag[0]
            val value = flag[4]
            print "  {name}: {value}"
            i = i + 1

    val options = result[1]
    if len(options) > 0:
        print "Options:"
        var j = 0
        while j < len(options):
            val option = options[j]
            val name = option[0]
            val value = option[5]
            print "  {name}: {value}"
            j = j + 1

    val positionals = result[2]
    if len(positionals) > 0:
        print "Positionals:"
        var k = 0
        while k < len(positionals):
            val pos = positionals[k]
            val name = pos[0]
            val value = pos[2]
            print "  {name}: {value}"
            k = k + 1

# Helper functions needed
fn starts_with(text: text, prefix: text) -> bool:
    if len(prefix) > len(text):
        return false
    val sub = substring(text, 0, len(prefix))
    sub == prefix

fn index_of(text: text, search: text) -> i64:
    var i = 0
    while i < len(text):
        if i + len(search) <= len(text):
            val sub = substring(text, i, i + len(search))
            if sub == search:
                return i
        i = i + 1
    -1

fn split_by_space(text: text) -> list:
    var result = []
    var current_word = ""
    var i = 0

    while i < len(text):
        val ch = substring(text, i, i + 1)
        if ch == " ":
            if current_word != "":
                result = result + [current_word]
                current_word = ""
        else:
            current_word = "{current_word}{ch}"
        i = i + 1

    if current_word != "":
        result = result + [current_word]

    result

fn print_error(message: text):
    print "[ERROR] {message}"

fn print_info(message: text):
    print "[INFO] {message}"

fn print_success(message: text):
    print "[SUCCESS] {message}"

fn create_parser(name: text, version: text) -> tuple:
    val flags = []
    val options = []
    val positionals = []
    val commands = []
    val description = ""
    (name, version, flags, options, positionals, commands, description)

fn add_flag(parser: tuple, name: text, short: text, long: text, help: text) -> tuple:
    val parser_name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    val description = parser[6]

    val flag = (name, short, long, help, false)
    val new_flags = flags + [flag]
    (parser_name, version, new_flags, options, positionals, commands, description)

fn parse_args(parser: tuple, args: list) -> tuple:
    ([], [], [], nil, [], [])

fn has_errors(result: tuple) -> bool:
    val errors = result[5]
    len(errors) > 0

fn print_validation_errors(result: tuple):
    val errors = result[5]
    var i = 0
    while i < len(errors):
        val error = errors[i]
        print_error(error)
        i = i + 1
