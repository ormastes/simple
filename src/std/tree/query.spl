# Tree Query Operations
#
# Functions for querying tree properties and searching.

# ============================================================================
# Exports
# ============================================================================

export height, size, leaf_count, is_balanced, is_complete, diameter
export bst_search, bst_min, bst_max, bst_validate
export find_path, lowest_common_ancestor, are_identical, is_subtree
export peek_min, peek_max, is_min_heap, is_max_heap

# ============================================================================
# Tree Properties
# ============================================================================

fn height(tree) -> i64:
    """Calculate height of tree.

    Height is the longest path from root to leaf.

    Example:
        height(tree)  # 3
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree
    val left_height = height(left)
    val right_height = height(right)

    if left_height > right_height:
        left_height + 1
    else:
        right_height + 1

fn size(tree) -> i64:
    """Count number of nodes in tree.

    Example:
        size(tree)  # 7
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree
    1 + size(left) + size(right)

fn leaf_count(tree) -> i64:
    """Count number of leaf nodes.

    Example:
        leaf_count(tree)  # 4
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree

    if not left.? and not right.?:
        return 1

    leaf_count(left) + leaf_count(right)

fn is_balanced(tree):
    """Check if tree is height-balanced.

    A tree is balanced if for every node, the height difference
    between left and right subtrees is at most 1.

    Example:
        is_balanced(tree)  # true
    """
    if not tree.?:
        return true

    val (_, left, right) = tree
    val left_h = height(left)
    val right_h = height(right)

    var diff = left_h - right_h
    if diff < 0:
        diff = 0 - diff

    if diff > 1:
        return false

    is_balanced(left) and is_balanced(right)

fn is_complete(tree) -> i64:
    """Check if tree is complete (all levels filled except possibly last).

    Returns 1 if complete, 0 if not (using i64 for compatibility).

    Example:
        is_complete(tree)  # 1
    """
    if not tree.?:
        return 1

    var queue = [tree]
    var found_null = false

    while queue.len() > 0:
        val node = queue[0]
        var new_queue = []
        var i = 1
        while i < queue.len():
            new_queue.push(queue[i])
            i = i + 1
        queue = new_queue

        if not node.?:
            found_null = true
        else:
            if found_null:
                return 0

            val (_, left, right) = node
            queue.push(left)
            queue.push(right)

    1

fn diameter(tree) -> i64:
    """Calculate diameter of tree (longest path between any two nodes).

    Example:
        diameter(tree)  # 5
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree
    val left_h = height(left)
    val right_h = height(right)

    # Diameter through root
    val through_root = left_h + right_h

    # Diameter in subtrees
    val left_diam = diameter(left)
    val right_diam = diameter(right)

    var max_val = through_root
    if left_diam > max_val:
        max_val = left_diam
    if right_diam > max_val:
        max_val = right_diam

    max_val

# ============================================================================
# Binary Search Tree Queries
# ============================================================================

fn bst_search(tree, value):
    """Search for value in BST.

    Returns true if found, false otherwise.

    Example:
        bst_search(tree, 7)  # true
    """
    if not tree.?:
        return false

    val (node_val, left, right) = tree

    if value == node_val:
        return true

    if value < node_val:
        bst_search(left, value)
    else:
        bst_search(right, value)

fn bst_min(tree):
    """Find minimum value in BST.

    Returns minimum value or nil if tree is empty.

    Example:
        bst_min(tree)  # 1
    """
    if not tree.?:
        return nil

    val (value, left, _) = tree

    if not left.?:
        return value

    bst_min(left)

fn bst_max(tree):
    """Find maximum value in BST.

    Returns maximum value or nil if tree is empty.

    Example:
        bst_max(tree)  # 20
    """
    if not tree.?:
        return nil

    val (value, _, right) = tree

    if not right.?:
        return value

    bst_max(right)

fn bst_validate_helper(tree, min_val, max_val):
    """Helper for BST validation."""
    if not tree.?:
        return true

    val (value, left, right) = tree

    if min_val.? and value <= min_val:
        return false

    if max_val.? and value >= max_val:
        return false

    bst_validate_helper(left, min_val, value) and bst_validate_helper(right, value, max_val)

fn bst_validate(tree):
    """Check if tree is a valid BST.

    Example:
        bst_validate(tree)  # true
    """
    bst_validate_helper(tree, nil, nil)

# ============================================================================
# Tree Utilities
# ============================================================================

fn find_path_helper(tree, value, path):
    """Helper for finding path to value."""
    if not tree.?:
        return false

    val (node_val, left, right) = tree
    path.push(node_val)

    if node_val == value:
        return true

    if find_path_helper(left, value, path):
        return true

    if find_path_helper(right, value, path):
        return true

    # Remove from path if not found
    var new_path = []
    var i = 0
    while i < path.len() - 1:
        new_path.push(path[i])
        i = i + 1

    # Clear and rebuild path
    while path.len() > 0:
        path.pop()
    for p in new_path:
        path.push(p)

    false

fn find_path(tree, value):
    """Find path from root to node with given value.

    Returns array of values on path, or nil if not found.

    Example:
        find_path(tree, 5)  # [1, 2, 5]
    """
    var path = []
    val found = find_path_helper(tree, value, path)
    if found:
        path
    else:
        nil

fn lowest_common_ancestor(tree, val1, val2):
    """Find lowest common ancestor of two nodes.

    Example:
        lowest_common_ancestor(tree, 4, 5)  # 2
    """
    val path1 = find_path(tree, val1)
    val path2 = find_path(tree, val2)

    if not path1.? or not path2.?:
        return nil

    var lca = nil
    var i = 0
    while i < path1.len() and i < path2.len():
        if path1[i] == path2[i]:
            lca = path1[i]
        else:
            break
        i = i + 1

    lca

fn are_identical(tree1, tree2):
    """Check if two trees are structurally identical.

    Example:
        are_identical(tree1, tree2)  # true
    """
    if not tree1.? and not tree2.?:
        return true

    if not tree1.? or not tree2.?:
        return false

    val (val1, left1, right1) = tree1
    val (val2, left2, right2) = tree2

    if val1 != val2:
        return false

    are_identical(left1, left2) and are_identical(right1, right2)

fn is_subtree(tree, subtree):
    """Check if subtree is a subtree of tree.

    Example:
        is_subtree(tree, smaller_tree)  # true
    """
    if not tree.?:
        return false

    if are_identical(tree, subtree):
        return true

    val (_, left, right) = tree
    is_subtree(left, subtree) or is_subtree(right, subtree)

# ============================================================================
# Heap Queries
# ============================================================================

fn peek_min(heap):
    """Get minimum value without removing.

    Example:
        peek_min(heap)  # 1
    """
    if heap.len() == 0:
        return nil
    heap[0]

fn peek_max(heap):
    """Get maximum value without removing.

    Example:
        peek_max(heap)  # 9
    """
    if heap.len() == 0:
        return nil
    heap[0]

fn is_min_heap(arr) -> i64:
    """Check if array satisfies min-heap property.

    Returns 1 if valid min-heap, 0 otherwise.

    Example:
        is_min_heap([1, 3, 5, 7, 9])  # 1
    """
    val size = arr.len()
    var i = 0

    while i <= (size - 2) / 2:
        val left = heap_left(i)
        val right = heap_right(i)

        if left < size and arr[i] > arr[left]:
            return 0

        if right < size and arr[i] > arr[right]:
            return 0

        i = i + 1

    1

fn is_max_heap(arr) -> i64:
    """Check if array satisfies max-heap property.

    Returns 1 if valid max-heap, 0 otherwise.

    Example:
        is_max_heap([9, 7, 5, 3, 1])  # 1
    """
    val size = arr.len()
    var i = 0

    while i <= (size - 2) / 2:
        val left = heap_left(i)
        val right = heap_right(i)

        if left < size and arr[i] < arr[left]:
            return 0

        if right < size and arr[i] < arr[right]:
            return 0

        i = i + 1

    1
