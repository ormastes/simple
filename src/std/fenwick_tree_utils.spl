# Fenwick Tree (Binary Indexed Tree) Utilities Module
# Comprehensive implementation of Fenwick trees for efficient range queries
# Pure Simple implementation with tuple-based data structures
#
# Fenwick Tree (BIT) Properties:
# - Space-efficient tree for cumulative frequency tables
# - Point update: O(log n)
# - Prefix sum query: O(log n)
# - Range sum query: O(log n)
# - Memory: O(n) - half the space of segment trees
# - 1-indexed arrays (tree[0] unused)
#
# Advantages over Segment Trees:
# - Simpler implementation (fewer lines of code)
# - Better memory efficiency (~50% less space)
# - Better cache performance (sequential memory access)
# - Elegant bit manipulation operations
#
# Key Concept:
# tree[i] stores sum of elements in range determined by LSB (Least Significant Bit):
# - tree[1] = arr[1] (covers 1 element)
# - tree[2] = arr[1..2] (covers 2 elements)
# - tree[4] = arr[1..4] (covers 4 elements)
# - tree[8] = arr[1..8] (covers 8 elements)
#
# Bit Operations:
# - i & -i: Isolates rightmost set bit (LSB)
#   Example: 6 (110) & -6 (010) = 2 (010)
# - i + (i & -i): Move to parent in update path
# - i - (i & -i): Move to child in query path
#
# Example:
# Array:   [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]
# Index:   [1, 2,  3, 4, 5, 6,  7, 8, 9,10,11]
# Fenwick: [0, 3, 5,  4, 10, 5, 9, 6, 16, 7, 9, 12]

# ============================================================================
# Data Structures (tuple-based)
# ============================================================================

# FenwickTree: (tree: list, n: i64)
#   - tree: 1-indexed array (tree[0] = 0)
#   - n: number of elements (excluding tree[0])

# RangeUpdateTree: (tree1: fenwick, tree2: fenwick, n: i64)
#   - tree1: difference array for range updates
#   - tree2: auxiliary tree for efficient range queries
#   - n: number of elements

# FenwickTree2D: (tree: list[list], rows: i64, cols: i64)
#   - tree: 2D array for matrix range sums
#   - rows: number of rows
#   - cols: number of columns

# ============================================================================
# Core Bit Manipulation Operations
# ============================================================================

# Isolate the least significant bit (LSB) of i
# This is the core operation for Fenwick tree navigation
# i & -i gives us the rightmost set bit
# Example: isolate_lsb(6) = 6 & -6 = 2
#          110 & 010 = 010
fn isolate_lsb(i: i64) -> i64:
    """Isolate the least significant bit (rightmost set bit) of i.

    This is achieved by i & -i:
    - -i is the two's complement of i
    - i & -i isolates the rightmost 1 bit

    Examples:
      isolate_lsb(6) = 2   (110 & 010 = 010)
      isolate_lsb(12) = 4  (1100 & 0100 = 0100)
      isolate_lsb(5) = 1   (101 & 001 = 001)
    """
    i & (0 - i)

# Get parent index in update path
# Parent is the next index that needs to be updated
# Formula: i + (i & -i)
fn get_parent(i: i64) -> i64:
    """Get parent index in Fenwick tree update path.

    When updating index i, we also need to update its parent.
    Parent index = i + (i & -i)

    This moves to the next index whose range includes i.

    Examples:
      get_parent(1) = 2  (1 + 1 = 2)
      get_parent(2) = 4  (2 + 2 = 4)
      get_parent(3) = 4  (3 + 1 = 4)
      get_parent(4) = 8  (4 + 4 = 8)
    """
    val lsb = isolate_lsb(i)
    i + lsb

# Get next index in query path
# Next is the previous range we need to add to sum
# Formula: i - (i & -i)
fn get_next(i: i64) -> i64:
    """Get next index in Fenwick tree query path.

    When querying prefix sum up to i, we need to traverse backwards.
    Next index = i - (i & -i)

    This moves to the previous index whose range we need to include.

    Examples:
      get_next(7) = 6  (7 - 1 = 6)
      get_next(6) = 4  (6 - 2 = 4)
      get_next(4) = 0  (4 - 4 = 0, stops here)
    """
    val lsb = isolate_lsb(i)
    i - lsb

# Count trailing zeros (equivalent to finding position of LSB)
fn count_trailing_zeros(i: i64) -> i64:
    """Count number of trailing zeros in binary representation.

    This tells us the power of 2 that divides i.
    Useful for understanding tree structure.

    Examples:
      count_trailing_zeros(8) = 3  (1000 has 3 trailing zeros)
      count_trailing_zeros(6) = 1  (110 has 1 trailing zero)
      count_trailing_zeros(5) = 0  (101 has 0 trailing zeros)
    """
    if i == 0:
        return 0
    val lsb = isolate_lsb(i)
    var count = 0
    var temp = lsb
    while temp > 1:
        temp = temp / 2
        count = count + 1
    count

# Get range size that index i is responsible for
fn get_range_size(i: i64) -> i64:
    """Get the size of range that tree[i] covers.

    tree[i] stores sum of elements in a range.
    The range size is determined by the LSB of i.

    Examples:
      get_range_size(1) = 1  (covers 1 element)
      get_range_size(2) = 2  (covers 2 elements)
      get_range_size(4) = 4  (covers 4 elements)
      get_range_size(8) = 8  (covers 8 elements)
    """
    isolate_lsb(i)

# Check if index i is a power of 2
fn is_power_of_two(i: i64) -> bool:
    """Check if i is a power of 2.

    A number is a power of 2 if it has exactly one bit set.
    This means i & (i-1) == 0.

    Powers of 2 are special in Fenwick trees - they cover
    the maximum range size for their position.
    """
    if i <= 0:
        return false
    val check = i & (i - 1)
    check == 0

# ============================================================================
# Fenwick Tree Creation
# ============================================================================

# Create an empty Fenwick tree of size n
fn create_fenwick_tree(n: i64) -> (list, i64):
    """Create an empty Fenwick tree with n elements.

    Creates a 1-indexed array of size n+1 (tree[0] unused).
    All elements initialized to 0.

    Args:
      n: Number of elements in the tree

    Returns:
      (tree, n) tuple where tree is the array and n is the size

    Time: O(n)
    Space: O(n)
    """
    var tree = []
    var i = 0
    while i <= n:
        tree.push(0)
        i = i + 1
    (tree, n)

# Build Fenwick tree from array
fn create_fenwick_from_array(arr: list) -> (list, i64):
    """Build a Fenwick tree from an existing array.

    Converts a 0-indexed array to a 1-indexed Fenwick tree.
    More efficient than creating empty tree and updating each element.

    Algorithm:
      1. Copy array to tree (with 1-indexing)
      2. For each i, add tree[i] to its parent
      3. This builds the tree in O(n) instead of O(n log n)

    Args:
      arr: Input array (0-indexed)

    Returns:
      Fenwick tree containing the cumulative structure

    Time: O(n) - linear build algorithm
    Space: O(n)

    Example:
      arr = [3, 2, -1, 6, 5]
      tree = [0, 3, 5, -1, 10, 5]
    """
    val n = arr.len()
    var tree = []
    tree.push(0)

    var i = 0
    while i < n:
        tree.push(arr[i])
        i = i + 1

    i = 1
    while i <= n:
        val parent = get_parent(i)
        if parent <= n:
            val current_val = tree[parent]
            val add_val = tree[i]
            tree[parent] = current_val + add_val
        i = i + 1

    (tree, n)

# Clone a Fenwick tree (deep copy)
fn clone_tree(fenwick_tree) -> (list, i64):
    """Create a deep copy of a Fenwick tree.

    Args:
      fenwick_tree: (tree, n) tuple

    Returns:
      New Fenwick tree with same values

    Time: O(n)
    Space: O(n)
    """
    val tree = fenwick_tree.0
    val n = fenwick_tree.1

    var new_tree = []
    var i = 0
    while i <= n:
        new_tree.push(tree[i])
        i = i + 1

    (new_tree, n)

# Clear a Fenwick tree (set all values to 0)
fn clear_tree(fenwick_tree) -> (list, i64):
    """Reset all values in Fenwick tree to 0.

    Args:
      fenwick_tree: (tree, n) tuple

    Returns:
      Fenwick tree with all zeros

    Time: O(n)
    """
    val n = fenwick_tree.1
    create_fenwick_tree(n)

# ============================================================================
# Point Update Operations
# ============================================================================

# Update single element at index i by adding delta
fn update(fenwick_tree, i: i64, delta: i64) -> (list, i64):
    """Add delta to element at index i (1-indexed).

    Updates tree[i] and all ancestors that depend on it.
    Traverses update path by repeatedly adding LSB.

    Algorithm:
      while i <= n:
        tree[i] += delta
        i = i + (i & -i)  # Move to parent

    Args:
      fenwick_tree: (tree, n) tuple
      i: 1-indexed position to update
      delta: Value to add

    Returns:
      Updated Fenwick tree

    Time: O(log n)

    Example:
      update(tree, 3, 5) adds 5 to position 3
      This updates tree[3], tree[4], tree[8], etc.
    """
    val tree = fenwick_tree.0
    val n = fenwick_tree.1

    if i < 1:
        return fenwick_tree
    if i > n:
        return fenwick_tree

    var idx = i
    while idx <= n:
        val current = tree[idx]
        tree[idx] = current + delta
        idx = get_parent(idx)

    (tree, n)

# Alias for update
fn add(fenwick_tree, i: i64, value: i64) -> (list, i64):
    """Add value to element at index i. Alias for update.

    Time: O(log n)
    """
    update(fenwick_tree, i, value)

# Set element at index i to a specific value
fn set_value(fenwick_tree, i: i64, value: i64) -> (list, i64):
    """Set element at index i to a specific value.

    First gets current value, then updates with difference.

    Args:
      fenwick_tree: (tree, n) tuple
      i: 1-indexed position
      value: New value to set

    Returns:
      Updated Fenwick tree

    Time: O(log n)
    """
    val current = point_query(fenwick_tree, i)
    val delta = value - current
    update(fenwick_tree, i, delta)

# ============================================================================
# Prefix Sum Query Operations
# ============================================================================

# Query prefix sum from index 1 to i
fn prefix_sum(fenwick_tree, i: i64) -> i64:
    """Compute prefix sum from index 1 to i (inclusive).

    Sums tree[i] and all ancestors in query path.
    Traverses backwards by repeatedly subtracting LSB.

    Algorithm:
      sum = 0
      while i > 0:
        sum += tree[i]
        i = i - (i & -i)  # Move to next range
      return sum

    Args:
      fenwick_tree: (tree, n) tuple
      i: 1-indexed position (query range [1, i])

    Returns:
      Sum of elements from index 1 to i

    Time: O(log n)

    Example:
      prefix_sum(tree, 5) returns sum of arr[1..5]
      Accesses tree[5], tree[4], tree[0] and sums them
    """
    val tree = fenwick_tree.0
    val n = fenwick_tree.1

    if i < 0:
        return 0
    if i > n:
        return prefix_sum(fenwick_tree, n)

    var sum = 0
    var idx = i
    while idx > 0:
        val current = tree[idx]
        sum = sum + current
        idx = get_next(idx)

    sum

# Alias for prefix_sum
fn query(fenwick_tree, i: i64) -> i64:
    """Query prefix sum up to index i. Alias for prefix_sum.

    Time: O(log n)
    """
    prefix_sum(fenwick_tree, i)

# ============================================================================
# Range Query Operations
# ============================================================================

# Query sum in range [l, r]
fn range_sum(fenwick_tree, l: i64, r: i64) -> i64:
    """Compute sum of elements in range [l, r] (inclusive, 1-indexed).

    Uses prefix sum difference:
      range_sum(l, r) = prefix_sum(r) - prefix_sum(l-1)

    Args:
      fenwick_tree: (tree, n) tuple
      l: Left boundary (1-indexed, inclusive)
      r: Right boundary (1-indexed, inclusive)

    Returns:
      Sum of elements from index l to r

    Time: O(log n)

    Example:
      range_sum(tree, 3, 7) returns sum of arr[3..7]
      = prefix_sum(7) - prefix_sum(2)
    """
    if l > r:
        return 0
    if l < 1:
        return range_sum(fenwick_tree, 1, r)

    val sum_r = prefix_sum(fenwick_tree, r)
    val sum_l = prefix_sum(fenwick_tree, l - 1)
    sum_r - sum_l

# Alias for range_sum
fn sum_range(fenwick_tree, left: i64, right: i64) -> i64:
    """Query range sum [left, right]. Alias for range_sum.

    Time: O(log n)
    """
    range_sum(fenwick_tree, left, right)

# ============================================================================
# Point Query Operations
# ============================================================================

# Get value at single point i
fn point_query(fenwick_tree, i: i64) -> i64:
    """Get the value at a single index i.

    Computes the difference of prefix sums:
      point_query(i) = prefix_sum(i) - prefix_sum(i-1)

    Args:
      fenwick_tree: (tree, n) tuple
      i: 1-indexed position

    Returns:
      Value at index i

    Time: O(log n)
    """
    range_sum(fenwick_tree, i, i)

# Alias for point_query
fn get_value_at(fenwick_tree, i: i64) -> i64:
    """Get value at index i. Alias for point_query.

    Time: O(log n)
    """
    point_query(fenwick_tree, i)

# ============================================================================
# Range Update with Difference Array
# ============================================================================

# Create a Fenwick tree that supports efficient range updates
fn create_range_update_tree(n: i64) -> ((list, i64), (list, i64), i64):
    """Create a Fenwick tree optimized for range updates.

    Uses two Fenwick trees to support efficient range updates:
    - tree1: Difference array
    - tree2: Auxiliary tree for queries

    This allows O(log n) range updates and O(log n) point queries.

    Args:
      n: Number of elements

    Returns:
      (tree1, tree2, n) tuple

    Time: O(n)
    Space: O(n)
    """
    val tree1 = create_fenwick_tree(n)
    val tree2 = create_fenwick_tree(n)
    (tree1, tree2, n)

# Build range update tree from array
fn create_range_update_from_array(arr: list) -> ((list, i64), (list, i64), i64):
    """Build a range update tree from an existing array.

    Args:
      arr: Input array (0-indexed)

    Returns:
      Range update tree structure

    Time: O(n)
    """
    val n = arr.len()
    var tree1 = create_fenwick_tree(n)
    var tree2 = create_fenwick_tree(n)

    var i = 0
    while i < n:
        val idx = i + 1
        tree1 = update(tree1, idx, arr[i])
        i = i + 1

    (tree1, tree2, n)

# Update range [l, r] by adding delta (using difference array)
fn range_update(range_tree, l: i64, r: i64, delta: i64) -> ((list, i64), (list, i64), i64):
    """Add delta to all elements in range [l, r].

    Uses difference array technique:
    - Update diff[l] += delta
    - Update diff[r+1] -= delta

    This makes prefix sums correctly reflect range updates.

    Args:
      range_tree: (tree1, tree2, n) tuple
      l: Left boundary (1-indexed, inclusive)
      r: Right boundary (1-indexed, inclusive)
      delta: Value to add to range

    Returns:
      Updated range update tree

    Time: O(log n)

    Example:
      range_update(tree, 2, 5, 10) adds 10 to arr[2..5]
    """
    val tree1 = range_tree.0
    val tree2 = range_tree.1
    val n = range_tree.2

    if l > r:
        return range_tree
    if l < 1:
        return range_update(range_tree, 1, r, delta)
    if r > n:
        return range_update(range_tree, l, n, delta)

    val new_tree1_1 = update(tree1, l, delta)
    var new_tree1 = new_tree1_1
    if r + 1 <= n:
        new_tree1 = update(new_tree1_1, r + 1, 0 - delta)

    (new_tree1, tree2, n)

# Add value to range [l, r]
fn add_range(range_tree, l: i64, r: i64, value: i64) -> ((list, i64), (list, i64), i64):
    """Add value to range [l, r]. Alias for range_update.

    Time: O(log n)
    """
    range_update(range_tree, l, r, value)

# Query point value in range update tree
fn range_update_point_query(range_tree, i: i64) -> i64:
    """Query value at index i in a range update tree.

    Computes prefix sum of difference array.

    Args:
      range_tree: (tree1, tree2, n) tuple
      i: 1-indexed position

    Returns:
      Value at index i after all range updates

    Time: O(log n)
    """
    val tree1 = range_tree.0
    prefix_sum(tree1, i)

# Query range sum in range update tree
fn range_update_range_sum(range_tree, l: i64, r: i64) -> i64:
    """Query range sum [l, r] in a range update tree.

    Time: O(n) - requires summing individual elements
    This is less efficient than standard range queries.
    """
    if l > r:
        return 0

    var sum = 0
    var i = l
    while i <= r:
        val val = range_update_point_query(range_tree, i)
        sum = sum + val
        i = i + 1
    sum

# ============================================================================
# Reconstruction and Conversion
# ============================================================================

# Reconstruct original array from Fenwick tree
fn tree_to_array(fenwick_tree) -> list:
    """Reconstruct the original array from a Fenwick tree.

    Returns 0-indexed array by querying each point.

    Args:
      fenwick_tree: (tree, n) tuple

    Returns:
      Original array (0-indexed)

    Time: O(n log n)
    Space: O(n)
    """
    val n = fenwick_tree.1
    var arr = []

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        arr.push(val)
        i = i + 1

    arr

# Convert Fenwick tree to list of prefix sums
fn tree_to_prefix_sums(fenwick_tree) -> list:
    """Convert Fenwick tree to array of prefix sums.

    Args:
      fenwick_tree: (tree, n) tuple

    Returns:
      Array where result[i] = prefix_sum(i+1)

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var result = []

    var i = 1
    while i <= n:
        val psum = prefix_sum(fenwick_tree, i)
        result.push(psum)
        i = i + 1

    result

# ============================================================================
# Advanced Query Operations
# ============================================================================

# Find smallest index where prefix sum >= target
fn lower_bound(fenwick_tree, target: i64) -> i64:
    """Find smallest index i where prefix_sum(i) >= target.

    Uses binary search on prefix sums.
    Returns -1 if no such index exists.

    Args:
      fenwick_tree: (tree, n) tuple
      target: Target prefix sum

    Returns:
      Smallest index with prefix_sum >= target, or -1

    Time: O(log² n)

    Example:
      If prefix sums are [3, 5, 4, 10, 15, ...]
      lower_bound(tree, 7) returns 4 (first sum >= 7 is 10)
    """
    val n = fenwick_tree.1

    var left = 1
    var right = n
    var result = -1

    while left <= right:
        val mid = (left + right) / 2
        val psum = prefix_sum(fenwick_tree, mid)

        if psum >= target:
            result = mid
            right = mid - 1
        else:
            left = mid + 1

    result

# Find largest index where prefix sum <= target
fn upper_bound(fenwick_tree, target: i64) -> i64:
    """Find largest index i where prefix_sum(i) <= target.

    Uses binary search on prefix sums.
    Returns 0 if no such index exists.

    Args:
      fenwick_tree: (tree, n) tuple
      target: Target prefix sum

    Returns:
      Largest index with prefix_sum <= target, or 0

    Time: O(log² n)
    """
    val n = fenwick_tree.1

    var left = 1
    var right = n
    var result = 0

    while left <= right:
        val mid = (left + right) / 2
        val psum = prefix_sum(fenwick_tree, mid)

        if psum <= target:
            result = mid
            left = mid + 1
        else:
            right = mid - 1

    result

# Find k-th smallest element (requires frequency tree)
fn find_kth_smallest(fenwick_tree, k: i64) -> i64:
    """Find the k-th smallest element in a frequency Fenwick tree.

    Assumes Fenwick tree stores frequencies at each position.
    Uses binary search to find position with k-th element.

    Args:
      fenwick_tree: Frequency tree (tree, n) tuple
      k: 1-indexed position (1 = smallest)

    Returns:
      Index containing the k-th element, or -1

    Time: O(log² n)

    Example:
      Frequencies: [0, 2, 1, 0, 3, 1, ...]
      find_kth_smallest(tree, 3) finds position of 3rd element
    """
    val n = fenwick_tree.1

    if k < 1:
        return -1

    val total = prefix_sum(fenwick_tree, n)
    if k > total:
        return -1

    lower_bound(fenwick_tree, k)

# ============================================================================
# Scaling and Transformation
# ============================================================================

# Scale all values in tree by a factor
fn scale_tree(fenwick_tree, factor: i64) -> (list, i64):
    """Multiply all values in Fenwick tree by factor.

    Reconstructs array, scales it, and rebuilds tree.

    Args:
      fenwick_tree: (tree, n) tuple
      factor: Scaling factor

    Returns:
      New Fenwick tree with scaled values

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var scaled = []
    var i = 0
    while i < n:
        scaled.push(arr[i] * factor)
        i = i + 1

    create_fenwick_from_array(scaled)

# Negate all values in tree
fn negate_tree(fenwick_tree) -> (list, i64):
    """Negate all values in Fenwick tree.

    Time: O(n log n)
    """
    scale_tree(fenwick_tree, -1)

# Add constant to all elements
fn add_constant(fenwick_tree, constant: i64) -> (list, i64):
    """Add a constant value to all elements.

    Args:
      fenwick_tree: (tree, n) tuple
      constant: Value to add to each element

    Returns:
      Updated Fenwick tree

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var result = fenwick_tree

    var i = 1
    while i <= n:
        result = update(result, i, constant)
        i = i + 1

    result

# ============================================================================
# 2D Fenwick Tree Operations
# ============================================================================

# Create empty 2D Fenwick tree
fn create_2d_fenwick(rows: i64, cols: i64) -> (list, i64, i64):
    """Create an empty 2D Fenwick tree.

    Supports efficient 2D range sum queries on matrices.
    Both dimensions use 1-indexing.

    Args:
      rows: Number of rows
      cols: Number of columns

    Returns:
      (tree, rows, cols) tuple where tree is 2D array

    Time: O(rows * cols)
    Space: O(rows * cols)
    """
    var tree = []

    var r = 0
    while r <= rows:
        var row = []
        var c = 0
        while c <= cols:
            row.push(0)
            c = c + 1
        tree.push(row)
        r = r + 1

    (tree, rows, cols)

# Build 2D Fenwick tree from matrix
fn create_2d_fenwick_from_matrix(matrix: list) -> (list, i64, i64):
    """Build 2D Fenwick tree from a matrix.

    Args:
      matrix: 2D array (0-indexed)

    Returns:
      2D Fenwick tree

    Time: O(rows * cols * log(rows) * log(cols))
    """
    val rows = matrix.len()
    if rows == 0:
        return create_2d_fenwick(0, 0)

    val cols = matrix[0].len()
    var tree_2d = create_2d_fenwick(rows, cols)

    var r = 0
    while r < rows:
        var c = 0
        while c < cols:
            val value = matrix[r][c]
            tree_2d = update_2d(tree_2d, r + 1, c + 1, value)
            c = c + 1
        r = r + 1

    tree_2d

# Update single cell in 2D Fenwick tree
fn update_2d(tree_2d, row: i64, col: i64, delta: i64) -> (list, i64, i64):
    """Add delta to cell at (row, col) in 2D Fenwick tree.

    Updates all parent cells in both dimensions.

    Algorithm:
      r = row
      while r <= rows:
        c = col
        while c <= cols:
          tree[r][c] += delta
          c = c + (c & -c)
        r = r + (r & -r)

    Args:
      tree_2d: (tree, rows, cols) tuple
      row: 1-indexed row
      col: 1-indexed column
      delta: Value to add

    Returns:
      Updated 2D Fenwick tree

    Time: O(log(rows) * log(cols))
    """
    val tree = tree_2d.0
    val rows = tree_2d.1
    val cols = tree_2d.2

    if row < 1:
        return tree_2d
    if row > rows:
        return tree_2d
    if col < 1:
        return tree_2d
    if col > cols:
        return tree_2d

    var r = row
    while r <= rows:
        var c = col
        while c <= cols:
            val row_data = tree[r]
            val current = row_data[c]
            row_data[c] = current + delta
            c = get_parent(c)
        r = get_parent(r)

    (tree, rows, cols)

# Query prefix sum in 2D (from (1,1) to (row, col))
fn prefix_sum_2d(tree_2d, row: i64, col: i64) -> i64:
    """Compute 2D prefix sum from (1,1) to (row, col).

    Returns sum of all elements in rectangle from (1,1) to (row,col).

    Algorithm:
      sum = 0
      r = row
      while r > 0:
        c = col
        while c > 0:
          sum += tree[r][c]
          c = c - (c & -c)
        r = r - (r & -r)
      return sum

    Args:
      tree_2d: (tree, rows, cols) tuple
      row: 1-indexed row boundary
      col: 1-indexed column boundary

    Returns:
      Sum of rectangle (1,1) to (row, col)

    Time: O(log(rows) * log(cols))
    """
    val tree = tree_2d.0
    val rows = tree_2d.1
    val cols = tree_2d.2

    if row < 0:
        return 0
    if col < 0:
        return 0
    if row > rows:
        return prefix_sum_2d(tree_2d, rows, col)
    if col > cols:
        return prefix_sum_2d(tree_2d, row, cols)

    var sum = 0
    var r = row
    while r > 0:
        var c = col
        while c > 0:
            val row_data = tree[r]
            val value = row_data[c]
            sum = sum + value
            c = get_next(c)
        r = get_next(r)

    sum

# Query 2D range sum for rectangle (r1,c1) to (r2,c2)
fn range_sum_2d(tree_2d, r1: i64, c1: i64, r2: i64, c2: i64) -> i64:
    """Compute sum of rectangle from (r1,c1) to (r2,c2).

    Uses inclusion-exclusion principle:
      sum = prefix(r2,c2) - prefix(r1-1,c2) - prefix(r2,c1-1) + prefix(r1-1,c1-1)

    Args:
      tree_2d: (tree, rows, cols) tuple
      r1: Top row (1-indexed, inclusive)
      c1: Left column (1-indexed, inclusive)
      r2: Bottom row (1-indexed, inclusive)
      c2: Right column (1-indexed, inclusive)

    Returns:
      Sum of rectangle (r1,c1) to (r2,c2)

    Time: O(log(rows) * log(cols))

    Example:
      Matrix:
        1 2 3
        4 5 6
        7 8 9
      range_sum_2d(tree, 1, 1, 2, 2) = 1+2+4+5 = 12
    """
    if r1 > r2:
        return 0
    if c1 > c2:
        return 0
    if r1 < 1:
        return range_sum_2d(tree_2d, 1, c1, r2, c2)
    if c1 < 1:
        return range_sum_2d(tree_2d, r1, 1, r2, c2)

    val sum1 = prefix_sum_2d(tree_2d, r2, c2)
    val sum2 = prefix_sum_2d(tree_2d, r1 - 1, c2)
    val sum3 = prefix_sum_2d(tree_2d, r2, c1 - 1)
    val sum4 = prefix_sum_2d(tree_2d, r1 - 1, c1 - 1)

    sum1 - sum2 - sum3 + sum4

# Query single cell in 2D tree
fn query_2d(tree_2d, row: i64, col: i64) -> i64:
    """Query value at single cell (row, col).

    Time: O(log(rows) * log(cols))
    """
    range_sum_2d(tree_2d, row, col, row, col)

# ============================================================================
# Utility and Inspection Functions
# ============================================================================

# Get tree size
fn get_size(fenwick_tree) -> i64:
    """Get number of elements in Fenwick tree.

    Returns:
      Size n (not including tree[0])

    Time: O(1)
    """
    fenwick_tree.1

# Get total sum of all elements
fn total_sum(fenwick_tree) -> i64:
    """Get sum of all elements in tree.

    Equivalent to prefix_sum(n).

    Time: O(log n)
    """
    val n = fenwick_tree.1
    prefix_sum(fenwick_tree, n)

# Check if tree is empty (all zeros)
fn is_empty(fenwick_tree) -> bool:
    """Check if all elements are zero.

    Time: O(log n)
    """
    val sum = total_sum(fenwick_tree)
    sum == 0

# Get minimum value in tree
fn min_value(fenwick_tree) -> i64:
    """Find minimum value in tree.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    var min_val = point_query(fenwick_tree, 1)
    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < min_val:
            min_val = val
        i = i + 1

    min_val

# Get maximum value in tree
fn max_value(fenwick_tree) -> i64:
    """Find maximum value in tree.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    var max_val = point_query(fenwick_tree, 1)
    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > max_val:
            max_val = val
        i = i + 1

    max_val

# Count non-zero elements
fn count_non_zero(fenwick_tree) -> i64:
    """Count number of non-zero elements.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var count = 0

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val != 0:
            count = count + 1
        i = i + 1

    count

# Count positive elements
fn count_positive(fenwick_tree) -> i64:
    """Count number of positive elements.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var count = 0

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > 0:
            count = count + 1
        i = i + 1

    count

# Count negative elements
fn count_negative(fenwick_tree) -> i64:
    """Count number of negative elements.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var count = 0

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < 0:
            count = count + 1
        i = i + 1

    count

# ============================================================================
# Application: Inversion Count
# ============================================================================

# Count inversions in array using Fenwick tree
fn inversion_count(arr: list) -> i64:
    """Count number of inversions in array.

    An inversion is a pair (i, j) where i < j but arr[i] > arr[j].
    Uses Fenwick tree with coordinate compression.

    Algorithm:
      1. Create frequency tree
      2. For each element from right to left:
         - Count elements smaller than current (inversions)
         - Update frequency tree

    Args:
      arr: Input array

    Returns:
      Number of inversions

    Time: O(n log n)
    Space: O(n)

    Example:
      arr = [3, 1, 2]
      Inversions: (0,1), (0,2) = 2
    """
    val n = arr.len()
    if n <= 1:
        return 0

    var max_val = arr[0]
    var i = 1
    while i < n:
        if arr[i] > max_val:
            max_val = arr[i]
        i = i + 1

    var tree = create_fenwick_tree(max_val)
    var count = 0

    i = n - 1
    while i >= 0:
        val val = arr[i]
        if val > 1:
            val smaller = prefix_sum(tree, val - 1)
            count = count + smaller
        tree = update(tree, val, 1)
        i = i - 1

    count

# ============================================================================
# Application: Coordinate Compression
# ============================================================================

# Compress coordinates to smaller range
fn compress_coordinates(values: list) -> (list, list):
    """Compress large coordinate values to smaller range.

    Maps values to ranks [1, n] preserving order.
    Useful when coordinate space is large but sparse.

    Args:
      values: Array of values to compress

    Returns:
      (compressed, mapping) where:
        - compressed: Array of ranks [1..n]
        - mapping: Sorted unique values

    Time: O(n log n)

    Example:
      values = [100, 50, 200, 50]
      compressed = [2, 1, 3, 1]
      mapping = [50, 100, 200]
    """
    val n = values.len()

    var sorted_vals = []
    var i = 0
    while i < n:
        sorted_vals.push(values[i])
        i = i + 1
    sorted_vals = sorted_vals.sort()

    var unique = []
    if n > 0:
        unique.push(sorted_vals[0])
    i = 1
    while i < n:
        if sorted_vals[i] != sorted_vals[i - 1]:
            unique.push(sorted_vals[i])
        i = i + 1

    var compressed = []
    i = 0
    while i < n:
        val val = values[i]
        var rank = 1
        var j = 0
        while j < unique.len():
            if unique[j] == val:
                rank = j + 1
            j = j + 1
        compressed.push(rank)
        i = i + 1

    (compressed, unique)

# ============================================================================
# Advanced Applications
# ============================================================================

# Count elements less than value
fn count_less_than(fenwick_tree, value: i64) -> i64:
    """Count elements strictly less than value in frequency tree.

    Assumes Fenwick tree stores frequencies.

    Args:
      fenwick_tree: Frequency tree
      value: Threshold value

    Returns:
      Count of elements < value

    Time: O(log n)
    """
    if value <= 1:
        return 0
    prefix_sum(fenwick_tree, value - 1)

# Count elements greater than value
fn count_greater_than(fenwick_tree, value: i64) -> i64:
    """Count elements strictly greater than value in frequency tree.

    Args:
      fenwick_tree: Frequency tree
      value: Threshold value

    Returns:
      Count of elements > value

    Time: O(log n)
    """
    val n = fenwick_tree.1
    val total = prefix_sum(fenwick_tree, n)
    val less_eq = prefix_sum(fenwick_tree, value)
    total - less_eq

# Count elements in range [low, high]
fn count_in_range(fenwick_tree, low: i64, high: i64) -> i64:
    """Count elements in range [low, high] in frequency tree.

    Time: O(log n)
    """
    range_sum(fenwick_tree, low, high)

# ============================================================================
# Debugging and Visualization
# ============================================================================

# Get internal tree array (for debugging)
fn get_internal_array(fenwick_tree) -> list:
    """Get the internal tree array (1-indexed with tree[0]=0).

    Useful for debugging and understanding tree structure.

    Returns:
      Internal array including tree[0]

    Time: O(n)
    """
    val tree = fenwick_tree.0
    var result = []
    var i = 0
    while i < tree.len():
        result.push(tree[i])
        i = i + 1
    result

# Get tree height (max depth)
fn get_tree_height(fenwick_tree) -> i64:
    """Get the height of Fenwick tree structure.

    Height is approximately log₂(n).

    Time: O(1)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    var height = 0
    var temp = n
    while temp > 0:
        temp = temp / 2
        height = height + 1
    height

# ============================================================================
# Additional Utility Functions
# ============================================================================

# Merge two Fenwick trees (element-wise addition)
fn merge_trees(tree1, tree2) -> (list, i64):
    """Merge two Fenwick trees by adding corresponding elements.

    Both trees must have the same size.

    Args:
      tree1: First Fenwick tree
      tree2: Second Fenwick tree

    Returns:
      Merged Fenwick tree

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return tree1

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var merged = []
    var i = 0
    while i < n1:
        merged.push(arr1[i] + arr2[i])
        i = i + 1

    create_fenwick_from_array(merged)

# Subtract tree2 from tree1 (element-wise)
fn subtract_trees(tree1, tree2) -> (list, i64):
    """Subtract tree2 from tree1 element-wise.

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return tree1

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var result = []
    var i = 0
    while i < n1:
        result.push(arr1[i] - arr2[i])
        i = i + 1

    create_fenwick_from_array(result)

# Element-wise multiply two trees
fn multiply_trees(tree1, tree2) -> (list, i64):
    """Multiply two trees element-wise.

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return tree1

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var result = []
    var i = 0
    while i < n1:
        result.push(arr1[i] * arr2[i])
        i = i + 1

    create_fenwick_from_array(result)

# Get average value
fn average_value(fenwick_tree) -> i64:
    """Calculate average of all elements.

    Returns integer division result.

    Time: O(log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0
    val sum = total_sum(fenwick_tree)
    sum / n

# Get median value (approximate)
fn median_value(fenwick_tree) -> i64:
    """Find median value (middle element).

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    val arr = tree_to_array(fenwick_tree)
    val sorted_arr = arr.sort()
    sorted_arr[n / 2]

# Reverse tree elements
fn reverse_tree(fenwick_tree) -> (list, i64):
    """Reverse the order of elements in tree.

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var reversed = []
    var i = n - 1
    while i >= 0:
        reversed.push(arr[i])
        i = i - 1

    create_fenwick_from_array(reversed)

# Rotate tree left by k positions
fn rotate_left(fenwick_tree, k: i64) -> (list, i64):
    """Rotate tree elements left by k positions.

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    if n == 0:
        return fenwick_tree

    val rot = k % n
    var rotated = []

    var i = rot
    while i < n:
        rotated.push(arr[i])
        i = i + 1

    i = 0
    while i < rot:
        rotated.push(arr[i])
        i = i + 1

    create_fenwick_from_array(rotated)

# Rotate tree right by k positions
fn rotate_right(fenwick_tree, k: i64) -> (list, i64):
    """Rotate tree elements right by k positions.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return fenwick_tree
    rotate_left(fenwick_tree, n - (k % n))

# Slice tree (extract subrange)
fn slice_tree(fenwick_tree, start: i64, end: i64) -> (list, i64):
    """Extract slice [start, end] from tree.

    Args:
      fenwick_tree: Source tree
      start: 1-indexed start position (inclusive)
      end: 1-indexed end position (inclusive)

    Returns:
      New Fenwick tree with sliced elements

    Time: O(n log n)
    """
    if start > end:
        return create_fenwick_tree(0)

    val arr = tree_to_array(fenwick_tree)
    var sliced = []

    var i = start - 1
    while i < end:
        if i >= 0:
            if i < arr.len():
                sliced.push(arr[i])
        i = i + 1

    create_fenwick_from_array(sliced)

# Concatenate two trees
fn concat_trees(tree1, tree2) -> (list, i64):
    """Concatenate two Fenwick trees.

    Time: O(n log n)
    """
    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var concat = []
    var i = 0
    while i < arr1.len():
        concat.push(arr1[i])
        i = i + 1

    i = 0
    while i < arr2.len():
        concat.push(arr2[i])
        i = i + 1

    create_fenwick_from_array(concat)

# Find first positive value
fn find_first_positive(fenwick_tree) -> i64:
    """Find index of first positive element.

    Returns -1 if no positive element found.

    Time: O(n log n)
    """
    val n = fenwick_tree.1

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > 0:
            return i
        i = i + 1

    -1

# Find first negative value
fn find_first_negative(fenwick_tree) -> i64:
    """Find index of first negative element.

    Returns -1 if no negative element found.

    Time: O(n log n)
    """
    val n = fenwick_tree.1

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < 0:
            return i
        i = i + 1

    -1

# Find index of maximum value
fn find_max_index(fenwick_tree) -> i64:
    """Find index of maximum element.

    Returns -1 if tree is empty.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return -1

    var max_idx = 1
    var max_val = point_query(fenwick_tree, 1)

    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > max_val:
            max_val = val
            max_idx = i
        i = i + 1

    max_idx

# Find index of minimum value
fn find_min_index(fenwick_tree) -> i64:
    """Find index of minimum element.

    Returns -1 if tree is empty.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return -1

    var min_idx = 1
    var min_val = point_query(fenwick_tree, 1)

    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < min_val:
            min_val = val
            min_idx = i
        i = i + 1

    min_idx

# Check if two trees are equal
fn trees_equal(tree1, tree2) -> bool:
    """Check if two Fenwick trees have equal elements.

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return false

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var i = 0
    while i < n1:
        if arr1[i] != arr2[i]:
            return false
        i = i + 1

    true

# Apply function to all elements
fn map_tree(fenwick_tree, fn_transform) -> (list, i64):
    """Apply transformation function to all elements.

    Args:
      fenwick_tree: Source tree
      fn_transform: Function i64 -> i64

    Returns:
      New tree with transformed values

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var mapped = []
    var i = 0
    while i < n:
        mapped.push(fn_transform(arr[i]))
        i = i + 1

    create_fenwick_from_array(mapped)

# Filter elements by predicate
fn filter_tree(fenwick_tree, predicate) -> (list, i64):
    """Filter elements matching predicate.

    Args:
      fenwick_tree: Source tree
      predicate: Function i64 -> bool

    Returns:
      New tree with filtered elements

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var filtered = []
    var i = 0
    while i < n:
        if predicate(arr[i]):
            filtered.push(arr[i])
        i = i + 1

    create_fenwick_from_array(filtered)

# Reduce tree to single value
fn reduce_tree(fenwick_tree, initial, fn_reduce) -> i64:
    """Reduce tree to single value using accumulator function.

    Args:
      fenwick_tree: Source tree
      initial: Initial accumulator value
      fn_reduce: Function (i64, i64) -> i64

    Returns:
      Reduced value

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var acc = initial
    var i = 0
    while i < n:
        acc = fn_reduce(acc, arr[i])
        i = i + 1

    acc
