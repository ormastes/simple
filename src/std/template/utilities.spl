# Template Engine Utilities Module
# String manipulation and character utilities

import string

# ============================================================================
# CHARACTER AND STRING UTILITIES
# ============================================================================

fn is_whitespace_char(c: text) -> bool:
    c == " " or c == "\t" or c == "\n" or c == "\r"

fn is_alpha_char(c: text) -> bool:
    val code = char_code(c)
    (code >= 65 and code <= 90) or (code >= 97 and code <= 122)

fn is_digit_char(c: text) -> bool:
    val code = char_code(c)
    code >= 48 and code <= 57

fn is_alnum_char(c: text) -> bool:
    is_alpha_char(c) or is_digit_char(c)

fn char_at_safe(s: text, idx: i64) -> text:
    if idx < 0 or idx >= s.len():
        return ""
    s[idx:idx+1]

fn substr_safe(s: text, start: i64, end_val: i64) -> text:
    var s_val = start
    var e_val = end_val
    if s_val < 0:
        s_val = 0
    if e_val > s.len():
        e_val = s.len()
    if s_val >= e_val:
        return ""
    s[s_val:e_val]

fn str_index_of(haystack: text, needle: text) -> i64:
    val h_len = haystack.len()
    val n_len = needle.len()
    if n_len == 0 or n_len > h_len:
        return -1
    var i = 0
    while i <= h_len - n_len:
        var match = true
        var j = 0
        while j < n_len:
            if haystack[i+j:i+j+1] != needle[j:j+1]:
                match = false
                j = n_len
            j = j + 1
        if match:
            return i
        i = i + 1
    -1

fn str_contains(haystack: text, needle: text) -> bool:
    str_index_of(haystack, needle) >= 0

fn str_starts_with(s: text, prefix: text) -> bool:
    val p_len = prefix.len()
    if s.len() < p_len:
        return false
    s[0:p_len] == prefix

fn str_ends_with(s: text, suffix: text) -> bool:
    val s_len = s.len()
    val suf_len = suffix.len()
    if s_len < suf_len:
        return false
    s[s_len - suf_len:s_len] == suffix

fn str_trim(s: text) -> text:
    var result = s
    while result.len() > 0 and is_whitespace_char(result[0:1]):
        result = result[1:]
    while result.len() > 0 and is_whitespace_char(result[result.len()-1:result.len()]):
        result = result[0:result.len()-1]
    result

fn str_trim_left(s: text) -> text:
    var result = s
    while result.len() > 0 and is_whitespace_char(result[0:1]):
        result = result[1:]
    result

fn str_trim_right(s: text) -> text:
    var result = s
    while result.len() > 0 and is_whitespace_char(result[result.len()-1:result.len()]):
        result = result[0:result.len()-1]
    result

fn str_split(s: text, delim: text) -> [text]:
    var result: [text] = []
    val s_len = s.len()
    val d_len = delim.len()
    if d_len == 0:
        result.push(s)
        return result
    var start = 0
    var i = 0
    while i <= s_len - d_len:
        var match = true
        var j = 0
        while j < d_len:
            if s[i+j:i+j+1] != delim[j:j+1]:
                match = false
                j = d_len
            j = j + 1
        if match:
            result.push(s[start:i])
            i = i + d_len
            start = i
        else:
            i = i + 1
    result.push(s[start:s_len])
    result

fn str_replace_all(s: text, old: text, new_val: text) -> text:
    val parts = str_split(s, old)
    join_strs(parts, new_val)

fn str_to_lower(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        if code >= 65 and code <= 90:
            result = result + char_from_code(code + 32)
        else:
            result = result + c
        i = i + 1
    result

fn str_to_upper(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        if code >= 97 and code <= 122:
            result = result + char_from_code(code - 32)
        else:
            result = result + c
        i = i + 1
    result

fn str_capitalize(s: text) -> text:
    if s.len() == 0:
        return s
    val first = str_to_upper(s[0:1])
    val rest = s[1:]
    first + rest

fn str_reverse(s: text) -> text:
    var result = ""
    var i = s.len() - 1
    while i >= 0:
        result = result + s[i:i+1]
        i = i - 1
    result

fn str_repeat(s: text, count: i64) -> text:
    var result = ""
    var i = 0
    while i < count:
        result = result + s
        i = i + 1
    result

fn str_truncate(s: text, max_len: i64) -> text:
    if s.len() <= max_len:
        return s
    s[0:max_len] + "..."

fn str_pad_left(s: text, width: i64, pad: text) -> text:
    var result = s
    while result.len() < width:
        result = pad + result
    result

fn str_pad_right(s: text, width: i64, pad: text) -> text:
    var result = s
    while result.len() < width:
        result = result + pad
    result

fn str_center(s: text, width: i64) -> text:
    if s.len() >= width:
        return s
    val padding = width - s.len()
    val left = padding / 2
    val right = padding - left
    str_repeat(" ", left) + s + str_repeat(" ", right)

fn int_to_str(n: i64) -> text:
    if n == 0:
        return "0"
    var is_neg = false
    var num = n
    if num < 0:
        is_neg = true
        num = -num
    var result = ""
    while num > 0:
        val digit = num % 10
        result = char_from_code(48 + digit) + result
        num = num / 10
    if is_neg:
        result = "-" + result
    result

fn str_to_int(s: text) -> i64:
    parse_i64_safe(s)

fn int_to_hex_str(n: i64) -> text:
    if n == 0:
        return "00"
    var result = ""
    var num = n
    while num > 0:
        val digit = num % 16
        if digit < 10:
            result = char_from_code(48 + digit) + result
        else:
            result = char_from_code(65 + digit - 10) + result
        num = num / 16
    if result.len() == 1:
        result = "0" + result
    result

fn hex_str_to_int(s: text) -> i64:
    var result = 0
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        var digit = 0
        if code >= 48 and code <= 57:
            digit = code - 48
        else:
            if code >= 65 and code <= 70:
                digit = code - 65 + 10
            else:
                if code >= 97 and code <= 102:
                    digit = code - 97 + 10
        result = result * 16 + digit
        i = i + 1
    result

# ============================================================================
# HTML ESCAPING
# ============================================================================

fn html_escape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "&", "&amp;")
    result = str_replace_all(result, "<", "&lt;")
    result = str_replace_all(result, ">", "&gt;")
    result = str_replace_all(result, "\"", "&quot;")
    result = str_replace_all(result, "'", "&#39;")
    result

fn html_unescape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "&lt;", "<")
    result = str_replace_all(result, "&gt;", ">")
    result = str_replace_all(result, "&quot;", "\"")
    result = str_replace_all(result, "&#39;", "'")
    result = str_replace_all(result, "&amp;", "&")
    result

fn url_encode(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        val is_safe = is_alnum_char(c) or c == "-" or c == "_" or c == "." or c == "~"
        if is_safe:
            result = result + c
        else:
            result = result + "%" + int_to_hex_str(code)
        i = i + 1
    result

fn url_decode(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        if c == "%":
            if i + 2 < s.len():
                val hex = s[i+1:i+3]
                val code = hex_str_to_int(hex)
                result = result + char_from_code(code)
                i = i + 3
            else:
                result = result + c
                i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn js_escape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "\\", "\\\\")
    result = str_replace_all(result, "\"", "\\\"")
    result = str_replace_all(result, "'", "\\'")
    result = str_replace_all(result, "\n", "\\n")
    result = str_replace_all(result, "\r", "\\r")
    result = str_replace_all(result, "\t", "\\t")
    result

fn css_escape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "\"", "\\\"")
    result = str_replace_all(result, "'", "\\'")
    result

# ============================================================================
# EXPORTS
# ============================================================================

export is_whitespace_char, is_alpha_char, is_digit_char, is_alnum_char
export char_at_safe, substr_safe
export str_index_of, str_contains, str_starts_with, str_ends_with
export str_trim, str_trim_left, str_trim_right
export str_split, str_replace_all
export str_to_lower, str_to_upper, str_capitalize, str_reverse
export str_repeat, str_truncate, str_pad_left, str_pad_right, str_center
export int_to_str, str_to_int, int_to_hex_str, hex_str_to_int
export html_escape, html_unescape, url_encode, url_decode, js_escape, css_escape
