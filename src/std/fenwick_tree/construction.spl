# Fenwick Tree Construction and Conversion Operations
#
# Purpose: Reconstruction, conversion, and transformation of trees
#
# Contains:
# - Tree to array conversion
# - Prefix sum arrays
# - Scaling and transformation
# - Tree merging and combining

# Import utilities from other modules
mod fenwick_tree.types
mod fenwick_tree.query
mod fenwick_tree.update

# ============================================================================
# Reconstruction and Conversion
# ============================================================================

# Reconstruct original array from Fenwick tree
fn tree_to_array(fenwick_tree) -> list:
    """Reconstruct the original array from a Fenwick tree.

    Returns 0-indexed array by querying each point.

    Args:
      fenwick_tree: (tree, n) tuple

    Returns:
      Original array (0-indexed)

    Time: O(n log n)
    Space: O(n)
    """
    val n = fenwick_tree.1
    var arr = []

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        arr.push(val)
        i = i + 1

    arr

# Convert Fenwick tree to list of prefix sums
fn tree_to_prefix_sums(fenwick_tree) -> list:
    """Convert Fenwick tree to array of prefix sums.

    Args:
      fenwick_tree: (tree, n) tuple

    Returns:
      Array where result[i] = prefix_sum(i+1)

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var result = []

    var i = 1
    while i <= n:
        val psum = prefix_sum(fenwick_tree, i)
        result.push(psum)
        i = i + 1

    result

# ============================================================================
# Scaling and Transformation
# ============================================================================

# Scale all values in tree by a factor
fn scale_tree(fenwick_tree, factor: i64) -> (list, i64):
    """Multiply all values in Fenwick tree by factor.

    Reconstructs array, scales it, and rebuilds tree.

    Args:
      fenwick_tree: (tree, n) tuple
      factor: Scaling factor

    Returns:
      New Fenwick tree with scaled values

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var scaled = []
    var i = 0
    while i < n:
        scaled.push(arr[i] * factor)
        i = i + 1

    create_fenwick_from_array(scaled)

# Negate all values in tree
fn negate_tree(fenwick_tree) -> (list, i64):
    """Negate all values in Fenwick tree.

    Time: O(n log n)
    """
    scale_tree(fenwick_tree, -1)

# Add constant to all elements
fn add_constant(fenwick_tree, constant: i64) -> (list, i64):
    """Add a constant value to all elements.

    Args:
      fenwick_tree: (tree, n) tuple
      constant: Value to add to each element

    Returns:
      Updated Fenwick tree

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var result = fenwick_tree

    var i = 1
    while i <= n:
        result = update(result, i, constant)
        i = i + 1

    result

# ============================================================================
# Tree Merging and Combining
# ============================================================================

# Merge two Fenwick trees (element-wise addition)
fn merge_trees(tree1, tree2) -> (list, i64):
    """Merge two Fenwick trees by adding corresponding elements.

    Both trees must have the same size.

    Args:
      tree1: First Fenwick tree
      tree2: Second Fenwick tree

    Returns:
      Merged Fenwick tree

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return tree1

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var merged = []
    var i = 0
    while i < n1:
        merged.push(arr1[i] + arr2[i])
        i = i + 1

    create_fenwick_from_array(merged)

# Subtract tree2 from tree1 (element-wise)
fn subtract_trees(tree1, tree2) -> (list, i64):
    """Subtract tree2 from tree1 element-wise.

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return tree1

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var result = []
    var i = 0
    while i < n1:
        result.push(arr1[i] - arr2[i])
        i = i + 1

    create_fenwick_from_array(result)

# Element-wise multiply two trees
fn multiply_trees(tree1, tree2) -> (list, i64):
    """Multiply two trees element-wise.

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return tree1

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var result = []
    var i = 0
    while i < n1:
        result.push(arr1[i] * arr2[i])
        i = i + 1

    create_fenwick_from_array(result)

# Concatenate two trees
fn concat_trees(tree1, tree2) -> (list, i64):
    """Concatenate two Fenwick trees.

    Time: O(n log n)
    """
    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var concat = []
    var i = 0
    while i < arr1.len():
        concat.push(arr1[i])
        i = i + 1

    i = 0
    while i < arr2.len():
        concat.push(arr2[i])
        i = i + 1

    create_fenwick_from_array(concat)

# Reverse tree elements
fn reverse_tree(fenwick_tree) -> (list, i64):
    """Reverse the order of elements in tree.

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var reversed = []
    var i = n - 1
    while i >= 0:
        reversed.push(arr[i])
        i = i - 1

    create_fenwick_from_array(reversed)

# Rotate tree left by k positions
fn rotate_left(fenwick_tree, k: i64) -> (list, i64):
    """Rotate tree elements left by k positions.

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    if n == 0:
        return fenwick_tree

    val rot = k % n
    var rotated = []

    var i = rot
    while i < n:
        rotated.push(arr[i])
        i = i + 1

    i = 0
    while i < rot:
        rotated.push(arr[i])
        i = i + 1

    create_fenwick_from_array(rotated)

# Rotate tree right by k positions
fn rotate_right(fenwick_tree, k: i64) -> (list, i64):
    """Rotate tree elements right by k positions.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return fenwick_tree
    rotate_left(fenwick_tree, n - (k % n))

# Slice tree (extract subrange)
fn slice_tree(fenwick_tree, start: i64, end: i64) -> (list, i64):
    """Extract slice [start, end] from tree.

    Args:
      fenwick_tree: Source tree
      start: 1-indexed start position (inclusive)
      end: 1-indexed end position (inclusive)

    Returns:
      New Fenwick tree with sliced elements

    Time: O(n log n)
    """
    if start > end:
        return create_fenwick_tree(0)

    val arr = tree_to_array(fenwick_tree)
    var sliced = []

    var i = start - 1
    while i < end:
        if i >= 0:
            if i < arr.len():
                sliced.push(arr[i])
        i = i + 1

    create_fenwick_from_array(sliced)

# Apply function to all elements
fn map_tree(fenwick_tree, fn_transform) -> (list, i64):
    """Apply transformation function to all elements.

    Args:
      fenwick_tree: Source tree
      fn_transform: Function i64 -> i64

    Returns:
      New tree with transformed values

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var mapped = []
    var i = 0
    while i < n:
        mapped.push(fn_transform(arr[i]))
        i = i + 1

    create_fenwick_from_array(mapped)

# Filter elements by predicate
fn filter_tree(fenwick_tree, predicate) -> (list, i64):
    """Filter elements matching predicate.

    Args:
      fenwick_tree: Source tree
      predicate: Function i64 -> bool

    Returns:
      New tree with filtered elements

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var filtered = []
    var i = 0
    while i < n:
        if predicate(arr[i]):
            filtered.push(arr[i])
        i = i + 1

    create_fenwick_from_array(filtered)

# Reduce tree to single value
fn reduce_tree(fenwick_tree, initial, fn_reduce) -> i64:
    """Reduce tree to single value using accumulator function.

    Args:
      fenwick_tree: Source tree
      initial: Initial accumulator value
      fn_reduce: Function (i64, i64) -> i64

    Returns:
      Reduced value

    Time: O(n log n)
    """
    val arr = tree_to_array(fenwick_tree)
    val n = arr.len()

    var acc = initial
    var i = 0
    while i < n:
        acc = fn_reduce(acc, arr[i])
        i = i + 1

    acc

# Check if two trees are equal
fn trees_equal(tree1, tree2) -> bool:
    """Check if two Fenwick trees have equal elements.

    Time: O(n log n)
    """
    val n1 = tree1.1
    val n2 = tree2.1

    if n1 != n2:
        return false

    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)

    var i = 0
    while i < n1:
        if arr1[i] != arr2[i]:
            return false
        i = i + 1

    true
