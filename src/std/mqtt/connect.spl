# ============================================================================

fn mqtt_create_connect_packet(client_id, clean_session, keep_alive, protocol_version):
    """Create a CONNECT packet."""
    var flags = 0
    if clean_session:
        flags = flags | CONNECT_FLAG_CLEAN_SESSION

    val headers = (protocol_version, flags, keep_alive, client_id, nil, nil, nil, nil, nil, nil, nil)
    mqtt_create_packet(PACKET_TYPE_CONNECT, 0, headers, nil)

fn mqtt_connect_set_credentials(packet, username, password):
    """Set username and password in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val protocol_version = parts[0]
    val old_flags = parts[1]
    val keep_alive = parts[2]
    val client_id = parts[3]
    val will_topic = parts[4]
    val will_message = parts[5]
    val will_qos = parts[6]
    val will_retain = parts[7]
    val properties = parts[8]
    val will_properties = parts[9]
    val auth_method = parts[10]

    var flags = old_flags
    if username != nil:
        flags = flags | CONNECT_FLAG_USERNAME
    if password != nil:
        flags = flags | CONNECT_FLAG_PASSWORD

    val new_headers = (protocol_version, flags, keep_alive, client_id, will_topic, will_message, will_qos, will_retain, properties, will_properties, auth_method)
    mqtt_set_packet_headers(packet, new_headers)

fn mqtt_connect_set_will(packet, will_topic, will_message, will_qos, will_retain):
    """Set Last Will and Testament in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val protocol_version = parts[0]
    val old_flags = parts[1]
    val keep_alive = parts[2]
    val client_id = parts[3]
    val properties = parts[8]
    val will_properties = parts[9]
    val auth_method = parts[10]

    var flags = old_flags | CONNECT_FLAG_WILL_FLAG

    if will_qos == 1:
        flags = flags | CONNECT_FLAG_WILL_QOS_1
    else:
        if will_qos == 2:
            flags = flags | CONNECT_FLAG_WILL_QOS_2

    if will_retain:
        flags = flags | CONNECT_FLAG_WILL_RETAIN

    val new_headers = (protocol_version, flags, keep_alive, client_id, will_topic, will_message, will_qos, will_retain, properties, will_properties, auth_method)
    mqtt_set_packet_headers(packet, new_headers)

fn mqtt_connect_get_client_id(packet):
    """Get client ID from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[3]

fn mqtt_connect_get_keep_alive(packet):
    """Get keep alive interval from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[2]

fn mqtt_connect_get_protocol_version(packet):
    """Get protocol version from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_connect_has_clean_session(packet):
    """Check if clean session flag is set in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val flags = parts[1]
    (flags & CONNECT_FLAG_CLEAN_SESSION) != 0

fn mqtt_connect_has_will(packet):
    """Check if will flag is set in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val flags = parts[1]
    (flags & CONNECT_FLAG_WILL_FLAG) != 0

fn mqtt_connect_get_will_qos(packet):
    """Get will QoS from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[6]

# ============================================================================
# CONNACK Packet Functions
# ============================================================================
