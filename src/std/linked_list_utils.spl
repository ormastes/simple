# Linked List Utilities Module
#
# Comprehensive linked list implementation for Simple language.
# Uses tuple representation: (value, next) for nodes.
# nil represents empty list.
#
# Examples:
#   val list = ll_from_array([1, 2, 3])
#   val mapped = ll_map(list, \x: x * 2)
#   val reversed = ll_reverse(list)

# ============================================================================
# SINGLY LINKED LIST - CONSTRUCTION
# ============================================================================

# Create an empty linked list
# Returns: nil
fn ll_empty():
    nil

# Create a single-node list
# Args:
#   value: The value to store in the node
# Returns: A list with one node
fn ll_singleton(value):
    (value, nil)

# Create a linked list from an array
# Args:
#   arr: Array of values
# Returns: Linked list containing all array elements
fn ll_from_array(arr):
    var result = nil
    var i = arr.length() - 1
    while i >= 0:
        result = (arr[i], result)
        i = i - 1
    result

# Convert linked list to array
# Args:
#   list: Linked list to convert
# Returns: Array containing all list elements
fn ll_to_array(list):
    var result = []
    var current = list
    while current != nil:
        result = result.push(current[0])
        current = current[1]
    result

# ============================================================================
# SINGLY LINKED LIST - BASIC OPERATIONS
# ============================================================================

# Prepend a value to the front of the list
# Args:
#   value: Value to prepend
#   list: Existing list
# Returns: New list with value at front
fn ll_prepend(value, list):
    (value, list)

# Append a value to the end of the list
# Args:
#   value: Value to append
#   list: Existing list
# Returns: New list with value at end
fn ll_append(value, list):
    if list == nil:
        (value, nil)
    else:
        var arr = ll_to_array(list)
        arr = arr.push(value)
        ll_from_array(arr)

# Get the first element (head) of the list
# Args:
#   list: Linked list
# Returns: First element or nil if empty
fn ll_head(list):
    if list == nil:
        nil
    else:
        list[0]

# Get the tail (all elements except first)
# Args:
#   list: Linked list
# Returns: List without first element, or nil if empty
fn ll_tail(list):
    if list == nil:
        nil
    else:
        list[1]

# Get element at specific index
# Args:
#   list: Linked list
#   index: Zero-based index
# Returns: Element at index or nil if out of bounds
fn ll_get(list, index):
    var current = list
    var i = 0
    while current != nil:
        if i == index:
            return current[0]
        i = i + 1
        current = current[1]
    nil

# Insert value at specific index
# Args:
#   list: Linked list
#   index: Zero-based index
#   value: Value to insert
# Returns: New list with value inserted
fn ll_insert(list, index, value):
    if index == 0:
        ll_prepend(value, list)
    else:
        var arr = ll_to_array(list)
        var new_arr = []
        var i = 0
        while i < arr.length():
            if i == index:
                new_arr = new_arr.push(value)
            new_arr = new_arr.push(arr[i])
            i = i + 1
        if index >= arr.length():
            new_arr = new_arr.push(value)
        ll_from_array(new_arr)

# Remove first occurrence of value
# Args:
#   list: Linked list
#   value: Value to remove
# Returns: New list without first occurrence of value
fn ll_remove(list, value):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        if head == value:
            tail
        else:
            (head, ll_remove(tail, value))

# Remove element at specific index
# Args:
#   list: Linked list
#   index: Zero-based index
# Returns: New list without element at index
fn ll_remove_at(list, index):
    if index == 0:
        ll_tail(list)
    else:
        var arr = ll_to_array(list)
        var new_arr = []
        var i = 0
        while i < arr.length():
            if i != index:
                new_arr = new_arr.push(arr[i])
            i = i + 1
        ll_from_array(new_arr)

# ============================================================================
# SINGLY LINKED LIST - PREDICATES
# ============================================================================

# Check if list is empty
# Args:
#   list: Linked list
# Returns: true if empty, false otherwise
fn ll_is_empty(list):
    list == nil

# Get length of list
# Args:
#   list: Linked list
# Returns: Number of elements
fn ll_length(list):
    var count = 0
    var current = list
    while current != nil:
        count = count + 1
        current = current[1]
    count

# Check if list contains value
# Args:
#   list: Linked list
#   value: Value to search for
# Returns: true if value found, false otherwise
fn ll_contains(list, value):
    var current = list
    while current != nil:
        if current[0] == value:
            return true
        current = current[1]
    false

# Find first element matching predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: First matching value or nil
fn ll_find(list, pred):
    var current = list
    while current != nil:
        var val = current[0]
        if pred(val):
            return val
        current = current[1]
    nil

# Find index of first occurrence of value
# Args:
#   list: Linked list
#   value: Value to search for
# Returns: Index of value or -1 if not found
fn ll_index_of(list, value):
    var current = list
    var index = 0
    while current != nil:
        if current[0] == value:
            return index
        index = index + 1
        current = current[1]
    -1

# Check if all elements satisfy predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: true if all elements match, false otherwise
fn ll_all(list, pred):
    var current = list
    while current != nil:
        var val = current[0]
        if !pred(val):
            return false
        current = current[1]
    true

# Check if any element satisfies predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: true if any element matches, false otherwise
fn ll_any(list, pred):
    var current = list
    while current != nil:
        var val = current[0]
        if pred(val):
            return true
        current = current[1]
    false

# ============================================================================
# SINGLY LINKED LIST - TRANSFORMATIONS
# ============================================================================

# Map function over list
# Args:
#   list: Linked list
#   f: Function to apply (value -> new_value)
# Returns: New list with function applied to each element
fn ll_map(list, f):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        (f(head), ll_map(tail, f))

# Filter list by predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: New list containing only matching elements
fn ll_filter(list, pred):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        var filtered_tail = ll_filter(tail, pred)
        if pred(head):
            (head, filtered_tail)
        else:
            filtered_tail

# Reverse a linked list
# Args:
#   list: Linked list
# Returns: New list with elements in reverse order
fn ll_reverse(list):
    var result = nil
    var current = list
    while current != nil:
        result = (current[0], result)
        current = current[1]
    result

# Concatenate two lists
# Args:
#   list1: First linked list
#   list2: Second linked list
# Returns: New list with list2 appended to list1
fn ll_concat(list1, list2):
    if list1 == nil:
        list2
    else:
        var head = list1[0]
        var tail = list1[1]
        (head, ll_concat(tail, list2))

# Flatten a list of lists
# Args:
#   list_of_lists: Linked list where each element is a linked list
# Returns: Single list with all elements
fn ll_flatten(list_of_lists):
    if list_of_lists == nil:
        nil
    else:
        var head = list_of_lists[0]
        var tail = list_of_lists[1]
        ll_concat(head, ll_flatten(tail))

# ============================================================================
# SINGLY LINKED LIST - FOLDING
# ============================================================================

# Fold left (reduce from left to right)
# Args:
#   list: Linked list
#   init: Initial accumulator value
#   f: Fold function (acc, value -> new_acc)
# Returns: Final accumulator value
fn ll_foldl(list, init, f):
    var acc = init
    var current = list
    while current != nil:
        acc = f(acc, current[0])
        current = current[1]
    acc

# Fold right (reduce from right to left)
# Args:
#   list: Linked list
#   init: Initial accumulator value
#   f: Fold function (value, acc -> new_acc)
# Returns: Final accumulator value
fn ll_foldr(list, init, f):
    if list == nil:
        init
    else:
        var head = list[0]
        var tail = list[1]
        f(head, ll_foldr(tail, init, f))

# Sum all numeric elements
# Args:
#   list: Linked list of numbers
# Returns: Sum of all elements
fn ll_sum(list):
    ll_foldl(list, 0, \acc, x: acc + x)

# Product of all numeric elements
# Args:
#   list: Linked list of numbers
# Returns: Product of all elements
fn ll_product(list):
    ll_foldl(list, 1, \acc, x: acc * x)

# ============================================================================
# SINGLY LINKED LIST - UTILITIES
# ============================================================================

# Split list at index
# Args:
#   list: Linked list
#   index: Index to split at
# Returns: Tuple of (before, after) where before has index elements
fn ll_split_at(list, index):
    var before = []
    var current = list
    var i = 0
    while i < index:
        if current == nil:
            break
        before = before.push(current[0])
        current = current[1]
        i = i + 1
    (ll_from_array(before), current)

# Take first n elements
# Args:
#   list: Linked list
#   n: Number of elements to take
# Returns: New list with first n elements
fn ll_take(list, n):
    var result = ll_split_at(list, n)
    result[0]

# Drop first n elements
# Args:
#   list: Linked list
#   n: Number of elements to drop
# Returns: New list without first n elements
fn ll_drop(list, n):
    var result = ll_split_at(list, n)
    result[1]

# Take elements while predicate is true
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: New list with leading elements matching predicate
fn ll_take_while(list, pred):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        if pred(head):
            (head, ll_take_while(tail, pred))
        else:
            nil

# Drop elements while predicate is true
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: New list without leading elements matching predicate
fn ll_drop_while(list, pred):
    var current = list
    while current != nil:
        var head = current[0]
        if !pred(head):
            return current
        current = current[1]
    nil

# Zip two lists into list of pairs
# Args:
#   list1: First linked list
#   list2: Second linked list
# Returns: New list of tuples (elem1, elem2)
fn ll_zip(list1, list2):
    if list1 == nil:
        nil
    else:
        if list2 == nil:
            nil
        else:
            var head1 = list1[0]
            var tail1 = list1[1]
            var head2 = list2[0]
            var tail2 = list2[1]
            ((head1, head2), ll_zip(tail1, tail2))

# Partition list by predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: Tuple of (matching, non_matching) lists
fn ll_partition(list, pred):
    var matching = []
    var non_matching = []
    var current = list
    while current != nil:
        var val = current[0]
        if pred(val):
            matching = matching.push(val)
        else:
            non_matching = non_matching.push(val)
        current = current[1]
    (ll_from_array(matching), ll_from_array(non_matching))

# Get last element of list
# Args:
#   list: Linked list
# Returns: Last element or nil if empty
fn ll_last(list):
    if list == nil:
        nil
    else:
        var current = list
        var last = current[0]
        while current != nil:
            last = current[0]
            current = current[1]
        last

# Get all elements except last
# Args:
#   list: Linked list
# Returns: New list without last element
fn ll_init(list):
    if list == nil:
        nil
    else:
        var arr = ll_to_array(list)
        if arr.length() <= 1:
            nil
        else:
            var new_arr = []
            var i = 0
            while i < arr.length() - 1:
                new_arr = new_arr.push(arr[i])
                i = i + 1
            ll_from_array(new_arr)

# ============================================================================
# SINGLY LINKED LIST - SORTING
# ============================================================================

# Merge two sorted lists
# Args:
#   list1: First sorted linked list
#   list2: Second sorted linked list
#   cmp: Comparison function (a, b -> bool) returns true if a <= b
# Returns: Merged sorted list
fn ll_merge(list1, list2, cmp):
    if list1 == nil:
        list2
    else:
        if list2 == nil:
            list1
        else:
            var head1 = list1[0]
            var tail1 = list1[1]
            var head2 = list2[0]
            var tail2 = list2[1]
            var should_take_first = cmp(head1, head2)
            if should_take_first:
                (head1, ll_merge(tail1, list2, cmp))
            else:
                (head2, ll_merge(list1, tail2, cmp))

# Merge sort for linked lists
# Args:
#   list: Linked list to sort
#   cmp: Comparison function (a, b -> bool) returns true if a <= b
# Returns: Sorted linked list
fn ll_merge_sort(list, cmp):
    if list == nil:
        nil
    else:
        var tail = list[1]
        if tail == nil:
            list
        else:
            var len = ll_length(list)
            var mid = len / 2
            var split = ll_split_at(list, mid)
            var left = split[0]
            var right = split[1]
            var sorted_left = ll_merge_sort(left, cmp)
            var sorted_right = ll_merge_sort(right, cmp)
            ll_merge(sorted_left, sorted_right, cmp)

# Sort list in ascending order (for numbers)
# Args:
#   list: Linked list of numbers
# Returns: Sorted linked list
fn ll_sort(list):
    ll_merge_sort(list, \a, b: a <= b)

# Sort list in descending order (for numbers)
# Args:
#   list: Linked list of numbers
# Returns: Reverse sorted linked list
fn ll_sort_desc(list):
    ll_merge_sort(list, \a, b: a >= b)

# ============================================================================
# SINGLY LINKED LIST - CYCLE DETECTION
# ============================================================================

# Detect cycle using Floyd's algorithm (tortoise and hare)
# Args:
#   list: Linked list (potentially with cycle)
# Returns: true if cycle exists, false otherwise
#
# Note: This implementation assumes proper node structure.
# In practice, cycles cannot be created with immutable tuples,
# but this demonstrates the algorithm conceptually.
fn ll_has_cycle(list):
    if list == nil:
        return false

    var slow = list
    var fast = list

    while fast != nil:
        var fast_next = fast[1]
        if fast_next == nil:
            return false

        slow = slow[1]
        fast = fast_next[1]

        if slow == fast:
            return true

    false

# Find cycle start node (Floyd's algorithm phase 2)
# Args:
#   list: Linked list with cycle
# Returns: Value at cycle start, or nil if no cycle
#
# Note: Conceptual implementation - cycles cannot exist with immutable tuples
fn ll_find_cycle_start(list):
    if list == nil:
        return nil

    var slow = list
    var fast = list
    var has_cycle = false

    while fast != nil:
        var fast_next = fast[1]
        if fast_next == nil:
            return nil

        slow = slow[1]
        fast = fast_next[1]

        if slow == fast:
            has_cycle = true
            break

    if !has_cycle:
        return nil

    slow = list
    while slow != fast:
        slow = slow[1]
        fast = fast[1]

    slow[0]

# ============================================================================
# DOUBLY LINKED LIST
# ============================================================================

# Doubly linked list node: (value, prev, next)
# where prev and next are also nodes or nil

# Create empty doubly linked list
# Returns: nil
fn dll_empty():
    nil

# Create doubly linked list from array
# Args:
#   arr: Array of values
# Returns: Doubly linked list (first node)
fn dll_from_array(arr):
    if arr.length() == 0:
        return nil

    var nodes = []
    var i = 0
    while i < arr.length():
        nodes = nodes.push((arr[i], nil, nil))
        i = i + 1

    i = 0
    while i < nodes.length():
        var prev = nil
        var next = nil

        if i > 0:
            prev = nodes[i - 1]

        if i < nodes.length() - 1:
            next = nodes[i + 1]

        nodes[i] = (nodes[i][0], prev, next)
        i = i + 1

    if nodes.length() > 0:
        nodes[0]
    else:
        nil

# Convert doubly linked list to array
# Args:
#   list: Doubly linked list
# Returns: Array of values
fn dll_to_array(list):
    var result = []
    var current = list
    while current != nil:
        result = result.push(current[0])
        current = current[2]
    result

# Get value from doubly linked list node
# Args:
#   node: Doubly linked list node
# Returns: Value or nil
fn dll_value(node):
    if node == nil:
        nil
    else:
        node[0]

# Get previous node in doubly linked list
# Args:
#   node: Doubly linked list node
# Returns: Previous node or nil
fn dll_prev(node):
    if node == nil:
        nil
    else:
        node[1]

# Get next node in doubly linked list
# Args:
#   node: Doubly linked list node
# Returns: Next node or nil
fn dll_next(node):
    if node == nil:
        nil
    else:
        node[2]

# Traverse doubly linked list forward
# Args:
#   node: Starting node
# Returns: Array of values from node to end
fn dll_traverse_forward(node):
    var result = []
    var current = node
    while current != nil:
        result = result.push(current[0])
        current = current[2]
    result

# Traverse doubly linked list backward
# Args:
#   node: Starting node
# Returns: Array of values from node to beginning (reversed)
fn dll_traverse_backward(node):
    var result = []
    var current = node
    while current != nil:
        result = result.push(current[0])
        current = current[1]
    result

# Find last node in doubly linked list
# Args:
#   list: Doubly linked list (first node)
# Returns: Last node or nil
fn dll_last_node(list):
    if list == nil:
        return nil

    var current = list
    while current[2] != nil:
        current = current[2]
    current

# Find first node in doubly linked list (from any node)
# Args:
#   node: Any node in doubly linked list
# Returns: First node or nil
fn dll_first_node(node):
    if node == nil:
        return nil

    var current = node
    while current[1] != nil:
        current = current[1]
    current

# Get length of doubly linked list
# Args:
#   list: Doubly linked list
# Returns: Number of nodes
fn dll_length(list):
    var count = 0
    var current = list
    while current != nil:
        count = count + 1
        current = current[2]
    count

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Print linked list for debugging
# Args:
#   list: Linked list
# Returns: String representation
fn ll_to_string(list):
    var arr = ll_to_array(list)
    var result = "["
    var i = 0
    while i < arr.length():
        result = result + arr[i].to_string()
        if i < arr.length() - 1:
            result = result + ", "
        i = i + 1
    result = result + "]"
    result

# Print doubly linked list for debugging
# Args:
#   list: Doubly linked list
# Returns: String representation
fn dll_to_string(list):
    var arr = dll_to_array(list)
    var result = "["
    var i = 0
    while i < arr.length():
        result = result + arr[i].to_string()
        if i < arr.length() - 1:
            result = result + " <-> "
        i = i + 1
    result = result + "]"
    result

# Compare two lists for equality
# Args:
#   list1: First linked list
#   list2: Second linked list
# Returns: true if lists contain same elements in same order
fn ll_equal(list1, list2):
    if list1 == nil:
        if list2 == nil:
            return true
        else:
            return false

    if list2 == nil:
        return false

    var head1 = list1[0]
    var head2 = list2[0]

    if head1 != head2:
        return false

    ll_equal(list1[1], list2[1])

# Intersperse value between list elements
# Args:
#   list: Linked list
#   sep: Separator value
# Returns: New list with separator between elements
fn ll_intersperse(list, sep):
    if list == nil:
        nil
    else:
        var tail = list[1]
        if tail == nil:
            list
        else:
            var head = list[0]
            (head, (sep, ll_intersperse(tail, sep)))

# Group consecutive equal elements
# Args:
#   list: Linked list
# Returns: List of lists, each containing equal consecutive elements
fn ll_group(list):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        var group = [head]
        var rest = tail

        while rest != nil:
            var next_val = rest[0]
            if next_val == head:
                group = group.push(next_val)
                rest = rest[1]
            else:
                break

        (ll_from_array(group), ll_group(rest))

# Remove duplicates from sorted list
# Args:
#   list: Sorted linked list
# Returns: New list without consecutive duplicates
fn ll_nub_sorted(list):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        var rest = ll_drop_while(tail, \x: x == head)
        (head, ll_nub_sorted(rest))

# Rotate list left by n positions
# Args:
#   list: Linked list
#   n: Number of positions to rotate
# Returns: Rotated list
fn ll_rotate_left(list, n):
    var len = ll_length(list)
    if len == 0:
        return nil

    var rotations = n % len
    if rotations == 0:
        return list

    var split = ll_split_at(list, rotations)
    ll_concat(split[1], split[0])

# Rotate list right by n positions
# Args:
#   list: Linked list
#   n: Number of positions to rotate
# Returns: Rotated list
fn ll_rotate_right(list, n):
    var len = ll_length(list)
    if len == 0:
        return nil

    var rotations = n % len
    if rotations == 0:
        return list

    ll_rotate_left(list, len - rotations)
