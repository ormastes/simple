# Runtime Value - Tagged Pointer Representation
#
# Zero-allocation value representation using tag bits in the low 3 bits.
# Enables efficient storage of primitives (int, float, bool, nil) without heap allocation.
#
# Architecture:
# - 64-bit values with 3-bit tags in low bits
# - Heap pointers use tag 0b000 (naturally 8-byte aligned)
# - Immediate values use tags 0b001-0b100
# - NaN-boxing for floats (IEEE 754 quiet NaN range)
#
# Memory Layout (64 bits):
# ┌─────────────────────────────────────────────────────────┬─────┐
# │                 61 bits payload                          │ 3   │
# │                                                          │bits │
# └─────────────────────────────────────────────────────────┴─────┘
#
# Tag Encoding:
# - 0b000: Heap pointer (8-byte aligned, no tag bits set)
# - 0b001: Immediate integer (61-bit signed, tag in low 3 bits)
# - 0b010: Float (NaN-boxing, uses quiet NaN range)
# - 0b011: Bool (0 = false, 1 = true in bit 3)
# - 0b100: Nil
# - 0b101-0b111: Reserved for future use
#
# Performance:
# - No allocation for int/float/bool/nil
# - Single 64-bit load/store for all types
# - Fast type checking (mask & compare)
# - Cache-friendly (fits in register)

use std.atomic.*

# ============================================================================
# Tag Constants
# ============================================================================

val TAG_MASK: i64 = 0b111  # Low 3 bits for tag
val TAG_SHIFT: i32 = 3

# Tag values
val TAG_PTR: i64 = 0b000    # Heap pointer (8-byte aligned)
val TAG_INT: i64 = 0b001    # Immediate integer
val TAG_FLOAT: i64 = 0b010  # NaN-boxed float
val TAG_BOOL: i64 = 0b011   # Boolean
val TAG_NIL: i64 = 0b100    # Nil/null

# Payload masks
val INT_PAYLOAD_MASK: i64 = not TAG_MASK  # 61 bits for integer
val PTR_PAYLOAD_MASK: i64 = not TAG_MASK  # Pointer address

# Boolean values (stored in bit 3, tag in bits 0-2)
val BOOL_FALSE: i64 = TAG_BOOL  # 0b011
val BOOL_TRUE: i64 = TAG_BOOL or (1 << TAG_SHIFT)  # 0b1011

# NaN-boxing constants
# IEEE 754 double: sign(1) exponent(11) mantissa(52)
# Quiet NaN: exponent all 1s, mantissa != 0
val NAN_QUIET_BASE: i64 = 0x7FF8000000000000  # Quiet NaN base

# ============================================================================
# RuntimeValue - Tagged Pointer Representation
# ============================================================================

class RuntimeValue:
    """Tagged pointer value representation.

    Stores primitives without allocation using tag bits.
    All values fit in a single 64-bit word.

    Examples:
        # Create values
        val int_val = RuntimeValue.from_int(42)
        val float_val = RuntimeValue.from_float(3.14)
        val bool_val = RuntimeValue.from_bool(true)
        val nil_val = RuntimeValue.nil()

        # Extract values
        if int_val.is_int():
            val n = int_val.as_int()
            print "Integer: {n}"

        # Type checking
        if not nil_val.is_nil():
            # Use value
    """
    bits: i64  # Tagged 64-bit value

    # ========================================================================
    # Constructors
    # ========================================================================

    static fn from_int(value: i64) -> RuntimeValue:
        """Create immediate integer value.

        Args:
            value: Integer value (must fit in 61 bits)

        Returns:
            Tagged integer value

        Note: If value doesn't fit in 61 bits, it will be truncated.
        """
        # Shift value left by 3 bits, set tag
        val shifted = (value << TAG_SHIFT) or TAG_INT
        RuntimeValue(bits: shifted)

    static fn from_float(value: f64) -> RuntimeValue:
        """Create NaN-boxed float value.

        Args:
            value: Float value

        Returns:
            Tagged float value

        Implementation: Uses NaN-boxing in IEEE 754 quiet NaN range
        """
        # Convert float to raw bits
        val float_bits = float_to_bits(value)

        # If it's already a NaN, use it directly
        if is_nan_bits(float_bits):
            return RuntimeValue(bits: float_bits or TAG_FLOAT)

        # Otherwise, encode in quiet NaN range with tag
        val tagged = NAN_QUIET_BASE or (float_bits and 0x7FFFFFFFFFFFF) or TAG_FLOAT
        RuntimeValue(bits: tagged)

    static fn from_bool(value: bool) -> RuntimeValue:
        """Create boolean value.

        Args:
            value: Boolean value

        Returns:
            Tagged boolean value
        """
        if value:
            RuntimeValue(bits: BOOL_TRUE)
        else:
            RuntimeValue(bits: BOOL_FALSE)

    static fn nil() -> RuntimeValue:
        """Create nil value.

        Returns:
            Tagged nil value
        """
        RuntimeValue(bits: TAG_NIL)

    static fn from_ptr<T>(ptr: [u8]) -> RuntimeValue:
        """Create heap pointer value.

        Args:
            ptr: Heap pointer (must be 8-byte aligned)

        Returns:
            Tagged pointer value

        Safety: Pointer must remain valid for lifetime of RuntimeValue.
        """
        val ptr_bits = ptr_to_i64(ptr)
        # Verify alignment (low 3 bits should be 0)
        if (ptr_bits and TAG_MASK) != 0:
            panic("Pointer not 8-byte aligned")
        RuntimeValue(bits: ptr_bits)

    # ========================================================================
    # Type Checking
    # ========================================================================

    fn tag() -> i64:
        """Get tag bits (low 3 bits).

        Returns:
            Tag value (0b000 to 0b111)
        """
        self.bits and TAG_MASK

    fn is_int() -> bool:
        """Check if value is immediate integer."""
        (self.bits and TAG_MASK) == TAG_INT

    fn is_float() -> bool:
        """Check if value is NaN-boxed float."""
        (self.bits and TAG_MASK) == TAG_FLOAT

    fn is_bool() -> bool:
        """Check if value is boolean."""
        (self.bits and TAG_MASK) == TAG_BOOL

    fn is_nil() -> bool:
        """Check if value is nil."""
        self.bits == TAG_NIL

    fn is_ptr() -> bool:
        """Check if value is heap pointer."""
        (self.bits and TAG_MASK) == TAG_PTR

    fn is_immediate() -> bool:
        """Check if value is non-heap (int, float, bool, or nil).

        Returns:
            true if value requires no heap allocation
        """
        not self.is_ptr()

    fn is_truthy() -> bool:
        """Check if value is truthy (for conditionals).

        Truthy values:
        - Bool: true
        - Int: non-zero
        - Float: non-zero, non-NaN
        - Ptr: non-null
        - Nil: false
        """
        if self.is_nil():
            return false
        if self.is_bool():
            return self.as_bool()
        if self.is_int():
            return self.as_int() != 0
        if self.is_float():
            val f = self.as_float()
            return f != 0.0 and not f.is_nan()
        if self.is_ptr():
            return self.bits != 0
        false

    # ========================================================================
    # Value Extraction
    # ========================================================================

    fn as_int() -> i64:
        """Extract immediate integer value.

        Returns:
            Integer value (61-bit signed)

        Panics: If value is not an integer
        """
        if not self.is_int():
            panic("Value is not an integer")
        # Shift right to remove tag, sign-extend
        self.bits >> TAG_SHIFT

    fn as_float() -> f64:
        """Extract NaN-boxed float value.

        Returns:
            Float value

        Panics: If value is not a float
        """
        if not self.is_float():
            panic("Value is not a float")
        # Remove tag and convert bits to float
        val float_bits = self.bits and (not TAG_MASK)
        bits_to_float(float_bits)

    fn as_bool() -> bool:
        """Extract boolean value.

        Returns:
            Boolean value

        Panics: If value is not a boolean
        """
        if not self.is_bool():
            panic("Value is not a boolean")
        # Check bit 3 (value bit)
        (self.bits and (1 << TAG_SHIFT)) != 0

    fn as_ptr<T>() -> [u8]:
        """Extract heap pointer.

        Returns:
            Heap pointer

        Panics: If value is not a pointer
        """
        if not self.is_ptr():
            panic("Value is not a pointer")
        i64_to_ptr(self.bits)

    # ========================================================================
    # Safe Extraction (Returns Option)
    # ========================================================================

    fn try_as_int() -> i64?:
        """Try to extract integer value.

        Returns:
            Some(value) if integer, nil otherwise
        """
        if self.is_int():
            Some(self.as_int())
        else:
            nil

    fn try_as_float() -> f64?:
        """Try to extract float value.

        Returns:
            Some(value) if float, nil otherwise
        """
        if self.is_float():
            Some(self.as_float())
        else:
            nil

    fn try_as_bool() -> bool?:
        """Try to extract boolean value.

        Returns:
            Some(value) if boolean, nil otherwise
        """
        if self.is_bool():
            Some(self.as_bool())
        else:
            nil

    fn try_as_ptr<T>() -> [u8]?:
        """Try to extract pointer.

        Returns:
            Some(ptr) if pointer, nil otherwise
        """
        if self.is_ptr():
            Some(self.as_ptr())
        else:
            nil

    # ========================================================================
    # Conversions & Display
    # ========================================================================

    fn to_string() -> text:
        """Convert value to string representation.

        Returns:
            String representation of value
        """
        if self.is_int():
            val n = self.as_int()
            return "{n}"
        if self.is_float():
            val f = self.as_float()
            return "{f}"
        if self.is_bool():
            val b = self.as_bool()
            return if b: "true" else: "false"
        if self.is_nil():
            return "nil"
        if self.is_ptr():
            val ptr = self.bits
            return "<ptr:0x{ptr:x}>"
        "<unknown>"

    fn type_name() -> text:
        """Get type name as string.

        Returns:
            "int", "float", "bool", "nil", "ptr", or "unknown"
        """
        if self.is_int():
            return "int"
        if self.is_float():
            return "float"
        if self.is_bool():
            return "bool"
        if self.is_nil():
            return "nil"
        if self.is_ptr():
            return "ptr"
        "unknown"

# ============================================================================
# AtomicValue - Thread-Safe Tagged Pointer
# ============================================================================

class AtomicValue:
    """Thread-safe atomic tagged pointer value.

    Uses AtomicI64 for lock-free concurrent access.
    All operations are atomic and thread-safe.

    Example:
        val atomic_val = AtomicValue(RuntimeValue.from_int(0))

        # Atomic increment pattern
        var old_val = atomic_val.load(MemoryOrdering.Relaxed)
        while true:
            if not old_val.is_int():
                break
            val old_int = old_val.as_int()
            val new_val = RuntimeValue.from_int(old_int + 1)
            match atomic_val.compare_exchange(
                old_val, new_val,
                MemoryOrdering.Release,
                MemoryOrdering.Relaxed
            ):
                case Ok(_): break
                case Err(current):
                    old_val = current
    """
    atomic: AtomicI64  # Atomic 64-bit value

    static fn new(value: RuntimeValue) -> AtomicValue:
        """Create atomic value with initial value."""
        AtomicValue(atomic: AtomicI64(value.bits))

    fn load(ordering: MemoryOrdering) -> RuntimeValue:
        """Load value atomically.

        Args:
            ordering: Memory ordering (Acquire, SeqCst, or Relaxed)

        Returns:
            Current value
        """
        val bits = self.atomic.load(ordering)
        RuntimeValue(bits: bits)

    me store(value: RuntimeValue, ordering: MemoryOrdering):
        """Store value atomically.

        Args:
            value: New value
            ordering: Memory ordering (Release, SeqCst, or Relaxed)
        """
        self.atomic.store(value.bits, ordering)

    me swap(value: RuntimeValue, ordering: MemoryOrdering) -> RuntimeValue:
        """Atomically swap value.

        Args:
            value: New value
            ordering: Memory ordering

        Returns:
            Old value
        """
        val old_bits = self.atomic.swap(value.bits, ordering)
        RuntimeValue(bits: old_bits)

    me compare_exchange(
        expected: RuntimeValue,
        new: RuntimeValue,
        success_order: MemoryOrdering,
        failure_order: MemoryOrdering
    ) -> Result<RuntimeValue, RuntimeValue>:
        """Compare-and-swap for tagged values.

        Args:
            expected: Expected current value
            new: New value if comparison succeeds
            success_order: Ordering if CAS succeeds
            failure_order: Ordering if CAS fails

        Returns:
            Ok(old_value) if swap succeeded
            Err(current_value) if swap failed
        """
        match self.atomic.compare_exchange(
            expected.bits,
            new.bits,
            success_order,
            failure_order
        ):
            case Ok(old_bits):
                Ok(RuntimeValue(bits: old_bits))
            case Err(current_bits):
                Err(RuntimeValue(bits: current_bits))

# ============================================================================
# Helper Functions (FFI to Rust)
# ============================================================================

# Float <-> Bits conversions
extern fn float_to_bits(f: f64) -> i64
extern fn bits_to_float(bits: i64) -> f64
extern fn is_nan_bits(bits: i64) -> bool

# Pointer <-> i64 conversions
extern fn ptr_to_i64(ptr: [u8]) -> i64
extern fn i64_to_ptr(bits: i64) -> [u8]

# ============================================================================
# Utility Functions
# ============================================================================

fn is_aligned_ptr(bits: i64) -> bool:
    """Check if bits represent a valid aligned pointer.

    Args:
        bits: Raw 64-bit value

    Returns:
        true if bits are 8-byte aligned (low 3 bits are 0)
    """
    (bits and TAG_MASK) == 0

fn max_immediate_int() -> i64:
    """Get maximum value that fits in immediate integer.

    Returns:
        2^60 - 1 (max positive 61-bit signed integer)
    """
    (1 << 60) - 1

fn min_immediate_int() -> i64:
    """Get minimum value that fits in immediate integer.

    Returns:
        -2^60 (min negative 61-bit signed integer)
    """
    -(1 << 60)

fn can_encode_as_immediate(value: i64) -> bool:
    """Check if integer can be encoded as immediate.

    Args:
        value: Integer to check

    Returns:
        true if value fits in 61 bits
    """
    value >= min_immediate_int() and value <= max_immediate_int()

# ============================================================================
# Type Predicates for Pattern Matching
# ============================================================================

fn match_int(value: RuntimeValue) -> i64?:
    """Extract integer for pattern matching.

    Args:
        value: Runtime value

    Returns:
        Some(int) if value is integer, nil otherwise

    Example:
        match value:
            case Some(n) = match_int(value):
                print "Integer: {n}"
            case _:
                print "Not an integer"
    """
    value.try_as_int()

fn match_float(value: RuntimeValue) -> f64?:
    """Extract float for pattern matching."""
    value.try_as_float()

fn match_bool(value: RuntimeValue) -> bool?:
    """Extract boolean for pattern matching."""
    value.try_as_bool()

# ============================================================================
# Exports
# ============================================================================

export RuntimeValue
export AtomicValue
export max_immediate_int
export min_immediate_int
export can_encode_as_immediate
export is_aligned_ptr
export match_int
export match_float
export match_bool
