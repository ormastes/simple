# B-Tree Node Splitting Operations
#
# Purpose: Split full nodes during insertion
#
# Contains:
# - Child node splitting
# - Key promotion to parent

mod b_tree.types

# ============================================================================
# Node Splitting Functions
# ============================================================================

# Split a full child node
# Parameters:
#   parent: Parent node
#   i: Index of child to split
#   child: Full child node to split
# Returns: (new_parent, new_child, new_sibling)
#
# Process:
# 1. Create new node (sibling)
# 2. Move t-1 largest keys from child to sibling
# 3. Move t largest children from child to sibling (if not leaf)
# 4. Promote middle key to parent
# 5. Insert new sibling as child of parent
fn split_child(parent, i, child):
    val t = node_t(child)
    val child_is_leaf = node_is_leaf(child)

    # Create new sibling node
    var sibling = create_node(t, child_is_leaf)

    # Get child data
    val child_keys = node_keys(child)
    val child_children = node_children(child)
    val child_n = node_n(child)

    # Middle key index (to be promoted)
    val mid = t - 1

    # Move t-1 keys to sibling
    var sibling_keys = []
    for j in 0..(t - 1):
        val src_idx = mid + 1 + j
        val key = child_keys.src_idx
        sibling_keys = list_append(sibling_keys, key)

    # Move t children to sibling (if not leaf)
    var sibling_children = []
    val is_not_leaf = !child_is_leaf
    if is_not_leaf:
        for j in 0..t:
            val src_idx = mid + 1 + j
            val child_node = child_children.src_idx
            sibling_children = list_append(sibling_children, child_node)

    # Update sibling
    sibling = node_set_keys(sibling, sibling_keys)
    sibling = node_set_children(sibling, sibling_children)
    sibling = node_set_n(sibling, t - 1)

    # Get middle key to promote
    val promote_key = child_keys.mid

    # Update child to have only first t-1 keys
    var new_child_keys = []
    for j in 0..mid:
        val key = child_keys.j
        new_child_keys = list_append(new_child_keys, key)

    var new_child_children = []
    if is_not_leaf:
        for j in 0..t:
            val child_node = child_children.j
            new_child_children = list_append(new_child_children, child_node)

    var new_child = child
    new_child = node_set_keys(new_child, new_child_keys)
    new_child = node_set_children(new_child, new_child_children)
    new_child = node_set_n(new_child, t - 1)

    # Insert promoted key into parent
    val parent_keys = node_keys(parent)
    val parent_children = node_children(parent)
    val parent_n = node_n(parent)

    var new_parent_keys = []
    for j in 0..i:
        val key = parent_keys.j
        new_parent_keys = list_append(new_parent_keys, key)
    new_parent_keys = list_append(new_parent_keys, promote_key)
    for j in i..parent_n:
        val key = parent_keys.j
        new_parent_keys = list_append(new_parent_keys, key)

    # Insert new sibling into parent's children
    var new_parent_children = []
    for j in 0..(i + 1):
        val child_node = parent_children.j
        new_parent_children = list_append(new_parent_children, child_node)
    new_parent_children = list_append(new_parent_children, sibling)
    for j in (i + 1)..(parent_n + 1):
        val child_node = parent_children.j
        new_parent_children = list_append(new_parent_children, child_node)

    # Update parent's child at index i
    var final_parent_children = []
    for j in 0..(i + 2):
        if j == i:
            final_parent_children = list_append(final_parent_children, new_child)
        else:
            val idx_in_new = j
            val is_before = j < i
            val is_after = j > i
            if is_before:
                val child_node = new_parent_children.j
                final_parent_children = list_append(final_parent_children, child_node)
            else:
                val adjusted = j
                val child_node = new_parent_children.adjusted
                final_parent_children = list_append(final_parent_children, child_node)
    for j in (i + 2)..(parent_n + 2):
        val child_node = new_parent_children.j
        final_parent_children = list_append(final_parent_children, child_node)

    var new_parent = parent
    new_parent = node_set_keys(new_parent, new_parent_keys)
    new_parent = node_set_children(new_parent, final_parent_children)
    new_parent = node_set_n(new_parent, parent_n + 1)

    (new_parent, new_child, sibling)

export *
