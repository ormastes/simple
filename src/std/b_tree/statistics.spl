# B-Tree Statistics and Validation
#
# Purpose: Tree metrics, statistics, and structural validation
#
# Contains:
# - Min/max key finding
# - Height and size calculations
# - Node counting
# - B-tree property validation

mod b_tree.types

# ============================================================================
# Statistics Functions
# ============================================================================

# Get minimum key in tree
fn btree_min(tree):
    val root = tree_root(tree)
    var current = root
    var is_leaf = node_is_leaf(current)

    # Keep going to leftmost child
    var done = is_leaf
    if done:
        val keys = node_keys(current)
        val n = node_n(current)
        val has_keys = n > 0
        if has_keys:
            keys.0
        else:
            nil
    else:
        var result = nil
        var running = true
        while running:
            val leaf = node_is_leaf(current)
            if leaf:
                running = false
                val keys = node_keys(current)
                val n = node_n(current)
                val has_keys = n > 0
                if has_keys:
                    result = keys.0
            else:
                val children = node_children(current)
                current = children.0
        result

# Get maximum key in tree
fn btree_max(tree):
    val root = tree_root(tree)
    var current = root
    var is_leaf = node_is_leaf(current)

    # Keep going to rightmost child
    var done = is_leaf
    if done:
        val keys = node_keys(current)
        val n = node_n(current)
        val has_keys = n > 0
        if has_keys:
            val last = n - 1
            keys.last
        else:
            nil
    else:
        var result = nil
        var running = true
        while running:
            val leaf = node_is_leaf(current)
            if leaf:
                running = false
                val keys = node_keys(current)
                val n = node_n(current)
                val has_keys = n > 0
                if has_keys:
                    val last = n - 1
                    result = keys.last
            else:
                val children = node_children(current)
                val n = node_n(current)
                current = children.n
        result

# Calculate height of tree
fn btree_height(tree):
    val height = tree_height(tree)
    height

# Count total number of keys in tree
fn count_keys_in_node(node):
    val n = node_n(node)
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        n
    else:
        val children = node_children(node)
        var total = n
        for i in 0..(n + 1):
            val child = children.i
            val child_count = count_keys_in_node(child)
            total = total + child_count
        total

# Get total number of keys in tree
fn btree_size(tree):
    val root = tree_root(tree)
    count_keys_in_node(root)

# Count total number of nodes
fn count_nodes_in_subtree(node):
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        1
    else:
        val children = node_children(node)
        val n = node_n(node)
        var total = 1
        for i in 0..(n + 1):
            val child = children.i
            val child_count = count_nodes_in_subtree(child)
            total = total + child_count
        total

# Count total nodes in tree
fn count_nodes(tree):
    val root = tree_root(tree)
    count_nodes_in_subtree(root)

# ============================================================================
# Validation Functions
# ============================================================================

# Check if node has valid number of keys
fn is_valid_key_count(node, is_root):
    val n = node_n(node)
    val t = node_t(node)
    val min = t - 1
    val max = (2 * t) - 1

    if is_root:
        # Root can have 0 keys (if tree is empty) or 1 to 2t-1 keys
        val valid = n <= max
        valid
    else:
        # Non-root must have t-1 to 2t-1 keys
        val min_ok = n >= min
        val max_ok = n <= max
        val valid = min_ok
        val also_valid = max_ok
        val result = valid
        result
        # Should be: min_ok && max_ok but avoiding multi-line boolean
        if min_ok:
            max_ok
        else:
            false

# Check if keys are sorted
fn are_keys_sorted(node):
    val keys = node_keys(node)
    val n = node_n(node)
    var sorted = true
    for i in 0..(n - 1):
        val current = keys.i
        val next = keys.(i + 1)
        val less = current < next
        if !less:
            sorted = false
    sorted

# Validate B-tree properties recursively
fn validate_node(node, is_root, min_key, max_key):
    # Check key count
    val key_count_valid = is_valid_key_count(node, is_root)
    if !key_count_valid:
        false
    else:
        # Check keys are sorted
        val keys_sorted = are_keys_sorted(node)
        if !keys_sorted:
            false
        else:
            # Check key range
            val keys = node_keys(node)
            val n = node_n(node)
            var range_valid = true
            for i in 0..n:
                val k = keys.i
                val min_check = min_key == nil
                val max_check = max_key == nil
                if !min_check:
                    val above_min = k >= min_key
                    if !above_min:
                        range_valid = false
                if !max_check:
                    val below_max = k <= max_key
                    if !below_max:
                        range_valid = false

            if !range_valid:
                false
            else:
                # Check children if not leaf
                val is_leaf = node_is_leaf(node)
                if is_leaf:
                    true
                else:
                    val children = node_children(node)
                    val t = node_t(node)

                    # Check child count
                    val child_count = list_length(children)
                    val expected = n + 1
                    val count_ok = child_count == expected
                    if !count_ok:
                        false
                    else:
                        # Validate each child
                        var all_valid = true
                        for i in 0..(n + 1):
                            val child = children.i
                            var child_min = min_key
                            var child_max = max_key

                            if i > 0:
                                child_min = keys.(i - 1)
                            if i < n:
                                child_max = keys.i

                            val child_valid = validate_node(child, false, child_min, child_max)
                            if !child_valid:
                                all_valid = false
                        all_valid

# Validate entire B-tree structure
fn is_valid_btree(tree):
    val root = tree_root(tree)
    validate_node(root, true, nil, nil)

export *
