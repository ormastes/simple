# Iterator Utilities
#
# Advanced iterator patterns and utilities for functional-style data processing.
# Works around runtime limitations (no generics at runtime, closure capture issues)
# by using explicit state-passing with dict-based iterator representation.
#
# Categories:
# - Iterator Construction: from_array, from_range, from_function, empty_iter
# - Basic Operations: iter_map, iter_filter, iter_take, iter_drop, iter_skip
# - Conditional Operations: iter_take_while, iter_drop_while
# - Iterator Combinators: iter_zip, iter_chain, iter_enumerate, iter_interleave
# - Advanced Combinators: iter_cartesian_product, iter_product_with
# - Iterator Consumers: iter_collect, iter_fold, iter_reduce, iter_find
# - Query Operations: iter_any, iter_all, iter_count, iter_count_matches
# - Chunking Operations: iter_chunk, iter_window, iter_partition, iter_group_by
# - Specialized Iterators: iter_cycle, iter_repeat, iter_flat_map, iter_flatten
# - Stateful Iterators: iter_scan, iter_accumulate, iter_dedupe
# - Numeric Operations: iter_sum, iter_product, iter_min, iter_max, iter_average
# - Advanced Queries: iter_position, iter_last, iter_nth, iter_nth_back
# - Side Effects: iter_peek, iter_inspect, iter_for_each
# - Utilities: iter_len, iter_empty?, iter_single?, iter_reverse
#
# All functions are pure Simple - no external dependencies required.
#
# Iterator Representation:
# An iterator is a dict with:
#   - "type": "iterator"
#   - "data": array of buffered elements (for finite iterators)
#   - "index": current position in data array
#   - "generator": generator type string (or nil for finite)
#   - "state": generator-specific state dict
#   - "done": boolean indicating if iterator is exhausted

# ============================================================================
# Exports
# ============================================================================

export iter_from_array, iter_from_range, iter_from_function, iter_empty
export iter_map, iter_filter, iter_take, iter_drop, iter_skip
export iter_take_while, iter_drop_while
export iter_zip, iter_chain, iter_enumerate, iter_interleave
export iter_cartesian_product, iter_product_with
export iter_collect, iter_fold, iter_reduce, iter_find
export iter_any, iter_all, iter_count, iter_count_matches
export iter_chunk, iter_window, iter_partition, iter_group_by
export iter_cycle, iter_repeat, iter_flat_map, iter_flatten
export iter_scan, iter_accumulate, iter_dedupe
export iter_sum, iter_product, iter_min, iter_max, iter_average
export iter_position, iter_last, iter_nth, iter_nth_back
export iter_peek, iter_inspect, iter_for_each
export iter_len, iter_empty?, iter_single?, iter_reverse
export iter_step_by, iter_alternate, iter_merge, iter_merge_with
export iter_unzip, iter_flatten_once, iter_intersperse

# ============================================================================
# Internal Helper - Advance Iterator
# ============================================================================

fn iter_next_internal(iter):
    """Internal: Get next element from iterator. Returns (element, has_more)."""
    if iter["done"]:
        return (nil, false)

    # Use buffered data if available
    if iter["index"] < iter["data"].len():
        val elem = iter["data"][iter["index"]]
        iter["index"] = iter["index"] + 1
        return (elem, true)

    # Check if finite iterator exhausted
    if iter["generator"] == nil:
        iter["done"] = true
        return (nil, false)

    # Generate next element based on generator type
    val gen_type = iter["generator"]
    val state = iter["state"]

    if gen_type == "repeat":
        val value = state["value"]
        return (value, true)

    if gen_type == "cycle":
        val items = state["items"]
        val pos = state["position"]
        val value = items[pos]
        state["position"] = (pos + 1) % items.len()
        return (value, true)

    if gen_type == "function":
        val fn = state["fn"]
        val current = state["current"]
        val has_more = fn(current)
        val elem = has_more[0]
        val continues = has_more[1]

        if continues:
            state["current"] = elem
            return (elem, true)
        else:
            iter["done"] = true
            return (nil, false)

    if gen_type == "range":
        val current = state["current"]
        val end = state["end"]
        val step = state["step"]

        if (step > 0 and current >= end) or (step < 0 and current <= end):
            iter["done"] = true
            return (nil, false)

        val value = current
        state["current"] = current + step
        return (value, true)

    # Unknown generator
    iter["done"] = true
    (nil, false)

# ============================================================================
# Iterator Construction
# ============================================================================

fn iter_from_array(items):
    """Create an iterator from an array.

    Example:
        val it = iter_from_array([1, 2, 3])
        iter_collect(it)  # [1, 2, 3]
    """
    {
        "type": "iterator",
        "data": items,
        "index": 0,
        "generator": nil,
        "state": nil,
        "done": items.len() == 0
    }

fn iter_from_range(start, end, step):
    """Create an iterator over a numeric range with custom step.

    Example:
        val it = iter_from_range(0, 10, 2)
        iter_collect(it)  # [0, 2, 4, 6, 8]
    """
    if step == 0:
        return iter_empty()

    {
        "type": "iterator",
        "data": [],
        "index": 0,
        "generator": "range",
        "state": {"current": start, "end": end, "step": step},
        "done": false
    }

fn iter_from_function(initial, fn):
    """Create an iterator from a generator function.

    The function takes current state and returns (next_state, continue).
    If continue is false, iteration stops.

    Example:
        val it = iter_from_function(1, \x: (x * 2, x < 100))
        iter_collect(it)  # [1, 2, 4, 8, 16, 32, 64]
    """
    {
        "type": "iterator",
        "data": [],
        "index": 0,
        "generator": "function",
        "state": {"fn": fn, "current": initial},
        "done": false
    }

fn iter_empty():
    """Create an empty iterator.

    Example:
        val it = iter_empty()
        iter_collect(it)  # []
    """
    {
        "type": "iterator",
        "data": [],
        "index": 0,
        "generator": nil,
        "state": nil,
        "done": true
    }

# ============================================================================
# Basic Iterator Operations
# ============================================================================

fn iter_map(iter, f):
    """Transform each element using function f.

    Example:
        val it = iter_from_array([1, 2, 3])
        val doubled = iter_map(it, \x: x * 2)
        iter_collect(doubled)  # [2, 4, 6]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(f(elem))
        else:
            continue = false

    iter_from_array(result)

fn iter_filter(iter, predicate):
    """Keep only elements satisfying the predicate.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        val evens = iter_filter(it, \x: x % 2 == 0)
        iter_collect(evens)  # [2, 4]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if predicate(elem):
                result.push(elem)
        else:
            continue = false

    iter_from_array(result)

fn iter_take(iter, n):
    """Take first n elements.

    Example:
        val it = iter_from_range(0, 100, 1)
        val first_five = iter_take(it, 5)
        iter_collect(first_five)  # [0, 1, 2, 3, 4]
    """
    var result = []
    var count = 0

    while count < n:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
            count = count + 1
        else:
            count = n  # Force exit

    iter_from_array(result)

fn iter_drop(iter, n):
    """Drop first n elements.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        val dropped = iter_drop(it, 2)
        iter_collect(dropped)  # [3, 4, 5]
    """
    var count = 0

    # Skip n elements
    while count < n:
        val next_result = iter_next_internal(iter)
        val has_more = next_result[1]

        if has_more:
            count = count + 1
        else:
            count = n  # Force exit

    # Collect remaining
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
        else:
            continue = false

    iter_from_array(result)

fn iter_skip(iter, n):
    """Alias for iter_drop. Skip first n elements.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        val skipped = iter_skip(it, 2)
        iter_collect(skipped)  # [3, 4, 5]
    """
    iter_drop(iter, n)

# ============================================================================
# Conditional Operations
# ============================================================================

fn iter_take_while(iter, predicate):
    """Take elements while predicate is true.

    Example:
        val it = iter_from_array([2, 4, 6, 7, 8])
        val evens = iter_take_while(it, \x: x % 2 == 0)
        iter_collect(evens)  # [2, 4, 6]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if predicate(elem):
                result.push(elem)
            else:
                continue = false
        else:
            continue = false

    iter_from_array(result)

fn iter_drop_while(iter, predicate):
    """Drop elements while predicate is true.

    Example:
        val it = iter_from_array([2, 4, 6, 7, 8])
        val rest = iter_drop_while(it, \x: x % 2 == 0)
        iter_collect(rest)  # [7, 8]
    """
    var dropping = true
    var result = []

    while dropping:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if not predicate(elem):
                dropping = false
                result.push(elem)
        else:
            dropping = false

    # Collect remaining
    var continue = true
    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
        else:
            continue = false

    iter_from_array(result)

# ============================================================================
# Iterator Combinators
# ============================================================================

fn iter_zip(iter1, iter2):
    """Zip two iterators into tuples. Stops when either exhausts.

    Example:
        val it1 = iter_from_array([1, 2, 3])
        val it2 = iter_from_array([4, 5, 6])
        iter_collect(iter_zip(it1, it2))  # [(1, 4), (2, 5), (3, 6)]
    """
    var result = []
    var continue = true

    while continue:
        val next1 = iter_next_internal(iter1)
        val elem1 = next1[0]
        val has1 = next1[1]

        val next2 = iter_next_internal(iter2)
        val elem2 = next2[0]
        val has2 = next2[1]

        if has1 and has2:
            result.push((elem1, elem2))
        else:
            continue = false

    iter_from_array(result)

fn iter_chain(iter1, iter2):
    """Chain two iterators together.

    Example:
        val it1 = iter_from_array([1, 2])
        val it2 = iter_from_array([3, 4])
        iter_collect(iter_chain(it1, it2))  # [1, 2, 3, 4]
    """
    var result = []

    # Consume first iterator
    var continue = true
    while continue:
        val next_result = iter_next_internal(iter1)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
        else:
            continue = false

    # Consume second iterator
    continue = true
    while continue:
        val next_result = iter_next_internal(iter2)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
        else:
            continue = false

    iter_from_array(result)

fn iter_enumerate(iter):
    """Add indices to elements as tuples (index, element).

    Example:
        val it = iter_from_array([10, 20, 30])
        iter_collect(iter_enumerate(it))  # [(0, 10), (1, 20), (2, 30)]
    """
    var result = []
    var index = 0
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push((index, elem))
            index = index + 1
        else:
            continue = false

    iter_from_array(result)

fn iter_interleave(iter1, iter2):
    """Interleave elements from two iterators alternately.

    Continues until both are exhausted.

    Example:
        val it1 = iter_from_array([1, 2, 3])
        val it2 = iter_from_array([10, 20])
        iter_collect(iter_interleave(it1, it2))  # [1, 10, 2, 20, 3]
    """
    var result = []
    var continue = true
    var toggle = true

    while continue:
        if toggle:
            val next1 = iter_next_internal(iter1)
            val elem1 = next1[0]
            val has1 = next1[1]

            if has1:
                result.push(elem1)

            toggle = false
        else:
            val next2 = iter_next_internal(iter2)
            val elem2 = next2[0]
            val has2 = next2[1]

            if has2:
                result.push(elem2)

            toggle = true

        # Check if both exhausted
        val peek1 = iter_next_internal(iter1)
        val has_more1 = peek1[1]
        val peek2 = iter_next_internal(iter2)
        val has_more2 = peek2[1]

        if not has_more1 and not has_more2:
            continue = false
        else:
            # Put back peeked elements
            if has_more1:
                iter1["index"] = iter1["index"] - 1
            if has_more2:
                iter2["index"] = iter2["index"] - 1

    iter_from_array(result)

fn iter_cartesian_product(iter1, iter2):
    """Compute cartesian product of two iterators.

    Returns iterator of tuples (a, b) for all a in iter1, b in iter2.

    Example:
        val it1 = iter_from_array([1, 2])
        val it2 = iter_from_array([3, 4])
        iter_collect(iter_cartesian_product(it1, it2))
        # [(1, 3), (1, 4), (2, 3), (2, 4)]
    """
    val items1 = iter_collect(iter1)
    val items2 = iter_collect(iter2)
    var result = []

    for item1 in items1:
        for item2 in items2:
            result.push((item1, item2))

    iter_from_array(result)

fn iter_product_with(iter1, iter2, f):
    """Compute cartesian product and apply function to each pair.

    Example:
        val it1 = iter_from_array([1, 2])
        val it2 = iter_from_array([3, 4])
        iter_collect(iter_product_with(it1, it2, \a, b: a + b))
        # [4, 5, 5, 6]
    """
    val items1 = iter_collect(iter1)
    val items2 = iter_collect(iter2)
    var result = []

    for item1 in items1:
        for item2 in items2:
            result.push(f(item1, item2))

    iter_from_array(result)

# ============================================================================
# Iterator Consumers
# ============================================================================

fn iter_collect(iter):
    """Collect all iterator elements into an array.

    Example:
        val it = iter_from_array([1, 2, 3])
        iter_collect(it)  # [1, 2, 3]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
        else:
            continue = false

    result

fn iter_fold(iter, init, f):
    """Fold iterator from left with initial value.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_fold(it, 0, \acc, x: acc + x)  # 10
    """
    var acc = init
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            acc = f(acc, elem)
        else:
            continue = false

    acc

fn iter_reduce(iter, f):
    """Reduce iterator without initial value (uses first element).

    Returns nil if iterator is empty.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_reduce(it, \acc, x: acc + x)  # 10
    """
    val first_result = iter_next_internal(iter)
    val first_elem = first_result[0]
    val has_first = first_result[1]

    if not has_first:
        return nil

    var acc = first_elem
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            acc = f(acc, elem)
        else:
            continue = false

    acc

fn iter_find(iter, predicate):
    """Find first element satisfying predicate, or nil.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_find(it, \x: x > 3)  # 4
    """
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if predicate(elem):
                return elem
        else:
            continue = false

    nil

# ============================================================================
# Query Operations
# ============================================================================

fn iter_any(iter, predicate):
    """Check if any element satisfies predicate.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_any(it, \x: x > 3)  # true
    """
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if predicate(elem):
                return true
        else:
            continue = false

    false

fn iter_all(iter, predicate):
    """Check if all elements satisfy predicate.

    Example:
        val it = iter_from_array([2, 4, 6, 8])
        iter_all(it, \x: x % 2 == 0)  # true
    """
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if not predicate(elem):
                return false
        else:
            continue = false

    true

fn iter_count(iter):
    """Count total elements in iterator.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_count(it)  # 5
    """
    var count = 0
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val has_more = next_result[1]

        if has_more:
            count = count + 1
        else:
            continue = false

    count

fn iter_count_matches(iter, predicate):
    """Count elements satisfying predicate.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_count_matches(it, \x: x % 2 == 0)  # 2
    """
    var count = 0
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if predicate(elem):
                count = count + 1
        else:
            continue = false

    count

# ============================================================================
# Chunking Operations
# ============================================================================

fn iter_chunk(iter, size):
    """Split iterator into chunks of given size.

    Last chunk may be smaller.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_collect(iter_chunk(it, 2))  # [[1, 2], [3, 4], [5]]
    """
    if size <= 0:
        return iter_empty()

    var result = []
    var current_chunk = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            current_chunk.push(elem)
            if current_chunk.len() == size:
                result.push(current_chunk)
                current_chunk = []
        else:
            if current_chunk.len() > 0:
                result.push(current_chunk)
            continue = false

    iter_from_array(result)

fn iter_window(iter, size):
    """Create sliding windows of given size.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_collect(iter_window(it, 2))  # [[1, 2], [2, 3], [3, 4]]
    """
    if size <= 0:
        return iter_empty()

    val all_items = iter_collect(iter)

    if all_items.len() < size:
        return iter_empty()

    var result = []
    var i = 0
    while i <= all_items.len() - size:
        var window = []
        var j = 0
        while j < size:
            window.push(all_items[i + j])
            j = j + 1
        result.push(window)
        i = i + 1

    iter_from_array(result)

fn iter_partition(iter, predicate):
    """Partition iterator into two arrays: (matching, not_matching).

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_partition(it, \x: x % 2 == 0)  # ([2, 4], [1, 3, 5])
    """
    var matching = []
    var not_matching = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if predicate(elem):
                matching.push(elem)
            else:
                not_matching.push(elem)
        else:
            continue = false

    (matching, not_matching)

fn iter_group_by(iter, key_fn):
    """Group iterator elements by key function.

    Returns a dict mapping string keys to arrays of elements.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_group_by(it, \x: x % 2)  # {"0": [2, 4], "1": [1, 3, 5]}
    """
    var groups = {}
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            val key = "{key_fn(elem)}"
            if not groups.contains(key):
                groups[key] = []
            groups[key].push(elem)
        else:
            continue = false

    groups

# ============================================================================
# Specialized Iterators
# ============================================================================

fn iter_cycle(items):
    """Create an infinite iterator that cycles through items.

    CAUTION: Infinite iterator. Use with iter_take.

    Example:
        val it = iter_cycle([1, 2, 3])
        iter_collect(iter_take(it, 7))  # [1, 2, 3, 1, 2, 3, 1]
    """
    if items.len() == 0:
        return iter_empty()

    {
        "type": "iterator",
        "data": [],
        "index": 0,
        "generator": "cycle",
        "state": {"items": items, "position": 0},
        "done": false
    }

fn iter_repeat(value):
    """Create an infinite iterator repeating the same value.

    CAUTION: Infinite iterator. Use with iter_take.

    Example:
        val it = iter_repeat(42)
        iter_collect(iter_take(it, 3))  # [42, 42, 42]
    """
    {
        "type": "iterator",
        "data": [],
        "index": 0,
        "generator": "repeat",
        "state": {"value": value},
        "done": false
    }

fn iter_flat_map(iter, f):
    """Map each element to an array and flatten results.

    Example:
        val it = iter_from_array([1, 2, 3])
        val doubled = iter_flat_map(it, \x: [x, x])
        iter_collect(doubled)  # [1, 1, 2, 2, 3, 3]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            val mapped = f(elem)
            for item in mapped:
                result.push(item)
        else:
            continue = false

    iter_from_array(result)

fn iter_flatten(iter):
    """Flatten an iterator of arrays into single iterator.

    Example:
        val it = iter_from_array([[1, 2], [3, 4], [5]])
        iter_collect(iter_flatten(it))  # [1, 2, 3, 4, 5]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            for item in elem:
                result.push(item)
        else:
            continue = false

    iter_from_array(result)

# ============================================================================
# Stateful Iterators
# ============================================================================

fn iter_scan(iter, init, f):
    """Like fold, but returns iterator of intermediate results.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_collect(iter_scan(it, 0, \acc, x: acc + x))
        # [0, 1, 3, 6, 10]
    """
    var result = [init]
    var acc = init
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            acc = f(acc, elem)
            result.push(acc)
        else:
            continue = false

    iter_from_array(result)

fn iter_accumulate(iter):
    """Accumulate values (running sum).

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_collect(iter_accumulate(it))  # [1, 3, 6, 10]
    """
    var result = []
    var acc = 0
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            acc = acc + elem
            result.push(acc)
        else:
            continue = false

    iter_from_array(result)

fn iter_dedupe(iter):
    """Remove consecutive duplicate elements.

    Example:
        val it = iter_from_array([1, 1, 2, 2, 2, 3, 1])
        iter_collect(iter_dedupe(it))  # [1, 2, 3, 1]
    """
    var result = []
    var last = nil
    var has_last = false
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if not has_last or elem != last:
                result.push(elem)
                last = elem
                has_last = true
        else:
            continue = false

    iter_from_array(result)

# ============================================================================
# Numeric Operations
# ============================================================================

fn iter_sum(iter):
    """Sum all numeric elements.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_sum(it)  # 10
    """
    iter_fold(iter, 0, \acc, x: acc + x)

fn iter_product(iter):
    """Multiply all numeric elements.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_product(it)  # 24
    """
    iter_fold(iter, 1, \acc, x: acc * x)

fn iter_min(iter):
    """Find minimum element, or nil if empty.

    Example:
        val it = iter_from_array([3, 1, 4, 1, 5])
        iter_min(it)  # 1
    """
    iter_reduce(iter, \acc, x: if x < acc: x else: acc)

fn iter_max(iter):
    """Find maximum element, or nil if empty.

    Example:
        val it = iter_from_array([3, 1, 4, 1, 5])
        iter_max(it)  # 5
    """
    iter_reduce(iter, \acc, x: if x > acc: x else: acc)

fn iter_average(iter):
    """Calculate average of numeric elements, or nil if empty.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_average(it)  # 2.5
    """
    var sum = 0
    var count = 0
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            sum = sum + elem
            count = count + 1
        else:
            continue = false

    if count == 0:
        nil
    else:
        sum / count

# ============================================================================
# Advanced Query Operations
# ============================================================================

fn iter_position(iter, predicate):
    """Find index of first element satisfying predicate, or nil.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_position(it, \x: x > 3)  # 3
    """
    var index = 0
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if predicate(elem):
                return index
            index = index + 1
        else:
            continue = false

    nil

fn iter_last(iter):
    """Get last element, or nil if empty.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_last(it)  # 4
    """
    var last = nil
    var has_elem = false
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            last = elem
            has_elem = true
        else:
            continue = false

    if has_elem:
        last
    else:
        nil

fn iter_nth(iter, n):
    """Get nth element (0-indexed), or nil if not enough elements.

    Example:
        val it = iter_from_array([10, 20, 30, 40])
        iter_nth(it, 2)  # 30
    """
    var count = 0

    while count <= n:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if count == n:
                return elem
            count = count + 1
        else:
            return nil

    nil

fn iter_nth_back(iter, n):
    """Get nth element from back (0-indexed), or nil.

    Example:
        val it = iter_from_array([10, 20, 30, 40])
        iter_nth_back(it, 1)  # 30
    """
    val items = iter_collect(iter)
    val len = items.len()

    if n >= len:
        return nil

    items[len - 1 - n]

# ============================================================================
# Side Effects
# ============================================================================

fn iter_peek(iter, action):
    """Execute action on each element while passing through.

    Useful for debugging and logging.

    Example:
        val it = iter_from_array([1, 2, 3])
        val peeked = iter_peek(it, \x: print("Saw: {x}"))
        iter_collect(peeked)  # [1, 2, 3] (with print side effects)
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            action(elem)
            result.push(elem)
        else:
            continue = false

    iter_from_array(result)

fn iter_inspect(iter, action):
    """Alias for iter_peek. Execute action on each element.

    Example:
        val it = iter_from_array([1, 2, 3])
        val inspected = iter_inspect(it, \x: print(x))
        iter_collect(inspected)  # [1, 2, 3] (with print side effects)
    """
    iter_peek(iter, action)

fn iter_for_each(iter, action):
    """Execute action on each element (consuming iterator).

    Example:
        val it = iter_from_array([1, 2, 3])
        iter_for_each(it, \x: print(x))  # Prints 1, 2, 3
    """
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            action(elem)
        else:
            continue = false

    nil

# ============================================================================
# Utility Operations
# ============================================================================

fn iter_len(iter):
    """Get length by consuming iterator.

    Alias for iter_count.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_len(it)  # 5
    """
    iter_count(iter)

fn iter_empty?(iter):
    """Check if iterator is empty without consuming.

    Example:
        val it = iter_empty()
        iter_empty?(it)  # true
    """
    iter["done"]

fn iter_single?(iter):
    """Check if iterator has exactly one element.

    Example:
        val it = iter_from_array([42])
        iter_single?(it)  # true
    """
    val items = iter_collect(iter)
    items.len() == 1

fn iter_reverse(iter):
    """Reverse iterator by collecting and reversing.

    Example:
        val it = iter_from_array([1, 2, 3])
        iter_collect(iter_reverse(it))  # [3, 2, 1]
    """
    val items = iter_collect(iter)
    var reversed = []
    var i = items.len() - 1

    while i >= 0:
        reversed.push(items[i])
        i = i - 1

    iter_from_array(reversed)

# ============================================================================
# Additional Utilities
# ============================================================================

fn iter_step_by(iter, step):
    """Take every nth element.

    Example:
        val it = iter_from_array([0, 1, 2, 3, 4, 5])
        iter_collect(iter_step_by(it, 2))  # [0, 2, 4]
    """
    if step <= 0:
        return iter_empty()

    var result = []
    var index = 0
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if index % step == 0:
                result.push(elem)
            index = index + 1
        else:
            continue = false

    iter_from_array(result)

fn iter_alternate(iter):
    """Take every other element (shortcut for step_by(2)).

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_collect(iter_alternate(it))  # [1, 3, 5]
    """
    iter_step_by(iter, 2)

fn iter_merge(iter1, iter2):
    """Merge two sorted iterators maintaining sort order.

    Assumes both iterators are already sorted.

    Example:
        val it1 = iter_from_array([1, 3, 5])
        val it2 = iter_from_array([2, 4, 6])
        iter_collect(iter_merge(it1, it2))  # [1, 2, 3, 4, 5, 6]
    """
    var result = []
    var next1 = iter_next_internal(iter1)
    var elem1 = next1[0]
    var has1 = next1[1]
    var next2 = iter_next_internal(iter2)
    var elem2 = next2[0]
    var has2 = next2[1]

    while has1 and has2:
        if elem1 <= elem2:
            result.push(elem1)
            next1 = iter_next_internal(iter1)
            elem1 = next1[0]
            has1 = next1[1]
        else:
            result.push(elem2)
            next2 = iter_next_internal(iter2)
            elem2 = next2[0]
            has2 = next2[1]

    # Consume remaining elements
    if has1:
        result.push(elem1)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter1)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    if has2:
        result.push(elem2)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter2)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    iter_from_array(result)

fn iter_merge_with(iter1, iter2, compare_fn):
    """Merge two iterators using custom comparison function.

    compare_fn(a, b) should return true if a should come before b.

    Example:
        val it1 = iter_from_array([5, 3, 1])
        val it2 = iter_from_array([6, 4, 2])
        iter_collect(iter_merge_with(it1, it2, \a, b: a > b))
        # [6, 5, 4, 3, 2, 1]
    """
    var result = []
    var next1 = iter_next_internal(iter1)
    var elem1 = next1[0]
    var has1 = next1[1]
    var next2 = iter_next_internal(iter2)
    var elem2 = next2[0]
    var has2 = next2[1]

    while has1 and has2:
        if compare_fn(elem1, elem2):
            result.push(elem1)
            next1 = iter_next_internal(iter1)
            elem1 = next1[0]
            has1 = next1[1]
        else:
            result.push(elem2)
            next2 = iter_next_internal(iter2)
            elem2 = next2[0]
            has2 = next2[1]

    # Consume remaining
    if has1:
        result.push(elem1)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter1)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    if has2:
        result.push(elem2)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter2)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    iter_from_array(result)

fn iter_unzip(iter):
    """Unzip iterator of tuples into tuple of arrays.

    Example:
        val it = iter_from_array([(1, 2), (3, 4), (5, 6)])
        iter_unzip(it)  # ([1, 3, 5], [2, 4, 6])
    """
    var first = []
    var second = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            first.push(elem[0])
            second.push(elem[1])
        else:
            continue = false

    (first, second)

fn iter_flatten_once(iter):
    """Flatten one level of nesting.

    Alias for iter_flatten.

    Example:
        val it = iter_from_array([[1, 2], [3, 4]])
        iter_collect(iter_flatten_once(it))  # [1, 2, 3, 4]
    """
    iter_flatten(iter)

fn iter_intersperse(iter, separator):
    """Insert separator between elements.

    Example:
        val it = iter_from_array([1, 2, 3])
        iter_collect(iter_intersperse(it, 0))  # [1, 0, 2, 0, 3]
    """
    var result = []
    var first = true
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            if not first:
                result.push(separator)
            result.push(elem)
            first = false
        else:
            continue = false

    iter_from_array(result)
