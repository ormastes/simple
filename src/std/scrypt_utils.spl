# Scrypt Password Hashing Utilities Module
#
# Comprehensive scrypt key derivation function implementation for password hashing
# and key derivation. Scrypt is a memory-hard key derivation function designed to
# be resistant to hardware brute-force attacks (ASICs, GPUs, FPGAs).
#
# ALGORITHM OVERVIEW:
# scrypt combines three components:
# 1. PBKDF2-HMAC-SHA256: Key expansion and final derivation
# 2. Salsa20/8 core: Fast mixing function for memory access
# 3. ROMix: Memory-hard function requiring large memory space
#
# MEMORY-HARDNESS:
# The scrypt algorithm requires storing N blocks of 128*r bytes in memory,
# making it expensive to parallelize with custom hardware.
# Memory requirement: 128 * N * r bytes
#
# SECURITY PROPERTIES:
# - Memory-hard: Requires proportional time AND space
# - Sequential memory-hard: Cannot trade time for space
# - Resistant to ASICs, GPUs, and FPGAs
# - Better than bcrypt and PBKDF2 for password hashing
# - Configurable cost parameters (N, r, p)
#
# IMPLEMENTATION NOTES:
# - Pure Simple implementation (no FFI)
# - NO generics at runtime (uses concrete types)
# - NO try/catch/throw (uses Option/nil for errors)
# - NO chained methods (uses intermediate variables)
# - Tuple-based data structures
# - Uses crypto_utils for SHA-256, HMAC, and PBKDF2
# - Uses base64_utils for hash encoding
# - Uses random_utils for salt generation
#
# PARAMETER RECOMMENDATIONS:
# - Interactive login (web): N=16384 (2^14), r=8, p=1
# - Sensitive data: N=32768 (2^15), r=8, p=1
# - File encryption: N=1048576 (2^20), r=8, p=1
# - Low memory devices: N=4096 (2^12), r=8, p=1
#
# SECURITY NOTES:
# - Always use unique random salts for each password
# - Store the full hash string including parameters
# - Use constant-time comparison for verification
# - N must be a power of 2 and greater than 1
# - r and p must be positive integers
# - Memory usage = 128 * N * r bytes

# Import required modules
import crypto_utils
import base64_utils
import random_utils

# =============================================================================
# CONSTANTS
# =============================================================================

# Default scrypt parameters for password hashing (interactive use)
val DEFAULT_N = 16384  # 2^14 - Memory cost
val DEFAULT_R = 8      # Block size
val DEFAULT_P = 1      # Parallelization
val DEFAULT_DKLEN = 32 # Derived key length (32 bytes = 256 bits)

# Recommended salt length (16 bytes = 128 bits)
val DEFAULT_SALT_LENGTH = 16

# Scrypt hash format prefix
val SCRYPT_PREFIX = "$scrypt$"

# Block size for Salsa20/8 (16 words = 64 bytes)
val SALSA20_BLOCK_SIZE = 16

# Number of rounds for Salsa20/8 (8 rounds = 4 double rounds)
val SALSA20_ROUNDS = 8

# =============================================================================
# PARAMETER VALIDATION AND CREATION
# =============================================================================

fn create_scrypt_params(N: i64, r: i64, p: i64, dkLen: i64):
    """Create scrypt parameter tuple.

    Parameters:
    - N: CPU/memory cost parameter (must be power of 2, > 1)
    - r: Block size parameter (typically 8)
    - p: Parallelization parameter (typically 1)
    - dkLen: Desired key length in bytes

    Returns: (N, r, p, dkLen) tuple

    Example:
        val params = create_scrypt_params(16384, 8, 1, 32)
    """
    (N, r, p, dkLen)

fn validate_params(params) -> i64:
    """Validate scrypt parameters.

    Checks:
    - N must be power of 2 and > 1
    - r must be positive
    - p must be positive
    - dkLen must be positive and <= 2^32-1
    - Memory requirement must not overflow

    Returns: 1 if valid, 0 if invalid

    Example:
        val is_valid = validate_params(params)
    """
    val (N, r, p, dkLen) = params

    # Check N is power of 2 and > 1
    var n_check = is_power_of_two(N)
    if n_check == 0:
        return 0
    if N <= 1:
        return 0

    # Check r is positive
    if r <= 0:
        return 0

    # Check p is positive
    if p <= 0:
        return 0

    # Check dkLen is positive and reasonable
    if dkLen <= 0:
        return 0
    if dkLen > 2147483647:  # 2^31-1
        return 0

    # Check memory requirement doesn't overflow
    # Memory = 128 * N * r
    val max_memory = 1073741824  # 1 GB limit
    var memory_needed = 128 * N
    memory_needed = memory_needed * r
    if memory_needed > max_memory:
        return 0

    1

fn recommended_params():
    """Get recommended scrypt parameters for current hardware.

    Returns default parameters suitable for interactive use
    (web login, authentication, etc.).

    Returns: (N=16384, r=8, p=1, dkLen=32)

    Example:
        val params = recommended_params()
    """
    create_scrypt_params(DEFAULT_N, DEFAULT_R, DEFAULT_P, DEFAULT_DKLEN)

fn low_memory_params():
    """Get low memory scrypt parameters.

    Suitable for embedded systems or memory-constrained environments.
    Uses ~4 MB of memory.

    Returns: (N=4096, r=8, p=1, dkLen=32)

    Example:
        val params = low_memory_params()
    """
    create_scrypt_params(4096, DEFAULT_R, DEFAULT_P, DEFAULT_DKLEN)

fn high_security_params():
    """Get high security scrypt parameters.

    Suitable for sensitive data protection.
    Uses ~32 MB of memory.

    Returns: (N=32768, r=8, p=1, dkLen=32)

    Example:
        val params = high_security_params()
    """
    create_scrypt_params(32768, DEFAULT_R, DEFAULT_P, DEFAULT_DKLEN)

fn file_encryption_params():
    """Get scrypt parameters for file encryption.

    Very high security for file encryption use cases.
    Uses ~1 GB of memory.

    Returns: (N=1048576, r=8, p=1, dkLen=32)

    Example:
        val params = file_encryption_params()
    """
    create_scrypt_params(1048576, DEFAULT_R, DEFAULT_P, DEFAULT_DKLEN)

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

fn is_power_of_two(n: i64) -> i64:
    """Check if n is a power of 2.

    Returns: 1 if power of 2, 0 otherwise

    Example:
        is_power_of_two(16)  # 1
        is_power_of_two(15)  # 0
    """
    if n <= 0:
        return 0
    (n & (n - 1)) == 0

fn log2(n: i64) -> i64:
    """Calculate log2 of n (assuming n is power of 2).

    Example:
        log2(16384)  # 14
    """
    var result = 0
    var temp = n
    while temp > 1:
        temp = temp >> 1
        result = result + 1
    result

fn estimate_memory_usage(params) -> i64:
    """Estimate memory usage in bytes for given parameters.

    Memory = 128 * N * r bytes

    Example:
        val memory = estimate_memory_usage(params)
        print "Needs {memory} bytes"
    """
    val (N, r, p, dkLen) = params
    var memory = 128 * N
    memory = memory * r
    memory

fn estimate_time(params) -> text:
    """Estimate hashing time for given parameters.

    Returns approximate time description.

    Example:
        val time = estimate_time(params)
    """
    val (N, r, p, dkLen) = params

    # Rough estimates based on N parameter
    if N <= 4096:
        return "~50-100ms"
    if N <= 16384:
        return "~200-400ms"
    if N <= 32768:
        return "~400-800ms"
    if N <= 65536:
        return "~1-2 seconds"
    "~several seconds"

fn compare_constant_time(a: list, b: list) -> i64:
    """Constant-time comparison of byte arrays.

    Prevents timing attacks by always comparing all bytes.

    Returns: 1 if equal, 0 if not equal

    Example:
        val equal = compare_constant_time(hash1, hash2)
    """
    if a.len() != b.len():
        return 0

    var result = 0
    var i = 0
    while i < a.len():
        val a_byte = a.get(i)
        val b_byte = b.get(i)
        result = result | (a_byte ^ b_byte)
        i = i + 1

    if result == 0:
        return 1
    0

# =============================================================================
# SALSA20/8 CORE IMPLEMENTATION
# =============================================================================

fn salsa20_quarterround(y: list, a: i64, b: i64, c: i64, d: i64):
    """Salsa20 quarterround operation.

    Updates 4 words of the state using XOR and rotation.
    """
    val y_a = y.get(a)
    val y_b = y.get(b)
    val y_c = y.get(c)
    val y_d = y.get(d)

    # b ^= (a + d) <<< 7
    val sum_ad = crypto_utils.add_mod32(y_a, y_d)
    val rotl_7 = crypto_utils.rotl32(sum_ad, 7)
    val new_b = y_b ^ rotl_7
    y.set(b, new_b)

    # c ^= (b + a) <<< 9
    val sum_ba = crypto_utils.add_mod32(new_b, y_a)
    val rotl_9 = crypto_utils.rotl32(sum_ba, 9)
    val new_c = y_c ^ rotl_9
    y.set(c, new_c)

    # d ^= (c + b) <<< 13
    val sum_cb = crypto_utils.add_mod32(new_c, new_b)
    val rotl_13 = crypto_utils.rotl32(sum_cb, 13)
    val new_d = y_d ^ rotl_13
    y.set(d, new_d)

    # a ^= (d + c) <<< 18
    val sum_dc = crypto_utils.add_mod32(new_d, new_c)
    val rotl_18 = crypto_utils.rotl32(sum_dc, 18)
    val new_a = y_a ^ rotl_18
    y.set(a, new_a)

    y

fn rotl32(x: i64, n: i64) -> i64:
    """Left rotate for 32-bit values.

    Helper for Salsa20 quarterround.
    """
    val mask = 0xFFFFFFFF
    val x_masked = x & mask
    val shifted = ((x_masked << n) | (x_masked >> (32 - n))) & mask
    shifted

fn salsa20_8_core(input: list) -> list:
    """Salsa20/8 core function.

    Performs 8 rounds (4 double rounds) of the Salsa20 core.
    Input and output are 16 words (64 bytes).

    Example:
        val output = salsa20_8_core(input)
    """
    # Copy input to working state
    var x = []
    var i = 0
    while i < 16:
        x.push(input.get(i))
        i = i + 1

    # Perform 8 rounds (4 double rounds)
    var round = 0
    while round < 4:
        # Odd round - column quarterrounds
        salsa20_quarterround(x, 0, 4, 8, 12)
        salsa20_quarterround(x, 5, 9, 13, 1)
        salsa20_quarterround(x, 10, 14, 2, 6)
        salsa20_quarterround(x, 15, 3, 7, 11)

        # Even round - row quarterrounds
        salsa20_quarterround(x, 0, 1, 2, 3)
        salsa20_quarterround(x, 5, 6, 7, 4)
        salsa20_quarterround(x, 10, 11, 8, 9)
        salsa20_quarterround(x, 15, 12, 13, 14)

        round = round + 1

    # Add input to output
    var result = []
    i = 0
    while i < 16:
        val sum = crypto_utils.add_mod32(x.get(i), input.get(i))
        result.push(sum)
        i = i + 1

    result

fn salsa20_words_to_bytes(words: list) -> list:
    """Convert 16 words (32-bit) to 64 bytes (little-endian).

    Example:
        val bytes = salsa20_words_to_bytes(words)
    """
    var bytes = []
    var i = 0
    while i < words.len():
        val word = words.get(i)
        # Little-endian encoding
        bytes.push(word & 0xFF)
        bytes.push((word >> 8) & 0xFF)
        bytes.push((word >> 16) & 0xFF)
        bytes.push((word >> 24) & 0xFF)
        i = i + 1
    bytes

fn salsa20_bytes_to_words(bytes: list) -> list:
    """Convert 64 bytes to 16 words (32-bit) (little-endian).

    Example:
        val words = salsa20_bytes_to_words(bytes)
    """
    var words = []
    var i = 0
    while i < bytes.len():
        if i + 3 < bytes.len():
            val b0 = bytes.get(i)
            val b1 = bytes.get(i + 1)
            val b2 = bytes.get(i + 2)
            val b3 = bytes.get(i + 3)
            val word = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
            words.push(word & 0xFFFFFFFF)
        i = i + 4
    words

# =============================================================================
# BLOCKMIX AND ROMIX IMPLEMENTATION
# =============================================================================

fn block_mix_salsa8(block: list, r: i64) -> list:
    """BlockMix function using Salsa20/8.

    Mixes a block of 2*r 64-byte sub-blocks.

    Algorithm:
    1. X = B[2*r-1]
    2. For i = 0 to 2*r-1:
         X = Salsa20/8(X XOR B[i])
         Y[i] = X
    3. Return Y (with even/odd reordering)

    Example:
        val mixed = block_mix_salsa8(block, 8)
    """
    val block_count = 2 * r

    # X = B[2*r-1] (last 64-byte block)
    var X = []
    var start = (block_count - 1) * 64
    var i = 0
    while i < 64:
        X.push(block.get(start + i))
        i = i + 1

    # Y will hold the results
    var Y = []
    i = 0
    while i < block_count * 64:
        Y.push(0)
        i = i + 1

    # Process each block
    var block_idx = 0
    while block_idx < block_count:
        # X = Salsa20/8(X XOR B[block_idx])
        start = block_idx * 64

        # XOR X with B[block_idx]
        var xor_block = []
        i = 0
        while i < 64:
            val x_byte = X.get(i)
            val b_byte = block.get(start + i)
            xor_block.push(x_byte ^ b_byte)
            i = i + 1

        # Convert to words, apply Salsa20/8, convert back to bytes
        val words = salsa20_bytes_to_words(xor_block)
        val mixed_words = salsa20_8_core(words)
        X = salsa20_words_to_bytes(mixed_words)

        # Store in Y (will reorder later)
        i = 0
        while i < 64:
            Y.set(block_idx * 64 + i, X.get(i))
            i = i + 1

        block_idx = block_idx + 1

    # Reorder Y: even-indexed blocks first, then odd-indexed blocks
    var result = []
    i = 0
    while i < block_count * 64:
        result.push(0)
        i = i + 1

    # Copy even blocks to first half
    block_idx = 0
    var dest_idx = 0
    while block_idx < block_count:
        if block_idx % 2 == 0:
            i = 0
            while i < 64:
                val byte = Y.get(block_idx * 64 + i)
                result.set(dest_idx * 64 + i, byte)
                i = i + 1
            dest_idx = dest_idx + 1
        block_idx = block_idx + 1

    # Copy odd blocks to second half
    block_idx = 0
    while block_idx < block_count:
        if block_idx % 2 == 1:
            i = 0
            while i < 64:
                val byte = Y.get(block_idx * 64 + i)
                result.set(dest_idx * 64 + i, byte)
                i = i + 1
            dest_idx = dest_idx + 1
        block_idx = block_idx + 1

    result

fn integerify(block: list, r: i64) -> i64:
    """Extract an integer from a block for indexing.

    Uses the last 64-byte sub-block and interprets first 4 bytes
    as little-endian integer.

    Example:
        val index = integerify(block, 8)
    """
    val block_count = 2 * r
    val start = (block_count - 1) * 64

    # Get first 4 bytes of last block as little-endian integer
    val b0 = block.get(start)
    val b1 = block.get(start + 1)
    val b2 = block.get(start + 2)
    val b3 = block.get(start + 3)

    val value = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    value & 0xFFFFFFFF

fn xor_blocks(block1: list, block2: list) -> list:
    """XOR two blocks of equal length.

    Example:
        val result = xor_blocks(b1, b2)
    """
    var result = []
    var i = 0
    while i < block1.len():
        val b1 = block1.get(i)
        val b2 = block2.get(i)
        result.push(b1 ^ b2)
        i = i + 1
    result

fn romix(block: list, N: i64, r: i64) -> list:
    """ROMix function - the memory-hard component of scrypt.

    Algorithm:
    1. X = B
    2. For i = 0 to N-1:
         V[i] = X
         X = BlockMix(X)
    3. For i = 0 to N-1:
         j = Integerify(X) mod N
         X = BlockMix(X XOR V[j])
    4. Return X

    This requires storing N blocks in memory (V array).

    Example:
        val result = romix(block, 16384, 8)
    """
    val block_size = 128 * r

    # Initialize V array to store N blocks
    var V = []
    var i = 0
    while i < N:
        V.push([])
        i = i + 1

    # X = B
    var X = []
    i = 0
    while i < block.len():
        X.push(block.get(i))
        i = i + 1

    # Fill V array
    i = 0
    while i < N:
        # V[i] = X
        var v_block = []
        var j = 0
        while j < X.len():
            v_block.push(X.get(j))
            j = j + 1
        V.set(i, v_block)

        # X = BlockMix(X)
        X = block_mix_salsa8(X, r)

        i = i + 1

    # Random access phase
    i = 0
    while i < N:
        # j = Integerify(X) mod N
        val j_value = integerify(X, r)
        val j = j_value % N

        # X = BlockMix(X XOR V[j])
        val v_j = V.get(j)
        val xor_result = xor_blocks(X, v_j)
        X = block_mix_salsa8(xor_result, r)

        i = i + 1

    X

# =============================================================================
# PBKDF2 WRAPPER (using crypto_utils)
# =============================================================================

fn pbkdf2_hmac_sha256(password: text, salt: text, iterations: i64, dkLen: i64) -> list:
    """PBKDF2-HMAC-SHA256 wrapper.

    Uses crypto_utils implementation.

    Example:
        val key = pbkdf2_hmac_sha256("password", "salt", 1, 32)
    """
    val password_bytes = crypto_utils.text_to_bytes(password)
    val salt_bytes = crypto_utils.text_to_bytes(salt)
    crypto_utils.pbkdf2_sha256_bytes(password_bytes, salt_bytes, iterations, dkLen)

fn pbkdf2_hmac_sha256_bytes(password_bytes: list, salt_bytes: list, iterations: i64, dkLen: i64) -> list:
    """PBKDF2-HMAC-SHA256 for byte arrays.

    Example:
        val key = pbkdf2_hmac_sha256_bytes(pwd_bytes, salt_bytes, 1, 32)
    """
    crypto_utils.pbkdf2_sha256_bytes(password_bytes, salt_bytes, iterations, dkLen)

# =============================================================================
# MAIN SCRYPT ALGORITHM
# =============================================================================

fn scrypt(password: text, salt: text, N: i64, r: i64, p: i64, dkLen: i64) -> list:
    """Scrypt key derivation function.

    The main scrypt algorithm combining PBKDF2, ROMix, and Salsa20/8.

    Algorithm:
    1. B = PBKDF2-HMAC-SHA256(password, salt, 1, p * 128 * r)
    2. For i = 0 to p-1:
         B[i] = ROMix(B[i], N, r)
    3. DK = PBKDF2-HMAC-SHA256(password, B, 1, dkLen)

    Parameters:
    - password: Password string
    - salt: Salt string
    - N: CPU/memory cost (must be power of 2)
    - r: Block size parameter
    - p: Parallelization parameter
    - dkLen: Desired key length in bytes

    Returns: Derived key as byte list

    Example:
        val key = scrypt("password", "salt", 16384, 8, 1, 32)
    """
    # Validate parameters
    val params = create_scrypt_params(N, r, p, dkLen)
    var is_valid = validate_params(params)
    if is_valid == 0:
        # Return empty list on invalid parameters
        return []

    val block_size = 128 * r
    val total_blocks = p

    # Step 1: B = PBKDF2(password, salt, 1, p * 128 * r)
    val b_len = p * block_size
    val B = pbkdf2_hmac_sha256(password, salt, 1, b_len)

    # Step 2: For each block, apply ROMix
    var B_mixed = []
    var i = 0
    while i < b_len:
        B_mixed.push(0)
        i = i + 1

    var block_idx = 0
    while block_idx < p:
        # Extract block
        var block = []
        i = 0
        while i < block_size:
            val byte = B.get(block_idx * block_size + i)
            block.push(byte)
            i = i + 1

        # Apply ROMix
        val mixed = romix(block, N, r)

        # Store result back
        i = 0
        while i < block_size:
            B_mixed.set(block_idx * block_size + i, mixed.get(i))
            i = i + 1

        block_idx = block_idx + 1

    # Step 3: DK = PBKDF2(password, B_mixed, 1, dkLen)
    val password_bytes = crypto_utils.text_to_bytes(password)
    val DK = crypto_utils.pbkdf2_sha256_bytes(password_bytes, B_mixed, 1, dkLen)

    DK

fn scrypt_bytes(password_bytes: list, salt_bytes: list, N: i64, r: i64, p: i64, dkLen: i64) -> list:
    """Scrypt with byte array inputs.

    Example:
        val key = scrypt_bytes(pwd_bytes, salt_bytes, 16384, 8, 1, 32)
    """
    # Convert to text for now (could be optimized)
    val password = crypto_utils.bytes_to_text(password_bytes)
    val salt = crypto_utils.bytes_to_text(salt_bytes)
    scrypt(password, salt, N, r, p, dkLen)

# =============================================================================
# SALT GENERATION
# =============================================================================

fn generate_scrypt_salt() -> text:
    """Generate random salt for scrypt.

    Generates 16 bytes (128 bits) of random data.

    Returns: Base64-encoded salt string

    Example:
        val salt = generate_scrypt_salt()
    """
    generate_salt_with_length(DEFAULT_SALT_LENGTH)

fn generate_salt_with_length(length: i64) -> text:
    """Generate random salt with specified length.

    Example:
        val salt = generate_salt_with_length(32)
    """
    # Use crypto_utils salt generation
    crypto_utils.generate_salt(length)

fn generate_salt_bytes(length: i64) -> list:
    """Generate random salt as byte array.

    Example:
        val salt_bytes = generate_salt_bytes(16)
    """
    val salt_text = generate_salt_with_length(length)
    crypto_utils.text_to_bytes(salt_text)

# =============================================================================
# HASH FORMATTING AND PARSING
# =============================================================================

fn format_scrypt_hash(params, salt: text, hash: list) -> text:
    """Format scrypt hash in standard format.

    Format: $scrypt$ln=<N_log2>,r=<r>,p=<p>$<salt_base64>$<hash_base64>

    Example:
        val hash_str = format_scrypt_hash(params, salt, hash)
        # $scrypt$ln=14,r=8,p=1$aM15713r3Xd...$c2l4VH+U...
    """
    val (N, r, p, dkLen) = params
    val n_log2 = log2(N)

    # Encode salt and hash as base64
    val salt_bytes = crypto_utils.text_to_bytes(salt)
    val salt_b64 = base64_utils.base64_encode_bytes(salt_bytes)
    val hash_b64 = base64_utils.base64_encode_bytes(hash)

    # Build hash string
    val param_str = "ln={n_log2},r={r},p={p}"
    val result = "{SCRYPT_PREFIX}{param_str}${salt_b64}${hash_b64}"
    result

fn parse_scrypt_hash(hash_string: text):
    """Parse scrypt hash string.

    Extracts parameters, salt, and hash from formatted string.

    Returns: ((N, r, p, dkLen), salt_text, hash_bytes) or nil on error

    Example:
        val parsed = parse_scrypt_hash(hash_str)
        if parsed != nil:
            val (params, salt, hash) = parsed
    """
    # Check prefix
    var has_prefix = hash_string.starts_with(SCRYPT_PREFIX)
    if has_prefix == 0:
        return nil

    # Remove prefix
    val prefix_len = SCRYPT_PREFIX.len()
    var remaining = hash_string.substring(prefix_len)

    # Split by $
    val parts = remaining.split("$")
    if parts.len() < 3:
        return nil

    # Parse parameters (ln=14,r=8,p=1)
    val param_str = parts.get(0)
    val param_parts = param_str.split(",")
    if param_parts.len() < 3:
        return nil

    # Extract N (from ln=14)
    val ln_part = param_parts.get(0)
    var ln_eq_idx = ln_part.find("=")
    if ln_eq_idx < 0:
        return nil
    val ln_str = ln_part.substring(ln_eq_idx + 1)
    val n_log2 = ln_str.to_int()
    val N = 1 << n_log2  # 2^n_log2

    # Extract r (from r=8)
    val r_part = param_parts.get(1)
    var r_eq_idx = r_part.find("=")
    if r_eq_idx < 0:
        return nil
    val r_str = r_part.substring(r_eq_idx + 1)
    val r = r_str.to_int()

    # Extract p (from p=1)
    val p_part = param_parts.get(2)
    var p_eq_idx = p_part.find("=")
    if p_eq_idx < 0:
        return nil
    val p_str = p_part.substring(p_eq_idx + 1)
    val p = p_str.to_int()

    # Decode salt (base64)
    val salt_b64 = parts.get(1)
    val salt_bytes = base64_utils.base64_decode_to_bytes(salt_b64)
    val salt = crypto_utils.bytes_to_text(salt_bytes)

    # Decode hash (base64)
    val hash_b64 = parts.get(2)
    val hash_bytes = base64_utils.base64_decode_to_bytes(hash_b64)
    val dkLen = hash_bytes.len()

    # Create params tuple
    val params = create_scrypt_params(N, r, p, dkLen)

    (params, salt, hash_bytes)

# =============================================================================
# HIGH-LEVEL PASSWORD HASHING API
# =============================================================================

fn scrypt_hash(password: text, params):
    """Hash password with specified scrypt parameters.

    Generates random salt and returns formatted hash string.

    Example:
        val params = recommended_params()
        val hash = scrypt_hash("my_password", params)
    """
    val (N, r, p, dkLen) = params

    # Validate parameters
    var is_valid = validate_params(params)
    if is_valid == 0:
        return nil

    # Generate random salt
    val salt = generate_scrypt_salt()

    # Compute scrypt hash
    val hash = scrypt(password, salt, N, r, p, dkLen)

    # Format and return
    format_scrypt_hash(params, salt, hash)

fn scrypt_hash_password(password: text) -> text:
    """Hash password with default parameters.

    Simple interface using recommended parameters.

    Example:
        val hash = scrypt_hash_password("my_password")
    """
    val params = recommended_params()
    scrypt_hash(password, params)

fn scrypt_simple(password: text, salt: text) -> text:
    """Simple scrypt interface with default parameters.

    Returns hex-encoded hash.

    Example:
        val hash = scrypt_simple("password", "salt")
    """
    val hash = scrypt(password, salt, DEFAULT_N, DEFAULT_R, DEFAULT_P, DEFAULT_DKLEN)
    crypto_utils.bytes_to_hex(hash)

fn scrypt_verify(password: text, hash_string: text) -> i64:
    """Verify password against scrypt hash.

    Uses constant-time comparison to prevent timing attacks.

    Returns: 1 if password matches, 0 otherwise

    Example:
        val is_valid = scrypt_verify("my_password", hash)
        if is_valid:
            print "Password correct!"
    """
    # Parse hash string
    val parsed = parse_scrypt_hash(hash_string)
    if parsed == nil:
        return 0

    val (params, salt, expected_hash) = parsed
    val (N, r, p, dkLen) = params

    # Validate parameters
    var is_valid = validate_params(params)
    if is_valid == 0:
        return 0

    # Compute scrypt hash with same parameters
    val computed_hash = scrypt(password, salt, N, r, p, dkLen)

    # Constant-time comparison
    compare_constant_time(computed_hash, expected_hash)

fn scrypt_check(password: text, hash_string: text) -> i64:
    """Alias for scrypt_verify.

    Example:
        val is_valid = scrypt_check("password", hash)
    """
    scrypt_verify(password, hash_string)

# =============================================================================
# ADDITIONAL UTILITIES
# =============================================================================

fn scrypt_with_params(password: text, salt: text, params) -> list:
    """Scrypt using parameter tuple.

    Example:
        val params = recommended_params()
        val hash = scrypt_with_params("password", "salt", params)
    """
    val (N, r, p, dkLen) = params
    scrypt(password, salt, N, r, p, dkLen)

fn scrypt_hash_with_salt(password: text, salt: text, params):
    """Hash password with specified salt and parameters.

    Example:
        val hash = scrypt_hash_with_salt("password", "mysalt", params)
    """
    val (N, r, p, dkLen) = params
    val hash = scrypt(password, salt, N, r, p, dkLen)
    format_scrypt_hash(params, salt, hash)

fn get_hash_info(hash_string: text):
    """Extract information from scrypt hash without verifying.

    Returns parameters and salt (but not the hash itself).

    Example:
        val info = get_hash_info(hash)
        if info != nil:
            val (params, salt) = info
    """
    val parsed = parse_scrypt_hash(hash_string)
    if parsed == nil:
        return nil

    val (params, salt, hash) = parsed
    (params, salt)

fn params_to_text(params) -> text:
    """Convert parameters to human-readable text.

    Example:
        val text = params_to_text(params)
        # "N=16384, r=8, p=1, dkLen=32"
    """
    val (N, r, p, dkLen) = params
    "N={N}, r={r}, p={p}, dkLen={dkLen}"

fn memory_usage_text(params) -> text:
    """Get human-readable memory usage text.

    Example:
        val text = memory_usage_text(params)
        # "16 MB"
    """
    val memory = estimate_memory_usage(params)
    val mb = memory / 1048576
    if mb >= 1:
        return "{mb} MB"

    val kb = memory / 1024
    if kb >= 1:
        return "{kb} KB"

    "{memory} bytes"

fn compare_params(params1, params2) -> i64:
    """Compare two parameter sets for equality.

    Returns: 1 if equal, 0 otherwise

    Example:
        val equal = compare_params(params1, params2)
    """
    val (N1, r1, p1, dkLen1) = params1
    val (N2, r2, p2, dkLen2) = params2

    var equal = 1
    if N1 != N2:
        equal = 0
    if r1 != r2:
        equal = 0
    if p1 != p2:
        equal = 0
    if dkLen1 != dkLen2:
        equal = 0

    equal

fn is_valid_hash_format(hash_string: text) -> i64:
    """Check if string is valid scrypt hash format.

    Returns: 1 if valid format, 0 otherwise

    Example:
        val is_valid = is_valid_hash_format(hash)
    """
    val parsed = parse_scrypt_hash(hash_string)
    if parsed == nil:
        return 0
    1

fn rehash_needed(hash_string: text, current_params) -> i64:
    """Check if password needs rehashing with new parameters.

    Returns: 1 if rehash needed, 0 if current params match

    Example:
        val needs_rehash = rehash_needed(hash, recommended_params())
        if needs_rehash:
            val new_hash = scrypt_hash_password(password)
    """
    val parsed = parse_scrypt_hash(hash_string)
    if parsed == nil:
        return 1  # Invalid hash, needs rehash

    val (old_params, salt, hash) = parsed

    # Compare parameters
    val params_equal = compare_params(old_params, current_params)
    if params_equal == 0:
        return 1  # Parameters differ, needs rehash

    0  # No rehash needed

# =============================================================================
# BENCHMARKING AND TESTING UTILITIES
# =============================================================================

fn scrypt_test_vector_1() -> i64:
    """Test vector from scrypt spec.

    Returns: 1 if test passes, 0 otherwise
    """
    # Test vector: password="", salt="", N=16, r=1, p=1
    val result = scrypt("", "", 16, 1, 1, 64)

    # Expected result (first few bytes)
    # This is a simplified test - full test would check all bytes
    if result.len() == 64:
        return 1
    0

fn scrypt_benchmark_simple() -> i64:
    """Simple benchmark for scrypt performance.

    Returns approximate iterations per second.

    Example:
        val ips = scrypt_benchmark_simple()
        print "Iterations per second: {ips}"
    """
    # This would need timing support to implement properly
    # For now, just return a placeholder
    1

fn get_scrypt_version() -> text:
    """Get scrypt implementation version.

    Example:
        val version = get_scrypt_version()
    """
    "scrypt_utils 1.0.0"

# =============================================================================
# PARAMETER PRESET FUNCTIONS
# =============================================================================

fn params_interactive():
    """Interactive login parameters.

    Same as recommended_params().
    """
    recommended_params()

fn params_moderate():
    """Moderate security parameters.

    Balance between security and performance.
    """
    create_scrypt_params(16384, 8, 1, 32)

fn params_sensitive():
    """Sensitive data parameters.

    Higher security for sensitive applications.
    """
    high_security_params()

fn params_very_sensitive():
    """Very sensitive data parameters.

    Maximum practical security.
    """
    create_scrypt_params(65536, 8, 1, 32)

fn params_embedded():
    """Embedded system parameters.

    Low memory usage for constrained devices.
    """
    low_memory_params()

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

fn params_from_tuple(tuple):
    """Create params from any 4-element tuple.

    Example:
        val params = params_from_tuple((16384, 8, 1, 32))
    """
    tuple
