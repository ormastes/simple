# Regular Expression Engine - Utilities
#
# Utility functions for regex operations.

use std.text.{NL}

from .matcher import regex_compile, regex_find, regex_find_all, regex_match

# ============================================================================
# UTILITIES
# ============================================================================

fn optimize_nfa(nfa: any) -> any:
    """Optimize NFA by removing unreachable states."""
    nfa

fn print_nfa(nfa: any) -> text:
    """Print NFA in human-readable format."""
    var result = "NFA:" + NL
    result = result + "  Start: " + nfa.start_state.to_text() + NL
    result = result + "  Accept: " + nfa.accept_state.to_text() + NL
    result = result + "  States: " + nfa.states.len().to_text() + NL
    result = result + "  Transitions: " + nfa.transitions.len().to_text() + NL
    result

fn print_dfa(dfa: any) -> text:
    """Print DFA in human-readable format."""
    var result = "DFA:" + NL
    result = result + "  Start: " + dfa.start_state.to_text() + NL
    result = result + "  Accept states: " + dfa.accept_states.len().to_text() + NL
    result = result + "  States: " + dfa.states.len().to_text() + NL
    result = result + "  Transitions: " + dfa.transitions.len().to_text() + NL
    result

fn regex_stats(pattern: text) -> any:
    """Get statistics about compiled regex. Returns (states, transitions, groups)."""
    val compile_result = regex_compile(pattern)
    val success = compile_result.0
    if not success:
        return (0, 0, 0)
    val nfa = compile_result.1
    (nfa.states.len(), nfa.transitions.len(), nfa.group_count)

# ============================================================================
# GROUP EXTRACTION
# ============================================================================

fn extract_groups(match_result: any) -> [any]:
    """Extract captured groups from match result."""
    match_result.groups

fn group_at(match_result: any, index: i64) -> text:
    """Get text of captured group at index."""
    val groups = match_result.groups
    if index >= 0 and index < groups.len():
        val group = groups[index]
        return group.2
    ""

fn group_count(match_result: any) -> i64:
    """Get number of captured groups."""
    match_result.groups.len()

fn group_names(match_result: any) -> [text]:
    """Get names of all named groups."""
    var names = []
    val name_map = match_result.group_names
    names

# ============================================================================
# SPLITTING
# ============================================================================

fn regex_split(pattern: text, input: text) -> [text]:
    """Split input string by regex pattern."""
    val matches = regex_find_all(pattern, input)
    if matches.len() == 0:
        return [input]
    var parts = []
    var pos = 0
    var i = 0
    while i < matches.len():
        val match_tuple = matches[i]
        val start = match_tuple.0
        val end = match_tuple.1
        val part = input[pos:start]
        parts.push(part)
        pos = end
        i = i + 1
    val last_part = input[pos:input.len()]
    parts.push(last_part)
    parts

fn regex_split_n(pattern: text, input: text, max_splits: i64) -> [text]:
    """Split input string by regex pattern with maximum number of splits."""
    val matches = regex_find_all(pattern, input)
    if matches.len() == 0:
        return [input]
    var parts = []
    var pos = 0
    var i = 0
    var splits = 0
    while i < matches.len() and splits < max_splits:
        val match_tuple = matches[i]
        val start = match_tuple.0
        val end = match_tuple.1
        val part = input[pos:start]
        parts.push(part)
        pos = end
        splits = splits + 1
        i = i + 1
    val last_part = input[pos:input.len()]
    parts.push(last_part)
    parts

# ============================================================================
# ADVANCED MATCHING
# ============================================================================

fn regex_count_matches(pattern: text, input: text) -> i64:
    """Count number of matches in input."""
    val matches = regex_find_all(pattern, input)
    matches.len()

fn regex_extract_all(pattern: text, input: text) -> [text]:
    """Extract all matched texts."""
    val matches = regex_find_all(pattern, input)
    var texts = []
    var i = 0
    while i < matches.len():
        val match_tuple = matches[i]
        val text_match = match_tuple.2
        texts.push(text_match)
        i = i + 1
    texts

fn regex_match_length(pattern: text, input: text) -> i64:
    """Get length of first match. Returns -1 if no match."""
    val find_result = regex_find(pattern, input)
    val found = find_result.0
    if not found:
        return -1
    val start = find_result.1
    val end = find_result.2
    end - start

fn regex_starts_with(pattern: text, input: text) -> bool:
    """Check if input starts with pattern match."""
    val anchored = "^" + pattern
    regex_match(anchored, input)

fn regex_ends_with(pattern: text, input: text) -> bool:
    """Check if input ends with pattern match."""
    val anchored = pattern + "$"
    regex_match(anchored, input)

export optimize_nfa, print_nfa, print_dfa, regex_stats
export extract_groups, group_at, group_count, group_names
export regex_split, regex_split_n
export regex_count_matches, regex_extract_all, regex_match_length
export regex_starts_with, regex_ends_with
