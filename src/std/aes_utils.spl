# AES (Advanced Encryption Standard) Encryption/Decryption Utilities
#
# Pure Simple implementation of AES-128, AES-192, and AES-256
# Supports multiple block cipher modes: ECB, CBC, CTR
# PKCS#7 padding for block alignment
#
# SECURITY NOTES:
# - NEVER use ECB mode in production (patterns leak information)
# - ALWAYS use CBC or CTR with random IV/nonce
# - IV must be unique for each encryption with same key
# - Use AES-256 for high security applications
# - Keys must be cryptographically random
#
# AES ALGORITHM:
# - Block size: 128 bits (16 bytes)
# - Key sizes: 128, 192, or 256 bits
# - Rounds: 10 (AES-128), 12 (AES-192), 14 (AES-256)
# - Operations: SubBytes, ShiftRows, MixColumns, AddRoundKey
#
# AES STATE:
# - 4x4 byte matrix (column-major order)
# - Processed through multiple rounds
# - Each round applies transformations
#
# ARCHITECTURE:
# This module uses the facade pattern to organize AES functionality:
# - aes/types.spl: State operations and type definitions
# - aes/sbox.spl: S-box lookup tables and SubBytes operations
# - aes/key_expansion.spl: Key schedule generation
# - aes/cipher.spl: Core cipher transformations (ShiftRows, MixColumns, block operations)
# - aes/modes.spl: Block cipher modes (ECB, CBC, CTR)
# - aes/padding.spl: PKCS#7 padding
# - aes/utilities.spl: Utility functions (conversions, key generation, debugging)

# =============================================================================
# MODULE IMPORTS
# =============================================================================

# Import utilities (must be first - provides fundamental operations)
import aes/utilities

# Import types (state operations)
import aes/types

# Import S-box operations
import aes/sbox

# Import key expansion
import aes/key_expansion

# Import cipher core
import aes/cipher

# Import padding
import aes/padding

# Import block cipher modes
import aes/modes

# =============================================================================
# HIGH-LEVEL AES API (Text-based)
# =============================================================================

# =============================================================================
# AES-128 (128-bit key)
# =============================================================================

# Encrypt text using AES-128-CBC
fn aes128_encrypt(plaintext: text, key: text) -> list:
    val key_bytes = prepare_key(key, 16)
    val iv = generate_iv()
    val data_bytes = text_to_bytes(plaintext)
    val ciphertext = aes_cbc_encrypt(data_bytes, key_bytes, iv)

    # Prepend IV to ciphertext
    val result = []
    var i = 0
    while i < 16:
        result.append(iv[i])
        i = i + 1

    var j = 0
    val len = ciphertext.length()
    while j < len:
        result.append(ciphertext[j])
        j = j + 1

    result

# Decrypt ciphertext using AES-128-CBC
fn aes128_decrypt(ciphertext: list, key: text) -> text:
    val key_bytes = prepare_key(key, 16)

    # Extract IV (first 16 bytes)
    val iv = []
    var i = 0
    while i < 16:
        iv.append(ciphertext[i])
        i = i + 1

    # Extract actual ciphertext
    val actual_cipher = []
    var j = 16
    val len = ciphertext.length()
    while j < len:
        actual_cipher.append(ciphertext[j])
        j = j + 1

    val plaintext_bytes = aes_cbc_decrypt(actual_cipher, key_bytes, iv)
    bytes_to_text(plaintext_bytes)

# =============================================================================
# AES-192 (192-bit key)
# =============================================================================

# Encrypt text using AES-192-CBC
fn aes192_encrypt(plaintext: text, key: text) -> list:
    val key_bytes = prepare_key(key, 24)
    val iv = generate_iv()
    val data_bytes = text_to_bytes(plaintext)
    val ciphertext = aes_cbc_encrypt(data_bytes, key_bytes, iv)

    # Prepend IV to ciphertext
    val result = []
    var i = 0
    while i < 16:
        result.append(iv[i])
        i = i + 1

    var j = 0
    val len = ciphertext.length()
    while j < len:
        result.append(ciphertext[j])
        j = j + 1

    result

# Decrypt ciphertext using AES-192-CBC
fn aes192_decrypt(ciphertext: list, key: text) -> text:
    val key_bytes = prepare_key(key, 24)

    # Extract IV (first 16 bytes)
    val iv = []
    var i = 0
    while i < 16:
        iv.append(ciphertext[i])
        i = i + 1

    # Extract actual ciphertext
    val actual_cipher = []
    var j = 16
    val len = ciphertext.length()
    while j < len:
        actual_cipher.append(ciphertext[j])
        j = j + 1

    val plaintext_bytes = aes_cbc_decrypt(actual_cipher, key_bytes, iv)
    bytes_to_text(plaintext_bytes)

# =============================================================================
# AES-256 (256-bit key)
# =============================================================================

# Encrypt text using AES-256-CBC
fn aes256_encrypt(plaintext: text, key: text) -> list:
    val key_bytes = prepare_key(key, 32)
    val iv = generate_iv()
    val data_bytes = text_to_bytes(plaintext)
    val ciphertext = aes_cbc_encrypt(data_bytes, key_bytes, iv)

    # Prepend IV to ciphertext
    val result = []
    var i = 0
    while i < 16:
        result.append(iv[i])
        i = i + 1

    var j = 0
    val len = ciphertext.length()
    while j < len:
        result.append(ciphertext[j])
        j = j + 1

    result

# Decrypt ciphertext using AES-256-CBC
fn aes256_decrypt(ciphertext: list, key: text) -> text:
    val key_bytes = prepare_key(key, 32)

    # Extract IV (first 16 bytes)
    val iv = []
    var i = 0
    while i < 16:
        iv.append(ciphertext[i])
        i = i + 1

    # Extract actual ciphertext
    val actual_cipher = []
    var j = 16
    val len = ciphertext.length()
    while j < len:
        actual_cipher.append(ciphertext[j])
        j = j + 1

    val plaintext_bytes = aes_cbc_decrypt(actual_cipher, key_bytes, iv)
    bytes_to_text(plaintext_bytes)

# =============================================================================
# MAIN ENCRYPTION/DECRYPTION FUNCTIONS (Auto-detect mode)
# =============================================================================

# Encrypt text with automatic mode selection (defaults to AES-256-CBC)
fn aes_encrypt(plaintext: text, key: text) -> list:
    aes256_encrypt(plaintext, key)

# Decrypt ciphertext with automatic mode selection (defaults to AES-256-CBC)
fn aes_decrypt(ciphertext: list, key: text) -> text:
    aes256_decrypt(ciphertext, key)

# Encrypt text with specified mode
fn aes_encrypt_with_mode(plaintext: text, key: text, mode: text) -> list:
    val data_bytes = text_to_bytes(plaintext)

    if mode == "ecb":
        val key_bytes = prepare_key(key, 16)
        return aes_ecb_encrypt(data_bytes, key_bytes)

    if mode == "cbc":
        return aes_encrypt(plaintext, key)

    if mode == "ctr":
        val key_bytes = prepare_key(key, 16)
        val nonce = generate_nonce()
        val ciphertext = aes_ctr_encrypt(data_bytes, key_bytes, nonce)

        # Prepend nonce to ciphertext
        val result = []
        var i = 0
        while i < 16:
            result.append(nonce[i])
            i = i + 1

        var j = 0
        val len = ciphertext.length()
        while j < len:
            result.append(ciphertext[j])
            j = j + 1

        return result

    # Default to CBC
    aes_encrypt(plaintext, key)

# Decrypt ciphertext with specified mode
fn aes_decrypt_with_mode(ciphertext: list, key: text, mode: text) -> text:
    if mode == "ecb":
        val key_bytes = prepare_key(key, 16)
        val plaintext_bytes = aes_ecb_decrypt(ciphertext, key_bytes)
        return bytes_to_text(plaintext_bytes)

    if mode == "cbc":
        return aes_decrypt(ciphertext, key)

    if mode == "ctr":
        val key_bytes = prepare_key(key, 16)

        # Extract nonce (first 16 bytes)
        val nonce = []
        var i = 0
        while i < 16:
            nonce.append(ciphertext[i])
            i = i + 1

        # Extract actual ciphertext
        val actual_cipher = []
        var j = 16
        val len = ciphertext.length()
        while j < len:
            actual_cipher.append(ciphertext[j])
            j = j + 1

        val plaintext_bytes = aes_ctr_decrypt(actual_cipher, key_bytes, nonce)
        return bytes_to_text(plaintext_bytes)

    # Default to CBC
    aes_decrypt(ciphertext, key)
