"""Parser Module - Parsing utilities for common formats and TreeSitter integration

@tag:stdlib
@tag:api
@tag:parsing

This module provides parsing utilities for common data formats (JSON, CSV, TOML, etc.)
and TreeSitter integration for syntax highlighting and LSP features.

Core Features
-------------

- **JSON parsing**: Parse and serialize JSON data
- **CSV parsing**: Parse comma-separated values
- **TOML parsing**: Parse TOML configuration files
- **TreeSitter integration**: Syntax trees for editor support
- **Custom parsers**: Build your own parsers with TreeSitter

Public API
----------

JSON parsing:
```simple
use std.parser.{parse_json, json_to_string}
```

CSV parsing:
```simple
use std.parser.{parse_csv, csv_to_string}
```

TreeSitter integration:
```simple
use std.parser.treesitter.{TokenKind, Span, Token, Lexer}
use std.parser.treesitter_node.{Node, Point}
```

Examples
--------

JSON parsing:
```simple
use std.parser.{parse_json, json_to_string}

# Parse JSON string
val json_text = '{"name": "Alice", "age": 30, "active": true}'
val data = parse_json(json_text)

# Access fields (returns Option types)
val name = data.get("name") ?? "Unknown"
print "Name: {name}"  # Name: Alice

val age = data.get("age") ?? 0
print "Age: {age}"  # Age: 30

# Serialize back to JSON
val output = json_to_string(data)
print output  # {"name":"Alice","age":30,"active":true}
```

CSV parsing:
```simple
use std.parser.{parse_csv}

# Parse CSV data
val csv_text = "name,age,city\nAlice,30,NYC\nBob,25,LA"
val rows = parse_csv(csv_text)

# Iterate over rows
for row in rows:
    val name = row[0]
    val age = row[1]
    val city = row[2]
    print "{name} is {age} years old, lives in {city}"

# Output:
# Alice is 30 years old, lives in NYC
# Bob is 25 years old, lives in LA
```

CSV with headers:
```simple
use std.parser.{parse_csv_with_headers}

val csv_text = "name,age,city\nAlice,30,NYC\nBob,25,LA"
val (headers, rows) = parse_csv_with_headers(csv_text)

print "Headers: {headers}"  # Headers: [name, age, city]

for row in rows:
    # Access by header index
    val name = row[0]
    val age = row[1]
    print "{name}: {age}"
```

TreeSitter lexer:
```simple
use std.parser.treesitter.{Lexer, TokenKind}

# Create lexer for Simple language
val source = "fn add(x: i64, y: i64) -> i64:\n    x + y"
val lexer = Lexer.new("simple", source)

# Get tokens
val tokens = lexer.tokenize()
for token in tokens:
    print "Token: {token.kind} at {token.span.start}:{token.span.end}"
    print "  Text: {token.text}"

# Output:
# Token: Keyword at 0:2
#   Text: fn
# Token: Identifier at 3:6
#   Text: add
# ...
```

TreeSitter syntax tree:
```simple
use std.parser.treesitter_node.{Node, Point}

# Parse source into syntax tree
val source = "val x = 42"
val tree = parse_simple(source)
val root = tree.root_node()

# Navigate tree
print "Root kind: {root.kind()}"  # Root kind: source_file

val children = root.children()
for child in children:
    print "Child: {child.kind()}"
    val start = child.start_position()
    val end = child.end_position()
    print "  Position: ({start.row},{start.column}) to ({end.row},{end.column})"
```

TOML configuration:
```simple
use std.parser.{parse_toml}

val config_text = """
[server]
host = "127.0.0.1"
port = 8080

[database]
url = "postgres://localhost/mydb"
max_connections = 10
"""

val config = parse_toml(config_text)

# Access nested tables
val server = config.get("server") ?? {}
val host = server.get("host") ?? "localhost"
val port = server.get("port") ?? 80

print "Server: {host}:{port}"  # Server: 127.0.0.1:8080
```

Data Format Support
-------------------

| Format | Parse Function | Serialize Function | Status |
|--------|---------------|-------------------|--------|
| JSON | parse_json | json_to_string | Stable |
| CSV | parse_csv | csv_to_string | Stable |
| TOML | parse_toml | toml_to_string | Beta |
| YAML | parse_yaml | yaml_to_string | Planned |
| XML | parse_xml | xml_to_string | Planned |

TreeSitter Languages
--------------------

Supported languages for syntax highlighting:

- Simple (.spl files)
- Python (.py files)
- JavaScript/TypeScript (.js, .ts files)
- Rust (.rs files)
- Go (.go files)
- C/C++ (.c, .cpp, .h files)

Error Handling
--------------

All parsing functions return Result types:

```simple
# JSON parsing with error handling
match parse_json(json_text):
    case Ok(data):
        print "Parsed successfully"
        # Use data...
    case Err(error):
        print "Parse error: {error.message}"
        print "  at line {error.line}, column {error.column}"
```

CSV parsing errors:
```simple
# CSV with error recovery
val result = parse_csv_tolerant(csv_text)
match result:
    case Ok((rows, warnings)):
        print "Parsed {rows.len()} rows"
        for warning in warnings:
            print "Warning: {warning}"
    case Err(error):
        print "Fatal error: {error}"
```

Submodules
----------

- **json**: JSON parsing and serialization
- **csv**: CSV parsing and writing
- **toml**: TOML configuration parsing
- **treesitter**: TreeSitter lexer and tokenization
- **treesitter_node**: TreeSitter AST navigation

Related Modules
---------------

- **std.sdn**: SDN format parsing (Simple Data Notation)
- **std.common.file_reader**: File reading utilities
- **app.io**: File I/O operations

Performance Notes
-----------------

- JSON parser is streaming (low memory for large files)
- CSV parser loads entire file (use streaming API for huge CSV)
- TreeSitter is incremental (efficient for editor updates)
- TOML parser is strict (validates types and structure)

See Also
--------

- **doc/guide/parsing.md**: Parsing guide
- **doc/design/treesitter_integration.md**: TreeSitter design
- **test/unit/std/parser/**: Parser test examples
"""

# All submodules are automatically available.
