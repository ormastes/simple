# ASN.1 DER Encoding/Decoding Functions
#
# This module provides low-level ASN.1 DER parsing primitives.

fn asn1_decode_tag(bytes: text, offset: i64) -> i64:
    # Decode ASN.1 tag at given offset
    if offset >= bytes.length():
        return nil

    bytes.char_code_at(offset)

fn asn1_decode_length(bytes: text, offset: i64) -> text:
    # Decode ASN.1 length and return (length, next_offset)
    if offset >= bytes.length():
        return nil

    val first_byte = bytes.char_code_at(offset)

    if first_byte < 128:
        # Short form: length is in first byte
        return (first_byte, offset + 1)

    # Long form: first byte indicates number of length bytes
    val num_length_bytes = first_byte & 127
    var length = 0
    var i = 0

    while i < num_length_bytes:
        if offset + 1 + i >= bytes.length():
            return nil

        val byte_val = bytes.char_code_at(offset + 1 + i)
        length = (length << 8) | byte_val
        i = i + 1

    (length, offset + 1 + num_length_bytes)

fn asn1_read_tlv(bytes: text, offset: i64) -> text:
    # Read Tag-Length-Value at offset, return (tag, value, next_offset)
    if offset >= bytes.length():
        return nil

    val tag = asn1_decode_tag(bytes, offset)
    if tag == nil:
        return nil

    val length_result = asn1_decode_length(bytes, offset + 1)
    if length_result == nil:
        return nil

    val length = length_result[0]
    val value_offset = length_result[1]

    if value_offset + length > bytes.length():
        return nil

    val value = bytes.substring(value_offset, value_offset + length)
    val next_offset = value_offset + length

    (tag, value, next_offset)

fn parse_der_integer(bytes: text) -> i64:
    # Parse DER INTEGER value
    if bytes.length() == 0:
        return 0

    var result = 0
    var i = 0

    # Handle negative numbers (skip for simplicity in certificates)
    val start = if bytes.char_code_at(0) == 0: 1 else: 0

    while i < bytes.length():
        if i >= start:
            val byte_val = bytes.char_code_at(i)
            result = (result << 8) | byte_val
        i = i + 1

    result

fn parse_der_string(bytes: text) -> text:
    # Parse DER string (UTF8String, PrintableString, IA5String)
    bytes

fn parse_der_oid(bytes: text) -> text:
    # Parse DER Object Identifier to dotted string
    if bytes.length() == 0:
        return ""

    var result = ""
    val first_byte = bytes.char_code_at(0)

    # First byte encodes first two components
    val first = first_byte / 40
    val second = first_byte % 40
    result = "{first}.{second}"

    var i = 1
    var current = 0

    while i < bytes.length():
        val byte_val = bytes.char_code_at(i)

        if byte_val >= 128:
            # High bit set: more bytes follow
            current = (current << 7) | (byte_val & 127)
        else:
            # High bit clear: last byte of component
            current = (current << 7) | byte_val
            result = result + ".{current}"
            current = 0

        i = i + 1

    result

fn parse_der_sequence(bytes: text) -> text:
    # Parse DER SEQUENCE and return array of TLV tuples
    var items = []
    var offset = 0

    while offset < bytes.length():
        val tlv = asn1_read_tlv(bytes, offset)
        if tlv == nil:
            break

        items = items + [tlv]
        offset = tlv[2]

    items

fn parse_der_bit_string(bytes: text) -> text:
    # Parse DER BIT STRING (first byte is unused bits count)
    if bytes.length() == 0:
        return ""

    val unused_bits = bytes.char_code_at(0)
    val data = bytes.substring(1, bytes.length())
    (unused_bits, data)
