# AES Block Cipher Modes Module
#
# This module implements different modes of operation: ECB, CBC, CTR

# Import dependencies
import aes/utilities
import aes/padding
import aes/key_expansion
import aes/cipher

# =============================================================================
# AES ECB MODE (Electronic Codebook)
# WARNING: ECB is insecure - patterns in plaintext are visible in ciphertext
# Use CBC or CTR mode instead
# =============================================================================

# Encrypt data using AES-ECB mode
fn aes_ecb_encrypt(data: list, key: list) -> list:
    val padded = pkcs7_pad(data, 16)
    val ciphertext = []

    val key_size = key.length()
    val num_rounds = 0
    var rounds = 0

    if key_size == 16:
        rounds = 10
    else:
        if key_size == 24:
            rounds = 12
        else:
            rounds = 14

    val expanded = expand_key(key, key_size)

    var i = 0
    val len = padded.length()
    while i < len:
        val block = []
        var j = 0
        while j < 16:
            block.append(padded[i + j])
            j = j + 1

        val encrypted = aes_encrypt_block_with_expanded(block, expanded, rounds)

        var k = 0
        while k < 16:
            ciphertext.append(encrypted[k])
            k = k + 1

        i = i + 16

    ciphertext

# Decrypt data using AES-ECB mode
fn aes_ecb_decrypt(ciphertext: list, key: list) -> list:
    val plaintext = []

    val key_size = key.length()
    val num_rounds = 0
    var rounds = 0

    if key_size == 16:
        rounds = 10
    else:
        if key_size == 24:
            rounds = 12
        else:
            rounds = 14

    val expanded = expand_key(key, key_size)

    var i = 0
    val len = ciphertext.length()
    while i < len:
        val block = []
        var j = 0
        while j < 16:
            block.append(ciphertext[i + j])
            j = j + 1

        val decrypted = aes_decrypt_block_with_expanded(block, expanded, rounds)

        var k = 0
        while k < 16:
            plaintext.append(decrypted[k])
            k = k + 1

        i = i + 16

    pkcs7_unpad(plaintext)

# =============================================================================
# AES CBC MODE (Cipher Block Chaining)
# More secure than ECB - requires random IV
# =============================================================================

# Encrypt data using AES-CBC mode
fn aes_cbc_encrypt(data: list, key: list, iv: list) -> list:
    val padded = pkcs7_pad(data, 16)
    val ciphertext = []

    val key_size = key.length()
    val num_rounds = 0
    var rounds = 0

    if key_size == 16:
        rounds = 10
    else:
        if key_size == 24:
            rounds = 12
        else:
            rounds = 14

    val expanded = expand_key(key, key_size)

    var prev_block = iv
    var i = 0
    val len = padded.length()

    while i < len:
        val block = []
        var j = 0
        while j < 16:
            block.append(padded[i + j])
            j = j + 1

        # XOR with previous ciphertext block (or IV)
        val xored = xor_blocks(block, prev_block)

        # Encrypt
        val encrypted = aes_encrypt_block_with_expanded(xored, expanded, rounds)

        # Save as previous block for next iteration
        prev_block = encrypted

        # Append to ciphertext
        var k = 0
        while k < 16:
            ciphertext.append(encrypted[k])
            k = k + 1

        i = i + 16

    ciphertext

# Decrypt data using AES-CBC mode
fn aes_cbc_decrypt(ciphertext: list, key: list, iv: list) -> list:
    val plaintext = []

    val key_size = key.length()
    val num_rounds = 0
    var rounds = 0

    if key_size == 16:
        rounds = 10
    else:
        if key_size == 24:
            rounds = 12
        else:
            rounds = 14

    val expanded = expand_key(key, key_size)

    var prev_block = iv
    var i = 0
    val len = ciphertext.length()

    while i < len:
        val block = []
        var j = 0
        while j < 16:
            block.append(ciphertext[i + j])
            j = j + 1

        # Decrypt
        val decrypted = aes_decrypt_block_with_expanded(block, expanded, rounds)

        # XOR with previous ciphertext block (or IV)
        val xored = xor_blocks(decrypted, prev_block)

        # Save current ciphertext block for next iteration
        prev_block = block

        # Append to plaintext
        var k = 0
        while k < 16:
            plaintext.append(xored[k])
            k = k + 1

        i = i + 16

    pkcs7_unpad(plaintext)

# =============================================================================
# AES CTR MODE (Counter)
# Stream cipher mode - parallelizable
# =============================================================================

# Increment counter (16-byte counter, big-endian)
fn increment_counter(counter: list) -> list:
    val new_counter = []
    var carry = 1

    # Increment from right to left (big-endian)
    var i = 15
    while i >= 0:
        val sum = counter[i] + carry
        val new_byte = sum % 256
        carry = sum / 256
        new_counter.append(new_byte)
        i = i - 1

    # Reverse to get correct order
    val result = []
    var j = 15
    while j >= 0:
        result.append(new_counter[j])
        j = j - 1
    result

# Encrypt/Decrypt data using AES-CTR mode (same operation for both)
fn aes_ctr_process(data: list, key: list, nonce: list) -> list:
    val output = []

    val key_size = key.length()
    val num_rounds = 0
    var rounds = 0

    if key_size == 16:
        rounds = 10
    else:
        if key_size == 24:
            rounds = 12
        else:
            rounds = 14

    val expanded = expand_key(key, key_size)

    # Initialize counter (nonce + counter)
    var counter = []
    var i = 0
    while i < 16:
        if i < nonce.length():
            counter.append(nonce[i])
        else:
            counter.append(0)
        i = i + 1

    var pos = 0
    val len = data.length()

    while pos < len:
        # Encrypt counter
        val encrypted_counter = aes_encrypt_block_with_expanded(counter, expanded, rounds)

        # XOR with data block
        var j = 0
        while j < 16:
            if pos + j < len:
                val xor_val = xor_byte(data[pos + j], encrypted_counter[j])
                output.append(xor_val)
            j = j + 1

        # Increment counter
        counter = increment_counter(counter)
        pos = pos + 16

    output

# Encrypt using CTR mode
fn aes_ctr_encrypt(data: list, key: list, nonce: list) -> list:
    aes_ctr_process(data, key, nonce)

# Decrypt using CTR mode (same as encrypt)
fn aes_ctr_decrypt(ciphertext: list, key: list, nonce: list) -> list:
    aes_ctr_process(ciphertext, key, nonce)
