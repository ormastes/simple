# B-tree Utilities Module
#
# Comprehensive B-tree implementation for database-style operations.
# A B-tree is a self-balancing tree data structure that maintains sorted data
# and allows searches, sequential access, insertions, and deletions in logarithmic time.
#
# B-tree Properties:
# 1. All leaves are at the same level
# 2. Each node (except root) has [t-1, 2t-1] keys where t is minimum degree
# 3. Each internal node has [t, 2t] children
# 4. Keys within a node are sorted in ascending order
# 5. All keys in left subtree < key < all keys in right subtree
#
# B-tree Parameters:
# - Minimum degree (t): Determines node capacity
#   - t=3: 2-5 keys per node (2-3-4 tree)
#   - t=10: 9-19 keys per node
#   - t=100: 99-199 keys per node (database-friendly)
#
# Time Complexity:
# - Search: O(log_t n)
# - Insert: O(log_t n)
# - Delete: O(log_t n)
# - Height: O(log_t n)
#
# Space Complexity: O(n)
#
# Use Cases:
# - Database indexes
# - File systems
# - Large datasets on disk
# - Range queries
#
# NOTE: Pure Simple implementation with tuple-based structures.
# No generics, no try/catch, no chained methods.

# ============================================================================
# Data Structures (Tuple-based)
# ============================================================================

# BTreeNode: Represents a node in the B-tree
# Structure: (keys: list, children: list, is_leaf: bool, n: i64, t: i64)
# - keys: List of keys stored in this node (sorted)
# - children: List of child nodes (for internal nodes)
# - is_leaf: True if this is a leaf node
# - n: Current number of keys in this node
# - t: Minimum degree (tree parameter)

# BTree: Represents the complete B-tree
# Structure: (root: node, t: i64, height: i64)
# - root: Root node of the tree
# - t: Minimum degree
# - height: Height of the tree

# ============================================================================
# Node Creation Functions
# ============================================================================

# Create an empty B-tree node
# Parameters:
#   t: Minimum degree
#   is_leaf: True if this should be a leaf node
# Returns: New node tuple (keys, children, is_leaf, n, t)
fn create_node(t, is_leaf):
    val keys = []
    val children = []
    val n = 0
    (keys, children, is_leaf, n, t)

# Create an empty root node
fn create_empty_node(t):
    create_node(t, true)

# Create a new B-tree with minimum degree t
# Parameters:
#   t: Minimum degree (must be >= 2)
# Returns: New B-tree tuple (root, t, height)
fn create_btree(t):
    val root = create_empty_node(t)
    val height = 0
    (root, t, height)

# ============================================================================
# Node Property Functions
# ============================================================================

# Get keys from a node
fn node_keys(node):
    val keys = node.0
    keys

# Get children from a node
fn node_children(node):
    val children = node.1
    children

# Check if node is a leaf
fn node_is_leaf(node):
    val is_leaf = node.2
    is_leaf

# Get number of keys in node
fn node_n(node):
    val n = node.3
    n

# Get minimum degree from node
fn node_t(node):
    val t = node.4
    t

# Set keys in a node (returns new node)
fn node_set_keys(node, keys):
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)
    val t = node_t(node)
    (keys, children, is_leaf, n, t)

# Set children in a node (returns new node)
fn node_set_children(node, children):
    val keys = node_keys(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)
    val t = node_t(node)
    (keys, children, is_leaf, n, t)

# Set n (key count) in a node (returns new node)
fn node_set_n(node, new_n):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val t = node_t(node)
    (keys, children, is_leaf, new_n, t)

# Set is_leaf flag in a node (returns new node)
fn node_set_is_leaf(node, new_is_leaf):
    val keys = node_keys(node)
    val children = node_children(node)
    val n = node_n(node)
    val t = node_t(node)
    (keys, children, new_is_leaf, n, t)

# ============================================================================
# Tree Property Functions
# ============================================================================

# Get root from tree
fn tree_root(tree):
    val root = tree.0
    root

# Get minimum degree from tree
fn tree_t(tree):
    val t = tree.1
    t

# Get height from tree
fn tree_height(tree):
    val height = tree.2
    height

# Set root in tree (returns new tree)
fn tree_set_root(tree, root):
    val t = tree_t(tree)
    val height = tree_height(tree)
    (root, t, height)

# Set height in tree (returns new tree)
fn tree_set_height(tree, height):
    val root = tree_root(tree)
    val t = tree_t(tree)
    (root, t, height)

# ============================================================================
# Node Capacity Functions
# ============================================================================

# Check if a node is full (has 2t-1 keys)
# A full node must be split before insertion
fn is_full(node):
    val n = node_n(node)
    val t = node_t(node)
    val max_keys = (2 * t) - 1
    n == max_keys

# Check if a node has minimum keys (t-1)
fn is_minimal(node):
    val n = node_n(node)
    val t = node_t(node)
    val min_keys = t - 1
    n == min_keys

# Check if a node can donate a key (has > t-1 keys)
fn can_donate(node):
    val n = node_n(node)
    val t = node_t(node)
    val min_keys = t - 1
    n > min_keys

# Get maximum number of keys for a node
fn max_keys(t):
    (2 * t) - 1

# Get minimum number of keys for a non-root node
fn min_keys(t):
    t - 1

# Get maximum number of children for a node
fn max_children(t):
    2 * t

# Get minimum number of children for a non-root internal node
fn min_children(t):
    t

# ============================================================================
# Key Search Functions
# ============================================================================

# Find the index of the first key >= search_key in a node
# Returns the index where the key should be (or is)
# If all keys < search_key, returns n (number of keys)
fn find_key_index(node, search_key):
    val keys = node_keys(node)
    val n = node_n(node)
    var idx = 0
    var found = false
    for i in 0..n:
        val current = idx
        val key = keys.current
        val less = key < search_key
        if less:
            idx = idx + 1
        else:
            found = true
    idx

# Check if a key exists in a node at specific index
fn key_at_index(node, idx):
    val keys = node_keys(node)
    val n = node_n(node)
    val valid = idx < n
    if valid:
        keys.idx
    else:
        nil

# Check if a key exists in a node
# Returns index if found, nil otherwise
fn find_key(node, search_key):
    val keys = node_keys(node)
    val n = node_n(node)
    var result = nil
    for i in 0..n:
        val key = keys.i
        val match = key == search_key
        if match:
            result = i
    result

# ============================================================================
# Tree Search Functions
# ============================================================================

# Search for a key in a node and its subtrees
# Returns true if key is found, false otherwise
fn search_node(node, search_key):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)

    # Find the first key >= search_key
    val idx = find_key_index(node, search_key)

    # Check if key is in this node
    val found_idx = find_key(node, search_key)
    val is_nil = found_idx == nil
    if is_nil:
        # Key not in this node
        val result = false
        result
    else:
        # Key found in this node
        val result = true
        result

    # If not found and is leaf, key doesn't exist
    if is_leaf:
        false
    else:
        # Search in appropriate child
        val has_children = idx < (n + 1)
        if has_children:
            val child = children.idx
            search_node(child, search_key)
        else:
            false

# Search for a key in the B-tree
# Returns true if key exists, false otherwise
fn btree_search(tree, search_key):
    val root = tree_root(tree)
    search_node(root, search_key)

# ============================================================================
# Node Splitting Functions
# ============================================================================

# Split a full child node
# Parameters:
#   parent: Parent node
#   i: Index of child to split
#   child: Full child node to split
# Returns: (new_parent, new_child, new_sibling)
#
# Process:
# 1. Create new node (sibling)
# 2. Move t-1 largest keys from child to sibling
# 3. Move t largest children from child to sibling (if not leaf)
# 4. Promote middle key to parent
# 5. Insert new sibling as child of parent
fn split_child(parent, i, child):
    val t = node_t(child)
    val child_is_leaf = node_is_leaf(child)

    # Create new sibling node
    var sibling = create_node(t, child_is_leaf)

    # Get child data
    val child_keys = node_keys(child)
    val child_children = node_children(child)
    val child_n = node_n(child)

    # Middle key index (to be promoted)
    val mid = t - 1

    # Move t-1 keys to sibling
    var sibling_keys = []
    for j in 0..(t - 1):
        val src_idx = mid + 1 + j
        val key = child_keys.src_idx
        sibling_keys = list_append(sibling_keys, key)

    # Move t children to sibling (if not leaf)
    var sibling_children = []
    val is_not_leaf = !child_is_leaf
    if is_not_leaf:
        for j in 0..t:
            val src_idx = mid + 1 + j
            val child_node = child_children.src_idx
            sibling_children = list_append(sibling_children, child_node)

    # Update sibling
    sibling = node_set_keys(sibling, sibling_keys)
    sibling = node_set_children(sibling, sibling_children)
    sibling = node_set_n(sibling, t - 1)

    # Get middle key to promote
    val promote_key = child_keys.mid

    # Update child to have only first t-1 keys
    var new_child_keys = []
    for j in 0..mid:
        val key = child_keys.j
        new_child_keys = list_append(new_child_keys, key)

    var new_child_children = []
    if is_not_leaf:
        for j in 0..t:
            val child_node = child_children.j
            new_child_children = list_append(new_child_children, child_node)

    var new_child = child
    new_child = node_set_keys(new_child, new_child_keys)
    new_child = node_set_children(new_child, new_child_children)
    new_child = node_set_n(new_child, t - 1)

    # Insert promoted key into parent
    val parent_keys = node_keys(parent)
    val parent_children = node_children(parent)
    val parent_n = node_n(parent)

    var new_parent_keys = []
    for j in 0..i:
        val key = parent_keys.j
        new_parent_keys = list_append(new_parent_keys, key)
    new_parent_keys = list_append(new_parent_keys, promote_key)
    for j in i..parent_n:
        val key = parent_keys.j
        new_parent_keys = list_append(new_parent_keys, key)

    # Insert new sibling into parent's children
    var new_parent_children = []
    for j in 0..(i + 1):
        val child_node = parent_children.j
        new_parent_children = list_append(new_parent_children, child_node)
    new_parent_children = list_append(new_parent_children, sibling)
    for j in (i + 1)..(parent_n + 1):
        val child_node = parent_children.j
        new_parent_children = list_append(new_parent_children, child_node)

    # Update parent's child at index i
    var final_parent_children = []
    for j in 0..(i + 2):
        if j == i:
            final_parent_children = list_append(final_parent_children, new_child)
        else:
            val idx_in_new = j
            val is_before = j < i
            val is_after = j > i
            if is_before:
                val child_node = new_parent_children.j
                final_parent_children = list_append(final_parent_children, child_node)
            else:
                val adjusted = j
                val child_node = new_parent_children.adjusted
                final_parent_children = list_append(final_parent_children, child_node)
    for j in (i + 2)..(parent_n + 2):
        val child_node = new_parent_children.j
        final_parent_children = list_append(final_parent_children, child_node)

    var new_parent = parent
    new_parent = node_set_keys(new_parent, new_parent_keys)
    new_parent = node_set_children(new_parent, final_parent_children)
    new_parent = node_set_n(new_parent, parent_n + 1)

    (new_parent, new_child, sibling)

# ============================================================================
# Insertion Helper Functions
# ============================================================================

# Insert a key into a node that is not full
# Assumes node is not full
# Returns new node with key inserted
fn insert_non_full(node, key):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)
    val t = node_t(node)

    if is_leaf:
        # Insert key in sorted position
        val idx = find_key_index(node, key)
        var new_keys = []
        for i in 0..idx:
            val k = keys.i
            new_keys = list_append(new_keys, k)
        new_keys = list_append(new_keys, key)
        for i in idx..n:
            val k = keys.i
            new_keys = list_append(new_keys, k)

        var new_node = node
        new_node = node_set_keys(new_node, new_keys)
        new_node = node_set_n(new_node, n + 1)
        new_node
    else:
        # Find child to insert into
        val idx = find_key_index(node, key)
        val child = children.idx

        # Check if child is full
        val child_full = is_full(child)
        if child_full:
            # Split child first
            val split_result = split_child(node, idx, child)
            val new_parent = split_result.0
            val new_child = split_result.1
            val new_sibling = split_result.2

            # Determine which child to insert into
            val parent_keys = node_keys(new_parent)
            val mid_key = parent_keys.idx
            val go_right = key > mid_key
            if go_right:
                val right_idx = idx + 1
                val parent_children = node_children(new_parent)
                val right_child = parent_children.right_idx
                val updated_right = insert_non_full(right_child, key)

                # Update parent's children
                var updated_children = []
                for i in 0..(right_idx):
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)
                updated_children = list_append(updated_children, updated_right)
                val parent_n = node_n(new_parent)
                for i in (right_idx + 1)..(parent_n + 1):
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)

                val result = node_set_children(new_parent, updated_children)
                result
            else:
                val updated_left = insert_non_full(new_child, key)

                # Update parent's children
                val parent_children = node_children(new_parent)
                var updated_children = []
                for i in 0..idx:
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)
                updated_children = list_append(updated_children, updated_left)
                val parent_n = node_n(new_parent)
                for i in (idx + 1)..(parent_n + 1):
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)

                val result = node_set_children(new_parent, updated_children)
                result
        else:
            # Insert into non-full child
            val updated_child = insert_non_full(child, key)

            # Update this node's children
            var updated_children = []
            for i in 0..idx:
                val c = children.i
                updated_children = list_append(updated_children, c)
            updated_children = list_append(updated_children, updated_child)
            for i in (idx + 1)..(n + 1):
                val c = children.i
                updated_children = list_append(updated_children, c)

            val result = node_set_children(node, updated_children)
            result

# ============================================================================
# Main Insertion Function
# ============================================================================

# Insert a key into the B-tree
# Parameters:
#   tree: The B-tree
#   key: Key to insert
# Returns: Updated tree
fn btree_insert(tree, key):
    val root = tree_root(tree)
    val t = tree_t(tree)
    val height = tree_height(tree)

    # Check if root is full
    val root_full = is_full(root)
    if root_full:
        # Create new root
        var new_root = create_node(t, false)

        # Old root becomes child of new root
        var new_root_children = []
        new_root_children = list_append(new_root_children, root)
        new_root = node_set_children(new_root, new_root_children)

        # Split old root
        val split_result = split_child(new_root, 0, root)
        val updated_root = split_result.0

        # Insert into new root
        val final_root = insert_non_full(updated_root, key)

        # Update tree with new root and increased height
        var new_tree = tree
        new_tree = tree_set_root(new_tree, final_root)
        new_tree = tree_set_height(new_tree, height + 1)
        new_tree
    else:
        # Insert into non-full root
        val updated_root = insert_non_full(root, key)
        val result = tree_set_root(tree, updated_root)
        result

# ============================================================================
# Deletion Helper Functions
# ============================================================================

# Get predecessor key (largest key in left subtree)
fn get_predecessor(node):
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        val keys = node_keys(node)
        val n = node_n(node)
        val last_idx = n - 1
        keys.last_idx
    else:
        val children = node_children(node)
        val n = node_n(node)
        val last_child = children.n
        get_predecessor(last_child)

# Get successor key (smallest key in right subtree)
fn get_successor(node):
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        val keys = node_keys(node)
        keys.0
    else:
        val children = node_children(node)
        val first_child = children.0
        get_successor(first_child)

# Remove key at index from leaf node
fn remove_from_leaf(node, idx):
    val keys = node_keys(node)
    val n = node_n(node)

    var new_keys = []
    for i in 0..idx:
        val k = keys.i
        new_keys = list_append(new_keys, k)
    for i in (idx + 1)..n:
        val k = keys.i
        new_keys = list_append(new_keys, k)

    var new_node = node
    new_node = node_set_keys(new_node, new_keys)
    new_node = node_set_n(new_node, n - 1)
    new_node

# Borrow a key from previous sibling
fn borrow_from_prev(parent, idx):
    val children = node_children(parent)
    val child = children.idx
    val sibling = children.(idx - 1)

    val parent_keys = node_keys(parent)
    val parent_n = node_n(parent)

    val child_keys = node_keys(child)
    val child_children = node_children(child)
    val child_n = node_n(child)
    val child_is_leaf = node_is_leaf(child)

    val sibling_keys = node_keys(sibling)
    val sibling_children = node_children(sibling)
    val sibling_n = node_n(sibling)

    # Move parent key down to child
    val parent_key = parent_keys.(idx - 1)
    var new_child_keys = []
    new_child_keys = list_append(new_child_keys, parent_key)
    for i in 0..child_n:
        val k = child_keys.i
        new_child_keys = list_append(new_child_keys, k)

    # Move sibling's last child to child's first child
    var new_child_children = []
    val is_not_leaf = !child_is_leaf
    if is_not_leaf:
        val last_child = sibling_children.(sibling_n)
        new_child_children = list_append(new_child_children, last_child)
        for i in 0..(child_n + 1):
            val c = child_children.i
            new_child_children = list_append(new_child_children, c)

    # Update child
    var new_child = child
    new_child = node_set_keys(new_child, new_child_keys)
    new_child = node_set_children(new_child, new_child_children)
    new_child = node_set_n(new_child, child_n + 1)

    # Move sibling's last key up to parent
    val last_sibling_key = sibling_keys.(sibling_n - 1)
    var new_parent_keys = []
    for i in 0..(idx - 1):
        val k = parent_keys.i
        new_parent_keys = list_append(new_parent_keys, k)
    new_parent_keys = list_append(new_parent_keys, last_sibling_key)
    for i in idx..parent_n:
        val k = parent_keys.i
        new_parent_keys = list_append(new_parent_keys, k)

    # Remove last key from sibling
    var new_sibling_keys = []
    for i in 0..(sibling_n - 1):
        val k = sibling_keys.i
        new_sibling_keys = list_append(new_sibling_keys, k)

    var new_sibling_children = sibling_children
    if is_not_leaf:
        new_sibling_children = []
        for i in 0..sibling_n:
            val c = sibling_children.i
            new_sibling_children = list_append(new_sibling_children, c)

    var new_sibling = sibling
    new_sibling = node_set_keys(new_sibling, new_sibling_keys)
    new_sibling = node_set_children(new_sibling, new_sibling_children)
    new_sibling = node_set_n(new_sibling, sibling_n - 1)

    # Update parent
    var new_parent = parent
    new_parent = node_set_keys(new_parent, new_parent_keys)

    var new_parent_children = []
    for i in 0..(idx - 1):
        val c = children.i
        new_parent_children = list_append(new_parent_children, c)
    new_parent_children = list_append(new_parent_children, new_sibling)
    new_parent_children = list_append(new_parent_children, new_child)
    for i in (idx + 1)..(parent_n + 1):
        val c = children.i
        new_parent_children = list_append(new_parent_children, c)

    new_parent = node_set_children(new_parent, new_parent_children)
    new_parent

# Borrow a key from next sibling
fn borrow_from_next(parent, idx):
    val children = node_children(parent)
    val child = children.idx
    val sibling = children.(idx + 1)

    val parent_keys = node_keys(parent)
    val parent_n = node_n(parent)

    val child_keys = node_keys(child)
    val child_children = node_children(child)
    val child_n = node_n(child)
    val child_is_leaf = node_is_leaf(child)

    val sibling_keys = node_keys(sibling)
    val sibling_children = node_children(sibling)
    val sibling_n = node_n(sibling)

    # Move parent key down to child
    val parent_key = parent_keys.idx
    var new_child_keys = []
    for i in 0..child_n:
        val k = child_keys.i
        new_child_keys = list_append(new_child_keys, k)
    new_child_keys = list_append(new_child_keys, parent_key)

    # Move sibling's first child to child's last child
    var new_child_children = child_children
    val is_not_leaf = !child_is_leaf
    if is_not_leaf:
        new_child_children = []
        for i in 0..(child_n + 1):
            val c = child_children.i
            new_child_children = list_append(new_child_children, c)
        val first_child = sibling_children.0
        new_child_children = list_append(new_child_children, first_child)

    # Update child
    var new_child = child
    new_child = node_set_keys(new_child, new_child_keys)
    new_child = node_set_children(new_child, new_child_children)
    new_child = node_set_n(new_child, child_n + 1)

    # Move sibling's first key up to parent
    val first_sibling_key = sibling_keys.0
    var new_parent_keys = []
    for i in 0..idx:
        val k = parent_keys.i
        new_parent_keys = list_append(new_parent_keys, k)
    new_parent_keys = list_append(new_parent_keys, first_sibling_key)
    for i in (idx + 1)..parent_n:
        val k = parent_keys.i
        new_parent_keys = list_append(new_parent_keys, k)

    # Remove first key from sibling
    var new_sibling_keys = []
    for i in 1..sibling_n:
        val k = sibling_keys.i
        new_sibling_keys = list_append(new_sibling_keys, k)

    var new_sibling_children = []
    if is_not_leaf:
        for i in 1..(sibling_n + 1):
            val c = sibling_children.i
            new_sibling_children = list_append(new_sibling_children, c)

    var new_sibling = sibling
    new_sibling = node_set_keys(new_sibling, new_sibling_keys)
    new_sibling = node_set_children(new_sibling, new_sibling_children)
    new_sibling = node_set_n(new_sibling, sibling_n - 1)

    # Update parent
    var new_parent = parent
    new_parent = node_set_keys(new_parent, new_parent_keys)

    var new_parent_children = []
    for i in 0..idx:
        val c = children.i
        new_parent_children = list_append(new_parent_children, c)
    new_parent_children = list_append(new_parent_children, new_child)
    new_parent_children = list_append(new_parent_children, new_sibling)
    for i in (idx + 2)..(parent_n + 1):
        val c = children.i
        new_parent_children = list_append(new_parent_children, c)

    new_parent = node_set_children(new_parent, new_parent_children)
    new_parent

# Merge child with its sibling
fn merge_nodes(parent, idx):
    val children = node_children(parent)
    val child = children.idx
    val sibling = children.(idx + 1)
    val t = node_t(child)

    val parent_keys = node_keys(parent)
    val parent_n = node_n(parent)

    val child_keys = node_keys(child)
    val child_children = node_children(child)
    val child_n = node_n(child)
    val child_is_leaf = node_is_leaf(child)

    val sibling_keys = node_keys(sibling)
    val sibling_children = node_children(sibling)
    val sibling_n = node_n(sibling)

    # Pull parent key down
    val parent_key = parent_keys.idx

    # Merge: child + parent_key + sibling
    var merged_keys = []
    for i in 0..child_n:
        val k = child_keys.i
        merged_keys = list_append(merged_keys, k)
    merged_keys = list_append(merged_keys, parent_key)
    for i in 0..sibling_n:
        val k = sibling_keys.i
        merged_keys = list_append(merged_keys, k)

    var merged_children = []
    val is_not_leaf = !child_is_leaf
    if is_not_leaf:
        for i in 0..(child_n + 1):
            val c = child_children.i
            merged_children = list_append(merged_children, c)
        for i in 0..(sibling_n + 1):
            val c = sibling_children.i
            merged_children = list_append(merged_children, c)

    var merged = child
    merged = node_set_keys(merged, merged_keys)
    merged = node_set_children(merged, merged_children)
    merged = node_set_n(merged, child_n + 1 + sibling_n)

    # Remove key from parent
    var new_parent_keys = []
    for i in 0..idx:
        val k = parent_keys.i
        new_parent_keys = list_append(new_parent_keys, k)
    for i in (idx + 1)..parent_n:
        val k = parent_keys.i
        new_parent_keys = list_append(new_parent_keys, k)

    # Remove sibling from parent's children
    var new_parent_children = []
    for i in 0..idx:
        val c = children.i
        new_parent_children = list_append(new_parent_children, c)
    new_parent_children = list_append(new_parent_children, merged)
    for i in (idx + 2)..(parent_n + 1):
        val c = children.i
        new_parent_children = list_append(new_parent_children, c)

    var new_parent = parent
    new_parent = node_set_keys(new_parent, new_parent_keys)
    new_parent = node_set_children(new_parent, new_parent_children)
    new_parent = node_set_n(new_parent, parent_n - 1)
    new_parent

# Fill child if it has minimum keys
fn fill_child(parent, idx):
    val children = node_children(parent)
    val parent_n = node_n(parent)

    # Check if previous sibling can donate
    val has_prev = idx > 0
    if has_prev:
        val prev_sibling = children.(idx - 1)
        val can_donate_prev = can_donate(prev_sibling)
        if can_donate_prev:
            val result = borrow_from_prev(parent, idx)
            result
        else:
            # Merge with previous sibling
            val result = merge_nodes(parent, idx - 1)
            result
    else:
        # No previous sibling, check next
        val has_next = idx < parent_n
        if has_next:
            val next_sibling = children.(idx + 1)
            val can_donate_next = can_donate(next_sibling)
            if can_donate_next:
                val result = borrow_from_next(parent, idx)
                result
            else:
                # Merge with next sibling
                val result = merge_nodes(parent, idx)
                result
        else:
            parent

# ============================================================================
# Deletion Main Functions
# ============================================================================

# Delete a key from a node
fn delete_from_node(node, key):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)
    val t = node_t(node)

    val idx = find_key_index(node, key)
    val found = find_key(node, key)
    val is_nil = found == nil

    val in_node = !is_nil
    if in_node:
        # Key is in this node
        if is_leaf:
            # Case 1: Key in leaf - simply remove
            val result = remove_from_leaf(node, found)
            result
        else:
            # Case 2: Key in internal node
            val left_child = children.found
            val right_child = children.(found + 1)

            val left_can_donate = can_donate(left_child)
            if left_can_donate:
                # Case 2a: Left child has >= t keys
                val pred = get_predecessor(left_child)

                # Replace key with predecessor
                var new_keys = []
                for i in 0..found:
                    val k = keys.i
                    new_keys = list_append(new_keys, k)
                new_keys = list_append(new_keys, pred)
                for i in (found + 1)..n:
                    val k = keys.i
                    new_keys = list_append(new_keys, k)

                var temp_node = node
                temp_node = node_set_keys(temp_node, new_keys)

                # Delete predecessor from left child
                val updated_left = delete_from_node(left_child, pred)

                var new_children = []
                for i in 0..found:
                    val c = children.i
                    new_children = list_append(new_children, c)
                new_children = list_append(new_children, updated_left)
                for i in (found + 1)..(n + 1):
                    val c = children.i
                    new_children = list_append(new_children, c)

                val result = node_set_children(temp_node, new_children)
                result
            else:
                val right_can_donate = can_donate(right_child)
                if right_can_donate:
                    # Case 2b: Right child has >= t keys
                    val succ = get_successor(right_child)

                    # Replace key with successor
                    var new_keys = []
                    for i in 0..found:
                        val k = keys.i
                        new_keys = list_append(new_keys, k)
                    new_keys = list_append(new_keys, succ)
                    for i in (found + 1)..n:
                        val k = keys.i
                        new_keys = list_append(new_keys, k)

                    var temp_node = node
                    temp_node = node_set_keys(temp_node, new_keys)

                    # Delete successor from right child
                    val updated_right = delete_from_node(right_child, succ)

                    var new_children = []
                    for i in 0..(found + 1):
                        val c = children.i
                        new_children = list_append(new_children, c)
                    new_children = list_append(new_children, updated_right)
                    for i in (found + 2)..(n + 1):
                        val c = children.i
                        new_children = list_append(new_children, c)

                    val result = node_set_children(temp_node, new_children)
                    result
                else:
                    # Case 2c: Both children have t-1 keys - merge
                    val merged_parent = merge_nodes(node, found)
                    val merged_children = node_children(merged_parent)
                    val merged_child = merged_children.found
                    val updated_merged = delete_from_node(merged_child, key)

                    var new_children = []
                    val merged_n = node_n(merged_parent)
                    for i in 0..found:
                        val c = merged_children.i
                        new_children = list_append(new_children, c)
                    new_children = list_append(new_children, updated_merged)
                    for i in (found + 1)..(merged_n + 1):
                        val c = merged_children.i
                        new_children = list_append(new_children, c)

                    val result = node_set_children(merged_parent, new_children)
                    result
    else:
        # Key not in this node
        if is_leaf:
            # Key doesn't exist
            node
        else:
            # Case 3: Key in subtree
            val child = children.idx
            val child_minimal = is_minimal(child)
            if child_minimal:
                # Fill child first
                val filled_parent = fill_child(node, idx)
                val filled_children = node_children(filled_parent)
                val filled_n = node_n(filled_parent)

                # Find correct child after filling
                val new_idx = find_key_index(filled_parent, key)
                val final_idx = new_idx
                val check = final_idx <= filled_n
                if check:
                    val target_child = filled_children.final_idx
                    val updated_child = delete_from_node(target_child, key)

                    var new_children = []
                    for i in 0..final_idx:
                        val c = filled_children.i
                        new_children = list_append(new_children, c)
                    new_children = list_append(new_children, updated_child)
                    for i in (final_idx + 1)..(filled_n + 1):
                        val c = filled_children.i
                        new_children = list_append(new_children, c)

                    val result = node_set_children(filled_parent, new_children)
                    result
                else:
                    filled_parent
            else:
                # Child has enough keys
                val updated_child = delete_from_node(child, key)

                var new_children = []
                for i in 0..idx:
                    val c = children.i
                    new_children = list_append(new_children, c)
                new_children = list_append(new_children, updated_child)
                for i in (idx + 1)..(n + 1):
                    val c = children.i
                    new_children = list_append(new_children, c)

                val result = node_set_children(node, new_children)
                result

# Delete a key from the B-tree
fn btree_delete(tree, key):
    val root = tree_root(tree)
    val updated_root = delete_from_node(root, key)

    # Check if root is now empty
    val root_n = node_n(updated_root)
    val root_empty = root_n == 0
    val root_is_leaf = node_is_leaf(updated_root)
    val is_not_leaf = !root_is_leaf

    val should_shrink = root_empty
    val can_shrink = is_not_leaf
    val do_shrink = should_shrink
    val final_shrink = can_shrink

    if do_shrink:
        if final_shrink:
            # Make first child the new root
            val children = node_children(updated_root)
            val new_root = children.0
            val height = tree_height(tree)
            var new_tree = tree
            new_tree = tree_set_root(new_tree, new_root)
            new_tree = tree_set_height(new_tree, height - 1)
            new_tree
        else:
            val result = tree_set_root(tree, updated_root)
            result
    else:
        val result = tree_set_root(tree, updated_root)
        result

# ============================================================================
# Traversal Functions
# ============================================================================

# Inorder traversal of a node (returns sorted list of keys)
fn inorder_node(node):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)

    var result = []

    if is_leaf:
        # Just return keys
        for i in 0..n:
            val k = keys.i
            result = list_append(result, k)
        result
    else:
        # Visit children and keys in order
        for i in 0..n:
            val child = children.i
            val child_keys = inorder_node(child)
            result = list_concat(result, child_keys)
            val k = keys.i
            result = list_append(result, k)

        # Visit last child
        val last_child = children.n
        val last_keys = inorder_node(last_child)
        result = list_concat(result, last_keys)
        result

# Inorder traversal of B-tree (returns sorted list)
fn inorder_traversal(tree):
    val root = tree_root(tree)
    inorder_node(root)

# Get all keys at a specific level
fn keys_at_level(node, level, current_level):
    if current_level == level:
        val keys = node_keys(node)
        keys
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            []
        else:
            val children = node_children(node)
            val n = node_n(node)
            var result = []
            for i in 0..(n + 1):
                val child = children.i
                val child_keys = keys_at_level(child, level, current_level + 1)
                result = list_concat(result, child_keys)
            result

# Level-order traversal (BFS)
fn level_order_traversal(tree):
    val height = tree_height(tree)
    val root = tree_root(tree)
    var result = []
    for level in 0..(height + 1):
        val level_keys = keys_at_level(root, level, 0)
        result = list_concat(result, level_keys)
    result

# ============================================================================
# Statistics Functions
# ============================================================================

# Get minimum key in tree
fn btree_min(tree):
    val root = tree_root(tree)
    var current = root
    var is_leaf = node_is_leaf(current)

    # Keep going to leftmost child
    var done = is_leaf
    if done:
        val keys = node_keys(current)
        val n = node_n(current)
        val has_keys = n > 0
        if has_keys:
            keys.0
        else:
            nil
    else:
        var result = nil
        var running = true
        while running:
            val leaf = node_is_leaf(current)
            if leaf:
                running = false
                val keys = node_keys(current)
                val n = node_n(current)
                val has_keys = n > 0
                if has_keys:
                    result = keys.0
            else:
                val children = node_children(current)
                current = children.0
        result

# Get maximum key in tree
fn btree_max(tree):
    val root = tree_root(tree)
    var current = root
    var is_leaf = node_is_leaf(current)

    # Keep going to rightmost child
    var done = is_leaf
    if done:
        val keys = node_keys(current)
        val n = node_n(current)
        val has_keys = n > 0
        if has_keys:
            val last = n - 1
            keys.last
        else:
            nil
    else:
        var result = nil
        var running = true
        while running:
            val leaf = node_is_leaf(current)
            if leaf:
                running = false
                val keys = node_keys(current)
                val n = node_n(current)
                val has_keys = n > 0
                if has_keys:
                    val last = n - 1
                    result = keys.last
            else:
                val children = node_children(current)
                val n = node_n(current)
                current = children.n
        result

# Calculate height of tree
fn btree_height(tree):
    val height = tree_height(tree)
    height

# Count total number of keys in tree
fn count_keys_in_node(node):
    val n = node_n(node)
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        n
    else:
        val children = node_children(node)
        var total = n
        for i in 0..(n + 1):
            val child = children.i
            val child_count = count_keys_in_node(child)
            total = total + child_count
        total

# Get total number of keys in tree
fn btree_size(tree):
    val root = tree_root(tree)
    count_keys_in_node(root)

# Count total number of nodes
fn count_nodes_in_subtree(node):
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        1
    else:
        val children = node_children(node)
        val n = node_n(node)
        var total = 1
        for i in 0..(n + 1):
            val child = children.i
            val child_count = count_nodes_in_subtree(child)
            total = total + child_count
        total

# Count total nodes in tree
fn count_nodes(tree):
    val root = tree_root(tree)
    count_nodes_in_subtree(root)

# ============================================================================
# Validation Functions
# ============================================================================

# Check if node has valid number of keys
fn is_valid_key_count(node, is_root):
    val n = node_n(node)
    val t = node_t(node)
    val min = t - 1
    val max = (2 * t) - 1

    if is_root:
        # Root can have 0 keys (if tree is empty) or 1 to 2t-1 keys
        val valid = n <= max
        valid
    else:
        # Non-root must have t-1 to 2t-1 keys
        val min_ok = n >= min
        val max_ok = n <= max
        val valid = min_ok
        val also_valid = max_ok
        val result = valid
        result
        # Should be: min_ok && max_ok but avoiding multi-line boolean
        if min_ok:
            max_ok
        else:
            false

# Check if keys are sorted
fn are_keys_sorted(node):
    val keys = node_keys(node)
    val n = node_n(node)
    var sorted = true
    for i in 0..(n - 1):
        val current = keys.i
        val next = keys.(i + 1)
        val less = current < next
        if !less:
            sorted = false
    sorted

# Validate B-tree properties recursively
fn validate_node(node, is_root, min_key, max_key):
    # Check key count
    val key_count_valid = is_valid_key_count(node, is_root)
    if !key_count_valid:
        false
    else:
        # Check keys are sorted
        val keys_sorted = are_keys_sorted(node)
        if !keys_sorted:
            false
        else:
            # Check key range
            val keys = node_keys(node)
            val n = node_n(node)
            var range_valid = true
            for i in 0..n:
                val k = keys.i
                val min_check = min_key == nil
                val max_check = max_key == nil
                if !min_check:
                    val above_min = k >= min_key
                    if !above_min:
                        range_valid = false
                if !max_check:
                    val below_max = k <= max_key
                    if !below_max:
                        range_valid = false

            if !range_valid:
                false
            else:
                # Check children if not leaf
                val is_leaf = node_is_leaf(node)
                if is_leaf:
                    true
                else:
                    val children = node_children(node)
                    val t = node_t(node)

                    # Check child count
                    val child_count = list_length(children)
                    val expected = n + 1
                    val count_ok = child_count == expected
                    if !count_ok:
                        false
                    else:
                        # Validate each child
                        var all_valid = true
                        for i in 0..(n + 1):
                            val child = children.i
                            var child_min = min_key
                            var child_max = max_key

                            if i > 0:
                                child_min = keys.(i - 1)
                            if i < n:
                                child_max = keys.i

                            val child_valid = validate_node(child, false, child_min, child_max)
                            if !child_valid:
                                all_valid = false
                        all_valid

# Validate entire B-tree structure
fn is_valid_btree(tree):
    val root = tree_root(tree)
    validate_node(root, true, nil, nil)

# ============================================================================
# Utility Functions
# ============================================================================

# Get fill factor (average node utilization)
fn get_fill_factor(tree):
    val root = tree_root(tree)
    val t = tree_t(tree)
    val max = (2 * t) - 1
    val total_keys = count_keys_in_node(root)
    val total_nodes = count_nodes_in_subtree(root)
    val max_possible = total_nodes * max
    val factor = (total_keys * 100) / max_possible
    factor

# Convert B-tree to sorted list
fn btree_to_list(tree):
    inorder_traversal(tree)

# Range query: find all keys in [min_key, max_key]
fn range_query_node(node, min_key, max_key):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)

    var result = []

    if is_leaf:
        for i in 0..n:
            val k = keys.i
            val above_min = k >= min_key
            val below_max = k <= max_key
            val in_range = above_min
            val also_in_range = below_max
            if in_range:
                if also_in_range:
                    result = list_append(result, k)
        result
    else:
        for i in 0..n:
            val k = keys.i
            val check_left = k >= min_key
            if check_left:
                val child = children.i
                val child_results = range_query_node(child, min_key, max_key)
                result = list_concat(result, child_results)

            val in_range = k >= min_key
            val also_in_range = k <= max_key
            if in_range:
                if also_in_range:
                    result = list_append(result, k)

        # Check last child
        val last_key = keys.(n - 1)
        val check_right = last_key <= max_key
        if check_right:
            val last_child = children.n
            val last_results = range_query_node(last_child, min_key, max_key)
            result = list_concat(result, last_results)
        result

# Range query on B-tree
fn range_query(tree, min_key, max_key):
    val root = tree_root(tree)
    range_query_node(root, min_key, max_key)

# ============================================================================
# List Helper Functions
# ============================================================================

# Append element to list
fn list_append(lst, elem):
    var result = []
    val len = list_length(lst)
    for i in 0..len:
        val item = lst.i
        result = result + [item]
    result = result + [elem]
    result

# Concatenate two lists
fn list_concat(lst1, lst2):
    var result = lst1
    val len = list_length(lst2)
    for i in 0..len:
        val item = lst2.i
        result = result + [item]
    result

# Get length of list
fn list_length(lst):
    var count = 0
    for item in lst:
        count = count + 1
    count

# ============================================================================
# Visualization Functions
# ============================================================================

# Print node with indentation
fn print_node_helper(node, level):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)

    # Print indentation
    var indent = ""
    for i in 0..level:
        indent = indent + "  "

    # Print keys
    print "{indent}Keys: {keys}"

    # Print children recursively
    val is_not_leaf = !is_leaf
    if is_not_leaf:
        for i in 0..(n + 1):
            val child = children.i
            print_node_helper(child, level + 1)

# Print ASCII visualization of B-tree
fn print_tree(tree):
    print "B-Tree Structure:"
    print "=================="
    val root = tree_root(tree)
    val t = tree_t(tree)
    val height = tree_height(tree)
    print "Minimum degree (t): {t}"
    print "Height: {height}"
    print "Total keys: {btree_size(tree)}"
    print "Total nodes: {count_nodes(tree)}"
    print ""
    print_node_helper(root, 0)

# ============================================================================
# Bulk Operations
# ============================================================================

# Bulk load sorted keys into B-tree (optimized)
# Assumes keys are already sorted
fn bulk_load(tree, sorted_keys):
    var current_tree = tree
    val len = list_length(sorted_keys)
    for i in 0..len:
        val key = sorted_keys.i
        current_tree = btree_insert(current_tree, key)
    current_tree

# Create B-tree from unsorted list
fn btree_from_list(lst, t):
    var tree = create_btree(t)
    val len = list_length(lst)
    for i in 0..len:
        val key = lst.i
        tree = btree_insert(tree, key)
    tree

# ============================================================================
# Advanced Statistics
# ============================================================================

# Get average keys per node
fn avg_keys_per_node(tree):
    val total_keys = btree_size(tree)
    val total_nodes = count_nodes(tree)
    val avg = total_keys / total_nodes
    avg

# Get number of leaf nodes
fn count_leaf_nodes(node):
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        1
    else:
        val children = node_children(node)
        val n = node_n(node)
        var count = 0
        for i in 0..(n + 1):
            val child = children.i
            val child_count = count_leaf_nodes(child)
            count = count + child_count
        count

# Get number of internal nodes
fn count_internal_nodes(tree):
    val total = count_nodes(tree)
    val root = tree_root(tree)
    val leaves = count_leaf_nodes(root)
    val internals = total - leaves
    internals

# Check if tree is empty
fn is_empty(tree):
    val size = btree_size(tree)
    val empty = size == 0
    empty

# Clear all keys from tree
fn clear_tree(tree):
    val t = tree_t(tree)
    create_btree(t)

# ============================================================================
# Key Existence and Membership
# ============================================================================

# Check if key exists (alias for btree_search)
fn contains(tree, key):
    btree_search(tree, key)

# Get all keys greater than threshold
fn keys_greater_than(tree, threshold):
    val all_keys = inorder_traversal(tree)
    var result = []
    val len = list_length(all_keys)
    for i in 0..len:
        val k = all_keys.i
        val greater = k > threshold
        if greater:
            result = list_append(result, k)
    result

# Get all keys less than threshold
fn keys_less_than(tree, threshold):
    val all_keys = inorder_traversal(tree)
    var result = []
    val len = list_length(all_keys)
    for i in 0..len:
        val k = all_keys.i
        val less = k < threshold
        if less:
            result = list_append(result, k)
    result

# Get nth smallest key (0-indexed)
fn nth_smallest(tree, n):
    val sorted = inorder_traversal(tree)
    val len = list_length(sorted)
    val valid = n < len
    if valid:
        sorted.n
    else:
        nil

# Get nth largest key (0-indexed)
fn nth_largest(tree, n):
    val sorted = inorder_traversal(tree)
    val len = list_length(sorted)
    val valid = n < len
    if valid:
        val idx = len - 1 - n
        sorted.idx
    else:
        nil

# ============================================================================
# Comparison and Set Operations
# ============================================================================

# Get union of two B-trees (all keys from both)
fn btree_union(tree1, tree2):
    val keys1 = inorder_traversal(tree1)
    val keys2 = inorder_traversal(tree2)
    val all_keys = list_concat(keys1, keys2)
    val t = tree_t(tree1)
    bulk_load(create_btree(t), all_keys)

# Get intersection of two B-trees (keys in both)
fn btree_intersection(tree1, tree2):
    val keys1 = inorder_traversal(tree1)
    var common = []
    val len = list_length(keys1)
    for i in 0..len:
        val k = keys1.i
        val in_tree2 = btree_search(tree2, k)
        if in_tree2:
            common = list_append(common, k)
    val t = tree_t(tree1)
    bulk_load(create_btree(t), common)

# Get difference of two B-trees (keys in tree1 but not tree2)
fn btree_difference(tree1, tree2):
    val keys1 = inorder_traversal(tree1)
    var diff = []
    val len = list_length(keys1)
    for i in 0..len:
        val k = keys1.i
        val in_tree2 = btree_search(tree2, k)
        if !in_tree2:
            diff = list_append(diff, k)
    val t = tree_t(tree1)
    bulk_load(create_btree(t), diff)

# Check if tree1 is subset of tree2
fn is_subset(tree1, tree2):
    val keys1 = inorder_traversal(tree1)
    var all_found = true
    val len = list_length(keys1)
    for i in 0..len:
        val k = keys1.i
        val found = btree_search(tree2, k)
        if !found:
            all_found = false
    all_found

# Check if two trees are equal (same keys)
fn btree_equals(tree1, tree2):
    val keys1 = inorder_traversal(tree1)
    val keys2 = inorder_traversal(tree2)
    val len1 = list_length(keys1)
    val len2 = list_length(keys2)
    val same_size = len1 == len2
    if !same_size:
        false
    else:
        var equal = true
        for i in 0..len1:
            val k1 = keys1.i
            val k2 = keys2.i
            val match = k1 == k2
            if !match:
                equal = false
        equal

# ============================================================================
# Advanced Queries
# ============================================================================

# Find closest key to target
fn find_closest(tree, target):
    val all_keys = inorder_traversal(tree)
    val len = list_length(all_keys)
    val has_keys = len > 0
    if !has_keys:
        nil
    else:
        var closest = all_keys.0
        var min_diff = abs(closest - target)
        for i in 1..len:
            val k = all_keys.i
            val diff = abs(k - target)
            val better = diff < min_diff
            if better:
                closest = k
                min_diff = diff
        closest

# Absolute value helper
fn abs(x):
    val negative = x < 0
    if negative:
        0 - x
    else:
        x

# Find k smallest keys
fn k_smallest(tree, k):
    val sorted = inorder_traversal(tree)
    var result = []
    val len = list_length(sorted)
    val limit = k
    val actual_limit = len
    val use_limit = limit < actual_limit
    var final_limit = 0
    if use_limit:
        final_limit = limit
    else:
        final_limit = actual_limit
    for i in 0..final_limit:
        val key = sorted.i
        result = list_append(result, key)
    result

# Find k largest keys
fn k_largest(tree, k):
    val sorted = inorder_traversal(tree)
    val len = list_length(sorted)
    var result = []
    val limit = k
    val actual_limit = len
    val use_limit = limit < actual_limit
    var start = 0
    if use_limit:
        start = len - limit
    else:
        start = 0
    for i in start..len:
        val key = sorted.i
        result = list_append(result, key)
    result

# Count keys in range
fn count_range(tree, min_key, max_key):
    val keys = range_query(tree, min_key, max_key)
    list_length(keys)

# Get median key
fn get_median(tree):
    val sorted = inorder_traversal(tree)
    val len = list_length(sorted)
    val has_keys = len > 0
    if !has_keys:
        nil
    else:
        val mid = len / 2
        sorted.mid

# ============================================================================
# Debug and Inspection
# ============================================================================

# Get node at specific path (list of indices)
fn get_node_at_path(tree, path):
    val root = tree_root(tree)
    var current = root
    val path_len = list_length(path)
    for i in 0..path_len:
        val idx = path.i
        val is_leaf = node_is_leaf(current)
        if is_leaf:
            current
        else:
            val children = node_children(current)
            val n = node_n(current)
            val valid = idx <= n
            if valid:
                current = children.idx
    current

# Get all keys at specific level
fn get_level_keys(tree, level):
    val root = tree_root(tree)
    keys_at_level(root, level, 0)

# Count keys at specific level
fn count_keys_at_level(tree, level):
    val keys = get_level_keys(tree, level)
    list_length(keys)

# Get tree depth (same as height)
fn get_depth(tree):
    btree_height(tree)

# Check tree balance (all leaves at same level)
fn is_balanced(tree):
    # B-trees are always balanced by definition
    true
