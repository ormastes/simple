# Effect System for Simple Language
#
# Provides types and utilities for effect annotations on functions.
# Effect annotations help track side effects and enable better
# optimization and reasoning about code.
#
# Supported effects:
# - @pure: No side effects, referentially transparent
# - @io: Console/terminal I/O operations
# - @net: Network operations
# - @fs: File system operations
# - @unsafe: Unsafe memory operations
# - @async: Asynchronous operations

# Effect enum representing different effect types
enum Effect:
    Pure
    Io
    Net
    Fs
    Unsafe
    Async

# Convert decorator name string to Effect value
# Returns Some(Effect) if valid, nil otherwise
fn effect_from_decorator_name(name: text) -> Effect?:
    if name == "pure":
        Some(Effect.Pure)
    else:
        var result = nil
        if name == "io":
            result = Some(Effect.Io)
        if name == "net":
            result = Some(Effect.Net)
        if name == "fs":
            result = Some(Effect.Fs)
        if name == "unsafe":
            result = Some(Effect.Unsafe)
        if name == "async":
            result = Some(Effect.Async)
        result

# Get decorator name for an Effect value
fn effect_decorator_name(effect: Effect) -> text:
    var name = ""
    if effect == Effect.Pure:
        name = "pure"
    if effect == Effect.Io:
        name = "io"
    if effect == Effect.Net:
        name = "net"
    if effect == Effect.Fs:
        name = "fs"
    if effect == Effect.Unsafe:
        name = "unsafe"
    if effect == Effect.Async:
        name = "async"
    name

# Extension methods for Effect enum
impl Effect:
    # Get decorator name for this effect
    fn decorator_name() -> text:
        effect_decorator_name(self)

    # Convert decorator name to Effect
    static fn from_decorator_name(name: text) -> Effect?:
        effect_from_decorator_name(name)

# Export public API
export Effect
export effect_from_decorator_name
export effect_decorator_name
