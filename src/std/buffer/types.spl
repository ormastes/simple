# Buffer class for managing byte arrays with read/write positions

class Buffer:
    data: List         # Byte array (list of integers 0-255)
    read_pos: i64      # Current read position
    write_pos: i64     # Current write position
    cap: i64          # Capacity

    fn size() -> i64:
        self.write_pos

    fn capacity() -> i64:
        self.cap

    fn available() -> i64:
        self.write_pos - self.read_pos

    fn available_capacity() -> i64:
        self.cap - self.write_pos

    fn is_full() -> bool:
        self.write_pos >= self.cap

    fn is_empty() -> bool:
        self.read_pos >= self.write_pos

    fn get_read_pos() -> i64:
        self.read_pos

    fn get_write_pos() -> i64:
        self.write_pos

    me set_read_pos(pos: i64):
        if pos >= 0 and pos <= self.write_pos:
            self.read_pos = pos

    me set_write_pos(pos: i64):
        if pos >= 0 and pos <= self.cap:
            self.write_pos = pos

    fn to_array() -> List:
        val result = []
        var i = 0
        while i < self.write_pos:
            result.append(self.data.get(i))
            i = i + 1
        result

    fn to_string() -> text:
        val bytes = self.to_array()
        bytes_to_string(bytes)

    fn compare(other: Buffer) -> i64:
        val len1 = self.write_pos
        val len2 = other.write_pos
        val min_len = if len1 < len2: len1 else: len2
        var i = 0
        while i < min_len:
            val b1 = self.data.get(i)
            val b2 = other.data.get(i)
            if b1 < b2:
                return -1
            if b1 > b2:
                return 1
            i = i + 1
        if len1 < len2:
            return -1
        if len1 > len2:
            return 1
        0

    fn equals(other: Buffer) -> bool:
        self.compare(other) == 0

    fn clone() -> Buffer:
        val new_buf = Buffer.create(self.cap)
        var i = 0
        while i < self.cap:
            new_buf.data.set(i, self.data.get(i))
            i = i + 1
        new_buf.read_pos = self.read_pos
        new_buf.write_pos = self.write_pos
        new_buf

    fn slice(start: i64, end: i64) -> List:
        val result = []
        var i = start
        while i < end and i < self.write_pos:
            result.append(self.data.get(i))
            i = i + 1
        result

    fn remaining() -> Buffer:
        val bytes = self.read_all()
        Buffer.from_array(bytes)

    # Forward declarations for static methods
    static fn create(capacity: i64) -> Buffer
    static fn from_array(arr: List) -> Buffer
    static fn from_string(s: text) -> Buffer
    static fn allocate(capacity: i64, fill_byte: i64) -> Buffer

    # Forward declarations for methods in other modules
    fn read_byte() -> i64
    fn read_bytes(count: i64) -> List
    fn read_all() -> List
    fn peek_byte() -> i64
    fn peek_bytes(count: i64) -> List
    me write_byte(byte_val: i64)
    me write_bytes(bytes: List)
    fn read_i64_be() -> i64
    fn read_i64_le() -> i64
    fn read_i32_be() -> i64
    fn read_i32_le() -> i64
    fn read_i16_be() -> i64
    fn read_i16_le() -> i64
    me write_i64_be(value: i64)
    me write_i64_le(value: i64)
    me write_i32_be(value: i64)
    me write_i32_le(value: i64)
    me write_i16_be(value: i64)
    me write_i16_le(value: i64)
    me write_string(s: text)
    fn read_string() -> text
    me write_raw_string(s: text)
    fn read_raw_string(length: i64) -> text
    me write_line(s: text)
    fn read_line() -> text
    me clear()
    me reset()
    me reset_read()
    me reset_write()
    me compact()
    fn expand(new_capacity: i64) -> Buffer
    me copy_from(other: Buffer, count: i64)
    me copy_to(other: Buffer, count: i64)
    me fill(byte_val: i64)
    me fill_range(start: i64, end: i64, byte_val: i64)
    me skip(count: i64)
    me rewind(count: i64)

# Forward declarations for utility functions
fn bytes_to_string(bytes: List) -> text
