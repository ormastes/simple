# Buffer Position and Manipulation Operations

# Clear the buffer (reset positions and fill with zeros)
fn buffer_clear(buf: Buffer):
    buf.read_pos = 0
    buf.write_pos = 0
    var i = 0
    while i < buf.cap:
        buf.data.set(i, 0)
        i = i + 1

# Reset positions to start
fn buffer_reset(buf: Buffer):
    buf.read_pos = 0
    buf.write_pos = 0

# Reset read position to start
fn buffer_reset_read(buf: Buffer):
    buf.read_pos = 0

# Reset write position to start
fn buffer_reset_write(buf: Buffer):
    buf.write_pos = 0

# Compact buffer (move unread data to start)
fn buffer_compact(buf: Buffer):
    val unread = buf.available()
    if unread == 0:
        buffer_reset(buf)
        return nil
    if buf.read_pos == 0:
        return nil
    var i = 0
    while i < unread:
        val byte_val = buf.data.get(buf.read_pos + i)
        buf.data.set(i, byte_val)
        i = i + 1
    buf.read_pos = 0
    buf.write_pos = unread

# Expand buffer capacity (create new larger buffer)
fn buffer_expand(buf: Buffer, new_capacity: i64) -> Buffer:
    if new_capacity <= buf.cap:
        return buf
    val new_buf = buffer_create(new_capacity)
    var i = 0
    while i < buf.write_pos:
        new_buf.data.set(i, buf.data.get(i))
        i = i + 1
    new_buf.read_pos = buf.read_pos
    new_buf.write_pos = buf.write_pos
    new_buf

# Copy data from another buffer
fn buffer_copy_from(buf: Buffer, other: Buffer, count: i64):
    var remaining = count
    while remaining > 0 and not other.is_empty() and not buf.is_full():
        val byte_val = buffer_read_byte(other)
        buffer_write_byte(buf, byte_val)
        remaining = remaining - 1

# Copy to another buffer
fn buffer_copy_to(buf: Buffer, other: Buffer, count: i64):
    var remaining = count
    while remaining > 0 and not buf.is_empty() and not other.is_full():
        val byte_val = buffer_read_byte(buf)
        buffer_write_byte(other, byte_val)
        remaining = remaining - 1

# Fill buffer with a specific byte value
fn buffer_fill(buf: Buffer, byte_val: i64):
    val clamped = byte_val & 0xFF
    var i = 0
    while i < buf.cap:
        buf.data.set(i, clamped)
        i = i + 1
    buf.write_pos = buf.cap

# Fill a range with a specific byte value
fn buffer_fill_range(buf: Buffer, start: i64, end: i64, byte_val: i64):
    val clamped = byte_val & 0xFF
    var i = start
    while i < end and i < buf.cap:
        buf.data.set(i, clamped)
        i = i + 1

# Skip bytes in read position
fn buffer_skip(buf: Buffer, count: i64):
    var new_pos = buf.read_pos
    new_pos = new_pos + count
    if new_pos > buf.write_pos:
        new_pos = buf.write_pos
    buf.read_pos = new_pos

# Rewind read position
fn buffer_rewind(buf: Buffer, count: i64):
    var new_pos = buf.read_pos
    new_pos = new_pos - count
    if new_pos < 0:
        new_pos = 0
    buf.read_pos = new_pos

# Forward declarations
fn buffer_create(capacity: i64) -> Buffer
fn buffer_read_byte(buf: Buffer) -> i64
fn buffer_write_byte(buf: Buffer, byte_val: i64)
