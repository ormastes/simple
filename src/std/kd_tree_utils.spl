# K-d Tree Data Structure Module
# Comprehensive multidimensional search and spatial indexing utilities
# Binary space partitioning trees for efficient k-dimensional point operations

# ============================================================================
# Core Types and Constants
# ============================================================================

# Point: List of i64 coordinates (variable dimension)
# KdNode: (dim: i64, value: i64, left: KdNode?, right: KdNode?, point: List<i64>)
# BoundingBox: (min: List<i64>, max: List<i64>)
# Distance metric types: 0=Euclidean, 1=Manhattan, 2=Chebyshev

# ============================================================================
# Point Operations
# ============================================================================

fn point_create(coords: List<i64>) -> List<i64>:
    # Create a point from coordinate list
    coords

fn point_dimension(point: List<i64>) -> i64:
    # Get dimension of point
    point.length()

fn point_get(point: List<i64>, dim: i64) -> i64:
    # Get coordinate at dimension
    point.get(dim)

fn point_set(point: List<i64>, dim: i64, value: i64) -> List<i64>:
    # Set coordinate at dimension (returns new point)
    var result = []
    var i = 0
    while i < point.length():
        if i == dim:
            result.push(value)
        else:
            val coord = point.get(i)
            result.push(coord)
        i = i + 1
    result

fn point_equal(p1: List<i64>, p2: List<i64>) -> i64:
    # Check if two points are equal
    val len1 = p1.length()
    val len2 = p2.length()
    if len1 != len2:
        return 0
    var i = 0
    while i < len1:
        val coord1 = p1.get(i)
        val coord2 = p2.get(i)
        if coord1 != coord2:
            return 0
        i = i + 1
    1

fn point_copy(point: List<i64>) -> List<i64>:
    # Create a copy of a point
    var result = []
    var i = 0
    while i < point.length():
        val coord = point.get(i)
        result.push(coord)
        i = i + 1
    result

fn point_distance_squared_euclidean(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate squared Euclidean distance between two points
    var sum = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        sum = sum + (diff * diff)
        i = i + 1
    sum

fn point_distance_manhattan(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate Manhattan distance between two points
    var sum = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        val abs_diff = if diff < 0: -diff else: diff
        sum = sum + abs_diff
        i = i + 1
    sum

fn point_distance_chebyshev(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate Chebyshev distance between two points
    var max_dist = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        val abs_diff = if diff < 0: -diff else: diff
        if abs_diff > max_dist:
            max_dist = abs_diff
        i = i + 1
    max_dist

fn point_distance(p1: List<i64>, p2: List<i64>, metric: i64) -> i64:
    # Calculate distance using specified metric
    # metric: 0=Euclidean (squared), 1=Manhattan, 2=Chebyshev
    if metric == 1:
        point_distance_manhattan(p1, p2)
    else:
        if metric == 2:
            point_distance_chebyshev(p1, p2)
        else:
            point_distance_squared_euclidean(p1, p2)

# ============================================================================
# KdNode Operations
# ============================================================================

fn kdnode_create(dim: i64, value: i64, point: List<i64>) -> List:
    # Create a new KdNode: [dim, value, left, right, point]
    [dim, value, nil, nil, point]

fn kdnode_get_dim(node: List) -> i64:
    # Get splitting dimension
    node.get(0)

fn kdnode_get_value(node: List) -> i64:
    # Get pivot value
    node.get(1)

fn kdnode_get_left(node: List):
    # Get left child
    node.get(2)

fn kdnode_get_right(node: List):
    # Get right child
    node.get(3)

fn kdnode_get_point(node: List) -> List<i64>:
    # Get point stored at node
    node.get(4)

fn kdnode_set_left(node: List, left):
    # Set left child
    node.set(2, left)

fn kdnode_set_right(node: List, right):
    # Set right child
    node.set(3, right)

fn kdnode_is_leaf(node: List) -> i64:
    # Check if node is a leaf
    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_nil = if left == nil: 1 else: 0
    val right_nil = if right == nil: 1 else: 0
    if left_nil == 1:
        if right_nil == 1:
            return 1
    0

# ============================================================================
# Point List Operations
# ============================================================================

fn points_get_dimension(points: List<List<i64>>) -> i64:
    # Get dimension from first point
    if points.length() == 0:
        return 0
    val first = points.get(0)
    first.length()

fn points_partition(points: List<List<i64>>, dim: i64, pivot: i64) -> List:
    # Partition points by dimension and pivot value
    # Returns [left_points, right_points]
    var left = []
    var right = []
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val coord = point.get(dim)
        if coord < pivot:
            left.push(point)
        else:
            right.push(point)
        i = i + 1
    [left, right]

fn points_find_median(points: List<List<i64>>, dim: i64) -> i64:
    # Find median value along dimension (approximation)
    if points.length() == 0:
        return 0

    var coords = []
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val coord = point.get(dim)
        coords.push(coord)
        i = i + 1

    val sorted = list_sort(coords)
    val mid = sorted.length() / 2
    sorted.get(mid)

fn points_find_median_point(points: List<List<i64>>, dim: i64) -> List<i64>:
    # Find point with median value along dimension
    if points.length() == 0:
        return []

    val median_val = points_find_median(points, dim)
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val coord = point.get(dim)
        if coord == median_val:
            return point
        i = i + 1

    points.get(0)

fn points_filter_not_equal(points: List<List<i64>>, target: List<i64>) -> List<List<i64>>:
    # Filter out point equal to target
    var result = []
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val is_equal = point_equal(point, target)
        if is_equal == 0:
            result.push(point)
        i = i + 1
    result

# ============================================================================
# List Utilities
# ============================================================================

fn list_sort(lst: List<i64>) -> List<i64>:
    # Simple insertion sort for small lists
    if lst.length() <= 1:
        return lst

    var sorted = []
    var i = 0
    while i < lst.length():
        val val = lst.get(i)
        sorted.push(val)
        i = i + 1

    var j = 1
    while j < sorted.length():
        val key = sorted.get(j)
        var k = j - 1
        while k >= 0:
            val curr = sorted.get(k)
            if curr <= key:
                break
            sorted.set(k + 1, curr)
            k = k - 1
        sorted.set(k + 1, key)
        j = j + 1

    sorted

fn list_min(lst: List<i64>) -> i64:
    # Find minimum value in list
    if lst.length() == 0:
        return 0
    var min_val = lst.get(0)
    var i = 1
    while i < lst.length():
        val val = lst.get(i)
        if val < min_val:
            min_val = val
        i = i + 1
    min_val

fn list_max(lst: List<i64>) -> i64:
    # Find maximum value in list
    if lst.length() == 0:
        return 0
    var max_val = lst.get(0)
    var i = 1
    while i < lst.length():
        val val = lst.get(i)
        if val > max_val:
            max_val = val
        i = i + 1
    max_val

# ============================================================================
# K-d Tree Construction
# ============================================================================

fn kdtree_build_recursive(points: List<List<i64>>, depth: i64, k: i64):
    # Recursively build K-d tree
    if points.length() == 0:
        return nil

    if points.length() == 1:
        val point = points.get(0)
        val dim = depth % k
        val value = point.get(dim)
        return kdnode_create(dim, value, point)

    val dim = depth % k
    val median_point = points_find_median_point(points, dim)
    val median_val = median_point.get(dim)

    val remaining = points_filter_not_equal(points, median_point)
    val partitions = points_partition(remaining, dim, median_val)
    val left_points = partitions.get(0)
    val right_points = partitions.get(1)

    val node = kdnode_create(dim, median_val, median_point)
    val left = kdtree_build_recursive(left_points, depth + 1, k)
    val right = kdtree_build_recursive(right_points, depth + 1, k)

    kdnode_set_left(node, left)
    kdnode_set_right(node, right)
    node

fn kdtree_build(points: List<List<i64>>):
    # Build K-d tree from list of points
    if points.length() == 0:
        return nil
    val k = points_get_dimension(points)
    kdtree_build_recursive(points, 0, k)

fn kdtree_height(node) -> i64:
    # Calculate height of K-d tree
    if node == nil:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_height = kdtree_height(left)
    val right_height = kdtree_height(right)

    val max_height = if left_height > right_height: left_height else: right_height
    max_height + 1

fn kdtree_size(node) -> i64:
    # Count number of nodes in tree
    if node == nil:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_size = kdtree_size(left)
    val right_size = kdtree_size(right)

    left_size + right_size + 1

fn kdtree_to_list(node) -> List<List<i64>>:
    # Convert tree to list of points (in-order traversal)
    if node == nil:
        return []

    var result = []
    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    val left_list = kdtree_to_list(left)
    var i = 0
    while i < left_list.length():
        val point = left_list.get(i)
        result.push(point)
        i = i + 1

    val point = kdnode_get_point(node)
    result.push(point)

    val right_list = kdtree_to_list(right)
    var j = 0
    while j < right_list.length():
        val point = right_list.get(j)
        result.push(point)
        j = j + 1

    result

# ============================================================================
# K-d Tree Insertion
# ============================================================================

fn kdtree_insert_recursive(node, point: List<i64>, depth: i64, k: i64):
    # Recursively insert point into K-d tree
    if node == nil:
        val dim = depth % k
        val value = point.get(dim)
        return kdnode_create(dim, value, point)

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = point.get(dim)

    if coord < pivot:
        val left = kdnode_get_left(node)
        val new_left = kdtree_insert_recursive(left, point, depth + 1, k)
        kdnode_set_left(node, new_left)
    else:
        val right = kdnode_get_right(node)
        val new_right = kdtree_insert_recursive(right, point, depth + 1, k)
        kdnode_set_right(node, new_right)

    node

fn kdtree_insert(node, point: List<i64>):
    # Insert point into K-d tree
    val k = point_dimension(point)
    kdtree_insert_recursive(node, point, 0, k)

# ============================================================================
# K-d Tree Search
# ============================================================================

fn kdtree_contains_recursive(node, point: List<i64>) -> i64:
    # Recursively search for point in tree
    if node == nil:
        return 0

    val node_point = kdnode_get_point(node)
    val is_equal = point_equal(node_point, point)
    if is_equal == 1:
        return 1

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = point.get(dim)

    if coord < pivot:
        val left = kdnode_get_left(node)
        return kdtree_contains_recursive(left, point)
    else:
        val right = kdnode_get_right(node)
        return kdtree_contains_recursive(right, point)

fn kdtree_contains(node, point: List<i64>) -> i64:
    # Check if tree contains point
    kdtree_contains_recursive(node, point)

# ============================================================================
# Nearest Neighbor Search
# ============================================================================

fn kdtree_nearest_neighbor_recursive(node, target: List<i64>, best_point: List<i64>, best_dist: i64, metric: i64) -> List:
    # Recursively find nearest neighbor
    # Returns [best_point, best_dist]
    if node == nil:
        return [best_point, best_dist]

    val node_point = kdnode_get_point(node)
    val dist = point_distance(node_point, target, metric)

    var current_best_point = best_point
    var current_best_dist = best_dist

    if best_point.length() == 0:
        current_best_point = node_point
        current_best_dist = dist
    else:
        if dist < current_best_dist:
            current_best_point = node_point
            current_best_dist = dist

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = target.get(dim)

    var first_child = nil
    var second_child = nil

    if coord < pivot:
        first_child = kdnode_get_left(node)
        second_child = kdnode_get_right(node)
    else:
        first_child = kdnode_get_right(node)
        second_child = kdnode_get_left(node)

    val result1 = kdtree_nearest_neighbor_recursive(first_child, target, current_best_point, current_best_dist, metric)
    current_best_point = result1.get(0)
    current_best_dist = result1.get(1)

    val diff = coord - pivot
    val abs_diff = if diff < 0: -diff else: diff
    val axis_dist = abs_diff * abs_diff

    if axis_dist < current_best_dist:
        val result2 = kdtree_nearest_neighbor_recursive(second_child, target, current_best_point, current_best_dist, metric)
        current_best_point = result2.get(0)
        current_best_dist = result2.get(1)

    [current_best_point, current_best_dist]

fn kdtree_nearest_neighbor(node, target: List<i64>, metric: i64) -> List<i64>:
    # Find nearest neighbor to target point
    # metric: 0=Euclidean (squared), 1=Manhattan, 2=Chebyshev
    if node == nil:
        return []

    val result = kdtree_nearest_neighbor_recursive(node, target, [], 999999999, metric)
    result.get(0)

fn kdtree_nearest_neighbor_euclidean(node, target: List<i64>) -> List<i64>:
    # Find nearest neighbor using Euclidean distance
    kdtree_nearest_neighbor(node, target, 0)

fn kdtree_nearest_neighbor_manhattan(node, target: List<i64>) -> List<i64>:
    # Find nearest neighbor using Manhattan distance
    kdtree_nearest_neighbor(node, target, 1)

fn kdtree_nearest_neighbor_chebyshev(node, target: List<i64>) -> List<i64>:
    # Find nearest neighbor using Chebyshev distance
    kdtree_nearest_neighbor(node, target, 2)

# ============================================================================
# K-Nearest Neighbors Search
# ============================================================================

fn heap_insert(heap: List, point: List<i64>, dist: i64, k: i64):
    # Insert into max-heap (keep k nearest)
    var item = [point, dist]
    heap.push(item)

    if heap.length() <= k:
        return

    var max_idx = 0
    var max_dist = 0
    var i = 0
    while i < heap.length():
        val item = heap.get(i)
        val d = item.get(1)
        if d > max_dist:
            max_dist = d
            max_idx = i
        i = i + 1

    heap.remove(max_idx)

fn heap_max_dist(heap: List) -> i64:
    # Get maximum distance in heap
    if heap.length() == 0:
        return 999999999

    var max_dist = 0
    var i = 0
    while i < heap.length():
        val item = heap.get(i)
        val d = item.get(1)
        if d > max_dist:
            max_dist = d
        i = i + 1
    max_dist

fn kdtree_k_nearest_recursive(node, target: List<i64>, heap: List, k: i64, metric: i64):
    # Recursively find k nearest neighbors
    if node == nil:
        return

    val node_point = kdnode_get_point(node)
    val dist = point_distance(node_point, target, metric)

    heap_insert(heap, node_point, dist, k)

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = target.get(dim)

    var first_child = nil
    var second_child = nil

    if coord < pivot:
        first_child = kdnode_get_left(node)
        second_child = kdnode_get_right(node)
    else:
        first_child = kdnode_get_right(node)
        second_child = kdnode_get_left(node)

    kdtree_k_nearest_recursive(first_child, target, heap, k, metric)

    val diff = coord - pivot
    val abs_diff = if diff < 0: -diff else: diff
    val axis_dist = abs_diff * abs_diff
    val max_dist = heap_max_dist(heap)

    val heap_full = if heap.length() < k: 0 else: 1
    if heap_full == 0:
        kdtree_k_nearest_recursive(second_child, target, heap, k, metric)
    else:
        if axis_dist < max_dist:
            kdtree_k_nearest_recursive(second_child, target, heap, k, metric)

fn kdtree_k_nearest_neighbors(node, target: List<i64>, k: i64, metric: i64) -> List<List<i64>>:
    # Find k nearest neighbors to target point
    # metric: 0=Euclidean (squared), 1=Manhattan, 2=Chebyshev
    if node == nil:
        return []

    var heap = []
    kdtree_k_nearest_recursive(node, target, heap, k, metric)

    var result = []
    var i = 0
    while i < heap.length():
        val item = heap.get(i)
        val point = item.get(0)
        result.push(point)
        i = i + 1

    result

# ============================================================================
# Range Search
# ============================================================================

fn point_in_range(point: List<i64>, min_bounds: List<i64>, max_bounds: List<i64>) -> i64:
    # Check if point is within range
    var i = 0
    while i < point.length():
        val coord = point.get(i)
        val min_val = min_bounds.get(i)
        val max_val = max_bounds.get(i)
        if coord < min_val:
            return 0
        if coord > max_val:
            return 0
        i = i + 1
    1

fn kdtree_range_search_recursive(node, min_bounds: List<i64>, max_bounds: List<i64>, result: List):
    # Recursively search for points in range
    if node == nil:
        return

    val point = kdnode_get_point(node)
    val in_range = point_in_range(point, min_bounds, max_bounds)
    if in_range == 1:
        result.push(point)

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val min_val = min_bounds.get(dim)
    val max_val = max_bounds.get(dim)

    if min_val <= pivot:
        val left = kdnode_get_left(node)
        kdtree_range_search_recursive(left, min_bounds, max_bounds, result)

    if max_val >= pivot:
        val right = kdnode_get_right(node)
        kdtree_range_search_recursive(right, min_bounds, max_bounds, result)

fn kdtree_range_search(node, min_bounds: List<i64>, max_bounds: List<i64>) -> List<List<i64>>:
    # Find all points within range
    var result = []
    kdtree_range_search_recursive(node, min_bounds, max_bounds, result)
    result

fn kdtree_range_search_radius(node, center: List<i64>, radius: i64, metric: i64) -> List<List<i64>>:
    # Find all points within radius of center
    # Uses range search followed by distance filtering
    var min_bounds = []
    var max_bounds = []
    var i = 0
    while i < center.length():
        val coord = center.get(i)
        min_bounds.push(coord - radius)
        max_bounds.push(coord + radius)
        i = i + 1

    val candidates = kdtree_range_search(node, min_bounds, max_bounds)
    var result = []
    var j = 0
    while j < candidates.length():
        val point = candidates.get(j)
        val dist = point_distance(point, center, metric)
        val rad_squared = radius * radius
        if dist <= rad_squared:
            result.push(point)
        j = j + 1

    result

# ============================================================================
# Bounding Box Operations
# ============================================================================

fn bbox_create(points: List<List<i64>>) -> List:
    # Create bounding box from points
    # Returns [min_bounds, max_bounds]
    if points.length() == 0:
        return [[], []]

    val first = points.get(0)
    val k = first.length()

    var min_bounds = []
    var max_bounds = []
    var d = 0
    while d < k:
        min_bounds.push(999999999)
        max_bounds.push(-999999999)
        d = d + 1

    var i = 0
    while i < points.length():
        val point = points.get(i)
        var j = 0
        while j < k:
            val coord = point.get(j)
            val min_val = min_bounds.get(j)
            val max_val = max_bounds.get(j)
            if coord < min_val:
                min_bounds.set(j, coord)
            if coord > max_val:
                max_bounds.set(j, coord)
            j = j + 1
        i = i + 1

    [min_bounds, max_bounds]

fn bbox_get_min(bbox: List) -> List<i64>:
    # Get minimum bounds
    bbox.get(0)

fn bbox_get_max(bbox: List) -> List<i64>:
    # Get maximum bounds
    bbox.get(1)

fn bbox_contains_point(bbox: List, point: List<i64>) -> i64:
    # Check if bounding box contains point
    val min_bounds = bbox_get_min(bbox)
    val max_bounds = bbox_get_max(bbox)
    point_in_range(point, min_bounds, max_bounds)

fn bbox_intersects(bbox1: List, bbox2: List) -> i64:
    # Check if two bounding boxes intersect
    val min1 = bbox_get_min(bbox1)
    val max1 = bbox_get_max(bbox1)
    val min2 = bbox_get_min(bbox2)
    val max2 = bbox_get_max(bbox2)

    var i = 0
    while i < min1.length():
        val min1_val = min1.get(i)
        val max1_val = max1.get(i)
        val min2_val = min2.get(i)
        val max2_val = max2.get(i)
        if max1_val < min2_val:
            return 0
        if min1_val > max2_val:
            return 0
        i = i + 1
    1

fn bbox_volume(bbox: List) -> i64:
    # Calculate volume of bounding box
    val min_bounds = bbox_get_min(bbox)
    val max_bounds = bbox_get_max(bbox)

    var volume = 1
    var i = 0
    while i < min_bounds.length():
        val min_val = min_bounds.get(i)
        val max_val = max_bounds.get(i)
        val extent = max_val - min_val
        volume = volume * extent
        i = i + 1
    volume

fn bbox_center(bbox: List) -> List<i64>:
    # Calculate center of bounding box
    val min_bounds = bbox_get_min(bbox)
    val max_bounds = bbox_get_max(bbox)

    var center = []
    var i = 0
    while i < min_bounds.length():
        val min_val = min_bounds.get(i)
        val max_val = max_bounds.get(i)
        val mid = (min_val + max_val) / 2
        center.push(mid)
        i = i + 1
    center

# ============================================================================
# Tree Rebalancing
# ============================================================================

fn kdtree_rebalance(node):
    # Rebalance K-d tree
    if node == nil:
        return nil

    val points = kdtree_to_list(node)
    kdtree_build(points)

fn kdtree_needs_rebalance(node, threshold: i64) -> i64:
    # Check if tree needs rebalancing based on height threshold
    val height = kdtree_height(node)
    val size = kdtree_size(node)

    if size == 0:
        return 0

    var ideal_height = 1
    var temp = size
    while temp > 1:
        temp = temp / 2
        ideal_height = ideal_height + 1

    val diff = height - ideal_height
    if diff > threshold:
        return 1
    0

# ============================================================================
# Tree Statistics
# ============================================================================

fn kdtree_depth(node, point: List<i64>) -> i64:
    # Find depth of point in tree
    if node == nil:
        return -1

    val node_point = kdnode_get_point(node)
    val is_equal = point_equal(node_point, point)
    if is_equal == 1:
        return 0

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = point.get(dim)

    var child = nil
    if coord < pivot:
        child = kdnode_get_left(node)
    else:
        child = kdnode_get_right(node)

    val child_depth = kdtree_depth(child, point)
    if child_depth == -1:
        return -1
    child_depth + 1

fn kdtree_leaf_count(node) -> i64:
    # Count number of leaf nodes
    if node == nil:
        return 0

    val is_leaf = kdnode_is_leaf(node)
    if is_leaf == 1:
        return 1

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_count = kdtree_leaf_count(left)
    val right_count = kdtree_leaf_count(right)

    left_count + right_count

fn kdtree_balance_factor(node) -> i64:
    # Calculate balance factor (height difference between subtrees)
    if node == nil:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_height = kdtree_height(left)
    val right_height = kdtree_height(right)

    val diff = left_height - right_height
    if diff < 0: -diff else: diff

# ============================================================================
# Removal Operations
# ============================================================================

fn kdtree_find_min_in_dim(node, target_dim: i64, current_dim: i64, k: i64) -> List<i64>:
    # Find point with minimum value in target dimension
    if node == nil:
        return []

    val point = kdnode_get_point(node)

    if current_dim == target_dim:
        val left = kdnode_get_left(node)
        if left == nil:
            return point
        return kdtree_find_min_in_dim(left, target_dim, (current_dim + 1) % k, k)

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    var min_point = point
    var min_val = point.get(target_dim)

    if left != nil:
        val left_min = kdtree_find_min_in_dim(left, target_dim, (current_dim + 1) % k, k)
        if left_min.length() > 0:
            val left_val = left_min.get(target_dim)
            if left_val < min_val:
                min_point = left_min
                min_val = left_val

    if right != nil:
        val right_min = kdtree_find_min_in_dim(right, target_dim, (current_dim + 1) % k, k)
        if right_min.length() > 0:
            val right_val = right_min.get(target_dim)
            if right_val < min_val:
                min_point = right_min
                min_val = right_val

    min_point

fn kdtree_remove_recursive(node, point: List<i64>, depth: i64, k: i64):
    # Recursively remove point from tree
    if node == nil:
        return nil

    val node_point = kdnode_get_point(node)
    val is_equal = point_equal(node_point, point)

    if is_equal == 1:
        val right = kdnode_get_right(node)
        if right != nil:
            val dim = kdnode_get_dim(node)
            val replacement = kdtree_find_min_in_dim(right, dim, (depth + 1) % k, k)
            val new_val = replacement.get(dim)
            val new_node = kdnode_create(dim, new_val, replacement)
            val new_right = kdtree_remove_recursive(right, replacement, depth + 1, k)
            kdnode_set_right(new_node, new_right)
            val left = kdnode_get_left(node)
            kdnode_set_left(new_node, left)
            return new_node

        val left = kdnode_get_left(node)
        if left != nil:
            val dim = kdnode_get_dim(node)
            val replacement = kdtree_find_min_in_dim(left, dim, (depth + 1) % k, k)
            val new_val = replacement.get(dim)
            val new_node = kdnode_create(dim, new_val, replacement)
            val new_left = kdtree_remove_recursive(left, replacement, depth + 1, k)
            kdnode_set_right(new_node, new_left)
            return new_node

        return nil

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = point.get(dim)

    if coord < pivot:
        val left = kdnode_get_left(node)
        val new_left = kdtree_remove_recursive(left, point, depth + 1, k)
        kdnode_set_left(node, new_left)
    else:
        val right = kdnode_get_right(node)
        val new_right = kdtree_remove_recursive(right, point, depth + 1, k)
        kdnode_set_right(node, new_right)

    node

fn kdtree_remove(node, point: List<i64>):
    # Remove point from K-d tree
    if node == nil:
        return nil
    val k = point_dimension(point)
    kdtree_remove_recursive(node, point, 0, k)

# ============================================================================
# Utility Functions
# ============================================================================

fn kdtree_print_node(node, depth: i64):
    # Print node information (for debugging)
    if node == nil:
        return

    var indent = ""
    var i = 0
    while i < depth:
        indent = indent + "  "
        i = i + 1

    val dim = kdnode_get_dim(node)
    val value = kdnode_get_value(node)
    val point = kdnode_get_point(node)

    print "{indent}Dim: {dim}, Value: {value}"

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    if left != nil:
        print "{indent}Left:"
        kdtree_print_node(left, depth + 1)

    if right != nil:
        print "{indent}Right:"
        kdtree_print_node(right, depth + 1)

fn kdtree_validate(node, depth: i64, k: i64) -> i64:
    # Validate K-d tree structure
    if node == nil:
        return 1

    val dim = kdnode_get_dim(node)
    val expected_dim = depth % k
    if dim != expected_dim:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    val left_valid = kdtree_validate(left, depth + 1, k)
    if left_valid == 0:
        return 0

    val right_valid = kdtree_validate(right, depth + 1, k)
    if right_valid == 0:
        return 0

    1
