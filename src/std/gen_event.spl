# Standard Library â€” GenEvent OTP Behaviour
#
# @tag:api
# @tag:stdlib
#
# GenEvent behaviour for event manager processes.
# An event manager holds a list of event handlers and broadcasts events to all.
# Inspired by Erlang/OTP gen_event.
#
# Usage:
#   val mgr = gen_event_manager_new("my_events")
#   gen_event_add_handler(mgr, "logger")
#   gen_event_notify(mgr, "user_logged_in", "handle_event dispatch here")

# GenEvent handler behaviour trait.
# Implement handle_event for your handler logic.
trait GenEventHandler:
    # Called when an event is notified to this handler.
    fn handle_event(event: text, state: text) -> text

    # Called when handler is added to manager.
    fn init(args: text) -> text:
        ""

    # Called when handler is removed.
    fn terminate(reason: text, state: text):
        pass_do_nothing

# GenEventManager â€” holds registered handler names and dispatches events.
struct GenEventManager:
    name: text
    handlers: [text]
    count: i64
    running: bool

fn gen_event_manager_new(name: text) -> GenEventManager:
    GenEventManager(name: name, handlers: [], count: 0, running: false)

fn gen_event_start(mgr: GenEventManager):
    mgr.running = true

fn gen_event_stop(mgr: GenEventManager):
    mgr.running = false

fn gen_event_is_running(mgr: GenEventManager) -> bool:
    mgr.running

# Add a handler (by name/identifier) to the manager.
fn gen_event_add_handler(mgr: GenEventManager, handler_id: text):
    mgr.handlers.push(handler_id)
    mgr.count = mgr.count + 1

# Remove a handler from the manager.
fn gen_event_remove_handler(mgr: GenEventManager, handler_id: text):
    var new_handlers: [text] = []
    for h in mgr.handlers:
        if h != handler_id:
            new_handlers.push(h)
    mgr.handlers = new_handlers
    mgr.count = new_handlers.len()

# Return the number of registered handlers.
fn gen_event_handler_count(mgr: GenEventManager) -> i64:
    mgr.count

# Notify all handlers of an event. Calls dispatch_fn for each handler.
fn gen_event_notify(mgr: GenEventManager, event: text,
                    dispatch_fn: fn(text, text)):
    for handler_id in mgr.handlers:
        dispatch_fn(handler_id, event)

# Synchronous call: notify all and collect responses.
fn gen_event_call(mgr: GenEventManager, event: text,
                  dispatch_fn: fn(text, text) -> text) -> [text]:
    var responses: [text] = []
    for handler_id in mgr.handlers:
        val resp = dispatch_fn(handler_id, event)
        responses.push(resp)
    responses

export GenEventHandler, GenEventManager
export gen_event_manager_new, gen_event_start, gen_event_stop
export gen_event_is_running, gen_event_add_handler, gen_event_remove_handler
export gen_event_handler_count, gen_event_notify, gen_event_call
