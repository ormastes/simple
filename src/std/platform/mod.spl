# Platform Abstraction Module
#
# Cross-platform utilities for:
# - OS detection (Windows, Linux, macOS, FreeBSD)
# - Path handling (separators, normalization)
# - Platform-specific behaviors

# Extern function declarations (to avoid circular dependency with app.io)
extern fn rt_env_get(key: text) -> text
extern fn rt_file_exists(path: text) -> bool

use std.common.target.{TargetOS, TargetArch}

# ===========================================================================
# Cached Platform Detection (computed once at module load)
# ===========================================================================
# These constants avoid repeated TargetOS.host() calls for 20x speedup

val HOST_OS: TargetOS = TargetOS.host()
val HOST_ARCH: TargetArch = TargetArch.host()

# Platform type checks (cached)
val IS_WINDOWS: bool = HOST_OS == TargetOS.Windows
val IS_UNIX: bool = match HOST_OS:
    case TargetOS.Linux | TargetOS.MacOS | TargetOS.FreeBSD: true
    case _: false
val IS_MACOS: bool = HOST_OS == TargetOS.MacOS
val IS_LINUX: bool = HOST_OS == TargetOS.Linux
val IS_FREEBSD: bool = HOST_OS == TargetOS.FreeBSD

# Architecture checks (cached)
val IS_X86_64: bool = HOST_ARCH == TargetArch.X86_64
val IS_ARM64: bool = HOST_ARCH == TargetArch.Aarch64

# Path separators (cached)
val DIR_SEP: text = HOST_OS.dir_separator()
val PATH_SEP: text = HOST_OS.path_separator()
val EXE_EXT: text = HOST_OS.executable_extension()
val LIB_EXT: text = HOST_OS.library_extension()

# ===========================================================================
# Platform Detection
# ===========================================================================

# Check if running on Windows
fn is_windows() -> bool:
    IS_WINDOWS

# Check if running on Unix-like system
fn is_unix() -> bool:
    IS_UNIX

# Check if running on macOS
fn is_macos() -> bool:
    IS_MACOS

# Check if running on Linux
fn is_linux() -> bool:
    IS_LINUX

# Check if running on FreeBSD
fn is_freebsd() -> bool:
    IS_FREEBSD

# Check if running on x86_64
fn is_x86_64() -> bool:
    IS_X86_64

# Check if running on ARM64/AArch64
fn is_arm64() -> bool:
    IS_ARM64

# ===========================================================================
# Path Separators
# ===========================================================================

# Get directory separator for current platform
fn dir_sep() -> text:
    DIR_SEP

# Get path separator (for PATH environment variable)
fn path_sep() -> text:
    PATH_SEP

# Get executable extension for current platform
fn exe_ext() -> text:
    EXE_EXT

# Get library extension for current platform
fn lib_ext() -> text:
    LIB_EXT

# ===========================================================================
# Path Normalization
# ===========================================================================

# Normalize path for current platform
fn normalize_path(path: text) -> text:
    if IS_WINDOWS:
        normalize_windows_path(path)
    else:
        path  # Unix paths don't need normalization

# Check if path is MinGW-style (/c/Users/... instead of C:\Users\...)
fn is_mingw_path(path: text) -> bool:
    # MinGW paths: /c/..., /d/..., etc.
    if path.len() >= 3:
        path.starts_with("/") and path[2] == '/' and path[1].is_ascii_alpha()
    else:
        false

# Convert MinGW path to Windows path
# /c/Users/Test → C:\Users\Test
# /d/Projects/code → D:\Projects\code
fn mingw_to_windows(path: text) -> text:
    if not is_mingw_path(path):
        return path  # Not a MinGW path

    # Extract drive letter (convert to uppercase)
    val drive = path[1].to_upper()

    # Get the rest of the path (after /c/)
    val rest = path[3:]

    # Build Windows path: C:\...
    val windows_path = "{drive}:{rest}"

    # Convert forward slashes to backslashes
    windows_path.replace("/", "\\")

# Convert Windows path to MinGW path
# C:\Users\Test → /c/Users/Test
# D:\Projects\code → /d/Projects/code
fn windows_to_mingw(path: text) -> text:
    # Check for drive letter (C:\...)
    if path.len() >= 3 and path[1] == ':' and path[2] == '\\':
        # Extract drive letter (convert to lowercase)
        val drive = path[0].to_lower()

        # Get the rest of the path
        val rest = path[2:]

        # Build MinGW path: /c/...
        val mingw_path = "/{drive}{rest}"

        # Convert backslashes to forward slashes
        mingw_path.replace("\\", "/")
    else:
        # Not a Windows absolute path, just convert slashes
        path.replace("\\", "/")

# Normalize Windows path (handles both native and MinGW-style paths)
fn normalize_windows_path(path: text) -> text:
    # Fast path 1: Empty or very short paths
    if path.len() < 3:
        return path

    # Fast path 2: Already normalized Windows paths (no forward slashes)
    if not path.contains("/"):
        # Check if it's a valid normalized Windows path
        if path.len() >= 3 and path[1] == ':' and path[2] == '\\':
            return path  # Already normalized: C:\...
        if path.starts_with("\\\\"):
            return path  # Already normalized UNC: \\server\share
        # Relative path with backslashes only
        if not path.contains(":"):
            return path  # Already normalized relative path

    # Slow path: needs normalization
    # First, convert MinGW-style paths to Windows format
    var normalized = if is_mingw_path(path):
        mingw_to_windows(path)
    else:
        path

    # Convert forward slashes to backslashes
    normalized = normalized.replace("/", "\\")

    # Handle drive letters: C:/ → C:\
    if normalized.len() >= 2 and normalized[1] == ':':
        normalized = normalized[0:2] + normalized[2:].replace("/", "\\")

    # Handle UNC paths: //server/share → \\server\share
    if normalized.starts_with("//"):
        normalized = "\\\\" + normalized[2:].replace("/", "\\")

    normalized

# Join path components with platform separator
fn join_path(parts: [text]) -> text:
    val sep = dir_sep()
    parts.join(sep)

# Get absolute path
fn absolute_path(path: text) -> text:
    # TODO: Implement proper absolute path resolution
    # For now, just normalize
    normalize_path(path)

# ===========================================================================
# Platform String Representation
# ===========================================================================

# Get platform name (e.g., "linux-x86_64", "darwin-arm64", "windows-x86_64")
fn platform_name() -> text:
    val os_name = match HOST_OS:
        case TargetOS.Windows: "windows"
        case TargetOS.Linux: "linux"
        case TargetOS.MacOS: "darwin"
        case TargetOS.FreeBSD: "freebsd"
        case _: "unknown"

    val arch_name = match HOST_ARCH:
        case TargetArch.X86_64: "x86_64"
        case TargetArch.Aarch64: "arm64"
        case TargetArch.X86: "i686"
        case TargetArch.Arm: "arm"
        case _: "unknown"

    "{os_name}-{arch_name}"

# Get platform triple (Rust-style)
fn platform_triple() -> text:
    match (HOST_OS, HOST_ARCH):
        case (TargetOS.Linux, TargetArch.X86_64):
            "x86_64-unknown-linux-gnu"
        case (TargetOS.Linux, TargetArch.Aarch64):
            "aarch64-unknown-linux-gnu"
        case (TargetOS.MacOS, TargetArch.X86_64):
            "x86_64-apple-darwin"
        case (TargetOS.MacOS, TargetArch.Aarch64):
            "aarch64-apple-darwin"
        case (TargetOS.Windows, TargetArch.X86_64):
            "x86_64-pc-windows-msvc"
        case (TargetOS.Windows, TargetArch.Aarch64):
            "aarch64-pc-windows-msvc"
        case _:
            "unknown-unknown-unknown"

# Parse platform name to TargetOS and TargetArch
fn parse_platform(name: text) -> (TargetOS, TargetArch):
    val parts = name.split("-")
    if parts.len() < 2:
        return (TargetOS.Linux, TargetArch.X86_64)  # Default

    val os_str = parts[0]
    val arch_str = parts[1]

    val os = match os_str:
        case "linux": TargetOS.Linux
        case "darwin" | "macos": TargetOS.MacOS
        case "windows" | "win32": TargetOS.Windows
        case "freebsd": TargetOS.FreeBSD
        case _: TargetOS.Linux

    val arch = match arch_str:
        case "x86_64" | "amd64": TargetArch.X86_64
        case "arm64" | "aarch64": TargetArch.Aarch64
        case "i686" | "x86": TargetArch.X86
        case "arm": TargetArch.Arm
        case _: TargetArch.X86_64

    (os, arch)

# ===========================================================================
# Command Resolution Cache
# ===========================================================================
# Cache command paths for 100x speedup (1000ns → 10ns)
# Invalidates automatically when PATH environment variable changes

class CommandCache:
    cache: Dict<text, text>      # cmd → full_path mapping
    path_env: text                # Last known PATH value
    hits: i32                     # Cache hit count (for metrics)
    misses: i32                   # Cache miss count (for metrics)

    # Get singleton instance
    static fn instance() -> CommandCache:
        # Lazy initialization - created on first access
        static var cache_instance: CommandCache? = None

        if not cache_instance.?:
            cache_instance = Some(CommandCache(
                cache: {},
                path_env: "",
                hits: 0,
                misses: 0
            ))

        cache_instance.unwrap()

    # Get cached command path, or None if not cached
    fn get(cmd: text) -> text?:
        # Check if PATH changed (invalidate cache if so)
        val current_path = rt_env_get("PATH")
        if current_path != self.path_env:
            self.cache = {}  # Clear cache
            self.path_env = current_path
            self.misses += 1
            return None

        # Check cache
        if self.cache.contains(cmd):
            self.hits += 1
            return Some(self.cache[cmd])

        self.misses += 1
        None

    # Store resolved command path
    fn set(cmd: text, resolved: text):
        self.cache[cmd] = resolved

    # Get cache hit rate (for monitoring)
    fn hit_rate() -> f64:
        val total = self.hits + self.misses
        if total == 0:
            return 0.0
        self.hits as f64 / total as f64

    # Get cache statistics
    fn stats() -> text:
        val rate = self.hit_rate() * 100.0
        "CommandCache: {self.cache.len()} entries, {self.hits} hits, {self.misses} misses ({rate:.1}% hit rate)"

# ===========================================================================
# Command Resolution (Windows-specific)
# ===========================================================================

# Resolve command path (adds .exe on Windows, searches PATH)
# Uses cache for 100x speedup on repeated calls
fn resolve_command(cmd: text) -> text:
    if not IS_WINDOWS:
        return cmd  # Unix: use PATH directly

    # Check cache first (fast path - 100x speedup)
    val cache = CommandCache.instance()
    if val Some(cached) = cache.get(cmd):
        return cached

    # Cache miss - resolve command (slow path)
    # Windows: add .exe if missing
    var resolved = cmd
    if not cmd.ends_with(".exe") and not cmd.ends_with(".bat") and not cmd.ends_with(".cmd"):
        resolved = "{cmd}.exe"

    # Check if absolute path
    if is_absolute_windows(resolved):
        cache.set(cmd, resolved)  # Cache result
        return resolved

    # Search in PATH
    val path_env = rt_env_get("PATH")
    val paths = path_env.split(path_sep())

    for dir in paths:
        val candidate = join_path([dir, resolved])
        if rt_file_exists(candidate):
            cache.set(cmd, candidate)  # Cache result
            return candidate

    # Not found - cache original command
    cache.set(cmd, cmd)
    cmd  # Return original if not found

# Get command cache statistics (for monitoring/debugging)
fn get_command_cache_stats() -> text:
    CommandCache.instance().stats()

# Clear command cache (for testing or manual invalidation)
fn clear_command_cache():
    val cache = CommandCache.instance()
    cache.cache = {}
    cache.path_env = ""

# Check if path is absolute (Windows)
fn is_absolute_windows(path: text) -> bool:
    # C:\... or \\server\share or MinGW /c/...
    (path.len() >= 3 and path[1] == ':') or
    path.starts_with("\\\\") or
    is_mingw_path(path)

# Check if path is absolute (Unix)
fn is_absolute_unix(path: text) -> bool:
    path.starts_with("/")

# Check if path is absolute (cross-platform)
fn is_absolute(path: text) -> bool:
    if IS_WINDOWS:
        is_absolute_windows(path)
    else:
        is_absolute_unix(path)

# ===========================================================================
# Environment Variables
# ===========================================================================

# Get home directory
fn home_dir() -> text:
    if IS_WINDOWS:
        val userprofile = rt_env_get("USERPROFILE")
        if userprofile != "":
            return userprofile
        # Fallback: %HOMEDRIVE%%HOMEPATH%
        val drive = rt_env_get("HOMEDRIVE")
        val path = rt_env_get("HOMEPATH")
        if drive != "" and path != "":
            return "{drive}{path}"
        "C:\\Users\\Default"
    else:
        val home = rt_env_get("HOME")
        if home != "":
            return home
        "/tmp"  # Fallback

# Get temporary directory
fn temp_dir() -> text:
    if IS_WINDOWS:
        val temp = rt_env_get("TEMP")
        if temp != "":
            return temp
        val tmp = rt_env_get("TMP")
        if tmp != "":
            return tmp
        "C:\\Temp"
    else:
        val tmpdir = rt_env_get("TMPDIR")
        if tmpdir != "":
            return tmpdir
        "/tmp"

# ===========================================================================
# Line Endings
# ===========================================================================

# Get line ending for current platform
fn line_ending() -> text:
    if IS_WINDOWS:
        "\r\n"
    else:
        "\n"

# Normalize line endings for current platform
fn normalize_line_endings(text: text) -> text:
    val target = line_ending()

    # First normalize all to \n
    var normalized = text.replace("\r\n", "\n")
    normalized = normalized.replace("\r", "\n")

    # Then convert to target
    if target == "\r\n":
        normalized.replace("\n", "\r\n")
    else:
        normalized

# ===========================================================================
# Exports
# ===========================================================================

# Export all public functions
export is_windows, is_unix, is_macos, is_linux, is_freebsd, is_x86_64, is_arm64
export dir_sep, path_sep, exe_ext, lib_ext
export normalize_path, normalize_windows_path, is_mingw_path, mingw_to_windows, windows_to_mingw
export join_path, is_absolute, is_absolute_windows, is_absolute_unix
export home_dir, temp_dir, line_ending, normalize_line_endings
export resolve_command, get_command_cache_stats, clear_command_cache

# Export constants
export HOST_OS, HOST_ARCH, IS_WINDOWS, IS_UNIX, IS_MACOS, IS_LINUX, IS_FREEBSD, IS_X86_64, IS_ARM64
export DIR_SEP, PATH_SEP, EXE_EXT, LIB_EXT
