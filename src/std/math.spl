# Math Utilities
#
# Pure Simple math functions that don't require SFFI.
# For SFFI-backed functions (log, trig, etc.), see app.io.mod.
#
# Functions:
# - math_abs / math_abs_i64: Absolute value
# - math_min / math_max: Min/max for f64
# - math_min_i64 / math_max_i64: Min/max for i64
# - math_clamp / math_clamp_i64: Clamp to range
# - math_sign / math_sign_i64: Sign function (-1, 0, 1)
# - math_lerp: Linear interpolation
# - math_is_close: Approximate equality for floats
# - math_gcd / math_lcm: Greatest common divisor / least common multiple
# - math_pow_i64: Integer power
# - math_factorial: Factorial

# ============================================================================
# Constants
# ============================================================================

val MATH_PI = 3.141592653589793
val MATH_E = 2.718281828459045
val MATH_TAU = 6.283185307179586
val MATH_INF = 999999999999999.0

# ============================================================================
# Absolute Value
# ============================================================================

fn math_abs(x: f64) -> f64:
    """Absolute value of a float."""
    if x < 0.0:
        -x
    else:
        x

fn math_abs_i64(x: i64) -> i64:
    """Absolute value of an integer."""
    if x < 0:
        -x
    else:
        x

# ============================================================================
# Min / Max
# ============================================================================

fn math_min(a: f64, b: f64) -> f64:
    """Minimum of two floats."""
    if a < b:
        a
    else:
        b

fn math_max(a: f64, b: f64) -> f64:
    """Maximum of two floats."""
    if a > b:
        a
    else:
        b

fn math_min_i64(a: i64, b: i64) -> i64:
    """Minimum of two integers."""
    if a < b:
        a
    else:
        b

fn math_max_i64(a: i64, b: i64) -> i64:
    """Maximum of two integers."""
    if a > b:
        a
    else:
        b

# ============================================================================
# Clamp
# ============================================================================

fn math_clamp(x: f64, min_val: f64, max_val: f64) -> f64:
    """Clamp x to the range [min_val, max_val]."""
    if x < min_val:
        min_val
    elif x > max_val:
        max_val
    else:
        x

fn math_clamp_i64(x: i64, min_val: i64, max_val: i64) -> i64:
    """Clamp x to the range [min_val, max_val]."""
    if x < min_val:
        min_val
    elif x > max_val:
        max_val
    else:
        x

# ============================================================================
# Sign
# ============================================================================

fn math_sign(x: f64) -> f64:
    """Sign function: returns -1.0, 0.0, or 1.0."""
    if x < 0.0:
        -1.0
    elif x > 0.0:
        1.0
    else:
        0.0

fn math_sign_i64(x: i64) -> i64:
    """Sign function: returns -1, 0, or 1."""
    if x < 0:
        -1
    elif x > 0:
        1
    else:
        0

# ============================================================================
# Interpolation and Approximate Equality
# ============================================================================

fn math_lerp(a: f64, b: f64, t: f64) -> f64:
    """Linear interpolation between a and b. t=0 returns a, t=1 returns b."""
    a + (b - a) * t

fn math_is_close(a: f64, b: f64, tolerance: f64) -> bool:
    """Check if two floats are approximately equal within tolerance."""
    val diff = a - b
    if diff < 0.0:
        -diff < tolerance
    else:
        diff < tolerance

# ============================================================================
# Integer Arithmetic
# ============================================================================

fn math_gcd(a: i64, b: i64) -> i64:
    """Greatest common divisor (Euclidean algorithm)."""
    var x = a
    var y = b
    if x < 0:
        x = -x
    if y < 0:
        y = -y
    while y != 0:
        val temp = y
        y = x % y
        x = temp
    x

fn math_lcm(a: i64, b: i64) -> i64:
    """Least common multiple."""
    if a == 0 or b == 0:
        return 0
    val g = math_gcd(a, b)
    var abs_a = a
    if abs_a < 0:
        abs_a = -abs_a
    var abs_b = b
    if abs_b < 0:
        abs_b = -abs_b
    abs_a / g * abs_b

fn math_pow_i64(base: i64, exp: i64) -> i64:
    """Integer exponentiation. Returns base^exp for non-negative exp."""
    if exp < 0:
        return 0
    if exp == 0:
        return 1
    var result = 1
    var b = base
    var e = exp
    while e > 0:
        if e % 2 == 1:
            result = result * b
        b = b * b
        e = e / 2
    result

fn math_factorial(n: i64) -> i64:
    """Factorial of n. Returns 1 for n <= 0."""
    if n <= 1:
        return 1
    var result = 1
    var i = 2
    while i <= n:
        result = result * i
        i = i + 1
    result

# ============================================================================
# Degree/Radian Conversion
# ============================================================================

fn math_to_radians(degrees: f64) -> f64:
    """Convert degrees to radians."""
    degrees * MATH_PI / 180.0

fn math_to_degrees(radians: f64) -> f64:
    """Convert radians to degrees."""
    radians * 180.0 / MATH_PI

# ============================================================================
# Convenience Aliases (clean names without math_ prefix)
# ============================================================================

fn abs_i64(x: i64) -> i64:
    math_abs_i64(x)

fn min_i64(a: i64, b: i64) -> i64:
    math_min_i64(a, b)

fn max_i64(a: i64, b: i64) -> i64:
    math_max_i64(a, b)

fn clamp_i64(x: i64, min_val: i64, max_val: i64) -> i64:
    math_clamp_i64(x, min_val, max_val)

fn sign_i64(x: i64) -> i64:
    math_sign_i64(x)

fn pow_i64(base: i64, exp: i64) -> i64:
    math_pow_i64(base, exp)

fn gcd(a: i64, b: i64) -> i64:
    math_gcd(a, b)

fn lcm(a: i64, b: i64) -> i64:
    math_lcm(a, b)

fn factorial(n: i64) -> i64:
    math_factorial(n)

# ============================================================================
# Combinatorics
# ============================================================================

fn binomial(n: i64, k: i64) -> i64:
    """Binomial coefficient C(n, k) = n! / (k! * (n-k)!)."""
    if k > n:
        return 0
    if k == 0 or k == n:
        return 1
    factorial(n) / (factorial(k) * factorial(n - k))

# ============================================================================
# Integer Predicates
# ============================================================================

fn is_even(x: i64) -> bool:
    x % 2 == 0

fn is_odd(x: i64) -> bool:
    x % 2 != 0

fn is_divisible_by(x: i64, d: i64) -> bool:
    if d == 0:
        return false
    x % d == 0

fn in_range_i64(x: i64, min_val: i64, max_val: i64) -> bool:
    x >= min_val and x <= max_val

# ============================================================================
# Statistical Functions
# ============================================================================

fn sum_i64(list: [i64]) -> i64:
    var total = 0
    for x in list:
        total = total + x
    total

fn product_i64(list: [i64]) -> i64:
    if list.len() == 0:
        return 1
    var result = 1
    for x in list:
        result = result * x
    result

fn average_i64(list: [i64]) -> i64?:
    if list.len() == 0:
        return nil
    sum_i64(list) / list.len()

fn median_i64(list: [i64]) -> i64?:
    if list.len() == 0:
        return nil
    var sorted = list
    val n = sorted.len()
    for i in 0..n:
        for j in 0..(n - i - 1):
            if sorted[j] > sorted[j + 1]:
                val temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp
    val mid = n / 2
    if n % 2 == 0:
        (sorted[mid - 1] + sorted[mid]) / 2
    else:
        sorted[mid]

# ============================================================================
# Exports
# ============================================================================

export MATH_PI, MATH_E, MATH_TAU, MATH_INF
export math_abs, math_abs_i64, math_min, math_max, math_min_i64, math_max_i64
export math_clamp, math_clamp_i64, math_sign, math_sign_i64
export math_lerp, math_is_close
export math_gcd, math_lcm, math_pow_i64, math_factorial
export math_to_radians, math_to_degrees
export abs_i64, min_i64, max_i64, clamp_i64, sign_i64
export pow_i64, gcd, lcm, factorial, binomial
export is_even, is_odd, is_divisible_by, in_range_i64
export sum_i64, product_i64, average_i64, median_i64
