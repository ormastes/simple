# Encoding Utilities
#
# Text encoding and decoding utilities.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - Base64: base64_encode, base64_decode
# - Hex: hex_encode, hex_decode, hex_dump
# - URL: url_encode, url_decode
# - Escape: escape_string, unescape_string
# - Binary: binary_encode, binary_decode
# - ROT13: rot13_encode, rot13_decode

use std.text.{NL}

# ============================================================================
# Base64 Encoding
# ============================================================================

fn base64_encode(data):
    """Encode byte array to base64 string.

    Example:
        base64_encode([72, 101, 108, 108, 111])  # "SGVsbG8="
    """
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""

    var i = 0
    while i < data.len():
        val b1 = data[i]
        val b2 = if i + 1 < data.len(): data[i + 1] else: 0
        val b3 = if i + 2 < data.len(): data[i + 2] else: 0

        val n = (b1 << 16) | (b2 << 8) | b3

        result = result + alphabet[(n >> 18) & 63]
        result = result + alphabet[(n >> 12) & 63]
        result = result + if i + 1 < data.len(): alphabet[(n >> 6) & 63] else: '='
        result = result + if i + 2 < data.len(): alphabet[n & 63] else: '='

        i = i + 3

    result

fn base64_decode(encoded: text):
    """Decode base64 string to byte array.

    Returns nil if invalid base64.

    Example:
        base64_decode("SGVsbG8=")  # [72, 101, 108, 108, 111]
    """
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

    # Create lookup table
    var lookup = []
    var i = 0
    while i < 256:
        lookup.push(-1)
        i = i + 1

    i = 0
    while i < alphabet.len():
        lookup[alphabet[i].ord()] = i
        i = i + 1

    var result = []
    i = 0

    while i < encoded.len():
        if encoded[i] == '=':
            break

        val c1 = if i < encoded.len(): lookup[encoded[i].ord()] else: -1
        val c2 = if i + 1 < encoded.len(): lookup[encoded[i + 1].ord()] else: -1
        val c3 = if i + 2 < encoded.len() and encoded[i + 2] != '=': lookup[encoded[i + 2].ord()] else: -1
        val c4 = if i + 3 < encoded.len() and encoded[i + 3] != '=': lookup[encoded[i + 3].ord()] else: -1

        if c1 < 0 or c2 < 0:
            return nil

        val n = (c1 << 18) | (c2 << 12) | (if c3 >= 0: c3 << 6 else: 0) | (if c4 >= 0: c4 else: 0)

        result.push((n >> 16) & 255)
        if c3 >= 0:
            result.push((n >> 8) & 255)
        if c4 >= 0:
            result.push(n & 255)

        i = i + 4

    result

fn base64_encode_string(s: text):
    """Encode string to base64.

    Example:
        base64_encode_string("Hello")  # "SGVsbG8="
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    base64_encode(bytes)

fn base64_decode_string(encoded: text):
    """Decode base64 to string.

    Example:
        base64_decode_string("SGVsbG8=")  # "Hello"
    """
    val bytes = base64_decode(encoded)
    if not bytes.?:
        return nil

    var result = ""
    for byte in bytes:
        result = result + byte.chr()

    result

# ============================================================================
# Hexadecimal Encoding
# ============================================================================

fn hex_encode(data):
    """Encode byte array to hex string.

    Example:
        hex_encode([72, 101, 108, 108, 111])  # "48656c6c6f"
    """
    val hex_chars = "0123456789abcdef"
    var result = ""

    for byte in data:
        result = result + hex_chars[(byte >> 4) & 15]
        result = result + hex_chars[byte & 15]

    result

fn hex_decode(hex: text):
    """Decode hex string to byte array.

    Returns nil if invalid hex.

    Example:
        hex_decode("48656c6c6f")  # [72, 101, 108, 108, 111]
    """
    if hex.len() % 2 != 0:
        return nil

    var result = []
    var i = 0

    while i < hex.len():
        val h1 = hex_digit_value(hex[i])
        val h2 = hex_digit_value(hex[i + 1])

        if h1 < 0 or h2 < 0:
            return nil

        result.push(h1 * 16 + h2)
        i = i + 2

    result

fn hex_digit_value(c):
    """Convert hex character to value.

    Example:
        hex_digit_value('A')  # 10
    """
    val code = c.ord()

    if code >= '0'.ord() and code <= '9'.ord():
        return code - '0'.ord()
    elif code >= 'a'.ord() and code <= 'f'.ord():
        return code - 'a'.ord() + 10
    elif code >= 'A'.ord() and code <= 'F'.ord():
        return code - 'A'.ord() + 10
    else:
        return -1

fn hex_encode_string(s: text):
    """Encode string to hex.

    Example:
        hex_encode_string("Hello")  # "48656c6c6f"
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    hex_encode(bytes)

fn hex_decode_string(hex: text):
    """Decode hex to string.

    Example:
        hex_decode_string("48656c6c6f")  # "Hello"
    """
    val bytes = hex_decode(hex)
    if not bytes.?:
        return nil

    var result = ""
    for byte in bytes:
        result = result + byte.chr()

    result

fn hex_dump(data, bytes_per_line: i64):
    """Format hex dump with addresses.

    Example:
        hex_dump([1, 2, 3, 4, 5, 6], 4)
        # "0000: 01 02 03 04\n0004: 05 06"
    """
    var result = ""
    val hex_chars = "0123456789abcdef"

    var i = 0
    while i < data.len():
        # Address
        var addr = i
        var addr_str = ""
        var j = 0
        while j < 4:
            addr_str = hex_chars[addr & 15] + addr_str
            addr = addr >> 4
            j = j + 1
        result = result + addr_str + ": "

        # Hex bytes
        var k = 0
        while k < bytes_per_line and i + k < data.len():
            val byte = data[i + k]
            result = result + hex_chars[(byte >> 4) & 15]
            result = result + hex_chars[byte & 15]
            result = result + " "
            k = k + 1

        result = result + NL
        i = i + bytes_per_line

    result

# ============================================================================
# URL Encoding
# ============================================================================

fn url_encode(s: text):
    """URL encode string (percent encoding).

    Example:
        url_encode("hello world")  # "hello%20world"
    """
    val hex_chars = "0123456789ABCDEF"
    var result = ""

    var i = 0
    while i < s.len():
        val c = s[i]
        val code = c.ord()

        # Check if safe character
        if is_url_safe(c):
            result = result + c
        else:
            # Percent encode
            result = result + '%'
            result = result + hex_chars[(code >> 4) & 15]
            result = result + hex_chars[code & 15]

        i = i + 1

    result

fn url_decode(s: text):
    """URL decode string.

    Returns nil if invalid encoding.

    Example:
        url_decode("hello%20world")  # "hello world"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if s[i] == '%':
            if i + 2 >= s.len():
                return nil

            val h1 = hex_digit_value(s[i + 1])
            val h2 = hex_digit_value(s[i + 2])

            if h1 < 0 or h2 < 0:
                return nil

            result = result + (h1 * 16 + h2).chr()
            i = i + 3
        elif s[i] == '+':
            result = result + ' '
            i = i + 1
        else:
            result = result + s[i]
            i = i + 1

    result

fn is_url_safe(c):
    """Check if character is URL-safe (doesn't need encoding).

    Example:
        is_url_safe('a')  # true
        is_url_safe(' ')  # false
    """
    val code = c.ord()

    # A-Z, a-z, 0-9, -, _, ., ~
    if code >= 'A'.ord() and code <= 'Z'.ord():
        return true
    if code >= 'a'.ord() and code <= 'z'.ord():
        return true
    if code >= '0'.ord() and code <= '9'.ord():
        return true
    if c == '-' or c == '_' or c == '.' or c == '~':
        return true

    false

# ============================================================================
# String Escaping
# ============================================================================

fn escape_string(s: text):
    """Escape special characters in string.

    Escapes: \\n, \\t, \\r, \\\\, \\"

    Example:
        escape_string("hello\\nworld")  # "hello\\\\nworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]

        if c == '\n':
            result = result + "\\n"
        elif c == '\t':
            result = result + "\\t"
        elif c == '\r':
            result = result + "\\r"
        elif c == '\\':
            result = result + "\\\\"
        elif c == '"':
            result = result + "\\\""
        else:
            result = result + c

        i = i + 1

    result

fn unescape_string(s: text):
    """Unescape string.

    Example:
        unescape_string("hello\\\\nworld")  # "hello\\nworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if s[i] == '\\' and i + 1 < s.len():
            val next = s[i + 1]

            if next == 'n':
                result = result + '\n'
                i = i + 2
            elif next == 't':
                result = result + '\t'
                i = i + 2
            elif next == 'r':
                result = result + '\r'
                i = i + 2
            elif next == '\\':
                result = result + '\\'
                i = i + 2
            elif next == '"':
                result = result + '"'
                i = i + 2
            else:
                result = result + s[i]
                i = i + 1
        else:
            result = result + s[i]
            i = i + 1

    result

fn escape_html(s: text):
    """Escape HTML special characters.

    Example:
        escape_html("<div>text</div>")  # "&lt;div&gt;text&lt;/div&gt;"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]

        if c == '<':
            result = result + "&lt;"
        elif c == '>':
            result = result + "&gt;"
        elif c == '&':
            result = result + "&amp;"
        elif c == '"':
            result = result + "&quot;"
        elif c == '\'':
            result = result + "&#39;"
        else:
            result = result + c

        i = i + 1

    result

fn escape_csv(s: text):
    """Escape string for CSV.

    Quotes string if contains comma, quote, or newline.

    Example:
        escape_csv("hello, world")  # "\"hello, world\""
    """
    var needs_quoting = false
    var i = 0

    while i < s.len():
        val nl_char = NL[0:1]
        if s[i] == ',' or s[i] == '"' or s[i] == nl_char:
            needs_quoting = true
            break
        i = i + 1

    if not needs_quoting:
        return s

    var result = "\""
    i = 0

    while i < s.len():
        if s[i] == '"':
            result = result + "\"\""  # Double quote
        else:
            result = result + s[i]
        i = i + 1

    result + "\""

# ============================================================================
# Binary Encoding
# ============================================================================

fn binary_encode(n: i64, bits: i64):
    """Encode integer as binary string.

    Example:
        binary_encode(5, 8)  # "00000101"
    """
    var result = ""
    var i = bits - 1

    while i >= 0:
        if (n & (1 << i)) != 0:
            result = result + '1'
        else:
            result = result + '0'
        i = i - 1

    result

fn binary_decode(s: text) -> i64:
    """Decode binary string to integer.

    Example:
        binary_decode("00000101")  # 5
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result << 1
        if s[i] == '1':
            result = result | 1
        i = i + 1

    result

fn octal_encode(n: i64):
    """Encode integer as octal string.

    Example:
        octal_encode(64)  # "100"
    """
    if n == 0:
        return "0"

    var result = ""
    var num = n

    while num > 0:
        val digit = num % 8
        result = digit.chr() + result
        num = num / 8

    result

fn octal_decode(s: text) -> i64:
    """Decode octal string to integer.

    Example:
        octal_decode("100")  # 64
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result * 8 + (s[i].ord() - '0'.ord())
        i = i + 1

    result

# ============================================================================
# ROT13 Encoding
# ============================================================================

fn rot13_encode(s: text):
    """ROT13 encoding (Caesar cipher with shift 13).

    Example:
        rot13_encode("hello")  # "uryyb"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]
        val code = c.ord()

        if code >= 'a'.ord() and code <= 'z'.ord():
            val shifted = ((code - 'a'.ord() + 13) % 26) + 'a'.ord()
            result = result + shifted.chr()
        elif code >= 'A'.ord() and code <= 'Z'.ord():
            val shifted = ((code - 'A'.ord() + 13) % 26) + 'A'.ord()
            result = result + shifted.chr()
        else:
            result = result + c

        i = i + 1

    result

fn rot13_decode(s: text):
    """ROT13 decoding (same as encoding).

    Example:
        rot13_decode("uryyb")  # "hello"
    """
    rot13_encode(s)

fn caesar_encode(s: text, shift: i64):
    """Caesar cipher with custom shift.

    Example:
        caesar_encode("hello", 3)  # "khoor"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]
        val code = c.ord()

        if code >= 'a'.ord() and code <= 'z'.ord():
            val shifted = ((code - 'a'.ord() + shift) % 26) + 'a'.ord()
            result = result + shifted.chr()
        elif code >= 'A'.ord() and code <= 'Z'.ord():
            val shifted = ((code - 'A'.ord() + shift) % 26) + 'A'.ord()
            result = result + shifted.chr()
        else:
            result = result + c

        i = i + 1

    result

fn caesar_decode(s: text, shift: i64):
    """Decode Caesar cipher.

    Example:
        caesar_decode("khoor", 3)  # "hello"
    """
    caesar_encode(s, 26 - shift)

# ============================================================================
# Unicode Utilities
# ============================================================================

fn char_to_unicode_escape(c) -> text:
    """Convert character to \\uXXXX escape.

    Example:
        char_to_unicode_escape('A')  # "\\u0041"
    """
    val code = c.ord()
    val hex_chars = "0123456789ABCDEF"

    "\\u" +
    hex_chars[(code >> 12) & 15] +
    hex_chars[(code >> 8) & 15] +
    hex_chars[(code >> 4) & 15] +
    hex_chars[code & 15]

fn is_printable(c):
    """Check if character is printable.

    Example:
        is_printable('A')  # true
        is_printable('\n')  # false
    """
    val code = c.ord()
    code >= 32 and code <= 126

fn filter_printable(s: text):
    """Keep only printable characters.

    Example:
        filter_printable("hello\\nworld")  # "helloworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if is_printable(s[i]):
            result = result + s[i]
        i = i + 1

    result
