# TLS Record Protocol Module
#
# Implements the TLS Record Layer which encapsulates all TLS messages.
# Handles building and parsing TLS records, content type mapping, and version validation.

# Build a TLS record
# Parameters:
#   content_type: Content type (20-23)
#   version: Protocol version (e.g., 0x0303 for TLS 1.2)
#   data: Payload data as bytes
# Returns: (type, version, data) tuple representing complete TLS record
fn build_tls_record(content_type, version, data):
    # TLS Record structure:
    # - ContentType (1 byte)
    # - ProtocolVersion (2 bytes)
    # - Length (2 bytes)
    # - Fragment (0-2^14 bytes)
    (content_type, version, data)

# Parse a TLS record from raw bytes
# Parameters:
#   raw_data: Raw bytes containing TLS record
# Returns: (type, version, data) tuple or nil on parse error
fn parse_tls_record(raw_data):
    val TLS_RECORD_HEADER_SIZE = 5
    val data_len = len(raw_data)
    if data_len < TLS_RECORD_HEADER_SIZE:
        nil
    else:
        val content_type = byte_at(raw_data, 0)
        val version_hi = byte_at(raw_data, 1)
        val version_lo = byte_at(raw_data, 2)
        val version = (version_hi * 256) + version_lo
        val length_hi = byte_at(raw_data, 3)
        val length_lo = byte_at(raw_data, 4)
        val length = (length_hi * 256) + length_lo

        if data_len < (TLS_RECORD_HEADER_SIZE + length):
            nil
        else:
            val payload = slice(raw_data, TLS_RECORD_HEADER_SIZE, TLS_RECORD_HEADER_SIZE + length)
            (content_type, version, payload)

# Get human-readable name for content type
# Parameters:
#   content_type: Content type code (20-23)
# Returns: Human-readable name
fn record_type_name(content_type):
    val CONTENT_TYPE_CHANGE_CIPHER_SPEC = 20
    val CONTENT_TYPE_ALERT = 21
    val CONTENT_TYPE_HANDSHAKE = 22
    val CONTENT_TYPE_APPLICATION_DATA = 23

    if content_type == CONTENT_TYPE_CHANGE_CIPHER_SPEC:
        "ChangeCipherSpec"
    else if content_type == CONTENT_TYPE_ALERT:
        "Alert"
    else if content_type == CONTENT_TYPE_HANDSHAKE:
        "Handshake"
    else if content_type == CONTENT_TYPE_APPLICATION_DATA:
        "ApplicationData"
    else:
        "Unknown"

# Validate TLS protocol version
# Parameters:
#   version: Version code (e.g., 0x0303)
# Returns: true if supported, false otherwise
fn validate_tls_version(version):
    val TLS_VERSION_1_2 = 0x0303
    val TLS_VERSION_1_3 = 0x0304
    val is_tls_12 = version == TLS_VERSION_1_2
    val is_tls_13 = version == TLS_VERSION_1_3
    is_tls_12 or is_tls_13

# Get TLS version name
# Parameters:
#   version: Version code
# Returns: Human-readable version string
fn tls_version_name(version):
    val TLS_VERSION_1_0 = 0x0301
    val TLS_VERSION_1_1 = 0x0302
    val TLS_VERSION_1_2 = 0x0303
    val TLS_VERSION_1_3 = 0x0304

    if version == TLS_VERSION_1_0:
        "TLS 1.0"
    else if version == TLS_VERSION_1_1:
        "TLS 1.1"
    else if version == TLS_VERSION_1_2:
        "TLS 1.2"
    else if version == TLS_VERSION_1_3:
        "TLS 1.3"
    else:
        "Unknown"

# Build TLS alert message
# Parameters:
#   level: Alert level (1=warning, 2=fatal)
#   description: Alert description code
# Returns: (level, description) tuple
fn build_alert(level, description):
    (level, description)

# Parse TLS alert from bytes
# Parameters:
#   data: Alert payload bytes
# Returns: (level, description) tuple or nil
fn parse_alert(data):
    if len(data) < 2:
        nil
    else:
        val level = byte_at(data, 0)
        val description = byte_at(data, 1)
        (level, description)

# Get alert level name
# Parameters:
#   level: Alert level code
# Returns: Human-readable level
fn alert_level_name(level):
    val ALERT_LEVEL_WARNING = 1
    val ALERT_LEVEL_FATAL = 2

    if level == ALERT_LEVEL_WARNING:
        "warning"
    else if level == ALERT_LEVEL_FATAL:
        "fatal"
    else:
        "unknown"

# Get alert description name
# Parameters:
#   description: Alert description code
# Returns: Human-readable description
fn alert_description_name(description):
    val ALERT_DESC_CLOSE_NOTIFY = 0
    val ALERT_DESC_UNEXPECTED_MESSAGE = 10
    val ALERT_DESC_BAD_RECORD_MAC = 20
    val ALERT_DESC_HANDSHAKE_FAILURE = 40
    val ALERT_DESC_BAD_CERTIFICATE = 42
    val ALERT_DESC_UNSUPPORTED_CERTIFICATE = 43
    val ALERT_DESC_CERTIFICATE_REVOKED = 44
    val ALERT_DESC_CERTIFICATE_EXPIRED = 45
    val ALERT_DESC_CERTIFICATE_UNKNOWN = 46
    val ALERT_DESC_ILLEGAL_PARAMETER = 47
    val ALERT_DESC_UNKNOWN_CA = 48
    val ALERT_DESC_DECODE_ERROR = 50
    val ALERT_DESC_PROTOCOL_VERSION = 70
    val ALERT_DESC_INTERNAL_ERROR = 80

    if description == ALERT_DESC_CLOSE_NOTIFY:
        "close_notify"
    else if description == ALERT_DESC_UNEXPECTED_MESSAGE:
        "unexpected_message"
    else if description == ALERT_DESC_BAD_RECORD_MAC:
        "bad_record_mac"
    else if description == ALERT_DESC_HANDSHAKE_FAILURE:
        "handshake_failure"
    else if description == ALERT_DESC_BAD_CERTIFICATE:
        "bad_certificate"
    else if description == ALERT_DESC_UNSUPPORTED_CERTIFICATE:
        "unsupported_certificate"
    else if description == ALERT_DESC_CERTIFICATE_REVOKED:
        "certificate_revoked"
    else if description == ALERT_DESC_CERTIFICATE_EXPIRED:
        "certificate_expired"
    else if description == ALERT_DESC_CERTIFICATE_UNKNOWN:
        "certificate_unknown"
    else if description == ALERT_DESC_ILLEGAL_PARAMETER:
        "illegal_parameter"
    else if description == ALERT_DESC_UNKNOWN_CA:
        "unknown_ca"
    else if description == ALERT_DESC_DECODE_ERROR:
        "decode_error"
    else if description == ALERT_DESC_PROTOCOL_VERSION:
        "protocol_version"
    else if description == ALERT_DESC_INTERNAL_ERROR:
        "internal_error"
    else:
        "unknown"

# Check if alert is fatal
# Parameters:
#   level: Alert level code
# Returns: true if fatal
fn is_fatal_alert(level):
    val ALERT_LEVEL_FATAL = 2
    level == ALERT_LEVEL_FATAL
