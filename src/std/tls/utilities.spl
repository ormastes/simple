# TLS Utilities Module
#
# Provides utility functions for byte operations, random generation,
# cryptographic hashing (SHA-256, SHA-384), and string operations.

# Generate pseudo-random bytes using a linear congruential generator
# seeded from the length parameter. Not cryptographically secure but
# produces proper byte-range values with good distribution.
# Parameters:
#   length: Number of random bytes to generate
# Returns: Random bytes as list of integers 0-255
fn generate_random(length):
    var result = []
    var i = 0
    # LCG state: seed with length * large prime + constant
    var state = (length * 6364136223846793005) + 1442695040888963407
    while i < length:
        # LCG step: state = state * a + c (mod 2^64 implicit in i64)
        state = state * 6364136223846793005 + 1442695040888963407
        # Extract byte from upper bits (better distribution)
        var shifted = state >> 33
        # Map to 0-255 range
        if shifted < 0:
            shifted = 0 - shifted
        val random_byte = shifted % 256
        result = append(result, random_byte)
        i = i + 1
    result

# Constant-time comparison to prevent timing attacks
# Parameters:
#   a: First byte array
#   b: Second byte array
# Returns: true if equal, false otherwise
fn constant_time_compare(a, b):
    val len_a = len(a)
    val len_b = len(b)

    if len_a != len_b:
        false
    else:
        var diff = 0
        var i = 0
        while i < len_a:
            val byte_a = byte_at(a, i)
            val byte_b = byte_at(b, i)
            val xor_result = xor(byte_a, byte_b)
            diff = or(diff, xor_result)
            i = i + 1
        diff == 0

# Format bytes as hexadecimal string
# Parameters:
#   data: Byte array
# Returns: Hex string (e.g., "0A1B2C")
fn format_hex(data):
    var result = ""
    val data_len = len(data)
    var i = 0

    while i < data_len:
        val byte_val = byte_at(data, i)
        val hex_str = byte_to_hex(byte_val)
        result = result + hex_str
        i = i + 1

    result

# Convert byte to 2-character hex string
# Parameters:
#   byte_val: Byte value (0-255)
# Returns: 2-character hex string
fn byte_to_hex(byte_val):
    val hex_chars = "0123456789ABCDEF"
    val hi = (byte_val / 16) % 16
    val lo = byte_val % 16
    val hi_char = char_at(hex_chars, hi)
    val lo_char = char_at(hex_chars, lo)
    hi_char + lo_char

# Pad bytes to specified length with zeros
# Parameters:
#   data: Input bytes
#   length: Desired length
# Returns: Padded bytes
fn pad_to_length(data, length):
    var result = data
    val data_len = len(data)
    var i = data_len

    while i < length:
        result = append(result, 0)
        i = i + 1

    result

# XOR each byte with a constant value
# Parameters:
#   data: Input bytes
#   value: XOR value
# Returns: XORed bytes
fn xor_with_byte(data, value):
    var result = []
    val data_len = len(data)
    var i = 0

    while i < data_len:
        val byte_val = byte_at(data, i)
        val xored = xor(byte_val, value)
        result = append(result, xored)
        i = i + 1

    result

# Concatenate two byte arrays
# Parameters:
#   a: First byte array
#   b: Second byte array
# Returns: Concatenated bytes
fn concat_bytes(a, b):
    var result = a
    val b_len = len(b)
    var i = 0

    while i < b_len:
        val byte_val = byte_at(b, i)
        result = append(result, byte_val)
        i = i + 1

    result

# Get byte at index (placeholder - assumes list of integers)
# Parameters:
#   data: Byte array
#   index: Index
# Returns: Byte value
fn byte_at(data, index):
    data[index]

# Slice byte array
# Parameters:
#   data: Byte array
#   start: Start index (inclusive)
#   end: End index (exclusive)
# Returns: Sliced bytes
fn slice(data, start, end):
    var result = []
    var i = start

    while i < end:
        val byte_val = byte_at(data, i)
        result = append(result, byte_val)
        i = i + 1

    result

# Convert string to bytes (UTF-8 / ASCII byte values)
# Parameters:
#   input_text: Input string
# Returns: Byte array (list of integers 0-255)
fn to_bytes(input_text):
    var result = []
    var i = 0
    val text_len = len(input_text)
    while i < text_len:
        val code = byte_at(input_text, i)
        result = append(result, code)
        i = i + 1
    result

# SHA-256 hash - real implementation per FIPS 180-4
# Parameters:
#   data: Input data (list of bytes)
# Returns: SHA-256 hash (32 bytes as list)
fn sha256(data):
    val mask32 = 4294967295  # 0xFFFFFFFF

    # Initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
    var h0 = 1779033703   # 0x6a09e667
    var h1 = 3144134277   # 0xbb67ae85
    var h2 = 1013904242   # 0x3c6ef372
    var h3 = 2773480762   # 0xa54ff53a
    var h4 = 1359893119   # 0x510e527f
    var h5 = 2600822924   # 0x9b05688c
    var h6 = 528734635    # 0x1f83d9ab
    var h7 = 1541459225   # 0x5be0cd19

    # Round constants
    var k_vals = [
        1116352408, 1899447441, 3049323471, 3921009573,
        961987163, 1508970993, 2453635748, 2870763221,
        3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037,
        2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877,
        958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298
    ]

    # Pre-processing: pad message
    val data_len = len(data)
    var padded = []
    var pi = 0
    while pi < data_len:
        padded = append(padded, byte_at(data, pi))
        pi = pi + 1

    # Append bit '1' (0x80 byte)
    padded = append(padded, 128)

    # Append zeros until length mod 64 == 56
    val padded_len_target = data_len + 1
    var pad_zeros = 56 - (padded_len_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        padded = append(padded, 0)
        pz = pz + 1

    # Append original length in bits as 64-bit big-endian
    val bit_length = data_len * 8
    padded = append(padded, 0)
    padded = append(padded, 0)
    padded = append(padded, 0)
    padded = append(padded, 0)
    padded = append(padded, (bit_length >> 24) & 255)
    padded = append(padded, (bit_length >> 16) & 255)
    padded = append(padded, (bit_length >> 8) & 255)
    padded = append(padded, bit_length & 255)

    # Process each 64-byte block
    val total_len = len(padded)
    var block_offset = 0
    while block_offset < total_len:
        # Create message schedule array w[0..63]
        var w = []
        # w[0..15]: 16 words from block (big-endian)
        var wi = 0
        while wi < 16:
            val base = block_offset + (wi * 4)
            val b0 = byte_at(padded, base) & 255
            val b1 = byte_at(padded, base + 1) & 255
            val b2 = byte_at(padded, base + 2) & 255
            val b3 = byte_at(padded, base + 3) & 255
            val word = ((b0 << 24) | (b1 << 16) | (b2 << 8) | b3) & mask32
            w = append(w, word)
            wi = wi + 1

        # w[16..63]: extend
        wi = 16
        while wi < 64:
            val w15 = w[wi - 15] & mask32
            val w2 = w[wi - 2] & mask32
            # s0 = rotr(w[i-15], 7) ^ rotr(w[i-15], 18) ^ (w[i-15] >> 3)
            val r7 = ((w15 >> 7) | (w15 << 25)) & mask32
            val r18 = ((w15 >> 18) | (w15 << 14)) & mask32
            val sh3 = (w15 >> 3) & mask32
            val s0 = (r7 ^ r18 ^ sh3) & mask32
            # s1 = rotr(w[i-2], 17) ^ rotr(w[i-2], 19) ^ (w[i-2] >> 10)
            val r17 = ((w2 >> 17) | (w2 << 15)) & mask32
            val r19 = ((w2 >> 19) | (w2 << 13)) & mask32
            val sh10 = (w2 >> 10) & mask32
            val s1 = (r17 ^ r19 ^ sh10) & mask32
            val new_w = (w[wi - 16] + s0 + w[wi - 7] + s1) & mask32
            w = append(w, new_w)
            wi = wi + 1

        # Initialize working variables
        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var h = h7

        # Compression rounds
        var ri = 0
        while ri < 64:
            val ea = e & mask32
            # S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)
            val er6 = ((ea >> 6) | (ea << 26)) & mask32
            val er11 = ((ea >> 11) | (ea << 21)) & mask32
            val er25 = ((ea >> 25) | (ea << 7)) & mask32
            val big_s1 = (er6 ^ er11 ^ er25) & mask32
            # ch = (e & f) ^ (~e & g)
            val ch = ((ea & (f & mask32)) ^ ((~ea & mask32) & (g & mask32))) & mask32
            val temp1 = (h + big_s1 + ch + k_vals[ri] + w[ri]) & mask32

            val aa = a & mask32
            # S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)
            val ar2 = ((aa >> 2) | (aa << 30)) & mask32
            val ar13 = ((aa >> 13) | (aa << 19)) & mask32
            val ar22 = ((aa >> 22) | (aa << 10)) & mask32
            val big_s0 = (ar2 ^ ar13 ^ ar22) & mask32
            # maj = (a & b) ^ (a & c) ^ (b & c)
            val maj = ((aa & (b & mask32)) ^ (aa & (c & mask32)) ^ ((b & mask32) & (c & mask32))) & mask32
            val temp2 = (big_s0 + maj) & mask32

            h = g
            g = f
            f = e
            e = (d + temp1) & mask32
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & mask32
            ri = ri + 1

        # Add compressed chunk to hash values
        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        h5 = (h5 + f) & mask32
        h6 = (h6 + g) & mask32
        h7 = (h7 + h) & mask32

        block_offset = block_offset + 64

    # Produce the final 32-byte hash
    var hash_result = []
    hash_result = append(hash_result, (h0 >> 24) & 255)
    hash_result = append(hash_result, (h0 >> 16) & 255)
    hash_result = append(hash_result, (h0 >> 8) & 255)
    hash_result = append(hash_result, h0 & 255)
    hash_result = append(hash_result, (h1 >> 24) & 255)
    hash_result = append(hash_result, (h1 >> 16) & 255)
    hash_result = append(hash_result, (h1 >> 8) & 255)
    hash_result = append(hash_result, h1 & 255)
    hash_result = append(hash_result, (h2 >> 24) & 255)
    hash_result = append(hash_result, (h2 >> 16) & 255)
    hash_result = append(hash_result, (h2 >> 8) & 255)
    hash_result = append(hash_result, h2 & 255)
    hash_result = append(hash_result, (h3 >> 24) & 255)
    hash_result = append(hash_result, (h3 >> 16) & 255)
    hash_result = append(hash_result, (h3 >> 8) & 255)
    hash_result = append(hash_result, h3 & 255)
    hash_result = append(hash_result, (h4 >> 24) & 255)
    hash_result = append(hash_result, (h4 >> 16) & 255)
    hash_result = append(hash_result, (h4 >> 8) & 255)
    hash_result = append(hash_result, h4 & 255)
    hash_result = append(hash_result, (h5 >> 24) & 255)
    hash_result = append(hash_result, (h5 >> 16) & 255)
    hash_result = append(hash_result, (h5 >> 8) & 255)
    hash_result = append(hash_result, h5 & 255)
    hash_result = append(hash_result, (h6 >> 24) & 255)
    hash_result = append(hash_result, (h6 >> 16) & 255)
    hash_result = append(hash_result, (h6 >> 8) & 255)
    hash_result = append(hash_result, h6 & 255)
    hash_result = append(hash_result, (h7 >> 24) & 255)
    hash_result = append(hash_result, (h7 >> 16) & 255)
    hash_result = append(hash_result, (h7 >> 8) & 255)
    hash_result = append(hash_result, h7 & 255)
    hash_result

# SHA-384 hash - real implementation per FIPS 180-4
# SHA-384 is SHA-512 with different initial values, truncated to 48 bytes.
# Uses 64-bit arithmetic (i64 is native 64-bit on this platform).
# Parameters:
#   data: Input data (list of bytes)
# Returns: SHA-384 hash (48 bytes as list)
fn sha384(data):
    # SHA-384 initial hash values (from fractional parts of square roots of 9th-16th primes)
    var h0 = -3766243637369397544   # 0xcbbb9d5dc1059ed8
    var h1 = 7105036623409557960    # 0x629a292a367cd507
    var h2 = -7973340178411365097   # 0x9159015a3070dd17
    var h3 = 1526699215303891257    # 0x152fecd8f70e5939
    var h4 = 7436329637833083697    # 0x67332667ffc00b31
    var h5 = -8163818279084223215   # 0x8eb44a8768581511
    var h6 = -2662702644619276377   # 0xdb0c2e0d64f98fa7
    var h7 = 5765546140918722680    # 0x47b5481dbefa4fa4

    # SHA-512 round constants (first 80 are needed)
    var k_vals = [
        4794697086780616226, 8158064640168781261, -5349999486874862801, -1606136188198331460,
        4131703408338449720, 6480981068601479193, -7908458776815382629, -6116909921290321640,
        -2880145864133508542, 1334009975649890238, 2608012711638119052, 6128411473006802146,
        8268148722764581231, -9160688886553864527, -7215885187991268811, -4495734319001033068,
        -1973867731355612462, -1171420211273849373, 1135362057144423861, 2597781545756921966,
        3308224258029322869, 5365058923640841347, 6679025012923562964, 8573033837759648693,
        -7476448914759557205, -6327057829258317296, -5763719355590565569, -4658551843659510044,
        -4116276920077217854, -3051310485924567259, 489312712824947311, 1452737877330783856,
        2861767655752347644, 3322285676063803686, 5560940570517711597, 5996557281743188959,
        7280758554555802590, 8532644243296465576, -9096487096722542874, -7894198246740708037,
        -6719396339535248540, -6333637450476146687, -4446306890439682159, -4076793802049405392,
        -3345356375505022440, -2983346525034927856, -860691631967231958, 1182934255886127544,
        1847814050463011016, 2177327727835720942, 2830643537854262166, 3796741975233480872,
        4115178125766777443, 5681478168544905931, 6601373596472566643, 7507060721942968483,
        8399075790359081724, 8693463985226723168, -8878714635349349518, -8302665154208450068,
        -8016688836872298968, -6606660893046293015, -4685533653050689259, -4147400797238176981,
        -3880063495543823972, -3348786107499101689, -1523767162380948706, -757361751448694408,
        500013540394364858, 748580250866718886, 1242879168328830382, 1977374033974150939,
        2944078676154940804, 3659926193048069267, 4368137639120453308, 4836135668995329356,
        5532061633213252278, 6448918945643986474, 6902733635092675308, 7801388544844847127
    ]

    # Pre-processing: pad message to multiple of 128 bytes
    val data_len = len(data)
    var padded = []
    var pi = 0
    while pi < data_len:
        padded = append(padded, byte_at(data, pi))
        pi = pi + 1

    # Append bit '1' (0x80 byte)
    padded = append(padded, 128)

    # Append zeros until length mod 128 == 112
    val padded_len_target = data_len + 1
    var pad_zeros = 112 - (padded_len_target % 128)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 128
    var pz = 0
    while pz < pad_zeros:
        padded = append(padded, 0)
        pz = pz + 1

    # Append 128-bit length (we only use lower 64 bits)
    val bit_length = data_len * 8
    # Upper 64 bits = 0
    var lb = 0
    while lb < 8:
        padded = append(padded, 0)
        lb = lb + 1
    # Lower 64 bits big-endian
    padded = append(padded, (bit_length >> 56) & 255)
    padded = append(padded, (bit_length >> 48) & 255)
    padded = append(padded, (bit_length >> 40) & 255)
    padded = append(padded, (bit_length >> 32) & 255)
    padded = append(padded, (bit_length >> 24) & 255)
    padded = append(padded, (bit_length >> 16) & 255)
    padded = append(padded, (bit_length >> 8) & 255)
    padded = append(padded, bit_length & 255)

    # Process each 128-byte block
    val total_len = len(padded)
    var block_offset = 0
    while block_offset < total_len:
        # Create message schedule w[0..79] with 64-bit words
        var w = []
        var wi = 0
        while wi < 16:
            val base = block_offset + (wi * 8)
            var word = 0
            var bi = 0
            while bi < 8:
                word = (word << 8) | (byte_at(padded, base + bi) & 255)
                bi = bi + 1
            w = append(w, word)
            wi = wi + 1

        # Extend to 80 words
        wi = 16
        while wi < 80:
            val w15 = w[wi - 15]
            val w2 = w[wi - 2]
            # sigma0 = rotr(w15,1) ^ rotr(w15,8) ^ (w15 >>> 7)
            val s0_r1 = (w15 >> 1) | (w15 << 63)
            val s0_r8 = (w15 >> 8) | (w15 << 56)
            val s0_s7 = (w15 >> 7) & 0x01FFFFFFFFFFFFFF
            val s0 = s0_r1 ^ s0_r8 ^ s0_s7
            # sigma1 = rotr(w2,19) ^ rotr(w2,61) ^ (w2 >>> 6)
            val s1_r19 = (w2 >> 19) | (w2 << 45)
            val s1_r61 = (w2 >> 61) | (w2 << 3)
            val s1_s6 = (w2 >> 6) & 0x03FFFFFFFFFFFFFF
            val s1 = s1_r19 ^ s1_r61 ^ s1_s6
            val new_w = w[wi - 16] + s0 + w[wi - 7] + s1
            w = append(w, new_w)
            wi = wi + 1

        # Working variables
        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var h = h7

        # 80 rounds
        var ri = 0
        while ri < 80:
            # Sigma1 = rotr(e,14) ^ rotr(e,18) ^ rotr(e,41)
            val e_r14 = (e >> 14) | (e << 50)
            val e_r18 = (e >> 18) | (e << 46)
            val e_r41 = (e >> 41) | (e << 23)
            val big_s1 = e_r14 ^ e_r18 ^ e_r41
            # Ch = (e & f) ^ (~e & g)
            val ch = (e & f) ^ (~e & g)
            val temp1 = h + big_s1 + ch + k_vals[ri] + w[ri]

            # Sigma0 = rotr(a,28) ^ rotr(a,34) ^ rotr(a,39)
            val a_r28 = (a >> 28) | (a << 36)
            val a_r34 = (a >> 34) | (a << 30)
            val a_r39 = (a >> 39) | (a << 25)
            val big_s0 = a_r28 ^ a_r34 ^ a_r39
            # Maj = (a & b) ^ (a & c) ^ (b & c)
            val maj = (a & b) ^ (a & c) ^ (b & c)
            val temp2 = big_s0 + maj

            h = g
            g = f
            f = e
            e = d + temp1
            d = c
            c = b
            b = a
            a = temp1 + temp2
            ri = ri + 1

        h0 = h0 + a
        h1 = h1 + b
        h2 = h2 + c
        h3 = h3 + d
        h4 = h4 + e
        h5 = h5 + f
        h6 = h6 + g
        h7 = h7 + h

        block_offset = block_offset + 128

    # Output first 6 words (48 bytes) for SHA-384
    var hash_result = []
    var hi_idx = 0
    var h_vals = [h0, h1, h2, h3, h4, h5]
    while hi_idx < 6:
        val hv = h_vals[hi_idx]
        hash_result = append(hash_result, (hv >> 56) & 255)
        hash_result = append(hash_result, (hv >> 48) & 255)
        hash_result = append(hash_result, (hv >> 40) & 255)
        hash_result = append(hash_result, (hv >> 32) & 255)
        hash_result = append(hash_result, (hv >> 24) & 255)
        hash_result = append(hash_result, (hv >> 16) & 255)
        hash_result = append(hash_result, (hv >> 8) & 255)
        hash_result = append(hash_result, hv & 255)
        hi_idx = hi_idx + 1
    hash_result

# XOR two byte values using bitwise XOR operator
# Parameters:
#   a: First byte (integer 0-255)
#   b: Second byte (integer 0-255)
# Returns: XOR result (integer 0-255)
fn xor(a, b):
    a ^ b

# Bitwise OR of two values
# Parameters:
#   a: First value
#   b: Second value
# Returns: OR result
fn or(a, b):
    a | b

# Get character at index in string
# Parameters:
#   input_text: Input string
#   index: Index position
# Returns: Single character as text, or "" if out of bounds
fn char_at(input_text, index):
    val text_len = len(input_text)
    if index < 0:
        return ""
    if index >= text_len:
        return ""
    val hex_chars_local = "0123456789ABCDEF"
    val code = byte_at(input_text, index)
    # Build character from byte code
    var i = 0
    while i < text_len:
        val c = byte_at(input_text, i)
        if i == index:
            # Return the character at this index via substring
            val result = slice(input_text, index, index + 1)
            return result
        i = i + 1
    ""

# String starts with prefix
# Parameters:
#   input_text: Input string
#   prefix: Prefix to check
# Returns: true if starts with prefix
fn starts_with(input_text, prefix):
    val text_len = len(input_text)
    val prefix_len = len(prefix)
    if prefix_len > text_len:
        return false
    var i = 0
    while i < prefix_len:
        val a = byte_at(input_text, i)
        val b = byte_at(prefix, i)
        if a != b:
            return false
        i = i + 1
    true

# String contains substring
# Parameters:
#   input_text: Input string
#   sub: Substring to find
# Returns: true if contains substring
fn contains(input_text, sub):
    val text_len = len(input_text)
    val sub_len = len(sub)
    if sub_len == 0:
        return true
    if sub_len > text_len:
        return false
    val search_limit = text_len - sub_len + 1
    var i = 0
    while i < search_limit:
        var found = true
        var j = 0
        while j < sub_len:
            val a = byte_at(input_text, i + j)
            val b = byte_at(sub, j)
            if a != b:
                found = false
                j = sub_len  # break inner loop
            j = j + 1
        if found:
            return true
        i = i + 1
    false

# Get length of collection
# Parameters:
#   collection: List or bytes
# Returns: Length
fn len(collection):
    # Placeholder - should return length
    0

# Append to list
# Parameters:
#   list: Input list
#   item: Item to append
# Returns: New list with item appended
fn append(list, item):
    # Placeholder - should append item
    list
