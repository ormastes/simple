# Unified Reporting System
#
# A comprehensive reporting system for the Simple language compiler and runtime.
# Provides unified handling for errors, warnings, and informational messages
# with configurable severity levels, multiple output formats, and fix suggestions.
#
# # Overview
#
# The reporting system consists of:
# - **ReportLevel**: Severity levels (Debug, Info, Warning, Error, Fatal)
# - **SourceLocation**: File/line/column/span information
# - **Report**: The core report type with builder pattern
# - **ReportCollector**: Manages collections of reports
# - **ReportConfig**: Configuration for filtering and output
#
# # Quick Start
#
# ```simple
# import std.report
#
# # Create a collector
# val collector = ReportCollector.default_collector()
#
# # Add reports
# collector.add(
#     Report.error("type mismatch")
#         .with_code("E0308")
#         .at("main.spl", 10, 5)
#         .with_note("expected `i64`, found `text`")
# )
#
# # Check and format
# if collector.has_errors():
#     print collector.format(true)
# ```
#
# # Report Levels
#
# | Level | Description | Use Case |
# |-------|-------------|----------|
# | Debug | Detailed diagnostic info | Development/debugging |
# | Info | Informational messages | Progress, status |
# | Warning | Potential issues | Suspicious code |
# | Error | Failures | Compilation errors |
# | Fatal | Unrecoverable | Panics, crashes |
#
# # Configuration
#
# Reports can be configured via:
# - `ReportConfig.default_config()` - Standard settings
# - `ReportConfig.strict()` - All warnings, warnings as errors
# - `ReportConfig.quiet()` - Only errors, compact output
# - `ReportConfig.json()` - JSON output for tooling
#
# Level overrides can be set per-code or per-pattern:
# ```simple
# config.set_code_level("L:print_in_test_spec", ReportLevel.Info)
# config.add_pattern_override("*deprecated*", ReportLevel.Error)
# ```
#
# # Output Formats
#
# - **Human**: Colorful terminal output with source context
# - **Compact**: One-line format for logs
# - **JSON**: Machine-readable JSON
# - **SARIF**: Static Analysis Results Interchange Format
#
# # Fix Suggestions
#
# Reports can include machine-applicable fixes:
# ```simple
# val suggestion = Suggestion.replace(
#     location,
#     "if val",
#     "Replace 'if let' with 'if val'"
# )
# report.with_suggestion(suggestion)
# ```
#
# See also:
# - `src/std/report/level.spl` - ReportLevel, LevelConfig
# - `src/std/report/location.spl` - Span, SourceLocation, Label
# - `src/std/report/report.spl` - Report, ReportKind, Suggestion
# - `src/std/report/config.spl` - ReportConfig, OutputFormat, ColorMode
# - `src/std/report/collector.spl` - ReportCollector, SourceRegistry
# - `src/std/report/compiler/` - Compiler-specific reports (EasyFix, diagnostics)
# - `src/std/report/runtime/` - Runtime reports (panics, logging, memory)
# - `src/std/report/tool/` - Tool reports (lint, test, build)
#
# # Compiler Reports
#
# For compiler-specific diagnostics and EasyFix support, use the compiler submodule:
# ```simple
# import std.report.compiler
#
# # Specialized compiler diagnostics
# val error = TypeError.mismatch("i64", "text", location)
# val warning = LintWarning.unused_variable("x", location)
#
# # EasyFix with auto-applicable fix
# val fix = EasyFixReport.safe("L:rule", "description")
#     .with_replacement(Replacement.at(file, start, end, line, col, "new_text"))
# ```
#
# # Runtime Reports
#
# For runtime diagnostics, panics, and logging, use the runtime submodule:
# ```simple
# import std.report.runtime
#
# # Panic with stack trace
# val panic = PanicReport.assertion("x must be positive")
#     .at("main.spl", 42, 5)
#     .with_context("x", "-5")
#
# # Debug logging
# val logger = Logger.named("my_module")
# logger.info("Processing started")
# logger.debug("Item count: 42")
#
# # Memory diagnostics
# val mem = MemoryReport.empty()
# mem.add_leak(LeakInfo.at_address(0x1234, 1024))
# ```
#
# # Tool Reports
#
# For tool diagnostics (lint, test, build), use the tool submodule:
# ```simple
# import std.report.tool
#
# # Lint results
# val lint = LintReport.warning("L:unused", "unused variable", location)
# val summary = LintSummary.empty()
# summary.add_result(result)
# print summary.format(true)
#
# # Test results
# val test = TestResult.passed("test_add", 50)
# val suite = TestSuite.named("math_tests")
# suite.add(test)
#
# # Build results
# val build = BuildResult.success(1500)
# build.add_artifact("target/release/myapp")
# ```

# Re-export all public types from core modules
pub use .level.{ReportLevel, LevelConfig}
pub use .location.{Span, SourceLocation, Label}
pub use .report.{Report, ReportKind, Suggestion, FixConfidence}
pub use .config.{ReportConfig, OutputFormat, ColorMode}
pub use .collector.{ReportCollector, SourceRegistry}

# Re-export submodules
pub mod compiler
pub mod runtime
pub mod tool
