# Human EmitterNL#NL# Human-readable terminal output with colors and source context.NL# Provides rich, formatted output for interactive use.NLNLimport ..levelNLimport ..locationNLimport ..reportNLimport ..configNLimport ..collectorNLuse std.string.{NL}NLNLexport HumanEmitter, HumanStyle, TerminalColorsNLNL# =============================================================================NL# ANSI Escape HelperNL# =============================================================================NLNL# Get the ANSI escape character (ASCII 27)NLfn esc_char() -> text:NL    val code: u8 = 27NL    "{code as char}"NLNL# =============================================================================NL# TerminalColors: ANSI color codesNL# =============================================================================NLNLclass TerminalColors:NL    enabled: boolNLNLimpl TerminalColors:NL    static fn enabled_colors() -> TerminalColors:NL        TerminalColors(enabled: true)NLNL    static fn disabled() -> TerminalColors:NL        TerminalColors(enabled: false)NLNL    fn reset() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[0m"NL        else: ""NLNL    fn bold() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[1m"NL        else: ""NLNL    fn dim() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[2m"NL        else: ""NLNL    fn italic() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[3m"NL        else: ""NLNL    fn underline() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[4m"NL        else: ""NLNL    # Foreground colorsNL    fn black() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[30m"NL        else: ""NLNL    fn red() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[31m"NL        else: ""NLNL    fn green() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[32m"NL        else: ""NLNL    fn yellow() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[33m"NL        else: ""NLNL    fn blue() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[34m"NL        else: ""NLNL    fn magenta() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[35m"NL        else: ""NLNL    fn cyan() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[36m"NL        else: ""NLNL    fn white() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[37m"NL        else: ""NLNL    fn gray() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[90m"NL        else: ""NLNL    # Bold variantsNL    fn bold_red() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[1;31m"NL        else: ""NLNL    fn bold_green() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[1;32m"NL        else: ""NLNL    fn bold_yellow() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[1;33m"NL        else: ""NLNL    fn bold_blue() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[1;34m"NL        else: ""NLNL    fn bold_magenta() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[1;35m"NL        else: ""NLNL    fn bold_cyan() -> text:NL        if self.enabled:NL            val e = esc_char()NL            "{e}[1;36m"NL        else: ""NLNL    # Level-specific colorsNL    fn for_level(level: ReportLevel) -> text:NL        if not self.enabled:NL            return ""NL        match level:NL            case ReportLevel.Debug: self.gray()NL            case ReportLevel.Info: self.cyan()NL            case ReportLevel.Warning: self.bold_yellow()NL            case ReportLevel.Error: self.bold_red()NL            case ReportLevel.Fatal: self.bold_magenta()NLNL# =============================================================================NL# HumanStyle: Configuration for human output styleNL# =============================================================================NLNLclass HumanStyle:NL    show_source_context: bool       # Show source code snippetsNL    show_line_numbers: bool         # Show line numbers in contextNL    context_lines_before: i64       # Lines to show before errorNL    context_lines_after: i64        # Lines to show after errorNL    show_suggestions: bool          # Show fix suggestionsNL    show_notes: bool                # Show notesNL    show_help: bool                 # Show help messagesNL    max_label_width: i64            # Max width for labelsNL    indent: text                    # Indentation stringNLNLimpl HumanStyle:NL    static fn default_style() -> HumanStyle:NL        HumanStyle(NL            show_source_context: true,NL            show_line_numbers: true,NL            context_lines_before: 0,NL            context_lines_after: 0,NL            show_suggestions: true,NL            show_notes: true,NL            show_help: true,NL            max_label_width: 80,NL            indent: "  "NL        )NLNL    static fn compact() -> HumanStyle:NL        HumanStyle(NL            show_source_context: false,NL            show_line_numbers: false,NL            context_lines_before: 0,NL            context_lines_after: 0,NL            show_suggestions: false,NL            show_notes: false,NL            show_help: false,NL            max_label_width: 120,NL            indent: ""NL        )NLNL    static fn verbose() -> HumanStyle:NL        HumanStyle(NL            show_source_context: true,NL            show_line_numbers: true,NL            context_lines_before: 2,NL            context_lines_after: 2,NL            show_suggestions: true,NL            show_notes: true,NL            show_help: true,NL            max_label_width: 100,NL            indent: "  "NL        )NLNL# =============================================================================NL# HumanEmitter: Emits human-readable outputNL# =============================================================================NLNLclass HumanEmitter:NL    colors: TerminalColorsNL    style: HumanStyleNL    sources: SourceRegistryNLNLimpl HumanEmitter:NL    static fn default_emitter() -> HumanEmitter:NL        HumanEmitter(NL            colors: TerminalColors.enabled_colors(),NL            style: HumanStyle.default_style(),NL            sources: SourceRegistry.empty()NL        )NLNL    static fn with_colors(use_color: bool) -> HumanEmitter:NL        HumanEmitter(NL            colors: if use_color: TerminalColors.enabled_colors() else: TerminalColors.disabled(),NL            style: HumanStyle.default_style(),NL            sources: SourceRegistry.empty()NL        )NLNL    static fn compact_emitter() -> HumanEmitter:NL        HumanEmitter(NL            colors: TerminalColors.disabled(),NL            style: HumanStyle.compact(),NL            sources: SourceRegistry.empty()NL        )NLNL    me add_source(path: text, content: text):NL        self.sources.add(path, content)NLNL    me set_style(style: HumanStyle):NL        self.style = styleNLNL    # ==========================================================================NL    # Emit methodsNL    # ==========================================================================NLNL    fn emit(report: Report) -> text:NL        var output = self.emit_header(report)NLNL        # Primary locationNL        if report.location.?:NL            output = output + self.emit_location(report.location.unwrap(), report.level)NLNL        # LabelsNL        for label in report.labels:NL            output = output + self.emit_label(label, report.level)NLNL        # NotesNL        if self.style.show_notes:NL            for note in report.notes:NL                output = output + self.emit_note(note)NLNL        # HelpNL        if self.style.show_help:NL            for help in report.help:NL                output = output + self.emit_help(help)NLNL        # SuggestionsNL        if self.style.show_suggestions:NL            for suggestion in report.suggestions:NL                output = output + self.emit_suggestion(suggestion)NLNL        outputNLNL    fn emit_header(report: Report) -> text:NL        val c = self.colorsNL        val level_color = c.for_level(report.level)NLNL        var header = "{level_color}{report.level.name()}{c.reset()}"NLNL        if report.code.?:NL            header = header + "[{report.code.unwrap()}]"NLNL        header = header + ": {c.bold()}{report.message}{c.reset()}\n"NLNL        if report.source_name.?:NL            header = header + "{self.style.indent}[{report.source_name.unwrap()}]\n"NLNL        headerNLNL    fn emit_location(location: SourceLocation, level: ReportLevel) -> text:NL        val c = self.colorsNLNL        var output = "{self.style.indent}{c.bold_blue()}-->{c.reset()} {location.format_short()}\n"NLNL        if self.style.show_source_context:NL            output = output + self.emit_source_context(location, level)NLNL        outputNLNL    fn emit_source_context(location: SourceLocation, level: ReportLevel) -> text:NL        if not location.is_valid():NL            return ""NLNL        val source = match self.sources.get(location.file):NL            case Some(s): sNL            case nil: return ""NLNL        val lines = source.split(NL)NL        if location.line <= 0 or location.line > lines.len():NL            return ""NLNL        val c = self.colorsNL        val line_num = location.lineNL        val line_str = lines[line_num - 1]NLNL        var output = "{self.style.indent} {c.bold_blue()}|{c.reset()}\n"NLNL        # Show context lines beforeNL        if self.style.context_lines_before > 0:NL            var start = (line_num - self.style.context_lines_before).max(1)NL            while start < line_num:NL                val ctx_line = lines[start - 1]NL                output = output + "{c.bold_blue()}{start:4}{c.reset()} {c.bold_blue()}|{c.reset()} {ctx_line}\n"NL                start = start + 1NLNL        # Main lineNL        output = output + "{c.bold_blue()}{line_num:4}{c.reset()} {c.bold_blue()}|{c.reset()} {line_str}\n"NLNL        # UnderlineNL        val col = (location.column - 1).max(0)NL        val len = if location.span.len() > 0:NL            location.span.len().min(line_str.len() - col).max(1)NL        else:NL            1NLNL        val spaces = " ".repeat(col)NL        val underline = "^".repeat(len)NL        val level_color = c.for_level(level)NLNL        output = output + "{self.style.indent} {c.bold_blue()}|{c.reset()} {spaces}{level_color}{underline}{c.reset()}\n"NLNL        # Show context lines afterNL        if self.style.context_lines_after > 0:NL            var end_line = (line_num + self.style.context_lines_after).min(lines.len())NL            var curr = line_num + 1NL            while curr <= end_line:NL                val ctx_line = lines[curr - 1]NL                output = output + "{c.bold_blue()}{curr:4}{c.reset()} {c.bold_blue()}|{c.reset()} {ctx_line}\n"NL                curr = curr + 1NLNL        outputNLNL    fn emit_label(label: Label, level: ReportLevel) -> text:NL        val c = self.colorsNLNL        var output = "{self.style.indent}{c.bold_blue()}-->{c.reset()} {label.location.format_short()}\n"NLNL        if self.style.show_source_context and label.location.is_valid():NL            val source = match self.sources.get(label.location.file):NL                case Some(s): sNL                case nil: return outputNLNL            val lines = source.split(NL)NL            if label.location.line > 0 and label.location.line <= lines.len():NL                val line_num = label.location.lineNL                val line_str = lines[line_num - 1]NLNL                output = output + "{self.style.indent} {c.bold_blue()}|{c.reset()}\n"NL                output = output + "{c.bold_blue()}{line_num:4}{c.reset()} {c.bold_blue()}|{c.reset()} {line_str}\n"NLNL                val col = (label.location.column - 1).max(0)NL                val len = if label.location.span.len() > 0:NL                    label.location.span.len().min(line_str.len() - col).max(1)NL                else:NL                    1NLNL                val spaces = " ".repeat(col)NL                val underline_char = if label.primary: "^" else: "-"NL                val underline = underline_char.repeat(len)NL                val label_color = if label.primary: c.for_level(level) else: c.bold_blue()NLNL                output = output + "{self.style.indent} {c.bold_blue()}|{c.reset()} {spaces}{label_color}{underline}{c.reset()} {label.message}\n"NLNL        outputNLNL    fn emit_note(note: text) -> text:NL        val c = self.colorsNL        "{self.style.indent}{c.bold_cyan()}= note:{c.reset()} {note}\n"NLNL    fn emit_help(help: text) -> text:NL        val c = self.colorsNL        "{self.style.indent}{c.bold_green()}= help:{c.reset()} {help}\n"NLNL    fn emit_suggestion(suggestion: Suggestion) -> text:NL        val c = self.colorsNL        var output = "{self.style.indent}{c.bold_green()}= suggestion:{c.reset()} {suggestion.message}"NL        output = output + " [{suggestion.confidence.name()}]\n"NLNL        if not suggestion.new_text.is_empty():NL            output = output + "{self.style.indent}  {c.green()}|{c.reset()} {suggestion.new_text}\n"NLNL        outputNLNL    # ==========================================================================NL    # Emit multiple reportsNL    # ==========================================================================NLNL    fn emit_all(reports: [Report]) -> text:NL        var output = ""NL        for report in reports:NL            output = output + self.emit(report) + "\n"NL        outputNLNL    fn emit_collector(collector: ReportCollector) -> text:NL        val displayable = collector.filter_displayable()NL        var output = self.emit_all(displayable)NLNL        # SummaryNL        val c = self.colorsNL        val err_count = collector.error_count()NL        val warn_count = collector.warning_count()NLNL        if err_count > 0 or warn_count > 0:NL            output = output + "\n{c.bold()}Summary:{c.reset()} "NL            if err_count > 0:NL                output = output + "{c.bold_red()}{err_count} error(s){c.reset()}"NL                if warn_count > 0:NL                    output = output + ", "NL            if warn_count > 0:NL                output = output + "{c.bold_yellow()}{warn_count} warning(s){c.reset()}"NL            output = output + "\n"NLNL        outputNLNL    # ==========================================================================NL    # Compact formatNL    # ==========================================================================NLNL    fn emit_compact(report: Report) -> text:NL        val loc_str = if report.location.?:NL            "{report.location.unwrap().format_short()}: "NL        else:NL            ""NLNL        val code_str = if report.code.?: "[{report.code.unwrap()}] " else: ""NLNL        "{loc_str}{report.level.name()}: {code_str}{report.message}"NLNL    fn emit_all_compact(reports: [Report]) -> text:NL        var lines: [text] = []NL        for report in reports:NL            lines.push(self.emit_compact(report))NL        lines.join("\n")NL