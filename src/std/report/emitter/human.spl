# Human Emitter
#
# Human-readable terminal output with colors and source context.
# Provides rich, formatted output for interactive use.

import ..level
import ..location
import ..report
import ..config
import ..collector

export HumanEmitter, HumanStyle, TerminalColors

# =============================================================================
# TerminalColors: ANSI color codes
# =============================================================================

class TerminalColors:
    enabled: bool

impl TerminalColors:
    static fn enabled_colors() -> TerminalColors:
        TerminalColors(enabled: true)

    static fn disabled() -> TerminalColors:
        TerminalColors(enabled: false)

    fn reset() -> text:
        if self.enabled: "\x1b[0m" else: ""

    fn bold() -> text:
        if self.enabled: "\x1b[1m" else: ""

    fn dim() -> text:
        if self.enabled: "\x1b[2m" else: ""

    fn italic() -> text:
        if self.enabled: "\x1b[3m" else: ""

    fn underline() -> text:
        if self.enabled: "\x1b[4m" else: ""

    # Foreground colors
    fn black() -> text:
        if self.enabled: "\x1b[30m" else: ""

    fn red() -> text:
        if self.enabled: "\x1b[31m" else: ""

    fn green() -> text:
        if self.enabled: "\x1b[32m" else: ""

    fn yellow() -> text:
        if self.enabled: "\x1b[33m" else: ""

    fn blue() -> text:
        if self.enabled: "\x1b[34m" else: ""

    fn magenta() -> text:
        if self.enabled: "\x1b[35m" else: ""

    fn cyan() -> text:
        if self.enabled: "\x1b[36m" else: ""

    fn white() -> text:
        if self.enabled: "\x1b[37m" else: ""

    fn gray() -> text:
        if self.enabled: "\x1b[90m" else: ""

    # Bold variants
    fn bold_red() -> text:
        if self.enabled: "\x1b[1;31m" else: ""

    fn bold_green() -> text:
        if self.enabled: "\x1b[1;32m" else: ""

    fn bold_yellow() -> text:
        if self.enabled: "\x1b[1;33m" else: ""

    fn bold_blue() -> text:
        if self.enabled: "\x1b[1;34m" else: ""

    fn bold_magenta() -> text:
        if self.enabled: "\x1b[1;35m" else: ""

    fn bold_cyan() -> text:
        if self.enabled: "\x1b[1;36m" else: ""

    # Level-specific colors
    fn for_level(level: ReportLevel) -> text:
        if not self.enabled:
            return ""
        match level:
            case ReportLevel.Debug: self.gray()
            case ReportLevel.Info: self.cyan()
            case ReportLevel.Warning: self.bold_yellow()
            case ReportLevel.Error: self.bold_red()
            case ReportLevel.Fatal: self.bold_magenta()

# =============================================================================
# HumanStyle: Configuration for human output style
# =============================================================================

class HumanStyle:
    show_source_context: bool       # Show source code snippets
    show_line_numbers: bool         # Show line numbers in context
    context_lines_before: i64       # Lines to show before error
    context_lines_after: i64        # Lines to show after error
    show_suggestions: bool          # Show fix suggestions
    show_notes: bool                # Show notes
    show_help: bool                 # Show help messages
    max_label_width: i64            # Max width for labels
    indent: text                    # Indentation string

impl HumanStyle:
    static fn default_style() -> HumanStyle:
        HumanStyle(
            show_source_context: true,
            show_line_numbers: true,
            context_lines_before: 0,
            context_lines_after: 0,
            show_suggestions: true,
            show_notes: true,
            show_help: true,
            max_label_width: 80,
            indent: "  "
        )

    static fn compact() -> HumanStyle:
        HumanStyle(
            show_source_context: false,
            show_line_numbers: false,
            context_lines_before: 0,
            context_lines_after: 0,
            show_suggestions: false,
            show_notes: false,
            show_help: false,
            max_label_width: 120,
            indent: ""
        )

    static fn verbose() -> HumanStyle:
        HumanStyle(
            show_source_context: true,
            show_line_numbers: true,
            context_lines_before: 2,
            context_lines_after: 2,
            show_suggestions: true,
            show_notes: true,
            show_help: true,
            max_label_width: 100,
            indent: "  "
        )

# =============================================================================
# HumanEmitter: Emits human-readable output
# =============================================================================

class HumanEmitter:
    colors: TerminalColors
    style: HumanStyle
    sources: SourceRegistry

impl HumanEmitter:
    static fn default_emitter() -> HumanEmitter:
        HumanEmitter(
            colors: TerminalColors.enabled_colors(),
            style: HumanStyle.default_style(),
            sources: SourceRegistry.empty()
        )

    static fn with_colors(use_color: bool) -> HumanEmitter:
        HumanEmitter(
            colors: if use_color: TerminalColors.enabled_colors() else: TerminalColors.disabled(),
            style: HumanStyle.default_style(),
            sources: SourceRegistry.empty()
        )

    static fn compact_emitter() -> HumanEmitter:
        HumanEmitter(
            colors: TerminalColors.disabled(),
            style: HumanStyle.compact(),
            sources: SourceRegistry.empty()
        )

    me add_source(path: text, content: text):
        self.sources.add(path, content)

    me set_style(style: HumanStyle):
        self.style = style

    # ==========================================================================
    # Emit methods
    # ==========================================================================

    fn emit(report: Report) -> text:
        var output = self.emit_header(report)

        # Primary location
        if report.location.?:
            output = output + self.emit_location(report.location.unwrap(), report.level)

        # Labels
        for label in report.labels:
            output = output + self.emit_label(label, report.level)

        # Notes
        if self.style.show_notes:
            for note in report.notes:
                output = output + self.emit_note(note)

        # Help
        if self.style.show_help:
            for help in report.help:
                output = output + self.emit_help(help)

        # Suggestions
        if self.style.show_suggestions:
            for suggestion in report.suggestions:
                output = output + self.emit_suggestion(suggestion)

        output

    fn emit_header(report: Report) -> text:
        val c = self.colors
        val level_color = c.for_level(report.level)

        var header = "{level_color}{report.level.name()}{c.reset()}"

        if report.code.?:
            header = header + "[{report.code.unwrap()}]"

        header = header + ": {c.bold()}{report.message}{c.reset()}\n"

        if report.source_name.?:
            header = header + "{self.style.indent}[{report.source_name.unwrap()}]\n"

        header

    fn emit_location(location: SourceLocation, level: ReportLevel) -> text:
        val c = self.colors

        var output = "{self.style.indent}{c.bold_blue()}-->{c.reset()} {location.format_short()}\n"

        if self.style.show_source_context:
            output = output + self.emit_source_context(location, level)

        output

    fn emit_source_context(location: SourceLocation, level: ReportLevel) -> text:
        if not location.is_valid():
            return ""

        val source = match self.sources.get(location.file):
            case Some(s): s
            case None: return ""

        val lines = source.split("\n")
        if location.line <= 0 or location.line > lines.len():
            return ""

        val c = self.colors
        val line_num = location.line
        val line_str = lines[line_num - 1]

        var output = "{self.style.indent} {c.bold_blue()}|{c.reset()}\n"

        # Show context lines before
        if self.style.context_lines_before > 0:
            var start = (line_num - self.style.context_lines_before).max(1)
            while start < line_num:
                val ctx_line = lines[start - 1]
                output = output + "{c.bold_blue()}{start:4}{c.reset()} {c.bold_blue()}|{c.reset()} {ctx_line}\n"
                start = start + 1

        # Main line
        output = output + "{c.bold_blue()}{line_num:4}{c.reset()} {c.bold_blue()}|{c.reset()} {line_str}\n"

        # Underline
        val col = (location.column - 1).max(0)
        val len = if location.span.len() > 0:
            location.span.len().min(line_str.len() - col).max(1)
        else:
            1

        val spaces = " ".repeat(col)
        val underline = "^".repeat(len)
        val level_color = c.for_level(level)

        output = output + "{self.style.indent} {c.bold_blue()}|{c.reset()} {spaces}{level_color}{underline}{c.reset()}\n"

        # Show context lines after
        if self.style.context_lines_after > 0:
            var end_line = (line_num + self.style.context_lines_after).min(lines.len())
            var curr = line_num + 1
            while curr <= end_line:
                val ctx_line = lines[curr - 1]
                output = output + "{c.bold_blue()}{curr:4}{c.reset()} {c.bold_blue()}|{c.reset()} {ctx_line}\n"
                curr = curr + 1

        output

    fn emit_label(label: Label, level: ReportLevel) -> text:
        val c = self.colors

        var output = "{self.style.indent}{c.bold_blue()}-->{c.reset()} {label.location.format_short()}\n"

        if self.style.show_source_context and label.location.is_valid():
            val source = match self.sources.get(label.location.file):
                case Some(s): s
                case None: return output

            val lines = source.split("\n")
            if label.location.line > 0 and label.location.line <= lines.len():
                val line_num = label.location.line
                val line_str = lines[line_num - 1]

                output = output + "{self.style.indent} {c.bold_blue()}|{c.reset()}\n"
                output = output + "{c.bold_blue()}{line_num:4}{c.reset()} {c.bold_blue()}|{c.reset()} {line_str}\n"

                val col = (label.location.column - 1).max(0)
                val len = if label.location.span.len() > 0:
                    label.location.span.len().min(line_str.len() - col).max(1)
                else:
                    1

                val spaces = " ".repeat(col)
                val underline_char = if label.primary: "^" else: "-"
                val underline = underline_char.repeat(len)
                val label_color = if label.primary: c.for_level(level) else: c.bold_blue()

                output = output + "{self.style.indent} {c.bold_blue()}|{c.reset()} {spaces}{label_color}{underline}{c.reset()} {label.message}\n"

        output

    fn emit_note(note: text) -> text:
        val c = self.colors
        "{self.style.indent}{c.bold_cyan()}= note:{c.reset()} {note}\n"

    fn emit_help(help: text) -> text:
        val c = self.colors
        "{self.style.indent}{c.bold_green()}= help:{c.reset()} {help}\n"

    fn emit_suggestion(suggestion: Suggestion) -> text:
        val c = self.colors
        var output = "{self.style.indent}{c.bold_green()}= suggestion:{c.reset()} {suggestion.message}"
        output = output + " [{suggestion.confidence.name()}]\n"

        if not suggestion.new_text.is_empty():
            output = output + "{self.style.indent}  {c.green()}|{c.reset()} {suggestion.new_text}\n"

        output

    # ==========================================================================
    # Emit multiple reports
    # ==========================================================================

    fn emit_all(reports: [Report]) -> text:
        var output = ""
        for report in reports:
            output = output + self.emit(report) + "\n"
        output

    fn emit_collector(collector: ReportCollector) -> text:
        val displayable = collector.filter_displayable()
        var output = self.emit_all(displayable)

        # Summary
        val c = self.colors
        val err_count = collector.error_count()
        val warn_count = collector.warning_count()

        if err_count > 0 or warn_count > 0:
            output = output + "\n{c.bold()}Summary:{c.reset()} "
            if err_count > 0:
                output = output + "{c.bold_red()}{err_count} error(s){c.reset()}"
                if warn_count > 0:
                    output = output + ", "
            if warn_count > 0:
                output = output + "{c.bold_yellow()}{warn_count} warning(s){c.reset()}"
            output = output + "\n"

        output

    # ==========================================================================
    # Compact format
    # ==========================================================================

    fn emit_compact(report: Report) -> text:
        val loc_str = if report.location.?:
            "{report.location.unwrap().format_short()}: "
        else:
            ""

        val code_str = if report.code.?: "[{report.code.unwrap()}] " else: ""

        "{loc_str}{report.level.name()}: {code_str}{report.message}"

    fn emit_all_compact(reports: [Report]) -> text:
        var lines: [text] = []
        for report in reports:
            lines.push(self.emit_compact(report))
        lines.join("\n")
