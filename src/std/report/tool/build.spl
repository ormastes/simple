# Build ReportNL#NL# Reports for build system errors, warnings, and status.NL# Provides structured build diagnostics with timing and dependency info.NLNLimport ..levelNLimport ..locationNLimport ..reportNLuse std.string.{NL}NLNLexport BuildReport, BuildResult, BuildStatus, BuildError, BuildWarning, BuildStep, BuildSummaryNLNL# ANSI escape helperNLfn esc_char() -> text:NL    val code: u8 = 27NL    "{code as char}"NLNL# =============================================================================NL# BuildStatus: Possible states of a buildNL# =============================================================================NLNLenum BuildStatus:NL    Success         # Build completed successfullyNL    Failed          # Build failedNL    Cancelled       # Build was cancelledNL    Timeout         # Build timed outNL    InProgress      # Build is runningNLNLimpl BuildStatus:NL    fn name() -> text:NL        match self:NL            case BuildStatus.Success: "success"NL            case BuildStatus.Failed: "failed"NL            case BuildStatus.Cancelled: "cancelled"NL            case BuildStatus.Timeout: "timeout"NL            case BuildStatus.InProgress: "in_progress"NLNL    fn is_success() -> bool:NL        self == BuildStatus.SuccessNLNL    fn is_failure() -> bool:NL        match self:NL            case BuildStatus.Failed: trueNL            case BuildStatus.Timeout: trueNL            case _: falseNLNL    fn color() -> text:NL        val e = esc_char()NL        match self:NL            case BuildStatus.Success: "{e}[32m"NL            case BuildStatus.Failed: "{e}[31m"NL            case BuildStatus.Cancelled: "{e}[33m"NL            case BuildStatus.Timeout: "{e}[35m"NL            case BuildStatus.InProgress: "{e}[36m"NLNL# =============================================================================NL# BuildError: A build errorNL# =============================================================================NLNLclass BuildError:NL    message: textNL    code: text?                 # Error code (e.g., "E0001")NL    location: SourceLocation?NL    notes: [text]NL    suggestions: [text]NLNLimpl BuildError:NL    static fn create(message: text) -> BuildError:NL        BuildError(NL            message: message,NL            code: nil,NL            location: nil,NL            notes: [],NL            suggestions: []NL        )NLNL    static fn at(message: text, location: SourceLocation) -> BuildError:NL        BuildError(NL            message: message,NL            code: nil,NL            location: Some(location),NL            notes: [],NL            suggestions: []NL        )NLNL    fn with_code(code: text) -> BuildError:NL        BuildError(NL            message: self.message,NL            code: Some(code),NL            location: self.location,NL            notes: self.notes,NL            suggestions: self.suggestionsNL        )NLNL    fn with_note(note: text) -> BuildError:NL        BuildError(NL            message: self.message,NL            code: self.code,NL            location: self.location,NL            notes: self.notes + [note],NL            suggestions: self.suggestionsNL        )NLNL    fn with_suggestion(suggestion: text) -> BuildError:NL        BuildError(NL            message: self.message,NL            code: self.code,NL            location: self.location,NL            notes: self.notes,NL            suggestions: self.suggestions + [suggestion]NL        )NLNL    fn to_report() -> Report:NL        var report = Report.error(self.message)NL            .with_kind(ReportKind.BuildError)NL            .with_source("build")NLNL        if self.code.?:NL            report = report.with_code(self.code.unwrap())NLNL        if self.location.?:NL            report = report.with_location(self.location.unwrap())NLNL        for note in self.notes:NL            report = report.with_note(note)NLNL        for suggestion in self.suggestions:NL            report = report.with_help(suggestion)NLNL        reportNLNL    fn format(use_color: bool) -> text:NL        self.to_report().format("", use_color)NLNL    fn format_short() -> text:NL        val loc = if self.location.?:NL            "{self.location.unwrap().format_short()}: "NL        else:NL            ""NL        val code = if self.code.?: "[{self.code.unwrap()}] " else: ""NL        "{loc}error: {code}{self.message}"NLNL# =============================================================================NL# BuildWarning: A build warningNL# =============================================================================NLNLclass BuildWarning:NL    message: textNL    code: text?NL    location: SourceLocation?NL    notes: [text]NLNLimpl BuildWarning:NL    static fn create(message: text) -> BuildWarning:NL        BuildWarning(NL            message: message,NL            code: nil,NL            location: nil,NL            notes: []NL        )NLNL    static fn at(message: text, location: SourceLocation) -> BuildWarning:NL        BuildWarning(NL            message: message,NL            code: nil,NL            location: Some(location),NL            notes: []NL        )NLNL    fn with_code(code: text) -> BuildWarning:NL        BuildWarning(NL            message: self.message,NL            code: Some(code),NL            location: self.location,NL            notes: self.notesNL        )NLNL    fn with_note(note: text) -> BuildWarning:NL        BuildWarning(NL            message: self.message,NL            code: self.code,NL            location: self.location,NL            notes: self.notes + [note]NL        )NLNL    fn to_report() -> Report:NL        var report = Report.warning(self.message)NL            .with_kind(ReportKind.BuildError)NL            .with_source("build")NLNL        if self.code.?:NL            report = report.with_code(self.code.unwrap())NLNL        if self.location.?:NL            report = report.with_location(self.location.unwrap())NLNL        for note in self.notes:NL            report = report.with_note(note)NLNL        reportNLNL    fn format(use_color: bool) -> text:NL        self.to_report().format("", use_color)NLNL    fn format_short() -> text:NL        val loc = if self.location.?:NL            "{self.location.unwrap().format_short()}: "NL        else:NL            ""NL        val code = if self.code.?: "[{self.code.unwrap()}] " else: ""NL        "{loc}warning: {code}{self.message}"NLNL# =============================================================================NL# BuildStep: A step in the build processNL# =============================================================================NLNLclass BuildStep:NL    name: text                  # Step name (e.g., "compile", "link")NL    target: text?               # Target being builtNL    status: BuildStatusNL    duration_ms: i64NL    errors: [BuildError]NL    warnings: [BuildWarning]NL    output: text?               # Captured outputNLNLimpl BuildStep:NL    static fn named(name: text) -> BuildStep:NL        BuildStep(NL            name: name,NL            target: nil,NL            status: BuildStatus.InProgress,NL            duration_ms: 0,NL            errors: [],NL            warnings: [],NL            output: nilNL        )NLNL    static fn for_target(name: text, target: text) -> BuildStep:NL        BuildStep(NL            name: name,NL            target: Some(target),NL            status: BuildStatus.InProgress,NL            duration_ms: 0,NL            errors: [],NL            warnings: [],NL            output: nilNL        )NLNL    me complete(status: BuildStatus, duration_ms: i64):NL        self.status = statusNL        self.duration_ms = duration_msNLNL    me add_error(error: BuildError):NL        self.errors.push(error)NLNL    me add_warning(warning: BuildWarning):NL        self.warnings.push(warning)NLNL    me set_output(output: text):NL        self.output = Some(output)NLNL    fn is_success() -> bool:NL        self.status.is_success()NLNL    fn has_errors() -> bool:NL        not self.errors.is_empty()NLNL    fn has_warnings() -> bool:NL        not self.warnings.is_empty()NLNL    fn error_count() -> i64:NL        self.errors.len()NLNL    fn warning_count() -> i64:NL        self.warnings.len()NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val status_color = if use_color: self.status.color() else: ""NL        val bold = if use_color: "{e}[1m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{bold}{self.name}{reset}"NL        if self.target.?:NL            output = output + " ({self.target.unwrap()})"NL        output = output + ": {status_color}{self.status.name()}{reset}"NL        output = output + " ({self.duration_ms}ms)"NLNL        if self.has_errors():NL            output = output + "\n"NL            for error in self.errors:NL                output = output + "  " + error.format_short() + "\n"NLNL        if self.has_warnings():NL            for warning in self.warnings:NL                output = output + "  " + warning.format_short() + "\n"NLNL        outputNLNL# =============================================================================NL# BuildResult: Result of a complete buildNL# =============================================================================NLNLclass BuildResult:NL    status: BuildStatusNL    steps: [BuildStep]NL    duration_ms: i64NL    errors: [BuildError]        # Top-level errorsNL    warnings: [BuildWarning]    # Top-level warningsNL    artifacts: [text]           # Produced artifacts (files)NLNLimpl BuildResult:NL    static fn success(duration_ms: i64) -> BuildResult:NL        BuildResult(NL            status: BuildStatus.Success,NL            steps: [],NL            duration_ms: duration_ms,NL            errors: [],NL            warnings: [],NL            artifacts: []NL        )NLNL    static fn failed(duration_ms: i64) -> BuildResult:NL        BuildResult(NL            status: BuildStatus.Failed,NL            steps: [],NL            duration_ms: duration_ms,NL            errors: [],NL            warnings: [],NL            artifacts: []NL        )NLNL    me add_step(step: BuildStep):NL        self.steps.push(step)NL        if step.status.is_failure() and self.status == BuildStatus.Success:NL            self.status = BuildStatus.FailedNLNL    me add_error(error: BuildError):NL        self.errors.push(error)NL        self.status = BuildStatus.FailedNLNL    me add_warning(warning: BuildWarning):NL        self.warnings.push(warning)NLNL    me add_artifact(path: text):NL        self.artifacts.push(path)NLNL    fn is_success() -> bool:NL        self.status.is_success()NLNL    fn total_errors() -> i64:NL        var count = self.errors.len()NL        for step in self.steps:NL            count = count + step.error_count()NL        countNLNL    fn total_warnings() -> i64:NL        var count = self.warnings.len()NL        for step in self.steps:NL            count = count + step.warning_count()NL        countNLNL    fn all_errors() -> [BuildError]:NL        var all = self.errorsNL        for step in self.steps:NL            for error in step.errors:NL                all.push(error)NL        allNLNL    fn all_warnings() -> [BuildWarning]:NL        var all = self.warningsNL        for step in self.steps:NL            for warning in step.warnings:NL                all.push(warning)NL        allNLNL    fn to_report() -> Report:NL        val level = if self.status.is_success():NL            ReportLevel.InfoNL        else:NL            ReportLevel.ErrorNLNL        val msg = "Build {self.status.name()} in {self.duration_ms}ms"NLNL        var report = match level:NL            case ReportLevel.Error: Report.error(msg)NL            case _: Report.info(msg)NLNL        report = report.with_kind(ReportKind.BuildError).with_source("build")NLNL        if self.total_errors() > 0:NL            report = report.with_note("{self.total_errors()} error(s)")NL        if self.total_warnings() > 0:NL            report = report.with_note("{self.total_warnings()} warning(s)")NL        if not self.artifacts.is_empty():NL            report = report.with_note("{self.artifacts.len()} artifact(s) produced")NLNL        reportNLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val bold = if use_color: "{e}[1m" else: ""NL        val status_color = if use_color: self.status.color() else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = ""NLNL        # Errors firstNL        if self.total_errors() > 0:NL            for error in self.all_errors():NL                output = output + error.format(use_color) + "\n"NLNL        # WarningsNL        if self.total_warnings() > 0:NL            for warning in self.all_warnings():NL                output = output + warning.format(use_color) + "\n"NLNL        # SummaryNL        output = output + "{bold}Build {status_color}{self.status.name()}{reset}"NL        output = output + " ({self.duration_ms}ms)\n"NLNL        if self.total_errors() > 0:NL            output = output + "  {self.total_errors()} error(s)\n"NL        if self.total_warnings() > 0:NL            output = output + "  {self.total_warnings()} warning(s)\n"NL        if not self.artifacts.is_empty():NL            output = output + "  Artifacts:\n"NL            for artifact in self.artifacts:NL                output = output + "    {artifact}\n"NLNL        outputNLNL# =============================================================================NL# BuildSummary: Summary across multiple buildsNL# =============================================================================NLNLclass BuildSummary:NL    results: [BuildResult]NL    total_duration_ms: i64NL    total_errors: i64NL    total_warnings: i64NLNLimpl BuildSummary:NL    static fn empty() -> BuildSummary:NL        BuildSummary(NL            results: [],NL            total_duration_ms: 0,NL            total_errors: 0,NL            total_warnings: 0NL        )NLNL    me add_result(result: BuildResult):NL        self.results.push(result)NL        self.total_duration_ms = self.total_duration_ms + result.duration_msNL        self.total_errors = self.total_errors + result.total_errors()NL        self.total_warnings = self.total_warnings + result.total_warnings()NLNL    fn has_failures() -> bool:NL        self.results.any(\r: r.status.is_failure())NLNL    fn all_succeeded() -> bool:NL        self.results.all(\r: r.status.is_success())NLNL    fn to_report() -> Report:NL        val level = if self.has_failures():NL            ReportLevel.ErrorNL        else:NL            ReportLevel.InfoNLNL        val successful = self.results.filter(\r: r.is_success()).len()NL        val msg = "{successful}/{self.results.len()} builds succeeded"NLNL        var report = match level:NL            case ReportLevel.Error: Report.error(msg)NL            case _: Report.info(msg)NLNL        report = report.with_source("build")NLNL        if self.total_errors > 0:NL            report = report.with_note("{self.total_errors} total error(s)")NL        if self.total_warnings > 0:NL            report = report.with_note("{self.total_warnings} total warning(s)")NLNL        reportNLNL    fn format(use_color: bool) -> text:NL        var output = ""NL        for result in self.results:NL            output = output + result.format(use_color) + "\n"NL        outputNLNL# =============================================================================NL# BuildReport: Unified build report (alias for convenience)NL# =============================================================================NLNLclass BuildReport:NL    result: BuildResultNLNLimpl BuildReport:NL    static fn from_result(result: BuildResult) -> BuildReport:NL        BuildReport(result: result)NLNL    fn is_success() -> bool:NL        self.result.is_success()NLNL    fn to_report() -> Report:NL        self.result.to_report()NLNL    fn format(use_color: bool) -> text:NL        self.result.format(use_color)NL