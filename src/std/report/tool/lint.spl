# Lint Report
#
# Reports for lint rule violations with auto-fix support.
# Integrates with EasyFix for machine-applicable fixes.

import ..level
import ..location
import ..report
import ..compiler.easy_fix

export LintReport, LintRule, LintCategory, LintSeverity, LintResult, LintSummary

# =============================================================================
# LintCategory: Categories of lint rules
# =============================================================================

enum LintCategory:
    Safety          # Memory safety, null checks
    Correctness     # Logic errors, type mismatches
    Style           # Code style recommendations
    Performance     # Performance issues
    Complexity      # Code complexity warnings
    Deprecated      # Deprecated feature usage
    Documentation   # Missing documentation
    Testing         # Test-related issues
    Security        # Security vulnerabilities

impl LintCategory:
    fn name() -> text:
        match self:
            case LintCategory.Safety: "safety"
            case LintCategory.Correctness: "correctness"
            case LintCategory.Style: "style"
            case LintCategory.Performance: "performance"
            case LintCategory.Complexity: "complexity"
            case LintCategory.Deprecated: "deprecated"
            case LintCategory.Documentation: "documentation"
            case LintCategory.Testing: "testing"
            case LintCategory.Security: "security"

    fn prefix() -> text:
        match self:
            case LintCategory.Safety: "S"
            case LintCategory.Correctness: "C"
            case LintCategory.Style: "ST"
            case LintCategory.Performance: "P"
            case LintCategory.Complexity: "CX"
            case LintCategory.Deprecated: "D"
            case LintCategory.Documentation: "DOC"
            case LintCategory.Testing: "T"
            case LintCategory.Security: "SEC"

# =============================================================================
# LintSeverity: How the lint should be treated
# =============================================================================

enum LintSeverity:
    Allow       # Info only (no output by default)
    Warn        # Warning (does not fail)
    Deny        # Error (causes failure)

impl LintSeverity:
    fn name() -> text:
        match self:
            case LintSeverity.Allow: "allow"
            case LintSeverity.Warn: "warn"
            case LintSeverity.Deny: "deny"

    fn to_report_level() -> ReportLevel:
        match self:
            case LintSeverity.Allow: ReportLevel.Info
            case LintSeverity.Warn: ReportLevel.Warning
            case LintSeverity.Deny: ReportLevel.Error

    fn is_failure() -> bool:
        self == LintSeverity.Deny

# =============================================================================
# LintRule: Definition of a lint rule
# =============================================================================

struct LintRule:
    id: text                    # Rule ID (e.g., "L:print_in_test_spec")
    name: text                  # Human-readable name
    category: LintCategory
    default_severity: LintSeverity
    description: text           # What the rule checks
    rationale: text?            # Why this rule exists
    has_auto_fix: bool          # Whether auto-fix is available

impl LintRule:
    static fn create(id: text, name: text, category: LintCategory, severity: LintSeverity, description: text) -> LintRule:
        LintRule(
            id: id,
            name: name,
            category: category,
            default_severity: severity,
            description: description,
            rationale: None,
            has_auto_fix: false
        )

    fn with_rationale(rationale: text) -> LintRule:
        LintRule(
            id: self.id,
            name: self.name,
            category: self.category,
            default_severity: self.default_severity,
            description: self.description,
            rationale: Some(rationale),
            has_auto_fix: self.has_auto_fix
        )

    fn with_auto_fix() -> LintRule:
        LintRule(
            id: self.id,
            name: self.name,
            category: self.category,
            default_severity: self.default_severity,
            description: self.description,
            rationale: self.rationale,
            has_auto_fix: true
        )

    fn format() -> text:
        var output = "[{self.id}] {self.name}\n"
        output = output + "  Category: {self.category.name()}\n"
        output = output + "  Severity: {self.default_severity.name()}\n"
        output = output + "  {self.description}"
        if self.has_auto_fix:
            output = output + " (auto-fix available)"
        output

# =============================================================================
# LintReport: Single lint violation report
# =============================================================================

class LintReport:
    rule: LintRule
    severity: LintSeverity      # May be overridden from default
    message: text
    location: SourceLocation
    easy_fix: EasyFixReport?
    notes: [text]
    related_locations: [(SourceLocation, text)]

impl LintReport:
    # Create a lint report
    static fn create(rule: LintRule, message: text, location: SourceLocation) -> LintReport:
        LintReport(
            rule: rule,
            severity: rule.default_severity,
            message: message,
            location: location,
            easy_fix: None,
            notes: [],
            related_locations: []
        )

    # Quick factory for common lints
    static fn warning(id: text, message: text, location: SourceLocation) -> LintReport:
        val rule = LintRule.create(id, id, LintCategory.Style, LintSeverity.Warn, message)
        LintReport.create(rule, message, location)

    static fn error(id: text, message: text, location: SourceLocation) -> LintReport:
        val rule = LintRule.create(id, id, LintCategory.Correctness, LintSeverity.Deny, message)
        LintReport.create(rule, message, location)

    # ==========================================================================
    # Builder methods
    # ==========================================================================

    fn with_severity(severity: LintSeverity) -> LintReport:
        LintReport(
            rule: self.rule,
            severity: severity,
            message: self.message,
            location: self.location,
            easy_fix: self.easy_fix,
            notes: self.notes,
            related_locations: self.related_locations
        )

    fn with_easy_fix(fix: EasyFixReport) -> LintReport:
        LintReport(
            rule: self.rule,
            severity: self.severity,
            message: self.message,
            location: self.location,
            easy_fix: Some(fix),
            notes: self.notes,
            related_locations: self.related_locations
        )

    fn with_note(note: text) -> LintReport:
        LintReport(
            rule: self.rule,
            severity: self.severity,
            message: self.message,
            location: self.location,
            easy_fix: self.easy_fix,
            notes: self.notes + [note],
            related_locations: self.related_locations
        )

    fn with_related(location: SourceLocation, message: text) -> LintReport:
        LintReport(
            rule: self.rule,
            severity: self.severity,
            message: self.message,
            location: self.location,
            easy_fix: self.easy_fix,
            notes: self.notes,
            related_locations: self.related_locations + [(location, message)]
        )

    # ==========================================================================
    # Accessors
    # ==========================================================================

    fn is_error() -> bool:
        self.severity == LintSeverity.Deny

    fn is_warning() -> bool:
        self.severity == LintSeverity.Warn

    fn has_fix() -> bool:
        self.easy_fix.?

    fn code() -> text:
        self.rule.id

    fn file() -> text:
        self.location.file

    fn line() -> i64:
        self.location.line

    # ==========================================================================
    # Conversion to Report
    # ==========================================================================

    fn to_report() -> Report:
        var report = match self.severity:
            case LintSeverity.Deny: Report.error(self.message)
            case LintSeverity.Warn: Report.warning(self.message)
            case LintSeverity.Allow: Report.info(self.message)

        report = report
            .with_code(self.rule.id)
            .with_kind(ReportKind.LintWarning)
            .with_location(self.location)
            .with_source("lint")

        for note in self.notes:
            report = report.with_note(note)

        for rel in self.related_locations:
            report = report.with_secondary_label(rel.0, rel.1)

        if self.easy_fix.?:
            val fix = self.easy_fix.unwrap()
            for rep in fix.replacements:
                val suggestion = Suggestion.with_confidence(
                    rep.to_location(),
                    rep.new_text,
                    fix.description,
                    fix.confidence
                )
                report = report.with_suggestion(suggestion)

        report

    # ==========================================================================
    # Formatting
    # ==========================================================================

    fn format(use_color: bool) -> text:
        self.to_report().format("", use_color)

    fn format_short() -> text:
        val level = match self.severity:
            case LintSeverity.Deny: "error"
            case LintSeverity.Warn: "warning"
            case LintSeverity.Allow: "info"
        "{self.location.format_short()}: {level}[{self.rule.id}]: {self.message}"

# =============================================================================
# LintResult: Collection of lint reports for a file
# =============================================================================

class LintResult:
    file: text
    reports: [LintReport]
    duration_ms: i64

impl LintResult:
    static fn for_file(file: text) -> LintResult:
        LintResult(file: file, reports: [], duration_ms: 0)

    me add(report: LintReport):
        self.reports.push(report)

    me set_duration(duration_ms: i64):
        self.duration_ms = duration_ms

    fn count() -> i64:
        self.reports.len()

    fn error_count() -> i64:
        self.reports.filter(\r: r.is_error()).len()

    fn warning_count() -> i64:
        self.reports.filter(\r: r.is_warning()).len()

    fn has_errors() -> bool:
        self.reports.any(\r: r.is_error())

    fn has_warnings() -> bool:
        self.reports.any(\r: r.is_warning())

    fn fixable_count() -> i64:
        self.reports.filter(\r: r.has_fix()).len()

    fn get_fixes() -> [EasyFixReport]:
        var fixes: [EasyFixReport] = []
        for report in self.reports:
            if report.easy_fix.?:
                fixes.push(report.easy_fix.unwrap())
        fixes

    fn format(use_color: bool) -> text:
        var output = ""
        for report in self.reports:
            output = output + report.format(use_color) + "\n"
        output

    fn format_compact() -> text:
        var lines: [text] = []
        for report in self.reports:
            lines.push(report.format_short())
        lines.join("\n")

# =============================================================================
# LintSummary: Summary of lint results across multiple files
# =============================================================================

class LintSummary:
    results: [LintResult]
    total_files: i64
    total_errors: i64
    total_warnings: i64
    total_fixable: i64
    duration_ms: i64

impl LintSummary:
    static fn empty() -> LintSummary:
        LintSummary(
            results: [],
            total_files: 0,
            total_errors: 0,
            total_warnings: 0,
            total_fixable: 0,
            duration_ms: 0
        )

    me add_result(result: LintResult):
        self.results.push(result)
        self.total_files = self.total_files + 1
        self.total_errors = self.total_errors + result.error_count()
        self.total_warnings = self.total_warnings + result.warning_count()
        self.total_fixable = self.total_fixable + result.fixable_count()
        self.duration_ms = self.duration_ms + result.duration_ms

    fn has_errors() -> bool:
        self.total_errors > 0

    fn has_warnings() -> bool:
        self.total_warnings > 0

    fn is_clean() -> bool:
        self.total_errors == 0 and self.total_warnings == 0

    fn total_issues() -> i64:
        self.total_errors + self.total_warnings

    fn all_reports() -> [LintReport]:
        var all: [LintReport] = []
        for result in self.results:
            for report in result.reports:
                all.push(report)
        all

    fn all_fixes() -> [EasyFixReport]:
        var fixes: [EasyFixReport] = []
        for result in self.results:
            for fix in result.get_fixes():
                fixes.push(fix)
        fixes

    fn to_report() -> Report:
        val level = if self.has_errors():
            ReportLevel.Error
        elif self.has_warnings():
            ReportLevel.Warning
        else:
            ReportLevel.Info

        val msg = if self.is_clean():
            "No lint issues found in {self.total_files} file(s)"
        else:
            "Found {self.total_issues()} issue(s) in {self.total_files} file(s)"

        var report = match level:
            case ReportLevel.Error: Report.error(msg)
            case ReportLevel.Warning: Report.warning(msg)
            case _: Report.info(msg)

        report = report.with_source("lint")

        if self.total_errors > 0:
            report = report.with_note("{self.total_errors} error(s)")
        if self.total_warnings > 0:
            report = report.with_note("{self.total_warnings} warning(s)")
        if self.total_fixable > 0:
            report = report.with_help("{self.total_fixable} issue(s) can be auto-fixed")

        report

    fn format(use_color: bool) -> text:
        val bold = if use_color: "\x1b[1m" else: ""
        val green = if use_color: "\x1b[32m" else: ""
        val red = if use_color: "\x1b[31m" else: ""
        val yellow = if use_color: "\x1b[33m" else: ""
        val reset = if use_color: "\x1b[0m" else: ""

        var output = ""

        # Individual results
        for result in self.results:
            if result.count() > 0:
                output = output + result.format(use_color)

        # Summary
        output = output + "\n{bold}Lint Summary:{reset}\n"
        output = output + "  Files checked: {self.total_files}\n"

        if self.total_errors > 0:
            output = output + "  {red}Errors: {self.total_errors}{reset}\n"
        if self.total_warnings > 0:
            output = output + "  {yellow}Warnings: {self.total_warnings}{reset}\n"
        if self.total_fixable > 0:
            output = output + "  Auto-fixable: {self.total_fixable}\n"

        if self.is_clean():
            output = output + "  {green}No issues found!{reset}\n"

        output = output + "  Duration: {self.duration_ms}ms\n"

        output
