# Lint ReportNL#NL# Reports for lint rule violations with auto-fix support.NL# Integrates with EasyFix for machine-applicable fixes.NLNLimport ..levelNLimport ..locationNLimport ..reportNLimport ..compiler.easy_fixNLuse std.string.{NL}NLNLexport LintReport, LintRule, LintCategory, LintSeverity, LintResult, LintSummaryNLNL# ANSI escape helperNLfn esc_char() -> text:NL    val code: u8 = 27NL    "{code as char}"NLNL# =============================================================================NL# LintCategory: Categories of lint rulesNL# =============================================================================NLNLenum LintCategory:NL    Safety          # Memory safety, null checksNL    Correctness     # Logic errors, type mismatchesNL    Style           # Code style recommendationsNL    Performance     # Performance issuesNL    Complexity      # Code complexity warningsNL    Deprecated      # Deprecated feature usageNL    Documentation   # Missing documentationNL    Testing         # Test-related issuesNL    Security        # Security vulnerabilitiesNLNLimpl LintCategory:NL    fn name() -> text:NL        match self:NL            case LintCategory.Safety: "safety"NL            case LintCategory.Correctness: "correctness"NL            case LintCategory.Style: "style"NL            case LintCategory.Performance: "performance"NL            case LintCategory.Complexity: "complexity"NL            case LintCategory.Deprecated: "deprecated"NL            case LintCategory.Documentation: "documentation"NL            case LintCategory.Testing: "testing"NL            case LintCategory.Security: "security"NLNL    fn prefix() -> text:NL        match self:NL            case LintCategory.Safety: "S"NL            case LintCategory.Correctness: "C"NL            case LintCategory.Style: "ST"NL            case LintCategory.Performance: "P"NL            case LintCategory.Complexity: "CX"NL            case LintCategory.Deprecated: "D"NL            case LintCategory.Documentation: "DOC"NL            case LintCategory.Testing: "T"NL            case LintCategory.Security: "SEC"NLNL# =============================================================================NL# LintSeverity: How the lint should be treatedNL# =============================================================================NLNLenum LintSeverity:NL    Allow       # Info only (no output by default)NL    Warn        # Warning (does not fail)NL    Deny        # Error (causes failure)NLNLimpl LintSeverity:NL    fn name() -> text:NL        match self:NL            case LintSeverity.Allow: "allow"NL            case LintSeverity.Warn: "warn"NL            case LintSeverity.Deny: "deny"NLNL    fn to_report_level() -> ReportLevel:NL        match self:NL            case LintSeverity.Allow: ReportLevel.InfoNL            case LintSeverity.Warn: ReportLevel.WarningNL            case LintSeverity.Deny: ReportLevel.ErrorNLNL    fn is_failure() -> bool:NL        self == LintSeverity.DenyNLNL# =============================================================================NL# LintRule: Definition of a lint ruleNL# =============================================================================NLNLstruct LintRule:NL    id: text                    # Rule ID (e.g., "L:print_in_test_spec")NL    name: text                  # Human-readable nameNL    category: LintCategoryNL    default_severity: LintSeverityNL    description: text           # What the rule checksNL    rationale: text?            # Why this rule existsNL    has_auto_fix: bool          # Whether auto-fix is availableNLNLimpl LintRule:NL    static fn create(id: text, name: text, category: LintCategory, severity: LintSeverity, description: text) -> LintRule:NL        LintRule(NL            id: id,NL            name: name,NL            category: category,NL            default_severity: severity,NL            description: description,NL            rationale: nil,NL            has_auto_fix: falseNL        )NLNL    fn with_rationale(rationale: text) -> LintRule:NL        LintRule(NL            id: self.id,NL            name: self.name,NL            category: self.category,NL            default_severity: self.default_severity,NL            description: self.description,NL            rationale: Some(rationale),NL            has_auto_fix: self.has_auto_fixNL        )NLNL    fn with_auto_fix() -> LintRule:NL        LintRule(NL            id: self.id,NL            name: self.name,NL            category: self.category,NL            default_severity: self.default_severity,NL            description: self.description,NL            rationale: self.rationale,NL            has_auto_fix: trueNL        )NLNL    fn format() -> text:NL        var output = "[{self.id}] {self.name}\n"NL        output = output + "  Category: {self.category.name()}\n"NL        output = output + "  Severity: {self.default_severity.name()}\n"NL        output = output + "  {self.description}"NL        if self.has_auto_fix:NL            output = output + " (auto-fix available)"NL        outputNLNL# =============================================================================NL# LintReport: Single lint violation reportNL# =============================================================================NLNLclass LintReport:NL    rule: LintRuleNL    severity: LintSeverity      # May be overridden from defaultNL    message: textNL    location: SourceLocationNL    easy_fix: EasyFixReport?NL    notes: [text]NL    related_locations: [(SourceLocation, text)]NLNLimpl LintReport:NL    # Create a lint reportNL    static fn create(rule: LintRule, message: text, location: SourceLocation) -> LintReport:NL        LintReport(NL            rule: rule,NL            severity: rule.default_severity,NL            message: message,NL            location: location,NL            easy_fix: nil,NL            notes: [],NL            related_locations: []NL        )NLNL    # Quick factory for common lintsNL    static fn warning(id: text, message: text, location: SourceLocation) -> LintReport:NL        val rule = LintRule.create(id, id, LintCategory.Style, LintSeverity.Warn, message)NL        LintReport.create(rule, message, location)NLNL    static fn error(id: text, message: text, location: SourceLocation) -> LintReport:NL        val rule = LintRule.create(id, id, LintCategory.Correctness, LintSeverity.Deny, message)NL        LintReport.create(rule, message, location)NLNL    # ==========================================================================NL    # Builder methodsNL    # ==========================================================================NLNL    fn with_severity(severity: LintSeverity) -> LintReport:NL        LintReport(NL            rule: self.rule,NL            severity: severity,NL            message: self.message,NL            location: self.location,NL            easy_fix: self.easy_fix,NL            notes: self.notes,NL            related_locations: self.related_locationsNL        )NLNL    fn with_easy_fix(fix: EasyFixReport) -> LintReport:NL        LintReport(NL            rule: self.rule,NL            severity: self.severity,NL            message: self.message,NL            location: self.location,NL            easy_fix: Some(fix),NL            notes: self.notes,NL            related_locations: self.related_locationsNL        )NLNL    fn with_note(note: text) -> LintReport:NL        LintReport(NL            rule: self.rule,NL            severity: self.severity,NL            message: self.message,NL            location: self.location,NL            easy_fix: self.easy_fix,NL            notes: self.notes + [note],NL            related_locations: self.related_locationsNL        )NLNL    fn with_related(location: SourceLocation, message: text) -> LintReport:NL        LintReport(NL            rule: self.rule,NL            severity: self.severity,NL            message: self.message,NL            location: self.location,NL            easy_fix: self.easy_fix,NL            notes: self.notes,NL            related_locations: self.related_locations + [(location, message)]NL        )NLNL    # ==========================================================================NL    # AccessorsNL    # ==========================================================================NLNL    fn is_error() -> bool:NL        self.severity == LintSeverity.DenyNLNL    fn is_warning() -> bool:NL        self.severity == LintSeverity.WarnNLNL    fn has_fix() -> bool:NL        self.easy_fix.?NLNL    fn code() -> text:NL        self.rule.idNLNL    fn file() -> text:NL        self.location.fileNLNL    fn line() -> i64:NL        self.location.lineNLNL    # ==========================================================================NL    # Conversion to ReportNL    # ==========================================================================NLNL    fn to_report() -> Report:NL        var report = match self.severity:NL            case LintSeverity.Deny: Report.error(self.message)NL            case LintSeverity.Warn: Report.warning(self.message)NL            case LintSeverity.Allow: Report.info(self.message)NLNL        report = reportNL            .with_code(self.rule.id)NL            .with_kind(ReportKind.LintWarning)NL            .with_location(self.location)NL            .with_source("lint")NLNL        for note in self.notes:NL            report = report.with_note(note)NLNL        for rel in self.related_locations:NL            report = report.with_secondary_label(rel.0, rel.1)NLNL        if self.easy_fix.?:NL            val fix = self.easy_fix.unwrap()NL            for rep in fix.replacements:NL                val suggestion = Suggestion.with_confidence(NL                    rep.to_location(),NL                    rep.new_text,NL                    fix.description,NL                    fix.confidenceNL                )NL                report = report.with_suggestion(suggestion)NLNL        reportNLNL    # ==========================================================================NL    # FormattingNL    # ==========================================================================NLNL    fn format(use_color: bool) -> text:NL        self.to_report().format("", use_color)NLNL    fn format_short() -> text:NL        val level = match self.severity:NL            case LintSeverity.Deny: "error"NL            case LintSeverity.Warn: "warning"NL            case LintSeverity.Allow: "info"NL        "{self.location.format_short()}: {level}[{self.rule.id}]: {self.message}"NLNL# =============================================================================NL# LintResult: Collection of lint reports for a fileNL# =============================================================================NLNLclass LintResult:NL    file: textNL    reports: [LintReport]NL    duration_ms: i64NLNLimpl LintResult:NL    static fn for_file(file: text) -> LintResult:NL        LintResult(file: file, reports: [], duration_ms: 0)NLNL    me add(report: LintReport):NL        self.reports.push(report)NLNL    me set_duration(duration_ms: i64):NL        self.duration_ms = duration_msNLNL    fn count() -> i64:NL        self.reports.len()NLNL    fn error_count() -> i64:NL        self.reports.filter(\r: r.is_error()).len()NLNL    fn warning_count() -> i64:NL        self.reports.filter(\r: r.is_warning()).len()NLNL    fn has_errors() -> bool:NL        self.reports.any(\r: r.is_error())NLNL    fn has_warnings() -> bool:NL        self.reports.any(\r: r.is_warning())NLNL    fn fixable_count() -> i64:NL        self.reports.filter(\r: r.has_fix()).len()NLNL    fn get_fixes() -> [EasyFixReport]:NL        var fixes: [EasyFixReport] = []NL        for report in self.reports:NL            if report.easy_fix.?:NL                fixes.push(report.easy_fix.unwrap())NL        fixesNLNL    fn format(use_color: bool) -> text:NL        var output = ""NL        for report in self.reports:NL            output = output + report.format(use_color) + "\n"NL        outputNLNL    fn format_compact() -> text:NL        var lines: [text] = []NL        for report in self.reports:NL            lines.push(report.format_short())NL        lines.join("\n")NLNL# =============================================================================NL# LintSummary: Summary of lint results across multiple filesNL# =============================================================================NLNLclass LintSummary:NL    results: [LintResult]NL    total_files: i64NL    total_errors: i64NL    total_warnings: i64NL    total_fixable: i64NL    duration_ms: i64NLNLimpl LintSummary:NL    static fn empty() -> LintSummary:NL        LintSummary(NL            results: [],NL            total_files: 0,NL            total_errors: 0,NL            total_warnings: 0,NL            total_fixable: 0,NL            duration_ms: 0NL        )NLNL    me add_result(result: LintResult):NL        self.results.push(result)NL        self.total_files = self.total_files + 1NL        self.total_errors = self.total_errors + result.error_count()NL        self.total_warnings = self.total_warnings + result.warning_count()NL        self.total_fixable = self.total_fixable + result.fixable_count()NL        self.duration_ms = self.duration_ms + result.duration_msNLNL    fn has_errors() -> bool:NL        self.total_errors > 0NLNL    fn has_warnings() -> bool:NL        self.total_warnings > 0NLNL    fn is_clean() -> bool:NL        self.total_errors == 0 and self.total_warnings == 0NLNL    fn total_issues() -> i64:NL        self.total_errors + self.total_warningsNLNL    fn all_reports() -> [LintReport]:NL        var all: [LintReport] = []NL        for result in self.results:NL            for report in result.reports:NL                all.push(report)NL        allNLNL    fn all_fixes() -> [EasyFixReport]:NL        var fixes: [EasyFixReport] = []NL        for result in self.results:NL            for fix in result.get_fixes():NL                fixes.push(fix)NL        fixesNLNL    fn to_report() -> Report:NL        val level = if self.has_errors():NL            ReportLevel.ErrorNL        elif self.has_warnings():NL            ReportLevel.WarningNL        else:NL            ReportLevel.InfoNLNL        val msg = if self.is_clean():NL            "No lint issues found in {self.total_files} file(s)"NL        else:NL            "Found {self.total_issues()} issue(s) in {self.total_files} file(s)"NLNL        var report = match level:NL            case ReportLevel.Error: Report.error(msg)NL            case ReportLevel.Warning: Report.warning(msg)NL            case _: Report.info(msg)NLNL        report = report.with_source("lint")NLNL        if self.total_errors > 0:NL            report = report.with_note("{self.total_errors} error(s)")NL        if self.total_warnings > 0:NL            report = report.with_note("{self.total_warnings} warning(s)")NL        if self.total_fixable > 0:NL            report = report.with_help("{self.total_fixable} issue(s) can be auto-fixed")NLNL        reportNLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val bold = if use_color: "{e}[1m" else: ""NL        val green = if use_color: "{e}[32m" else: ""NL        val red = if use_color: "{e}[31m" else: ""NL        val yellow = if use_color: "{e}[33m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = ""NLNL        # Individual resultsNL        for result in self.results:NL            if result.count() > 0:NL                output = output + result.format(use_color)NLNL        # SummaryNL        output = output + "\n{bold}Lint Summary:{reset}\n"NL        output = output + "  Files checked: {self.total_files}\n"NLNL        if self.total_errors > 0:NL            output = output + "  {red}Errors: {self.total_errors}{reset}\n"NL        if self.total_warnings > 0:NL            output = output + "  {yellow}Warnings: {self.total_warnings}{reset}\n"NL        if self.total_fixable > 0:NL            output = output + "  Auto-fixable: {self.total_fixable}\n"NLNL        if self.is_clean():NL            output = output + "  {green}No issues found!{reset}\n"NLNL        output = output + "  Duration: {self.duration_ms}ms\n"NLNL        outputNL