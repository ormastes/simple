# Source Location
#
# Unified source location types for all reports in the Simple language.
# Provides byte-level precision with line/column for display.

export Span, SourceLocation, Label

# =============================================================================
# Span: Byte range in source code
# =============================================================================

struct Span:
    start: i64      # Start byte offset (0-based)
    end: i64        # End byte offset (exclusive)

impl Span:
    # Create a span from start to end
    static fn from_range(start: i64, end: i64) -> Span:
        Span(start: start, end: end)

    # Create a zero-length span at a position
    static fn at(pos: i64) -> Span:
        Span(start: pos, end: pos)

    # Create an empty span
    static fn empty() -> Span:
        Span(start: 0, end: 0)

    # Get the length of this span
    fn len() -> i64:
        self.end - self.start

    # Check if this span is empty
    fn is_empty() -> bool:
        self.start >= self.end

    # Extend this span to include another
    fn extend_to(other: Span) -> Span:
        Span(
            start: self.start.min(other.start),
            end: self.end.max(other.end)
        )

    # Check if this span contains a position
    fn contains_pos(pos: i64) -> bool:
        pos >= self.start and pos < self.end

    # Check if this span overlaps with another
    fn overlaps(other: Span) -> bool:
        self.start < other.end and other.start < self.end

    # Get the text this span covers
    fn extract(source: text) -> text:
        if self.start >= 0 and self.end <= source.len():
            source.slice(self.start, self.end)
        else:
            ""

# =============================================================================
# SourceLocation: Full source location with file, line, column
# =============================================================================

struct SourceLocation:
    file: text              # File path
    span: Span              # Byte range
    line: i64               # Start line (1-based)
    column: i64             # Start column (1-based)
    end_line: i64           # End line (1-based), 0 if same as start
    end_column: i64         # End column (1-based), 0 if same as start

impl SourceLocation:
    # Create a location at a specific position
    static fn at(file: text, line: i64, column: i64) -> SourceLocation:
        SourceLocation(
            file: file,
            span: Span.at(0),
            line: line,
            column: column,
            end_line: 0,
            end_column: 0
        )

    # Create a location with full span information
    static fn from_span(file: text, span: Span, line: i64, column: i64, end_line: i64, end_column: i64) -> SourceLocation:
        SourceLocation(
            file: file,
            span: span,
            line: line,
            column: column,
            end_line: end_line,
            end_column: end_column
        )

    # Create a location with just line/column (no byte span)
    static fn line_col(file: text, line: i64, column: i64) -> SourceLocation:
        SourceLocation(
            file: file,
            span: Span.empty(),
            line: line,
            column: column,
            end_line: 0,
            end_column: 0
        )

    # Create an unknown/missing location
    static fn unknown() -> SourceLocation:
        SourceLocation(
            file: "<unknown>",
            span: Span.empty(),
            line: 0,
            column: 0,
            end_line: 0,
            end_column: 0
        )

    # Check if this location has valid position info
    fn is_valid() -> bool:
        self.line > 0 and self.column > 0

    # Check if this location spans multiple lines
    fn is_multiline() -> bool:
        self.end_line > 0 and self.end_line > self.line

    # Get effective end line (same as start if not specified)
    fn get_end_line() -> i64:
        if self.end_line > 0:
            self.end_line
        else:
            self.line

    # Get effective end column (same as start if not specified)
    fn get_end_column() -> i64:
        if self.end_column > 0:
            self.end_column
        else:
            self.column + self.span.len().max(1)

    # Format as "file:line:column"
    fn format_short() -> text:
        "{self.file}:{self.line}:{self.column}"

    # Format as "file:line:column-end_line:end_column" if multiline
    fn format_full() -> text:
        if self.is_multiline():
            "{self.file}:{self.line}:{self.column}-{self.get_end_line()}:{self.get_end_column()}"
        else:
            self.format_short()

    # Extract source text from the location's span
    fn extract(source: text) -> text:
        self.span.extract(source)

    # Show source context with underline
    fn show_context(source: text, use_color: bool) -> text:
        if not self.is_valid():
            return ""

        val lines = source.split("\n")
        if self.line <= 0 or self.line > lines.len():
            return ""

        val blue = if use_color: "\x1b[1;34m" else: ""
        val reset = if use_color: "\x1b[0m" else: ""

        val line_num = self.line
        val line_str = lines[line_num - 1]

        var output = "   {blue}|{reset}\n"
        output = output + " {blue}{line_num}{reset} {blue}|{reset} {line_str}\n"

        # Underline
        val col = (self.column - 1).max(0)
        val len = if self.span.len() > 0:
            self.span.len()
        else:
            1

        val spaces = " ".repeat(col)
        val underline = "^".repeat(len)

        output = output + "   {blue}|{reset} {spaces}{underline}"

        output

    # Extend to include another location (must be same file)
    fn extend_to(other: SourceLocation) -> SourceLocation:
        if self.file != other.file:
            return self

        val new_span = self.span.extend_to(other.span)
        val new_line = self.line.min(other.line)
        val new_col = if self.line < other.line:
            self.column
        elif other.line < self.line:
            other.column
        else:
            self.column.min(other.column)

        val new_end_line = self.get_end_line().max(other.get_end_line())
        val new_end_col = if self.get_end_line() > other.get_end_line():
            self.get_end_column()
        elif other.get_end_line() > self.get_end_line():
            other.get_end_column()
        else:
            self.get_end_column().max(other.get_end_column())

        SourceLocation(
            file: self.file,
            span: new_span,
            line: new_line,
            column: new_col,
            end_line: new_end_line,
            end_column: new_end_col
        )

# =============================================================================
# Label: Annotated source span with message
# =============================================================================

struct Label:
    location: SourceLocation
    message: text
    primary: bool           # Primary or secondary label

impl Label:
    # Create a primary label (main error location)
    static fn primary(location: SourceLocation, message: text) -> Label:
        Label(location: location, message: message, primary: true)

    # Create a secondary label (related location)
    static fn secondary(location: SourceLocation, message: text) -> Label:
        Label(location: location, message: message, primary: false)

    # Create a primary label with just file/line/column
    static fn at(file: text, line: i64, column: i64, message: text) -> Label:
        Label(
            location: SourceLocation.at(file, line, column),
            message: message,
            primary: true
        )

    # Get the underline character for this label
    fn underline_char() -> text:
        if self.primary:
            "^"
        else:
            "-"

    # Format the label with source context
    fn format(source: text, use_color: bool, label_color: text) -> text:
        val blue = if use_color: "\x1b[1;34m" else: ""
        val reset = if use_color: "\x1b[0m" else: ""

        var output = "  {blue}-->{reset} {self.location.format_short()}\n"

        if not self.location.is_valid():
            return output

        val lines = source.split("\n")
        if self.location.line <= 0 or self.location.line > lines.len():
            return output

        val line_num = self.location.line
        val line_str = lines[line_num - 1]

        output = output + "   {blue}|{reset}\n"
        output = output + " {blue}{line_num}{reset} {blue}|{reset} {line_str}\n"

        # Underline with message
        val col = (self.location.column - 1).max(0)
        val len = if self.location.span.len() > 0:
            self.location.span.len()
        else:
            1

        val spaces = " ".repeat(col)
        val underline = self.underline_char().repeat(len)
        val ul_color = if use_color: label_color else: ""

        output = output + "   {blue}|{reset} {spaces}{ul_color}{underline}{reset} {self.message}\n"

        output
