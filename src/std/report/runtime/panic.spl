# Panic ReportNL#NL# Reports for unrecoverable runtime errors (panics) with stack traces.NL# Provides structured panic information for debugging and error handling.NLNLimport ..levelNLimport ..locationNLimport ..reportNLuse std.text.{NL}NLNLexport PanicReport, StackFrame, StackTrace, PanicKindNLNL# ANSI escape helperNLfn esc_char() -> text:NL    val code: u8 = 27NL    "{code as char}"NLNL# =============================================================================NL# PanicKind: Categories of panic conditionsNL# =============================================================================NLNLenum PanicKind:NL    Assertion           # Assertion failedNL    Unreachable         # Unreachable code reachedNL    IndexOutOfBounds    # Array/slice index out of boundsNL    NullPointer         # Null pointer dereferenceNL    DivisionByZero      # Division or modulo by zeroNL    Overflow            # Integer overflowNL    StackOverflow       # Stack overflowNL    OutOfMemory         # Memory allocation failedNL    InvalidState        # Invalid internal stateNL    UserPanic           # Explicit panic!() callNL    Unknown             # Unknown panic typeNLNLimpl PanicKind:NL    fn name() -> text:NL        match self:NL            case PanicKind.Assertion: "assertion failed"NL            case PanicKind.Unreachable: "unreachable code"NL            case PanicKind.IndexOutOfBounds: "index out of bounds"NL            case PanicKind.NullPointer: "null pointer"NL            case PanicKind.DivisionByZero: "division by zero"NL            case PanicKind.Overflow: "integer overflow"NL            case PanicKind.StackOverflow: "stack overflow"NL            case PanicKind.OutOfMemory: "out of memory"NL            case PanicKind.InvalidState: "invalid state"NL            case PanicKind.UserPanic: "panic"NL            case PanicKind.Unknown: "unknown error"NLNL    fn code() -> text:NL        match self:NL            case PanicKind.Assertion: "P0001"NL            case PanicKind.Unreachable: "P0002"NL            case PanicKind.IndexOutOfBounds: "P0003"NL            case PanicKind.NullPointer: "P0004"NL            case PanicKind.DivisionByZero: "P0005"NL            case PanicKind.Overflow: "P0006"NL            case PanicKind.StackOverflow: "P0007"NL            case PanicKind.OutOfMemory: "P0008"NL            case PanicKind.InvalidState: "P0009"NL            case PanicKind.UserPanic: "P0010"NL            case PanicKind.Unknown: "P9999"NLNL    fn is_recoverable() -> bool:NL        # Most panics are not recoverable, but some might be caughtNL        match self:NL            case PanicKind.Assertion: falseNL            case PanicKind.UserPanic: falseNL            case PanicKind.StackOverflow: falseNL            case PanicKind.OutOfMemory: falseNL            case _: falseNLNL# =============================================================================NL# StackFrame: Single frame in a stack traceNL# =============================================================================NLNLstruct StackFrame:NL    function_name: text         # Name of the functionNL    file: text?                 # Source file (if available)NL    line: i64                   # Line number (0 if unknown)NL    column: i64                 # Column number (0 if unknown)NL    module: text?               # Module name (if available)NL    address: i64                # Memory address (for native frames)NLNLimpl StackFrame:NL    # Create a frame with source locationNL    static fn at(function_name: text, file: text, line: i64, column: i64) -> StackFrame:NL        StackFrame(NL            function_name: function_name,NL            file: Some(file),NL            line: line,NL            column: column,NL            module: nil,NL            address: 0NL        )NLNL    # Create a frame with just function nameNL    static fn named(function_name: text) -> StackFrame:NL        StackFrame(NL            function_name: function_name,NL            file: nil,NL            line: 0,NL            column: 0,NL            module: nil,NL            address: 0NL        )NLNL    # Create a native frame (no source info)NL    static fn native(function_name: text, address: i64) -> StackFrame:NL        StackFrame(NL            function_name: function_name,NL            file: nil,NL            line: 0,NL            column: 0,NL            module: nil,NL            address: addressNL        )NLNL    # Create a frame with module infoNL    static fn in_module(function_name: text, module: text) -> StackFrame:NL        StackFrame(NL            function_name: function_name,NL            file: nil,NL            line: 0,NL            column: 0,NL            module: Some(module),NL            address: 0NL        )NLNL    fn has_location() -> bool:NL        self.file.? and self.line > 0NLNL    fn has_module() -> bool:NL        self.module.?NLNL    # Convert to SourceLocation if we have file infoNL    fn to_location() -> SourceLocation?:NL        if self.file.?:NL            Some(SourceLocation.at(self.file.unwrap(), self.line, self.column))NL        else:NL            nilNLNL    # Format for displayNL    fn format(index: i64, use_color: bool) -> text:NL        val e = esc_char()NL        val gray = if use_color: "{e}[90m" else: ""NL        val bold = if use_color: "{e}[1m" else: ""NL        val cyan = if use_color: "{e}[36m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{gray}{index}:{reset} {bold}{self.function_name}{reset}"NLNL        if self.module.?:NL            output = output + " {gray}in {self.module.unwrap()}{reset}"NLNL        if self.file.? and self.line > 0:NL            output = output + "\n      {cyan}at {self.file.unwrap()}:{self.line}"NL            if self.column > 0:NL                output = output + ":{self.column}"NL            output = output + "{reset}"NL        elif self.address > 0:NL            output = output + "\n      {gray}at 0x{self.address:x}{reset}"NLNL        outputNLNL# =============================================================================NL# StackTrace: Collection of stack framesNL# =============================================================================NLNLclass StackTrace:NL    frames: [StackFrame]NL    truncated: bool         # True if trace was truncated due to depth limitNL    max_depth: i64          # Maximum frames recordedNLNLimpl StackTrace:NL    static fn empty() -> StackTrace:NL        StackTrace(frames: [], truncated: false, max_depth: 100)NLNL    static fn from_frames(frames: [StackFrame]) -> StackTrace:NL        StackTrace(frames: frames, truncated: false, max_depth: 100)NLNL    static fn with_max_depth(max_depth: i64) -> StackTrace:NL        StackTrace(frames: [], truncated: false, max_depth: max_depth)NLNL    me push(frame: StackFrame):NL        if self.frames.len() < self.max_depth:NL            self.frames.push(frame)NL        else:NL            self.truncated = trueNLNL    me push_at(function_name: text, file: text, line: i64, column: i64):NL        self.push(StackFrame.at(function_name, file, line, column))NLNL    fn len() -> i64:NL        self.frames.len()NLNL    fn is_empty() -> bool:NL        self.frames.is_empty()NLNL    fn get(index: i64) -> StackFrame?:NL        if index >= 0 and index < self.frames.len():NL            Some(self.frames[index])NL        else:NL            nilNLNL    # Get the top frame (most recent call)NL    fn top() -> StackFrame?:NL        if self.frames.is_empty():NL            nilNL        else:NL            Some(self.frames[0])NLNL    # Get the bottom frame (entry point)NL    fn bottom() -> StackFrame?:NL        if self.frames.is_empty():NL            nilNL        else:NL            Some(self.frames[self.frames.len() - 1])NLNL    # Format the stack traceNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val header_color = if use_color: "{e}[1;33m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{header_color}Stack trace:{reset}\n"NLNL        var i = 0NL        for frame in self.frames:NL            output = output + frame.format(i, use_color) + "\n"NL            i = i + 1NLNL        if self.truncated:NL            val gray = if use_color: "{e}[90m" else: ""NL            output = output + "{gray}... (truncated at {self.max_depth} frames){reset}\n"NLNL        outputNLNL# =============================================================================NL# PanicReport: Unrecoverable runtime errorNL# =============================================================================NLNLclass PanicReport:NL    kind: PanicKindNL    message: textNL    location: SourceLocation?NL    stack_trace: StackTrace?NL    context: Dict<text, text>   # Additional context (variable values, etc.)NLNLimpl PanicReport:NL    # Create a panic with messageNL    static fn panic(message: text) -> PanicReport:NL        PanicReport(NL            kind: PanicKind.UserPanic,NL            message: message,NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NLNL    # Create an assertion failureNL    static fn assertion(message: text) -> PanicReport:NL        PanicReport(NL            kind: PanicKind.Assertion,NL            message: message,NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NLNL    # Create an unreachable code panicNL    static fn unreachable(location: SourceLocation) -> PanicReport:NL        PanicReport(NL            kind: PanicKind.Unreachable,NL            message: "entered unreachable code",NL            location: Some(location),NL            stack_trace: nil,NL            context: {}NL        )NLNL    # Create an index out of bounds panicNL    static fn index_out_of_bounds(index: i64, length: i64) -> PanicReport:NL        var report = PanicReport(NL            kind: PanicKind.IndexOutOfBounds,NL            message: "index {index} out of bounds for length {length}",NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NL        report.context["index"] = "{index}"NL        report.context["length"] = "{length}"NL        reportNLNL    # Create a null pointer panicNL    static fn null_pointer(message: text) -> PanicReport:NL        PanicReport(NL            kind: PanicKind.NullPointer,NL            message: message,NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NLNL    # Create a division by zero panicNL    static fn division_by_zero() -> PanicReport:NL        PanicReport(NL            kind: PanicKind.DivisionByZero,NL            message: "attempt to divide by zero",NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NLNL    # Create an overflow panicNL    static fn overflow(operation: text) -> PanicReport:NL        PanicReport(NL            kind: PanicKind.Overflow,NL            message: "integer overflow in {operation}",NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NLNL    # Create a stack overflow panicNL    static fn stack_overflow() -> PanicReport:NL        PanicReport(NL            kind: PanicKind.StackOverflow,NL            message: "stack overflow",NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NLNL    # Create an out of memory panicNL    static fn out_of_memory(requested: i64) -> PanicReport:NL        var report = PanicReport(NL            kind: PanicKind.OutOfMemory,NL            message: "memory allocation of {requested} bytes failed",NL            location: nil,NL            stack_trace: nil,NL            context: {}NL        )NL        report.context["requested_bytes"] = "{requested}"NL        reportNLNL    # ==========================================================================NL    # Builder methodsNL    # ==========================================================================NLNL    fn at(file: text, line: i64, column: i64) -> PanicReport:NL        PanicReport(NL            kind: self.kind,NL            message: self.message,NL            location: Some(SourceLocation.at(file, line, column)),NL            stack_trace: self.stack_trace,NL            context: self.contextNL        )NLNL    fn with_location(location: SourceLocation) -> PanicReport:NL        PanicReport(NL            kind: self.kind,NL            message: self.message,NL            location: Some(location),NL            stack_trace: self.stack_trace,NL            context: self.contextNL        )NLNL    fn with_stack_trace(trace: StackTrace) -> PanicReport:NL        PanicReport(NL            kind: self.kind,NL            message: self.message,NL            location: self.location,NL            stack_trace: Some(trace),NL            context: self.contextNL        )NLNL    fn with_context(key: text, value: text) -> PanicReport:NL        var new_context = self.contextNL        new_context[key] = valueNL        PanicReport(NL            kind: self.kind,NL            message: self.message,NL            location: self.location,NL            stack_trace: self.stack_trace,NL            context: new_contextNL        )NLNL    # ==========================================================================NL    # AccessorsNL    # ==========================================================================NLNL    fn has_location() -> bool:NL        self.location.?NLNL    fn has_stack_trace() -> bool:NL        self.stack_trace.? and not self.stack_trace.unwrap().is_empty()NLNL    fn has_context() -> bool:NL        not self.context.is_empty()NLNL    # ==========================================================================NL    # Conversion to ReportNL    # ==========================================================================NLNL    fn to_report() -> Report:NL        var report = Report.fatal(self.message)NL            .with_code(self.kind.code())NL            .with_kind(ReportKind.Panic)NL            .with_source("runtime")NLNL        if self.location.?:NL            report = report.with_location(self.location.unwrap())NLNL        # Add context as notesNL        for key in self.context.keys():NL            report = report.with_note("{key}: {self.context[key]}")NLNL        reportNLNL    # ==========================================================================NL    # FormattingNL    # ==========================================================================NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val red = if use_color: "{e}[1;31m" else: ""NL        val bold = if use_color: "{e}[1m" else: ""NL        val gray = if use_color: "{e}[90m" else: ""NL        val cyan = if use_color: "{e}[36m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{red}panic{reset}[{self.kind.code()}]: {bold}{self.message}{reset}\n"NLNL        if self.location.?:NL            val loc = self.location.unwrap()NL            output = output + "  {cyan}-->{reset} {loc.format_short()}\n"NLNL        # ContextNL        if not self.context.is_empty():NL            output = output + "\n{gray}Context:{reset}\n"NL            for key in self.context.keys():NL                output = output + "  {key}: {self.context[key]}\n"NLNL        # Stack traceNL        if self.stack_trace.?:NL            output = output + "\n" + self.stack_trace.unwrap().format(use_color)NLNL        outputNLNL    fn format_short() -> text:NL        val loc_str = if self.location.?:NL            "{self.location.unwrap().format_short()}: "NL        else:NL            ""NL        "{loc_str}panic[{self.kind.code()}]: {self.message}"NL