# Compiler Diagnostic Types
#
# Specialized diagnostic types for compiler errors and warnings.
# Provides factory methods for common compiler diagnostics.

import ..level
import ..location
import ..report
import .easy_fix

export CompilerDiagnostic, ParseError, TypeError, NameError, LintWarning

# =============================================================================
# CompilerDiagnostic: Base class for compiler diagnostics
# =============================================================================

class CompilerDiagnostic:
    report: Report
    easy_fix: EasyFixReport?

impl CompilerDiagnostic:
    # Create from an existing report
    static fn from_report(report: Report) -> CompilerDiagnostic:
        CompilerDiagnostic(report: report, easy_fix: None)

    # Create an error diagnostic
    static fn error(message: text) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: Report.error(message).with_source("compiler"),
            easy_fix: None
        )

    # Create a warning diagnostic
    static fn warning(message: text) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: Report.warning(message).with_source("compiler"),
            easy_fix: None
        )

    # ==========================================================================
    # Builder methods
    # ==========================================================================

    fn with_code(code: text) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.with_code(code),
            easy_fix: self.easy_fix
        )

    fn with_kind(kind: ReportKind) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.with_kind(kind),
            easy_fix: self.easy_fix
        )

    fn at(file: text, line: i64, column: i64) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.at(file, line, column),
            easy_fix: self.easy_fix
        )

    fn with_location(location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.with_location(location),
            easy_fix: self.easy_fix
        )

    fn with_label(location: SourceLocation, message: text) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.with_primary_label(location, message),
            easy_fix: self.easy_fix
        )

    fn with_secondary_label(location: SourceLocation, message: text) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.with_secondary_label(location, message),
            easy_fix: self.easy_fix
        )

    fn with_note(note: text) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.with_note(note),
            easy_fix: self.easy_fix
        )

    fn with_help(help: text) -> CompilerDiagnostic:
        CompilerDiagnostic(
            report: self.report.with_help(help),
            easy_fix: self.easy_fix
        )

    fn with_easy_fix(fix: EasyFixReport) -> CompilerDiagnostic:
        # Also add suggestions to the report
        var updated_report = self.report
        for rep in fix.replacements:
            val suggestion = Suggestion.with_confidence(
                rep.to_location(),
                rep.new_text,
                fix.description,
                fix.confidence
            )
            updated_report = updated_report.with_suggestion(suggestion)

        CompilerDiagnostic(
            report: updated_report,
            easy_fix: Some(fix)
        )

    # ==========================================================================
    # Accessors
    # ==========================================================================

    fn is_error() -> bool:
        self.report.is_error()

    fn is_warning() -> bool:
        self.report.is_warning()

    fn has_easy_fix() -> bool:
        self.easy_fix.?

    fn get_easy_fix() -> EasyFixReport?:
        self.easy_fix

    fn get_report() -> Report:
        self.report

    fn message() -> text:
        self.report.message

    fn code() -> text?:
        self.report.code

    fn level() -> ReportLevel:
        self.report.level

    # ==========================================================================
    # Formatting
    # ==========================================================================

    fn format(source: text, use_color: bool) -> text:
        self.report.format(source, use_color)

    fn format_plain(source: text) -> text:
        self.report.format_plain(source)

    fn format_short() -> text:
        self.report.format_short()

# =============================================================================
# ParseError: Syntax and parsing errors
# =============================================================================

class ParseError:
    impl CompilerDiagnostic

impl ParseError:
    # Unexpected token
    static fn unexpected_token(expected: text, found: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("unexpected token: expected {expected}, found {found}")
            .with_kind(ReportKind.ParseError)
            .with_code("E0001")
            .with_location(location)
            .with_label(location, "unexpected token here")
            .with_help("expected {expected}")

    # Unexpected end of file
    static fn unexpected_eof(expected: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("unexpected end of file: expected {expected}")
            .with_kind(ReportKind.ParseError)
            .with_code("E0002")
            .with_location(location)
            .with_note("the file ended unexpectedly")

    # Invalid syntax
    static fn invalid_syntax(message: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("invalid syntax: {message}")
            .with_kind(ReportKind.ParseError)
            .with_code("E0003")
            .with_location(location)

    # Missing delimiter
    static fn missing_delimiter(delimiter: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("missing delimiter: expected '{delimiter}'")
            .with_kind(ReportKind.ParseError)
            .with_code("E0004")
            .with_location(location)

    # Invalid number literal
    static fn invalid_number(value: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("invalid number literal: {value}")
            .with_kind(ReportKind.ParseError)
            .with_code("E0005")
            .with_location(location)

    # Invalid string literal
    static fn invalid_string(message: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("invalid string literal: {message}")
            .with_kind(ReportKind.ParseError)
            .with_code("E0006")
            .with_location(location)

# =============================================================================
# TypeError: Type checking errors
# =============================================================================

class TypeError:
    impl CompilerDiagnostic

impl TypeError:
    # Type mismatch
    static fn mismatch(expected: text, found: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("type mismatch: expected `{expected}`, found `{found}`")
            .with_kind(ReportKind.TypeError)
            .with_code("E0308")
            .with_location(location)
            .with_label(location, "expected `{expected}`")

    # Cannot infer type
    static fn cannot_infer(location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("cannot infer type")
            .with_kind(ReportKind.TypeError)
            .with_code("E0282")
            .with_location(location)
            .with_help("consider adding a type annotation")

    # Invalid operation
    static fn invalid_operation(op: text, type_name: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("cannot apply operator `{op}` to type `{type_name}`")
            .with_kind(ReportKind.TypeError)
            .with_code("E0369")
            .with_location(location)

    # Not callable
    static fn not_callable(type_name: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("type `{type_name}` is not callable")
            .with_kind(ReportKind.TypeError)
            .with_code("E0618")
            .with_location(location)

    # Wrong number of arguments
    static fn wrong_arg_count(expected: i64, found: i64, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("wrong number of arguments: expected {expected}, found {found}")
            .with_kind(ReportKind.TypeError)
            .with_code("E0061")
            .with_location(location)

    # Field not found
    static fn field_not_found(type_name: text, field: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("no field `{field}` on type `{type_name}`")
            .with_kind(ReportKind.TypeError)
            .with_code("E0609")
            .with_location(location)

    # Method not found
    static fn method_not_found(type_name: text, method: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("no method named `{method}` found for type `{type_name}`")
            .with_kind(ReportKind.TypeError)
            .with_code("E0599")
            .with_location(location)

# =============================================================================
# NameError: Name resolution errors
# =============================================================================

class NameError:
    impl CompilerDiagnostic

impl NameError:
    # Undefined variable
    static fn undefined_variable(name: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("undefined variable: `{name}`")
            .with_kind(ReportKind.NameError)
            .with_code("E0425")
            .with_location(location)
            .with_label(location, "not found in this scope")

    # Undefined type
    static fn undefined_type(name: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("undefined type: `{name}`")
            .with_kind(ReportKind.NameError)
            .with_code("E0412")
            .with_location(location)

    # Undefined function
    static fn undefined_function(name: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("undefined function: `{name}`")
            .with_kind(ReportKind.NameError)
            .with_code("E0424")
            .with_location(location)

    # Duplicate definition
    static fn duplicate_definition(name: text, location: SourceLocation, previous: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("duplicate definition: `{name}`")
            .with_kind(ReportKind.NameError)
            .with_code("E0428")
            .with_location(location)
            .with_label(location, "redefined here")
            .with_secondary_label(previous, "previous definition here")

    # Import not found
    static fn import_not_found(path: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("import not found: `{path}`")
            .with_kind(ReportKind.NameError)
            .with_code("E0432")
            .with_location(location)

    # Undefined with suggestion
    static fn undefined_with_suggestion(name: text, suggestion: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.error("undefined: `{name}`")
            .with_kind(ReportKind.NameError)
            .with_code("E0425")
            .with_location(location)
            .with_help("did you mean `{suggestion}`?")

# =============================================================================
# LintWarning: Lint rule violations
# =============================================================================

class LintWarning:
    impl CompilerDiagnostic

impl LintWarning:
    # Unused variable
    static fn unused_variable(name: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.warning("unused variable: `{name}`")
            .with_kind(ReportKind.LintWarning)
            .with_code("W0001")
            .with_location(location)
            .with_help("prefix with `_` to suppress this warning")

    # Unused import
    static fn unused_import(path: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.warning("unused import: `{path}`")
            .with_kind(ReportKind.LintWarning)
            .with_code("W0002")
            .with_location(location)

    # Deprecated feature
    static fn deprecated(name: text, replacement: text?, location: SourceLocation) -> CompilerDiagnostic:
        var diag = CompilerDiagnostic.warning("deprecated: `{name}`")
            .with_kind(ReportKind.DeprecationWarning)
            .with_code("W0003")
            .with_location(location)

        if replacement.?:
            diag = diag.with_help("use `{replacement.unwrap()}` instead")

        diag

    # Unreachable code
    static fn unreachable_code(location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.warning("unreachable code")
            .with_kind(ReportKind.LintWarning)
            .with_code("W0004")
            .with_location(location)

    # Dead code
    static fn dead_code(name: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.warning("dead code: `{name}` is never used")
            .with_kind(ReportKind.LintWarning)
            .with_code("W0005")
            .with_location(location)

    # Shadowed variable
    static fn shadowed_variable(name: text, location: SourceLocation, previous: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.warning("variable `{name}` shadows previous definition")
            .with_kind(ReportKind.LintWarning)
            .with_code("W0006")
            .with_location(location)
            .with_secondary_label(previous, "previously defined here")

    # Generic lint with custom code
    static fn lint(code: text, message: text, location: SourceLocation) -> CompilerDiagnostic:
        CompilerDiagnostic.warning(message)
            .with_kind(ReportKind.LintWarning)
            .with_code(code)
            .with_location(location)
