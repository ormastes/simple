# Complex Number Utilities
#
# Complex number operations and mathematics.
# Pure Simple implementation - no external dependencies.
#
# Represents complex numbers as tuples (real, imaginary).
# All operations return new complex numbers (immutable).
#
# Functions:
# - Creation: from_cartesian, from_polar, from_real, i, zero, one
# - Arithmetic: add, subtract, multiply, divide, negate, conjugate
# - Powers: square, power, sqrt, cbrt
# - Exponential: exp, log (principal branch)
# - Trigonometric: sin, cos, tan, sinh, cosh, tanh
# - Properties: real_part, imag_part, magnitude, argument, phase
# - Comparison: equal, abs_value, distance
# - Conversion: to_polar, to_string, to_cartesian
# - Advanced: roots, reciprocal, normalize
# - Predicates: is_real, is_imaginary, is_zero, is_unit

# ============================================================================
# Constants
# ============================================================================

val PI = 3.141592653589793
val E = 2.718281828459045
val EPSILON = 0.0000000001

# ============================================================================
# Complex Number Creation
# ============================================================================

fn from_cartesian(real: f64, imag: f64):
    """Create complex number from real and imaginary parts.

    Example:
        from_cartesian(3.0, 4.0)  # 3 + 4i
    """
    (real, imag)

fn from_polar(r: f64, theta: f64):
    """Create complex number from polar coordinates (r, theta).

    Example:
        from_polar(5.0, 0.927)  # r=5, theta≈53°
    """
    val real = r * cos_approx(theta)
    val imag = r * sin_approx(theta)
    (real, imag)

fn from_real(r: f64):
    """Create complex number from real number.

    Example:
        from_real(5.0)  # 5 + 0i
    """
    (r, 0.0)

fn i():
    """Return imaginary unit i = 0 + 1i."""
    (0.0, 1.0)

fn zero():
    """Return complex zero 0 + 0i."""
    (0.0, 0.0)

fn one():
    """Return complex one 1 + 0i."""
    (1.0, 0.0)

fn negative_i():
    """Return -i = 0 - 1i."""
    (0.0, -1.0)

# ============================================================================
# Component Access
# ============================================================================

fn real_part(z):
    """Extract real part of complex number.

    Example:
        real_part((3.0, 4.0))  # 3.0
    """
    z.0

fn imag_part(z):
    """Extract imaginary part of complex number.

    Example:
        imag_part((3.0, 4.0))  # 4.0
    """
    z.1

# ============================================================================
# Basic Arithmetic
# ============================================================================

fn add(z1, z2):
    """Add two complex numbers.

    Example:
        add((1.0, 2.0), (3.0, 4.0))  # (4.0, 6.0)
    """
    (z1.0 + z2.0, z1.1 + z2.1)

fn subtract(z1, z2):
    """Subtract complex numbers (z1 - z2).

    Example:
        subtract((5.0, 7.0), (2.0, 3.0))  # (3.0, 4.0)
    """
    (z1.0 - z2.0, z1.1 - z2.1)

fn multiply(z1, z2):
    """Multiply two complex numbers.

    (a + bi)(c + di) = (ac - bd) + (ad + bc)i

    Example:
        multiply((2.0, 3.0), (4.0, 5.0))  # (-7.0, 22.0)
    """
    val a = z1.0
    val b = z1.1
    val c = z2.0
    val d = z2.1

    val real = a * c - b * d
    val imag = a * d + b * c
    (real, imag)

fn divide(z1, z2):
    """Divide complex numbers (z1 / z2).

    (a + bi) / (c + di) = [(a + bi)(c - di)] / (c² + d²)

    Example:
        divide((10.0, 5.0), (2.0, 1.0))  # (5.0, 0.0)
    """
    val a = z1.0
    val b = z1.1
    val c = z2.0
    val d = z2.1

    val denominator = c * c + d * d

    if abs_f64(denominator) < EPSILON:
        return (999999999999.0, 999999999999.0)

    val real = (a * c + b * d) / denominator
    val imag = (b * c - a * d) / denominator
    (real, imag)

fn negate(z):
    """Negate complex number.

    Example:
        negate((3.0, 4.0))  # (-3.0, -4.0)
    """
    (-z.0, -z.1)

fn conjugate(z):
    """Compute complex conjugate (reflect across real axis).

    Example:
        conjugate((3.0, 4.0))  # (3.0, -4.0)
    """
    (z.0, -z.1)

fn reciprocal(z):
    """Compute multiplicative inverse 1/z.

    Example:
        reciprocal((1.0, 1.0))  # (0.5, -0.5)
    """
    divide(one(), z)

# ============================================================================
# Magnitude and Argument
# ============================================================================

fn magnitude(z) -> f64:
    """Compute magnitude (absolute value, modulus) of complex number.

    |z| = sqrt(a² + b²)

    Example:
        magnitude((3.0, 4.0))  # 5.0
    """
    val a = z.0
    val b = z.1
    sqrt_approx(a * a + b * b)

fn abs_value(z) -> f64:
    """Alias for magnitude.

    Example:
        abs_value((3.0, 4.0))  # 5.0
    """
    magnitude(z)

fn argument(z) -> f64:
    """Compute argument (angle) of complex number in radians.

    arg(z) = atan2(b, a)

    Returns value in range (-π, π].

    Example:
        argument((1.0, 1.0))  # π/4 ≈ 0.785
    """
    atan2_approx(z.1, z.0)

fn phase(z) -> f64:
    """Alias for argument.

    Example:
        phase((0.0, 1.0))  # π/2 ≈ 1.571
    """
    argument(z)

# ============================================================================
# Powers and Roots
# ============================================================================

fn square(z):
    """Compute z²."""
    multiply(z, z)

fn power(z, n: i64):
    """Compute z^n for integer n using repeated multiplication.

    Example:
        power((1.0, 1.0), 3)  # (-2.0, 2.0)
    """
    if n == 0:
        return one()

    if n < 0:
        val pos_pow = power(z, -n)
        return reciprocal(pos_pow)

    var result = one()
    var i = 0

    while i < n:
        result = multiply(result, z)
        i = i + 1

    result

fn sqrt(z):
    """Compute principal square root of complex number.

    Uses formula: sqrt(a + bi) = ±(sqrt((r + a)/2) + i·sgn(b)·sqrt((r - a)/2))
    where r = |z|

    Example:
        sqrt((-1.0, 0.0))  # (0.0, 1.0) = i
    """
    val a = z.0
    val b = z.1

    if abs_f64(b) < EPSILON:
        if a >= 0.0:
            return (sqrt_approx(a), 0.0)
        else:
            return (0.0, sqrt_approx(-a))

    val r = magnitude(z)
    val real = sqrt_approx((r + a) / 2.0)
    val imag_abs = sqrt_approx((r - a) / 2.0)

    if b >= 0.0:
        (real, imag_abs)
    else:
        (real, -imag_abs)

fn cbrt(z):
    """Compute principal cube root of complex number.

    Example:
        cbrt((8.0, 0.0))  # (2.0, 0.0)
    """
    val r = magnitude(z)
    val theta = argument(z)

    val new_r = pow_approx(r, 1.0 / 3.0)
    val new_theta = theta / 3.0

    from_polar(new_r, new_theta)

fn nth_root(z, n: i64):
    """Compute principal nth root of complex number.

    Example:
        nth_root((16.0, 0.0), 4)  # (2.0, 0.0)
    """
    if n == 0:
        return one()

    val r = magnitude(z)
    val theta = argument(z)

    val new_r = pow_approx(r, 1.0 / to_f64(n))
    val new_theta = theta / to_f64(n)

    from_polar(new_r, new_theta)

fn roots(z, n: i64):
    """Compute all n-th roots of complex number.

    Returns array of n complex numbers.

    Example:
        roots((-1.0, 0.0), 2)  # [(0, 1), (0, -1)]
    """
    if n <= 0:
        return []

    val r = magnitude(z)
    val theta = argument(z)
    val new_r = pow_approx(r, 1.0 / to_f64(n))

    var result = []
    var k = 0

    while k < n:
        val new_theta = (theta + 2.0 * PI * to_f64(k)) / to_f64(n)
        val root = from_polar(new_r, new_theta)
        result.push(root)
        k = k + 1

    result

# ============================================================================
# Exponential and Logarithm
# ============================================================================

fn exp(z):
    """Compute e^z.

    e^(a + bi) = e^a · (cos(b) + i·sin(b))

    Example:
        exp((0.0, PI))  # (-1.0, 0.0) ≈ e^(iπ)
    """
    val a = z.0
    val b = z.1

    val exp_a = exp_approx(a)
    val cos_b = cos_approx(b)
    val sin_b = sin_approx(b)

    (exp_a * cos_b, exp_a * sin_b)

fn log(z):
    """Compute natural logarithm (principal branch).

    log(z) = log|z| + i·arg(z)

    Example:
        log((1.0, 0.0))  # (0.0, 0.0)
    """
    val r = magnitude(z)
    val theta = argument(z)

    if r < EPSILON:
        return (-999999999999.0, 0.0)

    (log_approx(r), theta)

# ============================================================================
# Trigonometric Functions
# ============================================================================

fn sin(z):
    """Compute sin(z).

    sin(a + bi) = sin(a)cosh(b) + i·cos(a)sinh(b)

    Example:
        sin((0.0, 0.0))  # (0.0, 0.0)
    """
    val a = z.0
    val b = z.1

    val sin_a = sin_approx(a)
    val cos_a = cos_approx(a)
    val sinh_b = sinh_approx(b)
    val cosh_b = cosh_approx(b)

    (sin_a * cosh_b, cos_a * sinh_b)

fn cos(z):
    """Compute cos(z).

    cos(a + bi) = cos(a)cosh(b) - i·sin(a)sinh(b)

    Example:
        cos((0.0, 0.0))  # (1.0, 0.0)
    """
    val a = z.0
    val b = z.1

    val sin_a = sin_approx(a)
    val cos_a = cos_approx(a)
    val sinh_b = sinh_approx(b)
    val cosh_b = cosh_approx(b)

    (cos_a * cosh_b, -sin_a * sinh_b)

fn tan(z):
    """Compute tan(z) = sin(z) / cos(z).

    Example:
        tan((0.0, 0.0))  # (0.0, 0.0)
    """
    val sin_z = sin(z)
    val cos_z = cos(z)
    divide(sin_z, cos_z)

# ============================================================================
# Hyperbolic Functions
# ============================================================================

fn sinh(z):
    """Compute sinh(z).

    sinh(a + bi) = sinh(a)cos(b) + i·cosh(a)sin(b)

    Example:
        sinh((0.0, 0.0))  # (0.0, 0.0)
    """
    val a = z.0
    val b = z.1

    val sinh_a = sinh_approx(a)
    val cosh_a = cosh_approx(a)
    val sin_b = sin_approx(b)
    val cos_b = cos_approx(b)

    (sinh_a * cos_b, cosh_a * sin_b)

fn cosh(z):
    """Compute cosh(z).

    cosh(a + bi) = cosh(a)cos(b) + i·sinh(a)sin(b)

    Example:
        cosh((0.0, 0.0))  # (1.0, 0.0)
    """
    val a = z.0
    val b = z.1

    val sinh_a = sinh_approx(a)
    val cosh_a = cosh_approx(a)
    val sin_b = sin_approx(b)
    val cos_b = cos_approx(b)

    (cosh_a * cos_b, sinh_a * sin_b)

fn tanh(z):
    """Compute tanh(z) = sinh(z) / cosh(z).

    Example:
        tanh((0.0, 0.0))  # (0.0, 0.0)
    """
    val sinh_z = sinh(z)
    val cosh_z = cosh(z)
    divide(sinh_z, cosh_z)

# ============================================================================
# Conversion
# ============================================================================

fn to_polar(z):
    """Convert complex number to polar form (r, theta).

    Example:
        to_polar((1.0, 1.0))  # (1.414..., 0.785...)
    """
    val r = magnitude(z)
    val theta = argument(z)
    (r, theta)

fn to_cartesian(z):
    """Identity - complex number is already in cartesian form.

    Example:
        to_cartesian((3.0, 4.0))  # (3.0, 4.0)
    """
    z

fn to_string(z) -> text:
    """Convert complex number to string representation.

    Example:
        to_string((3.0, 4.0))   # "3.0 + 4.0i"
        to_string((3.0, -4.0))  # "3.0 - 4.0i"
        to_string((0.0, 1.0))   # "0.0 + 1.0i"
    """
    val real = z.0
    val imag = z.1

    if abs_f64(imag) < EPSILON:
        return "{real}"

    if abs_f64(real) < EPSILON:
        return "{imag}i"

    if imag >= 0.0:
        "{real} + {imag}i"
    else:
        val pos_imag = -imag
        "{real} - {pos_imag}i"

# ============================================================================
# Predicates
# ============================================================================

fn is_real(z) -> bool:
    """Check if complex number is real (imaginary part ≈ 0).

    Example:
        is_real((5.0, 0.0))  # true
    """
    abs_f64(z.1) < EPSILON

fn is_imaginary(z) -> bool:
    """Check if complex number is purely imaginary (real part ≈ 0).

    Example:
        is_imaginary((0.0, 5.0))  # true
    """
    abs_f64(z.0) < EPSILON

fn is_zero(z) -> bool:
    """Check if complex number is zero.

    Example:
        is_zero((0.0, 0.0))  # true
    """
    abs_f64(z.0) < EPSILON and abs_f64(z.1) < EPSILON

fn is_unit(z) -> bool:
    """Check if complex number has magnitude 1.

    Example:
        is_unit((1.0, 0.0))  # true
    """
    val mag = magnitude(z)
    abs_f64(mag - 1.0) < EPSILON

fn equal(z1, z2) -> bool:
    """Check if two complex numbers are approximately equal.

    Example:
        equal((1.0, 2.0), (1.0, 2.0))  # true
    """
    val real_diff = z1.0 - z2.0
    val imag_diff = z1.1 - z2.1

    var real_check = false
    if real_diff >= 0.0:
        real_check = real_diff < EPSILON
    else:
        real_check = -real_diff < EPSILON

    var imag_check = false
    if imag_diff >= 0.0:
        imag_check = imag_diff < EPSILON
    else:
        imag_check = -imag_diff < EPSILON

    real_check and imag_check

# ============================================================================
# Advanced Operations
# ============================================================================

fn normalize(z):
    """Normalize complex number to unit magnitude.

    Example:
        normalize((3.0, 4.0))  # (0.6, 0.8)
    """
    val mag = magnitude(z)

    if mag < EPSILON:
        return zero()

    (z.0 / mag, z.1 / mag)

fn distance(z1, z2) -> f64:
    """Compute distance between two complex numbers.

    Example:
        distance((1.0, 2.0), (4.0, 6.0))  # 5.0
    """
    val diff = subtract(z1, z2)
    magnitude(diff)

fn scale(z, factor: f64):
    """Scale complex number by real factor.

    Example:
        scale((3.0, 4.0), 2.0)  # (6.0, 8.0)
    """
    (z.0 * factor, z.1 * factor)

fn rotate(z, angle: f64):
    """Rotate complex number by angle (in radians).

    Example:
        rotate((1.0, 0.0), PI / 2.0)  # (0.0, 1.0)
    """
    val rotation = from_polar(1.0, angle)
    multiply(z, rotation)

fn reflect_real(z):
    """Reflect complex number across real axis (same as conjugate).

    Example:
        reflect_real((3.0, 4.0))  # (3.0, -4.0)
    """
    conjugate(z)

fn reflect_imag(z):
    """Reflect complex number across imaginary axis.

    Example:
        reflect_imag((3.0, 4.0))  # (-3.0, 4.0)
    """
    (-z.0, z.1)

# ============================================================================
# Helper Math Functions (Pure Simple Approximations)
# ============================================================================

fn abs_f64(x: f64) -> f64:
    """Absolute value of float."""
    if x < 0.0:
        -x
    else:
        x

fn to_f64(n: i64) -> f64:
    """Convert integer to float (simple coercion)."""
    n * 1.0

fn sqrt_approx(x: f64) -> f64:
    """Newton's method square root approximation."""
    if x < 0.0:
        return 0.0

    if x < EPSILON:
        return 0.0

    var guess = x / 2.0
    var i = 0

    while i < 20:
        val next_guess = (guess + x / guess) / 2.0
        val diff = guess - next_guess

        var abs_diff = diff
        if abs_diff < 0.0:
            abs_diff = -abs_diff

        if abs_diff < EPSILON:
            return next_guess

        guess = next_guess
        i = i + 1

    guess

fn sin_approx(x: f64) -> f64:
    """Sine using Taylor series (accurate for small angles)."""
    var normalized = x

    while normalized > PI:
        normalized = normalized - 2.0 * PI

    while normalized < -PI:
        normalized = normalized + 2.0 * PI

    var term = normalized
    var result = term
    var i = 1

    while i < 15:
        term = -term * normalized * normalized / (to_f64(2 * i) * to_f64(2 * i + 1))
        result = result + term
        i = i + 1

    result

fn cos_approx(x: f64) -> f64:
    """Cosine using Taylor series."""
    var normalized = x

    while normalized > PI:
        normalized = normalized - 2.0 * PI

    while normalized < -PI:
        normalized = normalized + 2.0 * PI

    var term = 1.0
    var result = term
    var i = 1

    while i < 15:
        term = -term * normalized * normalized / (to_f64(2 * i - 1) * to_f64(2 * i))
        result = result + term
        i = i + 1

    result

fn exp_approx(x: f64) -> f64:
    """Exponential using Taylor series."""
    var term = 1.0
    var result = term
    var i = 1

    while i < 20:
        term = term * x / to_f64(i)
        result = result + term
        i = i + 1

    result

fn log_approx(x: f64) -> f64:
    """Natural logarithm using Newton's method (ln(x))."""
    if x <= 0.0:
        return -999999999999.0

    if abs_f64(x - 1.0) < EPSILON:
        return 0.0

    var guess = 0.0
    if x > 1.0:
        guess = (x - 1.0) / x
    else:
        guess = -(1.0 - x) / x

    var i = 0
    while i < 20:
        val exp_guess = exp_approx(guess)
        val next_guess = guess + (x - exp_guess) / exp_guess

        val diff = guess - next_guess
        var abs_diff = diff
        if abs_diff < 0.0:
            abs_diff = -abs_diff

        if abs_diff < EPSILON:
            return next_guess

        guess = next_guess
        i = i + 1

    guess

fn pow_approx(base: f64, exp: f64) -> f64:
    """Power function: base^exp = e^(exp * ln(base))."""
    if base <= 0.0:
        return 0.0

    val ln_base = log_approx(base)
    val result = exp_approx(exp * ln_base)
    result

fn sinh_approx(x: f64) -> f64:
    """Hyperbolic sine: sinh(x) = (e^x - e^(-x)) / 2."""
    val exp_x = exp_approx(x)
    val exp_neg_x = exp_approx(-x)
    (exp_x - exp_neg_x) / 2.0

fn cosh_approx(x: f64) -> f64:
    """Hyperbolic cosine: cosh(x) = (e^x + e^(-x)) / 2."""
    val exp_x = exp_approx(x)
    val exp_neg_x = exp_approx(-x)
    (exp_x + exp_neg_x) / 2.0

fn atan2_approx(y: f64, x: f64) -> f64:
    """Approximate atan2 for argument calculation."""
    if abs_f64(x) < EPSILON and abs_f64(y) < EPSILON:
        return 0.0

    if abs_f64(x) < EPSILON:
        if y > 0.0:
            return PI / 2.0
        else:
            return -PI / 2.0

    val ratio = y / x
    var atan = atan_approx(ratio)

    if x < 0.0:
        if y >= 0.0:
            atan = atan + PI
        else:
            atan = atan - PI

    atan

fn atan_approx(x: f64) -> f64:
    """Approximate arctangent using polynomial approximation."""
    if abs_f64(x) > 1.0:
        val result = PI / 2.0 - atan_small_approx(1.0 / x)
        if x < 0.0:
            return -result
        else:
            return result

    atan_small_approx(x)

fn atan_small_approx(x: f64) -> f64:
    """Arctangent for |x| <= 1 using Taylor series."""
    var term = x
    var result = term
    var i = 1

    while i < 15:
        val power = 2 * i + 1
        term = -term * x * x
        result = result + term / to_f64(power)
        i = i + 1

    result

# ============================================================================
# Exports
# ============================================================================

export PI, E, EPSILON
export from_cartesian, from_polar, from_real, i, zero, one, negative_i
export real_part, imag_part
export add, subtract, multiply, divide, negate, conjugate, reciprocal
export magnitude, abs_value, argument, phase
export square, power, sqrt, cbrt, nth_root, roots
export exp, log
export sin, cos, tan
export sinh, cosh, tanh
export to_polar, to_cartesian, to_string
export is_real, is_imaginary, is_zero, is_unit, equal
export normalize, distance, scale, rotate
export reflect_real, reflect_imag
