# Path Utilities Module
#
# Wrappers around std.path with convenient alternative names.
# All functions are pure Simple - no FFI required.

use std.path.{
    basename, dirname, extension, stem,
    join, join2, path_join, normalize,
    is_absolute, is_relative,
    resolve, relative_to
}

# ============================================================================
# Exports - Alternative Function Names
# ============================================================================

export get_filename, get_dir_name, get_parent_dir, get_parent_dir_option
export join_path, get_extension, get_stem, has_extension
export normalize_path, is_absolute_path, make_relative, split_path

# ============================================================================
# Filename Operations
# ============================================================================

fn get_filename(path: text) -> text:
    """Get the filename from a path (same as basename).

    Example:
        get_filename("/home/user/file.txt")  # "file.txt"
    """
    basename(path)

fn get_dir_name(path: text) -> text:
    """Get the directory name from a path (last component of directory).

    Example:
        get_dir_name("/home/user/docs")  # "docs"
    """
    basename(path)

fn get_parent_dir(path: text) -> text:
    """Get the parent directory of a path.

    Example:
        get_parent_dir("/home/user/file.txt")  # "/home/user"
        get_parent_dir("/file.txt")  # "/"
    """
    dirname(path)

fn get_parent_dir_option(path: text) -> text?:
    """Get the parent directory as Option. Returns nil for root paths.

    Example:
        get_parent_dir_option("/home/user")  # Some("/home")
        get_parent_dir_option("/")  # nil
    """
    val parent = dirname(path)
    if parent == "/" or parent == ".":
        nil
    else:
        parent

# ============================================================================
# Path Joining
# ============================================================================

fn join_path(base: text, child: text) -> text:
    """Join two path components.

    Example:
        join_path("/home/user", "file.txt")  # "/home/user/file.txt"
    """
    join2(base, child)

# ============================================================================
# Extension Operations
# ============================================================================

fn get_extension(path: text) -> text:
    """Get file extension without dot.

    Example:
        get_extension("file.txt")  # "txt"
        get_extension("archive.tar.gz")  # "gz"
    """
    extension(path)

fn get_stem(path: text) -> text:
    """Get filename without extension.

    Example:
        get_stem("file.txt")  # "file"
        get_stem("archive.tar.gz")  # "archive.tar"
    """
    stem(path)

fn has_extension_case_insensitive(path: text, ext: text) -> bool:
    """Check if path has given extension (case-insensitive).

    Example:
        has_extension("file.TXT", "txt")  # true
        has_extension("file.txt", ".txt")  # true
    """
    val actual = get_extension(path)
    var check_ext = ext
    if ext.starts_with("."):
        check_ext = ext[1:]
    to_lowercase_str(actual) == to_lowercase_str(check_ext)

fn to_lowercase_str(s: text) -> text:
    """Convert string to lowercase (ASCII only)."""
    var result = ""
    for i in 0..s.len():
        val c = s[i:i + 1]
        val code = char_code_simple(c)
        if code >= 65 and code <= 90:  # A-Z
            result = result + char_from_code(code + 32)
        else:
            result = result + c
    result

fn char_from_code(code: i64) -> text:
    """Convert ASCII code to character."""
    if code == 97: return "a"
    if code == 98: return "b"
    if code == 99: return "c"
    if code == 100: return "d"
    if code == 101: return "e"
    if code == 102: return "f"
    if code == 103: return "g"
    if code == 104: return "h"
    if code == 105: return "i"
    if code == 106: return "j"
    if code == 107: return "k"
    if code == 108: return "l"
    if code == 109: return "m"
    if code == 110: return "n"
    if code == 111: return "o"
    if code == 112: return "p"
    if code == 113: return "q"
    if code == 114: return "r"
    if code == 115: return "s"
    if code == 116: return "t"
    if code == 117: return "u"
    if code == 118: return "v"
    if code == 119: return "w"
    if code == 120: return "x"
    if code == 121: return "y"
    if code == 122: return "z"
    ""

# Wrapper to use case-insensitive version as default
fn has_extension(path: text, ext: text) -> bool:
    """Check if path has extension (case-insensitive wrapper)."""
    has_extension_case_insensitive(path, ext)

# ============================================================================
# Path Normalization
# ============================================================================

fn normalize_path(path: text) -> text:
    """Normalize a path by resolving . and .. components.
    Also converts backslashes to forward slashes for Windows paths.

    Example:
        normalize_path("/home/./user/../admin")  # "/home/admin"
        normalize_path("C:\\Users\\user")  # "C:/Users/user"
    """
    # Convert backslashes to forward slashes
    var normalized = ""
    for i in 0..path.len():
        val c = path[i:i + 1]
        if c == "\\":
            normalized = normalized + "/"
        else:
            normalized = normalized + c
    normalize(normalized)

fn is_absolute_path(path: text) -> bool:
    """Check if path is absolute (starts with / or Windows drive letter).

    Example:
        is_absolute_path("/home/user")  # true
        is_absolute_path("C:\\Users")  # true
        is_absolute_path("relative/path")  # false
    """
    if path.len() == 0:
        return false
    # Unix absolute path
    if path.starts_with("/"):
        return true
    # Windows absolute path (C:\ or C:/)
    if path.len() >= 3:
        val first = path[0:1]
        val second = path[1:2]
        val third = path[2:3]
        if second == ":" and (third == "\\" or third == "/"):
            # Check if first is a letter (A-Z or a-z)
            val code = char_code_simple(first)
            if (code >= 65 and code <= 90) or (code >= 97 and code <= 122):
                return true
    false

fn make_relative(path: text, base: text) -> text:
    """Convert absolute path to relative from base.
    Returns original path if no common prefix.

    Example:
        make_relative("/home/user/docs/file.txt", "/home/user")  # "docs/file.txt"
        make_relative("/var/log/file.txt", "/home/user")  # "/var/log/file.txt"
    """
    val np = normalize_path(path)
    val nb = normalize_path(base)

    # Check if path starts with base
    if np.starts_with(nb + "/"):
        return np[nb.len() + 1:]

    # Return original if no common prefix
    np

fn split_path(path: text) -> [text]:
    """Split path into components (filters out empty parts).

    Example:
        split_path("/home/user/file.txt")  # ["home", "user", "file.txt"]
        split_path("relative/path")  # ["relative", "path"]
        split_path("")  # []
    """
    if path == "":
        return []
    val normalized = normalize_path(path)
    val parts = normalized.split("/")
    var result: [text] = []
    for part in parts:
        if part != "" and part != ".":
            result = result.push(part)
    result

# ============================================================================
# Helper Functions
# ============================================================================

fn char_code_simple(c: text) -> i64:
    """Get ASCII code of a character (simplified version)."""
    if c.len() != 1:
        return 0
    if c == "A": return 65
    if c == "B": return 66
    if c == "C": return 67
    if c == "D": return 68
    if c == "E": return 69
    if c == "F": return 70
    if c == "G": return 71
    if c == "H": return 72
    if c == "I": return 73
    if c == "J": return 74
    if c == "K": return 75
    if c == "L": return 76
    if c == "M": return 77
    if c == "N": return 78
    if c == "O": return 79
    if c == "P": return 80
    if c == "Q": return 81
    if c == "R": return 82
    if c == "S": return 83
    if c == "T": return 84
    if c == "U": return 85
    if c == "V": return 86
    if c == "W": return 87
    if c == "X": return 88
    if c == "Y": return 89
    if c == "Z": return 90
    if c == "a": return 97
    if c == "b": return 98
    if c == "c": return 99
    if c == "d": return 100
    if c == "e": return 101
    if c == "f": return 102
    if c == "g": return 103
    if c == "h": return 104
    if c == "i": return 105
    if c == "j": return 106
    if c == "k": return 107
    if c == "l": return 108
    if c == "m": return 109
    if c == "n": return 110
    if c == "o": return 111
    if c == "p": return 112
    if c == "q": return 113
    if c == "r": return 114
    if c == "s": return 115
    if c == "t": return 116
    if c == "u": return 117
    if c == "v": return 118
    if c == "w": return 119
    if c == "x": return 120
    if c == "y": return 121
    if c == "z": return 122
    0
