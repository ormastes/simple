# MessagePack Utility Functions

import types
import encode
import pack

fn msgpack_size_int(n: i64) -> i64:
    if n >= 0 and n <= 127:
        return 1
    if n >= -32 and n < 0:
        return 1
    if n > 127 and n <= 255:
        return 2
    if n >= -128 and n < -32:
        return 2
    if n >= 256 and n <= 65535:
        return 3
    if n >= -32768 and n < -128:
        return 3
    if n >= 65536 and n <= 4294967295:
        return 5
    if n >= -2147483648 and n < -32768:
        return 5
    9

fn msgpack_size_float(f: f64) -> i64:
    9

fn msgpack_size_string(s: text) -> i64:
    val byte_len = encode.utf8_byte_length(s)
    if byte_len >= 0 and byte_len <= 31:
        return 1 + byte_len
    if byte_len >= 32 and byte_len <= 255:
        return 2 + byte_len
    if byte_len >= 256 and byte_len <= 65535:
        return 3 + byte_len
    5 + byte_len

fn msgpack_size_binary(data) -> i64:
    val data_len = encode.list_length(data)
    if data_len >= 0 and data_len <= 255:
        return 2 + data_len
    if data_len >= 256 and data_len <= 65535:
        return 3 + data_len
    5 + data_len

fn msgpack_size_array(arr) -> i64:
    val arr_len = encode.list_length(arr)
    var header_size = 0
    if arr_len >= 0 and arr_len <= 15:
        header_size = 1
    else:
        if arr_len >= 16 and arr_len <= 65535:
            header_size = 3
        else:
            header_size = 5

    var total_size = header_size
    var i = 0
    while i < arr_len:
        import unpack
        val elem_size = msgpack_size_value(arr[i])
        total_size = total_size + elem_size
        i = i + 1
    total_size

fn msgpack_size_map(map) -> i64:
    val keys = pack.map_keys(map)
    val map_len = encode.list_length(keys)
    var header_size = 0
    if map_len >= 0 and map_len <= 15:
        header_size = 1
    else:
        if map_len >= 16 and map_len <= 65535:
            header_size = 3
        else:
            header_size = 5

    var total_size = header_size
    var i = 0
    while i < map_len:
        val key = keys[i]
        val value = pack.map_get(map, key)
        val key_size = msgpack_size_value(key)
        val value_size = msgpack_size_value(value)
        total_size = total_size + key_size
        total_size = total_size + value_size
        i = i + 1
    total_size

fn msgpack_size_ext(type_id: i64, data) -> i64:
    val data_len = encode.list_length(data)
    if data_len == 1:
        return 3
    if data_len == 2:
        return 4
    if data_len == 4:
        return 6
    if data_len == 8:
        return 10
    if data_len == 16:
        return 18
    if data_len >= 0 and data_len <= 255:
        return 3 + data_len
    if data_len >= 256 and data_len <= 65535:
        return 4 + data_len
    6 + data_len

fn msgpack_size_value(value) -> i64:
    import unpack
    val value_type = unpack.get_value_type(value)

    if value_type == types.MSGPACK_TYPE_NIL:
        return 1
    if value_type == types.MSGPACK_TYPE_BOOL:
        return 1
    if value_type == types.MSGPACK_TYPE_INT:
        val n = unpack.get_int_value(value)
        return msgpack_size_int(n)
    if value_type == types.MSGPACK_TYPE_FLOAT:
        val f = unpack.get_float_value(value)
        return msgpack_size_float(f)
    if value_type == types.MSGPACK_TYPE_STRING:
        val s = unpack.get_string_value(value)
        return msgpack_size_string(s)
    if value_type == types.MSGPACK_TYPE_BINARY:
        val data = unpack.get_binary_value(value)
        return msgpack_size_binary(data)
    if value_type == types.MSGPACK_TYPE_ARRAY:
        val arr = unpack.get_array_value(value)
        return msgpack_size_array(arr)
    if value_type == types.MSGPACK_TYPE_MAP:
        val map = unpack.get_map_value(value)
        return msgpack_size_map(map)
    if value_type == types.MSGPACK_TYPE_EXT:
        val ext_data = unpack.get_ext_value(value)
        val type_id = ext_data[0]
        val data = ext_data[1]
        return msgpack_size_ext(type_id, data)
    1

fn msgpack_validate_format(byte: i64) -> bool:
    val format = types.msgpack_detect_format(byte)
    format != "unknown"

fn msgpack_is_valid(bytes) -> bool:
    val len = encode.list_length(bytes)
    if len == 0:
        return false
    val first_byte = bytes[0]
    msgpack_validate_format(first_byte)
