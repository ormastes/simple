# Tree Utilities
#
# Binary tree, BST, and heap implementations.
# Pure Simple implementation - no external dependencies.
#
# Represents trees using tuples: (value, left, right) for nodes, nil for empty.
# Heaps use array-based representation for efficiency.
#
# Functions:
# - Binary Tree: create_node, insert_level_order, traversals (inorder, preorder, postorder)
# - Tree Properties: height, size, is_balanced, is_complete, leaf_count
# - BST: bst_insert, bst_search, bst_delete, bst_min, bst_max, bst_validate
# - Tree Utilities: lowest_common_ancestor, find_path, mirror, diameter
# - Heaps: heapify, heap_insert, extract_min/max, is_heap, heap_sort
# - Conversions: tree_to_array, array_to_tree

# ============================================================================
# Node Construction
# ============================================================================

fn create_node(value, left, right):
    """Create a tree node (tuple representation).

    Example:
        create_node(5, nil, nil)  # (5, nil, nil)
    """
    (value, left, right)

fn create_leaf(value):
    """Create a leaf node (no children).

    Example:
        create_leaf(10)  # (10, nil, nil)
    """
    (value, nil, nil)

fn node_value(node):
    """Get value from node.

    Example:
        node_value((5, nil, nil))  # 5
    """
    if not node.?:
        return nil
    val (value, _, _) = node
    value

fn node_left(node):
    """Get left child of node.

    Example:
        node_left((5, left_child, right_child))  # left_child
    """
    if not node.?:
        return nil
    val (_, left, _) = node
    left

fn node_right(node):
    """Get right child of node.

    Example:
        node_right((5, left_child, right_child))  # right_child
    """
    if not node.?:
        return nil
    val (_, _, right) = node
    right

fn is_leaf(node):
    """Check if node is a leaf (has no children).

    Example:
        is_leaf((5, nil, nil))  # true
    """
    if not node.?:
        return false
    val (_, left, right) = node
    not left.? and not right.?

# ============================================================================
# Tree Construction
# ============================================================================

fn insert_level_order(arr, index: i64):
    """Build binary tree from array using level-order insertion.

    Array representation: nil values indicate missing nodes.

    Example:
        insert_level_order([1, 2, 3, 4, 5], 0)
        # Tree:     1
        #          / \\
        #         2   3
        #        / \\
        #       4   5
    """
    if index >= arr.len():
        return nil

    if not arr[index].?:
        return nil

    val left_idx = 2 * index + 1
    val right_idx = 2 * index + 2

    val left_child = insert_level_order(arr, left_idx)
    val right_child = insert_level_order(arr, right_idx)

    create_node(arr[index], left_child, right_child)

fn array_to_tree(arr):
    """Convert array to binary tree (level-order).

    Example:
        array_to_tree([1, 2, 3, 4, 5])
    """
    insert_level_order(arr, 0)

# ============================================================================
# Tree Traversals
# ============================================================================

fn inorder_helper(node, result):
    """Helper for inorder traversal."""
    if not node.?:
        return

    val (value, left, right) = node
    inorder_helper(left, result)
    result.push(value)
    inorder_helper(right, result)

fn inorder(tree):
    """Inorder traversal (left, root, right).

    Returns array of values in inorder.

    Example:
        inorder(tree)  # [4, 2, 5, 1, 3]
    """
    var result = []
    inorder_helper(tree, result)
    result

fn preorder_helper(node, result):
    """Helper for preorder traversal."""
    if not node.?:
        return

    val (value, left, right) = node
    result.push(value)
    preorder_helper(left, result)
    preorder_helper(right, result)

fn preorder(tree):
    """Preorder traversal (root, left, right).

    Returns array of values in preorder.

    Example:
        preorder(tree)  # [1, 2, 4, 5, 3]
    """
    var result = []
    preorder_helper(tree, result)
    result

fn postorder_helper(node, result):
    """Helper for postorder traversal."""
    if not node.?:
        return

    val (value, left, right) = node
    postorder_helper(left, result)
    postorder_helper(right, result)
    result.push(value)

fn postorder(tree):
    """Postorder traversal (left, right, root).

    Returns array of values in postorder.

    Example:
        postorder(tree)  # [4, 5, 2, 3, 1]
    """
    var result = []
    postorder_helper(tree, result)
    result

fn level_order(tree):
    """Level-order traversal (breadth-first).

    Returns array of values in level order.

    Example:
        level_order(tree)  # [1, 2, 3, 4, 5]
    """
    if not tree.?:
        return []

    var result = []
    var queue = [tree]

    while queue.len() > 0:
        # Dequeue first element
        val node = queue[0]
        var new_queue = []
        var i = 1
        while i < queue.len():
            new_queue.push(queue[i])
            i = i + 1
        queue = new_queue

        val (value, left, right) = node
        result.push(value)

        if left.?:
            queue.push(left)
        if right.?:
            queue.push(right)

    result

# ============================================================================
# Tree Properties
# ============================================================================

fn height(tree) -> i64:
    """Calculate height of tree.

    Height is the longest path from root to leaf.

    Example:
        height(tree)  # 3
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree
    val left_height = height(left)
    val right_height = height(right)

    if left_height > right_height:
        left_height + 1
    else:
        right_height + 1

fn size(tree) -> i64:
    """Count number of nodes in tree.

    Example:
        size(tree)  # 7
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree
    1 + size(left) + size(right)

fn leaf_count(tree) -> i64:
    """Count number of leaf nodes.

    Example:
        leaf_count(tree)  # 4
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree

    if not left.? and not right.?:
        return 1

    leaf_count(left) + leaf_count(right)

fn is_balanced(tree):
    """Check if tree is height-balanced.

    A tree is balanced if for every node, the height difference
    between left and right subtrees is at most 1.

    Example:
        is_balanced(tree)  # true
    """
    if not tree.?:
        return true

    val (_, left, right) = tree
    val left_h = height(left)
    val right_h = height(right)

    var diff = left_h - right_h
    if diff < 0:
        diff = 0 - diff

    if diff > 1:
        return false

    is_balanced(left) and is_balanced(right)

fn is_complete(tree) -> i64:
    """Check if tree is complete (all levels filled except possibly last).

    Returns 1 if complete, 0 if not (using i64 for compatibility).

    Example:
        is_complete(tree)  # 1
    """
    if not tree.?:
        return 1

    var queue = [tree]
    var found_null = false

    while queue.len() > 0:
        val node = queue[0]
        var new_queue = []
        var i = 1
        while i < queue.len():
            new_queue.push(queue[i])
            i = i + 1
        queue = new_queue

        if not node.?:
            found_null = true
        else:
            if found_null:
                return 0

            val (_, left, right) = node
            queue.push(left)
            queue.push(right)

    1

fn diameter(tree) -> i64:
    """Calculate diameter of tree (longest path between any two nodes).

    Example:
        diameter(tree)  # 5
    """
    if not tree.?:
        return 0

    val (_, left, right) = tree
    val left_h = height(left)
    val right_h = height(right)

    # Diameter through root
    val through_root = left_h + right_h

    # Diameter in subtrees
    val left_diam = diameter(left)
    val right_diam = diameter(right)

    var max_val = through_root
    if left_diam > max_val:
        max_val = left_diam
    if right_diam > max_val:
        max_val = right_diam

    max_val

# ============================================================================
# Binary Search Tree Operations
# ============================================================================

fn bst_insert(tree, value):
    """Insert value into BST.

    Example:
        bst_insert(tree, 7)
    """
    if not tree.?:
        return create_leaf(value)

    val (node_val, left, right) = tree

    if value < node_val:
        val new_left = bst_insert(left, value)
        create_node(node_val, new_left, right)
    else:
        if value > node_val:
            val new_right = bst_insert(right, value)
            create_node(node_val, left, new_right)
        else:
            tree

fn bst_search(tree, value):
    """Search for value in BST.

    Returns true if found, false otherwise.

    Example:
        bst_search(tree, 7)  # true
    """
    if not tree.?:
        return false

    val (node_val, left, right) = tree

    if value == node_val:
        return true

    if value < node_val:
        bst_search(left, value)
    else:
        bst_search(right, value)

fn bst_min(tree):
    """Find minimum value in BST.

    Returns minimum value or nil if tree is empty.

    Example:
        bst_min(tree)  # 1
    """
    if not tree.?:
        return nil

    val (value, left, _) = tree

    if not left.?:
        return value

    bst_min(left)

fn bst_max(tree):
    """Find maximum value in BST.

    Returns maximum value or nil if tree is empty.

    Example:
        bst_max(tree)  # 20
    """
    if not tree.?:
        return nil

    val (value, _, right) = tree

    if not right.?:
        return value

    bst_max(right)

fn bst_delete(tree, value):
    """Delete value from BST.

    Example:
        bst_delete(tree, 7)
    """
    if not tree.?:
        return nil

    val (node_val, left, right) = tree

    if value < node_val:
        val new_left = bst_delete(left, value)
        create_node(node_val, new_left, right)
    else:
        if value > node_val:
            val new_right = bst_delete(right, value)
            create_node(node_val, left, new_right)
        else:
            # Node to delete found
            if not left.?:
                return right
            if not right.?:
                return left

            # Node has two children - replace with min from right subtree
            val min_val = bst_min(right)
            val new_right = bst_delete(right, min_val)
            create_node(min_val, left, new_right)

fn bst_validate_helper(tree, min_val, max_val):
    """Helper for BST validation."""
    if not tree.?:
        return true

    val (value, left, right) = tree

    if min_val.? and value <= min_val:
        return false

    if max_val.? and value >= max_val:
        return false

    bst_validate_helper(left, min_val, value) and bst_validate_helper(right, value, max_val)

fn bst_validate(tree):
    """Check if tree is a valid BST.

    Example:
        bst_validate(tree)  # true
    """
    bst_validate_helper(tree, nil, nil)

fn bst_from_sorted(arr, start: i64, end: i64):
    """Build balanced BST from sorted array.

    Example:
        bst_from_sorted([1, 2, 3, 4, 5, 6, 7], 0, 6)
    """
    if start > end:
        return nil

    val mid = (start + end) / 2
    val left = bst_from_sorted(arr, start, mid - 1)
    val right = bst_from_sorted(arr, mid + 1, end)

    create_node(arr[mid], left, right)

# ============================================================================
# Tree Utilities
# ============================================================================

fn find_path_helper(tree, value, path):
    """Helper for finding path to value."""
    if not tree.?:
        return false

    val (node_val, left, right) = tree
    path.push(node_val)

    if node_val == value:
        return true

    if find_path_helper(left, value, path):
        return true

    if find_path_helper(right, value, path):
        return true

    # Remove from path if not found
    var new_path = []
    var i = 0
    while i < path.len() - 1:
        new_path.push(path[i])
        i = i + 1

    # Clear and rebuild path
    while path.len() > 0:
        path.pop()
    for p in new_path:
        path.push(p)

    false

fn find_path(tree, value):
    """Find path from root to node with given value.

    Returns array of values on path, or nil if not found.

    Example:
        find_path(tree, 5)  # [1, 2, 5]
    """
    var path = []
    val found = find_path_helper(tree, value, path)
    if found:
        path
    else:
        nil

fn lowest_common_ancestor(tree, val1, val2):
    """Find lowest common ancestor of two nodes.

    Example:
        lowest_common_ancestor(tree, 4, 5)  # 2
    """
    val path1 = find_path(tree, val1)
    val path2 = find_path(tree, val2)

    if not path1.? or not path2.?:
        return nil

    var lca = nil
    var i = 0
    while i < path1.len() and i < path2.len():
        if path1[i] == path2[i]:
            lca = path1[i]
        else:
            break
        i = i + 1

    lca

fn mirror(tree):
    """Create mirror image of tree (swap left and right).

    Example:
        mirror(tree)  # Tree with left and right swapped
    """
    if not tree.?:
        return nil

    val (value, left, right) = tree
    val new_left = mirror(right)
    val new_right = mirror(left)
    create_node(value, new_left, new_right)

fn are_identical(tree1, tree2):
    """Check if two trees are structurally identical.

    Example:
        are_identical(tree1, tree2)  # true
    """
    if not tree1.? and not tree2.?:
        return true

    if not tree1.? or not tree2.?:
        return false

    val (val1, left1, right1) = tree1
    val (val2, left2, right2) = tree2

    if val1 != val2:
        return false

    are_identical(left1, left2) and are_identical(right1, right2)

fn is_subtree(tree, subtree):
    """Check if subtree is a subtree of tree.

    Example:
        is_subtree(tree, smaller_tree)  # true
    """
    if not tree.?:
        return false

    if are_identical(tree, subtree):
        return true

    val (_, left, right) = tree
    is_subtree(left, subtree) or is_subtree(right, subtree)

# ============================================================================
# Heap Operations (Array-based)
# ============================================================================

fn heap_parent(index: i64) -> i64:
    """Get parent index in heap."""
    (index - 1) / 2

fn heap_left(index: i64) -> i64:
    """Get left child index in heap."""
    2 * index + 1

fn heap_right(index: i64) -> i64:
    """Get right child index in heap."""
    2 * index + 2

fn min_heapify_down(heap, index: i64):
    """Restore min-heap property downward from index.

    Modifies heap in place.
    """
    val size = heap.len()
    var smallest = index
    val left = heap_left(index)
    val right = heap_right(index)

    if left < size and heap[left] < heap[smallest]:
        smallest = left

    if right < size and heap[right] < heap[smallest]:
        smallest = right

    if smallest != index:
        # Swap
        val temp = heap[index]
        heap[index] = heap[smallest]
        heap[smallest] = temp
        min_heapify_down(heap, smallest)

fn max_heapify_down(heap, index: i64):
    """Restore max-heap property downward from index.

    Modifies heap in place.
    """
    val size = heap.len()
    var largest = index
    val left = heap_left(index)
    val right = heap_right(index)

    if left < size and heap[left] > heap[largest]:
        largest = left

    if right < size and heap[right] > heap[largest]:
        largest = right

    if largest != index:
        # Swap
        val temp = heap[index]
        heap[index] = heap[largest]
        heap[largest] = temp
        max_heapify_down(heap, largest)

fn min_heapify_up(heap, index: i64):
    """Restore min-heap property upward from index.

    Modifies heap in place.
    """
    if index == 0:
        return

    val parent = heap_parent(index)
    if heap[index] < heap[parent]:
        # Swap
        val temp = heap[index]
        heap[index] = heap[parent]
        heap[parent] = temp
        min_heapify_up(heap, parent)

fn max_heapify_up(heap, index: i64):
    """Restore max-heap property upward from index.

    Modifies heap in place.
    """
    if index == 0:
        return

    val parent = heap_parent(index)
    if heap[index] > heap[parent]:
        # Swap
        val temp = heap[index]
        heap[index] = heap[parent]
        heap[parent] = temp
        max_heapify_up(heap, parent)

fn build_min_heap(arr):
    """Build min-heap from array.

    Modifies array in place to satisfy heap property.

    Example:
        build_min_heap([5, 3, 8, 1, 9])  # [1, 3, 8, 5, 9]
    """
    val size = arr.len()
    var i = size / 2 - 1

    while i >= 0:
        min_heapify_down(arr, i)
        i = i - 1

    arr

fn build_max_heap(arr):
    """Build max-heap from array.

    Modifies array in place to satisfy heap property.

    Example:
        build_max_heap([5, 3, 8, 1, 9])  # [9, 5, 8, 1, 3]
    """
    val size = arr.len()
    var i = size / 2 - 1

    while i >= 0:
        max_heapify_down(arr, i)
        i = i - 1

    arr

fn heap_insert_min(heap, value):
    """Insert value into min-heap.

    Example:
        heap_insert_min(heap, 4)
    """
    heap.push(value)
    min_heapify_up(heap, heap.len() - 1)

fn heap_insert_max(heap, value):
    """Insert value into max-heap.

    Example:
        heap_insert_max(heap, 4)
    """
    heap.push(value)
    max_heapify_up(heap, heap.len() - 1)

fn extract_min(heap):
    """Extract minimum value from min-heap.

    Returns minimum value or nil if empty.

    Example:
        extract_min(heap)  # 1
    """
    if heap.len() == 0:
        return nil

    val min_val = heap[0]

    if heap.len() == 1:
        heap.pop()
        return min_val

    # Replace root with last element
    heap[0] = heap[heap.len() - 1]
    heap.pop()

    # Restore heap property
    min_heapify_down(heap, 0)

    min_val

fn extract_max(heap):
    """Extract maximum value from max-heap.

    Returns maximum value or nil if empty.

    Example:
        extract_max(heap)  # 9
    """
    if heap.len() == 0:
        return nil

    val max_val = heap[0]

    if heap.len() == 1:
        heap.pop()
        return max_val

    # Replace root with last element
    heap[0] = heap[heap.len() - 1]
    heap.pop()

    # Restore heap property
    max_heapify_down(heap, 0)

    max_val

fn peek_min(heap):
    """Get minimum value without removing.

    Example:
        peek_min(heap)  # 1
    """
    if heap.len() == 0:
        return nil
    heap[0]

fn peek_max(heap):
    """Get maximum value without removing.

    Example:
        peek_max(heap)  # 9
    """
    if heap.len() == 0:
        return nil
    heap[0]

fn is_min_heap(arr) -> i64:
    """Check if array satisfies min-heap property.

    Returns 1 if valid min-heap, 0 otherwise.

    Example:
        is_min_heap([1, 3, 5, 7, 9])  # 1
    """
    val size = arr.len()
    var i = 0

    while i <= (size - 2) / 2:
        val left = heap_left(i)
        val right = heap_right(i)

        if left < size and arr[i] > arr[left]:
            return 0

        if right < size and arr[i] > arr[right]:
            return 0

        i = i + 1

    1

fn is_max_heap(arr) -> i64:
    """Check if array satisfies max-heap property.

    Returns 1 if valid max-heap, 0 otherwise.

    Example:
        is_max_heap([9, 7, 5, 3, 1])  # 1
    """
    val size = arr.len()
    var i = 0

    while i <= (size - 2) / 2:
        val left = heap_left(i)
        val right = heap_right(i)

        if left < size and arr[i] < arr[left]:
            return 0

        if right < size and arr[i] < arr[right]:
            return 0

        i = i + 1

    1

fn heap_sort(arr):
    """Sort array using heap sort (ascending order).

    Modifies array in place.

    Example:
        heap_sort([5, 3, 8, 1, 9])  # [1, 3, 5, 8, 9]
    """
    build_max_heap(arr)

    var i = arr.len() - 1
    while i > 0:
        # Swap root with last element
        val temp = arr[0]
        arr[0] = arr[i]
        arr[i] = temp

        # Reduce heap size and heapify
        var temp_heap = []
        var j = 0
        while j < i:
            temp_heap.push(arr[j])
            j = j + 1

        max_heapify_down(temp_heap, 0)

        # Copy back
        j = 0
        while j < temp_heap.len():
            arr[j] = temp_heap[j]
            j = j + 1

        i = i - 1

    arr
