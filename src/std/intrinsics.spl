# src/std/intrinsics.spl
# Compile-Time Annotation Intrinsics — Simple Standard Library
#
# @tag:api
# @tag:stdlib
# @tag:comptime
#
# Documents and re-exports the built-in compile-time intrinsics available
# in Simple. These are evaluated at compile/eval time with zero runtime cost.
#
# ## Source Location Intrinsics
#
# These special identifiers are replaced by the interpreter/compiler with
# their values at the point of use:
#
#   @file      — text literal: current source file path
#   @line      — i64 literal: current source line number (1-based)
#   @function  — text literal: current function name, or "" at module level
#
# ## Compile-Time Assertions
#
#   @static_assert(condition, message)
#     Evaluates condition at compile time.
#     If condition is false, emits a compile error with message.
#     Condition must be a constant expression.
#
# ## Trait/Type Introspection (@traits)
#
#   @traits("fields", "TypeName")   — [text]: field names of struct TypeName
#   @traits("has_member", "T", "f") — bool: true if T has field f
#   @traits("compiles", expr)        — bool: true if expr compiles without error
#   @traits("module_name")           — text: current module path
#   @traits("identifier", sym)       — text: name of symbol sym
#   @traits("annotations", "T", "f") — [text]: annotations on T.f
#
# ## Must-Use Annotation
#
#   # @must_use
#   fn important_fn() -> Result:
#       ...
#
#   Marks a function so that discarding its return value emits a warning.
#   Implemented via source comment scanning.
#
# ## Phantom Struct Annotation
#
#   @phantom
#   struct Marker
#
#   Declares a zero-size marker struct for use as a generic type parameter.
#   See std.phantom for common marker types.
#
# ## keyof Operator
#
#   keyof T  — equivalent to @traits("fields", "T")
#   Returns a [text] array of field names for struct T at compile time.
#
#   Example:
#     struct Config:
#         host: text
#         port: i64
#
#     val fields = keyof Config   # → ["host", "port"]
#     for f in fields:
#         print f
#
# ## Usage Examples
#
# ### Source location in assertions:
#
#   fn my_fn(x: i64):
#       @static_assert(x > 0, "must be positive")
#       print "{@file}:{@line} — calling my_fn({x})"
#
# ### Field introspection:
#
#   struct Point:
#       x: i64
#       y: i64
#
#   val field_names = keyof Point   # ["x", "y"]
#   val has_x = @traits("has_member", "Point", "x")  # true
#
# ### Module-level annotations:
#
#   @static_assert(1 == 1, "arithmetic is broken")

# ============================================================================
# Intrinsic Constants (for documentation; actual values are compiler-resolved)
# ============================================================================

# INTRINSIC_FILE — replaced with current file path at compile time
val INTRINSIC_FILE: text = "@file"

# INTRINSIC_LINE — replaced with current line number at compile time
val INTRINSIC_LINE: text = "@line"

# INTRINSIC_FUNCTION — replaced with current function name at compile time
val INTRINSIC_FUNCTION: text = "@function"

# ============================================================================
# Keyof Helper
# ============================================================================

# keyof_fields(type_name) — returns field names for a named struct type.
# This is the runtime-callable equivalent of the keyof compile-time operator.
# Usage: val fields = keyof_fields("MyStruct")
fn keyof_fields(type_name: text) -> [text]:
    @traits("fields", type_name)

# has_field(type_name, field_name) — checks if a struct has a named field.
fn has_field(type_name: text, field_name: text) -> bool:
    @traits("has_member", type_name, field_name)

# ============================================================================
# Exports
# ============================================================================

export keyof_fields, has_field
export INTRINSIC_FILE, INTRINSIC_LINE, INTRINSIC_FUNCTION
