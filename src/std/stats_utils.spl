# Statistical Utilities
#
# Helper functions for statistical calculations and data analysis.
# Core functions delegated to math.spl for consistency.
#
# Provides descriptive statistics, measures of central tendency,
# measures of dispersion, and basic statistical operations.
#
# Functions:
# - Central tendency: mean, median, mode, geometric_mean, harmonic_mean
# - Dispersion: variance, std_dev, range_stat, iqr
# - Distribution: percentile, quartiles, five_number_summary
# - Correlation: covariance, correlation
# - Aggregation: sum (imported), product, cumsum, cumprod
# - Moving statistics: moving_average, exponential_moving_average

# Import from math.spl
use std.math.{sum_i64, median_i64}

# ============================================================================
# Basic Aggregation (sum_array delegates to math.spl)
# ============================================================================

fn sum_array(arr):
    """Calculate sum of array elements. Delegates to sum_i64 from math.spl.

    Example:
        sum_array([1, 2, 3, 4, 5])  # 15
    """
    sum_i64(arr)

fn product_array(arr):
    """Calculate product of array elements.

    Example:
        product_array([1, 2, 3, 4, 5])  # 120
    """
    var prod = 1
    for value in arr:
        prod = prod * value
    prod

fn cumulative_sum(arr):
    """Calculate cumulative sum.

    Example:
        cumulative_sum([1, 2, 3, 4])  # [1, 3, 6, 10]
    """
    var result = []
    var running_sum = 0

    for value in arr:
        running_sum = running_sum + value
        result.push(running_sum)

    result

fn cumulative_product(arr):
    """Calculate cumulative product.

    Example:
        cumulative_product([1, 2, 3, 4])  # [1, 2, 6, 24]
    """
    var result = []
    var running_prod = 1

    for value in arr:
        running_prod = running_prod * value
        result.push(running_prod)

    result

# ============================================================================
# Measures of Central Tendency
# ============================================================================

fn mean(arr):
    """Calculate arithmetic mean (average).

    Returns nil for empty array.

    Example:
        mean([1, 2, 3, 4, 5])  # 3
    """
    if arr.len() == 0:
        return nil

    val total = sum_array(arr)
    total / arr.len()

fn median_stat(sorted_arr):
    """Calculate median of sorted array. Delegates to median_i64 from math.spl.

    Array must be sorted. Returns nil for empty array.

    Example:
        median_stat([1, 2, 3, 4, 5])  # 3
        median_stat([1, 2, 3, 4])     # 2 (average of 2 and 3)
    """
    median_i64(sorted_arr)

fn mode_stat(arr):
    """Find most common element (mode).

    Returns (value, frequency) tuple.
    Returns nil for empty array.

    Example:
        mode_stat([1, 2, 2, 3, 3, 3])  # (3, 3)
    """
    if arr.len() == 0:
        return nil

    # Count frequencies
    var counts = []
    for item in arr:
        var found = false
        var i = 0
        while i < counts.len():
            val (elem, count) = counts[i]
            if elem == item:
                counts[i] = (elem, count + 1)
                found = true
                break
            i = i + 1

        if not found:
            counts.push((item, 1))

    # Find max frequency
    var max_count = 0
    var mode_val = nil

    for (elem, count) in counts:
        if count > max_count:
            max_count = count
            mode_val = elem

    (mode_val, max_count)

fn geometric_mean(arr):
    """Calculate geometric mean.

    Returns nth root of product. Approximated as product^(1/n).
    Note: Limited by integer arithmetic.

    Example:
        geometric_mean([1, 2, 4, 8])  # ~2.8
    """
    if arr.len() == 0:
        return nil

    val prod = product_array(arr)
    val n = arr.len()

    # Integer approximation of nth root
    var low = 0
    var high = prod
    var result = 0

    while low <= high:
        val mid = low + (high - low) / 2
        var power = 1
        var i = 0

        while i < n:
            power = power * mid
            i = i + 1

        if power == prod:
            return mid
        elif power < prod:
            result = mid
            low = mid + 1
        else:
            high = mid - 1

    result

fn harmonic_mean(arr):
    """Calculate harmonic mean.

    Returns n / (1/a1 + 1/a2 + ... + 1/an).
    Note: Approximated due to integer arithmetic.

    Example:
        harmonic_mean([1, 2, 4])  # ~1.7
    """
    if arr.len() == 0:
        return nil

    var reciprocal_sum = 0

    for value in arr:
        if value == 0:
            return nil  # Undefined for zero values
        # Approximate: multiply by large number to preserve precision
        reciprocal_sum = reciprocal_sum + (1000000 / value)

    (arr.len() * 1000000) / reciprocal_sum

# ============================================================================
# Measures of Dispersion
# ============================================================================

fn range_stat(arr):
    """Calculate range (max - min).

    Returns nil for empty array.

    Example:
        range_stat([1, 2, 3, 4, 5])  # 4
    """
    if arr.len() == 0:
        return nil

    var min = arr[0]
    var max = arr[0]

    for value in arr:
        if value < min:
            min = value
        if value > max:
            max = value

    max - min

fn variance(arr):
    """Calculate population variance.

    Variance = sum((x - mean)^2) / n

    Example:
        variance([1, 2, 3, 4, 5])  # 2
    """
    if arr.len() == 0:
        return nil

    val avg = mean(arr)
    var sum_squared_diff = 0

    for value in arr:
        val diff = value - avg
        sum_squared_diff = sum_squared_diff + (diff * diff)

    sum_squared_diff / arr.len()

fn sample_variance(arr):
    """Calculate sample variance (n-1 denominator).

    Example:
        sample_variance([1, 2, 3, 4, 5])  # 2.5
    """
    if arr.len() <= 1:
        return nil

    val avg = mean(arr)
    var sum_squared_diff = 0

    for value in arr:
        val diff = value - avg
        sum_squared_diff = sum_squared_diff + (diff * diff)

    sum_squared_diff / (arr.len() - 1)

fn std_dev(arr):
    """Calculate population standard deviation.

    Standard deviation = sqrt(variance).
    Returns integer approximation.

    Example:
        std_dev([1, 2, 3, 4, 5])  # ~1
    """
    val var = variance(arr)
    if not var.?:
        return nil

    # Integer square root approximation
    var low = 0
    var high = var
    var result = 0

    while low <= high:
        val mid = low + (high - low) / 2
        val squared = mid * mid

        if squared == var:
            return mid
        elif squared < var:
            result = mid
            low = mid + 1
        else:
            high = mid - 1

    result

fn mean_absolute_deviation(arr):
    """Calculate mean absolute deviation.

    MAD = mean(|x - mean|)

    Example:
        mean_absolute_deviation([1, 2, 3, 4, 5])  # 1.2 (approximated)
    """
    if arr.len() == 0:
        return nil

    val avg = mean(arr)
    var sum_abs_diff = 0

    for value in arr:
        val diff = value - avg
        val abs_diff = if diff < 0: -diff else: diff
        sum_abs_diff = sum_abs_diff + abs_diff

    sum_abs_diff / arr.len()

# ============================================================================
# Percentiles and Quartiles
# ============================================================================

fn percentile(sorted_arr, p: i64):
    """Calculate percentile of sorted array.

    p should be between 0 and 100.
    Array must be sorted.

    Example:
        percentile([1, 2, 3, 4, 5], 50)  # 3 (median)
    """
    if sorted_arr.len() == 0:
        return nil

    if p < 0 or p > 100:
        return nil

    val index = (p * (sorted_arr.len() - 1)) / 100
    sorted_arr[index]

fn quartiles(sorted_arr):
    """Calculate quartiles (Q1, Q2, Q3).

    Array must be sorted.

    Example:
        quartiles([1, 2, 3, 4, 5, 6, 7, 8, 9])
        # (3, 5, 7)
    """
    if sorted_arr.len() == 0:
        return nil

    val q1 = percentile(sorted_arr, 25)
    val q2 = percentile(sorted_arr, 50)
    val q3 = percentile(sorted_arr, 75)

    (q1, q2, q3)

fn interquartile_range(sorted_arr):
    """Calculate interquartile range (Q3 - Q1).

    Array must be sorted.

    Example:
        interquartile_range([1, 2, 3, 4, 5, 6, 7, 8, 9])  # 4
    """
    val qs = quartiles(sorted_arr)
    if not qs.?:
        return nil

    val (q1, _, q3) = qs
    q3 - q1

fn five_number_summary(sorted_arr):
    """Calculate five-number summary (min, Q1, median, Q3, max).

    Array must be sorted.

    Example:
        five_number_summary([1, 2, 3, 4, 5])
        # (1, 2, 3, 4, 5)
    """
    if sorted_arr.len() == 0:
        return nil

    val min = sorted_arr[0]
    val max = sorted_arr[sorted_arr.len() - 1]
    val qs = quartiles(sorted_arr)

    if not qs.?:
        return nil

    val (q1, q2, q3) = qs
    (min, q1, q2, q3, max)

# ============================================================================
# Data Normalization
# ============================================================================

fn z_score(value: i64, arr):
    """Calculate z-score (standard score).

    z = (x - mean) / std_dev

    Example:
        z_score(5, [1, 2, 3, 4, 5])  # ~1.4
    """
    val avg = mean(arr)
    val sd = std_dev(arr)

    if not avg.? or not sd.? or sd == 0:
        return nil

    (value - avg) / sd

fn normalize_min_max(arr):
    """Normalize array to [0, 1] range.

    normalized = (x - min) / (max - min)

    Example:
        normalize_min_max([1, 2, 3, 4, 5])
        # [0, 0, 0, 0, 1] (integer approximation)
    """
    if arr.len() == 0:
        return []

    var min = arr[0]
    var max = arr[0]

    for value in arr:
        if value < min:
            min = value
        if value > max:
            max = value

    val range = max - min
    if range == 0:
        return arr

    var result = []
    for value in arr:
        # Multiply by 100 for better integer precision
        val normalized = ((value - min) * 100) / range
        result.push(normalized)

    result

# ============================================================================
# Correlation and Covariance
# ============================================================================

fn covariance(arr1, arr2):
    """Calculate covariance between two arrays.

    Arrays must be same length.

    Example:
        covariance([1, 2, 3], [2, 4, 6])  # positive covariance
    """
    if arr1.len() != arr2.len() or arr1.len() == 0:
        return nil

    val mean1 = mean(arr1)
    val mean2 = mean(arr2)

    var sum = 0
    var i = 0

    while i < arr1.len():
        sum = sum + ((arr1[i] - mean1) * (arr2[i] - mean2))
        i = i + 1

    sum / arr1.len()

fn correlation(arr1, arr2):
    """Calculate Pearson correlation coefficient.

    Returns value approximating -1 to 1.
    Arrays must be same length.

    Example:
        correlation([1, 2, 3], [2, 4, 6])  # ~1 (perfect positive)
    """
    val cov = covariance(arr1, arr2)
    if not cov.?:
        return nil

    val sd1 = std_dev(arr1)
    val sd2 = std_dev(arr2)

    if not sd1.? or not sd2.? or sd1 == 0 or sd2 == 0:
        return nil

    cov / (sd1 * sd2)

# ============================================================================
# Moving Statistics
# ============================================================================

fn moving_average(arr, window: i64):
    """Calculate simple moving average.

    Example:
        moving_average([1, 2, 3, 4, 5], 3)
        # [2, 3, 4] (means of windows)
    """
    if window <= 0 or window > arr.len():
        return []

    var result = []
    var i = 0

    while i <= arr.len() - window:
        var sum = 0
        var j = 0
        while j < window:
            sum = sum + arr[i + j]
            j = j + 1

        result.push(sum / window)
        i = i + 1

    result

fn exponential_moving_average(arr, alpha: i64):
    """Calculate exponential moving average.

    alpha is smoothing factor (0-100).

    Example:
        exponential_moving_average([1, 2, 3, 4, 5], 50)
    """
    if arr.len() == 0:
        return []

    var result = [arr[0]]
    var ema = arr[0]
    var i = 1

    while i < arr.len():
        # EMA = alpha * value + (1 - alpha) * prev_EMA
        # Using integer arithmetic: multiply by 100
        ema = (alpha * arr[i] + (100 - alpha) * ema) / 100
        result.push(ema)
        i = i + 1

    result

# ============================================================================
# Distribution Properties
# ============================================================================

fn skewness_simple(arr):
    """Simple skewness measure.

    Returns (mean - median) as indicator of skewness.
    Positive = right-skewed, Negative = left-skewed.

    Example:
        skewness_simple([1, 2, 3, 10])  # positive (right-skewed)
    """
    val avg = mean(arr)

    # Sort for median
    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var j = i + 1
        while j < sorted.len():
            if sorted[j] < sorted[i]:
                val temp = sorted[i]
                sorted[i] = sorted[j]
                sorted[j] = temp
            j = j + 1
        i = i + 1

    val med = median_stat(sorted)

    if not avg.? or not med.?:
        return nil

    avg - med

fn count_above_mean(arr):
    """Count values above the mean.

    Example:
        count_above_mean([1, 2, 3, 4, 5])  # 2
    """
    val avg = mean(arr)
    if not avg.?:
        return nil

    var count = 0
    for value in arr:
        if value > avg:
            count = count + 1

    count

fn count_below_mean(arr):
    """Count values below the mean.

    Example:
        count_below_mean([1, 2, 3, 4, 5])  # 2
    """
    val avg = mean(arr)
    if not avg.?:
        return nil

    var count = 0
    for value in arr:
        if value < avg:
            count = count + 1

    count

# ============================================================================
# Outlier Detection
# ============================================================================

fn is_outlier_iqr(value: i64, sorted_arr):
    """Check if value is outlier using IQR method.

    Outlier if < Q1 - 1.5*IQR or > Q3 + 1.5*IQR.
    Array must be sorted.

    Example:
        is_outlier_iqr(100, [1, 2, 3, 4, 5])  # true
    """
    val qs = quartiles(sorted_arr)
    if not qs.?:
        return false

    val (q1, _, q3) = qs
    val iqr = q3 - q1
    val lower_bound = q1 - (iqr * 3) / 2
    val upper_bound = q3 + (iqr * 3) / 2

    value < lower_bound or value > upper_bound

fn find_outliers_iqr(sorted_arr):
    """Find all outliers using IQR method.

    Returns array of outlier values.

    Example:
        find_outliers_iqr([1, 2, 3, 4, 100])  # [100]
    """
    var outliers = []

    for value in sorted_arr:
        if is_outlier_iqr(value, sorted_arr):
            outliers.push(value)

    outliers

# ============================================================================
# Data Summary
# ============================================================================

fn summary_statistics(arr):
    """Calculate comprehensive summary statistics.

    Returns tuple of (count, mean, std_dev, min, max).

    Example:
        summary_statistics([1, 2, 3, 4, 5])
        # (5, 3, 1, 1, 5)
    """
    if arr.len() == 0:
        return nil

    val count = arr.len()
    val avg = mean(arr)
    val sd = std_dev(arr)

    var min = arr[0]
    var max = arr[0]

    for value in arr:
        if value < min:
            min = value
        if value > max:
            max = value

    (count, avg, sd, min, max)
