# Diff Utilities Module
# Helper functions for text processing, statistics, and formatting

use std.string.{NL}

import diff.types
import diff.lcs
import diff.myers

# ============================================================================
# TEXT SPLITTING UTILITIES
# ============================================================================

fn split_lines(text: text) -> list:
    # Split text into lines, preserving empty lines
    val lines = []
    var current = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        if ch == "\n":
            lines.append(current)
            current = ""
        else:
            current = current + ch
        i = i + 1
    # Add last line if not empty or if text ends with content
    if current.length() > 0 or text.length() > 0:
        lines.append(current)
    lines

fn split_words(text: text) -> list:
    # Split text into words (whitespace-delimited)
    val words = []
    var current = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        val is_space = ch == " " or ch == "\t" or ch == "\n" or ch == "\r"
        if is_space:
            if current.length() > 0:
                words.append(current)
                current = ""
        else:
            current = current + ch
        i = i + 1
    if current.length() > 0:
        words.append(current)
    words

fn split_chars(text: text) -> list:
    # Split text into individual characters
    val chars = []
    var i = 0
    while i < text.length():
        chars.append(text.char_at(i))
        i = i + 1
    chars

fn join_lines(lines: list) -> text:
    # Join lines with newline separator
    var result = ""
    var i = 0
    while i < lines.length():
        if i > 0:
            result = result + NL
        result = result + lines.get(i)
        i = i + 1
    result

fn join_with_separator(items: list, sep: text) -> text:
    # Join list items with separator
    var result = ""
    var i = 0
    while i < items.length():
        if i > 0:
            result = result + sep
        result = result + items.get(i)
        i = i + 1
    result

# ============================================================================
# LIST UTILITIES
# ============================================================================

fn slice_list(list: list, start: i64, end: i64) -> list:
    # Extract sublist from start (inclusive) to end (exclusive)
    val result = []
    var i = start
    while i < end and i < list.length():
        result.append(list.get(i))
        i = i + 1
    result

fn count_occurrences(seq: list) -> list:
    # Count occurrences of each element (simple list-based dict)
    val counts = []
    var i = 0
    while i < seq.length():
        val item = seq.get(i)
        val existing = dict_get(counts, item, -1)
        if existing == -1:
            counts.append((key: item, value: 1))
        else:
            dict_set(counts, item, existing + 1)
        i = i + 1
    counts

fn dict_get(dict: list, key: text, default: i64) -> i64:
    # Get value from simple key-value list
    var i = 0
    while i < dict.length():
        val entry = dict.get(i)
        if entry.key == key:
            return entry.value
        i = i + 1
    default

fn dict_set(dict: list, key: text, value: i64):
    # Set value in simple key-value list
    var i = 0
    while i < dict.length():
        val entry = dict.get(i)
        if entry.key == key:
            dict.set(i, (key: key, value: value))
            return
        i = i + 1

fn adjust_change_indices(change: tuple, offset1: i64, offset2: i64) -> tuple:
    # Adjust change indices by offsets
    val op = change.op

    if op == "equal":
        create_equal(change.content, change.old_line + offset1, change.new_line + offset2)
    else:
        if op == "add":
            create_add(change.content, change.new_line + offset2)
        else:
            if op == "delete":
                create_delete(change.content, change.old_line + offset1)
            else:
                change

# ============================================================================
# HIGH-LEVEL DIFF FUNCTIONS
# ============================================================================

fn diff_lines(text1: text, text2: text) -> list:
    # Diff two texts line by line
    val lines1 = split_lines(text1)
    val lines2 = split_lines(text2)
    myers_diff(lines1, lines2)

fn diff_lines_patience(text1: text, text2: text) -> list:
    # Diff two texts line by line using patience algorithm
    val lines1 = split_lines(text1)
    val lines2 = split_lines(text2)
    patience_diff(lines1, lines2)

fn diff_words(text1: text, text2: text) -> list:
    # Diff two texts word by word
    val words1 = split_words(text1)
    val words2 = split_words(text2)
    myers_diff(words1, words2)

fn diff_chars(text1: text, text2: text) -> list:
    # Diff two texts character by character
    val chars1 = split_chars(text1)
    val chars2 = split_chars(text2)
    myers_diff(chars1, chars2)

# ============================================================================
# PATIENCE DIFF ALGORITHM
# ============================================================================

fn patience_diff(seq1: list, seq2: list) -> list:
    # Patience diff - finds unique common elements as anchors
    val unique_common = find_unique_common_elements(seq1, seq2)

    if unique_common.length() == 0:
        # No unique common elements, fall back to Myers
        return myers_diff(seq1, seq2)

    # Recursively diff around anchors
    val changes = []
    var prev1 = 0
    var prev2 = 0

    var i = 0
    while i < unique_common.length():
        val anchor = unique_common.get(i)
        val pos1 = anchor.pos1
        val pos2 = anchor.pos2

        # Diff before this anchor
        if pos1 > prev1 or pos2 > prev2:
            val sub1 = slice_list(seq1, prev1, pos1)
            val sub2 = slice_list(seq2, prev2, pos2)
            val sub_changes = patience_diff(sub1, sub2)

            # Adjust indices and add changes
            var j = 0
            while j < sub_changes.length():
                val change = sub_changes.get(j)
                val adjusted = adjust_change_indices(change, prev1, prev2)
                changes.append(adjusted)
                j = j + 1

        # Add the anchor as equal
        changes.append(create_equal(seq1.get(pos1), pos1, pos2))

        prev1 = pos1 + 1
        prev2 = pos2 + 1
        i = i + 1

    # Diff after last anchor
    if prev1 < seq1.length() or prev2 < seq2.length():
        val sub1 = slice_list(seq1, prev1, seq1.length())
        val sub2 = slice_list(seq2, prev2, seq2.length())
        val sub_changes = patience_diff(sub1, sub2)

        var j = 0
        while j < sub_changes.length():
            val change = sub_changes.get(j)
            val adjusted = adjust_change_indices(change, prev1, prev2)
            changes.append(adjusted)
            j = j + 1

    changes

fn find_unique_common_elements(seq1: list, seq2: list) -> list:
    # Find elements that appear exactly once in both sequences
    val count1 = count_occurrences(seq1)
    val count2 = count_occurrences(seq2)

    val common = []
    var i = 0
    while i < seq1.length():
        val item = seq1.get(i)
        val c1 = dict_get(count1, item, 0)
        val c2 = dict_get(count2, item, 0)

        if c1 == 1 and c2 == 1:
            # Find position in seq2
            var j = 0
            while j < seq2.length():
                if seq2.get(j) == item:
                    common.append((pos1: i, pos2: j, item: item))
                    j = seq2.length()
                j = j + 1
        i = i + 1

    # Sort by position to maintain order
    common

# ============================================================================
# EDIT DISTANCE ALGORITHMS
# ============================================================================

fn levenshtein_distance(s1: text, s2: text) -> i64:
    # Compute Levenshtein (edit) distance between two strings
    val m = s1.length()
    val n = s2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m:
        val row = []
        var j = 0
        while j <= n:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    # Initialize first row and column
    i = 0
    while i <= m:
        val row = dp.get(i)
        row.set(0, i)
        i = i + 1

    var j = 0
    while j <= n:
        val row = dp.get(0)
        row.set(j, j)
        j = j + 1

    # Fill DP table
    i = 1
    while i <= m:
        j = 1
        while j <= n:
            val prev_row = dp.get(i - 1)
            val curr_row = dp.get(i)

            val cost = if s1.char_at(i - 1) == s2.char_at(j - 1): 0 else: 1

            val delete_cost = prev_row.get(j) + 1
            val insert_cost = curr_row.get(j - 1) + 1
            val subst_cost = prev_row.get(j - 1) + cost

            val min1 = if delete_cost < insert_cost: delete_cost else: insert_cost
            val min2 = if min1 < subst_cost: min1 else: subst_cost

            curr_row.set(j, min2)
            j = j + 1
        i = i + 1

    val last_row = dp.get(m)
    last_row.get(n)

fn damerau_levenshtein_distance(s1: text, s2: text) -> i64:
    # Compute Damerau-Levenshtein distance (allows transpositions)
    val m = s1.length()
    val n = s2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m + 1:
        val row = []
        var j = 0
        while j <= n + 1:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    val max_dist = m + n
    val first_row = dp.get(0)
    first_row.set(0, max_dist)

    # Initialize first row and column
    i = 1
    while i <= m + 1:
        val row = dp.get(i)
        row.set(0, max_dist)
        row.set(1, i - 1)
        i = i + 1

    var j = 1
    while j <= n + 1:
        val row = dp.get(0)
        row.set(j, max_dist)
        val row1 = dp.get(1)
        row1.set(j, j - 1)
        j = j + 1

    # Fill DP table
    i = 2
    while i <= m + 1:
        j = 2
        while j <= n + 1:
            val cost = if s1.char_at(i - 2) == s2.char_at(j - 2): 0 else: 1

            val curr_row = dp.get(i)
            val prev_row = dp.get(i - 1)
            val prev2_row = dp.get(i - 2)

            val delete_cost = prev_row.get(j) + 1
            val insert_cost = curr_row.get(j - 1) + 1
            val subst_cost = prev_row.get(j - 1) + cost

            val min1 = if delete_cost < insert_cost: delete_cost else: insert_cost
            val min2 = if min1 < subst_cost: min1 else: subst_cost

            var final_cost = min2

            # Check for transposition
            val can_transpose = i > 2 and j > 2
            if can_transpose:
                val chars_match = s1.char_at(i - 2) == s2.char_at(j - 3)
                val chars_swap = s1.char_at(i - 3) == s2.char_at(j - 2)
                if chars_match and chars_swap:
                    val trans_cost = prev2_row.get(j - 2) + cost
                    final_cost = if trans_cost < final_cost: trans_cost else: final_cost

            curr_row.set(j, final_cost)
            j = j + 1
        i = i + 1

    val last_row = dp.get(m + 1)
    last_row.get(n + 1)

fn hamming_distance(s1: text, s2: text) -> i64:
    # Compute Hamming distance (only for equal-length strings)
    if s1.length() != s2.length():
        return -1

    var distance = 0
    var i = 0
    while i < s1.length():
        if s1.char_at(i) != s2.char_at(i):
            distance = distance + 1
        i = i + 1
    distance

# ============================================================================
# SIMILARITY METRICS
# ============================================================================

fn similarity_ratio(s1: text, s2: text) -> i64:
    # Compute similarity ratio (0-100) based on edit distance
    val max_len = if s1.length() > s2.length(): s1.length() else: s2.length()
    if max_len == 0:
        return 100

    val distance = levenshtein_distance(s1, s2)
    val ratio = 100 - (distance * 100 / max_len)
    ratio

fn quick_ratio(s1: text, s2: text) -> i64:
    # Quick upper bound on similarity ratio (faster than full ratio)
    val len1 = s1.length()
    val len2 = s2.length()
    val max_len = if len1 > len2: len1 else: len2

    if max_len == 0:
        return 100

    # Count matching characters (very rough estimate)
    var matches = 0
    var i = 0
    while i < len1 and i < len2:
        if s1.char_at(i) == s2.char_at(i):
            matches = matches + 1
        i = i + 1

    matches * 100 / max_len

# ============================================================================
# DIFF STATISTICS
# ============================================================================

fn diff_stats(changes: list) -> tuple:
    # Compute statistics about a diff
    var additions = 0
    var deletions = 0
    var modifications = 0
    var equals = 0

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "add":
            additions = additions + 1
        else:
            if op == "delete":
                deletions = deletions + 1
            else:
                if op == "change":
                    modifications = modifications + 1
                else:
                    if op == "equal":
                        equals = equals + 1

        i = i + 1

    create_diff_stats(additions, deletions, modifications, equals)

fn count_additions(changes: list) -> i64:
    # Count number of additions in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "add":
            count = count + 1
        i = i + 1
    count

fn count_deletions(changes: list) -> i64:
    # Count number of deletions in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "delete":
            count = count + 1
        i = i + 1
    count

fn count_changes(changes: list) -> i64:
    # Count number of modifications in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "change":
            count = count + 1
        i = i + 1
    count

fn count_equals(changes: list) -> i64:
    # Count number of unchanged lines in diff
    var count = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        if change.op == "equal":
            count = count + 1
        i = i + 1
    count

# ============================================================================
# SIDE-BY-SIDE FORMAT
# ============================================================================

fn format_side_by_side(changes: list, width: i64) -> text:
    # Format diff in side-by-side format
    val col_width = (width - 3) / 2
    var result = ""

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal":
            val left = pad_right(change.content, col_width)
            result = result + left + " | " + change.content + NL
        else:
            if op == "delete":
                val left = pad_right(change.content, col_width)
                result = result + left + " <" + NL
            else:
                if op == "add":
                    val spaces = pad_right("", col_width)
                    result = result + spaces + " > " + change.content + NL
                else:
                    if op == "change":
                        val left = pad_right(change.old_content, col_width)
                        result = result + left + " | " + change.new_content + NL

        i = i + 1

    result

fn pad_right(text: text, width: i64) -> text:
    # Pad text to width with spaces on the right
    var result = text
    var len = text.length()
    while len < width:
        result = result + " "
        len = len + 1

    if result.length() > width:
        result = result.substring(0, width)

    result

# ============================================================================
# HIGHLIGHTING AND COLORIZATION
# ============================================================================

fn highlight_diff(changes: list, use_color: i64) -> text:
    # Highlight diff with optional ANSI colors
    var result = ""

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if use_color == 1:
            if op == "add":
                result = result + colorize_addition(change.content)
            else:
                if op == "delete":
                    result = result + colorize_deletion(change.content)
                else:
                    if op == "change":
                        result = result + colorize_deletion(change.old_content)
                        result = result + colorize_addition(change.new_content)
                    else:
                        result = result + change.content
        else:
            if op == "add":
                result = result + "+ " + change.content
            else:
                if op == "delete":
                    result = result + "- " + change.content
                else:
                    if op == "change":
                        result = result + "< " + change.old_content + NL
                        result = result + "> " + change.new_content
                    else:
                        result = result + "  " + change.content

        result = result + NL
        i = i + 1

    result

fn colorize_addition(text: text) -> text:
    # Add green color codes for additions
    "\x1b[32m+ {text}\x1b[0m"

fn colorize_deletion(text: text) -> text:
    # Add red color codes for deletions
    "\x1b[31m- {text}\x1b[0m"

fn colorize_change(text: text) -> text:
    # Add yellow color codes for changes
    "\x1b[33m! {text}\x1b[0m"

# ============================================================================
# DIFF OPTIONS
# ============================================================================

fn diff_with_options(text1: text, text2: text, options: tuple) -> list:
    # Diff with various options
    var t1 = text1
    var t2 = text2

    # Apply ignore whitespace
    if options.ignore_whitespace == 1:
        t1 = remove_whitespace(t1)
        t2 = remove_whitespace(t2)

    # Apply ignore case
    if options.ignore_case == 1:
        t1 = t1.to_lower()
        t2 = t2.to_lower()

    # Choose algorithm
    val result = if options.algorithm == "patience":
        diff_lines_patience(t1, t2)
    else:
        diff_lines(t1, t2)

    result

fn remove_whitespace(text: text) -> text:
    # Remove all whitespace from text
    var result = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        val is_space = ch == " " or ch == "\t" or ch == "\r"
        if not is_space:
            result = result + ch
        i = i + 1
    result

# ============================================================================
# TEXT NORMALIZATION
# ============================================================================

fn is_binary_text(text: text) -> i64:
    # Check if text appears to be binary
    var i = 0
    while i < text.length() and i < 8192:
        val ch = text.char_at(i)
        val code = ch.char_code_at(0)

        # Check for null bytes or control characters
        if code == 0 or (code < 32 and code != 9 and code != 10 and code != 13):
            return 1
        i = i + 1
    0

fn normalize_line_endings(text: text) -> text:
    # Normalize line endings to \n
    var result = ""
    var i = 0
    while i < text.length():
        val ch = text.char_at(i)
        if ch == "\r":
            val next_is_lf = i + 1 < text.length() and text.char_at(i + 1) == "\n"
            if next_is_lf:
                result = result + "\n"
                i = i + 1
            else:
                result = result + "\n"
        else:
            result = result + ch
        i = i + 1
    result

fn trim_trailing_whitespace(text: text) -> text:
    # Remove trailing whitespace from each line
    val lines = split_lines(text)
    val trimmed = []

    var i = 0
    while i < lines.length():
        val line = lines.get(i)
        val trimmed_line = trim_right(line)
        trimmed.append(trimmed_line)
        i = i + 1

    join_lines(trimmed)

fn trim_right(text: text) -> text:
    # Trim whitespace from right side of string
    var end = text.length()
    while end > 0:
        val ch = text.char_at(end - 1)
        val is_space = ch == " " or ch == "\t" or ch == "\r"
        if is_space:
            end = end - 1
        else:
            end = 0

    text.substring(0, end)
