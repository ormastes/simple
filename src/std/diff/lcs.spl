# Longest Common Subsequence (LCS) Module
# Dynamic programming algorithms for finding common subsequences

fn lcs_length(seq1: list, seq2: list) -> i64:
    # Compute length of longest common subsequence
    val m = seq1.length()
    val n = seq2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m:
        val row = []
        var j = 0
        while j <= n:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    # Fill DP table
    i = 1
    while i <= m:
        var j = 1
        while j <= n:
            val prev_row = dp.get(i - 1)
            val curr_row = dp.get(i)

            if seq1.get(i - 1) == seq2.get(j - 1):
                val diag = prev_row.get(j - 1)
                curr_row.set(j, diag + 1)
            else:
                val left = curr_row.get(j - 1)
                val up = prev_row.get(j)
                val max_val = if left > up: left else: up
                curr_row.set(j, max_val)
            j = j + 1
        i = i + 1

    val last_row = dp.get(m)
    last_row.get(n)

fn lcs(seq1: list, seq2: list) -> list:
    # Compute longest common subsequence
    val m = seq1.length()
    val n = seq2.length()

    # Create DP table
    val dp = []
    var i = 0
    while i <= m:
        val row = []
        var j = 0
        while j <= n:
            row.append(0)
            j = j + 1
        dp.append(row)
        i = i + 1

    # Fill DP table
    i = 1
    while i <= m:
        var j = 1
        while j <= n:
            val prev_row = dp.get(i - 1)
            val curr_row = dp.get(i)

            if seq1.get(i - 1) == seq2.get(j - 1):
                val diag = prev_row.get(j - 1)
                curr_row.set(j, diag + 1)
            else:
                val left = curr_row.get(j - 1)
                val up = prev_row.get(j)
                val max_val = if left > up: left else: up
                curr_row.set(j, max_val)
            j = j + 1
        i = i + 1

    # Backtrack to find LCS
    val result = []
    i = m
    var j = n
    while i > 0 and j > 0:
        val curr_row = dp.get(i)
        val prev_row = dp.get(i - 1)

        if seq1.get(i - 1) == seq2.get(j - 1):
            result.append(seq1.get(i - 1))
            i = i - 1
            j = j - 1
        else:
            val left = curr_row.get(j - 1)
            val up = prev_row.get(j)
            if up > left:
                i = i - 1
            else:
                j = j - 1

    result.reverse()
    result
