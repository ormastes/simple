# Comprehensive Geometry Utilities Library - Facade
#
# This module provides extensive 2D and 3D geometry operations including:
# - 2D/3D Point operations (distance, midpoint, rotation, translation)
# - 2D/3D Vector operations (add, subtract, dot, cross, magnitude, normalize)
# - Line operations (slope, intersection, parallel, perpendicular, segment operations)
# - Shape operations (circles, rectangles, triangles, polygons)
# - Collision detection (point-in-polygon, circle-circle, rect-rect, and more)
# - Bounding box operations (create, expand, intersection, union)
# - Transformations (translate, rotate, scale, reflect)
# - Utility functions (collinear, coplanar, angle normalization, interpolation)
#
# All 2D points are represented as tuples: (x, y)
# All 3D points are represented as tuples: (x, y, z)
# All angles are in radians unless otherwise specified
#
# Runtime-safe: NO generics, NO try/catch, uses Option/nil pattern

import "std/geometry/types" as types
import "std/geometry/point" as point
import "std/geometry/line" as line
import "std/geometry/polygon" as polygon
import "std/geometry/circle" as circle
import "std/geometry/utilities" as utilities

# ============================================================================
# Constants
# ============================================================================

val EPSILON = types.EPSILON

# ============================================================================
# Point Operations - Re-export from point module
# ============================================================================

fn point_create(x: f64, y: f64) -> (f64, f64): point.point_create(x, y)
fn point_x(p: (f64, f64)) -> f64: point.point_x(p)
fn point_y(p: (f64, f64)) -> f64: point.point_y(p)
fn point_distance(p1: (f64, f64), p2: (f64, f64)) -> f64: point.point_distance(p1, p2)
fn point_distance_squared(p1: (f64, f64), p2: (f64, f64)) -> f64: point.point_distance_squared(p1, p2)
fn point_midpoint(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64): point.point_midpoint(p1, p2)
fn point_rotate(p: (f64, f64), angle: f64) -> (f64, f64): point.point_rotate(p, angle)
fn point_rotate_around(p: (f64, f64), center: (f64, f64), angle: f64) -> (f64, f64): point.point_rotate_around(p, center, angle)
fn point_translate(p: (f64, f64), offset: (f64, f64)) -> (f64, f64): point.point_translate(p, offset)
fn point_scale(p: (f64, f64), factor: f64) -> (f64, f64): point.point_scale(p, factor)
fn point_scale_xy(p: (f64, f64), sx: f64, sy: f64) -> (f64, f64): point.point_scale_xy(p, sx, sy)
fn point_equal(p1: (f64, f64), p2: (f64, f64)) -> bool: point.point_equal(p1, p2)

# 3D Point Operations
fn point3d_create(x: f64, y: f64, z: f64) -> (f64, f64, f64): point.point3d_create(x, y, z)
fn point3d_x(p: (f64, f64, f64)) -> f64: point.point3d_x(p)
fn point3d_y(p: (f64, f64, f64)) -> f64: point.point3d_y(p)
fn point3d_z(p: (f64, f64, f64)) -> f64: point.point3d_z(p)
fn point3d_distance(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> f64: point.point3d_distance(p1, p2)
fn point3d_distance_squared(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> f64: point.point3d_distance_squared(p1, p2)
fn point3d_midpoint(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> (f64, f64, f64): point.point3d_midpoint(p1, p2)
fn point3d_equal(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> bool: point.point3d_equal(p1, p2)
fn point3d_translate(p: (f64, f64, f64), offset: (f64, f64, f64)) -> (f64, f64, f64): point.point3d_translate(p, offset)
fn point3d_scale(p: (f64, f64, f64), factor: f64) -> (f64, f64, f64): point.point3d_scale(p, factor)
fn point3d_scale_xyz(p: (f64, f64, f64), sx: f64, sy: f64, sz: f64) -> (f64, f64, f64): point.point3d_scale_xyz(p, sx, sy, sz)

# ============================================================================
# Vector Operations - Re-export from point module
# ============================================================================

fn vector_from_points(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64): point.vector_from_points(p1, p2)
fn vector_add(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64): point.vector_add(v1, v2)
fn vector_subtract(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64): point.vector_subtract(v1, v2)
fn vector_multiply(v: (f64, f64), scalar: f64) -> (f64, f64): point.vector_multiply(v, scalar)
fn vector_dot(v1: (f64, f64), v2: (f64, f64)) -> f64: point.vector_dot(v1, v2)
fn vector_cross(v1: (f64, f64), v2: (f64, f64)) -> f64: point.vector_cross(v1, v2)
fn vector_magnitude(v: (f64, f64)) -> f64: point.vector_magnitude(v)
fn vector_magnitude_squared(v: (f64, f64)) -> f64: point.vector_magnitude_squared(v)
fn vector_normalize(v: (f64, f64)) -> (f64, f64): point.vector_normalize(v)
fn vector_angle(v: (f64, f64)) -> f64: point.vector_angle(v)
fn vector_angle_between(v1: (f64, f64), v2: (f64, f64)) -> f64: point.vector_angle_between(v1, v2)
fn vector_perpendicular(v: (f64, f64)) -> (f64, f64): point.vector_perpendicular(v)
fn vector_project(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64): point.vector_project(v1, v2)
fn vector_reflect(v: (f64, f64), normal: (f64, f64)) -> (f64, f64): point.vector_reflect(v, normal)

# 3D Vector Operations
fn vector3d_from_points(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> (f64, f64, f64): point.vector3d_from_points(p1, p2)
fn vector3d_add(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64): point.vector3d_add(v1, v2)
fn vector3d_subtract(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64): point.vector3d_subtract(v1, v2)
fn vector3d_multiply(v: (f64, f64, f64), scalar: f64) -> (f64, f64, f64): point.vector3d_multiply(v, scalar)
fn vector3d_dot(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> f64: point.vector3d_dot(v1, v2)
fn vector3d_cross(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64): point.vector3d_cross(v1, v2)
fn vector3d_magnitude(v: (f64, f64, f64)) -> f64: point.vector3d_magnitude(v)
fn vector3d_magnitude_squared(v: (f64, f64, f64)) -> f64: point.vector3d_magnitude_squared(v)
fn vector3d_normalize(v: (f64, f64, f64)) -> (f64, f64, f64): point.vector3d_normalize(v)
fn vector3d_angle_between(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> f64: point.vector3d_angle_between(v1, v2)
fn vector3d_project(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64): point.vector3d_project(v1, v2)
fn vector3d_reflect(v: (f64, f64, f64), normal: (f64, f64, f64)) -> (f64, f64, f64): point.vector3d_reflect(v, normal)

# ============================================================================
# Line Operations - Re-export from line module
# ============================================================================

fn line_create(p1: (f64, f64), p2: (f64, f64)) -> ((f64, f64), (f64, f64)): line.line_create(p1, p2)
fn line_slope(l: ((f64, f64), (f64, f64))) -> f64?: line.line_slope(l)
fn line_y_intercept(l: ((f64, f64), (f64, f64))) -> f64?: line.line_y_intercept(l)
fn line_parallel(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool: line.line_parallel(line1, line2)
fn line_perpendicular(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool: line.line_perpendicular(line1, line2)
fn line_intersection(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> (f64, f64)?: line.line_intersection(line1, line2)
fn line_point_on_segment(l: ((f64, f64), (f64, f64)), p: (f64, f64)) -> bool: line.line_point_on_segment(l, p)
fn line_length(l: ((f64, f64), (f64, f64))) -> f64: line.line_length(l)
fn line_closest_point(l: ((f64, f64), (f64, f64)), p: (f64, f64)) -> (f64, f64): line.line_closest_point(l, p)
fn line_segment_distance_to_point(seg: ((f64, f64), (f64, f64)), p: (f64, f64)) -> f64: line.line_segment_distance_to_point(seg, p)
fn line_segment_intersects(seg1: ((f64, f64), (f64, f64)), seg2: ((f64, f64), (f64, f64))) -> bool: line.line_segment_intersects(seg1, seg2)
fn line_segment_intersection_point(seg1: ((f64, f64), (f64, f64)), seg2: ((f64, f64), (f64, f64))) -> (f64, f64)?: line.line_segment_intersection_point(seg1, seg2)

# ============================================================================
# Polygon Operations - Re-export from polygon module
# ============================================================================

fn polygon_signed_area(points: [(f64, f64)]) -> f64: polygon.polygon_signed_area(points)
fn polygon_area(points: [(f64, f64)]) -> f64: polygon.polygon_area(points)
fn polygon_perimeter(points: [(f64, f64)]) -> f64: polygon.polygon_perimeter(points)
fn polygon_centroid(points: [(f64, f64)]) -> (f64, f64): polygon.polygon_centroid(points)
fn polygon_contains_point(points: [(f64, f64)], p: (f64, f64)) -> bool: polygon.polygon_contains_point(points, p)
fn polygon_is_convex(points: [(f64, f64)]) -> bool: polygon.polygon_is_convex(points)
fn polygon_convex_hull(points: [(f64, f64)]) -> [(f64, f64)]: polygon.polygon_convex_hull(points)
fn polygon_signed_area_simple(points: [(f64, f64)]) -> f64: polygon.polygon_signed_area_simple(points)
fn polygon_distance_to_point(points: [(f64, f64)], p: (f64, f64)) -> f64: polygon.polygon_distance_to_point(points, p)

# ============================================================================
# Circle Operations - Re-export from circle module
# ============================================================================

fn circle_create(x: f64, y: f64, radius: f64) -> ((f64, f64), f64): circle.circle_create(x, y, radius)
fn circle_center(c: ((f64, f64), f64)) -> (f64, f64): circle.circle_center(c)
fn circle_radius(c: ((f64, f64), f64)) -> f64: circle.circle_radius(c)
fn circle_contains_point(c: ((f64, f64), f64), p: (f64, f64)) -> bool: circle.circle_contains_point(c, p)
fn circle_intersects(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool: circle.circle_intersects(c1, c2)
fn circle_rect_intersects(c: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool: circle.circle_rect_intersects(c, rect)
fn circle_area(c: ((f64, f64), f64)) -> f64: circle.circle_area(c)
fn circle_circumference(c: ((f64, f64), f64)) -> f64: circle.circle_circumference(c)
fn circle_point_at_angle(c: ((f64, f64), f64), angle: f64) -> (f64, f64): circle.circle_point_at_angle(c, angle)
fn circle_is_tangent(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool: circle.circle_is_tangent(c1, c2)
fn circle_bounding_box(c: ((f64, f64), f64)) -> ((f64, f64), f64, f64): circle.circle_bounding_box(c)

# ============================================================================
# Rectangle Operations - Re-export from circle module
# ============================================================================

fn rect_create(x: f64, y: f64, width: f64, height: f64) -> ((f64, f64), f64, f64): circle.rect_create(x, y, width, height)
fn rect_corners(rect: ((f64, f64), f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64), (f64, f64)): circle.rect_corners(rect)
fn rect_center(rect: ((f64, f64), f64, f64)) -> (f64, f64): circle.rect_center(rect)
fn rect_contains_point(rect: ((f64, f64), f64, f64), p: (f64, f64)) -> bool: circle.rect_contains_point(rect, p)
fn rect_intersects(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool: circle.rect_intersects(r1, r2)
fn rect_area(rect: ((f64, f64), f64, f64)) -> f64: circle.rect_area(rect)
fn rect_perimeter(rect: ((f64, f64), f64, f64)) -> f64: circle.rect_perimeter(rect)
fn rect_intersection(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> ((f64, f64), f64, f64)?: circle.rect_intersection(r1, r2)

# ============================================================================
# Triangle Operations - Re-export from circle module
# ============================================================================

fn triangle_create(p1: (f64, f64), p2: (f64, f64), p3: (f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64)): circle.triangle_create(p1, p2, p3)
fn triangle_area(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64: circle.triangle_area(tri)
fn triangle_perimeter(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64: circle.triangle_perimeter(tri)
fn triangle_centroid(tri: ((f64, f64), (f64, f64), (f64, f64))) -> (f64, f64): circle.triangle_centroid(tri)
fn triangle_contains_point(tri: ((f64, f64), (f64, f64), (f64, f64)), p: (f64, f64)) -> bool: circle.triangle_contains_point(tri, p)
fn triangle_is_clockwise(tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool: circle.triangle_is_clockwise(tri)
fn triangle_circumcircle(tri: ((f64, f64), (f64, f64), (f64, f64))) -> ((f64, f64), f64)?: circle.triangle_circumcircle(tri)
fn triangle_incircle(tri: ((f64, f64), (f64, f64), (f64, f64))) -> ((f64, f64), f64)?: circle.triangle_incircle(tri)

# ============================================================================
# Collision Detection - Re-export from utilities module
# ============================================================================

fn collision_point_in_polygon(poly: [(f64, f64)], p: (f64, f64)) -> bool: utilities.collision_point_in_polygon(poly, p)
fn collision_circle_circle(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool: utilities.collision_circle_circle(c1, c2)
fn collision_rect_rect(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool: utilities.collision_rect_rect(r1, r2)
fn collision_circle_rect(c: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool: utilities.collision_circle_rect(c, rect)
fn collision_point_circle(p: (f64, f64), c: ((f64, f64), f64)) -> bool: utilities.collision_point_circle(p, c)
fn collision_point_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> bool: utilities.collision_point_rect(p, rect)
fn collision_point_triangle(p: (f64, f64), tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool: utilities.collision_point_triangle(p, tri)
fn collision_line_line(l1: ((f64, f64), (f64, f64)), l2: ((f64, f64), (f64, f64))) -> bool: utilities.collision_line_line(l1, l2)
fn collision_circle_line(c: ((f64, f64), f64), l: ((f64, f64), (f64, f64))) -> bool: utilities.collision_circle_line(c, l)

# ============================================================================
# Transformation Operations - Re-export from utilities module
# ============================================================================

fn transform_point(p: (f64, f64), translation: (f64, f64), rotation: f64, scale: f64) -> (f64, f64): utilities.transform_point(p, translation, rotation, scale)
fn transform_points(points: [(f64, f64)], translation: (f64, f64), rotation: f64, scale: f64) -> [(f64, f64)]: utilities.transform_points(points, translation, rotation, scale)
fn transform_matrix_create(translation: (f64, f64), rotation: f64, scale: (f64, f64)) -> (f64, f64, f64, f64, f64, f64): utilities.transform_matrix_create(translation, rotation, scale)
fn transform_matrix_apply(matrix: (f64, f64, f64, f64, f64, f64), p: (f64, f64)) -> (f64, f64): utilities.transform_matrix_apply(matrix, p)
fn transform_matrix_compose(m1: (f64, f64, f64, f64, f64, f64), m2: (f64, f64, f64, f64, f64, f64)) -> (f64, f64, f64, f64, f64, f64): utilities.transform_matrix_compose(m1, m2)
fn transform_reflect_x(p: (f64, f64)) -> (f64, f64): utilities.transform_reflect_x(p)
fn transform_reflect_y(p: (f64, f64)) -> (f64, f64): utilities.transform_reflect_y(p)
fn transform_reflect_origin(p: (f64, f64)) -> (f64, f64): utilities.transform_reflect_origin(p)
fn transform_reflect_across_line(p: (f64, f64), l: ((f64, f64), (f64, f64))) -> (f64, f64): utilities.transform_reflect_across_line(p, l)
fn transform_scale_from_center(p: (f64, f64), center: (f64, f64), sx: f64, sy: f64) -> (f64, f64): utilities.transform_scale_from_center(p, center, sx, sy)
fn transform_rotate_translate(p: (f64, f64), angle: f64, translation: (f64, f64)) -> (f64, f64): utilities.transform_rotate_translate(p, angle, translation)

# ============================================================================
# Bounding Box Operations - Re-export from utilities module
# ============================================================================

fn bounding_box(points: [(f64, f64)]) -> ((f64, f64), f64, f64)?: utilities.bounding_box(points)
fn bbox_union(b1: ((f64, f64), f64, f64), b2: ((f64, f64), f64, f64)) -> ((f64, f64), f64, f64): utilities.bbox_union(b1, b2)
fn bbox_expand(bbox: ((f64, f64), f64, f64), margin: f64) -> ((f64, f64), f64, f64): utilities.bbox_expand(bbox, margin)
fn bbox_contains_point(bbox: ((f64, f64), f64, f64), p: (f64, f64)) -> bool: utilities.bbox_contains_point(bbox, p)
fn bbox_area(bbox: ((f64, f64), f64, f64)) -> f64: utilities.bbox_area(bbox)
fn bbox_center(bbox: ((f64, f64), f64, f64)) -> (f64, f64): utilities.bbox_center(bbox)

# ============================================================================
# Utility Functions - Re-export from utilities module
# ============================================================================

fn lerp_point(p1: (f64, f64), p2: (f64, f64), t: f64) -> (f64, f64): utilities.lerp_point(p1, p2, t)
fn clamp_to_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> (f64, f64): utilities.clamp_to_rect(p, rect)
fn distance_point_to_line(p: (f64, f64), l: ((f64, f64), (f64, f64))) -> f64: utilities.distance_point_to_line(p, l)
fn angle_between_points(p1: (f64, f64), p2: (f64, f64)) -> f64: utilities.angle_between_points(p1, p2)
fn degrees_to_radians(degrees: f64) -> f64: utilities.degrees_to_radians(degrees)
fn radians_to_degrees(radians: f64) -> f64: utilities.radians_to_degrees(radians)
fn collinear_2d(p1: (f64, f64), p2: (f64, f64), p3: (f64, f64)) -> bool: utilities.collinear_2d(p1, p2, p3)
fn coplanar_3d(p1: (f64, f64, f64), p2: (f64, f64, f64), p3: (f64, f64, f64), p4: (f64, f64, f64)) -> bool: utilities.coplanar_3d(p1, p2, p3, p4)
fn angle_normalize(angle: f64) -> f64: utilities.angle_normalize(angle)
fn angle_difference(a1: f64, a2: f64) -> f64: utilities.angle_difference(a1, a2)
fn lerp(a: f64, b: f64, t: f64) -> f64: utilities.lerp(a, b, t)
fn lerp_point3d(p1: (f64, f64, f64), p2: (f64, f64, f64), t: f64) -> (f64, f64, f64): utilities.lerp_point3d(p1, p2, t)
fn clamp(value: f64, min_val: f64, max_val: f64) -> f64: utilities.clamp(value, min_val, max_val)
