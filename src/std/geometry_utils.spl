# Comprehensive Geometry Utilities Library
#
# This module provides extensive 2D and 3D geometry operations including:
# - 2D/3D Point operations (distance, midpoint, rotation, translation)
# - 2D/3D Vector operations (add, subtract, dot, cross, magnitude, normalize)
# - Line operations (slope, intersection, parallel, perpendicular, segment operations)
# - Shape operations (circles, rectangles, triangles, polygons)
# - Collision detection (point-in-polygon, circle-circle, rect-rect, and more)
# - Bounding box operations (create, expand, intersection, union)
# - Transformations (translate, rotate, scale, reflect)
# - Utility functions (collinear, coplanar, angle normalization, interpolation)
#
# All 2D points are represented as tuples: (x, y)
# All 3D points are represented as tuples: (x, y, z)
# All angles are in radians unless otherwise specified
#
# Runtime-safe: NO generics, NO try/catch, uses Option/nil pattern

import "std/math" as math

# ============================================================================
# Constants
# ============================================================================

val EPSILON = 0.000001  # Small value for floating point comparisons

# ============================================================================
# Point Operations
# ============================================================================

# Create a point at the given coordinates
# Example: point_create(3.0, 4.0) -> (3.0, 4.0)
fn point_create(x: f64, y: f64) -> (f64, f64):
    (x, y)

# Get the x coordinate of a point
fn point_x(p: (f64, f64)) -> f64:
    p.0

# Get the y coordinate of a point
fn point_y(p: (f64, f64)) -> f64:
    p.1

# Calculate the Euclidean distance between two points
# Example: point_distance((0.0, 0.0), (3.0, 4.0)) -> 5.0
fn point_distance(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    math.sqrt(dx * dx + dy * dy)

# Calculate the squared distance between two points (faster, no sqrt)
# Useful for comparisons where actual distance isn't needed
fn point_distance_squared(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    dx * dx + dy * dy

# Calculate the midpoint between two points
# Example: point_midpoint((0.0, 0.0), (4.0, 6.0)) -> (2.0, 3.0)
fn point_midpoint(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64):
    ((p1.0 + p2.0) / 2.0, (p1.1 + p2.1) / 2.0)

# Rotate a point around the origin by the given angle (radians)
# Example: point_rotate((1.0, 0.0), PI/2) -> (0.0, 1.0)
fn point_rotate(p: (f64, f64), angle: f64) -> (f64, f64):
    val cos_a = math.cos(angle)
    val sin_a = math.sin(angle)
    val x = p.0 * cos_a - p.1 * sin_a
    val y = p.0 * sin_a + p.1 * cos_a
    (x, y)

# Rotate a point around a given center by the given angle (radians)
fn point_rotate_around(p: (f64, f64), center: (f64, f64), angle: f64) -> (f64, f64):
    val translated = (p.0 - center.0, p.1 - center.1)
    val rotated = point_rotate(translated, angle)
    (rotated.0 + center.0, rotated.1 + center.1)

# Translate a point by the given offset
# Example: point_translate((1.0, 2.0), (3.0, 4.0)) -> (4.0, 6.0)
fn point_translate(p: (f64, f64), offset: (f64, f64)) -> (f64, f64):
    (p.0 + offset.0, p.1 + offset.1)

# Scale a point by the given factor from the origin
# Example: point_scale((2.0, 3.0), 2.0) -> (4.0, 6.0)
fn point_scale(p: (f64, f64), factor: f64) -> (f64, f64):
    (p.0 * factor, p.1 * factor)

# Scale a point by different factors for x and y
fn point_scale_xy(p: (f64, f64), sx: f64, sy: f64) -> (f64, f64):
    (p.0 * sx, p.1 * sy)

# Check if two points are approximately equal (within EPSILON)
fn point_equal(p1: (f64, f64), p2: (f64, f64)) -> bool:
    val dx = math.abs(p1.0 - p2.0)
    val dy = math.abs(p1.1 - p2.1)
    dx < EPSILON and dy < EPSILON

# ============================================================================
# Vector Operations
# ============================================================================

# Create a vector from two points (from p1 to p2)
# Example: vector_from_points((1.0, 1.0), (4.0, 5.0)) -> (3.0, 4.0)
fn vector_from_points(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64):
    (p2.0 - p1.0, p2.1 - p1.1)

# Add two vectors
# Example: vector_add((1.0, 2.0), (3.0, 4.0)) -> (4.0, 6.0)
fn vector_add(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    (v1.0 + v2.0, v1.1 + v2.1)

# Subtract two vectors (v1 - v2)
# Example: vector_subtract((5.0, 7.0), (2.0, 3.0)) -> (3.0, 4.0)
fn vector_subtract(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    (v1.0 - v2.0, v1.1 - v2.1)

# Multiply a vector by a scalar
fn vector_multiply(v: (f64, f64), scalar: f64) -> (f64, f64):
    (v.0 * scalar, v.1 * scalar)

# Calculate the dot product of two vectors
# Example: vector_dot((1.0, 0.0), (0.0, 1.0)) -> 0.0
fn vector_dot(v1: (f64, f64), v2: (f64, f64)) -> f64:
    v1.0 * v2.0 + v1.1 * v2.1

# Calculate the cross product (z-component) of two 2D vectors
# Returns positive if v2 is counterclockwise from v1, negative if clockwise
# Example: vector_cross((1.0, 0.0), (0.0, 1.0)) -> 1.0
fn vector_cross(v1: (f64, f64), v2: (f64, f64)) -> f64:
    v1.0 * v2.1 - v1.1 * v2.0

# Calculate the magnitude (length) of a vector
# Example: vector_magnitude((3.0, 4.0)) -> 5.0
fn vector_magnitude(v: (f64, f64)) -> f64:
    math.sqrt(v.0 * v.0 + v.1 * v.1)

# Calculate the squared magnitude of a vector (faster)
fn vector_magnitude_squared(v: (f64, f64)) -> f64:
    v.0 * v.0 + v.1 * v.1

# Normalize a vector (make it unit length)
# Returns (0.0, 0.0) if the vector has zero length
# Example: vector_normalize((3.0, 4.0)) -> (0.6, 0.8)
fn vector_normalize(v: (f64, f64)) -> (f64, f64):
    val mag = vector_magnitude(v)
    if math.abs(mag) < EPSILON:
        (0.0, 0.0)
    else:
        (v.0 / mag, v.1 / mag)

# Calculate the angle of a vector from the positive x-axis (radians)
# Example: vector_angle((1.0, 1.0)) -> PI/4
fn vector_angle(v: (f64, f64)) -> f64:
    math.atan2(v.1, v.0)

# Calculate the angle between two vectors (radians)
fn vector_angle_between(v1: (f64, f64), v2: (f64, f64)) -> f64:
    val dot = vector_dot(v1, v2)
    val mag1 = vector_magnitude(v1)
    val mag2 = vector_magnitude(v2)
    val denom = mag1 * mag2
    if math.abs(denom) < EPSILON:
        0.0
    else:
        math.acos(dot / denom)

# Rotate a vector by 90 degrees counterclockwise
fn vector_perpendicular(v: (f64, f64)) -> (f64, f64):
    (0.0 - v.1, v.0)

# Project vector v1 onto vector v2
fn vector_project(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    val dot = vector_dot(v1, v2)
    val mag2_sq = vector_magnitude_squared(v2)
    if math.abs(mag2_sq) < EPSILON:
        (0.0, 0.0)
    else:
        val scalar = dot / mag2_sq
        vector_multiply(v2, scalar)

# Reflect a vector across a normal
fn vector_reflect(v: (f64, f64), normal: (f64, f64)) -> (f64, f64):
    val dot = vector_dot(v, normal)
    val scaled = vector_multiply(normal, 2.0 * dot)
    vector_subtract(v, scaled)

# ============================================================================
# Line Operations
# ============================================================================

# A line is represented as two points: ((x1, y1), (x2, y2))

# Create a line from two points
fn line_create(p1: (f64, f64), p2: (f64, f64)) -> ((f64, f64), (f64, f64)):
    (p1, p2)

# Calculate the slope of a line
# Returns nil if the line is vertical
fn line_slope(line: ((f64, f64), (f64, f64))) -> f64?:
    val p1 = line.0
    val p2 = line.1
    val dx = p2.0 - p1.0
    if math.abs(dx) < EPSILON:
        nil
    else:
        (p2.1 - p1.1) / dx

# Calculate the y-intercept of a line
# Returns nil if the line is vertical
fn line_y_intercept(line: ((f64, f64), (f64, f64))) -> f64?:
    val slope = line_slope(line)
    if slope == nil:
        nil
    else:
        val p1 = line.0
        p1.1 - slope * p1.0

# Check if two lines are parallel
fn line_parallel(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool:
    val v1 = vector_from_points(line1.0, line1.1)
    val v2 = vector_from_points(line2.0, line2.1)
    val cross = vector_cross(v1, v2)
    math.abs(cross) < EPSILON

# Check if two lines are perpendicular
fn line_perpendicular(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool:
    val v1 = vector_from_points(line1.0, line1.1)
    val v2 = vector_from_points(line2.0, line2.1)
    val dot = vector_dot(v1, v2)
    math.abs(dot) < EPSILON

# Find the intersection point of two lines
# Returns nil if lines are parallel or coincident
fn line_intersection(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> (f64, f64)?:
    val p1 = line1.0
    val p2 = line1.1
    val p3 = line2.0
    val p4 = line2.1

    val x1 = p1.0
    val y1 = p1.1
    val x2 = p2.0
    val y2 = p2.1
    val x3 = p3.0
    val y3 = p3.1
    val x4 = p4.0
    val y4 = p4.1

    val denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)

    if math.abs(denom) < EPSILON:
        nil
    else:
        val t_num = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)
        val t = t_num / denom
        val x = x1 + t * (x2 - x1)
        val y = y1 + t * (y2 - y1)
        (x, y)

# Check if a point lies on a line segment
fn line_point_on_segment(line: ((f64, f64), (f64, f64)), p: (f64, f64)) -> bool:
    val p1 = line.0
    val p2 = line.1

    val cross = vector_cross(vector_from_points(p1, p), vector_from_points(p1, p2))
    if math.abs(cross) > EPSILON:
        false
    else:
        val min_x = math.min(p1.0, p2.0)
        val max_x = math.max(p1.0, p2.0)
        val min_y = math.min(p1.1, p2.1)
        val max_y = math.max(p1.1, p2.1)
        p.0 >= min_x - EPSILON and p.0 <= max_x + EPSILON and p.1 >= min_y - EPSILON and p.1 <= max_y + EPSILON

# Calculate the length of a line segment
fn line_length(line: ((f64, f64), (f64, f64))) -> f64:
    point_distance(line.0, line.1)

# Find the closest point on a line segment to a given point
fn line_closest_point(line: ((f64, f64), (f64, f64)), p: (f64, f64)) -> (f64, f64):
    val p1 = line.0
    val p2 = line.1
    val line_vec = vector_from_points(p1, p2)
    val point_vec = vector_from_points(p1, p)

    val line_len_sq = vector_magnitude_squared(line_vec)

    if math.abs(line_len_sq) < EPSILON:
        p1
    else:
        val t = vector_dot(point_vec, line_vec) / line_len_sq
        if t < 0.0:
            p1
        else:
            if t > 1.0:
                p2
            else:
                (p1.0 + t * line_vec.0, p1.1 + t * line_vec.1)

# ============================================================================
# Rectangle Operations
# ============================================================================

# A rectangle is represented as: ((x, y), width, height)
# where (x, y) is the top-left corner

# Create a rectangle
fn rect_create(x: f64, y: f64, width: f64, height: f64) -> ((f64, f64), f64, f64):
    ((x, y), width, height)

# Get rectangle corners: top-left, top-right, bottom-right, bottom-left
fn rect_corners(rect: ((f64, f64), f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64), (f64, f64)):
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    val tl = pos
    val tr = (pos.0 + w, pos.1)
    val br = (pos.0 + w, pos.1 + h)
    val bl = (pos.0, pos.1 + h)
    (tl, tr, br, bl)

# Get rectangle center
fn rect_center(rect: ((f64, f64), f64, f64)) -> (f64, f64):
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    (pos.0 + w / 2.0, pos.1 + h / 2.0)

# Check if a rectangle contains a point
fn rect_contains_point(rect: ((f64, f64), f64, f64), p: (f64, f64)) -> bool:
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    p.0 >= pos.0 and p.0 <= pos.0 + w and p.1 >= pos.1 and p.1 <= pos.1 + h

# Check if two rectangles intersect
fn rect_intersects(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool:
    val pos1 = r1.0
    val w1 = r1.1
    val h1 = r1.2
    val pos2 = r2.0
    val w2 = r2.1
    val h2 = r2.2

    val left1 = pos1.0
    val right1 = pos1.0 + w1
    val top1 = pos1.1
    val bottom1 = pos1.1 + h1

    val left2 = pos2.0
    val right2 = pos2.0 + w2
    val top2 = pos2.1
    val bottom2 = pos2.1 + h2

    not (right1 < left2 or left1 > right2 or bottom1 < top2 or top1 > bottom2)

# Calculate the area of a rectangle
fn rect_area(rect: ((f64, f64), f64, f64)) -> f64:
    val w = rect.1
    val h = rect.2
    w * h

# Calculate the perimeter of a rectangle
fn rect_perimeter(rect: ((f64, f64), f64, f64)) -> f64:
    val w = rect.1
    val h = rect.2
    2.0 * (w + h)

# Get the intersection of two rectangles
# Returns nil if they don't intersect
fn rect_intersection(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> ((f64, f64), f64, f64)?:
    if not rect_intersects(r1, r2):
        nil
    else:
        val pos1 = r1.0
        val w1 = r1.1
        val h1 = r1.2
        val pos2 = r2.0
        val w2 = r2.1
        val h2 = r2.2

        val left = math.max(pos1.0, pos2.0)
        val top = math.max(pos1.1, pos2.1)
        val right = math.min(pos1.0 + w1, pos2.0 + w2)
        val bottom = math.min(pos1.1 + h1, pos2.1 + h2)

        ((left, top), right - left, bottom - top)

# ============================================================================
# Circle Operations
# ============================================================================

# A circle is represented as: ((x, y), radius)
# where (x, y) is the center

# Create a circle
fn circle_create(x: f64, y: f64, radius: f64) -> ((f64, f64), f64):
    ((x, y), radius)

# Get circle center
fn circle_center(circle: ((f64, f64), f64)) -> (f64, f64):
    circle.0

# Get circle radius
fn circle_radius(circle: ((f64, f64), f64)) -> f64:
    circle.1

# Check if a circle contains a point
fn circle_contains_point(circle: ((f64, f64), f64), p: (f64, f64)) -> bool:
    val center = circle.0
    val radius = circle.1
    val dist_sq = point_distance_squared(center, p)
    dist_sq <= radius * radius

# Check if two circles intersect
fn circle_intersects(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    val center1 = c1.0
    val radius1 = c1.1
    val center2 = c2.0
    val radius2 = c2.1
    val dist = point_distance(center1, center2)
    val sum_radii = radius1 + radius2
    dist <= sum_radii

# Check if a circle intersects a rectangle
fn circle_rect_intersects(circle: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool:
    val center = circle.0
    val radius = circle.1
    val pos = rect.0
    val w = rect.1
    val h = rect.2

    val closest_x = math.max(pos.0, math.min(center.0, pos.0 + w))
    val closest_y = math.max(pos.1, math.min(center.1, pos.1 + h))
    val closest = (closest_x, closest_y)

    val dist_sq = point_distance_squared(center, closest)
    dist_sq <= radius * radius

# Calculate the area of a circle
fn circle_area(circle: ((f64, f64), f64)) -> f64:
    val radius = circle.1
    math.pi() * radius * radius

# Calculate the circumference of a circle
fn circle_circumference(circle: ((f64, f64), f64)) -> f64:
    val radius = circle.1
    2.0 * math.pi() * radius

# Get a point on the circle at the given angle (radians)
fn circle_point_at_angle(circle: ((f64, f64), f64), angle: f64) -> (f64, f64):
    val center = circle.0
    val radius = circle.1
    val x = center.0 + radius * math.cos(angle)
    val y = center.1 + radius * math.sin(angle)
    (x, y)

# ============================================================================
# Triangle Operations
# ============================================================================

# A triangle is represented as three points: (p1, p2, p3)

# Create a triangle
fn triangle_create(p1: (f64, f64), p2: (f64, f64), p3: (f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64)):
    (p1, p2, p3)

# Calculate the area of a triangle using the cross product
fn triangle_area(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val v1 = vector_from_points(p1, p2)
    val v2 = vector_from_points(p1, p3)
    val cross = vector_cross(v1, v2)
    math.abs(cross) / 2.0

# Calculate the perimeter of a triangle
fn triangle_perimeter(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val d12 = point_distance(p1, p2)
    val d23 = point_distance(p2, p3)
    val d31 = point_distance(p3, p1)
    d12 + d23 + d31

# Calculate the centroid of a triangle
fn triangle_centroid(tri: ((f64, f64), (f64, f64), (f64, f64))) -> (f64, f64):
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val x = (p1.0 + p2.0 + p3.0) / 3.0
    val y = (p1.1 + p2.1 + p3.1) / 3.0
    (x, y)

# Check if a triangle contains a point (using barycentric coordinates)
fn triangle_contains_point(tri: ((f64, f64), (f64, f64), (f64, f64)), p: (f64, f64)) -> bool:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2

    val v0 = vector_from_points(p1, p3)
    val v1 = vector_from_points(p1, p2)
    val v2 = vector_from_points(p1, p)

    val dot00 = vector_dot(v0, v0)
    val dot01 = vector_dot(v0, v1)
    val dot02 = vector_dot(v0, v2)
    val dot11 = vector_dot(v1, v1)
    val dot12 = vector_dot(v1, v2)

    val denom = dot00 * dot11 - dot01 * dot01
    if math.abs(denom) < EPSILON:
        false
    else:
        val inv_denom = 1.0 / denom
        val u = (dot11 * dot02 - dot01 * dot12) * inv_denom
        val v = (dot00 * dot12 - dot01 * dot02) * inv_denom

        u >= 0.0 and v >= 0.0 and u + v <= 1.0

# Check if a triangle is clockwise
fn triangle_is_clockwise(tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val v1 = vector_from_points(p1, p2)
    val v2 = vector_from_points(p2, p3)
    val cross = vector_cross(v1, v2)
    cross < 0.0

# ============================================================================
# Polygon Operations
# ============================================================================

# A polygon is represented as a list of points: [(x1, y1), (x2, y2), ...]

# Calculate the signed area of a polygon (positive if counterclockwise)
fn polygon_signed_area(points: [(f64, f64)]) -> f64:
    val len = points.length()
    if len < 3:
        0.0
    else:
        var area = 0.0
        var i = 0
        while i < len:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]
            area = area + (p1.0 * p2.1 - p2.0 * p1.1)
            i = i + 1
        area / 2.0

# Calculate the area of a polygon
fn polygon_area(points: [(f64, f64)]) -> f64:
    math.abs(polygon_signed_area(points))

# Calculate the perimeter of a polygon
fn polygon_perimeter(points: [(f64, f64)]) -> f64:
    val len = points.length()
    if len < 2:
        0.0
    else:
        var perim = 0.0
        var i = 0
        while i < len:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]
            perim = perim + point_distance(p1, p2)
            i = i + 1
        perim

# Calculate the centroid of a polygon
fn polygon_centroid(points: [(f64, f64)]) -> (f64, f64):
    val len = points.length()
    if len == 0:
        (0.0, 0.0)
    else:
        var sum_x = 0.0
        var sum_y = 0.0
        var i = 0
        while i < len:
            val p = points[i]
            sum_x = sum_x + p.0
            sum_y = sum_y + p.1
            i = i + 1
        (sum_x / len as f64, sum_y / len as f64)

# Check if a polygon contains a point (ray casting algorithm)
fn polygon_contains_point(points: [(f64, f64)], p: (f64, f64)) -> bool:
    val len = points.length()
    if len < 3:
        false
    else:
        var inside = false
        var i = 0
        while i < len:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]

            val y_check = (p1.1 > p.1) != (p2.1 > p.1)
            if y_check:
                val x_intersect = (p2.0 - p1.0) * (p.1 - p1.1) / (p2.1 - p1.1) + p1.0
                if p.0 < x_intersect:
                    inside = not inside

            i = i + 1
        inside

# Check if a polygon is convex
fn polygon_is_convex(points: [(f64, f64)]) -> bool:
    val len = points.length()
    if len < 3:
        false
    else:
        var sign = 0.0
        var i = 0
        var is_convex = true
        while i < len and is_convex:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]
            val p3 = points[(i + 2) % len]

            val v1 = vector_from_points(p1, p2)
            val v2 = vector_from_points(p2, p3)
            val cross = vector_cross(v1, v2)

            if math.abs(cross) > EPSILON:
                if sign == 0.0:
                    sign = cross
                else:
                    if sign * cross < 0.0:
                        is_convex = false

            i = i + 1
        is_convex

# Compute the convex hull using Graham scan
# Returns points in counterclockwise order
fn polygon_convex_hull(points: [(f64, f64)]) -> [(f64, f64)]:
    val len = points.length()
    if len < 3:
        points
    else:
        # Find the point with lowest y-coordinate (and leftmost if tied)
        var lowest_idx = 0
        var i = 1
        while i < len:
            val curr = points[i]
            val lowest = points[lowest_idx]
            if curr.1 < lowest.1 or (curr.1 == lowest.1 and curr.0 < lowest.0):
                lowest_idx = i
            i = i + 1

        val pivot = points[lowest_idx]

        # Sort points by polar angle with respect to pivot
        var sorted_points = []
        i = 0
        while i < len:
            if i != lowest_idx:
                sorted_points = sorted_points + [points[i]]
            i = i + 1

        # Simple bubble sort by angle (good enough for small datasets)
        var n = sorted_points.length()
        var swapped = true
        while swapped:
            swapped = false
            i = 0
            while i < n - 1:
                val p1 = sorted_points[i]
                val p2 = sorted_points[i + 1]
                val v1 = vector_from_points(pivot, p1)
                val v2 = vector_from_points(pivot, p2)
                val cross = vector_cross(v1, v2)

                if cross < 0.0:
                    sorted_points = sorted_points[0..i] + [p2] + [p1] + sorted_points[i + 2..n]
                    swapped = true

                i = i + 1

        # Build convex hull
        var hull = [pivot]
        i = 0
        while i < sorted_points.length():
            val p = sorted_points[i]

            # Remove points that make clockwise turn
            var hull_len = hull.length()
            while hull_len >= 2:
                val p1 = hull[hull_len - 2]
                val p2 = hull[hull_len - 1]
                val v1 = vector_from_points(p1, p2)
                val v2 = vector_from_points(p2, p)
                val cross = vector_cross(v1, v2)

                if cross <= 0.0:
                    hull = hull[0..hull_len - 1]
                    hull_len = hull.length()
                else:
                    hull_len = 0  # Break the loop

            hull = hull + [p]
            i = i + 1

        hull

# ============================================================================
# Collision Detection
# ============================================================================

# Point-in-polygon test (alias for polygon_contains_point)
fn collision_point_in_polygon(polygon: [(f64, f64)], p: (f64, f64)) -> bool:
    polygon_contains_point(polygon, p)

# Circle-circle collision
fn collision_circle_circle(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    circle_intersects(c1, c2)

# Rectangle-rectangle collision
fn collision_rect_rect(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool:
    rect_intersects(r1, r2)

# Circle-rectangle collision
fn collision_circle_rect(circle: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool:
    circle_rect_intersects(circle, rect)

# Point-circle collision
fn collision_point_circle(p: (f64, f64), circle: ((f64, f64), f64)) -> bool:
    circle_contains_point(circle, p)

# Point-rectangle collision
fn collision_point_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> bool:
    rect_contains_point(rect, p)

# Point-triangle collision
fn collision_point_triangle(p: (f64, f64), tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool:
    triangle_contains_point(tri, p)

# Line segment intersection test
fn collision_line_line(l1: ((f64, f64), (f64, f64)), l2: ((f64, f64), (f64, f64))) -> bool:
    val p1 = l1.0
    val p2 = l1.1
    val p3 = l2.0
    val p4 = l2.1

    val d1 = vector_cross(vector_from_points(p3, p4), vector_from_points(p3, p1))
    val d2 = vector_cross(vector_from_points(p3, p4), vector_from_points(p3, p2))
    val d3 = vector_cross(vector_from_points(p1, p2), vector_from_points(p1, p3))
    val d4 = vector_cross(vector_from_points(p1, p2), vector_from_points(p1, p4))

    (d1 * d2 < 0.0 and d3 * d4 < 0.0) or (math.abs(d1) < EPSILON and line_point_on_segment(l2, p1)) or (math.abs(d2) < EPSILON and line_point_on_segment(l2, p2)) or (math.abs(d3) < EPSILON and line_point_on_segment(l1, p3)) or (math.abs(d4) < EPSILON and line_point_on_segment(l1, p4))

# Circle-line collision
fn collision_circle_line(circle: ((f64, f64), f64), line: ((f64, f64), (f64, f64))) -> bool:
    val center = circle.0
    val radius = circle.1
    val closest = line_closest_point(line, center)
    val dist = point_distance(center, closest)
    dist <= radius

# ============================================================================
# Transformation Operations
# ============================================================================

# Transform a point: translate, rotate, scale
fn transform_point(p: (f64, f64), translation: (f64, f64), rotation: f64, scale: f64) -> (f64, f64):
    var result = p
    result = point_scale(result, scale)
    result = point_rotate(result, rotation)
    result = point_translate(result, translation)
    result

# Transform multiple points
fn transform_points(points: [(f64, f64)], translation: (f64, f64), rotation: f64, scale: f64) -> [(f64, f64)]:
    var result = []
    var i = 0
    while i < points.length():
        val p = points[i]
        val transformed = transform_point(p, translation, rotation, scale)
        result = result + [transformed]
        i = i + 1
    result

# Create a 2D transformation matrix (as 6 values: a, b, c, d, e, f)
# Represents: [a c e]
#            [b d f]
#            [0 0 1]
fn transform_matrix_create(translation: (f64, f64), rotation: f64, scale: (f64, f64)) -> (f64, f64, f64, f64, f64, f64):
    val cos_r = math.cos(rotation)
    val sin_r = math.sin(rotation)
    val sx = scale.0
    val sy = scale.1
    val tx = translation.0
    val ty = translation.1

    val a = cos_r * sx
    val b = sin_r * sx
    val c = 0.0 - sin_r * sy
    val d = cos_r * sy
    val e = tx
    val f = ty

    (a, b, c, d, e, f)

# Apply a transformation matrix to a point
fn transform_matrix_apply(matrix: (f64, f64, f64, f64, f64, f64), p: (f64, f64)) -> (f64, f64):
    val a = matrix.0
    val b = matrix.1
    val c = matrix.2
    val d = matrix.3
    val e = matrix.4
    val f = matrix.5

    val x = a * p.0 + c * p.1 + e
    val y = b * p.0 + d * p.1 + f
    (x, y)

# Compose two transformation matrices
fn transform_matrix_compose(m1: (f64, f64, f64, f64, f64, f64), m2: (f64, f64, f64, f64, f64, f64)) -> (f64, f64, f64, f64, f64, f64):
    val a1 = m1.0
    val b1 = m1.1
    val c1 = m1.2
    val d1 = m1.3
    val e1 = m1.4
    val f1 = m1.5

    val a2 = m2.0
    val b2 = m2.1
    val c2 = m2.2
    val d2 = m2.3
    val e2 = m2.4
    val f2 = m2.5

    val a = a1 * a2 + c1 * b2
    val b = b1 * a2 + d1 * b2
    val c = a1 * c2 + c1 * d2
    val d = b1 * c2 + d1 * d2
    val e = a1 * e2 + c1 * f2 + e1
    val f = b1 * e2 + d1 * f2 + f1

    (a, b, c, d, e, f)

# ============================================================================
# Utility Functions
# ============================================================================

# Linear interpolation between two points
fn lerp_point(p1: (f64, f64), p2: (f64, f64), t: f64) -> (f64, f64):
    val x = p1.0 + (p2.0 - p1.0) * t
    val y = p1.1 + (p2.1 - p1.1) * t
    (x, y)

# Calculate the bounding box of a set of points
# Returns ((min_x, min_y), width, height)
fn bounding_box(points: [(f64, f64)]) -> ((f64, f64), f64, f64)?:
    val len = points.length()
    if len == 0:
        nil
    else:
        var min_x = points[0].0
        var max_x = points[0].0
        var min_y = points[0].1
        var max_y = points[0].1

        var i = 1
        while i < len:
            val p = points[i]
            min_x = math.min(min_x, p.0)
            max_x = math.max(max_x, p.0)
            min_y = math.min(min_y, p.1)
            max_y = math.max(max_y, p.1)
            i = i + 1

        ((min_x, min_y), max_x - min_x, max_y - min_y)

# Clamp a point to be within a rectangle
fn clamp_to_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> (f64, f64):
    val pos = rect.0
    val w = rect.1
    val h = rect.2

    val x = math.max(pos.0, math.min(p.0, pos.0 + w))
    val y = math.max(pos.1, math.min(p.1, pos.1 + h))
    (x, y)

# Calculate signed distance from a point to a line
fn distance_point_to_line(p: (f64, f64), line: ((f64, f64), (f64, f64))) -> f64:
    val p1 = line.0
    val p2 = line.1
    val line_vec = vector_from_points(p1, p2)
    val point_vec = vector_from_points(p1, p)
    val cross = vector_cross(line_vec, point_vec)
    val line_len = vector_magnitude(line_vec)
    if math.abs(line_len) < EPSILON:
        0.0
    else:
        cross / line_len

# Calculate angle from p1 to p2 relative to positive x-axis
fn angle_between_points(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val v = vector_from_points(p1, p2)
    vector_angle(v)

# Convert degrees to radians
fn degrees_to_radians(degrees: f64) -> f64:
    degrees * math.pi() / 180.0

# Convert radians to degrees
fn radians_to_degrees(radians: f64) -> f64:
    radians * 180.0 / math.pi()

# ============================================================================
# 3D Point Operations
# ============================================================================

# Create a 3D point at the given coordinates
fn point3d_create(x: f64, y: f64, z: f64) -> (f64, f64, f64):
    (x, y, z)

# Get the x coordinate of a 3D point
fn point3d_x(p: (f64, f64, f64)) -> f64:
    p.0

# Get the y coordinate of a 3D point
fn point3d_y(p: (f64, f64, f64)) -> f64:
    p.1

# Get the z coordinate of a 3D point
fn point3d_z(p: (f64, f64, f64)) -> f64:
    p.2

# Calculate the Euclidean distance between two 3D points
fn point3d_distance(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    val dz = p2.2 - p1.2
    val sum = dx * dx + dy * dy + dz * dz
    math.sqrt(sum)

# Calculate the squared distance between two 3D points
fn point3d_distance_squared(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    val dz = p2.2 - p1.2
    dx * dx + dy * dy + dz * dz

# Calculate the midpoint between two 3D points
fn point3d_midpoint(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> (f64, f64, f64):
    val mx = (p1.0 + p2.0) / 2.0
    val my = (p1.1 + p2.1) / 2.0
    val mz = (p1.2 + p2.2) / 2.0
    (mx, my, mz)

# Check if two 3D points are approximately equal
fn point3d_equal(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> bool:
    val dx = math.abs(p1.0 - p2.0)
    val dy = math.abs(p1.1 - p2.1)
    val dz = math.abs(p1.2 - p2.2)
    val check_x = dx < EPSILON
    val check_y = dy < EPSILON
    val check_z = dz < EPSILON
    check_x and check_y and check_z

# Translate a 3D point by the given offset
fn point3d_translate(p: (f64, f64, f64), offset: (f64, f64, f64)) -> (f64, f64, f64):
    val nx = p.0 + offset.0
    val ny = p.1 + offset.1
    val nz = p.2 + offset.2
    (nx, ny, nz)

# Scale a 3D point by the given factor from the origin
fn point3d_scale(p: (f64, f64, f64), factor: f64) -> (f64, f64, f64):
    val nx = p.0 * factor
    val ny = p.1 * factor
    val nz = p.2 * factor
    (nx, ny, nz)

# Scale a 3D point by different factors for x, y, and z
fn point3d_scale_xyz(p: (f64, f64, f64), sx: f64, sy: f64, sz: f64) -> (f64, f64, f64):
    val nx = p.0 * sx
    val ny = p.1 * sy
    val nz = p.2 * sz
    (nx, ny, nz)

# ============================================================================
# 3D Vector Operations
# ============================================================================

# Create a 3D vector from two points (from p1 to p2)
fn vector3d_from_points(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> (f64, f64, f64):
    val vx = p2.0 - p1.0
    val vy = p2.1 - p1.1
    val vz = p2.2 - p1.2
    (vx, vy, vz)

# Add two 3D vectors
fn vector3d_add(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val rx = v1.0 + v2.0
    val ry = v1.1 + v2.1
    val rz = v1.2 + v2.2
    (rx, ry, rz)

# Subtract two 3D vectors (v1 - v2)
fn vector3d_subtract(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val rx = v1.0 - v2.0
    val ry = v1.1 - v2.1
    val rz = v1.2 - v2.2
    (rx, ry, rz)

# Multiply a 3D vector by a scalar
fn vector3d_multiply(v: (f64, f64, f64), scalar: f64) -> (f64, f64, f64):
    val sx = v.0 * scalar
    val sy = v.1 * scalar
    val sz = v.2 * scalar
    (sx, sy, sz)

# Calculate the dot product of two 3D vectors
fn vector3d_dot(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> f64:
    v1.0 * v2.0 + v1.1 * v2.1 + v1.2 * v2.2

# Calculate the cross product of two 3D vectors
fn vector3d_cross(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val rx = v1.1 * v2.2 - v1.2 * v2.1
    val ry = v1.2 * v2.0 - v1.0 * v2.2
    val rz = v1.0 * v2.1 - v1.1 * v2.0
    (rx, ry, rz)

# Calculate the magnitude (length) of a 3D vector
fn vector3d_magnitude(v: (f64, f64, f64)) -> f64:
    val sum = v.0 * v.0 + v.1 * v.1 + v.2 * v.2
    math.sqrt(sum)

# Calculate the squared magnitude of a 3D vector
fn vector3d_magnitude_squared(v: (f64, f64, f64)) -> f64:
    v.0 * v.0 + v.1 * v.1 + v.2 * v.2

# Normalize a 3D vector (make it unit length)
fn vector3d_normalize(v: (f64, f64, f64)) -> (f64, f64, f64):
    val mag = vector3d_magnitude(v)
    if math.abs(mag) < EPSILON:
        (0.0, 0.0, 0.0)
    else:
        val nx = v.0 / mag
        val ny = v.1 / mag
        val nz = v.2 / mag
        (nx, ny, nz)

# Calculate the angle between two 3D vectors (radians)
fn vector3d_angle_between(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> f64:
    val dot = vector3d_dot(v1, v2)
    val mag1 = vector3d_magnitude(v1)
    val mag2 = vector3d_magnitude(v2)
    val denom = mag1 * mag2
    if math.abs(denom) < EPSILON:
        0.0
    else:
        val ratio = dot / denom
        math.acos(ratio)

# Project 3D vector v1 onto vector v2
fn vector3d_project(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val dot = vector3d_dot(v1, v2)
    val mag2_sq = vector3d_magnitude_squared(v2)
    if math.abs(mag2_sq) < EPSILON:
        (0.0, 0.0, 0.0)
    else:
        val scalar = dot / mag2_sq
        vector3d_multiply(v2, scalar)

# Reflect a 3D vector across a normal
fn vector3d_reflect(v: (f64, f64, f64), normal: (f64, f64, f64)) -> (f64, f64, f64):
    val dot = vector3d_dot(v, normal)
    val scaled = vector3d_multiply(normal, 2.0 * dot)
    vector3d_subtract(v, scaled)

# ============================================================================
# Extended Bounding Box Operations
# ============================================================================

# Create a bounding box that encompasses two bounding boxes (union)
fn bbox_union(b1: ((f64, f64), f64, f64), b2: ((f64, f64), f64, f64)) -> ((f64, f64), f64, f64):
    val pos1 = b1.0
    val w1 = b1.1
    val h1 = b1.2
    val pos2 = b2.0
    val w2 = b2.1
    val h2 = b2.2
    val min_x = math.min(pos1.0, pos2.0)
    val min_y = math.min(pos1.1, pos2.1)
    val max_x = math.max(pos1.0 + w1, pos2.0 + w2)
    val max_y = math.max(pos1.1 + h1, pos2.1 + h2)
    ((min_x, min_y), max_x - min_x, max_y - min_y)

# Expand a bounding box by a margin on all sides
fn bbox_expand(bbox: ((f64, f64), f64, f64), margin: f64) -> ((f64, f64), f64, f64):
    val pos = bbox.0
    val w = bbox.1
    val h = bbox.2
    val new_x = pos.0 - margin
    val new_y = pos.1 - margin
    val new_w = w + 2.0 * margin
    val new_h = h + 2.0 * margin
    ((new_x, new_y), new_w, new_h)

# Check if a bounding box contains a point
fn bbox_contains_point(bbox: ((f64, f64), f64, f64), p: (f64, f64)) -> bool:
    rect_contains_point(bbox, p)

# Get the area of a bounding box
fn bbox_area(bbox: ((f64, f64), f64, f64)) -> f64:
    rect_area(bbox)

# Get the center of a bounding box
fn bbox_center(bbox: ((f64, f64), f64, f64)) -> (f64, f64):
    rect_center(bbox)

# ============================================================================
# Extended Triangle Operations
# ============================================================================

# Calculate the circumcircle of a triangle (returns center and radius)
fn triangle_circumcircle(tri: ((f64, f64), (f64, f64), (f64, f64))) -> ((f64, f64), f64)?:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val ax = p1.0
    val ay = p1.1
    val bx = p2.0
    val by = p2.1
    val cx = p3.0
    val cy = p3.1
    val d = 2.0 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))
    if math.abs(d) < EPSILON:
        nil
    else:
        val ax2_ay2 = ax * ax + ay * ay
        val bx2_by2 = bx * bx + by * by
        val cx2_cy2 = cx * cx + cy * cy
        val ux = (ax2_ay2 * (by - cy) + bx2_by2 * (cy - ay) + cx2_cy2 * (ay - by)) / d
        val uy = (ax2_ay2 * (cx - bx) + bx2_by2 * (ax - cx) + cx2_cy2 * (bx - ax)) / d
        val center = (ux, uy)
        val radius = point_distance(center, p1)
        (center, radius)

# Calculate the incircle of a triangle (returns center and radius)
fn triangle_incircle(tri: ((f64, f64), (f64, f64), (f64, f64))) -> ((f64, f64), f64)?:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val a = point_distance(p2, p3)
    val b = point_distance(p1, p3)
    val c = point_distance(p1, p2)
    val perim = a + b + c
    if math.abs(perim) < EPSILON:
        nil
    else:
        val cx = (a * p1.0 + b * p2.0 + c * p3.0) / perim
        val cy = (a * p1.1 + b * p2.1 + c * p3.1) / perim
        val s = perim / 2.0
        val area = triangle_area(tri)
        val radius = area / s
        val center = (cx, cy)
        (center, radius)

# ============================================================================
# Extended Transformation Operations
# ============================================================================

# Reflect a 2D point across the X axis
fn transform_reflect_x(p: (f64, f64)) -> (f64, f64):
    val nx = p.0
    val ny = 0.0 - p.1
    (nx, ny)

# Reflect a 2D point across the Y axis
fn transform_reflect_y(p: (f64, f64)) -> (f64, f64):
    val nx = 0.0 - p.0
    val ny = p.1
    (nx, ny)

# Reflect a 2D point across the origin
fn transform_reflect_origin(p: (f64, f64)) -> (f64, f64):
    val nx = 0.0 - p.0
    val ny = 0.0 - p.1
    (nx, ny)

# Reflect a 2D point across a line defined by two points
fn transform_reflect_across_line(p: (f64, f64), line: ((f64, f64), (f64, f64))) -> (f64, f64):
    val p1 = line.0
    val p2 = line.1
    val line_vec = vector_from_points(p1, p2)
    val normalized = vector_normalize(line_vec)
    val point_vec = vector_from_points(p1, p)
    val dot = vector_dot(point_vec, normalized)
    val projection = vector_multiply(normalized, dot)
    val proj_point_x = p1.0 + projection.0
    val proj_point_y = p1.1 + projection.1
    val proj_point = (proj_point_x, proj_point_y)
    val reflected_x = 2.0 * proj_point.0 - p.0
    val reflected_y = 2.0 * proj_point.1 - p.1
    (reflected_x, reflected_y)

# Scale a 2D point from a given center point
fn transform_scale_from_center(p: (f64, f64), center: (f64, f64), sx: f64, sy: f64) -> (f64, f64):
    val translated = point_translate(p, (0.0 - center.0, 0.0 - center.1))
    val scaled = point_scale_xy(translated, sx, sy)
    point_translate(scaled, center)

# Rotate and translate a 2D point
fn transform_rotate_translate(p: (f64, f64), angle: f64, translation: (f64, f64)) -> (f64, f64):
    val rotated = point_rotate(p, angle)
    point_translate(rotated, translation)

# ============================================================================
# Line Segment Extended Operations
# ============================================================================

# Calculate the perpendicular distance from a point to a line segment
fn line_segment_distance_to_point(seg: ((f64, f64), (f64, f64)), p: (f64, f64)) -> f64:
    val closest = line_closest_point(seg, p)
    point_distance(p, closest)

# Check if two line segments intersect
fn line_segment_intersects(seg1: ((f64, f64), (f64, f64)), seg2: ((f64, f64), (f64, f64))) -> bool:
    collision_line_line(seg1, seg2)

# Find the intersection point of two line segments (returns nil if no intersection)
fn line_segment_intersection_point(seg1: ((f64, f64), (f64, f64)), seg2: ((f64, f64), (f64, f64))) -> (f64, f64)?:
    if not line_segment_intersects(seg1, seg2):
        nil
    else:
        line_intersection(seg1, seg2)

# ============================================================================
# Circle Extended Operations
# ============================================================================

# Check if two circles are tangent (externally or internally)
fn circle_is_tangent(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    val center1 = c1.0
    val radius1 = c1.1
    val center2 = c2.0
    val radius2 = c2.1
    val dist = point_distance(center1, center2)
    val sum_radii = radius1 + radius2
    val diff_radii = math.abs(radius1 - radius2)
    val is_external = math.abs(dist - sum_radii) < EPSILON
    val is_internal = math.abs(dist - diff_radii) < EPSILON
    is_external or is_internal

# Get the bounding box of a circle
fn circle_bounding_box(circle: ((f64, f64), f64)) -> ((f64, f64), f64, f64):
    val center = circle.0
    val radius = circle.1
    val x = center.0 - radius
    val y = center.1 - radius
    val w = 2.0 * radius
    val h = 2.0 * radius
    ((x, y), w, h)

# ============================================================================
# Advanced Utility Functions
# ============================================================================

# Check if three 2D points are collinear
fn collinear_2d(p1: (f64, f64), p2: (f64, f64), p3: (f64, f64)) -> bool:
    val v1 = vector_from_points(p1, p2)
    val v2 = vector_from_points(p1, p3)
    val cross = vector_cross(v1, v2)
    math.abs(cross) < EPSILON

# Check if four 3D points are coplanar
fn coplanar_3d(p1: (f64, f64, f64), p2: (f64, f64, f64), p3: (f64, f64, f64), p4: (f64, f64, f64)) -> bool:
    val v1 = vector3d_from_points(p1, p2)
    val v2 = vector3d_from_points(p1, p3)
    val v3 = vector3d_from_points(p1, p4)
    val normal = vector3d_cross(v1, v2)
    val dot = vector3d_dot(normal, v3)
    math.abs(dot) < EPSILON

# Normalize an angle to the range [0, 2*PI)
fn angle_normalize(angle: f64) -> f64:
    val pi = math.pi()
    val two_pi = 2.0 * pi
    var result = angle
    while result < 0.0:
        result = result + two_pi
    while result >= two_pi:
        result = result - two_pi
    result

# Calculate the signed angle difference (shortest rotation from a1 to a2)
fn angle_difference(a1: f64, a2: f64) -> f64:
    val pi = math.pi()
    val diff = angle_normalize(a2 - a1)
    if diff > pi:
        diff - 2.0 * pi
    else:
        diff

# Linear interpolation between two values
fn lerp(a: f64, b: f64, t: f64) -> f64:
    a + (b - a) * t

# Linear interpolation between two 3D points
fn lerp_point3d(p1: (f64, f64, f64), p2: (f64, f64, f64), t: f64) -> (f64, f64, f64):
    val x = lerp(p1.0, p2.0, t)
    val y = lerp(p1.1, p2.1, t)
    val z = lerp(p1.2, p2.2, t)
    (x, y, z)

# Clamp a value between min and max
fn clamp(value: f64, min_val: f64, max_val: f64) -> f64:
    math.max(min_val, math.min(max_val, value))

# Calculate the signed area of a simple polygon (positive if counterclockwise)
fn polygon_signed_area_simple(points: [(f64, f64)]) -> f64:
    polygon_signed_area(points)

# Calculate distance between a point and a polygon (minimum distance to any edge)
fn polygon_distance_to_point(points: [(f64, f64)], p: (f64, f64)) -> f64:
    val len = points.length()
    if len < 2:
        0.0
    else:
        var min_dist = line_segment_distance_to_point((points[0], points[1]), p)
        var i = 1
        while i < len:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]
            val seg = (p1, p2)
            val dist = line_segment_distance_to_point(seg, p)
            min_dist = math.min(min_dist, dist)
            i = i + 1
        min_dist
