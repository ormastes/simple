# 2D Geometry Utilities Library
#
# This module provides comprehensive 2D geometry operations including:
# - Point operations (distance, midpoint, rotation, translation)
# - Vector operations (add, subtract, dot, cross, magnitude, normalize)
# - Line operations (slope, intersection, parallel, perpendicular)
# - Shape operations (rectangles, circles, triangles, polygons)
# - Collision detection (point-in-polygon, circle-circle, rect-rect)
# - Transformations (rotate, scale, translate)
#
# All points are represented as tuples: (x, y)
# All angles are in radians unless otherwise specified

import "std/math" as math

# ============================================================================
# Constants
# ============================================================================

val EPSILON = 0.000001  # Small value for floating point comparisons

# ============================================================================
# Point Operations
# ============================================================================

# Create a point at the given coordinates
# Example: point_create(3.0, 4.0) -> (3.0, 4.0)
fn point_create(x: f64, y: f64) -> (f64, f64):
    (x, y)

# Get the x coordinate of a point
fn point_x(p: (f64, f64)) -> f64:
    p.0

# Get the y coordinate of a point
fn point_y(p: (f64, f64)) -> f64:
    p.1

# Calculate the Euclidean distance between two points
# Example: point_distance((0.0, 0.0), (3.0, 4.0)) -> 5.0
fn point_distance(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    math.sqrt(dx * dx + dy * dy)

# Calculate the squared distance between two points (faster, no sqrt)
# Useful for comparisons where actual distance isn't needed
fn point_distance_squared(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    dx * dx + dy * dy

# Calculate the midpoint between two points
# Example: point_midpoint((0.0, 0.0), (4.0, 6.0)) -> (2.0, 3.0)
fn point_midpoint(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64):
    ((p1.0 + p2.0) / 2.0, (p1.1 + p2.1) / 2.0)

# Rotate a point around the origin by the given angle (radians)
# Example: point_rotate((1.0, 0.0), PI/2) -> (0.0, 1.0)
fn point_rotate(p: (f64, f64), angle: f64) -> (f64, f64):
    val cos_a = math.cos(angle)
    val sin_a = math.sin(angle)
    val x = p.0 * cos_a - p.1 * sin_a
    val y = p.0 * sin_a + p.1 * cos_a
    (x, y)

# Rotate a point around a given center by the given angle (radians)
fn point_rotate_around(p: (f64, f64), center: (f64, f64), angle: f64) -> (f64, f64):
    val translated = (p.0 - center.0, p.1 - center.1)
    val rotated = point_rotate(translated, angle)
    (rotated.0 + center.0, rotated.1 + center.1)

# Translate a point by the given offset
# Example: point_translate((1.0, 2.0), (3.0, 4.0)) -> (4.0, 6.0)
fn point_translate(p: (f64, f64), offset: (f64, f64)) -> (f64, f64):
    (p.0 + offset.0, p.1 + offset.1)

# Scale a point by the given factor from the origin
# Example: point_scale((2.0, 3.0), 2.0) -> (4.0, 6.0)
fn point_scale(p: (f64, f64), factor: f64) -> (f64, f64):
    (p.0 * factor, p.1 * factor)

# Scale a point by different factors for x and y
fn point_scale_xy(p: (f64, f64), sx: f64, sy: f64) -> (f64, f64):
    (p.0 * sx, p.1 * sy)

# Check if two points are approximately equal (within EPSILON)
fn point_equal(p1: (f64, f64), p2: (f64, f64)) -> bool:
    val dx = math.abs(p1.0 - p2.0)
    val dy = math.abs(p1.1 - p2.1)
    dx < EPSILON and dy < EPSILON

# ============================================================================
# Vector Operations
# ============================================================================

# Create a vector from two points (from p1 to p2)
# Example: vector_from_points((1.0, 1.0), (4.0, 5.0)) -> (3.0, 4.0)
fn vector_from_points(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64):
    (p2.0 - p1.0, p2.1 - p1.1)

# Add two vectors
# Example: vector_add((1.0, 2.0), (3.0, 4.0)) -> (4.0, 6.0)
fn vector_add(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    (v1.0 + v2.0, v1.1 + v2.1)

# Subtract two vectors (v1 - v2)
# Example: vector_subtract((5.0, 7.0), (2.0, 3.0)) -> (3.0, 4.0)
fn vector_subtract(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    (v1.0 - v2.0, v1.1 - v2.1)

# Multiply a vector by a scalar
fn vector_multiply(v: (f64, f64), scalar: f64) -> (f64, f64):
    (v.0 * scalar, v.1 * scalar)

# Calculate the dot product of two vectors
# Example: vector_dot((1.0, 0.0), (0.0, 1.0)) -> 0.0
fn vector_dot(v1: (f64, f64), v2: (f64, f64)) -> f64:
    v1.0 * v2.0 + v1.1 * v2.1

# Calculate the cross product (z-component) of two 2D vectors
# Returns positive if v2 is counterclockwise from v1, negative if clockwise
# Example: vector_cross((1.0, 0.0), (0.0, 1.0)) -> 1.0
fn vector_cross(v1: (f64, f64), v2: (f64, f64)) -> f64:
    v1.0 * v2.1 - v1.1 * v2.0

# Calculate the magnitude (length) of a vector
# Example: vector_magnitude((3.0, 4.0)) -> 5.0
fn vector_magnitude(v: (f64, f64)) -> f64:
    math.sqrt(v.0 * v.0 + v.1 * v.1)

# Calculate the squared magnitude of a vector (faster)
fn vector_magnitude_squared(v: (f64, f64)) -> f64:
    v.0 * v.0 + v.1 * v.1

# Normalize a vector (make it unit length)
# Returns (0.0, 0.0) if the vector has zero length
# Example: vector_normalize((3.0, 4.0)) -> (0.6, 0.8)
fn vector_normalize(v: (f64, f64)) -> (f64, f64):
    val mag = vector_magnitude(v)
    if math.abs(mag) < EPSILON:
        (0.0, 0.0)
    else:
        (v.0 / mag, v.1 / mag)

# Calculate the angle of a vector from the positive x-axis (radians)
# Example: vector_angle((1.0, 1.0)) -> PI/4
fn vector_angle(v: (f64, f64)) -> f64:
    math.atan2(v.1, v.0)

# Calculate the angle between two vectors (radians)
fn vector_angle_between(v1: (f64, f64), v2: (f64, f64)) -> f64:
    val dot = vector_dot(v1, v2)
    val mag1 = vector_magnitude(v1)
    val mag2 = vector_magnitude(v2)
    val denom = mag1 * mag2
    if math.abs(denom) < EPSILON:
        0.0
    else:
        math.acos(dot / denom)

# Rotate a vector by 90 degrees counterclockwise
fn vector_perpendicular(v: (f64, f64)) -> (f64, f64):
    (0.0 - v.1, v.0)

# Project vector v1 onto vector v2
fn vector_project(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    val dot = vector_dot(v1, v2)
    val mag2_sq = vector_magnitude_squared(v2)
    if math.abs(mag2_sq) < EPSILON:
        (0.0, 0.0)
    else:
        val scalar = dot / mag2_sq
        vector_multiply(v2, scalar)

# Reflect a vector across a normal
fn vector_reflect(v: (f64, f64), normal: (f64, f64)) -> (f64, f64):
    val dot = vector_dot(v, normal)
    val scaled = vector_multiply(normal, 2.0 * dot)
    vector_subtract(v, scaled)

# ============================================================================
# Line Operations
# ============================================================================

# A line is represented as two points: ((x1, y1), (x2, y2))

# Create a line from two points
fn line_create(p1: (f64, f64), p2: (f64, f64)) -> ((f64, f64), (f64, f64)):
    (p1, p2)

# Calculate the slope of a line
# Returns nil if the line is vertical
fn line_slope(line: ((f64, f64), (f64, f64))) -> f64?:
    val p1 = line.0
    val p2 = line.1
    val dx = p2.0 - p1.0
    if math.abs(dx) < EPSILON:
        nil
    else:
        (p2.1 - p1.1) / dx

# Calculate the y-intercept of a line
# Returns nil if the line is vertical
fn line_y_intercept(line: ((f64, f64), (f64, f64))) -> f64?:
    val slope = line_slope(line)
    if slope == nil:
        nil
    else:
        val p1 = line.0
        p1.1 - slope * p1.0

# Check if two lines are parallel
fn line_parallel(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool:
    val v1 = vector_from_points(line1.0, line1.1)
    val v2 = vector_from_points(line2.0, line2.1)
    val cross = vector_cross(v1, v2)
    math.abs(cross) < EPSILON

# Check if two lines are perpendicular
fn line_perpendicular(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool:
    val v1 = vector_from_points(line1.0, line1.1)
    val v2 = vector_from_points(line2.0, line2.1)
    val dot = vector_dot(v1, v2)
    math.abs(dot) < EPSILON

# Find the intersection point of two lines
# Returns nil if lines are parallel or coincident
fn line_intersection(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> (f64, f64)?:
    val p1 = line1.0
    val p2 = line1.1
    val p3 = line2.0
    val p4 = line2.1

    val x1 = p1.0
    val y1 = p1.1
    val x2 = p2.0
    val y2 = p2.1
    val x3 = p3.0
    val y3 = p3.1
    val x4 = p4.0
    val y4 = p4.1

    val denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)

    if math.abs(denom) < EPSILON:
        nil
    else:
        val t_num = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)
        val t = t_num / denom
        val x = x1 + t * (x2 - x1)
        val y = y1 + t * (y2 - y1)
        (x, y)

# Check if a point lies on a line segment
fn line_point_on_segment(line: ((f64, f64), (f64, f64)), p: (f64, f64)) -> bool:
    val p1 = line.0
    val p2 = line.1

    val cross = vector_cross(vector_from_points(p1, p), vector_from_points(p1, p2))
    if math.abs(cross) > EPSILON:
        false
    else:
        val min_x = math.min(p1.0, p2.0)
        val max_x = math.max(p1.0, p2.0)
        val min_y = math.min(p1.1, p2.1)
        val max_y = math.max(p1.1, p2.1)
        p.0 >= min_x - EPSILON and p.0 <= max_x + EPSILON and p.1 >= min_y - EPSILON and p.1 <= max_y + EPSILON

# Calculate the length of a line segment
fn line_length(line: ((f64, f64), (f64, f64))) -> f64:
    point_distance(line.0, line.1)

# Find the closest point on a line segment to a given point
fn line_closest_point(line: ((f64, f64), (f64, f64)), p: (f64, f64)) -> (f64, f64):
    val p1 = line.0
    val p2 = line.1
    val line_vec = vector_from_points(p1, p2)
    val point_vec = vector_from_points(p1, p)

    val line_len_sq = vector_magnitude_squared(line_vec)

    if math.abs(line_len_sq) < EPSILON:
        p1
    else:
        val t = vector_dot(point_vec, line_vec) / line_len_sq
        if t < 0.0:
            p1
        else:
            if t > 1.0:
                p2
            else:
                (p1.0 + t * line_vec.0, p1.1 + t * line_vec.1)

# ============================================================================
# Rectangle Operations
# ============================================================================

# A rectangle is represented as: ((x, y), width, height)
# where (x, y) is the top-left corner

# Create a rectangle
fn rect_create(x: f64, y: f64, width: f64, height: f64) -> ((f64, f64), f64, f64):
    ((x, y), width, height)

# Get rectangle corners: top-left, top-right, bottom-right, bottom-left
fn rect_corners(rect: ((f64, f64), f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64), (f64, f64)):
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    val tl = pos
    val tr = (pos.0 + w, pos.1)
    val br = (pos.0 + w, pos.1 + h)
    val bl = (pos.0, pos.1 + h)
    (tl, tr, br, bl)

# Get rectangle center
fn rect_center(rect: ((f64, f64), f64, f64)) -> (f64, f64):
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    (pos.0 + w / 2.0, pos.1 + h / 2.0)

# Check if a rectangle contains a point
fn rect_contains_point(rect: ((f64, f64), f64, f64), p: (f64, f64)) -> bool:
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    p.0 >= pos.0 and p.0 <= pos.0 + w and p.1 >= pos.1 and p.1 <= pos.1 + h

# Check if two rectangles intersect
fn rect_intersects(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool:
    val pos1 = r1.0
    val w1 = r1.1
    val h1 = r1.2
    val pos2 = r2.0
    val w2 = r2.1
    val h2 = r2.2

    val left1 = pos1.0
    val right1 = pos1.0 + w1
    val top1 = pos1.1
    val bottom1 = pos1.1 + h1

    val left2 = pos2.0
    val right2 = pos2.0 + w2
    val top2 = pos2.1
    val bottom2 = pos2.1 + h2

    not (right1 < left2 or left1 > right2 or bottom1 < top2 or top1 > bottom2)

# Calculate the area of a rectangle
fn rect_area(rect: ((f64, f64), f64, f64)) -> f64:
    val w = rect.1
    val h = rect.2
    w * h

# Calculate the perimeter of a rectangle
fn rect_perimeter(rect: ((f64, f64), f64, f64)) -> f64:
    val w = rect.1
    val h = rect.2
    2.0 * (w + h)

# Get the intersection of two rectangles
# Returns nil if they don't intersect
fn rect_intersection(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> ((f64, f64), f64, f64)?:
    if not rect_intersects(r1, r2):
        nil
    else:
        val pos1 = r1.0
        val w1 = r1.1
        val h1 = r1.2
        val pos2 = r2.0
        val w2 = r2.1
        val h2 = r2.2

        val left = math.max(pos1.0, pos2.0)
        val top = math.max(pos1.1, pos2.1)
        val right = math.min(pos1.0 + w1, pos2.0 + w2)
        val bottom = math.min(pos1.1 + h1, pos2.1 + h2)

        ((left, top), right - left, bottom - top)

# ============================================================================
# Circle Operations
# ============================================================================

# A circle is represented as: ((x, y), radius)
# where (x, y) is the center

# Create a circle
fn circle_create(x: f64, y: f64, radius: f64) -> ((f64, f64), f64):
    ((x, y), radius)

# Get circle center
fn circle_center(circle: ((f64, f64), f64)) -> (f64, f64):
    circle.0

# Get circle radius
fn circle_radius(circle: ((f64, f64), f64)) -> f64:
    circle.1

# Check if a circle contains a point
fn circle_contains_point(circle: ((f64, f64), f64), p: (f64, f64)) -> bool:
    val center = circle.0
    val radius = circle.1
    val dist_sq = point_distance_squared(center, p)
    dist_sq <= radius * radius

# Check if two circles intersect
fn circle_intersects(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    val center1 = c1.0
    val radius1 = c1.1
    val center2 = c2.0
    val radius2 = c2.1
    val dist = point_distance(center1, center2)
    val sum_radii = radius1 + radius2
    dist <= sum_radii

# Check if a circle intersects a rectangle
fn circle_rect_intersects(circle: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool:
    val center = circle.0
    val radius = circle.1
    val pos = rect.0
    val w = rect.1
    val h = rect.2

    val closest_x = math.max(pos.0, math.min(center.0, pos.0 + w))
    val closest_y = math.max(pos.1, math.min(center.1, pos.1 + h))
    val closest = (closest_x, closest_y)

    val dist_sq = point_distance_squared(center, closest)
    dist_sq <= radius * radius

# Calculate the area of a circle
fn circle_area(circle: ((f64, f64), f64)) -> f64:
    val radius = circle.1
    math.pi() * radius * radius

# Calculate the circumference of a circle
fn circle_circumference(circle: ((f64, f64), f64)) -> f64:
    val radius = circle.1
    2.0 * math.pi() * radius

# Get a point on the circle at the given angle (radians)
fn circle_point_at_angle(circle: ((f64, f64), f64), angle: f64) -> (f64, f64):
    val center = circle.0
    val radius = circle.1
    val x = center.0 + radius * math.cos(angle)
    val y = center.1 + radius * math.sin(angle)
    (x, y)

# ============================================================================
# Triangle Operations
# ============================================================================

# A triangle is represented as three points: (p1, p2, p3)

# Create a triangle
fn triangle_create(p1: (f64, f64), p2: (f64, f64), p3: (f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64)):
    (p1, p2, p3)

# Calculate the area of a triangle using the cross product
fn triangle_area(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val v1 = vector_from_points(p1, p2)
    val v2 = vector_from_points(p1, p3)
    val cross = vector_cross(v1, v2)
    math.abs(cross) / 2.0

# Calculate the perimeter of a triangle
fn triangle_perimeter(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val d12 = point_distance(p1, p2)
    val d23 = point_distance(p2, p3)
    val d31 = point_distance(p3, p1)
    d12 + d23 + d31

# Calculate the centroid of a triangle
fn triangle_centroid(tri: ((f64, f64), (f64, f64), (f64, f64))) -> (f64, f64):
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val x = (p1.0 + p2.0 + p3.0) / 3.0
    val y = (p1.1 + p2.1 + p3.1) / 3.0
    (x, y)

# Check if a triangle contains a point (using barycentric coordinates)
fn triangle_contains_point(tri: ((f64, f64), (f64, f64), (f64, f64)), p: (f64, f64)) -> bool:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2

    val v0 = vector_from_points(p1, p3)
    val v1 = vector_from_points(p1, p2)
    val v2 = vector_from_points(p1, p)

    val dot00 = vector_dot(v0, v0)
    val dot01 = vector_dot(v0, v1)
    val dot02 = vector_dot(v0, v2)
    val dot11 = vector_dot(v1, v1)
    val dot12 = vector_dot(v1, v2)

    val denom = dot00 * dot11 - dot01 * dot01
    if math.abs(denom) < EPSILON:
        false
    else:
        val inv_denom = 1.0 / denom
        val u = (dot11 * dot02 - dot01 * dot12) * inv_denom
        val v = (dot00 * dot12 - dot01 * dot02) * inv_denom

        u >= 0.0 and v >= 0.0 and u + v <= 1.0

# Check if a triangle is clockwise
fn triangle_is_clockwise(tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val v1 = vector_from_points(p1, p2)
    val v2 = vector_from_points(p2, p3)
    val cross = vector_cross(v1, v2)
    cross < 0.0

# ============================================================================
# Polygon Operations
# ============================================================================

# A polygon is represented as a list of points: [(x1, y1), (x2, y2), ...]

# Calculate the signed area of a polygon (positive if counterclockwise)
fn polygon_signed_area(points: [(f64, f64)]) -> f64:
    val len = points.length()
    if len < 3:
        0.0
    else:
        var area = 0.0
        var i = 0
        while i < len:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]
            area = area + (p1.0 * p2.1 - p2.0 * p1.1)
            i = i + 1
        area / 2.0

# Calculate the area of a polygon
fn polygon_area(points: [(f64, f64)]) -> f64:
    math.abs(polygon_signed_area(points))

# Calculate the perimeter of a polygon
fn polygon_perimeter(points: [(f64, f64)]) -> f64:
    val len = points.length()
    if len < 2:
        0.0
    else:
        var perim = 0.0
        var i = 0
        while i < len:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]
            perim = perim + point_distance(p1, p2)
            i = i + 1
        perim

# Calculate the centroid of a polygon
fn polygon_centroid(points: [(f64, f64)]) -> (f64, f64):
    val len = points.length()
    if len == 0:
        (0.0, 0.0)
    else:
        var sum_x = 0.0
        var sum_y = 0.0
        var i = 0
        while i < len:
            val p = points[i]
            sum_x = sum_x + p.0
            sum_y = sum_y + p.1
            i = i + 1
        (sum_x / len as f64, sum_y / len as f64)

# Check if a polygon contains a point (ray casting algorithm)
fn polygon_contains_point(points: [(f64, f64)], p: (f64, f64)) -> bool:
    val len = points.length()
    if len < 3:
        false
    else:
        var inside = false
        var i = 0
        while i < len:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]

            val y_check = (p1.1 > p.1) != (p2.1 > p.1)
            if y_check:
                val x_intersect = (p2.0 - p1.0) * (p.1 - p1.1) / (p2.1 - p1.1) + p1.0
                if p.0 < x_intersect:
                    inside = not inside

            i = i + 1
        inside

# Check if a polygon is convex
fn polygon_is_convex(points: [(f64, f64)]) -> bool:
    val len = points.length()
    if len < 3:
        false
    else:
        var sign = 0.0
        var i = 0
        var is_convex = true
        while i < len and is_convex:
            val p1 = points[i]
            val p2 = points[(i + 1) % len]
            val p3 = points[(i + 2) % len]

            val v1 = vector_from_points(p1, p2)
            val v2 = vector_from_points(p2, p3)
            val cross = vector_cross(v1, v2)

            if math.abs(cross) > EPSILON:
                if sign == 0.0:
                    sign = cross
                else:
                    if sign * cross < 0.0:
                        is_convex = false

            i = i + 1
        is_convex

# Compute the convex hull using Graham scan
# Returns points in counterclockwise order
fn polygon_convex_hull(points: [(f64, f64)]) -> [(f64, f64)]:
    val len = points.length()
    if len < 3:
        points
    else:
        # Find the point with lowest y-coordinate (and leftmost if tied)
        var lowest_idx = 0
        var i = 1
        while i < len:
            val curr = points[i]
            val lowest = points[lowest_idx]
            if curr.1 < lowest.1 or (curr.1 == lowest.1 and curr.0 < lowest.0):
                lowest_idx = i
            i = i + 1

        val pivot = points[lowest_idx]

        # Sort points by polar angle with respect to pivot
        var sorted_points = []
        i = 0
        while i < len:
            if i != lowest_idx:
                sorted_points = sorted_points + [points[i]]
            i = i + 1

        # Simple bubble sort by angle (good enough for small datasets)
        var n = sorted_points.length()
        var swapped = true
        while swapped:
            swapped = false
            i = 0
            while i < n - 1:
                val p1 = sorted_points[i]
                val p2 = sorted_points[i + 1]
                val v1 = vector_from_points(pivot, p1)
                val v2 = vector_from_points(pivot, p2)
                val cross = vector_cross(v1, v2)

                if cross < 0.0:
                    sorted_points = sorted_points[0..i] + [p2] + [p1] + sorted_points[i + 2..n]
                    swapped = true

                i = i + 1

        # Build convex hull
        var hull = [pivot]
        i = 0
        while i < sorted_points.length():
            val p = sorted_points[i]

            # Remove points that make clockwise turn
            var hull_len = hull.length()
            while hull_len >= 2:
                val p1 = hull[hull_len - 2]
                val p2 = hull[hull_len - 1]
                val v1 = vector_from_points(p1, p2)
                val v2 = vector_from_points(p2, p)
                val cross = vector_cross(v1, v2)

                if cross <= 0.0:
                    hull = hull[0..hull_len - 1]
                    hull_len = hull.length()
                else:
                    hull_len = 0  # Break the loop

            hull = hull + [p]
            i = i + 1

        hull

# ============================================================================
# Collision Detection
# ============================================================================

# Point-in-polygon test (alias for polygon_contains_point)
fn collision_point_in_polygon(polygon: [(f64, f64)], p: (f64, f64)) -> bool:
    polygon_contains_point(polygon, p)

# Circle-circle collision
fn collision_circle_circle(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    circle_intersects(c1, c2)

# Rectangle-rectangle collision
fn collision_rect_rect(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool:
    rect_intersects(r1, r2)

# Circle-rectangle collision
fn collision_circle_rect(circle: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool:
    circle_rect_intersects(circle, rect)

# Point-circle collision
fn collision_point_circle(p: (f64, f64), circle: ((f64, f64), f64)) -> bool:
    circle_contains_point(circle, p)

# Point-rectangle collision
fn collision_point_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> bool:
    rect_contains_point(rect, p)

# Point-triangle collision
fn collision_point_triangle(p: (f64, f64), tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool:
    triangle_contains_point(tri, p)

# Line segment intersection test
fn collision_line_line(l1: ((f64, f64), (f64, f64)), l2: ((f64, f64), (f64, f64))) -> bool:
    val p1 = l1.0
    val p2 = l1.1
    val p3 = l2.0
    val p4 = l2.1

    val d1 = vector_cross(vector_from_points(p3, p4), vector_from_points(p3, p1))
    val d2 = vector_cross(vector_from_points(p3, p4), vector_from_points(p3, p2))
    val d3 = vector_cross(vector_from_points(p1, p2), vector_from_points(p1, p3))
    val d4 = vector_cross(vector_from_points(p1, p2), vector_from_points(p1, p4))

    (d1 * d2 < 0.0 and d3 * d4 < 0.0) or (math.abs(d1) < EPSILON and line_point_on_segment(l2, p1)) or (math.abs(d2) < EPSILON and line_point_on_segment(l2, p2)) or (math.abs(d3) < EPSILON and line_point_on_segment(l1, p3)) or (math.abs(d4) < EPSILON and line_point_on_segment(l1, p4))

# Circle-line collision
fn collision_circle_line(circle: ((f64, f64), f64), line: ((f64, f64), (f64, f64))) -> bool:
    val center = circle.0
    val radius = circle.1
    val closest = line_closest_point(line, center)
    val dist = point_distance(center, closest)
    dist <= radius

# ============================================================================
# Transformation Operations
# ============================================================================

# Transform a point: translate, rotate, scale
fn transform_point(p: (f64, f64), translation: (f64, f64), rotation: f64, scale: f64) -> (f64, f64):
    var result = p
    result = point_scale(result, scale)
    result = point_rotate(result, rotation)
    result = point_translate(result, translation)
    result

# Transform multiple points
fn transform_points(points: [(f64, f64)], translation: (f64, f64), rotation: f64, scale: f64) -> [(f64, f64)]:
    var result = []
    var i = 0
    while i < points.length():
        val p = points[i]
        val transformed = transform_point(p, translation, rotation, scale)
        result = result + [transformed]
        i = i + 1
    result

# Create a 2D transformation matrix (as 6 values: a, b, c, d, e, f)
# Represents: [a c e]
#            [b d f]
#            [0 0 1]
fn transform_matrix_create(translation: (f64, f64), rotation: f64, scale: (f64, f64)) -> (f64, f64, f64, f64, f64, f64):
    val cos_r = math.cos(rotation)
    val sin_r = math.sin(rotation)
    val sx = scale.0
    val sy = scale.1
    val tx = translation.0
    val ty = translation.1

    val a = cos_r * sx
    val b = sin_r * sx
    val c = 0.0 - sin_r * sy
    val d = cos_r * sy
    val e = tx
    val f = ty

    (a, b, c, d, e, f)

# Apply a transformation matrix to a point
fn transform_matrix_apply(matrix: (f64, f64, f64, f64, f64, f64), p: (f64, f64)) -> (f64, f64):
    val a = matrix.0
    val b = matrix.1
    val c = matrix.2
    val d = matrix.3
    val e = matrix.4
    val f = matrix.5

    val x = a * p.0 + c * p.1 + e
    val y = b * p.0 + d * p.1 + f
    (x, y)

# Compose two transformation matrices
fn transform_matrix_compose(m1: (f64, f64, f64, f64, f64, f64), m2: (f64, f64, f64, f64, f64, f64)) -> (f64, f64, f64, f64, f64, f64):
    val a1 = m1.0
    val b1 = m1.1
    val c1 = m1.2
    val d1 = m1.3
    val e1 = m1.4
    val f1 = m1.5

    val a2 = m2.0
    val b2 = m2.1
    val c2 = m2.2
    val d2 = m2.3
    val e2 = m2.4
    val f2 = m2.5

    val a = a1 * a2 + c1 * b2
    val b = b1 * a2 + d1 * b2
    val c = a1 * c2 + c1 * d2
    val d = b1 * c2 + d1 * d2
    val e = a1 * e2 + c1 * f2 + e1
    val f = b1 * e2 + d1 * f2 + f1

    (a, b, c, d, e, f)

# ============================================================================
# Utility Functions
# ============================================================================

# Linear interpolation between two points
fn lerp_point(p1: (f64, f64), p2: (f64, f64), t: f64) -> (f64, f64):
    val x = p1.0 + (p2.0 - p1.0) * t
    val y = p1.1 + (p2.1 - p1.1) * t
    (x, y)

# Calculate the bounding box of a set of points
# Returns ((min_x, min_y), width, height)
fn bounding_box(points: [(f64, f64)]) -> ((f64, f64), f64, f64)?:
    val len = points.length()
    if len == 0:
        nil
    else:
        var min_x = points[0].0
        var max_x = points[0].0
        var min_y = points[0].1
        var max_y = points[0].1

        var i = 1
        while i < len:
            val p = points[i]
            min_x = math.min(min_x, p.0)
            max_x = math.max(max_x, p.0)
            min_y = math.min(min_y, p.1)
            max_y = math.max(max_y, p.1)
            i = i + 1

        ((min_x, min_y), max_x - min_x, max_y - min_y)

# Clamp a point to be within a rectangle
fn clamp_to_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> (f64, f64):
    val pos = rect.0
    val w = rect.1
    val h = rect.2

    val x = math.max(pos.0, math.min(p.0, pos.0 + w))
    val y = math.max(pos.1, math.min(p.1, pos.1 + h))
    (x, y)

# Calculate signed distance from a point to a line
fn distance_point_to_line(p: (f64, f64), line: ((f64, f64), (f64, f64))) -> f64:
    val p1 = line.0
    val p2 = line.1
    val line_vec = vector_from_points(p1, p2)
    val point_vec = vector_from_points(p1, p)
    val cross = vector_cross(line_vec, point_vec)
    val line_len = vector_magnitude(line_vec)
    if math.abs(line_len) < EPSILON:
        0.0
    else:
        cross / line_len

# Calculate angle from p1 to p2 relative to positive x-axis
fn angle_between_points(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val v = vector_from_points(p1, p2)
    vector_angle(v)

# Convert degrees to radians
fn degrees_to_radians(degrees: f64) -> f64:
    degrees * math.pi() / 180.0

# Convert radians to degrees
fn radians_to_degrees(radians: f64) -> f64:
    radians * 180.0 / math.pi()
