# Combinatorics Utilities
#
# Helper functions for combinatorial mathematics and operations.
# Pure Simple implementation - no external dependencies.
#
# Provides permutations, combinations, factorials, and other
# combinatorial functions.
#
# Functions:
# - Factorials: factorial, factorial_tail, double_factorial
# - Binomial: binomial_coefficient, pascal_triangle
# - Permutations: permutations_count, permutations, next_permutation
# - Combinations: combinations_count, combinations
# - Partitions: integer_partitions, set_partitions
# - Sequences: fibonacci, catalan, stirling

# ============================================================================
# Factorial Functions
# ============================================================================

fn factorial(n: i64) -> i64:
    """Calculate factorial n!

    Returns 1 for n <= 0.
    Warning: Can overflow for large n.

    Example:
        factorial(5)  # 120
        factorial(0)  # 1
    """
    if n <= 0:
        return 1

    var result = 1
    var i = 1

    while i <= n:
        result = result * i
        i = i + 1

    result

fn factorial_tail(n: i64, acc: i64) -> i64:
    """Tail-recursive factorial.

    Example:
        factorial_tail(5, 1)  # 120
    """
    if n <= 0:
        return acc
    factorial_tail(n - 1, acc * n)

fn double_factorial(n: i64) -> i64:
    """Calculate double factorial n!!

    n!! = n * (n-2) * (n-4) * ... * 1 or 2

    Example:
        double_factorial(6)  # 48 (6*4*2)
        double_factorial(7)  # 105 (7*5*3*1)
    """
    if n <= 0:
        return 1

    var result = 1
    var i = n

    while i > 0:
        result = result * i
        i = i - 2

    result

fn falling_factorial(n: i64, k: i64) -> i64:
    """Calculate falling factorial (Pochhammer symbol).

    (n)_k = n * (n-1) * ... * (n-k+1)

    Example:
        falling_factorial(5, 3)  # 60 (5*4*3)
    """
    if k <= 0:
        return 1

    var result = 1
    var i = 0

    while i < k:
        result = result * (n - i)
        i = i + 1

    result

fn rising_factorial(n: i64, k: i64) -> i64:
    """Calculate rising factorial.

    n^(k) = n * (n+1) * ... * (n+k-1)

    Example:
        rising_factorial(5, 3)  # 210 (5*6*7)
    """
    if k <= 0:
        return 1

    var result = 1
    var i = 0

    while i < k:
        result = result * (n + i)
        i = i + 1

    result

# ============================================================================
# Binomial Coefficients
# ============================================================================

fn binomial_coefficient(n: i64, k: i64) -> i64:
    """Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)

    Number of ways to choose k items from n items.

    Example:
        binomial_coefficient(5, 2)  # 10
        binomial_coefficient(10, 3)  # 120
    """
    if k < 0 or k > n:
        return 0

    if k == 0 or k == n:
        return 1

    # Use symmetry: C(n, k) = C(n, n-k)
    var k_use = k
    if k > n - k:
        k_use = n - k

    var result = 1
    var i = 0

    while i < k_use:
        result = result * (n - i)
        result = result / (i + 1)
        i = i + 1

    result

fn pascal_triangle(rows: i64):
    """Generate Pascal's triangle up to n rows.

    Uses recurrence relation: each entry is sum of two entries above.
    Time: O(n^2), avoids redundant binomial_coefficient calls.

    Example:
        pascal_triangle(4)
        # [[1], [1,1], [1,2,1], [1,3,3,1]]
    """
    var triangle: [[i64]] = []
    for row_num in range(0, rows):
        var new_row: [i64] = [1]
        if row_num > 0:
            val prev = triangle[row_num - 1]
            for col in range(1, row_num):
                new_row = new_row.push(prev[col - 1] + prev[col])
            new_row = new_row.push(1)
        triangle = triangle.push(new_row)
    triangle

fn multinomial_coefficient(values):
    """Calculate multinomial coefficient.

    n! / (k1! * k2! * ... * km!) where n = sum(values)

    Example:
        multinomial_coefficient([2, 3, 1])  # 6! / (2! * 3! * 1!) = 60
    """
    var n = 0
    for value in values:
        n = n + value

    var numerator = factorial(n)
    var denominator = 1

    for value in values:
        denominator = denominator * factorial(value)

    numerator / denominator

# ============================================================================
# Permutations
# ============================================================================

fn permutations_count(n: i64, k: i64) -> i64:
    """Count permutations P(n, k) = n! / (n-k)!

    Number of ways to arrange k items from n items.

    Example:
        permutations_count(5, 2)  # 20
        permutations_count(5, 5)  # 120
    """
    if k < 0 or k > n:
        return 0

    falling_factorial(n, k)

fn permutations(arr, k: i64):
    """Generate all k-permutations of array.

    Returns array of permutations.
    Warning: Can be expensive for large inputs.

    Example:
        permutations([1, 2, 3], 2)
        # [[1,2], [1,3], [2,1], [2,3], [3,1], [3,2]]
    """
    if k <= 0:
        return [[]]

    if k > arr.len():
        return []

    var result = []

    var i = 0
    while i < arr.len():
        # Choose element at position i
        val elem = arr[i]

        # Create array without element i
        var remaining = []
        var j = 0
        while j < arr.len():
            if j != i:
                remaining.push(arr[j])
            j = j + 1

        # Get permutations of remaining elements
        val sub_perms = permutations(remaining, k - 1)

        # Add current element to each sub-permutation
        for sub_perm in sub_perms:
            var perm = [elem]
            for elem in sub_perm:
                perm.push(elem)
            result.push(perm)

        i = i + 1

    result

fn next_permutation(arr):
    """Generate next lexicographic permutation in-place.

    Returns true if next permutation exists, false otherwise.
    Modifies array in place.

    Example:
        var arr = [1, 2, 3]
        next_permutation(arr)  # arr becomes [1, 3, 2]
    """
    # Find largest index i such that arr[i] < arr[i+1]
    var i = arr.len() - 2
    while i >= 0:
        if arr[i] < arr[i + 1]:
            break
        i = i - 1

    if i < 0:
        # Already at last permutation
        return false

    # Find largest index j > i such that arr[i] < arr[j]
    var j = arr.len() - 1
    while j > i:
        if arr[i] < arr[j]:
            break
        j = j - 1

    # Swap arr[i] and arr[j]
    val temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp

    # Reverse suffix starting at arr[i+1]
    var left = i + 1
    var right = arr.len() - 1

    while left < right:
        val temp2 = arr[left]
        arr[left] = arr[right]
        arr[right] = temp2
        left = left + 1
        right = right - 1

    true

# ============================================================================
# Combinations
# ============================================================================

fn combinations_count(n: i64, k: i64) -> i64:
    """Count combinations C(n, k).

    Alias for binomial_coefficient.

    Example:
        combinations_count(5, 2)  # 10
    """
    binomial_coefficient(n, k)

fn combinations(arr, k: i64):
    """Generate all k-combinations of array.

    Returns array of combinations.
    Warning: Can be expensive for large inputs.

    Example:
        combinations([1, 2, 3], 2)
        # [[1,2], [1,3], [2,3]]
    """
    if k <= 0:
        return [[]]

    if k > arr.len():
        return []

    if k == arr.len():
        return [arr]

    var result = []

    # Include first element
    val first = arr[0]
    var rest = []
    var i = 1
    while i < arr.len():
        rest.push(arr[i])
        i = i + 1

    # Combinations including first element
    val with_first = combinations(rest, k - 1)
    for combo in with_first:
        var new_combo = [first]
        for elem in combo:
            new_combo.push(elem)
        result.push(new_combo)

    # Combinations not including first element
    val without_first = combinations(rest, k)
    for combo in without_first:
        result.push(combo)

    result

fn combinations_with_replacement(arr, k: i64):
    """Generate k-combinations with replacement.

    Elements can be repeated.

    Example:
        combinations_with_replacement([1, 2], 2)
        # [[1,1], [1,2], [2,2]]
    """
    if k <= 0:
        return [[]]

    if arr.len() == 0:
        return []

    var result = []

    var i = 0
    while i < arr.len():
        val elem = arr[i]

        # Create subarray from current position onward
        var subarray = []
        var j = i
        while j < arr.len():
            subarray.push(arr[j])
            j = j + 1

        # Get combinations of remaining positions
        val sub_combos = combinations_with_replacement(subarray, k - 1)

        for combo in sub_combos:
            var new_combo = [elem]
            for e in combo:
                new_combo.push(e)
            result.push(new_combo)

        i = i + 1

    result

# ============================================================================
# Power Set
# ============================================================================

fn power_set(arr):
    """Generate power set (all subsets).

    Warning: Returns 2^n subsets.

    Example:
        power_set([1, 2])
        # [[], [1], [2], [1,2]]
    """
    if arr.len() == 0:
        return [[]]

    val first = arr[0]
    var rest = []
    var i = 1
    while i < arr.len():
        rest.push(arr[i])
        i = i + 1

    val subsets_without = power_set(rest)
    var result = []

    # Add subsets without first element
    for subset in subsets_without:
        result.push(subset)

    # Add subsets with first element
    for subset in subsets_without:
        var with_first = [first]
        for elem in subset:
            with_first.push(elem)
        result.push(with_first)

    result

fn power_set_size(n: i64) -> i64:
    """Calculate size of power set (2^n).

    Example:
        power_set_size(5)  # 32
    """
    var result = 1
    var i = 0

    while i < n:
        result = result * 2
        i = i + 1

    result

# ============================================================================
# Integer Partitions
# ============================================================================

fn count_partitions(n: i64) -> i64:
    """Count integer partitions of n.

    Uses dynamic programming.

    Example:
        count_partitions(5)  # 7
        # (5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1)
    """
    if n <= 0:
        return 0

    # Dynamic programming table
    var dp = []
    var i = 0
    while i <= n:
        dp.push(0)
        i = i + 1

    dp[0] = 1

    var num = 1
    while num <= n:
        i = num
        while i <= n:
            dp[i] = dp[i] + dp[i - num]
            i = i + 1
        num = num + 1

    dp[n]

fn integer_partitions_helper(n: i64, max_val: i64):
    """Helper for generating integer partitions."""
    if n == 0:
        return [[]]

    if max_val == 0:
        return []

    var result = []

    # Partitions using max_val
    if max_val <= n:
        val with_max = integer_partitions_helper(n - max_val, max_val)
        for partition in with_max:
            var new_partition = [max_val]
            for elem in partition:
                new_partition.push(elem)
            result.push(new_partition)

    # Partitions not using max_val
    val without_max = integer_partitions_helper(n, max_val - 1)
    for partition in without_max:
        result.push(partition)

    result

fn integer_partitions(n: i64):
    """Generate all integer partitions of n.

    Warning: Can be expensive for large n.

    Example:
        integer_partitions(4)
        # [[4], [3,1], [2,2], [2,1,1], [1,1,1,1]]
    """
    integer_partitions_helper(n, n)

# ============================================================================
# Famous Sequences
# ============================================================================

fn fibonacci(n: i64) -> i64:
    """Calculate nth Fibonacci number.

    F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)

    Example:
        fibonacci(10)  # 55
    """
    if n <= 0:
        return 0
    if n == 1:
        return 1

    var prev = 0
    var curr = 1
    var i = 2

    while i <= n:
        val next = prev + curr
        prev = curr
        curr = next
        i = i + 1

    curr

fn fibonacci_sequence(n: i64):
    """Generate first n Fibonacci numbers.

    Example:
        fibonacci_sequence(7)  # [0, 1, 1, 2, 3, 5, 8]
    """
    var result = []
    var i = 0

    while i < n:
        result.push(fibonacci(i))
        i = i + 1

    result

fn catalan(n: i64) -> i64:
    """Calculate nth Catalan number.

    C(n) = (2n)! / ((n+1)! * n!)

    Example:
        catalan(4)  # 14
    """
    if n <= 1:
        return 1

    binomial_coefficient(2 * n, n) / (n + 1)

fn catalan_sequence(n: i64):
    """Generate first n Catalan numbers.

    Example:
        catalan_sequence(5)  # [1, 1, 2, 5, 14]
    """
    var result = []
    var i = 0

    while i < n:
        result.push(catalan(i))
        i = i + 1

    result

fn stirling_second_kind(n: i64, k: i64) -> i64:
    """Calculate Stirling number of second kind S(n, k).

    Number of ways to partition n objects into k non-empty subsets.

    Example:
        stirling_second_kind(4, 2)  # 7
    """
    if n == 0 and k == 0:
        return 1
    if n == 0 or k == 0:
        return 0
    if k > n:
        return 0

    # S(n, k) = k * S(n-1, k) + S(n-1, k-1)
    var dp = []
    var i = 0
    while i <= n:
        var row = []
        var j = 0
        while j <= k:
            row.push(0)
            j = j + 1
        dp.push(row)
        i = i + 1

    dp[0][0] = 1

    i = 1
    while i <= n:
        var j = 1
        while j <= k and j <= i:
            dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1]
            j = j + 1
        i = i + 1

    dp[n][k]

fn bell_number(n: i64) -> i64:
    """Calculate nth Bell number.

    Number of ways to partition n elements.
    B(n) = sum of S(n, k) for k = 0 to n.

    Example:
        bell_number(3)  # 5
    """
    var sum = 0
    var k = 0

    while k <= n:
        sum = sum + stirling_second_kind(n, k)
        k = k + 1

    sum

# ============================================================================
# Derangements
# ============================================================================

fn derangements(n: i64) -> i64:
    """Calculate number of derangements of n elements.

    Derangement = permutation where no element is in its original position.

    Example:
        derangements(3)  # 2
        # [2,3,1] and [3,1,2]
    """
    if n == 0:
        return 1
    if n == 1:
        return 0

    var d_prev_prev = 1
    var d_prev = 0
    var i = 2

    while i <= n:
        val d_curr = (i - 1) * (d_prev + d_prev_prev)
        d_prev_prev = d_prev
        d_prev = d_curr
        i = i + 1

    d_prev
