# Functional Programming Library
#
# Consolidated functional programming utilities for Simple.
# Pure Simple implementation - no external dependencies.
#
# This module consolidates:
# - Core functional primitives (identity, constant, apply)
# - Function composition and piping
# - Higher-order array functions (map, filter, fold, scan)
# - Option type helpers (map, unwrap, filter, zip)
# - Result type helpers (map, unwrap, map_err)
# - Iteration and generation utilities
# - Predicates and combinators
#
# Note: Runtime limitations:
# - Closures can read but not modify outer variables
# - Generic functions not available at runtime
#
# Total Functions: 83

# ============================================================================
# Section 1: Core Functional Primitives
# ============================================================================

fn identity(x):
    """Identity function - returns its argument unchanged.

    Useful as default function or placeholder.

    Example:
        identity(42)  # 42
    """
    x

fn constant(value):
    """Create a function that always returns the same value.

    Note: Returns a function that takes one argument.

    Example:
        val always_42 = constant(42)
        always_42(1)  # 42
        always_42(2)  # 42
    """
    \x: value

fn apply(f, x):
    """Apply function f to value x.

    Explicit function application.

    Example:
        apply(\x: x * 2, 5)  # 10
    """
    f(x)

# ============================================================================
# Section 2: Function Composition
# ============================================================================

fn pipe_two(x, f, g):
    """Pipe value through two functions: g(f(x)).

    Example:
        pipe_two(5, \x: x * 2, \x: x + 1)  # 11
    """
    g(f(x))

fn pipe_three(x, f, g, h):
    """Pipe value through three functions: h(g(f(x))).

    Example:
        pipe_three(5, \x: x * 2, \x: x + 1, \x: x * 10)  # 110
    """
    h(g(f(x)))

fn compose_two(f, g):
    """Compose two functions: returns \x: g(f(x)).

    Example:
        val double_then_inc = compose_two(\x: x * 2, \x: x + 1)
        double_then_inc(5)  # 11
    """
    \x: g(f(x))

# ============================================================================
# Section 3: Higher-Order Array Functions
# ============================================================================

fn map_with_index(arr, f):
    """Map with index: f receives (element, index).

    Example:
        map_with_index([10,20,30], \x, i: x + i)
        # [10, 21, 32]
    """
    var result = []
    var i = 0
    while i < arr.len():
        result.push(f(arr[i], i))
        i = i + 1
    result

fn filter_with_index(arr, predicate):
    """Filter with index: predicate receives (element, index).

    Example:
        filter_with_index([10,20,30,40], \x, i: i % 2 == 0)
        # [10, 30]
    """
    var result = []
    var i = 0
    while i < arr.len():
        if predicate(arr[i], i):
            result.push(arr[i])
        i = i + 1
    result

fn fold_left(arr, initial, f):
    """Left fold (reduce): f(accumulator, element).

    Example:
        fold_left([1,2,3,4], 0, \acc, x: acc + x)  # 10
    """
    var acc = initial
    for item in arr:
        acc = f(acc, item)
    acc

fn fold_right(arr, initial, f):
    """Right fold: f(element, accumulator).

    Processes array from right to left.

    Example:
        fold_right([1,2,3], 0, \x, acc: x - acc)
        # 1 - (2 - (3 - 0)) = 2
    """
    var acc = initial
    var i = arr.len() - 1
    while i >= 0:
        acc = f(arr[i], acc)
        i = i - 1
    acc

fn scan_left(arr, initial, f):
    """Scan (cumulative fold): returns all intermediate results.

    Example:
        scan_left([1,2,3], 0, \acc, x: acc + x)
        # [0, 1, 3, 6]
    """
    var result = [initial]
    var acc = initial
    for item in arr:
        acc = f(acc, item)
        result.push(acc)
    result

fn zip_with(arr1, arr2, f):
    """Zip two arrays with a combining function.

    Example:
        zip_with([1,2,3], [4,5,6], \a, b: a + b)
        # [5, 7, 9]
    """
    var result = []
    var len = arr1.len()
    if arr2.len() < len:
        len = arr2.len()

    var i = 0
    while i < len:
        result.push(f(arr1[i], arr2[i]))
        i = i + 1

    result

fn unzip_pairs(arr):
    """Unzip array of pairs into two arrays.

    Example:
        unzip_pairs([(1,2), (3,4), (5,6)])
        # ([1,3,5], [2,4,6])
    """
    var first = []
    var second = []

    for (a, b) in arr:
        first.push(a)
        second.push(b)

    (first, second)

# ============================================================================
# Section 4: Predicates and Combinators
# ============================================================================

fn all_predicate(arr, predicate):
    """Check if predicate is true for all elements.

    Example:
        all_predicate([2,4,6], \x: x % 2 == 0)  # true
    """
    for item in arr:
        if not predicate(item):
            return false
    true

fn any_predicate(arr, predicate):
    """Check if predicate is true for any element.

    Example:
        any_predicate([1,3,5,6], \x: x % 2 == 0)  # true
    """
    for item in arr:
        if predicate(item):
            return true
    false

fn none_predicate(arr, predicate):
    """Check if predicate is false for all elements.

    Example:
        none_predicate([1,3,5], \x: x % 2 == 0)  # true
    """
    for item in arr:
        if predicate(item):
            return false
    true

fn count_where(arr, predicate):
    """Count elements matching predicate.

    Example:
        count_where([1,2,3,4,5], \x: x % 2 == 0)  # 2
    """
    var count = 0
    for item in arr:
        if predicate(item):
            count = count + 1
    count

# ============================================================================
# Section 5: Iteration Helpers
# ============================================================================

fn times(n: i64, f: fn(i64)):
    """Execute function n times with index as argument.

    Example:
        times(3, \i: print("Iteration {i}"))
    """
    var i = 0
    while i < n:
        f(i)
        i = i + 1

fn repeat_value(n: i64, value) -> []:
    """Create array with value repeated n times.

    Example:
        repeat_value(3, 42)  # [42, 42, 42]
    """
    var result = []
    var i = 0
    while i < n:
        result.push(value)
        i = i + 1
    result

fn iterate(f, initial, n: i64):
    """Apply function repeatedly, collecting results.

    Returns array: [initial, f(initial), f(f(initial)), ...]

    Example:
        iterate(\x: x * 2, 1, 4)  # [1, 2, 4, 8]
    """
    var result = [initial]
    var current = initial
    var i = 1
    while i < n:
        current = f(current)
        result.push(current)
        i = i + 1
    result

fn until_predicate(f, predicate, initial, max_iterations: i64):
    """Apply function repeatedly until predicate is true.

    Returns array of intermediate values.
    Stops at max_iterations to prevent infinite loops.

    Example:
        until_predicate(\x: x + 1, \x: x > 5, 0, 100)
        # [0, 1, 2, 3, 4, 5, 6]
    """
    var result = [initial]
    var current = initial
    var i = 0

    while not predicate(current) and i < max_iterations:
        current = f(current)
        result.push(current)
        i = i + 1

    result

# ============================================================================
# Section 6: Array Utilities
# ============================================================================

fn take_while(arr, predicate):
    """Take elements while predicate is true.

    Example:
        take_while([1,2,3,4,2,1], \x: x < 4)  # [1,2,3]
    """
    var result = []
    for item in arr:
        if not predicate(item):
            break
        result.push(item)
    result

fn drop_while(arr, predicate):
    """Drop elements while predicate is true.

    Example:
        drop_while([1,2,3,4,5], \x: x < 3)  # [3,4,5]
    """
    var i = 0
    while i < arr.len():
        if not predicate(arr[i]):
            break
        i = i + 1

    var result = []
    while i < arr.len():
        result.push(arr[i])
        i = i + 1

    result

fn find_first(arr, predicate):
    """Find first element matching predicate.

    Returns Some(element) or nil.

    Example:
        find_first([1,2,3,4], \x: x > 2)  # Some(3)
    """
    for item in arr:
        if predicate(item):
            return Some(item)
    nil

fn find_last(arr, predicate):
    """Find last element matching predicate.

    Returns Some(element) or nil.

    Example:
        find_last([1,2,3,4,3,2], \x: x > 2)  # Some(3)
    """
    var result = nil
    for item in arr:
        if predicate(item):
            result = Some(item)
    result

# ============================================================================
# Section 7: Array Generation
# ============================================================================

fn generate(n: i64, f: fn(i64)):
    """Generate array by applying function to indices.

    Example:
        generate(5, \i: i * i)  # [0, 1, 4, 9, 16]
    """
    var result = []
    var i = 0
    while i < n:
        result.push(f(i))
        i = i + 1
    result

fn range_step(start: i64, end: i64, step: i64) -> [i64]:
    """Generate range with custom step.

    Example:
        range_step(0, 10, 2)  # [0, 2, 4, 6, 8]
    """
    var result = []
    var i = start
    if step > 0:
        while i < end:
            result.push(i)
            i = i + step
    elif step < 0:
        while i > end:
            result.push(i)
            i = i + step
    result

# ============================================================================
# Section 8: Simple Memoization
# ============================================================================

fn memoize_simple(f: fn(i64) -> i64, max_cache: i64):
    """Simple memoization for i64 -> i64 functions.

    Returns a new function that caches results.
    Cache is a simple array of (input, output) pairs.
    Limited to max_cache entries.

    Note: This is a simplified version due to runtime limitations.

    Example:
        val fib = \n: if n <= 1: n else: fib(n-1) + fib(n-2)
        val memo_fib = memoize_simple(fib, 100)
        # (In practice, this won't work perfectly due to closure issues)
    """
    var cache = []

    fn memoized(x: i64) -> i64:
        # Check cache
        for (input, output) in cache:
            if input == x:
                return output

        # Compute and cache
        val result = f(x)

        if cache.len() < max_cache:
            cache.push((x, result))

        result

    memoized

# ============================================================================
# Section 9: Option Type Helpers
# ============================================================================

fn option_unwrap_or(opt, default_val):
    """Unwrap Option or return default value.

    Example:
        option_unwrap_or(Some(42), 0)  # 42
        option_unwrap_or(nil, 0)       # 0
    """
    if val x = opt:
        x
    else:
        default_val

fn option_unwrap_or_else(opt, f: fn()):
    """Unwrap Option or call function to get default.

    Lazy evaluation - function only called if nil.

    Example:
        option_unwrap_or_else(Some(42), \: expensive_default())
    """
    if val x = opt:
        x
    else:
        f()

fn option_map(opt, f):
    """Map function over Option value.

    Example:
        option_map(Some(5), \x: x * 2)  # Some(10)
        option_map(nil, \x: x * 2)       # nil
    """
    if val x = opt:
        Some(f(x))
    else:
        nil

fn option_flat_map(opt, f):
    """FlatMap function over Option (f returns Option).

    Example:
        option_flat_map(Some(5), \x: Some(x * 2))  # Some(10)
        option_flat_map(Some(5), \x: nil)          # nil
        option_flat_map(nil, \x: Some(x * 2))      # nil
    """
    if val x = opt:
        f(x)
    else:
        nil

fn option_filter(opt, predicate):
    """Filter Option by predicate.

    Returns Some if predicate is true, nil otherwise.

    Example:
        option_filter(Some(5), \x: x > 3)  # Some(5)
        option_filter(Some(2), \x: x > 3)  # nil
    """
    if val x = opt:
        if predicate(x):
            Some(x)
        else:
            nil
    else:
        nil

fn option_or_else(opt, f: fn()):
    """Return Option or call function to get alternative Option.

    Example:
        option_or_else(Some(5), \: Some(0))  # Some(5)
        option_or_else(nil, \: Some(0))      # Some(0)
    """
    if opt.?:
        opt
    else:
        f()

fn option_and_then(opt1, opt2):
    """Return second Option if first is Some, nil otherwise.

    Example:
        option_and_then(Some(5), Some(10))  # Some(10)
        option_and_then(nil, Some(10))      # nil
    """
    if opt1.?:
        opt2
    else:
        nil

fn option_zip(opt1, opt2):
    """Combine two Options into Option of tuple.

    Returns Some((a, b)) if both are Some, nil otherwise.

    Example:
        option_zip(Some(1), Some(2))  # Some((1, 2))
        option_zip(Some(1), nil)      # nil
    """
    if val a = opt1:
        if val b = opt2:
            return Some((a, b))
    nil

fn option_zip_with(opt1, opt2, f):
    """Combine two Options with function.

    Example:
        option_zip_with(Some(2), Some(3), \a, b: a + b)  # Some(5)
    """
    if val a = opt1:
        if val b = opt2:
            return Some(f(a, b))
    nil

fn option_sequence(opts):
    """Convert array of Options to Option of array.

    Returns Some([...]) if all are Some, nil if any is nil.

    Example:
        option_sequence([Some(1), Some(2), Some(3)])  # Some([1,2,3])
        option_sequence([Some(1), nil, Some(3)])      # nil
    """
    var values = []

    for opt in opts:
        if val x = opt:
            values.push(x)
        else:
            return nil

    Some(values)

fn option_all_some(opts):
    """Check if all Options are Some.

    Example:
        option_all_some([Some(1), Some(2)])  # true
        option_all_some([Some(1), nil])      # false
    """
    for opt in opts:
        if not opt.?:
            return false
    true

fn option_any_some(opts):
    """Check if any Option is Some.

    Example:
        option_any_some([nil, Some(2), nil])  # true
        option_any_some([nil, nil])           # false
    """
    for opt in opts:
        if opt.?:
            return true
    false

fn option_first_some(opts):
    """Get first Some value from array of Options.

    Returns first Some found, or nil if all are nil.

    Example:
        option_first_some([nil, Some(2), Some(3)])  # Some(2)
    """
    for opt in opts:
        if opt.?:
            return opt
    nil

fn option_flatten(nested_opt):
    """Flatten Option<Option<T>> to Option<T>.

    Example:
        option_flatten(Some(Some(5)))  # Some(5)
        option_flatten(Some(nil))      # nil
        option_flatten(nil)            # nil
    """
    if val outer = nested_opt:
        outer
    else:
        nil

fn option_is_some(opt):
    """Check if Option is Some.

    Example:
        option_is_some(Some(5))  # true
        option_is_some(nil)      # false
    """
    opt.?

fn option_is_none(opt):
    """Check if Option is None (nil).

    Example:
        option_is_none(nil)      # true
        option_is_none(Some(5))  # false
    """
    not opt.?

fn option_contains(opt, value):
    """Check if Option contains specific value.

    Example:
        option_contains(Some(5), 5)  # true
        option_contains(Some(5), 3)  # false
        option_contains(nil, 5)      # false
    """
    if val x = opt:
        x == value
    else:
        false

fn option_to_array(opt):
    """Convert Option to array.

    Returns [value] if Some, [] if nil.

    Example:
        option_to_array(Some(5))  # [5]
        option_to_array(nil)      # []
    """
    if val x = opt:
        [x]
    else:
        []

fn option_from_array(arr):
    """Convert array to Option.

    Returns Some(first) if non-empty, nil if empty.

    Example:
        option_from_array([1,2,3])  # Some(1)
        option_from_array([])       # nil
    """
    if arr.len() > 0:
        Some(arr[0])
    else:
        nil

fn option_iter(opt, f: fn()):
    """Execute function if Some, do nothing if nil.

    Example:
        option_iter(Some(5), \x: print(x))  # prints 5
        option_iter(nil, \x: print(x))      # does nothing
    """
    if val x = opt:
        f(x)

fn option_for_each(opts, f: fn()):
    """Execute function for each Some value in array of Options.

    Example:
        option_for_each([Some(1), nil, Some(3)], \x: print(x))
        # prints 1, then 3
    """
    for opt in opts:
        if val x = opt:
            f(x)

fn option_from_nullable(value, null_check: fn() -> bool):
    """Create Option from potentially null value.

    null_check function should return true if value is "null".

    Example:
        option_from_nullable(0, \: false)  # Some(0)
        option_from_nullable(0, \: true)   # nil
    """
    if null_check():
        nil
    else:
        Some(value)

fn option_from_predicate(value, predicate):
    """Create Some if predicate is true, nil otherwise.

    Example:
        option_from_predicate(5, \x: x > 3)  # Some(5)
        option_from_predicate(2, \x: x > 3)  # nil
    """
    if predicate(value):
        Some(value)
    else:
        nil

fn option_merge(opt1, opt2, merger):
    """Merge two Options with merger function.

    - If both Some: merger(a, b)
    - If one Some: that value
    - If both nil: nil

    Example:
        option_merge(Some(2), Some(3), \a, b: a + b)  # Some(5)
        option_merge(Some(2), nil, \a, b: a + b)      # Some(2)
    """
    if val a = opt1:
        if val b = opt2:
            return Some(merger(a, b))
        else:
            return Some(a)
    else:
        if val b = opt2:
            return Some(b)
        else:
            return nil

fn option_choose(opt1, opt2):
    """Choose first Some value.

    Returns opt1 if Some, otherwise opt2.

    Example:
        option_choose(Some(1), Some(2))  # Some(1)
        option_choose(nil, Some(2))      # Some(2)
    """
    if opt1.?:
        opt1
    else:
        opt2

fn option_choose_many(opts):
    """Choose first Some value from array.

    Example:
        option_choose_many([nil, nil, Some(3), Some(4)])  # Some(3)
    """
    for opt in opts:
        if opt.?:
            return opt
    nil

# ============================================================================
# Section 10: Result Type Helpers
# ============================================================================

fn Ok(value):
    """Create an Ok Result.

    Example:
        val result = Ok(42)
    """
    (ok: value, err: nil)

fn Err(error):
    """Create an Err Result.

    Example:
        val result = Err("File not found")
    """
    (ok: nil, err: error)

fn result_is_ok(result):
    """Check if Result is Ok.

    Example:
        result_is_ok(Ok(42))  # true
        result_is_ok(Err("error"))  # false
    """
    if val (ok: value, err: _) = result:
        value.?
    else:
        false

fn result_is_err(result):
    """Check if Result is Err.

    Example:
        result_is_err(Err("error"))  # true
        result_is_err(Ok(42))  # false
    """
    if val (ok: _, err: error) = result:
        error.?
    else:
        false

fn result_unwrap_or(result, default_val):
    """Unwrap Ok value or return default.

    Example:
        result_unwrap_or(Ok(42), 0)  # 42
        result_unwrap_or(Err("e"), 0)  # 0
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return value
    default_val

fn result_unwrap_err_or(result, default_err):
    """Unwrap Err value or return default error.

    Example:
        result_unwrap_err_or(Err("bad"), "none")  # "bad"
        result_unwrap_err_or(Ok(42), "none")  # "none"
    """
    if val (ok: _, err: error) = result:
        if error.?:
            return error
    default_err

fn result_unwrap_or_else(result, f: fn()):
    """Unwrap Ok value or call function to get default.

    Lazy evaluation - function only called if Err.

    Example:
        result_unwrap_or_else(Ok(42), \: expensive_default())
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return value
    f()

fn result_map(result, f):
    """Map function over Ok value.

    Example:
        result_map(Ok(5), \x: x * 2)  # Ok(10)
        result_map(Err("e"), \x: x * 2)  # Err("e")
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return Ok(f(value))
    result

fn result_map_err(result, f):
    """Map function over Err value.

    Example:
        result_map_err(Err("io"), \e: "Error: {e}")  # Err("Error: io")
        result_map_err(Ok(5), \e: "Error: {e}")  # Ok(5)
    """
    if val (ok: _, err: error) = result:
        if error.?:
            return Err(f(error))
    result

fn result_flat_map(result, f):
    """FlatMap function over Result (f returns Result).

    Example:
        result_flat_map(Ok(5), \x: Ok(x * 2))  # Ok(10)
        result_flat_map(Ok(5), \x: Err("bad"))  # Err("bad")
        result_flat_map(Err("e"), \x: Ok(x * 2))  # Err("e")
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return f(value)
    result

fn result_and_then(result1, result2):
    """Return second Result if first is Ok, first if Err.

    Example:
        result_and_then(Ok(5), Ok(10))  # Ok(10)
        result_and_then(Err("e"), Ok(10))  # Err("e")
        result_and_then(Ok(5), Err("e"))  # Err("e")
    """
    if result_is_ok(result1):
        result2
    else:
        result1

fn result_or_else(result, f: fn()):
    """Return Result or call function to get alternative Result.

    Example:
        result_or_else(Ok(5), \: Ok(0))  # Ok(5)
        result_or_else(Err("e"), \: Ok(0))  # Ok(0)
    """
    if result_is_ok(result):
        result
    else:
        f()

fn result_or(result1, result2):
    """Return first Ok Result, or second if first is Err.

    Example:
        result_or(Ok(5), Ok(10))  # Ok(5)
        result_or(Err("e"), Ok(10))  # Ok(10)
        result_or(Err("e1"), Err("e2"))  # Err("e2")
    """
    if result_is_ok(result1):
        result1
    else:
        result2

fn result_flatten(nested_result):
    """Flatten Result<Result<T>> to Result<T>.

    Example:
        result_flatten(Ok(Ok(5)))  # Ok(5)
        result_flatten(Ok(Err("e")))  # Err("e")
        result_flatten(Err("e"))  # Err("e")
    """
    if val (ok: value, err: _) = nested_result:
        if value.?:
            return value
    nested_result

fn result_transpose_opt(result):
    """Convert Result<Option<T>> to Option<Result<T>>.

    Example:
        result_transpose_opt(Ok(Some(5)))  # Some(Ok(5))
        result_transpose_opt(Ok(nil))  # nil
        result_transpose_opt(Err("e"))  # Some(Err("e"))
    """
    if val (ok: value, err: _) = result:
        if value.?:
            if value.?:
                return Some(Ok(value))
            else:
                return nil
    elif val (ok: _, err: error) = result:
        if error.?:
            return Some(Err(error))
    nil

fn result_ok(result):
    """Extract Ok value as Option.

    Returns Some(value) if Ok, nil if Err.

    Example:
        result_ok(Ok(42))  # Some(42)
        result_ok(Err("e"))  # nil
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return Some(value)
    nil

fn result_err(result):
    """Extract Err value as Option.

    Returns Some(error) if Err, nil if Ok.

    Example:
        result_err(Err("bad"))  # Some("bad")
        result_err(Ok(42))  # nil
    """
    if val (ok: _, err: error) = result:
        if error.?:
            return Some(error)
    nil

fn result_collect(results):
    """Convert array of Results to Result of array.

    Returns Ok([...]) if all are Ok, Err(first_error) if any is Err.

    Example:
        result_collect([Ok(1), Ok(2), Ok(3)])  # Ok([1,2,3])
        result_collect([Ok(1), Err("e"), Ok(3)])  # Err("e")
    """
    var values = []

    for result in results:
        if val (ok: value, err: _) = result:
            if value.?:
                values.push(value)
            else:
                return result
        elif val (ok: _, err: error) = result:
            if error.?:
                return result

    Ok(values)

fn result_all_ok(results):
    """Check if all Results are Ok.

    Example:
        result_all_ok([Ok(1), Ok(2)])  # true
        result_all_ok([Ok(1), Err("e")])  # false
    """
    for result in results:
        if not result_is_ok(result):
            return false
    true

fn result_any_ok(results):
    """Check if any Result is Ok.

    Example:
        result_any_ok([Err("e1"), Ok(2), Err("e2")])  # true
        result_any_ok([Err("e1"), Err("e2")])  # false
    """
    for result in results:
        if result_is_ok(result):
            return true
    false

fn result_first_ok(results):
    """Get first Ok Result from array.

    Returns first Ok found, or last Err if all are Err.

    Example:
        result_first_ok([Err("e1"), Ok(2), Ok(3)])  # Ok(2)
        result_first_ok([Err("e1"), Err("e2")])  # Err("e2")
    """
    var last_err = nil
    for result in results:
        if result_is_ok(result):
            return result
        else:
            last_err = result
    last_err ?? Err("No results")

fn result_partition(results):
    """Partition Results into Ok values and Err values.

    Returns tuple of ([ok_values], [err_values]).

    Example:
        result_partition([Ok(1), Err("e1"), Ok(3), Err("e2")])
        # ([1, 3], ["e1", "e2"])
    """
    var oks = []
    var errs = []

    for result in results:
        if val (ok: value, err: _) = result:
            if value.?:
                oks.push(value)
        elif val (ok: _, err: error) = result:
            if error.?:
                errs.push(error)

    (oks, errs)

fn result_iter(result, f: fn()):
    """Execute function if Ok, do nothing if Err.

    Example:
        result_iter(Ok(5), \x: print(x))  # prints 5
        result_iter(Err("e"), \x: print(x))  # does nothing
    """
    if val (ok: value, err: _) = result:
        if value.?:
            f(value)

fn result_iter_err(result, f: fn()):
    """Execute function if Err, do nothing if Ok.

    Example:
        result_iter_err(Err("bad"), \e: print("Error: {e}"))
    """
    if val (ok: _, err: error) = result:
        if error.?:
            f(error)

fn result_zip(result1, result2):
    """Combine two Results into Result of tuple.

    Returns Ok((a, b)) if both are Ok, Err otherwise.

    Example:
        result_zip(Ok(1), Ok(2))  # Ok((1, 2))
        result_zip(Ok(1), Err("e"))  # Err("e")
        result_zip(Err("e1"), Err("e2"))  # Err("e1")
    """
    if val (ok: value1, err: _) = result1:
        if value1.?:
            if val (ok: value2, err: _) = result2:
                if value2.?:
                    return Ok((value1, value2))

    # Return first error encountered
    if result_is_err(result1):
        return result1
    result2

fn result_zip_with(result1, result2, f):
    """Combine two Results with function.

    Example:
        result_zip_with(Ok(2), Ok(3), \a, b: a + b)  # Ok(5)
        result_zip_with(Ok(2), Err("e"), \a, b: a + b)  # Err("e")
    """
    if val (ok: value1, err: _) = result1:
        if value1.?:
            if val (ok: value2, err: _) = result2:
                if value2.?:
                    return Ok(f(value1, value2))

    if result_is_err(result1):
        return result1
    result2

fn result_from_option(opt, error_message):
    """Convert Option to Result.

    Returns Ok(value) if Some, Err(error_message) if nil.

    Example:
        result_from_option(Some(42), "missing")  # Ok(42)
        result_from_option(nil, "missing")  # Err("missing")
    """
    if val value = opt:
        Ok(value)
    else:
        Err(error_message)

fn result_from_predicate(value, predicate, error_message):
    """Create Ok if predicate is true, Err otherwise.

    Example:
        result_from_predicate(5, \x: x > 3, "too small")  # Ok(5)
        result_from_predicate(2, \x: x > 3, "too small")  # Err("too small")
    """
    if predicate(value):
        Ok(value)
    else:
        Err(error_message)

fn result_to_option(result):
    """Convert Result to Option, discarding error.

    Example:
        result_to_option(Ok(42))  # Some(42)
        result_to_option(Err("e"))  # nil
    """
    result_ok(result)
