# Feature Documentation Framework
# Provides metadata, registry, and documentation generation for features.

# Feature metadata
struct FeatureMetadata:
    id: i64
    name: text
    category: text
    difficulty: i64
    status: text
    impl_type: text
    spec_ref: text
    files: [text]
    tests: [text]
    description: text
    code_examples: [text]
    dependencies: [i64]
    required_by: [i64]
    notes: text

# Module-level registry
var _registry: [FeatureMetadata] = []

# Clear the feature registry
fn clear_feature_registry():
    _registry = []

# Register a feature
fn register_feature(meta: FeatureMetadata):
    _registry = _registry.merge([meta])

# Get all registered features
fn get_all_features() -> [FeatureMetadata]:
    _registry

# Get features by category
fn get_features_by_category(cat: text) -> [FeatureMetadata]:
    var result: [FeatureMetadata] = []
    for f in _registry:
        if f.category == cat:
            result = result.merge([f])
    result

# Get all unique categories
fn get_all_categories() -> [text]:
    var cats: [text] = []
    for f in _registry:
        var found = false
        for c in cats:
            if c == f.category:
                found = true
        if not found:
            cats = cats.merge([f.category])
    cats

# Get difficulty label
fn get_difficulty_label(level: i64) -> text:
    if level == 1:
        "Trivial"
    elif level == 2:
        "Easy"
    elif level == 3:
        "Medium"
    elif level == 4:
        "Hard"
    elif level == 5:
        "Very Hard"
    else:
        "Unknown"

# Format feature filename with zero-padded ID
fn format_feature_filename(id: i64, name: text) -> text:
    val lower_name = name.lower().replace(" ", "_")
    if id < 10:
        "000{id}_{lower_name}.md"
    elif id < 100:
        "00{id}_{lower_name}.md"
    elif id < 1000:
        "0{id}_{lower_name}.md"
    else:
        "{id}_{lower_name}.md"

# Generate markdown documentation for a single feature
fn generate_feature_doc(id: i64) -> text?:
    for f in _registry:
        if f.id == id:
            var md = "# {f.name}\n\n"
            md = md + "| Property | Value |\n"
            md = md + "|----------|-------|\n"
            md = md + "| **Feature ID** | #{f.id} |\n"
            md = md + "| **Category** | {f.category} |\n"
            md = md + "| **Difficulty** | {get_difficulty_label(f.difficulty)} |\n"
            md = md + "| **Status** | {f.status} |\n"
            md = md + "| **Implementation** | {f.impl_type} |\n"
            md = md + "\n## Description\n\n{f.description}\n"
            if f.notes.len() > 0:
                md = md + "\n## Notes\n\n{f.notes}\n"
            return Some(md)
    nil

# Generate category index
fn generate_category_index(cat: text) -> text:
    val features = get_features_by_category(cat)
    var md = "# {cat} Features\n\n"
    for f in features:
        md = md + "- [{f.name}]({format_feature_filename(f.id, f.name)})\n"
    md

# Generate master index
fn generate_master_index() -> text:
    val cats = get_all_categories()
    val all = get_all_features()
    var md = "# Feature Index\n\n"
    md = md + "## Summary\n\n"
    md = md + "Total features: {all.len()}\n\n"
    md = md + "## Categories\n\n"
    for cat in cats:
        val cat_features = get_features_by_category(cat)
        md = md + "### {cat}\n\n"
        for f in cat_features:
            md = md + "- {f.name} (#{f.id})\n"
        md = md + "\n"
    md
