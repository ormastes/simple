# Environment Detection for Skip/Ignore System
# Comprehensive detection of platform, runtime, architecture, features, hardware, etc.
# NOTE: No global var caching due to runtime module var limitation

# ================================================================
# EXTERNAL DEPENDENCIES (Runtime FFI)
# ================================================================

extern fn rt_env_get(key: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

# ================================================================
# 1. PLATFORM DETECTION
# ================================================================

fn _detect_platform_os() -> text:
    """Internal: Detect platform OS name."""
    val os_env = rt_env_get("OS")
    if os_env != nil and os_env.lower().contains("windows"):
        return "windows"

    # Unix: use uname -s
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "uname -s"])
    if code == 0:
        val os = stdout.trim()
        if os == "Linux":
            return "linux"
        if os == "Darwin":
            return "macos"
        if os == "FreeBSD":
            return "freebsd"
        if os == "OpenBSD":
            return "openbsd"
        if os == "NetBSD":
            return "netbsd"
        return os.lower()

    "linux"  # Default

fn get_platform_os() -> text:
    """Get platform OS name: 'windows', 'linux', 'macos', 'freebsd', etc."""
    _detect_platform_os()

fn is_windows() -> bool:
    """Check if running on Windows."""
    get_platform_os() == "windows"

fn is_linux() -> bool:
    """Check if running on Linux."""
    get_platform_os() == "linux"

fn is_macos() -> bool:
    """Check if running on macOS."""
    get_platform_os() == "macos"

fn is_unix() -> bool:
    """Check if running on Unix-like system (not Windows)."""
    get_platform_os() != "windows"

fn is_bsd() -> bool:
    """Check if running on BSD variant."""
    val os = get_platform_os()
    os == "freebsd" or os == "openbsd" or os == "netbsd"

# ================================================================
# 2. RUNTIME MODE DETECTION
# ================================================================

fn get_runtime_mode() -> text:
    """Get runtime mode: 'interpreter', 'compiled', 'jit', 'aot'."""

    # Check environment variable first
    val mode_env = rt_env_get("SIMPLE_RUNTIME_MODE")
    if mode_env != nil:
        return mode_env.lower()

    # Heuristic: Check if running from interpreter
    val interp_env = rt_env_get("SIMPLE_INTERPRETER")
    if interp_env == "1":
        return "interpreter"

    # Check if JIT enabled
    val jit_env = rt_env_get("SIMPLE_JIT")
    if jit_env == "1":
        return "jit"

    # Default: assume interpreter (bootstrap binary is an interpreter)
    "interpreter"

fn is_interpreter() -> bool:
    """Check if running in interpreter mode."""
    get_runtime_mode() == "interpreter"

fn is_compiled() -> bool:
    """Check if running in compiled mode."""
    val mode = get_runtime_mode()
    mode == "compiled" or mode == "aot"

fn is_jit() -> bool:
    """Check if JIT compilation is enabled."""
    get_runtime_mode() == "jit"

# ================================================================
# 3. BUILD PROFILE DETECTION
# ================================================================

fn get_build_profile() -> text:
    """Get build profile: 'debug', 'release', 'bootstrap', 'test'."""

    val profile_env = rt_env_get("SIMPLE_BUILD_PROFILE")
    if profile_env != nil:
        return profile_env.lower()

    # Heuristic: Check for debug symbols or optimization flags
    val debug_env = rt_env_get("SIMPLE_DEBUG")
    if debug_env == "1":
        return "debug"

    # Check if bootstrap mode
    val bootstrap_env = rt_env_get("SIMPLE_BOOTSTRAP")
    if bootstrap_env == "1":
        return "bootstrap"

    # Default: release
    "release"

fn is_debug() -> bool:
    """Check if running in debug build."""
    get_build_profile() == "debug"

fn is_release() -> bool:
    """Check if running in release build."""
    get_build_profile() == "release"

fn is_bootstrap() -> bool:
    """Check if running in bootstrap build."""
    get_build_profile() == "bootstrap"

# ================================================================
# 4. ARCHITECTURE DETECTION
# ================================================================

fn get_architecture() -> text:
    """Get CPU architecture: 'x86_64', 'aarch64', 'arm64', 'riscv64', etc."""

    # Try environment variable first
    val arch_env = rt_env_get("SIMPLE_ARCH")
    if arch_env != nil:
        return arch_env.lower()

    # Use uname -m
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "uname -m"])
    if code == 0:
        val arch = stdout.trim().lower()
        if arch == "x86_64" or arch == "amd64":
            return "x86_64"
        if arch == "aarch64":
            return "aarch64"
        if arch == "arm64":
            return "arm64"
        if arch == "riscv64":
            return "riscv64"
        if arch == "armv7l":
            return "arm32"
        if arch == "i686":
            return "x86"
        return arch

    "x86_64"  # Default

fn get_pointer_size() -> i64:
    """Get pointer size in bits: 32 or 64."""
    val arch = get_architecture()
    if arch == "x86_64" or arch == "aarch64" or arch == "arm64" or arch == "riscv64":
        return 64
    if arch == "x86" or arch == "arm32":
        return 32
    64  # Default

fn is_x86_64() -> bool:
    """Check if running on x86_64 architecture."""
    get_architecture() == "x86_64"

fn is_aarch64() -> bool:
    """Check if running on aarch64 architecture."""
    val arch = get_architecture()
    arch == "aarch64" or arch == "arm64"

fn is_64bit() -> bool:
    """Check if running on 64-bit architecture."""
    get_pointer_size() == 64

fn is_32bit() -> bool:
    """Check if running on 32-bit architecture."""
    get_pointer_size() == 32

# ================================================================
# 5. FEATURE FLAG DETECTION
# ================================================================

fn has_feature(feature: text) -> bool:
    """Check if compiler feature is enabled."""
    val env_key = "SIMPLE_FEATURE_{feature.to_upper()}"
    val feature_env = rt_env_get(env_key)
    feature_env == "1"

fn has_generics() -> bool:
    """Check if generics are supported."""
    has_feature("generics")

fn has_async() -> bool:
    """Check if async/await is supported."""
    has_feature("async")

fn has_macros() -> bool:
    """Check if macro system is supported."""
    has_feature("macros")

fn has_effects() -> bool:
    """Check if effect system is supported."""
    has_feature("effects")

fn has_inline_asm() -> bool:
    """Check if inline assembly is supported."""
    has_feature("inline_asm")

# ================================================================
# 6. HARDWARE CAPABILITY DETECTION
# ================================================================

fn has_gpu() -> bool:
    """Check if GPU is available."""
    # Check for CUDA
    val (stdout_cuda, stderr_cuda, code_cuda) = rt_process_run("/bin/sh", ["-c", "which nvidia-smi 2>/dev/null"])
    if code_cuda == 0:
        return true

    # Check for AMD ROCm
    val (stdout_rocm, stderr_rocm, code_rocm) = rt_process_run("/bin/sh", ["-c", "which rocm-smi 2>/dev/null"])
    if code_rocm == 0:
        return true

    # Check environment variable
    val gpu_env = rt_env_get("SIMPLE_HAS_GPU")
    gpu_env == "1"

fn has_cuda() -> bool:
    """Check if NVIDIA CUDA is available."""
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "which nvidia-smi 2>/dev/null"])
    code == 0

fn has_simd() -> bool:
    """Check if SIMD instructions are available."""
    # On x86_64, assume SSE2 is available (baseline)
    if is_x86_64():
        return true

    # On ARM, check for NEON
    if is_aarch64():
        return true

    false

fn has_avx2() -> bool:
    """Check if AVX2 instructions are available (x86_64 only)."""
    if not is_x86_64():
        return false

    # Check /proc/cpuinfo for avx2 (Linux only)
    if is_linux():
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "grep -q avx2 /proc/cpuinfo 2>/dev/null"])
        return code == 0

    false

fn has_neon() -> bool:
    """Check if ARM NEON instructions are available."""
    # ARM64 always has NEON
    is_aarch64()

fn get_cpu_cores() -> i64:
    """Get number of CPU cores."""
    # Try nproc first (Linux)
    val (stdout_nproc, stderr_nproc, code_nproc) = rt_process_run("/bin/sh", ["-c", "nproc 2>/dev/null"])
    if code_nproc == 0:
        val cores_text = stdout_nproc.trim()
        return int(cores_text)

    # Fallback: try sysctl (macOS)
    val (stdout_sysctl, stderr_sysctl, code_sysctl) = rt_process_run("/bin/sh", ["-c", "sysctl -n hw.ncpu 2>/dev/null"])
    if code_sysctl == 0:
        val cores_text = stdout_sysctl.trim()
        return int(cores_text)

    # Default: assume 1 core
    1

fn is_multi_core() -> bool:
    """Check if system has multiple CPU cores."""
    get_cpu_cores() > 1

# ================================================================
# 7. DEPENDENCY DETECTION
# ================================================================

fn has_module(module_name: text) -> bool:
    """Check if a Simple module is available."""
    # This would require runtime module introspection
    # For now, check environment variable
    val env_key = "SIMPLE_MODULE_{module_name.to_upper()}"
    val module_env = rt_env_get(env_key)
    module_env == "1"

fn has_library(lib_name: text) -> bool:
    """Check if a system library is available."""
    # Check with ldconfig (Linux) or dyld (macOS)
    if is_linux():
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "ldconfig -p 2>/dev/null | grep -q {lib_name}"])
        return code == 0

    if is_macos():
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "otool -L /usr/lib/lib{lib_name}.dylib 2>/dev/null"])
        return code == 0

    false

# ================================================================
# 8. ENVIRONMENT VARIABLE DETECTION
# ================================================================

fn has_env(key: text) -> bool:
    """Check if environment variable is set."""
    val value = rt_env_get(key)
    value != nil

fn get_env(key: text) -> text:
    """Get environment variable value (empty string if not set)."""
    val value = rt_env_get(key)
    if value == nil:
        return ""
    value

fn is_ci() -> bool:
    """Check if running in CI environment."""
    has_env("CI") or has_env("CONTINUOUS_INTEGRATION")

# ================================================================
# 9. FILE SYSTEM FEATURE DETECTION
# ================================================================

fn has_symlinks() -> bool:
    """Check if file system supports symbolic links."""
    # Unix always supports symlinks
    if is_unix():
        return true

    # Windows: check if we're in a symlink-capable environment
    if is_windows():
        val (stdout, stderr, code) = rt_process_run("cmd", ["/c", "mklink /?"])
        return code == 0

    false

fn has_permissions() -> bool:
    """Check if file system supports Unix permissions."""
    is_unix()

fn is_case_sensitive() -> bool:
    """Check if file system is case-sensitive."""
    # Linux: usually case-sensitive
    if is_linux():
        return true

    # Windows: case-insensitive
    if is_windows():
        return false

    # macOS: can be either, default to false
    if is_macos():
        return false

    # Default: assume case-sensitive on Unix
    is_unix()

fn has_xattr() -> bool:
    """Check if file system supports extended attributes."""
    # Check with getfattr (Linux) or xattr (macOS)
    if is_linux():
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "which getfattr 2>/dev/null"])
        return code == 0

    if is_macos():
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "which xattr 2>/dev/null"])
        return code == 0

    false

# ================================================================
# 10. NETWORK DETECTION
# ================================================================

fn has_network() -> bool:
    """Check if network connection is available."""
    # Try to ping a reliable host (Google DNS)
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "ping -c 1 -W 1 8.8.8.8 2>/dev/null"])
    code == 0

fn can_reach(host: text) -> bool:
    """Check if specific host is reachable."""
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "ping -c 1 -W 1 {host} 2>/dev/null"])
    code == 0

# ================================================================
# 11. VERSION DETECTION
# ================================================================

fn get_compiler_version() -> text:
    """Get Simple compiler version."""
    val version_env = rt_env_get("SIMPLE_VERSION")
    if version_env != nil:
        return version_env

    # Fallback: try to run simple --version
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "simple --version 2>&1"])
    if code == 0:
        return stdout.trim()

    "unknown"

fn check_version_constraint(constraint: text) -> bool:
    """Check if compiler version satisfies constraint.

    Supports:
    - '>= 0.5.0' - greater than or equal
    - '< 1.0.0' - less than
    - '0.4.x' - wildcard match
    """
    val version = get_compiler_version()

    # Parse constraint
    if constraint.starts_with(">="):
        val required = constraint[2:].trim()
        return version >= required

    if constraint.starts_with(">"):
        val required = constraint[1:].trim()
        return version > required

    if constraint.starts_with("<="):
        val required = constraint[2:].trim()
        return version <= required

    if constraint.starts_with("<"):
        val required = constraint[1:].trim()
        return version < required

    if constraint.starts_with("=="):
        val required = constraint[2:].trim()
        return version == required

    if constraint.contains("x"):
        # Wildcard: 0.4.x matches 0.4.0, 0.4.1, etc.
        val pattern = constraint.replace("x", "")
        return version.starts_with(pattern)

    # Default: exact match
    version == constraint

# Export all detection functions
export get_platform_os, is_windows, is_linux, is_macos, is_unix, is_bsd
export get_runtime_mode, is_interpreter, is_compiled, is_jit
export get_build_profile, is_debug, is_release, is_bootstrap
export get_architecture, get_pointer_size, is_x86_64, is_aarch64, is_64bit, is_32bit
export has_feature, has_generics, has_async, has_macros, has_effects, has_inline_asm
export has_gpu, has_cuda, has_simd, has_avx2, has_neon, get_cpu_cores, is_multi_core
export has_module, has_library
export has_env, get_env, is_ci
export has_symlinks, has_permissions, is_case_sensitive, has_xattr
export has_network, can_reach
export get_compiler_version, check_version_constraint
