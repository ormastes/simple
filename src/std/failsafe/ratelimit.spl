# Fail-Safe Rate Limiter
# Pure Simple implementation - no FFI dependencies

use compiler_core.*
use std.failsafe.core.*

# ============================================================================
# RATE LIMIT CONFIG
# ============================================================================

pub class RateLimitConfig:
    pub requests_per_second: f64
    pub burst_size: i64
    pub penalty_duration_ms: i64

    static fn default() -> RateLimitConfig:
        return RateLimitConfig(100.0, 50, 1000)

    static fn strict() -> RateLimitConfig:
        return RateLimitConfig(50.0, 20, 5000)

    static fn permissive() -> RateLimitConfig:
        return RateLimitConfig(1000.0, 500, 100)

# ============================================================================
# TOKEN BUCKET
# ============================================================================

pub class TokenBucket:
    pub capacity: f64
    pub tokens: f64
    pub refill_rate: f64
    pub last_update: i64

    static fn new(capacity: f64, refill_rate: f64) -> TokenBucket:
        return TokenBucket(capacity, capacity, refill_rate, 0)

    pub me try_consume(count: f64) -> bool:
        # Simple token consumption without time-based refill
        # In real implementation, would use time to refill
        if self.tokens >= count:
            self.tokens = self.tokens - count
            return true
        return false

    pub fn available() -> f64:
        return self.tokens

    pub me reset():
        self.tokens = self.capacity

# ============================================================================
# RATE LIMIT DECISION
# ============================================================================

pub enum RateLimitDecision:
    Allow
    Deny(i64)
    Penalize(i64)

    pub fn is_allowed() -> bool:
        match self:
            case Allow: true
            case Penalize(_): true
            case Deny(_): false

# ============================================================================
# RATE LIMITER
# ============================================================================

pub class RateLimiter:
    pub config: RateLimitConfig
    pub global_bucket: TokenBucket
    pub client_requests: Dict<text, i64>
    pub enabled: bool
    pub stats: RateLimitStats

    static fn new(config: RateLimitConfig) -> RateLimiter:
        val bucket = TokenBucket__new(config.burst_size as f64, config.requests_per_second)
        return RateLimiter(config, bucket, {}, true, RateLimitStats__new())

    static fn default() -> RateLimiter:
        return RateLimiter__new(RateLimitConfig__default())

    pub me check(client_id: text) -> RateLimitDecision:
        if not self.enabled:
            return RateLimitDecision.Allow

        # Check global limit
        if not self.global_bucket.try_consume(1.0):
            self.stats.denied_requests = self.stats.denied_requests + 1
            return RateLimitDecision.Deny(1000)

        # Track client requests
        val current = self.client_requests.get(client_id) ?? 0

        self.client_requests.set(client_id, current + 1)
        self.stats.allowed_requests = self.stats.allowed_requests + 1
        return RateLimitDecision.Allow

    pub me reset():
        self.global_bucket.reset()
        self.client_requests = {}
        self.stats = RateLimitStats__new()

    pub me disable():
        self.enabled = false

    pub me enable():
        self.enabled = true

# ============================================================================
# RATE LIMIT STATS
# ============================================================================

pub class RateLimitStats:
    pub allowed_requests: i64
    pub denied_requests: i64

    static fn new() -> RateLimitStats:
        return RateLimitStats(0, 0)

    pub fn total_requests() -> i64:
        return self.allowed_requests + self.denied_requests

    pub fn denial_rate() -> f64:
        val total = self.total_requests()
        if total == 0:
            return 0.0
        return self.denied_requests as f64 / total as f64

# ============================================================================
# RATE LIMIT CHECK FUNCTION
# ============================================================================

pub fn rate_limit_check(limiter: RateLimiter, client_id: text) -> FailSafeResult<()>:
    match limiter.check(client_id):
        case RateLimitDecision.Allow:
            return FailSafeResult.Ok(())
        case RateLimitDecision.Deny(retry_after):
            return FailSafeResult.Err(
                FailSafeError__new(ErrorCategory.TooManyRequests, "Rate limit exceeded")
                    .with_retry(retry_after)
            )
        case RateLimitDecision.Penalize(_):
            return FailSafeResult.Ok(())
