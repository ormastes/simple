# Fail-Safe Resource Monitor
# Pure Simple implementation - no FFI dependencies

use core.*
use std.failsafe.core.*

# ============================================================================
# RESOURCE TYPES
# ============================================================================

pub enum ResourceType:
    Memory
    FileHandles
    Connections
    Threads

    pub fn to_string() -> text:
        match self:
            case Memory: "memory"
            case FileHandles: "file_handles"
            case Connections: "connections"
            case Threads: "threads"

# ============================================================================
# ALERT LEVEL
# ============================================================================

pub enum AlertLevel:
    Info
    Warning
    Critical
    Emergency

    pub fn to_string() -> text:
        match self:
            case Info: "info"
            case Warning: "warning"
            case Critical: "critical"
            case Emergency: "emergency"

# ============================================================================
# RESOURCE USAGE
# ============================================================================

pub class ResourceUsage:
    pub resource_type: ResourceType
    pub current: i64
    pub limit: i64

    static fn new(resource_type: ResourceType, current: i64, limit: i64) -> ResourceUsage:
        return ResourceUsage(resource_type, current, limit)

    pub fn usage_percent() -> f64:
        if self.limit == 0:
            return 0.0
        return self.current as f64 / self.limit as f64

    pub fn is_over_threshold(threshold: f64) -> bool:
        return self.usage_percent() >= threshold

    pub fn available() -> i64:
        if self.current >= self.limit:
            return 0
        return self.limit - self.current

# ============================================================================
# RESOURCE LIMITS
# ============================================================================

pub class ResourceLimits:
    pub memory_bytes: i64
    pub max_file_handles: i64
    pub max_connections: i64
    pub max_threads: i64
    pub warning_threshold: f64
    pub critical_threshold: f64

    static fn default() -> ResourceLimits:
        return ResourceLimits(
            1024 * 1024 * 1024,  # 1 GB
            1024,
            256,
            100,
            0.75,
            0.90
        )

    static fn strict() -> ResourceLimits:
        return ResourceLimits(
            512 * 1024 * 1024,  # 512 MB
            256,
            64,
            50,
            0.60,
            0.80
        )

    static fn permissive() -> ResourceLimits:
        return ResourceLimits(
            4 * 1024 * 1024 * 1024,  # 4 GB
            4096,
            1024,
            500,
            0.85,
            0.95
        )

# ============================================================================
# RESOURCE ALERT
# ============================================================================

pub class ResourceAlert:
    pub id: text
    pub resource_type: ResourceType
    pub level: AlertLevel
    pub message: text
    pub acknowledged: bool

    static fn new(id: text, resource_type: ResourceType, level: AlertLevel, message: text) -> ResourceAlert:
        return ResourceAlert(id, resource_type, level, message, false)

    pub me acknowledge():
        self.acknowledged = true

# ============================================================================
# RESOURCE MONITOR
# ============================================================================

pub class ResourceMonitor:
    pub limits: ResourceLimits
    pub alerts: [ResourceAlert]
    pub next_alert_id: i64
    pub stats: ResourceMonitorStats
    pub enabled: bool

    static fn new(limits: ResourceLimits) -> ResourceMonitor:
        return ResourceMonitor(limits, [], 0, ResourceMonitorStats.new(), true)

    static fn default() -> ResourceMonitor:
        return ResourceMonitor.new(ResourceLimits.default())

    pub fn get_unacknowledged_alerts() -> [ResourceAlert]:
        var result: [ResourceAlert] = []
        for alert in self.alerts:
            if not alert.acknowledged:
                result.append(alert)
        return result

    pub me acknowledge_all():
        for alert in self.alerts:
            alert.acknowledge()

    pub me enable():
        self.enabled = true

    pub me disable():
        self.enabled = false

    pub me reset():
        self.alerts = []
        self.stats = ResourceMonitorStats.new()

    pub fn check_all() -> FailSafeResult<()>:
        if not self.enabled:
            return FailSafeResult.Ok(())
        self.stats.checks_performed = self.stats.checks_performed + 1
        return FailSafeResult.Ok(())

# ============================================================================
# RESOURCE MONITOR STATS
# ============================================================================

pub class ResourceMonitorStats:
    pub checks_performed: i64
    pub threshold_violations: i64
    pub alerts_raised: i64

    static fn new() -> ResourceMonitorStats:
        return ResourceMonitorStats(0, 0, 0)

    pub fn violation_rate() -> f64:
        if self.checks_performed == 0:
            return 0.0
        return self.threshold_violations as f64 / self.checks_performed as f64
