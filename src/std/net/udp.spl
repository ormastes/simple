# UDP Socket Operations
#
# UDP datagram socket implementation for connectionless communication.
# Provides unreliable, message-oriented network communication.
#
# Components:
# - UdpSocket: UDP datagram socket
#
# Features:
# - Send/receive datagrams
# - Broadcast support
# - Multicast support
# - Configurable timeouts
# - Optional connection mode

use std.error.*
use std.net.ffi.*

# ============================================================================
# UdpSocket - UDP Datagram Socket
# ============================================================================

class UdpSocket:
    """UDP datagram socket.

    Connectionless UDP socket for sending/receiving datagrams.

    Example:
        val socket = UdpSocket.bind("127.0.0.1:8080")?
        val (data, addr) = socket.recv_from(1024)?
        socket.send_to(data, addr)
    """
    handle: [u8]?

    static fn bind(addr: text) -> Result<UdpSocket, SimpleError>:
        """Bind to address.

        Args:
            addr: Address in format "host:port"

        Returns:
            Result with UdpSocket or error

        Example:
            val socket = UdpSocket.bind("0.0.0.0:8080")?
        """
        udp_socket_bind(addr)

    fn recv_from(size: usize) -> Result<([u8], text), SimpleError>:
        """Receive datagram.

        Args:
            size: Maximum bytes to receive

        Returns:
            Result with (data, sender_addr) or error

        Blocks until datagram arrives.
        """
        udp_socket_recv_from(self, size)

    fn send_to(data: [u8], addr: text) -> Result<usize, SimpleError>:
        """Send datagram to address.

        Args:
            data: Bytes to send
            addr: Destination address

        Returns:
            Result with bytes sent or error
        """
        udp_socket_send_to(self, data, addr)

    fn connect(addr: text) -> Result<(), SimpleError>:
        """Connect to remote address.

        Args:
            addr: Remote address

        Returns:
            Result or error

        After connect, use send.recv instead of send_to/recv_from.
        """
        udp_socket_connect(self, addr)

    fn send(data: [u8]) -> Result<usize, SimpleError>:
        """Send to connected peer.

        Args:
            data: Bytes to send

        Returns:
            Result with bytes sent or error

        Requires prior connect().
        """
        udp_socket_send(self, data)

    fn recv(size: usize) -> Result<[u8], SimpleError>:
        """Receive from connected peer.

        Args:
            size: Maximum bytes to receive

        Returns:
            Result with data or error

        Requires prior connect().
        """
        udp_socket_recv(self, size)

    fn local_addr() -> text?:
        """Get local address.

        Returns:
            Some(address) or nil
        """
        udp_socket_local_addr(self)

    fn set_broadcast(broadcast: bool) -> bool:
        """Enable/disable broadcast.

        Args:
            broadcast: true to enable

        Returns:
            true on success
        """
        udp_socket_set_broadcast(self, broadcast)

    fn set_multicast_loop(multicast_loop: bool) -> bool:
        """Enable/disable multicast loopback.

        Args:
            multicast_loop: true to enable

        Returns:
            true on success
        """
        udp_socket_set_multicast_loop(self, multicast_loop)

    fn join_multicast(multicast_addr: text) -> bool:
        """Join multicast group.

        Args:
            multicast_addr: Multicast address

        Returns:
            true on success
        """
        udp_socket_join_multicast(self, multicast_addr)

    fn leave_multicast(multicast_addr: text) -> bool:
        """Leave multicast group.

        Args:
            multicast_addr: Multicast address

        Returns:
            true on success
        """
        udp_socket_leave_multicast(self, multicast_addr)

    fn set_read_timeout(timeout_ms: i64?) -> bool:
        """Set read timeout.

        Args:
            timeout_ms: Timeout in ms or nil for blocking

        Returns:
            true on success
        """
        udp_socket_set_read_timeout(self, timeout_ms)

    fn set_nonblocking(nonblocking: bool) -> bool:
        """Set non-blocking mode.

        Args:
            nonblocking: true for non-blocking

        Returns:
            true on success
        """
        udp_socket_set_nonblocking(self, nonblocking)

    me close():
        """Close socket."""
        udp_socket_close(self)

# ============================================================================
# Exports
# ============================================================================

export UdpSocket
