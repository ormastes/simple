# Base Encoding Utilities Module
#
# Comprehensive module for Base16/32/64/85 encoding schemes.
# Provides encoding, decoding, validation, and utility functions
# for multiple base encoding formats.
#
# FEATURES:
# - Base16 (Hex): Standard hexadecimal encoding with uppercase/lowercase
# - Base32: RFC 4648 standard and extended hex variants
# - Base64: RFC 4648 standard, URL-safe variant, with/without padding
# - Base85 (Ascii85): Adobe and RFC 1924 (btoa) variants
# - Encoding: Convert bytes to encoded strings
# - Decoding: Convert encoded strings to bytes (Option/nil pattern)
# - Validation: Check valid encoded strings
# - Padding: Add/remove/validate padding characters
# - Alphabets: Standard, URL-safe, and custom alphabet support
# - Line breaking: Optional line wrapping at specified length
# - Utilities: Alphabet validation, calculate output size
#
# IMPLEMENTATION NOTES:
# - Pure Simple implementation (no FFI)
# - No generics at runtime (uses concrete types)
# - No try/catch/throw (uses Option/nil pattern for errors)
# - No chained method calls (uses intermediate variables)
# - Byte arrays represented as i64 lists
# - All functions are pure and stateless

# ============================================================================
# CONSTANTS AND ALPHABETS
# ============================================================================

# Base64 standard alphabet (RFC 4648)
val BASE64_STD_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

# Base64 URL-safe alphabet (RFC 4648 Section 5)
val BASE64_URL_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"

# Base32 standard alphabet (RFC 4648)
val BASE32_STD_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"

# Base32 extended hex alphabet (RFC 4648)
val BASE32_HEX_ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUV"

# Base16 (hex) lowercase alphabet
val BASE16_LOWER_ALPHABET = "0123456789abcdef"

# Base16 (hex) uppercase alphabet
val BASE16_UPPER_ALPHABET = "0123456789ABCDEF"

# Base85 Adobe (Ascii85) alphabet
val BASE85_ADOBE_ALPHABET = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu"

# Base85 RFC 1924 (btoa) alphabet
val BASE85_RFC1924_ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~"

# Padding character
val PADDING_CHAR = "="

# ============================================================================
# CHARACTER CODE UTILITIES
# ============================================================================

fn char_code(c: text) -> i64:
    """Get ASCII code of a single character. Returns 0 for unknown."""
    if c == " ": return 32
    if c == "!": return 33
    if c == "\"": return 34
    if c == "#": return 35
    if c == "$": return 36
    if c == "%": return 37
    if c == "&": return 38
    if c == "'": return 39
    if c == "(": return 40
    if c == ")": return 41
    if c == "*": return 42
    if c == "+": return 43
    if c == ",": return 44
    if c == "-": return 45
    if c == ".": return 46
    if c == "/": return 47
    if c == "0": return 48
    if c == "1": return 49
    if c == "2": return 50
    if c == "3": return 51
    if c == "4": return 52
    if c == "5": return 53
    if c == "6": return 54
    if c == "7": return 55
    if c == "8": return 56
    if c == "9": return 57
    if c == ":": return 58
    if c == ";": return 59
    if c == "<": return 60
    if c == "=": return 61
    if c == ">": return 62
    if c == "?": return 63
    if c == "@": return 64
    if c == "A": return 65
    if c == "B": return 66
    if c == "C": return 67
    if c == "D": return 68
    if c == "E": return 69
    if c == "F": return 70
    if c == "G": return 71
    if c == "H": return 72
    if c == "I": return 73
    if c == "J": return 74
    if c == "K": return 75
    if c == "L": return 76
    if c == "M": return 77
    if c == "N": return 78
    if c == "O": return 79
    if c == "P": return 80
    if c == "Q": return 81
    if c == "R": return 82
    if c == "S": return 83
    if c == "T": return 84
    if c == "U": return 85
    if c == "V": return 86
    if c == "W": return 87
    if c == "X": return 88
    if c == "Y": return 89
    if c == "Z": return 90
    if c == "[": return 91
    if c == "\\": return 92
    if c == "]": return 93
    if c == "^": return 94
    if c == "_": return 95
    if c == "`": return 96
    if c == "a": return 97
    if c == "b": return 98
    if c == "c": return 99
    if c == "d": return 100
    if c == "e": return 101
    if c == "f": return 102
    if c == "g": return 103
    if c == "h": return 104
    if c == "i": return 105
    if c == "j": return 106
    if c == "k": return 107
    if c == "l": return 108
    if c == "m": return 109
    if c == "n": return 110
    if c == "o": return 111
    if c == "p": return 112
    if c == "q": return 113
    if c == "r": return 114
    if c == "s": return 115
    if c == "t": return 116
    if c == "u": return 117
    if c == "v": return 118
    if c == "w": return 119
    if c == "x": return 120
    if c == "y": return 121
    if c == "z": return 122
    if c == "{": return 123
    if c == "|": return 124
    if c == "}": return 125
    if c == "~": return 126
    0

fn char_from_code(code: i64) -> text:
    """Create a character from an ASCII code."""
    if code == 32: return " "
    if code == 33: return "!"
    if code == 34: return "\""
    if code == 35: return "#"
    if code == 36: return "$"
    if code == 37: return "%"
    if code == 38: return "&"
    if code == 39: return "'"
    if code == 40: return "("
    if code == 41: return ")"
    if code == 42: return "*"
    if code == 43: return "+"
    if code == 44: return ","
    if code == 45: return "-"
    if code == 46: return "."
    if code == 47: return "/"
    if code == 48: return "0"
    if code == 49: return "1"
    if code == 50: return "2"
    if code == 51: return "3"
    if code == 52: return "4"
    if code == 53: return "5"
    if code == 54: return "6"
    if code == 55: return "7"
    if code == 56: return "8"
    if code == 57: return "9"
    if code == 58: return ":"
    if code == 59: return ";"
    if code == 60: return "<"
    if code == 61: return "="
    if code == 62: return ">"
    if code == 63: return "?"
    if code == 64: return "@"
    if code == 65: return "A"
    if code == 66: return "B"
    if code == 67: return "C"
    if code == 68: return "D"
    if code == 69: return "E"
    if code == 70: return "F"
    if code == 71: return "G"
    if code == 72: return "H"
    if code == 73: return "I"
    if code == 74: return "J"
    if code == 75: return "K"
    if code == 76: return "L"
    if code == 77: return "M"
    if code == 78: return "N"
    if code == 79: return "O"
    if code == 80: return "P"
    if code == 81: return "Q"
    if code == 82: return "R"
    if code == 83: return "S"
    if code == 84: return "T"
    if code == 85: return "U"
    if code == 86: return "V"
    if code == 87: return "W"
    if code == 88: return "X"
    if code == 89: return "Y"
    if code == 90: return "Z"
    if code == 91: return "["
    if code == 92: return "\\"
    if code == 93: return "]"
    if code == 94: return "^"
    if code == 95: return "_"
    if code == 96: return "`"
    if code == 97: return "a"
    if code == 98: return "b"
    if code == 99: return "c"
    if code == 100: return "d"
    if code == 101: return "e"
    if code == 102: return "f"
    if code == 103: return "g"
    if code == 104: return "h"
    if code == 105: return "i"
    if code == 106: return "j"
    if code == 107: return "k"
    if code == 108: return "l"
    if code == 109: return "m"
    if code == 110: return "n"
    if code == 111: return "o"
    if code == 112: return "p"
    if code == 113: return "q"
    if code == 114: return "r"
    if code == 115: return "s"
    if code == 116: return "t"
    if code == 117: return "u"
    if code == 118: return "v"
    if code == 119: return "w"
    if code == 120: return "x"
    if code == 121: return "y"
    if code == 122: return "z"
    if code == 123: return "{"
    if code == 124: return "|"
    if code == 125: return "}"
    if code == 126: return "~"
    ""

# ============================================================================
# TEXT UTILITIES
# ============================================================================

fn text_char_at(s: text, pos: i64) -> text:
    """Get character at position in text."""
    var i = 0
    var current_pos = 0
    var result = ""
    var found = false
    while i < s.len():
        if current_pos == pos:
            result = s[i:i+1]
            found = true
            return result
        current_pos = current_pos + 1
        i = i + 1
    result

fn text_length(s: text) -> i64:
    """Get length of text string."""
    s.len()

fn text_contains(s: text, substr: text) -> bool:
    """Check if text contains substring."""
    s.contains(substr)

fn text_concat(a: text, b: text) -> text:
    """Concatenate two text strings."""
    a + b

fn text_split_at(s: text, pos: i64) -> list:
    """Split text at position into two parts."""
    var left = s[0:pos]
    var right = s[pos:s.len()]
    [left, right]

# ============================================================================
# BYTE LIST UTILITIES
# ============================================================================

fn bytes_new() -> list:
    """Create new empty byte list."""
    []

fn bytes_push(bytes: list, byte: i64) -> list:
    """Add byte to list (creates new list)."""
    var result = bytes
    result.push(byte)
    result

fn bytes_get(bytes: list, index: i64) -> i64:
    """Get byte at index."""
    bytes[index]

fn bytes_length(bytes: list) -> i64:
    """Get length of byte list."""
    bytes.len()

fn bytes_slice(bytes: list, start: i64, end: i64) -> list:
    """Get slice of byte list."""
    bytes[start:end]

fn text_to_bytes(s: text) -> list:
    """Convert text to byte list (ASCII codes)."""
    var bytes = []
    var i = 0
    while i < s.len():
        var c = text_char_at(s, i)
        var code = char_code(c)
        bytes.push(code)
        i = i + 1
    bytes

fn bytes_to_text(bytes: list) -> text:
    """Convert byte list to text."""
    var result = ""
    var i = 0
    while i < bytes.len():
        var code = bytes[i]
        var c = char_from_code(code)
        result = result + c
        i = i + 1
    result

# ============================================================================
# ALPHABET UTILITIES
# ============================================================================

fn alphabet_char_at(alphabet: text, index: i64) -> text:
    """Get character from alphabet at index."""
    text_char_at(alphabet, index)

fn alphabet_find_index(alphabet: text, c: text) -> i64:
    """Find index of character in alphabet. Returns -1 if not found."""
    var i = 0
    while i < alphabet.len():
        var ch = text_char_at(alphabet, i)
        if ch == c:
            return i
        i = i + 1
    -1

fn alphabet_validate(alphabet: text, min_length: i64) -> bool:
    """Validate alphabet has minimum length and no duplicates."""
    if alphabet.len() < min_length:
        return false
    var i = 0
    while i < alphabet.len():
        var c = text_char_at(alphabet, i)
        var j = i + 1
        while j < alphabet.len():
            var c2 = text_char_at(alphabet, j)
            if c == c2:
                return false
            j = j + 1
        i = i + 1
    true

fn alphabet_length(alphabet: text) -> i64:
    """Get alphabet length."""
    alphabet.len()

# ============================================================================
# PADDING UTILITIES
# ============================================================================

fn padding_add(encoded: text, block_size: i64) -> text:
    """Add padding to reach block size multiple."""
    var current_len = encoded.len()
    var remainder = current_len % block_size
    if remainder == 0:
        return encoded
    var padding_needed = block_size - remainder
    var result = encoded
    var i = 0
    while i < padding_needed:
        result = result + PADDING_CHAR
        i = i + 1
    result

fn padding_remove(encoded: text) -> text:
    """Remove trailing padding characters."""
    var result = encoded
    var len = result.len()
    while len > 0:
        var last_char = text_char_at(result, len - 1)
        if last_char != PADDING_CHAR:
            return result
        result = result[0:len-1]
        len = len - 1
    result

fn padding_count(encoded: text) -> i64:
    """Count trailing padding characters."""
    var count = 0
    var i = encoded.len() - 1
    while i >= 0:
        var c = text_char_at(encoded, i)
        if c != PADDING_CHAR:
            return count
        count = count + 1
        i = i - 1
    count

fn padding_validate(encoded: text, block_size: i64) -> bool:
    """Validate padding is correct for block size."""
    var pad_count = padding_count(encoded)
    if pad_count == 0:
        return true
    if pad_count >= block_size:
        return false
    var data_len = encoded.len() - pad_count
    var remainder = data_len % block_size
    var expected_padding = block_size - remainder
    if remainder == 0:
        expected_padding = 0
    pad_count == expected_padding

# ============================================================================
# BASE16 (HEX) ENCODING
# ============================================================================

fn base16_encode(bytes: list) -> text:
    """Encode bytes to Base16 (hex) uppercase."""
    base16_encode_with_alphabet(bytes, BASE16_UPPER_ALPHABET)

fn base16_encode_lower(bytes: list) -> text:
    """Encode bytes to Base16 (hex) lowercase."""
    base16_encode_with_alphabet(bytes, BASE16_LOWER_ALPHABET)

fn base16_encode_upper(bytes: list) -> text:
    """Encode bytes to Base16 (hex) uppercase."""
    base16_encode_with_alphabet(bytes, BASE16_UPPER_ALPHABET)

fn base16_encode_with_alphabet(bytes: list, alphabet: text) -> text:
    """Encode bytes to Base16 with custom alphabet."""
    var result = ""
    var i = 0
    while i < bytes.len():
        var byte = bytes[i]
        var high = byte / 16
        var low = byte % 16
        var high_char = alphabet_char_at(alphabet, high)
        var low_char = alphabet_char_at(alphabet, low)
        result = result + high_char + low_char
        i = i + 1
    result

fn base16_decode(encoded: text) -> list:
    """Decode Base16 (hex) to bytes. Case-insensitive."""
    var bytes = []
    var i = 0
    while i < encoded.len():
        if i + 1 >= encoded.len():
            return bytes
        var c1 = text_char_at(encoded, i)
        var c2 = text_char_at(encoded, i + 1)
        var v1 = hex_char_to_value(c1)
        var v2 = hex_char_to_value(c2)
        if v1 == -1:
            return bytes
        if v2 == -1:
            return bytes
        var byte = v1 * 16 + v2
        bytes.push(byte)
        i = i + 2
    bytes

fn hex_char_to_value(c: text) -> i64:
    """Convert hex character to value. Returns -1 for invalid."""
    if c == "0": return 0
    if c == "1": return 1
    if c == "2": return 2
    if c == "3": return 3
    if c == "4": return 4
    if c == "5": return 5
    if c == "6": return 6
    if c == "7": return 7
    if c == "8": return 8
    if c == "9": return 9
    if c == "a": return 10
    if c == "A": return 10
    if c == "b": return 11
    if c == "B": return 11
    if c == "c": return 12
    if c == "C": return 12
    if c == "d": return 13
    if c == "D": return 13
    if c == "e": return 14
    if c == "E": return 14
    if c == "f": return 15
    if c == "F": return 15
    -1

fn base16_validate(encoded: text) -> bool:
    """Validate Base16 (hex) encoded string."""
    if encoded.len() % 2 != 0:
        return false
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        var v = hex_char_to_value(c)
        if v == -1:
            return false
        i = i + 1
    true

# ============================================================================
# BASE32 ENCODING
# ============================================================================

fn base32_encode(bytes: list) -> text:
    """Encode bytes to Base32 standard with padding."""
    base32_encode_with_config(bytes, BASE32_STD_ALPHABET, true)

fn base32_encode_no_pad(bytes: list) -> text:
    """Encode bytes to Base32 standard without padding."""
    base32_encode_with_config(bytes, BASE32_STD_ALPHABET, false)

fn base32_encode_hex(bytes: list) -> text:
    """Encode bytes to Base32 extended hex with padding."""
    base32_encode_with_config(bytes, BASE32_HEX_ALPHABET, true)

fn base32_encode_hex_no_pad(bytes: list) -> text:
    """Encode bytes to Base32 extended hex without padding."""
    base32_encode_with_config(bytes, BASE32_HEX_ALPHABET, false)

fn base32_encode_with_config(bytes: list, alphabet: text, use_padding: bool) -> text:
    """Encode bytes to Base32 with custom alphabet and padding option."""
    var result = ""
    var i = 0
    while i < bytes.len():
        var bits = 0
        var bit_count = 0
        var j = 0
        while j < 5:
            if i + j < bytes.len():
                var byte = bytes[i + j]
                bits = bits * 256 + byte
                bit_count = bit_count + 8
            j = j + 1
        var remaining_bits = bit_count
        while remaining_bits > 0:
            if remaining_bits >= 5:
                var shift = remaining_bits - 5
                var index = bits / power_of_2(shift)
                var mask = 31
                index = index % 32
                var c = alphabet_char_at(alphabet, index)
                result = result + c
                remaining_bits = remaining_bits - 5
            else:
                var shift = 5 - remaining_bits
                var index = bits * power_of_2(shift)
                var mask = 31
                index = index % 32
                var c = alphabet_char_at(alphabet, index)
                result = result + c
                remaining_bits = 0
        i = i + 5
    if use_padding:
        result = padding_add(result, 8)
    result

fn base32_decode(encoded: text) -> list:
    """Decode Base32 standard to bytes."""
    base32_decode_with_alphabet(encoded, BASE32_STD_ALPHABET)

fn base32_decode_hex(encoded: text) -> list:
    """Decode Base32 extended hex to bytes."""
    base32_decode_with_alphabet(encoded, BASE32_HEX_ALPHABET)

fn base32_decode_with_alphabet(encoded: text, alphabet: text) -> list:
    """Decode Base32 with custom alphabet to bytes."""
    var clean = padding_remove(encoded)
    var bytes = []
    var bits = 0
    var bit_count = 0
    var i = 0
    while i < clean.len():
        var c = text_char_at(clean, i)
        var index = alphabet_find_index(alphabet, c)
        if index == -1:
            return bytes
        bits = bits * 32 + index
        bit_count = bit_count + 5
        if bit_count >= 8:
            var shift = bit_count - 8
            var byte = bits / power_of_2(shift)
            byte = byte % 256
            bytes.push(byte)
            bit_count = bit_count - 8
        i = i + 1
    bytes

fn base32_validate(encoded: text) -> bool:
    """Validate Base32 standard encoded string."""
    base32_validate_with_alphabet(encoded, BASE32_STD_ALPHABET)

fn base32_validate_hex(encoded: text) -> bool:
    """Validate Base32 extended hex encoded string."""
    base32_validate_with_alphabet(encoded, BASE32_HEX_ALPHABET)

fn base32_validate_with_alphabet(encoded: text, alphabet: text) -> bool:
    """Validate Base32 encoded string with custom alphabet."""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            i = i + 1
            pass
        else:
            var index = alphabet_find_index(alphabet, c)
            if index == -1:
                return false
            i = i + 1
    padding_validate(encoded, 8)

# ============================================================================
# BASE64 ENCODING
# ============================================================================

fn base64_encode(bytes: list) -> text:
    """Encode bytes to Base64 standard with padding."""
    base64_encode_with_config(bytes, BASE64_STD_ALPHABET, true)

fn base64_encode_no_pad(bytes: list) -> text:
    """Encode bytes to Base64 standard without padding."""
    base64_encode_with_config(bytes, BASE64_STD_ALPHABET, false)

fn base64_encode_url(bytes: list) -> text:
    """Encode bytes to Base64 URL-safe with padding."""
    base64_encode_with_config(bytes, BASE64_URL_ALPHABET, true)

fn base64_encode_url_no_pad(bytes: list) -> text:
    """Encode bytes to Base64 URL-safe without padding."""
    base64_encode_with_config(bytes, BASE64_URL_ALPHABET, false)

fn base64_encode_with_config(bytes: list, alphabet: text, use_padding: bool) -> text:
    """Encode bytes to Base64 with custom alphabet and padding option."""
    var result = ""
    var i = 0
    while i < bytes.len():
        var b1 = bytes[i]
        var b2 = 0
        var b3 = 0
        var has_b2 = false
        var has_b3 = false
        if i + 1 < bytes.len():
            b2 = bytes[i + 1]
            has_b2 = true
        if i + 2 < bytes.len():
            b3 = bytes[i + 2]
            has_b3 = true
        var idx1 = b1 / 4
        var c1 = alphabet_char_at(alphabet, idx1)
        result = result + c1
        var idx2 = (b1 % 4) * 16
        if has_b2:
            idx2 = idx2 + b2 / 16
        var c2 = alphabet_char_at(alphabet, idx2)
        result = result + c2
        if has_b2:
            var idx3 = (b2 % 16) * 4
            if has_b3:
                idx3 = idx3 + b3 / 64
            var c3 = alphabet_char_at(alphabet, idx3)
            result = result + c3
        else:
            if use_padding:
                result = result + PADDING_CHAR
        if has_b3:
            var idx4 = b3 % 64
            var c4 = alphabet_char_at(alphabet, idx4)
            result = result + c4
        else:
            if use_padding:
                result = result + PADDING_CHAR
        i = i + 3
    result

fn base64_decode(encoded: text) -> list:
    """Decode Base64 standard to bytes."""
    base64_decode_with_alphabet(encoded, BASE64_STD_ALPHABET)

fn base64_decode_url(encoded: text) -> list:
    """Decode Base64 URL-safe to bytes."""
    base64_decode_with_alphabet(encoded, BASE64_URL_ALPHABET)

fn base64_decode_with_alphabet(encoded: text, alphabet: text) -> list:
    """Decode Base64 with custom alphabet to bytes."""
    var clean = padding_remove(encoded)
    var bytes = []
    var i = 0
    while i < clean.len():
        if i + 1 >= clean.len():
            return bytes
        var c1 = text_char_at(clean, i)
        var c2 = text_char_at(clean, i + 1)
        var idx1 = alphabet_find_index(alphabet, c1)
        var idx2 = alphabet_find_index(alphabet, c2)
        if idx1 == -1:
            return bytes
        if idx2 == -1:
            return bytes
        var b1 = idx1 * 4 + idx2 / 16
        bytes.push(b1)
        if i + 2 < clean.len():
            var c3 = text_char_at(clean, i + 2)
            var idx3 = alphabet_find_index(alphabet, c3)
            if idx3 == -1:
                return bytes
            var b2 = (idx2 % 16) * 16 + idx3 / 4
            bytes.push(b2)
            if i + 3 < clean.len():
                var c4 = text_char_at(clean, i + 3)
                var idx4 = alphabet_find_index(alphabet, c4)
                if idx4 == -1:
                    return bytes
                var b3 = (idx3 % 4) * 64 + idx4
                bytes.push(b3)
        i = i + 4
    bytes

fn base64_validate(encoded: text) -> bool:
    """Validate Base64 standard encoded string."""
    base64_validate_with_alphabet(encoded, BASE64_STD_ALPHABET)

fn base64_validate_url(encoded: text) -> bool:
    """Validate Base64 URL-safe encoded string."""
    base64_validate_with_alphabet(encoded, BASE64_URL_ALPHABET)

fn base64_validate_with_alphabet(encoded: text, alphabet: text) -> bool:
    """Validate Base64 encoded string with custom alphabet."""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            i = i + 1
            pass
        else:
            var index = alphabet_find_index(alphabet, c)
            if index == -1:
                return false
            i = i + 1
    padding_validate(encoded, 4)

# ============================================================================
# BASE85 (ASCII85) ENCODING
# ============================================================================

fn base85_encode(bytes: list) -> text:
    """Encode bytes to Base85 Adobe (Ascii85) format."""
    base85_encode_adobe(bytes)

fn base85_encode_adobe(bytes: list) -> text:
    """Encode bytes to Base85 Adobe (Ascii85) format with special sequences."""
    var result = "<~"
    var i = 0
    while i < bytes.len():
        var b1 = bytes[i]
        var b2 = 0
        var b3 = 0
        var b4 = 0
        var count = 1
        if i + 1 < bytes.len():
            b2 = bytes[i + 1]
            count = 2
        if i + 2 < bytes.len():
            b3 = bytes[i + 2]
            count = 3
        if i + 3 < bytes.len():
            b4 = bytes[i + 3]
            count = 4
        var value = b1 * 16777216 + b2 * 65536 + b3 * 256 + b4
        if value == 0:
            if count == 4:
                result = result + "z"
            else:
                var encoded = base85_encode_value(value, count, BASE85_ADOBE_ALPHABET)
                result = result + encoded
        else:
            var encoded = base85_encode_value(value, count, BASE85_ADOBE_ALPHABET)
            result = result + encoded
        i = i + 4
    result = result + "~>"
    result

fn base85_encode_rfc1924(bytes: list) -> text:
    """Encode bytes to Base85 RFC 1924 (btoa) format."""
    var result = ""
    var i = 0
    while i < bytes.len():
        var b1 = bytes[i]
        var b2 = 0
        var b3 = 0
        var b4 = 0
        var count = 1
        if i + 1 < bytes.len():
            b2 = bytes[i + 1]
            count = 2
        if i + 2 < bytes.len():
            b3 = bytes[i + 2]
            count = 3
        if i + 3 < bytes.len():
            b4 = bytes[i + 3]
            count = 4
        var value = b1 * 16777216 + b2 * 65536 + b3 * 256 + b4
        var encoded = base85_encode_value(value, count, BASE85_RFC1924_ALPHABET)
        result = result + encoded
        i = i + 4
    result

fn base85_encode_value(value: i64, byte_count: i64, alphabet: text) -> text:
    """Encode 32-bit value to Base85 characters."""
    var chars = []
    var v = value
    var i = 0
    while i < 5:
        var remainder = v % 85
        chars.push(remainder)
        v = v / 85
        i = i + 1
    var result = ""
    var output_len = byte_count + 1
    var j = 0
    while j < output_len:
        var idx = chars[4 - j]
        var c = alphabet_char_at(alphabet, idx)
        result = result + c
        j = j + 1
    result

fn base85_decode(encoded: text) -> list:
    """Decode Base85 Adobe (Ascii85) format to bytes."""
    base85_decode_adobe(encoded)

fn base85_decode_adobe(encoded: text) -> list:
    """Decode Base85 Adobe (Ascii85) format to bytes."""
    var clean = encoded
    if clean.starts_with("<~"):
        clean = clean[2:clean.len()]
    if clean.ends_with("~>"):
        clean = clean[0:clean.len()-2]
    var bytes = []
    var i = 0
    while i < clean.len():
        var c = text_char_at(clean, i)
        if c == "z":
            bytes.push(0)
            bytes.push(0)
            bytes.push(0)
            bytes.push(0)
            i = i + 1
        else:
            var chars = []
            var j = 0
            while j < 5:
                if i + j < clean.len():
                    var ch = text_char_at(clean, i + j)
                    chars.push(ch)
                j = j + 1
            var value = base85_decode_value(chars, BASE85_ADOBE_ALPHABET)
            var b1 = value / 16777216
            var b2 = (value / 65536) % 256
            var b3 = (value / 256) % 256
            var b4 = value % 256
            bytes.push(b1)
            if chars.len() > 2:
                bytes.push(b2)
            if chars.len() > 3:
                bytes.push(b3)
            if chars.len() > 4:
                bytes.push(b4)
            i = i + chars.len()
    bytes

fn base85_decode_rfc1924(encoded: text) -> list:
    """Decode Base85 RFC 1924 (btoa) format to bytes."""
    var bytes = []
    var i = 0
    while i < encoded.len():
        var chars = []
        var j = 0
        while j < 5:
            if i + j < encoded.len():
                var ch = text_char_at(encoded, i + j)
                chars.push(ch)
            j = j + 1
        var value = base85_decode_value(chars, BASE85_RFC1924_ALPHABET)
        var b1 = value / 16777216
        var b2 = (value / 65536) % 256
        var b3 = (value / 256) % 256
        var b4 = value % 256
        bytes.push(b1)
        if chars.len() > 2:
            bytes.push(b2)
        if chars.len() > 3:
            bytes.push(b3)
        if chars.len() > 4:
            bytes.push(b4)
        i = i + chars.len()
    bytes

fn base85_decode_value(chars: list, alphabet: text) -> i64:
    """Decode Base85 characters to 32-bit value."""
    var value = 0
    var i = 0
    while i < chars.len():
        var c = chars[i]
        var idx = alphabet_find_index(alphabet, c)
        if idx == -1:
            return 0
        value = value * 85 + idx
        i = i + 1
    value

fn base85_validate_adobe(encoded: text) -> bool:
    """Validate Base85 Adobe (Ascii85) encoded string."""
    if encoded.starts_with("<~") == false:
        return false
    if encoded.ends_with("~>") == false:
        return false
    var clean = encoded[2:encoded.len()-2]
    var i = 0
    while i < clean.len():
        var c = text_char_at(clean, i)
        if c == "z":
            i = i + 1
            pass
        else:
            var idx = alphabet_find_index(BASE85_ADOBE_ALPHABET, c)
            if idx == -1:
                return false
            i = i + 1
    true

fn base85_validate_rfc1924(encoded: text) -> bool:
    """Validate Base85 RFC 1924 (btoa) encoded string."""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        var idx = alphabet_find_index(BASE85_RFC1924_ALPHABET, c)
        if idx == -1:
            return false
        i = i + 1
    true

# ============================================================================
# SIZE CALCULATION UTILITIES
# ============================================================================

fn base16_encoded_size(input_bytes: i64) -> i64:
    """Calculate Base16 encoded size from input byte count."""
    input_bytes * 2

fn base16_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base16 decoded size from encoded length."""
    encoded_length / 2

fn base32_encoded_size(input_bytes: i64, use_padding: bool) -> i64:
    """Calculate Base32 encoded size from input byte count."""
    var bits = input_bytes * 8
    var chars = (bits + 4) / 5
    if use_padding:
        var remainder = chars % 8
        if remainder != 0:
            chars = chars + (8 - remainder)
    chars

fn base32_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base32 decoded size from encoded length."""
    var bits = encoded_length * 5
    bits / 8

fn base64_encoded_size(input_bytes: i64, use_padding: bool) -> i64:
    """Calculate Base64 encoded size from input byte count."""
    var chars = (input_bytes + 2) / 3 * 4
    if use_padding == false:
        var remainder = input_bytes % 3
        if remainder == 1:
            chars = chars - 2
        else:
            if remainder == 2:
                chars = chars - 1
    chars

fn base64_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base64 decoded size from encoded length."""
    (encoded_length * 3) / 4

fn base85_encoded_size(input_bytes: i64) -> i64:
    """Calculate Base85 encoded size from input byte count."""
    var blocks = (input_bytes + 3) / 4
    blocks * 5

fn base85_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base85 decoded size from encoded length."""
    var blocks = encoded_length / 5
    blocks * 4

# ============================================================================
# LINE WRAPPING UTILITIES
# ============================================================================

fn line_wrap(encoded: text, line_length: i64) -> text:
    """Wrap encoded string at specified line length."""
    var result = ""
    var i = 0
    while i < encoded.len():
        var end = i + line_length
        if end > encoded.len():
            end = encoded.len()
        var line = encoded[i:end]
        result = result + line
        if end < encoded.len():
            result = result + "\n"
        i = end
    result

fn line_unwrap(encoded: text) -> text:
    """Remove line breaks from wrapped encoded string."""
    var result = ""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        if c != "\n":
            if c != "\r":
                result = result + c
        i = i + 1
    result

fn line_count(encoded: text) -> i64:
    """Count lines in wrapped encoded string."""
    var count = 1
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        if c == "\n":
            count = count + 1
        i = i + 1
    count

# ============================================================================
# WHITESPACE UTILITIES
# ============================================================================

fn whitespace_strip(encoded: text) -> text:
    """Remove all whitespace from encoded string."""
    var result = ""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        var is_ws = whitespace_is_char(c)
        if is_ws == false:
            result = result + c
        i = i + 1
    result

fn whitespace_is_char(c: text) -> bool:
    """Check if character is whitespace."""
    if c == " ": return true
    if c == "\t": return true
    if c == "\n": return true
    if c == "\r": return true
    false

# ============================================================================
# CONVERSION UTILITIES
# ============================================================================

fn text_encode_base16(s: text) -> text:
    """Encode text to Base16 (hex)."""
    var bytes = text_to_bytes(s)
    base16_encode(bytes)

fn text_decode_base16(encoded: text) -> text:
    """Decode Base16 (hex) to text."""
    var bytes = base16_decode(encoded)
    bytes_to_text(bytes)

fn text_encode_base32(s: text) -> text:
    """Encode text to Base32."""
    var bytes = text_to_bytes(s)
    base32_encode(bytes)

fn text_decode_base32(encoded: text) -> text:
    """Decode Base32 to text."""
    var bytes = base32_decode(encoded)
    bytes_to_text(bytes)

fn text_encode_base64(s: text) -> text:
    """Encode text to Base64."""
    var bytes = text_to_bytes(s)
    base64_encode(bytes)

fn text_decode_base64(encoded: text) -> text:
    """Decode Base64 to text."""
    var bytes = base64_decode(encoded)
    bytes_to_text(bytes)

fn text_encode_base85(s: text) -> text:
    """Encode text to Base85 Adobe."""
    var bytes = text_to_bytes(s)
    base85_encode_adobe(bytes)

fn text_decode_base85(encoded: text) -> text:
    """Decode Base85 Adobe to text."""
    var bytes = base85_decode_adobe(encoded)
    bytes_to_text(bytes)

# ============================================================================
# HELPER UTILITIES
# ============================================================================

fn power_of_2(exponent: i64) -> i64:
    """Calculate 2^exponent."""
    var result = 1
    var i = 0
    while i < exponent:
        result = result * 2
        i = i + 1
    result

fn power_of_85(exponent: i64) -> i64:
    """Calculate 85^exponent."""
    var result = 1
    var i = 0
    while i < exponent:
        result = result * 85
        i = i + 1
    result

fn min_i64(a: i64, b: i64) -> i64:
    """Return minimum of two integers."""
    if a < b:
        a
    else:
        b

fn max_i64(a: i64, b: i64) -> i64:
    """Return maximum of two integers."""
    if a > b:
        a
    else:
        b

# ============================================================================
# ALPHABET GETTERS
# ============================================================================

fn get_base16_lower_alphabet() -> text:
    """Get Base16 lowercase alphabet."""
    BASE16_LOWER_ALPHABET

fn get_base16_upper_alphabet() -> text:
    """Get Base16 uppercase alphabet."""
    BASE16_UPPER_ALPHABET

fn get_base32_std_alphabet() -> text:
    """Get Base32 standard alphabet."""
    BASE32_STD_ALPHABET

fn get_base32_hex_alphabet() -> text:
    """Get Base32 extended hex alphabet."""
    BASE32_HEX_ALPHABET

fn get_base64_std_alphabet() -> text:
    """Get Base64 standard alphabet."""
    BASE64_STD_ALPHABET

fn get_base64_url_alphabet() -> text:
    """Get Base64 URL-safe alphabet."""
    BASE64_URL_ALPHABET

fn get_base85_adobe_alphabet() -> text:
    """Get Base85 Adobe alphabet."""
    BASE85_ADOBE_ALPHABET

fn get_base85_rfc1924_alphabet() -> text:
    """Get Base85 RFC 1924 alphabet."""
    BASE85_RFC1924_ALPHABET

fn get_padding_char() -> text:
    """Get padding character."""
    PADDING_CHAR
