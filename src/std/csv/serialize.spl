# CSV Writing and Serialization Functions

# Helper functions (from utilities conceptually)
fn string_contains_char(s: text, c: text) -> text:
    val index = s.find(c)
    if index == -1:
        return "no"
    "yes"

fn needs_quoting(field: text, delimiter: text, quote_char: text) -> bool:
    val has_delimiter = string_contains_char(field, delimiter)
    val has_quote = string_contains_char(field, quote_char)
    val has_newline = string_contains_char(field, "\n")
    val has_cr = string_contains_char(field, "\r")
    val result1 = has_delimiter == "yes"
    val result2 = has_quote == "yes"
    val result3 = has_newline == "yes"
    val result4 = has_cr == "yes"
    val temp1 = result1 or result2
    val temp2 = result3 or result4
    val final = temp1 or temp2
    final

fn char_at(s: text, index: i64) -> text:
    val len = s.length()
    if index < 0 or index >= len:
        return ""
    val substring = s.substring(index, index + 1)
    substring

fn is_quote_char(c: text, quote: text) -> bool:
    c == quote

fn escape_quote_in_field(field: text, quote_char: text, escape_char: text) -> text:
    var result = ""
    var i = 0
    val len = field.length()
    loop:
        if i >= len:
            break
        val c = char_at(field, i)
        val is_q = is_quote_char(c, quote_char)
        if is_q:
            result = result + escape_char
            result = result + c
        else:
            result = result + c
        i = i + 1
    result

fn escape_field(field: text, config: CsvConfig) -> text:
    val needs_q = needs_quoting(field, config.delimiter, config.quote_char)
    if not needs_q:
        return field
    val escaped = escape_quote_in_field(field, config.quote_char, config.escape_char)
    var result = config.quote_char
    result = result + escaped
    result = result + config.quote_char
    result

# ============================================================================
# CSV Writing Functions
# ============================================================================

fn write_csv_row(fields: list, config: CsvConfig) -> text:
    var result = ""
    var i = 0
    val field_count = fields.length()

    loop:
        if i >= field_count:
            break
        val field = fields.at(i)
        val escaped = escape_field(field, config)
        result = result + escaped
        val next_i = i + 1
        if next_i < field_count:
            result = result + config.delimiter
        i = i + 1

    result

fn write_csv_table(table: CsvTable) -> text:
    var result = ""
    val has_headers = table.headers.length() > 0

    if has_headers:
        val header_line = write_csv_row(table.headers, table.config)
        result = result + header_line
        result = result + table.config.line_ending

    var i = 0
    val row_count = table.rows.length()
    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val row_line = write_csv_row(row, table.config)
        result = result + row_line
        val next_i = i + 1
        if next_i < row_count:
            result = result + table.config.line_ending
        i = i + 1

    result

fn write_csv_rows(rows: list, config: CsvConfig) -> text:
    val empty_headers = []
    val table = CsvTable(headers: empty_headers, rows: rows, config: config)
    write_csv_table(table)

fn write_csv_simple(rows: list) -> text:
    val config = default_csv_config()
    write_csv_rows(rows, config)

fn write_csv_with_headers(headers: list, rows: list, config: CsvConfig) -> text:
    val table = CsvTable(headers: headers, rows: rows, config: config)
    write_csv_table(table)

# ============================================================================
# Export Functions
# ============================================================================

fn table_to_string(table: CsvTable) -> text:
    write_csv_table(table)

fn rows_to_string(rows: list) -> text:
    write_csv_simple(rows)

fn rows_to_tsv(rows: list) -> text:
    val config = create_tsv_config()
    write_csv_rows(rows, config)

fn rows_to_csv_crlf(rows: list) -> text:
    val config = create_crlf_config()
    write_csv_rows(rows, config)

# Placeholder imports
fn default_csv_config() -> CsvConfig:
    CsvConfig(
        delimiter: ",",
        quote_char: "\"",
        escape_char: "\"",
        line_ending: "\n",
        trim_whitespace: false,
        skip_empty_lines: false
    )

fn create_tsv_config() -> CsvConfig:
    val base = default_csv_config()
    config_with_delimiter(base, "\t")

fn create_crlf_config() -> CsvConfig:
    val base = default_csv_config()
    config_with_line_ending(base, "\r\n")

fn config_with_delimiter(config: CsvConfig, delimiter: text) -> CsvConfig:
    CsvConfig(
        delimiter: delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: config.line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )

fn config_with_line_ending(config: CsvConfig, line_ending: text) -> CsvConfig:
    CsvConfig(
        delimiter: config.delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )
