# Linked List Traversal and Transformation Functions

# Map function over list
# Args:
#   list: Linked list
#   f: Function to apply (value -> new_value)
# Returns: New list with function applied to each element
fn ll_map(list, f):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        (f(head), ll_map(tail, f))

# Filter list by predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: New list containing only matching elements
fn ll_filter(list, pred):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        var filtered_tail = ll_filter(tail, pred)
        if pred(head):
            (head, filtered_tail)
        else:
            filtered_tail

# Reverse a linked list
# Args:
#   list: Linked list
# Returns: New list with elements in reverse order
fn ll_reverse(list):
    var result = nil
    var current = list
    while current != nil:
        result = (current[0], result)
        current = current[1]
    result

# Concatenate two lists
# Args:
#   list1: First linked list
#   list2: Second linked list
# Returns: New list with list2 appended to list1
fn ll_concat(list1, list2):
    if list1 == nil:
        list2
    else:
        var head = list1[0]
        var tail = list1[1]
        (head, ll_concat(tail, list2))

# Flatten a list of lists
# Args:
#   list_of_lists: Linked list where each element is a linked list
# Returns: Single list with all elements
fn ll_flatten(list_of_lists):
    if list_of_lists == nil:
        nil
    else:
        var head = list_of_lists[0]
        var tail = list_of_lists[1]
        ll_concat(head, ll_flatten(tail))

# Fold left (reduce from left to right)
# Args:
#   list: Linked list
#   init: Initial accumulator value
#   f: Fold function (acc, value -> new_acc)
# Returns: Final accumulator value
fn ll_foldl(list, init, f):
    var acc = init
    var current = list
    while current != nil:
        acc = f(acc, current[0])
        current = current[1]
    acc

# Fold right (reduce from right to left)
# Args:
#   list: Linked list
#   init: Initial accumulator value
#   f: Fold function (value, acc -> new_acc)
# Returns: Final accumulator value
fn ll_foldr(list, init, f):
    if list == nil:
        init
    else:
        var head = list[0]
        var tail = list[1]
        f(head, ll_foldr(tail, init, f))

# Sum all numeric elements
# Args:
#   list: Linked list of numbers
# Returns: Sum of all elements
fn ll_sum(list):
    ll_foldl(list, 0, \acc, x: acc + x)

# Product of all numeric elements
# Args:
#   list: Linked list of numbers
# Returns: Product of all elements
fn ll_product(list):
    ll_foldl(list, 1, \acc, x: acc * x)

# Zip two lists into list of pairs
# Args:
#   list1: First linked list
#   list2: Second linked list
# Returns: New list of tuples (elem1, elem2)
fn ll_zip(list1, list2):
    if list1 == nil:
        nil
    else:
        if list2 == nil:
            nil
        else:
            var head1 = list1[0]
            var tail1 = list1[1]
            var head2 = list2[0]
            var tail2 = list2[1]
            ((head1, head2), ll_zip(tail1, tail2))

# Partition list by predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: Tuple of (matching, non_matching) lists
fn ll_partition(list, pred):
    var matching = []
    var non_matching = []
    var current = list
    while current != nil:
        var val = current[0]
        if pred(val):
            matching = matching.push(val)
        else:
            non_matching = non_matching.push(val)
        current = current[1]
    (ll_from_array(matching), ll_from_array(non_matching))

# Get value from doubly linked list node
# Args:
#   node: Doubly linked list node
# Returns: Value or nil
fn dll_value(node):
    if node == nil:
        nil
    else:
        node[0]

# Get previous node in doubly linked list
# Args:
#   node: Doubly linked list node
# Returns: Previous node or nil
fn dll_prev(node):
    if node == nil:
        nil
    else:
        node[1]

# Get next node in doubly linked list
# Args:
#   node: Doubly linked list node
# Returns: Next node or nil
fn dll_next(node):
    if node == nil:
        nil
    else:
        node[2]

# Traverse doubly linked list forward
# Args:
#   node: Starting node
# Returns: Array of values from node to end
fn dll_traverse_forward(node):
    var result = []
    var current = node
    while current != nil:
        result = result.push(current[0])
        current = current[2]
    result

# Traverse doubly linked list backward
# Args:
#   node: Starting node
# Returns: Array of values from node to beginning (reversed)
fn dll_traverse_backward(node):
    var result = []
    var current = node
    while current != nil:
        result = result.push(current[0])
        current = current[1]
    result

# Find last node in doubly linked list
# Args:
#   list: Doubly linked list (first node)
# Returns: Last node or nil
fn dll_last_node(list):
    if list == nil:
        return nil

    var current = list
    while current[2] != nil:
        current = current[2]
    current

# Find first node in doubly linked list (from any node)
# Args:
#   node: Any node in doubly linked list
# Returns: First node or nil
fn dll_first_node(node):
    if node == nil:
        return nil

    var current = node
    while current[1] != nil:
        current = current[1]
    current

# Get length of doubly linked list
# Args:
#   list: Doubly linked list
# Returns: Number of nodes
fn dll_length(list):
    var count = 0
    var current = list
    while current != nil:
        count = count + 1
        current = current[2]
    count
