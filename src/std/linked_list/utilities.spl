# Linked List Utility Functions

# Split list at index
# Args:
#   list: Linked list
#   index: Index to split at
# Returns: Tuple of (before, after) where before has index elements
fn ll_split_at(list, index):
    var before = []
    var current = list
    var i = 0
    while i < index:
        if current == nil:
            break
        before = before.push(current[0])
        current = current[1]
        i = i + 1
    (ll_from_array(before), current)

# Take first n elements
# Args:
#   list: Linked list
#   n: Number of elements to take
# Returns: New list with first n elements
fn ll_take(list, n):
    var result = ll_split_at(list, n)
    result[0]

# Drop first n elements
# Args:
#   list: Linked list
#   n: Number of elements to drop
# Returns: New list without first n elements
fn ll_drop(list, n):
    var result = ll_split_at(list, n)
    result[1]

# Take elements while predicate is true
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: New list with leading elements matching predicate
fn ll_take_while(list, pred):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        if pred(head):
            (head, ll_take_while(tail, pred))
        else:
            nil

# Drop elements while predicate is true
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: New list without leading elements matching predicate
fn ll_drop_while(list, pred):
    var current = list
    while current != nil:
        var head = current[0]
        if !pred(head):
            return current
        current = current[1]
    nil

# Merge two sorted lists
# Args:
#   list1: First sorted linked list
#   list2: Second sorted linked list
#   cmp: Comparison function (a, b -> bool) returns true if a <= b
# Returns: Merged sorted list
fn ll_merge(list1, list2, cmp):
    if list1 == nil:
        list2
    else:
        if list2 == nil:
            list1
        else:
            var head1 = list1[0]
            var tail1 = list1[1]
            var head2 = list2[0]
            var tail2 = list2[1]
            var should_take_first = cmp(head1, head2)
            if should_take_first:
                (head1, ll_merge(tail1, list2, cmp))
            else:
                (head2, ll_merge(list1, tail2, cmp))

# Merge sort for linked lists
# Args:
#   list: Linked list to sort
#   cmp: Comparison function (a, b -> bool) returns true if a <= b
# Returns: Sorted linked list
fn ll_merge_sort(list, cmp):
    if list == nil:
        nil
    else:
        var tail = list[1]
        if tail == nil:
            list
        else:
            var len = ll_length(list)
            var mid = len / 2
            var split = ll_split_at(list, mid)
            var left = split[0]
            var right = split[1]
            var sorted_left = ll_merge_sort(left, cmp)
            var sorted_right = ll_merge_sort(right, cmp)
            ll_merge(sorted_left, sorted_right, cmp)

# Sort list in ascending order (for numbers)
# Args:
#   list: Linked list of numbers
# Returns: Sorted linked list
fn ll_sort(list):
    ll_merge_sort(list, \a, b: a <= b)

# Sort list in descending order (for numbers)
# Args:
#   list: Linked list of numbers
# Returns: Reverse sorted linked list
fn ll_sort_desc(list):
    ll_merge_sort(list, \a, b: a >= b)

# Print linked list for debugging
# Args:
#   list: Linked list
# Returns: String representation
fn ll_to_string(list):
    var arr = ll_to_array(list)
    var result = "["
    var i = 0
    while i < arr.length():
        result = result + arr[i].to_string()
        if i < arr.length() - 1:
            result = result + ", "
        i = i + 1
    result = result + "]"
    result

# Print doubly linked list for debugging
# Args:
#   list: Doubly linked list
# Returns: String representation
fn dll_to_string(list):
    var arr = dll_to_array(list)
    var result = "["
    var i = 0
    while i < arr.length():
        result = result + arr[i].to_string()
        if i < arr.length() - 1:
            result = result + " <-> "
        i = i + 1
    result = result + "]"
    result

# Compare two lists for equality
# Args:
#   list1: First linked list
#   list2: Second linked list
# Returns: true if lists contain same elements in same order
fn ll_equal(list1, list2):
    if list1 == nil:
        if list2 == nil:
            return true
        else:
            return false

    if list2 == nil:
        return false

    var head1 = list1[0]
    var head2 = list2[0]

    if head1 != head2:
        return false

    ll_equal(list1[1], list2[1])

# Intersperse value between list elements
# Args:
#   list: Linked list
#   sep: Separator value
# Returns: New list with separator between elements
fn ll_intersperse(list, sep):
    if list == nil:
        nil
    else:
        var tail = list[1]
        if tail == nil:
            list
        else:
            var head = list[0]
            (head, (sep, ll_intersperse(tail, sep)))

# Group consecutive equal elements
# Args:
#   list: Linked list
# Returns: List of lists, each containing equal consecutive elements
fn ll_group(list):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        var group = [head]
        var rest = tail

        while rest != nil:
            var next_val = rest[0]
            if next_val == head:
                group = group.push(next_val)
                rest = rest[1]
            else:
                break

        (ll_from_array(group), ll_group(rest))

# Remove duplicates from sorted list
# Args:
#   list: Sorted linked list
# Returns: New list without consecutive duplicates
fn ll_nub_sorted(list):
    if list == nil:
        nil
    else:
        var head = list[0]
        var tail = list[1]
        var rest = ll_drop_while(tail, \x: x == head)
        (head, ll_nub_sorted(rest))

# Rotate list left by n positions
# Args:
#   list: Linked list
#   n: Number of positions to rotate
# Returns: Rotated list
fn ll_rotate_left(list, n):
    var len = ll_length(list)
    if len == 0:
        return nil

    var rotations = n % len
    if rotations == 0:
        return list

    var split = ll_split_at(list, rotations)
    ll_concat(split[1], split[0])

# Rotate list right by n positions
# Args:
#   list: Linked list
#   n: Number of positions to rotate
# Returns: Rotated list
fn ll_rotate_right(list, n):
    var len = ll_length(list)
    if len == 0:
        return nil

    var rotations = n % len
    if rotations == 0:
        return list

    ll_rotate_left(list, len - rotations)
