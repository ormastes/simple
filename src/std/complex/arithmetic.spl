# Complex Number Arithmetic Operations
#
# Purpose: Basic arithmetic operations on complex numbers
#
# Contains:
# - Addition, subtraction, multiplication, division
# - Negation, conjugation
# - Reciprocal
# - Magnitude and argument

# ============================================================================
# Basic Arithmetic
# ============================================================================

fn add(z1, z2):
    """Add two complex numbers.

    Example:
        add((1.0, 2.0), (3.0, 4.0))  # (4.0, 6.0)
    """
    (z1.0 + z2.0, z1.1 + z2.1)

fn subtract(z1, z2):
    """Subtract complex numbers (z1 - z2).

    Example:
        subtract((5.0, 7.0), (2.0, 3.0))  # (3.0, 4.0)
    """
    (z1.0 - z2.0, z1.1 - z2.1)

fn multiply(z1, z2):
    """Multiply two complex numbers.

    (a + bi)(c + di) = (ac - bd) + (ad + bc)i

    Example:
        multiply((2.0, 3.0), (4.0, 5.0))  # (-7.0, 22.0)
    """
    val a = z1.0
    val b = z1.1
    val c = z2.0
    val d = z2.1

    val real = a * c - b * d
    val imag = a * d + b * c
    (real, imag)

fn divide(z1, z2):
    """Divide complex numbers (z1 / z2).

    (a + bi) / (c + di) = [(a + bi)(c - di)] / (c² + d²)

    Example:
        divide((10.0, 5.0), (2.0, 1.0))  # (5.0, 0.0)
    """
    val a = z1.0
    val b = z1.1
    val c = z2.0
    val d = z2.1

    val denominator = c * c + d * d

    if abs_f64(denominator) < EPSILON:
        return (999999999999.0, 999999999999.0)

    val real = (a * c + b * d) / denominator
    val imag = (b * c - a * d) / denominator
    (real, imag)

fn negate(z):
    """Negate complex number.

    Example:
        negate((3.0, 4.0))  # (-3.0, -4.0)
    """
    (-z.0, -z.1)

fn conjugate(z):
    """Compute complex conjugate (reflect across real axis).

    Example:
        conjugate((3.0, 4.0))  # (3.0, -4.0)
    """
    (z.0, -z.1)

fn reciprocal(z):
    """Compute multiplicative inverse 1/z.

    Example:
        reciprocal((1.0, 1.0))  # (0.5, -0.5)
    """
    divide(one(), z)

# ============================================================================
# Magnitude and Argument
# ============================================================================

fn magnitude(z) -> f64:
    """Compute magnitude (absolute value, modulus) of complex number.

    |z| = sqrt(a² + b²)

    Example:
        magnitude((3.0, 4.0))  # 5.0
    """
    val a = z.0
    val b = z.1
    sqrt_approx(a * a + b * b)

fn abs_value(z) -> f64:
    """Alias for magnitude.

    Example:
        abs_value((3.0, 4.0))  # 5.0
    """
    magnitude(z)

fn argument(z) -> f64:
    """Compute argument (angle) of complex number in radians.

    arg(z) = atan2(b, a)

    Returns value in range (-π, π].

    Example:
        argument((1.0, 1.0))  # π/4 ≈ 0.785
    """
    atan2_approx(z.1, z.0)

fn phase(z) -> f64:
    """Alias for argument.

    Example:
        phase((0.0, 1.0))  # π/2 ≈ 1.571
    """
    argument(z)

# ============================================================================
# Powers
# ============================================================================

fn square(z):
    """Compute z²."""
    multiply(z, z)

fn power(z, n: i64):
    """Compute z^n for integer n using repeated multiplication.

    Example:
        power((1.0, 1.0), 3)  # (-2.0, 2.0)
    """
    if n == 0:
        return one()

    if n < 0:
        val pos_pow = power(z, -n)
        return reciprocal(pos_pow)

    var result = one()
    var i = 0

    while i < n:
        result = multiply(result, z)
        i = i + 1

    result

# ============================================================================
# Helper functions (stubs)
# ============================================================================

val EPSILON = 0.0000000001

fn abs_f64(x: f64) -> f64:
    if x < 0.0:
        -x
    else:
        x

fn sqrt_approx(x: f64) -> f64:
    """Stub - implemented in utilities."""
    x

fn atan2_approx(y: f64, x: f64) -> f64:
    """Stub - implemented in utilities."""
    0.0

fn one():
    """Return complex one 1 + 0i."""
    (1.0, 0.0)

export add, subtract, multiply, divide, negate, conjugate, reciprocal
export magnitude, abs_value, argument, phase
export square, power
