# Cache Eviction and Cleanup Operations
#
# Purpose: Cache clearing and cleanup functions
#
# Contains:
# - Cache clear operations
# - TTL cleanup
# - Cache size and containment checks

# ============================================================================
# Clear Operations
# ============================================================================

fn cache_lru_clear(cache):
    """Clear all entries from LRU cache."""
    cache['keys'] = []
    cache['values'] = []
    cache

fn cache_fifo_clear(cache):
    """Clear all entries from FIFO cache."""
    cache['keys'] = []
    cache['values'] = []
    cache

fn cache_lfu_clear(cache):
    """Clear all entries from LFU cache."""
    cache['keys'] = []
    cache['values'] = []
    cache['frequencies'] = []
    cache

fn cache_ttl_clear(cache):
    """Clear all entries from TTL cache."""
    cache['keys'] = []
    cache['values'] = []
    cache['expiry_times'] = []
    cache

fn cache_clear(cache):
    """Generic cache clear operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_clear(cache)
    elif cache_type == 'fifo':
        cache_fifo_clear(cache)
    elif cache_type == 'lfu':
        cache_lfu_clear(cache)
    elif cache_type == 'ttl':
        cache_ttl_clear(cache)
    else:
        cache

# ============================================================================
# TTL Cleanup
# ============================================================================

fn cache_ttl_cleanup(cache):
    """Remove all expired entries from TTL cache."""
    val now = _get_timestamp()
    val keys = cache['keys']
    val values = cache['values']
    val expiry_times = cache['expiry_times']

    var new_keys = []
    var new_values = []
    var new_expiry_times = []

    var i = 0
    while i < keys.len():
        if now < expiry_times[i]:
            # Not expired - keep it
            new_keys.push(keys[i])
            new_values.push(values[i])
            new_expiry_times.push(expiry_times[i])
        i = i + 1

    cache['keys'] = new_keys
    cache['values'] = new_values
    cache['expiry_times'] = new_expiry_times
    cache

# ============================================================================
# Size and Contains Operations
# ============================================================================

fn cache_lru_size(cache) -> i64:
    """Get current number of entries in LRU cache."""
    val keys = cache['keys']
    keys.len()

fn cache_fifo_size(cache) -> i64:
    """Get current number of entries in FIFO cache."""
    val keys = cache['keys']
    keys.len()

fn cache_lfu_size(cache) -> i64:
    """Get current number of entries in LFU cache."""
    val keys = cache['keys']
    keys.len()

fn cache_ttl_size(cache) -> i64:
    """Get current number of entries in TTL cache."""
    val keys = cache['keys']
    keys.len()

fn cache_size(cache) -> i64:
    """Generic cache size operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_size(cache)
    elif cache_type == 'fifo':
        cache_fifo_size(cache)
    elif cache_type == 'lfu':
        cache_lfu_size(cache)
    elif cache_type == 'ttl':
        cache_ttl_size(cache)
    else:
        0

fn cache_lru_contains(cache, key: text) -> bool:
    """Check if key exists in LRU cache."""
    val keys = cache['keys']
    _find_key_index(keys, key) >= 0

fn cache_fifo_contains(cache, key: text) -> bool:
    """Check if key exists in FIFO cache."""
    val keys = cache['keys']
    _find_key_index(keys, key) >= 0

fn cache_lfu_contains(cache, key: text) -> bool:
    """Check if key exists in LFU cache."""
    val keys = cache['keys']
    _find_key_index(keys, key) >= 0

fn cache_ttl_contains(cache, key: text) -> bool:
    """Check if key exists in TTL cache and is not expired."""
    val keys = cache['keys']
    val expiry_times = cache['expiry_times']
    val index = _find_key_index(keys, key)

    if index >= 0:
        val now = _get_timestamp()
        return now < expiry_times[index]
    else:
        return false

fn cache_contains(cache, key: text) -> bool:
    """Generic cache contains operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_contains(cache, key)
    elif cache_type == 'fifo':
        cache_fifo_contains(cache, key)
    elif cache_type == 'lfu':
        cache_lfu_contains(cache, key)
    elif cache_type == 'ttl':
        cache_ttl_contains(cache, key)
    else:
        false

# ============================================================================
# Memoization Clear
# ============================================================================

fn memo_clear(memo_cache):
    """Clear memoization cache."""
    cache_lru_clear(memo_cache)

# ============================================================================
# Helper Functions
# ============================================================================

fn _find_key_index(keys, key: text) -> i64:
    """Find index of key in keys array. Returns -1 if not found."""
    var i = 0
    while i < keys.len():
        if keys[i] == key:
            return i
        i = i + 1
    -1

fn _get_timestamp() -> i64:
    """Get current timestamp (simulated with counter for testing)."""
    1000000

export cache_lru_clear, cache_fifo_clear, cache_lfu_clear, cache_ttl_clear, cache_clear
export cache_ttl_cleanup
export cache_lru_size, cache_fifo_size, cache_lfu_size, cache_ttl_size, cache_size
export cache_lru_contains, cache_fifo_contains, cache_lfu_contains, cache_ttl_contains, cache_contains
export memo_clear
