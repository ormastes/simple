# Utility Functions
#
# Helper functions for byte manipulation and conversion

# Rotate left (circular left shift)
fn rotate_left(value: i64, bits: i64) -> i64:
    var v = value & 0xFFFFFFFF
    var b = bits & 31
    var left = (v << b) & 0xFFFFFFFF
    var right = v >> (32 - b)
    (left | right) & 0xFFFFFFFF

# Convert bytes list to hex string
fn bytes_to_hex(bytes: list) -> text:
    var result = ""
    var i = 0
    while i < bytes.length():
        var byte_val = bytes.get(i)
        var high = (byte_val >> 4) & 0x0F
        var low = byte_val & 0x0F
        var hex_chars = "0123456789abcdef"
        var high_char = hex_chars.get(high)
        var low_char = hex_chars.get(low)
        result = result + high_char + low_char
        i = i + 1
    result

# Convert hex string to bytes list
fn hex_to_bytes(hex: text) -> list:
    var result = []
    var i = 0
    var len = hex.length()
    while i < len:
        if i + 1 >= len:
            break
        var high_char = hex.get(i)
        var low_char = hex.get(i + 1)
        var high = hex_char_to_int(high_char)
        var low = hex_char_to_int(low_char)
        if high >= 0:
            if low >= 0:
                var byte_val = (high << 4) | low
                result.append(byte_val)
        i = i + 2
    result

# Convert hex character to integer
fn hex_char_to_int(c: text) -> i64:
    if c >= "0":
        if c <= "9":
            return c.char_at(0) - 48
    if c >= "a":
        if c <= "f":
            return c.char_at(0) - 97 + 10
    if c >= "A":
        if c <= "F":
            return c.char_at(0) - 65 + 10
    -1

# XOR two byte arrays
fn xor_bytes(a: list, b: list) -> list:
    var result = []
    var len = a.length()
    var i = 0
    while i < len:
        if i < b.length():
            var xor_val = a.get(i) ^ b.get(i)
            result.append(xor_val & 0xFF)
        else:
            result.append(a.get(i) & 0xFF)
        i = i + 1
    result

# Constant-time comparison (timing-safe)
fn constant_time_compare(a: list, b: list) -> bool:
    if a.length() != b.length():
        return false
    var diff = 0
    var i = 0
    while i < a.length():
        var a_val = a.get(i)
        var b_val = b.get(i)
        diff = diff | (a_val ^ b_val)
        i = i + 1
    diff == 0

# Convert 4 bytes to 32-bit integer (little-endian)
fn bytes_to_u32_le(bytes: list, offset: i64) -> i64:
    var b0 = bytes.get(offset) & 0xFF
    var b1 = bytes.get(offset + 1) & 0xFF
    var b2 = bytes.get(offset + 2) & 0xFF
    var b3 = bytes.get(offset + 3) & 0xFF
    (b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)) & 0xFFFFFFFF

# Convert 32-bit integer to 4 bytes (little-endian)
fn u32_to_bytes_le(value: i64) -> list:
    var result = []
    result.append(value & 0xFF)
    result.append((value >> 8) & 0xFF)
    result.append((value >> 16) & 0xFF)
    result.append((value >> 24) & 0xFF)
    result

# Convert bytes to base64
fn bytes_to_base64(bytes: list) -> text:
    var base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""
    var i = 0
    var len = bytes.length()
    while i < len:
        var b1 = bytes.get(i)
        var b2 = 0
        var b3 = 0
        if i + 1 < len:
            b2 = bytes.get(i + 1)
        if i + 2 < len:
            b3 = bytes.get(i + 2)
        var n = (b1 << 16) | (b2 << 8) | b3
        var c1 = (n >> 18) & 0x3F
        var c2 = (n >> 12) & 0x3F
        var c3 = (n >> 6) & 0x3F
        var c4 = n & 0x3F
        result = result + base64_chars.get(c1)
        result = result + base64_chars.get(c2)
        if i + 1 < len:
            result = result + base64_chars.get(c3)
        else:
            result = result + "="
        if i + 2 < len:
            result = result + base64_chars.get(c4)
        else:
            result = result + "="
        i = i + 3
    result

export rotate_left
export bytes_to_hex
export hex_to_bytes
export xor_bytes
export constant_time_compare
export bytes_to_u32_le
export u32_to_bytes_le
export bytes_to_base64
