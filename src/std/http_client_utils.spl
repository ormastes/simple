# HTTP Client Utilities Module - Facade
# Comprehensive HTTP/1.1 client for making HTTP requests
# Pure Simple implementation with tuple-based structures

import http_client.types
import http_client.request
import http_client.response
import http_client.connection
import http_client.ssl
import http_client.utilities

# Re-export constants
val HTTP_VERSION = types.HTTP_VERSION
val METHOD_GET = types.METHOD_GET
val METHOD_POST = types.METHOD_POST
val METHOD_PUT = types.METHOD_PUT
val METHOD_DELETE = types.METHOD_DELETE
val METHOD_PATCH = types.METHOD_PATCH
val METHOD_HEAD = types.METHOD_HEAD
val METHOD_OPTIONS = types.METHOD_OPTIONS
val CONTENT_TYPE_JSON = types.CONTENT_TYPE_JSON
val CONTENT_TYPE_FORM = types.CONTENT_TYPE_FORM
val CONTENT_TYPE_MULTIPART = types.CONTENT_TYPE_MULTIPART
val CONTENT_TYPE_TEXT = types.CONTENT_TYPE_TEXT
val CONTENT_TYPE_HTML = types.CONTENT_TYPE_HTML
val CONTENT_TYPE_XML = types.CONTENT_TYPE_XML
val CONTENT_TYPE_OCTET_STREAM = types.CONTENT_TYPE_OCTET_STREAM
val STATUS_OK = types.STATUS_OK
val STATUS_CREATED = types.STATUS_CREATED
val STATUS_ACCEPTED = types.STATUS_ACCEPTED
val STATUS_NO_CONTENT = types.STATUS_NO_CONTENT
val STATUS_MOVED_PERMANENTLY = types.STATUS_MOVED_PERMANENTLY
val STATUS_FOUND = types.STATUS_FOUND
val STATUS_SEE_OTHER = types.STATUS_SEE_OTHER
val STATUS_NOT_MODIFIED = types.STATUS_NOT_MODIFIED
val STATUS_TEMPORARY_REDIRECT = types.STATUS_TEMPORARY_REDIRECT
val STATUS_PERMANENT_REDIRECT = types.STATUS_PERMANENT_REDIRECT
val STATUS_BAD_REQUEST = types.STATUS_BAD_REQUEST
val STATUS_UNAUTHORIZED = types.STATUS_UNAUTHORIZED
val STATUS_FORBIDDEN = types.STATUS_FORBIDDEN
val STATUS_NOT_FOUND = types.STATUS_NOT_FOUND
val STATUS_METHOD_NOT_ALLOWED = types.STATUS_METHOD_NOT_ALLOWED
val STATUS_CONFLICT = types.STATUS_CONFLICT
val STATUS_INTERNAL_SERVER_ERROR = types.STATUS_INTERNAL_SERVER_ERROR
val STATUS_NOT_IMPLEMENTED = types.STATUS_NOT_IMPLEMENTED
val STATUS_BAD_GATEWAY = types.STATUS_BAD_GATEWAY
val STATUS_SERVICE_UNAVAILABLE = types.STATUS_SERVICE_UNAVAILABLE
val USER_AGENT_DEFAULT = types.USER_AGENT_DEFAULT
val ACCEPT_DEFAULT = types.ACCEPT_DEFAULT

# Re-export URL encoding/decoding from types
fn url_encode(text: text) -> text:
    types.url_encode(text)

fn url_decode(text: text) -> text:
    types.url_decode(text)

fn url_encode_component(component: text) -> text:
    types.url_encode_component(component)

fn url_decode_component(component: text) -> text:
    types.url_decode_component(component)

# Re-export URL parsing from types
fn parse_url(url: text) -> (text, text, i64, text, text, text):
    types.parse_url(url)

fn build_url(scheme: text, host: text, port: i64, path: text, query: text, fragment: text) -> text:
    types.build_url(scheme, host, port, path, query, fragment)

fn url_join(base: text, relative: text) -> text:
    types.url_join(base, relative)

# Re-export query string handling from types
fn parse_query_string(query: text) -> list:
    types.parse_query_string(query)

fn build_query_string(params: list) -> text:
    types.build_query_string(params)

fn add_query_param(url: text, key: text, value: text) -> text:
    types.add_query_param(url, key, value)

fn remove_query_param(url: text, key: text) -> text:
    types.remove_query_param(url, key)

# Re-export request functions
fn create_headers() -> list:
    request.create_headers()

fn add_header(headers: list, name: text, value: text) -> list:
    request.add_header(headers, name, value)

fn get_header(headers: list, name: text) -> text:
    request.get_header(headers, name)

fn has_header(headers: list, name: text) -> bool:
    request.has_header(headers, name)

fn remove_header(headers: list, name: text) -> list:
    request.remove_header(headers, name)

fn set_header(headers: list, name: text, value: text) -> list:
    request.set_header(headers, name, value)

fn create_request(method: text, url: text) -> (text, text, list, text):
    request.create_request(method, url)

fn request_add_header(request: (text, text, list, text), name: text, value: text) -> (text, text, list, text):
    request.request_add_header(request, name, value)

fn request_set_body(request: (text, text, list, text), body: text) -> (text, text, list, text):
    request.request_set_body(request, body)

fn http_get(url: text) -> (text, text, list, text):
    request.http_get(url)

fn http_post(url: text, body: text) -> (text, text, list, text):
    request.http_post(url, body)

fn http_put(url: text, body: text) -> (text, text, list, text):
    request.http_put(url, body)

fn http_delete(url: text) -> (text, text, list, text):
    request.http_delete(url)

# Re-export response functions
fn create_response(status_code: i64, status_text: text, headers: list, body: text) -> (i64, text, list, text):
    response.create_response(status_code, status_text, headers, body)

fn response_get_status_code(response: (i64, text, list, text)) -> i64:
    response.response_get_status_code(response)

fn response_get_status_text(response: (i64, text, list, text)) -> text:
    response.response_get_status_text(response)

fn response_get_headers(response: (i64, text, list, text)) -> list:
    response.response_get_headers(response)

fn response_get_body(response: (i64, text, list, text)) -> text:
    response.response_get_body(response)

fn response_get_header(response: (i64, text, list, text), name: text) -> text:
    response.response_get_header(response, name)

fn response_is_success(response: (i64, text, list, text)) -> bool:
    response.response_is_success(response)

fn response_is_redirect(response: (i64, text, list, text)) -> bool:
    response.response_is_redirect(response)

fn response_is_client_error(response: (i64, text, list, text)) -> bool:
    response.response_is_client_error(response)

fn response_is_server_error(response: (i64, text, list, text)) -> bool:
    response.response_is_server_error(response)

fn status_code_to_text(code: i64) -> text:
    response.status_code_to_text(code)

# Re-export connection functions
fn serialize_headers(headers: list) -> text:
    connection.serialize_headers(headers)

fn serialize_request(request: (text, text, list, text)) -> text:
    connection.serialize_request(request)

fn parse_response(response_text: text) -> (i64, text, list, text):
    connection.parse_response(response_text)

fn mock_http_execute(request: (text, text, list, text)) -> (i64, text, list, text):
    connection.mock_http_execute(request)

# Re-export SSL/timeout functions
fn create_timeout_config(connect_ms: i64, read_ms: i64, write_ms: i64) -> (i64, i64, i64):
    ssl.create_timeout_config(connect_ms, read_ms, write_ms)

fn default_timeout_config() -> (i64, i64, i64):
    ssl.default_timeout_config()

fn timeout_config_get_connect(config: (i64, i64, i64)) -> i64:
    ssl.timeout_config_get_connect(config)

fn timeout_config_get_read(config: (i64, i64, i64)) -> i64:
    ssl.timeout_config_get_read(config)

fn timeout_config_get_write(config: (i64, i64, i64)) -> i64:
    ssl.timeout_config_get_write(config)

# Re-export utility functions
fn base64_encode(text: text) -> text:
    utilities.base64_encode(text)

fn is_valid_http_method(method: text) -> bool:
    utilities.is_valid_http_method(method)

fn is_absolute_url(url: text) -> bool:
    utilities.is_absolute_url(url)

fn normalize_url(url: text) -> text:
    utilities.normalize_url(url)

fn get_default_port(scheme: text) -> i64:
    utilities.get_default_port(scheme)

fn content_type_is_json(content_type: text) -> bool:
    utilities.content_type_is_json(content_type)

fn content_type_is_form(content_type: text) -> bool:
    utilities.content_type_is_form(content_type)

fn content_type_is_text(content_type: text) -> bool:
    utilities.content_type_is_text(content_type)
