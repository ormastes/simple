# Buffer and Byte Array Utilities - Facade
#
# Provides utilities for working with buffers and byte arrays.
# Useful for binary data manipulation, serialization, and protocol implementation.
#
# This is a facade that re-exports all buffer functionality from submodules:
# - buffer/types.spl: Buffer class definition and core methods
# - buffer/create.spl: Buffer creation functions
# - buffer/read.spl: Read operations
# - buffer/write.spl: Write operations
# - buffer/seek.spl: Position manipulation
# - buffer/utilities.spl: Byte utility functions

# Import all submodules
import buffer.types
import buffer.create
import buffer.read
import buffer.write
import buffer.seek
import buffer.utilities

# Re-export Buffer class
class Buffer:
    data: List
    read_pos: i64
    write_pos: i64
    cap: i64

    static fn create(capacity: i64) -> Buffer:
        buffer.create.buffer_create(capacity)

    static fn from_array(arr: List) -> Buffer:
        buffer.create.buffer_from_array(arr)

    static fn from_string(s: text) -> Buffer:
        buffer.create.buffer_from_string(s)

    static fn allocate(capacity: i64, fill_byte: i64) -> Buffer:
        buffer.create.buffer_allocate(capacity, fill_byte)

    fn size() -> i64:
        self.write_pos

    fn capacity() -> i64:
        self.cap

    fn available() -> i64:
        self.write_pos - self.read_pos

    fn available_capacity() -> i64:
        self.cap - self.write_pos

    fn is_full() -> bool:
        self.write_pos >= self.cap

    fn is_empty() -> bool:
        self.read_pos >= self.write_pos

    fn get_read_pos() -> i64:
        self.read_pos

    fn get_write_pos() -> i64:
        self.write_pos

    me set_read_pos(pos: i64):
        if pos >= 0 and pos <= self.write_pos:
            self.read_pos = pos

    me set_write_pos(pos: i64):
        if pos >= 0 and pos <= self.cap:
            self.write_pos = pos

    fn read_byte() -> i64:
        buffer.read.buffer_read_byte(self)

    fn read_bytes(count: i64) -> List:
        buffer.read.buffer_read_bytes(self, count)

    fn read_all() -> List:
        buffer.read.buffer_read_all(self)

    fn peek_byte() -> i64:
        buffer.read.buffer_peek_byte(self)

    fn peek_bytes(count: i64) -> List:
        buffer.read.buffer_peek_bytes(self, count)

    me write_byte(byte_val: i64):
        buffer.write.buffer_write_byte(self, byte_val)

    me write_bytes(bytes: List):
        buffer.write.buffer_write_bytes(self, bytes)

    me write_i64_be(value: i64):
        buffer.write.buffer_write_i64_be(self, value)

    me write_i64_le(value: i64):
        buffer.write.buffer_write_i64_le(self, value)

    me write_i32_be(value: i64):
        buffer.write.buffer_write_i32_be(self, value)

    me write_i32_le(value: i64):
        buffer.write.buffer_write_i32_le(self, value)

    me write_i16_be(value: i64):
        buffer.write.buffer_write_i16_be(self, value)

    me write_i16_le(value: i64):
        buffer.write.buffer_write_i16_le(self, value)

    fn read_i64_be() -> i64:
        buffer.read.buffer_read_i64_be(self)

    fn read_i64_le() -> i64:
        buffer.read.buffer_read_i64_le(self)

    fn read_i32_be() -> i64:
        buffer.read.buffer_read_i32_be(self)

    fn read_i32_le() -> i64:
        buffer.read.buffer_read_i32_le(self)

    fn read_i16_be() -> i64:
        buffer.read.buffer_read_i16_be(self)

    fn read_i16_le() -> i64:
        buffer.read.buffer_read_i16_le(self)

    me write_string(s: text):
        buffer.write.buffer_write_string(self, s)

    fn read_string() -> text:
        buffer.read.buffer_read_string(self)

    me write_raw_string(s: text):
        buffer.write.buffer_write_raw_string(self, s)

    fn read_raw_string(length: i64) -> text:
        buffer.read.buffer_read_raw_string(self, length)

    me write_line(s: text):
        buffer.write.buffer_write_line(self, s)

    fn read_line() -> text:
        buffer.read.buffer_read_line(self)

    me clear():
        buffer.seek.buffer_clear(self)

    me reset():
        buffer.seek.buffer_reset(self)

    me reset_read():
        buffer.seek.buffer_reset_read(self)

    me reset_write():
        buffer.seek.buffer_reset_write(self)

    me compact():
        buffer.seek.buffer_compact(self)

    fn expand(new_capacity: i64) -> Buffer:
        buffer.seek.buffer_expand(self, new_capacity)

    fn slice(start: i64, end: i64) -> List:
        val result = []
        var i = start
        while i < end and i < self.write_pos:
            result.append(self.data.get(i))
            i = i + 1
        result

    me copy_from(other: Buffer, count: i64):
        buffer.seek.buffer_copy_from(self, other, count)

    me copy_to(other: Buffer, count: i64):
        buffer.seek.buffer_copy_to(self, other, count)

    fn to_array() -> List:
        val result = []
        var i = 0
        while i < self.write_pos:
            result.append(self.data.get(i))
            i = i + 1
        result

    fn to_string() -> text:
        val bytes = self.to_array()
        buffer.utilities.bytes_to_string(bytes)

    fn compare(other: Buffer) -> i64:
        val len1 = self.write_pos
        val len2 = other.write_pos
        val min_len = if len1 < len2: len1 else: len2
        var i = 0
        while i < min_len:
            val b1 = self.data.get(i)
            val b2 = other.data.get(i)
            if b1 < b2:
                return -1
            if b1 > b2:
                return 1
            i = i + 1
        if len1 < len2:
            return -1
        if len1 > len2:
            return 1
        0

    fn equals(other: Buffer) -> bool:
        self.compare(other) == 0

    me fill(byte_val: i64):
        buffer.seek.buffer_fill(self, byte_val)

    me fill_range(start: i64, end: i64, byte_val: i64):
        buffer.seek.buffer_fill_range(self, start, end, byte_val)

    me skip(count: i64):
        buffer.seek.buffer_skip(self, count)

    me rewind(count: i64):
        buffer.seek.buffer_rewind(self, count)

    fn remaining() -> Buffer:
        val bytes = self.read_all()
        Buffer.from_array(bytes)

    fn clone() -> Buffer:
        val new_buf = Buffer.create(self.cap)
        var i = 0
        while i < self.cap:
            new_buf.data.set(i, self.data.get(i))
            i = i + 1
        new_buf.read_pos = self.read_pos
        new_buf.write_pos = self.write_pos
        new_buf

# Re-export utility functions
fn string_to_bytes(s: text) -> List: buffer.utilities.string_to_bytes(s)
fn bytes_to_string(bytes: List) -> text: buffer.utilities.bytes_to_string(bytes)
fn code_to_char(code: i64) -> text: buffer.utilities.code_to_char(code)
fn i64_to_bytes_be(value: i64) -> List: buffer.utilities.i64_to_bytes_be(value)
fn i64_to_bytes_le(value: i64) -> List: buffer.utilities.i64_to_bytes_le(value)
fn bytes_to_i64_be(bytes: List) -> i64: buffer.utilities.bytes_to_i64_be(bytes)
fn bytes_to_i64_le(bytes: List) -> i64: buffer.utilities.bytes_to_i64_le(bytes)
fn i32_to_bytes_be(value: i64) -> List: buffer.utilities.i32_to_bytes_be(value)
fn i32_to_bytes_le(value: i64) -> List: buffer.utilities.i32_to_bytes_le(value)
fn bytes_to_i32_be(bytes: List) -> i64: buffer.utilities.bytes_to_i32_be(bytes)
fn bytes_to_i32_le(bytes: List) -> i64: buffer.utilities.bytes_to_i32_le(bytes)
fn compare_bytes(a: List, b: List) -> i64: buffer.utilities.compare_bytes(a, b)
fn bytes_equal(a: List, b: List) -> bool: buffer.utilities.bytes_equal(a, b)
fn concat_bytes(a: List, b: List) -> List: buffer.utilities.concat_bytes(a, b)
fn copy_bytes(bytes: List) -> List: buffer.utilities.copy_bytes(bytes)
fn reverse_bytes(bytes: List) -> List: buffer.utilities.reverse_bytes(bytes)
fn slice_bytes(bytes: List, start: i64, end: i64) -> List: buffer.utilities.slice_bytes(bytes, start, end)
fn find_byte(bytes: List, target: i64) -> i64: buffer.utilities.find_byte(bytes, target)
fn count_byte(bytes: List, target: i64) -> i64: buffer.utilities.count_byte(bytes, target)
fn xor_bytes(a: List, b: List) -> List: buffer.utilities.xor_bytes(a, b)
fn bytes_to_hex(bytes: List) -> text: buffer.utilities.bytes_to_hex(bytes)
fn hex_to_bytes(hex: text) -> List: buffer.utilities.hex_to_bytes(hex)
fn hex_char_to_value(ch: text) -> i64: buffer.utilities.hex_char_to_value(ch)
fn checksum(bytes: List) -> i64: buffer.utilities.checksum(bytes)
fn crc8(bytes: List) -> i64: buffer.utilities.crc8(bytes)
