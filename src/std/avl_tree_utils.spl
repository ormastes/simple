# AVL Tree Utilities Module
# Comprehensive self-balancing Binary Search Tree (AVL tree) implementation
# Pure Simple implementation with tuple-based data structures
#
# AVL Tree Properties:
# - Balance factor: height(left) - height(right) ∈ {-1, 0, 1}
# - Self-balancing: Maintains balance after every insert/delete
# - Height: O(log n) guaranteed
# - Operations: Search, insert, delete all O(log n) worst-case
#
# Performance:
# - Search: O(log n) worst-case
# - Insert: O(log n) worst-case
# - Delete: O(log n) worst-case
# - Space: O(n)
# - Height: At most 1.44 * log₂(n + 2)

# ============================================================================
# Data Structures (tuple-based)
# ============================================================================

# AVLTree: (root: node, size: i64)
# AVLNode: (value: i64, left: node, right: node, height: i64)
# NIL_NODE: Special sentinel for empty nodes

# ============================================================================
# Constants and Sentinel Values
# ============================================================================

# NIL_NODE sentinel: (value: -999999999, left: nil, right: nil, height: 0)
# We use -999999999 as a sentinel value to represent nil nodes
fn NIL_SENTINEL() -> i64:
    -999999999

# ============================================================================
# Node Creation and Basic Accessors
# ============================================================================

# Create a nil node (sentinel)
fn nil_node() -> (i64, (i64, (i64, (i64, (i64, i64)))), (i64, (i64, (i64, (i64, i64)))), i64):
    val sentinel = NIL_SENTINEL()
    (sentinel, nil, nil, 0)

# Check if a node is nil
fn is_nil(node) -> bool:
    if node == nil:
        return true
    val value = node.0
    value == NIL_SENTINEL()

# Create a new AVL node with a value
fn create_node(value: i64) -> (i64, (i64, (i64, (i64, (i64, i64)))), (i64, (i64, (i64, (i64, i64)))), i64):
    (value, nil, nil, 1)

# Get node value
fn get_value(node) -> i64:
    if is_nil(node):
        return 0
    node.0

# Get left child
fn get_left(node):
    if is_nil(node):
        return nil
    node.1

# Get right child
fn get_right(node):
    if is_nil(node):
        return nil
    node.2

# Get node height
fn get_node_height(node) -> i64:
    if is_nil(node):
        return 0
    node.3

# Set node value
fn set_value(node, value: i64):
    if is_nil(node):
        return node
    (value, get_left(node), get_right(node), get_node_height(node))

# Set left child
fn set_left(node, left):
    if is_nil(node):
        return node
    (get_value(node), left, get_right(node), get_node_height(node))

# Set right child
fn set_right(node, right):
    if is_nil(node):
        return node
    (get_value(node), get_left(node), right, get_node_height(node))

# Set node height
fn set_height(node, height: i64):
    if is_nil(node):
        return node
    (get_value(node), get_left(node), get_right(node), height)

# ============================================================================
# AVL Tree Creation
# ============================================================================

# Create an empty AVL tree
# Returns: (root: node, size: i64)
fn create_avl_tree() -> (any, i64):
    (nil, 0)

# Get tree root
fn get_root(tree):
    tree.0

# Get tree size
fn get_size(tree) -> i64:
    tree.1

# Set tree root
fn set_root(tree, root):
    (root, get_size(tree))

# Set tree size
fn set_tree_size(tree, size: i64):
    (get_root(tree), size)

# Check if tree is empty
fn avl_is_empty(tree) -> bool:
    val root = get_root(tree)
    is_nil(root)

# ============================================================================
# Height and Balance Operations
# ============================================================================

# Get height of a node
fn get_height(node) -> i64:
    if is_nil(node):
        return 0
    get_node_height(node)

# Calculate and update node height based on children
fn update_height(node):
    if is_nil(node):
        return node
    val left = get_left(node)
    val right = get_right(node)
    val left_height = get_height(left)
    val right_height = get_height(right)
    var max_height = left_height
    if right_height > left_height:
        max_height = right_height
    val new_height = max_height + 1
    set_height(node, new_height)

# Get balance factor of a node
# Balance factor = height(left) - height(right)
fn get_balance_factor(node) -> i64:
    if is_nil(node):
        return 0
    val left = get_left(node)
    val right = get_right(node)
    val left_height = get_height(left)
    val right_height = get_height(right)
    left_height - right_height

# Check if a single node is balanced
fn is_node_balanced(node) -> bool:
    if is_nil(node):
        return true
    val bf = get_balance_factor(node)
    var result = bf >= -1
    if result:
        result = bf <= 1
    result

# ============================================================================
# Rotation Operations
# ============================================================================

# Left rotation (LL case)
#     y              x
#    / \            / \
#   x   C    =>    A   y
#  / \                / \
# A   B              B   C
fn rotate_left(y):
    if is_nil(y):
        return y
    val x = get_right(y)
    if is_nil(x):
        return y
    val B = get_left(x)

    # Perform rotation
    var new_y = set_right(y, B)
    new_y = update_height(new_y)
    var new_x = set_left(x, new_y)
    new_x = update_height(new_x)
    new_x

# Right rotation (RR case)
#     x              y
#    / \            / \
#   A   y    =>    x   C
#      / \        / \
#     B   C      A   B
fn rotate_right(x):
    if is_nil(x):
        return x
    val y = get_left(x)
    if is_nil(y):
        return x
    val B = get_right(y)

    # Perform rotation
    var new_x = set_left(x, B)
    new_x = update_height(new_x)
    var new_y = set_right(y, new_x)
    new_y = update_height(new_y)
    new_y

# Left-Right rotation (LR case)
fn rotate_left_right(node):
    if is_nil(node):
        return node
    val left = get_left(node)
    val rotated_left = rotate_left(left)
    var new_node = set_left(node, rotated_left)
    rotate_right(new_node)

# Right-Left rotation (RL case)
fn rotate_right_left(node):
    if is_nil(node):
        return node
    val right = get_right(node)
    val rotated_right = rotate_right(right)
    var new_node = set_right(node, rotated_right)
    rotate_left(new_node)

# ============================================================================
# Rebalancing
# ============================================================================

# Rebalance a node after modification
fn rebalance(node):
    if is_nil(node):
        return node

    # Update height first
    var balanced = update_height(node)

    # Get balance factor
    val bf = get_balance_factor(balanced)

    # Left-heavy (bf > 1)
    if bf > 1:
        val left = get_left(balanced)
        val left_bf = get_balance_factor(left)
        # Left-Left case
        if left_bf >= 0:
            return rotate_right(balanced)
        # Left-Right case
        return rotate_left_right(balanced)

    # Right-heavy (bf < -1)
    if bf < -1:
        val right = get_right(balanced)
        val right_bf = get_balance_factor(right)
        # Right-Right case
        if right_bf <= 0:
            return rotate_left(balanced)
        # Right-Left case
        return rotate_right_left(balanced)

    balanced

# Rebalance after insert
fn balance_after_insert(node):
    rebalance(node)

# Rebalance after delete
fn balance_after_delete(node):
    rebalance(node)

# ============================================================================
# Search Operations
# ============================================================================

# Search for a value in the tree (returns true if found)
fn avl_search(tree, value: i64) -> bool:
    val root = get_root(tree)
    search_node(root, value)

# Search in a node subtree
fn search_node(node, value: i64) -> bool:
    if is_nil(node):
        return false
    val node_value = get_value(node)
    if value == node_value:
        return true
    if value < node_value:
        val left = get_left(node)
        return search_node(left, value)
    val right = get_right(node)
    search_node(right, value)

# Check if tree contains a value
fn avl_contains(tree, value: i64) -> bool:
    avl_search(tree, value)

# Find node with value (returns node or nil)
fn find_node(node, value: i64):
    if is_nil(node):
        return nil
    val node_value = get_value(node)
    if value == node_value:
        return node
    if value < node_value:
        val left = get_left(node)
        return find_node(left, value)
    val right = get_right(node)
    find_node(right, value)

# ============================================================================
# Insert Operations
# ============================================================================

# Insert a value into the tree
fn avl_insert(tree, value: i64):
    val root = get_root(tree)
    val new_root = insert_node(root, value)
    var new_tree = set_root(tree, new_root)
    val old_size = get_size(tree)
    set_tree_size(new_tree, old_size + 1)

# Insert into node subtree
fn insert_node(node, value: i64):
    # Base case: create new node
    if is_nil(node):
        return create_node(value)

    val node_value = get_value(node)
    var modified = node

    # Insert into left subtree
    if value < node_value:
        val left = get_left(node)
        val new_left = insert_node(left, value)
        modified = set_left(node, new_left)
    # Insert into right subtree (allow duplicates on right)
    else:
        val right = get_right(node)
        val new_right = insert_node(right, value)
        modified = set_right(node, new_right)

    # Rebalance
    rebalance(modified)

# ============================================================================
# Delete Operations
# ============================================================================

# Delete a value from the tree
fn avl_delete(tree, value: i64):
    val root = get_root(tree)
    val new_root = delete_node(root, value)
    var new_tree = set_root(tree, new_root)
    val old_size = get_size(tree)
    var new_size = old_size - 1
    if new_size < 0:
        new_size = 0
    set_tree_size(new_tree, new_size)

# Delete from node subtree
fn delete_node(node, value: i64):
    if is_nil(node):
        return node

    val node_value = get_value(node)
    var modified = node

    # Value in left subtree
    if value < node_value:
        val left = get_left(node)
        val new_left = delete_node(left, value)
        modified = set_left(node, new_left)
    # Value in right subtree
    else:
        var cond = value > node_value
        if cond:
            val right = get_right(node)
            val new_right = delete_node(right, value)
            modified = set_right(node, new_right)
        # Found node to delete
        else:
            val left = get_left(node)
            val right = get_right(node)

            # Case 1: Node with only one child or no child
            if is_nil(left):
                return right
            if is_nil(right):
                return left

            # Case 2: Node with two children
            # Get inorder successor (smallest in right subtree)
            val successor = find_min_node(right)
            val successor_value = get_value(successor)

            # Copy successor value to this node
            modified = set_value(node, successor_value)

            # Delete successor
            val new_right = delete_node(right, successor_value)
            modified = set_right(modified, new_right)

    # Rebalance
    rebalance(modified)

# ============================================================================
# Min/Max Operations
# ============================================================================

# Find minimum value in tree
fn avl_min(tree) -> i64:
    val root = get_root(tree)
    val min_node = find_min_node(root)
    if is_nil(min_node):
        return 0
    get_value(min_node)

# Find maximum value in tree
fn avl_max(tree) -> i64:
    val root = get_root(tree)
    val max_node = find_max_node(root)
    if is_nil(max_node):
        return 0
    get_value(max_node)

# Find node with minimum value in subtree
fn find_min_node(node):
    if is_nil(node):
        return nil
    val left = get_left(node)
    if is_nil(left):
        return node
    find_min_node(left)

# Find node with maximum value in subtree
fn find_max_node(node):
    if is_nil(node):
        return nil
    val right = get_right(node)
    if is_nil(right):
        return node
    find_max_node(right)

# ============================================================================
# Successor/Predecessor Operations
# ============================================================================

# Find inorder successor of a value in tree
fn inorder_successor(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_successor(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find successor node
fn find_successor(node, value: i64, successor):
    if is_nil(node):
        return successor

    val node_value = get_value(node)

    # If value is less than node, node might be successor
    if value < node_value:
        val left = get_left(node)
        return find_successor(left, value, node)

    # If value is greater or equal, go right
    val right = get_right(node)
    find_successor(right, value, successor)

# Find inorder predecessor of a value in tree
fn inorder_predecessor(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_predecessor(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find predecessor node
fn find_predecessor(node, value: i64, predecessor):
    if is_nil(node):
        return predecessor

    val node_value = get_value(node)

    # If value is greater than node, node might be predecessor
    if value > node_value:
        val right = get_right(node)
        return find_predecessor(right, value, node)

    # If value is less or equal, go left
    val left = get_left(node)
    find_predecessor(left, value, predecessor)

# Find successor of a node
fn successor(node):
    if is_nil(node):
        return nil
    val right = get_right(node)
    if is_nil(right):
        return nil
    find_min_node(right)

# Find predecessor of a node
fn predecessor(node):
    if is_nil(node):
        return nil
    val left = get_left(node)
    if is_nil(left):
        return nil
    find_max_node(left)

# ============================================================================
# Statistics Operations
# ============================================================================

# Get tree size (number of nodes)
fn avl_size(tree) -> i64:
    get_size(tree)

# Get tree height
fn avl_height(tree) -> i64:
    val root = get_root(tree)
    get_height(root)

# Count nodes in subtree
fn count_nodes(node) -> i64:
    if is_nil(node):
        return 0
    val left = get_left(node)
    val right = get_right(node)
    val left_count = count_nodes(left)
    val right_count = count_nodes(right)
    1 + left_count + right_count

# Check if entire tree is balanced
fn is_balanced(tree) -> bool:
    val root = get_root(tree)
    check_balanced(root)

# Check if subtree is balanced
fn check_balanced(node) -> bool:
    if is_nil(node):
        return true

    # Check this node
    if is_node_balanced(node) == false:
        return false

    # Check children
    val left = get_left(node)
    val right = get_right(node)
    val left_balanced = check_balanced(left)
    if left_balanced == false:
        return false
    check_balanced(right)

# Check if tree satisfies BST property
fn is_valid_bst(tree) -> bool:
    val root = get_root(tree)
    val min_val = -2147483648
    val max_val = 2147483647
    check_bst(root, min_val, max_val)

# Check BST property for subtree
fn check_bst(node, min_val: i64, max_val: i64) -> bool:
    if is_nil(node):
        return true

    val value = get_value(node)

    # Check value range
    if value <= min_val:
        return false
    if value >= max_val:
        return false

    # Check children
    val left = get_left(node)
    val right = get_right(node)
    val left_valid = check_bst(left, min_val, value)
    if left_valid == false:
        return false
    check_bst(right, value, max_val)

# Check if tree is a valid AVL tree (BST + balanced)
fn is_valid_avl(tree) -> bool:
    val bst_valid = is_valid_bst(tree)
    if bst_valid == false:
        return false
    is_balanced(tree)

# ============================================================================
# Traversal Operations
# ============================================================================

# Inorder traversal (returns sorted list)
fn inorder(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    inorder_traverse(root, result)
    result

# Inorder traversal helper
fn inorder_traverse(node, result):
    if is_nil(node):
        return result

    val left = get_left(node)
    var updated = inorder_traverse(left, result)

    val value = get_value(node)
    updated = updated + [value]

    val right = get_right(node)
    inorder_traverse(right, updated)

# Preorder traversal
fn preorder(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    preorder_traverse(root, result)
    result

# Preorder traversal helper
fn preorder_traverse(node, result):
    if is_nil(node):
        return result

    val value = get_value(node)
    var updated = result + [value]

    val left = get_left(node)
    updated = preorder_traverse(left, updated)

    val right = get_right(node)
    preorder_traverse(right, updated)

# Postorder traversal
fn postorder(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    postorder_traverse(root, result)
    result

# Postorder traversal helper
fn postorder_traverse(node, result):
    if is_nil(node):
        return result

    val left = get_left(node)
    var updated = postorder_traverse(left, result)

    val right = get_right(node)
    updated = postorder_traverse(right, updated)

    val value = get_value(node)
    updated + [value]

# Level-order traversal (BFS)
fn level_order(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    if is_nil(root):
        return []

    val result = []
    val queue = [root]
    level_order_traverse(queue, result)

# Level-order traversal helper
fn level_order_traverse(queue, result):
    if queue == []:
        return result

    # Dequeue first node
    val node = queue.0
    val rest_queue = queue[1:]

    if is_nil(node):
        return level_order_traverse(rest_queue, result)

    # Add value to result
    val value = get_value(node)
    var updated_result = result + [value]

    # Enqueue children
    val left = get_left(node)
    val right = get_right(node)
    var updated_queue = rest_queue
    if is_nil(left) == false:
        updated_queue = updated_queue + [left]
    if is_nil(right) == false:
        updated_queue = updated_queue + [right]

    level_order_traverse(updated_queue, updated_result)

# ============================================================================
# Range Query Operations
# ============================================================================

# Range query: find all values in [min, max]
fn range_query(tree, min_val: i64, max_val: i64) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    range_search(root, min_val, max_val, result)

# Range search helper
fn range_search(node, min_val: i64, max_val: i64, result):
    if is_nil(node):
        return result

    val value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    var updated = result

    # Search left if value might be there
    if value > min_val:
        updated = range_search(left, min_val, max_val, updated)

    # Add current value if in range
    var in_range = value >= min_val
    if in_range:
        in_range = value <= max_val
    if in_range:
        updated = updated + [value]

    # Search right if value might be there
    if value < max_val:
        updated = range_search(right, min_val, max_val, updated)

    updated

# Count values in range [min, max]
fn count_range(tree, min_val: i64, max_val: i64) -> i64:
    val root = get_root(tree)
    count_in_range(root, min_val, max_val)

# Count in range helper
fn count_in_range(node, min_val: i64, max_val: i64) -> i64:
    if is_nil(node):
        return 0

    val value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    var count = 0

    # Count left if values might be there
    if value > min_val:
        val left_count = count_in_range(left, min_val, max_val)
        count = count + left_count

    # Count current if in range
    var in_range = value >= min_val
    if in_range:
        in_range = value <= max_val
    if in_range:
        count = count + 1

    # Count right if values might be there
    if value < max_val:
        val right_count = count_in_range(right, min_val, max_val)
        count = count + right_count

    count

# ============================================================================
# Floor and Ceiling Operations
# ============================================================================

# Floor: largest element <= value
fn floor(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_floor(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find floor node
fn find_floor(node, value: i64, best):
    if is_nil(node):
        return best

    val node_value = get_value(node)

    # If node value equals target, that's the floor
    if node_value == value:
        return node

    # If node value > target, floor is in left subtree
    if node_value > value:
        val left = get_left(node)
        return find_floor(left, value, best)

    # If node value < target, this might be floor, but check right
    val right = get_right(node)
    find_floor(right, value, node)

# Ceiling: smallest element >= value
fn ceiling(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_ceiling(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find ceiling node
fn find_ceiling(node, value: i64, best):
    if is_nil(node):
        return best

    val node_value = get_value(node)

    # If node value equals target, that's the ceiling
    if node_value == value:
        return node

    # If node value < target, ceiling is in right subtree
    if node_value < value:
        val right = get_right(node)
        return find_ceiling(right, value, best)

    # If node value > target, this might be ceiling, but check left
    val left = get_left(node)
    find_ceiling(left, value, node)

# ============================================================================
# Kth Element Operations
# ============================================================================

# Find k-th smallest element (1-indexed)
fn kth_smallest(tree, k: i64) -> i64:
    val root = get_root(tree)
    val result = find_kth_smallest(root, k)
    if is_nil(result):
        return 0
    get_value(result)

# Find k-th smallest node
fn find_kth_smallest(node, k: i64):
    if is_nil(node):
        return nil

    val left = get_left(node)
    val left_size = count_nodes(left)

    # k-th smallest is in left subtree
    if k <= left_size:
        return find_kth_smallest(left, k)

    # Current node is k-th smallest
    if k == left_size + 1:
        return node

    # k-th smallest is in right subtree
    val right = get_right(node)
    val new_k = k - left_size - 1
    find_kth_smallest(right, new_k)

# Find k-th largest element (1-indexed)
fn kth_largest(tree, k: i64) -> i64:
    val root = get_root(tree)
    val result = find_kth_largest(root, k)
    if is_nil(result):
        return 0
    get_value(result)

# Find k-th largest node
fn find_kth_largest(node, k: i64):
    if is_nil(node):
        return nil

    val right = get_right(node)
    val right_size = count_nodes(right)

    # k-th largest is in right subtree
    if k <= right_size:
        return find_kth_largest(right, k)

    # Current node is k-th largest
    if k == right_size + 1:
        return node

    # k-th largest is in left subtree
    val left = get_left(node)
    val new_k = k - right_size - 1
    find_kth_largest(left, new_k)

# ============================================================================
# Count Operations
# ============================================================================

# Count elements less than value
fn count_less_than(tree, value: i64) -> i64:
    val root = get_root(tree)
    count_less(root, value)

# Count less than helper
fn count_less(node, value: i64) -> i64:
    if is_nil(node):
        return 0

    val node_value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    # If node value >= value, all matching are in left
    if node_value >= value:
        return count_less(left, value)

    # If node value < value, count this + all left + some right
    val left_count = count_nodes(left)
    val right_count = count_less(right, value)
    1 + left_count + right_count

# Count elements greater than value
fn count_greater_than(tree, value: i64) -> i64:
    val root = get_root(tree)
    count_greater(root, value)

# Count greater than helper
fn count_greater(node, value: i64) -> i64:
    if is_nil(node):
        return 0

    val node_value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    # If node value <= value, all matching are in right
    if node_value <= value:
        return count_greater(right, value)

    # If node value > value, count this + all right + some left
    val right_count = count_nodes(right)
    val left_count = count_greater(left, value)
    1 + right_count + left_count

# ============================================================================
# Bulk Operations
# ============================================================================

# Build balanced tree from sorted array
fn build_from_sorted(values) -> (any, i64):
    val n = values.length
    if n == 0:
        return create_avl_tree()
    val root = build_from_sorted_helper(values, 0, n - 1)
    (root, n)

# Build from sorted array helper
fn build_from_sorted_helper(values, start: i64, end: i64):
    if start > end:
        return nil

    val mid = start + ((end - start) / 2)
    val value = values[mid]

    val left = build_from_sorted_helper(values, start, mid - 1)
    val right = build_from_sorted_helper(values, mid + 1, end)

    var node = create_node(value)
    node = set_left(node, left)
    node = set_right(node, right)
    update_height(node)

# Build balanced tree from unsorted array
fn build_balanced(values) -> (any, i64):
    val n = values.length
    if n == 0:
        return create_avl_tree()

    # Sort array first (simple bubble sort for now)
    val sorted = bubble_sort(values)
    build_from_sorted(sorted)

# Simple bubble sort for build_balanced
fn bubble_sort(arr):
    val n = arr.length
    if n <= 1:
        return arr
    var sorted = arr
    var i = 0
    while i < n - 1:
        var j = 0
        while j < n - i - 1:
            val curr = sorted[j]
            val next = sorted[j + 1]
            if curr > next:
                # Swap
                var temp = []
                var k = 0
                while k < sorted.length:
                    if k == j:
                        temp = temp + [next]
                    else:
                        var cond = k == j + 1
                        if cond:
                            temp = temp + [curr]
                        else:
                            temp = temp + [sorted[k]]
                    k = k + 1
                sorted = temp
            j = j + 1
        i = i + 1
    sorted

# ============================================================================
# Tree Merge and Split Operations
# ============================================================================

# Merge two AVL trees
fn merge_trees(tree1, tree2) -> (any, i64):
    val list1 = avl_to_list(tree1)
    val list2 = avl_to_list(tree2)
    val merged = merge_sorted_lists(list1, list2)
    build_from_sorted(merged)

# Merge two sorted lists
fn merge_sorted_lists(list1, list2):
    if list1 == []:
        return list2
    if list2 == []:
        return list1

    val h1 = list1.0
    val h2 = list2.0

    if h1 <= h2:
        val t1 = list1[1:]
        val rest = merge_sorted_lists(t1, list2)
        return [h1] + rest

    val t2 = list2[1:]
    val rest = merge_sorted_lists(list1, t2)
    [h2] + rest

# Split tree at value (returns two trees: < value and >= value)
fn split_tree(tree, value: i64) -> ((any, i64), (any, i64)):
    val all_values = avl_to_list(tree)
    val left_values = filter_less_than(all_values, value)
    val right_values = filter_greater_equal(all_values, value)
    val left_tree = build_from_sorted(left_values)
    val right_tree = build_from_sorted(right_values)
    (left_tree, right_tree)

# Filter values less than target
fn filter_less_than(values, target: i64):
    if values == []:
        return []
    val head = values.0
    val tail = values[1:]
    val rest = filter_less_than(tail, target)
    if head < target:
        return [head] + rest
    rest

# Filter values greater than or equal to target
fn filter_greater_equal(values, target: i64):
    if values == []:
        return []
    val head = values.0
    val tail = values[1:]
    val rest = filter_greater_equal(tail, target)
    if head >= target:
        return [head] + rest
    rest

# ============================================================================
# Clone and Copy Operations
# ============================================================================

# Deep copy of tree
fn clone_tree(tree) -> (any, i64):
    val root = get_root(tree)
    val size = get_size(tree)
    val new_root = clone_node(root)
    (new_root, size)

# Clone node recursively
fn clone_node(node):
    if is_nil(node):
        return nil

    val value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)
    val height = get_node_height(node)

    val new_left = clone_node(left)
    val new_right = clone_node(right)

    (value, new_left, new_right, height)

# ============================================================================
# Clear and Utility Operations
# ============================================================================

# Clear all nodes from tree
fn avl_clear(tree):
    create_avl_tree()

# Convert tree to sorted list (inorder traversal)
fn avl_to_list(tree) -> (i64, (i64, (i64, (i64, i64)))):
    inorder(tree)

# ============================================================================
# Visualization Operations
# ============================================================================

# Generate Graphviz DOT format
fn tree_to_dot(tree) -> text:
    val root = get_root(tree)
    var dot = "digraph AVLTree {\n"
    dot = dot + "    node [shape=circle];\n"
    val content = node_to_dot(root, 0)
    dot = dot + content
    dot + "}\n"

# Convert node to DOT format
fn node_to_dot(node, node_id: i64) -> text:
    if is_nil(node):
        return ""

    val value = get_value(node)
    val height = get_node_height(node)
    val label = "{value} (h:{height})"
    var result = "    n{node_id} [label=\"{label}\"];\n"

    val left = get_left(node)
    val right = get_right(node)
    val left_id = node_id * 2 + 1
    val right_id = node_id * 2 + 2

    if is_nil(left) == false:
        result = result + "    n{node_id} -> n{left_id};\n"
        val left_dot = node_to_dot(left, left_id)
        result = result + left_dot

    if is_nil(right) == false:
        result = result + "    n{node_id} -> n{right_id};\n"
        val right_dot = node_to_dot(right, right_id)
        result = result + right_dot

    result

# Print tree in ASCII format (simple version)
fn print_tree(tree):
    val root = get_root(tree)
    print_node(root, "", true)

# Print node recursively
fn print_node(node, prefix: text, is_tail: bool):
    if is_nil(node):
        return ()

    val value = get_value(node)
    val height = get_node_height(node)
    val bf = get_balance_factor(node)

    var connector = "└── "
    if is_tail == false:
        connector = "├── "

    print "{prefix}{connector}{value} (h:{height}, bf:{bf})"

    val left = get_left(node)
    val right = get_right(node)

    var new_prefix = prefix
    if is_tail:
        new_prefix = prefix + "    "
    else:
        new_prefix = prefix + "│   "

    if is_nil(right) == false:
        print_node(right, new_prefix, false)

    if is_nil(left) == false:
        print_node(left, new_prefix, true)

    ()
