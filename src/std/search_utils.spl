# Search Utilities
#
# Search algorithms and pattern matching.
# Pure Simple implementation - no external dependencies.
#
# Provides various search algorithms for different scenarios:
# - Linear search (sequential, sentinel)
# - Binary search (standard, lower/upper bound, rotated arrays)
# - Pattern matching (substring search, wildcard matching)
# - Special searches (jump search, interpolation search)
#
# Functions:
# - Linear: linear_search, linear_search_all, sentinel_search
# - Binary: binary_search, lower_bound, upper_bound, binary_search_rotated
# - Pattern: substring_search, wildcard_match, pattern_match_all
# - Special: jump_search, interpolation_search, exponential_search

# ============================================================================
# Linear Search
# ============================================================================

fn linear_search(arr, target):
    """Search for target using linear search.

    Returns index of first occurrence, or nil if not found.
    Time: O(n)

    Example:
        linear_search([1, 3, 5, 7, 9], 5)  # 2
        linear_search([1, 3, 5], 4)         # nil
    """
    var i = 0
    while i < arr.len():
        if arr[i] == target:
            return i
        i = i + 1

    nil

fn linear_search_all(arr, target):
    """Find all occurrences of target.

    Returns array of indices.

    Example:
        linear_search_all([1, 2, 3, 2, 4], 2)  # [1, 3]
    """
    var indices = []
    var i = 0

    while i < arr.len():
        if arr[i] == target:
            indices.push(i)
        i = i + 1

    indices

fn linear_search_with(arr, predicate):
    """Search for first element matching predicate.

    Returns index of first match, or nil.

    Example:
        linear_search_with([1, 2, 3, 4], \x: x > 2)  # 2
    """
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return i
        i = i + 1

    nil

fn sentinel_search(arr, target):
    """Linear search with sentinel optimization.

    Slightly faster than standard linear search.

    Example:
        sentinel_search([1, 3, 5, 7, 9], 5)  # 2
    """
    var work = arr
    work.push(target)  # Add sentinel

    var i = 0
    while work[i] != target:
        i = i + 1

    if i < arr.len():
        return i

    nil

# ============================================================================
# Binary Search
# ============================================================================

fn binary_search(arr, target):
    """Binary search in sorted array.

    Returns index if found, nil otherwise.
    Time: O(log n)
    Array must be sorted.

    Example:
        binary_search([1, 3, 5, 7, 9], 5)  # 2
        binary_search([1, 3, 5, 7, 9], 4)  # nil
    """
    var left = 0
    var right = arr.len() - 1

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    nil

fn binary_search_first(arr, target):
    """Find first occurrence in sorted array.

    Example:
        binary_search_first([1, 2, 2, 2, 3], 2)  # 1
    """
    var left = 0
    var right = arr.len() - 1
    var result = nil

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            result = mid
            right = mid - 1  # Continue searching left
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    result

fn binary_search_last(arr, target):
    """Find last occurrence in sorted array.

    Example:
        binary_search_last([1, 2, 2, 2, 3], 2)  # 3
    """
    var left = 0
    var right = arr.len() - 1
    var result = nil

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            result = mid
            left = mid + 1  # Continue searching right
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    result

fn lower_bound(arr, target):
    """Find first position where target could be inserted.

    Returns index of first element >= target.

    Example:
        lower_bound([1, 2, 4, 4, 5], 3)  # 2
        lower_bound([1, 2, 4, 4, 5], 4)  # 2
    """
    var left = 0
    var right = arr.len()

    while left < right:
        val mid = left + (right - left) / 2

        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    left

fn upper_bound(arr, target):
    """Find last position where target could be inserted.

    Returns index of first element > target.

    Example:
        upper_bound([1, 2, 4, 4, 5], 3)  # 2
        upper_bound([1, 2, 4, 4, 5], 4)  # 4
    """
    var left = 0
    var right = arr.len()

    while left < right:
        val mid = left + (right - left) / 2

        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid

    left

fn binary_search_range(arr, target):
    """Find range of target in sorted array.

    Returns (first_idx, last_idx) or nil if not found.

    Example:
        binary_search_range([1, 2, 2, 2, 3], 2)  # (1, 3)
    """
    val first = binary_search_first(arr, target)
    if not first.?:
        return nil

    val last = binary_search_last(arr, target)
    (first, last)

# ============================================================================
# Rotated Array Search
# ============================================================================

fn find_pivot(arr):
    """Find pivot point in rotated sorted array.

    Example:
        find_pivot([4, 5, 6, 7, 1, 2, 3])  # 4
    """
    var left = 0
    var right = arr.len() - 1

    while left < right:
        val mid = left + (right - left) / 2

        if arr[mid] > arr[right]:
            left = mid + 1
        else:
            right = mid

    left

fn binary_search_rotated(arr, target):
    """Binary search in rotated sorted array.

    Example:
        binary_search_rotated([4, 5, 6, 7, 1, 2, 3], 2)  # 5
    """
    var left = 0
    var right = arr.len() - 1

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            return mid

        # Determine which half is sorted
        if arr[left] <= arr[mid]:
            # Left half is sorted
            if target >= arr[left] and target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            # Right half is sorted
            if target > arr[mid] and target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1

    nil

# ============================================================================
# Jump Search
# ============================================================================

fn jump_search(arr, target):
    """Jump search in sorted array.

    Time: O(âˆšn)
    Faster than linear, slower than binary for large arrays.

    Example:
        jump_search([1, 3, 5, 7, 9, 11, 13], 9)  # 4
    """
    val n = arr.len()
    val jump = sqrt_integer(n)

    var prev = 0
    var step = jump

    # Jump ahead
    while step < n and arr[step] < target:
        prev = step
        step = step + jump

    # Linear search in block
    var i = prev
    while i < step and i < n:
        if arr[i] == target:
            return i
        i = i + 1

    nil

fn sqrt_integer(n: i64) -> i64:
    """Integer square root for jump search."""
    if n == 0:
        return 0

    var x = n
    var y = (x + 1) / 2

    while y < x:
        x = y
        y = (x + n / x) / 2

    x

# ============================================================================
# Interpolation Search
# ============================================================================

fn interpolation_search(arr, target):
    """Interpolation search in uniformly distributed sorted array.

    Time: O(log log n) for uniform distribution, O(n) worst case
    Best for uniformly distributed data.

    Example:
        interpolation_search([1, 3, 5, 7, 9], 5)  # 2
    """
    var low = 0
    var high = arr.len() - 1

    while low <= high and target >= arr[low] and target <= arr[high]:
        if low == high:
            if arr[low] == target:
                return low
            return nil

        # Estimate position
        val range = arr[high] - arr[low]
        if range == 0:
            if arr[low] == target:
                return low
            return nil

        val offset = (target - arr[low]) * (high - low) / range
        val pos = low + offset

        if arr[pos] == target:
            return pos
        elif arr[pos] < target:
            low = pos + 1
        else:
            high = pos - 1

    nil

# ============================================================================
# Exponential Search
# ============================================================================

fn exponential_search(arr, target):
    """Exponential search in sorted array.

    Useful for unbounded/infinite arrays.
    Time: O(log n)

    Example:
        exponential_search([1, 2, 3, 4, 5, 6, 7], 5)  # 4
    """
    if arr.len() == 0:
        return nil

    if arr[0] == target:
        return 0

    # Find range
    var i = 1
    while i < arr.len() and arr[i] <= target:
        i = i * 2

    # Binary search in range
    var left = i / 2
    var right = if i < arr.len(): i else: arr.len() - 1

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    nil

# ============================================================================
# String/Substring Search
# ============================================================================

fn substring_search(text: text, pattern: text) -> i64:
    """Find first occurrence of pattern in text.

    Returns starting index, or -1 if not found.
    Simple brute force algorithm.

    Example:
        substring_search("hello world", "world")  # 6
    """
    val text_len = text.len()
    val pattern_len = pattern.len()

    if pattern_len > text_len:
        return -1

    var i = 0
    while i <= text_len - pattern_len:
        var match = true
        var j = 0

        while j < pattern_len:
            if text[i + j] != pattern[j]:
                match = false
                break
            j = j + 1

        if match:
            return i

        i = i + 1

    -1

fn substring_search_all(text: text, pattern: text):
    """Find all occurrences of pattern in text.

    Returns array of starting indices.

    Example:
        substring_search_all("abababa", "aba")  # [0, 2, 4]
    """
    var indices = []
    val text_len = text.len()
    val pattern_len = pattern.len()

    if pattern_len > text_len:
        return indices

    var i = 0
    while i <= text_len - pattern_len:
        var match = true
        var j = 0

        while j < pattern_len:
            if text[i + j] != pattern[j]:
                match = false
                break
            j = j + 1

        if match:
            indices.push(i)

        i = i + 1

    indices

fn contains_substring(text: text, pattern: text):
    """Check if text contains pattern.

    Example:
        contains_substring("hello world", "world")  # true
    """
    substring_search(text, pattern) >= 0

# ============================================================================
# Pattern Matching
# ============================================================================

fn wildcard_match_helper(text: text, pattern: text, t_idx: i64, p_idx: i64):
    """Helper for wildcard matching."""
    # Base cases
    if p_idx == pattern.len():
        return t_idx == text.len()

    if t_idx == text.len():
        # Check if remaining pattern is all '*'
        var i = p_idx
        while i < pattern.len():
            if pattern[i] != '*':
                return false
            i = i + 1
        return true

    # Current characters
    val p_char = pattern[p_idx]

    # Match
    if p_char == '*':
        # Try matching zero or more characters
        # Zero characters
        if wildcard_match_helper(text, pattern, t_idx, p_idx + 1):
            return true
        # One or more characters
        return wildcard_match_helper(text, pattern, t_idx + 1, p_idx)
    elif p_char == '?' or p_char == text[t_idx]:
        return wildcard_match_helper(text, pattern, t_idx + 1, p_idx + 1)
    else:
        return false

fn wildcard_match(text: text, pattern: text):
    """Match text against wildcard pattern.

    Supports:
    - '*' matches zero or more characters
    - '?' matches exactly one character

    Example:
        wildcard_match("hello", "h*o")    # true
        wildcard_match("hello", "h?llo")  # true
        wildcard_match("hello", "h*x")    # false
    """
    wildcard_match_helper(text, pattern, 0, 0)

fn starts_with_pattern(text: text, prefix: text):
    """Check if text starts with prefix.

    Example:
        starts_with_pattern("hello world", "hello")  # true
    """
    if prefix.len() > text.len():
        return false

    var i = 0
    while i < prefix.len():
        if text[i] != prefix[i]:
            return false
        i = i + 1

    true

fn ends_with_pattern(text: text, suffix: text):
    """Check if text ends with suffix.

    Example:
        ends_with_pattern("hello world", "world")  # true
    """
    val text_len = text.len()
    val suffix_len = suffix.len()

    if suffix_len > text_len:
        return false

    var i = 0
    while i < suffix_len:
        if text[text_len - suffix_len + i] != suffix[i]:
            return false
        i = i + 1

    true

# ============================================================================
# Two Pointer Search
# ============================================================================

fn find_pair_with_sum(arr, target_sum):
    """Find pair of elements that sum to target.

    Array must be sorted.
    Returns (index1, index2) or nil.

    Example:
        find_pair_with_sum([1, 2, 3, 4, 5], 7)  # (1, 4) -> [2, 5]
    """
    var left = 0
    var right = arr.len() - 1

    while left < right:
        val current_sum = arr[left] + arr[right]

        if current_sum == target_sum:
            return (left, right)
        elif current_sum < target_sum:
            left = left + 1
        else:
            right = right - 1

    nil

fn find_triplet_with_sum(arr, target_sum):
    """Find three elements that sum to target.

    Array must be sorted.
    Returns (i, j, k) or nil.

    Example:
        find_triplet_with_sum([1, 2, 3, 4, 5], 9)  # (0, 2, 4) -> [1, 3, 5]
    """
    var i = 0
    while i < arr.len() - 2:
        var left = i + 1
        var right = arr.len() - 1

        while left < right:
            val current_sum = arr[i] + arr[left] + arr[right]

            if current_sum == target_sum:
                return (i, left, right)
            elif current_sum < target_sum:
                left = left + 1
            else:
                right = right - 1

        i = i + 1

    nil

# ============================================================================
# Search Utilities
# ============================================================================

fn find_min(arr):
    """Find minimum element in array.

    Example:
        find_min([3, 1, 4, 1, 5])  # 1
    """
    if arr.len() == 0:
        return nil

    var min_val = arr[0]
    for x in arr:
        if x < min_val:
            min_val = x

    min_val

fn find_max(arr):
    """Find maximum element in array.

    Example:
        find_max([3, 1, 4, 1, 5])  # 5
    """
    if arr.len() == 0:
        return nil

    var max_val = arr[0]
    for x in arr:
        if x > max_val:
            max_val = x

    max_val

fn find_min_max(arr):
    """Find both min and max in single pass.

    Returns (min, max) or nil.

    Example:
        find_min_max([3, 1, 4, 1, 5])  # (1, 5)
    """
    if arr.len() == 0:
        return nil

    var min_val = arr[0]
    var max_val = arr[0]

    for x in arr:
        if x < min_val:
            min_val = x
        if x > max_val:
            max_val = x

    (min_val, max_val)

fn count_occurrences(arr, target):
    """Count occurrences of target in array.

    Example:
        count_occurrences([1, 2, 2, 3, 2, 4], 2)  # 3
    """
    var count = 0
    for x in arr:
        if x == target:
            count = count + 1

    count

fn find_missing_number(arr, n: i64):
    """Find missing number in array [0..n].

    Array should contain n numbers from range [0, n].

    Example:
        find_missing_number([0, 1, 3, 4], 4)  # 2
    """
    # Sum of 0..n
    val expected_sum = n * (n + 1) / 2

    # Actual sum
    var actual_sum = 0
    for x in arr:
        actual_sum = actual_sum + x

    expected_sum - actual_sum

fn best_search_algorithm(arr_size: i64, is_sorted):
    """Recommend best search algorithm.

    Returns name of recommended algorithm.

    Example:
        best_search_algorithm(1000, true)   # "binary_search"
        best_search_algorithm(100, false)   # "linear_search"
    """
    if not is_sorted:
        return "linear_search"

    if arr_size < 100:
        return "linear_search"

    if arr_size < 10000:
        return "binary_search"

    "interpolation_search"
