# OAuth 2.0 Utilities Module
#
# Comprehensive OAuth 2.0 implementation supporting:
# - Authorization Code flow (RFC 6749)
# - Client Credentials flow
# - Refresh Token flow
# - PKCE extension (RFC 7636)
# - Token management and validation
# - Scope handling
# - State parameter for CSRF protection
#
# Security features:
# - State parameter validation (CSRF protection)
# - PKCE for public clients (mobile, SPA)
# - Secure URL validation (HTTPS only)
# - Token expiry checking
# - Scope validation
#
# Data structures (tuple-based for runtime compatibility):
# - OAuthConfig: (client_id, client_secret, redirect_uri, auth_url, token_url)
# - AccessToken: (token, token_type, expires_in, refresh_token, scope, issued_at)
# - AuthRequest: (client_id, redirect_uri, scope, state, code_challenge)
# - TokenRequest: (grant_type, code, client_id, client_secret, redirect_uri, code_verifier)
# - AuthResponse: (code, state, error, error_description)

import string
import array
import math

# ============================================================================
# OAuth Configuration
# ============================================================================

# Create OAuth configuration
# Returns: (client_id, client_secret, redirect_uri, auth_url, token_url)
fn create_oauth_config(client_id: text, client_secret: text, redirect_uri: text, auth_url: text, token_url: text):
    (client_id, client_secret, redirect_uri, auth_url, token_url)

# Get client ID from config
fn get_config_client_id(config):
    config.0

# Get client secret from config
fn get_config_client_secret(config):
    config.1

# Get redirect URI from config
fn get_config_redirect_uri(config):
    config.2

# Get authorization URL from config
fn get_config_auth_url(config):
    config.3

# Get token URL from config
fn get_config_token_url(config):
    config.4

# Validate OAuth configuration
fn validate_oauth_config(config) -> bool:
    val client_id = get_config_client_id(config)
    val client_secret = get_config_client_secret(config)
    val redirect_uri = get_config_redirect_uri(config)
    val auth_url = get_config_auth_url(config)
    val token_url = get_config_token_url(config)

    var valid = true
    if string.length(client_id) == 0:
        valid = false
    if string.length(client_secret) == 0:
        valid = false
    if string.length(redirect_uri) == 0:
        valid = false
    if string.length(auth_url) == 0:
        valid = false
    if string.length(token_url) == 0:
        valid = false

    valid

# ============================================================================
# Access Token Structure
# ============================================================================

# Create access token
# Returns: (token, token_type, expires_in, refresh_token, scope, issued_at)
fn create_access_token(token: text, token_type: text, expires_in: i64, refresh_token: text, scope: text, issued_at: i64):
    (token, token_type, expires_in, refresh_token, scope, issued_at)

# Get access token string
fn get_access_token(token):
    token.0

# Get token type (usually "Bearer")
fn get_token_type(token):
    token.1

# Get expires_in value (seconds)
fn get_expires_in(token):
    token.2

# Get refresh token
fn get_refresh_token(token):
    token.3

# Get token scope
fn get_token_scope(token):
    token.4

# Get token issued timestamp
fn get_token_issued_at(token):
    token.5

# Create token with current timestamp
fn create_token_now(token: text, token_type: text, expires_in: i64, refresh_token: text, scope: text):
    val now = get_current_timestamp()
    create_access_token(token, token_type, expires_in, refresh_token, scope, now)

# ============================================================================
# State Generation and Validation (CSRF Protection)
# ============================================================================

# Generate random state parameter for CSRF protection
# Returns a random 32-character string
fn generate_state() -> text:
    val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    var state = ""
    var i = 0
    while i < 32:
        val idx = random_int(0, string.length(chars) - 1)
        val char = string.char_at(chars, idx)
        state = string.concat(state, char)
        i = i + 1
    state

# Verify state parameter matches expected value
fn verify_state(state: text, expected: text) -> bool:
    string.equals(state, expected)

# Generate state with timestamp prefix (for expiry checking)
fn generate_state_with_timestamp() -> text:
    val timestamp = get_current_timestamp()
    val random_part = generate_state()
    val timestamp_str = i64_to_text(timestamp)
    string.concat(string.concat(timestamp_str, "_"), random_part)

# Verify state and check if not expired (within 10 minutes)
fn verify_state_with_expiry(state: text, expected: text, max_age_seconds: i64) -> bool:
    if not verify_state(state, expected):
        false
    else:
        # Extract timestamp from state
        val parts = string.split(state, "_")
        if array.length(parts) < 2:
            false
        else:
            val timestamp_str = array.get(parts, 0)
            val timestamp = text_to_i64(timestamp_str)
            val now = get_current_timestamp()
            val age = now - timestamp
            age <= max_age_seconds

# ============================================================================
# PKCE (Proof Key for Code Exchange) - RFC 7636
# ============================================================================

# Generate code verifier (43-128 characters, URL-safe)
fn generate_code_verifier() -> text:
    val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
    var verifier = ""
    var i = 0
    val length = 128  # Maximum length for better security
    while i < length:
        val idx = random_int(0, string.length(chars) - 1)
        val char = string.char_at(chars, idx)
        verifier = string.concat(verifier, char)
        i = i + 1
    verifier

# Generate code challenge from verifier using S256 method
# Challenge = BASE64URL(SHA256(verifier))
fn generate_code_challenge(verifier: text) -> text:
    # Simple implementation: use hash of verifier
    # In production, use proper SHA-256 and BASE64URL encoding
    val hashed = hash_sha256(verifier)
    base64url_encode(hashed)

# Verify code challenge matches verifier
fn verify_code_challenge(verifier: text, challenge: text) -> bool:
    val computed = generate_code_challenge(verifier)
    string.equals(computed, challenge)

# Get PKCE method (always S256 for security)
fn get_pkce_method() -> text:
    "S256"

# ============================================================================
# Scope Management
# ============================================================================

# Parse scope string into array of scopes
fn parse_scopes(scope_string: text):
    if string.length(scope_string) == 0:
        []
    else:
        string.split(scope_string, " ")

# Build scope string from array of scopes
fn build_scope_string(scopes):
    array.join(scopes, " ")

# Check if token has specific scope
fn has_scope(token, scope: text) -> bool:
    val token_scope = get_token_scope(token)
    val scopes = parse_scopes(token_scope)
    array_contains(scopes, scope)

# Check if token has all required scopes
fn has_all_scopes(token, required_scopes) -> bool:
    var i = 0
    var has_all = true
    while i < array.length(required_scopes):
        val scope = array.get(required_scopes, i)
        if not has_scope(token, scope):
            has_all = false
        i = i + 1
    has_all

# Check if token has any of the required scopes
fn has_any_scope(token, required_scopes) -> bool:
    var i = 0
    var has_any = false
    while i < array.length(required_scopes):
        val scope = array.get(required_scopes, i)
        if has_scope(token, scope):
            has_any = true
        i = i + 1
    has_any

# Validate scope format (alphanumeric, dots, underscores, hyphens)
fn validate_scope(scope: text) -> bool:
    val len = string.length(scope)
    if len == 0:
        return false

    var i = 0
    var valid = true
    while i < len:
        val char = string.char_at(scope, i)
        val is_alpha = is_alphanumeric(char)
        val is_dot = string.equals(char, ".")
        val is_underscore = string.equals(char, "_")
        val is_hyphen = string.equals(char, "-")

        if not is_alpha:
            if not is_dot:
                if not is_underscore:
                    if not is_hyphen:
                        valid = false
        i = i + 1
    valid

# Validate all scopes in array
fn validate_scopes(scopes) -> bool:
    var i = 0
    var valid = true
    while i < array.length(scopes):
        val scope = array.get(scopes, i)
        if not validate_scope(scope):
            valid = false
        i = i + 1
    valid

# ============================================================================
# Token Validation and Expiry
# ============================================================================

# Check if token is expired
fn is_token_expired(token) -> bool:
    val issued_at = get_token_issued_at(token)
    val expires_in = get_expires_in(token)
    val now = get_current_timestamp()
    val expiry_time = issued_at + expires_in
    now >= expiry_time

# Get token expiry timestamp
fn get_token_expiry(token) -> i64:
    val issued_at = get_token_issued_at(token)
    val expires_in = get_expires_in(token)
    issued_at + expires_in

# Get seconds until token expires (negative if expired)
fn get_time_until_expiry(token) -> i64:
    val expiry = get_token_expiry(token)
    val now = get_current_timestamp()
    expiry - now

# Validate access token (basic validation)
fn validate_access_token(token_string: text) -> bool:
    # Token should not be empty
    if string.length(token_string) == 0:
        return false

    # Token should be at least 20 characters (common minimum)
    if string.length(token_string) < 20:
        return false

    true

# Check if token needs refresh (expires within threshold seconds)
fn token_needs_refresh(token, threshold_seconds: i64) -> bool:
    val time_left = get_time_until_expiry(token)
    time_left <= threshold_seconds

# ============================================================================
# Authorization Request Building
# ============================================================================

# Build authorization URL for OAuth 2.0 flow
fn build_auth_url(config, scopes, state: text) -> text:
    val base_url = get_config_auth_url(config)
    val client_id = get_config_client_id(config)
    val redirect_uri = get_config_redirect_uri(config)
    val scope_string = build_scope_string(scopes)

    var url = base_url
    url = string.concat(url, "?response_type=code")

    val client_param = string.concat("&client_id=", url_encode(client_id))
    url = string.concat(url, client_param)

    val redirect_param = string.concat("&redirect_uri=", url_encode(redirect_uri))
    url = string.concat(url, redirect_param)

    val scope_param = string.concat("&scope=", url_encode(scope_string))
    url = string.concat(url, scope_param)

    val state_param = string.concat("&state=", url_encode(state))
    url = string.concat(url, state_param)

    url

# Build authorization URL with PKCE
fn build_auth_url_with_pkce(config, scopes, state: text, code_challenge: text) -> text:
    val base_url = build_auth_url(config, scopes, state)

    val challenge_param = string.concat("&code_challenge=", url_encode(code_challenge))
    var url = string.concat(base_url, challenge_param)

    val method_param = string.concat("&code_challenge_method=", get_pkce_method())
    url = string.concat(url, method_param)

    url

# Build authorization URL with additional parameters
fn build_auth_url_with_params(config, scopes, state: text, extra_params):
    var url = build_auth_url(config, scopes, state)

    var i = 0
    while i < array.length(extra_params):
        val param = array.get(extra_params, i)
        val key = param.0
        val value = param.1

        val param_str = string.concat(string.concat("&", key), string.concat("=", url_encode(value)))
        url = string.concat(url, param_str)
        i = i + 1

    url

# ============================================================================
# Authorization Response Parsing
# ============================================================================

# Parse authorization callback URL
# Returns: (code, state, error, error_description)
fn parse_auth_response(callback_url: text):
    val params = parse_query_params(callback_url)

    val code = get_param_value(params, "code")
    val state = get_param_value(params, "state")
    val error = get_param_value(params, "error")
    val error_desc = get_param_value(params, "error_description")

    (code, state, error, error_desc)

# Get authorization code from response
fn get_auth_code(response):
    response.0

# Get state from response
fn get_response_state(response):
    response.1

# Get error from response
fn get_response_error(response):
    response.2

# Get error description from response
fn get_response_error_description(response):
    response.3

# Check if authorization response has error
fn has_auth_error(response) -> bool:
    val error = get_response_error(response)
    string.length(error) > 0

# ============================================================================
# Token Exchange (Authorization Code Flow)
# ============================================================================

# Exchange authorization code for access token
# This is a simplified version - in production, make HTTP POST request
fn exchange_code_for_token(code: text, config):
    val client_id = get_config_client_id(config)
    val client_secret = get_config_client_secret(config)
    val redirect_uri = get_config_redirect_uri(config)

    # Build token request
    val request_body = build_token_request_body(
        "authorization_code",
        code,
        client_id,
        client_secret,
        redirect_uri,
        ""
    )

    # In production: POST to token_url with request_body
    # For now, return mock token
    create_mock_access_token()

# Exchange code with PKCE verifier
fn exchange_code_with_pkce(code: text, code_verifier: text, config):
    val client_id = get_config_client_id(config)
    val client_secret = get_config_client_secret(config)
    val redirect_uri = get_config_redirect_uri(config)

    val request_body = build_token_request_body(
        "authorization_code",
        code,
        client_id,
        client_secret,
        redirect_uri,
        code_verifier
    )

    # In production: POST to token_url with request_body
    create_mock_access_token()

# Build token request body (x-www-form-urlencoded)
fn build_token_request_body(grant_type: text, code: text, client_id: text, client_secret: text, redirect_uri: text, code_verifier: text) -> text:
    var body = ""

    val grant_param = string.concat("grant_type=", url_encode(grant_type))
    body = string.concat(body, grant_param)

    if string.length(code) > 0:
        val code_param = string.concat("&code=", url_encode(code))
        body = string.concat(body, code_param)

    val client_id_param = string.concat("&client_id=", url_encode(client_id))
    body = string.concat(body, client_id_param)

    val client_secret_param = string.concat("&client_secret=", url_encode(client_secret))
    body = string.concat(body, client_secret_param)

    if string.length(redirect_uri) > 0:
        val redirect_param = string.concat("&redirect_uri=", url_encode(redirect_uri))
        body = string.concat(body, redirect_param)

    if string.length(code_verifier) > 0:
        val verifier_param = string.concat("&code_verifier=", url_encode(code_verifier))
        body = string.concat(body, verifier_param)

    body

# ============================================================================
# Client Credentials Flow (Service-to-Service)
# ============================================================================

# Get access token using client credentials flow
fn get_client_credentials_token(config, scopes):
    val client_id = get_config_client_id(config)
    val client_secret = get_config_client_secret(config)
    val scope_string = build_scope_string(scopes)

    val request_body = build_client_credentials_request(client_id, client_secret, scope_string)

    # In production: POST to token_url with request_body
    create_mock_access_token()

# Build client credentials request body
fn build_client_credentials_request(client_id: text, client_secret: text, scope: text) -> text:
    var body = "grant_type=client_credentials"

    val client_id_param = string.concat("&client_id=", url_encode(client_id))
    body = string.concat(body, client_id_param)

    val client_secret_param = string.concat("&client_secret=", url_encode(client_secret))
    body = string.concat(body, client_secret_param)

    if string.length(scope) > 0:
        val scope_param = string.concat("&scope=", url_encode(scope))
        body = string.concat(body, scope_param)

    body

# ============================================================================
# Refresh Token Flow
# ============================================================================

# Refresh access token using refresh token
fn refresh_access_token(refresh_token: text, config):
    val client_id = get_config_client_id(config)
    val client_secret = get_config_client_secret(config)

    val request_body = build_refresh_token_request(refresh_token, client_id, client_secret)

    # In production: POST to token_url with request_body
    create_mock_access_token()

# Build refresh token request body
fn build_refresh_token_request(refresh_token: text, client_id: text, client_secret: text) -> text:
    var body = "grant_type=refresh_token"

    val refresh_param = string.concat("&refresh_token=", url_encode(refresh_token))
    body = string.concat(body, refresh_param)

    val client_id_param = string.concat("&client_id=", url_encode(client_id))
    body = string.concat(body, client_id_param)

    val client_secret_param = string.concat("&client_secret=", url_encode(client_secret))
    body = string.concat(body, client_secret_param)

    body

# Refresh token with additional scopes
fn refresh_token_with_scopes(refresh_token: text, config, scopes):
    val client_id = get_config_client_id(config)
    val client_secret = get_config_client_secret(config)
    val scope_string = build_scope_string(scopes)

    var body = build_refresh_token_request(refresh_token, client_id, client_secret)

    if string.length(scope_string) > 0:
        val scope_param = string.concat("&scope=", url_encode(scope_string))
        body = string.concat(body, scope_param)

    # In production: POST to token_url with body
    create_mock_access_token()

# ============================================================================
# HTTP Headers and Request Building
# ============================================================================

# Create Authorization header for Bearer token
fn create_auth_header(access_token: text) -> text:
    string.concat("Bearer ", access_token)

# Create full headers map for authenticated request
fn create_auth_headers(access_token: text):
    val auth_value = create_auth_header(access_token)
    [("Authorization", auth_value)]

# Add content type header for token requests
fn create_token_request_headers():
    [("Content-Type", "application/x-www-form-urlencoded")]

# Create headers with both auth and content type
fn create_full_request_headers(access_token: text):
    [
        ("Authorization", create_auth_header(access_token)),
        ("Content-Type", "application/json")
    ]

# ============================================================================
# Token Response Parsing
# ============================================================================

# Parse token JSON response (simplified)
# In production, use proper JSON parser
fn parse_token_response(json: text):
    # Mock implementation - extract values from JSON string
    val access_token = extract_json_value(json, "access_token")
    val token_type = extract_json_value(json, "token_type")
    val expires_in_str = extract_json_value(json, "expires_in")
    val refresh_token = extract_json_value(json, "refresh_token")
    val scope = extract_json_value(json, "scope")

    val expires_in = text_to_i64(expires_in_str)

    create_token_now(access_token, token_type, expires_in, refresh_token, scope)

# Extract value from JSON (simplified)
fn extract_json_value(json: text, key: text) -> text:
    # Simple extraction - in production use proper JSON parser
    val search_key = string.concat(string.concat("\"", key), "\":")
    val idx = string.index_of(json, search_key)

    if idx < 0:
        return ""

    val start_idx = idx + string.length(search_key)
    val rest = string.substring(json, start_idx, string.length(json))

    # Extract value until comma or closing brace
    val value = extract_until_delimiter(rest, ",}")
    string.trim(string.replace(value, "\"", ""))

# ============================================================================
# URL and Parameter Utilities
# ============================================================================

# URL encode a string
fn url_encode(input: text) -> text:
    var result = ""
    var i = 0
    val len = string.length(input)

    while i < len:
        val char = string.char_at(input, i)

        if is_unreserved_char(char):
            result = string.concat(result, char)
        else:
            # Encode as %XX (simplified - proper encoding needed)
            val encoded = percent_encode_char(char)
            result = string.concat(result, encoded)

        i = i + 1

    result

# Check if character is unreserved (no encoding needed)
fn is_unreserved_char(char: text) -> bool:
    val is_alpha = is_alphanumeric(char)
    val is_hyphen = string.equals(char, "-")
    val is_underscore = string.equals(char, "_")
    val is_dot = string.equals(char, ".")
    val is_tilde = string.equals(char, "~")

    if is_alpha:
        true
    else:
        if is_hyphen:
            true
        else:
            if is_underscore:
                true
            else:
                if is_dot:
                    true
                else:
                    is_tilde

# Parse query parameters from URL
fn parse_query_params(url: text):
    val query_start = string.index_of(url, "?")
    if query_start < 0:
        return []

    val query_string = string.substring(url, query_start + 1, string.length(url))
    val pairs = string.split(query_string, "&")

    var params = []
    var i = 0
    while i < array.length(pairs):
        val pair = array.get(pairs, i)
        val parts = string.split(pair, "=")

        if array.length(parts) >= 2:
            val key = array.get(parts, 0)
            val value = array.get(parts, 1)
            params = array.append(params, (key, url_decode(value)))

        i = i + 1

    params

# Get parameter value from params array
fn get_param_value(params, key: text) -> text:
    var i = 0
    var value = ""

    while i < array.length(params):
        val param = array.get(params, i)
        val param_key = param.0

        if string.equals(param_key, key):
            value = param.1

        i = i + 1

    value

# URL decode a string
fn url_decode(input: text) -> text:
    # Simplified implementation
    var result = input
    result = string.replace(result, "+", " ")
    result = string.replace(result, "%20", " ")
    result

# Build URL with query parameters
fn build_url_with_params(base_url: text, params):
    var url = base_url

    var i = 0
    while i < array.length(params):
        val param = array.get(params, i)
        val key = param.0
        val value = param.1

        val separator = if i == 0: "?" else: "&"
        val param_str = string.concat(string.concat(string.concat(separator, key), "="), url_encode(value))
        url = string.concat(url, param_str)

        i = i + 1

    url

# ============================================================================
# Security Validation
# ============================================================================

# Validate redirect URI is in allowed list
fn validate_redirect_uri(uri: text, allowed_uris) -> bool:
    array_contains(allowed_uris, uri)

# Check if URL uses HTTPS
fn is_secure_url(url: text) -> bool:
    string.starts_with(url, "https://")

# Validate client ID format
fn validate_client_id(client_id: text) -> bool:
    val len = string.length(client_id)
    if len < 5:
        return false
    if len > 256:
        return false

    # Should contain only alphanumeric and hyphens
    var i = 0
    var valid = true
    while i < len:
        val char = string.char_at(client_id, i)
        val is_valid_char = is_alphanumeric(char)
        val is_hyphen = string.equals(char, "-")

        if not is_valid_char:
            if not is_hyphen:
                valid = false

        i = i + 1

    valid

# Validate authorization code format
fn validate_auth_code(code: text) -> bool:
    val len = string.length(code)
    if len < 20:
        return false
    if len > 512:
        return false
    true

# Check token age in seconds
fn get_token_age(token) -> i64:
    val issued_at = get_token_issued_at(token)
    val now = get_current_timestamp()
    now - issued_at

# ============================================================================
# Client Credential Generation
# ============================================================================

# Generate client ID (random alphanumeric string)
fn generate_client_id() -> text:
    val prefix = "client_"
    val random_part = generate_random_string(32)
    string.concat(prefix, random_part)

# Generate client secret (longer random string)
fn generate_client_secret() -> text:
    generate_random_string(64)

# Hash client secret for storage (simplified - use proper hash in production)
fn hash_client_secret(secret: text) -> text:
    hash_sha256(secret)

# Verify hashed secret
fn verify_client_secret(secret: text, hashed: text) -> bool:
    val computed = hash_client_secret(secret)
    string.equals(computed, hashed)

# ============================================================================
# Token Introspection
# ============================================================================

# Build token introspection request
fn build_introspection_request(token: text, client_id: text, client_secret: text) -> text:
    var body = ""

    val token_param = string.concat("token=", url_encode(token))
    body = string.concat(body, token_param)

    val client_id_param = string.concat("&client_id=", url_encode(client_id))
    body = string.concat(body, client_id_param)

    val client_secret_param = string.concat("&client_secret=", url_encode(client_secret))
    body = string.concat(body, client_secret_param)

    body

# Parse introspection response
# Returns: (active, scope, client_id, username, token_type, exp, iat)
fn parse_introspection_response(json: text):
    val active_str = extract_json_value(json, "active")
    val active = string.equals(active_str, "true")
    val scope = extract_json_value(json, "scope")
    val client_id = extract_json_value(json, "client_id")
    val username = extract_json_value(json, "username")
    val token_type = extract_json_value(json, "token_type")
    val exp_str = extract_json_value(json, "exp")
    val iat_str = extract_json_value(json, "iat")

    val exp = text_to_i64(exp_str)
    val iat = text_to_i64(iat_str)

    (active, scope, client_id, username, token_type, exp, iat)

# Check if introspection response indicates active token
fn is_token_active(introspection_response) -> bool:
    introspection_response.0

# ============================================================================
# Token Revocation
# ============================================================================

# Build token revocation request
fn build_revocation_request(token: text, token_type_hint: text, client_id: text, client_secret: text) -> text:
    var body = ""

    val token_param = string.concat("token=", url_encode(token))
    body = string.concat(body, token_param)

    if string.length(token_type_hint) > 0:
        val hint_param = string.concat("&token_type_hint=", url_encode(token_type_hint))
        body = string.concat(body, hint_param)

    val client_id_param = string.concat("&client_id=", url_encode(client_id))
    body = string.concat(body, client_id_param)

    val client_secret_param = string.concat("&client_secret=", url_encode(client_secret))
    body = string.concat(body, client_secret_param)

    body

# Revoke access token
fn revoke_access_token(token: text, config):
    build_revocation_request(token, "access_token", get_config_client_id(config), get_config_client_secret(config))

# Revoke refresh token
fn revoke_refresh_token(token: text, config):
    build_revocation_request(token, "refresh_token", get_config_client_id(config), get_config_client_secret(config))

# ============================================================================
# Helper Functions
# ============================================================================

# Get current timestamp (seconds since epoch)
fn get_current_timestamp() -> i64:
    # Simplified - in production use system time
    1707753600  # Mock timestamp

# Generate random integer in range [min, max]
fn random_int(min: i64, max: i64) -> i64:
    # Simplified random - in production use proper PRNG
    val range = max - min + 1
    min + (get_current_timestamp() % range)

# Generate random alphanumeric string
fn generate_random_string(length: i64) -> text:
    val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    var result = ""
    var i = 0
    while i < length:
        val idx = random_int(0, string.length(chars) - 1)
        val char = string.char_at(chars, idx)
        result = string.concat(result, char)
        i = i + 1
    result

# Check if character is alphanumeric
fn is_alphanumeric(char: text) -> bool:
    val code = string.char_code(char)
    val is_digit = code >= 48  # '0' = 48
    val is_digit_end = code <= 57  # '9' = 57
    val is_upper = code >= 65  # 'A' = 65
    val is_upper_end = code <= 90  # 'Z' = 90
    val is_lower = code >= 97  # 'a' = 97
    val is_lower_end = code <= 122  # 'z' = 122

    var result = false
    if is_digit:
        if is_digit_end:
            result = true

    if is_upper:
        if is_upper_end:
            result = true

    if is_lower:
        if is_lower_end:
            result = true

    result

# Check if array contains element
fn array_contains(arr, element: text) -> bool:
    var i = 0
    var found = false
    while i < array.length(arr):
        val item = array.get(arr, i)
        if string.equals(item, element):
            found = true
        i = i + 1
    found

# Convert i64 to text
fn i64_to_text(value: i64) -> text:
    # Simplified - in production use proper conversion
    if value == 0:
        return "0"

    var result = ""
    var num = value
    var is_negative = num < 0

    if is_negative:
        num = 0 - num

    while num > 0:
        val digit = num % 10
        val char = digit_to_char(digit)
        result = string.concat(char, result)
        num = num / 10

    if is_negative:
        result = string.concat("-", result)

    result

# Convert text to i64
fn text_to_i64(text: text) -> i64:
    # Simplified - in production use proper parsing
    val len = string.length(text)
    if len == 0:
        return 0

    var result = 0
    var i = 0
    var is_negative = string.equals(string.char_at(text, 0), "-")

    if is_negative:
        i = 1

    while i < len:
        val char = string.char_at(text, i)
        val digit = char_to_digit(char)
        result = result * 10 + digit
        i = i + 1

    if is_negative:
        result = 0 - result

    result

# Convert digit to character
fn digit_to_char(digit: i64) -> text:
    val digits = "0123456789"
    string.char_at(digits, digit)

# Convert character to digit
fn char_to_digit(char: text) -> i64:
    val code = string.char_code(char)
    code - 48  # '0' = 48

# Real SHA-256 hash per FIPS 180-4
# Returns 64-character lowercase hex string
fn hash_sha256(input: text) -> text:
    val mask32 = 4294967295

    # SHA-256 initial hash values
    var h0 = 1779033703
    var h1 = 3144134277
    var h2 = 1013904242
    var h3 = 2773480762
    var h4 = 1359893119
    var h5 = 2600822924
    var h6 = 528734635
    var h7 = 1541459225

    # Round constants
    var kk = [
        1116352408, 1899447441, 3049323471, 3921009573,
        961987163, 1508970993, 2453635748, 2870763221,
        3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037,
        2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877,
        958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298
    ]

    # Convert to bytes
    val input_len = string.length(input)
    var bytes = []
    var bi = 0
    while bi < input_len:
        val ch = string.char_at(input, bi)
        val code = string.char_code(ch)
        bytes = array.push(bytes, code)
        bi = bi + 1

    # Pad message
    val data_len = array.length(bytes)
    bytes = array.push(bytes, 128)
    val pad_target = data_len + 1
    var pad_zeros = 56 - (pad_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        bytes = array.push(bytes, 0)
        pz = pz + 1

    val bit_length = data_len * 8
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, (bit_length >> 24) & 255)
    bytes = array.push(bytes, (bit_length >> 16) & 255)
    bytes = array.push(bytes, (bit_length >> 8) & 255)
    bytes = array.push(bytes, bit_length & 255)

    # Process 64-byte blocks
    val total_len = array.length(bytes)
    var block_off = 0
    while block_off < total_len:
        var w = []
        var wi = 0
        while wi < 16:
            val base = block_off + (wi * 4)
            val vb0 = bytes[base] & 255
            val vb1 = bytes[base + 1] & 255
            val vb2 = bytes[base + 2] & 255
            val vb3 = bytes[base + 3] & 255
            val word = ((vb0 << 24) | (vb1 << 16) | (vb2 << 8) | vb3) & mask32
            w = array.push(w, word)
            wi = wi + 1

        wi = 16
        while wi < 64:
            val w15 = w[wi - 15] & mask32
            val w2 = w[wi - 2] & mask32
            val r7 = ((w15 >> 7) | (w15 << 25)) & mask32
            val r18 = ((w15 >> 18) | (w15 << 14)) & mask32
            val sh3 = (w15 >> 3) & mask32
            val s0 = (r7 ^ r18 ^ sh3) & mask32
            val r17 = ((w2 >> 17) | (w2 << 15)) & mask32
            val r19 = ((w2 >> 19) | (w2 << 13)) & mask32
            val sh10 = (w2 >> 10) & mask32
            val s1 = (r17 ^ r19 ^ sh10) & mask32
            val new_w = (w[wi - 16] + s0 + w[wi - 7] + s1) & mask32
            w = array.push(w, new_w)
            wi = wi + 1

        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var hv = h7

        var ri = 0
        while ri < 64:
            val ea = e & mask32
            val er6 = ((ea >> 6) | (ea << 26)) & mask32
            val er11 = ((ea >> 11) | (ea << 21)) & mask32
            val er25 = ((ea >> 25) | (ea << 7)) & mask32
            val big_s1 = (er6 ^ er11 ^ er25) & mask32
            val ch = ((ea & (f & mask32)) ^ ((~ea & mask32) & (g & mask32))) & mask32
            val temp1 = (hv + big_s1 + ch + kk[ri] + w[ri]) & mask32

            val aa = a & mask32
            val ar2 = ((aa >> 2) | (aa << 30)) & mask32
            val ar13 = ((aa >> 13) | (aa << 19)) & mask32
            val ar22 = ((aa >> 22) | (aa << 10)) & mask32
            val big_s0 = (ar2 ^ ar13 ^ ar22) & mask32
            val maj = ((aa & (b & mask32)) ^ (aa & (c & mask32)) ^ ((b & mask32) & (c & mask32))) & mask32
            val temp2 = (big_s0 + maj) & mask32

            hv = g
            g = f
            f = e
            e = (d + temp1) & mask32
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & mask32
            ri = ri + 1

        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        h5 = (h5 + f) & mask32
        h6 = (h6 + g) & mask32
        h7 = (h7 + hv) & mask32

        block_off = block_off + 64

    # Convert to hex string
    val hex_chars = "0123456789abcdef"
    var result = ""
    var h_vals = [h0, h1, h2, h3, h4, h5, h6, h7]
    var hi = 0
    while hi < 8:
        val word = h_vals[hi] & mask32
        var nibble_idx = 7
        while nibble_idx >= 0:
            val nibble = (word >> (nibble_idx * 4)) & 15
            val hex_char = string.char_at(hex_chars, nibble)
            result = string.concat(result, hex_char)
            nibble_idx = nibble_idx - 1
        hi = hi + 1

    result

# Convert i64 to hex
fn i64_to_hex(value: i64) -> text:
    val hex_chars = "0123456789abcdef"
    var result = ""
    var num = value

    if num == 0:
        return "00"

    while num > 0:
        val digit = num % 16
        val char = string.char_at(hex_chars, digit)
        result = string.concat(char, result)
        num = num / 16

    # Pad to 2 characters
    while string.length(result) < 2:
        result = string.concat("0", result)

    result

# Base64 URL encode (simplified)
fn base64url_encode(input: text) -> text:
    # In production, use proper base64url encoding
    # This is a simplified mock
    var result = input
    result = string.replace(result, "+", "-")
    result = string.replace(result, "/", "_")
    result = string.replace(result, "=", "")
    result

# Percent encode character
fn percent_encode_char(char: text) -> text:
    val code = string.char_code(char)
    val hex = i64_to_hex(code)
    string.concat("%", hex)

# Extract string until delimiter
fn extract_until_delimiter(input: text, delimiters: text) -> text:
    var result = ""
    var i = 0
    val len = string.length(input)

    while i < len:
        val char = string.char_at(input, i)
        val is_delimiter = string.contains(delimiters, char)

        if is_delimiter:
            return result

        result = string.concat(result, char)
        i = i + 1

    result

# Create mock access token for testing
fn create_mock_access_token():
    create_token_now(
        "mock_access_token_" + generate_random_string(32),
        "Bearer",
        3600,
        "mock_refresh_token_" + generate_random_string(32),
        "read write profile"
    )

# ============================================================================
# Error Handling
# ============================================================================

# OAuth error codes (RFC 6749)
fn get_invalid_request_error() -> text:
    "invalid_request"

fn get_invalid_client_error() -> text:
    "invalid_client"

fn get_invalid_grant_error() -> text:
    "invalid_grant"

fn get_unauthorized_client_error() -> text:
    "unauthorized_client"

fn get_unsupported_grant_type_error() -> text:
    "unsupported_grant_type"

fn get_invalid_scope_error() -> text:
    "invalid_scope"

fn get_access_denied_error() -> text:
    "access_denied"

# Create error response
fn create_error_response(error: text, description: text):
    (error, description)

# Get error code from error response
fn get_error_code(error_response):
    error_response.0

# Get error description from error response
fn get_error_description(error_response):
    error_response.1
