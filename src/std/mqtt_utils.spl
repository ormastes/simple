# MQTT Protocol Utilities Module
# Supports MQTT v3.1.1 and v5.0
# Pure Simple implementation with no runtime limitations

# ============================================================================
# MQTT Constants and Types
# ============================================================================

# MQTT Protocol Versions
val MQTT_VERSION_3_1_1 = 4
val MQTT_VERSION_5_0 = 5

# MQTT Packet Types
val PACKET_TYPE_CONNECT = 1
val PACKET_TYPE_CONNACK = 2
val PACKET_TYPE_PUBLISH = 3
val PACKET_TYPE_PUBACK = 4
val PACKET_TYPE_PUBREC = 5
val PACKET_TYPE_PUBREL = 6
val PACKET_TYPE_PUBCOMP = 7
val PACKET_TYPE_SUBSCRIBE = 8
val PACKET_TYPE_SUBACK = 9
val PACKET_TYPE_UNSUBSCRIBE = 10
val PACKET_TYPE_UNSUBACK = 11
val PACKET_TYPE_PINGREQ = 12
val PACKET_TYPE_PINGRESP = 13
val PACKET_TYPE_DISCONNECT = 14
val PACKET_TYPE_AUTH = 15

# QoS Levels
val QOS_AT_MOST_ONCE = 0
val QOS_AT_LEAST_ONCE = 1
val QOS_EXACTLY_ONCE = 2

# CONNECT Flags
val CONNECT_FLAG_USERNAME = 128
val CONNECT_FLAG_PASSWORD = 64
val CONNECT_FLAG_WILL_RETAIN = 32
val CONNECT_FLAG_WILL_QOS_1 = 8
val CONNECT_FLAG_WILL_QOS_2 = 16
val CONNECT_FLAG_WILL_FLAG = 4
val CONNECT_FLAG_CLEAN_SESSION = 2

# PUBLISH Flags
val PUBLISH_FLAG_DUP = 8
val PUBLISH_FLAG_QOS_1 = 2
val PUBLISH_FLAG_QOS_2 = 4
val PUBLISH_FLAG_RETAIN = 1

# CONNACK Return Codes (v3.1.1)
val CONNACK_ACCEPTED = 0
val CONNACK_REFUSED_PROTOCOL = 1
val CONNACK_REFUSED_IDENTIFIER = 2
val CONNACK_REFUSED_SERVER_UNAVAILABLE = 3
val CONNACK_REFUSED_BAD_CREDENTIALS = 4
val CONNACK_REFUSED_NOT_AUTHORIZED = 5

# MQTT v5.0 Reason Codes
val REASON_SUCCESS = 0
val REASON_NORMAL_DISCONNECTION = 0
val REASON_GRANTED_QOS_0 = 0
val REASON_GRANTED_QOS_1 = 1
val REASON_GRANTED_QOS_2 = 2
val REASON_DISCONNECT_WILL = 4
val REASON_NO_MATCHING_SUBSCRIBERS = 16
val REASON_UNSPECIFIED_ERROR = 128
val REASON_MALFORMED_PACKET = 129
val REASON_PROTOCOL_ERROR = 130
val REASON_IMPLEMENTATION_ERROR = 131
val REASON_UNSUPPORTED_PROTOCOL = 132
val REASON_CLIENT_IDENTIFIER_NOT_VALID = 133
val REASON_BAD_CREDENTIALS = 134
val REASON_NOT_AUTHORIZED = 135
val REASON_SERVER_UNAVAILABLE = 136
val REASON_SERVER_BUSY = 137
val REASON_BANNED = 138
val REASON_BAD_AUTHENTICATION = 140
val REASON_TOPIC_NAME_INVALID = 144
val REASON_PACKET_TOO_LARGE = 149
val REASON_QUOTA_EXCEEDED = 151
val REASON_PAYLOAD_FORMAT_INVALID = 153
val REASON_RETAIN_NOT_SUPPORTED = 154
val REASON_QOS_NOT_SUPPORTED = 155
val REASON_USE_ANOTHER_SERVER = 156
val REASON_SERVER_MOVED = 157
val REASON_CONNECTION_RATE_EXCEEDED = 159

# MQTT v5.0 Property IDs
val PROPERTY_PAYLOAD_FORMAT = 1
val PROPERTY_MESSAGE_EXPIRY = 2
val PROPERTY_CONTENT_TYPE = 3
val PROPERTY_RESPONSE_TOPIC = 8
val PROPERTY_CORRELATION_DATA = 9
val PROPERTY_SUBSCRIPTION_ID = 11
val PROPERTY_SESSION_EXPIRY = 17
val PROPERTY_ASSIGNED_CLIENT_ID = 18
val PROPERTY_SERVER_KEEP_ALIVE = 19
val PROPERTY_AUTH_METHOD = 21
val PROPERTY_AUTH_DATA = 22
val PROPERTY_REQUEST_PROBLEM_INFO = 23
val PROPERTY_WILL_DELAY = 24
val PROPERTY_REQUEST_RESPONSE_INFO = 25
val PROPERTY_RESPONSE_INFO = 26
val PROPERTY_SERVER_REFERENCE = 28
val PROPERTY_REASON_STRING = 31
val PROPERTY_RECEIVE_MAXIMUM = 33
val PROPERTY_TOPIC_ALIAS_MAXIMUM = 34
val PROPERTY_TOPIC_ALIAS = 35
val PROPERTY_MAXIMUM_QOS = 36
val PROPERTY_RETAIN_AVAILABLE = 37
val PROPERTY_USER_PROPERTY = 38
val PROPERTY_MAXIMUM_PACKET_SIZE = 39
val PROPERTY_WILDCARD_SUB_AVAILABLE = 40
val PROPERTY_SUB_ID_AVAILABLE = 41
val PROPERTY_SHARED_SUB_AVAILABLE = 42

# Maximum lengths
val MAX_CLIENT_ID_LENGTH = 23
val MAX_TOPIC_LENGTH = 65535
val MAX_PAYLOAD_SIZE = 268435455

# ============================================================================
# Packet Structure Functions
# Packet: (type, flags, headers, payload)
# ============================================================================

fn mqtt_create_packet(packet_type, flags, headers, payload):
    """Create an MQTT packet tuple."""
    (packet_type, flags, headers, payload)

fn mqtt_packet_type(packet):
    """Get packet type from packet tuple."""
    val parts = packet
    parts[0]

fn mqtt_packet_flags(packet):
    """Get packet flags from packet tuple."""
    val parts = packet
    parts[1]

fn mqtt_packet_headers(packet):
    """Get packet headers from packet tuple."""
    val parts = packet
    parts[2]

fn mqtt_packet_payload(packet):
    """Get packet payload from packet tuple."""
    val parts = packet
    parts[3]

fn mqtt_set_packet_type(packet, packet_type):
    """Set packet type in packet tuple."""
    val parts = packet
    val flags = parts[1]
    val headers = parts[2]
    val payload = parts[3]
    (packet_type, flags, headers, payload)

fn mqtt_set_packet_flags(packet, flags):
    """Set packet flags in packet tuple."""
    val parts = packet
    val ptype = parts[0]
    val headers = parts[2]
    val payload = parts[3]
    (ptype, flags, headers, payload)

fn mqtt_set_packet_headers(packet, headers):
    """Set packet headers in packet tuple."""
    val parts = packet
    val ptype = parts[0]
    val flags = parts[1]
    val payload = parts[3]
    (ptype, flags, headers, payload)

fn mqtt_set_packet_payload(packet, payload):
    """Set packet payload in packet tuple."""
    val parts = packet
    val ptype = parts[0]
    val flags = parts[1]
    val headers = parts[2]
    (ptype, flags, headers, payload)

# ============================================================================
# Encoding/Decoding Utilities
# ============================================================================

fn mqtt_encode_remaining_length(length):
    """Encode remaining length using variable byte integer format."""
    var result = []
    var value = length

    var continue = true
    while continue:
        var encoded_byte = value % 128
        value = value / 128

        if value > 0:
            encoded_byte = encoded_byte | 128

        result = result + [encoded_byte]

        if value == 0:
            continue = false

    result

fn mqtt_decode_remaining_length(bytes):
    """Decode remaining length from variable byte integer format.
    Returns (length, bytes_consumed)."""
    var multiplier = 1
    var value = 0
    var index = 0

    var continue = true
    while continue:
        if index >= bytes.length():
            return nil

        val encoded_byte = bytes[index]
        value = value + (encoded_byte & 127) * multiplier

        if multiplier > 128 * 128 * 128:
            return nil

        multiplier = multiplier * 128
        index = index + 1

        if (encoded_byte & 128) == 0:
            continue = false

    (value, index)

fn mqtt_encode_string(text):
    """Encode UTF-8 string with 2-byte length prefix."""
    val length = text.length()
    val high_byte = length / 256
    val low_byte = length % 256

    var result = [high_byte, low_byte]

    var i = 0
    while i < length:
        val char_code = text[i].ord()
        result = result + [char_code]
        i = i + 1

    result

fn mqtt_decode_string(bytes, offset):
    """Decode UTF-8 string with 2-byte length prefix.
    Returns (string, bytes_consumed) or nil on error."""
    if offset + 2 > bytes.length():
        return nil

    val high_byte = bytes[offset]
    val low_byte = bytes[offset + 1]
    val length = high_byte * 256 + low_byte

    if offset + 2 + length > bytes.length():
        return nil

    var chars = []
    var i = 0
    while i < length:
        val byte_val = bytes[offset + 2 + i]
        chars = chars + [byte_val.chr()]
        i = i + 1

    val result = chars.join("")
    (result, 2 + length)

fn mqtt_encode_binary(data):
    """Encode binary data with 2-byte length prefix."""
    val length = data.length()
    val high_byte = length / 256
    val low_byte = length % 256

    [high_byte, low_byte] + data

fn mqtt_decode_binary(bytes, offset):
    """Decode binary data with 2-byte length prefix.
    Returns (data, bytes_consumed) or nil on error."""
    if offset + 2 > bytes.length():
        return nil

    val high_byte = bytes[offset]
    val low_byte = bytes[offset + 1]
    val length = high_byte * 256 + low_byte

    if offset + 2 + length > bytes.length():
        return nil

    var data = []
    var i = 0
    while i < length:
        data = data + [bytes[offset + 2 + i]]
        i = i + 1

    (data, 2 + length)

fn mqtt_encode_two_byte_int(value):
    """Encode 2-byte integer (MSB first)."""
    val high_byte = value / 256
    val low_byte = value % 256
    [high_byte, low_byte]

fn mqtt_decode_two_byte_int(bytes, offset):
    """Decode 2-byte integer (MSB first).
    Returns (value, bytes_consumed) or nil on error."""
    if offset + 2 > bytes.length():
        return nil

    val high_byte = bytes[offset]
    val low_byte = bytes[offset + 1]
    val value = high_byte * 256 + low_byte

    (value, 2)

fn mqtt_encode_four_byte_int(value):
    """Encode 4-byte integer (MSB first)."""
    val byte3 = value / (256 * 256 * 256)
    val remainder = value % (256 * 256 * 256)
    val byte2 = remainder / (256 * 256)
    val remainder2 = remainder % (256 * 256)
    val byte1 = remainder2 / 256
    val byte0 = remainder2 % 256

    [byte3, byte2, byte1, byte0]

fn mqtt_decode_four_byte_int(bytes, offset):
    """Decode 4-byte integer (MSB first).
    Returns (value, bytes_consumed) or nil on error."""
    if offset + 4 > bytes.length():
        return nil

    val byte3 = bytes[offset]
    val byte2 = bytes[offset + 1]
    val byte1 = bytes[offset + 2]
    val byte0 = bytes[offset + 3]

    val value = byte3 * 256 * 256 * 256 + byte2 * 256 * 256 + byte1 * 256 + byte0

    (value, 4)

fn mqtt_encode_variable_byte_int(value):
    """Encode variable byte integer (MQTT v5.0)."""
    mqtt_encode_remaining_length(value)

fn mqtt_decode_variable_byte_int(bytes, offset):
    """Decode variable byte integer (MQTT v5.0).
    Returns (value, bytes_consumed) or nil on error."""
    if offset >= bytes.length():
        return nil

    var slice = []
    var i = offset
    while i < bytes.length():
        slice = slice + [bytes[i]]
        i = i + 1

    val result = mqtt_decode_remaining_length(slice)
    if result == nil:
        return nil

    val parts = result
    val value = parts[0]
    val consumed = parts[1]
    (value, consumed)

# ============================================================================
# Fixed Header Functions
# ============================================================================

fn mqtt_create_fixed_header(packet_type, flags):
    """Create MQTT fixed header byte."""
    (packet_type * 16) | flags

fn mqtt_parse_fixed_header(byte):
    """Parse MQTT fixed header byte.
    Returns (packet_type, flags)."""
    val packet_type = byte / 16
    val flags = byte % 16
    (packet_type, flags)

fn mqtt_get_qos_from_flags(flags):
    """Extract QoS level from flags."""
    (flags / 2) % 4

fn mqtt_set_qos_in_flags(flags, qos):
    """Set QoS level in flags."""
    val masked = flags & 249
    masked | (qos * 2)

fn mqtt_has_dup_flag(flags):
    """Check if DUP flag is set."""
    (flags & 8) != 0

fn mqtt_set_dup_flag(flags, dup):
    """Set DUP flag in flags."""
    if dup:
        flags | 8
    else:
        flags & 247

fn mqtt_has_retain_flag(flags):
    """Check if RETAIN flag is set."""
    (flags & 1) != 0

fn mqtt_set_retain_flag(flags, retain):
    """Set RETAIN flag in flags."""
    if retain:
        flags | 1
    else:
        flags & 254

# ============================================================================
# CONNECT Packet Functions
# ============================================================================

fn mqtt_create_connect_packet(client_id, clean_session, keep_alive, protocol_version):
    """Create a CONNECT packet."""
    var flags = 0
    if clean_session:
        flags = flags | CONNECT_FLAG_CLEAN_SESSION

    val headers = (protocol_version, flags, keep_alive, client_id, nil, nil, nil, nil, nil, nil, nil)
    mqtt_create_packet(PACKET_TYPE_CONNECT, 0, headers, nil)

fn mqtt_connect_set_credentials(packet, username, password):
    """Set username and password in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val protocol_version = parts[0]
    val old_flags = parts[1]
    val keep_alive = parts[2]
    val client_id = parts[3]
    val will_topic = parts[4]
    val will_message = parts[5]
    val will_qos = parts[6]
    val will_retain = parts[7]
    val properties = parts[8]
    val will_properties = parts[9]
    val auth_method = parts[10]

    var flags = old_flags
    if username != nil:
        flags = flags | CONNECT_FLAG_USERNAME
    if password != nil:
        flags = flags | CONNECT_FLAG_PASSWORD

    val new_headers = (protocol_version, flags, keep_alive, client_id, will_topic, will_message, will_qos, will_retain, properties, will_properties, auth_method)
    mqtt_set_packet_headers(packet, new_headers)

fn mqtt_connect_set_will(packet, will_topic, will_message, will_qos, will_retain):
    """Set Last Will and Testament in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val protocol_version = parts[0]
    val old_flags = parts[1]
    val keep_alive = parts[2]
    val client_id = parts[3]
    val properties = parts[8]
    val will_properties = parts[9]
    val auth_method = parts[10]

    var flags = old_flags | CONNECT_FLAG_WILL_FLAG

    if will_qos == 1:
        flags = flags | CONNECT_FLAG_WILL_QOS_1
    else:
        if will_qos == 2:
            flags = flags | CONNECT_FLAG_WILL_QOS_2

    if will_retain:
        flags = flags | CONNECT_FLAG_WILL_RETAIN

    val new_headers = (protocol_version, flags, keep_alive, client_id, will_topic, will_message, will_qos, will_retain, properties, will_properties, auth_method)
    mqtt_set_packet_headers(packet, new_headers)

fn mqtt_connect_get_client_id(packet):
    """Get client ID from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[3]

fn mqtt_connect_get_keep_alive(packet):
    """Get keep alive interval from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[2]

fn mqtt_connect_get_protocol_version(packet):
    """Get protocol version from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_connect_has_clean_session(packet):
    """Check if clean session flag is set in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val flags = parts[1]
    (flags & CONNECT_FLAG_CLEAN_SESSION) != 0

fn mqtt_connect_has_will(packet):
    """Check if will flag is set in CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val flags = parts[1]
    (flags & CONNECT_FLAG_WILL_FLAG) != 0

fn mqtt_connect_get_will_qos(packet):
    """Get will QoS from CONNECT packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[6]

# ============================================================================
# CONNACK Packet Functions
# ============================================================================

fn mqtt_create_connack_packet(session_present, return_code):
    """Create a CONNACK packet."""
    val headers = (session_present, return_code, nil)
    mqtt_create_packet(PACKET_TYPE_CONNACK, 0, headers, nil)

fn mqtt_connack_get_return_code(packet):
    """Get return code from CONNACK packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[1]

fn mqtt_connack_has_session_present(packet):
    """Check if session present flag is set in CONNACK packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_connack_is_accepted(packet):
    """Check if connection was accepted."""
    val code = mqtt_connack_get_return_code(packet)
    code == CONNACK_ACCEPTED

# ============================================================================
# PUBLISH Packet Functions
# ============================================================================

fn mqtt_create_publish_packet(topic, payload, qos, retain):
    """Create a PUBLISH packet."""
    var flags = 0
    flags = mqtt_set_qos_in_flags(flags, qos)
    flags = mqtt_set_retain_flag(flags, retain)

    val headers = (topic, nil, nil)
    mqtt_create_packet(PACKET_TYPE_PUBLISH, flags, headers, payload)

fn mqtt_publish_set_packet_id(packet, packet_id):
    """Set packet ID in PUBLISH packet (for QoS > 0)."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    val topic = parts[0]
    val properties = parts[2]

    val new_headers = (topic, packet_id, properties)
    mqtt_set_packet_headers(packet, new_headers)

fn mqtt_publish_get_topic(packet):
    """Get topic from PUBLISH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_publish_get_packet_id(packet):
    """Get packet ID from PUBLISH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[1]

fn mqtt_publish_get_qos(packet):
    """Get QoS from PUBLISH packet."""
    val flags = mqtt_packet_flags(packet)
    mqtt_get_qos_from_flags(flags)

fn mqtt_publish_is_retained(packet):
    """Check if PUBLISH packet has retain flag set."""
    val flags = mqtt_packet_flags(packet)
    mqtt_has_retain_flag(flags)

fn mqtt_publish_is_duplicate(packet):
    """Check if PUBLISH packet has DUP flag set."""
    val flags = mqtt_packet_flags(packet)
    mqtt_has_dup_flag(flags)

fn mqtt_publish_set_duplicate(packet, dup):
    """Set DUP flag in PUBLISH packet."""
    val old_flags = mqtt_packet_flags(packet)
    val new_flags = mqtt_set_dup_flag(old_flags, dup)
    mqtt_set_packet_flags(packet, new_flags)

# ============================================================================
# PUBACK/PUBREC/PUBREL/PUBCOMP Packet Functions
# ============================================================================

fn mqtt_create_puback_packet(packet_id):
    """Create a PUBACK packet."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_PUBACK, 0, headers, nil)

fn mqtt_create_pubrec_packet(packet_id):
    """Create a PUBREC packet."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_PUBREC, 0, headers, nil)

fn mqtt_create_pubrel_packet(packet_id):
    """Create a PUBREL packet."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_PUBREL, 2, headers, nil)

fn mqtt_create_pubcomp_packet(packet_id):
    """Create a PUBCOMP packet."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_PUBCOMP, 0, headers, nil)

fn mqtt_pubx_get_packet_id(packet):
    """Get packet ID from PUBACK/PUBREC/PUBREL/PUBCOMP packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

# ============================================================================
# SUBSCRIBE Packet Functions
# ============================================================================

fn mqtt_create_subscribe_packet(packet_id, topic_filters):
    """Create a SUBSCRIBE packet.
    topic_filters: list of (topic, qos) tuples."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_SUBSCRIBE, 2, headers, topic_filters)

fn mqtt_subscribe_get_packet_id(packet):
    """Get packet ID from SUBSCRIBE packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_subscribe_get_topic_filters(packet):
    """Get topic filters from SUBSCRIBE packet."""
    mqtt_packet_payload(packet)

fn mqtt_subscribe_add_topic_filter(packet, topic, qos):
    """Add a topic filter to SUBSCRIBE packet."""
    val old_filters = mqtt_packet_payload(packet)
    val new_filter = (topic, qos)
    val new_filters = old_filters + [new_filter]
    mqtt_set_packet_payload(packet, new_filters)

# ============================================================================
# SUBACK Packet Functions
# ============================================================================

fn mqtt_create_suback_packet(packet_id, return_codes):
    """Create a SUBACK packet."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_SUBACK, 0, headers, return_codes)

fn mqtt_suback_get_packet_id(packet):
    """Get packet ID from SUBACK packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_suback_get_return_codes(packet):
    """Get return codes from SUBACK packet."""
    mqtt_packet_payload(packet)

# ============================================================================
# UNSUBSCRIBE Packet Functions
# ============================================================================

fn mqtt_create_unsubscribe_packet(packet_id, topics):
    """Create an UNSUBSCRIBE packet."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_UNSUBSCRIBE, 2, headers, topics)

fn mqtt_unsubscribe_get_packet_id(packet):
    """Get packet ID from UNSUBSCRIBE packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_unsubscribe_get_topics(packet):
    """Get topics from UNSUBSCRIBE packet."""
    mqtt_packet_payload(packet)

# ============================================================================
# UNSUBACK Packet Functions
# ============================================================================

fn mqtt_create_unsuback_packet(packet_id):
    """Create an UNSUBACK packet."""
    val headers = (packet_id, nil)
    mqtt_create_packet(PACKET_TYPE_UNSUBACK, 0, headers, nil)

fn mqtt_unsuback_get_packet_id(packet):
    """Get packet ID from UNSUBACK packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

# ============================================================================
# PINGREQ/PINGRESP Packet Functions
# ============================================================================

fn mqtt_create_pingreq_packet():
    """Create a PINGREQ packet."""
    mqtt_create_packet(PACKET_TYPE_PINGREQ, 0, nil, nil)

fn mqtt_create_pingresp_packet():
    """Create a PINGRESP packet."""
    mqtt_create_packet(PACKET_TYPE_PINGRESP, 0, nil, nil)

# ============================================================================
# DISCONNECT Packet Functions
# ============================================================================

fn mqtt_create_disconnect_packet():
    """Create a DISCONNECT packet (v3.1.1)."""
    mqtt_create_packet(PACKET_TYPE_DISCONNECT, 0, nil, nil)

fn mqtt_create_disconnect_packet_v5(reason_code):
    """Create a DISCONNECT packet (v5.0) with reason code."""
    val headers = (reason_code, nil)
    mqtt_create_packet(PACKET_TYPE_DISCONNECT, 0, headers, nil)

fn mqtt_disconnect_get_reason_code(packet):
    """Get reason code from DISCONNECT packet (v5.0)."""
    val headers = mqtt_packet_headers(packet)
    if headers == nil:
        return REASON_NORMAL_DISCONNECTION

    val parts = headers
    parts[0]

# ============================================================================
# AUTH Packet Functions (MQTT v5.0)
# ============================================================================

fn mqtt_create_auth_packet(reason_code, auth_method, auth_data):
    """Create an AUTH packet (v5.0)."""
    val headers = (reason_code, auth_method, auth_data, nil)
    mqtt_create_packet(PACKET_TYPE_AUTH, 0, headers, nil)

fn mqtt_auth_get_reason_code(packet):
    """Get reason code from AUTH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_auth_get_method(packet):
    """Get authentication method from AUTH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[1]

fn mqtt_auth_get_data(packet):
    """Get authentication data from AUTH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[2]

# ============================================================================
# Topic Matching and Validation Functions
# ============================================================================

fn mqtt_topic_is_valid(topic):
    """Check if topic is valid according to MQTT rules."""
    if topic == nil:
        return false

    val length = topic.length()
    if length == 0 or length > MAX_TOPIC_LENGTH:
        return false

    # Check for null characters
    var i = 0
    while i < length:
        val char = topic[i]
        if char == "\0":
            return false
        i = i + 1

    true

fn mqtt_topic_filter_is_valid(filter):
    """Check if topic filter is valid (can contain wildcards)."""
    if not mqtt_topic_is_valid(filter):
        return false

    val length = filter.length()
    var i = 0

    while i < length:
        val char = filter[i]

        # Check multi-level wildcard
        if char == "#":
            # Must be at end and preceded by / or be the only character
            var is_at_end = i == length - 1
            if not is_at_end:
                return false

            if i > 0:
                val prev = filter[i - 1]
                if prev != "/":
                    return false

        # Check single-level wildcard
        if char == "+":
            # Must be at start or preceded by /
            if i > 0:
                val prev = filter[i - 1]
                if prev != "/":
                    return false

            # Must be at end or followed by /
            if i < length - 1:
                val next = filter[i + 1]
                if next != "/":
                    return false

        i = i + 1

    true

fn mqtt_topic_matches_filter(topic, filter):
    """Check if a topic matches a topic filter (with wildcards)."""
    if not mqtt_topic_is_valid(topic):
        return false

    if not mqtt_topic_filter_is_valid(filter):
        return false

    # Split into levels
    val topic_levels = topic.split("/")
    val filter_levels = filter.split("/")

    var topic_idx = 0
    var filter_idx = 0

    while filter_idx < filter_levels.length():
        val filter_level = filter_levels[filter_idx]

        # Multi-level wildcard matches rest of topic
        if filter_level == "#":
            return true

        # Need more topic levels
        if topic_idx >= topic_levels.length():
            return false

        val topic_level = topic_levels[topic_idx]

        # Single-level wildcard or exact match
        var matches = filter_level == "+" or filter_level == topic_level
        if not matches:
            return false

        topic_idx = topic_idx + 1
        filter_idx = filter_idx + 1

    # All filter levels matched, check if all topic levels consumed
    topic_idx == topic_levels.length()

fn mqtt_topic_has_wildcard(filter):
    """Check if topic filter contains wildcards."""
    val has_plus = filter.contains("+")
    val has_hash = filter.contains("#")
    has_plus or has_hash

fn mqtt_topic_split_levels(topic):
    """Split topic into levels."""
    topic.split("/")

fn mqtt_topic_join_levels(levels):
    """Join topic levels into a topic string."""
    levels.join("/")

fn mqtt_topic_get_level(topic, level):
    """Get a specific level from a topic (0-indexed)."""
    val levels = mqtt_topic_split_levels(topic)
    if level < 0 or level >= levels.length():
        return nil
    levels[level]

fn mqtt_topic_level_count(topic):
    """Count the number of levels in a topic."""
    val levels = mqtt_topic_split_levels(topic)
    levels.length()

# ============================================================================
# QoS and Session Functions
# ============================================================================

fn mqtt_qos_is_valid(qos):
    """Check if QoS level is valid."""
    qos == 0 or qos == 1 or qos == 2

fn mqtt_qos_to_string(qos):
    """Convert QoS level to string."""
    if qos == QOS_AT_MOST_ONCE:
        return "at most once"

    if qos == QOS_AT_LEAST_ONCE:
        return "at least once"

    if qos == QOS_EXACTLY_ONCE:
        return "exactly once"

    "invalid"

fn mqtt_packet_type_to_string(packet_type):
    """Convert packet type to string."""
    if packet_type == PACKET_TYPE_CONNECT:
        return "CONNECT"
    if packet_type == PACKET_TYPE_CONNACK:
        return "CONNACK"
    if packet_type == PACKET_TYPE_PUBLISH:
        return "PUBLISH"
    if packet_type == PACKET_TYPE_PUBACK:
        return "PUBACK"
    if packet_type == PACKET_TYPE_PUBREC:
        return "PUBREC"
    if packet_type == PACKET_TYPE_PUBREL:
        return "PUBREL"
    if packet_type == PACKET_TYPE_PUBCOMP:
        return "PUBCOMP"
    if packet_type == PACKET_TYPE_SUBSCRIBE:
        return "SUBSCRIBE"
    if packet_type == PACKET_TYPE_SUBACK:
        return "SUBACK"
    if packet_type == PACKET_TYPE_UNSUBSCRIBE:
        return "UNSUBSCRIBE"
    if packet_type == PACKET_TYPE_UNSUBACK:
        return "UNSUBACK"
    if packet_type == PACKET_TYPE_PINGREQ:
        return "PINGREQ"
    if packet_type == PACKET_TYPE_PINGRESP:
        return "PINGRESP"
    if packet_type == PACKET_TYPE_DISCONNECT:
        return "DISCONNECT"
    if packet_type == PACKET_TYPE_AUTH:
        return "AUTH"

    "UNKNOWN"

fn mqtt_reason_code_to_string(reason_code):
    """Convert reason code (v5.0) to string."""
    if reason_code == REASON_SUCCESS:
        return "Success"
    if reason_code == REASON_GRANTED_QOS_1:
        return "Granted QoS 1"
    if reason_code == REASON_GRANTED_QOS_2:
        return "Granted QoS 2"
    if reason_code == REASON_DISCONNECT_WILL:
        return "Disconnect with Will"
    if reason_code == REASON_NO_MATCHING_SUBSCRIBERS:
        return "No matching subscribers"
    if reason_code == REASON_UNSPECIFIED_ERROR:
        return "Unspecified error"
    if reason_code == REASON_MALFORMED_PACKET:
        return "Malformed packet"
    if reason_code == REASON_PROTOCOL_ERROR:
        return "Protocol error"
    if reason_code == REASON_IMPLEMENTATION_ERROR:
        return "Implementation error"
    if reason_code == REASON_UNSUPPORTED_PROTOCOL:
        return "Unsupported protocol"
    if reason_code == REASON_CLIENT_IDENTIFIER_NOT_VALID:
        return "Client identifier not valid"
    if reason_code == REASON_BAD_CREDENTIALS:
        return "Bad credentials"
    if reason_code == REASON_NOT_AUTHORIZED:
        return "Not authorized"
    if reason_code == REASON_SERVER_UNAVAILABLE:
        return "Server unavailable"
    if reason_code == REASON_SERVER_BUSY:
        return "Server busy"
    if reason_code == REASON_BANNED:
        return "Banned"
    if reason_code == REASON_BAD_AUTHENTICATION:
        return "Bad authentication"
    if reason_code == REASON_TOPIC_NAME_INVALID:
        return "Topic name invalid"
    if reason_code == REASON_PACKET_TOO_LARGE:
        return "Packet too large"
    if reason_code == REASON_QUOTA_EXCEEDED:
        return "Quota exceeded"
    if reason_code == REASON_PAYLOAD_FORMAT_INVALID:
        return "Payload format invalid"
    if reason_code == REASON_RETAIN_NOT_SUPPORTED:
        return "Retain not supported"
    if reason_code == REASON_QOS_NOT_SUPPORTED:
        return "QoS not supported"
    if reason_code == REASON_USE_ANOTHER_SERVER:
        return "Use another server"
    if reason_code == REASON_SERVER_MOVED:
        return "Server moved"
    if reason_code == REASON_CONNECTION_RATE_EXCEEDED:
        return "Connection rate exceeded"

    "Unknown reason"

# ============================================================================
# Validation Functions
# ============================================================================

fn mqtt_validate_client_id(client_id):
    """Validate client ID according to MQTT rules."""
    if client_id == nil:
        return false

    val length = client_id.length()
    if length > MAX_CLIENT_ID_LENGTH:
        return false

    # Empty client ID is valid for clean session
    if length == 0:
        return true

    # Check for valid characters (alphanumeric and some special chars)
    var i = 0
    while i < length:
        val char = client_id[i]
        val code = char.ord()

        # Allow a-z, A-Z, 0-9, and some special characters
        var is_letter = (code >= 65 and code <= 90) or (code >= 97 and code <= 122)
        var is_digit = code >= 48 and code <= 57
        var is_special = char == "_" or char == "-"

        var is_valid = is_letter or is_digit or is_special
        if not is_valid:
            return false

        i = i + 1

    true

fn mqtt_validate_packet_id(packet_id):
    """Validate packet ID (must be non-zero)."""
    packet_id != nil and packet_id > 0 and packet_id < 65536

fn mqtt_validate_keep_alive(keep_alive):
    """Validate keep alive interval."""
    keep_alive >= 0 and keep_alive < 65536

fn mqtt_validate_payload_size(payload):
    """Validate payload size."""
    if payload == nil:
        return true

    val length = payload.length()
    length <= MAX_PAYLOAD_SIZE

# ============================================================================
# Utility Functions
# ============================================================================

fn mqtt_generate_client_id(prefix):
    """Generate a random client ID with given prefix."""
    val timestamp = 1234567890
    val random = timestamp % 100000
    prefix + "_" + random.to_string()

fn mqtt_calculate_message_size(topic, payload):
    """Calculate the size of a PUBLISH message."""
    var size = 0

    # Fixed header (minimum)
    size = size + 1

    # Topic length (2 bytes) + topic
    size = size + 2 + topic.length()

    # Packet ID (if QoS > 0)
    size = size + 2

    # Payload
    if payload != nil:
        size = size + payload.length()

    size

fn mqtt_is_system_topic(topic):
    """Check if topic is a system topic ($-prefixed)."""
    if topic == nil or topic.length() == 0:
        return false

    topic[0] == "$"

fn mqtt_is_shared_subscription(filter):
    """Check if topic filter is a shared subscription (MQTT v5.0)."""
    if filter == nil:
        return false

    filter.starts_with("$share/")

fn mqtt_get_shared_subscription_group(filter):
    """Get shared subscription group name from filter."""
    if not mqtt_is_shared_subscription(filter):
        return nil

    val without_prefix = filter[7:]
    val parts = without_prefix.split("/")
    if parts.length() == 0:
        return nil

    parts[0]

fn mqtt_get_shared_subscription_filter(filter):
    """Get actual topic filter from shared subscription filter."""
    if not mqtt_is_shared_subscription(filter):
        return filter

    val without_prefix = filter[7:]
    val parts = without_prefix.split("/")
    if parts.length() <= 1:
        return ""

    var result_parts = []
    var i = 1
    while i < parts.length():
        result_parts = result_parts + [parts[i]]
        i = i + 1

    result_parts.join("/")

fn mqtt_extract_shared_filter_parts(filter):
    """Extract (group, actual_filter) from shared subscription filter.
    Returns nil if not a shared subscription."""
    if not mqtt_is_shared_subscription(filter):
        return nil

    val group = mqtt_get_shared_subscription_group(filter)
    val actual = mqtt_get_shared_subscription_filter(filter)
    (group, actual)

fn mqtt_create_shared_subscription_filter(group, filter):
    """Create a shared subscription filter from group and topic filter."""
    "$share/" + group + "/" + filter

fn mqtt_packet_requires_packet_id(packet_type):
    """Check if packet type requires a packet ID."""
    var needs_id = packet_type == PACKET_TYPE_PUBLISH
    needs_id = needs_id or packet_type == PACKET_TYPE_PUBACK
    needs_id = needs_id or packet_type == PACKET_TYPE_PUBREC
    needs_id = needs_id or packet_type == PACKET_TYPE_PUBREL
    needs_id = needs_id or packet_type == PACKET_TYPE_PUBCOMP
    needs_id = needs_id or packet_type == PACKET_TYPE_SUBSCRIBE
    needs_id = needs_id or packet_type == PACKET_TYPE_SUBACK
    needs_id = needs_id or packet_type == PACKET_TYPE_UNSUBSCRIBE
    needs_id = needs_id or packet_type == PACKET_TYPE_UNSUBACK
    needs_id

fn mqtt_packet_has_payload(packet_type):
    """Check if packet type typically has a payload."""
    var has_payload = packet_type == PACKET_TYPE_CONNECT
    has_payload = has_payload or packet_type == PACKET_TYPE_PUBLISH
    has_payload = has_payload or packet_type == PACKET_TYPE_SUBSCRIBE
    has_payload = has_payload or packet_type == PACKET_TYPE_SUBACK
    has_payload = has_payload or packet_type == PACKET_TYPE_UNSUBSCRIBE
    has_payload

fn mqtt_version_to_string(version):
    """Convert MQTT protocol version to string."""
    if version == MQTT_VERSION_3_1_1:
        return "MQTT 3.1.1"

    if version == MQTT_VERSION_5_0:
        return "MQTT 5.0"

    "Unknown version"

fn mqtt_is_valid_version(version):
    """Check if MQTT version is supported."""
    version == MQTT_VERSION_3_1_1 or version == MQTT_VERSION_5_0

fn mqtt_get_default_flags_for_packet_type(packet_type):
    """Get default flags for a given packet type."""
    if packet_type == PACKET_TYPE_PUBREL:
        return 2

    if packet_type == PACKET_TYPE_SUBSCRIBE:
        return 2

    if packet_type == PACKET_TYPE_UNSUBSCRIBE:
        return 2

    0

fn mqtt_validate_flags_for_packet_type(packet_type, flags):
    """Validate flags for a given packet type."""
    val expected = mqtt_get_default_flags_for_packet_type(packet_type)

    # PUBLISH can have various flags
    if packet_type == PACKET_TYPE_PUBLISH:
        return true

    # Other packets must match expected flags
    flags == expected

fn mqtt_create_property_list():
    """Create an empty MQTT v5.0 property list."""
    []

fn mqtt_add_property(properties, property_id, value):
    """Add a property to MQTT v5.0 property list."""
    val prop = (property_id, value)
    properties + [prop]

fn mqtt_get_property(properties, property_id):
    """Get a property value from MQTT v5.0 property list.
    Returns nil if not found."""
    if properties == nil:
        return nil

    var i = 0
    while i < properties.length():
        val prop = properties[i]
        val parts = prop
        val pid = parts[0]
        val value = parts[1]

        if pid == property_id:
            return value

        i = i + 1

    nil

fn mqtt_has_property(properties, property_id):
    """Check if property exists in MQTT v5.0 property list."""
    val value = mqtt_get_property(properties, property_id)
    value != nil

fn mqtt_remove_property(properties, property_id):
    """Remove a property from MQTT v5.0 property list."""
    if properties == nil:
        return []

    var result = []
    var i = 0
    while i < properties.length():
        val prop = properties[i]
        val parts = prop
        val pid = parts[0]
        val value = parts[1]

        if pid != property_id:
            result = result + [prop]

        i = i + 1

    result

fn mqtt_property_id_to_string(property_id):
    """Convert property ID to string."""
    if property_id == PROPERTY_PAYLOAD_FORMAT:
        return "Payload Format Indicator"
    if property_id == PROPERTY_MESSAGE_EXPIRY:
        return "Message Expiry Interval"
    if property_id == PROPERTY_CONTENT_TYPE:
        return "Content Type"
    if property_id == PROPERTY_RESPONSE_TOPIC:
        return "Response Topic"
    if property_id == PROPERTY_CORRELATION_DATA:
        return "Correlation Data"
    if property_id == PROPERTY_SUBSCRIPTION_ID:
        return "Subscription Identifier"
    if property_id == PROPERTY_SESSION_EXPIRY:
        return "Session Expiry Interval"
    if property_id == PROPERTY_ASSIGNED_CLIENT_ID:
        return "Assigned Client Identifier"
    if property_id == PROPERTY_SERVER_KEEP_ALIVE:
        return "Server Keep Alive"
    if property_id == PROPERTY_AUTH_METHOD:
        return "Authentication Method"
    if property_id == PROPERTY_AUTH_DATA:
        return "Authentication Data"
    if property_id == PROPERTY_REQUEST_PROBLEM_INFO:
        return "Request Problem Information"
    if property_id == PROPERTY_WILL_DELAY:
        return "Will Delay Interval"
    if property_id == PROPERTY_REQUEST_RESPONSE_INFO:
        return "Request Response Information"
    if property_id == PROPERTY_RESPONSE_INFO:
        return "Response Information"
    if property_id == PROPERTY_SERVER_REFERENCE:
        return "Server Reference"
    if property_id == PROPERTY_REASON_STRING:
        return "Reason String"
    if property_id == PROPERTY_RECEIVE_MAXIMUM:
        return "Receive Maximum"
    if property_id == PROPERTY_TOPIC_ALIAS_MAXIMUM:
        return "Topic Alias Maximum"
    if property_id == PROPERTY_TOPIC_ALIAS:
        return "Topic Alias"
    if property_id == PROPERTY_MAXIMUM_QOS:
        return "Maximum QoS"
    if property_id == PROPERTY_RETAIN_AVAILABLE:
        return "Retain Available"
    if property_id == PROPERTY_USER_PROPERTY:
        return "User Property"
    if property_id == PROPERTY_MAXIMUM_PACKET_SIZE:
        return "Maximum Packet Size"
    if property_id == PROPERTY_WILDCARD_SUB_AVAILABLE:
        return "Wildcard Subscription Available"
    if property_id == PROPERTY_SUB_ID_AVAILABLE:
        return "Subscription Identifier Available"
    if property_id == PROPERTY_SHARED_SUB_AVAILABLE:
        return "Shared Subscription Available"

    "Unknown Property"

fn mqtt_connack_return_code_to_string(return_code):
    """Convert CONNACK return code (v3.1.1) to string."""
    if return_code == CONNACK_ACCEPTED:
        return "Connection Accepted"
    if return_code == CONNACK_REFUSED_PROTOCOL:
        return "Connection Refused: unacceptable protocol version"
    if return_code == CONNACK_REFUSED_IDENTIFIER:
        return "Connection Refused: identifier rejected"
    if return_code == CONNACK_REFUSED_SERVER_UNAVAILABLE:
        return "Connection Refused: server unavailable"
    if return_code == CONNACK_REFUSED_BAD_CREDENTIALS:
        return "Connection Refused: bad user name or password"
    if return_code == CONNACK_REFUSED_NOT_AUTHORIZED:
        return "Connection Refused: not authorized"

    "Unknown return code"

fn mqtt_max_packet_size():
    """Get maximum packet size."""
    MAX_PAYLOAD_SIZE

fn mqtt_max_topic_length():
    """Get maximum topic length."""
    MAX_TOPIC_LENGTH

fn mqtt_max_client_id_length():
    """Get maximum client ID length."""
    MAX_CLIENT_ID_LENGTH

# ============================================================================
# Module Exports
# ============================================================================

# This module provides comprehensive MQTT protocol utilities
# Supporting both MQTT v3.1.1 and v5.0
# Total functions: 120+
