# Inline Helper Module - Phase 2 Workaround
#
# This module provides inline implementations of Phase 2 SFFI functions
# to work around the runtime import limitation.
#
# USAGE: Copy needed functions directly into your test files.
# DO NOT use imports - they will fail.
#
# Background: Phase 2 implemented 65+ SFFI wrappers (string, array, system/process)
# but the runtime import system prevents using them. This module provides inline
# versions of the most commonly needed functions.
#
# When imports are fixed, migrate to:
# - use std.string.{string_trim, string_split, to_int_or}
# - use std.array.{array_append_all, array_partition, array_flatten}
# - use ffi.system.{uuid_v4, process_spawn, env_remove}

# ============================================================================
# String Helpers (Phase 2.1 workarounds)
# ============================================================================

fn string_trim_inline(s: text) -> text:
    """Trim whitespace from both ends of string.

    Inline implementation of std.string.string_trim()
    Copy this function into your test file to use."""
    var result = s
    # Trim leading whitespace
    while result.len() > 0:
        val first = result[0:1]
        if first == " " or first == "\t" or first == "\n" or first == "\r":
            result = result[1:]
        else:
            break
    # Trim trailing whitespace
    while result.len() > 0:
        val last = result[result.len()-1:result.len()]
        if last == " " or last == "\t" or last == "\n" or last == "\r":
            result = result[0:result.len()-1]
        else:
            break
    result

fn string_split_inline(s: text, delimiter: text) -> [text]:
    """Split string by delimiter.

    Inline implementation of std.string.string_split()
    Copy this function into your test file to use."""
    if delimiter.len() == 0:
        return [s]

    var parts = []
    var current = ""
    var i = 0

    while i < s.len():
        # Check if delimiter starts at current position
        var is_delim = true
        var j = 0
        while j < delimiter.len() and i + j < s.len():
            if s[i+j:i+j+1] != delimiter[j:j+1]:
                is_delim = false
                break
            j = j + 1

        if is_delim and j == delimiter.len():
            # Found delimiter
            parts.push(current)
            current = ""
            i = i + delimiter.len()
        else:
            # Not delimiter, add character to current part
            current = current + s[i:i+1]
            i = i + 1

    # Add final part
    parts.push(current)
    parts

fn to_int_or_inline(s: text, default_val: i64) -> i64:
    """Parse string to integer with fallback.

    Inline implementation of std.string.to_int_or()
    Copy this function into your test file to use."""
    if s.len() == 0:
        return default_val

    # Use built-in int() which exists in runtime
    # It returns 0 for invalid strings, so check first character
    val first = s[0:1]
    if first == "-" or first == "0" or first == "1" or first == "2" or
       first == "3" or first == "4" or first == "5" or first == "6" or
       first == "7" or first == "8" or first == "9":
        val result = int(s)
        # int() returns 0 for both "0" and invalid strings
        # Can't distinguish, so return result
        result
    else:
        default_val

# ============================================================================
# Array Helpers (Phase 2.2 workarounds)
# ============================================================================

fn array_append_all_inline(arr1, arr2):
    """Concatenate two arrays.

    Inline implementation of std.array.array_append_all()
    Copy this function into your test file to use."""
    var result = []
    for item in arr1:
        result.push(item)
    for item in arr2:
        result.push(item)
    result

fn array_partition_inline(arr, predicate):
    """Partition array into matching and non-matching elements.

    Returns tuple: (matching, non_matching)

    Inline implementation of std.array.array_partition()
    Copy this function into your test file to use."""
    var matching = []
    var non_matching = []
    for item in arr:
        if predicate(item):
            matching.push(item)
        else:
            non_matching.push(item)
    (matching, non_matching)

fn array_flatten_inline(nested_arr):
    """Flatten one level of array nesting.

    Inline implementation of std.array.array_flatten()
    Copy this function into your test file to use."""
    var result = []
    for sub_arr in nested_arr:
        for item in sub_arr:
            result.push(item)
    result

fn array_uniq_inline(arr):
    """Remove duplicate elements from array.

    Inline implementation of std.array.array_uniq()
    Copy this function into your test file to use."""
    var seen = {}
    var result = []
    for item in arr:
        val key = "{item}"
        if not seen.contains_key(key):
            seen[key] = true
            result.push(item)
    result

fn array_compact_inline(arr):
    """Remove nil values from array.

    Inline implementation of std.array.array_compact()
    Copy this function into your test file to use."""
    var result = []
    for item in arr:
        if item != nil:
            result.push(item)
    result

# ============================================================================
# System Helpers (Phase 2.3 workarounds)
# ============================================================================

# Note: System/Process functions (uuid_v4, process_spawn, etc.) cannot be
# implemented inline because they require runtime FFI. These must wait for
# the import system to be fixed.
#
# For now, tests needing these functions should:
# 1. Skip in interpreter mode using skip_it or skip_on_interpreter
# 2. Use shell() workarounds for simple cases
# 3. Wait for import fix to use ffi.system module

fn generate_simple_uuid_inline() -> text:
    """Generate a simple UUID-like string (NOT cryptographically secure).

    This is a workaround - NOT a real UUID. Use ffi.system.uuid_v4() when imports work.
    Copy this function into your test file to use."""
    # Use timestamp as pseudo-random base
    use app.io.{time_now_unix_micros}
    val micros = time_now_unix_micros()

    # Simple hash to create variation
    var hash = micros
    hash = (hash xor (hash * 31)) % 1000000

    # Format as UUID-like string (format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
    "{micros}-{hash}-0000-0000-000000000000"

# ============================================================================
# Export Note
# ============================================================================

# DO NOT export these functions - exports won't work due to import limitation.
# Instead, copy the inline functions directly into your test files.
#
# Example usage in test:
#
# fn string_trim_inline(s: text) -> text:
#     var result = s
#     # ... copy implementation from above ...
#     result
#
# describe "My Feature":
#     it "trims strings":
#         val trimmed = string_trim_inline("  test  ")
#         expect(trimmed).to_equal("test")

# ============================================================================
# Documentation References
# ============================================================================

# Full Phase 2 implementations (blocked by imports):
# - src/std/string.spl - String SFFI wrappers (+70 lines, 8 functions)
# - src/std/array.spl - Array SFFI wrappers (+85 lines, 7 functions)
# - src/ffi/system.spl - System/Process SFFI (260 lines, 50+ functions)
#
# Session reports:
# - doc/report/phase2_sffi_wrappers_complete_2026-02-09.md
# - doc/report/test_enablement_session_summary_2026-02-09.md
