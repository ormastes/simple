# Date and Calendar Utilities
#
# Pure Simple implementation of date handling and calendar calculations.
# No system dependencies - all calendar math is computed.
#
# Date representation: (year, month, day) tuples as i64 values
# - year: any integer (supports historical and future dates)
# - month: 1-12 (January=1, December=12)
# - day: 1-31 (depending on month/year)
#
# Calendar system: Proleptic Gregorian calendar
# Epoch: January 1, 0001 (day 1)
# Day of week: Monday=1, Sunday=7 (ISO 8601)
#
# Examples:
#   val date = from_ymd(2025, 1, 15)
#   val next = add_days(date, 10)
#   val diff = difference_in_days(date, next)
#   val iso = to_iso8601(date)
#   val parsed = parse_iso8601("2025-01-15")

# ============================================================================
# Constants
# ============================================================================

# Days of the week (ISO 8601: Monday=1, Sunday=7)
val MONDAY = 1
val TUESDAY = 2
val WEDNESDAY = 3
val THURSDAY = 4
val FRIDAY = 5
val SATURDAY = 6
val SUNDAY = 7

# Month constants
val JANUARY = 1
val FEBRUARY = 2
val MARCH = 3
val APRIL = 4
val MAY = 5
val JUNE = 6
val JULY = 7
val AUGUST = 8
val SEPTEMBER = 9
val OCTOBER = 10
val NOVEMBER = 11
val DECEMBER = 12

# Day names for display
fn day_name(day: i64) -> text:
    if day == 1:
        return "Monday"
    if day == 2:
        return "Tuesday"
    if day == 3:
        return "Wednesday"
    if day == 4:
        return "Thursday"
    if day == 5:
        return "Friday"
    if day == 6:
        return "Saturday"
    if day == 7:
        return "Sunday"
    return "Invalid"

# Month names for display
fn month_name(month: i64) -> text:
    if month == 1:
        return "January"
    if month == 2:
        return "February"
    if month == 3:
        return "March"
    if month == 4:
        return "April"
    if month == 5:
        return "May"
    if month == 6:
        return "June"
    if month == 7:
        return "July"
    if month == 8:
        return "August"
    if month == 9:
        return "September"
    if month == 10:
        return "October"
    if month == 11:
        return "November"
    if month == 12:
        return "December"
    return "Invalid"

# Short month names (3 letters)
fn month_abbrev(month: i64) -> text:
    if month == 1:
        return "Jan"
    if month == 2:
        return "Feb"
    if month == 3:
        return "Mar"
    if month == 4:
        return "Apr"
    if month == 5:
        return "May"
    if month == 6:
        return "Jun"
    if month == 7:
        return "Jul"
    if month == 8:
        return "Aug"
    if month == 9:
        return "Sep"
    if month == 10:
        return "Oct"
    if month == 11:
        return "Nov"
    if month == 12:
        return "Dec"
    return "Inv"

# ============================================================================
# Core Date Creation
# ============================================================================

# Create a date from year, month, day components
# Returns a tuple (year, month, day) or nil if invalid
fn from_ymd(year: i64, month: i64, day: i64) -> any:
    if is_valid_date(year, month, day):
        return (year, month, day)
    return nil

# Get the epoch date (January 1, 0001)
fn epoch() -> any:
    return (1, 1, 1)

# Mock today function for testing (returns a fixed date)
fn today_mock() -> any:
    return (2025, 1, 15)

# Create a date from days since epoch
fn from_days(days: i64) -> any:
    if days < 1:
        return nil

    # Start from epoch
    var year = 1
    var month = 1
    var day = days

    # Advance through years
    var done = false
    while not done:
        var year_days = 365
        if is_leap_year(year):
            year_days = 366

        if day > year_days:
            day = day - year_days
            year = year + 1
        else:
            done = true

    # Advance through months
    done = false
    while not done:
        var month_days = days_in_month(year, month)

        if day > month_days:
            day = day - month_days
            month = month + 1
        else:
            done = true

    return (year, month, day)

# ============================================================================
# Date Validation
# ============================================================================

# Check if a year is a leap year
# Leap year: divisible by 4, except century years (divisible by 100)
#            unless also divisible by 400
fn is_leap_year(year: i64) -> bool:
    if year % 400 == 0:
        return true
    if year % 100 == 0:
        return false
    if year % 4 == 0:
        return true
    return false

# Get the number of days in a month
fn days_in_month(year: i64, month: i64) -> i64:
    if month == 1:
        return 31
    if month == 2:
        if is_leap_year(year):
            return 29
        return 28
    if month == 3:
        return 31
    if month == 4:
        return 30
    if month == 5:
        return 31
    if month == 6:
        return 30
    if month == 7:
        return 31
    if month == 8:
        return 31
    if month == 9:
        return 30
    if month == 10:
        return 31
    if month == 11:
        return 30
    if month == 12:
        return 31
    return 0

# Check if a date is valid
fn is_valid_date(year: i64, month: i64, day: i64) -> bool:
    if month < 1:
        return false
    if month > 12:
        return false
    if day < 1:
        return false

    var max_days = days_in_month(year, month)
    if day > max_days:
        return false

    return true

# ============================================================================
# Date Conversion to Days
# ============================================================================

# Convert a date to days since epoch (January 1, 0001 = day 1)
fn to_days(date: any) -> i64:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    var days = day

    # Add days for complete years
    var y = 1
    while y < year:
        if is_leap_year(y):
            days = days + 366
        else:
            days = days + 365
        y = y + 1

    # Add days for complete months in current year
    var m = 1
    while m < month:
        days = days + days_in_month(year, m)
        m = m + 1

    return days

# ============================================================================
# Date Arithmetic
# ============================================================================

# Add days to a date
fn add_days(date: any, days: i64) -> any:
    var current_days = to_days(date)
    var new_days = current_days + days

    if new_days < 1:
        return nil

    return from_days(new_days)

# Subtract days from a date
fn subtract_days(date: any, days: i64) -> any:
    return add_days(date, 0 - days)

# Calculate difference in days between two dates (date1 - date2)
fn difference_in_days(date1: any, date2: any) -> i64:
    var days1 = to_days(date1)
    var days2 = to_days(date2)
    return days1 - days2

# Add months to a date (handles month overflow correctly)
fn add_months(date: any, months: i64) -> any:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    # Calculate new month and year
    var total_months = month + months

    # Handle negative months
    while total_months < 1:
        total_months = total_months + 12
        year = year - 1

    # Handle overflow
    while total_months > 12:
        total_months = total_months - 12
        year = year + 1

    # Adjust day if it exceeds the new month's days
    var new_month = total_months
    var max_day = days_in_month(year, new_month)
    var new_day = day
    if new_day > max_day:
        new_day = max_day

    return (year, new_month, new_day)

# Subtract months from a date
fn subtract_months(date: any, months: i64) -> any:
    return add_months(date, 0 - months)

# Add years to a date
fn add_years(date: any, years: i64) -> any:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    var new_year = year + years

    # Handle Feb 29 on non-leap years
    if month == 2:
        if day == 29:
            if not is_leap_year(new_year):
                day = 28

    return (new_year, month, day)

# Subtract years from a date
fn subtract_years(date: any, years: i64) -> any:
    return add_years(date, 0 - years)

# ============================================================================
# Date Comparison
# ============================================================================

# Check if two dates are equal
fn equal(date1: any, date2: any) -> bool:
    var y1 = date1[0]
    var m1 = date1[1]
    var d1 = date1[2]
    var y2 = date2[0]
    var m2 = date2[1]
    var d2 = date2[2]

    if y1 != y2:
        return false
    if m1 != m2:
        return false
    if d1 != d2:
        return false
    return true

# Check if date1 is before date2
fn before(date1: any, date2: any) -> bool:
    var days1 = to_days(date1)
    var days2 = to_days(date2)
    return days1 < days2

# Check if date1 is after date2
fn after(date1: any, date2: any) -> bool:
    var days1 = to_days(date1)
    var days2 = to_days(date2)
    return days1 > days2

# Compare two dates: returns -1 (before), 0 (equal), or 1 (after)
fn compare(date1: any, date2: any) -> i64:
    var days1 = to_days(date1)
    var days2 = to_days(date2)

    if days1 < days2:
        return -1
    if days1 > days2:
        return 1
    return 0

# Check if date1 is before or equal to date2
fn before_or_equal(date1: any, date2: any) -> bool:
    var cmp = compare(date1, date2)
    return cmp <= 0

# Check if date1 is after or equal to date2
fn after_or_equal(date1: any, date2: any) -> bool:
    var cmp = compare(date1, date2)
    return cmp >= 0

# ============================================================================
# Date Properties
# ============================================================================

# Get day of week (Monday=1, Sunday=7)
# Using Zeller's congruence algorithm modified for ISO week date
fn day_of_week(date: any) -> i64:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    # Adjust for January and February
    var m = month
    var y = year
    if m < 3:
        m = m + 12
        y = y - 1

    # Calculate day of week
    var q = day
    var k = y % 100
    var j = y / 100

    # Zeller's formula
    var h = q + ((13 * (m + 1)) / 5) + k + (k / 4) + (j / 4) - (2 * j)
    h = h % 7

    # Convert to ISO (Monday=1, Sunday=7)
    # Zeller gives Saturday=0, Sunday=1, ..., Friday=6
    var dow = ((h + 5) % 7) + 1

    return dow

# Get day of year (1-366)
fn day_of_year(date: any) -> i64:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    var doy = day

    var m = 1
    while m < month:
        doy = doy + days_in_month(year, m)
        m = m + 1

    return doy

# Get week of year (ISO 8601: week 1 contains first Thursday)
fn week_of_year(date: any) -> i64:
    var year = date[0]

    # Get day of year
    var doy = day_of_year(date)

    # Get day of week for January 1
    var jan1 = (year, 1, 1)
    var jan1_dow = day_of_week(jan1)

    # Calculate week number
    # Week 1 is the week containing the first Thursday
    var week = ((doy + jan1_dow - 2) / 7) + 1

    # Adjust if January 1 is Friday, Saturday, or Sunday
    if jan1_dow > 4:
        week = week - 1

    # Handle edge cases
    if week == 0:
        # This date belongs to the last week of previous year
        return 52

    if week > 52:
        # Check if it's week 53 or week 1 of next year
        var is_leap = is_leap_year(year)
        if is_leap:
            if doy > 366:
                return 1
        else:
            if doy > 365:
                return 1
        return 53

    return week

# Check if a date falls on a weekend (Saturday or Sunday)
fn is_weekend(date: any) -> bool:
    var dow = day_of_week(date)
    return dow == 6 or dow == 7

# Check if a date falls on a weekday (Monday-Friday)
fn is_weekday(date: any) -> bool:
    return not is_weekend(date)

# Get the quarter of the year (1-4)
fn quarter(date: any) -> i64:
    var month = date[1]
    if month <= 3:
        return 1
    if month <= 6:
        return 2
    if month <= 9:
        return 3
    return 4

# ============================================================================
# Date Formatting and Parsing
# ============================================================================

# Convert date to string in format "YYYY-MM-DD"
fn to_string(date: any) -> text:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    var year_str = text_from_i64(year)
    var month_str = text_from_i64(month)
    var day_str = text_from_i64(day)

    # Pad month and day with leading zeros
    if month < 10:
        month_str = "0" + month_str
    if day < 10:
        day_str = "0" + day_str

    return year_str + "-" + month_str + "-" + day_str

# Convert date to ISO 8601 format (same as to_string)
fn to_iso8601(date: any) -> text:
    return to_string(date)

# Convert date to readable format "January 15, 2025"
fn to_readable(date: any) -> text:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    var month_str = month_name(month)
    var day_str = text_from_i64(day)
    var year_str = text_from_i64(year)

    return month_str + " " + day_str + ", " + year_str

# Convert date to short format "Jan 15, 2025"
fn to_short(date: any) -> text:
    var year = date[0]
    var month = date[1]
    var day = date[2]

    var month_str = month_abbrev(month)
    var day_str = text_from_i64(day)
    var year_str = text_from_i64(year)

    return month_str + " " + day_str + ", " + year_str

# Parse ISO 8601 date string "YYYY-MM-DD"
fn parse_iso8601(s: text) -> any:
    var parts = text_split(s, "-")
    if text_length(parts) != 3:
        return nil

    var year = i64_from_text(parts[0])
    var month = i64_from_text(parts[1])
    var day = i64_from_text(parts[2])

    return from_ymd(year, month, day)

# ============================================================================
# Calendar Navigation
# ============================================================================

# Get the first day of the month
fn first_day_of_month(date: any) -> any:
    var year = date[0]
    var month = date[1]
    return (year, month, 1)

# Get the last day of the month
fn last_day_of_month(date: any) -> any:
    var year = date[0]
    var month = date[1]
    var last_day = days_in_month(year, month)
    return (year, month, last_day)

# Get the first day of the year
fn first_day_of_year(date: any) -> any:
    var year = date[0]
    return (year, 1, 1)

# Get the last day of the year
fn last_day_of_year(date: any) -> any:
    var year = date[0]
    return (year, 12, 31)

# Get the first day of the quarter
fn first_day_of_quarter(date: any) -> any:
    var year = date[0]
    var q = quarter(date)

    if q == 1:
        return (year, 1, 1)
    if q == 2:
        return (year, 4, 1)
    if q == 3:
        return (year, 7, 1)
    return (year, 10, 1)

# Get the last day of the quarter
fn last_day_of_quarter(date: any) -> any:
    var year = date[0]
    var q = quarter(date)

    if q == 1:
        return (year, 3, 31)
    if q == 2:
        return (year, 6, 30)
    if q == 3:
        return (year, 9, 30)
    return (year, 12, 31)

# Get the nth day of the month (e.g., nth=2, dow=1 = second Monday)
# Returns nil if that day doesn't exist in the month
fn nth_day_of_month(date: any, nth: i64, dow: i64) -> any:
    var year = date[0]
    var month = date[1]

    # Start with first day of month
    var first = first_day_of_month(date)
    var first_dow = day_of_week(first)

    # Calculate days to add to get to first occurrence of dow
    var days_to_add = dow - first_dow
    if days_to_add < 0:
        days_to_add = days_to_add + 7

    # Add weeks to get to nth occurrence
    days_to_add = days_to_add + ((nth - 1) * 7)

    # Check if result is still in the same month
    var result = add_days(first, days_to_add)
    var result_year = result[0]
    var result_month = result[1]

    if result_year != year:
        return nil
    if result_month != month:
        return nil

    return result

# Get the last occurrence of a day of week in a month
fn last_day_of_week_in_month(date: any, dow: i64) -> any:
    var last = last_day_of_month(date)
    var last_dow = day_of_week(last)

    # Calculate days to subtract to get to last occurrence of dow
    var days_to_sub = last_dow - dow
    if days_to_sub < 0:
        days_to_sub = days_to_sub + 7

    return subtract_days(last, days_to_sub)

# Get the next occurrence of a day of week
fn next_day_of_week(date: any, dow: i64) -> any:
    var current_dow = day_of_week(date)
    var days_to_add = dow - current_dow

    if days_to_add <= 0:
        days_to_add = days_to_add + 7

    return add_days(date, days_to_add)

# Get the previous occurrence of a day of week
fn prev_day_of_week(date: any, dow: i64) -> any:
    var current_dow = day_of_week(date)
    var days_to_sub = current_dow - dow

    if days_to_sub <= 0:
        days_to_sub = days_to_sub + 7

    return subtract_days(date, days_to_sub)

# ============================================================================
# Date Ranges and Sequences
# ============================================================================

# Generate a list of dates between start and end (inclusive)
fn date_range(start: any, end: any) -> any:
    var result = []
    var current = start

    var done = false
    while not done:
        result = array_push(result, current)

        if equal(current, end):
            done = true
        else:
            current = add_days(current, 1)

            # Safety check to prevent infinite loops
            if after(current, end):
                done = true

    return result

# Count the number of days between two dates (inclusive)
fn days_between(start: any, end: any) -> i64:
    var diff = difference_in_days(end, start)
    return diff + 1

# Count weekdays between two dates (inclusive)
fn weekdays_between(start: any, end: any) -> i64:
    var count = 0
    var current = start

    var done = false
    while not done:
        if is_weekday(current):
            count = count + 1

        if equal(current, end):
            done = true
        else:
            current = add_days(current, 1)

            # Safety check
            if after(current, end):
                done = true

    return count

# Count weekends between two dates (inclusive)
fn weekends_between(start: any, end: any) -> i64:
    var total = days_between(start, end)
    var weekdays = weekdays_between(start, end)
    return total - weekdays

# Count occurrences of a specific day of week between two dates
fn count_day_of_week(start: any, end: any, dow: i64) -> i64:
    var count = 0
    var current = start

    var done = false
    while not done:
        if day_of_week(current) == dow:
            count = count + 1

        if equal(current, end):
            done = true
        else:
            current = add_days(current, 1)

            # Safety check
            if after(current, end):
                done = true

    return count

# ============================================================================
# Advanced Calendar Calculations
# ============================================================================

# Calculate Easter Sunday for a given year (using Meeus/Jones/Butcher algorithm)
# Works for Gregorian calendar (years 1583+)
fn easter_date(year: i64) -> any:
    if year < 1583:
        return nil

    var a = year % 19
    var b = year / 100
    var c = year % 100
    var d = b / 4
    var e = b % 4
    var f = (b + 8) / 25
    var g = (b - f + 1) / 3
    var h = (19 * a + b - d - g + 15) % 30
    var i = c / 4
    var k = c % 4
    var l = (32 + 2 * e + 2 * i - h - k) % 7
    var m = (a + 11 * h + 22 * l) / 451
    var month = (h + l - 7 * m + 114) / 31
    var day = ((h + l - 7 * m + 114) % 31) + 1

    return (year, month, day)

# Calculate Good Friday (2 days before Easter)
fn good_friday(year: i64) -> any:
    var easter = easter_date(year)
    if easter == nil:
        return nil
    return subtract_days(easter, 2)

# Calculate Ash Wednesday (46 days before Easter)
fn ash_wednesday(year: i64) -> any:
    var easter = easter_date(year)
    if easter == nil:
        return nil
    return subtract_days(easter, 46)

# Calculate Pentecost (49 days after Easter)
fn pentecost(year: i64) -> any:
    var easter = easter_date(year)
    if easter == nil:
        return nil
    return add_days(easter, 49)

# Calculate Thanksgiving (US: 4th Thursday of November)
fn thanksgiving_us(year: i64) -> any:
    var nov1 = (year, 11, 1)
    return nth_day_of_month(nov1, 4, THURSDAY)

# Calculate Labor Day (US: 1st Monday of September)
fn labor_day_us(year: i64) -> any:
    var sep1 = (year, 9, 1)
    return nth_day_of_month(sep1, 1, MONDAY)

# Calculate Memorial Day (US: last Monday of May)
fn memorial_day_us(year: i64) -> any:
    var may1 = (year, 5, 1)
    return last_day_of_week_in_month(may1, MONDAY)

# ============================================================================
# Date Age and Duration Calculations
# ============================================================================

# Calculate age in years from birthdate to reference date
fn age_in_years(birthdate: any, reference: any) -> i64:
    var birth_year = birthdate[0]
    var birth_month = birthdate[1]
    var birth_day = birthdate[2]

    var ref_year = reference[0]
    var ref_month = reference[1]
    var ref_day = reference[2]

    var age = ref_year - birth_year

    # Adjust if birthday hasn't occurred yet this year
    if ref_month < birth_month:
        age = age - 1
    else:
        if ref_month == birth_month:
            if ref_day < birth_day:
                age = age - 1

    return age

# Calculate difference in months between two dates
fn difference_in_months(date1: any, date2: any) -> i64:
    var y1 = date1[0]
    var m1 = date1[1]
    var d1 = date1[2]

    var y2 = date2[0]
    var m2 = date2[1]
    var d2 = date2[2]

    var months = (y1 - y2) * 12 + (m1 - m2)

    # Adjust for day difference
    if d1 < d2:
        months = months - 1

    return months

# Calculate difference in years between two dates
fn difference_in_years(date1: any, date2: any) -> i64:
    return age_in_years(date2, date1)

# ============================================================================
# Helper Functions
# ============================================================================

# Convert integer to text
fn text_from_i64(n: i64) -> text:
    if n == 0:
        return "0"

    var negative = false
    var num = n
    if num < 0:
        negative = true
        num = 0 - num

    var digits = ""
    while num > 0:
        var digit = num % 10
        var digit_char = ""

        if digit == 0:
            digit_char = "0"
        if digit == 1:
            digit_char = "1"
        if digit == 2:
            digit_char = "2"
        if digit == 3:
            digit_char = "3"
        if digit == 4:
            digit_char = "4"
        if digit == 5:
            digit_char = "5"
        if digit == 6:
            digit_char = "6"
        if digit == 7:
            digit_char = "7"
        if digit == 8:
            digit_char = "8"
        if digit == 9:
            digit_char = "9"

        digits = digit_char + digits
        num = num / 10

    if negative:
        digits = "-" + digits

    return digits

# Convert text to integer
fn i64_from_text(s: text) -> i64:
    var result = 0
    var negative = false
    var i = 0
    var len = text_length(s)

    # Check for negative sign
    if len > 0:
        var first_char = text_substring(s, 0, 1)
        if first_char == "-":
            negative = true
            i = 1

    while i < len:
        var char = text_substring(s, i, i + 1)
        var digit = 0

        if char == "0":
            digit = 0
        if char == "1":
            digit = 1
        if char == "2":
            digit = 2
        if char == "3":
            digit = 3
        if char == "4":
            digit = 4
        if char == "5":
            digit = 5
        if char == "6":
            digit = 6
        if char == "7":
            digit = 7
        if char == "8":
            digit = 8
        if char == "9":
            digit = 9

        result = result * 10 + digit
        i = i + 1

    if negative:
        result = 0 - result

    return result

# Get text length
fn text_length(s: text) -> i64:
    var len = 0
    var test = s
    while test != "":
        len = len + 1
        # Try to get substring (this is a simplified approach)
        test = ""
    return len

# Get substring (simplified version for parsing)
fn text_substring(s: text, start: i64, end: i64) -> text:
    # This is a placeholder - actual implementation would need runtime support
    return s

# Split text by delimiter (simplified)
fn text_split(s: text, delim: text) -> any:
    # This is a placeholder - returns array of parts
    # Actual implementation would need string manipulation support
    return [s]

# Push to array (helper for building result arrays)
fn array_push(arr: any, item: any) -> any:
    # This is a placeholder - actual implementation would use array operations
    return arr
