# CSV Utilities Module
# Comprehensive CSV parsing and writing with RFC 4180 compliance
# Pure Simple implementation - NO runtime generics, NO try/catch

# ============================================================================
# Core Data Types and Constants
# ============================================================================

class CsvConfig:
    delimiter: text
    quote_char: text
    escape_char: text
    line_ending: text
    trim_whitespace: bool
    skip_empty_lines: bool

fn default_csv_config() -> CsvConfig:
    CsvConfig(
        delimiter: ",",
        quote_char: "\"",
        escape_char: "\"",
        line_ending: "\n",
        trim_whitespace: false,
        skip_empty_lines: false
    )

class CsvTable:
    headers: list
    rows: list
    config: CsvConfig

class CsvParseResult:
    success: bool
    table: CsvTable
    error: text
    line_number: i64

# ============================================================================
# Character and String Utilities
# ============================================================================

fn is_quote_char(c: text, quote: text) -> bool:
    c == quote

fn is_delimiter_char(c: text, delimiter: text) -> bool:
    c == delimiter

fn is_newline_char(c: text) -> bool:
    val result = c == "\n"
    result

fn is_carriage_return(c: text) -> bool:
    val result = c == "\r"
    result

fn is_whitespace_char(c: text) -> bool:
    val is_space = c == " "
    val is_tab = c == "\t"
    val is_nl = c == "\n"
    val is_cr = c == "\r"
    val result1 = is_space or is_tab
    val result2 = is_nl or is_cr
    val final_result = result1 or result2
    final_result

fn char_at(s: text, index: i64) -> text:
    val len = s.length()
    if index < 0 or index >= len:
        return ""
    val substring = s.substring(index, index + 1)
    substring

fn string_contains_char(s: text, c: text) -> text:
    val index = s.find(c)
    if index == -1:
        return "no"
    "yes"

fn needs_quoting(field: text, delimiter: text, quote_char: text) -> bool:
    val has_delimiter = string_contains_char(field, delimiter)
    val has_quote = string_contains_char(field, quote_char)
    val has_newline = string_contains_char(field, "\n")
    val has_cr = string_contains_char(field, "\r")
    val result1 = has_delimiter == "yes"
    val result2 = has_quote == "yes"
    val result3 = has_newline == "yes"
    val result4 = has_cr == "yes"
    val temp1 = result1 or result2
    val temp2 = result3 or result4
    val final = temp1 or temp2
    final

# ============================================================================
# String Trimming
# ============================================================================

fn trim_left(s: text) -> text:
    var i = 0
    val len = s.length()
    loop:
        if i >= len:
            break
        val c = char_at(s, i)
        val is_ws = is_whitespace_char(c)
        if not is_ws:
            break
        i = i + 1
    val result = s.substring(i, len)
    result

fn trim_right(s: text) -> text:
    var i = s.length()
    loop:
        if i <= 0:
            break
        val c = char_at(s, i - 1)
        val is_ws = is_whitespace_char(c)
        if not is_ws:
            break
        i = i - 1
    val result = s.substring(0, i)
    result

fn trim_whitespace(s: text) -> text:
    val temp = trim_left(s)
    val result = trim_right(temp)
    result

fn trim_field(field: text, should_trim: bool) -> text:
    if not should_trim:
        return field
    val result = trim_whitespace(field)
    result

# ============================================================================
# Field Escaping and Unescaping
# ============================================================================

fn escape_quote_in_field(field: text, quote_char: text, escape_char: text) -> text:
    var result = ""
    var i = 0
    val len = field.length()
    loop:
        if i >= len:
            break
        val c = char_at(field, i)
        val is_q = is_quote_char(c, quote_char)
        if is_q:
            result = result + escape_char
            result = result + c
        else:
            result = result + c
        i = i + 1
    result

fn unescape_field(field: text, quote_char: text, escape_char: text) -> text:
    var result = ""
    var i = 0
    val len = field.length()
    loop:
        if i >= len:
            break
        val c = char_at(field, i)
        val is_esc = c == escape_char
        if is_esc:
            val next_i = i + 1
            if next_i < len:
                val next_c = char_at(field, next_i)
                val is_q = is_quote_char(next_c, quote_char)
                if is_q:
                    result = result + next_c
                    i = i + 2
                else:
                    result = result + c
                    i = i + 1
            else:
                result = result + c
                i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn escape_field(field: text, config: CsvConfig) -> text:
    val needs_q = needs_quoting(field, config.delimiter, config.quote_char)
    if not needs_q:
        return field
    val escaped = escape_quote_in_field(field, config.quote_char, config.escape_char)
    var result = config.quote_char
    result = result + escaped
    result = result + config.quote_char
    result

# ============================================================================
# Line Splitting
# ============================================================================

fn split_lines_crlf(content: text) -> list:
    var lines = []
    var current = ""
    var i = 0
    val len = content.length()
    loop:
        if i >= len:
            break
        val c = char_at(content, i)
        val is_cr = is_carriage_return(c)
        if is_cr:
            val next_i = i + 1
            if next_i < len:
                val next_c = char_at(content, next_i)
                val is_nl = is_newline_char(next_c)
                if is_nl:
                    lines = lines.append(current)
                    current = ""
                    i = i + 2
                else:
                    current = current + c
                    i = i + 1
            else:
                current = current + c
                i = i + 1
        else:
            val is_nl = is_newline_char(c)
            if is_nl:
                lines = lines.append(current)
                current = ""
                i = i + 1
            else:
                current = current + c
                i = i + 1
    val current_len = current.length()
    if current_len > 0:
        lines = lines.append(current)
    lines

fn split_lines(content: text) -> list:
    split_lines_crlf(content)

# ============================================================================
# Field Parsing (Core CSV Parser)
# ============================================================================

fn parse_csv_line(line: text, config: CsvConfig) -> list:
    var fields = []
    var current_field = ""
    var in_quotes = false
    var i = 0
    val len = line.length()

    loop:
        if i >= len:
            break

        val c = char_at(line, i)
        val is_q = is_quote_char(c, config.quote_char)

        if is_q:
            if in_quotes:
                val next_i = i + 1
                if next_i < len:
                    val next_c = char_at(line, next_i)
                    val next_is_q = is_quote_char(next_c, config.quote_char)
                    if next_is_q:
                        current_field = current_field + config.quote_char
                        i = i + 2
                    else:
                        in_quotes = false
                        i = i + 1
                else:
                    in_quotes = false
                    i = i + 1
            else:
                in_quotes = true
                i = i + 1
        else:
            val is_delim = is_delimiter_char(c, config.delimiter)
            if is_delim:
                if in_quotes:
                    current_field = current_field + c
                    i = i + 1
                else:
                    val trimmed = trim_field(current_field, config.trim_whitespace)
                    fields = fields.append(trimmed)
                    current_field = ""
                    i = i + 1
            else:
                current_field = current_field + c
                i = i + 1

    val trimmed = trim_field(current_field, config.trim_whitespace)
    fields = fields.append(trimmed)
    fields

# ============================================================================
# CSV Parsing Functions
# ============================================================================

fn parse_csv_string(content: text, config: CsvConfig) -> CsvTable:
    val lines = split_lines(content)
    var rows = []
    var i = 0
    val line_count = lines.length()

    loop:
        if i >= line_count:
            break
        val line = lines.at(i)
        val line_len = line.length()
        val should_skip = config.skip_empty_lines and line_len == 0
        if not should_skip:
            val fields = parse_csv_line(line, config)
            rows = rows.append(fields)
        i = i + 1

    val empty_headers = []
    CsvTable(headers: empty_headers, rows: rows, config: config)

fn parse_csv(content: text) -> CsvTable:
    val config = default_csv_config()
    parse_csv_string(content, config)

fn parse_csv_with_delimiter(content: text, delimiter: text) -> CsvTable:
    val config = default_csv_config()
    val new_config = CsvConfig(
        delimiter: delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: config.line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )
    parse_csv_string(content, new_config)

fn parse_csv_with_headers(content: text, config: CsvConfig) -> CsvTable:
    val lines = split_lines(content)
    val line_count = lines.length()
    if line_count == 0:
        val empty_headers = []
        val empty_rows = []
        return CsvTable(headers: empty_headers, rows: empty_rows, config: config)

    val header_line = lines.at(0)
    val headers = parse_csv_line(header_line, config)

    var rows = []
    var i = 1
    loop:
        if i >= line_count:
            break
        val line = lines.at(i)
        val line_len = line.length()
        val should_skip = config.skip_empty_lines and line_len == 0
        if not should_skip:
            val fields = parse_csv_line(line, config)
            rows = rows.append(fields)
        i = i + 1

    CsvTable(headers: headers, rows: rows, config: config)

fn parse_csv_simple_headers(content: text) -> CsvTable:
    val config = default_csv_config()
    parse_csv_with_headers(content, config)

# ============================================================================
# CSV Writing Functions
# ============================================================================

fn write_csv_row(fields: list, config: CsvConfig) -> text:
    var result = ""
    var i = 0
    val field_count = fields.length()

    loop:
        if i >= field_count:
            break
        val field = fields.at(i)
        val escaped = escape_field(field, config)
        result = result + escaped
        val next_i = i + 1
        if next_i < field_count:
            result = result + config.delimiter
        i = i + 1

    result

fn write_csv_table(table: CsvTable) -> text:
    var result = ""
    val has_headers = table.headers.length() > 0

    if has_headers:
        val header_line = write_csv_row(table.headers, table.config)
        result = result + header_line
        result = result + table.config.line_ending

    var i = 0
    val row_count = table.rows.length()
    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val row_line = write_csv_row(row, table.config)
        result = result + row_line
        val next_i = i + 1
        if next_i < row_count:
            result = result + table.config.line_ending
        i = i + 1

    result

fn write_csv_rows(rows: list, config: CsvConfig) -> text:
    val empty_headers = []
    val table = CsvTable(headers: empty_headers, rows: rows, config: config)
    write_csv_table(table)

fn write_csv_simple(rows: list) -> text:
    val config = default_csv_config()
    write_csv_rows(rows, config)

fn write_csv_with_headers(headers: list, rows: list, config: CsvConfig) -> text:
    val table = CsvTable(headers: headers, rows: rows, config: config)
    write_csv_table(table)

# ============================================================================
# Table Operations - Row Access and Filtering
# ============================================================================

fn get_row_count(table: CsvTable) -> i64:
    table.rows.length()

fn get_row(table: CsvTable, index: i64) -> list:
    val row_count = table.rows.length()
    if index < 0 or index >= row_count:
        return []
    table.rows.at(index)

fn get_first_row(table: CsvTable) -> list:
    get_row(table, 0)

fn get_last_row(table: CsvTable) -> list:
    val row_count = table.rows.length()
    if row_count == 0:
        return []
    val last_index = row_count - 1
    get_row(table, last_index)

fn slice_rows(table: CsvTable, start: i64, end: i64) -> CsvTable:
    var sliced = []
    var i = start
    val row_count = table.rows.length()
    val actual_end = end

    loop:
        if i >= actual_end or i >= row_count:
            break
        val row = table.rows.at(i)
        sliced = sliced.append(row)
        i = i + 1

    CsvTable(headers: table.headers, rows: sliced, config: table.config)

fn take_rows(table: CsvTable, n: i64) -> CsvTable:
    slice_rows(table, 0, n)

fn skip_rows(table: CsvTable, n: i64) -> CsvTable:
    val row_count = table.rows.length()
    slice_rows(table, n, row_count)

fn reverse_rows(table: CsvTable) -> CsvTable:
    var reversed = []
    var i = table.rows.length()
    loop:
        if i <= 0:
            break
        i = i - 1
        val row = table.rows.at(i)
        reversed = reversed.append(row)
    CsvTable(headers: table.headers, rows: reversed, config: table.config)

# ============================================================================
# Table Operations - Column Access
# ============================================================================

fn get_column_count(table: CsvTable) -> i64:
    val row_count = table.rows.length()
    if row_count == 0:
        return 0
    val first_row = table.rows.at(0)
    first_row.length()

fn find_column_index(table: CsvTable, column_name: text) -> i64:
    var i = 0
    val header_count = table.headers.length()

    loop:
        if i >= header_count:
            break
        val header = table.headers.at(i)
        if header == column_name:
            return i
        i = i + 1

    -1

fn get_column_by_index(table: CsvTable, col_index: i64) -> list:
    var column = []
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val field_count = row.length()
        if col_index >= 0 and col_index < field_count:
            val value = row.at(col_index)
            column = column.append(value)
        else:
            column = column.append("")
        i = i + 1

    column

fn get_column_by_name(table: CsvTable, column_name: text) -> list:
    val col_index = find_column_index(table, column_name)
    if col_index == -1:
        return []
    get_column_by_index(table, col_index)

fn get_field(table: CsvTable, row_index: i64, col_index: i64) -> text:
    val row_count = table.rows.length()
    if row_index < 0 or row_index >= row_count:
        return ""
    val row = table.rows.at(row_index)
    val field_count = row.length()
    if col_index < 0 or col_index >= field_count:
        return ""
    row.at(col_index)

fn get_field_by_name(table: CsvTable, row_index: i64, column_name: text) -> text:
    val col_index = find_column_index(table, column_name)
    if col_index == -1:
        return ""
    get_field(table, row_index, col_index)

# ============================================================================
# Table Operations - Column Modifications
# ============================================================================

fn select_columns_by_indices(table: CsvTable, col_indices: list) -> CsvTable:
    var new_headers = []
    val has_headers = table.headers.length() > 0

    if has_headers:
        var i = 0
        val index_count = col_indices.length()
        loop:
            if i >= index_count:
                break
            val col_index = col_indices.at(i)
            val header_count = table.headers.length()
            if col_index >= 0 and col_index < header_count:
                val header = table.headers.at(col_index)
                new_headers = new_headers.append(header)
            i = i + 1

    var new_rows = []
    var row_i = 0
    val row_count = table.rows.length()
    loop:
        if row_i >= row_count:
            break
        val row = table.rows.at(row_i)
        var new_row = []
        var col_i = 0
        val index_count = col_indices.length()
        loop:
            if col_i >= index_count:
                break
            val col_index = col_indices.at(col_i)
            val field_count = row.length()
            if col_index >= 0 and col_index < field_count:
                val field = row.at(col_index)
                new_row = new_row.append(field)
            else:
                new_row = new_row.append("")
            col_i = col_i + 1
        new_rows = new_rows.append(new_row)
        row_i = row_i + 1

    CsvTable(headers: new_headers, rows: new_rows, config: table.config)

fn select_columns_by_names(table: CsvTable, column_names: list) -> CsvTable:
    var col_indices = []
    var i = 0
    val name_count = column_names.length()

    loop:
        if i >= name_count:
            break
        val column_name = column_names.at(i)
        val col_index = find_column_index(table, column_name)
        if col_index != -1:
            col_indices = col_indices.append(col_index)
        i = i + 1

    select_columns_by_indices(table, col_indices)

fn add_column(table: CsvTable, column_name: text, values: list) -> CsvTable:
    var new_headers = table.headers
    val has_headers = table.headers.length() > 0
    if has_headers:
        new_headers = new_headers.append(column_name)

    var new_rows = []
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        var new_row = row
        val value_count = values.length()
        if i < value_count:
            val value = values.at(i)
            new_row = new_row.append(value)
        else:
            new_row = new_row.append("")
        new_rows = new_rows.append(new_row)
        i = i + 1

    CsvTable(headers: new_headers, rows: new_rows, config: table.config)

fn remove_column_by_index(table: CsvTable, col_index: i64) -> CsvTable:
    var new_headers = []
    val has_headers = table.headers.length() > 0

    if has_headers:
        var i = 0
        val header_count = table.headers.length()
        loop:
            if i >= header_count:
                break
            if i != col_index:
                val header = table.headers.at(i)
                new_headers = new_headers.append(header)
            i = i + 1

    var new_rows = []
    var row_i = 0
    val row_count = table.rows.length()
    loop:
        if row_i >= row_count:
            break
        val row = table.rows.at(row_i)
        var new_row = []
        var col_i = 0
        val field_count = row.length()
        loop:
            if col_i >= field_count:
                break
            if col_i != col_index:
                val field = row.at(col_i)
                new_row = new_row.append(field)
            col_i = col_i + 1
        new_rows = new_rows.append(new_row)
        row_i = row_i + 1

    CsvTable(headers: new_headers, rows: new_rows, config: table.config)

fn remove_column_by_name(table: CsvTable, column_name: text) -> CsvTable:
    val col_index = find_column_index(table, column_name)
    if col_index == -1:
        return table
    remove_column_by_index(table, col_index)

fn rename_column(table: CsvTable, old_name: text, new_name: text) -> CsvTable:
    val col_index = find_column_index(table, old_name)
    if col_index == -1:
        return table

    var new_headers = []
    var i = 0
    val header_count = table.headers.length()
    loop:
        if i >= header_count:
            break
        if i == col_index:
            new_headers = new_headers.append(new_name)
        else:
            val header = table.headers.at(i)
            new_headers = new_headers.append(header)
        i = i + 1

    CsvTable(headers: new_headers, rows: table.rows, config: table.config)

# ============================================================================
# Data Validation
# ============================================================================

fn validate_row_length(row: list, expected_length: i64) -> bool:
    val actual_length = row.length()
    actual_length == expected_length

fn validate_table_uniform_rows(table: CsvTable) -> bool:
    val row_count = table.rows.length()
    if row_count == 0:
        return true

    val first_row = table.rows.at(0)
    val expected_length = first_row.length()

    var i = 1
    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val is_valid = validate_row_length(row, expected_length)
        if not is_valid:
            return false
        i = i + 1

    true

fn validate_headers_match_columns(table: CsvTable) -> bool:
    val header_count = table.headers.length()
    if header_count == 0:
        return true
    val col_count = get_column_count(table)
    header_count == col_count

fn is_numeric_field(field: text) -> bool:
    val trimmed = trim_whitespace(field)
    val len = trimmed.length()
    if len == 0:
        return false

    var i = 0
    var has_digit = false
    var has_dot = false

    loop:
        if i >= len:
            break
        val c = char_at(trimmed, i)
        val is_minus = c == "-"
        val is_plus = c == "+"
        val is_dot = c == "."
        val is_digit = c >= "0" and c <= "9"

        if is_minus or is_plus:
            if i != 0:
                return false
        else:
            if is_dot:
                if has_dot:
                    return false
                has_dot = true
            else:
                if is_digit:
                    has_digit = true
                else:
                    return false
        i = i + 1

    has_digit

fn validate_column_numeric(table: CsvTable, col_index: i64) -> bool:
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val field_count = row.length()
        if col_index >= 0 and col_index < field_count:
            val field = row.at(col_index)
            val is_num = is_numeric_field(field)
            if not is_num:
                return false
        i = i + 1

    true

fn validate_column_not_empty(table: CsvTable, col_index: i64) -> bool:
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val field_count = row.length()
        if col_index >= 0 and col_index < field_count:
            val field = row.at(col_index)
            val trimmed = trim_whitespace(field)
            val len = trimmed.length()
            if len == 0:
                return false
        i = i + 1

    true

fn validate_row_not_empty(table: CsvTable, row_index: i64) -> bool:
    val row = get_row(table, row_index)
    val field_count = row.length()
    var i = 0
    loop:
        if i >= field_count:
            break
        val field = row.at(i)
        val trimmed = trim_whitespace(field)
        val len = trimmed.length()
        if len > 0:
            return true
        i = i + 1
    false

# ============================================================================
# Delimiter Detection
# ============================================================================

fn count_char_occurrences(s: text, c: text) -> i64:
    var count = 0
    var i = 0
    val len = s.length()

    loop:
        if i >= len:
            break
        val current = char_at(s, i)
        if current == c:
            count = count + 1
        i = i + 1

    count

fn detect_delimiter_in_line(line: text) -> text:
    val comma_count = count_char_occurrences(line, ",")
    val tab_count = count_char_occurrences(line, "\t")
    val semicolon_count = count_char_occurrences(line, ";")
    val pipe_count = count_char_occurrences(line, "|")

    var max_count = comma_count
    var delimiter = ","

    if tab_count > max_count:
        max_count = tab_count
        delimiter = "\t"

    if semicolon_count > max_count:
        max_count = semicolon_count
        delimiter = ";"

    if pipe_count > max_count:
        max_count = pipe_count
        delimiter = "|"

    delimiter

fn detect_delimiter(content: text) -> text:
    val lines = split_lines(content)
    val line_count = lines.length()
    if line_count == 0:
        return ","

    val first_line = lines.at(0)
    detect_delimiter_in_line(first_line)

# ============================================================================
# Advanced Parsing Options
# ============================================================================

fn parse_tsv(content: text) -> CsvTable:
    parse_csv_with_delimiter(content, "\t")

fn parse_ssv(content: text) -> CsvTable:
    parse_csv_with_delimiter(content, ";")

fn parse_psv(content: text) -> CsvTable:
    parse_csv_with_delimiter(content, "|")

fn parse_csv_auto_delimiter(content: text) -> CsvTable:
    val delimiter = detect_delimiter(content)
    parse_csv_with_delimiter(content, delimiter)

fn create_config_with_trim(delimiter: text, should_trim: bool) -> CsvConfig:
    val base = default_csv_config()
    CsvConfig(
        delimiter: delimiter,
        quote_char: base.quote_char,
        escape_char: base.escape_char,
        line_ending: base.line_ending,
        trim_whitespace: should_trim,
        skip_empty_lines: base.skip_empty_lines
    )

fn parse_csv_with_trim(content: text, should_trim: bool) -> CsvTable:
    val config = create_config_with_trim(",", should_trim)
    parse_csv_string(content, config)

fn create_config_skip_empty(delimiter: text, skip_empty: bool) -> CsvConfig:
    val base = default_csv_config()
    CsvConfig(
        delimiter: delimiter,
        quote_char: base.quote_char,
        escape_char: base.escape_char,
        line_ending: base.line_ending,
        trim_whitespace: base.trim_whitespace,
        skip_empty_lines: skip_empty
    )

fn parse_csv_skip_empty_lines(content: text) -> CsvTable:
    val config = create_config_skip_empty(",", true)
    parse_csv_string(content, config)

# ============================================================================
# Table Transformation
# ============================================================================

fn transpose_table(table: CsvTable) -> CsvTable:
    val row_count = table.rows.length()
    if row_count == 0:
        val empty_headers = []
        val empty_rows = []
        return CsvTable(headers: empty_headers, rows: empty_rows, config: table.config)

    val col_count = get_column_count(table)
    var new_rows = []

    var col_i = 0
    loop:
        if col_i >= col_count:
            break
        var new_row = []
        var row_i = 0
        loop:
            if row_i >= row_count:
                break
            val row = table.rows.at(row_i)
            val field_count = row.length()
            if col_i < field_count:
                val field = row.at(col_i)
                new_row = new_row.append(field)
            else:
                new_row = new_row.append("")
            row_i = row_i + 1
        new_rows = new_rows.append(new_row)
        col_i = col_i + 1

    val empty_headers = []
    CsvTable(headers: empty_headers, rows: new_rows, config: table.config)

fn merge_tables_vertical(table1: CsvTable, table2: CsvTable) -> CsvTable:
    var merged_rows = []
    var i = 0
    val row_count1 = table1.rows.length()
    loop:
        if i >= row_count1:
            break
        val row = table1.rows.at(i)
        merged_rows = merged_rows.append(row)
        i = i + 1

    var j = 0
    val row_count2 = table2.rows.length()
    loop:
        if j >= row_count2:
            break
        val row = table2.rows.at(j)
        merged_rows = merged_rows.append(row)
        j = j + 1

    CsvTable(headers: table1.headers, rows: merged_rows, config: table1.config)

fn merge_tables_horizontal(table1: CsvTable, table2: CsvTable) -> CsvTable:
    var merged_headers = []
    var i = 0
    val header_count1 = table1.headers.length()
    loop:
        if i >= header_count1:
            break
        val header = table1.headers.at(i)
        merged_headers = merged_headers.append(header)
        i = i + 1

    var j = 0
    val header_count2 = table2.headers.length()
    loop:
        if j >= header_count2:
            break
        val header = table2.headers.at(j)
        merged_headers = merged_headers.append(header)
        j = j + 1

    var merged_rows = []
    val row_count1 = table1.rows.length()
    val row_count2 = table2.rows.length()
    val max_rows = row_count1
    var max_val = max_rows
    if row_count2 > max_val:
        max_val = row_count2

    var row_i = 0
    loop:
        if row_i >= max_val:
            break
        var merged_row = []

        if row_i < row_count1:
            val row1 = table1.rows.at(row_i)
            var k = 0
            val field_count1 = row1.length()
            loop:
                if k >= field_count1:
                    break
                val field = row1.at(k)
                merged_row = merged_row.append(field)
                k = k + 1

        if row_i < row_count2:
            val row2 = table2.rows.at(row_i)
            var m = 0
            val field_count2 = row2.length()
            loop:
                if m >= field_count2:
                    break
                val field = row2.at(m)
                merged_row = merged_row.append(field)
                m = m + 1

        merged_rows = merged_rows.append(merged_row)
        row_i = row_i + 1

    CsvTable(headers: merged_headers, rows: merged_rows, config: table1.config)

# ============================================================================
# Configuration Builders
# ============================================================================

fn config_with_delimiter(config: CsvConfig, delimiter: text) -> CsvConfig:
    CsvConfig(
        delimiter: delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: config.line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )

fn config_with_line_ending(config: CsvConfig, line_ending: text) -> CsvConfig:
    CsvConfig(
        delimiter: config.delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )

fn config_with_quote_char(config: CsvConfig, quote_char: text) -> CsvConfig:
    CsvConfig(
        delimiter: config.delimiter,
        quote_char: quote_char,
        escape_char: config.escape_char,
        line_ending: config.line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )

fn config_with_trim(config: CsvConfig, should_trim: bool) -> CsvConfig:
    CsvConfig(
        delimiter: config.delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: config.line_ending,
        trim_whitespace: should_trim,
        skip_empty_lines: config.skip_empty_lines
    )

fn config_with_skip_empty(config: CsvConfig, skip_empty: bool) -> CsvConfig:
    CsvConfig(
        delimiter: config.delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: config.line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: skip_empty
    )

fn create_tsv_config() -> CsvConfig:
    val base = default_csv_config()
    config_with_delimiter(base, "\t")

fn create_crlf_config() -> CsvConfig:
    val base = default_csv_config()
    config_with_line_ending(base, "\r\n")

fn create_custom_config(delimiter: text, quote: text, escape: text) -> CsvConfig:
    CsvConfig(
        delimiter: delimiter,
        quote_char: quote,
        escape_char: escape,
        line_ending: "\n",
        trim_whitespace: false,
        skip_empty_lines: false
    )

# ============================================================================
# Table Information
# ============================================================================

fn table_is_empty(table: CsvTable) -> bool:
    val row_count = table.rows.length()
    row_count == 0

fn table_has_headers(table: CsvTable) -> bool:
    val header_count = table.headers.length()
    header_count > 0

fn get_table_dimensions(table: CsvTable) -> list:
    val row_count = get_row_count(table)
    val col_count = get_column_count(table)
    var dims = []
    dims = dims.append(row_count)
    dims = dims.append(col_count)
    dims

fn get_header_names(table: CsvTable) -> list:
    table.headers

fn count_empty_rows(table: CsvTable) -> i64:
    var count = 0
    var i = 0
    val row_count = table.rows.length()
    loop:
        if i >= row_count:
            break
        val is_empty = not validate_row_not_empty(table, i)
        if is_empty:
            count = count + 1
        i = i + 1
    count

# ============================================================================
# Export Functions
# ============================================================================

fn table_to_string(table: CsvTable) -> text:
    write_csv_table(table)

fn rows_to_string(rows: list) -> text:
    write_csv_simple(rows)

fn rows_to_tsv(rows: list) -> text:
    val config = create_tsv_config()
    write_csv_rows(rows, config)

fn rows_to_csv_crlf(rows: list) -> text:
    val config = create_crlf_config()
    write_csv_rows(rows, config)

# ============================================================================
# Filtering and Searching
# ============================================================================

fn find_rows_with_value(table: CsvTable, col_index: i64, value: text) -> list:
    var matching_indices = []
    var i = 0
    val row_count = table.rows.length()
    loop:
        if i >= row_count:
            break
        val field = get_field(table, i, col_index)
        if field == value:
            matching_indices = matching_indices.append(i)
        i = i + 1
    matching_indices

fn find_rows_containing(table: CsvTable, col_index: i64, substring: text) -> list:
    var matching_indices = []
    var i = 0
    val row_count = table.rows.length()
    loop:
        if i >= row_count:
            break
        val field = get_field(table, i, col_index)
        val contains = string_contains_char(field, substring)
        if contains == "yes":
            matching_indices = matching_indices.append(i)
        i = i + 1
    matching_indices

fn filter_table_by_row_indices(table: CsvTable, indices: list) -> CsvTable:
    var filtered_rows = []
    var i = 0
    val index_count = indices.length()
    loop:
        if i >= index_count:
            break
        val row_index = indices.at(i)
        val row = get_row(table, row_index)
        val row_len = row.length()
        if row_len > 0:
            filtered_rows = filtered_rows.append(row)
        i = i + 1
    CsvTable(headers: table.headers, rows: filtered_rows, config: table.config)

# ============================================================================
# Sorting
# ============================================================================

fn compare_text_fields(field1: text, field2: text) -> i64:
    if field1 < field2:
        return -1
    if field1 > field2:
        return 1
    0

fn compare_numeric_fields(field1: text, field2: text) -> i64:
    val is_num1 = is_numeric_field(field1)
    val is_num2 = is_numeric_field(field2)
    if not is_num1 or not is_num2:
        return compare_text_fields(field1, field2)
    if field1 < field2:
        return -1
    if field1 > field2:
        return 1
    0

# ============================================================================
# Statistics
# ============================================================================

fn count_unique_values_in_column(table: CsvTable, col_index: i64) -> i64:
    val column = get_column_by_index(table, col_index)
    var unique_count = 0
    var i = 0
    val col_len = column.length()
    loop:
        if i >= col_len:
            break
        val value = column.at(i)
        var is_unique = true
        var j = 0
        loop:
            if j >= i:
                break
            val prev_value = column.at(j)
            if prev_value == value:
                is_unique = false
                break
            j = j + 1
        if is_unique:
            unique_count = unique_count + 1
        i = i + 1
    unique_count

fn get_distinct_values(table: CsvTable, col_index: i64) -> list:
    val column = get_column_by_index(table, col_index)
    var distinct = []
    var i = 0
    val col_len = column.length()
    loop:
        if i >= col_len:
            break
        val value = column.at(i)
        var is_unique = true
        var j = 0
        val distinct_len = distinct.length()
        loop:
            if j >= distinct_len:
                break
            val prev_value = distinct.at(j)
            if prev_value == value:
                is_unique = false
                break
            j = j + 1
        if is_unique:
            distinct = distinct.append(value)
        i = i + 1
    distinct
