# FFT Utilities Module
# Helper functions and mathematical operations

# ============================================================================
# Utility Functions
# ============================================================================

fn is_power_of_2(n: i64) -> bool:
    if n <= 0:
        false
    else:
        n & (n - 1) == 0

fn next_power_of_2(n: i64) -> i64:
    if n <= 1:
        1
    else:
        var power = 1
        while power < n:
            power = power * 2
        power

fn log2_int(n: i64) -> i64:
    var result = 0
    var value = n
    while value > 1:
        value = value / 2
        result = result + 1
    result

fn frequency_resolution(sample_rate: f64, n: i64) -> f64:
    sample_rate / n as f64

fn bin_to_frequency(bin: i64, sample_rate: f64, n: i64) -> f64:
    bin as f64 * sample_rate / n as f64

fn frequency_to_bin(freq: f64, sample_rate: f64, n: i64) -> i64:
    (freq * n as f64 / sample_rate) as i64

# ============================================================================
# Bit Reversal
# ============================================================================

fn reverse_bits(x: i64, bits: i64) -> i64:
    var result = 0
    var value = x
    var i = 0
    while i < bits:
        result = (result << 1) | (value & 1)
        value = value >> 1
        i = i + 1
    result

fn bit_reversal_permutation(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    val bits = log2_int(n)
    var result = []
    var i = 0
    while i < n:
        val j = reverse_bits(i, bits)
        val elem = array_get(data, j)
        result = array_push(result, elem)
        i = i + 1
    result

# ============================================================================
# Twiddle Factors
# ============================================================================

fn compute_twiddle_factors(n: i64, inverse: bool) -> [(f64, f64)]:
    var factors = []
    var k = 0
    val sign = if inverse: 1.0 else: -1.0
    while k < n / 2:
        val angle = sign * 2.0 * math_pi() * k as f64 / n as f64
        val twiddle = complex_exp(angle)
        factors = array_push(factors, twiddle)
        k = k + 1
    factors

# ============================================================================
# Zero Padding
# ============================================================================

fn zero_pad_to_power_of_2(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    val target = next_power_of_2(n)
    var result = data
    var i = n
    while i < target:
        result = array_push(result, (0.0, 0.0))
        i = i + 1
    result

fn zero_pad_to_size(data: [(f64, f64)], target_size: i64) -> [(f64, f64)]:
    val n = array_len(data)
    var result = data
    var i = n
    while i < target_size:
        result = array_push(result, (0.0, 0.0))
        i = i + 1
    result

# ============================================================================
# Windowing Functions
# ============================================================================

fn hamming_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    while i < n:
        val w = 0.54 - 0.46 * math_cos(2.0 * math_pi() * i as f64 / (n - 1) as f64)
        window = array_push(window, w)
        i = i + 1
    window

fn hanning_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    while i < n:
        val w = 0.5 * (1.0 - math_cos(2.0 * math_pi() * i as f64 / (n - 1) as f64))
        window = array_push(window, w)
        i = i + 1
    window

fn blackman_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    val a0 = 0.42
    val a1 = 0.5
    val a2 = 0.08
    while i < n:
        val t = i as f64 / (n - 1) as f64
        val w = a0 - a1 * math_cos(2.0 * math_pi() * t) + a2 * math_cos(4.0 * math_pi() * t)
        window = array_push(window, w)
        i = i + 1
    window

fn kaiser_window(n: i64, beta: f64) -> [f64]:
    # Simplified Kaiser window using approximation
    var window = []
    var i = 0
    val n_half = (n - 1) as f64 / 2.0
    while i < n:
        val x = (i as f64 - n_half) / n_half
        val arg = beta * math_sqrt(1.0 - x * x)
        # Approximation of I0(arg) using first few terms
        val w = bessel_i0_approx(arg) / bessel_i0_approx(beta)
        window = array_push(window, w)
        i = i + 1
    window

fn bessel_i0_approx(x: f64) -> f64:
    # Modified Bessel function I0 approximation
    val t = x / 3.75
    if x < 3.75:
        val y = t * t
        1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492 +
            y * (0.2659732 + y * (0.0360768 + y * 0.0045813)))))
    else:
        val y = 1.0 / t
        val exp_x = math_exp(x)
        exp_x / math_sqrt(x) * (0.39894228 + y * (0.01328592 +
            y * (0.00225319 + y * (-0.00157565 + y * (0.00916281 +
            y * (-0.02057706 + y * (0.02635537 + y * (-0.01647633 +
            y * 0.00392377))))))))

fn rectangular_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    while i < n:
        window = array_push(window, 1.0)
        i = i + 1
    window

fn triangular_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    val n_half = n as f64 / 2.0
    while i < n:
        val w = 1.0 - math_abs((i as f64 - n_half) / n_half)
        window = array_push(window, w)
        i = i + 1
    window

fn apply_window(data: [(f64, f64)], window: [f64]) -> [(f64, f64)]:
    val n = array_len(data)
    var result = []
    var i = 0
    while i < n:
        val sample = array_get(data, i)
        val w = array_get(window, i)
        val windowed = complex_scale(sample, w)
        result = array_push(result, windowed)
        i = i + 1
    result

# ============================================================================
# Utility Conversions
# ============================================================================

fn real_to_complex(real_data: [f64]) -> [(f64, f64)]:
    var result = []
    var i = 0
    val n = array_len(real_data)
    while i < n:
        val r = array_get(real_data, i)
        result = array_push(result, (r, 0.0))
        i = i + 1
    result

fn complex_to_real(complex_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(complex_data)
    while i < n:
        val c = array_get(complex_data, i)
        result = array_push(result, c.0)
        i = i + 1
    result

fn complex_to_imag(complex_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(complex_data)
    while i < n:
        val c = array_get(complex_data, i)
        result = array_push(result, c.1)
        i = i + 1
    result

# ============================================================================
# Mathematical Helpers
# ============================================================================

fn math_pi() -> f64:
    3.141592653589793

fn math_sqrt(x: f64) -> f64:
    x ** 0.5

fn math_cos(x: f64) -> f64:
    # Taylor series approximation
    var result = 1.0
    var term = 1.0
    var i = 1
    while i < 20:
        term = -term * x * x / ((2 * i - 1) as f64 * (2 * i) as f64)
        result = result + term
        i = i + 1
    result

fn math_sin(x: f64) -> f64:
    # Taylor series approximation
    var result = x
    var term = x
    var i = 1
    while i < 20:
        term = -term * x * x / ((2 * i) as f64 * (2 * i + 1) as f64)
        result = result + term
        i = i + 1
    result

fn math_atan2(y: f64, x: f64) -> f64:
    # Simplified atan2
    if x > 0.0:
        math_atan(y / x)
    else:
        if x < 0.0 and y >= 0.0:
            math_atan(y / x) + math_pi()
        else:
            if x < 0.0 and y < 0.0:
                math_atan(y / x) - math_pi()
            else:
                if x == 0.0 and y > 0.0:
                    math_pi() / 2.0
                else:
                    if x == 0.0 and y < 0.0:
                        -math_pi() / 2.0
                    else:
                        0.0

fn math_atan(x: f64) -> f64:
    # Taylor series for small x, else use identities
    if x > -0.5 and x < 0.5:
        var result = x
        var term = x
        var i = 1
        while i < 20:
            term = -term * x * x
            result = result + term / (2 * i + 1) as f64
            i = i + 1
        result
    else:
        if x > 0.0:
            math_pi() / 2.0 - math_atan(1.0 / x)
        else:
            -math_pi() / 2.0 - math_atan(1.0 / x)

fn math_exp(x: f64) -> f64:
    # Taylor series approximation
    var result = 1.0
    var term = 1.0
    var i = 1
    while i < 30:
        term = term * x / i as f64
        result = result + term
        i = i + 1
    result

fn math_log10(x: f64) -> f64:
    math_ln(x) / math_ln(10.0)

fn math_ln(x: f64) -> f64:
    # Natural log approximation using series
    if x <= 0.0:
        -1000.0  # Error value
    else:
        var y = (x - 1.0) / (x + 1.0)
        var result = 0.0
        var term = y
        var i = 0
        while i < 50:
            result = result + term / (2 * i + 1) as f64
            term = term * y * y
            i = i + 1
        2.0 * result

fn math_abs(x: f64) -> f64:
    if x < 0.0: -x else: x
