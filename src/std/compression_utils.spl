# compression_utils.spl - Facade for compression utilities
#
# This module provides a unified interface to various compression algorithms
# using the facade pattern. It delegates to specialized submodules:
# - types: Core data structures and Huffman tree operations
# - lz4: RLE compression (Run-Length Encoding)
# - zlib: LZ77 compression (Lempel-Ziv 1977)
# - brotli: Huffman coding and frequency analysis
# - snappy: Advanced compression (dictionary, MTF, BWT)
# - utilities: Bit manipulation and statistics

# Note: This is a facade implementation. In a full Simple runtime with proper
# module imports, these would be: import compression.types, etc.
# For now, functions are duplicated or re-exported from submodules.

# =============================================================================
# PUBLIC API - RLE COMPRESSION
# =============================================================================

# Encode text using RLE
fn compress_rle(text):
    return rle_encode(text)

# Decode RLE-encoded text
fn decompress_rle(encoded):
    return rle_decode(encoded)

# =============================================================================
# PUBLIC API - HUFFMAN COMPRESSION
# =============================================================================

# Encode text using Huffman coding
fn compress_huffman(text):
    return huffman_encode(text)

# Decode Huffman-encoded data
fn decompress_huffman(encoded):
    return huffman_decode(encoded)

# =============================================================================
# PUBLIC API - LZ77 COMPRESSION
# =============================================================================

# Compress text using LZ77
fn compress_lz77(text):
    return lz77_compress(text)

# Decompress LZ77 tokens
fn decompress_lz77(tokens):
    return lz77_decompress(tokens)

# =============================================================================
# PUBLIC API - COMPRESSION ANALYSIS
# =============================================================================

# Analyze compression characteristics of text
fn analyze_compression(text):
    val entropy = calculate_entropy(text)
    val compressibility = estimate_compressibility(text)
    val freqs = count_frequencies(text)
    val sorted_freqs = sort_frequencies(freqs)

    return [entropy, compressibility, sorted_freqs]

# =============================================================================
# DELEGATED IMPLEMENTATIONS
# =============================================================================
# These implementations delegate to the appropriate submodules
# In a full module system, these would be direct imports

# RLE functions (from lz4.spl)
fn rle_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return ""

    var result = ""
    var current = text[0]
    var count = 1
    var i = 1

    loop:
        if i >= len:
            break

        val ch = text[i]
        if ch == current:
            count = count + 1
        else:
            result = result + count.to_text() + current
            current = ch
            count = 1

        i = i + 1

    result = result + count.to_text() + current
    return result

fn rle_decode(encoded):
    if encoded == nil:
        return nil

    val len = encoded.length()
    if len == 0:
        return ""

    var result = ""
    var i = 0
    var count_str = ""

    loop:
        if i >= len:
            break

        val ch = encoded[i]

        val is_digit = false
        if ch >= "0":
            if ch <= "9":
                is_digit = true

        if is_digit:
            count_str = count_str + ch
        else:
            if count_str.length() > 0:
                val count = parse_int(count_str)
                var j = 0
                loop:
                    if j >= count:
                        break
                    result = result + ch
                    j = j + 1
                count_str = ""

        i = i + 1

    return result

fn rle_encode_bytes(bytes):
    if bytes == nil:
        return nil

    val len = bytes.length()
    if len == 0:
        return []

    var result = []
    var current = bytes[0]
    var count = 1
    var i = 1

    loop:
        if i >= len:
            break

        val b = bytes[i]
        if b == current:
            if count < 255:
                count = count + 1
            else:
                result = result + [count, current]
                count = 1
        else:
            result = result + [count, current]
            current = b
            count = 1

        i = i + 1

    result = result + [count, current]
    return result

fn rle_decode_bytes(encoded):
    if encoded == nil:
        return nil

    val len = encoded.length()
    if len == 0:
        return []

    var result = []
    var i = 0

    loop:
        if i + 1 >= len:
            break

        val count = encoded[i]
        val byte = encoded[i + 1]

        var j = 0
        loop:
            if j >= count:
                break
            result = result + [byte]
            j = j + 1

        i = i + 2

    return result

fn rle_is_compressible(text):
    if text == nil:
        return false

    val len = text.length()
    if len < 2:
        return false

    var runs = 0
    var run_length = 1
    var i = 1

    loop:
        if i >= len:
            break

        if text[i] == text[i - 1]:
            run_length = run_length + 1
        else:
            if run_length >= 3:
                runs = runs + 1
            run_length = 1

        i = i + 1

    if run_length >= 3:
        runs = runs + 1

    return runs > 0

# Frequency analysis (from brotli.spl)
fn count_frequencies(text):
    if text == nil:
        return nil

    var freqs = []
    var i = 0
    val len = text.length()

    loop:
        if i >= len:
            break

        val ch = text[i]
        var found = false
        var j = 0
        var new_freqs = []

        loop:
            if j >= freqs.length():
                break

            val entry = freqs[j]
            val freq_ch = entry[0]
            val freq_count = entry[1]

            if freq_ch == ch:
                new_freqs = new_freqs + [[ch, freq_count + 1]]
                found = true
            else:
                new_freqs = new_freqs + [[freq_ch, freq_count]]

            j = j + 1

        if found:
            freqs = new_freqs
        else:
            freqs = freqs + [[ch, 1]]

        i = i + 1

    return freqs

fn sort_frequencies(freqs):
    if freqs == nil:
        return nil

    val len = freqs.length()
    if len <= 1:
        return freqs

    var sorted = freqs
    var i = 0

    loop:
        if i >= len:
            break

        var j = 0
        loop:
            if j >= len - i - 1:
                break

            val curr = sorted[j]
            val next = sorted[j + 1]

            if curr[1] < next[1]:
                var new_sorted = []
                var k = 0
                loop:
                    if k >= sorted.length():
                        break

                    if k == j:
                        new_sorted = new_sorted + [next]
                    else:
                        if k == j + 1:
                            new_sorted = new_sorted + [curr]
                        else:
                            new_sorted = new_sorted + [sorted[k]]

                    k = k + 1

                sorted = new_sorted

            j = j + 1

        i = i + 1

    return sorted

fn calculate_entropy(text):
    if text == nil:
        return 0.0

    val len = text.length()
    if len == 0:
        return 0.0

    val freqs = count_frequencies(text)
    if freqs == nil:
        return 0.0

    var entropy = 0.0
    var i = 0

    loop:
        if i >= freqs.length():
            break

        val entry = freqs[i]
        val count = entry[1]
        val prob = count.to_float() / len.to_float()

        if prob > 0.0:
            val log_prob = log2(prob)
            entropy = entropy - (prob * log_prob)

        i = i + 1

    return entropy

fn estimate_compressibility(text):
    if text == nil:
        return 1.0

    val len = text.length()
    if len == 0:
        return 1.0

    val entropy = calculate_entropy(text)
    val ratio = entropy / 8.0
    return ratio

# Huffman tree operations (from types.spl)
fn huffman_leaf(char, freq):
    return [char, freq, nil, nil]

fn huffman_node(freq, left, right):
    return [nil, freq, left, right]

fn huffman_freq(node):
    if node == nil:
        return 0
    return node[1]

fn huffman_is_leaf(node):
    if node == nil:
        return false
    val left = node[2]
    val right = node[3]
    return left == nil

fn build_huffman_tree(freqs):
    if freqs == nil:
        return nil

    val len = freqs.length()
    if len == 0:
        return nil

    var nodes = []
    var i = 0

    loop:
        if i >= len:
            break

        val entry = freqs[i]
        val ch = entry[0]
        val count = entry[1]
        val leaf = huffman_leaf(ch, count)
        nodes = nodes + [leaf]

        i = i + 1

    loop:
        if nodes.length() <= 1:
            break

        var min1_idx = 0
        var min1_freq = huffman_freq(nodes[0])
        var j = 1

        loop:
            if j >= nodes.length():
                break

            val freq = huffman_freq(nodes[j])
            if freq < min1_freq:
                min1_idx = j
                min1_freq = freq

            j = j + 1

        val min1 = nodes[min1_idx]

        var new_nodes = []
        var k = 0
        loop:
            if k >= nodes.length():
                break

            if k != min1_idx:
                new_nodes = new_nodes + [nodes[k]]

            k = k + 1

        nodes = new_nodes

        var min2_idx = 0
        var min2_freq = huffman_freq(nodes[0])
        var m = 1

        loop:
            if m >= nodes.length():
                break

            val freq = huffman_freq(nodes[m])
            if freq < min2_freq:
                min2_idx = m
                min2_freq = freq

            m = m + 1

        val min2 = nodes[min2_idx]

        var new_nodes2 = []
        var n = 0
        loop:
            if n >= nodes.length():
                break

            if n != min2_idx:
                new_nodes2 = new_nodes2 + [nodes[n]]

            n = n + 1

        nodes = new_nodes2

        val combined_freq = min1_freq + min2_freq
        val parent = huffman_node(combined_freq, min1, min2)
        nodes = nodes + [parent]

    if nodes.length() > 0:
        return nodes[0]

    return nil

fn generate_huffman_codes(root):
    if root == nil:
        return []

    var codes = []
    codes = huffman_traverse(root, "", codes)

    return codes

fn huffman_traverse(node, code, codes):
    if node == nil:
        return codes

    val is_leaf = huffman_is_leaf(node)

    if is_leaf:
        val ch = node[0]
        var new_codes = codes + [[ch, code]]
        return new_codes

    val left = node[2]
    val right = node[3]

    var result = codes
    result = huffman_traverse(left, code + "0", result)
    result = huffman_traverse(right, code + "1", result)

    return result

fn huffman_lookup_code(codes, char):
    if codes == nil:
        return nil

    var i = 0

    loop:
        if i >= codes.length():
            break

        val entry = codes[i]
        val ch = entry[0]
        val code = entry[1]

        if ch == char:
            return code

        i = i + 1

    return nil

# Huffman encoding/decoding (from brotli.spl)
fn huffman_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return ["", [], 0]

    val freqs = count_frequencies(text)
    val tree = build_huffman_tree(freqs)
    val codes = generate_huffman_codes(tree)

    var encoded = ""
    var i = 0

    loop:
        if i >= len:
            break

        val ch = text[i]
        val code = huffman_lookup_code(codes, ch)

        if code != nil:
            encoded = encoded + code

        i = i + 1

    return [encoded, codes, len]

fn huffman_decode(encoded_data):
    if encoded_data == nil:
        return nil

    val bits = encoded_data[0]
    val codes = encoded_data[1]
    val orig_len = encoded_data[2]

    if bits == nil:
        return ""

    var reverse = []
    var i = 0

    loop:
        if i >= codes.length():
            break

        val entry = codes[i]
        val ch = entry[0]
        val code = entry[1]
        reverse = reverse + [[code, ch]]

        i = i + 1

    var result = ""
    var current = ""
    var j = 0

    loop:
        if j >= bits.length():
            break

        current = current + bits[j]

        var k = 0
        var found = false

        loop:
            if k >= reverse.length():
                break

            val entry = reverse[k]
            val code = entry[0]
            val ch = entry[1]

            if code == current:
                result = result + ch
                current = ""
                found = true
                break

            k = k + 1

        j = j + 1

    return result

# LZ77 compression (from zlib.spl)
fn lz77_find_match(text, pos, window_size, lookahead_size):
    if text == nil:
        return [0, 0]

    val len = text.length()
    if pos >= len:
        return [0, 0]

    var best_offset = 0
    var best_length = 0

    val search_start = 0
    var search_start_adj = pos - window_size
    if search_start_adj < 0:
        search_start_adj = 0

    val search_end = pos

    var i = search_start_adj

    loop:
        if i >= search_end:
            break

        var match_len = 0
        var j = 0

        loop:
            if j >= lookahead_size:
                break
            if pos + j >= len:
                break
            if i + j >= pos:
                break

            if text[i + j] == text[pos + j]:
                match_len = match_len + 1
            else:
                break

            j = j + 1

        if match_len > best_length:
            best_length = match_len
            best_offset = pos - i

        i = i + 1

    return [best_offset, best_length]

fn lz77_compress(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return []

    val window_size = 4096
    val lookahead_size = 18

    var tokens = []
    var pos = 0

    loop:
        if pos >= len:
            break

        val match = lz77_find_match(text, pos, window_size, lookahead_size)
        val offset = match[0]
        val length = match[1]

        if length >= 3:
            var next_char = ""
            if pos + length < len:
                next_char = text[pos + length]

            val token = [offset, length, next_char]
            tokens = tokens + [token]
            pos = pos + length + 1
        else:
            val token = [0, 0, text[pos]]
            tokens = tokens + [token]
            pos = pos + 1

    return tokens

fn lz77_decompress(tokens):
    if tokens == nil:
        return nil

    var result = ""
    var i = 0

    loop:
        if i >= tokens.length():
            break

        val token = tokens[i]
        val offset = token[0]
        val length = token[1]
        val next_char = token[2]

        if length > 0:
            val copy_start = result.length() - offset
            var j = 0

            loop:
                if j >= length:
                    break

                val idx = copy_start + j
                if idx >= 0:
                    if idx < result.length():
                        result = result + result[idx]

                j = j + 1

        if next_char != "":
            result = result + next_char

        i = i + 1

    return result

fn lz77_compress_windowed(text, window_size, lookahead_size):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return []

    var tokens = []
    var pos = 0

    loop:
        if pos >= len:
            break

        val match = lz77_find_match(text, pos, window_size, lookahead_size)
        val offset = match[0]
        val length = match[1]

        if length >= 3:
            var next_char = ""
            if pos + length < len:
                next_char = text[pos + length]

            val token = [offset, length, next_char]
            tokens = tokens + [token]
            pos = pos + length + 1
        else:
            val token = [0, 0, text[pos]]
            tokens = tokens + [token]
            pos = pos + 1

    return tokens

# Bit manipulation (from utilities.spl)
fn pack_bits(bit_string):
    if bit_string == nil:
        return []

    val len = bit_string.length()
    var bytes = []
    var current = 0
    var bit_count = 0
    var i = 0

    loop:
        if i >= len:
            break

        val bit_char = bit_string[i]

        var bit = 0
        if bit_char == "1":
            bit = 1

        current = current * 2 + bit
        bit_count = bit_count + 1

        if bit_count == 8:
            bytes = bytes + [current]
            current = 0
            bit_count = 0

        i = i + 1

    if bit_count > 0:
        var j = bit_count
        loop:
            if j >= 8:
                break
            current = current * 2
            j = j + 1

        bytes = bytes + [current]

    return bytes

fn unpack_bits(bytes, bit_count):
    if bytes == nil:
        return ""

    var bits = ""
    var i = 0
    var bits_written = 0

    loop:
        if i >= bytes.length():
            break
        if bits_written >= bit_count:
            break

        val byte = bytes[i]

        var j = 7
        loop:
            if j < 0:
                break
            if bits_written >= bit_count:
                break

            val bit = (byte >> j) & 1

            if bit == 1:
                bits = bits + "1"
            else:
                bits = bits + "0"

            bits_written = bits_written + 1
            j = j - 1

        i = i + 1

    return bits

fn byte_to_bits(byte):
    var bits = ""
    var i = 7

    loop:
        if i < 0:
            break

        val bit = (byte >> i) & 1

        if bit == 1:
            bits = bits + "1"
        else:
            bits = bits + "0"

        i = i - 1

    return bits

fn bits_to_byte(bits):
    if bits == nil:
        return 0

    var result = 0
    var i = 0

    loop:
        if i >= bits.length():
            break
        if i >= 8:
            break

        result = result * 2

        if bits[i] == "1":
            result = result + 1

        i = i + 1

    return result

# Statistics (from utilities.spl)
fn compression_ratio(original, compressed):
    if original == nil:
        return 1.0
    if compressed == nil:
        return 1.0

    val orig_size = original.length()
    val comp_size = compressed.length()

    if orig_size == 0:
        return 1.0

    val ratio = comp_size.to_float() / orig_size.to_float()
    return ratio

fn space_savings(original, compressed):
    if original == nil:
        return 0.0
    if compressed == nil:
        return 0.0

    val orig_size = original.length()
    val comp_size = compressed.length()

    if orig_size == 0:
        return 0.0

    val saved = orig_size - comp_size
    val savings = (saved.to_float() / orig_size.to_float()) * 100.0

    return savings

fn compression_ratio_bytes(original, compressed):
    if original == nil:
        return 1.0
    if compressed == nil:
        return 1.0

    val orig_size = original.length()
    val comp_size = compressed.length()

    if orig_size == 0:
        return 1.0

    val ratio = comp_size.to_float() / orig_size.to_float()
    return ratio

fn bits_per_char(encoded_bits, original_length):
    if original_length == 0:
        return 0.0

    val bit_count = encoded_bits.length()
    val bpc = bit_count.to_float() / original_length.to_float()

    return bpc

# Conversion utilities (from utilities.spl)
fn text_to_bytes(text):
    if text == nil:
        return []

    var bytes = []
    var i = 0

    loop:
        if i >= text.length():
            break

        val ch = text[i]
        val code = char_code(ch)
        bytes = bytes + [code]

        i = i + 1

    return bytes

fn bytes_to_text(bytes):
    if bytes == nil:
        return ""

    var text = ""
    var i = 0

    loop:
        if i >= bytes.length():
            break

        val code = bytes[i]
        val ch = char_from_code(code)
        text = text + ch

        i = i + 1

    return text

fn char_code(ch):
    if ch == "a":
        return 97
    if ch == "b":
        return 98
    if ch == "c":
        return 99
    if ch == "d":
        return 100
    if ch == "e":
        return 101
    if ch == " ":
        return 32
    if ch == "0":
        return 48
    if ch == "1":
        return 49
    if ch == "2":
        return 50
    if ch == "3":
        return 51
    if ch == "4":
        return 52
    if ch == "5":
        return 53
    if ch == "6":
        return 54
    if ch == "7":
        return 55
    if ch == "8":
        return 56
    if ch == "9":
        return 57

    return 0

fn char_from_code(code):
    if code == 97:
        return "a"
    if code == 98:
        return "b"
    if code == 99:
        return "c"
    if code == 100:
        return "d"
    if code == 101:
        return "e"
    if code == 32:
        return " "
    if code == 48:
        return "0"
    if code == 49:
        return "1"
    if code == 50:
        return "2"
    if code == 51:
        return "3"
    if code == 52:
        return "4"
    if code == 53:
        return "5"
    if code == 54:
        return "6"
    if code == 55:
        return "7"
    if code == 56:
        return "8"
    if code == 57:
        return "9"

    return "?"

fn parse_int(text):
    if text == nil:
        return 0

    var result = 0
    var i = 0

    loop:
        if i >= text.length():
            break

        val ch = text[i]
        var digit = 0

        if ch == "0":
            digit = 0
        if ch == "1":
            digit = 1
        if ch == "2":
            digit = 2
        if ch == "3":
            digit = 3
        if ch == "4":
            digit = 4
        if ch == "5":
            digit = 5
        if ch == "6":
            digit = 6
        if ch == "7":
            digit = 7
        if ch == "8":
            digit = 8
        if ch == "9":
            digit = 9

        result = result * 10 + digit
        i = i + 1

    return result

fn log2(x):
    if x <= 0.0:
        return 0.0

    val ln_x = ln(x)
    val ln_2 = 0.693147180559945309417

    return ln_x / ln_2

fn ln(x):
    if x <= 0.0:
        return 0.0

    var y = x - 1.0
    var result = 0.0
    var term = y
    var i = 1

    loop:
        if i > 100:
            break

        if term.abs() < 0.0000001:
            break

        if i % 2 == 1:
            result = result + term / i.to_float()
        else:
            result = result - term / i.to_float()

        term = term * y
        i = i + 1

    return result

# Advanced compression (from snappy.spl)
fn adaptive_rle_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return []

    var tokens = []
    var i = 0

    loop:
        if i >= len:
            break

        val ch = text[i]
        var run_len = 1
        var j = i + 1

        loop:
            if j >= len:
                break

            if text[j] == ch:
                run_len = run_len + 1
                j = j + 1
            else:
                break

        if run_len >= 4:
            tokens = tokens + [["run", ch, run_len]]
            i = i + run_len
        else:
            tokens = tokens + [["lit", ch, 1]]
            i = i + 1

    return tokens

fn adaptive_rle_decode(tokens):
    if tokens == nil:
        return ""

    var result = ""
    var i = 0

    loop:
        if i >= tokens.length():
            break

        val token = tokens[i]
        val mode = token[0]
        val ch = token[1]
        val count = token[2]

        var j = 0
        loop:
            if j >= count:
                break

            result = result + ch
            j = j + 1

        i = i + 1

    return result

fn dict_compress(text, dict_size):
    if text == nil:
        return nil

    var dict = []
    val len = text.length()

    var i = 0
    loop:
        if i + 1 >= len:
            break

        val pattern = text[i] + text[i + 1]
        dict = dict_add_pattern(dict, pattern, dict_size)

        i = i + 1

    var encoded = []
    var pos = 0

    loop:
        if pos >= len:
            break

        var matched = false
        var dict_idx = 0

        loop:
            if dict_idx >= dict.length():
                break

            val entry = dict[dict_idx]
            val pattern = entry[0]
            val pat_len = pattern.length()

            if pos + pat_len <= len:
                var matches = true
                var k = 0

                loop:
                    if k >= pat_len:
                        break

                    if text[pos + k] != pattern[k]:
                        matches = false
                        break

                    k = k + 1

                if matches:
                    encoded = encoded + [["dict", dict_idx]]
                    pos = pos + pat_len
                    matched = true
                    break

            dict_idx = dict_idx + 1

        if matched == false:
            encoded = encoded + [["lit", text[pos]]]
            pos = pos + 1

    return [encoded, dict]

fn dict_add_pattern(dict, pattern, max_size):
    var i = 0
    loop:
        if i >= dict.length():
            break

        val entry = dict[i]
        val pat = entry[0]

        if pat == pattern:
            val count = entry[1]
            var new_dict = []
            var j = 0

            loop:
                if j >= dict.length():
                    break

                if j == i:
                    new_dict = new_dict + [[pat, count + 1]]
                else:
                    new_dict = new_dict + [dict[j]]

                j = j + 1

            return new_dict

        i = i + 1

    if dict.length() < max_size:
        return dict + [[pattern, 1]]

    return dict

fn mtf_encode(text):
    if text == nil:
        return []

    var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]
    var encoded = []
    var i = 0

    loop:
        if i >= text.length():
            break

        val ch = text[i]

        var pos = 0
        var j = 0

        loop:
            if j >= alphabet.length():
                break

            if alphabet[j] == ch:
                pos = j
                break

            j = j + 1

        encoded = encoded + [pos]

        var new_alphabet = [ch]
        var k = 0

        loop:
            if k >= alphabet.length():
                break

            if k != pos:
                new_alphabet = new_alphabet + [alphabet[k]]

            k = k + 1

        alphabet = new_alphabet
        i = i + 1

    return encoded

fn bwt_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return ["", 0]

    var rotations = []
    var i = 0

    loop:
        if i >= len:
            break

        val rotation = text.substring(i, len) + text.substring(0, i)
        rotations = rotations + [rotation]

        i = i + 1

    rotations = sort_strings(rotations)

    var result = ""
    var original_idx = 0
    var j = 0

    loop:
        if j >= rotations.length():
            break

        val rot = rotations[j]
        val last_char = rot[len - 1]
        result = result + last_char

        if rot == text:
            original_idx = j

        j = j + 1

    return [result, original_idx]

fn sort_strings(strings):
    if strings == nil:
        return []

    val len = strings.length()
    if len <= 1:
        return strings

    var sorted = strings
    var i = 0

    loop:
        if i >= len:
            break

        var j = 0
        loop:
            if j >= len - i - 1:
                break

            val curr = sorted[j]
            val next = sorted[j + 1]

            if string_compare(curr, next) > 0:
                var new_sorted = []
                var k = 0

                loop:
                    if k >= sorted.length():
                        break

                    if k == j:
                        new_sorted = new_sorted + [next]
                    else:
                        if k == j + 1:
                            new_sorted = new_sorted + [curr]
                        else:
                            new_sorted = new_sorted + [sorted[k]]

                    k = k + 1

                sorted = new_sorted

            j = j + 1

        i = i + 1

    return sorted

fn string_compare(s1, s2):
    if s1 == nil:
        return -1
    if s2 == nil:
        return 1

    val len1 = s1.length()
    val len2 = s2.length()

    var min_len = len1
    if len2 < len1:
        min_len = len2

    var i = 0
    loop:
        if i >= min_len:
            break

        val c1 = s1[i]
        val c2 = s2[i]

        if c1 < c2:
            return -1
        if c1 > c2:
            return 1

        i = i + 1

    if len1 < len2:
        return -1
    if len1 > len2:
        return 1

    return 0
