# Array Extension Methods
#
# Provides array utility functions as standalone functions.
# These complement the built-in array methods (.sort(), .reverse(), etc.).
# Pure Simple implementation - no external dependencies.
#
# Built-in methods available on arrays:
#   .push(item), .merge(other), .len(), .map(fn), .filter(fn)
#   .contains(item), .join(sep), .sort(), .reverse(), .first(), .last()
#   .index_of(item), .flatten(), .unique(), .zip(other), .enumerate()
#   .reduce(init, fn), .take(n), .drop(n)
#
# Functions in this module (standalone utilities):
# - array_position: Find index of first element matching predicate
# - array_find: Find first element matching predicate
# - array_find_or: Find first match or return default
# - array_enumerate: Enumerate with indices (standalone version)
# - array_zip: Zip two arrays (standalone version)
# - array_sort_by: Sort with custom comparator
# - array_chunk: Split array into chunks of size n
# - array_group_by: Group elements by key function
# - array_count: Count elements matching predicate
# - array_any: True if any element matches predicate
# - array_all: True if all elements match predicate
# - array_sum: Sum numeric array
# - array_max: Find maximum element
# - array_min: Find minimum element
# - array_flat_map: Map then flatten
# - array_take_while: Take elements while predicate is true
# - array_drop_while: Drop elements while predicate is true

# ============================================================================
# Search Functions
# ============================================================================

fn array_position(arr, predicate):
    """Find index of first element matching predicate. Returns -1 if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return i
        i = i + 1
    -1

fn array_find(arr, predicate):
    """Find first element matching predicate. Returns nil if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return arr[i]
        i = i + 1
    nil

fn array_find_or(arr, predicate, default_val):
    """Find first element matching predicate. Returns default_val if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return arr[i]
        i = i + 1
    default_val

# ============================================================================
# Transformation Functions
# ============================================================================

fn array_enumerate(arr):
    """Return array of (index, element) tuples."""
    var result = []
    var i = 0
    while i < arr.len():
        result.push((i, arr[i]))
        i = i + 1
    result

fn array_zip(arr1, arr2):
    """Zip two arrays into array of tuples. Truncates to shorter length."""
    var result = []
    var min_len = arr1.len()
    if arr2.len() < min_len:
        min_len = arr2.len()
    var i = 0
    while i < min_len:
        result.push((arr1[i], arr2[i]))
        i = i + 1
    result

fn array_chunk(arr, size):
    """Split array into chunks of given size. Last chunk may be smaller."""
    var result = []
    var i = 0
    while i < arr.len():
        var end_idx = i + size
        if end_idx > arr.len():
            end_idx = arr.len()
        result.push(arr[i:end_idx])
        i = i + size
    result

fn array_flat_map(arr, mapper):
    """Map each element then flatten the results."""
    var result = []
    for item in arr:
        val mapped = mapper(item)
        for sub in mapped:
            result.push(sub)
    result

fn array_take_while(arr, predicate):
    """Take elements from the start while predicate is true."""
    var result = []
    var i = 0
    while i < arr.len():
        if not predicate(arr[i]):
            return result
        result.push(arr[i])
        i = i + 1
    result

fn array_drop_while(arr, predicate):
    """Drop elements from the start while predicate is true."""
    var i = 0
    while i < arr.len():
        if not predicate(arr[i]):
            return arr[i:]
        i = i + 1
    []

# ============================================================================
# Sorting
# ============================================================================

fn array_sort_by(arr, comparator):
    """Sort array with custom comparator function.
    comparator(a, b) should return negative if a < b, 0 if equal, positive if a > b.
    Uses quicksort (O(n log n) average case)."""
    if arr.len() <= 1:
        return arr

    # Use insertion sort for small arrays (faster due to low overhead)
    if arr.len() < 10:
        var sorted = []
        for item in arr:
            var inserted = false
            var i = 0
            while i < sorted.len() and not inserted:
                if comparator(item, sorted[i]) < 0:
                    val before = sorted[0:i]
                    val after = sorted[i:]
                    var combined = before
                    combined.push(item)
                    for a in after:
                        combined.push(a)
                    sorted = combined
                    inserted = true
                i = i + 1
            if not inserted:
                sorted.push(item)
        return sorted

    # Quicksort for larger arrays
    val pivot = arr[arr.len() / 2]
    var less = []
    var equal = []
    var greater = []

    for item in arr:
        val cmp = comparator(item, pivot)
        if cmp < 0:
            less.push(item)
        elif cmp == 0:
            equal.push(item)
        else:
            greater.push(item)

    # Recursively sort and combine
    val sorted_less = array_sort_by(less, comparator)
    val sorted_greater = array_sort_by(greater, comparator)

    var result = sorted_less
    for e in equal:
        result.push(e)
    for g in sorted_greater:
        result.push(g)
    result

# ============================================================================
# Grouping
# ============================================================================

fn array_group_by(arr, key_fn):
    """Group elements by key function. Returns dict of key -> [elements]."""
    var groups = {}
    for item in arr:
        val key = key_fn(item)
        if groups.contains_key(key):
            var group = groups[key]
            group.push(item)
            groups[key] = group
        else:
            groups[key] = [item]
    groups

# ============================================================================
# Aggregation Functions
# ============================================================================

fn array_count(arr, predicate):
    """Count elements matching predicate."""
    var count = 0
    for item in arr:
        if predicate(item):
            count = count + 1
    count

fn array_any(arr, predicate):
    """True if any element matches predicate."""
    for item in arr:
        if predicate(item):
            return true
    false

fn array_all(arr, predicate):
    """True if all elements match predicate."""
    for item in arr:
        if not predicate(item):
            return false
    true

fn array_sum(arr):
    """Sum all elements in array."""
    var total = 0
    for item in arr:
        total = total + item
    total

fn array_max(arr):
    """Find maximum element. Returns nil for empty array."""
    if arr.len() == 0:
        return nil
    var best = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] > best:
            best = arr[i]
        i = i + 1
    best

fn array_min(arr):
    """Find minimum element. Returns nil for empty array."""
    if arr.len() == 0:
        return nil
    var best = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] < best:
            best = arr[i]
        i = i + 1
    best

# ============================================================================
# Creation Functions
# ============================================================================

fn array_range(start: i64, end_val: i64) -> [i64]:
    """Create array from start (inclusive) to end (exclusive)."""
    var result = []
    var i = start
    while i < end_val:
        result.push(i)
        i = i + 1
    result

fn array_repeat(item, count: i64):
    """Create array with item repeated count times."""
    var result = []
    var i = 0
    while i < count:
        result.push(item)
        i = i + 1
    result

# ============================================================================
# Additional Array Operations
# ============================================================================

fn array_append_all(arr1, arr2):
    """Append all elements from arr2 to arr1. Returns new array."""
    var result = []
    for item in arr1:
        result.push(item)
    for item in arr2:
        result.push(item)
    result

fn array_partition(arr, predicate):
    """Partition array into two arrays based on predicate.
    Returns (matching, non_matching) as tuple."""
    var matching = []
    var non_matching = []
    for item in arr:
        if predicate(item):
            matching.push(item)
        else:
            non_matching.push(item)
    (matching, non_matching)

fn array_concat(arrays):
    """Concatenate multiple arrays into one."""
    var result = []
    for arr in arrays:
        for item in arr:
            result.push(item)
    result

fn array_flatten(nested_arr):
    """Flatten one level of nesting in an array."""
    var result = []
    for arr in nested_arr:
        for item in arr:
            result.push(item)
    result

fn array_uniq(arr):
    """Remove duplicates from array (alias for .unique())."""
    var seen = {}
    var result = []
    for item in arr:
        val key = "{item}"
        if not seen.contains_key(key):
            seen[key] = true
            result.push(item)
    result

fn array_compact(arr):
    """Remove nil values from array."""
    var result = []
    for item in arr:
        if item != nil:
            result.push(item)
    result

fn array_reverse(arr):
    """Reverse an array."""
    var result = []
    var i = arr.len() - 1
    while i >= 0:
        result.push(arr[i])
        i = i - 1
    result
