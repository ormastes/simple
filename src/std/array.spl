# Array Extension Methods
#
# Provides array utility functions as standalone functions.
# These complement the built-in array methods (.sort(), .reverse(), etc.).
# Pure Simple implementation - no external dependencies.
#
# Built-in methods available on arrays:
#   .push(item), .merge(other), .len(), .map(fn), .filter(fn)
#   .contains(item), .join(sep), .sort(), .reverse(), .first(), .last()
#   .index_of(item), .flatten(), .unique(), .zip(other), .enumerate()
#   .reduce(init, fn), .take(n), .drop(n)
#
# Functions in this module (standalone utilities):
# - array_position: Find index of first element matching predicate
# - array_find: Find first element matching predicate
# - array_find_or: Find first match or return default
# - array_enumerate: Enumerate with indices (standalone version)
# - array_zip: Zip two arrays (standalone version)
# - array_sort_by: Sort with custom comparator
# - array_chunk: Split array into chunks of size n
# - array_group_by: Group elements by key function
# - array_count: Count elements matching predicate
# - array_any: True if any element matches predicate
# - array_all: True if all elements match predicate
# - array_sum: Sum numeric array
# - array_max: Find maximum element
# - array_min: Find minimum element
# - array_flat_map: Map then flatten
# - array_take_while: Take elements while predicate is true
# - array_drop_while: Drop elements while predicate is true

# ============================================================================
# Search Functions
# ============================================================================

fn array_position(arr, predicate):
    """Find index of first element matching predicate. Returns -1 if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return i
        i = i + 1
    -1

fn array_find(arr, predicate):
    """Find first element matching predicate. Returns nil if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return arr[i]
        i = i + 1
    nil

fn array_find_or(arr, predicate, default_val):
    """Find first element matching predicate. Returns default_val if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return arr[i]
        i = i + 1
    default_val

# ============================================================================
# Transformation Functions
# ============================================================================

fn array_enumerate(arr):
    """Return array of (index, element) tuples."""
    var result = []
    var i = 0
    while i < arr.len():
        result.push((i, arr[i]))
        i = i + 1
    result

fn array_zip(arr1, arr2):
    """Zip two arrays into array of tuples. Truncates to shorter length."""
    var result = []
    var min_len = arr1.len()
    if arr2.len() < min_len:
        min_len = arr2.len()
    var i = 0
    while i < min_len:
        result.push((arr1[i], arr2[i]))
        i = i + 1
    result

fn array_chunk(arr, size):
    """Split array into chunks of given size. Last chunk may be smaller."""
    var result = []
    var i = 0
    while i < arr.len():
        var end_idx = i + size
        if end_idx > arr.len():
            end_idx = arr.len()
        result.push(arr[i:end_idx])
        i = i + size
    result

fn array_flat_map(arr, mapper):
    """Map each element then flatten the results."""
    var result = []
    for item in arr:
        val mapped = mapper(item)
        for sub in mapped:
            result.push(sub)
    result

fn array_take_while(arr, predicate):
    """Take elements from the start while predicate is true."""
    var result = []
    var i = 0
    while i < arr.len():
        if not predicate(arr[i]):
            return result
        result.push(arr[i])
        i = i + 1
    result

fn array_drop_while(arr, predicate):
    """Drop elements from the start while predicate is true."""
    var i = 0
    while i < arr.len():
        if not predicate(arr[i]):
            return arr[i:]
        i = i + 1
    []

# ============================================================================
# Sorting
# ============================================================================

fn array_sort_by(arr, comparator):
    """Sort array with custom comparator function.
    comparator(a, b) should return negative if a < b, 0 if equal, positive if a > b.
    Uses insertion sort (stable, O(n^2))."""
    var sorted = []
    for item in arr:
        var inserted = false
        var i = 0
        while i < sorted.len() and not inserted:
            if comparator(item, sorted[i]) < 0:
                # Avoid chained .merge() (BUG-14 workaround)
                val before = sorted[0:i]
                val after = sorted[i:]
                var combined = before
                combined.push(item)
                for a in after:
                    combined.push(a)
                sorted = combined
                inserted = true
            i = i + 1
        if not inserted:
            sorted.push(item)
    sorted

# ============================================================================
# Grouping
# ============================================================================

fn array_group_by(arr, key_fn):
    """Group elements by key function. Returns dict of key -> [elements]."""
    var groups = {}
    for item in arr:
        val key = key_fn(item)
        if groups.contains_key(key):
            var group = groups[key]
            group.push(item)
            groups[key] = group
        else:
            groups[key] = [item]
    groups

# ============================================================================
# Aggregation Functions
# ============================================================================

fn array_count(arr, predicate):
    """Count elements matching predicate."""
    var count = 0
    for item in arr:
        if predicate(item):
            count = count + 1
    count

fn array_any(arr, predicate):
    """True if any element matches predicate."""
    for item in arr:
        if predicate(item):
            return true
    false

fn array_all(arr, predicate):
    """True if all elements match predicate."""
    for item in arr:
        if not predicate(item):
            return false
    true

fn array_sum(arr):
    """Sum all elements in array."""
    var total = 0
    for item in arr:
        total = total + item
    total

fn array_max(arr):
    """Find maximum element. Returns nil for empty array."""
    if arr.len() == 0:
        return nil
    var best = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] > best:
            best = arr[i]
        i = i + 1
    best

fn array_min(arr):
    """Find minimum element. Returns nil for empty array."""
    if arr.len() == 0:
        return nil
    var best = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] < best:
            best = arr[i]
        i = i + 1
    best

# ============================================================================
# Creation Functions
# ============================================================================

fn array_range(start: i64, end_val: i64) -> [i64]:
    """Create array from start (inclusive) to end (exclusive)."""
    var result = []
    var i = start
    while i < end_val:
        result.push(i)
        i = i + 1
    result

fn array_repeat(item, count: i64):
    """Create array with item repeated count times."""
    var result = []
    var i = 0
    while i < count:
        result.push(item)
        i = i + 1
    result
