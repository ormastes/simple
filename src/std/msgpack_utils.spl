# MessagePack Binary Serialization Module - Facade
#
# Provides comprehensive MessagePack binary serialization/deserialization
# utilities following the MessagePack specification.
#
# FEATURES:
# - All MessagePack format types (fixint, fixmap, fixarray, fixstr, etc.)
# - Encoding: pack values to binary MessagePack format
# - Decoding: unpack MessagePack binary to values
# - Type detection: automatic type selection for encoding
# - Integer optimization: smallest representation selection
# - String encoding: UTF-8 string packing
# - Binary data: raw binary packing
# - Arrays: variable-length array encoding
# - Maps: key-value pair encoding
# - Extension types: custom type extension support
# - Timestamp extension: MessagePack timestamp format
# - Utility functions: size calculation, format detection
#
# IMPLEMENTATION NOTES:
# - Pure Simple implementation (no FFI)
# - No generics (uses concrete types)
# - No try/catch (uses Option/nil pattern)
# - No chained methods (uses intermediate variables)
# - Value representation: (type, data) tuples

import msgpack.types
import msgpack.encode
import msgpack.pack
import msgpack.decode
import msgpack.unpack
import msgpack.utilities

# Re-export constants
val MSGPACK_FIXINT_MIN = types.MSGPACK_FIXINT_MIN
val MSGPACK_FIXINT_MAX = types.MSGPACK_FIXINT_MAX
val MSGPACK_NEGFIXINT_MIN = types.MSGPACK_NEGFIXINT_MIN
val MSGPACK_NEGFIXINT_MAX = types.MSGPACK_NEGFIXINT_MAX
val MSGPACK_FIXMAP_PREFIX = types.MSGPACK_FIXMAP_PREFIX
val MSGPACK_FIXMAP_MAX = types.MSGPACK_FIXMAP_MAX
val MSGPACK_FIXARRAY_PREFIX = types.MSGPACK_FIXARRAY_PREFIX
val MSGPACK_FIXARRAY_MAX = types.MSGPACK_FIXARRAY_MAX
val MSGPACK_FIXSTR_PREFIX = types.MSGPACK_FIXSTR_PREFIX
val MSGPACK_FIXSTR_MAX = types.MSGPACK_FIXSTR_MAX
val MSGPACK_NIL = types.MSGPACK_NIL
val MSGPACK_FALSE = types.MSGPACK_FALSE
val MSGPACK_TRUE = types.MSGPACK_TRUE
val MSGPACK_BIN8 = types.MSGPACK_BIN8
val MSGPACK_BIN16 = types.MSGPACK_BIN16
val MSGPACK_BIN32 = types.MSGPACK_BIN32
val MSGPACK_EXT8 = types.MSGPACK_EXT8
val MSGPACK_EXT16 = types.MSGPACK_EXT16
val MSGPACK_EXT32 = types.MSGPACK_EXT32
val MSGPACK_FIXEXT1 = types.MSGPACK_FIXEXT1
val MSGPACK_FIXEXT2 = types.MSGPACK_FIXEXT2
val MSGPACK_FIXEXT4 = types.MSGPACK_FIXEXT4
val MSGPACK_FIXEXT8 = types.MSGPACK_FIXEXT8
val MSGPACK_FIXEXT16 = types.MSGPACK_FIXEXT16
val MSGPACK_FLOAT32 = types.MSGPACK_FLOAT32
val MSGPACK_FLOAT64 = types.MSGPACK_FLOAT64
val MSGPACK_UINT8 = types.MSGPACK_UINT8
val MSGPACK_UINT16 = types.MSGPACK_UINT16
val MSGPACK_UINT32 = types.MSGPACK_UINT32
val MSGPACK_UINT64 = types.MSGPACK_UINT64
val MSGPACK_INT8 = types.MSGPACK_INT8
val MSGPACK_INT16 = types.MSGPACK_INT16
val MSGPACK_INT32 = types.MSGPACK_INT32
val MSGPACK_INT64 = types.MSGPACK_INT64
val MSGPACK_STR8 = types.MSGPACK_STR8
val MSGPACK_STR16 = types.MSGPACK_STR16
val MSGPACK_STR32 = types.MSGPACK_STR32
val MSGPACK_ARRAY16 = types.MSGPACK_ARRAY16
val MSGPACK_ARRAY32 = types.MSGPACK_ARRAY32
val MSGPACK_MAP16 = types.MSGPACK_MAP16
val MSGPACK_MAP32 = types.MSGPACK_MAP32
val MSGPACK_EXT_TIMESTAMP = types.MSGPACK_EXT_TIMESTAMP
val MSGPACK_TYPE_NIL = types.MSGPACK_TYPE_NIL
val MSGPACK_TYPE_BOOL = types.MSGPACK_TYPE_BOOL
val MSGPACK_TYPE_INT = types.MSGPACK_TYPE_INT
val MSGPACK_TYPE_FLOAT = types.MSGPACK_TYPE_FLOAT
val MSGPACK_TYPE_STRING = types.MSGPACK_TYPE_STRING
val MSGPACK_TYPE_BINARY = types.MSGPACK_TYPE_BINARY
val MSGPACK_TYPE_ARRAY = types.MSGPACK_TYPE_ARRAY
val MSGPACK_TYPE_MAP = types.MSGPACK_TYPE_MAP
val MSGPACK_TYPE_EXT = types.MSGPACK_TYPE_EXT

# Re-export byte manipulation functions
fn to_byte(n: i64) -> i64:
    types.to_byte(n)

fn byte_to_unsigned(b: i64) -> i64:
    types.byte_to_unsigned(b)

fn bytes_to_i16(b1: i64, b2: i64) -> i64:
    types.bytes_to_i16(b1, b2)

fn bytes_to_i32(b1: i64, b2: i64, b3: i64, b4: i64) -> i64:
    types.bytes_to_i32(b1, b2, b3, b4)

fn bytes_to_i64(b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64, b7: i64, b8: i64) -> i64:
    types.bytes_to_i64(b1, b2, b3, b4, b5, b6, b7, b8)

fn i16_to_bytes(n: i64):
    types.i16_to_bytes(n)

fn i32_to_bytes(n: i64):
    types.i32_to_bytes(n)

fn i64_to_bytes(n: i64):
    types.i64_to_bytes(n)

fn f32_to_bytes(f: f64):
    types.f32_to_bytes(f)

fn bytes_to_f32(b1: i64, b2: i64, b3: i64, b4: i64) -> f64:
    types.bytes_to_f32(b1, b2, b3, b4)

fn f64_to_bytes(f: f64):
    types.f64_to_bytes(f)

fn bytes_to_f64(b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64, b7: i64, b8: i64) -> f64:
    types.bytes_to_f64(b1, b2, b3, b4, b5, b6, b7, b8)

fn float_to_bits_32(f: f64) -> i64:
    types.float_to_bits_32(f)

fn bits_to_float_32(bits: i64) -> f64:
    types.bits_to_float_32(bits)

fn float_to_bits_64(f: f64) -> i64:
    types.float_to_bits_64(f)

fn bits_to_float_64(bits: i64) -> f64:
    types.bits_to_float_64(bits)

# Re-export format detection
fn msgpack_detect_format(byte: i64) -> text:
    types.msgpack_detect_format(byte)

fn is_fixint(byte: i64) -> bool:
    types.is_fixint(byte)

fn is_negfixint(byte: i64) -> bool:
    types.is_negfixint(byte)

fn is_fixmap(byte: i64) -> bool:
    types.is_fixmap(byte)

fn is_fixarray(byte: i64) -> bool:
    types.is_fixarray(byte)

fn is_fixstr(byte: i64) -> bool:
    types.is_fixstr(byte)

# Re-export encoding functions
fn msgpack_encode_uint(n: i64):
    encode.msgpack_encode_uint(n)

fn msgpack_encode_int(n: i64):
    encode.msgpack_encode_int(n)

fn msgpack_encode_uint8(n: i64):
    encode.msgpack_encode_uint8(n)

fn msgpack_encode_uint16(n: i64):
    encode.msgpack_encode_uint16(n)

fn msgpack_encode_uint32(n: i64):
    encode.msgpack_encode_uint32(n)

fn msgpack_encode_uint64(n: i64):
    encode.msgpack_encode_uint64(n)

fn msgpack_encode_int8(n: i64):
    encode.msgpack_encode_int8(n)

fn msgpack_encode_int16(n: i64):
    encode.msgpack_encode_int16(n)

fn msgpack_encode_int32(n: i64):
    encode.msgpack_encode_int32(n)

fn msgpack_encode_int64(n: i64):
    encode.msgpack_encode_int64(n)

fn msgpack_encode_float32(f: f64):
    encode.msgpack_encode_float32(f)

fn msgpack_encode_float64(f: f64):
    encode.msgpack_encode_float64(f)

fn msgpack_encode_float(f: f64):
    encode.msgpack_encode_float(f)

fn msgpack_encode_nil():
    encode.msgpack_encode_nil()

fn msgpack_encode_bool(b: bool):
    encode.msgpack_encode_bool(b)

fn msgpack_encode_string(s: text):
    encode.msgpack_encode_string(s)

fn msgpack_encode_binary(data):
    encode.msgpack_encode_binary(data)

# Re-export pack functions
fn msgpack_encode_array(arr):
    pack.msgpack_encode_array(arr)

fn msgpack_encode_map(map):
    pack.msgpack_encode_map(map)

fn msgpack_encode_ext(type_id: i64, data):
    pack.msgpack_encode_ext(type_id, data)

fn msgpack_encode_timestamp(seconds: i64, nanoseconds: i64):
    pack.msgpack_encode_timestamp(seconds, nanoseconds)

# Re-export decode functions
fn msgpack_decode_fixint(byte: i64) -> i64:
    decode.msgpack_decode_fixint(byte)

fn msgpack_decode_negfixint(byte: i64) -> i64:
    decode.msgpack_decode_negfixint(byte)

fn msgpack_decode_fixmap_size(byte: i64) -> i64:
    decode.msgpack_decode_fixmap_size(byte)

fn msgpack_decode_fixarray_size(byte: i64) -> i64:
    decode.msgpack_decode_fixarray_size(byte)

fn msgpack_decode_fixstr_size(byte: i64) -> i64:
    decode.msgpack_decode_fixstr_size(byte)

# Re-export unpack functions
fn msgpack_encode_value(value):
    unpack.msgpack_encode_value(value)

fn get_value_type(value) -> text:
    unpack.get_value_type(value)

fn get_bool_value(value) -> bool:
    unpack.get_bool_value(value)

fn get_int_value(value) -> i64:
    unpack.get_int_value(value)

fn get_float_value(value) -> f64:
    unpack.get_float_value(value)

fn get_string_value(value) -> text:
    unpack.get_string_value(value)

fn get_binary_value(value):
    unpack.get_binary_value(value)

fn get_array_value(value):
    unpack.get_array_value(value)

fn get_map_value(value):
    unpack.get_map_value(value)

fn get_ext_value(value):
    unpack.get_ext_value(value)

# Re-export utility functions
fn msgpack_size_int(n: i64) -> i64:
    utilities.msgpack_size_int(n)

fn msgpack_size_float(f: f64) -> i64:
    utilities.msgpack_size_float(f)

fn msgpack_size_string(s: text) -> i64:
    utilities.msgpack_size_string(s)

fn msgpack_size_binary(data) -> i64:
    utilities.msgpack_size_binary(data)

fn msgpack_size_array(arr) -> i64:
    utilities.msgpack_size_array(arr)

fn msgpack_size_map(map) -> i64:
    utilities.msgpack_size_map(map)

fn msgpack_size_ext(type_id: i64, data) -> i64:
    utilities.msgpack_size_ext(type_id, data)

fn msgpack_size_value(value) -> i64:
    utilities.msgpack_size_value(value)

fn msgpack_validate_format(byte: i64) -> bool:
    utilities.msgpack_validate_format(byte)

fn msgpack_is_valid(bytes) -> bool:
    utilities.msgpack_is_valid(bytes)

# Re-export helper functions from encode module
fn utf8_byte_length(s: text) -> i64:
    encode.utf8_byte_length(s)

fn get_char_at(s: text, index: i64) -> text:
    encode.get_char_at(s, index)

fn string_length(s: text) -> i64:
    encode.string_length(s)

fn string_to_bytes(s: text):
    encode.string_to_bytes(s)

fn char_to_byte(c: text) -> i64:
    encode.char_to_byte(c)

fn list_length(lst) -> i64:
    encode.list_length(lst)

# Re-export map helpers from pack module
fn map_keys(map):
    pack.map_keys(map)

fn map_get(map, key):
    pack.map_get(map, key)
