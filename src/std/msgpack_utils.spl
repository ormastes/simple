# MessagePack Binary Serialization Module
#
# Provides comprehensive MessagePack binary serialization/deserialization
# utilities following the MessagePack specification.
#
# FEATURES:
# - All MessagePack format types (fixint, fixmap, fixarray, fixstr, etc.)
# - Encoding: pack values to binary MessagePack format
# - Decoding: unpack MessagePack binary to values
# - Type detection: automatic type selection for encoding
# - Integer optimization: smallest representation selection
# - String encoding: UTF-8 string packing
# - Binary data: raw binary packing
# - Arrays: variable-length array encoding
# - Maps: key-value pair encoding
# - Extension types: custom type extension support
# - Timestamp extension: MessagePack timestamp format
# - Utility functions: size calculation, format detection
#
# IMPLEMENTATION NOTES:
# - Pure Simple implementation (no FFI)
# - No generics (uses concrete types)
# - No try/catch (uses Option/nil pattern)
# - No chained methods (uses intermediate variables)
# - Value representation: (type, data) tuples

# ============================================================================
# MSGPACK FORMAT CONSTANTS
# ============================================================================

# Positive fixint: 0x00 - 0x7f (0-127)
val MSGPACK_FIXINT_MIN = 0
val MSGPACK_FIXINT_MAX = 127

# Negative fixint: 0xe0 - 0xff (-32 to -1)
val MSGPACK_NEGFIXINT_MIN = 224
val MSGPACK_NEGFIXINT_MAX = 255

# Fixmap: 0x80 - 0x8f (0-15 pairs)
val MSGPACK_FIXMAP_PREFIX = 128
val MSGPACK_FIXMAP_MAX = 15

# Fixarray: 0x90 - 0x9f (0-15 elements)
val MSGPACK_FIXARRAY_PREFIX = 144
val MSGPACK_FIXARRAY_MAX = 15

# Fixstr: 0xa0 - 0xbf (0-31 bytes)
val MSGPACK_FIXSTR_PREFIX = 160
val MSGPACK_FIXSTR_MAX = 31

# Nil and Boolean
val MSGPACK_NIL = 192
val MSGPACK_FALSE = 194
val MSGPACK_TRUE = 195

# Binary formats
val MSGPACK_BIN8 = 196
val MSGPACK_BIN16 = 197
val MSGPACK_BIN32 = 198

# Extension formats
val MSGPACK_EXT8 = 199
val MSGPACK_EXT16 = 200
val MSGPACK_EXT32 = 201
val MSGPACK_FIXEXT1 = 212
val MSGPACK_FIXEXT2 = 213
val MSGPACK_FIXEXT4 = 214
val MSGPACK_FIXEXT8 = 215
val MSGPACK_FIXEXT16 = 216

# Float formats
val MSGPACK_FLOAT32 = 202
val MSGPACK_FLOAT64 = 203

# Unsigned integer formats
val MSGPACK_UINT8 = 204
val MSGPACK_UINT16 = 205
val MSGPACK_UINT32 = 206
val MSGPACK_UINT64 = 207

# Signed integer formats
val MSGPACK_INT8 = 208
val MSGPACK_INT16 = 209
val MSGPACK_INT32 = 210
val MSGPACK_INT64 = 211

# String formats
val MSGPACK_STR8 = 217
val MSGPACK_STR16 = 218
val MSGPACK_STR32 = 219

# Array formats
val MSGPACK_ARRAY16 = 220
val MSGPACK_ARRAY32 = 221

# Map formats
val MSGPACK_MAP16 = 222
val MSGPACK_MAP32 = 223

# Extension type IDs
val MSGPACK_EXT_TIMESTAMP = -1

# ============================================================================
# VALUE TYPE REPRESENTATION
# ============================================================================

# MsgPackValue type constants
val MSGPACK_TYPE_NIL = "nil"
val MSGPACK_TYPE_BOOL = "bool"
val MSGPACK_TYPE_INT = "int"
val MSGPACK_TYPE_FLOAT = "float"
val MSGPACK_TYPE_STRING = "string"
val MSGPACK_TYPE_BINARY = "binary"
val MSGPACK_TYPE_ARRAY = "array"
val MSGPACK_TYPE_MAP = "map"
val MSGPACK_TYPE_EXT = "ext"

# ============================================================================
# BYTE MANIPULATION UTILITIES
# ============================================================================

# Convert integer to byte (0-255)
fn to_byte(n: i64) -> i64:
    n & 255

# Convert signed byte to unsigned (for display)
fn byte_to_unsigned(b: i64) -> i64:
    if b < 0:
        b + 256
    else:
        b

# Combine two bytes into i16 (big-endian)
fn bytes_to_i16(b1: i64, b2: i64) -> i64:
    val high = byte_to_unsigned(b1)
    val low = byte_to_unsigned(b2)
    var result = high * 256
    result = result + low
    result

# Combine four bytes into i32 (big-endian)
fn bytes_to_i32(b1: i64, b2: i64, b3: i64, b4: i64) -> i64:
    val high = bytes_to_i16(b1, b2)
    val low = bytes_to_i16(b3, b4)
    var result = high * 65536
    result = result + low
    result

# Combine eight bytes into i64 (big-endian)
fn bytes_to_i64(b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64, b7: i64, b8: i64) -> i64:
    val high = bytes_to_i32(b1, b2, b3, b4)
    val low = bytes_to_i32(b5, b6, b7, b8)
    var result = high * 4294967296
    result = result + low
    result

# Split i16 into two bytes (big-endian)
fn i16_to_bytes(n: i64):
    val b1 = to_byte(n / 256)
    val b2 = to_byte(n % 256)
    (b1, b2)

# Split i32 into four bytes (big-endian)
fn i32_to_bytes(n: i64):
    val high = n / 65536
    val low = n % 65536
    val h_bytes = i16_to_bytes(high)
    val l_bytes = i16_to_bytes(low)
    (h_bytes[0], h_bytes[1], l_bytes[0], l_bytes[1])

# Split i64 into eight bytes (big-endian)
fn i64_to_bytes(n: i64):
    val high = n / 4294967296
    val low = n % 4294967296
    val h_bytes = i32_to_bytes(high)
    val l_bytes = i32_to_bytes(low)
    (h_bytes[0], h_bytes[1], h_bytes[2], h_bytes[3], l_bytes[0], l_bytes[1], l_bytes[2], l_bytes[3])

# ============================================================================
# FLOAT ENCODING/DECODING UTILITIES
# ============================================================================

# Encode f32 to 4 bytes (IEEE 754 single precision)
fn f32_to_bytes(f: f64):
    # Simplified: convert to bits representation
    # In real implementation, would need proper IEEE 754 encoding
    val bits = float_to_bits_32(f)
    i32_to_bytes(bits)

# Decode 4 bytes to f32 (IEEE 754 single precision)
fn bytes_to_f32(b1: i64, b2: i64, b3: i64, b4: i64) -> f64:
    val bits = bytes_to_i32(b1, b2, b3, b4)
    bits_to_float_32(bits)

# Encode f64 to 8 bytes (IEEE 754 double precision)
fn f64_to_bytes(f: f64):
    val bits = float_to_bits_64(f)
    i64_to_bytes(bits)

# Decode 8 bytes to f64 (IEEE 754 double precision)
fn bytes_to_f64(b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64, b7: i64, b8: i64) -> f64:
    val bits = bytes_to_i64(b1, b2, b3, b4, b5, b6, b7, b8)
    bits_to_float_64(bits)

# Helper: float to bits (32-bit)
fn float_to_bits_32(f: f64) -> i64:
    # Simplified implementation
    # Real IEEE 754 encoding would go here
    var result = 0
    if f < 0.0:
        result = result | 2147483648  # Sign bit
    var abs_f = f
    if abs_f < 0.0:
        abs_f = 0.0 - abs_f
    # Encode mantissa and exponent
    result

# Helper: bits to float (32-bit)
fn bits_to_float_32(bits: i64) -> f64:
    # Simplified implementation
    var result = 0.0
    val sign = bits / 2147483648
    if sign > 0:
        result = 0.0 - result
    result

# Helper: float to bits (64-bit)
fn float_to_bits_64(f: f64) -> i64:
    # Simplified implementation
    var result = 0
    if f < 0.0:
        val sign_bit = 1
        result = result | (sign_bit * 9223372036854775808)
    result

# Helper: bits to float (64-bit)
fn bits_to_float_64(bits: i64) -> f64:
    # Simplified implementation
    var result = 0.0
    result

# ============================================================================
# FORMAT DETECTION
# ============================================================================

# Detect format type from first byte
fn msgpack_detect_format(byte: i64) -> text:
    val b = byte_to_unsigned(byte)

    # Positive fixint: 0x00 - 0x7f
    if b >= 0 and b <= 127:
        return "fixint"

    # Fixmap: 0x80 - 0x8f
    if b >= 128 and b <= 143:
        return "fixmap"

    # Fixarray: 0x90 - 0x9f
    if b >= 144 and b <= 159:
        return "fixarray"

    # Fixstr: 0xa0 - 0xbf
    if b >= 160 and b <= 191:
        return "fixstr"

    # Nil
    if b == 192:
        return "nil"

    # Boolean
    if b == 194:
        return "false"
    if b == 195:
        return "true"

    # Binary
    if b == 196:
        return "bin8"
    if b == 197:
        return "bin16"
    if b == 198:
        return "bin32"

    # Extension
    if b == 199:
        return "ext8"
    if b == 200:
        return "ext16"
    if b == 201:
        return "ext32"
    if b == 212:
        return "fixext1"
    if b == 213:
        return "fixext2"
    if b == 214:
        return "fixext4"
    if b == 215:
        return "fixext8"
    if b == 216:
        return "fixext16"

    # Float
    if b == 202:
        return "float32"
    if b == 203:
        return "float64"

    # Unsigned integer
    if b == 204:
        return "uint8"
    if b == 205:
        return "uint16"
    if b == 206:
        return "uint32"
    if b == 207:
        return "uint64"

    # Signed integer
    if b == 208:
        return "int8"
    if b == 209:
        return "int16"
    if b == 210:
        return "int32"
    if b == 211:
        return "int64"

    # String
    if b == 217:
        return "str8"
    if b == 218:
        return "str16"
    if b == 219:
        return "str32"

    # Array
    if b == 220:
        return "array16"
    if b == 221:
        return "array32"

    # Map
    if b == 222:
        return "map16"
    if b == 223:
        return "map32"

    # Negative fixint: 0xe0 - 0xff
    if b >= 224 and b <= 255:
        return "negfixint"

    "unknown"

# Check if byte is fixint
fn is_fixint(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 0 and b <= 127

# Check if byte is negative fixint
fn is_negfixint(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 224 and b <= 255

# Check if byte is fixmap
fn is_fixmap(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 128 and b <= 143

# Check if byte is fixarray
fn is_fixarray(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 144 and b <= 159

# Check if byte is fixstr
fn is_fixstr(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 160 and b <= 191

# ============================================================================
# INTEGER ENCODING
# ============================================================================

# Encode positive integer (automatic format selection)
fn msgpack_encode_uint(n: i64):
    # Positive fixint (0-127)
    if n >= 0 and n <= 127:
        return [to_byte(n)]

    # uint8 (128-255)
    if n >= 128 and n <= 255:
        return [MSGPACK_UINT8, to_byte(n)]

    # uint16 (256-65535)
    if n >= 256 and n <= 65535:
        val bytes = i16_to_bytes(n)
        return [MSGPACK_UINT16, bytes[0], bytes[1]]

    # uint32 (65536-4294967295)
    if n >= 65536 and n <= 4294967295:
        val bytes = i32_to_bytes(n)
        return [MSGPACK_UINT32, bytes[0], bytes[1], bytes[2], bytes[3]]

    # uint64
    val bytes = i64_to_bytes(n)
    [MSGPACK_UINT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

# Encode signed integer (automatic format selection)
fn msgpack_encode_int(n: i64):
    # Positive fixint (0-127)
    if n >= 0 and n <= 127:
        return [to_byte(n)]

    # Negative fixint (-32 to -1)
    if n >= -32 and n < 0:
        val b = to_byte(256 + n)
        return [b]

    # Positive integers use uint encoding
    if n > 127:
        return msgpack_encode_uint(n)

    # int8 (-128 to -33)
    if n >= -128 and n < -32:
        val b = to_byte(256 + n)
        return [MSGPACK_INT8, b]

    # int16
    if n >= -32768 and n < -128:
        val bytes = i16_to_bytes(n)
        return [MSGPACK_INT16, bytes[0], bytes[1]]

    # int32
    if n >= -2147483648 and n < -32768:
        val bytes = i32_to_bytes(n)
        return [MSGPACK_INT32, bytes[0], bytes[1], bytes[2], bytes[3]]

    # int64
    val bytes = i64_to_bytes(n)
    [MSGPACK_INT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

# Encode integer with specific format
fn msgpack_encode_uint8(n: i64):
    [MSGPACK_UINT8, to_byte(n)]

fn msgpack_encode_uint16(n: i64):
    val bytes = i16_to_bytes(n)
    [MSGPACK_UINT16, bytes[0], bytes[1]]

fn msgpack_encode_uint32(n: i64):
    val bytes = i32_to_bytes(n)
    [MSGPACK_UINT32, bytes[0], bytes[1], bytes[2], bytes[3]]

fn msgpack_encode_uint64(n: i64):
    val bytes = i64_to_bytes(n)
    [MSGPACK_UINT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

fn msgpack_encode_int8(n: i64):
    val b = to_byte(n)
    [MSGPACK_INT8, b]

fn msgpack_encode_int16(n: i64):
    val bytes = i16_to_bytes(n)
    [MSGPACK_INT16, bytes[0], bytes[1]]

fn msgpack_encode_int32(n: i64):
    val bytes = i32_to_bytes(n)
    [MSGPACK_INT32, bytes[0], bytes[1], bytes[2], bytes[3]]

fn msgpack_encode_int64(n: i64):
    val bytes = i64_to_bytes(n)
    [MSGPACK_INT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

# ============================================================================
# FLOAT ENCODING
# ============================================================================

# Encode float32
fn msgpack_encode_float32(f: f64):
    val bytes = f32_to_bytes(f)
    [MSGPACK_FLOAT32, bytes[0], bytes[1], bytes[2], bytes[3]]

# Encode float64
fn msgpack_encode_float64(f: f64):
    val bytes = f64_to_bytes(f)
    [MSGPACK_FLOAT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

# Encode float (automatic format selection)
fn msgpack_encode_float(f: f64):
    # Check if value fits in float32
    # Simplified: always use float64 for simplicity
    msgpack_encode_float64(f)

# ============================================================================
# STRING ENCODING
# ============================================================================

# Get byte length of UTF-8 string
fn utf8_byte_length(s: text) -> i64:
    # Simplified: assume each character is 1 byte
    # Real implementation would calculate UTF-8 byte length
    var count = 0
    var i = 0
    while i < 10000:
        val char = get_char_at(s, i)
        if char == "":
            return count
        count = count + 1
        i = i + 1
    count

# Get character at index
fn get_char_at(s: text, index: i64) -> text:
    # Simplified implementation
    if index >= string_length(s):
        return ""
    # Would extract character at index
    ""

# Get string length
fn string_length(s: text) -> i64:
    # Count characters in string
    var count = 0
    var i = 0
    while i < 10000:
        val test = "{s}"
        if test == "":
            return count
        count = count + 1
        i = i + 1
    count

# Convert string to byte array
fn string_to_bytes(s: text):
    var bytes = []
    var i = 0
    while i < string_length(s):
        val char = get_char_at(s, i)
        val byte = char_to_byte(char)
        bytes = bytes + [byte]
        i = i + 1
    bytes

# Convert character to byte
fn char_to_byte(c: text) -> i64:
    # Simplified: return ASCII value
    # Real implementation would handle UTF-8
    0

# Encode string (automatic format selection)
fn msgpack_encode_string(s: text):
    val byte_len = utf8_byte_length(s)
    val str_bytes = string_to_bytes(s)

    # fixstr (0-31 bytes)
    if byte_len >= 0 and byte_len <= 31:
        val header = MSGPACK_FIXSTR_PREFIX + byte_len
        var result = [to_byte(header)]
        var i = 0
        while i < byte_len:
            result = result + [str_bytes[i]]
            i = i + 1
        return result

    # str8 (32-255 bytes)
    if byte_len >= 32 and byte_len <= 255:
        var result = [MSGPACK_STR8, to_byte(byte_len)]
        var i = 0
        while i < byte_len:
            result = result + [str_bytes[i]]
            i = i + 1
        return result

    # str16 (256-65535 bytes)
    if byte_len >= 256 and byte_len <= 65535:
        val len_bytes = i16_to_bytes(byte_len)
        var result = [MSGPACK_STR16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < byte_len:
            result = result + [str_bytes[i]]
            i = i + 1
        return result

    # str32 (65536+ bytes)
    val len_bytes = i32_to_bytes(byte_len)
    var result = [MSGPACK_STR32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < byte_len:
        result = result + [str_bytes[i]]
        i = i + 1
    result

# ============================================================================
# BINARY ENCODING
# ============================================================================

# Encode binary data (automatic format selection)
fn msgpack_encode_binary(data):
    val data_len = list_length(data)

    # bin8 (0-255 bytes)
    if data_len >= 0 and data_len <= 255:
        var result = [MSGPACK_BIN8, to_byte(data_len)]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    # bin16 (256-65535 bytes)
    if data_len >= 256 and data_len <= 65535:
        val len_bytes = i16_to_bytes(data_len)
        var result = [MSGPACK_BIN16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    # bin32 (65536+ bytes)
    val len_bytes = i32_to_bytes(data_len)
    var result = [MSGPACK_BIN32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < data_len:
        result = result + [data[i]]
        i = i + 1
    result

# Get list length
fn list_length(lst) -> i64:
    var count = 0
    var i = 0
    while i < 100000:
        if i >= 100000:
            return count
        count = count + 1
        i = i + 1
    count

# ============================================================================
# ARRAY ENCODING
# ============================================================================

# Encode array (automatic format selection)
fn msgpack_encode_array(arr):
    val arr_len = list_length(arr)

    # fixarray (0-15 elements)
    if arr_len >= 0 and arr_len <= 15:
        val header = MSGPACK_FIXARRAY_PREFIX + arr_len
        var result = [to_byte(header)]
        var i = 0
        while i < arr_len:
            val elem_bytes = msgpack_encode_value(arr[i])
            result = result + elem_bytes
            i = i + 1
        return result

    # array16 (16-65535 elements)
    if arr_len >= 16 and arr_len <= 65535:
        val len_bytes = i16_to_bytes(arr_len)
        var result = [MSGPACK_ARRAY16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < arr_len:
            val elem_bytes = msgpack_encode_value(arr[i])
            result = result + elem_bytes
            i = i + 1
        return result

    # array32 (65536+ elements)
    val len_bytes = i32_to_bytes(arr_len)
    var result = [MSGPACK_ARRAY32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < arr_len:
        val elem_bytes = msgpack_encode_value(arr[i])
        result = result + elem_bytes
        i = i + 1
    result

# ============================================================================
# MAP ENCODING
# ============================================================================

# Encode map (automatic format selection)
fn msgpack_encode_map(map):
    val keys = map_keys(map)
    val map_len = list_length(keys)

    # fixmap (0-15 pairs)
    if map_len >= 0 and map_len <= 15:
        val header = MSGPACK_FIXMAP_PREFIX + map_len
        var result = [to_byte(header)]
        var i = 0
        while i < map_len:
            val key = keys[i]
            val value = map_get(map, key)
            val key_bytes = msgpack_encode_value(key)
            val value_bytes = msgpack_encode_value(value)
            result = result + key_bytes
            result = result + value_bytes
            i = i + 1
        return result

    # map16 (16-65535 pairs)
    if map_len >= 16 and map_len <= 65535:
        val len_bytes = i16_to_bytes(map_len)
        var result = [MSGPACK_MAP16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < map_len:
            val key = keys[i]
            val value = map_get(map, key)
            val key_bytes = msgpack_encode_value(key)
            val value_bytes = msgpack_encode_value(value)
            result = result + key_bytes
            result = result + value_bytes
            i = i + 1
        return result

    # map32 (65536+ pairs)
    val len_bytes = i32_to_bytes(map_len)
    var result = [MSGPACK_MAP32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < map_len:
        val key = keys[i]
        val value = map_get(map, key)
        val key_bytes = msgpack_encode_value(key)
        val value_bytes = msgpack_encode_value(value)
        result = result + key_bytes
        result = result + value_bytes
        i = i + 1
    result

# Get map keys
fn map_keys(map):
    # Extract keys from map
    []

# Get value from map
fn map_get(map, key):
    # Get value for key
    nil

# ============================================================================
# EXTENSION TYPE ENCODING
# ============================================================================

# Encode extension type
fn msgpack_encode_ext(type_id: i64, data):
    val data_len = list_length(data)

    # fixext1 (1 byte)
    if data_len == 1:
        return [MSGPACK_FIXEXT1, to_byte(type_id), data[0]]

    # fixext2 (2 bytes)
    if data_len == 2:
        return [MSGPACK_FIXEXT2, to_byte(type_id), data[0], data[1]]

    # fixext4 (4 bytes)
    if data_len == 4:
        return [MSGPACK_FIXEXT4, to_byte(type_id), data[0], data[1], data[2], data[3]]

    # fixext8 (8 bytes)
    if data_len == 8:
        return [MSGPACK_FIXEXT8, to_byte(type_id), data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]

    # fixext16 (16 bytes)
    if data_len == 16:
        var result = [MSGPACK_FIXEXT16, to_byte(type_id)]
        var i = 0
        while i < 16:
            result = result + [data[i]]
            i = i + 1
        return result

    # ext8 (0-255 bytes)
    if data_len >= 0 and data_len <= 255:
        var result = [MSGPACK_EXT8, to_byte(data_len), to_byte(type_id)]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    # ext16 (256-65535 bytes)
    if data_len >= 256 and data_len <= 65535:
        val len_bytes = i16_to_bytes(data_len)
        var result = [MSGPACK_EXT16, len_bytes[0], len_bytes[1], to_byte(type_id)]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    # ext32 (65536+ bytes)
    val len_bytes = i32_to_bytes(data_len)
    var result = [MSGPACK_EXT32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3], to_byte(type_id)]
    var i = 0
    while i < data_len:
        result = result + [data[i]]
        i = i + 1
    result

# ============================================================================
# TIMESTAMP ENCODING
# ============================================================================

# Encode timestamp (seconds, nanoseconds)
fn msgpack_encode_timestamp(seconds: i64, nanoseconds: i64):
    # timestamp32: seconds in uint32
    if nanoseconds == 0 and seconds >= 0 and seconds <= 4294967295:
        val bytes = i32_to_bytes(seconds)
        return [MSGPACK_FIXEXT4, to_byte(MSGPACK_EXT_TIMESTAMP), bytes[0], bytes[1], bytes[2], bytes[3]]

    # timestamp64: nanoseconds in 30 bits, seconds in 34 bits
    if seconds >= 0 and seconds <= 17179869183:
        val ns_sec = nanoseconds * 4
        val high = ns_sec + (seconds / 4294967296)
        val low = seconds % 4294967296
        val high_bytes = i32_to_bytes(high)
        val low_bytes = i32_to_bytes(low)
        return [MSGPACK_FIXEXT8, to_byte(MSGPACK_EXT_TIMESTAMP), high_bytes[0], high_bytes[1], high_bytes[2], high_bytes[3], low_bytes[0], low_bytes[1], low_bytes[2], low_bytes[3]]

    # timestamp96: nanoseconds in uint32, seconds in int64
    val ns_bytes = i32_to_bytes(nanoseconds)
    val sec_bytes = i64_to_bytes(seconds)
    [MSGPACK_EXT8, 12, to_byte(MSGPACK_EXT_TIMESTAMP), ns_bytes[0], ns_bytes[1], ns_bytes[2], ns_bytes[3], sec_bytes[0], sec_bytes[1], sec_bytes[2], sec_bytes[3], sec_bytes[4], sec_bytes[5], sec_bytes[6], sec_bytes[7]]

# ============================================================================
# NIL AND BOOLEAN ENCODING
# ============================================================================

# Encode nil
fn msgpack_encode_nil():
    [MSGPACK_NIL]

# Encode boolean
fn msgpack_encode_bool(b: bool):
    if b:
        [MSGPACK_TRUE]
    else:
        [MSGPACK_FALSE]

# ============================================================================
# GENERIC VALUE ENCODING
# ============================================================================

# Encode value (type, data) tuple
fn msgpack_encode_value(value):
    val value_type = get_value_type(value)

    if value_type == MSGPACK_TYPE_NIL:
        return msgpack_encode_nil()

    if value_type == MSGPACK_TYPE_BOOL:
        val b = get_bool_value(value)
        return msgpack_encode_bool(b)

    if value_type == MSGPACK_TYPE_INT:
        val n = get_int_value(value)
        return msgpack_encode_int(n)

    if value_type == MSGPACK_TYPE_FLOAT:
        val f = get_float_value(value)
        return msgpack_encode_float(f)

    if value_type == MSGPACK_TYPE_STRING:
        val s = get_string_value(value)
        return msgpack_encode_string(s)

    if value_type == MSGPACK_TYPE_BINARY:
        val data = get_binary_value(value)
        return msgpack_encode_binary(data)

    if value_type == MSGPACK_TYPE_ARRAY:
        val arr = get_array_value(value)
        return msgpack_encode_array(arr)

    if value_type == MSGPACK_TYPE_MAP:
        val map = get_map_value(value)
        return msgpack_encode_map(map)

    if value_type == MSGPACK_TYPE_EXT:
        val ext_data = get_ext_value(value)
        val type_id = ext_data[0]
        val data = ext_data[1]
        return msgpack_encode_ext(type_id, data)

    # Default: encode as nil
    msgpack_encode_nil()

# ============================================================================
# VALUE TYPE DETECTION
# ============================================================================

# Get value type from value
fn get_value_type(value) -> text:
    # Detect value type
    # In real implementation, would check value structure
    MSGPACK_TYPE_NIL

# Get boolean value
fn get_bool_value(value) -> bool:
    false

# Get integer value
fn get_int_value(value) -> i64:
    0

# Get float value
fn get_float_value(value) -> f64:
    0.0

# Get string value
fn get_string_value(value) -> text:
    ""

# Get binary value
fn get_binary_value(value):
    []

# Get array value
fn get_array_value(value):
    []

# Get map value
fn get_map_value(value):
    {}

# Get extension value
fn get_ext_value(value):
    (0, [])

# ============================================================================
# SIZE CALCULATION
# ============================================================================

# Calculate encoded size for integer
fn msgpack_size_int(n: i64) -> i64:
    if n >= 0 and n <= 127:
        return 1
    if n >= -32 and n < 0:
        return 1
    if n > 127 and n <= 255:
        return 2
    if n >= -128 and n < -32:
        return 2
    if n >= 256 and n <= 65535:
        return 3
    if n >= -32768 and n < -128:
        return 3
    if n >= 65536 and n <= 4294967295:
        return 5
    if n >= -2147483648 and n < -32768:
        return 5
    9

# Calculate encoded size for float
fn msgpack_size_float(f: f64) -> i64:
    9

# Calculate encoded size for string
fn msgpack_size_string(s: text) -> i64:
    val byte_len = utf8_byte_length(s)
    if byte_len >= 0 and byte_len <= 31:
        return 1 + byte_len
    if byte_len >= 32 and byte_len <= 255:
        return 2 + byte_len
    if byte_len >= 256 and byte_len <= 65535:
        return 3 + byte_len
    5 + byte_len

# Calculate encoded size for binary
fn msgpack_size_binary(data) -> i64:
    val data_len = list_length(data)
    if data_len >= 0 and data_len <= 255:
        return 2 + data_len
    if data_len >= 256 and data_len <= 65535:
        return 3 + data_len
    5 + data_len

# Calculate encoded size for array
fn msgpack_size_array(arr) -> i64:
    val arr_len = list_length(arr)
    var header_size = 0
    if arr_len >= 0 and arr_len <= 15:
        header_size = 1
    else:
        if arr_len >= 16 and arr_len <= 65535:
            header_size = 3
        else:
            header_size = 5

    var total_size = header_size
    var i = 0
    while i < arr_len:
        val elem_size = msgpack_size_value(arr[i])
        total_size = total_size + elem_size
        i = i + 1
    total_size

# Calculate encoded size for map
fn msgpack_size_map(map) -> i64:
    val keys = map_keys(map)
    val map_len = list_length(keys)
    var header_size = 0
    if map_len >= 0 and map_len <= 15:
        header_size = 1
    else:
        if map_len >= 16 and map_len <= 65535:
            header_size = 3
        else:
            header_size = 5

    var total_size = header_size
    var i = 0
    while i < map_len:
        val key = keys[i]
        val value = map_get(map, key)
        val key_size = msgpack_size_value(key)
        val value_size = msgpack_size_value(value)
        total_size = total_size + key_size
        total_size = total_size + value_size
        i = i + 1
    total_size

# Calculate encoded size for extension
fn msgpack_size_ext(type_id: i64, data) -> i64:
    val data_len = list_length(data)
    if data_len == 1:
        return 3
    if data_len == 2:
        return 4
    if data_len == 4:
        return 6
    if data_len == 8:
        return 10
    if data_len == 16:
        return 18
    if data_len >= 0 and data_len <= 255:
        return 3 + data_len
    if data_len >= 256 and data_len <= 65535:
        return 4 + data_len
    6 + data_len

# Calculate encoded size for value
fn msgpack_size_value(value) -> i64:
    val value_type = get_value_type(value)

    if value_type == MSGPACK_TYPE_NIL:
        return 1
    if value_type == MSGPACK_TYPE_BOOL:
        return 1
    if value_type == MSGPACK_TYPE_INT:
        val n = get_int_value(value)
        return msgpack_size_int(n)
    if value_type == MSGPACK_TYPE_FLOAT:
        val f = get_float_value(value)
        return msgpack_size_float(f)
    if value_type == MSGPACK_TYPE_STRING:
        val s = get_string_value(value)
        return msgpack_size_string(s)
    if value_type == MSGPACK_TYPE_BINARY:
        val data = get_binary_value(value)
        return msgpack_size_binary(data)
    if value_type == MSGPACK_TYPE_ARRAY:
        val arr = get_array_value(value)
        return msgpack_size_array(arr)
    if value_type == MSGPACK_TYPE_MAP:
        val map = get_map_value(value)
        return msgpack_size_map(map)
    if value_type == MSGPACK_TYPE_EXT:
        val ext_data = get_ext_value(value)
        val type_id = ext_data[0]
        val data = ext_data[1]
        return msgpack_size_ext(type_id, data)
    1

# ============================================================================
# DECODING HELPERS
# ============================================================================

# Decode fixint
fn msgpack_decode_fixint(byte: i64) -> i64:
    byte_to_unsigned(byte)

# Decode negative fixint
fn msgpack_decode_negfixint(byte: i64) -> i64:
    val b = byte_to_unsigned(byte)
    b - 256

# Decode fixmap size
fn msgpack_decode_fixmap_size(byte: i64) -> i64:
    val b = byte_to_unsigned(byte)
    b - MSGPACK_FIXMAP_PREFIX

# Decode fixarray size
fn msgpack_decode_fixarray_size(byte: i64) -> i64:
    val b = byte_to_unsigned(byte)
    b - MSGPACK_FIXARRAY_PREFIX

# Decode fixstr size
fn msgpack_decode_fixstr_size(byte: i64) -> i64:
    val b = byte_to_unsigned(byte)
    b - MSGPACK_FIXSTR_PREFIX

# ============================================================================
# VALIDATION
# ============================================================================

# Validate MessagePack format byte
fn msgpack_validate_format(byte: i64) -> bool:
    val format = msgpack_detect_format(byte)
    format != "unknown"

# Check if bytes are valid MessagePack
fn msgpack_is_valid(bytes) -> bool:
    val len = list_length(bytes)
    if len == 0:
        return false
    val first_byte = bytes[0]
    msgpack_validate_format(first_byte)
