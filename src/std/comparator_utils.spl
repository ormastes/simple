# Comparator Utilities
#
# Helper functions for comparison, ordering, and sorting operations.
# Pure Simple implementation - no external dependencies.
#
# Provides comparators, ordering functions, and utilities for
# working with comparable values.
#
# Functions:
# - Comparators: natural, reverse, by_key, compose_comparators
# - Ordering: min, max, min_by, max_by, clamp
# - Comparison: compare, compare_by, equal_by
# - Sorting helpers: is_sorted, is_sorted_by, find_insertion_point
# - Min/Max finding: min_max, argmin, argmax

# ============================================================================
# Comparison Results
# ============================================================================

fn Less():
    """Comparison result: less than.

    Example:
        compare(1, 2)  # Less()
    """
    -1

fn Equal():
    """Comparison result: equal.

    Example:
        compare(5, 5)  # Equal()
    """
    0

fn Greater():
    """Comparison result: greater than.

    Example:
        compare(10, 5)  # Greater()
    """
    1

# ============================================================================
# Basic Comparison
# ============================================================================

fn compare(a, b):
    """Compare two values.

    Returns: -1 (less), 0 (equal), 1 (greater)

    Example:
        compare(1, 2)  # -1
        compare(5, 5)  # 0
        compare(10, 5)  # 1
    """
    if a < b:
        return Less()
    if a > b:
        return Greater()
    Equal()

fn compare_by(a, b, key_fn):
    """Compare two values by key function.

    Example:
        compare_by("hello", "world", \\s: s.len())  # 0 (same length)
    """
    val key_a = key_fn(a)
    val key_b = key_fn(b)
    compare(key_a, key_b)

fn equal_by(a, b, key_fn):
    """Check equality by key function.

    Example:
        equal_by("hello", "world", \\s: s.len())  # true
    """
    compare_by(a, b, key_fn) == Equal()

# ============================================================================
# Comparator Functions
# ============================================================================

fn natural_comparator():
    """Natural ordering comparator.

    Example:
        val cmp = natural_comparator()
        cmp(1, 2)  # -1
    """
    \\a, b: compare(a, b)

fn reverse_comparator(cmp):
    """Reverse a comparator.

    Example:
        val rev_cmp = reverse_comparator(natural_comparator())
        rev_cmp(1, 2)  # 1
    """
    \\a, b: -cmp(a, b)

fn by_key_comparator(key_fn):
    """Create comparator based on key function.

    Example:
        val len_cmp = by_key_comparator(\\s: s.len())
        len_cmp("hi", "hello")  # -1 (shorter)
    """
    \\a, b: compare(key_fn(a), key_fn(b))

fn compose_comparators(cmp1, cmp2):
    """Compose two comparators (use cmp2 if cmp1 returns Equal).

    Example:
        # Sort by length, then alphabetically
        val cmp = compose_comparators(
            by_key_comparator(\\s: s.len()),
            natural_comparator()
        )
    """
    \\a, b:
        val result1 = cmp1(a, b)
        if result1 == Equal():
            cmp2(a, b)
        else:
            result1

fn nullable_comparator(cmp, null_first: bool):
    """Create comparator that handles nil values.

    Example:
        val cmp = nullable_comparator(natural_comparator(), true)
        cmp(nil, 5)  # -1 (nil comes first)
    """
    \\a, b:
        val a_null = not a.?
        val b_null = not b.?

        if a_null and b_null:
            return Equal()
        if a_null:
            return if null_first: Less() else: Greater()
        if b_null:
            return if null_first: Greater() else: Less()

        cmp(a, b)

# ============================================================================
# Min/Max Operations
# ============================================================================

fn min_value(a, b):
    """Return minimum of two values.

    Example:
        min_value(5, 10)  # 5
    """
    if a < b: a else: b

fn max_value(a, b):
    """Return maximum of two values.

    Example:
        max_value(5, 10)  # 10
    """
    if a > b: a else: b

fn min_by(a, b, key_fn):
    """Return minimum by key function.

    Example:
        min_by("hello", "hi", \\s: s.len())  # "hi"
    """
    if key_fn(a) < key_fn(b):
        a
    else:
        b

fn max_by(a, b, key_fn):
    """Return maximum by key function.

    Example:
        max_by("hello", "hi", \\s: s.len())  # "hello"
    """
    if key_fn(a) > key_fn(b):
        a
    else:
        b

fn min_max(a, b):
    """Return (min, max) tuple.

    Example:
        min_max(10, 5)  # (5, 10)
    """
    if a < b:
        (a, b)
    else:
        (b, a)

fn clamp_value(value, min: i64, max: i64):
    """Clamp value between min and max.

    Example:
        clamp_value(15, 1, 10)  # 10
        clamp_value(-5, 1, 10)  # 1
        clamp_value(5, 1, 10)   # 5
    """
    if value < min:
        return min
    if value > max:
        return max
    value

# ============================================================================
# Array Min/Max
# ============================================================================

fn array_min(arr):
    """Find minimum value in array.

    Returns nil for empty array.

    Example:
        array_min([3, 1, 4, 1, 5])  # 1
    """
    if arr.len() == 0:
        return nil

    var min = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] < min:
            min = arr[i]
        i = i + 1

    min

fn array_max(arr):
    """Find maximum value in array.

    Returns nil for empty array.

    Example:
        array_max([3, 1, 4, 1, 5])  # 5
    """
    if arr.len() == 0:
        return nil

    var max = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] > max:
            max = arr[i]
        i = i + 1

    max

fn array_min_max(arr):
    """Find both minimum and maximum in one pass.

    Returns Some((min, max)) or nil for empty array.

    Example:
        array_min_max([3, 1, 4, 1, 5])  # Some((1, 5))
    """
    if arr.len() == 0:
        return nil

    var min = arr[0]
    var max = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] < min:
            min = arr[i]
        if arr[i] > max:
            max = arr[i]
        i = i + 1

    Some((min, max))

fn array_min_by(arr, key_fn):
    """Find minimum by key function.

    Example:
        array_min_by(["hello", "hi", "world"], \\s: s.len())  # "hi"
    """
    if arr.len() == 0:
        return nil

    var min_item = arr[0]
    var min_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key < min_key:
            min_key = key
            min_item = arr[i]
        i = i + 1

    min_item

fn array_max_by(arr, key_fn):
    """Find maximum by key function.

    Example:
        array_max_by(["hello", "hi", "world"], \\s: s.len())  # "hello"
    """
    if arr.len() == 0:
        return nil

    var max_item = arr[0]
    var max_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key > max_key:
            max_key = key
            max_item = arr[i]
        i = i + 1

    max_item

# ============================================================================
# Argument Min/Max (Index Finding)
# ============================================================================

fn argmin(arr):
    """Find index of minimum value.

    Returns Some(index) or nil for empty array.

    Example:
        argmin([3, 1, 4, 1, 5])  # Some(1)
    """
    if arr.len() == 0:
        return nil

    var min_idx = 0
    var min_val = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] < min_val:
            min_val = arr[i]
            min_idx = i
        i = i + 1

    Some(min_idx)

fn argmax(arr):
    """Find index of maximum value.

    Returns Some(index) or nil for empty array.

    Example:
        argmax([3, 1, 4, 1, 5])  # Some(4)
    """
    if arr.len() == 0:
        return nil

    var max_idx = 0
    var max_val = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] > max_val:
            max_val = arr[i]
            max_idx = i
        i = i + 1

    Some(max_idx)

fn argmin_by(arr, key_fn):
    """Find index of minimum by key function.

    Example:
        argmin_by(["hello", "hi", "world"], \\s: s.len())  # Some(1)
    """
    if arr.len() == 0:
        return nil

    var min_idx = 0
    var min_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key < min_key:
            min_key = key
            min_idx = i
        i = i + 1

    Some(min_idx)

fn argmax_by(arr, key_fn):
    """Find index of maximum by key function.

    Example:
        argmax_by(["hello", "hi", "world"], \\s: s.len())  # Some(0)
    """
    if arr.len() == 0:
        return nil

    var max_idx = 0
    var max_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key > max_key:
            max_key = key
            max_idx = i
        i = i + 1

    Some(max_idx)

# ============================================================================
# Sorting Utilities
# ============================================================================

fn is_sorted(arr):
    """Check if array is sorted in ascending order.

    Example:
        is_sorted([1, 2, 3, 4])  # true
        is_sorted([1, 3, 2, 4])  # false
    """
    var i = 0
    while i < arr.len() - 1:
        if arr[i] > arr[i + 1]:
            return false
        i = i + 1
    true

fn is_sorted_by(arr, key_fn):
    """Check if array is sorted by key function.

    Example:
        is_sorted_by(["hi", "cat", "hello"], \\s: s.len())  # true
    """
    var i = 0
    while i < arr.len() - 1:
        if key_fn(arr[i]) > key_fn(arr[i + 1]):
            return false
        i = i + 1
    true

fn is_strictly_sorted(arr):
    """Check if array is strictly sorted (no duplicates).

    Example:
        is_strictly_sorted([1, 2, 3, 4])  # true
        is_strictly_sorted([1, 2, 2, 4])  # false
    """
    var i = 0
    while i < arr.len() - 1:
        if arr[i] >= arr[i + 1]:
            return false
        i = i + 1
    true

fn find_insertion_point(sorted_arr, value):
    """Find insertion point to maintain sorted order.

    Uses binary search. Returns index where value should be inserted.

    Example:
        find_insertion_point([1, 3, 5, 7], 4)  # 2
    """
    var left = 0
    var right = sorted_arr.len()

    while left < right:
        val mid = left + (right - left) / 2
        if sorted_arr[mid] < value:
            left = mid + 1
        else:
            right = mid

    left

# ============================================================================
# Comparison Predicates
# ============================================================================

fn between(value, lower, upper):
    """Check if value is between lower and upper (inclusive).

    Example:
        between(5, 1, 10)  # true
        between(15, 1, 10)  # false
    """
    value >= lower and value <= upper

fn between_exclusive(value, lower, upper):
    """Check if value is between lower and upper (exclusive).

    Example:
        between_exclusive(5, 1, 10)  # true
        between_exclusive(1, 1, 10)  # false
    """
    value > lower and value < upper

fn is_ascending(a, b, c):
    """Check if three values are in ascending order.

    Example:
        is_ascending(1, 5, 10)  # true
        is_ascending(1, 10, 5)  # false
    """
    a <= b and b <= c

fn is_descending(a, b, c):
    """Check if three values are in descending order.

    Example:
        is_descending(10, 5, 1)  # true
    """
    a >= b and b >= c

# ============================================================================
# K-th Element Finding
# ============================================================================

fn kth_smallest(arr, k: i64):
    """Find k-th smallest element (0-indexed).

    Uses simple selection. For small arrays only.
    Returns nil if k is out of bounds.

    Example:
        kth_smallest([3, 1, 4, 1, 5], 2)  # Some(3)
    """
    if k < 0 or k >= arr.len():
        return nil

    # Create sorted copy
    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var min_idx = i
        var j = i + 1
        while j < sorted.len():
            if sorted[j] < sorted[min_idx]:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[min_idx]
            sorted[min_idx] = temp

        i = i + 1

    Some(sorted[k])

fn kth_largest(arr, k: i64):
    """Find k-th largest element (0-indexed).

    Example:
        kth_largest([3, 1, 4, 1, 5], 1)  # Some(4)
    """
    kth_smallest(arr, arr.len() - 1 - k)

fn median(arr):
    """Find median value.

    For even-length arrays, returns lower middle element.

    Example:
        median([3, 1, 4, 1, 5])  # Some(3)
    """
    if arr.len() == 0:
        return nil

    val mid = arr.len() / 2
    kth_smallest(arr, mid)

# ============================================================================
# Top-N Finding
# ============================================================================

fn top_n(arr, n: i64):
    """Find top n largest elements.

    Returns array of n largest elements in descending order.

    Example:
        top_n([3, 1, 4, 1, 5, 9], 3)  # [9, 5, 4]
    """
    if n <= 0 or arr.len() == 0:
        return []

    # Simple approach: sort and take last n
    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var max_idx = i
        var j = i + 1
        while j < sorted.len():
            if sorted[j] > sorted[max_idx]:
                max_idx = j
            j = j + 1

        if max_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[max_idx]
            sorted[max_idx] = temp

        i = i + 1

    var result = []
    i = 0
    val count = if n < sorted.len(): n else: sorted.len()

    while i < count:
        result.push(sorted[i])
        i = i + 1

    result

fn bottom_n(arr, n: i64):
    """Find bottom n smallest elements.

    Returns array of n smallest elements in ascending order.

    Example:
        bottom_n([3, 1, 4, 1, 5, 9], 3)  # [1, 1, 3]
    """
    if n <= 0 or arr.len() == 0:
        return []

    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var min_idx = i
        var j = i + 1
        while j < sorted.len():
            if sorted[j] < sorted[min_idx]:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[min_idx]
            sorted[min_idx] = temp

        i = i + 1

    var result = []
    i = 0
    val count = if n < sorted.len(): n else: sorted.len()

    while i < count:
        result.push(sorted[i])
        i = i + 1

    result

# ============================================================================
# Lexicographic Comparison
# ============================================================================

fn compare_arrays(arr1, arr2):
    """Compare two arrays lexicographically.

    Returns: -1 (less), 0 (equal), 1 (greater)

    Example:
        compare_arrays([1, 2, 3], [1, 2, 4])  # -1
        compare_arrays([1, 2], [1, 2, 3])     # -1 (shorter)
    """
    val len1 = arr1.len()
    val len2 = arr2.len()
    val min_len = if len1 < len2: len1 else: len2

    var i = 0
    while i < min_len:
        val cmp = compare(arr1[i], arr2[i])
        if cmp != Equal():
            return cmp
        i = i + 1

    # All elements equal up to min_len, compare lengths
    compare(len1, len2)
