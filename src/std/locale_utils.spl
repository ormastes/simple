# Internationalization (i18n) and Localization (l10n) Utilities Module
# Provides comprehensive locale management, message translation, number/date formatting,
# pluralization, text direction, and collation support.
#
# ARCHITECTURE:
# - Pure Simple implementation (no FFI dependencies)
# - Tuple-based data structures (no runtime generics)
# - Option/nil error handling (no exceptions)
# - No method chaining (intermediate variables)
#
# LOCALE FORMAT: BCP 47 (language-region-script-variant)
# Example: "en-US" (English, United States), "zh-Hans-CN" (Chinese, Simplified, China)

# ============================================================================
# CORE DATA STRUCTURES
# ============================================================================

# Locale: (language: text, region: text, script: text, variant: text)
# Example: ("en", "US", "", "") for English (United States)

# Message catalog: (locale_code: text, messages: Map<text, text>)
# Stores translations for a specific locale

# Number format: (decimal_sep: text, thousands_sep: text, grouping: List<i64>)
# Example: (".", ",", [3]) for US format

# Date/time pattern: (pattern: text, locale: Locale)
# Example: ("yyyy-MM-dd", locale) for ISO date format

# Plural forms: (zero: text, one: text, two: text, few: text, many: text, other: text)
# Different languages have different plural rules

# ============================================================================
# GLOBAL STATE (Message Catalogs)
# ============================================================================

# Message catalog storage: locale_code -> messages map
# In a real implementation, this would be a proper data structure
# For now, we use simple string-based lookup

var global_messages = ""  # Will store serialized message catalog

# ============================================================================
# LOCALE CREATION AND PARSING
# ============================================================================

fn create_locale(language: text, region: text) -> (text, text, text, text):
    # Creates a locale tuple from language and region codes.
    # Returns: (language, region, script, variant)
    #
    # Args:
    #   language: ISO 639 language code (e.g., "en", "es", "fr")
    #   region: ISO 3166 region code (e.g., "US", "GB", "FR")
    #
    # Example:
    #   val locale = create_locale("en", "US")  # English (United States)
    (language, region, "", "")

fn create_locale_full(language: text, region: text, script: text, variant: text) -> (text, text, text, text):
    # Creates a complete locale tuple with all components.
    # Returns: (language, region, script, variant)
    #
    # Args:
    #   language: ISO 639 language code
    #   region: ISO 3166 region code
    #   script: ISO 15924 script code (e.g., "Hans", "Latn")
    #   variant: Variant identifier
    #
    # Example:
    #   val locale = create_locale_full("zh", "CN", "Hans", "")  # Simplified Chinese
    (language, region, script, variant)

fn parse_locale(locale_code: text) -> (text, text, text, text):
    # Parses a BCP 47 locale code into components.
    # Returns: (language, region, script, variant) or ("", "", "", "") on error
    #
    # Supported formats:
    #   "en" -> ("en", "", "", "")
    #   "en-US" -> ("en", "US", "", "")
    #   "zh-Hans-CN" -> ("zh", "CN", "Hans", "")
    #
    # Example:
    #   val locale = parse_locale("fr-FR")  # ("fr", "FR", "", "")

    var parts = locale_code.split("-")
    var len = parts.length()

    if len == 0:
        return ("", "", "", "")

    if len == 1:
        return (parts.get(0), "", "", "")

    if len == 2:
        return (parts.get(0), parts.get(1), "", "")

    if len == 3:
        return (parts.get(0), parts.get(2), parts.get(1), "")

    # len >= 4
    (parts.get(0), parts.get(2), parts.get(1), parts.get(3))

fn locale_to_code(locale: (text, text, text, text)) -> text:
    # Converts a locale tuple to BCP 47 code string.
    # Returns: Locale code string (e.g., "en-US", "zh-Hans-CN")
    #
    # Example:
    #   val code = locale_to_code(("en", "US", "", ""))  # "en-US"

    var language = locale.0
    var region = locale.1
    var script = locale.2
    var variant = locale.3

    var code = language

    if script != "":
        code = code + "-" + script

    if region != "":
        code = code + "-" + region

    if variant != "":
        code = code + "-" + variant

    code

fn default_locale() -> (text, text, text, text):
    # Returns the default locale (en-US).
    # Returns: ("en", "US", "", "")
    ("en", "US", "", "")

# ============================================================================
# LOCALE PROPERTY ACCESSORS
# ============================================================================

fn get_language(locale: (text, text, text, text)) -> text:
    # Gets the language code from a locale.
    # Example: get_language(("en", "US", "", "")) -> "en"
    locale.0

fn get_region(locale: (text, text, text, text)) -> text:
    # Gets the region code from a locale.
    # Example: get_region(("en", "US", "", "")) -> "US"
    locale.1

fn get_script(locale: (text, text, text, text)) -> text:
    # Gets the script code from a locale.
    # Example: get_script(("zh", "CN", "Hans", "")) -> "Hans"
    locale.2

fn get_variant(locale: (text, text, text, text)) -> text:
    # Gets the variant from a locale.
    # Example: get_variant(("en", "US", "", "posix")) -> "posix"
    locale.3

fn locale_equals(locale1: (text, text, text, text), locale2: (text, text, text, text)) -> bool:
    # Checks if two locales are equal.
    # Returns: true if all components match
    var lang_match = locale1.0 == locale2.0
    var region_match = locale1.1 == locale2.1
    var script_match = locale1.2 == locale2.2
    var variant_match = locale1.3 == locale2.3

    var first_check = lang_match and region_match
    var second_check = script_match and variant_match
    first_check and second_check

# ============================================================================
# COMMON LOCALE CONSTRUCTORS
# ============================================================================

fn locale_en_us() -> (text, text, text, text):
    # English (United States)
    ("en", "US", "", "")

fn locale_en_gb() -> (text, text, text, text):
    # English (United Kingdom)
    ("en", "GB", "", "")

fn locale_es_es() -> (text, text, text, text):
    # Spanish (Spain)
    ("es", "ES", "", "")

fn locale_es_mx() -> (text, text, text, text):
    # Spanish (Mexico)
    ("es", "MX", "", "")

fn locale_fr_fr() -> (text, text, text, text):
    # French (France)
    ("fr", "FR", "", "")

fn locale_fr_ca() -> (text, text, text, text):
    # French (Canada)
    ("fr", "CA", "", "")

fn locale_de_de() -> (text, text, text, text):
    # German (Germany)
    ("de", "DE", "", "")

fn locale_it_it() -> (text, text, text, text):
    # Italian (Italy)
    ("it", "IT", "", "")

fn locale_pt_br() -> (text, text, text, text):
    # Portuguese (Brazil)
    ("pt", "BR", "", "")

fn locale_pt_pt() -> (text, text, text, text):
    # Portuguese (Portugal)
    ("pt", "PT", "", "")

fn locale_ja_jp() -> (text, text, text, text):
    # Japanese (Japan)
    ("ja", "JP", "", "")

fn locale_zh_cn() -> (text, text, text, text):
    # Chinese (China, Simplified)
    ("zh", "CN", "Hans", "")

fn locale_zh_tw() -> (text, text, text, text):
    # Chinese (Taiwan, Traditional)
    ("zh", "TW", "Hant", "")

fn locale_ko_kr() -> (text, text, text, text):
    # Korean (South Korea)
    ("ko", "KR", "", "")

fn locale_ar_sa() -> (text, text, text, text):
    # Arabic (Saudi Arabia)
    ("ar", "SA", "", "")

fn locale_ar_ae() -> (text, text, text, text):
    # Arabic (UAE)
    ("ar", "AE", "", "")

fn locale_ru_ru() -> (text, text, text, text):
    # Russian (Russia)
    ("ru", "RU", "", "")

fn locale_hi_in() -> (text, text, text, text):
    # Hindi (India)
    ("hi", "IN", "", "")

fn locale_nl_nl() -> (text, text, text, text):
    # Dutch (Netherlands)
    ("nl", "NL", "", "")

fn locale_sv_se() -> (text, text, text, text):
    # Swedish (Sweden)
    ("sv", "SE", "", "")

fn locale_pl_pl() -> (text, text, text, text):
    # Polish (Poland)
    ("pl", "PL", "", "")

# ============================================================================
# MESSAGE TRANSLATION
# ============================================================================

fn create_message_key(locale_code: text, key: text) -> text:
    # Internal: Creates a unique key for message storage.
    locale_code + ":" + key

fn load_messages(locale: (text, text, text, text), messages: text):
    # Loads message translations for a locale.
    # Messages format: "key1=value1\nkey2=value2\n..."
    #
    # Args:
    #   locale: Target locale
    #   messages: Newline-separated key=value pairs
    #
    # Example:
    #   val msgs = "greeting=Hello\nfarewell=Goodbye"
    #   load_messages(locale_en_us(), msgs)

    var locale_code = locale_to_code(locale)
    var lines = messages.split("\n")
    var i = 0

    # In a real implementation, this would populate a data structure
    # For now, we append to global_messages
    while i < lines.length():
        var line = lines.get(i)
        if line != "":
            global_messages = global_messages + locale_code + ":" + line + "\n"
        i = i + 1

fn add_message(locale: (text, text, text, text), key: text, value: text):
    # Adds a single message translation for a locale.
    #
    # Example:
    #   add_message(locale_en_us(), "welcome", "Welcome!")

    var locale_code = locale_to_code(locale)
    var entry = locale_code + ":" + key + "=" + value + "\n"
    global_messages = global_messages + entry

fn translate(key: text, locale: (text, text, text, text)) -> text:
    # Translates a message key to the target locale.
    # Returns: Translated message or key if not found
    #
    # Example:
    #   val msg = translate("greeting", locale_en_us())

    var locale_code = locale_to_code(locale)
    var search_key = locale_code + ":" + key + "="
    var lines = global_messages.split("\n")
    var i = 0

    while i < lines.length():
        var line = lines.get(i)
        if line.starts_with(search_key):
            var parts = line.split("=")
            if parts.length() >= 2:
                return parts.get(1)
        i = i + 1

    # Not found, return key
    key

fn translate_with_args(key: text, args: (text, text, text, text, text), locale: (text, text, text, text)) -> text:
    # Translates a message with placeholder substitution.
    # Placeholders: {0}, {1}, {2}, {3}, {4}
    # Returns: Translated and formatted message
    #
    # Example:
    #   add_message(locale, "welcome_user", "Welcome, {0}!")
    #   val msg = translate_with_args("welcome_user", ("Alice", "", "", "", ""), locale)
    #   # "Welcome, Alice!"

    var template = translate(key, locale)

    # Replace {0}
    var result = template.replace("{0}", args.0)

    # Replace {1}
    if args.1 != "":
        result = result.replace("{1}", args.1)

    # Replace {2}
    if args.2 != "":
        result = result.replace("{2}", args.2)

    # Replace {3}
    if args.3 != "":
        result = result.replace("{3}", args.3)

    # Replace {4}
    if args.4 != "":
        result = result.replace("{4}", args.4)

    result

fn translate_with_count(key: text, count: i64, locale: (text, text, text, text)) -> text:
    # Translates a message with count placeholder {n}.
    # Returns: Translated message with {n} replaced by count
    #
    # Example:
    #   add_message(locale, "items", "{n} items")
    #   val msg = translate_with_count("items", 5, locale)  # "5 items"

    var template = translate(key, locale)
    var count_str = count.to_text()
    template.replace("{n}", count_str)

# ============================================================================
# NUMBER FORMATTING
# ============================================================================

fn get_decimal_separator(locale: (text, text, text, text)) -> text:
    # Gets the decimal separator for a locale.
    # Returns: "." for most locales, "," for European locales

    var lang = locale.0

    # European locales use comma
    if lang == "fr" or lang == "de" or lang == "es" or lang == "it" or lang == "pt" or lang == "ru" or lang == "nl" or lang == "sv" or lang == "pl":
        return ","

    # Most other locales use period
    "."

fn get_thousands_separator(locale: (text, text, text, text)) -> text:
    # Gets the thousands separator for a locale.
    # Returns: "," for English, " " for French, "." for German, etc.

    var lang = locale.0

    # French uses space
    if lang == "fr":
        return " "

    # German and similar use period
    if lang == "de" or lang == "it" or lang == "nl" or lang == "es" or lang == "pt":
        return "."

    # Most others use comma
    ","

fn format_integer_part(num: i64, sep: text) -> text:
    # Internal: Formats integer with thousands separator.
    # Returns: Formatted string (e.g., "1,234,567")

    var str = num.to_text()
    var len = str.length()

    if len <= 3:
        return str

    # Build result from right to left
    var result = ""
    var count = 0
    var i = len - 1

    while i >= 0:
        if count == 3:
            result = sep + result
            count = 0

        var ch = str.substring(i, i + 1)
        result = ch + result
        count = count + 1
        i = i - 1

    result

fn format_number(num: i64, locale: (text, text, text, text)) -> text:
    # Formats an integer with locale-specific thousands separator.
    # Returns: Formatted number string
    #
    # Example:
    #   format_number(1234567, locale_en_us())  # "1,234,567"
    #   format_number(1234567, locale_fr_fr())  # "1 234 567"

    var sep = get_thousands_separator(locale)
    format_integer_part(num, sep)

fn format_decimal(num: i64, decimals: i64, locale: (text, text, text, text)) -> text:
    # Formats a number as decimal with specified decimal places.
    # Note: num is in "cents" (multiply by 100)
    # Returns: Formatted decimal string
    #
    # Example:
    #   format_decimal(123456789, 2, locale_en_us())  # "1,234,567.89"
    #   format_decimal(123456789, 2, locale_fr_fr())  # "1 234 567,89"

    var dec_sep = get_decimal_separator(locale)
    var thou_sep = get_thousands_separator(locale)

    # Calculate integer and fractional parts
    var divisor = 1
    var i = 0
    while i < decimals:
        divisor = divisor * 10
        i = i + 1

    var int_part = num / divisor
    var frac_part = num % divisor

    # Handle negative fractional part
    if frac_part < 0:
        frac_part = 0 - frac_part

    # Format integer part with thousands separator
    var int_str = format_integer_part(int_part, thou_sep)

    # Format fractional part with leading zeros
    var frac_str = frac_part.to_text()
    while frac_str.length() < decimals:
        frac_str = "0" + frac_str

    int_str + dec_sep + frac_str

# ============================================================================
# CURRENCY FORMATTING
# ============================================================================

fn currency_symbol(currency: text, locale: (text, text, text, text)) -> text:
    # Gets the currency symbol for a currency code.
    # Returns: Currency symbol (e.g., "$", "€", "¥")
    #
    # Args:
    #   currency: ISO 4217 currency code (e.g., "USD", "EUR", "JPY")

    if currency == "USD":
        return "$"

    if currency == "EUR":
        return "€"

    if currency == "GBP":
        return "£"

    if currency == "JPY":
        return "¥"

    if currency == "CNY":
        return "¥"

    if currency == "KRW":
        return "₩"

    if currency == "RUB":
        return "₽"

    if currency == "INR":
        return "₹"

    if currency == "BRL":
        return "R$"

    if currency == "CAD":
        return "C$"

    if currency == "AUD":
        return "A$"

    if currency == "CHF":
        return "CHF"

    # Default: return currency code
    currency

fn currency_decimals(currency: text) -> i64:
    # Gets the number of decimal places for a currency.
    # Returns: Number of decimals (usually 2, 0 for JPY/KRW)

    # Zero decimal currencies
    if currency == "JPY" or currency == "KRW":
        return 0

    # Most currencies use 2 decimals
    2

fn currency_position(locale: (text, text, text, text)) -> text:
    # Gets the currency symbol position preference.
    # Returns: "before" or "after"

    var lang = locale.0

    # Most European languages put symbol after
    if lang == "fr" or lang == "es" or lang == "it" or lang == "pt" or lang == "ru" or lang == "nl" or lang == "sv" or lang == "pl":
        return "after"

    # English and most others put symbol before
    "before"

fn format_currency(amount: i64, currency: text, locale: (text, text, text, text)) -> text:
    # Formats a currency amount with locale-specific formatting.
    # Note: amount is in smallest unit (e.g., cents for USD)
    # Returns: Formatted currency string
    #
    # Example:
    #   format_currency(1999, "USD", locale_en_us())  # "$19.99"
    #   format_currency(1999, "EUR", locale_fr_fr())  # "19,99 €"

    var symbol = currency_symbol(currency, locale)
    var decimals = currency_decimals(currency)
    var position = currency_position(locale)

    var num_str = format_decimal(amount, decimals, locale)

    if position == "before":
        return symbol + num_str

    # after
    num_str + " " + symbol

fn parse_currency(text: text, currency: text, locale: (text, text, text, text)) -> i64:
    # Parses a currency string to amount in smallest unit.
    # Returns: Amount or 0 on error
    #
    # Example:
    #   parse_currency("$19.99", "USD", locale_en_us())  # 1999

    var symbol = currency_symbol(currency, locale)
    var dec_sep = get_decimal_separator(locale)
    var thou_sep = get_thousands_separator(locale)

    # Remove currency symbol and whitespace
    var cleaned = text.replace(symbol, "")
    cleaned = cleaned.replace(" ", "")

    # Remove thousands separator
    cleaned = cleaned.replace(thou_sep, "")

    # Split by decimal separator
    var parts = cleaned.split(dec_sep)

    if parts.length() == 0:
        return 0

    var int_part = 0
    var int_str = parts.get(0)
    if int_str != "":
        int_part = int_str.to_int()

    var frac_part = 0
    if parts.length() >= 2:
        var frac_str = parts.get(1)
        if frac_str != "":
            frac_part = frac_str.to_int()

    var decimals = currency_decimals(currency)
    var multiplier = 1
    var i = 0
    while i < decimals:
        multiplier = multiplier * 10
        i = i + 1

    int_part * multiplier + frac_part

# ============================================================================
# PERCENTAGE FORMATTING
# ============================================================================

fn format_percent(ratio: i64, locale: (text, text, text, text)) -> text:
    # Formats a ratio as percentage (ratio is per-10000).
    # Returns: Formatted percentage string
    #
    # Example:
    #   format_percent(7550, locale_en_us())  # "75.50%"
    #   format_percent(7550, locale_fr_fr())  # "75,50 %"

    var lang = locale.0

    # Format as decimal with 2 places
    var num_str = format_decimal(ratio, 2, locale)

    # French puts space before %
    if lang == "fr":
        return num_str + " %"

    num_str + "%"

fn parse_percent(text: text, locale: (text, text, text, text)) -> i64:
    # Parses a percentage string to ratio (per-10000).
    # Returns: Ratio or 0 on error
    #
    # Example:
    #   parse_percent("75.50%", locale_en_us())  # 7550

    var dec_sep = get_decimal_separator(locale)

    # Remove % and whitespace
    var cleaned = text.replace("%", "")
    cleaned = cleaned.replace(" ", "")

    # Split by decimal separator
    var parts = cleaned.split(dec_sep)

    if parts.length() == 0:
        return 0

    var int_part = 0
    var int_str = parts.get(0)
    if int_str != "":
        int_part = int_str.to_int()

    var frac_part = 0
    if parts.length() >= 2:
        var frac_str = parts.get(1)
        if frac_str != "":
            frac_part = frac_str.to_int()

    int_part * 100 + frac_part

# ============================================================================
# DATE/TIME FORMATTING
# ============================================================================

fn month_name(month: i64, locale: (text, text, text, text)) -> text:
    # Gets the full month name for a locale.
    # Returns: Month name (1-12)
    #
    # Example:
    #   month_name(1, locale_en_us())  # "January"
    #   month_name(1, locale_fr_fr())  # "janvier"

    var lang = locale.0

    if lang == "fr":
        if month == 1: return "janvier"
        if month == 2: return "février"
        if month == 3: return "mars"
        if month == 4: return "avril"
        if month == 5: return "mai"
        if month == 6: return "juin"
        if month == 7: return "juillet"
        if month == 8: return "août"
        if month == 9: return "septembre"
        if month == 10: return "octobre"
        if month == 11: return "novembre"
        if month == 12: return "décembre"
        return ""

    if lang == "es":
        if month == 1: return "enero"
        if month == 2: return "febrero"
        if month == 3: return "marzo"
        if month == 4: return "abril"
        if month == 5: return "mayo"
        if month == 6: return "junio"
        if month == 7: return "julio"
        if month == 8: return "agosto"
        if month == 9: return "septiembre"
        if month == 10: return "octubre"
        if month == 11: return "noviembre"
        if month == 12: return "diciembre"
        return ""

    if lang == "de":
        if month == 1: return "Januar"
        if month == 2: return "Februar"
        if month == 3: return "März"
        if month == 4: return "April"
        if month == 5: return "Mai"
        if month == 6: return "Juni"
        if month == 7: return "Juli"
        if month == 8: return "August"
        if month == 9: return "September"
        if month == 10: return "Oktober"
        if month == 11: return "November"
        if month == 12: return "Dezember"
        return ""

    # English (default)
    if month == 1: return "January"
    if month == 2: return "February"
    if month == 3: return "March"
    if month == 4: return "April"
    if month == 5: return "May"
    if month == 6: return "June"
    if month == 7: return "July"
    if month == 8: return "August"
    if month == 9: return "September"
    if month == 10: return "October"
    if month == 11: return "November"
    if month == 12: return "December"
    ""

fn month_name_short(month: i64, locale: (text, text, text, text)) -> text:
    # Gets the abbreviated month name for a locale.
    # Returns: Short month name (1-12)
    #
    # Example:
    #   month_name_short(1, locale_en_us())  # "Jan"

    var full_name = month_name(month, locale)
    if full_name.length() >= 3:
        return full_name.substring(0, 3)
    full_name

fn day_name(day: i64, locale: (text, text, text, text)) -> text:
    # Gets the full day name for a locale (1=Monday, 7=Sunday).
    # Returns: Day name
    #
    # Example:
    #   day_name(1, locale_en_us())  # "Monday"
    #   day_name(1, locale_fr_fr())  # "lundi"

    var lang = locale.0

    if lang == "fr":
        if day == 1: return "lundi"
        if day == 2: return "mardi"
        if day == 3: return "mercredi"
        if day == 4: return "jeudi"
        if day == 5: return "vendredi"
        if day == 6: return "samedi"
        if day == 7: return "dimanche"
        return ""

    if lang == "es":
        if day == 1: return "lunes"
        if day == 2: return "martes"
        if day == 3: return "miércoles"
        if day == 4: return "jueves"
        if day == 5: return "viernes"
        if day == 6: return "sábado"
        if day == 7: return "domingo"
        return ""

    if lang == "de":
        if day == 1: return "Montag"
        if day == 2: return "Dienstag"
        if day == 3: return "Mittwoch"
        if day == 4: return "Donnerstag"
        if day == 5: return "Freitag"
        if day == 6: return "Samstag"
        if day == 7: return "Sonntag"
        return ""

    # English (default)
    if day == 1: return "Monday"
    if day == 2: return "Tuesday"
    if day == 3: return "Wednesday"
    if day == 4: return "Thursday"
    if day == 5: return "Friday"
    if day == 6: return "Saturday"
    if day == 7: return "Sunday"
    ""

fn day_name_short(day: i64, locale: (text, text, text, text)) -> text:
    # Gets the abbreviated day name for a locale.
    # Returns: Short day name
    #
    # Example:
    #   day_name_short(1, locale_en_us())  # "Mon"

    var full_name = day_name(day, locale)
    if full_name.length() >= 3:
        return full_name.substring(0, 3)
    full_name

fn format_date(year: i64, month: i64, day: i64, pattern: text, locale: (text, text, text, text)) -> text:
    # Formats a date according to pattern and locale.
    # Pattern tokens: yyyy (year), MM (month), dd (day), MMM (short month), MMMM (full month)
    # Returns: Formatted date string
    #
    # Example:
    #   format_date(2026, 2, 11, "yyyy-MM-dd", locale)  # "2026-02-11"
    #   format_date(2026, 2, 11, "MMMM dd, yyyy", locale_en_us())  # "February 11, 2026"

    var result = pattern

    # Year
    var year_str = year.to_text()
    result = result.replace("yyyy", year_str)

    # Month (numeric)
    var month_str = month.to_text()
    if month < 10:
        month_str = "0" + month_str
    result = result.replace("MM", month_str)

    # Day
    var day_str = day.to_text()
    if day < 10:
        day_str = "0" + day_str
    result = result.replace("dd", day_str)

    # Full month name
    var month_full = month_name(month, locale)
    result = result.replace("MMMM", month_full)

    # Short month name
    var month_short = month_name_short(month, locale)
    result = result.replace("MMM", month_short)

    result

fn format_time(hour: i64, minute: i64, second: i64, pattern: text, locale: (text, text, text, text)) -> text:
    # Formats a time according to pattern and locale.
    # Pattern tokens: HH (hour 24), hh (hour 12), mm (minute), ss (second), a (AM/PM)
    # Returns: Formatted time string
    #
    # Example:
    #   format_time(14, 30, 0, "HH:mm:ss", locale)  # "14:30:00"
    #   format_time(14, 30, 0, "hh:mm a", locale_en_us())  # "02:30 PM"

    var result = pattern

    # 24-hour
    var hour_str = hour.to_text()
    if hour < 10:
        hour_str = "0" + hour_str
    result = result.replace("HH", hour_str)

    # 12-hour
    var hour_12 = hour % 12
    if hour_12 == 0:
        hour_12 = 12
    var hour_12_str = hour_12.to_text()
    if hour_12 < 10:
        hour_12_str = "0" + hour_12_str
    result = result.replace("hh", hour_12_str)

    # AM/PM
    var ampm = "AM"
    if hour >= 12:
        ampm = "PM"
    result = result.replace("a", ampm)

    # Minute
    var minute_str = minute.to_text()
    if minute < 10:
        minute_str = "0" + minute_str
    result = result.replace("mm", minute_str)

    # Second
    var second_str = second.to_text()
    if second < 10:
        second_str = "0" + second_str
    result = result.replace("ss", second_str)

    result

# ============================================================================
# RELATIVE TIME FORMATTING
# ============================================================================

fn relative_time_seconds(seconds: i64, locale: (text, text, text, text)) -> text:
    # Formats relative time from seconds difference.
    # Returns: Relative time string (e.g., "5 minutes ago", "in 2 hours")
    #
    # Example:
    #   relative_time_seconds(-300, locale_en_us())  # "5 minutes ago"
    #   relative_time_seconds(7200, locale_en_us())  # "in 2 hours"

    var lang = locale.0
    var abs_seconds = seconds
    if abs_seconds < 0:
        abs_seconds = 0 - abs_seconds

    var future = seconds > 0

    # Less than a minute
    if abs_seconds < 60:
        if lang == "fr":
            if future: return "dans quelques secondes"
            return "il y a quelques secondes"
        if lang == "es":
            if future: return "en unos segundos"
            return "hace unos segundos"
        # English
        if future: return "in a few seconds"
        return "a few seconds ago"

    # Minutes
    if abs_seconds < 3600:
        var minutes = abs_seconds / 60
        var min_str = minutes.to_text()
        if lang == "fr":
            if future: return "dans " + min_str + " minutes"
            return "il y a " + min_str + " minutes"
        if lang == "es":
            if future: return "en " + min_str + " minutos"
            return "hace " + min_str + " minutos"
        # English
        if future: return "in " + min_str + " minutes"
        return min_str + " minutes ago"

    # Hours
    if abs_seconds < 86400:
        var hours = abs_seconds / 3600
        var hour_str = hours.to_text()
        if lang == "fr":
            if future: return "dans " + hour_str + " heures"
            return "il y a " + hour_str + " heures"
        if lang == "es":
            if future: return "en " + hour_str + " horas"
            return "hace " + hour_str + " horas"
        # English
        if future: return "in " + hour_str + " hours"
        return hour_str + " hours ago"

    # Days
    var days = abs_seconds / 86400
    var day_str = days.to_text()
    if lang == "fr":
        if future: return "dans " + day_str + " jours"
        return "il y a " + day_str + " jours"
    if lang == "es":
        if future: return "en " + day_str + " días"
        return "hace " + day_str + " días"
    # English
    if future: return "in " + day_str + " days"
    day_str + " days ago"

fn time_ago(seconds: i64, locale: (text, text, text, text)) -> text:
    # Formats time in the past (seconds should be negative).
    # Returns: "X ago" string
    #
    # Example:
    #   time_ago(-3600, locale_en_us())  # "1 hours ago"

    relative_time_seconds(seconds, locale)

fn time_until(seconds: i64, locale: (text, text, text, text)) -> text:
    # Formats time in the future (seconds should be positive).
    # Returns: "in X" string
    #
    # Example:
    #   time_until(3600, locale_en_us())  # "in 1 hours"

    relative_time_seconds(seconds, locale)

# ============================================================================
# PLURALIZATION
# ============================================================================

fn plural_rule(count: i64, locale: (text, text, text, text)) -> text:
    # Determines the plural category for a count in a locale.
    # Returns: "zero", "one", "two", "few", "many", or "other"
    #
    # CLDR Plural Rules implementation for common languages

    var lang = locale.0

    # English, German: one (n == 1), other
    if lang == "en" or lang == "de":
        if count == 1: return "one"
        return "other"

    # French: one (n == 0 or n == 1), other
    if lang == "fr":
        if count == 0 or count == 1: return "one"
        return "other"

    # Spanish, Italian: one (n == 1), other
    if lang == "es" or lang == "it" or lang == "pt":
        if count == 1: return "one"
        return "other"

    # Russian: complex rules
    if lang == "ru":
        var mod_10 = count % 10
        var mod_100 = count % 100
        if mod_10 == 1 and mod_100 != 11: return "one"
        var check1 = mod_10 >= 2 and mod_10 <= 4
        var check2 = mod_100 < 10 or mod_100 >= 20
        if check1 and check2: return "few"
        return "many"

    # Arabic: very complex rules (simplified)
    if lang == "ar":
        if count == 0: return "zero"
        if count == 1: return "one"
        if count == 2: return "two"
        var mod_100 = count % 100
        if mod_100 >= 3 and mod_100 <= 10: return "few"
        if mod_100 >= 11: return "many"
        return "other"

    # Polish: complex rules
    if lang == "pl":
        if count == 1: return "one"
        var mod_10 = count % 10
        var mod_100 = count % 100
        var check1 = mod_10 >= 2 and mod_10 <= 4
        var check2 = mod_100 < 10 or mod_100 >= 20
        if check1 and check2: return "few"
        return "many"

    # Japanese, Korean, Chinese: other (no plurals)
    if lang == "ja" or lang == "ko" or lang == "zh":
        return "other"

    # Default: one (n == 1), other
    if count == 1: return "one"
    "other"

fn pluralize(count: i64, forms: (text, text, text, text, text, text), locale: (text, text, text, text)) -> text:
    # Selects the appropriate plural form for a count.
    # Forms: (zero, one, two, few, many, other)
    # Returns: Selected form with {n} replaced by count
    #
    # Example:
    #   val forms = ("no items", "one item", "", "", "", "{n} items")
    #   pluralize(0, forms, locale_en_us())  # "no items"
    #   pluralize(1, forms, locale_en_us())  # "one item"
    #   pluralize(5, forms, locale_en_us())  # "5 items"

    var category = plural_rule(count, locale)

    var selected = ""
    if category == "zero": selected = forms.0
    if category == "one": selected = forms.1
    if category == "two": selected = forms.2
    if category == "few": selected = forms.3
    if category == "many": selected = forms.4
    if category == "other": selected = forms.5

    # Fallback to "other" if selected is empty
    if selected == "":
        selected = forms.5

    # Replace {n} with count
    var count_str = count.to_text()
    selected.replace("{n}", count_str)

# ============================================================================
# TEXT DIRECTION
# ============================================================================

fn text_direction(locale: (text, text, text, text)) -> text:
    # Gets the text direction for a locale.
    # Returns: "ltr" (left-to-right) or "rtl" (right-to-left)
    #
    # Example:
    #   text_direction(locale_en_us())  # "ltr"
    #   text_direction(locale_ar_sa())  # "rtl"

    var lang = locale.0

    # RTL languages
    if lang == "ar" or lang == "he" or lang == "fa" or lang == "ur":
        return "rtl"

    # Most languages are LTR
    "ltr"

fn is_rtl(locale: (text, text, text, text)) -> bool:
    # Checks if a locale uses right-to-left text direction.
    # Returns: true if RTL, false otherwise

    var dir = text_direction(locale)
    dir == "rtl"

fn is_ltr(locale: (text, text, text, text)) -> bool:
    # Checks if a locale uses left-to-right text direction.
    # Returns: true if LTR, false otherwise

    var dir = text_direction(locale)
    dir == "ltr"

# ============================================================================
# COLLATION (String Comparison)
# ============================================================================

fn compare_strings(s1: text, s2: text, locale: (text, text, text, text)) -> i64:
    # Compares two strings using locale-specific collation rules.
    # Returns: -1 (s1 < s2), 0 (s1 == s2), 1 (s1 > s2)
    #
    # Note: This is a simplified implementation.
    # Real collation requires Unicode normalization and complex rules.
    #
    # Example:
    #   compare_strings("apple", "banana", locale_en_us())  # -1

    # Simple lexicographic comparison (not fully locale-aware)
    if s1 < s2:
        return -1
    if s1 > s2:
        return 1
    0

fn sort_strings(items: (text, text, text, text, text), locale: (text, text, text, text)) -> (text, text, text, text, text):
    # Sorts up to 5 strings using locale-specific collation.
    # Returns: Sorted tuple
    #
    # Note: This is a simple bubble sort implementation.
    # Limited to 5 items due to tuple constraints.

    # Convert to array-like structure
    var s0 = items.0
    var s1 = items.1
    var s2 = items.2
    var s3 = items.3
    var s4 = items.4

    # Bubble sort pass 1
    if s0 != "" and s1 != "":
        var cmp = compare_strings(s0, s1, locale)
        if cmp > 0:
            var temp = s0
            s0 = s1
            s1 = temp

    if s1 != "" and s2 != "":
        var cmp = compare_strings(s1, s2, locale)
        if cmp > 0:
            var temp = s1
            s1 = s2
            s2 = temp

    if s2 != "" and s3 != "":
        var cmp = compare_strings(s2, s3, locale)
        if cmp > 0:
            var temp = s2
            s2 = s3
            s3 = temp

    if s3 != "" and s4 != "":
        var cmp = compare_strings(s3, s4, locale)
        if cmp > 0:
            var temp = s3
            s3 = s4
            s4 = temp

    # Bubble sort pass 2
    if s0 != "" and s1 != "":
        var cmp = compare_strings(s0, s1, locale)
        if cmp > 0:
            var temp = s0
            s0 = s1
            s1 = temp

    if s1 != "" and s2 != "":
        var cmp = compare_strings(s1, s2, locale)
        if cmp > 0:
            var temp = s1
            s1 = s2
            s2 = temp

    if s2 != "" and s3 != "":
        var cmp = compare_strings(s2, s3, locale)
        if cmp > 0:
            var temp = s2
            s2 = s3
            s3 = temp

    # Bubble sort pass 3
    if s0 != "" and s1 != "":
        var cmp = compare_strings(s0, s1, locale)
        if cmp > 0:
            var temp = s0
            s0 = s1
            s1 = temp

    if s1 != "" and s2 != "":
        var cmp = compare_strings(s1, s2, locale)
        if cmp > 0:
            var temp = s1
            s1 = s2
            s2 = temp

    # Bubble sort pass 4
    if s0 != "" and s1 != "":
        var cmp = compare_strings(s0, s1, locale)
        if cmp > 0:
            var temp = s0
            s0 = s1
            s1 = temp

    (s0, s1, s2, s3, s4)

# ============================================================================
# CASE CONVERSION (Locale-Aware)
# ============================================================================

fn to_upper_locale(text: text, locale: (text, text, text, text)) -> text:
    # Converts text to uppercase using locale-specific rules.
    # Returns: Uppercase text
    #
    # Note: This uses built-in to_upper() which may not handle
    # all locale-specific cases (e.g., Turkish i/İ).

    text.to_upper()

fn to_lower_locale(text: text, locale: (text, text, text, text)) -> text:
    # Converts text to lowercase using locale-specific rules.
    # Returns: Lowercase text
    #
    # Note: This uses built-in to_lower() which may not handle
    # all locale-specific cases (e.g., Turkish İ/i).

    text.to_lower()

fn to_title_case(text: text, locale: (text, text, text, text)) -> text:
    # Converts text to title case (first letter uppercase).
    # Returns: Title case text
    #
    # Example:
    #   to_title_case("hello world", locale)  # "Hello World"

    if text.length() == 0:
        return text

    var first = text.substring(0, 1)
    var rest = text.substring(1, text.length())

    var first_upper = first.to_upper()
    first_upper + rest

# ============================================================================
# LOCALE VALIDATION
# ============================================================================

fn is_valid_language_code(code: text) -> bool:
    # Checks if a language code is valid (simplified check).
    # Returns: true if valid ISO 639 code format

    var len = code.length()
    len == 2 or len == 3

fn is_valid_region_code(code: text) -> bool:
    # Checks if a region code is valid (simplified check).
    # Returns: true if valid ISO 3166 code format

    var len = code.length()
    len == 2

fn is_valid_locale(locale: (text, text, text, text)) -> bool:
    # Checks if a locale tuple is valid.
    # Returns: true if language code is valid

    var lang = locale.0
    is_valid_language_code(lang)

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

fn pad_left(text: text, width: i64, pad_char: text) -> text:
    # Pads text on the left to specified width.
    # Returns: Padded text
    #
    # Example:
    #   pad_left("42", 5, "0")  # "00042"

    var len = text.length()
    if len >= width:
        return text

    var result = text
    var needed = width - len
    var i = 0

    while i < needed:
        result = pad_char + result
        i = i + 1

    result

fn pad_right(text: text, width: i64, pad_char: text) -> text:
    # Pads text on the right to specified width.
    # Returns: Padded text
    #
    # Example:
    #   pad_right("hello", 10, " ")  # "hello     "

    var len = text.length()
    if len >= width:
        return text

    var result = text
    var needed = width - len
    var i = 0

    while i < needed:
        result = result + pad_char
        i = i + 1

    result

fn format_list(items: (text, text, text, text, text), locale: (text, text, text, text)) -> text:
    # Formats a list of items with locale-specific separators.
    # Returns: Formatted list string
    #
    # Example:
    #   format_list(("apple", "banana", "orange", "", ""), locale_en_us())
    #   # "apple, banana, and orange"

    var lang = locale.0

    # Count non-empty items
    var count = 0
    if items.0 != "": count = count + 1
    if items.1 != "": count = count + 1
    if items.2 != "": count = count + 1
    if items.3 != "": count = count + 1
    if items.4 != "": count = count + 1

    if count == 0:
        return ""

    if count == 1:
        return items.0

    if count == 2:
        var sep = " and "
        if lang == "fr": sep = " et "
        if lang == "es": sep = " y "
        if lang == "de": sep = " und "
        return items.0 + sep + items.1

    # 3 or more items
    var result = items.0
    var i = 1

    while i < count - 1:
        result = result + ", "
        if i == 0 and items.0 != "": result = result + items.0
        if i == 1 and items.1 != "": result = result + items.1
        if i == 2 and items.2 != "": result = result + items.2
        if i == 3 and items.3 != "": result = result + items.3
        i = i + 1

    # Add final item with "and"
    var sep = ", and "
    if lang == "fr": sep = ", et "
    if lang == "es": sep = ", y "
    if lang == "de": sep = ", und "

    result = result + sep
    if count == 3: result = result + items.2
    if count == 4: result = result + items.3
    if count == 5: result = result + items.4

    result

# ============================================================================
# MODULE EXPORTS
# ============================================================================

# This module provides 80+ functions for comprehensive i18n/l10n support:
#
# Locale Management (20 functions):
#   - create_locale, create_locale_full, parse_locale, locale_to_code
#   - get_language, get_region, get_script, get_variant, locale_equals
#   - default_locale, is_valid_language_code, is_valid_region_code, is_valid_locale
#   - 11 common locale constructors (en_us, fr_fr, es_es, de_de, ja_jp, zh_cn, etc.)
#
# Translation (6 functions):
#   - load_messages, add_message, translate, translate_with_args, translate_with_count
#   - create_message_key (internal)
#
# Number Formatting (8 functions):
#   - format_number, format_decimal, format_integer_part
#   - get_decimal_separator, get_thousands_separator
#
# Currency (6 functions):
#   - format_currency, parse_currency, currency_symbol, currency_decimals, currency_position
#
# Percentage (2 functions):
#   - format_percent, parse_percent
#
# Date/Time (9 functions):
#   - month_name, month_name_short, day_name, day_name_short
#   - format_date, format_time
#
# Relative Time (3 functions):
#   - relative_time_seconds, time_ago, time_until
#
# Pluralization (2 functions):
#   - plural_rule, pluralize
#
# Text Direction (3 functions):
#   - text_direction, is_rtl, is_ltr
#
# Collation (2 functions):
#   - compare_strings, sort_strings
#
# Case Conversion (3 functions):
#   - to_upper_locale, to_lower_locale, to_title_case
#
# Utilities (4 functions):
#   - pad_left, pad_right, format_list
#
# Total: 80+ functions for production-ready i18n/l10n support
