# Matrix Utilities
#
# Matrix operations and linear algebra utilities.
# Pure Simple implementation - no external dependencies.
#
# Represents matrices as 2D arrays (array of arrays).
# Matrix operations use integer arithmetic only.
#
# Functions:
# - Construction: create_matrix, identity_matrix, zero_matrix
# - Properties: dimensions, is_square, trace
# - Basic ops: add, subtract, multiply, scalar_multiply
# - Transformation: transpose, rotate, flip
# - Access: get_row, get_column, get_element
# - Analysis: determinant, is_symmetric, diagonal

# ============================================================================
# Matrix Construction
# ============================================================================

fn create_matrix(rows: i64, cols: i64, initial_value):
    """Create matrix filled with initial value.

    Example:
        create_matrix(3, 3, 0)  # 3x3 zero matrix
    """
    var matrix = []
    var i = 0

    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            row.push(initial_value)
            j = j + 1
        matrix.push(row)
        i = i + 1

    matrix

fn zero_matrix(rows: i64, cols: i64):
    """Create zero matrix.

    Example:
        zero_matrix(3, 3)  # [[0,0,0], [0,0,0], [0,0,0]]
    """
    create_matrix(rows, cols, 0)

fn identity_matrix(n: i64):
    """Create nÃ—n identity matrix.

    Example:
        identity_matrix(3)
        # [[1,0,0], [0,1,0], [0,0,1]]
    """
    var matrix = zero_matrix(n, n)
    var i = 0

    while i < n:
        matrix[i][i] = 1
        i = i + 1

    matrix

fn diagonal_matrix(values):
    """Create diagonal matrix from values.

    Example:
        diagonal_matrix([1, 2, 3])
        # [[1,0,0], [0,2,0], [0,0,3]]
    """
    val n = values.len()
    var matrix = zero_matrix(n, n)
    var i = 0

    while i < n:
        matrix[i][i] = values[i]
        i = i + 1

    matrix

fn from_rows(rows):
    """Create matrix from array of row arrays.

    Example:
        from_rows([[1,2], [3,4]])
    """
    rows

fn from_columns(cols):
    """Create matrix from array of column arrays.

    Example:
        from_columns([[1,3], [2,4]])  # [[1,2], [3,4]]
    """
    if cols.len() == 0:
        return []

    val rows = cols[0].len()
    val columns = cols.len()

    var matrix = []
    var i = 0

    while i < rows:
        var row = []
        var j = 0
        while j < columns:
            row.push(cols[j][i])
            j = j + 1
        matrix.push(row)
        i = i + 1

    matrix

# ============================================================================
# Matrix Properties
# ============================================================================

fn dimensions(matrix):
    """Get matrix dimensions (rows, cols).

    Example:
        dimensions([[1,2,3], [4,5,6]])  # (2, 3)
    """
    if matrix.len() == 0:
        return (0, 0)

    (matrix.len(), matrix[0].len())

fn is_square(matrix):
    """Check if matrix is square.

    Example:
        is_square([[1,2], [3,4]])  # true
    """
    val (rows, cols) = dimensions(matrix)
    rows == cols and rows > 0

fn trace(matrix):
    """Calculate trace (sum of diagonal elements).

    Only for square matrices.

    Example:
        trace([[1,2], [3,4]])  # 5
    """
    if not is_square(matrix):
        return nil

    var sum = 0
    var i = 0

    while i < matrix.len():
        sum = sum + matrix[i][i]
        i = i + 1

    sum

fn is_symmetric(matrix):
    """Check if matrix is symmetric (M = M^T).

    Example:
        is_symmetric([[1,2], [2,1]])  # true
    """
    if not is_square(matrix):
        return false

    val n = matrix.len()
    var i = 0

    while i < n:
        var j = i + 1
        while j < n:
            if matrix[i][j] != matrix[j][i]:
                return false
            j = j + 1
        i = i + 1

    true

fn is_diagonal(matrix):
    """Check if matrix is diagonal.

    Example:
        is_diagonal([[1,0], [0,2]])  # true
    """
    if not is_square(matrix):
        return false

    val n = matrix.len()
    var i = 0

    while i < n:
        var j = 0
        while j < n:
            if i != j and matrix[i][j] != 0:
                return false
            j = j + 1
        i = i + 1

    true

# ============================================================================
# Matrix Access
# ============================================================================

fn get_element(matrix, row: i64, col: i64):
    """Get element at position.

    Example:
        get_element([[1,2], [3,4]], 1, 0)  # 3
    """
    if row < 0 or row >= matrix.len():
        return nil
    if col < 0 or col >= matrix[0].len():
        return nil

    matrix[row][col]

fn get_row(matrix, row: i64):
    """Get row as array.

    Example:
        get_row([[1,2], [3,4]], 1)  # [3, 4]
    """
    if row < 0 or row >= matrix.len():
        return nil

    matrix[row]

fn get_column(matrix, col: i64):
    """Get column as array.

    Example:
        get_column([[1,2], [3,4]], 0)  # [1, 3]
    """
    if matrix.len() == 0:
        return nil
    if col < 0 or col >= matrix[0].len():
        return nil

    var column = []
    for row in matrix:
        column.push(row[col])

    column

fn get_diagonal(matrix):
    """Get main diagonal as array.

    Example:
        get_diagonal([[1,2], [3,4]])  # [1, 4]
    """
    if not is_square(matrix):
        return nil

    var diagonal = []
    var i = 0

    while i < matrix.len():
        diagonal.push(matrix[i][i])
        i = i + 1

    diagonal

# ============================================================================
# Matrix Basic Operations
# ============================================================================

fn add_matrices(m1, m2):
    """Add two matrices.

    Matrices must have same dimensions.

    Example:
        add_matrices([[1,2], [3,4]], [[5,6], [7,8]])
        # [[6,8], [10,12]]
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if rows1 != rows2 or cols1 != cols2:
        return nil

    var result = []
    var i = 0

    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] + m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1

    result

fn subtract_matrices(m1, m2):
    """Subtract two matrices.

    Example:
        subtract_matrices([[5,6], [7,8]], [[1,2], [3,4]])
        # [[4,4], [4,4]]
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if rows1 != rows2 or cols1 != cols2:
        return nil

    var result = []
    var i = 0

    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] - m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1

    result

fn scalar_multiply(matrix, scalar):
    """Multiply matrix by scalar.

    Example:
        scalar_multiply([[1,2], [3,4]], 2)
        # [[2,4], [6,8]]
    """
    var result = []

    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem * scalar)
        result.push(new_row)

    result

fn multiply_matrices(m1, m2):
    """Multiply two matrices.

    m1 must have cols equal to m2 rows.

    Example:
        multiply_matrices([[1,2], [3,4]], [[5,6], [7,8]])
        # [[19,22], [43,50]]
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if cols1 != rows2:
        return nil

    var result = []
    var i = 0

    while i < rows1:
        var row = []
        var j = 0
        while j < cols2:
            var sum = 0
            var k = 0
            while k < cols1:
                sum = sum + (m1[i][k] * m2[k][j])
                k = k + 1
            row.push(sum)
            j = j + 1
        result.push(row)
        i = i + 1

    result

# ============================================================================
# Matrix Transformations
# ============================================================================

fn transpose(matrix):
    """Transpose matrix (swap rows and columns).

    Example:
        transpose([[1,2,3], [4,5,6]])
        # [[1,4], [2,5], [3,6]]
    """
    val (rows, cols) = dimensions(matrix)
    if rows == 0 or cols == 0:
        return []

    var result = []
    var j = 0

    while j < cols:
        var column = []
        var i = 0
        while i < rows:
            column.push(matrix[i][j])
            i = i + 1
        result.push(column)
        j = j + 1

    result

fn flip_horizontal(matrix):
    """Flip matrix horizontally (reverse rows).

    Example:
        flip_horizontal([[1,2], [3,4]])
        # [[3,4], [1,2]]
    """
    var result = []
    var i = matrix.len() - 1

    while i >= 0:
        result.push(matrix[i])
        i = i - 1

    result

fn flip_vertical(matrix):
    """Flip matrix vertically (reverse columns).

    Example:
        flip_vertical([[1,2], [3,4]])
        # [[2,1], [4,3]]
    """
    var result = []

    for row in matrix:
        var new_row = []
        var i = row.len() - 1
        while i >= 0:
            new_row.push(row[i])
            i = i - 1
        result.push(new_row)

    result

fn rotate_90_clockwise(matrix):
    """Rotate matrix 90 degrees clockwise.

    Example:
        rotate_90_clockwise([[1,2], [3,4]])
        # [[3,1], [4,2]]
    """
    val transposed = transpose(matrix)
    flip_vertical(transposed)

fn rotate_90_counterclockwise(matrix):
    """Rotate matrix 90 degrees counterclockwise.

    Example:
        rotate_90_counterclockwise([[1,2], [3,4]])
        # [[2,4], [1,3]]
    """
    val transposed = transpose(matrix)
    flip_horizontal(transposed)

# ============================================================================
# Submatrix Operations
# ============================================================================

fn submatrix(matrix, start_row: i64, start_col: i64, num_rows: i64, num_cols: i64):
    """Extract submatrix.

    Example:
        submatrix([[1,2,3], [4,5,6], [7,8,9]], 1, 1, 2, 2)
        # [[5,6], [8,9]]
    """
    var result = []
    var i = 0

    while i < num_rows and (start_row + i) < matrix.len():
        var row = []
        var j = 0
        while j < num_cols and (start_col + j) < matrix[0].len():
            row.push(matrix[start_row + i][start_col + j])
            j = j + 1
        result.push(row)
        i = i + 1

    result

fn minor_matrix(matrix, exclude_row: i64, exclude_col: i64):
    """Get minor (matrix with row and column removed).

    Example:
        minor_matrix([[1,2,3], [4,5,6], [7,8,9]], 0, 0)
        # [[5,6], [8,9]]
    """
    var result = []
    var i = 0

    while i < matrix.len():
        if i != exclude_row:
            var row = []
            var j = 0
            while j < matrix[0].len():
                if j != exclude_col:
                    row.push(matrix[i][j])
                j = j + 1
            result.push(row)
        i = i + 1

    result

# ============================================================================
# Determinant
# ============================================================================

fn determinant(matrix):
    """Calculate determinant of square matrix.

    Uses cofactor expansion. Only works for small matrices.

    Example:
        determinant([[1,2], [3,4]])  # -2
    """
    if not is_square(matrix):
        return nil

    val n = matrix.len()

    if n == 1:
        return matrix[0][0]

    if n == 2:
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]

    # Cofactor expansion along first row
    var det = 0
    var j = 0

    while j < n:
        val minor = minor_matrix(matrix, 0, j)
        val cofactor = if j % 2 == 0: 1 else: -1
        val minor_det = determinant(minor)

        if minor_det.?:
            det = det + cofactor * matrix[0][j] * minor_det

        j = j + 1

    det

# ============================================================================
# Matrix Vector Operations
# ============================================================================

fn matrix_vector_multiply(matrix, vector):
    """Multiply matrix by column vector.

    Example:
        matrix_vector_multiply([[1,2], [3,4]], [5, 6])
        # [17, 39]
    """
    val (rows, cols) = dimensions(matrix)

    if cols != vector.len():
        return nil

    var result = []
    var i = 0

    while i < rows:
        var sum = 0
        var j = 0
        while j < cols:
            sum = sum + matrix[i][j] * vector[j]
            j = j + 1
        result.push(sum)
        i = i + 1

    result

fn dot_product(v1, v2):
    """Calculate dot product of two vectors.

    Example:
        dot_product([1, 2, 3], [4, 5, 6])  # 32
    """
    if v1.len() != v2.len():
        return nil

    var sum = 0
    var i = 0

    while i < v1.len():
        sum = sum + v1[i] * v2[i]
        i = i + 1

    sum

fn outer_product(v1, v2):
    """Calculate outer product of two vectors.

    Returns matrix.

    Example:
        outer_product([1, 2], [3, 4])
        # [[3,4], [6,8]]
    """
    var result = []

    for a in v1:
        var row = []
        for b in v2:
            row.push(a * b)
        result.push(row)

    result

# ============================================================================
# Matrix Comparison
# ============================================================================

fn matrices_equal(m1, m2):
    """Check if two matrices are equal.

    Example:
        matrices_equal([[1,2], [3,4]], [[1,2], [3,4]])  # true
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if rows1 != rows2 or cols1 != cols2:
        return false

    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            if m1[i][j] != m2[i][j]:
                return false
            j = j + 1
        i = i + 1

    true

# ============================================================================
# Matrix Utilities
# ============================================================================

fn matrix_power(matrix, n: i64):
    """Raise square matrix to power n.

    Example:
        matrix_power([[1,1], [1,0]], 2)
        # [[2,1], [1,1]] (Fibonacci)
    """
    if not is_square(matrix):
        return nil

    if n == 0:
        return identity_matrix(matrix.len())

    if n == 1:
        return matrix

    var result = matrix
    var i = 1

    while i < n:
        result = multiply_matrices(result, matrix)
        i = i + 1

    result

fn matrix_sum(matrix):
    """Sum all elements in matrix.

    Example:
        matrix_sum([[1,2], [3,4]])  # 10
    """
    var sum = 0

    for row in matrix:
        for elem in row:
            sum = sum + elem

    sum

fn reshape(matrix, new_rows: i64, new_cols: i64):
    """Reshape matrix to new dimensions.

    Total elements must match.

    Example:
        reshape([[1,2,3,4]], 2, 2)  # [[1,2], [3,4]]
    """
    val (rows, cols) = dimensions(matrix)
    val total = rows * cols

    if total != new_rows * new_cols:
        return nil

    # Flatten
    var flat = []
    for row in matrix:
        for elem in row:
            flat.push(elem)

    # Reshape
    var result = []
    var i = 0

    while i < new_rows:
        var row = []
        var j = 0
        while j < new_cols:
            row.push(flat[i * new_cols + j])
            j = j + 1
        result.push(row)
        i = i + 1

    result
