# AVL Tree Utilities
#
# Traversals, validation, range queries, kth element, count operations, bulk operations, and visualization

use avl_tree.types.{is_nil, get_value, get_left, get_right, get_node_height, create_node, set_left, set_right, set_value}
use avl_tree.create.{create_avl_tree, get_root, get_size}
use avl_tree.balance.{is_node_balanced, get_balance_factor, update_height}
use avl_tree.search.{find_min_node}

# ============================================================================
# Statistics Operations
# ============================================================================

# Get tree height
fn avl_height(tree) -> i64:
    val root = get_root(tree)
    get_height(root)

# Get height helper
fn get_height(node) -> i64:
    if is_nil(node):
        return 0
    get_node_height(node)

# Count nodes in subtree
fn count_nodes(node) -> i64:
    if is_nil(node):
        return 0
    val left = get_left(node)
    val right = get_right(node)
    val left_count = count_nodes(left)
    val right_count = count_nodes(right)
    1 + left_count + right_count

# Check if entire tree is balanced
fn is_balanced(tree) -> bool:
    val root = get_root(tree)
    check_balanced(root)

# Check if subtree is balanced
fn check_balanced(node) -> bool:
    if is_nil(node):
        return true

    # Check this node
    if is_node_balanced(node) == false:
        return false

    # Check children
    val left = get_left(node)
    val right = get_right(node)
    val left_balanced = check_balanced(left)
    if left_balanced == false:
        return false
    check_balanced(right)

# Check if tree satisfies BST property
fn is_valid_bst(tree) -> bool:
    val root = get_root(tree)
    val min_val = -2147483648
    val max_val = 2147483647
    check_bst(root, min_val, max_val)

# Check BST property for subtree
fn check_bst(node, min_val: i64, max_val: i64) -> bool:
    if is_nil(node):
        return true

    val value = get_value(node)

    # Check value range
    if value <= min_val:
        return false
    if value >= max_val:
        return false

    # Check children
    val left = get_left(node)
    val right = get_right(node)
    val left_valid = check_bst(left, min_val, value)
    if left_valid == false:
        return false
    check_bst(right, value, max_val)

# Check if tree is a valid AVL tree (BST + balanced)
fn is_valid_avl(tree) -> bool:
    val bst_valid = is_valid_bst(tree)
    if bst_valid == false:
        return false
    is_balanced(tree)

# ============================================================================
# Traversal Operations
# ============================================================================

# Inorder traversal (returns sorted list)
fn inorder(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    inorder_traverse(root, result)
    result

# Inorder traversal helper
fn inorder_traverse(node, result):
    if is_nil(node):
        return result

    val left = get_left(node)
    var updated = inorder_traverse(left, result)

    val value = get_value(node)
    updated = updated + [value]

    val right = get_right(node)
    inorder_traverse(right, updated)

# Preorder traversal
fn preorder(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    preorder_traverse(root, result)
    result

# Preorder traversal helper
fn preorder_traverse(node, result):
    if is_nil(node):
        return result

    val value = get_value(node)
    var updated = result + [value]

    val left = get_left(node)
    updated = preorder_traverse(left, updated)

    val right = get_right(node)
    preorder_traverse(right, updated)

# Postorder traversal
fn postorder(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    postorder_traverse(root, result)
    result

# Postorder traversal helper
fn postorder_traverse(node, result):
    if is_nil(node):
        return result

    val left = get_left(node)
    var updated = postorder_traverse(left, result)

    val right = get_right(node)
    updated = postorder_traverse(right, updated)

    val value = get_value(node)
    updated + [value]

# Level-order traversal (BFS)
fn level_order(tree) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    if is_nil(root):
        return []

    val result = []
    val queue = [root]
    level_order_traverse(queue, result)

# Level-order traversal helper
fn level_order_traverse(queue, result):
    if queue == []:
        return result

    # Dequeue first node
    val node = queue.0
    val rest_queue = queue[1:]

    if is_nil(node):
        return level_order_traverse(rest_queue, result)

    # Add value to result
    val value = get_value(node)
    var updated_result = result + [value]

    # Enqueue children
    val left = get_left(node)
    val right = get_right(node)
    var updated_queue = rest_queue
    if is_nil(left) == false:
        updated_queue = updated_queue + [left]
    if is_nil(right) == false:
        updated_queue = updated_queue + [right]

    level_order_traverse(updated_queue, updated_result)

# Convert tree to sorted list (inorder traversal)
fn avl_to_list(tree) -> (i64, (i64, (i64, (i64, i64)))):
    inorder(tree)

# ============================================================================
# Range Query Operations
# ============================================================================

# Range query: find all values in [min, max]
fn range_query(tree, min_val: i64, max_val: i64) -> (i64, (i64, (i64, (i64, i64)))):
    val root = get_root(tree)
    val result = []
    range_search(root, min_val, max_val, result)

# Range search helper
fn range_search(node, min_val: i64, max_val: i64, result):
    if is_nil(node):
        return result

    val value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    var updated = result

    # Search left if value might be there
    if value > min_val:
        updated = range_search(left, min_val, max_val, updated)

    # Add current value if in range
    var in_range = value >= min_val
    if in_range:
        in_range = value <= max_val
    if in_range:
        updated = updated + [value]

    # Search right if value might be there
    if value < max_val:
        updated = range_search(right, min_val, max_val, updated)

    updated

# Count values in range [min, max]
fn count_range(tree, min_val: i64, max_val: i64) -> i64:
    val root = get_root(tree)
    count_in_range(root, min_val, max_val)

# Count in range helper
fn count_in_range(node, min_val: i64, max_val: i64) -> i64:
    if is_nil(node):
        return 0

    val value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    var count = 0

    # Count left if values might be there
    if value > min_val:
        val left_count = count_in_range(left, min_val, max_val)
        count = count + left_count

    # Count current if in range
    var in_range = value >= min_val
    if in_range:
        in_range = value <= max_val
    if in_range:
        count = count + 1

    # Count right if values might be there
    if value < max_val:
        val right_count = count_in_range(right, min_val, max_val)
        count = count + right_count

    count

# ============================================================================
# Kth Element Operations
# ============================================================================

# Find k-th smallest element (1-indexed)
fn kth_smallest(tree, k: i64) -> i64:
    val root = get_root(tree)
    val result = find_kth_smallest(root, k)
    if is_nil(result):
        return 0
    get_value(result)

# Find k-th smallest node
fn find_kth_smallest(node, k: i64):
    if is_nil(node):
        return nil

    val left = get_left(node)
    val left_size = count_nodes(left)

    # k-th smallest is in left subtree
    if k <= left_size:
        return find_kth_smallest(left, k)

    # Current node is k-th smallest
    if k == left_size + 1:
        return node

    # k-th smallest is in right subtree
    val right = get_right(node)
    val new_k = k - left_size - 1
    find_kth_smallest(right, new_k)

# Find k-th largest element (1-indexed)
fn kth_largest(tree, k: i64) -> i64:
    val root = get_root(tree)
    val result = find_kth_largest(root, k)
    if is_nil(result):
        return 0
    get_value(result)

# Find k-th largest node
fn find_kth_largest(node, k: i64):
    if is_nil(node):
        return nil

    val right = get_right(node)
    val right_size = count_nodes(right)

    # k-th largest is in right subtree
    if k <= right_size:
        return find_kth_largest(right, k)

    # Current node is k-th largest
    if k == right_size + 1:
        return node

    # k-th largest is in left subtree
    val left = get_left(node)
    val new_k = k - right_size - 1
    find_kth_largest(left, new_k)

# ============================================================================
# Count Operations
# ============================================================================

# Count elements less than value
fn count_less_than(tree, value: i64) -> i64:
    val root = get_root(tree)
    count_less(root, value)

# Count less than helper
fn count_less(node, value: i64) -> i64:
    if is_nil(node):
        return 0

    val node_value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    # If node value >= value, all matching are in left
    if node_value >= value:
        return count_less(left, value)

    # If node value < value, count this + all left + some right
    val left_count = count_nodes(left)
    val right_count = count_less(right, value)
    1 + left_count + right_count

# Count elements greater than value
fn count_greater_than(tree, value: i64) -> i64:
    val root = get_root(tree)
    count_greater(root, value)

# Count greater than helper
fn count_greater(node, value: i64) -> i64:
    if is_nil(node):
        return 0

    val node_value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)

    # If node value <= value, all matching are in right
    if node_value <= value:
        return count_greater(right, value)

    # If node value > value, count this + all right + some left
    val right_count = count_nodes(right)
    val left_count = count_greater(left, value)
    1 + right_count + left_count

# ============================================================================
# Bulk Operations
# ============================================================================

# Build balanced tree from sorted array
fn build_from_sorted(values) -> (any, i64):
    val n = values.length
    if n == 0:
        return create_avl_tree()
    val root = build_from_sorted_helper(values, 0, n - 1)
    (root, n)

# Build from sorted array helper
fn build_from_sorted_helper(values, start: i64, end: i64):
    if start > end:
        return nil

    val mid = start + ((end - start) / 2)
    val value = values[mid]

    val left = build_from_sorted_helper(values, start, mid - 1)
    val right = build_from_sorted_helper(values, mid + 1, end)

    var node = create_node(value)
    node = set_left(node, left)
    node = set_right(node, right)
    update_height(node)

# Build balanced tree from unsorted array
fn build_balanced(values) -> (any, i64):
    val n = values.length
    if n == 0:
        return create_avl_tree()

    # Sort array first (simple bubble sort for now)
    val sorted = bubble_sort(values)
    build_from_sorted(sorted)

# Simple bubble sort for build_balanced
fn bubble_sort(arr):
    val n = arr.length
    if n <= 1:
        return arr
    var sorted = arr
    var i = 0
    while i < n - 1:
        var j = 0
        while j < n - i - 1:
            val curr = sorted[j]
            val next = sorted[j + 1]
            if curr > next:
                # Swap
                var temp = []
                var k = 0
                while k < sorted.length:
                    if k == j:
                        temp = temp + [next]
                    else:
                        var cond = k == j + 1
                        if cond:
                            temp = temp + [curr]
                        else:
                            temp = temp + [sorted[k]]
                    k = k + 1
                sorted = temp
            j = j + 1
        i = i + 1
    sorted

# ============================================================================
# Tree Merge and Split Operations
# ============================================================================

# Merge two AVL trees
fn merge_trees(tree1, tree2) -> (any, i64):
    val list1 = avl_to_list(tree1)
    val list2 = avl_to_list(tree2)
    val merged = merge_sorted_lists(list1, list2)
    build_from_sorted(merged)

# Merge two sorted lists
fn merge_sorted_lists(list1, list2):
    if list1 == []:
        return list2
    if list2 == []:
        return list1

    val h1 = list1.0
    val h2 = list2.0

    if h1 <= h2:
        val t1 = list1[1:]
        val rest = merge_sorted_lists(t1, list2)
        return [h1] + rest

    val t2 = list2[1:]
    val rest = merge_sorted_lists(list1, t2)
    [h2] + rest

# Split tree at value (returns two trees: < value and >= value)
fn split_tree(tree, value: i64) -> ((any, i64), (any, i64)):
    val all_values = avl_to_list(tree)
    val left_values = filter_less_than(all_values, value)
    val right_values = filter_greater_equal(all_values, value)
    val left_tree = build_from_sorted(left_values)
    val right_tree = build_from_sorted(right_values)
    (left_tree, right_tree)

# Filter values less than target
fn filter_less_than(values, target: i64):
    if values == []:
        return []
    val head = values.0
    val tail = values[1:]
    val rest = filter_less_than(tail, target)
    if head < target:
        return [head] + rest
    rest

# Filter values greater than or equal to target
fn filter_greater_equal(values, target: i64):
    if values == []:
        return []
    val head = values.0
    val tail = values[1:]
    val rest = filter_greater_equal(tail, target)
    if head >= target:
        return [head] + rest
    rest

# ============================================================================
# Clone and Copy Operations
# ============================================================================

# Deep copy of tree
fn clone_tree(tree) -> (any, i64):
    val root = get_root(tree)
    val size = get_size(tree)
    val new_root = clone_node(root)
    (new_root, size)

# Clone node recursively
fn clone_node(node):
    if is_nil(node):
        return nil

    val value = get_value(node)
    val left = get_left(node)
    val right = get_right(node)
    val height = get_node_height(node)

    val new_left = clone_node(left)
    val new_right = clone_node(right)

    (value, new_left, new_right, height)

# ============================================================================
# Visualization Operations
# ============================================================================

# Generate Graphviz DOT format
fn tree_to_dot(tree) -> text:
    val root = get_root(tree)
    var dot = "digraph AVLTree {\n"
    dot = dot + "    node [shape=circle];\n"
    val content = node_to_dot(root, 0)
    dot = dot + content
    dot + "}\n"

# Convert node to DOT format
fn node_to_dot(node, node_id: i64) -> text:
    if is_nil(node):
        return ""

    val value = get_value(node)
    val height = get_node_height(node)
    val label = "{value} (h:{height})"
    var result = "    n{node_id} [label=\"{label}\"];\n"

    val left = get_left(node)
    val right = get_right(node)
    val left_id = node_id * 2 + 1
    val right_id = node_id * 2 + 2

    if is_nil(left) == false:
        result = result + "    n{node_id} -> n{left_id};\n"
        val left_dot = node_to_dot(left, left_id)
        result = result + left_dot

    if is_nil(right) == false:
        result = result + "    n{node_id} -> n{right_id};\n"
        val right_dot = node_to_dot(right, right_id)
        result = result + right_dot

    result

# Print tree in ASCII format (simple version)
fn print_tree(tree):
    val root = get_root(tree)
    print_node(root, "", true)

# Print node recursively
fn print_node(node, prefix: text, is_tail: bool):
    if is_nil(node):
        return ()

    val value = get_value(node)
    val height = get_node_height(node)
    val bf = get_balance_factor(node)

    var connector = "└── "
    if is_tail == false:
        connector = "├── "

    print "{prefix}{connector}{value} (h:{height}, bf:{bf})"

    val left = get_left(node)
    val right = get_right(node)

    var new_prefix = prefix
    if is_tail:
        new_prefix = prefix + "    "
    else:
        new_prefix = prefix + "│   "

    if is_nil(right) == false:
        print_node(right, new_prefix, false)

    if is_nil(left) == false:
        print_node(left, new_prefix, true)

    ()
