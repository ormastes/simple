# Sorting - Advanced Algorithms (QuickSort, MergeSort, HeapSort)

use sorting.simple.{insertion_sort_range}

# Partition algorithms
fn lomuto_partition(arr: List<i64>, low: i64, high: i64) -> i64:
    val pivot = arr.get(high)
    var i = low - 1

    var j = low
    while j < high:
        val curr = arr.get(j)
        if curr <= pivot:
            i = i + 1
            val temp = arr.get(i)
            arr.set(i, curr)
            arr.set(j, temp)
        j = j + 1

    val temp = arr.get(i + 1)
    arr.set(i + 1, arr.get(high))
    arr.set(high, temp)
    i + 1

fn hoare_partition(arr: List<i64>, low: i64, high: i64) -> i64:
    val mid = low + (high - low) / 2
    val pivot = arr.get(mid)
    var i = low - 1
    var j = high + 1

    var done = false
    while not done:
        var i_done = false
        while not i_done:
            i = i + 1
            val curr = arr.get(i)
            if curr >= pivot:
                i_done = true

        var j_done = false
        while not j_done:
            j = j - 1
            val curr = arr.get(j)
            if curr <= pivot:
                j_done = true

        if i >= j:
            done = true
        else:
            val temp = arr.get(i)
            arr.set(i, arr.get(j))
            arr.set(j, temp)
    j

fn three_way_partition(arr: List<i64>, low: i64, high: i64) -> List<i64>:
    val pivot = arr.get(high)
    var lt = low
    var i = low
    var gt = high

    while i <= gt:
        val curr = arr.get(i)
        if curr < pivot:
            val temp = arr.get(lt)
            arr.set(lt, curr)
            arr.set(i, temp)
            lt = lt + 1
            i = i + 1
        else if curr > pivot:
            val temp = arr.get(gt)
            arr.set(gt, curr)
            arr.set(i, temp)
            gt = gt - 1
        else:
            i = i + 1

    [lt, gt]

# QuickSort
fn quicksort_lomuto(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    quicksort_lomuto_helper(result, 0, result.len() - 1)
    result

fn quicksort_lomuto_helper(arr: List<i64>, low: i64, high: i64):
    if low < high:
        val pi = lomuto_partition(arr, low, high)
        quicksort_lomuto_helper(arr, low, pi - 1)
        quicksort_lomuto_helper(arr, pi + 1, high)

fn quicksort_hoare(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    quicksort_hoare_helper(result, 0, result.len() - 1)
    result

fn quicksort_hoare_helper(arr: List<i64>, low: i64, high: i64):
    if low < high:
        val pi = hoare_partition(arr, low, high)
        quicksort_hoare_helper(arr, low, pi)
        quicksort_hoare_helper(arr, pi + 1, high)

fn quicksort_3way(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    quicksort_3way_helper(result, 0, result.len() - 1)
    result

fn quicksort_3way_helper(arr: List<i64>, low: i64, high: i64):
    if low < high:
        val boundaries = three_way_partition(arr, low, high)
        val lt = boundaries.get(0)
        val gt = boundaries.get(1)
        quicksort_3way_helper(arr, low, lt - 1)
        quicksort_3way_helper(arr, gt + 1, high)

# Merge operations
fn copy_range(arr: List<i64>, start: i64, end: i64) -> List<i64>:
    var result = []
    var i = start
    while i <= end:
        val elem = arr.get(i)
        result = result.push(elem)
        i = i + 1
    result

fn merge_sorted_arrays(left: List<i64>, right: List<i64>) -> List<i64>:
    var result = []
    var i = 0
    var j = 0
    val left_len = left.len()
    val right_len = right.len()

    while i < left_len and j < right_len:
        val left_val = left.get(i)
        val right_val = right.get(j)
        if left_val <= right_val:
            result = result.push(left_val)
            i = i + 1
        else:
            result = result.push(right_val)
            j = j + 1

    while i < left_len:
        val val = left.get(i)
        result = result.push(val)
        i = i + 1

    while j < right_len:
        val val = right.get(j)
        result = result.push(val)
        j = j + 1

    result

fn merge_in_place(arr: List<i64>, left: i64, mid: i64, right: i64):
    val left_part = copy_range(arr, left, mid)
    val right_part = copy_range(arr, mid + 1, right)

    var i = 0
    var j = 0
    var k = left
    val left_len = left_part.len()
    val right_len = right_part.len()

    while i < left_len and j < right_len:
        val left_val = left_part.get(i)
        val right_val = right_part.get(j)
        if left_val <= right_val:
            arr.set(k, left_val)
            i = i + 1
        else:
            arr.set(k, right_val)
            j = j + 1
        k = k + 1

    while i < left_len:
        val val = left_part.get(i)
        arr.set(k, val)
        i = i + 1
        k = k + 1

    while j < right_len:
        val val = right_part.get(j)
        arr.set(k, val)
        j = j + 1
        k = k + 1

# MergeSort
fn mergesort(arr: List<i64>) -> List<i64>:
    val len = arr.len()
    if len <= 1:
        return arr

    val mid = len / 2
    val left = copy_range(arr, 0, mid - 1)
    val right = copy_range(arr, mid, len - 1)

    val sorted_left = mergesort(left)
    val sorted_right = mergesort(right)
    merge_sorted_arrays(sorted_left, sorted_right)

fn mergesort_in_place(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    mergesort_in_place_helper(result, 0, result.len() - 1)
    result

fn mergesort_in_place_helper(arr: List<i64>, left: i64, right: i64):
    if left < right:
        val mid = left + (right - left) / 2
        mergesort_in_place_helper(arr, left, mid)
        mergesort_in_place_helper(arr, mid + 1, right)
        merge_in_place(arr, left, mid, right)

fn mergesort_iterative(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()

    var curr_size = 1
    while curr_size < len:
        var left_start = 0
        while left_start < len:
            val mid_calc = left_start + curr_size - 1
            val mid = if mid_calc < len - 1: mid_calc else: len - 1

            val right_end_calc = left_start + curr_size * 2 - 1
            val right_end = if right_end_calc < len - 1: right_end_calc else: len - 1

            if mid < right_end:
                merge_in_place(result, left_start, mid, right_end)

            left_start = left_start + curr_size * 2

        curr_size = curr_size * 2

    result

# Heap operations
fn heap_parent(i: i64) -> i64:
    (i - 1) / 2

fn heap_left_child(i: i64) -> i64:
    2 * i + 1

fn heap_right_child(i: i64) -> i64:
    2 * i + 2

fn heap_sift_down(arr: List<i64>, start: i64, end: i64):
    var root = start

    var done = false
    while not done:
        val left = heap_left_child(root)
        val right = heap_right_child(root)
        var largest = root

        if left <= end:
            val root_val = arr.get(largest)
            val left_val = arr.get(left)
            if left_val > root_val:
                largest = left

        if right <= end:
            val largest_val = arr.get(largest)
            val right_val = arr.get(right)
            if right_val > largest_val:
                largest = right

        if largest != root:
            val temp = arr.get(root)
            arr.set(root, arr.get(largest))
            arr.set(largest, temp)
            root = largest
        else:
            done = true

fn heapify(arr: List<i64>):
    val len = arr.len()
    var start = heap_parent(len - 1)

    while start >= 0:
        heap_sift_down(arr, start, len - 1)
        start = start - 1

fn heapsort(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()

    heapify(result)

    var end = len - 1
    while end > 0:
        val temp = result.get(0)
        result.set(0, result.get(end))
        result.set(end, temp)

        end = end - 1
        heap_sift_down(result, 0, end)

    result

# Hybrid: Introsort
fn log2_floor(n: i64) -> i64:
    var result = 0
    var val = n
    while val > 1:
        val = val / 2
        result = result + 1
    result

fn heap_sift_down_range(arr: List<i64>, start: i64, end: i64, offset: i64):
    var root = start

    var done = false
    while not done:
        val left = offset + 2 * (root - offset) + 1
        val right = offset + 2 * (root - offset) + 2
        var largest = root

        if left <= end:
            val root_val = arr.get(largest)
            val left_val = arr.get(left)
            if left_val > root_val:
                largest = left

        if right <= end:
            val largest_val = arr.get(largest)
            val right_val = arr.get(right)
            if right_val > largest_val:
                largest = right

        if largest != root:
            val temp = arr.get(root)
            arr.set(root, arr.get(largest))
            arr.set(largest, temp)
            root = largest
        else:
            done = true

fn heap_sort_range(arr: List<i64>, low: i64, high: i64):
    val size = high - low + 1

    var start = low + (size / 2) - 1
    while start >= low:
        heap_sift_down_range(arr, start, high, low)
        start = start - 1

    var end = high
    while end > low:
        val temp = arr.get(low)
        arr.set(low, arr.get(end))
        arr.set(end, temp)

        end = end - 1
        heap_sift_down_range(arr, low, end, low)

fn introsort(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()
    val max_depth = log2_floor(len) * 2
    introsort_helper(result, 0, len - 1, max_depth)
    result

fn introsort_helper(arr: List<i64>, low: i64, high: i64, depth_limit: i64):
    val size = high - low + 1

    if size < 16:
        insertion_sort_range(arr, low, high)
        return ()

    if depth_limit == 0:
        heap_sort_range(arr, low, high)
        return ()

    val pi = lomuto_partition(arr, low, high)
    introsort_helper(arr, low, pi - 1, depth_limit - 1)
    introsort_helper(arr, pi + 1, high, depth_limit - 1)

fn timsort_simple(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()
    val run_size = 32

    var i = 0
    while i < len:
        val end_calc = i + run_size - 1
        val end = if end_calc < len - 1: end_calc else: len - 1
        insertion_sort_range(result, i, end)
        i = i + run_size

    var size = run_size
    while size < len:
        var left = 0
        while left < len:
            val mid_calc = left + size - 1
            val mid = if mid_calc < len - 1: mid_calc else: len - 1

            val right_calc = left + size * 2 - 1
            val right = if right_calc < len - 1: right_calc else: len - 1

            if mid < right:
                merge_in_place(result, left, mid, right)

            left = left + size * 2

        size = size * 2

    result

export lomuto_partition, hoare_partition, three_way_partition
export quicksort_lomuto, quicksort_hoare, quicksort_3way
export copy_range, merge_sorted_arrays, merge_in_place
export mergesort, mergesort_in_place, mergesort_iterative
export heap_parent, heap_left_child, heap_right_child, heap_sift_down, heapify, heapsort
export introsort, timsort_simple
