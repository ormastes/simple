# Sorting - Simple Comparison Sorts

# Contains: bubble_sort, selection_sort, insertion_sort

fn bubble_sort(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()

    var i = 0
    while i < len:
        var j = 0
        while j < len - i - 1:
            val curr = result.get(j)
            val next = result.get(j + 1)
            if curr > next:
                result.set(j, next)
                result.set(j + 1, curr)
            j = j + 1
        i = i + 1
    result

fn bubble_sort_optimized(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()

    var i = 0
    var swapped = true
    while i < len and swapped:
        swapped = false
        var j = 0
        while j < len - i - 1:
            val curr = result.get(j)
            val next = result.get(j + 1)
            if curr > next:
                result.set(j, next)
                result.set(j + 1, curr)
                swapped = true
            j = j + 1
        i = i + 1
    result

fn selection_sort(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()

    var i = 0
    while i < len - 1:
        var min_idx = i
        var j = i + 1
        while j < len:
            val curr_min = result.get(min_idx)
            val candidate = result.get(j)
            if candidate < curr_min:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = result.get(i)
            result.set(i, result.get(min_idx))
            result.set(min_idx, temp)
        i = i + 1
    result

fn insertion_sort(arr: List<i64>) -> List<i64>:
    var result = arr.copy()
    val len = result.len()

    var i = 1
    while i < len:
        val key = result.get(i)
        var j = i - 1

        var done = false
        while j >= 0 and not done:
            val curr = result.get(j)
            if curr > key:
                result.set(j + 1, curr)
                j = j - 1
            else:
                done = true

        result.set(j + 1, key)
        i = i + 1
    result

fn insertion_sort_range(arr: List<i64>, start: i64, end: i64):
    var i = start + 1
    while i <= end:
        val key = arr.get(i)
        var j = i - 1

        var done = false
        while j >= start and not done:
            val curr = arr.get(j)
            if curr > key:
                arr.set(j + 1, curr)
                j = j - 1
            else:
                done = true

        arr.set(j + 1, key)
        i = i + 1

export bubble_sort, bubble_sort_optimized, selection_sort, insertion_sort, insertion_sort_range
