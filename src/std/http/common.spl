# HTTP Common Utilities
#
# Shared utility functions used across HTTP modules to avoid code duplication.

# ============================================================================
# Header Parsing (shared by request and response modules)
# ============================================================================

# Parse list of header lines into list of (name, value) tuples
fn parse_headers(lines: list) -> list:
    var headers = []
    var i = 0
    while i < lines.length():
        val line = lines[i]
        val header = parse_header(line)
        headers = headers.append(header)
        i = i + 1
    return headers

# Parse single header line
# Example: "Content-Type: application/json" -> ("Content-Type", "application/json")
fn parse_header(line: text) -> tuple:
    val colon_pos = line.index_of(":")

    if colon_pos < 0:
        return ("", "")

    val name = line.substring(0, colon_pos)

    var value_start = colon_pos + 1

    # Skip leading whitespace in value
    while value_start < line.length():
        val ch = line[value_start]
        var is_space = false
        if ch == " ":
            is_space = true
        if ch == "\t":
            is_space = true

        if is_space:
            value_start = value_start + 1
        else:
            break

    val value = line.substring(value_start, line.length())

    return (name, value)

# Format headers list into HTTP header text
fn format_headers(headers: list) -> text:
    var result = ""
    var i = 0
    while i < headers.length():
        val header = headers[i]
        val name = header[0]
        val value = header[1]

        result = result + name
        result = result + ": "
        result = result + value
        result = result + "\r\n"

        i = i + 1
    return result

# ============================================================================
# Number Parsing (shared across modules)
# ============================================================================

# Parse integer from text
fn parse_int(text: text) -> i64:
    var result = 0
    var i = 0
    while i < text.length():
        val ch = text[i]
        if ch >= "0" and ch <= "9":
            val digit_val = ch.char_code() - "0".char_code()
            result = result * 10
            result = result + digit_val
        i = i + 1
    return result

# Convert hex digit to integer
fn hex_to_int(ch: text) -> i64:
    if ch >= "0" and ch <= "9":
        return ch.char_code() - "0".char_code()

    if ch >= "A" and ch <= "F":
        val offset = ch.char_code() - "A".char_code()
        return 10 + offset

    if ch >= "a" and ch <= "f":
        val offset = ch.char_code() - "a".char_code()
        return 10 + offset

    return 0

# ============================================================================
# String Utilities
# ============================================================================

# Find substring with start position
fn index_of(text: text, substring: text, start: i64) -> i64:
    var i = start
    while i <= text.length() - substring.length():
        var match = true
        var j = 0
        while j < substring.length():
            if text[i + j] != substring[j]:
                match = false
                break
            j = j + 1

        if match:
            return i

        i = i + 1

    return -1
