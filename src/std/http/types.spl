# HTTP Types and Constants
#
# Provides HTTP-related type definitions and status code utilities.

# ============================================================================
# Status Code Utilities
# ============================================================================

# Get status text for HTTP status code
fn status_text(code: i64) -> text:
    # 1xx Informational
    if code == 100:
        return "Continue"
    if code == 101:
        return "Switching Protocols"

    # 2xx Success
    if code == 200:
        return "OK"
    if code == 201:
        return "Created"
    if code == 202:
        return "Accepted"
    if code == 204:
        return "No Content"
    if code == 206:
        return "Partial Content"

    # 3xx Redirection
    if code == 300:
        return "Multiple Choices"
    if code == 301:
        return "Moved Permanently"
    if code == 302:
        return "Found"
    if code == 303:
        return "See Other"
    if code == 304:
        return "Not Modified"
    if code == 307:
        return "Temporary Redirect"
    if code == 308:
        return "Permanent Redirect"

    # 4xx Client Error
    if code == 400:
        return "Bad Request"
    if code == 401:
        return "Unauthorized"
    if code == 403:
        return "Forbidden"
    if code == 404:
        return "Not Found"
    if code == 405:
        return "Method Not Allowed"
    if code == 406:
        return "Not Acceptable"
    if code == 408:
        return "Request Timeout"
    if code == 409:
        return "Conflict"
    if code == 410:
        return "Gone"
    if code == 413:
        return "Payload Too Large"
    if code == 414:
        return "URI Too Long"
    if code == 415:
        return "Unsupported Media Type"
    if code == 429:
        return "Too Many Requests"

    # 5xx Server Error
    if code == 500:
        return "Internal Server Error"
    if code == 501:
        return "Not Implemented"
    if code == 502:
        return "Bad Gateway"
    if code == 503:
        return "Service Unavailable"
    if code == 504:
        return "Gateway Timeout"
    if code == 505:
        return "HTTP Version Not Supported"

    return "Unknown"

# Check if status code is success (2xx)
fn is_success(code: i64) -> bool:
    return code >= 200 and code < 300

# Check if status code is redirect (3xx)
fn is_redirect(code: i64) -> bool:
    return code >= 300 and code < 400

# Check if status code is client error (4xx)
fn is_client_error(code: i64) -> bool:
    return code >= 400 and code < 500

# Check if status code is server error (5xx)
fn is_server_error(code: i64) -> bool:
    return code >= 500 and code < 600

# Check if status code is error (4xx or 5xx)
fn is_error(code: i64) -> bool:
    return code >= 400

# Check if status code is informational (1xx)
fn is_informational(code: i64) -> bool:
    return code >= 100 and code < 200

# ============================================================================
# HTTP Method Utilities
# ============================================================================

# Check if HTTP method is safe (no side effects)
fn is_safe_method(method: text) -> bool:
    val upper = method.to_upper()

    if upper == "GET":
        return true
    if upper == "HEAD":
        return true
    if upper == "OPTIONS":
        return true
    if upper == "TRACE":
        return true

    return false

# Check if HTTP method is idempotent
fn is_idempotent(method: text) -> bool:
    val upper = method.to_upper()

    if upper == "GET":
        return true
    if upper == "HEAD":
        return true
    if upper == "PUT":
        return true
    if upper == "DELETE":
        return true
    if upper == "OPTIONS":
        return true
    if upper == "TRACE":
        return true

    return false

# Check if HTTP method typically has a request body
fn has_request_body(method: text) -> bool:
    val upper = method.to_upper()

    if upper == "POST":
        return true
    if upper == "PUT":
        return true
    if upper == "PATCH":
        return true

    return false

# Check if HTTP method is valid
fn is_valid_method(method: text) -> bool:
    val upper = method.to_upper()

    if upper == "GET":
        return true
    if upper == "POST":
        return true
    if upper == "PUT":
        return true
    if upper == "DELETE":
        return true
    if upper == "PATCH":
        return true
    if upper == "HEAD":
        return true
    if upper == "OPTIONS":
        return true
    if upper == "TRACE":
        return true
    if upper == "CONNECT":
        return true

    return false

# ============================================================================
# Content Type Handling
# ============================================================================

# Parse Content-Type header
# Returns: (media_type, charset)
fn parse_content_type(header: text) -> tuple:
    val parts = header.split(";")

    if parts.length() == 0:
        return ("text/plain", nil)

    val media_type = parts[0].trim()

    var charset = nil

    var i = 1
    while i < parts.length():
        val part = parts[i].trim()

        if part.starts_with("charset="):
            charset = part.substring(8, part.length())

        i = i + 1

    return (media_type, charset)

# Check if content type is JSON
fn is_json(content_type: text) -> bool:
    val lower = content_type.to_lower()
    return lower.contains("json")

# Check if content type is HTML
fn is_html(content_type: text) -> bool:
    val lower = content_type.to_lower()
    return lower.contains("html")

# Check if content type is XML
fn is_xml(content_type: text) -> bool:
    val lower = content_type.to_lower()
    return lower.contains("xml")

# Check if content type is text
fn is_text(content_type: text) -> bool:
    val lower = content_type.to_lower()
    return lower.starts_with("text/")
