# HTTP URL Handling
#
# Provides URL encoding/decoding and query string handling.

import common from "std/http/common"

# ============================================================================
# Query String Handling
# ============================================================================

# Parse query string into list of (name, value) tuples
# Example: "name=Alice&age=30" -> [("name", "Alice"), ("age", "30")]
fn parse_query_string(query: text) -> list:
    if query.length() == 0:
        return []

    val pairs = query.split("&")
    var params = []

    var i = 0
    while i < pairs.length():
        val pair = pairs[i]
        val param = parse_query_param(pair)
        params = params.append(param)
        i = i + 1

    return params

# Parse single query parameter
# Example: "name=Alice" -> ("name", "Alice")
fn parse_query_param(pair: text) -> tuple:
    val eq_pos = pair.index_of("=")

    if eq_pos < 0:
        return (pair, "")

    val name = pair.substring(0, eq_pos)
    val value_encoded = pair.substring(eq_pos + 1, pair.length())
    val value = url_decode(value_encoded)

    return (name, value)

# Build query string from list of (name, value) tuples
fn build_query_string(params: list) -> text:
    if params.length() == 0:
        return ""

    var parts = []
    var i = 0
    while i < params.length():
        val param = params[i]
        val name = param[0]
        val value = param[1]

        val encoded_value = url_encode(value)

        var part = name
        part = part + "="
        part = part + encoded_value

        parts = parts.append(part)
        i = i + 1

    return "&".join(parts)

# Encode query parameter value
fn encode_query_param(value: text) -> text:
    return url_encode(value)

# Get query parameter value by name
fn get_query_param(params: list, name: text) -> text:
    var i = 0
    while i < params.length():
        val param = params[i]
        val param_name = param[0]
        val param_value = param[1]

        if param_name == name:
            return param_value

        i = i + 1

    return nil

# ============================================================================
# URL Encoding/Decoding
# ============================================================================

# URL encode text (percent encoding)
fn url_encode(text: text) -> text:
    var result = ""
    var i = 0

    while i < text.length():
        val ch = text[i]

        val should_encode = should_url_encode_char(ch)

        if should_encode:
            val encoded = percent_encode_char(ch)
            result = result + encoded
        else:
            result = result + ch

        i = i + 1

    return result

# Check if character should be URL encoded
fn should_url_encode_char(ch: text) -> bool:
    # Unreserved characters (don't encode): A-Z a-z 0-9 - _ . ~

    var is_alpha = false
    if ch >= "A" and ch <= "Z":
        is_alpha = true
    if ch >= "a" and ch <= "z":
        is_alpha = true

    var is_digit = false
    if ch >= "0" and ch <= "9":
        is_digit = true

    var is_unreserved = false
    if ch == "-":
        is_unreserved = true
    if ch == "_":
        is_unreserved = true
    if ch == ".":
        is_unreserved = true
    if ch == "~":
        is_unreserved = true

    var should_not_encode = false
    if is_alpha:
        should_not_encode = true
    if is_digit:
        should_not_encode = true
    if is_unreserved:
        should_not_encode = true

    if should_not_encode:
        return false

    return true

# Percent encode a single character
fn percent_encode_char(ch: text) -> text:
    val code = ch.char_code()

    var result = "%"
    result = result + to_hex(code)

    return result

# Convert integer to hex string (2 digits)
fn to_hex(n: i64) -> text:
    val hex_chars = "0123456789ABCDEF"

    val high = n / 16
    val low = n % 16

    var result = hex_chars[high]
    result = result + hex_chars[low]

    return result

# URL decode text (percent decoding)
fn url_decode(encoded: text) -> text:
    var result = ""
    var i = 0

    while i < encoded.length():
        val ch = encoded[i]

        if ch == "%":
            # Decode percent-encoded character
            if i + 2 < encoded.length():
                val hex1 = encoded[i + 1]
                val hex2 = encoded[i + 2]

                val code = from_hex(hex1, hex2)
                val decoded = char_from_code(code)

                result = result + decoded
                i = i + 3
            else:
                result = result + ch
                i = i + 1
        else:
            if ch == "+":
                result = result + " "
            else:
                result = result + ch
            i = i + 1

    return result

# Convert two hex digits to integer
fn from_hex(hex1: text, hex2: text) -> i64:
    val high = common.hex_to_int(hex1)
    val low = common.hex_to_int(hex2)

    val result = high * 16
    return result + low

# Convert character code to character
fn char_from_code(code: i64) -> text:
    # This is a simplified version - in real implementation
    # we would use proper character encoding
    if code >= 32 and code <= 126:
        # Printable ASCII range
        val chars = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        val index = code - 32
        if index >= 0 and index < chars.length():
            return chars[index]

    return "?"

# URL encode component (encodes more characters than url_encode)
fn url_encode_component(text: text) -> text:
    # For now, same as url_encode
    return url_encode(text)
