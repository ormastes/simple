# statistics_utils.spl - Comprehensive Statistical Analysis Module
#
# Provides statistical functions for data analysis including:
# - Descriptive statistics (mean, median, mode, quartiles, percentiles)
# - Measures of spread (variance, standard deviation, MAD, CV)
# - Measures of shape (skewness, kurtosis)
# - Correlation analysis (Pearson, Spearman, Kendall)
# - Regression analysis (linear regression, R-squared)
# - Probability distributions (normal, uniform, binomial, Poisson)
# - Statistical tests (t-test, chi-square, z-score)
# - Data transformations (normalization, standardization, log)
# - Frequency analysis (frequency tables, histogram bins)
# - Moving statistics (moving average, exponential moving average)
# - Utility functions (sum, product, cumulative operations)

import math from "std/math"
import array from "std/array"

# ============================================================================
# CONSTANTS
# ============================================================================

val EPSILON = 1e-10
val PI = 3.141592653589793
val E = 2.718281828459045
val SQRT_2PI = 2.5066282746310002

# ============================================================================
# BASIC UTILITIES
# ============================================================================

fn sum(data: List<f64>) -> f64:
    """Calculate the sum of all values in the array."""
    if data.length() == 0:
        return 0.0

    var total = 0.0
    for val in data:
        total = total + val
    total

fn product(data: List<f64>) -> f64:
    """Calculate the product of all values in the array."""
    if data.length() == 0:
        return 1.0

    var prod = 1.0
    for val in data:
        prod = prod * val
    prod

fn count(data: List<f64>) -> i64:
    """Count the number of elements."""
    data.length()

fn count_non_zero(data: List<f64>) -> i64:
    """Count non-zero elements."""
    var cnt = 0
    for val in data:
        if math.abs(val) > EPSILON:
            cnt = cnt + 1
    cnt

fn cumsum(data: List<f64>) -> List<f64>:
    """Calculate cumulative sum."""
    var result = []
    var running_sum = 0.0

    for val in data:
        running_sum = running_sum + val
        result.push(running_sum)

    result

fn cumprod(data: List<f64>) -> List<f64>:
    """Calculate cumulative product."""
    var result = []
    var running_prod = 1.0

    for val in data:
        running_prod = running_prod * val
        result.push(running_prod)

    result

fn diff(data: List<f64>) -> List<f64>:
    """Calculate differences between consecutive elements."""
    if data.length() < 2:
        return []

    var result = []
    var i = 1
    while i < data.length():
        val d = data[i] - data[i - 1]
        result.push(d)
        i = i + 1

    result

fn pct_change(data: List<f64>) -> List<f64>:
    """Calculate percentage change between consecutive elements."""
    if data.length() < 2:
        return []

    var result = []
    var i = 1
    while i < data.length():
        if math.abs(data[i - 1]) > EPSILON:
            val change = (data[i] - data[i - 1]) / data[i - 1]
            result.push(change)
        else:
            result.push(0.0)
        i = i + 1

    result

# ============================================================================
# DESCRIPTIVE STATISTICS
# ============================================================================

fn mean(data: List<f64>) -> Option<f64>:
    """Calculate arithmetic mean (average)."""
    if data.length() == 0:
        return nil

    val total = sum(data)
    val n = data.length()
    Some(total / n)

fn geometric_mean(data: List<f64>) -> Option<f64>:
    """Calculate geometric mean."""
    if data.length() == 0:
        return nil

    var log_sum = 0.0
    for val in data:
        if val <= 0.0:
            return nil
        log_sum = log_sum + math.log(val)

    val result = math.exp(log_sum / data.length())
    Some(result)

fn harmonic_mean(data: List<f64>) -> Option<f64>:
    """Calculate harmonic mean."""
    if data.length() == 0:
        return nil

    var recip_sum = 0.0
    for val in data:
        if math.abs(val) < EPSILON:
            return nil
        recip_sum = recip_sum + (1.0 / val)

    val result = data.length() / recip_sum
    Some(result)

fn median(data: List<f64>) -> Option<f64>:
    """Calculate median (50th percentile)."""
    if data.length() == 0:
        return nil

    val sorted = array.sort(data)
    val n = sorted.length()
    val mid = n / 2

    if n % 2 == 0:
        val result = (sorted[mid - 1] + sorted[mid]) / 2.0
        Some(result)
    else:
        Some(sorted[mid])

fn mode(data: List<f64>) -> Option<f64>:
    """Calculate mode (most frequent value)."""
    if data.length() == 0:
        return nil

    var freq_map = {}
    var max_freq = 0
    var mode_val = data[0]

    for val in data:
        val key = val
        var current_freq = 0

        for v in data:
            if math.abs(v - key) < EPSILON:
                current_freq = current_freq + 1

        if current_freq > max_freq:
            max_freq = current_freq
            mode_val = val

    Some(mode_val)

fn min_value(data: List<f64>) -> Option<f64>:
    """Find minimum value."""
    if data.length() == 0:
        return nil

    var min_val = data[0]
    for val in data:
        if val < min_val:
            min_val = val

    Some(min_val)

fn max_value(data: List<f64>) -> Option<f64>:
    """Find maximum value."""
    if data.length() == 0:
        return nil

    var max_val = data[0]
    for val in data:
        if val > max_val:
            max_val = val

    Some(max_val)

fn range_value(data: List<f64>) -> Option<f64>:
    """Calculate range (max - min)."""
    if data.length() == 0:
        return nil

    val min_opt = min_value(data)
    val max_opt = max_value(data)

    if min_opt and max_opt:
        Some(max_opt - min_opt)
    else:
        nil

fn quantile(data: List<f64>, q: f64) -> Option<f64>:
    """Calculate quantile (0.0 to 1.0)."""
    if data.length() == 0:
        return nil

    if q < 0.0 or q > 1.0:
        return nil

    val sorted = array.sort(data)
    val n = sorted.length()
    val pos = q * (n - 1)
    val lower = math.floor(pos)
    val upper = math.ceil(pos)

    if lower == upper:
        return Some(sorted[lower])

    val weight = pos - lower
    val result = sorted[lower] * (1.0 - weight) + sorted[upper] * weight
    Some(result)

fn percentile(data: List<f64>, p: f64) -> Option<f64>:
    """Calculate percentile (0 to 100)."""
    quantile(data, p / 100.0)

fn quartile_1(data: List<f64>) -> Option<f64>:
    """Calculate first quartile (Q1, 25th percentile)."""
    quantile(data, 0.25)

fn quartile_2(data: List<f64>) -> Option<f64>:
    """Calculate second quartile (Q2, 50th percentile, median)."""
    median(data)

fn quartile_3(data: List<f64>) -> Option<f64>:
    """Calculate third quartile (Q3, 75th percentile)."""
    quantile(data, 0.75)

fn iqr(data: List<f64>) -> Option<f64>:
    """Calculate interquartile range (Q3 - Q1)."""
    val q1 = quartile_1(data)
    val q3 = quartile_3(data)

    if q1 and q3:
        Some(q3 - q1)
    else:
        nil

# ============================================================================
# MEASURES OF SPREAD
# ============================================================================

fn variance(data: List<f64>) -> Option<f64>:
    """Calculate population variance."""
    if data.length() == 0:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_sq = 0.0

    for val in data:
        val diff_val = val - m
        sum_sq = sum_sq + (diff_val * diff_val)

    Some(sum_sq / data.length())

fn variance_sample(data: List<f64>) -> Option<f64>:
    """Calculate sample variance (Bessel's correction)."""
    if data.length() < 2:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_sq = 0.0

    for val in data:
        val diff_val = val - m
        sum_sq = sum_sq + (diff_val * diff_val)

    Some(sum_sq / (data.length() - 1))

fn stddev(data: List<f64>) -> Option<f64>:
    """Calculate population standard deviation."""
    val var_opt = variance(data)
    if var_opt == nil:
        return nil

    Some(math.sqrt(var_opt))

fn stddev_sample(data: List<f64>) -> Option<f64>:
    """Calculate sample standard deviation."""
    val var_opt = variance_sample(data)
    if var_opt == nil:
        return nil

    Some(math.sqrt(var_opt))

fn mad(data: List<f64>) -> Option<f64>:
    """Calculate mean absolute deviation."""
    if data.length() == 0:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_abs = 0.0

    for val in data:
        sum_abs = sum_abs + math.abs(val - m)

    Some(sum_abs / data.length())

fn median_absolute_deviation(data: List<f64>) -> Option<f64>:
    """Calculate median absolute deviation (MAD)."""
    if data.length() == 0:
        return nil

    val med_opt = median(data)
    if med_opt == nil:
        return nil

    val m = med_opt
    var deviations = []

    for val in data:
        deviations.push(math.abs(val - m))

    median(deviations)

fn coefficient_of_variation(data: List<f64>) -> Option<f64>:
    """Calculate coefficient of variation (CV = stddev / mean)."""
    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    if math.abs(mean_opt) < EPSILON:
        return nil

    Some(std_opt / math.abs(mean_opt))

fn standard_error(data: List<f64>) -> Option<f64>:
    """Calculate standard error of the mean."""
    val std_opt = stddev_sample(data)
    if std_opt == nil:
        return nil

    val n = data.length()
    if n == 0:
        return nil

    Some(std_opt / math.sqrt(n))

# ============================================================================
# MEASURES OF SHAPE
# ============================================================================

fn skewness(data: List<f64>) -> Option<f64>:
    """Calculate skewness (Fisher-Pearson coefficient)."""
    if data.length() < 3:
        return nil

    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    if std_opt < EPSILON:
        return nil

    val m = mean_opt
    val s = std_opt
    var sum_cubed = 0.0

    for val in data:
        val z = (val - m) / s
        sum_cubed = sum_cubed + (z * z * z)

    Some(sum_cubed / data.length())

fn kurtosis(data: List<f64>) -> Option<f64>:
    """Calculate excess kurtosis."""
    if data.length() < 4:
        return nil

    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    if std_opt < EPSILON:
        return nil

    val m = mean_opt
    val s = std_opt
    var sum_fourth = 0.0

    for val in data:
        val z = (val - m) / s
        sum_fourth = sum_fourth + (z * z * z * z)

    val kurt = sum_fourth / data.length()
    Some(kurt - 3.0)

# ============================================================================
# CORRELATION
# ============================================================================

fn covariance(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate population covariance between two arrays."""
    if x.length() != y.length() or x.length() == 0:
        return nil

    val mean_x_opt = mean(x)
    val mean_y_opt = mean(y)

    if mean_x_opt == nil or mean_y_opt == nil:
        return nil

    val mx = mean_x_opt
    val my = mean_y_opt
    var sum_prod = 0.0

    var i = 0
    while i < x.length():
        sum_prod = sum_prod + ((x[i] - mx) * (y[i] - my))
        i = i + 1

    Some(sum_prod / x.length())

fn covariance_sample(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate sample covariance between two arrays."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val mean_x_opt = mean(x)
    val mean_y_opt = mean(y)

    if mean_x_opt == nil or mean_y_opt == nil:
        return nil

    val mx = mean_x_opt
    val my = mean_y_opt
    var sum_prod = 0.0

    var i = 0
    while i < x.length():
        sum_prod = sum_prod + ((x[i] - mx) * (y[i] - my))
        i = i + 1

    Some(sum_prod / (x.length() - 1))

fn correlation_pearson(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate Pearson correlation coefficient."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val cov_opt = covariance(x, y)
    val std_x_opt = stddev(x)
    val std_y_opt = stddev(y)

    if cov_opt == nil or std_x_opt == nil or std_y_opt == nil:
        return nil

    val denominator = std_x_opt * std_y_opt
    if denominator < EPSILON:
        return nil

    Some(cov_opt / denominator)

fn rank_data(data: List<f64>) -> List<f64>:
    """Assign ranks to data (average rank for ties)."""
    val n = data.length()
    if n == 0:
        return []

    var ranks = []
    var i = 0
    while i < n:
        ranks.push(0.0)
        i = i + 1

    i = 0
    while i < n:
        var rank = 1.0
        var j = 0
        while j < n:
            if data[j] < data[i]:
                rank = rank + 1.0
            j = j + 1
        ranks[i] = rank
        i = i + 1

    ranks

fn correlation_spearman(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate Spearman rank correlation coefficient."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val ranks_x = rank_data(x)
    val ranks_y = rank_data(y)

    correlation_pearson(ranks_x, ranks_y)

fn correlation_kendall(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate Kendall's tau correlation coefficient."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val n = x.length()
    var concordant = 0
    var discordant = 0

    var i = 0
    while i < n - 1:
        var j = i + 1
        while j < n:
            val dx = x[j] - x[i]
            val dy = y[j] - y[i]

            if dx * dy > 0.0:
                concordant = concordant + 1
            else:
                if dx * dy < 0.0:
                    discordant = discordant + 1

            j = j + 1
        i = i + 1

    val pairs = n * (n - 1) / 2
    val tau = (concordant - discordant) / pairs
    Some(tau)

# ============================================================================
# REGRESSION
# ============================================================================

fn linear_regression(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    """Calculate linear regression (returns [slope, intercept])."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val mean_x_opt = mean(x)
    val mean_y_opt = mean(y)

    if mean_x_opt == nil or mean_y_opt == nil:
        return nil

    val mx = mean_x_opt
    val my = mean_y_opt

    var sum_xy = 0.0
    var sum_xx = 0.0

    var i = 0
    while i < x.length():
        val dx = x[i] - mx
        val dy = y[i] - my
        sum_xy = sum_xy + (dx * dy)
        sum_xx = sum_xx + (dx * dx)
        i = i + 1

    if sum_xx < EPSILON:
        return nil

    val slope = sum_xy / sum_xx
    val intercept = my - (slope * mx)

    Some([slope, intercept])

fn r_squared(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate coefficient of determination (RÂ²)."""
    val reg_opt = linear_regression(x, y)
    if reg_opt == nil:
        return nil

    val params = reg_opt
    val slope = params[0]
    val intercept = params[1]

    val mean_y_opt = mean(y)
    if mean_y_opt == nil:
        return nil

    val my = mean_y_opt

    var ss_res = 0.0
    var ss_tot = 0.0

    var i = 0
    while i < x.length():
        val pred = slope * x[i] + intercept
        val res = y[i] - pred
        val tot = y[i] - my
        ss_res = ss_res + (res * res)
        ss_tot = ss_tot + (tot * tot)
        i = i + 1

    if ss_tot < EPSILON:
        return nil

    Some(1.0 - (ss_res / ss_tot))

fn residuals(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    """Calculate regression residuals."""
    val reg_opt = linear_regression(x, y)
    if reg_opt == nil:
        return nil

    val params = reg_opt
    val slope = params[0]
    val intercept = params[1]

    var res = []
    var i = 0
    while i < x.length():
        val pred = slope * x[i] + intercept
        res.push(y[i] - pred)
        i = i + 1

    Some(res)

# ============================================================================
# PROBABILITY DISTRIBUTIONS
# ============================================================================

fn normal_pdf(x: f64, mu: f64, sigma: f64) -> f64:
    """Normal distribution probability density function."""
    if sigma < EPSILON:
        return 0.0

    val z = (x - mu) / sigma
    val exp_term = math.exp(-0.5 * z * z)
    exp_term / (sigma * SQRT_2PI)

fn normal_cdf(x: f64, mu: f64, sigma: f64) -> f64:
    """Normal distribution cumulative distribution function (approximation)."""
    if sigma < EPSILON:
        return 0.0

    val z = (x - mu) / (sigma * math.sqrt(2.0))
    0.5 * (1.0 + erf(z))

fn erf(x: f64) -> f64:
    """Error function (approximation)."""
    val sign = if x >= 0.0: 1.0 else: -1.0
    val abs_x = math.abs(x)

    val a1 = 0.254829592
    val a2 = -0.284496736
    val a3 = 1.421413741
    val a4 = -1.453152027
    val a5 = 1.061405429
    val p = 0.3275911

    val t = 1.0 / (1.0 + p * abs_x)
    val t2 = t * t
    val t3 = t2 * t
    val t4 = t3 * t
    val t5 = t4 * t

    val poly = a1 * t + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5
    val result = 1.0 - poly * math.exp(-abs_x * abs_x)

    sign * result

fn uniform_pdf(x: f64, a: f64, b: f64) -> f64:
    """Uniform distribution probability density function."""
    if x < a or x > b:
        return 0.0

    if b - a < EPSILON:
        return 0.0

    1.0 / (b - a)

fn uniform_cdf(x: f64, a: f64, b: f64) -> f64:
    """Uniform distribution cumulative distribution function."""
    if x < a:
        return 0.0

    if x > b:
        return 1.0

    if b - a < EPSILON:
        return 0.0

    (x - a) / (b - a)

fn binomial_pmf(k: i64, n: i64, p: f64) -> f64:
    """Binomial distribution probability mass function."""
    if k < 0 or k > n or n < 0:
        return 0.0

    if p < 0.0 or p > 1.0:
        return 0.0

    val binom_coef = binomial_coefficient(n, k)
    val pk = math.pow(p, k)
    val p1k = math.pow(1.0 - p, n - k)

    binom_coef * pk * p1k

fn binomial_coefficient(n: i64, k: i64) -> f64:
    """Calculate binomial coefficient C(n, k)."""
    if k < 0 or k > n:
        return 0.0

    if k == 0 or k == n:
        return 1.0

    var result = 1.0
    var i = 0
    while i < k:
        result = result * (n - i) / (i + 1)
        i = i + 1

    result

fn poisson_pmf(k: i64, lambda: f64) -> f64:
    """Poisson distribution probability mass function."""
    if k < 0 or lambda < 0.0:
        return 0.0

    val exp_term = math.exp(-lambda)
    val lambda_k = math.pow(lambda, k)
    val k_fact = factorial(k)

    exp_term * lambda_k / k_fact

fn factorial(n: i64) -> f64:
    """Calculate factorial (returns f64 to handle large values)."""
    if n < 0:
        return 0.0

    if n == 0 or n == 1:
        return 1.0

    var result = 1.0
    var i = 2
    while i <= n:
        result = result * i
        i = i + 1

    result

# ============================================================================
# STATISTICAL TESTS
# ============================================================================

fn z_score(x: f64, mu: f64, sigma: f64) -> Option<f64>:
    """Calculate z-score (standard score)."""
    if sigma < EPSILON:
        return nil

    Some((x - mu) / sigma)

fn z_scores(data: List<f64>) -> Option<List<f64>>:
    """Calculate z-scores for all values in array."""
    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    if std_opt < EPSILON:
        return nil

    val m = mean_opt
    val s = std_opt

    var result = []
    for val in data:
        result.push((val - m) / s)

    Some(result)

fn t_statistic(sample: List<f64>, pop_mean: f64) -> Option<f64>:
    """Calculate one-sample t-statistic."""
    val mean_opt = mean(sample)
    val se_opt = standard_error(sample)

    if mean_opt == nil or se_opt == nil:
        return nil

    if se_opt < EPSILON:
        return nil

    Some((mean_opt - pop_mean) / se_opt)

fn t_statistic_two_sample(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate two-sample t-statistic (equal variance assumed)."""
    if x.length() < 2 or y.length() < 2:
        return nil

    val mean_x_opt = mean(x)
    val mean_y_opt = mean(y)
    val var_x_opt = variance_sample(x)
    val var_y_opt = variance_sample(y)

    if mean_x_opt == nil or mean_y_opt == nil or var_x_opt == nil or var_y_opt == nil:
        return nil

    val nx = x.length()
    val ny = y.length()

    val pooled_var = ((nx - 1) * var_x_opt + (ny - 1) * var_y_opt) / (nx + ny - 2)
    val se = math.sqrt(pooled_var * (1.0 / nx + 1.0 / ny))

    if se < EPSILON:
        return nil

    Some((mean_x_opt - mean_y_opt) / se)

fn chi_square_statistic(observed: List<f64>, expected: List<f64>) -> Option<f64>:
    """Calculate chi-square statistic."""
    if observed.length() != expected.length() or observed.length() == 0:
        return nil

    var chi_sq = 0.0
    var i = 0

    while i < observed.length():
        if expected[i] < EPSILON:
            return nil

        val diff = observed[i] - expected[i]
        chi_sq = chi_sq + (diff * diff / expected[i])
        i = i + 1

    Some(chi_sq)

# ============================================================================
# DATA TRANSFORMATION
# ============================================================================

fn normalize(data: List<f64>) -> Option<List<f64>>:
    """Normalize data to [0, 1] range using min-max scaling."""
    if data.length() == 0:
        return nil

    val min_opt = min_value(data)
    val max_opt = max_value(data)

    if min_opt == nil or max_opt == nil:
        return nil

    val min_v = min_opt
    val max_v = max_opt
    val range_v = max_v - min_v

    if range_v < EPSILON:
        var result = []
        for val in data:
            result.push(0.5)
        return Some(result)

    var result = []
    for val in data:
        result.push((val - min_v) / range_v)

    Some(result)

fn standardize(data: List<f64>) -> Option<List<f64>>:
    """Standardize data to have mean=0 and stddev=1."""
    z_scores(data)

fn log_transform(data: List<f64>) -> Option<List<f64>>:
    """Apply natural logarithm transformation."""
    var result = []

    for val in data:
        if val <= 0.0:
            return nil
        result.push(math.log(val))

    Some(result)

fn log10_transform(data: List<f64>) -> Option<List<f64>>:
    """Apply base-10 logarithm transformation."""
    var result = []

    for val in data:
        if val <= 0.0:
            return nil
        result.push(math.log10(val))

    Some(result)

fn sqrt_transform(data: List<f64>) -> Option<List<f64>>:
    """Apply square root transformation."""
    var result = []

    for val in data:
        if val < 0.0:
            return nil
        result.push(math.sqrt(val))

    Some(result)

fn box_cox_transform(data: List<f64>, lambda: f64) -> Option<List<f64>>:
    """Apply Box-Cox transformation."""
    var result = []

    for val in data:
        if val <= 0.0:
            return nil

        if math.abs(lambda) < EPSILON:
            result.push(math.log(val))
        else:
            val transformed = (math.pow(val, lambda) - 1.0) / lambda
            result.push(transformed)

    Some(result)

# ============================================================================
# FREQUENCY ANALYSIS
# ============================================================================

fn frequency_table(data: List<f64>) -> List<List<f64>>:
    """Create frequency table (returns [[value, count], ...])."""
    if data.length() == 0:
        return []

    var unique_vals = []
    var counts = []

    for val in data:
        var found = false
        var idx = 0

        var i = 0
        while i < unique_vals.length():
            if math.abs(unique_vals[i] - val) < EPSILON:
                found = true
                idx = i
                break
            i = i + 1

        if found:
            counts[idx] = counts[idx] + 1.0
        else:
            unique_vals.push(val)
            counts.push(1.0)

    var result = []
    var i = 0
    while i < unique_vals.length():
        result.push([unique_vals[i], counts[i]])
        i = i + 1

    result

fn histogram_bins(data: List<f64>, num_bins: i64) -> Option<List<f64>>:
    """Calculate histogram bin counts."""
    if data.length() == 0 or num_bins <= 0:
        return nil

    val min_opt = min_value(data)
    val max_opt = max_value(data)

    if min_opt == nil or max_opt == nil:
        return nil

    val min_v = min_opt
    val max_v = max_opt
    val range_v = max_v - min_v

    if range_v < EPSILON:
        var bins = []
        var i = 0
        while i < num_bins:
            bins.push(0.0)
            i = i + 1
        bins[0] = data.length()
        return Some(bins)

    val bin_width = range_v / num_bins

    var bins = []
    var i = 0
    while i < num_bins:
        bins.push(0.0)
        i = i + 1

    for val in data:
        var bin_idx = math.floor((val - min_v) / bin_width)
        if bin_idx >= num_bins:
            bin_idx = num_bins - 1
        bins[bin_idx] = bins[bin_idx] + 1.0

    Some(bins)

fn relative_frequency(data: List<f64>) -> List<List<f64>>:
    """Calculate relative frequency table (proportions)."""
    val freq = frequency_table(data)
    val n = data.length()

    if n == 0:
        return []

    var result = []
    for entry in freq:
        val value = entry[0]
        val count = entry[1]
        result.push([value, count / n])

    result

# ============================================================================
# MOVING STATISTICS
# ============================================================================

fn moving_average(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate simple moving average."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var sum_val = 0.0
        var j = 0
        while j < window:
            sum_val = sum_val + data[i + j]
            j = j + 1

        result.push(sum_val / window)
        i = i + 1

    Some(result)

fn exponential_moving_average(data: List<f64>, alpha: f64) -> Option<List<f64>>:
    """Calculate exponential moving average."""
    if alpha <= 0.0 or alpha > 1.0:
        return nil

    if data.length() == 0:
        return nil

    var result = []
    var ema = data[0]
    result.push(ema)

    var i = 1
    while i < data.length():
        ema = alpha * data[i] + (1.0 - alpha) * ema
        result.push(ema)
        i = i + 1

    Some(result)

fn weighted_moving_average(data: List<f64>, weights: List<f64>) -> Option<List<f64>>:
    """Calculate weighted moving average."""
    if weights.length() == 0 or weights.length() > data.length():
        return nil

    val weight_sum = sum(weights)
    if math.abs(weight_sum) < EPSILON:
        return nil

    val window = weights.length()
    var result = []
    var i = 0

    while i <= data.length() - window:
        var weighted_sum = 0.0
        var j = 0
        while j < window:
            weighted_sum = weighted_sum + data[i + j] * weights[j]
            j = j + 1

        result.push(weighted_sum / weight_sum)
        i = i + 1

    Some(result)

fn moving_stddev(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate moving standard deviation."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var window_data = []
        var j = 0
        while j < window:
            window_data.push(data[i + j])
            j = j + 1

        val std_opt = stddev(window_data)
        if std_opt == nil:
            return nil

        result.push(std_opt)
        i = i + 1

    Some(result)

fn moving_min(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate moving minimum."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var min_val = data[i]
        var j = 1
        while j < window:
            if data[i + j] < min_val:
                min_val = data[i + j]
            j = j + 1

        result.push(min_val)
        i = i + 1

    Some(result)

fn moving_max(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate moving maximum."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var max_val = data[i]
        var j = 1
        while j < window:
            if data[i + j] > max_val:
                max_val = data[i + j]
            j = j + 1

        result.push(max_val)
        i = i + 1

    Some(result)

# ============================================================================
# ADDITIONAL UTILITIES
# ============================================================================

fn clip(data: List<f64>, min_val: f64, max_val: f64) -> List<f64>:
    """Clip values to range [min_val, max_val]."""
    var result = []

    for val in data:
        if val < min_val:
            result.push(min_val)
        else:
            if val > max_val:
                result.push(max_val)
            else:
                result.push(val)

    result

fn winsorize(data: List<f64>, lower_pct: f64, upper_pct: f64) -> Option<List<f64>>:
    """Winsorize data by replacing extreme values with percentiles."""
    if lower_pct < 0.0 or upper_pct > 100.0 or lower_pct >= upper_pct:
        return nil

    val lower_val_opt = percentile(data, lower_pct)
    val upper_val_opt = percentile(data, upper_pct)

    if lower_val_opt == nil or upper_val_opt == nil:
        return nil

    val result = clip(data, lower_val_opt, upper_val_opt)
    Some(result)

fn remove_outliers(data: List<f64>, num_stddev: f64) -> Option<List<f64>>:
    """Remove outliers beyond num_stddev standard deviations from mean."""
    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    val m = mean_opt
    val s = std_opt
    val threshold = num_stddev * s

    var result = []
    for val in data:
        if math.abs(val - m) <= threshold:
            result.push(val)

    Some(result)

fn detect_outliers_iqr(data: List<f64>, multiplier: f64) -> Option<List<bool>>:
    """Detect outliers using IQR method (returns boolean mask)."""
    val q1_opt = quartile_1(data)
    val q3_opt = quartile_3(data)

    if q1_opt == nil or q3_opt == nil:
        return nil

    val q1 = q1_opt
    val q3 = q3_opt
    val iqr_val = q3 - q1
    val lower = q1 - multiplier * iqr_val
    val upper = q3 + multiplier * iqr_val

    var result = []
    for val in data:
        val is_outlier = val < lower or val > upper
        result.push(is_outlier)

    Some(result)

fn interpolate_linear(x: f64, x0: f64, y0: f64, x1: f64, y1: f64) -> f64:
    """Linear interpolation between two points."""
    if math.abs(x1 - x0) < EPSILON:
        return y0

    y0 + (x - x0) * (y1 - y0) / (x1 - x0)

fn mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate mean squared error."""
    if actual.length() != predicted.length() or actual.length() == 0:
        return nil

    var sum_sq = 0.0
    var i = 0
    while i < actual.length():
        val err = actual[i] - predicted[i]
        sum_sq = sum_sq + (err * err)
        i = i + 1

    Some(sum_sq / actual.length())

fn root_mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate root mean squared error."""
    val mse_opt = mean_squared_error(actual, predicted)
    if mse_opt == nil:
        return nil

    Some(math.sqrt(mse_opt))

fn mean_absolute_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate mean absolute error."""
    if actual.length() != predicted.length() or actual.length() == 0:
        return nil

    var sum_abs = 0.0
    var i = 0
    while i < actual.length():
        sum_abs = sum_abs + math.abs(actual[i] - predicted[i])
        i = i + 1

    Some(sum_abs / actual.length())

fn mean_absolute_percentage_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate mean absolute percentage error."""
    if actual.length() != predicted.length() or actual.length() == 0:
        return nil

    var sum_pct = 0.0
    var i = 0
    while i < actual.length():
        if math.abs(actual[i]) < EPSILON:
            return nil
        sum_pct = sum_pct + math.abs((actual[i] - predicted[i]) / actual[i])
        i = i + 1

    Some(100.0 * sum_pct / actual.length())

fn entropy(probabilities: List<f64>) -> Option<f64>:
    """Calculate Shannon entropy."""
    if probabilities.length() == 0:
        return nil

    var ent = 0.0
    for p in probabilities:
        if p < 0.0 or p > 1.0:
            return nil
        if p > EPSILON:
            ent = ent - (p * math.log(p) / math.log(2.0))

    Some(ent)

fn gini_impurity(probabilities: List<f64>) -> Option<f64>:
    """Calculate Gini impurity."""
    if probabilities.length() == 0:
        return nil

    var gini = 1.0
    for p in probabilities:
        if p < 0.0 or p > 1.0:
            return nil
        gini = gini - (p * p)

    Some(gini)

fn weighted_mean(values: List<f64>, weights: List<f64>) -> Option<f64>:
    """Calculate weighted mean."""
    if values.length() != weights.length() or values.length() == 0:
        return nil

    var sum_val = 0.0
    var sum_weight = 0.0

    var i = 0
    while i < values.length():
        sum_val = sum_val + values[i] * weights[i]
        sum_weight = sum_weight + weights[i]
        i = i + 1

    if math.abs(sum_weight) < EPSILON:
        return nil

    Some(sum_val / sum_weight)

fn weighted_variance(values: List<f64>, weights: List<f64>) -> Option<f64>:
    """Calculate weighted variance."""
    val wmean_opt = weighted_mean(values, weights)
    if wmean_opt == nil:
        return nil

    val wm = wmean_opt

    var sum_sq = 0.0
    var sum_weight = 0.0

    var i = 0
    while i < values.length():
        val diff_val = values[i] - wm
        sum_sq = sum_sq + weights[i] * diff_val * diff_val
        sum_weight = sum_weight + weights[i]
        i = i + 1

    if math.abs(sum_weight) < EPSILON:
        return nil

    Some(sum_sq / sum_weight)

fn confidence_interval_mean(data: List<f64>, confidence: f64) -> Option<List<f64>>:
    """Calculate confidence interval for mean (returns [lower, upper])."""
    if data.length() < 2:
        return nil

    val mean_opt = mean(data)
    val se_opt = standard_error(data)

    if mean_opt == nil or se_opt == nil:
        return nil

    val z = if confidence >= 0.99: 2.576 else: if confidence >= 0.95: 1.96 else: 1.645
    val margin = z * se_opt

    Some([mean_opt - margin, mean_opt + margin])

fn sample_with_replacement(data: List<f64>, size: i64, seed: i64) -> List<f64>:
    """Simple sampling with replacement (pseudo-random)."""
    var result = []
    var rng = seed

    var i = 0
    while i < size:
        rng = (rng * 1103515245 + 12345) % 2147483648
        val idx = (rng % data.length())
        result.push(data[idx])
        i = i + 1

    result

fn bootstrap_mean(data: List<f64>, num_samples: i64, seed: i64) -> Option<List<f64>>:
    """Bootstrap resampling of mean estimates."""
    if data.length() == 0 or num_samples <= 0:
        return nil

    var means = []
    var rng = seed

    var i = 0
    while i < num_samples:
        val sample = sample_with_replacement(data, data.length(), rng)
        val mean_opt = mean(sample)
        if mean_opt == nil:
            return nil
        means.push(mean_opt)
        rng = rng + 1
        i = i + 1

    Some(means)

fn trimmed_mean(data: List<f64>, trim_pct: f64) -> Option<f64>:
    """Calculate trimmed mean (removing percentage from both ends)."""
    if data.length() == 0:
        return nil

    if trim_pct < 0.0 or trim_pct >= 50.0:
        return nil

    val sorted = array.sort(data)
    val n = sorted.length()
    val trim_count = math.floor(n * trim_pct / 100.0)

    var sum_val = 0.0
    var count_val = 0

    var i = trim_count
    while i < n - trim_count:
        sum_val = sum_val + sorted[i]
        count_val = count_val + 1
        i = i + 1

    if count_val == 0:
        return nil

    Some(sum_val / count_val)

fn moment(data: List<f64>, order: i64) -> Option<f64>:
    """Calculate n-th moment about the mean."""
    if data.length() == 0 or order < 1:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_val = 0.0

    for val in data:
        sum_val = sum_val + math.pow(val - m, order)

    Some(sum_val / data.length())

fn autocorrelation(data: List<f64>, lag: i64) -> Option<f64>:
    """Calculate autocorrelation at given lag."""
    if lag < 0 or lag >= data.length():
        return nil

    val n = data.length() - lag
    if n < 1:
        return nil

    var x = []
    var y = []

    var i = 0
    while i < n:
        x.push(data[i])
        y.push(data[i + lag])
        i = i + 1

    correlation_pearson(x, y)

fn cross_correlation(x: List<f64>, y: List<f64>, lag: i64) -> Option<f64>:
    """Calculate cross-correlation at given lag."""
    if lag < 0:
        return nil

    if x.length() - lag < 1 or y.length() < 1:
        return nil

    val n = math.min(x.length() - lag, y.length())

    var x_subset = []
    var y_subset = []

    var i = 0
    while i < n:
        x_subset.push(x[i + lag])
        y_subset.push(y[i])
        i = i + 1

    correlation_pearson(x_subset, y_subset)

fn rolling_sum(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate rolling sum."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var sum_val = 0.0
        var j = 0
        while j < window:
            sum_val = sum_val + data[i + j]
            j = j + 1
        result.push(sum_val)
        i = i + 1

    Some(result)

fn expanding_mean(data: List<f64>) -> Option<List<f64>>:
    """Calculate expanding (cumulative) mean."""
    if data.length() == 0:
        return nil

    var result = []
    var sum_val = 0.0

    var i = 0
    while i < data.length():
        sum_val = sum_val + data[i]
        result.push(sum_val / (i + 1))
        i = i + 1

    Some(result)

fn expanding_stddev(data: List<f64>) -> Option<List<f64>>:
    """Calculate expanding standard deviation."""
    if data.length() < 2:
        return nil

    var result = []

    var i = 2
    while i <= data.length():
        var window = []
        var j = 0
        while j < i:
            window.push(data[j])
            j = j + 1

        val std_opt = stddev(window)
        if std_opt == nil:
            return nil

        result.push(std_opt)
        i = i + 1

    Some(result)
