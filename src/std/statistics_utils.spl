# statistics_utils.spl - Comprehensive Statistical Analysis Module
#
# This module is now a facade that re-exports all functionality from the
# statistics submodule, which is organized into focused components:
#
# - types: Constants and type definitions
# - utilities: Basic utility functions (sum, product, frequency analysis)
# - descriptive: Descriptive statistics (mean, median, variance, quartiles)
# - distributions: Probability distributions (normal, uniform, binomial, Poisson)
# - correlation: Correlation analysis (Pearson, Spearman, Kendall)
# - regression: Regression analysis (linear regression, R-squared)
# - inference: Statistical inference and hypothesis testing
#
# All functions maintain the same API as before. Import this module to access
# all statistical functions, or import specific submodules for focused functionality.

import statistics from "std/statistics/mod"

# ============================================================================
# RE-EXPORT CONSTANTS
# ============================================================================

val EPSILON = statistics.EPSILON
val PI = statistics.PI
val E = statistics.E
val SQRT_2PI = statistics.SQRT_2PI

# ============================================================================
# RE-EXPORT UTILITIES
# ============================================================================

fn sum(data: List<f64>) -> f64:
    statistics.sum(data)

fn product(data: List<f64>) -> f64:
    statistics.product(data)

fn count(data: List<f64>) -> i64:
    statistics.count(data)

fn count_non_zero(data: List<f64>) -> i64:
    statistics.count_non_zero(data)

fn cumsum(data: List<f64>) -> List<f64>:
    statistics.cumsum(data)

fn cumprod(data: List<f64>) -> List<f64>:
    statistics.cumprod(data)

fn diff(data: List<f64>) -> List<f64>:
    statistics.diff(data)

fn pct_change(data: List<f64>) -> List<f64>:
    statistics.pct_change(data)

fn clip(data: List<f64>, min_val: f64, max_val: f64) -> List<f64>:
    statistics.clip(data, min_val, max_val)

fn interpolate_linear(x: f64, x0: f64, y0: f64, x1: f64, y1: f64) -> f64:
    statistics.interpolate_linear(x, x0, y0, x1, y1)

fn sample_with_replacement(data: List<f64>, size: i64, seed: i64) -> List<f64>:
    statistics.sample_with_replacement(data, size, seed)

fn factorial(n: i64) -> f64:
    statistics.factorial(n)

fn binomial_coefficient(n: i64, k: i64) -> f64:
    statistics.binomial_coefficient(n, k)

fn rank_data(data: List<f64>) -> List<f64>:
    statistics.rank_data(data)

fn frequency_table(data: List<f64>) -> List<List<f64>>:
    statistics.frequency_table(data)

fn histogram_bins(data: List<f64>, num_bins: i64) -> Option<List<f64>>:
    statistics.histogram_bins(data, num_bins)

fn relative_frequency(data: List<f64>) -> List<List<f64>>:
    statistics.relative_frequency(data)

fn min_value(data: List<f64>) -> Option<f64>:
    statistics.min_value(data)

fn max_value(data: List<f64>) -> Option<f64>:
    statistics.max_value(data)

fn entropy(probabilities: List<f64>) -> Option<f64>:
    statistics.entropy(probabilities)

fn gini_impurity(probabilities: List<f64>) -> Option<f64>:
    statistics.gini_impurity(probabilities)

fn mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    statistics.mean_squared_error(actual, predicted)

fn root_mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    statistics.root_mean_squared_error(actual, predicted)

fn mean_absolute_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    statistics.mean_absolute_error(actual, predicted)

fn mean_absolute_percentage_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    statistics.mean_absolute_percentage_error(actual, predicted)

# ============================================================================
# RE-EXPORT DESCRIPTIVE STATISTICS
# ============================================================================

fn mean(data: List<f64>) -> Option<f64>:
    statistics.mean(data)

fn geometric_mean(data: List<f64>) -> Option<f64>:
    statistics.geometric_mean(data)

fn harmonic_mean(data: List<f64>) -> Option<f64>:
    statistics.harmonic_mean(data)

fn median(data: List<f64>) -> Option<f64>:
    statistics.median(data)

fn mode(data: List<f64>) -> Option<f64>:
    statistics.mode(data)

fn range_value(data: List<f64>) -> Option<f64>:
    statistics.range_value(data)

fn quantile(data: List<f64>, q: f64) -> Option<f64>:
    statistics.quantile(data, q)

fn percentile(data: List<f64>, p: f64) -> Option<f64>:
    statistics.percentile(data, p)

fn quartile_1(data: List<f64>) -> Option<f64>:
    statistics.quartile_1(data)

fn quartile_2(data: List<f64>) -> Option<f64>:
    statistics.quartile_2(data)

fn quartile_3(data: List<f64>) -> Option<f64>:
    statistics.quartile_3(data)

fn iqr(data: List<f64>) -> Option<f64>:
    statistics.iqr(data)

fn variance(data: List<f64>) -> Option<f64>:
    statistics.variance(data)

fn variance_sample(data: List<f64>) -> Option<f64>:
    statistics.variance_sample(data)

fn stddev(data: List<f64>) -> Option<f64>:
    statistics.stddev(data)

fn stddev_sample(data: List<f64>) -> Option<f64>:
    statistics.stddev_sample(data)

fn mad(data: List<f64>) -> Option<f64>:
    statistics.mad(data)

fn median_absolute_deviation(data: List<f64>) -> Option<f64>:
    statistics.median_absolute_deviation(data)

fn coefficient_of_variation(data: List<f64>) -> Option<f64>:
    statistics.coefficient_of_variation(data)

fn standard_error(data: List<f64>) -> Option<f64>:
    statistics.standard_error(data)

fn skewness(data: List<f64>) -> Option<f64>:
    statistics.skewness(data)

fn kurtosis(data: List<f64>) -> Option<f64>:
    statistics.kurtosis(data)

fn trimmed_mean(data: List<f64>, trim_pct: f64) -> Option<f64>:
    statistics.trimmed_mean(data, trim_pct)

fn moment(data: List<f64>, order: i64) -> Option<f64>:
    statistics.moment(data, order)

fn weighted_mean(values: List<f64>, weights: List<f64>) -> Option<f64>:
    statistics.weighted_mean(values, weights)

fn weighted_variance(values: List<f64>, weights: List<f64>) -> Option<f64>:
    statistics.weighted_variance(values, weights)

fn winsorize(data: List<f64>, lower_pct: f64, upper_pct: f64) -> Option<List<f64>>:
    statistics.winsorize(data, lower_pct, upper_pct)

fn remove_outliers(data: List<f64>, num_stddev: f64) -> Option<List<f64>>:
    statistics.remove_outliers(data, num_stddev)

fn detect_outliers_iqr(data: List<f64>, multiplier: f64) -> Option<List<bool>>:
    statistics.detect_outliers_iqr(data, multiplier)

fn expanding_mean(data: List<f64>) -> Option<List<f64>>:
    statistics.expanding_mean(data)

fn expanding_stddev(data: List<f64>) -> Option<List<f64>>:
    statistics.expanding_stddev(data)

fn moving_average(data: List<f64>, window: i64) -> Option<List<f64>>:
    statistics.moving_average(data, window)

fn exponential_moving_average(data: List<f64>, alpha: f64) -> Option<List<f64>>:
    statistics.exponential_moving_average(data, alpha)

fn weighted_moving_average(data: List<f64>, weights: List<f64>) -> Option<List<f64>>:
    statistics.weighted_moving_average(data, weights)

fn moving_stddev(data: List<f64>, window: i64) -> Option<List<f64>>:
    statistics.moving_stddev(data, window)

fn moving_min(data: List<f64>, window: i64) -> Option<List<f64>>:
    statistics.moving_min(data, window)

fn moving_max(data: List<f64>, window: i64) -> Option<List<f64>>:
    statistics.moving_max(data, window)

fn rolling_sum(data: List<f64>, window: i64) -> Option<List<f64>>:
    statistics.rolling_sum(data, window)

# ============================================================================
# RE-EXPORT DISTRIBUTIONS
# ============================================================================

fn erf(x: f64) -> f64:
    statistics.erf(x)

fn normal_pdf(x: f64, mu: f64, sigma: f64) -> f64:
    statistics.normal_pdf(x, mu, sigma)

fn normal_cdf(x: f64, mu: f64, sigma: f64) -> f64:
    statistics.normal_cdf(x, mu, sigma)

fn uniform_pdf(x: f64, a: f64, b: f64) -> f64:
    statistics.uniform_pdf(x, a, b)

fn uniform_cdf(x: f64, a: f64, b: f64) -> f64:
    statistics.uniform_cdf(x, a, b)

fn binomial_pmf(k: i64, n: i64, p: f64) -> f64:
    statistics.binomial_pmf(k, n, p)

fn poisson_pmf(k: i64, lambda: f64) -> f64:
    statistics.poisson_pmf(k, lambda)

# ============================================================================
# RE-EXPORT CORRELATION
# ============================================================================

fn covariance(x: List<f64>, y: List<f64>) -> Option<f64>:
    statistics.covariance(x, y)

fn covariance_sample(x: List<f64>, y: List<f64>) -> Option<f64>:
    statistics.covariance_sample(x, y)

fn correlation_pearson(x: List<f64>, y: List<f64>) -> Option<f64>:
    statistics.correlation_pearson(x, y)

fn correlation_spearman(x: List<f64>, y: List<f64>) -> Option<f64>:
    statistics.correlation_spearman(x, y)

fn correlation_kendall(x: List<f64>, y: List<f64>) -> Option<f64>:
    statistics.correlation_kendall(x, y)

fn autocorrelation(data: List<f64>, lag: i64) -> Option<f64>:
    statistics.autocorrelation(data, lag)

fn cross_correlation(x: List<f64>, y: List<f64>, lag: i64) -> Option<f64>:
    statistics.cross_correlation(x, y, lag)

# ============================================================================
# RE-EXPORT REGRESSION
# ============================================================================

fn linear_regression(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    statistics.linear_regression(x, y)

fn r_squared(x: List<f64>, y: List<f64>) -> Option<f64>:
    statistics.r_squared(x, y)

fn residuals(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    statistics.residuals(x, y)

# ============================================================================
# RE-EXPORT INFERENCE
# ============================================================================

fn z_score(x: f64, mu: f64, sigma: f64) -> Option<f64>:
    statistics.z_score(x, mu, sigma)

fn z_scores(data: List<f64>) -> Option<List<f64>>:
    statistics.z_scores(data)

fn t_statistic(sample: List<f64>, pop_mean: f64) -> Option<f64>:
    statistics.t_statistic(sample, pop_mean)

fn t_statistic_two_sample(x: List<f64>, y: List<f64>) -> Option<f64>:
    statistics.t_statistic_two_sample(x, y)

fn chi_square_statistic(observed: List<f64>, expected: List<f64>) -> Option<f64>:
    statistics.chi_square_statistic(observed, expected)

fn confidence_interval_mean(data: List<f64>, confidence: f64) -> Option<List<f64>>:
    statistics.confidence_interval_mean(data, confidence)

fn bootstrap_mean(data: List<f64>, num_samples: i64, seed: i64) -> Option<List<f64>>:
    statistics.bootstrap_mean(data, num_samples, seed)

fn normalize(data: List<f64>) -> Option<List<f64>>:
    statistics.normalize(data)

fn standardize(data: List<f64>) -> Option<List<f64>>:
    statistics.standardize(data)

fn log_transform(data: List<f64>) -> Option<List<f64>>:
    statistics.log_transform(data)

fn log10_transform(data: List<f64>) -> Option<List<f64>>:
    statistics.log10_transform(data)

fn sqrt_transform(data: List<f64>) -> Option<List<f64>>:
    statistics.sqrt_transform(data)

fn box_cox_transform(data: List<f64>, lambda: f64) -> Option<List<f64>>:
    statistics.box_cox_transform(data, lambda)
