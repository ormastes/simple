# Standard Library â€” String Formatting
#
# @tag:api
# @tag:stdlib
#
# Format values with format specifications.
# Supports: width, precision, alignment, radix
#
# Usage:
#   val padded = format_left("hi", 10)      # "hi        "
#   val padded = format_right("hi", 10)     # "        hi"
#   val hex = format_hex(255)               # "ff"
#   val fixed = format_fixed(3.14159, 2)    # "3.14"

# Repeat a string N times
fn str_repeat(s: text, n: i64) -> text:
    var result = ""
    for i in 0..n:
        result = result + s
    result

# Left-align text in field of given width
fn format_left(s: text, width: i64) -> text:
    val len = s.len()
    if len >= width:
        return s
    val pad = str_repeat(" ", width - len)
    s + pad

# Right-align text in field of given width
fn format_right(s: text, width: i64) -> text:
    val len = s.len()
    if len >= width:
        return s
    val pad = str_repeat(" ", width - len)
    pad + s

# Center text in field of given width
fn format_center(s: text, width: i64) -> text:
    val len = s.len()
    if len >= width:
        return s
    val total_pad = width - len
    val left_pad = total_pad / 2
    val right_pad = total_pad - left_pad
    str_repeat(" ", left_pad) + s + str_repeat(" ", right_pad)

# Pad with zeros (right-aligned)
fn format_zero_pad(s: text, width: i64) -> text:
    val len = s.len()
    if len >= width:
        return s
    str_repeat("0", width - len) + s

# Format integer as hex (lowercase)
fn format_hex(n: i64) -> text:
    if n == 0: return "0"
    val digits = "0123456789abcdef"
    var result = ""
    var num = n
    while num > 0:
        val digit = num % 16
        result = digits[digit:digit+1] + result
        num = num / 16
    result

# Format integer as hex (uppercase)
fn format_hex_upper(n: i64) -> text:
    if n == 0: return "0"
    val digits = "0123456789ABCDEF"
    var result = ""
    var num = n
    while num > 0:
        val digit = num % 16
        result = digits[digit:digit+1] + result
        num = num / 16
    result

# Format integer as binary
fn format_binary(n: i64) -> text:
    if n == 0: return "0"
    var result = ""
    var num = n
    while num > 0:
        val bit = num % 2
        if bit == 0:
            result = "0" + result
        else:
            result = "1" + result
        num = num / 2
    result

# Format float with fixed number of decimal places
fn format_fixed(f: f64, decimals: i64) -> text:
    val i_part = int(f)
    var frac = f - float(i_part)
    if frac < 0.0:
        frac = 0.0 - frac
    # Build decimal part
    var dec_str = ""
    var di = 0
    while di < decimals:
        frac = frac * 10.0
        val digit = int(frac)
        dec_str = dec_str + str(digit)
        frac = frac - float(digit)
        di = di + 1
    if decimals == 0:
        return str(i_part)
    str(i_part) + "." + dec_str

# Format with sign (always show + or -)
fn format_signed(n: i64) -> text:
    if n >= 0:
        return "+" + str(n)
    str(n)

# Format a value with width and alignment
# align: "left", "right", "center"
fn format_align(s: text, width: i64, align: text) -> text:
    if align == "left":
        return format_left(s, width)
    if align == "right":
        return format_right(s, width)
    if align == "center":
        return format_center(s, width)
    format_left(s, width)

export str_repeat, format_left, format_right, format_center, format_zero_pad
export format_hex, format_hex_upper, format_binary, format_fixed
export format_signed, format_align
