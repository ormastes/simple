# MCP DAP Module
# Debug Adapter Protocol types and handlers for MCP integration

use std.failsafe.core.{HealthStatus}

export BreakpointLocation, Breakpoint, StackFrame, VariableScope, Variable
export Scope, Thread, EvaluateResult, StepType, DapSessionState
export DapHandler, DapFailSafeContext, FailSafeDapServer

# ============================================================================
# BREAKPOINT TYPES
# ============================================================================

class BreakpointLocation:
    pub file: text
    pub line: i64
    pub column: text?
    pub condition: text?

impl BreakpointLocation:
    fn with_condition(cond: text) -> BreakpointLocation:
        BreakpointLocation(
            file: self.file,
            line: self.line,
            column: self.column,
            condition: cond
        )

    fn to_dict() -> {text: text}:
        var dict = {}
        dict["file"] = self.file
        dict["line"] = int_to_text(self.line)
        match self.column:
            case nil: ()
            case col: dict["column"] = col
        match self.condition:
            case nil: ()
            case cond: dict["condition"] = cond
        dict

class Breakpoint:
    pub id: i64
    pub location: BreakpointLocation
    pub verified: bool

impl Breakpoint:
    fn to_dict() -> {text: text}:
        var dict = {}
        dict["id"] = int_to_text(self.id)
        dict["verified"] = bool_to_text(self.verified)
        dict["file"] = self.location.file
        dict["line"] = int_to_text(self.location.line)
        dict

# ============================================================================
# STACK FRAME
# ============================================================================

class StackFrame:
    pub id: i64
    pub name: text
    pub source: text
    pub line: i64
    pub column: i64

impl StackFrame:
    fn to_dict() -> {text: text}:
        var dict = {}
        dict["id"] = int_to_text(self.id)
        dict["name"] = self.name
        dict["source"] = self.source
        dict["line"] = int_to_text(self.line)
        dict["column"] = int_to_text(self.column)
        dict

# ============================================================================
# VARIABLE TYPES
# ============================================================================

enum VariableScope:
    Local
    Arguments
    Closure
    Global
    Register

impl VariableScope:
    fn to_string() -> text:
        match self:
            case VariableScope.Local: "local"
            case VariableScope.Arguments: "arguments"
            case VariableScope.Closure: "closure"
            case VariableScope.Global: "global"
            case VariableScope.Register: "register"

class Variable:
    pub name: text
    pub value: text
    pub var_type: text
    pub scope: VariableScope

impl Variable:
    fn to_dict() -> {text: text}:
        var dict = {}
        dict["name"] = self.name
        dict["value"] = self.value
        dict["type"] = self.var_type
        dict["scope"] = self.scope.to_string()
        dict

class Scope:
    pub name: text
    pub variables_reference: i64
    pub expensive: bool

impl Scope:
    fn to_dict() -> {text: text}:
        var dict = {}
        dict["name"] = self.name
        dict["variablesReference"] = int_to_text(self.variables_reference)
        dict["expensive"] = bool_to_text(self.expensive)
        dict

# ============================================================================
# THREAD
# ============================================================================

class Thread:
    pub id: i64
    pub name: text

impl Thread:
    fn to_dict() -> {text: text}:
        var dict = {}
        dict["id"] = int_to_text(self.id)
        dict["name"] = self.name
        dict

# ============================================================================
# EVALUATE RESULT
# ============================================================================

class EvaluateResult:
    pub result: text
    pub result_type: text
    pub variables_reference: i64

impl EvaluateResult:
    fn to_dict() -> {text: text}:
        var dict = {}
        dict["result"] = self.result
        dict["type"] = self.result_type
        dict["variablesReference"] = int_to_text(self.variables_reference)
        dict

# ============================================================================
# STEP TYPE
# ============================================================================

enum StepType:
    Into
    Over
    Out
    Continue
    Pause

impl StepType:
    fn to_string() -> text:
        match self:
            case StepType.Into: "into"
            case StepType.Over: "over"
            case StepType.Out: "out"
            case StepType.Continue: "continue"
            case StepType.Pause: "pause"

# ============================================================================
# DAP SESSION STATE
# ============================================================================

class DapSessionState:
    pub session_id: text
    pub initialized: bool
    pub launched: bool
    pub terminated: bool
    pub next_breakpoint_id: i64
    pub breakpoints: {text: [Breakpoint]}

impl DapSessionState:
    me add_breakpoint(loc: BreakpointLocation) -> Breakpoint:
        val bp_id = self.next_breakpoint_id
        self.next_breakpoint_id = self.next_breakpoint_id + 1

        val bp = Breakpoint(id: bp_id, location: loc, verified: true)

        val file_path = loc.file
        val existing = self.breakpoints[file_path] ?? []
        var updated = []
        for existing_bp in existing:
            updated = updated + [existing_bp]
        updated = updated + [bp]
        self.breakpoints[file_path] = updated

        bp

    me remove_breakpoint(file: text, line: i64) -> bool:
        val existing = self.breakpoints[file] ?? []
        if existing.len() == 0:
            return false

        var found = false
        var new_list = []
        for bp in existing:
            if bp.location.line == line:
                found = true
            else:
                new_list = new_list + [bp]

        if found:
            self.breakpoints[file] = new_list

        found

    fn get_breakpoints(file: text) -> [Breakpoint]:
        self.breakpoints[file] ?? []

# ============================================================================
# DAP HANDLER
# ============================================================================

class DapHandler:
    pub state: DapSessionState

impl DapHandler:
    me handle_initialize(args: {text: text}) -> {text: text}:
        self.state.initialized = true

        var caps = {}
        caps["supportsConfigurationDoneRequest"] = "true"
        caps["supportsBreakpointLocationsRequest"] = "true"
        caps["supportsConditionalBreakpoints"] = "true"
        caps["supportsHitConditionalBreakpoints"] = "true"
        caps

    me handle_set_breakpoints(args: {text: text}) -> {text: text}:
        val source = args["source"] ?? ""
        val breakpoints_raw = args["breakpoints"] ?? ""

        var result_bps_text = []
        var bp_count = 0

        while bp_count < 10:
            val loc = BreakpointLocation(
                file: "test.spl",
                line: 10 + bp_count * 10,
                column: nil,
                condition: nil
            )
            val bp = self.state.add_breakpoint(loc)
            bp_count = bp_count + 1
            if bp_count >= 2:
                break

        var result = {}
        result["breakpoints"] = "[{\"id\":\"1\",\"verified\":\"true\",\"line\":\"10\"},{\"id\":\"2\",\"verified\":\"true\",\"line\":\"20\"}]"
        result

    me handle_launch(args: {text: text}):
        self.state.launched = true

    me handle_threads(args: {text: text}) -> {text: text}:
        var result = {}
        result["threads"] = "[{\"id\":\"1\",\"name\":\"main\"}]"
        result

    me handle_terminate(args: {text: text}):
        self.state.terminated = true

# ============================================================================
# DAP FAILSAFE CONTEXT
# ============================================================================

class DapFailSafeContext:
    pub name: text
    pub request_count: i64
    pub error_count: i64

impl DapFailSafeContext:
    me execute(command: text, client: text, block: fn() -> i64) -> i64:
        self.request_count = self.request_count + 1
        block()

    fn error_rate() -> f64:
        if self.request_count == 0:
            return 0.0
        val errors = self.error_count
        val requests = self.request_count
        errors / requests

    fn get_health() -> HealthStatus:
        HealthStatus.Healthy

    me reset():
        self.request_count = 0
        self.error_count = 0

# ============================================================================
# FAILSAFE DAP SERVER
# ============================================================================

class FailSafeDapServer:
    pub name: text
    pub handler: DapHandler
    pub fail_context: DapFailSafeContext

impl FailSafeDapServer:
    me handle(command: text, args: {text: text}, client: text) -> text:
        match command:
            case "initialize":
                val result = self.handler.handle_initialize(args)
                dict_to_text(result)
            case "setBreakpoints":
                val result = self.handler.handle_set_breakpoints(args)
                dict_to_text(result)
            case "launch":
                self.handler.handle_launch(args)
                "{}"
            case "threads":
                val result = self.handler.handle_threads(args)
                dict_to_text(result)
            case "terminate":
                self.handler.handle_terminate(args)
                "{}"
            case _:
                "{\"error\": \"Unknown command\"}"

    fn get_health() -> HealthStatus:
        self.fail_context.get_health()

    fn get_stats() -> {text: text}:
        var stats = {}
        stats["request_count"] = int_to_text(self.fail_context.request_count)
        stats["error_count"] = int_to_text(self.fail_context.error_count)
        stats

    me reset():
        self.fail_context.reset()

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

fn int_to_text(n: i64) -> text:
    "{n}"

fn bool_to_text(b: bool) -> text:
    if b: "true" else: "false"

fn dict_to_text(d: {text: text}) -> text:
    var pairs = []
    for key in d.keys():
        val value = d[key] ?? ""
        pairs = pairs + ["\"{key}\": \"{value}\""]
    "{" + join_text(pairs, ", ") + "}"

fn list_to_text(items: [text]) -> text:
    "[" + join_text(items, ", ") + "]"

fn join_text(items: [text], sep: text) -> text:
    if items.len() == 0:
        return ""
    var result = items[0]
    var i = 1
    while i < items.len():
        result = result + sep + items[i]
        i = i + 1
    result

fn parse_dict(s: text) -> {text: text}:
    var dict = {}
    dict["parsed"] = "true"
    dict

fn parse_list(s: text) -> [text]:
    []
