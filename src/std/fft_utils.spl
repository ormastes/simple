# FFT Utilities Module
# Comprehensive Fast Fourier Transform implementation in Pure Simple

# ============================================================================
# Complex Number Operations
# ============================================================================

# Complex number represented as (real, imag) tuple
fn complex_new(real: f64, imag: f64) -> (f64, f64):
    (real, imag)

fn complex_add(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    (a_real + b_real, a_imag + b_imag)

fn complex_sub(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    (a_real - b_real, a_imag - b_imag)

fn complex_mul(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    val real = a_real * b_real - a_imag * b_imag
    val imag = a_real * b_imag + a_imag * b_real
    (real, imag)

fn complex_div(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    val denom = b_real * b_real + b_imag * b_imag
    val real = (a_real * b_real + a_imag * b_imag) / denom
    val imag = (a_imag * b_real - a_real * b_imag) / denom
    (real, imag)

fn complex_conjugate(c: (f64, f64)) -> (f64, f64):
    val real = c.0
    val imag = c.1
    (real, -imag)

fn complex_magnitude(c: (f64, f64)) -> f64:
    val real = c.0
    val imag = c.1
    math_sqrt(real * real + imag * imag)

fn complex_magnitude_squared(c: (f64, f64)) -> f64:
    val real = c.0
    val imag = c.1
    real * real + imag * imag

fn complex_phase(c: (f64, f64)) -> f64:
    val real = c.0
    val imag = c.1
    math_atan2(imag, real)

fn complex_exp(theta: f64) -> (f64, f64):
    # e^(i*theta) = cos(theta) + i*sin(theta)
    val real = math_cos(theta)
    val imag = math_sin(theta)
    (real, imag)

fn complex_scale(c: (f64, f64), s: f64) -> (f64, f64):
    val real = c.0
    val imag = c.1
    (real * s, imag * s)

fn complex_negate(c: (f64, f64)) -> (f64, f64):
    val real = c.0
    val imag = c.1
    (-real, -imag)

fn complex_real(c: (f64, f64)) -> f64:
    c.0

fn complex_imag(c: (f64, f64)) -> f64:
    c.1

# ============================================================================
# Utility Functions
# ============================================================================

fn is_power_of_2(n: i64) -> bool:
    if n <= 0:
        false
    else:
        n & (n - 1) == 0

fn next_power_of_2(n: i64) -> i64:
    if n <= 1:
        1
    else:
        var power = 1
        while power < n:
            power = power * 2
        power

fn log2_int(n: i64) -> i64:
    var result = 0
    var value = n
    while value > 1:
        value = value / 2
        result = result + 1
    result

fn frequency_resolution(sample_rate: f64, n: i64) -> f64:
    sample_rate / n as f64

fn bin_to_frequency(bin: i64, sample_rate: f64, n: i64) -> f64:
    bin as f64 * sample_rate / n as f64

fn frequency_to_bin(freq: f64, sample_rate: f64, n: i64) -> i64:
    (freq * n as f64 / sample_rate) as i64

# ============================================================================
# Bit Reversal
# ============================================================================

fn reverse_bits(x: i64, bits: i64) -> i64:
    var result = 0
    var value = x
    var i = 0
    while i < bits:
        result = (result << 1) | (value & 1)
        value = value >> 1
        i = i + 1
    result

fn bit_reversal_permutation(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    val bits = log2_int(n)
    var result = []
    var i = 0
    while i < n:
        val j = reverse_bits(i, bits)
        val elem = array_get(data, j)
        result = array_push(result, elem)
        i = i + 1
    result

# ============================================================================
# Twiddle Factors
# ============================================================================

fn compute_twiddle_factors(n: i64, inverse: bool) -> [(f64, f64)]:
    var factors = []
    var k = 0
    val sign = if inverse: 1.0 else: -1.0
    while k < n / 2:
        val angle = sign * 2.0 * math_pi() * k as f64 / n as f64
        val twiddle = complex_exp(angle)
        factors = array_push(factors, twiddle)
        k = k + 1
    factors

# ============================================================================
# Zero Padding
# ============================================================================

fn zero_pad_to_power_of_2(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    val target = next_power_of_2(n)
    var result = data
    var i = n
    while i < target:
        result = array_push(result, (0.0, 0.0))
        i = i + 1
    result

fn zero_pad_to_size(data: [(f64, f64)], target_size: i64) -> [(f64, f64)]:
    val n = array_len(data)
    var result = data
    var i = n
    while i < target_size:
        result = array_push(result, (0.0, 0.0))
        i = i + 1
    result

# ============================================================================
# Windowing Functions
# ============================================================================

fn hamming_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    while i < n:
        val w = 0.54 - 0.46 * math_cos(2.0 * math_pi() * i as f64 / (n - 1) as f64)
        window = array_push(window, w)
        i = i + 1
    window

fn hanning_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    while i < n:
        val w = 0.5 * (1.0 - math_cos(2.0 * math_pi() * i as f64 / (n - 1) as f64))
        window = array_push(window, w)
        i = i + 1
    window

fn blackman_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    val a0 = 0.42
    val a1 = 0.5
    val a2 = 0.08
    while i < n:
        val t = i as f64 / (n - 1) as f64
        val w = a0 - a1 * math_cos(2.0 * math_pi() * t) + a2 * math_cos(4.0 * math_pi() * t)
        window = array_push(window, w)
        i = i + 1
    window

fn kaiser_window(n: i64, beta: f64) -> [f64]:
    # Simplified Kaiser window using approximation
    var window = []
    var i = 0
    val n_half = (n - 1) as f64 / 2.0
    while i < n:
        val x = (i as f64 - n_half) / n_half
        val arg = beta * math_sqrt(1.0 - x * x)
        # Approximation of I0(arg) using first few terms
        val w = bessel_i0_approx(arg) / bessel_i0_approx(beta)
        window = array_push(window, w)
        i = i + 1
    window

fn bessel_i0_approx(x: f64) -> f64:
    # Modified Bessel function I0 approximation
    val t = x / 3.75
    if x < 3.75:
        val y = t * t
        1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492 +
            y * (0.2659732 + y * (0.0360768 + y * 0.0045813)))))
    else:
        val y = 1.0 / t
        val exp_x = math_exp(x)
        exp_x / math_sqrt(x) * (0.39894228 + y * (0.01328592 +
            y * (0.00225319 + y * (-0.00157565 + y * (0.00916281 +
            y * (-0.02057706 + y * (0.02635537 + y * (-0.01647633 +
            y * 0.00392377))))))))

fn rectangular_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    while i < n:
        window = array_push(window, 1.0)
        i = i + 1
    window

fn triangular_window(n: i64) -> [f64]:
    var window = []
    var i = 0
    val n_half = n as f64 / 2.0
    while i < n:
        val w = 1.0 - math_abs((i as f64 - n_half) / n_half)
        window = array_push(window, w)
        i = i + 1
    window

fn apply_window(data: [(f64, f64)], window: [f64]) -> [(f64, f64)]:
    val n = array_len(data)
    var result = []
    var i = 0
    while i < n:
        val sample = array_get(data, i)
        val w = array_get(window, i)
        val windowed = complex_scale(sample, w)
        result = array_push(result, windowed)
        i = i + 1
    result

# ============================================================================
# Direct DFT (for any size)
# ============================================================================

fn dft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    var result = []
    var k = 0
    while k < n:
        var sum_real = 0.0
        var sum_imag = 0.0
        var m = 0
        while m < n:
            val angle = -2.0 * math_pi() * k as f64 * m as f64 / n as f64
            val twiddle = complex_exp(angle)
            val sample = array_get(data, m)
            val product = complex_mul(sample, twiddle)
            sum_real = sum_real + product.0
            sum_imag = sum_imag + product.1
            m = m + 1
        result = array_push(result, (sum_real, sum_imag))
        k = k + 1
    result

fn idft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    var result = []
    var k = 0
    while k < n:
        var sum_real = 0.0
        var sum_imag = 0.0
        var m = 0
        while m < n:
            val angle = 2.0 * math_pi() * k as f64 * m as f64 / n as f64
            val twiddle = complex_exp(angle)
            val sample = array_get(data, m)
            val product = complex_mul(sample, twiddle)
            sum_real = sum_real + product.0
            sum_imag = sum_imag + product.1
            m = m + 1
        val scaled = (sum_real / n as f64, sum_imag / n as f64)
        result = array_push(result, scaled)
        k = k + 1
    result

# ============================================================================
# Cooley-Tukey Radix-2 FFT
# ============================================================================

fn fft_radix2(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if not is_power_of_2(n):
            # Fall back to DFT for non-power-of-2
            dft(data)
        else:
            # Bit reversal permutation
            var x = bit_reversal_permutation(data)

            # Iterative FFT
            var size = 2
            while size <= n:
                val half_size = size / 2
                val twiddles = compute_twiddle_factors(size, false)

                var i = 0
                while i < n:
                    var k = 0
                    while k < half_size:
                        val idx1 = i + k
                        val idx2 = i + k + half_size
                        val t = complex_mul(array_get(twiddles, k), array_get(x, idx2))
                        val u = array_get(x, idx1)
                        val new1 = complex_add(u, t)
                        val new2 = complex_sub(u, t)
                        x = array_set(x, idx1, new1)
                        x = array_set(x, idx2, new2)
                        k = k + 1
                    i = i + size
                size = size * 2
            x

fn ifft_radix2(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if not is_power_of_2(n):
            # Fall back to IDFT for non-power-of-2
            idft(data)
        else:
            # Conjugate input
            var conjugated = []
            var i = 0
            while i < n:
                val c = complex_conjugate(array_get(data, i))
                conjugated = array_push(conjugated, c)
                i = i + 1

            # Apply FFT
            val fft_result = fft_radix2(conjugated)

            # Conjugate and scale output
            var result = []
            i = 0
            while i < n:
                val c = complex_conjugate(array_get(fft_result, i))
                val scaled = complex_scale(c, 1.0 / n as f64)
                result = array_push(result, scaled)
                i = i + 1
            result

# ============================================================================
# Bluestein's Algorithm (for any size)
# ============================================================================

fn bluestein_chirp(n: i64, k: i64, inverse: bool) -> (f64, f64):
    val sign = if inverse: 1.0 else: -1.0
    val angle = sign * math_pi() * k as f64 * k as f64 / n as f64
    complex_exp(angle)

fn bluestein_fft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    val m = next_power_of_2(2 * n - 1)

    # Compute chirp values and modulate input
    var a = []
    var i = 0
    while i < m:
        if i < n:
            val chirp = bluestein_chirp(n, i, false)
            val sample = array_get(data, i)
            val modulated = complex_mul(sample, complex_conjugate(chirp))
            a = array_push(a, modulated)
        else:
            a = array_push(a, (0.0, 0.0))
        i = i + 1

    # Compute chirp convolution kernel
    var b = []
    i = 0
    while i < m:
        if i < n:
            val chirp = bluestein_chirp(n, i, false)
            b = array_push(b, chirp)
        else:
            if i >= m - n + 1:
                val chirp = bluestein_chirp(n, m - i, false)
                b = array_push(b, chirp)
            else:
                b = array_push(b, (0.0, 0.0))
        i = i + 1

    # Convolve using FFT
    val fft_a = fft_radix2(a)
    val fft_b = fft_radix2(b)

    var product = []
    i = 0
    while i < m:
        val p = complex_mul(array_get(fft_a, i), array_get(fft_b, i))
        product = array_push(product, p)
        i = i + 1

    val convolution = ifft_radix2(product)

    # Demodulate output
    var result = []
    i = 0
    while i < n:
        val chirp = bluestein_chirp(n, i, false)
        val sample = array_get(convolution, i)
        val demodulated = complex_mul(sample, complex_conjugate(chirp))
        result = array_push(result, demodulated)
        i = i + 1
    result

fn bluestein_ifft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)

    # Conjugate input
    var conjugated = []
    var i = 0
    while i < n:
        val c = complex_conjugate(array_get(data, i))
        conjugated = array_push(conjugated, c)
        i = i + 1

    # Apply Bluestein FFT
    val fft_result = bluestein_fft(conjugated)

    # Conjugate and scale output
    var result = []
    i = 0
    while i < n:
        val c = complex_conjugate(array_get(fft_result, i))
        val scaled = complex_scale(c, 1.0 / n as f64)
        result = array_push(result, scaled)
        i = i + 1
    result

# ============================================================================
# Adaptive FFT (chooses best algorithm)
# ============================================================================

fn fft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if is_power_of_2(n):
            fft_radix2(data)
        else:
            if n < 32:
                dft(data)
            else:
                bluestein_fft(data)

fn ifft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if is_power_of_2(n):
            ifft_radix2(data)
        else:
            if n < 32:
                idft(data)
            else:
                bluestein_ifft(data)

# ============================================================================
# Real FFT (RFFT)
# ============================================================================

fn rfft(real_data: [f64]) -> [(f64, f64)]:
    val n = array_len(real_data)
    var complex_data = []
    var i = 0
    while i < n:
        val r = array_get(real_data, i)
        complex_data = array_push(complex_data, (r, 0.0))
        i = i + 1
    fft(complex_data)

fn irfft(complex_data: [(f64, f64)]) -> [f64]:
    val result = ifft(complex_data)
    var real_data = []
    var i = 0
    val n = array_len(result)
    while i < n:
        val c = array_get(result, i)
        real_data = array_push(real_data, c.0)
        i = i + 1
    real_data

# ============================================================================
# 2D FFT
# ============================================================================

fn fft2d(data: [[(f64, f64)]]) -> [[(f64, f64)]]:
    val rows = array_len(data)
    if rows == 0:
        []
    else:
        val cols = array_len(array_get(data, 0))

        # FFT on rows
        var row_fft = []
        var i = 0
        while i < rows:
            val row = array_get(data, i)
            val transformed = fft(row)
            row_fft = array_push(row_fft, transformed)
            i = i + 1

        # Transpose
        var transposed = []
        var j = 0
        while j < cols:
            var col = []
            i = 0
            while i < rows:
                val row = array_get(row_fft, i)
                val elem = array_get(row, j)
                col = array_push(col, elem)
                i = i + 1
            transposed = array_push(transposed, col)
            j = j + 1

        # FFT on columns (transposed rows)
        var col_fft = []
        i = 0
        while i < cols:
            val col = array_get(transposed, i)
            val transformed = fft(col)
            col_fft = array_push(col_fft, transformed)
            i = i + 1

        # Transpose back
        var result = []
        i = 0
        while i < rows:
            var row = []
            j = 0
            while j < cols:
                val col = array_get(col_fft, j)
                val elem = array_get(col, i)
                row = array_push(row, elem)
                j = j + 1
            result = array_push(result, row)
            i = i + 1
        result

fn ifft2d(data: [[(f64, f64)]]) -> [[(f64, f64)]]:
    val rows = array_len(data)
    if rows == 0:
        []
    else:
        val cols = array_len(array_get(data, 0))

        # IFFT on rows
        var row_ifft = []
        var i = 0
        while i < rows:
            val row = array_get(data, i)
            val transformed = ifft(row)
            row_ifft = array_push(row_ifft, transformed)
            i = i + 1

        # Transpose
        var transposed = []
        var j = 0
        while j < cols:
            var col = []
            i = 0
            while i < rows:
                val row = array_get(row_ifft, i)
                val elem = array_get(row, j)
                col = array_push(col, elem)
                i = i + 1
            transposed = array_push(transposed, col)
            j = j + 1

        # IFFT on columns (transposed rows)
        var col_ifft = []
        i = 0
        while i < cols:
            val col = array_get(transposed, i)
            val transformed = ifft(col)
            col_ifft = array_push(col_ifft, transformed)
            i = i + 1

        # Transpose back
        var result = []
        i = 0
        while i < rows:
            var row = []
            j = 0
            while j < cols:
                val col = array_get(col_ifft, j)
                val elem = array_get(col, i)
                row = array_push(row, elem)
                j = j + 1
            result = array_push(result, row)
            i = i + 1
        result

# ============================================================================
# Spectral Analysis
# ============================================================================

fn power_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val power = complex_magnitude_squared(c)
        result = array_push(result, power)
        i = i + 1
    result

fn magnitude_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val mag = complex_magnitude(c)
        result = array_push(result, mag)
        i = i + 1
    result

fn phase_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val phase = complex_phase(c)
        result = array_push(result, phase)
        i = i + 1
    result

fn power_spectral_density(fft_data: [(f64, f64)], sample_rate: f64) -> [f64]:
    val n = array_len(fft_data)
    val scale = 1.0 / (sample_rate * n as f64)
    var result = []
    var i = 0
    while i < n:
        val c = array_get(fft_data, i)
        val psd = complex_magnitude_squared(c) * scale
        result = array_push(result, psd)
        i = i + 1
    result

fn db_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val mag = complex_magnitude(c)
        val db = if mag > 0.0: 20.0 * math_log10(mag) else: -100.0
        result = array_push(result, db)
        i = i + 1
    result

# ============================================================================
# Convolution and Correlation
# ============================================================================

fn convolve_fft(signal1: [f64], signal2: [f64]) -> [f64]:
    val n1 = array_len(signal1)
    val n2 = array_len(signal2)
    val n = next_power_of_2(n1 + n2 - 1)

    # Zero pad both signals
    var padded1 = []
    var i = 0
    while i < n:
        if i < n1:
            val r = array_get(signal1, i)
            padded1 = array_push(padded1, (r, 0.0))
        else:
            padded1 = array_push(padded1, (0.0, 0.0))
        i = i + 1

    var padded2 = []
    i = 0
    while i < n:
        if i < n2:
            val r = array_get(signal2, i)
            padded2 = array_push(padded2, (r, 0.0))
        else:
            padded2 = array_push(padded2, (0.0, 0.0))
        i = i + 1

    # FFT both signals
    val fft1 = fft(padded1)
    val fft2 = fft(padded2)

    # Multiply in frequency domain
    var product = []
    i = 0
    while i < n:
        val p = complex_mul(array_get(fft1, i), array_get(fft2, i))
        product = array_push(product, p)
        i = i + 1

    # IFFT to get convolution
    val conv_complex = ifft(product)

    # Extract real part
    var result = []
    i = 0
    while i < n1 + n2 - 1:
        val c = array_get(conv_complex, i)
        result = array_push(result, c.0)
        i = i + 1
    result

fn correlate_fft(signal1: [f64], signal2: [f64]) -> [f64]:
    val n1 = array_len(signal1)
    val n2 = array_len(signal2)
    val n = next_power_of_2(n1 + n2 - 1)

    # Zero pad both signals
    var padded1 = []
    var i = 0
    while i < n:
        if i < n1:
            val r = array_get(signal1, i)
            padded1 = array_push(padded1, (r, 0.0))
        else:
            padded1 = array_push(padded1, (0.0, 0.0))
        i = i + 1

    var padded2 = []
    i = 0
    while i < n:
        if i < n2:
            val r = array_get(signal2, i)
            padded2 = array_push(padded2, (r, 0.0))
        else:
            padded2 = array_push(padded2, (0.0, 0.0))
        i = i + 1

    # FFT both signals
    val fft1 = fft(padded1)
    val fft2 = fft(padded2)

    # Multiply first by conjugate of second
    var product = []
    i = 0
    while i < n:
        val f1 = array_get(fft1, i)
        val f2_conj = complex_conjugate(array_get(fft2, i))
        val p = complex_mul(f1, f2_conj)
        product = array_push(product, p)
        i = i + 1

    # IFFT to get correlation
    val corr_complex = ifft(product)

    # Extract real part
    var result = []
    i = 0
    while i < n1 + n2 - 1:
        val c = array_get(corr_complex, i)
        result = array_push(result, c.0)
        i = i + 1
    result

# ============================================================================
# Utility Conversions
# ============================================================================

fn real_to_complex(real_data: [f64]) -> [(f64, f64)]:
    var result = []
    var i = 0
    val n = array_len(real_data)
    while i < n:
        val r = array_get(real_data, i)
        result = array_push(result, (r, 0.0))
        i = i + 1
    result

fn complex_to_real(complex_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(complex_data)
    while i < n:
        val c = array_get(complex_data, i)
        result = array_push(result, c.0)
        i = i + 1
    result

fn complex_to_imag(complex_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(complex_data)
    while i < n:
        val c = array_get(complex_data, i)
        result = array_push(result, c.1)
        i = i + 1
    result

# ============================================================================
# Frequency Domain Filtering
# ============================================================================

fn lowpass_filter_fft(signal: [f64], cutoff_bin: i64) -> [f64]:
    val complex_signal = real_to_complex(signal)
    val fft_result = fft(complex_signal)
    val n = array_len(fft_result)

    # Zero out high frequencies
    var filtered = []
    var i = 0
    while i < n:
        if i <= cutoff_bin or i >= n - cutoff_bin:
            filtered = array_push(filtered, array_get(fft_result, i))
        else:
            filtered = array_push(filtered, (0.0, 0.0))
        i = i + 1

    val ifft_result = ifft(filtered)
    complex_to_real(ifft_result)

fn highpass_filter_fft(signal: [f64], cutoff_bin: i64) -> [f64]:
    val complex_signal = real_to_complex(signal)
    val fft_result = fft(complex_signal)
    val n = array_len(fft_result)

    # Zero out low frequencies
    var filtered = []
    var i = 0
    while i < n:
        if i > cutoff_bin and i < n - cutoff_bin:
            filtered = array_push(filtered, array_get(fft_result, i))
        else:
            filtered = array_push(filtered, (0.0, 0.0))
        i = i + 1

    val ifft_result = ifft(filtered)
    complex_to_real(ifft_result)

fn bandpass_filter_fft(signal: [f64], low_bin: i64, high_bin: i64) -> [f64]:
    val complex_signal = real_to_complex(signal)
    val fft_result = fft(complex_signal)
    val n = array_len(fft_result)

    # Zero out frequencies outside band
    var filtered = []
    var i = 0
    while i < n:
        val in_low_band = i >= low_bin and i <= high_bin
        val in_high_band = i >= n - high_bin and i <= n - low_bin
        if in_low_band or in_high_band:
            filtered = array_push(filtered, array_get(fft_result, i))
        else:
            filtered = array_push(filtered, (0.0, 0.0))
        i = i + 1

    val ifft_result = ifft(filtered)
    complex_to_real(ifft_result)

# ============================================================================
# Mathematical Helpers
# ============================================================================

fn math_pi() -> f64:
    3.141592653589793

fn math_sqrt(x: f64) -> f64:
    x ** 0.5

fn math_cos(x: f64) -> f64:
    # Taylor series approximation
    var result = 1.0
    var term = 1.0
    var i = 1
    while i < 20:
        term = -term * x * x / ((2 * i - 1) as f64 * (2 * i) as f64)
        result = result + term
        i = i + 1
    result

fn math_sin(x: f64) -> f64:
    # Taylor series approximation
    var result = x
    var term = x
    var i = 1
    while i < 20:
        term = -term * x * x / ((2 * i) as f64 * (2 * i + 1) as f64)
        result = result + term
        i = i + 1
    result

fn math_atan2(y: f64, x: f64) -> f64:
    # Simplified atan2
    if x > 0.0:
        math_atan(y / x)
    else:
        if x < 0.0 and y >= 0.0:
            math_atan(y / x) + math_pi()
        else:
            if x < 0.0 and y < 0.0:
                math_atan(y / x) - math_pi()
            else:
                if x == 0.0 and y > 0.0:
                    math_pi() / 2.0
                else:
                    if x == 0.0 and y < 0.0:
                        -math_pi() / 2.0
                    else:
                        0.0

fn math_atan(x: f64) -> f64:
    # Taylor series for small x, else use identities
    if x > -0.5 and x < 0.5:
        var result = x
        var term = x
        var i = 1
        while i < 20:
            term = -term * x * x
            result = result + term / (2 * i + 1) as f64
            i = i + 1
        result
    else:
        if x > 0.0:
            math_pi() / 2.0 - math_atan(1.0 / x)
        else:
            -math_pi() / 2.0 - math_atan(1.0 / x)

fn math_exp(x: f64) -> f64:
    # Taylor series approximation
    var result = 1.0
    var term = 1.0
    var i = 1
    while i < 30:
        term = term * x / i as f64
        result = result + term
        i = i + 1
    result

fn math_log10(x: f64) -> f64:
    math_ln(x) / math_ln(10.0)

fn math_ln(x: f64) -> f64:
    # Natural log approximation using series
    if x <= 0.0:
        -1000.0  # Error value
    else:
        var y = (x - 1.0) / (x + 1.0)
        var result = 0.0
        var term = y
        var i = 0
        while i < 50:
            result = result + term / (2 * i + 1) as f64
            term = term * y * y
            i = i + 1
        2.0 * result

fn math_abs(x: f64) -> f64:
    if x < 0.0: -x else: x
