# Skip List Search and Lookup Operations
#
# This module provides functions for searching and retrieving elements from skip lists.

import types

# Find update path for insertion/deletion (returns array of predecessor indices)
fn sl_find_update_path(skiplist: tuple, key: i64) -> list:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var current_level = types.sl_get_level(skiplist)

    var update = []
    var i = 0
    while i < types.MAX_LEVELS:
        update = update + [types.NIL_REF]
        i = i + 1

    var current_idx = head_idx
    var lvl = current_level

    while lvl >= 0:
        var current_node = nodes[current_idx]
        var next_idx = types.sl_node_get_forward(current_node, lvl)

        while next_idx != types.NIL_REF:
            var next_node = nodes[next_idx]
            var next_key = types.sl_node_key(next_node)

            if next_key >= key:
                break

            current_idx = next_idx
            current_node = nodes[current_idx]
            next_idx = types.sl_node_get_forward(current_node, lvl)

        var new_update = []
        var j = 0
        while j < types.MAX_LEVELS:
            if j == lvl:
                new_update = new_update + [current_idx]
            else:
                var existing = update[j]
                new_update = new_update + [existing]
            j = j + 1
        update = new_update

        lvl = lvl - 1

    update

# Search for a key in the skip list (returns node index or NIL_REF)
fn sl_search(skiplist: tuple, key: i64) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx == types.NIL_REF:
        return types.NIL_REF

    var pred_node = nodes[pred_idx]
    var next_idx = types.sl_node_get_forward(pred_node, 0)

    if next_idx == types.NIL_REF:
        return types.NIL_REF

    var next_node = nodes[next_idx]
    var next_key = types.sl_node_key(next_node)

    if next_key == key:
        next_idx
    else:
        types.NIL_REF

# Get value associated with key (returns value or 0 if not found)
fn sl_get(skiplist: tuple, key: i64) -> i64:
    var idx = sl_search(skiplist, key)
    if idx == types.NIL_REF:
        return 0

    var nodes = types.sl_get_nodes(skiplist)
    var node = nodes[idx]
    var value = types.sl_node_value(node)
    value

# Check if skip list contains a key
fn sl_contains(skiplist: tuple, key: i64) -> i64:
    var idx = sl_search(skiplist, key)
    if idx != types.NIL_REF:
        1
    else:
        0

# Find floor (largest key <= given key)
fn sl_floor(skiplist: tuple, key: i64) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx == types.NIL_REF:
        return types.MIN_KEY

    var pred_node = nodes[pred_idx]
    var next_idx = types.sl_node_get_forward(pred_node, 0)

    if next_idx != types.NIL_REF:
        var next_node = nodes[next_idx]
        var next_key = types.sl_node_key(next_node)
        if next_key == key:
            return next_key

    if pred_idx == head_idx:
        return types.MIN_KEY

    var pred_key = types.sl_node_key(pred_node)
    pred_key

# Find ceiling (smallest key >= given key)
fn sl_ceiling(skiplist: tuple, key: i64) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx == types.NIL_REF:
        return types.MAX_KEY

    var pred_node = nodes[pred_idx]
    var next_idx = types.sl_node_get_forward(pred_node, 0)

    if next_idx == types.NIL_REF:
        return types.MAX_KEY

    var next_node = nodes[next_idx]
    var next_key = types.sl_node_key(next_node)
    next_key

# Get all key-value pairs in range [min_key, max_key]
fn sl_range_query(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    var nodes = types.sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, min_key)
    var pred_idx = update[0]

    if pred_idx == types.NIL_REF:
        return []

    var pred_node = nodes[pred_idx]
    var current_idx = types.sl_node_get_forward(pred_node, 0)

    var result = []
    while current_idx != types.NIL_REF:
        var current_node = nodes[current_idx]
        var current_key = types.sl_node_key(current_node)

        if current_key > max_key:
            break

        if current_key >= min_key:
            var current_value = types.sl_node_value(current_node)
            var pair = (current_key, current_value)
            result = result + [pair]

        current_idx = types.sl_node_get_forward(current_node, 0)

    result

# Get all keys in range [min_key, max_key]
fn sl_range_keys(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var key = pair[0]
        result = result + [key]
        i = i + 1
    result

# Get all values in range [min_key, max_key]
fn sl_range_values(skiplist: tuple, min_key: i64, max_key: i64) -> list:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var value = pair[1]
        result = result + [value]
        i = i + 1
    result

# Count elements in range [min_key, max_key]
fn sl_range_count(skiplist: tuple, min_key: i64, max_key: i64) -> i64:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    pairs.len()

# Prefix sum for values in range [MIN_KEY, max_key]
fn sl_prefix_sum(skiplist: tuple, max_key: i64) -> i64:
    var values = sl_range_values(skiplist, types.MIN_KEY, max_key)
    var sum = 0
    var i = 0
    while i < values.len():
        var value = values[i]
        sum = sum + value
        i = i + 1
    sum

# Range sum for values in range [min_key, max_key]
fn sl_range_sum(skiplist: tuple, min_key: i64, max_key: i64) -> i64:
    var values = sl_range_values(skiplist, min_key, max_key)
    var sum = 0
    var i = 0
    while i < values.len():
        var value = values[i]
        sum = sum + value
        i = i + 1
    sum

# Filter skip list by predicate on keys
fn sl_filter_keys(skiplist: tuple, min_key: i64, max_key: i64) -> tuple:
    var pairs = sl_range_query(skiplist, min_key, max_key)
    import create
    var result = create.sl_create()
    import insert
    insert.sl_insert_many(result, pairs)
