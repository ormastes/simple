# Minimum Spanning Tree Algorithms
#
# Purpose: Algorithms for finding minimum spanning trees
#
# Contains:
# - Kruskal's algorithm (union-find based)
# - Prim's algorithm (greedy approach)

# Import types module for graph_neighbors
mod graph.types

# ============================================================================
# Minimum Spanning Tree Algorithms
# ============================================================================

# Kruskal's algorithm (MST using union-find)
# Returns list of edges in MST
fn graph_kruskal(graph: tuple) -> list:
    var edges = graph.3
    var num_vertices = graph.2

    # Sort edges by weight (simple bubble sort)
    var sorted_edges = edges
    var n = sorted_edges.len()
    var swapped = true
    while swapped:
        swapped = false
        var i = 1
        while i < n:
            var e1 = sorted_edges.get(i - 1)
            var e2 = sorted_edges.get(i)
            if e1.2 > e2.2:
                sorted_edges = sorted_edges.set(i - 1, e2)
                sorted_edges = sorted_edges.set(i, e1)
                swapped = true
            i = i + 1
        n = n - 1

    # Union-Find data structures
    var parent = {}
    var rank = {}
    var j = 0
    while j < num_vertices:
        parent = parent.set(j, j)
        rank = rank.set(j, 0)
        j = j + 1

    # Find with path compression
    fn find(x: i64) -> i64:
        var p = parent.get(x)
        if p != x:
            p = find(p)
            parent = parent.set(x, p)
        p

    # Union by rank
    fn union(x: i64, y: i64) -> bool:
        var root_x = find(x)
        var root_y = find(y)

        if root_x == root_y:
            return false

        var rank_x = rank.get(root_x)
        var rank_y = rank.get(root_y)

        if rank_x < rank_y:
            parent = parent.set(root_x, root_y)
        else:
            if rank_x > rank_y:
                parent = parent.set(root_y, root_x)
            else:
                parent = parent.set(root_y, root_x)
                rank = rank.set(root_x, rank_x + 1)

        true

    # Kruskal's algorithm
    var mst = []
    var k = 0
    while k < sorted_edges.len() && mst.len() < num_vertices - 1:
        var edge = sorted_edges.get(k)
        var from = edge.0
        var to = edge.1

        if union(from, to):
            mst = mst.append(edge)

        k = k + 1

    mst

# Prim's algorithm (MST using priority queue simulation)
# Returns list of edges in MST
fn graph_prim(graph: tuple, start: i64) -> list:
    var mst = []
    var visited = {}
    var num_vertices = graph.2

    visited = visited.set(start, true)
    var visited_count = 1

    while visited_count < num_vertices:
        # Find minimum edge from visited to unvisited vertices
        var min_weight = 999999999.0
        var min_edge = nil

        var i = 0
        while i < num_vertices:
            var is_visited = visited.get(i)
            if is_visited != nil:
                var neighbors = graph_neighbors(graph, i)
                var j = 0
                while j < neighbors.len():
                    var neighbor = neighbors.get(j)
                    var neighbor_id = neighbor.0
                    var weight = neighbor.1
                    var neighbor_visited = visited.get(neighbor_id)
                    if neighbor_visited == nil && weight < min_weight:
                        min_weight = weight
                        min_edge = (i, neighbor_id, weight)
                    j = j + 1
            i = i + 1

        if min_edge == nil:
            break

        mst = mst.append(min_edge)
        visited = visited.set(min_edge.1, true)
        visited_count = visited_count + 1

    mst

export *
