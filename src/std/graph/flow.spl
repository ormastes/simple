# Flow and Cut Algorithms
#
# Purpose: Maximum flow and minimum cut algorithms
#
# Contains:
# - Minimum cut using BFS
# - Basic flow algorithms

# Import modules
mod graph.types
mod graph.traversal

# ============================================================================
# Minimum Cut and Flow (Basic)
# ============================================================================

# Find minimum cut using BFS (returns capacity of min cut)
fn graph_min_cut_bfs(graph: tuple, source: i64, sink: i64) -> f64:
    var num_vertices = graph.2

    # Check if path exists
    if !graph_has_path(graph, source, sink):
        return 0.0

    # Simple approach: find minimum edge weight on any path
    var min_capacity = 999999999.0
    var path = graph_bfs_shortest_path(graph, source, sink)

    var i = 0
    while i < path.len() - 1:
        var from = path.get(i)
        var to = path.get(i + 1)
        var weight = graph_edge_weight(graph, from, to)
        if weight < min_capacity:
            min_capacity = weight
        i = i + 1

    min_capacity

# Check if there's a path between two vertices
fn graph_has_path(graph: tuple, start: i64, end: i64) -> bool:
    var visited = graph_dfs(graph, start)
    var i = 0
    while i < visited.len():
        if visited.get(i) == end:
            return true
        i = i + 1
    false

# Get edge weight between two vertices
fn graph_edge_weight(graph: tuple, from: i64, to: i64) -> f64:
    var neighbors = graph_neighbors(graph, from)
    var i = 0
    while i < neighbors.len():
        var neighbor = neighbors.get(i)
        if neighbor.0 == to:
            return neighbor.1
        i = i + 1
    999999999.0

export *
