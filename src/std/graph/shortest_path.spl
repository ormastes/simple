# Shortest Path Algorithms
#
# Purpose: Single-source and all-pairs shortest path algorithms for weighted graphs
#
# Contains:
# - Dijkstra's algorithm (single-source, non-negative weights)
# - Bellman-Ford algorithm (handles negative weights)
# - Floyd-Warshall algorithm (all-pairs shortest paths)
# - Path reconstruction utilities

# Import types module for graph_neighbors and graph_to_matrix
mod graph.types

# ============================================================================
# Shortest Path Algorithms
# ============================================================================

# Dijkstra's algorithm (single-source shortest path for non-negative weights)
# Returns map<vertex, distance>
fn graph_dijkstra(graph: tuple, start: i64) -> map:
    var distances = {}
    var visited = {}
    var num_vertices = graph.2

    # Initialize distances
    var i = 0
    while i < num_vertices:
        distances = distances.set(i, 999999999.0)
        i = i + 1
    distances = distances.set(start, 0.0)

    var remaining = num_vertices
    while remaining > 0:
        # Find unvisited vertex with minimum distance
        var min_dist = 999999999.0
        var min_vertex = -1
        var j = 0
        while j < num_vertices:
            var is_visited = visited.get(j)
            if is_visited == nil:
                var dist = distances.get(j)
                if dist < min_dist:
                    min_dist = dist
                    min_vertex = j
            j = j + 1

        if min_vertex == -1:
            break

        visited = visited.set(min_vertex, true)
        remaining = remaining - 1

        # Update distances to neighbors
        var neighbors = graph_neighbors(graph, min_vertex)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var weight = neighbor.1
            var current_dist = distances.get(min_vertex)
            var neighbor_dist = distances.get(neighbor_id)
            var new_dist = current_dist + weight
            if new_dist < neighbor_dist:
                distances = distances.set(neighbor_id, new_dist)
            k = k + 1

    distances

# Dijkstra's algorithm with path reconstruction
# Returns (distances: map, parents: map)
fn graph_dijkstra_with_paths(graph: tuple, start: i64) -> tuple:
    var distances = {}
    var parents = {}
    var visited = {}
    var num_vertices = graph.2

    # Initialize
    var i = 0
    while i < num_vertices:
        distances = distances.set(i, 999999999.0)
        parents = parents.set(i, -1)
        i = i + 1
    distances = distances.set(start, 0.0)

    var remaining = num_vertices
    while remaining > 0:
        # Find minimum
        var min_dist = 999999999.0
        var min_vertex = -1
        var j = 0
        while j < num_vertices:
            var is_visited = visited.get(j)
            if is_visited == nil:
                var dist = distances.get(j)
                if dist < min_dist:
                    min_dist = dist
                    min_vertex = j
            j = j + 1

        if min_vertex == -1:
            break

        visited = visited.set(min_vertex, true)
        remaining = remaining - 1

        # Update neighbors
        var neighbors = graph_neighbors(graph, min_vertex)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var weight = neighbor.1
            var current_dist = distances.get(min_vertex)
            var neighbor_dist = distances.get(neighbor_id)
            var new_dist = current_dist + weight
            if new_dist < neighbor_dist:
                distances = distances.set(neighbor_id, new_dist)
                parents = parents.set(neighbor_id, min_vertex)
            k = k + 1

    (distances, parents)

# Reconstruct path from Dijkstra's parents map
fn graph_reconstruct_path(parents: map, start: i64, end: i64) -> list:
    var path = []
    var current = end

    while current != -1:
        path = [current].concat(path)
        if current == start:
            break
        current = parents.get(current)

    if path.len() > 0 && path.get(0) != start:
        []
    else:
        path

# Bellman-Ford algorithm (handles negative weights, detects negative cycles)
# Returns (distances: map, has_negative_cycle: bool)
fn graph_bellman_ford(graph: tuple, start: i64) -> tuple:
    var num_vertices = graph.2
    var edges = graph.3
    var distances = {}

    # Initialize distances
    var i = 0
    while i < num_vertices:
        distances = distances.set(i, 999999999.0)
        i = i + 1
    distances = distances.set(start, 0.0)

    # Relax edges V-1 times
    var round = 0
    while round < num_vertices - 1:
        var j = 0
        while j < edges.len():
            var edge = edges.get(j)
            var from = edge.0
            var to = edge.1
            var weight = edge.2
            var from_dist = distances.get(from)
            var to_dist = distances.get(to)
            var new_dist = from_dist + weight
            if from_dist != 999999999.0 && new_dist < to_dist:
                distances = distances.set(to, new_dist)
            j = j + 1
        round = round + 1

    # Check for negative cycles
    var has_negative_cycle = false
    var k = 0
    while k < edges.len():
        var edge = edges.get(k)
        var from = edge.0
        var to = edge.1
        var weight = edge.2
        var from_dist = distances.get(from)
        var to_dist = distances.get(to)
        var new_dist = from_dist + weight
        if from_dist != 999999999.0 && new_dist < to_dist:
            has_negative_cycle = true
        k = k + 1

    (distances, has_negative_cycle)

# Floyd-Warshall algorithm (all-pairs shortest paths)
# Returns matrix of distances
fn graph_floyd_warshall(graph: tuple) -> list:
    var num_vertices = graph.2
    var matrix = graph_to_matrix(graph)

    # Initialize with infinity for non-edges
    var i = 0
    while i < num_vertices:
        var row = matrix.get(i)
        var j = 0
        while j < num_vertices:
            if i != j:
                var val = row.get(j)
                if val == 0.0:
                    row = row.set(j, 999999999.0)
            j = j + 1
        matrix = matrix.set(i, row)
        i = i + 1

    # Floyd-Warshall iterations
    var k = 0
    while k < num_vertices:
        var m = 0
        while m < num_vertices:
            var row_m = matrix.get(m)
            var n = 0
            while n < num_vertices:
                var dist_mn = row_m.get(n)
                var dist_mk = row_m.get(k)
                var row_k = matrix.get(k)
                var dist_kn = row_k.get(n)
                var new_dist = dist_mk + dist_kn
                if new_dist < dist_mn:
                    row_m = row_m.set(n, new_dist)
                n = n + 1
            matrix = matrix.set(m, row_m)
            m = m + 1
        k = k + 1

    matrix

export *
