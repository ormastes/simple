# Async Runtime
#
# Asynchronous programming runtime with futures, executors, and async I/O.
# Provides cooperative multitasking without blocking threads.
#
# Components:
# - Future<T>: Represents an async computation
# - Promise<T>: Write side of a future
# - Task: Schedulable unit of async work
# - Executor: Single-threaded task executor
# - Scheduler: Task scheduling with priorities
# - AsyncIO: Non-blocking I/O operations
#
# Usage:
#   val future = async_compute()
#   val result = await future  # Suspends until ready
#
# Architecture:
# - Cooperative multitasking (no preemption)
# - Poll-based futures (Rust-style)
# - Event loop with wake notifications

use std.atomic.*
use std.concurrent.*

# ============================================================================
# Poll - Future Poll Result
# ============================================================================

enum Poll<T>:
    """Result of polling a future.

    - Ready(value): Future completed with value
    - Pending: Future not yet ready
    """
    Ready(T)
    Pending

impl Poll<T>:
    fn is_ready() -> bool:
        """Check if future is ready."""
        match self:
            case Poll.Ready(_): true
            case Poll.Pending: false

    fn is_pending() -> bool:
        """Check if future is pending."""
        not self.is_ready()

    fn unwrap() -> T:
        """Unwrap ready value (panics if pending)."""
        match self:
            case Poll.Ready(value): value
            case Poll.Pending: panic("Poll is pending")

# ============================================================================
# Future<T> - Async Computation
# ============================================================================

class Future<T>:
    """Represents an asynchronous computation.

    A future is a value that may not be available yet.
    Futures are polled to check if they're ready.

    Example:
        val future = Future<i64>.from_value(42)

        match future.poll():
            case Poll.Ready(value):
                print "Got {value}"
            case Poll.Pending:
                print "Not ready yet"
    """
    state: [u8]  # Opaque future state

    static fn from_value(value: T) -> Future<T>:
        """Create future that's immediately ready.

        Args:
            value: Ready value

        Returns:
            Completed future
        """
        val state = future_alloc_ready(value)
        Future(state: state)

    static fn pending() -> Future<T>:
        """Create future that's pending.

        Returns:
            Pending future
        """
        val state = future_alloc_pending::<T>()
        Future(state: state)

    fn poll() -> Poll<T>:
        """Poll future to check if ready.

        Returns:
            Ready(value) if complete, Pending otherwise

        Non-blocking operation.
        """
        future_poll::<T>(self.state)

    fn is_ready() -> bool:
        """Check if future is ready (non-blocking).

        Returns:
            true if ready, false otherwise
        """
        self.poll().is_ready()

    fn map<U>(f: fn(T) -> U) -> Future<U>:
        """Transform future value.

        Args:
            f: Transformation function

        Returns:
            New future with transformed value
        """
        val state = future_map(self.state, f)
        Future(state: state)

    fn then<U>(f: fn(T) -> Future<U>) -> Future<U>:
        """Chain futures (flatMap).

        Args:
            f: Function returning future

        Returns:
            Chained future
        """
        val state = future_then(self.state, f)
        Future(state: state)

    me drop():
        """Drop future, freeing resources."""
        future_free::<T>(self.state)

# ============================================================================
# Promise<T> - Future Write Side
# ============================================================================

class Promise<T>:
    """Write side of a future.

    A promise allows completing a future with a value.
    Each promise has an associated future.

    Example:
        val (future, promise) = Promise<i64>.new()

        # Complete promise
        promise.complete(42)

        # Future now ready
        val value = future.poll().unwrap()  # 42
    """
    state: [u8]  # Opaque promise state

    static fn new() -> (Future<T>, Promise<T>):
        """Create new future-promise pair.

        Returns:
            (future, promise) tuple
        """
        val state = promise_alloc::<T>()
        val future_state = promise_get_future(state)

        (Future(state: future_state), Promise(state: state))

    fn complete(value: T) -> bool:
        """Complete promise with value.

        Args:
            value: Completion value

        Returns:
            true if completed, false if already completed

        Wakes waiting tasks.
        """
        promise_complete(self.state, value)

    fn is_completed() -> bool:
        """Check if promise is completed.

        Returns:
            true if completed, false otherwise
        """
        promise_is_completed(self.state)

    me drop():
        """Drop promise (future becomes cancelled if not completed)."""
        promise_free::<T>(self.state)

# ============================================================================
# Task - Schedulable Async Work
# ============================================================================

class Task:
    """Schedulable unit of async work.

    A task wraps a future and provides scheduling metadata.

    Example:
        val task = Task.new(\: async_work())
        executor.spawn(task)
    """
    id: usize           # Task ID
    future: [u8]        # Future to execute
    priority: i32       # Task priority (higher = more urgent)
    state: TaskState    # Current state

enum TaskState:
    """Task execution state."""
    Pending      # Not yet started
    Running      # Currently executing
    Suspended    # Waiting for event
    Completed    # Finished
    Cancelled    # Cancelled

impl Task:
    static fn new<T>(f: fn() -> Future<T>) -> Task:
        """Create new task from async function.

        Args:
            f: Async function

        Returns:
            Task
        """
        val id = task_alloc_id()
        val future = f()

        Task(
            id: id,
            future: future.state,
            priority: 0,
            state: TaskState.Pending
        )

    static fn with_priority<T>(f: fn() -> Future<T>, priority: i32) -> Task:
        """Create task with priority.

        Args:
            f: Async function
            priority: Task priority

        Returns:
            Task
        """
        var task = Task.new(f)
        task.priority = priority
        task

    fn is_completed() -> bool:
        """Check if task is completed."""
        match self.state:
            case TaskState.Completed: true
            case _: false

    fn is_running() -> bool:
        """Check if task is running."""
        match self.state:
            case TaskState.Running: true
            case _: false

# ============================================================================
# Executor - Single-Threaded Task Executor
# ============================================================================

class Executor:
    """Single-threaded async task executor.

    Runs tasks cooperatively on a single thread.
    Tasks yield when waiting for I/O or other futures.

    Example:
        val executor = Executor.new()

        # Spawn tasks
        executor.spawn(Task.new(\: async_task1()))
        executor.spawn(Task.new(\: async_task2()))

        # Run until all tasks complete
        executor.run()
    """
    tasks: [Task]           # Task queue
    ready_queue: [usize]    # IDs of ready tasks
    running: bool           # Executor running flag

    static fn new() -> Executor:
        """Create new executor."""
        Executor(
            tasks: [],
            ready_queue: [],
            running: false
        )

    me spawn(task: Task):
        """Spawn task for execution.

        Args:
            task: Task to spawn

        Task added to ready queue.
        """
        val task_id = task.id
        self.tasks = self.tasks.push(task)
        self.ready_queue = self.ready_queue.push(task_id)

    me run():
        """Run executor until all tasks complete.

        Blocks until no tasks remain.
        """
        self.running = true

        while self.running and not self.ready_queue.is_empty():
            # Get next ready task
            val task_id = self.ready_queue[0]
            self.ready_queue = self.ready_queue[1:]

            # Find task
            var task_index = 0
            for i in 0..self.tasks.len():
                if self.tasks[i].id == task_id:
                    task_index = i
                    break

            # Poll task
            var task = self.tasks[task_index]
            task.state = TaskState.Running

            val poll_result = future_poll_any(task.future)

            match poll_result:
                case Poll.Ready(_):
                    # Task completed
                    task.state = TaskState.Completed
                    self.tasks[task_index] = task

                case Poll.Pending:
                    # Task suspended
                    task.state = TaskState.Suspended
                    self.tasks[task_index] = task
                    # Will be re-queued when woken

        self.running = false

    me run_once():
        """Run one iteration of event loop.

        Returns after polling all ready tasks once.
        """
        if self.ready_queue.is_empty():
            return

        val initial_count = self.ready_queue.len()

        for _ in 0..initial_count:
            if self.ready_queue.is_empty():
                break

            val task_id = self.ready_queue[0]
            self.ready_queue = self.ready_queue[1:]

            # Poll task (same as run())
            for i in 0..self.tasks.len():
                if self.tasks[i].id == task_id:
                    var task = self.tasks[i]
                    task.state = TaskState.Running

                    val result = future_poll_any(task.future)

                    if result.is_ready():
                        task.state = TaskState.Completed
                    else:
                        task.state = TaskState.Suspended

                    self.tasks[i] = task
                    break

    me stop():
        """Stop executor."""
        self.running = false

    fn has_tasks() -> bool:
        """Check if executor has pending tasks.

        Returns:
            true if tasks remain, false otherwise
        """
        not self.tasks.is_empty()

    me wake(task_id: usize):
        """Wake suspended task.

        Args:
            task_id: Task to wake

        Task added to ready queue.
        """
        # Check if already in ready queue
        for id in self.ready_queue:
            if id == task_id:
                return

        self.ready_queue = self.ready_queue.push(task_id)

# ============================================================================
# Scheduler - Priority-Based Task Scheduler
# ============================================================================

class Scheduler:
    """Priority-based task scheduler.

    Schedules tasks based on priority (higher = more urgent).

    Example:
        val scheduler = Scheduler.new()

        scheduler.schedule(Task.with_priority(\: urgent(), 10))
        scheduler.schedule(Task.with_priority(\: normal(), 0))

        scheduler.run()  # Urgent tasks run first
    """
    high_priority: [Task]   # High priority tasks (priority >= 5)
    normal_priority: [Task] # Normal priority tasks
    low_priority: [Task]    # Low priority tasks (priority < 0)
    executor: Executor      # Underlying executor

    static fn new() -> Scheduler:
        """Create new scheduler."""
        Scheduler(
            high_priority: [],
            normal_priority: [],
            low_priority: [],
            executor: Executor.new()
        )

    me schedule(task: Task):
        """Schedule task based on priority.

        Args:
            task: Task to schedule
        """
        if task.priority >= 5:
            self.high_priority = self.high_priority.push(task)
        else if task.priority < 0:
            self.low_priority = self.low_priority.push(task)
        else:
            self.normal_priority = self.normal_priority.push(task)

    me run():
        """Run all scheduled tasks (priority order).

        High priority tasks run first.
        """
        # Spawn high priority tasks
        for task in self.high_priority:
            self.executor.spawn(task)
        self.high_priority = []

        # Spawn normal priority tasks
        for task in self.normal_priority:
            self.executor.spawn(task)
        self.normal_priority = []

        # Spawn low priority tasks
        for task in self.low_priority:
            self.executor.spawn(task)
        self.low_priority = []

        # Run executor
        self.executor.run()

    fn pending_count() -> usize:
        """Get count of pending tasks.

        Returns:
            Number of scheduled tasks
        """
        self.high_priority.len() +
        self.normal_priority.len() +
        self.low_priority.len()

# ============================================================================
# AsyncIO - Non-Blocking I/O
# ============================================================================

class AsyncIO:
    """Non-blocking I/O operations.

    Provides async versions of blocking I/O operations.

    Example:
        val io = AsyncIO.new()

        # Async read
        val data = await io.read_file("data.txt")

        # Async write
        await io.write_file("output.txt", data)
    """
    executor: Executor  # IO executor

    static fn new() -> AsyncIO:
        """Create async I/O runtime."""
        AsyncIO(executor: Executor.new())

    fn sleep(millis: usize) -> Future<()>:
        """Sleep for specified milliseconds (async).

        Args:
            millis: Milliseconds to sleep

        Returns:
            Future that completes after delay
        """
        val state = async_sleep(millis)
        Future(state: state)

    fn yield_now() -> Future<()>:
        """Yield to other tasks.

        Returns:
            Future that completes immediately but allows scheduling
        """
        val state = async_yield()
        Future(state: state)

    fn read_file(path: text) -> Future<[u8]>:
        """Read file asynchronously.

        Args:
            path: File path

        Returns:
            Future with file contents
        """
        val state = async_read_file(path)
        Future(state: state)

    fn write_file(path: text, data: [u8]) -> Future<bool>:
        """Write file asynchronously.

        Args:
            path: File path
            data: Data to write

        Returns:
            Future with success flag
        """
        val state = async_write_file(path, data)
        Future(state: state)

# ============================================================================
# Utility Functions
# ============================================================================

fn spawn<T>(f: fn() -> Future<T>) -> Task:
    """Convenience function to spawn task.

    Args:
        f: Async function

    Returns:
        Task
    """
    Task.new(f)

fn join<T>(futures: [Future<T>]) -> Future<[T]>:
    """Wait for all futures to complete.

    Args:
        futures: Futures to wait for

    Returns:
        Future with all results
    """
    val state = async_join(futures.map(\f: f.state))
    Future(state: state)

fn select<T>(futures: [Future<T>]) -> Future<T>:
    """Wait for first future to complete.

    Args:
        futures: Futures to race

    Returns:
        Future with first result
    """
    val state = async_select(futures.map(\f: f.state))
    Future(state: state)

# ============================================================================
# FFI Functions
# ============================================================================

# Future operations
extern fn future_alloc_ready<T>(value: T) -> [u8]
extern fn future_alloc_pending<T>() -> [u8]
extern fn future_poll<T>(state: [u8]) -> Poll<T>
extern fn future_poll_any(state: [u8]) -> Poll<()>
extern fn future_free<T>(state: [u8])
extern fn future_map<T, U>(state: [u8], f: fn(T) -> U) -> [u8]
extern fn future_then<T, U>(state: [u8], f: fn(T) -> Future<U>) -> [u8]

# Promise operations
extern fn promise_alloc<T>() -> [u8]
extern fn promise_get_future(state: [u8]) -> [u8]
extern fn promise_complete<T>(state: [u8], value: T) -> bool
extern fn promise_is_completed(state: [u8]) -> bool
extern fn promise_free<T>(state: [u8])

# Task operations
extern fn task_alloc_id() -> usize

# Async I/O operations
extern fn async_sleep(millis: usize) -> [u8]
extern fn async_yield() -> [u8]
extern fn async_read_file(path: text) -> [u8]
extern fn async_write_file(path: text, data: [u8]) -> [u8]

# Combinators
extern fn async_join(futures: [[u8]]) -> [u8]
extern fn async_select(futures: [[u8]]) -> [u8]

# ============================================================================
# Exports
# ============================================================================

export Poll
export Future
export Promise
export Task
export TaskState
export Executor
export Scheduler
export AsyncIO
export spawn
export join
export select

# ============================================================================
# Two-Tier Runtime System
# ============================================================================
#
# Simple provides two async runtime implementations:
#
# 1. EMBEDDED (src/std/async_embedded.spl)
#    - Fixed capacity (configurable MAX_TASKS, MAX_FUTURES)
#    - No heap allocation (stack + static only)
#    - Polling-based (no wakers)
#    - Simple cooperative scheduling
#    - Use for: microcontrollers, RTOS, resource-constrained
#
# 2. HOST (src/std/async_host.spl)
#    - Dynamic capacity (heap-allocated)
#    - Waker-based notification
#    - Work-stealing scheduler
#    - Full cancellation support
#    - Use for: desktop, server, full OS
#
# SHARED INTERFACE (src/std/async_core.spl)
#    - Common traits: FutureCore, TaskHandleCore, JoinSetCore
#    - Common types: Poll, TaskState, Priority, CancellationToken
#    - Code can target both runtimes using traits
#
# NEW PRIMITIVES (in both runtimes):
#    - JoinSet<T>     - Await group with streaming completion
#    - FuturesUnordered<T> - Stream futures as each completes
#    - TaskHandle.is_finished() - Non-blocking completion check
#
# Usage:
#   # For unified API (selectable at compile time):
#   use std.async_unified.*
#
#   # For embedded specifically:
#   use std.async_embedded.*
#
#   # For host specifically:
#   use std.async_host.*
#
# ============================================================================
