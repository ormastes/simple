# Email Address Validation and Parsing

fn email_is_valid_char(ch: text) -> bool:
    if ch == "@":
        return true
    if ch == ".":
        return true
    if ch == "-":
        return true
    if ch == "_":
        return true
    if ch == "+":
        return true

    var is_alpha = ch >= "a" and ch <= "z"
    if is_alpha:
        return true

    var is_upper = ch >= "A" and ch <= "Z"
    if is_upper:
        return true

    var is_digit = ch >= "0" and ch <= "9"
    return is_digit

fn email_validate(email: text) -> bool:
    var at_pos = email.index_of("@")
    if at_pos == -1:
        return false

    var at_count = 0
    var i = 0
    var len = email.length()
    while i < len:
        var ch = email.char_at(i)
        if ch == "@":
            at_count = at_count + 1
        i = i + 1

    if at_count != 1:
        return false

    var local_part = email.substring(0, at_pos)
    var domain_part_start = at_pos + 1
    var domain_part = email.substring(domain_part_start, len)

    if local_part.length() == 0:
        return false
    if domain_part.length() == 0:
        return false

    var dot_pos = domain_part.index_of(".")
    if dot_pos == -1:
        return false

    return true

fn email_parse_local_part(email: text) -> text:
    var at_pos = email.index_of("@")
    if at_pos == -1:
        return ""
    return email.substring(0, at_pos)

fn email_parse_domain(email: text) -> text:
    var at_pos = email.index_of("@")
    if at_pos == -1:
        return ""
    var start = at_pos + 1
    var len = email.length()
    return email.substring(start, len)

fn email_parse_display_name(full_address: text) -> text:
    var start_bracket = full_address.index_of("<")
    if start_bracket == -1:
        return ""
    var display = full_address.substring(0, start_bracket)
    return display.trim()

fn email_parse_address(full_address: text) -> text:
    var start_bracket = full_address.index_of("<")
    var end_bracket = full_address.index_of(">")

    if start_bracket == -1:
        return full_address.trim()

    if end_bracket == -1:
        return full_address.trim()

    var start_pos = start_bracket + 1
    return full_address.substring(start_pos, end_bracket)

fn email_format_address(email: text, display_name: text) -> text:
    if display_name.length() == 0:
        return email
    return "{display_name} <{email}>"

fn email_list_to_recipients(emails: text) -> List:
    var parts = emails.split(",")
    var result = []
    var i = 0
    var count = parts.length()

    while i < count:
        var email = parts.get(i)
        var trimmed = email.trim()
        if trimmed.length() > 0:
            result.push(trimmed)
        i = i + 1

    return result

fn email_sanitize_subject(subject: text) -> text:
    var result = subject.replace("\r", "")
    var result2 = result.replace("\n", "")
    return result2

fn email_sanitize_body(body: text) -> text:
    var result = body.replace("\n.\n", "\n..\n")
    var result2 = result.replace("\r\n.\r\n", "\r\n..\r\n")
    return result2

# Email Headers
# RFC 5322

fn header_from(email: text) -> text:
    return "From: {email}\r\n"

fn header_to(email: text) -> text:
    return "To: {email}\r\n"

fn header_cc(email: text) -> text:
    return "Cc: {email}\r\n"

fn header_bcc(email: text) -> text:
    return "Bcc: {email}\r\n"

fn header_subject(subject: text) -> text:
    return "Subject: {subject}\r\n"

fn header_date(date: text) -> text:
    return "Date: {date}\r\n"

fn header_message_id(id: text) -> text:
    return "Message-ID: <{id}>\r\n"

fn header_content_type(content_type: text) -> text:
    return "Content-Type: {content_type}\r\n"

fn header_content_transfer_encoding(encoding: text) -> text:
    return "Content-Transfer-Encoding: {encoding}\r\n"

fn header_mime_version() -> text:
    return "MIME-Version: 1.0\r\n"

fn header_reply_to(email: text) -> text:
    return "Reply-To: {email}\r\n"

fn header_sender(email: text) -> text:
    return "Sender: {email}\r\n"

fn header_return_path(email: text) -> text:
    return "Return-Path: <{email}>\r\n"

fn header_content_disposition(disposition: text) -> text:
    return "Content-Disposition: {disposition}\r\n"

fn header_custom(name: text, value: text) -> text:
    return "{name}: {value}\r\n"

# Header Folding (RFC 5322)

fn header_fold_line(header: text, max_length: i64) -> text:
    var len = header.length()
    if len <= max_length:
        return header

    var result = ""
    var current_line = ""
    var words = header.split(" ")
    var word_idx = 0
    var word_count = words.length()

    while word_idx < word_count:
        var word = words.get(word_idx)
        var test_line = current_line
        if test_line.length() > 0:
            test_line = test_line + " "
        test_line = test_line + word

        if test_line.length() > max_length:
            if current_line.length() > 0:
                result = result + current_line + "\r\n "
                current_line = word
            else:
                result = result + word + "\r\n "
                current_line = ""
        else:
            current_line = test_line

        word_idx = word_idx + 1

    if current_line.length() > 0:
        result = result + current_line

    return result

fn header_unfold(header: text) -> text:
    var result = header.replace("\r\n ", " ")
    var result2 = result.replace("\r\n\t", " ")
    return result2

# Message Building

fn message_build_simple(from: text, to: text, subject: text, body: text) -> text:
    var msg = ""
    msg = msg + header_from(from)
    msg = msg + header_to(to)
    msg = msg + header_subject(subject)
    msg = msg + header_content_type(mime_type_text_plain())
    msg = msg + "\r\n"
    msg = msg + body
    msg = msg + "\r\n"
    return msg

fn message_build_html(from: text, to: text, subject: text, html_body: text) -> text:
    var msg = ""
    msg = msg + header_from(from)
    msg = msg + header_to(to)
    msg = msg + header_subject(subject)
    msg = msg + header_content_type(mime_type_text_html())
    msg = msg + "\r\n"
    msg = msg + html_body
    msg = msg + "\r\n"
    return msg

fn message_build_multipart_alternative(from: text, to: text, subject: text, text_body: text, html_body: text) -> text:
    var boundary = mime_generate_boundary()
    var content_type = mime_type_multipart_alternative() + "; boundary=\"{boundary}\""

    var msg = ""
    msg = msg + header_from(from)
    msg = msg + header_to(to)
    msg = msg + header_subject(subject)
    msg = msg + header_mime_version()
    msg = msg + header_content_type(content_type)
    msg = msg + "\r\n"

    msg = msg + mime_boundary_start(boundary)
    msg = msg + header_content_type(mime_type_text_plain())
    msg = msg + "\r\n"
    msg = msg + text_body
    msg = msg + "\r\n\r\n"

    msg = msg + mime_boundary_start(boundary)
    msg = msg + header_content_type(mime_type_text_html())
    msg = msg + "\r\n"
    msg = msg + html_body
    msg = msg + "\r\n\r\n"

    msg = msg + mime_boundary_end(boundary)
    return msg

fn message_build_with_attachment(from: text, to: text, subject: text, body: text, attachment_name: text, attachment_data: text) -> text:
    var boundary = mime_generate_boundary()
    var content_type = mime_type_multipart_mixed() + "; boundary=\"{boundary}\""

    var msg = ""
    msg = msg + header_from(from)
    msg = msg + header_to(to)
    msg = msg + header_subject(subject)
    msg = msg + header_mime_version()
    msg = msg + header_content_type(content_type)
    msg = msg + "\r\n"

    msg = msg + mime_boundary_start(boundary)
    msg = msg + header_content_type(mime_type_text_plain())
    msg = msg + "\r\n"
    msg = msg + body
    msg = msg + "\r\n\r\n"

    msg = msg + mime_boundary_start(boundary)
    msg = msg + header_content_type(mime_type_application_octet_stream())
    var disposition = "attachment; filename=\"{attachment_name}\""
    msg = msg + header_content_disposition(disposition)
    msg = msg + header_content_transfer_encoding("base64")
    msg = msg + "\r\n"
    var encoded_attachment = base64_encode_with_line_breaks(attachment_data, 76)
    msg = msg + encoded_attachment
    msg = msg + "\r\n\r\n"

    msg = msg + mime_boundary_end(boundary)
    return msg

fn message_build_reply(original_message_id: text, from: text, to: text, subject: text, body: text) -> text:
    var msg = ""
    msg = msg + header_from(from)
    msg = msg + header_to(to)
    msg = msg + header_subject(subject)
    msg = msg + header_custom("In-Reply-To", "<{original_message_id}>")
    msg = msg + header_custom("References", "<{original_message_id}>")
    msg = msg + header_content_type(mime_type_text_plain())
    msg = msg + "\r\n"
    msg = msg + body
    msg = msg + "\r\n"
    return msg

fn message_build_forward(original_from: text, from: text, to: text, subject: text, original_body: text, preamble: text) -> text:
    var msg = ""
    msg = msg + header_from(from)
    msg = msg + header_to(to)
    msg = msg + header_subject(subject)
    msg = msg + header_content_type(mime_type_text_plain())
    msg = msg + "\r\n"
    msg = msg + preamble
    msg = msg + "\r\n\r\n"
    msg = msg + "---------- Forwarded message ---------\r\n"
    msg = msg + "From: {original_from}\r\n"
    msg = msg + "\r\n"
    msg = msg + original_body
    msg = msg + "\r\n"
    return msg

fn message_terminate() -> text:
    return "\r\n.\r\n"

# Message Parsing Utilities

fn message_extract_header(message: text, header_name: text) -> text:
    var search = header_name + ":"
    var start = message.index_of(search)
    if start == -1:
        return ""

    var value_start = start + search.length()
    var line_end = message.index_of("\r\n", value_start)

    if line_end == -1:
        var len = message.length()
        return message.substring(value_start, len).trim()

    return message.substring(value_start, line_end).trim()

fn message_extract_body(message: text) -> text:
    var separator = "\r\n\r\n"
    var pos = message.index_of(separator)
    if pos == -1:
        return ""
    var body_start = pos + 4
    var len = message.length()
    return message.substring(body_start, len)

fn message_has_header(message: text, header_name: text) -> bool:
    var search = header_name + ":"
    var pos = message.index_of(search)
    return pos != -1

fn message_id_generate(domain: text) -> text:
    var timestamp = "1234567890"
    var random = "abcdef"
    return "{timestamp}.{random}@{domain}"

fn date_rfc5322_format(timestamp: i64) -> text:
    return "Mon, 01 Jan 2024 12:00:00 +0000"

# Forward declarations for MIME functions
fn mime_type_text_plain() -> text
fn mime_type_text_html() -> text
fn mime_type_multipart_alternative() -> text
fn mime_type_multipart_mixed() -> text
fn mime_type_application_octet_stream() -> text
fn mime_generate_boundary() -> text
fn mime_boundary_start(boundary: text) -> text
fn mime_boundary_end(boundary: text) -> text
fn base64_encode_with_line_breaks(data: text, line_length: i64) -> text
