# Base64 Encoding

use string.{char_from_code}

fn base64_char(value: i64) -> text:
    if value < 26:
        var ch_code = 65 + value
        return text_from_char_code(ch_code)
    if value < 52:
        var offset = value - 26
        var ch_code = 97 + offset
        return text_from_char_code(ch_code)
    if value < 62:
        var offset = value - 52
        var ch_code = 48 + offset
        return text_from_char_code(ch_code)
    if value == 62:
        return "+"
    if value == 63:
        return "/"
    return "="

fn base64_encode_bytes(data: text) -> text:
    var result = ""
    var len = data.length()
    var i = 0

    while i < len:
        var byte1 = data.char_code_at(i)
        var has_byte2 = i + 1 < len
        var has_byte3 = i + 2 < len

        var byte2 = 0
        if has_byte2:
            byte2 = data.char_code_at(i + 1)

        var byte3 = 0
        if has_byte3:
            byte3 = data.char_code_at(i + 2)

        var enc1 = byte1 >> 2
        var enc2_part1 = (byte1 & 3) << 4
        var enc2_part2 = byte2 >> 4
        var enc2 = enc2_part1 | enc2_part2
        var enc3_part1 = (byte2 & 15) << 2
        var enc3_part2 = byte3 >> 6
        var enc3 = enc3_part1 | enc3_part2
        var enc4 = byte3 & 63

        result = result + base64_char(enc1)
        result = result + base64_char(enc2)

        if has_byte2:
            result = result + base64_char(enc3)
        else:
            result = result + "="

        if has_byte3:
            result = result + base64_char(enc4)
        else:
            result = result + "="

        i = i + 3

    return result

fn base64_encode_with_line_breaks(data: text, line_length: i64) -> text:
    var encoded = base64_encode_bytes(data)
    var result = ""
    var len = encoded.length()
    var i = 0

    while i < len:
        var end_pos = i + line_length
        if end_pos > len:
            end_pos = len

        var chunk = encoded.substring(i, end_pos)
        result = result + chunk

        var needs_line_break = end_pos < len
        if needs_line_break:
            result = result + "\r\n"

        i = i + line_length

    return result

fn text_from_char_code(code: i64) -> text:
    """Wrapper for string.char_from_code."""
    char_from_code(code)
fn qp_needs_encoding(ch: text) -> bool:
    var code = ch.char_code_at(0)

    if code < 33:
        return true
    if code > 126:
        return true
    if ch == "=":
        return true

    return false

fn qp_encode_char(ch: text) -> text:
    var code = ch.char_code_at(0)
    var hex = code.to_hex()
    var hex_upper = hex.to_upper()
    return "={hex_upper}"

fn qp_encode(text_data: text, line_length: i64) -> text:
    var result = ""
    var current_line = ""
    var i = 0
    var len = text_data.length()

    while i < len:
        var ch = text_data.char_at(i)
        var encoded = ch

        if qp_needs_encoding(ch):
            encoded = qp_encode_char(ch)

        var new_line = current_line + encoded
        var new_len = new_line.length()

        if new_len > line_length:
            result = result + current_line + "=\r\n"
            current_line = encoded
        else:
            current_line = new_line

        i = i + 1

    if current_line.length() > 0:
        result = result + current_line

    return result
