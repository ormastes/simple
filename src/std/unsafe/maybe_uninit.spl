# MaybeUninit<T> - Wrapper for potentially uninitialized memory
# @tag:unsafe
# @tag:api
#
# Usage:
#   val mu = new_uninit()           # create uninitialized slot
#   val mu2 = mu_write(mu, 42)      # write a value (returns new MaybeUninit)
#   val v = mu_assume_init(mu2)     # extract value (runtime-checked)
#
# Note: mu_write returns a NEW MaybeUninit (immutable pattern)
# Use the returned value, not the original.

export MaybeUninit, new_uninit, mu_write, mu_assume_init, mu_is_initialized
export mu_write_text, mu_assume_init_text
export mu_write_bool, mu_assume_init_bool

# First (and only) struct in this file â€” direct construction works from within
struct MaybeUninit<T>:
    value: T
    initialized: bool

# Create an uninitialized MaybeUninit slot
fn new_uninit<T>() -> MaybeUninit<T>:
    MaybeUninit(value: nil, initialized: false)

# Write a value into a MaybeUninit slot (returns a new initialized MaybeUninit)
fn mu_write<T>(mu: MaybeUninit<T>, new_val: T) -> MaybeUninit<T>:
    MaybeUninit(value: new_val, initialized: true)

# Extract the value, assuming it is initialized
# Returns nil if not initialized (runtime safety check)
fn mu_assume_init<T>(mu: MaybeUninit<T>) -> T:
    if mu.initialized == false:
        return nil
    mu.value

# Check if a MaybeUninit slot has been written
fn mu_is_initialized<T>(mu: MaybeUninit<T>) -> bool:
    mu.initialized

# Typed helpers for common cases (avoid generic instantiation issues)
fn mu_write_text(mu: MaybeUninit<text>, val_t: text) -> MaybeUninit<text>:
    MaybeUninit(value: val_t, initialized: true)

fn mu_assume_init_text(mu: MaybeUninit<text>) -> text:
    if mu.initialized == false:
        return ""
    mu.value

fn mu_write_bool(mu: MaybeUninit<bool>, val_b: bool) -> MaybeUninit<bool>:
    MaybeUninit(value: val_b, initialized: true)

fn mu_assume_init_bool(mu: MaybeUninit<bool>) -> bool:
    if mu.initialized == false:
        return false
    mu.value
