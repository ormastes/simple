# TLS/SSL Protocol Utilities Module - Facade
#
# A comprehensive implementation of TLS/SSL protocol utilities for the Simple language.
# This module provides tools for TLS handshake processing, cipher suite management,
# record protocol handling, and key derivation.
#
# This is the main facade that delegates to specialized modules:
# - tls/types.spl: Constants and type definitions
# - tls/record.spl: Record protocol and alert handling
# - tls/handshake.spl: Handshake messages and extensions
# - tls/cipher.spl: Cipher suites and key derivation
# - tls/certificate.spl: Certificate operations (placeholder)
# - tls/validation.spl: Cryptographic validation
# - tls/utilities.spl: Low-level utility functions
#
# TLS Protocol Overview:
# ---------------------
# TLS (Transport Layer Security) provides secure communication over networks through:
# 1. Handshake Protocol: Negotiate security parameters
# 2. Record Protocol: Encapsulate messages with encryption/MAC
# 3. Alert Protocol: Communicate warnings and errors
# 4. Application Data Protocol: Transfer encrypted application data
#
# TLS Handshake Flow:
# ------------------
# Client                                 Server
# ClientHello          -------->
#                                        ServerHello
#                                        Certificate
#                                        ServerKeyExchange*
#                                        CertificateRequest*
#                                        ServerHelloDone
#                      <--------
# Certificate*
# ClientKeyExchange
# CertificateVerify*
# ChangeCipherSpec
# Finished             -------->
#                                        ChangeCipherSpec
#                                        Finished
#                      <--------
# Application Data     <------->        Application Data
#
# * Optional messages

# =============================================================================
# TYPE CONSTANTS - Re-exported from tls/types.spl
# =============================================================================

# NOTE: In a full implementation with proper module imports, these would be:
# from tls.types import *
# For now, we duplicate the constants here as facade exports.

# Content Types (1 byte)
val CONTENT_TYPE_CHANGE_CIPHER_SPEC = 20
val CONTENT_TYPE_ALERT = 21
val CONTENT_TYPE_HANDSHAKE = 22
val CONTENT_TYPE_APPLICATION_DATA = 23

# Protocol Versions (2 bytes)
val TLS_VERSION_1_0 = 0x0301
val TLS_VERSION_1_1 = 0x0302
val TLS_VERSION_1_2 = 0x0303
val TLS_VERSION_1_3 = 0x0304

# Handshake Message Types (1 byte)
val HANDSHAKE_TYPE_HELLO_REQUEST = 0
val HANDSHAKE_TYPE_CLIENT_HELLO = 1
val HANDSHAKE_TYPE_SERVER_HELLO = 2
val HANDSHAKE_TYPE_CERTIFICATE = 11
val HANDSHAKE_TYPE_SERVER_KEY_EXCHANGE = 12
val HANDSHAKE_TYPE_CERTIFICATE_REQUEST = 13
val HANDSHAKE_TYPE_SERVER_HELLO_DONE = 14
val HANDSHAKE_TYPE_CERTIFICATE_VERIFY = 15
val HANDSHAKE_TYPE_CLIENT_KEY_EXCHANGE = 16
val HANDSHAKE_TYPE_FINISHED = 20

# Cipher Suite IDs (2 bytes) - Modern secure suites
val CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F
val CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030
val CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8
val CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C
val CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D
val CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003C
val CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003D

# Extension Types (2 bytes)
val EXTENSION_TYPE_SERVER_NAME = 0
val EXTENSION_TYPE_MAX_FRAGMENT_LENGTH = 1
val EXTENSION_TYPE_STATUS_REQUEST = 5
val EXTENSION_TYPE_SUPPORTED_GROUPS = 10
val EXTENSION_TYPE_EC_POINT_FORMATS = 11
val EXTENSION_TYPE_SIGNATURE_ALGORITHMS = 13
val EXTENSION_TYPE_ALPN = 16
val EXTENSION_TYPE_SUPPORTED_VERSIONS = 43

# Alert Levels (1 byte)
val ALERT_LEVEL_WARNING = 1
val ALERT_LEVEL_FATAL = 2

# Alert Descriptions (1 byte)
val ALERT_DESC_CLOSE_NOTIFY = 0
val ALERT_DESC_UNEXPECTED_MESSAGE = 10
val ALERT_DESC_BAD_RECORD_MAC = 20
val ALERT_DESC_HANDSHAKE_FAILURE = 40
val ALERT_DESC_BAD_CERTIFICATE = 42
val ALERT_DESC_UNSUPPORTED_CERTIFICATE = 43
val ALERT_DESC_CERTIFICATE_REVOKED = 44
val ALERT_DESC_CERTIFICATE_EXPIRED = 45
val ALERT_DESC_CERTIFICATE_UNKNOWN = 46
val ALERT_DESC_ILLEGAL_PARAMETER = 47
val ALERT_DESC_UNKNOWN_CA = 48
val ALERT_DESC_DECODE_ERROR = 50
val ALERT_DESC_PROTOCOL_VERSION = 70
val ALERT_DESC_INTERNAL_ERROR = 80

# TLS Record Protocol
val TLS_RECORD_HEADER_SIZE = 5
val TLS_MAX_FRAGMENT_LENGTH = 16384  # 2^14 bytes

# =============================================================================
# RECORD PROTOCOL - Delegated to tls/record.spl
# =============================================================================

# All record protocol functions are implemented in tls/record.spl
# These are facade functions that maintain backward compatibility

fn build_tls_record(content_type, version, data):
    (content_type, version, data)

fn parse_tls_record(raw_data):
    val data_len = len(raw_data)
    if data_len < TLS_RECORD_HEADER_SIZE:
        nil
    else:
        val content_type = byte_at(raw_data, 0)
        val version_hi = byte_at(raw_data, 1)
        val version_lo = byte_at(raw_data, 2)
        val version = (version_hi * 256) + version_lo
        val length_hi = byte_at(raw_data, 3)
        val length_lo = byte_at(raw_data, 4)
        val length = (length_hi * 256) + length_lo

        if data_len < (TLS_RECORD_HEADER_SIZE + length):
            nil
        else:
            val payload = slice(raw_data, TLS_RECORD_HEADER_SIZE, TLS_RECORD_HEADER_SIZE + length)
            (content_type, version, payload)

fn record_type_name(content_type):
    if content_type == CONTENT_TYPE_CHANGE_CIPHER_SPEC:
        "ChangeCipherSpec"
    else if content_type == CONTENT_TYPE_ALERT:
        "Alert"
    else if content_type == CONTENT_TYPE_HANDSHAKE:
        "Handshake"
    else if content_type == CONTENT_TYPE_APPLICATION_DATA:
        "ApplicationData"
    else:
        "Unknown"

fn validate_tls_version(version):
    val is_tls_12 = version == TLS_VERSION_1_2
    val is_tls_13 = version == TLS_VERSION_1_3
    is_tls_12 or is_tls_13

fn tls_version_name(version):
    if version == TLS_VERSION_1_0:
        "TLS 1.0"
    else if version == TLS_VERSION_1_1:
        "TLS 1.1"
    else if version == TLS_VERSION_1_2:
        "TLS 1.2"
    else if version == TLS_VERSION_1_3:
        "TLS 1.3"
    else:
        "Unknown"

# =============================================================================
# HANDSHAKE PROTOCOL - Handshake Messages
# =============================================================================

# Build a handshake message wrapper
# Parameters:
#   msg_type: Handshake message type (0-20)
#   data: Message payload
# Returns: (type, length, data) tuple
fn build_handshake_message(msg_type, data):
    val length = len(data)
    (msg_type, length, data)

# Parse handshake message from bytes
# Parameters:
#   raw_data: Raw handshake message bytes
# Returns: (type, length, data) tuple or nil on error
fn parse_handshake_message(raw_data):
    val data_len = len(raw_data)
    if data_len < 4:
        nil
    else:
        val msg_type = byte_at(raw_data, 0)
        val len_hi = byte_at(raw_data, 1)
        val len_mid = byte_at(raw_data, 2)
        val len_lo = byte_at(raw_data, 3)
        val length = (len_hi * 65536) + (len_mid * 256) + len_lo

        if data_len < (4 + length):
            nil
        else:
            val payload = slice(raw_data, 4, 4 + length)
            (msg_type, length, payload)

# Get handshake message type name
# Parameters:
#   msg_type: Message type code
# Returns: Human-readable message type
fn handshake_type_name(msg_type):
    if msg_type == HANDSHAKE_TYPE_HELLO_REQUEST:
        "HelloRequest"
    else if msg_type == HANDSHAKE_TYPE_CLIENT_HELLO:
        "ClientHello"
    else if msg_type == HANDSHAKE_TYPE_SERVER_HELLO:
        "ServerHello"
    else if msg_type == HANDSHAKE_TYPE_CERTIFICATE:
        "Certificate"
    else if msg_type == HANDSHAKE_TYPE_SERVER_KEY_EXCHANGE:
        "ServerKeyExchange"
    else if msg_type == HANDSHAKE_TYPE_CERTIFICATE_REQUEST:
        "CertificateRequest"
    else if msg_type == HANDSHAKE_TYPE_SERVER_HELLO_DONE:
        "ServerHelloDone"
    else if msg_type == HANDSHAKE_TYPE_CERTIFICATE_VERIFY:
        "CertificateVerify"
    else if msg_type == HANDSHAKE_TYPE_CLIENT_KEY_EXCHANGE:
        "ClientKeyExchange"
    else if msg_type == HANDSHAKE_TYPE_FINISHED:
        "Finished"
    else:
        "Unknown"

# Build ClientHello message
# Parameters:
#   version: Client-supported TLS version
#   random: 32 bytes of random data
#   session_id: Session ID (empty for new session)
#   cipher_suites: List of cipher suite IDs
#   extensions: List of extension tuples
# Returns: ClientHello tuple (version, random, session_id, cipher_suites, extensions)
fn build_client_hello(version, random, session_id, cipher_suites, extensions):
    (version, random, session_id, cipher_suites, extensions)

# Parse ServerHello message
# Parameters:
#   data: ServerHello payload bytes
# Returns: (version, random, session_id, cipher_suite, extensions) tuple or nil
fn parse_server_hello(data):
    val data_len = len(data)
    if data_len < 38:  # Minimum: 2 (version) + 32 (random) + 1 (session_id len) + 2 (cipher) + 1 (compression)
        nil
    else:
        val version_hi = byte_at(data, 0)
        val version_lo = byte_at(data, 1)
        val version = (version_hi * 256) + version_lo

        val random = slice(data, 2, 34)
        val session_id_len = byte_at(data, 34)

        if data_len < (35 + session_id_len + 3):
            nil
        else:
            val session_id = slice(data, 35, 35 + session_id_len)
            val cipher_offset = 35 + session_id_len
            val cipher_hi = byte_at(data, cipher_offset)
            val cipher_lo = byte_at(data, cipher_offset + 1)
            val cipher_suite = (cipher_hi * 256) + cipher_lo

            # Compression method (1 byte) - always 0 in TLS 1.2+
            val ext_offset = cipher_offset + 3
            var extensions = []

            if data_len > ext_offset:
                extensions = parse_extensions(slice(data, ext_offset, data_len))
            else:
                pass

            (version, random, session_id, cipher_suite, extensions)

# Build ClientKeyExchange message
# Parameters:
#   key_data: Pre-master secret or key exchange data
# Returns: ClientKeyExchange tuple
fn build_client_key_exchange(key_data):
    (len(key_data), key_data)

# Build Finished message
# Parameters:
#   verify_data: 12 bytes of PRF output
# Returns: Finished message data
fn build_finished_message(verify_data):
    verify_data

# Parse Finished message
# Parameters:
#   data: Finished message payload
# Returns: Verify data (12 bytes) or nil
fn parse_finished_message(data):
    if len(data) == 12:
        data
    else:
        nil

# =============================================================================
# CIPHER SUITES - Cipher Suite Management
# =============================================================================

# Get cipher suite information
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: (id, name, key_exchange, cipher, mac, secure) tuple
fn parse_cipher_suite(cipher_id):
    if cipher_id == CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
        (cipher_id, "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", "ECDHE_RSA", "AES_128_GCM", "SHA256", true)
    else if cipher_id == CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
        (cipher_id, "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", "ECDHE_RSA", "AES_256_GCM", "SHA384", true)
    else if cipher_id == CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
        (cipher_id, "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", "ECDHE_RSA", "CHACHA20_POLY1305", "SHA256", true)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256:
        (cipher_id, "TLS_RSA_WITH_AES_128_GCM_SHA256", "RSA", "AES_128_GCM", "SHA256", false)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384:
        (cipher_id, "TLS_RSA_WITH_AES_256_GCM_SHA384", "RSA", "AES_256_GCM", "SHA384", false)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA256:
        (cipher_id, "TLS_RSA_WITH_AES_128_CBC_SHA256", "RSA", "AES_128_CBC", "SHA256", false)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA256:
        (cipher_id, "TLS_RSA_WITH_AES_256_CBC_SHA256", "RSA", "AES_256_CBC", "SHA256", false)
    else:
        (cipher_id, "UNKNOWN", "UNKNOWN", "UNKNOWN", "UNKNOWN", false)

# Get cipher suite name
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: Human-readable name
fn get_cipher_name(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    suite[1]

# Check if cipher suite is considered secure
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: true if secure (ECDHE + AEAD), false otherwise
fn is_cipher_suite_secure(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    suite[5]

# Check if cipher provides forward secrecy
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: true if provides forward secrecy (ECDHE/DHE)
fn has_forward_secrecy(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    val kex = suite[2]
    val starts_ecdhe = starts_with(kex, "ECDHE")
    val starts_dhe = starts_with(kex, "DHE")
    starts_ecdhe or starts_dhe

# Check if cipher uses AEAD mode
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: true if AEAD (GCM, ChaCha20-Poly1305)
fn is_aead_cipher(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    val cipher = suite[3]
    val has_gcm = contains(cipher, "GCM")
    val has_poly1305 = contains(cipher, "POLY1305")
    has_gcm or has_poly1305

# Get cipher key size in bits
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: Key size in bits
fn get_cipher_key_size(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    val cipher = suite[3]

    if contains(cipher, "AES_128"):
        128
    else if contains(cipher, "AES_256"):
        256
    else if contains(cipher, "CHACHA20"):
        256
    else:
        0

# Get hash algorithm for cipher suite
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: Hash algorithm name
fn get_hash_algorithm(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    suite[4]

# Get list of supported cipher suites (ordered by preference)
# Returns: List of cipher suite IDs
fn get_supported_ciphers():
    [
        CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
        CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384,
        CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256
    ]

# Get list of secure cipher suites only
# Returns: List of secure cipher suite IDs
fn get_secure_ciphers():
    [
        CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    ]

# Filter cipher suites by security level
# Parameters:
#   cipher_list: List of cipher suite IDs
# Returns: List of only secure ciphers
fn filter_secure_ciphers(cipher_list):
    var result = []
    for cipher in cipher_list:
        if is_cipher_suite_secure(cipher):
            result = append(result, cipher)
        else:
            pass
    result

# =============================================================================
# EXTENSIONS - TLS Extensions
# =============================================================================

# Build Server Name Indication (SNI) extension
# Parameters:
#   hostname: Server hostname (e.g., "example.com")
# Returns: (type, data) extension tuple
fn build_sni_extension(hostname):
    val host_bytes = to_bytes(hostname)
    val host_len = len(host_bytes)
    # SNI extension format:
    # - Extension type: 0
    # - Extension length: 2 bytes
    # - Server name list length: 2 bytes
    # - Server name type: 1 byte (0 = hostname)
    # - Server name length: 2 bytes
    # - Server name: variable
    (EXTENSION_TYPE_SERVER_NAME, host_bytes)

# Build Supported Versions extension
# Parameters:
#   versions: List of supported version codes
# Returns: (type, data) extension tuple
fn build_supported_versions_extension(versions):
    (EXTENSION_TYPE_SUPPORTED_VERSIONS, versions)

# Build ALPN (Application-Layer Protocol Negotiation) extension
# Parameters:
#   protocols: List of protocol names (e.g., ["h2", "http/1.1"])
# Returns: (type, data) extension tuple
fn build_alpn_extension(protocols):
    (EXTENSION_TYPE_ALPN, protocols)

# Build Signature Algorithms extension
# Parameters:
#   algorithms: List of signature algorithm codes
# Returns: (type, data) extension tuple
fn build_signature_algorithms_extension(algorithms):
    (EXTENSION_TYPE_SIGNATURE_ALGORITHMS, algorithms)

# Build Supported Groups (Elliptic Curves) extension
# Parameters:
#   groups: List of supported group codes
# Returns: (type, data) extension tuple
fn build_supported_groups_extension(groups):
    (EXTENSION_TYPE_SUPPORTED_GROUPS, groups)

# Parse extensions from bytes
# Parameters:
#   data: Extension data bytes
# Returns: List of (type, data) extension tuples
fn parse_extensions(data):
    var extensions = []
    var offset = 0
    val data_len = len(data)

    # Extensions have 2-byte length prefix
    if data_len < 2:
        extensions
    else:
        val ext_list_len_hi = byte_at(data, 0)
        val ext_list_len_lo = byte_at(data, 1)
        val ext_list_len = (ext_list_len_hi * 256) + ext_list_len_lo
        offset = 2

        # Parse individual extensions
        var continue_parsing = offset < data_len
        var loop_count = 0
        var max_loops = 100

        while continue_parsing and (loop_count < max_loops):
            loop_count = loop_count + 1

            if (offset + 4) > data_len:
                continue_parsing = false
            else:
                val ext_type_hi = byte_at(data, offset)
                val ext_type_lo = byte_at(data, offset + 1)
                val ext_type = (ext_type_hi * 256) + ext_type_lo

                val ext_len_hi = byte_at(data, offset + 2)
                val ext_len_lo = byte_at(data, offset + 3)
                val ext_len = (ext_len_hi * 256) + ext_len_lo

                offset = offset + 4

                if (offset + ext_len) > data_len:
                    continue_parsing = false
                else:
                    val ext_data = slice(data, offset, offset + ext_len)
                    extensions = append(extensions, (ext_type, ext_data))
                    offset = offset + ext_len

                    if offset >= data_len:
                        continue_parsing = false
                    else:
                        pass

        extensions

# Get extension type name
# Parameters:
#   ext_type: Extension type code
# Returns: Human-readable name
fn extension_type_name(ext_type):
    if ext_type == EXTENSION_TYPE_SERVER_NAME:
        "server_name"
    else if ext_type == EXTENSION_TYPE_MAX_FRAGMENT_LENGTH:
        "max_fragment_length"
    else if ext_type == EXTENSION_TYPE_STATUS_REQUEST:
        "status_request"
    else if ext_type == EXTENSION_TYPE_SUPPORTED_GROUPS:
        "supported_groups"
    else if ext_type == EXTENSION_TYPE_EC_POINT_FORMATS:
        "ec_point_formats"
    else if ext_type == EXTENSION_TYPE_SIGNATURE_ALGORITHMS:
        "signature_algorithms"
    else if ext_type == EXTENSION_TYPE_ALPN:
        "alpn"
    else if ext_type == EXTENSION_TYPE_SUPPORTED_VERSIONS:
        "supported_versions"
    else:
        "unknown"

# Find extension by type in extension list
# Parameters:
#   extensions: List of (type, data) tuples
#   ext_type: Extension type to find
# Returns: Extension data or nil if not found
fn find_extension(extensions, ext_type):
    var found = nil
    for ext in extensions:
        val current_type = ext[0]
        if current_type == ext_type:
            found = ext[1]
        else:
            pass
    found

# =============================================================================
# ALERT PROTOCOL - TLS Alerts
# =============================================================================

# Build TLS alert message
# Parameters:
#   level: Alert level (1=warning, 2=fatal)
#   description: Alert description code
# Returns: (level, description) tuple
fn build_alert(level, description):
    (level, description)

# Parse TLS alert from bytes
# Parameters:
#   data: Alert payload bytes
# Returns: (level, description) tuple or nil
fn parse_alert(data):
    if len(data) < 2:
        nil
    else:
        val level = byte_at(data, 0)
        val description = byte_at(data, 1)
        (level, description)

# Get alert level name
# Parameters:
#   level: Alert level code
# Returns: Human-readable level
fn alert_level_name(level):
    if level == ALERT_LEVEL_WARNING:
        "warning"
    else if level == ALERT_LEVEL_FATAL:
        "fatal"
    else:
        "unknown"

# Get alert description name
# Parameters:
#   description: Alert description code
# Returns: Human-readable description
fn alert_description_name(description):
    if description == ALERT_DESC_CLOSE_NOTIFY:
        "close_notify"
    else if description == ALERT_DESC_UNEXPECTED_MESSAGE:
        "unexpected_message"
    else if description == ALERT_DESC_BAD_RECORD_MAC:
        "bad_record_mac"
    else if description == ALERT_DESC_HANDSHAKE_FAILURE:
        "handshake_failure"
    else if description == ALERT_DESC_BAD_CERTIFICATE:
        "bad_certificate"
    else if description == ALERT_DESC_UNSUPPORTED_CERTIFICATE:
        "unsupported_certificate"
    else if description == ALERT_DESC_CERTIFICATE_REVOKED:
        "certificate_revoked"
    else if description == ALERT_DESC_CERTIFICATE_EXPIRED:
        "certificate_expired"
    else if description == ALERT_DESC_CERTIFICATE_UNKNOWN:
        "certificate_unknown"
    else if description == ALERT_DESC_ILLEGAL_PARAMETER:
        "illegal_parameter"
    else if description == ALERT_DESC_UNKNOWN_CA:
        "unknown_ca"
    else if description == ALERT_DESC_DECODE_ERROR:
        "decode_error"
    else if description == ALERT_DESC_PROTOCOL_VERSION:
        "protocol_version"
    else if description == ALERT_DESC_INTERNAL_ERROR:
        "internal_error"
    else:
        "unknown"

# Check if alert is fatal
# Parameters:
#   level: Alert level code
# Returns: true if fatal
fn is_fatal_alert(level):
    level == ALERT_LEVEL_FATAL

# =============================================================================
# KEY DERIVATION - TLS PRF and Master Secret
# =============================================================================

# TLS PRF (Pseudorandom Function) - TLS 1.2 version
# Parameters:
#   secret: Secret value for PRF
#   label: ASCII label string
#   seed: Seed value
#   output_length: Desired output length in bytes
# Returns: PRF output bytes
#
# TLS 1.2 PRF uses HMAC-SHA256:
# PRF(secret, label, seed) = P_SHA256(secret, label + seed)
fn tls_prf(secret, label, seed, output_length):
    val label_bytes = to_bytes(label)
    val combined_seed = concat_bytes(label_bytes, seed)
    tls_prf_sha256(secret, combined_seed, output_length)

# P_SHA256 expansion function
# Parameters:
#   secret: Secret key
#   seed: Seed value
#   output_length: Desired output length
# Returns: Expanded key material
#
# P_SHA256(secret, seed) = HMAC_SHA256(secret, A(1) + seed) +
#                          HMAC_SHA256(secret, A(2) + seed) + ...
# where A(0) = seed
#       A(i) = HMAC_SHA256(secret, A(i-1))
fn tls_prf_sha256(secret, seed, output_length):
    var result = []
    var a_value = seed  # A(0) = seed
    var current_length = 0
    var iteration = 0
    var max_iterations = 20

    var continue_loop = current_length < output_length
    while continue_loop and (iteration < max_iterations):
        iteration = iteration + 1

        # A(i) = HMAC_SHA256(secret, A(i-1))
        a_value = hmac_sha256(secret, a_value)

        # Output = HMAC_SHA256(secret, A(i) + seed)
        val a_plus_seed = concat_bytes(a_value, seed)
        val hmac_output = hmac_sha256(secret, a_plus_seed)

        result = concat_bytes(result, hmac_output)
        current_length = len(result)

        if current_length >= output_length:
            continue_loop = false
        else:
            pass

    # Truncate to desired length
    slice(result, 0, output_length)

# Compute master secret from pre-master secret
# Parameters:
#   pre_master_secret: Pre-master secret (48 bytes for RSA)
#   client_random: Client random (32 bytes)
#   server_random: Server random (32 bytes)
# Returns: Master secret (48 bytes)
#
# master_secret = PRF(pre_master_secret, "master secret",
#                     ClientHello.random + ServerHello.random)[0..47]
fn compute_master_secret(pre_master_secret, client_random, server_random):
    val combined_random = concat_bytes(client_random, server_random)
    tls_prf(pre_master_secret, "master secret", combined_random, 48)

# Derive session keys from master secret
# Parameters:
#   master_secret: Master secret (48 bytes)
#   client_random: Client random (32 bytes)
#   server_random: Server random (32 bytes)
#   mac_key_length: MAC key length in bytes
#   enc_key_length: Encryption key length in bytes
#   iv_length: IV length in bytes
# Returns: (client_mac, server_mac, client_key, server_key, client_iv, server_iv) tuple
#
# key_block = PRF(master_secret, "key expansion",
#                 server_random + client_random)
fn derive_keys(master_secret, client_random, server_random, mac_key_length, enc_key_length, iv_length):
    val combined_random = concat_bytes(server_random, client_random)
    val key_material_length = (2 * mac_key_length) + (2 * enc_key_length) + (2 * iv_length)
    val key_block = tls_prf(master_secret, "key expansion", combined_random, key_material_length)

    # Split key block into individual keys
    var offset = 0
    val client_mac = slice(key_block, offset, offset + mac_key_length)
    offset = offset + mac_key_length

    val server_mac = slice(key_block, offset, offset + mac_key_length)
    offset = offset + mac_key_length

    val client_key = slice(key_block, offset, offset + enc_key_length)
    offset = offset + enc_key_length

    val server_key = slice(key_block, offset, offset + enc_key_length)
    offset = offset + enc_key_length

    val client_iv = slice(key_block, offset, offset + iv_length)
    offset = offset + iv_length

    val server_iv = slice(key_block, offset, offset + iv_length)

    (client_mac, server_mac, client_key, server_key, client_iv, server_iv)

# Compute verify data for Finished message
# Parameters:
#   master_secret: Master secret (48 bytes)
#   label: "client finished" or "server finished"
#   handshake_hash: Hash of all handshake messages
# Returns: Verify data (12 bytes)
#
# verify_data = PRF(master_secret, finished_label, Hash(handshake_messages))[0..11]
fn compute_verify_data(master_secret, label, handshake_hash):
    tls_prf(master_secret, label, handshake_hash, 12)

# =============================================================================
# HMAC - Hash-based Message Authentication Code
# =============================================================================

# HMAC-SHA256 (simplified implementation)
# Parameters:
#   key: HMAC key
#   data: Data to authenticate
# Returns: HMAC output (32 bytes for SHA-256)
#
# HMAC(K, m) = H((K' ⊕ opad) || H((K' ⊕ ipad) || m))
# where K' = K if len(K) = block_size, else H(K) padded to block_size
fn hmac_sha256(key, data):
    val block_size = 64  # SHA-256 block size
    val output_size = 32  # SHA-256 output size

    # Prepare key
    var key_prime = key
    val key_len = len(key)

    if key_len > block_size:
        key_prime = sha256(key)
    else if key_len < block_size:
        key_prime = pad_to_length(key, block_size)
    else:
        pass

    # Create ipad and opad
    val ipad = xor_with_byte(key_prime, 0x36)
    val opad = xor_with_byte(key_prime, 0x5C)

    # Inner hash: H((K' ⊕ ipad) || m)
    val inner_input = concat_bytes(ipad, data)
    val inner_hash = sha256(inner_input)

    # Outer hash: H((K' ⊕ opad) || inner_hash)
    val outer_input = concat_bytes(opad, inner_hash)
    sha256(outer_input)

# HMAC-SHA384 (for cipher suites using SHA-384)
# Parameters:
#   key: HMAC key
#   data: Data to authenticate
# Returns: HMAC output (48 bytes for SHA-384)
fn hmac_sha384(key, data):
    val block_size = 128  # SHA-384 block size
    val output_size = 48  # SHA-384 output size

    var key_prime = key
    val key_len = len(key)

    if key_len > block_size:
        key_prime = sha384(key)
    else if key_len < block_size:
        key_prime = pad_to_length(key, block_size)
    else:
        pass

    val ipad = xor_with_byte(key_prime, 0x36)
    val opad = xor_with_byte(key_prime, 0x5C)

    val inner_input = concat_bytes(ipad, data)
    val inner_hash = sha384(inner_input)

    val outer_input = concat_bytes(opad, inner_hash)
    sha384(outer_input)

# =============================================================================
# UTILITY FUNCTIONS - Helper Functions
# =============================================================================

# Generate pseudo-random bytes using a linear congruential generator
# seeded from the length parameter. Not cryptographically secure but
# produces proper byte-range values with good distribution.
# Parameters:
#   length: Number of random bytes to generate
# Returns: Random bytes as list of integers 0-255
fn generate_random(length):
    var result = []
    var i = 0
    # LCG state: seed with length * large prime + constant
    var state = (length * 6364136223846793005) + 1442695040888963407
    while i < length:
        # LCG step: state = state * a + c (mod 2^64 implicit in i64)
        state = state * 6364136223846793005 + 1442695040888963407
        # Extract byte from upper bits (better distribution)
        var shifted = state >> 33
        # Map to 0-255 range
        if shifted < 0:
            shifted = 0 - shifted
        val random_byte = shifted % 256
        result = append(result, random_byte)
        i = i + 1
    result

# Constant-time comparison to prevent timing attacks
# Parameters:
#   a: First byte array
#   b: Second byte array
# Returns: true if equal, false otherwise
fn constant_time_compare(a, b):
    val len_a = len(a)
    val len_b = len(b)

    if len_a != len_b:
        false
    else:
        var diff = 0
        var i = 0
        while i < len_a:
            val byte_a = byte_at(a, i)
            val byte_b = byte_at(b, i)
            val xor_result = xor(byte_a, byte_b)
            diff = or(diff, xor_result)
            i = i + 1
        diff == 0

# Format bytes as hexadecimal string
# Parameters:
#   data: Byte array
# Returns: Hex string (e.g., "0A1B2C")
fn format_hex(data):
    var result = ""
    val data_len = len(data)
    var i = 0

    while i < data_len:
        val byte_val = byte_at(data, i)
        val hex_str = byte_to_hex(byte_val)
        result = result + hex_str
        i = i + 1

    result

# Convert byte to 2-character hex string
# Parameters:
#   byte_val: Byte value (0-255)
# Returns: 2-character hex string
fn byte_to_hex(byte_val):
    val hex_chars = "0123456789ABCDEF"
    val hi = (byte_val / 16) % 16
    val lo = byte_val % 16
    val hi_char = char_at(hex_chars, hi)
    val lo_char = char_at(hex_chars, lo)
    hi_char + lo_char

# Pad bytes to specified length with zeros
# Parameters:
#   data: Input bytes
#   length: Desired length
# Returns: Padded bytes
fn pad_to_length(data, length):
    var result = data
    val data_len = len(data)
    var i = data_len

    while i < length:
        result = append(result, 0)
        i = i + 1

    result

# XOR each byte with a constant value
# Parameters:
#   data: Input bytes
#   value: XOR value
# Returns: XORed bytes
fn xor_with_byte(data, value):
    var result = []
    val data_len = len(data)
    var i = 0

    while i < data_len:
        val byte_val = byte_at(data, i)
        val xored = xor(byte_val, value)
        result = append(result, xored)
        i = i + 1

    result

# Concatenate two byte arrays
# Parameters:
#   a: First byte array
#   b: Second byte array
# Returns: Concatenated bytes
fn concat_bytes(a, b):
    var result = a
    val b_len = len(b)
    var i = 0

    while i < b_len:
        val byte_val = byte_at(b, i)
        result = append(result, byte_val)
        i = i + 1

    result

# Get byte at index (placeholder - assumes list of integers)
# Parameters:
#   data: Byte array
#   index: Index
# Returns: Byte value
fn byte_at(data, index):
    data[index]

# Slice byte array
# Parameters:
#   data: Byte array
#   start: Start index (inclusive)
#   end: End index (exclusive)
# Returns: Sliced bytes
fn slice(data, start, end):
    var result = []
    var i = start

    while i < end:
        val byte_val = byte_at(data, i)
        result = append(result, byte_val)
        i = i + 1

    result

# Convert string to bytes (UTF-8 / ASCII byte values)
# Parameters:
#   input_text: Input string
# Returns: Byte array (list of integers 0-255)
fn to_bytes(input_text):
    var result = []
    var i = 0
    val text_len = len(input_text)
    while i < text_len:
        val code = byte_at(input_text, i)
        result = append(result, code)
        i = i + 1
    result

# SHA-256 hash - real implementation per FIPS 180-4
# Parameters:
#   data: Input data (list of bytes)
# Returns: SHA-256 hash (32 bytes as list)
fn sha256(data):
    val mask32 = 4294967295  # 0xFFFFFFFF

    # Initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
    var h0 = 1779033703   # 0x6a09e667
    var h1 = 3144134277   # 0xbb67ae85
    var h2 = 1013904242   # 0x3c6ef372
    var h3 = 2773480762   # 0xa54ff53a
    var h4 = 1359893119   # 0x510e527f
    var h5 = 2600822924   # 0x9b05688c
    var h6 = 528734635    # 0x1f83d9ab
    var h7 = 1541459225   # 0x5be0cd19

    # Round constants
    var k_vals = [
        1116352408, 1899447441, 3049323471, 3921009573,
        961987163, 1508970993, 2453635748, 2870763221,
        3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037,
        2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877,
        958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298
    ]

    # Pre-processing: pad message
    val data_len = len(data)
    var padded = []
    var pi = 0
    while pi < data_len:
        padded = append(padded, byte_at(data, pi))
        pi = pi + 1

    # Append bit '1' (0x80 byte)
    padded = append(padded, 128)

    # Append zeros until length mod 64 == 56
    val padded_len_target = data_len + 1
    var pad_zeros = 56 - (padded_len_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        padded = append(padded, 0)
        pz = pz + 1

    # Append original length in bits as 64-bit big-endian
    val bit_length = data_len * 8
    padded = append(padded, 0)
    padded = append(padded, 0)
    padded = append(padded, 0)
    padded = append(padded, 0)
    padded = append(padded, (bit_length >> 24) & 255)
    padded = append(padded, (bit_length >> 16) & 255)
    padded = append(padded, (bit_length >> 8) & 255)
    padded = append(padded, bit_length & 255)

    # Process each 64-byte block
    val total_len = len(padded)
    var block_offset = 0
    while block_offset < total_len:
        # Create message schedule array w[0..63]
        var w = []
        # w[0..15]: 16 words from block (big-endian)
        var wi = 0
        while wi < 16:
            val base = block_offset + (wi * 4)
            val b0 = byte_at(padded, base) & 255
            val b1 = byte_at(padded, base + 1) & 255
            val b2 = byte_at(padded, base + 2) & 255
            val b3 = byte_at(padded, base + 3) & 255
            val word = ((b0 << 24) | (b1 << 16) | (b2 << 8) | b3) & mask32
            w = append(w, word)
            wi = wi + 1

        # w[16..63]: extend
        wi = 16
        while wi < 64:
            val w15 = w[wi - 15] & mask32
            val w2 = w[wi - 2] & mask32
            # s0 = rotr(w[i-15], 7) ^ rotr(w[i-15], 18) ^ (w[i-15] >> 3)
            val r7 = ((w15 >> 7) | (w15 << 25)) & mask32
            val r18 = ((w15 >> 18) | (w15 << 14)) & mask32
            val sh3 = (w15 >> 3) & mask32
            val s0 = (r7 ^ r18 ^ sh3) & mask32
            # s1 = rotr(w[i-2], 17) ^ rotr(w[i-2], 19) ^ (w[i-2] >> 10)
            val r17 = ((w2 >> 17) | (w2 << 15)) & mask32
            val r19 = ((w2 >> 19) | (w2 << 13)) & mask32
            val sh10 = (w2 >> 10) & mask32
            val s1 = (r17 ^ r19 ^ sh10) & mask32
            val new_w = (w[wi - 16] + s0 + w[wi - 7] + s1) & mask32
            w = append(w, new_w)
            wi = wi + 1

        # Initialize working variables
        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var h = h7

        # Compression rounds
        var ri = 0
        while ri < 64:
            val ea = e & mask32
            # S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)
            val er6 = ((ea >> 6) | (ea << 26)) & mask32
            val er11 = ((ea >> 11) | (ea << 21)) & mask32
            val er25 = ((ea >> 25) | (ea << 7)) & mask32
            val big_s1 = (er6 ^ er11 ^ er25) & mask32
            # ch = (e & f) ^ (~e & g)
            val ch = ((ea & (f & mask32)) ^ ((~ea & mask32) & (g & mask32))) & mask32
            val temp1 = (h + big_s1 + ch + k_vals[ri] + w[ri]) & mask32

            val aa = a & mask32
            # S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)
            val ar2 = ((aa >> 2) | (aa << 30)) & mask32
            val ar13 = ((aa >> 13) | (aa << 19)) & mask32
            val ar22 = ((aa >> 22) | (aa << 10)) & mask32
            val big_s0 = (ar2 ^ ar13 ^ ar22) & mask32
            # maj = (a & b) ^ (a & c) ^ (b & c)
            val maj = ((aa & (b & mask32)) ^ (aa & (c & mask32)) ^ ((b & mask32) & (c & mask32))) & mask32
            val temp2 = (big_s0 + maj) & mask32

            h = g
            g = f
            f = e
            e = (d + temp1) & mask32
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & mask32
            ri = ri + 1

        # Add compressed chunk to hash values
        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        h5 = (h5 + f) & mask32
        h6 = (h6 + g) & mask32
        h7 = (h7 + h) & mask32

        block_offset = block_offset + 64

    # Produce the final 32-byte hash
    var hash_result = []
    hash_result = append(hash_result, (h0 >> 24) & 255)
    hash_result = append(hash_result, (h0 >> 16) & 255)
    hash_result = append(hash_result, (h0 >> 8) & 255)
    hash_result = append(hash_result, h0 & 255)
    hash_result = append(hash_result, (h1 >> 24) & 255)
    hash_result = append(hash_result, (h1 >> 16) & 255)
    hash_result = append(hash_result, (h1 >> 8) & 255)
    hash_result = append(hash_result, h1 & 255)
    hash_result = append(hash_result, (h2 >> 24) & 255)
    hash_result = append(hash_result, (h2 >> 16) & 255)
    hash_result = append(hash_result, (h2 >> 8) & 255)
    hash_result = append(hash_result, h2 & 255)
    hash_result = append(hash_result, (h3 >> 24) & 255)
    hash_result = append(hash_result, (h3 >> 16) & 255)
    hash_result = append(hash_result, (h3 >> 8) & 255)
    hash_result = append(hash_result, h3 & 255)
    hash_result = append(hash_result, (h4 >> 24) & 255)
    hash_result = append(hash_result, (h4 >> 16) & 255)
    hash_result = append(hash_result, (h4 >> 8) & 255)
    hash_result = append(hash_result, h4 & 255)
    hash_result = append(hash_result, (h5 >> 24) & 255)
    hash_result = append(hash_result, (h5 >> 16) & 255)
    hash_result = append(hash_result, (h5 >> 8) & 255)
    hash_result = append(hash_result, h5 & 255)
    hash_result = append(hash_result, (h6 >> 24) & 255)
    hash_result = append(hash_result, (h6 >> 16) & 255)
    hash_result = append(hash_result, (h6 >> 8) & 255)
    hash_result = append(hash_result, h6 & 255)
    hash_result = append(hash_result, (h7 >> 24) & 255)
    hash_result = append(hash_result, (h7 >> 16) & 255)
    hash_result = append(hash_result, (h7 >> 8) & 255)
    hash_result = append(hash_result, h7 & 255)
    hash_result

# SHA-384 hash - real implementation per FIPS 180-4
# SHA-384 is SHA-512 with different initial values, truncated to 48 bytes.
# Uses 64-bit arithmetic (i64 is native 64-bit on this platform).
# Parameters:
#   data: Input data (list of bytes)
# Returns: SHA-384 hash (48 bytes as list)
fn sha384(data):
    # SHA-384 initial hash values (from fractional parts of square roots of 9th-16th primes)
    var h0 = -3766243637369397544   # 0xcbbb9d5dc1059ed8
    var h1 = 7105036623409557960    # 0x629a292a367cd507
    var h2 = -7973340178411365097   # 0x9159015a3070dd17
    var h3 = 1526699215303891257    # 0x152fecd8f70e5939
    var h4 = 7436329637833083697    # 0x67332667ffc00b31
    var h5 = -8163818279084223215   # 0x8eb44a8768581511
    var h6 = -2662702644619276377   # 0xdb0c2e0d64f98fa7
    var h7 = 5765546140918722680    # 0x47b5481dbefa4fa4

    # SHA-512 round constants (first 80 are needed)
    var k_vals = [
        4794697086780616226, 8158064640168781261, -5349999486874862801, -1606136188198331460,
        4131703408338449720, 6480981068601479193, -7908458776815382629, -6116909921290321640,
        -2880145864133508542, 1334009975649890238, 2608012711638119052, 6128411473006802146,
        8268148722764581231, -9160688886553864527, -7215885187991268811, -4495734319001033068,
        -1973867731355612462, -1171420211273849373, 1135362057144423861, 2597781545756921966,
        3308224258029322869, 5365058923640841347, 6679025012923562964, 8573033837759648693,
        -7476448914759557205, -6327057829258317296, -5763719355590565569, -4658551843659510044,
        -4116276920077217854, -3051310485924567259, 489312712824947311, 1452737877330783856,
        2861767655752347644, 3322285676063803686, 5560940570517711597, 5996557281743188959,
        7280758554555802590, 8532644243296465576, -9096487096722542874, -7894198246740708037,
        -6719396339535248540, -6333637450476146687, -4446306890439682159, -4076793802049405392,
        -3345356375505022440, -2983346525034927856, -860691631967231958, 1182934255886127544,
        1847814050463011016, 2177327727835720942, 2830643537854262166, 3796741975233480872,
        4115178125766777443, 5681478168544905931, 6601373596472566643, 7507060721942968483,
        8399075790359081724, 8693463985226723168, -8878714635349349518, -8302665154208450068,
        -8016688836872298968, -6606660893046293015, -4685533653050689259, -4147400797238176981,
        -3880063495543823972, -3348786107499101689, -1523767162380948706, -757361751448694408,
        500013540394364858, 748580250866718886, 1242879168328830382, 1977374033974150939,
        2944078676154940804, 3659926193048069267, 4368137639120453308, 4836135668995329356,
        5532061633213252278, 6448918945643986474, 6902733635092675308, 7801388544844847127
    ]

    # Pre-processing: pad message to multiple of 128 bytes
    val data_len = len(data)
    var padded = []
    var pi = 0
    while pi < data_len:
        padded = append(padded, byte_at(data, pi))
        pi = pi + 1

    # Append bit '1' (0x80 byte)
    padded = append(padded, 128)

    # Append zeros until length mod 128 == 112
    val padded_len_target = data_len + 1
    var pad_zeros = 112 - (padded_len_target % 128)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 128
    var pz = 0
    while pz < pad_zeros:
        padded = append(padded, 0)
        pz = pz + 1

    # Append 128-bit length (we only use lower 64 bits)
    val bit_length = data_len * 8
    # Upper 64 bits = 0
    var lb = 0
    while lb < 8:
        padded = append(padded, 0)
        lb = lb + 1
    # Lower 64 bits big-endian
    padded = append(padded, (bit_length >> 56) & 255)
    padded = append(padded, (bit_length >> 48) & 255)
    padded = append(padded, (bit_length >> 40) & 255)
    padded = append(padded, (bit_length >> 32) & 255)
    padded = append(padded, (bit_length >> 24) & 255)
    padded = append(padded, (bit_length >> 16) & 255)
    padded = append(padded, (bit_length >> 8) & 255)
    padded = append(padded, bit_length & 255)

    # Process each 128-byte block
    val total_len = len(padded)
    var block_offset = 0
    while block_offset < total_len:
        # Create message schedule w[0..79] with 64-bit words
        var w = []
        var wi = 0
        while wi < 16:
            val base = block_offset + (wi * 8)
            var word = 0
            var bi = 0
            while bi < 8:
                word = (word << 8) | (byte_at(padded, base + bi) & 255)
                bi = bi + 1
            w = append(w, word)
            wi = wi + 1

        # Extend to 80 words
        wi = 16
        while wi < 80:
            val w15 = w[wi - 15]
            val w2 = w[wi - 2]
            # sigma0 = rotr(w15,1) ^ rotr(w15,8) ^ (w15 >>> 7)
            val s0_r1 = (w15 >> 1) | (w15 << 63)
            val s0_r8 = (w15 >> 8) | (w15 << 56)
            val s0_s7 = (w15 >> 7) & 0x01FFFFFFFFFFFFFF
            val s0 = s0_r1 ^ s0_r8 ^ s0_s7
            # sigma1 = rotr(w2,19) ^ rotr(w2,61) ^ (w2 >>> 6)
            val s1_r19 = (w2 >> 19) | (w2 << 45)
            val s1_r61 = (w2 >> 61) | (w2 << 3)
            val s1_s6 = (w2 >> 6) & 0x03FFFFFFFFFFFFFF
            val s1 = s1_r19 ^ s1_r61 ^ s1_s6
            val new_w = w[wi - 16] + s0 + w[wi - 7] + s1
            w = append(w, new_w)
            wi = wi + 1

        # Working variables
        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var h = h7

        # 80 rounds
        var ri = 0
        while ri < 80:
            # Sigma1 = rotr(e,14) ^ rotr(e,18) ^ rotr(e,41)
            val e_r14 = (e >> 14) | (e << 50)
            val e_r18 = (e >> 18) | (e << 46)
            val e_r41 = (e >> 41) | (e << 23)
            val big_s1 = e_r14 ^ e_r18 ^ e_r41
            # Ch = (e & f) ^ (~e & g)
            val ch = (e & f) ^ (~e & g)
            val temp1 = h + big_s1 + ch + k_vals[ri] + w[ri]

            # Sigma0 = rotr(a,28) ^ rotr(a,34) ^ rotr(a,39)
            val a_r28 = (a >> 28) | (a << 36)
            val a_r34 = (a >> 34) | (a << 30)
            val a_r39 = (a >> 39) | (a << 25)
            val big_s0 = a_r28 ^ a_r34 ^ a_r39
            # Maj = (a & b) ^ (a & c) ^ (b & c)
            val maj = (a & b) ^ (a & c) ^ (b & c)
            val temp2 = big_s0 + maj

            h = g
            g = f
            f = e
            e = d + temp1
            d = c
            c = b
            b = a
            a = temp1 + temp2
            ri = ri + 1

        h0 = h0 + a
        h1 = h1 + b
        h2 = h2 + c
        h3 = h3 + d
        h4 = h4 + e
        h5 = h5 + f
        h6 = h6 + g
        h7 = h7 + h

        block_offset = block_offset + 128

    # Output first 6 words (48 bytes) for SHA-384
    var hash_result = []
    var hi_idx = 0
    var h_vals = [h0, h1, h2, h3, h4, h5]
    while hi_idx < 6:
        val hv = h_vals[hi_idx]
        hash_result = append(hash_result, (hv >> 56) & 255)
        hash_result = append(hash_result, (hv >> 48) & 255)
        hash_result = append(hash_result, (hv >> 40) & 255)
        hash_result = append(hash_result, (hv >> 32) & 255)
        hash_result = append(hash_result, (hv >> 24) & 255)
        hash_result = append(hash_result, (hv >> 16) & 255)
        hash_result = append(hash_result, (hv >> 8) & 255)
        hash_result = append(hash_result, hv & 255)
        hi_idx = hi_idx + 1
    hash_result

# XOR two byte values using bitwise XOR operator
# Parameters:
#   a: First byte (integer 0-255)
#   b: Second byte (integer 0-255)
# Returns: XOR result (integer 0-255)
fn xor(a, b):
    a ^ b

# Bitwise OR of two values
# Parameters:
#   a: First value
#   b: Second value
# Returns: OR result
fn or(a, b):
    a | b

# Get character at index in string
# Parameters:
#   input_text: Input string
#   index: Index position
# Returns: Single character as text, or "" if out of bounds
fn char_at(input_text, index):
    val text_len = len(input_text)
    if index < 0:
        return ""
    if index >= text_len:
        return ""
    val hex_chars_local = "0123456789ABCDEF"
    val code = byte_at(input_text, index)
    # Build character from byte code
    var i = 0
    while i < text_len:
        val c = byte_at(input_text, i)
        if i == index:
            # Return the character at this index via substring
            val result = slice(input_text, index, index + 1)
            return result
        i = i + 1
    ""

# String starts with prefix
# Parameters:
#   input_text: Input string
#   prefix: Prefix to check
# Returns: true if starts with prefix
fn starts_with(input_text, prefix):
    val text_len = len(input_text)
    val prefix_len = len(prefix)
    if prefix_len > text_len:
        return false
    var i = 0
    while i < prefix_len:
        val a = byte_at(input_text, i)
        val b = byte_at(prefix, i)
        if a != b:
            return false
        i = i + 1
    true

# String contains substring
# Parameters:
#   input_text: Input string
#   sub: Substring to find
# Returns: true if contains substring
fn contains(input_text, sub):
    val text_len = len(input_text)
    val sub_len = len(sub)
    if sub_len == 0:
        return true
    if sub_len > text_len:
        return false
    val search_limit = text_len - sub_len + 1
    var i = 0
    while i < search_limit:
        var found = true
        var j = 0
        while j < sub_len:
            val a = byte_at(input_text, i + j)
            val b = byte_at(sub, j)
            if a != b:
                found = false
                j = sub_len  # break inner loop
            j = j + 1
        if found:
            return true
        i = i + 1
    false

# Get length of collection
# Parameters:
#   collection: List or bytes
# Returns: Length
fn len(collection):
    # Placeholder - should return length
    0

# Append to list
# Parameters:
#   list: Input list
#   item: Item to append
# Returns: New list with item appended
fn append(list, item):
    # Placeholder - should append item
    list
