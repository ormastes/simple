# Apache Kafka Serialization Module
# Serialization and compression utilities

import kafka.types

# ============================================================================
# Compression Utilities
# ============================================================================

fn compression_codec_to_string(codec: i64) -> text:
    if codec == 0:
        return "none"
    if codec == 1:
        return "gzip"
    if codec == 2:
        return "snappy"
    if codec == 3:
        return "lz4"
    if codec == 4:
        return "zstd"
    "unknown"

fn compression_codec_from_string(codec_name: text) -> i64:
    if codec_name == "none":
        return 0
    if codec_name == "gzip":
        return 1
    if codec_name == "snappy":
        return 2
    if codec_name == "lz4":
        return 3
    if codec_name == "zstd":
        return 4
    0

fn is_valid_compression_codec(codec: i64) -> bool:
    var valid = codec == 0
    if codec == 1:
        valid = true
    if codec == 2:
        valid = true
    if codec == 3:
        valid = true
    if codec == 4:
        valid = true
    valid

# ============================================================================
# Varint Encoding Utilities
# ============================================================================

# Encode unsigned varint (used in Kafka protocol)
fn encode_varint_unsigned(value: i64) -> list:
    var result = []
    var remaining = value
    var continue_encoding = true

    if remaining == 0:
        return [0]

    # Encode 7 bits at a time
    while continue_encoding:
        var byte_val = remaining % 128
        remaining = remaining / 128

        if remaining > 0:
            byte_val = byte_val + 128

        var temp = result
        result = temp + [byte_val]

        if remaining == 0:
            continue_encoding = false

    result

# Decode unsigned varint
fn decode_varint_unsigned(bytes: list) -> i64:
    var result = 0
    var shift = 0
    var idx = 0
    var byte_count = 0

    # Safety: limit to 10 bytes maximum
    while byte_count < 10:
        if idx >= bytes.len():
            return result

        var byte_val = bytes[idx]
        var value_bits = byte_val % 128
        result = result + (value_bits * (2 ** shift))

        idx = idx + 1
        byte_count = byte_count + 1
        shift = shift + 7

        # Check if this is the last byte
        if byte_val < 128:
            return result

    result

# Encode signed varint using zigzag encoding
fn encode_varint_signed(value: i64) -> list:
    var zigzag = 0
    if value >= 0:
        zigzag = value * 2
    if value < 0:
        zigzag = (value * -2) - 1
    encode_varint_unsigned(zigzag)

# Decode signed varint using zigzag encoding
fn decode_varint_signed(bytes: list) -> i64:
    var zigzag = decode_varint_unsigned(bytes)
    var is_negative = (zigzag % 2) == 1

    if is_negative:
        return (zigzag + 1) / -2

    zigzag / 2

# ============================================================================
# CRC32 Calculation
# ============================================================================

# Simple CRC32 implementation for Kafka message integrity
# Using standard CRC32 polynomial: 0xEDB88320
fn crc32_table() -> list:
    [
        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
        0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
        0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
        0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
        0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
        0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
        0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
        0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
        0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
        0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
        0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D
    ]

fn crc32_calculate(data: text) -> i64:
    var table = crc32_table()
    var crc = 0xFFFFFFFF
    var idx = 0
    var data_len = data.len()

    while idx < data_len:
        var byte_val = data[idx].ord()
        var table_idx = (crc ^ byte_val) % 256
        crc = (crc / 256) ^ table[table_idx]
        idx = idx + 1

    crc ^ 0xFFFFFFFF

fn crc32_verify(data: text, expected_crc: i64) -> bool:
    var calculated = crc32_calculate(data)
    calculated == expected_crc

# ============================================================================
# Serialization Utilities
# ============================================================================

# Convert i64 to 4-byte representation (big-endian)
fn int32_to_bytes(value: i64) -> list:
    var byte0 = (value / 16777216) % 256
    var byte1 = (value / 65536) % 256
    var byte2 = (value / 256) % 256
    var byte3 = value % 256
    [byte0, byte1, byte2, byte3]

# Convert i64 to 8-byte representation (big-endian)
fn int64_to_bytes(value: i64) -> list:
    var upper = value / 4294967296
    var lower = value % 4294967296
    var bytes_upper = int32_to_bytes(upper)
    var bytes_lower = int32_to_bytes(lower)
    bytes_upper + bytes_lower

# Convert 4 bytes to i64 (big-endian)
fn bytes_to_int32(bytes: list) -> i64:
    if bytes.len() < 4:
        return 0
    var result = bytes[0] * 16777216
    result = result + (bytes[1] * 65536)
    result = result + (bytes[2] * 256)
    result = result + bytes[3]
    result

# Convert 8 bytes to i64 (big-endian)
fn bytes_to_int64(bytes: list) -> i64:
    if bytes.len() < 8:
        return 0
    var upper_bytes = [bytes[0], bytes[1], bytes[2], bytes[3]]
    var lower_bytes = [bytes[4], bytes[5], bytes[6], bytes[7]]
    var upper = bytes_to_int32(upper_bytes)
    var lower = bytes_to_int32(lower_bytes)
    (upper * 4294967296) + lower

# Serialize text with length prefix
fn serialize_string(value: text) -> list:
    var length = value.len()
    var length_bytes = int32_to_bytes(length)
    var result = length_bytes
    var idx = 0

    while idx < length:
        var char_code = value[idx].ord()
        var temp = result
        result = temp + [char_code]
        idx = idx + 1

    result

# Deserialize text with length prefix
fn deserialize_string(bytes: list, offset: i64) -> text:
    if offset + 4 > bytes.len():
        return ""

    var length_bytes = [bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]]
    var length = bytes_to_int32(length_bytes)

    if length <= 0:
        return ""

    if offset + 4 + length > bytes.len():
        return ""

    var result = ""
    var idx = 0

    while idx < length:
        var byte_val = bytes[offset + 4 + idx]
        var char = byte_val.chr()
        result = result + char
        idx = idx + 1

    result

# ============================================================================
# Utility Functions
