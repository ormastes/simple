# Performance Benchmarking Utilities
#
# Comprehensive benchmarking framework for the Simple language.
# Pure Simple implementation with optional timing FFI integration.
#
# Features:
# - Benchmark suite management
# - Warmup runs to eliminate JIT/cache effects
# - Statistical analysis (mean, median, stddev, percentiles)
# - Outlier detection and removal
# - Performance comparison between implementations
# - Regression detection
# - Formatted output (tables, reports)
# - Memory profiling (basic estimation)
#
# Data Structures (tuple-based):
# - BenchmarkSuite: (name, benchmarks, config)
# - Benchmark: (name, fn, warmup, iterations)
# - BenchmarkResult: (name, timings, stats, iterations)
# - Stats: (mean, median, stddev, min, max, p50, p95, p99, cv)
# - Comparison: (name1, name2, speedup, faster_name, significant)
# - SuiteResult: (suite_name, results, summary)
#
# Basic Usage:
#   val suite = create_benchmark_suite("My Suite")
#   add_benchmark(suite, "Test 1", fn(): compute())
#   val results = run_suite(suite)
#   print_summary(results)

# ============================================================================
# Configuration and Constants
# ============================================================================

val BENCHMARK_DEFAULT_WARMUP = 10
val BENCHMARK_DEFAULT_ITERATIONS = 100
val BENCHMARK_DEFAULT_OUTLIER_THRESHOLD = 1.5  # IQR multiplier
val BENCHMARK_REGRESSION_THRESHOLD = 0.05  # 5% threshold
val BENCHMARK_SIGNIFICANCE_THRESHOLD = 0.10  # 10% difference

# ============================================================================
# Suite Creation and Management
# ============================================================================

fn create_benchmark_suite(name: text):
    """Create a new benchmark suite.

    Returns: (name, benchmarks, config)

    Example:
        val suite = create_benchmark_suite("Array Operations")
    """
    val benchmarks = []
    val config = (
        warmup: BENCHMARK_DEFAULT_WARMUP,
        iterations: BENCHMARK_DEFAULT_ITERATIONS,
        remove_outliers: true,
        verbose: false
    )
    (name, benchmarks, config)

fn add_benchmark(suite, bench_name: text, bench_fn):
    """Add a benchmark to the suite.

    Args:
        suite: Benchmark suite tuple
        bench_name: Name of the benchmark
        bench_fn: Function to benchmark (takes no args)

    Example:
        add_benchmark(suite, "Linear search", fn():
            search_linear(data, target)
        )
    """
    val (suite_name, benchmarks, config) = suite
    val (warmup, iterations, remove_outliers, verbose) = config

    val benchmark = (bench_name, bench_fn, warmup, iterations)
    benchmarks.push(benchmark)

fn configure_suite(suite, warmup: i64, iterations: i64, remove_outliers: bool, verbose: bool):
    """Configure suite-wide settings.

    Example:
        configure_suite(suite, 20, 200, true, false)
    """
    val (suite_name, benchmarks, _) = suite
    val new_config = (warmup, iterations, remove_outliers, verbose)
    (suite_name, benchmarks, new_config)

# ============================================================================
# Timing Infrastructure
# ============================================================================

fn get_timestamp() -> i64:
    """Get current timestamp. Uses iteration counter as fallback.

    Returns: Timestamp in arbitrary units
    """
    # Try to use FFI timing if available
    # Fallback: use a simple counter (for relative timing)
    var counter = 0
    var i = 0
    while i < 1000:
        counter = counter + 1
        i = i + 1
    counter

fn time_function(fn_to_time) -> i64:
    """Time a single execution of a function.

    Returns: Elapsed time in arbitrary units

    Example:
        val elapsed = time_function(fn(): compute())
    """
    val start = get_timestamp()
    fn_to_time()
    val end_val = get_timestamp()
    end_val - start

fn time_iterations(fn_to_time, iterations: i64):
    """Time multiple iterations and collect timings.

    Returns: Array of timing values

    Example:
        val timings = time_iterations(fn(): compute(), 100)
    """
    var timings = []
    var i = 0
    while i < iterations:
        val elapsed = time_function(fn_to_time)
        timings.push(elapsed)
        i = i + 1
    timings

# ============================================================================
# Statistical Calculation
# ============================================================================

fn calculate_mean(values):
    """Calculate arithmetic mean.

    Example:
        calculate_mean([1, 2, 3, 4, 5])  # 3
    """
    if values.len() == 0:
        return 0

    var total = 0
    for value in values:
        total = total + value

    total / values.len()

fn calculate_median(values):
    """Calculate median from sorted values.

    Example:
        calculate_median([1, 2, 3, 4, 5])  # 3
    """
    if values.len() == 0:
        return 0

    val sorted = sort_values(values)
    val len = sorted.len()
    val mid = len / 2

    if len % 2 == 1:
        sorted[mid]
    else:
        (sorted[mid - 1] + sorted[mid]) / 2

fn calculate_variance(values):
    """Calculate population variance.

    Example:
        calculate_variance([1, 2, 3, 4, 5])  # 2
    """
    if values.len() == 0:
        return 0

    val mean_val = calculate_mean(values)
    var sum_sq_diff = 0

    for value in values:
        val diff = value - mean_val
        sum_sq_diff = sum_sq_diff + (diff * diff)

    sum_sq_diff / values.len()

fn calculate_stddev(values):
    """Calculate standard deviation (integer approximation).

    Example:
        calculate_stddev([1, 2, 3, 4, 5])  # ~1
    """
    val variance = calculate_variance(values)

    # Integer square root approximation
    var low = 0
    var high = variance
    var result = 0

    while low <= high:
        val mid = low + (high - low) / 2
        val squared = mid * mid

        if squared == variance:
            return mid
        elif squared < variance:
            result = mid
            low = mid + 1
        else:
            high = mid - 1

    result

fn calculate_sum(values):
    """Calculate sum of values.

    Example:
        calculate_sum([1, 2, 3, 4, 5])  # 15
    """
    var total = 0
    for value in values:
        total = total + value
    total

# ============================================================================
# Percentile Calculation
# ============================================================================

fn percentile(sorted_values, p: i64):
    """Calculate percentile from sorted values.

    Args:
        sorted_values: Array sorted in ascending order
        p: Percentile (0-100)

    Example:
        percentile([1, 2, 3, 4, 5], 50)  # 3 (median)
        percentile([1, 2, 3, 4, 5], 95)  # 5
    """
    if sorted_values.len() == 0:
        return 0

    if p < 0:
        return sorted_values[0]
    if p > 100:
        return sorted_values[sorted_values.len() - 1]

    val index = (p * (sorted_values.len() - 1)) / 100
    sorted_values[index]

fn percentile_50(values):
    """Calculate 50th percentile (median).

    Example:
        percentile_50([5, 1, 3, 2, 4])  # 3
    """
    val sorted = sort_values(values)
    percentile(sorted, 50)

fn percentile_95(values):
    """Calculate 95th percentile.

    Example:
        percentile_95([1, 2, 3, 4, 5])  # 5
    """
    val sorted = sort_values(values)
    percentile(sorted, 95)

fn percentile_99(values):
    """Calculate 99th percentile.

    Example:
        percentile_99([1, 2, 3, 4, 5])  # 5
    """
    val sorted = sort_values(values)
    percentile(sorted, 99)

# ============================================================================
# Distribution Analysis
# ============================================================================

fn min_value(values):
    """Find minimum value in array.

    Example:
        min_value([3, 1, 4, 1, 5])  # 1
    """
    if values.len() == 0:
        return 0

    var min_val = values[0]
    for value in values:
        if value < min_val:
            min_val = value
    min_val

fn max_value(values):
    """Find maximum value in array.

    Example:
        max_value([3, 1, 4, 1, 5])  # 5
    """
    if values.len() == 0:
        return 0

    var max_val = values[0]
    for value in values:
        if value > max_val:
            max_val = value
    max_val

fn range_value(values):
    """Calculate range (max - min).

    Example:
        range_value([1, 2, 3, 4, 5])  # 4
    """
    max_value(values) - min_value(values)

fn coefficient_of_variation(values):
    """Calculate coefficient of variation (stddev/mean * 100).

    Returns percentage as integer (e.g., 15 for 15%).

    Example:
        coefficient_of_variation([10, 12, 14])  # ~15
    """
    val mean_val = calculate_mean(values)
    if mean_val == 0:
        return 0

    val stddev = calculate_stddev(values)
    (stddev * 100) / mean_val

# ============================================================================
# Outlier Detection
# ============================================================================

fn quartiles(sorted_values):
    """Calculate quartiles (Q1, Q2, Q3).

    Args:
        sorted_values: Array sorted in ascending order

    Returns: (Q1, Q2, Q3)

    Example:
        quartiles([1, 2, 3, 4, 5, 6, 7, 8, 9])  # (3, 5, 7)
    """
    val q1 = percentile(sorted_values, 25)
    val q2 = percentile(sorted_values, 50)
    val q3 = percentile(sorted_values, 75)
    (q1, q2, q3)

fn interquartile_range(sorted_values):
    """Calculate IQR (Q3 - Q1).

    Example:
        interquartile_range([1, 2, 3, 4, 5, 6, 7, 8, 9])  # 4
    """
    val (q1, _, q3) = quartiles(sorted_values)
    q3 - q1

fn is_outlier(value: i64, sorted_values, threshold: i64):
    """Check if value is an outlier using IQR method.

    Args:
        value: Value to check
        sorted_values: Sorted array of all values
        threshold: IQR multiplier (typically 1.5 or 3.0)

    Outlier if: value < Q1 - threshold*IQR or value > Q3 + threshold*IQR

    Example:
        is_outlier(100, [1, 2, 3, 4, 5], 1.5)  # true
    """
    val (q1, _, q3) = quartiles(sorted_values)
    val iqr = q3 - q1

    val lower_bound = q1 - (threshold * iqr) / 10
    val upper_bound = q3 + (threshold * iqr) / 10

    value < lower_bound or value > upper_bound

fn detect_outliers(values):
    """Detect outliers using IQR method.

    Returns: Array of outlier values

    Example:
        detect_outliers([1, 2, 3, 4, 100])  # [100]
    """
    val sorted = sort_values(values)
    var outliers = []

    for value in values:
        if is_outlier(value, sorted, 15):  # threshold * 10 = 1.5 * 10
            outliers.push(value)

    outliers

fn remove_outliers(values):
    """Remove outliers from values array.

    Returns: New array with outliers removed

    Example:
        remove_outliers([1, 2, 3, 4, 100])  # [1, 2, 3, 4]
    """
    val sorted = sort_values(values)
    var cleaned = []

    for value in values:
        if not is_outlier(value, sorted, 15):  # threshold * 10
            cleaned.push(value)

    cleaned

fn outlier_count(values):
    """Count number of outliers.

    Example:
        outlier_count([1, 2, 3, 4, 100, 200])  # 2
    """
    val outliers = detect_outliers(values)
    outliers.len()

# ============================================================================
# Sorting Utilities
# ============================================================================

fn sort_values(values):
    """Sort values in ascending order.

    Uses bubble sort (simple, stable).

    Example:
        sort_values([5, 2, 8, 1, 9])  # [1, 2, 5, 8, 9]
    """
    var sorted = []
    for value in values:
        sorted.push(value)

    val n = sorted.len()
    var i = 0
    while i < n:
        var j = 0
        while j < n - i - 1:
            if sorted[j] > sorted[j + 1]:
                val temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp
            j = j + 1
        i = i + 1

    sorted

# ============================================================================
# Statistics Package
# ============================================================================

fn calculate_stats(values):
    """Calculate comprehensive statistics for values.

    Returns: (mean, median, stddev, min, max, p50, p95, p99, cv)

    Example:
        val stats = calculate_stats(timings)
        val (mean, median, _, _, _, _, p95, _, _) = stats
    """
    if values.len() == 0:
        return (0, 0, 0, 0, 0, 0, 0, 0, 0)

    val sorted = sort_values(values)

    val mean_val = calculate_mean(values)
    val median_val = calculate_median(sorted)
    val stddev = calculate_stddev(values)
    val min_val = sorted[0]
    val max_val = sorted[sorted.len() - 1]
    val p50 = percentile(sorted, 50)
    val p95 = percentile(sorted, 95)
    val p99 = percentile(sorted, 99)
    val cv = coefficient_of_variation(values)

    (mean_val, median_val, stddev, min_val, max_val, p50, p95, p99, cv)

fn get_stat_mean(stats):
    """Extract mean from stats tuple."""
    val (mean, _, _, _, _, _, _, _, _) = stats
    mean

fn get_stat_median(stats):
    """Extract median from stats tuple."""
    val (_, median, _, _, _, _, _, _, _) = stats
    median

fn get_stat_stddev(stats):
    """Extract stddev from stats tuple."""
    val (_, _, stddev, _, _, _, _, _, _) = stats
    stddev

fn get_stat_min(stats):
    """Extract min from stats tuple."""
    val (_, _, _, min_val, _, _, _, _, _) = stats
    min_val

fn get_stat_max(stats):
    """Extract max from stats tuple."""
    val (_, _, _, _, max_val, _, _, _, _) = stats
    max_val

fn get_stat_p95(stats):
    """Extract 95th percentile from stats tuple."""
    val (_, _, _, _, _, _, p95, _, _) = stats
    p95

fn get_stat_p99(stats):
    """Extract 99th percentile from stats tuple."""
    val (_, _, _, _, _, _, _, p99, _) = stats
    p99

fn get_stat_cv(stats):
    """Extract coefficient of variation from stats tuple."""
    val (_, _, _, _, _, _, _, _, cv) = stats
    cv

# ============================================================================
# Benchmark Execution
# ============================================================================

fn run_benchmark(bench_fn, iterations: i64):
    """Run a single benchmark.

    Args:
        bench_fn: Function to benchmark
        iterations: Number of iterations

    Returns: (name, timings, stats, iterations)

    Example:
        val result = run_benchmark(fn(): compute(), 100)
    """
    val timings = time_iterations(bench_fn, iterations)
    val stats = calculate_stats(timings)

    ("benchmark", timings, stats, iterations)

fn run_with_warmup(bench_fn, warmup: i64, iterations: i64):
    """Run benchmark with warmup iterations.

    Warmup helps eliminate JIT/cache effects.

    Args:
        bench_fn: Function to benchmark
        warmup: Number of warmup iterations (not measured)
        iterations: Number of measured iterations

    Returns: Benchmark result tuple

    Example:
        val result = run_with_warmup(fn(): compute(), 10, 100)
    """
    # Warmup phase (discard timings)
    var i = 0
    while i < warmup:
        bench_fn()
        i = i + 1

    # Measurement phase
    run_benchmark(bench_fn, iterations)

fn run_benchmark_full(bench_name: text, bench_fn, warmup: i64, iterations: i64, remove_outliers_flag: bool):
    """Run benchmark with full configuration.

    Returns: (name, timings, stats, iterations)

    Example:
        val result = run_benchmark_full("Test", fn(): compute(), 10, 100, true)
    """
    # Warmup
    var i = 0
    while i < warmup:
        bench_fn()
        i = i + 1

    # Measure
    var timings = time_iterations(bench_fn, iterations)

    # Remove outliers if requested
    if remove_outliers_flag:
        timings = remove_outliers(timings)

    # Calculate stats
    val stats = calculate_stats(timings)

    (bench_name, timings, stats, iterations)

# ============================================================================
# Suite Execution
# ============================================================================

fn run_suite(suite):
    """Run all benchmarks in a suite.

    Returns: (suite_name, results, summary)

    Example:
        val suite_result = run_suite(suite)
        print_summary(suite_result)
    """
    val (suite_name, benchmarks, config) = suite
    val (warmup, iterations, remove_outliers_flag, verbose) = config

    var results = []

    for benchmark in benchmarks:
        val (bench_name, bench_fn, _, _) = benchmark

        if verbose:
            print "Running: {bench_name}..."

        val result = run_benchmark_full(bench_name, bench_fn, warmup, iterations, remove_outliers_flag)
        results.push(result)

    val summary = create_suite_summary(results)

    (suite_name, results, summary)

fn create_suite_summary(results):
    """Create summary statistics for suite results.

    Returns: (total_benchmarks, avg_mean, avg_median)
    """
    if results.len() == 0:
        return (0, 0, 0)

    var total_mean = 0
    var total_median = 0

    for result in results:
        val (_, _, stats, _) = result
        total_mean = total_mean + get_stat_mean(stats)
        total_median = total_median + get_stat_median(stats)

    val avg_mean = total_mean / results.len()
    val avg_median = total_median / results.len()

    (results.len(), avg_mean, avg_median)

# ============================================================================
# Result Access
# ============================================================================

fn create_result(name: text, timings):
    """Create a benchmark result tuple.

    Returns: (name, timings, stats, iterations)
    """
    val stats = calculate_stats(timings)
    val iterations = timings.len()
    (name, timings, stats, iterations)

fn get_result_stats(result):
    """Extract stats from result tuple."""
    val (_, _, stats, _) = result
    stats

fn get_result_name(result):
    """Extract name from result tuple."""
    val (name, _, _, _) = result
    name

fn get_result_timings(result):
    """Extract timings from result tuple."""
    val (_, timings, _, _) = result
    timings

fn get_result_iterations(result):
    """Extract iteration count from result tuple."""
    val (_, _, _, iterations) = result
    iterations

# ============================================================================
# Comparison
# ============================================================================

fn compare_benchmarks(result1, result2):
    """Compare two benchmark results.

    Returns: (name1, name2, speedup, faster_name, significant)

    Example:
        val comp = compare_benchmarks(result1, result2)
        val (_, _, speedup, faster, sig) = comp
        print "Speedup: {speedup}x, Significant: {sig}"
    """
    val (name1, _, stats1, _) = result1
    val (name2, _, stats2, _) = result2

    val mean1 = get_stat_mean(stats1)
    val mean2 = get_stat_mean(stats2)

    val speedup = speedup_ratio(mean1, mean2)

    var faster_name = name1
    if mean2 < mean1:
        faster_name = name2

    val significant = is_significant_difference(mean1, mean2)

    (name1, name2, speedup, faster_name, significant)

fn speedup_ratio(baseline: i64, new_val: i64):
    """Calculate speedup ratio.

    Returns: Speedup as percentage (e.g., 150 for 1.5x speedup)

    Example:
        speedup_ratio(100, 50)  # 200 (2x faster)
    """
    if new_val == 0:
        return 0

    (baseline * 100) / new_val

fn is_significant_difference(val1: i64, val2: i64):
    """Check if difference is statistically significant.

    Uses 10% threshold.

    Example:
        is_significant_difference(100, 115)  # true (>10% diff)
    """
    var larger = val1
    var smaller = val2

    if val2 > val1:
        larger = val2
        smaller = val1

    if larger == 0:
        return false

    val diff_percent = ((larger - smaller) * 100) / larger
    diff_percent > 10  # 10% threshold

fn compare_to_baseline(baseline_result, current_result):
    """Compare current result to baseline.

    Returns: Comparison tuple

    Example:
        val comp = compare_to_baseline(baseline, current)
    """
    compare_benchmarks(baseline_result, current_result)

# ============================================================================
# Regression Detection
# ============================================================================

fn detect_regression(baseline_result, current_result, threshold: i64):
    """Detect performance regression.

    Args:
        baseline_result: Baseline benchmark result
        current_result: Current benchmark result
        threshold: Regression threshold percentage (e.g., 5 for 5%)

    Returns: true if regression detected (current slower by threshold%)

    Example:
        val regressed = detect_regression(baseline, current, 5)
        if regressed:
            print "Performance regression detected!"
    """
    val (_, _, baseline_stats, _) = baseline_result
    val (_, _, current_stats, _) = current_result

    val baseline_mean = get_stat_mean(baseline_stats)
    val current_mean = get_stat_mean(current_stats)

    # Regression if current is slower by threshold%
    if baseline_mean == 0:
        return false

    val percent_change = ((current_mean - baseline_mean) * 100) / baseline_mean
    percent_change > threshold

fn regression_percentage(baseline_result, current_result):
    """Calculate regression percentage.

    Returns: Percentage change (positive = regression, negative = improvement)

    Example:
        val change = regression_percentage(baseline, current)
        # 15 means 15% slower (regression)
        # -10 means 10% faster (improvement)
    """
    val (_, _, baseline_stats, _) = baseline_result
    val (_, _, current_stats, _) = current_result

    val baseline_mean = get_stat_mean(baseline_stats)
    val current_mean = get_stat_mean(current_stats)

    if baseline_mean == 0:
        return 0

    ((current_mean - baseline_mean) * 100) / baseline_mean

fn is_performance_improvement(baseline_result, current_result, threshold: i64):
    """Check if current is faster than baseline by threshold%.

    Example:
        val improved = is_performance_improvement(baseline, current, 10)
    """
    val change = regression_percentage(baseline_result, current_result)
    change < (0 - threshold)

# ============================================================================
# Memory Profiling (Basic)
# ============================================================================

fn estimate_memory_usage(obj):
    """Estimate memory usage (very basic).

    Returns: Rough estimate in bytes

    Note: This is a placeholder. Real memory tracking requires runtime support.
    """
    # Very rough estimation based on type
    if obj == nil:
        return 8

    # Assume 8 bytes per value (simplified)
    8

fn track_allocations(bench_fn):
    """Track allocations during benchmark.

    Returns: (result, estimated_bytes)

    Note: This is a placeholder. Real tracking requires runtime support.
    """
    val result = bench_fn()
    val estimated = estimate_memory_usage(result)
    (result, estimated)

fn memory_overhead(fn_before, fn_after):
    """Estimate memory overhead.

    Returns: Difference in estimated memory usage
    """
    val (_, before_mem) = track_allocations(fn_before)
    val (_, after_mem) = track_allocations(fn_after)
    after_mem - before_mem

# ============================================================================
# Profiling
# ============================================================================

fn profile_function(bench_fn):
    """Profile function execution.

    Returns: (elapsed, memory_estimate)

    Example:
        val (time, mem) = profile_function(fn(): compute())
    """
    val elapsed = time_function(bench_fn)
    val (result, mem) = track_allocations(bench_fn)
    (elapsed, mem)

fn profile_with_breakdown(bench_fn):
    """Profile with detailed breakdown.

    Returns: (total_time, memory, iterations)
    """
    val iterations = 10
    val timings = time_iterations(bench_fn, iterations)
    val total = calculate_sum(timings)
    val (_, mem) = track_allocations(bench_fn)

    (total, mem, iterations)

# ============================================================================
# Formatted Output
# ============================================================================

fn format_time(value: i64):
    """Format time value with appropriate unit.

    Example:
        format_time(1234)  # "1234 units"
    """
    "{value} units"

fn format_percentage(value: i64):
    """Format percentage value.

    Example:
        format_percentage(150)  # "150%"
    """
    "{value}%"

fn format_result(result):
    """Format benchmark result as string.

    Example:
        print format_result(result)
    """
    val (name, _, stats, iterations) = result
    val mean_val = get_stat_mean(stats)
    val median_val = get_stat_median(stats)
    val stddev = get_stat_stddev(stats)
    val p95 = get_stat_p95(stats)

    var output = ""
    output = "{output}{name}:"
    output = "{output}\n  Iterations: {iterations}"
    output = "{output}\n  Mean:   {mean_val} units"
    output = "{output}\n  Median: {median_val} units"
    output = "{output}\n  StdDev: {stddev}"
    output = "{output}\n  95th:   {p95} units"
    output

fn format_comparison(comparison):
    """Format comparison result as string.

    Example:
        print format_comparison(comp)
    """
    val (name1, name2, speedup, faster_name, significant) = comparison

    val speedup_x = speedup / 100
    val speedup_frac = speedup % 100

    var sig_text = ""
    if significant:
        sig_text = " (SIGNIFICANT)"

    "Comparison: {name1} vs {name2}\n  Faster: {faster_name}\n  Speedup: {speedup_x}.{speedup_frac}x{sig_text}"

fn format_stats_row(name: text, stats):
    """Format stats as table row.

    Returns: Formatted string
    """
    val mean_val = get_stat_mean(stats)
    val median_val = get_stat_median(stats)
    val stddev = get_stat_stddev(stats)
    val p95 = get_stat_p95(stats)

    "{name}: mean={mean_val}, median={median_val}, std={stddev}, p95={p95}"

# ============================================================================
# Summary Reports
# ============================================================================

fn print_result(result):
    """Print formatted benchmark result.

    Example:
        print_result(result)
    """
    print format_result(result)

fn print_comparison(comparison):
    """Print formatted comparison.

    Example:
        print_comparison(comp)
    """
    print format_comparison(comparison)

fn print_summary(suite_result):
    """Print comprehensive suite summary.

    Example:
        val suite_result = run_suite(suite)
        print_summary(suite_result)
    """
    val (suite_name, results, summary) = suite_result
    val (total_benchmarks, avg_mean, avg_median) = summary

    print "================================"
    print "Benchmark Suite: {suite_name}"
    print "================================"
    print "Total Benchmarks: {total_benchmarks}"
    print ""

    for result in results:
        print format_result(result)
        print ""

    print "--------------------------------"
    print "Suite Average:"
    print "  Mean:   {avg_mean} units"
    print "  Median: {avg_median} units"
    print "================================"

fn print_comparison_table(results):
    """Print comparison table for multiple results.

    Example:
        print_comparison_table([result1, result2, result3])
    """
    print "Comparison Table:"
    print "--------------------------------"

    for result in results:
        val (name, _, stats, _) = result
        print format_stats_row(name, stats)

    print "--------------------------------"

fn print_regression_report(baseline_result, current_result):
    """Print regression analysis report.

    Example:
        print_regression_report(baseline, current)
    """
    val regressed = detect_regression(baseline_result, current_result, 5)
    val change = regression_percentage(baseline_result, current_result)

    print "Regression Analysis:"
    print "  Change: {change}%"

    if regressed:
        print "  Status: REGRESSION DETECTED"
    elif change < 0:
        print "  Status: Performance Improved"
    else:
        print "  Status: Within Threshold"

# ============================================================================
# Export to File (Text Format)
# ============================================================================

fn export_result_text(result):
    """Export result to text format.

    Returns: String representation suitable for file export
    """
    format_result(result)

fn export_comparison_text(comparison):
    """Export comparison to text format.

    Returns: String representation
    """
    format_comparison(comparison)

fn export_suite_text(suite_result):
    """Export suite result to text format.

    Returns: String representation
    """
    val (suite_name, results, summary) = suite_result
    val (total_benchmarks, avg_mean, avg_median) = summary

    var output = "Benchmark Suite: {suite_name}\n"
    output = "{output}Total Benchmarks: {total_benchmarks}\n\n"

    for result in results:
        val formatted = format_result(result)
        output = "{output}{formatted}\n\n"

    output = "{output}Suite Average:\n"
    output = "{output}  Mean:   {avg_mean} units\n"
    output = "{output}  Median: {avg_median} units\n"

    output

# ============================================================================
# CSV Export
# ============================================================================

fn export_result_csv_header():
    """Get CSV header for results.

    Returns: CSV header string
    """
    "name,iterations,mean,median,stddev,min,max,p95,p99,cv"

fn export_result_csv_row(result):
    """Export result as CSV row.

    Returns: CSV row string
    """
    val (name, _, stats, iterations) = result
    val (mean_val, median, stddev, min_val, max_val, _, p95, p99, cv) = stats

    "{name},{iterations},{mean_val},{median},{stddev},{min_val},{max_val},{p95},{p99},{cv}"

fn export_results_csv(results):
    """Export multiple results to CSV format.

    Returns: Complete CSV string with header
    """
    var csv = export_result_csv_header()
    csv = "{csv}\n"

    for result in results:
        val row = export_result_csv_row(result)
        csv = "{csv}{row}\n"

    csv

# ============================================================================
# Utilities
# ============================================================================

fn benchmark_count(suite):
    """Get count of benchmarks in suite.

    Example:
        val count = benchmark_count(suite)
    """
    val (_, benchmarks, _) = suite
    benchmarks.len()

fn get_benchmark_names(suite):
    """Get list of benchmark names.

    Returns: Array of names
    """
    val (_, benchmarks, _) = suite
    var names = []

    for benchmark in benchmarks:
        val (name, _, _, _) = benchmark
        names.push(name)

    names

fn find_fastest_result(results):
    """Find result with lowest mean time.

    Returns: Fastest result tuple
    """
    if results.len() == 0:
        return nil

    var fastest = results[0]
    var fastest_mean = get_stat_mean(get_result_stats(fastest))

    var i = 1
    while i < results.len():
        val current = results[i]
        val current_stats = get_result_stats(current)
        val current_mean = get_stat_mean(current_stats)

        if current_mean < fastest_mean:
            fastest = current
            fastest_mean = current_mean

        i = i + 1

    fastest

fn find_slowest_result(results):
    """Find result with highest mean time.

    Returns: Slowest result tuple
    """
    if results.len() == 0:
        return nil

    var slowest = results[0]
    var slowest_mean = get_stat_mean(get_result_stats(slowest))

    var i = 1
    while i < results.len():
        val current = results[i]
        val current_stats = get_result_stats(current)
        val current_mean = get_stat_mean(current_stats)

        if current_mean > slowest_mean:
            slowest = current
            slowest_mean = current_mean

        i = i + 1

    slowest

# ============================================================================
# Advanced Benchmarking
# ============================================================================

fn benchmark_convergence(bench_fn, max_iterations: i64, convergence_threshold: i64):
    """Run benchmark until results converge.

    Runs until coefficient of variation is below threshold.

    Returns: Benchmark result
    """
    var all_timings = []
    var iterations = 0
    var converged = false

    while iterations < max_iterations and not converged:
        val timing = time_function(bench_fn)
        all_timings.push(timing)
        iterations = iterations + 1

        if iterations >= 10:
            val cv = coefficient_of_variation(all_timings)
            if cv < convergence_threshold:
                converged = true

    create_result("convergence", all_timings)

fn benchmark_adaptive(bench_fn, target_time: i64):
    """Run benchmark adaptively to reach target total time.

    Automatically determines iteration count.

    Returns: Benchmark result
    """
    # Quick sampling to estimate iteration time
    val sample_timing = time_function(bench_fn)

    var estimated_iterations = 100
    if sample_timing > 0:
        estimated_iterations = target_time / sample_timing

    if estimated_iterations < 10:
        estimated_iterations = 10
    if estimated_iterations > 10000:
        estimated_iterations = 10000

    run_benchmark(bench_fn, estimated_iterations)

# ============================================================================
# Exports
# ============================================================================

export create_benchmark_suite, add_benchmark, configure_suite
export run_benchmark, run_with_warmup, run_benchmark_full, run_suite
export get_timestamp, time_function, time_iterations
export calculate_mean, calculate_median, calculate_variance, calculate_stddev
export calculate_sum, calculate_stats
export percentile, percentile_50, percentile_95, percentile_99
export quartiles, interquartile_range
export min_value, max_value, range_value, coefficient_of_variation
export is_outlier, detect_outliers, remove_outliers, outlier_count
export sort_values
export create_result, get_result_stats, get_result_name, get_result_timings
export get_result_iterations
export get_stat_mean, get_stat_median, get_stat_stddev, get_stat_min
export get_stat_max, get_stat_p95, get_stat_p99, get_stat_cv
export compare_benchmarks, speedup_ratio, is_significant_difference
export compare_to_baseline
export detect_regression, regression_percentage, is_performance_improvement
export estimate_memory_usage, track_allocations, memory_overhead
export profile_function, profile_with_breakdown
export format_time, format_percentage, format_result, format_comparison
export format_stats_row
export print_result, print_comparison, print_summary, print_comparison_table
export print_regression_report
export export_result_text, export_comparison_text, export_suite_text
export export_result_csv_header, export_result_csv_row, export_results_csv
export benchmark_count, get_benchmark_names, find_fastest_result, find_slowest_result
export benchmark_convergence, benchmark_adaptive
export create_suite_summary
export BENCHMARK_DEFAULT_WARMUP, BENCHMARK_DEFAULT_ITERATIONS
export BENCHMARK_DEFAULT_OUTLIER_THRESHOLD, BENCHMARK_REGRESSION_THRESHOLD
