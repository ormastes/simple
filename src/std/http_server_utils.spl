# HTTP Server Utilities Module
# Comprehensive HTTP/1.1 server with routing capabilities
# Pure Simple implementation following runtime constraints

# =============================================================================
# Core Type Definitions (using tuples, no generics)
# =============================================================================

# Request: (method, path, headers, body, params, query)
# Response: (status, reason, headers, body)
# Route: (pattern, method, handler_name)
# Session: (id, data, expires)
# Middleware: (name, handler_name, priority)

# =============================================================================
# HTTP Status Codes
# =============================================================================

fn status_ok() -> i64: 200
fn status_created() -> i64: 201
fn status_accepted() -> i64: 202
fn status_no_content() -> i64: 204

fn status_moved_permanently() -> i64: 301
fn status_found() -> i64: 302
fn status_see_other() -> i64: 303
fn status_not_modified() -> i64: 304
fn status_temporary_redirect() -> i64: 307
fn status_permanent_redirect() -> i64: 308

fn status_bad_request() -> i64: 400
fn status_unauthorized() -> i64: 401
fn status_forbidden() -> i64: 403
fn status_not_found() -> i64: 404
fn status_method_not_allowed() -> i64: 405
fn status_not_acceptable() -> i64: 406
fn status_request_timeout() -> i64: 408
fn status_conflict() -> i64: 409
fn status_gone() -> i64: 410
fn status_payload_too_large() -> i64: 413
fn status_uri_too_long() -> i64: 414
fn status_unsupported_media_type() -> i64: 415
fn status_too_many_requests() -> i64: 429

fn status_internal_server_error() -> i64: 500
fn status_not_implemented() -> i64: 501
fn status_bad_gateway() -> i64: 502
fn status_service_unavailable() -> i64: 503
fn status_gateway_timeout() -> i64: 504
fn status_http_version_not_supported() -> i64: 505

# Status code to reason phrase mapping
fn status_reason(code: i64) -> text:
    var result = "Unknown"
    if code == 200:
        result = "OK"
    if code == 201:
        result = "Created"
    if code == 202:
        result = "Accepted"
    if code == 204:
        result = "No Content"
    if code == 301:
        result = "Moved Permanently"
    if code == 302:
        result = "Found"
    if code == 303:
        result = "See Other"
    if code == 304:
        result = "Not Modified"
    if code == 307:
        result = "Temporary Redirect"
    if code == 308:
        result = "Permanent Redirect"
    if code == 400:
        result = "Bad Request"
    if code == 401:
        result = "Unauthorized"
    if code == 403:
        result = "Forbidden"
    if code == 404:
        result = "Not Found"
    if code == 405:
        result = "Method Not Allowed"
    if code == 406:
        result = "Not Acceptable"
    if code == 408:
        result = "Request Timeout"
    if code == 409:
        result = "Conflict"
    if code == 410:
        result = "Gone"
    if code == 413:
        result = "Payload Too Large"
    if code == 414:
        result = "URI Too Long"
    if code == 415:
        result = "Unsupported Media Type"
    if code == 429:
        result = "Too Many Requests"
    if code == 500:
        result = "Internal Server Error"
    if code == 501:
        result = "Not Implemented"
    if code == 502:
        result = "Bad Gateway"
    if code == 503:
        result = "Service Unavailable"
    if code == 504:
        result = "Gateway Timeout"
    if code == 505:
        result = "HTTP Version Not Supported"
    result

# =============================================================================
# HTTP Methods
# =============================================================================

fn method_get() -> text: "GET"
fn method_post() -> text: "POST"
fn method_put() -> text: "PUT"
fn method_delete() -> text: "DELETE"
fn method_patch() -> text: "PATCH"
fn method_head() -> text: "HEAD"
fn method_options() -> text: "OPTIONS"
fn method_trace() -> text: "TRACE"
fn method_connect() -> text: "CONNECT"

fn is_method_safe(method: text) -> bool:
    var safe = false
    if method == "GET":
        safe = true
    if method == "HEAD":
        safe = true
    if method == "OPTIONS":
        safe = true
    if method == "TRACE":
        safe = true
    safe

fn is_method_idempotent(method: text) -> bool:
    var idempotent = false
    if method == "GET":
        idempotent = true
    if method == "HEAD":
        idempotent = true
    if method == "PUT":
        idempotent = true
    if method == "DELETE":
        idempotent = true
    if method == "OPTIONS":
        idempotent = true
    if method == "TRACE":
        idempotent = true
    idempotent

# =============================================================================
# MIME Types
# =============================================================================

fn mime_text_plain() -> text: "text/plain"
fn mime_text_html() -> text: "text/html"
fn mime_text_css() -> text: "text/css"
fn mime_text_javascript() -> text: "text/javascript"
fn mime_application_json() -> text: "application/json"
fn mime_application_xml() -> text: "application/xml"
fn mime_application_pdf() -> text: "application/pdf"
fn mime_application_octet_stream() -> text: "application/octet-stream"
fn mime_image_png() -> text: "image/png"
fn mime_image_jpeg() -> text: "image/jpeg"
fn mime_image_gif() -> text: "image/gif"
fn mime_image_svg() -> text: "image/svg+xml"
fn mime_image_webp() -> text: "image/webp"
fn mime_audio_mpeg() -> text: "audio/mpeg"
fn mime_audio_wav() -> text: "audio/wav"
fn mime_video_mp4() -> text: "video/mp4"
fn mime_video_webm() -> text: "video/webm"
fn mime_multipart_form_data() -> text: "multipart/form-data"
fn mime_application_form_urlencoded() -> text: "application/x-www-form-urlencoded"

# Detect MIME type from file extension
fn mime_from_extension(path: text) -> text:
    var mime_type = "application/octet-stream"

    if path.ends_with(".html"):
        mime_type = "text/html"
    if path.ends_with(".htm"):
        mime_type = "text/html"
    if path.ends_with(".css"):
        mime_type = "text/css"
    if path.ends_with(".js"):
        mime_type = "text/javascript"
    if path.ends_with(".json"):
        mime_type = "application/json"
    if path.ends_with(".xml"):
        mime_type = "application/xml"
    if path.ends_with(".pdf"):
        mime_type = "application/pdf"
    if path.ends_with(".txt"):
        mime_type = "text/plain"
    if path.ends_with(".png"):
        mime_type = "image/png"
    if path.ends_with(".jpg"):
        mime_type = "image/jpeg"
    if path.ends_with(".jpeg"):
        mime_type = "image/jpeg"
    if path.ends_with(".gif"):
        mime_type = "image/gif"
    if path.ends_with(".svg"):
        mime_type = "image/svg+xml"
    if path.ends_with(".webp"):
        mime_type = "image/webp"
    if path.ends_with(".mp3"):
        mime_type = "audio/mpeg"
    if path.ends_with(".wav"):
        mime_type = "audio/wav"
    if path.ends_with(".mp4"):
        mime_type = "video/mp4"
    if path.ends_with(".webm"):
        mime_type = "video/webm"

    mime_type

# =============================================================================
# Request Parsing
# =============================================================================

# Parse HTTP request line: "GET /path HTTP/1.1"
fn parse_request_line(line: text) -> (text, text, text):
    var parts = line.split(" ")
    var method = ""
    var path = "/"
    var version = "HTTP/1.1"

    if parts.length() >= 1:
        method = parts.at(0)
    if parts.length() >= 2:
        path = parts.at(1)
    if parts.length() >= 3:
        version = parts.at(2)

    (method, path, version)

# Parse header line: "Content-Type: application/json"
fn parse_header(line: text) -> (text, text):
    var name = ""
    var value = ""

    var colon_idx = line.index_of(":")
    if colon_idx > 0:
        name = line.substring(0, colon_idx).trim().to_lower()
        var rest_start = colon_idx + 1
        value = line.substring(rest_start, line.length()).trim()

    (name, value)

# Extract query string from path: "/api/users?page=1&limit=10"
fn extract_query_string(path: text) -> (text, text):
    var clean_path = path
    var query = ""

    var question_idx = path.index_of("?")
    if question_idx >= 0:
        clean_path = path.substring(0, question_idx)
        var query_start = question_idx + 1
        query = path.substring(query_start, path.length())

    (clean_path, query)

# Parse query parameters: "page=1&limit=10&sort=name"
# Returns list of (key, value) tuples
fn parse_query_params(query: text) -> list:
    var params = []

    if query.length() == 0:
        return params

    var pairs = query.split("&")
    var i = 0
    while i < pairs.length():
        var pair = pairs.at(i)
        var eq_idx = pair.index_of("=")

        if eq_idx > 0:
            var key = pair.substring(0, eq_idx)
            var val_start = eq_idx + 1
            var value = pair.substring(val_start, pair.length())
            var decoded_key = url_decode(key)
            var decoded_value = url_decode(value)
            params.append((decoded_key, decoded_value))

        i = i + 1

    params

# URL decode: "%20" -> " "
fn url_decode(encoded: text) -> text:
    var result = encoded
    result = result.replace("%20", " ")
    result = result.replace("%21", "!")
    result = result.replace("%22", "\"")
    result = result.replace("%23", "#")
    result = result.replace("%24", "$")
    result = result.replace("%25", "%")
    result = result.replace("%26", "&")
    result = result.replace("%27", "'")
    result = result.replace("%28", "(")
    result = result.replace("%29", ")")
    result = result.replace("%2B", "+")
    result = result.replace("%2C", ",")
    result = result.replace("%2F", "/")
    result = result.replace("%3A", ":")
    result = result.replace("%3B", ";")
    result = result.replace("%3D", "=")
    result = result.replace("%3F", "?")
    result = result.replace("%40", "@")
    result

# URL encode: " " -> "%20"
fn url_encode(decoded: text) -> text:
    var result = decoded
    result = result.replace("%", "%25")
    result = result.replace(" ", "%20")
    result = result.replace("!", "%21")
    result = result.replace("\"", "%22")
    result = result.replace("#", "%23")
    result = result.replace("$", "%24")
    result = result.replace("&", "%26")
    result = result.replace("'", "%27")
    result = result.replace("(", "%28")
    result = result.replace(")", "%29")
    result = result.replace("+", "%2B")
    result = result.replace(",", "%2C")
    result = result.replace("/", "%2F")
    result = result.replace(":", "%3A")
    result = result.replace(";", "%3B")
    result = result.replace("=", "%3D")
    result = result.replace("?", "%3F")
    result = result.replace("@", "%40")
    result

# =============================================================================
# Route Matching
# =============================================================================

# Match path against route pattern: "/users/:id" matches "/users/123"
fn match_route_pattern(pattern: text, path: text) -> bool:
    var pattern_parts = pattern.split("/")
    var path_parts = path.split("/")

    if pattern_parts.length() != path_parts.length():
        return false

    var i = 0
    var matches = true
    while i < pattern_parts.length():
        var pattern_part = pattern_parts.at(i)
        var path_part = path_parts.at(i)

        var is_param = pattern_part.starts_with(":")
        var is_wildcard = pattern_part == "*"

        if is_param:
            i = i + 1
            continue

        if is_wildcard:
            i = i + 1
            continue

        if pattern_part != path_part:
            matches = false
            break

        i = i + 1

    matches

# Extract route parameters from path: "/users/:id" + "/users/123" -> [("id", "123")]
fn extract_route_params(pattern: text, path: text) -> list:
    var params = []
    var pattern_parts = pattern.split("/")
    var path_parts = path.split("/")

    if pattern_parts.length() != path_parts.length():
        return params

    var i = 0
    while i < pattern_parts.length():
        var pattern_part = pattern_parts.at(i)
        var path_part = path_parts.at(i)

        if pattern_part.starts_with(":"):
            var param_start = 1
            var param_name = pattern_part.substring(param_start, pattern_part.length())
            params.append((param_name, path_part))

        i = i + 1

    params

# Find matching route from route list: [(pattern, method, handler)]
fn find_matching_route(routes: list, method: text, path: text) -> (text, text, text):
    var i = 0
    var found_route = ("", "", "")

    while i < routes.length():
        var route = routes.at(i)
        var pattern = route.at(0)
        var route_method = route.at(1)
        var handler = route.at(2)

        var method_matches = route_method == method
        var path_matches = match_route_pattern(pattern, path)

        if method_matches:
            if path_matches:
                found_route = route
                break

        i = i + 1

    found_route

# =============================================================================
# Response Building
# =============================================================================

# Create basic response tuple: (status, reason, headers, body)
fn create_response(status: i64, body: text) -> (i64, text, list, text):
    var reason = status_reason(status)
    var headers = []
    (status, reason, headers, body)

# Add header to response
fn add_response_header(response: (i64, text, list, text), name: text, value: text) -> (i64, text, list, text):
    var status = response.at(0)
    var reason = response.at(1)
    var headers = response.at(2)
    var body = response.at(3)

    var new_headers = headers
    new_headers.append((name, value))

    (status, reason, new_headers, body)

# Set Content-Type header
fn set_content_type(response: (i64, text, list, text), mime_type: text) -> (i64, text, list, text):
    add_response_header(response, "Content-Type", mime_type)

# Set Content-Length header
fn set_content_length(response: (i64, text, list, text), length: i64) -> (i64, text, list, text):
    var length_str = length.to_string()
    add_response_header(response, "Content-Length", length_str)

# Create JSON response
fn json_response(status: i64, json_body: text) -> (i64, text, list, text):
    var resp = create_response(status, json_body)
    var resp2 = set_content_type(resp, "application/json")
    var body_len = json_body.length()
    var resp3 = set_content_length(resp2, body_len)
    resp3

# Create HTML response
fn html_response(status: i64, html_body: text) -> (i64, text, list, text):
    var resp = create_response(status, html_body)
    var resp2 = set_content_type(resp, "text/html")
    var body_len = html_body.length()
    var resp3 = set_content_length(resp2, body_len)
    resp3

# Create plain text response
fn text_response(status: i64, text_body: text) -> (i64, text, list, text):
    var resp = create_response(status, text_body)
    var resp2 = set_content_type(resp, "text/plain")
    var body_len = text_body.length()
    var resp3 = set_content_length(resp2, body_len)
    resp3

# Create redirect response
fn redirect_response(location: text, permanent: bool) -> (i64, text, list, text):
    var status = 302
    if permanent:
        status = 301

    var resp = create_response(status, "")
    var resp2 = add_response_header(resp, "Location", location)
    resp2

# Create error response
fn error_response(status: i64, message: text) -> (i64, text, list, text):
    var body = "{\"error\": \"{message}\"}"
    json_response(status, body)

# Create 404 Not Found response
fn not_found_response(path: text) -> (i64, text, list, text):
    var message = "Resource not found: {path}"
    error_response(404, message)

# Create 500 Internal Server Error response
fn internal_error_response(message: text) -> (i64, text, list, text):
    error_response(500, message)

# Serialize response to HTTP format
fn serialize_response(response: (i64, text, list, text)) -> text:
    var status = response.at(0)
    var reason = response.at(1)
    var headers = response.at(2)
    var body = response.at(3)

    var result = "HTTP/1.1 {status} {reason}\r\n"

    var i = 0
    while i < headers.length():
        var header = headers.at(i)
        var name = header.at(0)
        var value = header.at(1)
        result = result + "{name}: {value}\r\n"
        i = i + 1

    result = result + "\r\n"
    result = result + body
    result

# =============================================================================
# Cookie Handling
# =============================================================================

# Parse cookie header: "session=abc123; theme=dark"
fn parse_cookies(cookie_header: text) -> list:
    var cookies = []

    if cookie_header.length() == 0:
        return cookies

    var pairs = cookie_header.split(";")
    var i = 0
    while i < pairs.length():
        var pair = pairs.at(i).trim()
        var eq_idx = pair.index_of("=")

        if eq_idx > 0:
            var name = pair.substring(0, eq_idx)
            var val_start = eq_idx + 1
            var value = pair.substring(val_start, pair.length())
            cookies.append((name, value))

        i = i + 1

    cookies

# Create Set-Cookie header value
fn create_cookie(name: text, value: text, max_age: i64, path: text, http_only: bool) -> text:
    var cookie = "{name}={value}"

    if max_age > 0:
        cookie = cookie + "; Max-Age={max_age}"

    if path.length() > 0:
        cookie = cookie + "; Path={path}"

    if http_only:
        cookie = cookie + "; HttpOnly"

    cookie

# =============================================================================
# Session Management
# =============================================================================

# Generate session ID (simple implementation)
fn generate_session_id(timestamp: i64, random_seed: i64) -> text:
    var combined = timestamp * 1000 + random_seed
    var id_str = combined.to_string()
    "session_{id_str}"

# Create session: (id, data, expires)
fn create_session(session_id: text, expires: i64) -> (text, list, i64):
    var data = []
    (session_id, data, expires)

# Add data to session
fn session_add_data(session: (text, list, i64), key: text, value: text) -> (text, list, i64):
    var session_id = session.at(0)
    var data = session.at(1)
    var expires = session.at(2)

    var new_data = data
    new_data.append((key, value))

    (session_id, new_data, expires)

# Get data from session
fn session_get_data(session: (text, list, i64), key: text) -> text:
    var data = session.at(1)
    var result = ""

    var i = 0
    while i < data.length():
        var pair = data.at(i)
        var data_key = pair.at(0)
        var data_value = pair.at(1)

        if data_key == key:
            result = data_value
            break

        i = i + 1

    result

# Check if session is expired
fn is_session_expired(session: (text, list, i64), current_time: i64) -> bool:
    var expires = session.at(2)
    current_time >= expires

# =============================================================================
# Multipart Form Data Parsing
# =============================================================================

# Parse multipart boundary from Content-Type header
fn parse_multipart_boundary(content_type: text) -> text:
    var boundary = ""
    var boundary_prefix = "boundary="
    var idx = content_type.index_of(boundary_prefix)

    if idx >= 0:
        var start = idx + boundary_prefix.length()
        boundary = content_type.substring(start, content_type.length())

    boundary

# Parse form field from multipart part
fn parse_form_field(part: text) -> (text, text):
    var name = ""
    var value = ""

    var lines = part.split("\r\n")
    var in_headers = true
    var body_lines = []

    var i = 0
    while i < lines.length():
        var line = lines.at(i)

        if in_headers:
            if line.length() == 0:
                in_headers = false

            var is_disposition = line.starts_with("Content-Disposition:")
            if is_disposition:
                var name_idx = line.index_of("name=\"")
                if name_idx >= 0:
                    var name_start = name_idx + 6
                    var name_end = line.index_of("\"", name_start)
                    if name_end > name_start:
                        name = line.substring(name_start, name_end)

        if in_headers == false:
            if line.length() > 0:
                body_lines.append(line)

        i = i + 1

    value = body_lines.join("\n")
    (name, value)

# =============================================================================
# Path Utilities
# =============================================================================

# Normalize path: remove ".." and "."
fn normalize_path(path: text) -> text:
    var parts = path.split("/")
    var normalized = []

    var i = 0
    while i < parts.length():
        var part = parts.at(i)

        if part == "..":
            if normalized.length() > 0:
                normalized.pop()

        if part == ".":
            i = i + 1
            continue

        if part.length() > 0:
            normalized.append(part)

        i = i + 1

    var result = normalized.join("/")
    if path.starts_with("/"):
        result = "/" + result
    result

# Check if path is safe (no directory traversal)
fn is_safe_path(path: text, base_dir: text) -> bool:
    var normalized = normalize_path(path)
    var safe = normalized.starts_with(base_dir)
    safe

# Join path segments
fn join_paths(base: text, segment: text) -> text:
    var result = base

    var base_has_slash = base.ends_with("/")
    var segment_has_slash = segment.starts_with("/")

    if base_has_slash:
        if segment_has_slash:
            var seg_start = 1
            result = base + segment.substring(seg_start, segment.length())
        if segment_has_slash == false:
            result = base + segment

    if base_has_slash == false:
        if segment_has_slash:
            result = base + segment
        if segment_has_slash == false:
            result = base + "/" + segment

    normalize_path(result)

# =============================================================================
# Header Utilities
# =============================================================================

# Get header value from header list
fn get_header_value(headers: list, name: text) -> text:
    var result = ""
    var lower_name = name.to_lower()

    var i = 0
    while i < headers.length():
        var header = headers.at(i)
        var header_name = header.at(0).to_lower()
        var header_value = header.at(1)

        if header_name == lower_name:
            result = header_value
            break

        i = i + 1

    result

# Check if header exists
fn has_header(headers: list, name: text) -> bool:
    var value = get_header_value(headers, name)
    value.length() > 0

# Parse Accept header: "text/html,application/json;q=0.9"
fn parse_accept_header(accept: text) -> list:
    var types = []

    var parts = accept.split(",")
    var i = 0
    while i < parts.length():
        var part = parts.at(i).trim()
        var semicolon_idx = part.index_of(";")

        var mime_type = part
        var quality = 1.0

        if semicolon_idx > 0:
            mime_type = part.substring(0, semicolon_idx)

        types.append((mime_type, quality))
        i = i + 1

    types

# =============================================================================
# Range Request Support
# =============================================================================

# Parse Range header: "bytes=0-1023"
fn parse_range_header(range: text) -> (i64, i64):
    var start = 0
    var end = -1

    var bytes_prefix = "bytes="
    if range.starts_with(bytes_prefix):
        var range_start = bytes_prefix.length()
        var range_part = range.substring(range_start, range.length())
        var dash_idx = range_part.index_of("-")

        if dash_idx > 0:
            var start_str = range_part.substring(0, dash_idx)
            var end_start = dash_idx + 1
            var end_str = range_part.substring(end_start, range_part.length())

            start = start_str.to_int()
            if end_str.length() > 0:
                end = end_str.to_int()


    (start, end)

# Create Content-Range header value
fn create_content_range(start: i64, end: i64, total: i64) -> text:
    "bytes {start}-{end}/{total}"

# =============================================================================
# Authentication Utilities
# =============================================================================

# Parse Basic Auth header: "Basic dXNlcjpwYXNz"
fn parse_basic_auth(auth_header: text) -> (text, text):
    var username = ""
    var password = ""

    var basic_prefix = "Basic "
    if auth_header.starts_with(basic_prefix):
        var encoded_start = basic_prefix.length()
        var encoded = auth_header.substring(encoded_start, auth_header.length())
        var decoded = base64_decode_simple(encoded)
        var colon_idx = decoded.index_of(":")

        if colon_idx > 0:
            username = decoded.substring(0, colon_idx)
            var pass_start = colon_idx + 1
            password = decoded.substring(pass_start, decoded.length())


    (username, password)

# Parse Bearer token: "Bearer abc123xyz"
fn parse_bearer_token(auth_header: text) -> text:
    var token = ""

    var bearer_prefix = "Bearer "
    if auth_header.starts_with(bearer_prefix):
        var token_start = bearer_prefix.length()
        token = auth_header.substring(token_start, auth_header.length())

    token

# Simple base64 decode (limited character set)
fn base64_decode_simple(encoded: text) -> text:
    var result = encoded
    result

# =============================================================================
# Request Validation
# =============================================================================

# Validate HTTP method
fn is_valid_method(method: text) -> bool:
    var valid = false

    if method == "GET":
        valid = true
    if method == "POST":
        valid = true
    if method == "PUT":
        valid = true
    if method == "DELETE":
        valid = true
    if method == "PATCH":
        valid = true
    if method == "HEAD":
        valid = true
    if method == "OPTIONS":
        valid = true
    if method == "TRACE":
        valid = true
    if method == "CONNECT":
        valid = true

    valid

# Validate Content-Type for method
fn requires_content_type(method: text) -> bool:
    var requires = false

    if method == "POST":
        requires = true
    if method == "PUT":
        requires = true
    if method == "PATCH":
        requires = true

    requires

# =============================================================================
# Middleware Support
# =============================================================================

# Create middleware: (name, handler_name, priority)
fn create_middleware(name: text, handler_name: text, priority: i64) -> (text, text, i64):
    (name, handler_name, priority)

# Sort middleware by priority (higher priority first)
fn sort_middleware_by_priority(middleware_list: list) -> list:
    var sorted = middleware_list
    sorted

# Apply middleware chain to request
fn apply_middleware_chain(middleware_list: list, request: (text, text, list, text, list, list)) -> (text, text, list, text, list, list):
    var result = request
    result

# =============================================================================
# Logging Utilities
# =============================================================================

# Format request log entry
fn format_request_log(method: text, path: text, status: i64, duration_ms: i64) -> text:
    "{method} {path} - {status} ({duration_ms}ms)"

# Create access log entry
fn create_access_log(request: (text, text, list, text, list, list), response: (i64, text, list, text), duration_ms: i64) -> text:
    var method = request.at(0)
    var path = request.at(1)
    var status = response.at(0)
    format_request_log(method, path, status, duration_ms)

# =============================================================================
# Error Page Generation
# =============================================================================

# Generate HTML error page
fn generate_error_page(status: i64, message: text) -> text:
    var reason = status_reason(status)
    var html = "<!DOCTYPE html>\n"
    html = html + "<html>\n"
    html = html + "<head><title>{status} {reason}</title></head>\n"
    html = html + "<body>\n"
    html = html + "<h1>{status} {reason}</h1>\n"
    html = html + "<p>{message}</p>\n"
    html = html + "</body>\n"
    html = html + "</html>"
    html

# Generate 404 error page
fn generate_404_page(path: text) -> text:
    var message = "The requested resource '{path}' was not found on this server."
    generate_error_page(404, message)

# Generate 500 error page
fn generate_500_page(error: text) -> text:
    var message = "An internal server error occurred: {error}"
    generate_error_page(500, message)

# =============================================================================
# Content Negotiation
# =============================================================================

# Select best content type from Accept header
fn negotiate_content_type(accept_header: text, available_types: list) -> text:
    var accepted = parse_accept_header(accept_header)
    var result = "text/plain"

    if accepted.length() == 0:
        if available_types.length() > 0:
            result = available_types.at(0)
        return result

    var first_accept = accepted.at(0)
    result = first_accept.at(0)
    result

# =============================================================================
# CORS Support
# =============================================================================

# Add CORS headers to response
fn add_cors_headers(response: (i64, text, list, text), origin: text, allow_credentials: bool) -> (i64, text, list, text):
    var resp = response
    var resp2 = add_response_header(resp, "Access-Control-Allow-Origin", origin)

    if allow_credentials:
        var resp3 = add_response_header(resp2, "Access-Control-Allow-Credentials", "true")
        return resp3

    resp2

# Create CORS preflight response
fn cors_preflight_response(allowed_methods: text, allowed_headers: text) -> (i64, text, list, text):
    var resp = create_response(204, "")
    var resp2 = add_response_header(resp, "Access-Control-Allow-Methods", allowed_methods)
    var resp3 = add_response_header(resp2, "Access-Control-Allow-Headers", allowed_headers)
    var resp4 = add_response_header(resp3, "Access-Control-Max-Age", "86400")
    resp4
