# Random Utilities
#
# Pseudo-random number generation and utilities.
# Pure Simple implementation - no external dependencies.
#
# Uses Linear Congruential Generator (LCG) for PRNG.
# Note: Not cryptographically secure - for simulation/testing only.
#
# Functions:
# - PRNG: rng_create, rng_next, rng_next_range
# - Distributions: random_int, random_float_like, random_bool
# - Arrays: shuffle, sample, random_choice, random_sample
# - Generation: random_array, random_permutation

# ============================================================================
# Random Number Generator (LCG)
# ============================================================================

fn rng_create(seed: i64):
    """Create RNG state from seed.

    Returns RNG state tuple (seed, multiplier, increment, modulus).

    Example:
        val rng = rng_create(12345)
    """
    # LCG parameters (same as glibc)
    val multiplier = 1103515245
    val increment = 12345
    val modulus = 2147483648  # 2^31

    (seed % modulus, multiplier, increment, modulus)

fn rng_next(rng):
    """Generate next random number.

    Returns (new_rng_state, random_value).

    Example:
        val (rng2, value) = rng_next(rng)
    """
    val (state, a, c, m) = rng
    val new_state = (a * state + c) % m

    ((new_state, a, c, m), new_state)

fn rng_next_range(rng, min_val: i64, max_val: i64):
    """Generate random number in range [min, max).

    Returns (new_rng_state, random_value).

    Example:
        val (rng2, dice) = rng_next_range(rng, 1, 7)  # 1-6
    """
    val (new_rng, value) = rng_next(rng)
    val range = max_val - min_val
    val result = min_val + (value % range)

    (new_rng, result)

fn rng_next_float_like(rng, precision: i64):
    """Generate float-like value (scaled integer).

    Returns (new_rng_state, value) where value is in [0, precision).
    Divide by precision to get value in [0, 1).

    Example:
        val (rng2, val) = rng_next_float_like(rng, 1000)
        # val / 1000.0 would be in [0.0, 1.0)
    """
    rng_next_range(rng, 0, precision)

# ============================================================================
# Simple Random Functions
# ============================================================================

fn random_int(rng, max_val: i64):
    """Generate random integer in [0, max_val).

    Example:
        val (rng2, num) = random_int(rng, 100)  # 0-99
    """
    rng_next_range(rng, 0, max_val)

fn random_int_range(rng, min_val: i64, max_val: i64):
    """Generate random integer in [min_val, max_val).

    Example:
        val (rng2, num) = random_int_range(rng, 10, 20)  # 10-19
    """
    rng_next_range(rng, min_val, max_val)

fn random_bool(rng):
    """Generate random boolean.

    Example:
        val (rng2, coin) = random_bool(rng)
    """
    val (new_rng, value) = rng_next(rng)
    (new_rng, value % 2 == 0)

fn random_sign(rng):
    """Generate random sign (-1 or 1).

    Example:
        val (rng2, sign) = random_sign(rng)
    """
    val (new_rng, value) = rng_next(rng)
    (new_rng, if value % 2 == 0: 1 else: -1)

# ============================================================================
# Array Randomization
# ============================================================================

fn shuffle(rng, arr):
    """Shuffle array (Fisher-Yates algorithm).

    Returns (new_rng_state, shuffled_array).

    Example:
        val (rng2, shuffled) = shuffle(rng, [1, 2, 3, 4, 5])
    """
    var result = arr
    var current_rng = rng

    var i = result.len() - 1
    while i > 0:
        # Pick random index j where 0 <= j <= i
        val (new_rng, j) = rng_next_range(current_rng, 0, i + 1)
        current_rng = new_rng

        # Swap elements
        val temp = result[i]
        result[i] = result[j]
        result[j] = temp

        i = i - 1

    (current_rng, result)

fn random_choice(rng, arr):
    """Pick random element from array.

    Returns (new_rng_state, element).

    Example:
        val (rng2, item) = random_choice(rng, [1, 2, 3, 4, 5])
    """
    val (new_rng, idx) = rng_next_range(rng, 0, arr.len())
    (new_rng, arr[idx])

fn random_sample(rng, arr, n: i64):
    """Sample n random elements without replacement.

    Returns (new_rng_state, sample_array).

    Example:
        val (rng2, sample) = random_sample(rng, [1,2,3,4,5], 3)
    """
    if n >= arr.len():
        return shuffle(rng, arr)

    # Shuffle and take first n elements
    val (new_rng, shuffled) = shuffle(rng, arr)
    var result = []
    var i = 0
    while i < n:
        result.push(shuffled[i])
        i = i + 1

    (new_rng, result)

fn random_sample_with_replacement(rng, arr, n: i64):
    """Sample n random elements with replacement.

    Returns (new_rng_state, sample_array).

    Example:
        val (rng2, sample) = random_sample_with_replacement(rng, [1,2,3], 5)
    """
    var result = []
    var current_rng = rng

    var i = 0
    while i < n:
        val (new_rng, elem) = random_choice(current_rng, arr)
        current_rng = new_rng
        result.push(elem)
        i = i + 1

    (current_rng, result)

# ============================================================================
# Random Array Generation
# ============================================================================

fn random_array(rng, length: i64, max_val: i64):
    """Generate array of random integers.

    Example:
        val (rng2, arr) = random_array(rng, 10, 100)  # 10 values 0-99
    """
    var result = []
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, value) = random_int(current_rng, max_val)
        current_rng = new_rng
        result.push(value)
        i = i + 1

    (current_rng, result)

fn random_array_range(rng, length: i64, min_val: i64, max_val: i64):
    """Generate array of random integers in range.

    Example:
        val (rng2, arr) = random_array_range(rng, 10, 1, 7)  # Dice rolls
    """
    var result = []
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, value) = random_int_range(current_rng, min_val, max_val)
        current_rng = new_rng
        result.push(value)
        i = i + 1

    (current_rng, result)

fn random_permutation(rng, n: i64):
    """Generate random permutation of [0, n).

    Example:
        val (rng2, perm) = random_permutation(rng, 5)  # [2,0,4,1,3]
    """
    # Create sequential array
    var arr = []
    var i = 0
    while i < n:
        arr.push(i)
        i = i + 1

    # Shuffle
    shuffle(rng, arr)

fn random_subset(rng, n: i64, k: i64):
    """Generate random k-subset of [0, n).

    Example:
        val (rng2, subset) = random_subset(rng, 10, 3)
    """
    val (new_rng, perm) = random_permutation(rng, n)

    var result = []
    var i = 0
    while i < k and i < perm.len():
        result.push(perm[i])
        i = i + 1

    (new_rng, result)

# ============================================================================
# Weighted Random
# ============================================================================

fn weighted_choice(rng, items, weights):
    """Choose item based on weights.

    weights should be array of positive integers.
    Returns (new_rng_state, chosen_item).

    Example:
        val (rng2, item) = weighted_choice(rng, ['a', 'b', 'c'], [1, 2, 3])
    """
    # Calculate total weight
    var total = 0
    for w in weights:
        total = total + w

    # Pick random value
    val (new_rng, target) = rng_next_range(rng, 0, total)

    # Find item
    var cumulative = 0
    var i = 0
    while i < items.len():
        cumulative = cumulative + weights[i]
        if target < cumulative:
            return (new_rng, items[i])
        i = i + 1

    # Fallback (shouldn't happen)
    (new_rng, items[items.len() - 1])

# ============================================================================
# Distribution Sampling
# ============================================================================

fn random_uniform_int(rng, a: i64, b: i64):
    """Uniform distribution over [a, b].

    Example:
        val (rng2, val) = random_uniform_int(rng, 1, 6)  # Fair die
    """
    rng_next_range(rng, a, b + 1)

fn random_binomial(rng, n: i64, p_numerator: i64, p_denominator: i64):
    """Simple binomial distribution (n trials, p = p_numerator/p_denominator).

    Returns (new_rng_state, successes).

    Example:
        val (rng2, heads) = random_binomial(rng, 10, 1, 2)  # 10 coin flips
    """
    var successes = 0
    var current_rng = rng

    var i = 0
    while i < n:
        val (new_rng, value) = rng_next_range(current_rng, 0, p_denominator)
        current_rng = new_rng

        if value < p_numerator:
            successes = successes + 1

        i = i + 1

    (current_rng, successes)

fn random_geometric(rng, p_numerator: i64, p_denominator: i64):
    """Geometric distribution (number of trials until success).

    Returns (new_rng_state, trials).

    Example:
        val (rng2, rolls) = random_geometric(rng, 1, 6)  # Until 1 on die
    """
    var trials = 1
    var current_rng = rng

    while true:
        val (new_rng, value) = rng_next_range(current_rng, 0, p_denominator)
        current_rng = new_rng

        if value < p_numerator:
            break

        trials = trials + 1

    (current_rng, trials)

# ============================================================================
# Monte Carlo Utilities
# ============================================================================

fn monte_carlo_pi(rng, samples: i64, precision: i64):
    """Estimate π using Monte Carlo method.

    Returns (new_rng_state, pi_estimate_times_precision).
    Divide result by precision to get π estimate.

    Example:
        val (rng2, pi_x_1000) = monte_carlo_pi(rng, 10000, 1000)
        # pi_x_1000 / 1000 ≈ 3.14...
    """
    var inside = 0
    var current_rng = rng

    var i = 0
    while i < samples:
        val (rng1, x) = rng_next_range(current_rng, 0, precision)
        val (rng2, y) = rng_next_range(rng1, 0, precision)
        current_rng = rng2

        # Check if point is inside unit circle
        if x * x + y * y < precision * precision:
            inside = inside + 1

        i = i + 1

    # π ≈ 4 * (inside / samples)
    val estimate = (4 * inside * precision) / samples

    (current_rng, estimate)

fn monte_carlo_integration(rng, samples: i64, func, a: i64, b: i64, precision: i64):
    """Estimate integral using Monte Carlo.

    func should take scaled integer input.

    Returns (new_rng_state, integral_estimate_times_precision).
    """
    var sum = 0
    var current_rng = rng

    val range = b - a

    var i = 0
    while i < samples:
        val (new_rng, x_scaled) = rng_next_range(current_rng, a * precision, b * precision)
        current_rng = new_rng

        val y = func(x_scaled / precision)
        sum = sum + y

        i = i + 1

    val estimate = (sum * range) / samples

    (current_rng, estimate)

# ============================================================================
# Random String Generation
# ============================================================================

fn random_alphanumeric(rng, length: i64):
    """Generate random alphanumeric string.

    Returns (new_rng_state, string).

    Example:
        val (rng2, str) = random_alphanumeric(rng, 10)
    """
    val chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    var result = ""
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, idx) = rng_next_range(current_rng, 0, chars.len())
        current_rng = new_rng
        result = result + chars[idx]
        i = i + 1

    (current_rng, result)

fn random_string(rng, length: i64, alphabet: text):
    """Generate random string from alphabet.

    Example:
        val (rng2, dna) = random_string(rng, 20, "ACGT")
    """
    var result = ""
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, idx) = rng_next_range(current_rng, 0, alphabet.len())
        current_rng = new_rng
        result = result + alphabet[idx]
        i = i + 1

    (current_rng, result)

fn random_digit_string(rng, length: i64):
    """Generate random digit string.

    Example:
        val (rng2, pin) = random_digit_string(rng, 4)  # "1234"
    """
    random_string(rng, length, "0123456789")

fn random_hex_string(rng, length: i64):
    """Generate random hex string.

    Example:
        val (rng2, hex) = random_hex_string(rng, 8)  # "A3F2B1C4"
    """
    random_string(rng, length, "0123456789ABCDEF")

# ============================================================================
# Testing Utilities
# ============================================================================

fn random_test_data(rng, n: i64):
    """Generate random test data array.

    Returns (new_rng_state, test_array).

    Example:
        val (rng2, test) = random_test_data(rng, 100)
    """
    random_array(rng, n, 1000)

fn random_sorted_array(rng, n: i64, max_val: i64):
    """Generate random sorted array.

    Example:
        val (rng2, sorted) = random_sorted_array(rng, 10, 100)
    """
    val (new_rng, arr) = random_array(rng, n, max_val)

    # Simple insertion sort
    var result = arr
    var i = 1
    while i < result.len():
        val key = result[i]
        var j = i - 1

        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1

        result[j + 1] = key
        i = i + 1

    (new_rng, result)

fn is_random_enough(arr, expected_avg: i64, tolerance: i64):
    """Check if array is "random enough" (simple test).

    Checks if average is within tolerance of expected.

    Example:
        is_random_enough([1,2,3,4,5], 3, 1)  # true
    """
    var sum = 0
    for x in arr:
        sum = sum + x

    val avg = sum / arr.len()
    val diff = if avg > expected_avg: avg - expected_avg else: expected_avg - avg

    diff <= tolerance
