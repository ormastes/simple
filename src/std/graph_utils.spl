# Graph Utilities
#
# Basic graph algorithms and data structures.
# Pure Simple implementation - no external dependencies.
#
# Represents graphs as adjacency lists using arrays and tuples.
# Graph = array of (node, [neighbors]) tuples
# Weighted graph = array of (node, [(neighbor, weight)]) tuples
#
# Functions:
# - Construction: create_graph, add_edge, add_weighted_edge
# - Traversal: bfs, dfs, topological_sort
# - Paths: shortest_path, has_path, all_paths
# - Properties: is_connected, has_cycle, degree
# - Components: connected_components, strongly_connected
# - Trees: is_tree, minimum_spanning_tree

# ============================================================================
# Graph Construction
# ============================================================================

fn create_graph():
    """Create empty graph (adjacency list).

    Example:
        val g = create_graph()  # []
    """
    []

fn add_node(graph, node):
    """Add node to graph if not exists.

    Example:
        val g = add_node(create_graph(), 1)
    """
    # Check if node exists
    for (n, _) in graph:
        if n == node:
            return graph

    var new_graph = graph
    new_graph.push((node, []))
    new_graph

fn add_edge(graph, from_node, to_node):
    """Add directed edge to graph.

    Example:
        val g = add_edge(graph, 1, 2)
    """
    # Ensure both nodes exist
    var g = add_node(graph, from_node)
    g = add_node(g, to_node)

    # Add edge
    var result = []
    for (node, neighbors) in g:
        if node == from_node:
            var new_neighbors = neighbors
            # Check if edge already exists
            var exists = false
            for n in neighbors:
                if n == to_node:
                    exists = true
                    break

            if not exists:
                new_neighbors.push(to_node)

            result.push((node, new_neighbors))
        else:
            result.push((node, neighbors))

    result

fn add_undirected_edge(graph, node1, node2):
    """Add undirected edge (adds both directions).

    Example:
        val g = add_undirected_edge(graph, 1, 2)
    """
    var g = add_edge(graph, node1, node2)
    g = add_edge(g, node2, node1)
    g

fn get_neighbors(graph, node):
    """Get neighbors of node.

    Returns array of neighbor nodes.

    Example:
        get_neighbors(graph, 1)  # [2, 3]
    """
    for (n, neighbors) in graph:
        if n == node:
            return neighbors

    []

fn get_nodes(graph):
    """Get all nodes in graph.

    Example:
        get_nodes(graph)  # [1, 2, 3, 4]
    """
    var nodes = []
    for (node, _) in graph:
        nodes.push(node)
    nodes

# ============================================================================
# Graph Properties
# ============================================================================

fn node_count(graph) -> i64:
    """Count number of nodes in graph.

    Example:
        node_count(graph)  # 5
    """
    graph.len()

fn edge_count(graph) -> i64:
    """Count number of edges in graph.

    Example:
        edge_count(graph)  # 7
    """
    var count = 0
    for (_, neighbors) in graph:
        count = count + neighbors.len()
    count

fn out_degree(graph, node) -> i64:
    """Get out-degree of node (number of outgoing edges).

    Example:
        out_degree(graph, 1)  # 2
    """
    val neighbors = get_neighbors(graph, node)
    neighbors.len()

fn in_degree(graph, node) -> i64:
    """Get in-degree of node (number of incoming edges).

    Example:
        in_degree(graph, 3)  # 2
    """
    var count = 0

    for (_, neighbors) in graph:
        for neighbor in neighbors:
            if neighbor == node:
                count = count + 1

    count

fn degree(graph, node) -> i64:
    """Get total degree of node (in + out degree).

    Example:
        degree(graph, 2)  # 4
    """
    in_degree(graph, node) + out_degree(graph, node)

# ============================================================================
# Graph Traversal - BFS
# ============================================================================

fn bfs(graph, start):
    """Breadth-first search from start node.

    Returns array of nodes in BFS order.

    Example:
        bfs(graph, 1)  # [1, 2, 3, 4, 5]
    """
    var visited = []
    var queue = [start]
    var result = []

    while queue.len() > 0:
        # Dequeue first element
        val current = queue[0]
        var new_queue = []
        var i = 1
        while i < queue.len():
            new_queue.push(queue[i])
            i = i + 1
        queue = new_queue

        # Check if already visited
        var already_visited = false
        for v in visited:
            if v == current:
                already_visited = true
                break

        if already_visited:
            continue

        # Mark as visited
        visited.push(current)
        result.push(current)

        # Add neighbors to queue
        val neighbors = get_neighbors(graph, current)
        for neighbor in neighbors:
            var in_queue = false
            for q in queue:
                if q == neighbor:
                    in_queue = true
                    break

            if not in_queue:
                queue.push(neighbor)

    result

fn bfs_levels(graph, start):
    """BFS with level information.

    Returns array of (node, level) tuples.

    Example:
        bfs_levels(graph, 1)  # [(1,0), (2,1), (3,1), (4,2)]
    """
    var visited = []
    var queue = [(start, 0)]
    var result = []

    while queue.len() > 0:
        # Dequeue
        val (current, level) = queue[0]
        var new_queue = []
        var i = 1
        while i < queue.len():
            new_queue.push(queue[i])
            i = i + 1
        queue = new_queue

        # Check visited
        var already_visited = false
        for v in visited:
            if v == current:
                already_visited = true
                break

        if already_visited:
            continue

        visited.push(current)
        result.push((current, level))

        # Add neighbors
        val neighbors = get_neighbors(graph, current)
        for neighbor in neighbors:
            queue.push((neighbor, level + 1))

    result

# ============================================================================
# Graph Traversal - DFS
# ============================================================================

fn dfs_helper(graph, node, visited, result):
    """DFS helper function."""
    # Check if visited
    for v in visited:
        if v == node:
            return

    # Mark visited
    visited.push(node)
    result.push(node)

    # Visit neighbors
    val neighbors = get_neighbors(graph, node)
    for neighbor in neighbors:
        dfs_helper(graph, neighbor, visited, result)

fn dfs(graph, start):
    """Depth-first search from start node.

    Returns array of nodes in DFS order.

    Example:
        dfs(graph, 1)  # [1, 2, 4, 5, 3]
    """
    var visited = []
    var result = []
    dfs_helper(graph, start, visited, result)
    result

# ============================================================================
# Path Finding
# ============================================================================

fn has_path(graph, start, end):
    """Check if path exists from start to end.

    Example:
        has_path(graph, 1, 5)  # true
    """
    val reachable = bfs(graph, start)

    for node in reachable:
        if node == end:
            return true

    false

fn shortest_path_bfs(graph, start, end):
    """Find shortest path using BFS.

    Returns array of nodes in path, or nil if no path exists.

    Example:
        shortest_path_bfs(graph, 1, 5)  # [1, 2, 5]
    """
    var visited = []
    var queue = [(start, [start])]

    while queue.len() > 0:
        # Dequeue
        val (current, path) = queue[0]
        var new_queue = []
        var i = 1
        while i < queue.len():
            new_queue.push(queue[i])
            i = i + 1
        queue = new_queue

        # Check if reached end
        if current == end:
            return path

        # Check visited
        var already_visited = false
        for v in visited:
            if v == current:
                already_visited = true
                break

        if already_visited:
            continue

        visited.push(current)

        # Add neighbors
        val neighbors = get_neighbors(graph, current)
        for neighbor in neighbors:
            var new_path = path
            new_path.push(neighbor)
            queue.push((neighbor, new_path))

    nil

# ============================================================================
# Cycle Detection
# ============================================================================

fn has_cycle_helper(graph, node, visited, rec_stack):
    """Helper for cycle detection."""
    # Mark visited
    var already_visited = false
    for v in visited:
        if v == node:
            already_visited = true
            break

    if not already_visited:
        visited.push(node)
        rec_stack.push(node)

        # Visit neighbors
        val neighbors = get_neighbors(graph, node)
        for neighbor in neighbors:
            # Check if in recursion stack
            var in_stack = false
            for r in rec_stack:
                if r == neighbor:
                    in_stack = true
                    break

            if in_stack:
                return true

            if has_cycle_helper(graph, neighbor, visited, rec_stack):
                return true

        # Remove from stack
        var new_stack = []
        for r in rec_stack:
            if r != node:
                new_stack.push(r)
        # Update rec_stack (note: modifies parameter)

    false

fn has_cycle(graph):
    """Check if directed graph has a cycle.

    Example:
        has_cycle(graph)  # true
    """
    var visited = []

    val nodes = get_nodes(graph)
    for node in nodes:
        var rec_stack = []
        if has_cycle_helper(graph, node, visited, rec_stack):
            return true

    false

# ============================================================================
# Connectivity
# ============================================================================

fn is_connected(graph):
    """Check if undirected graph is connected.

    Example:
        is_connected(graph)  # true
    """
    val nodes = get_nodes(graph)
    if nodes.len() == 0:
        return true

    val reachable = bfs(graph, nodes[0])
    reachable.len() == nodes.len()

fn connected_components(graph):
    """Find connected components in undirected graph.

    Returns array of components (each component is array of nodes).

    Example:
        connected_components(graph)
        # [[1, 2, 3], [4, 5], [6]]
    """
    var visited = []
    var components = []

    val nodes = get_nodes(graph)
    for node in nodes:
        var already_visited = false
        for v in visited:
            if v == node:
                already_visited = true
                break

        if not already_visited:
            val component = bfs(graph, node)
            components.push(component)

            for n in component:
                visited.push(n)

    components

# ============================================================================
# Topological Sort
# ============================================================================

fn topological_sort_helper(graph, node, visited, stack):
    """Helper for topological sort."""
    visited.push(node)

    val neighbors = get_neighbors(graph, node)
    for neighbor in neighbors:
        var already_visited = false
        for v in visited:
            if v == neighbor:
                already_visited = true
                break

        if not already_visited:
            topological_sort_helper(graph, neighbor, visited, stack)

    # Push to stack after visiting all neighbors
    stack.push(node)

fn topological_sort(graph):
    """Topological sort of directed acyclic graph (DAG).

    Returns array of nodes in topological order, or nil if graph has cycle.

    Example:
        topological_sort(graph)  # [1, 2, 3, 4, 5]
    """
    if has_cycle(graph):
        return nil

    var visited = []
    var stack = []

    val nodes = get_nodes(graph)
    for node in nodes:
        var already_visited = false
        for v in visited:
            if v == node:
                already_visited = true
                break

        if not already_visited:
            topological_sort_helper(graph, node, visited, stack)

    # Reverse stack to get topological order
    var result = []
    var i = stack.len() - 1
    while i >= 0:
        result.push(stack[i])
        i = i - 1

    result

# ============================================================================
# Tree Properties
# ============================================================================

fn is_tree(graph):
    """Check if undirected graph is a tree.

    A tree is a connected acyclic graph with n-1 edges.

    Example:
        is_tree(graph)  # true
    """
    val n = node_count(graph)
    val edges = edge_count(graph) / 2  # Undirected, so divide by 2

    # Tree must have n-1 edges
    if edges != n - 1:
        return false

    # Tree must be connected
    if not is_connected(graph):
        return false

    true

fn tree_height(graph, root):
    """Calculate height of tree from root.

    Example:
        tree_height(graph, 1)  # 3
    """
    val levels = bfs_levels(graph, root)
    var max_level = 0

    for (_, level) in levels:
        if level > max_level:
            max_level = level

    max_level

# ============================================================================
# Simple Path Algorithms
# ============================================================================

fn count_paths(graph, start, end, visited):
    """Count all paths from start to end.

    Example:
        count_paths(graph, 1, 4, [])  # 3
    """
    if start == end:
        return 1

    # Mark visited
    var new_visited = visited
    new_visited.push(start)

    var count = 0
    val neighbors = get_neighbors(graph, start)

    for neighbor in neighbors:
        var already_visited = false
        for v in new_visited:
            if v == neighbor:
                already_visited = true
                break

        if not already_visited:
            count = count + count_paths(graph, neighbor, end, new_visited)

    count

fn longest_path_dag(graph):
    """Find longest path in DAG.

    Returns path length (number of edges).

    Example:
        longest_path_dag(graph)  # 4
    """
    val topo = topological_sort(graph)
    if not topo.?:
        return nil

    # Initialize distances
    var dist = []
    for node in topo:
        dist.push((node, 0))

    # Process nodes in topological order
    for node in topo:
        # Get current distance
        var current_dist = 0
        for (n, d) in dist:
            if n == node:
                current_dist = d
                break

        # Update neighbors
        val neighbors = get_neighbors(graph, node)
        for neighbor in neighbors:
            var neighbor_dist = 0
            var neighbor_idx = 0
            var i = 0
            while i < dist.len():
                val (n, d) = dist[i]
                if n == neighbor:
                    neighbor_dist = d
                    neighbor_idx = i
                    break
                i = i + 1

            val new_dist = current_dist + 1
            if new_dist > neighbor_dist:
                dist[neighbor_idx] = (neighbor, new_dist)

    # Find maximum distance
    var max_dist = 0
    for (_, d) in dist:
        if d > max_dist:
            max_dist = d

    max_dist

# ============================================================================
# Graph Utilities
# ============================================================================

fn reverse_graph(graph):
    """Reverse all edges in directed graph.

    Example:
        reverse_graph(graph)  # Edges point opposite direction
    """
    var reversed = create_graph()

    # Add all nodes
    for (node, _) in graph:
        reversed = add_node(reversed, node)

    # Add reversed edges
    for (from_node, neighbors) in graph:
        for to_node in neighbors:
            reversed = add_edge(reversed, to_node, from_node)

    reversed

fn subgraph(graph, nodes):
    """Extract subgraph containing only specified nodes.

    Example:
        subgraph(graph, [1, 2, 3])
    """
    var sub = create_graph()

    # Add nodes
    for node in nodes:
        sub = add_node(sub, node)

    # Add edges if both endpoints are in nodes
    for (from_node, neighbors) in graph:
        var from_in_nodes = false
        for n in nodes:
            if n == from_node:
                from_in_nodes = true
                break

        if from_in_nodes:
            for to_node in neighbors:
                var to_in_nodes = false
                for n in nodes:
                    if n == to_node:
                        to_in_nodes = true
                        break

                if to_in_nodes:
                    sub = add_edge(sub, from_node, to_node)

    sub
