# Graph Data Structure and Algorithms Module
# Comprehensive graph utilities with classic algorithms
# Uses tuple-based representations with i64 vertex IDs

# ============================================================================
# Core Data Structures
# ============================================================================
# Graph: (directed: bool, weighted: bool, num_vertices: i64, edges: list, adj_list: map)
# Edge: (from: i64, to: i64, weight: f64)
# AdjList: map<i64, list<(to: i64, weight: f64)>>

# Create an empty graph
fn graph_new(directed: bool, weighted: bool) -> tuple:
    (directed, weighted, 0, [], {})

# Create a graph with n vertices
fn graph_with_vertices(directed: bool, weighted: bool, n: i64) -> tuple:
    var adj_list = {}
    var i = 0
    while i < n:
        adj_list = adj_list.set(i, [])
        i = i + 1
    (directed, weighted, n, [], adj_list)

# Get number of vertices
fn graph_num_vertices(graph: tuple) -> i64:
    graph.2

# Get number of edges
fn graph_num_edges(graph: tuple) -> i64:
    graph.3.len()

# Check if graph is directed
fn graph_is_directed(graph: tuple) -> bool:
    graph.0

# Check if graph is weighted
fn graph_is_weighted(graph: tuple) -> bool:
    graph.1

# Get all edges
fn graph_edges(graph: tuple) -> list:
    graph.3

# Get adjacency list
fn graph_adj_list(graph: tuple) -> map:
    graph.4

# ============================================================================
# Graph Construction Operations
# ============================================================================

# Add a vertex to the graph
fn graph_add_vertex(graph: tuple) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    adj_list = adj_list.set(num_vertices, [])
    (directed, weighted, num_vertices + 1, edges, adj_list)

# Add an edge to the graph
fn graph_add_edge(graph: tuple, from: i64, to: i64, weight: f64) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    # Ensure vertices exist
    var max_vertex = from
    if to > max_vertex:
        max_vertex = to

    while num_vertices <= max_vertex:
        adj_list = adj_list.set(num_vertices, [])
        num_vertices = num_vertices + 1

    # Add edge to edge list
    var edge = (from, to, weight)
    edges = edges.append(edge)

    # Update adjacency list
    var from_neighbors = adj_list.get(from)
    from_neighbors = from_neighbors.append((to, weight))
    adj_list = adj_list.set(from, from_neighbors)

    # If undirected, add reverse edge
    if !directed:
        var to_neighbors = adj_list.get(to)
        to_neighbors = to_neighbors.append((from, weight))
        adj_list = adj_list.set(to, to_neighbors)

    (directed, weighted, num_vertices, edges, adj_list)

# Add an unweighted edge (weight = 1.0)
fn graph_add_edge_unweighted(graph: tuple, from: i64, to: i64) -> tuple:
    graph_add_edge(graph, from, to, 1.0)

# Remove a vertex from the graph
fn graph_remove_vertex(graph: tuple, vertex: i64) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    # Remove all edges involving this vertex
    var new_edges = []
    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var from = edge.0
        var to = edge.1
        if from != vertex && to != vertex:
            new_edges = new_edges.append(edge)
        i = i + 1

    # Rebuild adjacency list
    var new_adj_list = {}
    var v = 0
    while v < num_vertices:
        if v != vertex:
            var neighbors = adj_list.get(v)
            var filtered_neighbors = []
            var j = 0
            while j < neighbors.len():
                var neighbor = neighbors.get(j)
                if neighbor.0 != vertex:
                    filtered_neighbors = filtered_neighbors.append(neighbor)
                j = j + 1
            new_adj_list = new_adj_list.set(v, filtered_neighbors)
        v = v + 1

    (directed, weighted, num_vertices, new_edges, new_adj_list)

# Remove an edge from the graph
fn graph_remove_edge(graph: tuple, from: i64, to: i64) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    # Remove from edge list
    var new_edges = []
    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var edge_from = edge.0
        var edge_to = edge.1
        var keep = true
        if edge_from == from && edge_to == to:
            keep = false
        if !directed && edge_from == to && edge_to == from:
            keep = false
        if keep:
            new_edges = new_edges.append(edge)
        i = i + 1

    # Remove from adjacency list
    var from_neighbors = adj_list.get(from)
    var new_from_neighbors = []
    var j = 0
    while j < from_neighbors.len():
        var neighbor = from_neighbors.get(j)
        if neighbor.0 != to:
            new_from_neighbors = new_from_neighbors.append(neighbor)
        j = j + 1
    adj_list = adj_list.set(from, new_from_neighbors)

    if !directed:
        var to_neighbors = adj_list.get(to)
        var new_to_neighbors = []
        var k = 0
        while k < to_neighbors.len():
            var neighbor = to_neighbors.get(k)
            if neighbor.0 != from:
                new_to_neighbors = new_to_neighbors.append(neighbor)
            k = k + 1
        adj_list = adj_list.set(to, new_to_neighbors)

    (directed, weighted, num_vertices, new_edges, adj_list)

# Get neighbors of a vertex
fn graph_neighbors(graph: tuple, vertex: i64) -> list:
    var adj_list = graph.4
    var neighbors = adj_list.get(vertex)
    if neighbors == nil:
        []
    else:
        neighbors

# Get degree of a vertex (out-degree for directed graphs)
fn graph_degree(graph: tuple, vertex: i64) -> i64:
    var neighbors = graph_neighbors(graph, vertex)
    neighbors.len()

# Get in-degree of a vertex (for directed graphs)
fn graph_in_degree(graph: tuple, vertex: i64) -> i64:
    var count = 0
    var adj_list = graph.4
    var num_vertices = graph.2
    var i = 0
    while i < num_vertices:
        var neighbors = adj_list.get(i)
        if neighbors != nil:
            var j = 0
            while j < neighbors.len():
                var neighbor = neighbors.get(j)
                if neighbor.0 == vertex:
                    count = count + 1
                j = j + 1
        i = i + 1
    count

# Get out-degree of a vertex (for directed graphs)
fn graph_out_degree(graph: tuple, vertex: i64) -> i64:
    graph_degree(graph, vertex)

# ============================================================================
# Graph Conversions
# ============================================================================

# Convert adjacency list to adjacency matrix
fn graph_to_matrix(graph: tuple) -> list:
    var num_vertices = graph.2
    var adj_list = graph.4
    var matrix = []

    var i = 0
    while i < num_vertices:
        var row = []
        var j = 0
        while j < num_vertices:
            row = row.append(0.0)
            j = j + 1
        matrix = matrix.append(row)
        i = i + 1

    # Fill matrix with edge weights
    var k = 0
    while k < num_vertices:
        var neighbors = adj_list.get(k)
        if neighbors != nil:
            var m = 0
            while m < neighbors.len():
                var neighbor = neighbors.get(m)
                var to = neighbor.0
                var weight = neighbor.1
                var row = matrix.get(k)
                row = row.set(to, weight)
                matrix = matrix.set(k, row)
                m = m + 1
        k = k + 1

    matrix

# Create graph from adjacency matrix
fn graph_from_matrix(matrix: list, directed: bool, weighted: bool) -> tuple:
    var n = matrix.len()
    var graph = graph_with_vertices(directed, weighted, n)

    var i = 0
    while i < n:
        var row = matrix.get(i)
        var j = 0
        while j < row.len():
            var weight = row.get(j)
            if weight != 0.0:
                graph = graph_add_edge(graph, i, j, weight)
            j = j + 1
        i = i + 1

    graph

# ============================================================================
# Graph Traversal: DFS (Depth-First Search)
# ============================================================================

# DFS traversal starting from a vertex (returns visited list)
fn graph_dfs(graph: tuple, start: i64) -> list:
    var visited = []
    var stack = [start]
    var visited_set = {}

    while stack.len() > 0:
        var vertex = stack.get(stack.len() - 1)
        stack = stack.slice(0, stack.len() - 1)

        var is_visited = visited_set.get(vertex)
        if is_visited == nil:
            visited = visited.append(vertex)
            visited_set = visited_set.set(vertex, true)

            var neighbors = graph_neighbors(graph, vertex)
            var i = neighbors.len() - 1
            while i >= 0:
                var neighbor = neighbors.get(i)
                stack = stack.append(neighbor.0)
                i = i - 1

    visited

# DFS with pre-order and post-order callbacks (returns (pre_order, post_order))
fn graph_dfs_with_order(graph: tuple, start: i64) -> tuple:
    var pre_order = []
    var post_order = []
    var visited_set = {}
    var stack = [(start, false)]

    while stack.len() > 0:
        var item = stack.get(stack.len() - 1)
        stack = stack.slice(0, stack.len() - 1)
        var vertex = item.0
        var post = item.1

        if post:
            post_order = post_order.append(vertex)
        else:
            var is_visited = visited_set.get(vertex)
            if is_visited == nil:
                visited_set = visited_set.set(vertex, true)
                pre_order = pre_order.append(vertex)
                stack = stack.append((vertex, true))

                var neighbors = graph_neighbors(graph, vertex)
                var i = neighbors.len() - 1
                while i >= 0:
                    var neighbor = neighbors.get(i)
                    stack = stack.append((neighbor.0, false))
                    i = i - 1

    (pre_order, post_order)

# DFS for all vertices (handles disconnected graphs)
fn graph_dfs_all(graph: tuple) -> list:
    var visited_set = {}
    var all_visited = []
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        var is_visited = visited_set.get(i)
        if is_visited == nil:
            var component = graph_dfs(graph, i)
            var j = 0
            while j < component.len():
                var vertex = component.get(j)
                visited_set = visited_set.set(vertex, true)
                all_visited = all_visited.append(vertex)
                j = j + 1
        i = i + 1

    all_visited

# ============================================================================
# Graph Traversal: BFS (Breadth-First Search)
# ============================================================================

# BFS traversal starting from a vertex (returns visited list)
fn graph_bfs(graph: tuple, start: i64) -> list:
    var visited = []
    var queue = [start]
    var visited_set = {}
    visited_set = visited_set.set(start, true)

    while queue.len() > 0:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())
        visited = visited.append(vertex)

        var neighbors = graph_neighbors(graph, vertex)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var is_visited = visited_set.get(neighbor_id)
            if is_visited == nil:
                visited_set = visited_set.set(neighbor_id, true)
                queue = queue.append(neighbor_id)
            i = i + 1

    visited

# BFS with distance tracking (returns map<vertex, distance>)
fn graph_bfs_distances(graph: tuple, start: i64) -> map:
    var distances = {}
    var queue = [start]
    distances = distances.set(start, 0)

    while queue.len() > 0:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())
        var current_dist = distances.get(vertex)

        var neighbors = graph_neighbors(graph, vertex)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var has_dist = distances.get(neighbor_id)
            if has_dist == nil:
                distances = distances.set(neighbor_id, current_dist + 1)
                queue = queue.append(neighbor_id)
            i = i + 1

    distances

# BFS for shortest path (unweighted graphs)
fn graph_bfs_shortest_path(graph: tuple, start: i64, end: i64) -> list:
    var parent = {}
    var queue = [start]
    var visited = {}
    visited = visited.set(start, true)
    parent = parent.set(start, -1)

    var found = false
    while queue.len() > 0 && !found:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())

        if vertex == end:
            found = true
        else:
            var neighbors = graph_neighbors(graph, vertex)
            var i = 0
            while i < neighbors.len():
                var neighbor = neighbors.get(i)
                var neighbor_id = neighbor.0
                var is_visited = visited.get(neighbor_id)
                if is_visited == nil:
                    visited = visited.set(neighbor_id, true)
                    parent = parent.set(neighbor_id, vertex)
                    queue = queue.append(neighbor_id)
                i = i + 1

    if !found:
        return []

    # Reconstruct path
    var path = []
    var current = end
    while current != -1:
        path = [current].concat(path)
        current = parent.get(current)

    path

# ============================================================================
# Shortest Path Algorithms
# ============================================================================

# Dijkstra's algorithm (single-source shortest path for non-negative weights)
# Returns map<vertex, distance>
fn graph_dijkstra(graph: tuple, start: i64) -> map:
    var distances = {}
    var visited = {}
    var num_vertices = graph.2

    # Initialize distances
    var i = 0
    while i < num_vertices:
        distances = distances.set(i, 999999999.0)
        i = i + 1
    distances = distances.set(start, 0.0)

    var remaining = num_vertices
    while remaining > 0:
        # Find unvisited vertex with minimum distance
        var min_dist = 999999999.0
        var min_vertex = -1
        var j = 0
        while j < num_vertices:
            var is_visited = visited.get(j)
            if is_visited == nil:
                var dist = distances.get(j)
                if dist < min_dist:
                    min_dist = dist
                    min_vertex = j
            j = j + 1

        if min_vertex == -1:
            break

        visited = visited.set(min_vertex, true)
        remaining = remaining - 1

        # Update distances to neighbors
        var neighbors = graph_neighbors(graph, min_vertex)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var weight = neighbor.1
            var current_dist = distances.get(min_vertex)
            var neighbor_dist = distances.get(neighbor_id)
            var new_dist = current_dist + weight
            if new_dist < neighbor_dist:
                distances = distances.set(neighbor_id, new_dist)
            k = k + 1

    distances

# Dijkstra's algorithm with path reconstruction
# Returns (distances: map, parents: map)
fn graph_dijkstra_with_paths(graph: tuple, start: i64) -> tuple:
    var distances = {}
    var parents = {}
    var visited = {}
    var num_vertices = graph.2

    # Initialize
    var i = 0
    while i < num_vertices:
        distances = distances.set(i, 999999999.0)
        parents = parents.set(i, -1)
        i = i + 1
    distances = distances.set(start, 0.0)

    var remaining = num_vertices
    while remaining > 0:
        # Find minimum
        var min_dist = 999999999.0
        var min_vertex = -1
        var j = 0
        while j < num_vertices:
            var is_visited = visited.get(j)
            if is_visited == nil:
                var dist = distances.get(j)
                if dist < min_dist:
                    min_dist = dist
                    min_vertex = j
            j = j + 1

        if min_vertex == -1:
            break

        visited = visited.set(min_vertex, true)
        remaining = remaining - 1

        # Update neighbors
        var neighbors = graph_neighbors(graph, min_vertex)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var weight = neighbor.1
            var current_dist = distances.get(min_vertex)
            var neighbor_dist = distances.get(neighbor_id)
            var new_dist = current_dist + weight
            if new_dist < neighbor_dist:
                distances = distances.set(neighbor_id, new_dist)
                parents = parents.set(neighbor_id, min_vertex)
            k = k + 1

    (distances, parents)

# Reconstruct path from Dijkstra's parents map
fn graph_reconstruct_path(parents: map, start: i64, end: i64) -> list:
    var path = []
    var current = end

    while current != -1:
        path = [current].concat(path)
        if current == start:
            break
        current = parents.get(current)

    if path.len() > 0 && path.get(0) != start:
        []
    else:
        path

# Bellman-Ford algorithm (handles negative weights, detects negative cycles)
# Returns (distances: map, has_negative_cycle: bool)
fn graph_bellman_ford(graph: tuple, start: i64) -> tuple:
    var num_vertices = graph.2
    var edges = graph.3
    var distances = {}

    # Initialize distances
    var i = 0
    while i < num_vertices:
        distances = distances.set(i, 999999999.0)
        i = i + 1
    distances = distances.set(start, 0.0)

    # Relax edges V-1 times
    var round = 0
    while round < num_vertices - 1:
        var j = 0
        while j < edges.len():
            var edge = edges.get(j)
            var from = edge.0
            var to = edge.1
            var weight = edge.2
            var from_dist = distances.get(from)
            var to_dist = distances.get(to)
            var new_dist = from_dist + weight
            if from_dist != 999999999.0 && new_dist < to_dist:
                distances = distances.set(to, new_dist)
            j = j + 1
        round = round + 1

    # Check for negative cycles
    var has_negative_cycle = false
    var k = 0
    while k < edges.len():
        var edge = edges.get(k)
        var from = edge.0
        var to = edge.1
        var weight = edge.2
        var from_dist = distances.get(from)
        var to_dist = distances.get(to)
        var new_dist = from_dist + weight
        if from_dist != 999999999.0 && new_dist < to_dist:
            has_negative_cycle = true
        k = k + 1

    (distances, has_negative_cycle)

# Floyd-Warshall algorithm (all-pairs shortest paths)
# Returns matrix of distances
fn graph_floyd_warshall(graph: tuple) -> list:
    var num_vertices = graph.2
    var matrix = graph_to_matrix(graph)

    # Initialize with infinity for non-edges
    var i = 0
    while i < num_vertices:
        var row = matrix.get(i)
        var j = 0
        while j < num_vertices:
            if i != j:
                var val = row.get(j)
                if val == 0.0:
                    row = row.set(j, 999999999.0)
            j = j + 1
        matrix = matrix.set(i, row)
        i = i + 1

    # Floyd-Warshall iterations
    var k = 0
    while k < num_vertices:
        var m = 0
        while m < num_vertices:
            var row_m = matrix.get(m)
            var n = 0
            while n < num_vertices:
                var dist_mn = row_m.get(n)
                var dist_mk = row_m.get(k)
                var row_k = matrix.get(k)
                var dist_kn = row_k.get(n)
                var new_dist = dist_mk + dist_kn
                if new_dist < dist_mn:
                    row_m = row_m.set(n, new_dist)
                n = n + 1
            matrix = matrix.set(m, row_m)
            m = m + 1
        k = k + 1

    matrix

# ============================================================================
# Minimum Spanning Tree Algorithms
# ============================================================================

# Kruskal's algorithm (MST using union-find)
# Returns list of edges in MST
fn graph_kruskal(graph: tuple) -> list:
    var edges = graph.3
    var num_vertices = graph.2

    # Sort edges by weight (simple bubble sort)
    var sorted_edges = edges
    var n = sorted_edges.len()
    var swapped = true
    while swapped:
        swapped = false
        var i = 1
        while i < n:
            var e1 = sorted_edges.get(i - 1)
            var e2 = sorted_edges.get(i)
            if e1.2 > e2.2:
                sorted_edges = sorted_edges.set(i - 1, e2)
                sorted_edges = sorted_edges.set(i, e1)
                swapped = true
            i = i + 1
        n = n - 1

    # Union-Find data structures
    var parent = {}
    var rank = {}
    var j = 0
    while j < num_vertices:
        parent = parent.set(j, j)
        rank = rank.set(j, 0)
        j = j + 1

    # Find with path compression
    fn find(x: i64) -> i64:
        var p = parent.get(x)
        if p != x:
            p = find(p)
            parent = parent.set(x, p)
        p

    # Union by rank
    fn union(x: i64, y: i64) -> bool:
        var root_x = find(x)
        var root_y = find(y)

        if root_x == root_y:
            return false

        var rank_x = rank.get(root_x)
        var rank_y = rank.get(root_y)

        if rank_x < rank_y:
            parent = parent.set(root_x, root_y)
        else:
            if rank_x > rank_y:
                parent = parent.set(root_y, root_x)
            else:
                parent = parent.set(root_y, root_x)
                rank = rank.set(root_x, rank_x + 1)

        true

    # Kruskal's algorithm
    var mst = []
    var k = 0
    while k < sorted_edges.len() && mst.len() < num_vertices - 1:
        var edge = sorted_edges.get(k)
        var from = edge.0
        var to = edge.1

        if union(from, to):
            mst = mst.append(edge)

        k = k + 1

    mst

# Prim's algorithm (MST using priority queue simulation)
# Returns list of edges in MST
fn graph_prim(graph: tuple, start: i64) -> list:
    var mst = []
    var visited = {}
    var num_vertices = graph.2

    visited = visited.set(start, true)
    var visited_count = 1

    while visited_count < num_vertices:
        # Find minimum edge from visited to unvisited vertices
        var min_weight = 999999999.0
        var min_edge = nil

        var i = 0
        while i < num_vertices:
            var is_visited = visited.get(i)
            if is_visited != nil:
                var neighbors = graph_neighbors(graph, i)
                var j = 0
                while j < neighbors.len():
                    var neighbor = neighbors.get(j)
                    var neighbor_id = neighbor.0
                    var weight = neighbor.1
                    var neighbor_visited = visited.get(neighbor_id)
                    if neighbor_visited == nil && weight < min_weight:
                        min_weight = weight
                        min_edge = (i, neighbor_id, weight)
                    j = j + 1
            i = i + 1

        if min_edge == nil:
            break

        mst = mst.append(min_edge)
        visited = visited.set(min_edge.1, true)
        visited_count = visited_count + 1

    mst

# ============================================================================
# Connectivity Algorithms
# ============================================================================

# Find connected components (for undirected graphs)
# Returns list of components (each component is a list of vertices)
fn graph_connected_components(graph: tuple) -> list:
    var visited = {}
    var components = []
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        var is_visited = visited.get(i)
        if is_visited == nil:
            var component = graph_dfs(graph, i)
            components = components.append(component)
            var j = 0
            while j < component.len():
                visited = visited.set(component.get(j), true)
                j = j + 1
        i = i + 1

    components

# Check if graph is connected (for undirected graphs)
fn graph_is_connected(graph: tuple) -> bool:
    var num_vertices = graph.2
    if num_vertices == 0:
        return true

    var visited = graph_dfs(graph, 0)
    visited.len() == num_vertices

# Strongly connected components using Kosaraju's algorithm (for directed graphs)
# Returns list of SCCs (each SCC is a list of vertices)
fn graph_strongly_connected_components(graph: tuple) -> list:
    var num_vertices = graph.2

    # First DFS to get finish times
    var visited = {}
    var stack = []

    var i = 0
    while i < num_vertices:
        var is_visited = visited.get(i)
        if is_visited == nil:
            var orders = graph_dfs_with_order(graph, i)
            var post_order = orders.1
            var j = 0
            while j < post_order.len():
                var vertex = post_order.get(j)
                var already_visited = visited.get(vertex)
                if already_visited == nil:
                    stack = stack.append(vertex)
                    visited = visited.set(vertex, true)
                j = j + 1
        i = i + 1

    # Reverse the graph
    var reversed_graph = graph_reverse(graph)

    # Second DFS on reversed graph in stack order
    var visited2 = {}
    var sccs = []

    var k = stack.len() - 1
    while k >= 0:
        var vertex = stack.get(k)
        var is_visited2 = visited2.get(vertex)
        if is_visited2 == nil:
            var scc = graph_dfs(reversed_graph, vertex)
            sccs = sccs.append(scc)
            var m = 0
            while m < scc.len():
                visited2 = visited2.set(scc.get(m), true)
                m = m + 1
        k = k - 1

    sccs

# Reverse a directed graph
fn graph_reverse(graph: tuple) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3

    var reversed = graph_with_vertices(directed, weighted, num_vertices)

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var from = edge.0
        var to = edge.1
        var weight = edge.2
        reversed = graph_add_edge(reversed, to, from, weight)
        i = i + 1

    reversed

# Check if there's a path between two vertices
fn graph_has_path(graph: tuple, start: i64, end: i64) -> bool:
    var visited = graph_dfs(graph, start)
    var i = 0
    while i < visited.len():
        if visited.get(i) == end:
            return true
        i = i + 1
    false

# ============================================================================
# Cycle Detection
# ============================================================================

# Detect cycle in undirected graph
fn graph_has_cycle_undirected(graph: tuple) -> bool:
    var visited = {}
    var num_vertices = graph.2

    fn dfs_cycle(vertex: i64, parent: i64) -> bool:
        visited = visited.set(vertex, true)

        var neighbors = graph_neighbors(graph, vertex)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var is_visited = visited.get(neighbor_id)

            if is_visited == nil:
                if dfs_cycle(neighbor_id, vertex):
                    return true
            else:
                if neighbor_id != parent:
                    return true

            i = i + 1

        false

    var j = 0
    while j < num_vertices:
        var is_visited = visited.get(j)
        if is_visited == nil:
            if dfs_cycle(j, -1):
                return true
        j = j + 1

    false

# Detect cycle in directed graph using DFS with colors
fn graph_has_cycle_directed(graph: tuple) -> bool:
    var white = 0
    var gray = 1
    var black = 2
    var color = {}
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        color = color.set(i, white)
        i = i + 1

    fn dfs_cycle_directed(vertex: i64) -> bool:
        color = color.set(vertex, gray)

        var neighbors = graph_neighbors(graph, vertex)
        var j = 0
        while j < neighbors.len():
            var neighbor = neighbors.get(j)
            var neighbor_id = neighbor.0
            var neighbor_color = color.get(neighbor_id)

            if neighbor_color == gray:
                return true

            if neighbor_color == white:
                if dfs_cycle_directed(neighbor_id):
                    return true

            j = j + 1

        color = color.set(vertex, black)
        false

    var k = 0
    while k < num_vertices:
        var vertex_color = color.get(k)
        if vertex_color == white:
            if dfs_cycle_directed(k):
                return true
        k = k + 1

    false

# Check if graph is cyclic (works for both directed and undirected)
fn graph_is_cyclic(graph: tuple) -> bool:
    var directed = graph.0
    if directed:
        graph_has_cycle_directed(graph)
    else:
        graph_has_cycle_undirected(graph)

# ============================================================================
# Topological Sort
# ============================================================================

# Topological sort (for DAGs - Directed Acyclic Graphs)
# Returns list of vertices in topological order, or empty list if cycle exists
fn graph_topological_sort(graph: tuple) -> list:
    if graph_has_cycle_directed(graph):
        return []

    var visited = {}
    var stack = []
    var num_vertices = graph.2

    fn dfs_topo(vertex: i64) -> bool:
        visited = visited.set(vertex, true)

        var neighbors = graph_neighbors(graph, vertex)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var is_visited = visited.get(neighbor_id)
            if is_visited == nil:
                dfs_topo(neighbor_id)
            i = i + 1

        stack = [vertex].concat(stack)
        true

    var j = 0
    while j < num_vertices:
        var is_visited = visited.get(j)
        if is_visited == nil:
            dfs_topo(j)
        j = j + 1

    stack

# Kahn's algorithm for topological sort (using in-degrees)
fn graph_topological_sort_kahn(graph: tuple) -> list:
    var num_vertices = graph.2
    var in_degree = {}

    # Calculate in-degrees
    var i = 0
    while i < num_vertices:
        in_degree = in_degree.set(i, 0)
        i = i + 1

    var j = 0
    while j < num_vertices:
        var neighbors = graph_neighbors(graph, j)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var deg = in_degree.get(neighbor_id)
            in_degree = in_degree.set(neighbor_id, deg + 1)
            k = k + 1
        j = j + 1

    # Queue vertices with in-degree 0
    var queue = []
    var m = 0
    while m < num_vertices:
        if in_degree.get(m) == 0:
            queue = queue.append(m)
        m = m + 1

    var result = []
    while queue.len() > 0:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())
        result = result.append(vertex)

        var neighbors = graph_neighbors(graph, vertex)
        var n = 0
        while n < neighbors.len():
            var neighbor = neighbors.get(n)
            var neighbor_id = neighbor.0
            var deg = in_degree.get(neighbor_id)
            deg = deg - 1
            in_degree = in_degree.set(neighbor_id, deg)
            if deg == 0:
                queue = queue.append(neighbor_id)
            n = n + 1

    if result.len() != num_vertices:
        []
    else:
        result

# ============================================================================
# Graph Properties
# ============================================================================

# Check if graph is bipartite (2-colorable)
fn graph_is_bipartite(graph: tuple) -> bool:
    var num_vertices = graph.2
    var color = {}

    fn bfs_bipartite(start: i64) -> bool:
        var queue = [start]
        color = color.set(start, 0)

        while queue.len() > 0:
            var vertex = queue.get(0)
            queue = queue.slice(1, queue.len())
            var vertex_color = color.get(vertex)

            var neighbors = graph_neighbors(graph, vertex)
            var i = 0
            while i < neighbors.len():
                var neighbor = neighbors.get(i)
                var neighbor_id = neighbor.0
                var neighbor_color = color.get(neighbor_id)

                if neighbor_color == nil:
                    var new_color = 0
                    if vertex_color == 0:
                        new_color = 1
                    color = color.set(neighbor_id, new_color)
                    queue = queue.append(neighbor_id)
                else:
                    if neighbor_color == vertex_color:
                        return false

                i = i + 1

        true

    var j = 0
    while j < num_vertices:
        var has_color = color.get(j)
        if has_color == nil:
            if !bfs_bipartite(j):
                return false
        j = j + 1

    true

# Check if graph is a tree (connected acyclic undirected graph)
fn graph_is_tree(graph: tuple) -> bool:
    var num_vertices = graph.2
    var num_edges = graph.3.len()

    if graph.0:
        return false

    if num_edges != num_vertices - 1:
        return false

    graph_is_connected(graph) && !graph_has_cycle_undirected(graph)

# Check if graph is a DAG (Directed Acyclic Graph)
fn graph_is_dag(graph: tuple) -> bool:
    graph.0 && !graph_has_cycle_directed(graph)

# Get all vertices with no incoming edges (sources)
fn graph_sources(graph: tuple) -> list:
    var sources = []
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        if graph_in_degree(graph, i) == 0:
            sources = sources.append(i)
        i = i + 1

    sources

# Get all vertices with no outgoing edges (sinks)
fn graph_sinks(graph: tuple) -> list:
    var sinks = []
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        if graph_out_degree(graph, i) == 0:
            sinks = sinks.append(i)
        i = i + 1

    sinks

# Calculate graph density (ratio of actual edges to maximum possible edges)
fn graph_density(graph: tuple) -> f64:
    var num_vertices = graph.2
    var num_edges = graph.3.len()

    if num_vertices <= 1:
        return 0.0

    var max_edges = 0.0
    if graph.0:
        max_edges = (num_vertices * (num_vertices - 1)) as f64
    else:
        max_edges = (num_vertices * (num_vertices - 1) / 2) as f64

    (num_edges as f64) / max_edges

# ============================================================================
# Utility Functions
# ============================================================================

# Print graph structure (for debugging)
fn graph_print(graph: tuple) -> text:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3

    var result = "Graph("
    if directed:
        result = result + "directed"
    else:
        result = result + "undirected"

    if weighted:
        result = result + ", weighted"
    else:
        result = result + ", unweighted"

    result = result + ", vertices: {num_vertices}, edges: {edges.len()})\n"

    var i = 0
    while i < num_vertices:
        result = result + "  {i}: "
        var neighbors = graph_neighbors(graph, i)
        var j = 0
        while j < neighbors.len():
            var neighbor = neighbors.get(j)
            result = result + "{neighbor.0}"
            if weighted:
                result = result + "({neighbor.1})"
            if j < neighbors.len() - 1:
                result = result + ", "
            j = j + 1
        result = result + "\n"
        i = i + 1

    result

# Clone a graph
fn graph_clone(graph: tuple) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3

    var new_graph = graph_with_vertices(directed, weighted, num_vertices)

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        new_graph = graph_add_edge(new_graph, edge.0, edge.1, edge.2)
        i = i + 1

    new_graph

# Get edge weight between two vertices
fn graph_edge_weight(graph: tuple, from: i64, to: i64) -> f64:
    var neighbors = graph_neighbors(graph, from)
    var i = 0
    while i < neighbors.len():
        var neighbor = neighbors.get(i)
        if neighbor.0 == to:
            return neighbor.1
        i = i + 1
    999999999.0

# Check if edge exists
fn graph_has_edge(graph: tuple, from: i64, to: i64) -> bool:
    var neighbors = graph_neighbors(graph, from)
    var i = 0
    while i < neighbors.len():
        var neighbor = neighbors.get(i)
        if neighbor.0 == to:
            return true
        i = i + 1
    false

# Get total weight of all edges in graph
fn graph_total_weight(graph: tuple) -> f64:
    var edges = graph.3
    var total = 0.0
    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        total = total + edge.2
        i = i + 1
    total

# Get number of self-loops
fn graph_self_loops(graph: tuple) -> i64:
    var edges = graph.3
    var count = 0
    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        if edge.0 == edge.1:
            count = count + 1
        i = i + 1
    count

# ============================================================================
# Advanced Path Algorithms
# ============================================================================

# Find all simple paths between two vertices using DFS
fn graph_all_paths(graph: tuple, start: i64, end: i64) -> list:
    var all_paths = []

    fn dfs_paths(current: i64, target: i64, path: list, visited: map) -> bool:
        var new_path = path.append(current)
        var new_visited = visited.set(current, true)

        if current == target:
            all_paths = all_paths.append(new_path)
            return true

        var neighbors = graph_neighbors(graph, current)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var is_visited = new_visited.get(neighbor_id)
            if is_visited == nil:
                dfs_paths(neighbor_id, target, new_path, new_visited)
            i = i + 1

        true

    dfs_paths(start, end, [], {})
    all_paths

# Count all paths between two vertices
fn graph_count_paths(graph: tuple, start: i64, end: i64) -> i64:
    var paths = graph_all_paths(graph, start, end)
    paths.len()

# Find longest path in DAG
fn graph_longest_path_dag(graph: tuple) -> i64:
    var topo = graph_topological_sort(graph)
    if topo.len() == 0:
        return 0

    var distances = {}
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        distances = distances.set(i, 0)
        i = i + 1

    var j = 0
    while j < topo.len():
        var vertex = topo.get(j)
        var current_dist = distances.get(vertex)
        var neighbors = graph_neighbors(graph, vertex)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var neighbor_dist = distances.get(neighbor_id)
            var new_dist = current_dist + 1
            if new_dist > neighbor_dist:
                distances = distances.set(neighbor_id, new_dist)
            k = k + 1
        j = j + 1

    # Find maximum distance
    var max_dist = 0
    var m = 0
    while m < num_vertices:
        var dist = distances.get(m)
        if dist > max_dist:
            max_dist = dist
        m = m + 1

    max_dist

# ============================================================================
# Graph Metrics and Analysis
# ============================================================================

# Calculate average degree
fn graph_avg_degree(graph: tuple) -> f64:
    var num_vertices = graph.2
    if num_vertices == 0:
        return 0.0

    var total_degree = 0
    var i = 0
    while i < num_vertices:
        total_degree = total_degree + graph_degree(graph, i)
        i = i + 1

    (total_degree as f64) / (num_vertices as f64)

# Find vertex with maximum degree
fn graph_max_degree_vertex(graph: tuple) -> i64:
    var num_vertices = graph.2
    var max_degree = -1
    var max_vertex = -1

    var i = 0
    while i < num_vertices:
        var degree = graph_degree(graph, i)
        if degree > max_degree:
            max_degree = degree
            max_vertex = i
        i = i + 1

    max_vertex

# Find vertex with minimum degree
fn graph_min_degree_vertex(graph: tuple) -> i64:
    var num_vertices = graph.2
    var min_degree = 999999999
    var min_vertex = -1

    var i = 0
    while i < num_vertices:
        var degree = graph_degree(graph, i)
        if degree < min_degree:
            min_degree = degree
            min_vertex = i
        i = i + 1

    min_vertex

# Calculate diameter of graph (longest shortest path)
fn graph_diameter(graph: tuple) -> i64:
    var num_vertices = graph.2
    var max_distance = 0

    var i = 0
    while i < num_vertices:
        var distances = graph_bfs_distances(graph, i)
        var j = 0
        while j < num_vertices:
            var dist = distances.get(j)
            if dist != nil:
                if dist > max_distance:
                    max_distance = dist
            j = j + 1
        i = i + 1

    max_distance

# Calculate radius of graph (minimum eccentricity)
fn graph_radius(graph: tuple) -> i64:
    var num_vertices = graph.2
    var min_eccentricity = 999999999

    var i = 0
    while i < num_vertices:
        var distances = graph_bfs_distances(graph, i)
        var max_dist = 0
        var j = 0
        while j < num_vertices:
            var dist = distances.get(j)
            if dist != nil:
                if dist > max_dist:
                    max_dist = dist
            j = j + 1

        if max_dist < min_eccentricity:
            min_eccentricity = max_dist

        i = i + 1

    min_eccentricity

# Calculate eccentricity of a vertex
fn graph_eccentricity(graph: tuple, vertex: i64) -> i64:
    var distances = graph_bfs_distances(graph, vertex)
    var num_vertices = graph.2
    var max_dist = 0

    var i = 0
    while i < num_vertices:
        var dist = distances.get(i)
        if dist != nil:
            if dist > max_dist:
                max_dist = dist
        i = i + 1

    max_dist

# Find center vertices (vertices with minimum eccentricity)
fn graph_center(graph: tuple) -> list:
    var num_vertices = graph.2
    var radius = graph_radius(graph)
    var center = []

    var i = 0
    while i < num_vertices:
        var ecc = graph_eccentricity(graph, i)
        if ecc == radius:
            center = center.append(i)
        i = i + 1

    center

# Find periphery vertices (vertices with maximum eccentricity)
fn graph_periphery(graph: tuple) -> list:
    var num_vertices = graph.2
    var diameter = graph_diameter(graph)
    var periphery = []

    var i = 0
    while i < num_vertices:
        var ecc = graph_eccentricity(graph, i)
        if ecc == diameter:
            periphery = periphery.append(i)
        i = i + 1

    periphery

# ============================================================================
# Graph Coloring
# ============================================================================

# Greedy graph coloring algorithm
# Returns map<vertex, color>
fn graph_greedy_coloring(graph: tuple) -> map:
    var num_vertices = graph.2
    var colors = {}

    var i = 0
    while i < num_vertices:
        # Find smallest available color
        var neighbor_colors = {}
        var neighbors = graph_neighbors(graph, i)
        var j = 0
        while j < neighbors.len():
            var neighbor = neighbors.get(j)
            var neighbor_id = neighbor.0
            var neighbor_color = colors.get(neighbor_id)
            if neighbor_color != nil:
                neighbor_colors = neighbor_colors.set(neighbor_color, true)
            j = j + 1

        # Find first available color
        var color = 0
        while neighbor_colors.get(color) != nil:
            color = color + 1

        colors = colors.set(i, color)
        i = i + 1

    colors

# Get chromatic number (number of colors needed)
fn graph_chromatic_number(graph: tuple) -> i64:
    var coloring = graph_greedy_coloring(graph)
    var num_vertices = graph.2
    var max_color = -1

    var i = 0
    while i < num_vertices:
        var color = coloring.get(i)
        if color != nil:
            if color > max_color:
                max_color = color
        i = i + 1

    max_color + 1

# ============================================================================
# Special Graph Structures
# ============================================================================

# Create complete graph with n vertices
fn graph_complete(n: i64, directed: bool) -> tuple:
    var graph = graph_with_vertices(directed, false, n)

    var i = 0
    while i < n:
        var j = 0
        while j < n:
            if i != j:
                graph = graph_add_edge_unweighted(graph, i, j)
            j = j + 1
        i = i + 1

    graph

# Create cycle graph with n vertices
fn graph_cycle(n: i64, directed: bool) -> tuple:
    var graph = graph_with_vertices(directed, false, n)

    var i = 0
    while i < n:
        var next = (i + 1) % n
        graph = graph_add_edge_unweighted(graph, i, next)
        i = i + 1

    graph

# Create path graph with n vertices
fn graph_path(n: i64, directed: bool) -> tuple:
    var graph = graph_with_vertices(directed, false, n)

    var i = 0
    while i < n - 1:
        graph = graph_add_edge_unweighted(graph, i, i + 1)
        i = i + 1

    graph

# Create star graph with n vertices (1 center + n-1 leaves)
fn graph_star(n: i64, directed: bool) -> tuple:
    var graph = graph_with_vertices(directed, false, n)

    var i = 1
    while i < n:
        graph = graph_add_edge_unweighted(graph, 0, i)
        i = i + 1

    graph

# Create wheel graph (cycle + center connected to all)
fn graph_wheel(n: i64, directed: bool) -> tuple:
    var graph = graph_with_vertices(directed, false, n + 1)

    # Create cycle
    var i = 1
    while i <= n:
        var next = (i % n) + 1
        graph = graph_add_edge_unweighted(graph, i, next)
        i = i + 1

    # Connect center to all
    var j = 1
    while j <= n:
        graph = graph_add_edge_unweighted(graph, 0, j)
        j = j + 1

    graph

# ============================================================================
# Bridges and Articulation Points
# ============================================================================

# Find bridges (edges whose removal increases number of components)
fn graph_find_bridges(graph: tuple) -> list:
    var bridges = []
    var edges = graph.3

    var original_components = graph_connected_components(graph)
    var original_count = original_components.len()

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var temp_graph = graph_remove_edge(graph, edge.0, edge.1)
        var new_components = graph_connected_components(temp_graph)
        var new_count = new_components.len()

        if new_count > original_count:
            bridges = bridges.append(edge)

        i = i + 1

    bridges

# Find articulation points (vertices whose removal increases components)
fn graph_find_articulation_points(graph: tuple) -> list:
    var articulation_points = []
    var num_vertices = graph.2

    var original_components = graph_connected_components(graph)
    var original_count = original_components.len()

    var i = 0
    while i < num_vertices:
        var temp_graph = graph_remove_vertex(graph, i)
        var new_components = graph_connected_components(temp_graph)
        var new_count = new_components.len()

        if new_count > original_count:
            articulation_points = articulation_points.append(i)

        i = i + 1

    articulation_points

# ============================================================================
# Graph Isomorphism and Comparison
# ============================================================================

# Check if two graphs have same number of vertices and edges
fn graph_same_size(g1: tuple, g2: tuple) -> bool:
    var v1 = graph_num_vertices(g1)
    var v2 = graph_num_vertices(g2)
    var e1 = graph_num_edges(g1)
    var e2 = graph_num_edges(g2)

    v1 == v2 && e1 == e2

# Get degree sequence (sorted list of all vertex degrees)
fn graph_degree_sequence(graph: tuple) -> list:
    var num_vertices = graph.2
    var degrees = []

    var i = 0
    while i < num_vertices:
        var degree = graph_degree(graph, i)
        degrees = degrees.append(degree)
        i = i + 1

    # Sort degrees (bubble sort)
    var n = degrees.len()
    var swapped = true
    while swapped:
        swapped = false
        var j = 1
        while j < n:
            var d1 = degrees.get(j - 1)
            var d2 = degrees.get(j)
            if d1 > d2:
                degrees = degrees.set(j - 1, d2)
                degrees = degrees.set(j, d1)
                swapped = true
            j = j + 1
        n = n - 1

    degrees

# ============================================================================
# Eulerian and Hamiltonian Properties
# ============================================================================

# Check if graph has Eulerian path (path visiting every edge once)
fn graph_has_eulerian_path(graph: tuple) -> bool:
    if graph.0:
        # Directed graph
        var num_vertices = graph.2
        var in_degree_diff = 0
        var out_degree_diff = 0

        var i = 0
        while i < num_vertices:
            var in_deg = graph_in_degree(graph, i)
            var out_deg = graph_out_degree(graph, i)
            if in_deg != out_deg:
                if in_deg == out_deg + 1:
                    in_degree_diff = in_degree_diff + 1
                else:
                    if out_deg == in_deg + 1:
                        out_degree_diff = out_degree_diff + 1
                    else:
                        return false
            i = i + 1

        in_degree_diff <= 1 && out_degree_diff <= 1
    else:
        # Undirected graph
        var num_vertices = graph.2
        var odd_degree_count = 0

        var j = 0
        while j < num_vertices:
            var degree = graph_degree(graph, j)
            if degree % 2 == 1:
                odd_degree_count = odd_degree_count + 1
            j = j + 1

        odd_degree_count == 0 || odd_degree_count == 2

# Check if graph has Eulerian circuit (cycle visiting every edge once)
fn graph_has_eulerian_circuit(graph: tuple) -> bool:
    if !graph_is_connected(graph):
        return false

    if graph.0:
        # Directed graph: all vertices must have equal in and out degree
        var num_vertices = graph.2
        var i = 0
        while i < num_vertices:
            if graph_in_degree(graph, i) != graph_out_degree(graph, i):
                return false
            i = i + 1
        true
    else:
        # Undirected graph: all vertices must have even degree
        var num_vertices = graph.2
        var j = 0
        while j < num_vertices:
            var degree = graph_degree(graph, j)
            if degree % 2 == 1:
                return false
            j = j + 1
        true

# ============================================================================
# Graph Transformation and Complement
# ============================================================================

# Get complement graph (edges that don't exist in original)
fn graph_complement(graph: tuple) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2

    var complement = graph_with_vertices(directed, weighted, num_vertices)

    var i = 0
    while i < num_vertices:
        var j = 0
        while j < num_vertices:
            if i != j:
                if !graph_has_edge(graph, i, j):
                    complement = graph_add_edge_unweighted(complement, i, j)
            j = j + 1
        i = i + 1

    complement

# Create induced subgraph from vertex set
fn graph_induced_subgraph(graph: tuple, vertices: list) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var n = vertices.len()

    var vertex_map = {}
    var i = 0
    while i < n:
        vertex_map = vertex_map.set(vertices.get(i), i)
        i = i + 1

    var subgraph = graph_with_vertices(directed, weighted, n)

    var j = 0
    while j < n:
        var v = vertices.get(j)
        var neighbors = graph_neighbors(graph, v)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var weight = neighbor.1
            var neighbor_index = vertex_map.get(neighbor_id)
            if neighbor_index != nil:
                subgraph = graph_add_edge(subgraph, j, neighbor_index, weight)
            k = k + 1
        j = j + 1

    subgraph

# ============================================================================
# Graph Union and Operations
# ============================================================================

# Union of two graphs (combine vertices and edges)
fn graph_union(g1: tuple, g2: tuple) -> tuple:
    var directed = g1.0
    var weighted = g1.1
    var n1 = graph_num_vertices(g1)
    var n2 = graph_num_vertices(g2)

    var union_graph = graph_with_vertices(directed, weighted, n1 + n2)

    # Add edges from g1
    var edges1 = graph_edges(g1)
    var i = 0
    while i < edges1.len():
        var edge = edges1.get(i)
        union_graph = graph_add_edge(union_graph, edge.0, edge.1, edge.2)
        i = i + 1

    # Add edges from g2 (offset vertex IDs by n1)
    var edges2 = graph_edges(g2)
    var j = 0
    while j < edges2.len():
        var edge = edges2.get(j)
        union_graph = graph_add_edge(union_graph, edge.0 + n1, edge.1 + n1, edge.2)
        j = j + 1

    union_graph

# ============================================================================
# Minimum Cut and Flow (Basic)
# ============================================================================

# Find minimum cut using BFS (returns capacity of min cut)
fn graph_min_cut_bfs(graph: tuple, source: i64, sink: i64) -> f64:
    var num_vertices = graph.2

    # Check if path exists
    if !graph_has_path(graph, source, sink):
        return 0.0

    # Simple approach: find minimum edge weight on any path
    var min_capacity = 999999999.0
    var path = graph_bfs_shortest_path(graph, source, sink)

    var i = 0
    while i < path.len() - 1:
        var from = path.get(i)
        var to = path.get(i + 1)
        var weight = graph_edge_weight(graph, from, to)
        if weight < min_capacity:
            min_capacity = weight
        i = i + 1

    min_capacity

# ============================================================================
# Additional Utility Functions
# ============================================================================

# Get all isolated vertices (vertices with degree 0)
fn graph_isolated_vertices(graph: tuple) -> list:
    var isolated = []
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        if graph_degree(graph, i) == 0:
            isolated = isolated.append(i)
        i = i + 1

    isolated

# Check if graph is regular (all vertices have same degree)
fn graph_is_regular(graph: tuple) -> bool:
    var num_vertices = graph.2
    if num_vertices == 0:
        return true

    var first_degree = graph_degree(graph, 0)
    var i = 1
    while i < num_vertices:
        if graph_degree(graph, i) != first_degree:
            return false
        i = i + 1

    true

# Get regularity degree (if regular, return common degree; else -1)
fn graph_regularity(graph: tuple) -> i64:
    if graph_is_regular(graph):
        var num_vertices = graph.2
        if num_vertices > 0:
            return graph_degree(graph, 0)
    -1

# Check if graph is simple (no self-loops or multiple edges)
fn graph_is_simple(graph: tuple) -> bool:
    # Check for self-loops
    if graph_self_loops(graph) > 0:
        return false

    # Check for multiple edges (same pair appears twice)
    var edges = graph.3
    var seen = {}

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var from = edge.0
        var to = edge.1
        var key = "{from}_{to}"
        var already_seen = seen.get(key)
        if already_seen != nil:
            return false
        seen = seen.set(key, true)
        i = i + 1

    true

# Export graph to edge list format (list of (from, to, weight) tuples)
fn graph_to_edge_list(graph: tuple) -> list:
    graph.3

# Create graph from edge list
fn graph_from_edge_list(edges: list, directed: bool, weighted: bool) -> tuple:
    var graph = graph_new(directed, weighted)

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        graph = graph_add_edge(graph, edge.0, edge.1, edge.2)
        i = i + 1

    graph

# Get subgraph containing only edges with weight >= threshold
fn graph_filter_by_weight(graph: tuple, threshold: f64) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3

    var filtered = graph_with_vertices(directed, weighted, num_vertices)

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        if edge.2 >= threshold:
            filtered = graph_add_edge(filtered, edge.0, edge.1, edge.2)
        i = i + 1

    filtered

# Count triangles in undirected graph
fn graph_count_triangles(graph: tuple) -> i64:
    var num_vertices = graph.2
    var count = 0

    var i = 0
    while i < num_vertices:
        var neighbors_i = graph_neighbors(graph, i)
        var j = 0
        while j < neighbors_i.len():
            var neighbor_j = neighbors_i.get(j)
            var vertex_j = neighbor_j.0

            if vertex_j > i:
                var neighbors_j = graph_neighbors(graph, vertex_j)
                var k = 0
                while k < neighbors_j.len():
                    var neighbor_k = neighbors_j.get(k)
                    var vertex_k = neighbor_k.0

                    if vertex_k > vertex_j:
                        if graph_has_edge(graph, i, vertex_k):
                            count = count + 1
                    k = k + 1
            j = j + 1
        i = i + 1

    count

# Calculate clustering coefficient for a vertex
fn graph_clustering_coefficient(graph: tuple, vertex: i64) -> f64:
    var neighbors = graph_neighbors(graph, vertex)
    var k = neighbors.len()

    if k < 2:
        return 0.0

    var edges_between = 0
    var i = 0
    while i < k:
        var neighbor_i = neighbors.get(i)
        var vertex_i = neighbor_i.0
        var j = i + 1
        while j < k:
            var neighbor_j = neighbors.get(j)
            var vertex_j = neighbor_j.0
            if graph_has_edge(graph, vertex_i, vertex_j):
                edges_between = edges_between + 1
            j = j + 1
        i = i + 1

    var max_edges = (k * (k - 1)) / 2
    (edges_between as f64) / (max_edges as f64)

# Calculate average clustering coefficient
fn graph_avg_clustering_coefficient(graph: tuple) -> f64:
    var num_vertices = graph.2
    if num_vertices == 0:
        return 0.0

    var total = 0.0
    var i = 0
    while i < num_vertices:
        total = total + graph_clustering_coefficient(graph, i)
        i = i + 1

    total / (num_vertices as f64)
