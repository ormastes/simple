# Template Engine Utilities Module
# Comprehensive text templating system for Simple language
#
# Features:
# - Variable interpolation: {{variable}}, {{object.property}}
# - Conditionals: {{#if condition}}...{{else}}...{{/if}}
# - Loops: {{#each items}}...{{/each}} with {{@index}}, {{@key}}
# - Partials: {{> partial_name}} for reusable fragments
# - Helpers: {{helper arg1 arg2}} custom functions
# - Comments: {{! comment }}, {{!-- block --}}
# - Escaping: HTML by default, {{{raw}}} for unescaped
# - Whitespace: {{~variable~}} trim whitespace
# - Context: ../parent access, nested contexts
# - Block helpers: {{#with context}}...{{/with}}
#
# Pure Simple implementation - no generics, no try/catch, tuple-based AST

import string

# ============================================================================
# DATA STRUCTURES (Tuple-based, no generics)
# ============================================================================

# Token: (type, value, position)
fn make_token(ttype: text, value: text, pos: i64) -> [text]:
    [ttype, value, "{pos}"]

fn token_type(token: [text]) -> text:
    token[0]

fn token_value(token: [text]) -> text:
    token[1]

fn token_pos(token: [text]) -> i64:
    parse_i64_safe(token[2])

# AST Node: (node_type, data1, data2, data3)
fn make_node(ntype: text, d1: text, d2: text, d3: text) -> [text]:
    [ntype, d1, d2, d3]

fn node_type(node: [text]) -> text:
    node[0]

fn node_data1(node: [text]) -> text:
    node[1]

fn node_data2(node: [text]) -> text:
    node[2]

fn node_data3(node: [text]) -> text:
    node[3]

# Context: list of (key, value) pairs
fn make_context() -> [[text]]:
    []

fn ctx_set(ctx: [[text]], key: text, val: text) -> [[text]]:
    var result = ctx
    result.push([key, val])
    result

fn ctx_get(ctx: [[text]], key: text) -> text?:
    var i = ctx.len() - 1
    while i >= 0:
        val entry = ctx[i]
        if entry[0] == key:
            return entry[1]
        i = i - 1
    nil

fn ctx_has(ctx: [[text]], key: text) -> bool:
    var i = 0
    while i < ctx.len():
        if ctx[i][0] == key:
            return true
        i = i + 1
    false

fn ctx_clone(ctx: [[text]]) -> [[text]]:
    var result: [[text]] = []
    for entry in ctx:
        result.push([entry[0], entry[1]])
    result

# Partials registry: list of (name, compiled_template) pairs
fn make_registry() -> [[text]]:
    []

fn reg_add(registry: [[text]], name: text, template: text) -> [[text]]:
    var result = registry
    result.push([name, template])
    result

fn reg_get(registry: [[text]], name: text) -> text?:
    for entry in registry:
        if entry[0] == name:
            return entry[1]
    nil

# ============================================================================
# CHARACTER AND STRING UTILITIES
# ============================================================================

fn is_whitespace_char(c: text) -> bool:
    c == " " or c == "\t" or c == "\n" or c == "\r"

fn is_alpha_char(c: text) -> bool:
    val code = char_code(c)
    (code >= 65 and code <= 90) or (code >= 97 and code <= 122)

fn is_digit_char(c: text) -> bool:
    val code = char_code(c)
    code >= 48 and code <= 57

fn is_alnum_char(c: text) -> bool:
    is_alpha_char(c) or is_digit_char(c)

fn char_at_safe(s: text, idx: i64) -> text:
    if idx < 0 or idx >= s.len():
        return ""
    s[idx:idx+1]

fn substr_safe(s: text, start: i64, end_val: i64) -> text:
    var s_val = start
    var e_val = end_val
    if s_val < 0:
        s_val = 0
    if e_val > s.len():
        e_val = s.len()
    if s_val >= e_val:
        return ""
    s[s_val:e_val]

fn str_index_of(haystack: text, needle: text) -> i64:
    val h_len = haystack.len()
    val n_len = needle.len()
    if n_len == 0 or n_len > h_len:
        return -1
    var i = 0
    while i <= h_len - n_len:
        var match = true
        var j = 0
        while j < n_len:
            if haystack[i+j:i+j+1] != needle[j:j+1]:
                match = false
                j = n_len
            j = j + 1
        if match:
            return i
        i = i + 1
    -1

fn str_contains(haystack: text, needle: text) -> bool:
    str_index_of(haystack, needle) >= 0

fn str_starts_with(s: text, prefix: text) -> bool:
    val p_len = prefix.len()
    if s.len() < p_len:
        return false
    s[0:p_len] == prefix

fn str_ends_with(s: text, suffix: text) -> bool:
    val s_len = s.len()
    val suf_len = suffix.len()
    if s_len < suf_len:
        return false
    s[s_len - suf_len:s_len] == suffix

fn str_trim(s: text) -> text:
    var result = s
    while result.len() > 0 and is_whitespace_char(result[0:1]):
        result = result[1:]
    while result.len() > 0 and is_whitespace_char(result[result.len()-1:result.len()]):
        result = result[0:result.len()-1]
    result

fn str_trim_left(s: text) -> text:
    var result = s
    while result.len() > 0 and is_whitespace_char(result[0:1]):
        result = result[1:]
    result

fn str_trim_right(s: text) -> text:
    var result = s
    while result.len() > 0 and is_whitespace_char(result[result.len()-1:result.len()]):
        result = result[0:result.len()-1]
    result

fn str_split(s: text, delim: text) -> [text]:
    var result: [text] = []
    val s_len = s.len()
    val d_len = delim.len()
    if d_len == 0:
        result.push(s)
        return result
    var start = 0
    var i = 0
    while i <= s_len - d_len:
        var match = true
        var j = 0
        while j < d_len:
            if s[i+j:i+j+1] != delim[j:j+1]:
                match = false
                j = d_len
            j = j + 1
        if match:
            result.push(s[start:i])
            i = i + d_len
            start = i
        else:
            i = i + 1
    result.push(s[start:s_len])
    result

fn str_replace_all(s: text, old: text, new_val: text) -> text:
    val parts = str_split(s, old)
    join_strs(parts, new_val)

fn str_to_lower(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        if code >= 65 and code <= 90:
            result = result + char_from_code(code + 32)
        else:
            result = result + c
        i = i + 1
    result

fn str_to_upper(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        if code >= 97 and code <= 122:
            result = result + char_from_code(code - 32)
        else:
            result = result + c
        i = i + 1
    result

fn str_capitalize(s: text) -> text:
    if s.len() == 0:
        return s
    val first = str_to_upper(s[0:1])
    val rest = s[1:]
    first + rest

fn str_reverse(s: text) -> text:
    var result = ""
    var i = s.len() - 1
    while i >= 0:
        result = result + s[i:i+1]
        i = i - 1
    result

fn str_repeat(s: text, count: i64) -> text:
    var result = ""
    var i = 0
    while i < count:
        result = result + s
        i = i + 1
    result

fn str_truncate(s: text, max_len: i64) -> text:
    if s.len() <= max_len:
        return s
    s[0:max_len] + "..."

fn str_pad_left(s: text, width: i64, pad: text) -> text:
    var result = s
    while result.len() < width:
        result = pad + result
    result

fn str_pad_right(s: text, width: i64, pad: text) -> text:
    var result = s
    while result.len() < width:
        result = result + pad
    result

fn str_center(s: text, width: i64) -> text:
    if s.len() >= width:
        return s
    val padding = width - s.len()
    val left = padding / 2
    val right = padding - left
    str_repeat(" ", left) + s + str_repeat(" ", right)

fn int_to_str(n: i64) -> text:
    if n == 0:
        return "0"
    var is_neg = false
    var num = n
    if num < 0:
        is_neg = true
        num = -num
    var result = ""
    while num > 0:
        val digit = num % 10
        result = char_from_code(48 + digit) + result
        num = num / 10
    if is_neg:
        result = "-" + result
    result

fn str_to_int(s: text) -> i64:
    parse_i64_safe(s)

# ============================================================================
# HTML ESCAPING
# ============================================================================

fn html_escape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "&", "&amp;")
    result = str_replace_all(result, "<", "&lt;")
    result = str_replace_all(result, ">", "&gt;")
    result = str_replace_all(result, "\"", "&quot;")
    result = str_replace_all(result, "'", "&#39;")
    result

fn html_unescape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "&lt;", "<")
    result = str_replace_all(result, "&gt;", ">")
    result = str_replace_all(result, "&quot;", "\"")
    result = str_replace_all(result, "&#39;", "'")
    result = str_replace_all(result, "&amp;", "&")
    result

fn url_encode(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        val is_safe = is_alnum_char(c) or c == "-" or c == "_" or c == "." or c == "~"
        if is_safe:
            result = result + c
        else:
            result = result + "%" + int_to_hex_str(code)
        i = i + 1
    result

fn url_decode(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        if c == "%":
            if i + 2 < s.len():
                val hex = s[i+1:i+3]
                val code = hex_str_to_int(hex)
                result = result + char_from_code(code)
                i = i + 3
            else:
                result = result + c
                i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn js_escape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "\\", "\\\\")
    result = str_replace_all(result, "\"", "\\\"")
    result = str_replace_all(result, "'", "\\'")
    result = str_replace_all(result, "\n", "\\n")
    result = str_replace_all(result, "\r", "\\r")
    result = str_replace_all(result, "\t", "\\t")
    result

fn css_escape(s: text) -> text:
    var result = s
    result = str_replace_all(result, "\"", "\\\"")
    result = str_replace_all(result, "'", "\\'")
    result

fn int_to_hex_str(n: i64) -> text:
    if n == 0:
        return "00"
    var result = ""
    var num = n
    while num > 0:
        val digit = num % 16
        if digit < 10:
            result = char_from_code(48 + digit) + result
        else:
            result = char_from_code(65 + digit - 10) + result
        num = num / 16
    if result.len() == 1:
        result = "0" + result
    result

fn hex_str_to_int(s: text) -> i64:
    var result = 0
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        val code = char_code(c)
        var digit = 0
        if code >= 48 and code <= 57:
            digit = code - 48
        else:
            if code >= 65 and code <= 70:
                digit = code - 65 + 10
            else:
                if code >= 97 and code <= 102:
                    digit = code - 97 + 10
        result = result * 16 + digit
        i = i + 1
    result

# ============================================================================
# TOKENIZER
# ============================================================================

fn tokenize(template: text) -> [[text]]:
    var tokens: [[text]] = []
    var pos = 0
    val len = template.len()

    while pos < len:
        # Check for {{
        if pos + 1 < len:
            val c1 = char_at_safe(template, pos)
            val c2 = char_at_safe(template, pos + 1)
            if c1 == "{" and c2 == "{":
                # Check for {{{
                if pos + 2 < len:
                    val c3 = char_at_safe(template, pos + 2)
                    if c3 == "{":
                        tokens.push(make_token("RAW_VAR_OPEN", "{{{", pos))
                        pos = pos + 3
                    else:
                        # Check for {{! or {{!--
                        if c3 == "!":
                            if pos + 3 < len:
                                val c4 = char_at_safe(template, pos + 3)
                                if c4 == "-":
                                    if pos + 4 < len:
                                        val c5 = char_at_safe(template, pos + 4)
                                        if c5 == "-":
                                            tokens.push(make_token("COMMENT_OPEN", "{{!--", pos))
                                            pos = pos + 5
                                        else:
                                            tokens.push(make_token("COMMENT_OPEN", "{{!", pos))
                                            pos = pos + 3
                                    else:
                                        tokens.push(make_token("COMMENT_OPEN", "{{!", pos))
                                        pos = pos + 3
                                else:
                                    tokens.push(make_token("COMMENT_OPEN", "{{!", pos))
                                    pos = pos + 3
                            else:
                                tokens.push(make_token("COMMENT_OPEN", "{{!", pos))
                                pos = pos + 3
                        else:
                            # Check for {{# or {{/ or {{> or {{~
                            if c3 == "#":
                                tokens.push(make_token("BLOCK_OPEN", "{{#", pos))
                                pos = pos + 3
                            else:
                                if c3 == "/":
                                    tokens.push(make_token("BLOCK_CLOSE", "{{/", pos))
                                    pos = pos + 3
                                else:
                                    if c3 == ">":
                                        tokens.push(make_token("PARTIAL", "{{>", pos))
                                        pos = pos + 3
                                    else:
                                        if c3 == "~":
                                            tokens.push(make_token("VAR_OPEN_TRIM", "{{~", pos))
                                            pos = pos + 3
                                        else:
                                            tokens.push(make_token("VAR_OPEN", "{{", pos))
                                            pos = pos + 2
                else:
                    tokens.push(make_token("VAR_OPEN", "{{", pos))
                    pos = pos + 2
            else:
                # Check for }}
                if c1 == "}" and c2 == "}":
                    # Check for }}}
                    if pos + 2 < len:
                        val c3 = char_at_safe(template, pos + 2)
                        if c3 == "}":
                            tokens.push(make_token("RAW_VAR_CLOSE", "}}}", pos))
                            pos = pos + 3
                        else:
                            # Check for ~}}
                            if pos > 0:
                                val prev = char_at_safe(template, pos - 1)
                                if prev == "~":
                                    tokens.push(make_token("VAR_CLOSE_TRIM", "~}}", pos))
                                    pos = pos + 2
                                else:
                                    tokens.push(make_token("VAR_CLOSE", "}}", pos))
                                    pos = pos + 2
                            else:
                                tokens.push(make_token("VAR_CLOSE", "}}", pos))
                                pos = pos + 2
                    else:
                        tokens.push(make_token("VAR_CLOSE", "}}", pos))
                        pos = pos + 2
                else:
                    # Check for --}}
                    if c1 == "-" and c2 == "-":
                        if pos + 3 < len:
                            val c3 = char_at_safe(template, pos + 2)
                            val c4 = char_at_safe(template, pos + 3)
                            if c3 == "}" and c4 == "}":
                                tokens.push(make_token("COMMENT_CLOSE", "--}}", pos))
                                pos = pos + 4
                            else:
                                tokens.push(make_token("TEXT", c1, pos))
                                pos = pos + 1
                        else:
                            tokens.push(make_token("TEXT", c1, pos))
                            pos = pos + 1
                    else:
                        # Regular text - collect until next special
                        var text_start = pos
                        var text_end = pos
                        while text_end < len:
                            val tc = char_at_safe(template, text_end)
                            val is_special = tc == "{" or tc == "}"
                            if is_special:
                                text_end = len
                            else:
                                text_end = text_end + 1
                        if text_end > text_start:
                            val text = substr_safe(template, text_start, text_end)
                            tokens.push(make_token("TEXT", text, text_start))
                        pos = text_end
        else:
            # Single character at end
            val c = char_at_safe(template, pos)
            tokens.push(make_token("TEXT", c, pos))
            pos = pos + 1

    tokens

# ============================================================================
# EXPRESSION PARSING
# ============================================================================

fn parse_expr(expr: text) -> [text]:
    val trimmed = str_trim(expr)
    # For now, simple variable path parsing
    # Returns [type, name, arg1, arg2]
    if str_contains(trimmed, "."):
        # Property access
        val parts = str_split(trimmed, ".")
        if parts.len() >= 2:
            return make_node("PATH", parts[0], parts[1], "")
    make_node("VAR", trimmed, "", "")

fn parse_block_expr(expr: text) -> [text]:
    val trimmed = str_trim(expr)
    val parts = str_split(trimmed, " ")
    if parts.len() > 0:
        val cmd = parts[0]
        if parts.len() > 1:
            return make_node("BLOCK", cmd, parts[1], "")
        return make_node("BLOCK", cmd, "", "")
    make_node("BLOCK", "", "", "")

# ============================================================================
# PARSER
# ============================================================================

fn parse(tokens: [[text]]) -> [[text]]:
    var nodes: [[text]] = []
    var i = 0
    val len = tokens.len()

    while i < len:
        val tok = tokens[i]
        val ttype = token_type(tok)
        val tval = token_value(tok)

        if ttype == "TEXT":
            nodes.push(make_node("TEXT", tval, "", ""))
            i = i + 1
        else:
            if ttype == "VAR_OPEN" or ttype == "VAR_OPEN_TRIM":
                # Find closing }}
                var j = i + 1
                var content = ""
                while j < len:
                    val t = tokens[j]
                    val tt = token_type(t)
                    if tt == "VAR_CLOSE" or tt == "VAR_CLOSE_TRIM":
                        j = len
                    else:
                        content = content + token_value(t)
                        j = j + 1
                nodes.push(make_node("VAR", str_trim(content), "", ""))
                i = j + 1
            else:
                if ttype == "RAW_VAR_OPEN":
                    # Find closing }}}
                    var j = i + 1
                    var content = ""
                    while j < len:
                        val t = tokens[j]
                        if token_type(t) == "RAW_VAR_CLOSE":
                            j = len
                        else:
                            content = content + token_value(t)
                            j = j + 1
                    nodes.push(make_node("RAW_VAR", str_trim(content), "", ""))
                    i = j + 1
                else:
                    if ttype == "BLOCK_OPEN":
                        # Parse block {{#if}}, {{#each}}, etc.
                        var j = i + 1
                        var content = ""
                        while j < len:
                            val t = tokens[j]
                            if token_type(t) == "VAR_CLOSE":
                                j = len
                            else:
                                content = content + token_value(t)
                                j = j + 1
                        val block_info = parse_block_expr(content)
                        nodes.push(block_info)
                        i = j + 1
                    else:
                        if ttype == "BLOCK_CLOSE":
                            # {{/if}}, {{/each}}
                            var j = i + 1
                            var content = ""
                            while j < len:
                                val t = tokens[j]
                                if token_type(t) == "VAR_CLOSE":
                                    j = len
                                else:
                                    content = content + token_value(t)
                                    j = j + 1
                            nodes.push(make_node("END_BLOCK", str_trim(content), "", ""))
                            i = j + 1
                        else:
                            if ttype == "PARTIAL":
                                # {{> name}}
                                var j = i + 1
                                var content = ""
                                while j < len:
                                    val t = tokens[j]
                                    if token_type(t) == "VAR_CLOSE":
                                        j = len
                                    else:
                                        content = content + token_value(t)
                                        j = j + 1
                                nodes.push(make_node("PARTIAL", str_trim(content), "", ""))
                                i = j + 1
                            else:
                                if ttype == "COMMENT_OPEN":
                                    # Skip until comment close
                                    var j = i + 1
                                    while j < len:
                                        val t = tokens[j]
                                        if token_type(t) == "COMMENT_CLOSE" or token_type(t) == "VAR_CLOSE":
                                            j = len
                                        j = j + 1
                                    i = j + 1
                                else:
                                    i = i + 1

    nodes

# ============================================================================
# VARIABLE RESOLUTION
# ============================================================================

fn resolve_var(ctx: [[text]], name: text) -> text:
    # Handle special loop variables
    if str_starts_with(name, "@"):
        val loop_var = ctx_get(ctx, name)
        if loop_var != nil:
            return loop_var
        return ""

    # Handle parent access ../
    if str_starts_with(name, "../"):
        # Would need parent context support
        return ""

    # Handle property access
    if str_contains(name, "."):
        val parts = str_split(name, ".")
        # For now, just get first part
        if parts.len() > 0:
            val val_opt = ctx_get(ctx, parts[0])
            if val_opt != nil:
                return val_opt
        return ""

    # Simple variable
    val val_opt = ctx_get(ctx, name)
    if val_opt != nil:
        return val_opt
    ""

fn is_truthy(val: text) -> bool:
    if val == "":
        return false
    if val == "0":
        return false
    if val == "false":
        return false
    if val == "nil":
        return false
    true

# ============================================================================
# HELPERS (Built-in functions)
# ============================================================================

fn apply_helper(name: text, args: [text]) -> text:
    if name == "upper":
        if args.len() > 0:
            return str_to_upper(args[0])
    if name == "lower":
        if args.len() > 0:
            return str_to_lower(args[0])
    if name == "capitalize":
        if args.len() > 0:
            return str_capitalize(args[0])
    if name == "trim":
        if args.len() > 0:
            return str_trim(args[0])
    if name == "reverse":
        if args.len() > 0:
            return str_reverse(args[0])
    if name == "truncate":
        if args.len() > 1:
            val max_len = str_to_int(args[1])
            return str_truncate(args[0], max_len)
    if name == "default":
        if args.len() > 1:
            if args[0] == "":
                return args[1]
            return args[0]
    if name == "add":
        if args.len() > 1:
            val a = str_to_int(args[0])
            val b = str_to_int(args[1])
            return int_to_str(a + b)
    if name == "sub":
        if args.len() > 1:
            val a = str_to_int(args[0])
            val b = str_to_int(args[1])
            return int_to_str(a - b)
    if name == "mul":
        if args.len() > 1:
            val a = str_to_int(args[0])
            val b = str_to_int(args[1])
            return int_to_str(a * b)
    if name == "div":
        if args.len() > 1:
            val a = str_to_int(args[0])
            val b = str_to_int(args[1])
            if b != 0:
                return int_to_str(a / b)
    ""

# ============================================================================
# RENDERER
# ============================================================================

fn render_nodes(nodes: [[text]], ctx: [[text]], registry: [[text]]) -> text:
    var result = ""
    var i = 0

    while i < nodes.len():
        val node = nodes[i]
        val ntype = node_type(node)

        if ntype == "TEXT":
            result = result + node_data1(node)
            i = i + 1
        else:
            if ntype == "VAR":
                val var_name = node_data1(node)
                val value = resolve_var(ctx, var_name)
                result = result + html_escape(value)
                i = i + 1
            else:
                if ntype == "RAW_VAR":
                    val var_name = node_data1(node)
                    val value = resolve_var(ctx, var_name)
                    result = result + value
                    i = i + 1
                else:
                    if ntype == "PARTIAL":
                        val partial_name = node_data1(node)
                        val partial_opt = reg_get(registry, partial_name)
                        if partial_opt != nil:
                            val p_nodes = compile_template(partial_opt)
                            result = result + render_nodes(p_nodes, ctx, registry)
                        i = i + 1
                    else:
                        if ntype == "BLOCK":
                            val block_type = node_data1(node)
                            val block_arg = node_data2(node)

                            if block_type == "if":
                                # Find matching {{/if}}
                                var j = i + 1
                                var depth = 1
                                var if_body: [[text]] = []
                                var else_body: [[text]] = []
                                var in_else = false

                                while j < nodes.len() and depth > 0:
                                    val n = nodes[j]
                                    val nt = node_type(n)

                                    if nt == "BLOCK":
                                        if node_data1(n) == "if":
                                            depth = depth + 1
                                        if node_data1(n) == "else":
                                            if depth == 1:
                                                in_else = true
                                                j = j + 1
                                    if nt == "END_BLOCK":
                                        if node_data1(n) == "if":
                                            depth = depth - 1
                                            if depth == 0:
                                                j = nodes.len()

                                    if depth > 0:
                                        if in_else:
                                            else_body.push(n)
                                        else:
                                            if_body.push(n)
                                    j = j + 1

                                # Evaluate condition
                                val cond_val = resolve_var(ctx, block_arg)
                                if is_truthy(cond_val):
                                    result = result + render_nodes(if_body, ctx, registry)
                                else:
                                    result = result + render_nodes(else_body, ctx, registry)

                                i = j
                            else:
                                if block_type == "each":
                                    # Find matching {{/each}}
                                    var j = i + 1
                                    var depth = 1
                                    var loop_body: [[text]] = []

                                    while j < nodes.len() and depth > 0:
                                        val n = nodes[j]
                                        val nt = node_type(n)

                                        if nt == "BLOCK":
                                            if node_data1(n) == "each":
                                                depth = depth + 1
                                        if nt == "END_BLOCK":
                                            if node_data1(n) == "each":
                                                depth = depth - 1
                                                if depth == 0:
                                                    j = nodes.len()

                                        if depth > 0:
                                            loop_body.push(n)
                                        j = j + 1

                                    # Get array from context
                                    # For now, simple implementation - assume comma-separated values
                                    val items_str = resolve_var(ctx, block_arg)
                                    val items = str_split(items_str, ",")

                                    var idx = 0
                                    for item in items:
                                        var loop_ctx = ctx_clone(ctx)
                                        loop_ctx = ctx_set(loop_ctx, "this", str_trim(item))
                                        loop_ctx = ctx_set(loop_ctx, "@index", int_to_str(idx))
                                        loop_ctx = ctx_set(loop_ctx, "@first", if idx == 0: "true" else: "false")
                                        loop_ctx = ctx_set(loop_ctx, "@last", if idx == items.len() - 1: "true" else: "false")
                                        loop_ctx = ctx_set(loop_ctx, "@key", int_to_str(idx))

                                        result = result + render_nodes(loop_body, loop_ctx, registry)
                                        idx = idx + 1

                                    i = j
                                else:
                                    if block_type == "with":
                                        # Find matching {{/with}}
                                        var j = i + 1
                                        var depth = 1
                                        var with_body: [[text]] = []

                                        while j < nodes.len() and depth > 0:
                                            val n = nodes[j]
                                            val nt = node_type(n)

                                            if nt == "BLOCK":
                                                if node_data1(n) == "with":
                                                    depth = depth + 1
                                            if nt == "END_BLOCK":
                                                if node_data1(n) == "with":
                                                    depth = depth - 1
                                                    if depth == 0:
                                                        j = nodes.len()

                                            if depth > 0:
                                                with_body.push(n)
                                            j = j + 1

                                        # Create new context with variable
                                        var with_ctx = ctx_clone(ctx)
                                        val with_val = resolve_var(ctx, block_arg)
                                        with_ctx = ctx_set(with_ctx, "this", with_val)

                                        result = result + render_nodes(with_body, with_ctx, registry)
                                        i = j
                                    else:
                                        # Unknown block type
                                        i = i + 1
                        else:
                            # Unknown node type or END_BLOCK
                            i = i + 1

    result

fn compile_template(template: text) -> [[text]]:
    val tokens = tokenize(template)
    parse(tokens)

fn render_template(template: text, ctx: [[text]], registry: [[text]]) -> text:
    val nodes = compile_template(template)
    render_nodes(nodes, ctx, registry)

# ============================================================================
# FILTERS - Additional Text Operations
# ============================================================================

fn filter_strip_html(s: text) -> text:
    var result = ""
    var in_tag = false
    var i = 0
    while i < s.len():
        val c = s[i:i+1]
        if c == "<":
            in_tag = true
        else:
            if c == ">":
                in_tag = false
            else:
                if not in_tag:
                    result = result + c
        i = i + 1
    result

fn filter_slug(s: text) -> text:
    var result = str_to_lower(s)
    result = str_replace_all(result, " ", "-")
    result = str_replace_all(result, "_", "-")
    # Remove non-alphanumeric except dash
    var clean = ""
    var i = 0
    while i < result.len():
        val c = result[i:i+1]
        val is_valid = is_alnum_char(c) or c == "-"
        if is_valid:
            clean = clean + c
        i = i + 1
    clean

fn filter_word_count(s: text) -> text:
    val words = str_split(str_trim(s), " ")
    var count = 0
    for word in words:
        if str_trim(word).len() > 0:
            count = count + 1
    int_to_str(count)

fn filter_line_count(s: text) -> text:
    val lines = str_split(s, "\n")
    int_to_str(lines.len())

fn filter_char_count(s: text) -> text:
    int_to_str(s.len())

fn filter_first_line(s: text) -> text:
    val lines = str_split(s, "\n")
    if lines.len() > 0:
        return lines[0]
    ""

fn filter_last_line(s: text) -> text:
    val lines = str_split(s, "\n")
    if lines.len() > 0:
        return lines[lines.len() - 1]
    ""

fn filter_indent(s: text, spaces: i64) -> text:
    val lines = str_split(s, "\n")
    val indent = str_repeat(" ", spaces)
    var result: [text] = []
    for line in lines:
        result.push(indent + line)
    join_strs(result, "\n")

fn filter_dedent(s: text) -> text:
    val lines = str_split(s, "\n")
    # Find minimum indent
    var min_indent = 9999
    for line in lines:
        if str_trim(line).len() > 0:
            var spaces = 0
            var i = 0
            while i < line.len() and line[i:i+1] == " ":
                spaces = spaces + 1
                i = i + 1
            if spaces < min_indent:
                min_indent = spaces
    # Remove min indent from all lines
    var result: [text] = []
    for line in lines:
        if line.len() >= min_indent:
            result.push(line[min_indent:])
        else:
            result.push(line)
    join_strs(result, "\n")

fn filter_quote(s: text) -> text:
    "\"" + s + "\""

fn filter_unquote(s: text) -> text:
    if s.len() >= 2:
        val first = s[0:1]
        val last = s[s.len()-1:s.len()]
        if (first == "\"" and last == "\"") or (first == "'" and last == "'"):
            return s[1:s.len()-1]
    s

# ============================================================================
# FILTERS - Number Formatting
# ============================================================================

fn filter_abs(s: text) -> text:
    if s.len() > 0 and s[0:1] == "-":
        return s[1:]
    s

fn filter_format_bytes(bytes: i64) -> text:
    if bytes < 1024:
        return int_to_str(bytes) + " B"
    val kb = bytes / 1024
    if kb < 1024:
        return int_to_str(kb) + " KB"
    val mb = kb / 1024
    if mb < 1024:
        return int_to_str(mb) + " MB"
    val gb = mb / 1024
    int_to_str(gb) + " GB"

fn filter_ordinal(n: i64) -> text:
    val num_str = int_to_str(n)
    val last_digit = n % 10
    val last_two = n % 100
    if last_two >= 11 and last_two <= 13:
        return num_str + "th"
    if last_digit == 1:
        return num_str + "st"
    if last_digit == 2:
        return num_str + "nd"
    if last_digit == 3:
        return num_str + "rd"
    num_str + "th"

fn filter_percentage(n: i64, decimals: i64) -> text:
    int_to_str(n) + "%"

# ============================================================================
# FILTERS - Array/List Operations
# ============================================================================

fn filter_join_list(items: [text], sep: text) -> text:
    join_strs(items, sep)

fn filter_first_item(items: [text]) -> text:
    if items.len() > 0:
        return items[0]
    ""

fn filter_last_item(items: [text]) -> text:
    if items.len() > 0:
        return items[items.len() - 1]
    ""

fn filter_list_length(items: [text]) -> text:
    int_to_str(items.len())

fn filter_sort_list(items: [text]) -> [text]:
    # Simple bubble sort
    var result: [text] = []
    for item in items:
        result.push(item)
    var n = result.len()
    var swapped = true
    while swapped:
        swapped = false
        var i = 1
        while i < n:
            if result[i-1] > result[i]:
                val temp = result[i-1]
                result[i-1] = result[i]
                result[i] = temp
                swapped = true
            i = i + 1
        n = n - 1
    result

fn filter_reverse_list(items: [text]) -> [text]:
    var result: [text] = []
    var i = items.len() - 1
    while i >= 0:
        result.push(items[i])
        i = i - 1
    result

fn filter_unique_list(items: [text]) -> [text]:
    var result: [text] = []
    var seen: [text] = []
    for item in items:
        var found = false
        for s in seen:
            if s == item:
                found = true
        if not found:
            result.push(item)
            seen.push(item)
    result

# ============================================================================
# PUBLIC API
# ============================================================================

fn template_create_context() -> [[text]]:
    make_context()

fn template_set(ctx: [[text]], key: text, value: text) -> [[text]]:
    ctx_set(ctx, key, value)

fn template_get(ctx: [[text]], key: text) -> text?:
    ctx_get(ctx, key)

fn template_has(ctx: [[text]], key: text) -> bool:
    ctx_has(ctx, key)

fn template_clone_context(ctx: [[text]]) -> [[text]]:
    ctx_clone(ctx)

fn template_compile(template: text) -> [[text]]:
    compile_template(template)

fn template_render(compiled: [[text]], ctx: [[text]]) -> text:
    val registry = make_registry()
    render_nodes(compiled, ctx, registry)

fn template_render_with_partials(compiled: [[text]], ctx: [[text]], registry: [[text]]) -> text:
    render_nodes(compiled, ctx, registry)

fn template_render_string(template: text, ctx: [[text]]) -> text:
    val registry = make_registry()
    render_template(template, ctx, registry)

fn template_create_registry() -> [[text]]:
    make_registry()

fn template_register_partial(registry: [[text]], name: text, template: text) -> [[text]]:
    reg_add(registry, name, template)

fn template_get_partial(registry: [[text]], name: text) -> text?:
    reg_get(registry, name)

fn template_register_helper(registry: [[text]], name: text, fn_name: text) -> [[text]]:
    # Helper registration would need function reference support
    # For now, just return registry as-is
    registry

fn template_escape_html(s: text) -> text:
    html_escape(s)

fn template_unescape_html(s: text) -> text:
    html_unescape(s)

fn template_escape_url(s: text) -> text:
    url_encode(s)

fn template_escape_js(s: text) -> text:
    js_escape(s)

fn template_escape_css(s: text) -> text:
    css_escape(s)

fn template_strip_html(s: text) -> text:
    filter_strip_html(s)

fn template_slug(s: text) -> text:
    filter_slug(s)

fn template_word_count(s: text) -> text:
    filter_word_count(s)

fn template_format_bytes(bytes: i64) -> text:
    filter_format_bytes(bytes)

fn template_ordinal(n: i64) -> text:
    filter_ordinal(n)

fn template_indent(s: text, spaces: i64) -> text:
    filter_indent(s, spaces)

fn template_dedent(s: text) -> text:
    filter_dedent(s)

# ============================================================================
# EXPORTS
# ============================================================================

# Core API
export template_create_context, template_set, template_get, template_has, template_clone_context
export template_compile, template_render, template_render_with_partials, template_render_string
export template_create_registry, template_register_partial, template_get_partial, template_register_helper

# Escaping functions
export template_escape_html, template_unescape_html, template_escape_url
export template_escape_js, template_escape_css
export html_escape, html_unescape, url_encode, url_decode, js_escape, css_escape

# Filter functions
export template_strip_html, template_slug, template_word_count
export template_format_bytes, template_ordinal, template_indent, template_dedent

# String utilities
export str_trim, str_trim_left, str_trim_right
export str_to_upper, str_to_lower, str_capitalize, str_reverse
export str_truncate, str_repeat, str_split, str_replace_all
export str_contains, str_starts_with, str_ends_with, str_index_of
export str_pad_left, str_pad_right, str_center
export int_to_str, str_to_int, int_to_hex_str, hex_str_to_int

# Character utilities
export is_whitespace_char, is_alpha_char, is_digit_char, is_alnum_char
export char_at_safe, substr_safe

# Filter operations
export filter_strip_html, filter_slug, filter_word_count, filter_line_count, filter_char_count
export filter_first_line, filter_last_line, filter_indent, filter_dedent
export filter_quote, filter_unquote, filter_abs
export filter_format_bytes, filter_ordinal, filter_percentage
export filter_join_list, filter_first_item, filter_last_item, filter_list_length
export filter_sort_list, filter_reverse_list, filter_unique_list

# Helpers
export apply_helper, is_truthy, resolve_var
