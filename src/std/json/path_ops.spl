# JSON Path Operations
#
# Purpose: JSONPath-like operations for nested navigation
#
# Contains:
# - Path parsing: json_path_parse
# - Path operations: get_path, set_path, has_path, delete_path
# - Path format: dot-separated paths (e.g., "user.address.city")

# Import types and object/array ops
mod json.types
mod json.object_ops
mod json.array_ops

fn json_path_parse(path: text) -> [text]:
    """Parse path string into components.

    Args:
        path: Path string (e.g., "user.address.city")

    Returns:
        Array of path components

    Example:
        json_path_parse("user.name")  # ["user", "name"]
    """
    if path == "":
        return []
    path.split(".")

fn json_path_get(value: any, path: text) -> any:
    """Get value at path.

    Args:
        value: JSON value
        path: Dot-separated path (e.g., "user.address.city")

    Returns:
        Value at path, or nil if not found

    Example:
        json_path_get(data, "user.name")
    """
    val parts = json_path_parse(path)
    var current = value
    for part in parts:
        if current == nil:
            return nil
        if json_is_object(current):
            current = json_object_get(current, part)
        else:
            if json_is_array(current):
                val idx = part.to_int()
                current = json_array_get(current, idx)
            else:
                return nil
    current

fn json_path_set(value: any, path: text, new_value: any) -> any:
    """Set value at path.

    Args:
        value: JSON value
        path: Dot-separated path
        new_value: New JSON value to set

    Returns:
        New JSON value with updated path

    Example:
        json_path_set(data, "user.age", json_number(31))
    """
    val parts = json_path_parse(path)
    if parts.len() == 0:
        return new_value
    if parts.len() == 1:
        if json_is_object(value):
            return json_object_set(value, parts[0], new_value)
        return value
    val first = parts[0]
    var rest_path = ""
    for i in 1..parts.len():
        if i > 1:
            rest_path = rest_path + "."
        rest_path = rest_path + parts[i]
    if json_is_object(value):
        val nested = json_object_get(value, first)
        val updated_nested = json_path_set(nested, rest_path, new_value)
        return json_object_set(value, first, updated_nested)
    value

fn json_path_has(value: any, path: text) -> bool:
    """Check if path exists in JSON value.

    Args:
        value: JSON value
        path: Dot-separated path

    Returns:
        true if path exists, false otherwise

    Example:
        json_path_has(data, "user.email")
    """
    json_path_get(value, path) != nil

fn json_path_delete(value: any, path: text) -> any:
    """Delete value at path.

    Args:
        value: JSON value
        path: Dot-separated path

    Returns:
        New JSON value with deleted path

    Example:
        json_path_delete(data, "user.temp_field")
    """
    val parts = json_path_parse(path)
    if parts.len() == 0:
        return value
    if parts.len() == 1:
        if json_is_object(value):
            return json_object_remove(value, parts[0])
        return value
    val first = parts[0]
    var rest_path = ""
    for i in 1..parts.len():
        if i > 1:
            rest_path = rest_path + "."
        rest_path = rest_path + parts[i]
    if json_is_object(value):
        val nested = json_object_get(value, first)
        val updated_nested = json_path_delete(nested, rest_path)
        return json_object_set(value, first, updated_nested)
    value

export *
