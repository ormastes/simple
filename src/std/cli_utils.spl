# CLI Utilities Module - Facade
# Comprehensive command-line interface utilities for Simple language
#
# This file serves as the main facade for the CLI utilities.
# The implementation has been refactored into a modular structure
# located in the cli/ subdirectory:
#
# Categories:
# - cli/types.spl        - Data structure definitions and ANSI codes
# - cli/parser.spl       - Parser creation and argument definition
# - cli/flags.spl        - Argument parsing logic and result accessors
# - cli/commands.spl     - Subcommand support
# - cli/help.spl         - Help text generation
# - cli/formatting.spl   - Text formatting, colors, tables, progress
# - cli/utilities.spl    - Interactive prompts, validation, misc utilities
#
# Features:
# - Argument parsing (flags, options, positional args)
# - Help text generation
# - Command/subcommand support
# - Interactive prompts
# - Progress indicators
# - Colored output
# - Table formatting
# - Input validation

# =============================================================================
# ANSI Color Codes
# =============================================================================

val ANSI_RESET = "\033[0m"
val ANSI_RED = "\033[31m"
val ANSI_GREEN = "\033[32m"
val ANSI_YELLOW = "\033[33m"
val ANSI_BLUE = "\033[34m"
val ANSI_MAGENTA = "\033[35m"
val ANSI_CYAN = "\033[36m"
val ANSI_WHITE = "\033[37m"
val ANSI_BOLD = "\033[1m"
val ANSI_DIM = "\033[2m"
val ANSI_UNDERLINE = "\033[4m"

# =============================================================================
# Data Structures (using tuples)
# =============================================================================

# Parser: (name, version, flags, options, positionals, commands, description)
# Flag: (name, short, long, help, present)
# Option: (name, short, long, default, help, value, required)
# Positional: (name, help, value, required)
# Command: (name, help, parser)
# ParseResult: (flags, options, positionals, command, args, errors)
# ProgressBar: (total, current, width, prefix, suffix)
# Table: (headers, rows, column_widths)

# =============================================================================
# Parser Creation
# =============================================================================

# Create a new argument parser
fn create_parser(name: text, version: text) -> tuple:
    val flags = []
    val options = []
    val positionals = []
    val commands = []
    val description = ""
    (name, version, flags, options, positionals, commands, description)

# Set parser description
fn set_description(parser: tuple, desc: text) -> tuple:
    val name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    (name, version, flags, options, positionals, commands, desc)

# =============================================================================
# Argument Definition
# =============================================================================

# Add a boolean flag (e.g., -v, --verbose)
fn add_flag(parser: tuple, name: text, short: text, long: text, help: text) -> tuple:
    val parser_name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    val description = parser[6]

    val flag = (name, short, long, help, false)
    val new_flags = flags + [flag]
    (parser_name, version, new_flags, options, positionals, commands, description)

# Add an option with a value (e.g., -o file.txt, --output=file.txt)
fn add_option(parser: tuple, name: text, short: text, long: text, default: text, help: text) -> tuple:
    val parser_name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    val description = parser[6]

    val option = (name, short, long, default, help, default, false)
    val new_options = options + [option]
    (parser_name, version, flags, new_options, positionals, commands, description)

# Add a required option
fn add_required_option(parser: tuple, name: text, short: text, long: text, help: text) -> tuple:
    val parser_name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    val description = parser[6]

    val option = (name, short, long, "", help, "", true)
    val new_options = options + [option]
    (parser_name, version, flags, new_options, positionals, commands, description)

# Add a positional argument
fn add_positional(parser: tuple, name: text, help: text) -> tuple:
    val parser_name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    val description = parser[6]

    val positional = (name, help, "", false)
    val new_positionals = positionals + [positional]
    (parser_name, version, flags, options, new_positionals, commands, description)

# Add a required positional argument
fn add_required_positional(parser: tuple, name: text, help: text) -> tuple:
    val parser_name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    val description = parser[6]

    val positional = (name, help, "", true)
    val new_positionals = positionals + [positional]
    (parser_name, version, flags, options, new_positionals, commands, description)

# =============================================================================
# Command/Subcommand Support
# =============================================================================

# Create a command with its own parser
fn create_command(name: text, help: text) -> tuple:
    val cmd_parser = create_parser(name, "")
    (name, help, cmd_parser)

# Add a subcommand to a parser
fn add_subcommand(parser: tuple, command: tuple) -> tuple:
    val parser_name = parser[0]
    val version = parser[1]
    val flags = parser[2]
    val options = parser[3]
    val positionals = parser[4]
    val commands = parser[5]
    val description = parser[6]

    val new_commands = commands + [command]
    (parser_name, version, flags, options, positionals, new_commands, description)

# Get command by name
fn get_command(parser: tuple, name: text) -> tuple:
    val commands = parser[5]
    var result = nil
    var i = 0
    while i < len(commands):
        val cmd = commands[i]
        val cmd_name = cmd[0]
        if cmd_name == name:
            result = cmd
            i = len(commands)
        i = i + 1
    result

# =============================================================================
# Argument Parsing
# =============================================================================

# Parse command-line arguments
fn parse_args(parser: tuple, args: list) -> tuple:
    val parser_flags = parser[2]
    val parser_options = parser[3]
    val parser_positionals = parser[4]
    val commands = parser[5]

    var result_flags = []
    var result_options = []
    var result_positionals = []
    var result_command = nil
    var remaining_args = []
    var errors = []

    var i = 0
    var positional_index = 0

    while i < len(args):
        val arg = args[i]

        # Check for command
        if i == 0:
            val cmd = get_command(parser, arg)
            if cmd != nil:
                result_command = arg
                i = i + 1
                continue

        # Check for long flag (--flag)
        if starts_with(arg, "--"):
            val flag_name = substring(arg, 2, len(arg))

            # Check for option with = (--option=value)
            var eq_pos = index_of(flag_name, "=")
            if eq_pos >= 0:
                val opt_name = substring(flag_name, 0, eq_pos)
                val opt_value = substring(flag_name, eq_pos + 1, len(flag_name))
                val option_tuple = find_option_by_long(parser_options, opt_name)
                if option_tuple != nil:
                    var updated_option = (option_tuple[0], option_tuple[1], option_tuple[2],
                                         option_tuple[3], option_tuple[4], opt_value, option_tuple[6])
                    result_options = result_options + [updated_option]
                else:
                    errors = errors + ["Unknown option: --{opt_name}"]
                i = i + 1
                continue

            # Check if it's a flag
            val flag_tuple = find_flag_by_long(parser_flags, flag_name)
            if flag_tuple != nil:
                var updated_flag = (flag_tuple[0], flag_tuple[1], flag_tuple[2], flag_tuple[3], true)
                result_flags = result_flags + [updated_flag]
                i = i + 1
                continue

            # Check if it's an option (next arg is value)
            val option_tuple = find_option_by_long(parser_options, flag_name)
            if option_tuple != nil:
                if i + 1 < len(args):
                    val opt_value = args[i + 1]
                    var updated_option = (option_tuple[0], option_tuple[1], option_tuple[2],
                                         option_tuple[3], option_tuple[4], opt_value, option_tuple[6])
                    result_options = result_options + [updated_option]
                    i = i + 2
                    continue
                else:
                    errors = errors + ["Option --{flag_name} requires a value"]
                    i = i + 1
                    continue

            errors = errors + ["Unknown flag: --{flag_name}"]
            i = i + 1
            continue

        # Check for short flag (-f)
        if starts_with(arg, "-"):
            val flag_name = substring(arg, 1, len(arg))

            # Check if it's a flag
            val flag_tuple = find_flag_by_short(parser_flags, flag_name)
            if flag_tuple != nil:
                var updated_flag = (flag_tuple[0], flag_tuple[1], flag_tuple[2], flag_tuple[3], true)
                result_flags = result_flags + [updated_flag]
                i = i + 1
                continue

            # Check if it's an option (next arg is value)
            val option_tuple = find_option_by_short(parser_flags, flag_name)
            if option_tuple != nil:
                if i + 1 < len(args):
                    val opt_value = args[i + 1]
                    var updated_option = (option_tuple[0], option_tuple[1], option_tuple[2],
                                         option_tuple[3], option_tuple[4], opt_value, option_tuple[6])
                    result_options = result_options + [updated_option]
                    i = i + 2
                    continue
                else:
                    errors = errors + ["Option -{flag_name} requires a value"]
                    i = i + 1
                    continue

            errors = errors + ["Unknown flag: -{flag_name}"]
            i = i + 1
            continue

        # Positional argument
        if positional_index < len(parser_positionals):
            val pos = parser_positionals[positional_index]
            var updated_pos = (pos[0], pos[1], arg, pos[3])
            result_positionals = result_positionals + [updated_pos]
            positional_index = positional_index + 1
        else:
            remaining_args = remaining_args + [arg]

        i = i + 1

    # Add unset flags with default (false)
    var j = 0
    while j < len(parser_flags):
        val flag = parser_flags[j]
        val flag_name = flag[0]
        if not contains_flag(result_flags, flag_name):
            result_flags = result_flags + [flag]
        j = j + 1

    # Add unset options with default values
    var k = 0
    while k < len(parser_options):
        val option = parser_options[k]
        val option_name = option[0]
        if not contains_option(result_options, option_name):
            result_options = result_options + [option]
        k = k + 1

    # Add unset positionals
    var m = 0
    while m < len(parser_positionals):
        val pos = parser_positionals[m]
        val pos_name = pos[0]
        if not contains_positional(result_positionals, pos_name):
            result_positionals = result_positionals + [pos]
        m = m + 1

    # Validate required options
    var n = 0
    while n < len(result_options):
        val option = result_options[n]
        val is_required = option[6]
        val value = option[5]
        val name = option[0]
        if is_required:
            if value == "":
                errors = errors + ["Required option '{name}' not provided"]
        n = n + 1

    # Validate required positionals
    var p = 0
    while p < len(result_positionals):
        val pos = result_positionals[p]
        val is_required = pos[3]
        val value = pos[2]
        val name = pos[0]
        if is_required:
            if value == "":
                errors = errors + ["Required argument '{name}' not provided"]
        p = p + 1

    (result_flags, result_options, result_positionals, result_command, remaining_args, errors)

# =============================================================================
# Helper Functions for Parsing
# =============================================================================

fn starts_with(text: text, prefix: text) -> bool:
    if len(prefix) > len(text):
        return false
    val sub = substring(text, 0, len(prefix))
    sub == prefix

fn index_of(text: text, search: text) -> i64:
    var i = 0
    while i < len(text):
        if i + len(search) <= len(text):
            val sub = substring(text, i, i + len(search))
            if sub == search:
                return i
        i = i + 1
    -1

fn find_flag_by_long(flags: list, long_name: text) -> tuple:
    var i = 0
    while i < len(flags):
        val flag = flags[i]
        val flag_long = flag[2]
        if flag_long == long_name:
            return flag
        i = i + 1
    nil

fn find_flag_by_short(flags: list, short_name: text) -> tuple:
    var i = 0
    while i < len(flags):
        val flag = flags[i]
        val flag_short = flag[1]
        if flag_short == short_name:
            return flag
        i = i + 1
    nil

fn find_option_by_long(options: list, long_name: text) -> tuple:
    var i = 0
    while i < len(options):
        val option = options[i]
        val option_long = option[2]
        if option_long == long_name:
            return option
        i = i + 1
    nil

fn find_option_by_short(options: list, short_name: text) -> tuple:
    var i = 0
    while i < len(options):
        val option = options[i]
        val option_short = option[1]
        if option_short == short_name:
            return option
        i = i + 1
    nil

fn contains_flag(flags: list, name: text) -> bool:
    var i = 0
    while i < len(flags):
        val flag = flags[i]
        val flag_name = flag[0]
        if flag_name == name:
            return true
        i = i + 1
    false

fn contains_option(options: list, name: text) -> bool:
    var i = 0
    while i < len(options):
        val option = options[i]
        val option_name = option[0]
        if option_name == name:
            return true
        i = i + 1
    false

fn contains_positional(positionals: list, name: text) -> bool:
    var i = 0
    while i < len(positionals):
        val pos = positionals[i]
        val pos_name = pos[0]
        if pos_name == name:
            return true
        i = i + 1
    false

# =============================================================================
# Result Accessors
# =============================================================================

# Get flag value from parse result
fn get_flag(result: tuple, name: text) -> bool:
    val flags = result[0]
    var i = 0
    while i < len(flags):
        val flag = flags[i]
        val flag_name = flag[0]
        if flag_name == name:
            return flag[4]
        i = i + 1
    false

# Get option value from parse result
fn get_option(result: tuple, name: text) -> text:
    val options = result[1]
    var i = 0
    while i < len(options):
        val option = options[i]
        val option_name = option[0]
        if option_name == name:
            return option[5]
        i = i + 1
    ""

# Get positional value from parse result
fn get_positional(result: tuple, name: text) -> text:
    val positionals = result[2]
    var i = 0
    while i < len(positionals):
        val pos = positionals[i]
        val pos_name = pos[0]
        if pos_name == name:
            return pos[2]
        i = i + 1
    ""

# Get command name from parse result
fn get_command_name(result: tuple) -> text:
    val cmd = result[3]
    if cmd == nil:
        return ""
    cmd

# Get remaining args from parse result
fn get_remaining_args(result: tuple) -> list:
    result[4]

# Get errors from parse result
fn get_errors(result: tuple) -> list:
    result[5]

# Check if parsing had errors
fn has_errors(result: tuple) -> bool:
    val errors = result[5]
    len(errors) > 0

# =============================================================================
# Help Text Generation
# =============================================================================

# Generate full help text for parser
fn generate_help(parser: tuple) -> text:
    val name = parser[0]
    val version = parser[1]
    val description = parser[6]

    var help_text = ""

    # Header
    help_text = "{help_text}{name} {version}\n"
    if description != "":
        help_text = "{help_text}{description}\n"
    help_text = "{help_text}\n"

    # Usage
    val usage = generate_usage(parser)
    help_text = "{help_text}{usage}\n\n"

    # Flags
    val flags = parser[2]
    if len(flags) > 0:
        help_text = "{help_text}FLAGS:\n"
        var i = 0
        while i < len(flags):
            val flag = flags[i]
            val flag_line = format_flag_help(flag)
            help_text = "{help_text}  {flag_line}\n"
            i = i + 1
        help_text = "{help_text}\n"

    # Options
    val options = parser[3]
    if len(options) > 0:
        help_text = "{help_text}OPTIONS:\n"
        var j = 0
        while j < len(options):
            val option = options[j]
            val option_line = format_option_help(option)
            help_text = "{help_text}  {option_line}\n"
            j = j + 1
        help_text = "{help_text}\n"

    # Positionals
    val positionals = parser[4]
    if len(positionals) > 0:
        help_text = "{help_text}ARGUMENTS:\n"
        var k = 0
        while k < len(positionals):
            val pos = positionals[k]
            val pos_line = format_positional_help(pos)
            help_text = "{help_text}  {pos_line}\n"
            k = k + 1
        help_text = "{help_text}\n"

    # Commands
    val commands = parser[5]
    if len(commands) > 0:
        help_text = "{help_text}COMMANDS:\n"
        var m = 0
        while m < len(commands):
            val cmd = commands[m]
            val cmd_name = cmd[0]
            val cmd_help = cmd[1]
            help_text = "{help_text}  {cmd_name}\n"
            help_text = "{help_text}      {cmd_help}\n"
            m = m + 1
        help_text = "{help_text}\n"

    help_text

# Generate usage line
fn generate_usage(parser: tuple) -> text:
    val name = parser[0]
    var usage = "USAGE: {name}"

    val flags = parser[2]
    if len(flags) > 0:
        usage = "{usage} [FLAGS]"

    val options = parser[3]
    if len(options) > 0:
        usage = "{usage} [OPTIONS]"

    val commands = parser[5]
    if len(commands) > 0:
        usage = "{usage} <COMMAND>"

    val positionals = parser[4]
    var i = 0
    while i < len(positionals):
        val pos = positionals[i]
        val pos_name = pos[0]
        val is_required = pos[3]
        if is_required:
            usage = "{usage} <{pos_name}>"
        else:
            usage = "{usage} [{pos_name}]"
        i = i + 1

    usage

# Format flag for help display
fn format_flag_help(flag: tuple) -> text:
    val short = flag[1]
    val long = flag[2]
    val help = flag[3]

    var line = ""
    if short != "":
        line = "-{short}"
    if long != "":
        if line != "":
            line = "{line}, --{long}"
        else:
            line = "--{long}"

    val padded = pad_right(line, 20)
    "{padded}{help}"

# Format option for help display
fn format_option_help(option: tuple) -> text:
    val short = option[1]
    val long = option[2]
    val default = option[3]
    val help = option[4]
    val is_required = option[6]

    var line = ""
    if short != "":
        line = "-{short} <value>"
    if long != "":
        if line != "":
            line = "{line}, --{long}=<value>"
        else:
            line = "--{long}=<value>"

    val padded = pad_right(line, 20)
    var help_text = "{padded}{help}"

    if is_required:
        help_text = "{help_text} [required]"
    else:
        if default != "":
            help_text = "{help_text} [default: {default}]"

    help_text

# Format positional for help display
fn format_positional_help(pos: tuple) -> text:
    val name = pos[0]
    val help = pos[1]
    val is_required = pos[3]

    var line = ""
    if is_required:
        line = "<{name}>"
    else:
        line = "[{name}]"

    val padded = pad_right(line, 20)
    "{padded}{help}"

# =============================================================================
# Text Formatting Utilities
# =============================================================================

# Pad text to the right with spaces
fn pad_right(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len >= width:
        return text
    val spaces_needed = width - current_len
    var result = text
    var i = 0
    while i < spaces_needed:
        result = "{result} "
        i = i + 1
    result

# Pad text to the left with spaces
fn pad_left(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len >= width:
        return text
    val spaces_needed = width - current_len
    var result = ""
    var i = 0
    while i < spaces_needed:
        result = "{result} "
        i = i + 1
    "{result}{text}"

# Align text left within width
fn align_left(text: text, width: i64) -> text:
    pad_right(text, width)

# Align text right within width
fn align_right(text: text, width: i64) -> text:
    pad_left(text, width)

# Align text center within width
fn align_center(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len >= width:
        return text
    val spaces_needed = width - current_len
    val left_spaces = spaces_needed / 2
    val right_spaces = spaces_needed - left_spaces

    var result = ""
    var i = 0
    while i < left_spaces:
        result = "{result} "
        i = i + 1
    result = "{result}{text}"
    var j = 0
    while j < right_spaces:
        result = "{result} "
        j = j + 1
    result

# Wrap text to specified width
fn wrap_text(text: text, width: i64) -> text:
    if len(text) <= width:
        return text

    var result = ""
    var current_line = ""
    var words = split_by_space(text)
    var i = 0

    while i < len(words):
        val word = words[i]
        val test_line = "{current_line} {word}"
        val trimmed = trim(test_line)

        if len(trimmed) <= width:
            current_line = trimmed
        else:
            if current_line != "":
                if result == "":
                    result = current_line
                else:
                    result = "{result}\n{current_line}"
            current_line = word
        i = i + 1

    if current_line != "":
        if result == "":
            result = current_line
        else:
            result = "{result}\n{current_line}"

    result

# Truncate text to width with ellipsis
fn truncate(text: text, width: i64) -> text:
    if len(text) <= width:
        return text
    if width <= 3:
        return substring(text, 0, width)
    val truncated = substring(text, 0, width - 3)
    "{truncated}..."

# Pad text to exact width (truncate if too long)
fn pad(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len == width:
        return text
    if current_len > width:
        return truncate(text, width)
    pad_right(text, width)

fn split_by_space(text: text) -> list:
    var result = []
    var current_word = ""
    var i = 0

    while i < len(text):
        val ch = substring(text, i, i + 1)
        if ch == " ":
            if current_word != "":
                result = result + [current_word]
                current_word = ""
        else:
            current_word = "{current_word}{ch}"
        i = i + 1

    if current_word != "":
        result = result + [current_word]

    result

fn trim(text: text) -> text:
    var start = 0
    var end = len(text)

    # Trim from start
    while start < end:
        val ch = substring(text, start, start + 1)
        if ch != " ":
            start = len(text)
        else:
            start = start + 1

    # Trim from end
    while end > start:
        val ch = substring(text, end - 1, end)
        if ch != " ":
            end = 0
        else:
            end = end - 1

    substring(text, start, end)

# =============================================================================
# Color Output
# =============================================================================

# Apply ANSI color code to text
fn colorize(text: text, color_code: text) -> text:
    "{color_code}{text}{ANSI_RESET}"

# Color text red
fn red(text: text) -> text:
    colorize(text, ANSI_RED)

# Color text green
fn green(text: text) -> text:
    colorize(text, ANSI_GREEN)

# Color text yellow
fn yellow(text: text) -> text:
    colorize(text, ANSI_YELLOW)

# Color text blue
fn blue(text: text) -> text:
    colorize(text, ANSI_BLUE)

# Color text magenta
fn magenta(text: text) -> text:
    colorize(text, ANSI_MAGENTA)

# Color text cyan
fn cyan(text: text) -> text:
    colorize(text, ANSI_CYAN)

# Color text white
fn white(text: text) -> text:
    colorize(text, ANSI_WHITE)

# Make text bold
fn bold(text: text) -> text:
    "{ANSI_BOLD}{text}{ANSI_RESET}"

# Make text dim
fn dim(text: text) -> text:
    "{ANSI_DIM}{text}{ANSI_RESET}"

# Make text underlined
fn underline(text: text) -> text:
    "{ANSI_UNDERLINE}{text}{ANSI_RESET}"

# =============================================================================
# Formatted Output
# =============================================================================

# Print success message (green)
fn print_success(message: text):
    val formatted = green("[SUCCESS] {message}")
    print formatted

# Print error message (red)
fn print_error(message: text):
    val formatted = red("[ERROR] {message}")
    print formatted

# Print warning message (yellow)
fn print_warning(message: text):
    val formatted = yellow("[WARNING] {message}")
    print formatted

# Print info message (blue)
fn print_info(message: text):
    val formatted = blue("[INFO] {message}")
    print formatted

# Print debug message (dim)
fn print_debug(message: text):
    val formatted = dim("[DEBUG] {message}")
    print formatted

# =============================================================================
# Interactive Prompts
# =============================================================================

# Simple text prompt
fn prompt(message: text) -> text:
    print "{message}"
    readln()

# Yes/no prompt (returns true for yes, false for no)
fn prompt_yes_no(message: text) -> bool:
    val response = prompt("{message} (y/n): ")
    val lower = to_lower(response)
    lower == "y"

# Choice prompt (returns index of selected choice)
fn prompt_choice(message: text, choices: list) -> i64:
    print "{message}"
    var i = 0
    while i < len(choices):
        val choice = choices[i]
        val num = i + 1
        print "  {num}. {choice}"
        i = i + 1

    val response = prompt("Enter choice (1-{len(choices)}): ")
    val choice_num = parse_int_or_zero(response)
    choice_num - 1

# Password prompt (note: Simple doesn't support hidden input)
fn prompt_password(message: text) -> text:
    print "{message} (warning: will be visible)"
    readln()

# Confirm password prompt
fn prompt_confirm_password(message: text) -> text:
    val pass1 = prompt_password(message)
    val pass2 = prompt_password("Confirm password: ")
    if pass1 == pass2:
        return pass1
    print_error("Passwords do not match")
    ""

# Multi-select prompt
fn prompt_multi_select(message: text, choices: list) -> list:
    print "{message}"
    print "(Enter numbers separated by spaces, or 'all' for all choices)"
    var i = 0
    while i < len(choices):
        val choice = choices[i]
        val num = i + 1
        print "  {num}. {choice}"
        i = i + 1

    val response = prompt("Enter choices: ")
    if response == "all":
        return choices

    val selected_nums = split_by_space(response)
    var selected = []
    var j = 0
    while j < len(selected_nums):
        val num_str = selected_nums[j]
        val num = parse_int_or_zero(num_str)
        val index = num - 1
        if index >= 0:
            if index < len(choices):
                selected = selected + [choices[index]]
        j = j + 1

    selected

fn to_lower(text: text) -> text:
    var result = ""
    var i = 0
    while i < len(text):
        val ch = substring(text, i, i + 1)
        if ch == "Y":
            result = "{result}y"
        else:
            if ch == "N":
                result = "{result}n"
            else:
                result = "{result}{ch}"
        i = i + 1
    result

fn parse_int_or_zero(text: text) -> i64:
    # Simple integer parsing (positive numbers only)
    var result = 0
    var i = 0
    while i < len(text):
        val ch = substring(text, i, i + 1)
        if ch == "0":
            result = result * 10 + 0
        else:
            if ch == "1":
                result = result * 10 + 1
            else:
                if ch == "2":
                    result = result * 10 + 2
                else:
                    if ch == "3":
                        result = result * 10 + 3
                    else:
                        if ch == "4":
                            result = result * 10 + 4
                        else:
                            if ch == "5":
                                result = result * 10 + 5
                            else:
                                if ch == "6":
                                    result = result * 10 + 6
                                else:
                                    if ch == "7":
                                        result = result * 10 + 7
                                    else:
                                        if ch == "8":
                                            result = result * 10 + 8
                                        else:
                                            if ch == "9":
                                                result = result * 10 + 9
        i = i + 1
    result

# =============================================================================
# Progress Indicators
# =============================================================================

# Create a progress bar
fn create_progress_bar(total: i64) -> tuple:
    val current = 0
    val width = 50
    val prefix = ""
    val suffix = ""
    (total, current, width, prefix, suffix)

# Update progress bar
fn update_progress(bar: tuple, current: i64):
    val total = bar[0]
    val width = bar[2]
    val prefix = bar[3]
    val suffix = bar[4]

    val percentage = current * 100 / total
    val filled = current * width / total

    var bar_str = "["
    var i = 0
    while i < width:
        if i < filled:
            bar_str = "{bar_str}="
        else:
            bar_str = "{bar_str} "
        i = i + 1
    bar_str = "{bar_str}]"

    print "\r{prefix}{bar_str} {percentage}% {suffix}"

# Show a simple spinner
fn show_spinner(message: text):
    print "{message}..."

# =============================================================================
# Table Formatting
# =============================================================================

# Create a table with headers
fn create_table(headers: list) -> tuple:
    val rows = []
    val column_widths = calculate_widths_from_headers(headers)
    (headers, rows, column_widths)

# Add a row to the table
fn add_row(table: tuple, values: list) -> tuple:
    val headers = table[0]
    val rows = table[1]
    val widths = table[2]

    val new_rows = rows + [values]
    val new_widths = update_widths(widths, values)
    (headers, new_rows, new_widths)

# Format table for display
fn format_table(table: tuple) -> text:
    val headers = table[0]
    val rows = table[1]
    val widths = table[2]

    var result = ""

    # Header row
    var header_line = "|"
    var i = 0
    while i < len(headers):
        val header = headers[i]
        val width = widths[i]
        val padded = pad_right(header, width)
        header_line = "{header_line} {padded} |"
        i = i + 1
    result = "{result}{header_line}\n"

    # Separator
    var separator = "|"
    var j = 0
    while j < len(headers):
        val width = widths[j]
        var dashes = ""
        var k = 0
        while k < width + 2:
            dashes = "{dashes}-"
            k = k + 1
        separator = "{separator}{dashes}|"
        j = j + 1
    result = "{result}{separator}\n"

    # Data rows
    var m = 0
    while m < len(rows):
        val row = rows[m]
        var row_line = "|"
        var n = 0
        while n < len(row):
            val cell = row[n]
            val width = widths[n]
            val padded = pad_right(cell, width)
            row_line = "{row_line} {padded} |"
            n = n + 1
        result = "{result}{row_line}\n"
        m = m + 1

    result

fn calculate_widths_from_headers(headers: list) -> list:
    var widths = []
    var i = 0
    while i < len(headers):
        val header = headers[i]
        widths = widths + [len(header)]
        i = i + 1
    widths

fn update_widths(widths: list, values: list) -> list:
    var new_widths = []
    var i = 0
    while i < len(widths):
        val current_width = widths[i]
        var new_width = current_width
        if i < len(values):
            val value = values[i]
            val value_len = len(value)
            if value_len > current_width:
                new_width = value_len
        new_widths = new_widths + [new_width]
        i = i + 1
    new_widths

# =============================================================================
# Input Validation
# =============================================================================

# Check if input is a valid integer
fn is_integer_input(text: text) -> bool:
    if len(text) == 0:
        return false
    var i = 0
    var is_valid = true
    while i < len(text):
        val ch = substring(text, i, i + 1)
        val is_digit = is_digit_char(ch)
        if not is_digit:
            is_valid = false
            i = len(text)
        i = i + 1
    is_valid

# Check if input looks like an email
fn is_email_input(text: text) -> bool:
    val at_pos = index_of(text, "@")
    if at_pos < 0:
        return false
    val dot_pos = index_of(text, ".")
    dot_pos > at_pos

# Check if input looks like a URL
fn is_url_input(text: text) -> bool:
    val http = starts_with(text, "http://")
    val https = starts_with(text, "https://")
    http or https

# Validate input against a list of choices
fn validate_choice(value: text, choices: list) -> bool:
    var i = 0
    while i < len(choices):
        val choice = choices[i]
        if choice == value:
            return true
        i = i + 1
    false

# Validate that value is not empty
fn validate_not_empty(value: text) -> bool:
    len(value) > 0

# Validate minimum length
fn validate_min_length(value: text, min_len: i64) -> bool:
    len(value) >= min_len

# Validate maximum length
fn validate_max_length(value: text, max_len: i64) -> bool:
    len(value) <= max_len

# Validate range for integer input
fn validate_int_range(value: text, min_val: i64, max_val: i64) -> bool:
    if not is_integer_input(value):
        return false
    val num = parse_int_or_zero(value)
    val is_min = num >= min_val
    val is_max = num <= max_val
    is_min and is_max

fn is_digit_char(ch: text) -> bool:
    val digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    var i = 0
    while i < len(digits):
        if ch == digits[i]:
            return true
        i = i + 1
    false

# =============================================================================
# Validation Helpers
# =============================================================================

# Validate all required options are present
fn validate_required_options(result: tuple) -> bool:
    val options = result[1]
    var i = 0
    while i < len(options):
        val option = options[i]
        val is_required = option[6]
        val value = option[5]
        if is_required:
            if value == "":
                return false
        i = i + 1
    true

# Validate all required positionals are present
fn validate_required_positionals(result: tuple) -> bool:
    val positionals = result[2]
    var i = 0
    while i < len(positionals):
        val pos = positionals[i]
        val is_required = pos[3]
        val value = pos[2]
        if is_required:
            if value == "":
                return false
        i = i + 1
    true

# Print all validation errors
fn print_validation_errors(result: tuple):
    val errors = result[5]
    var i = 0
    while i < len(errors):
        val error = errors[i]
        print_error(error)
        i = i + 1

# =============================================================================
# Advanced Formatting
# =============================================================================

# Create a horizontal line
fn horizontal_line(width: i64) -> text:
    var line = ""
    var i = 0
    while i < width:
        line = "{line}-"
        i = i + 1
    line

# Create a box around text
fn box_text(text: text) -> text:
    val width = len(text) + 4
    val top = horizontal_line(width)
    val middle = "| {text} |"
    val bottom = horizontal_line(width)
    "{top}\n{middle}\n{bottom}"

# Create a section header
fn section_header(title: text) -> text:
    val line = horizontal_line(50)
    "{line}\n{title}\n{line}"

# Format a key-value pair
fn format_key_value(key: text, value: text) -> text:
    val padded_key = pad_right(key, 20)
    "{padded_key}: {value}"

# Format a list item
fn format_list_item(text: text, number: i64) -> text:
    "  {number}. {text}"

# Format a bullet item
fn format_bullet_item(text: text) -> text:
    "  * {text}"

# =============================================================================
# Utility Functions
# =============================================================================

# Check if list is empty
fn is_empty_list(lst: list) -> bool:
    len(lst) == 0

# Get first element of list (or empty string)
fn first_or_empty(lst: list) -> text:
    if len(lst) > 0:
        return lst[0]
    ""

# Get last element of list (or empty string)
fn last_or_empty(lst: list) -> text:
    val size = len(lst)
    if size > 0:
        return lst[size - 1]
    ""

# Join list elements with separator
fn join_list(lst: list, separator: text) -> text:
    if len(lst) == 0:
        return ""
    var result = lst[0]
    var i = 1
    while i < len(lst):
        val item = lst[i]
        result = "{result}{separator}{item}"
        i = i + 1
    result

# Repeat a string n times
fn repeat_string(text: text, count: i64) -> text:
    var result = ""
    var i = 0
    while i < count:
        result = "{result}{text}"
        i = i + 1
    result

# Count occurrences of substring
fn count_occurrences(text: text, search: text) -> i64:
    var count = 0
    var i = 0
    while i < len(text):
        if i + len(search) <= len(text):
            val sub = substring(text, i, i + len(search))
            if sub == search:
                count = count + 1
        i = i + 1
    count

# Check if text contains substring
fn contains_substring(text: text, search: text) -> bool:
    index_of(text, search) >= 0

# Replace all occurrences of substring
fn replace_all(text: text, search: text, replace: text) -> text:
    var result = ""
    var i = 0
    while i < len(text):
        var found = false
        if i + len(search) <= len(text):
            val sub = substring(text, i, i + len(search))
            if sub == search:
                result = "{result}{replace}"
                i = i + len(search)
                found = true
        if not found:
            val ch = substring(text, i, i + 1)
            result = "{result}{ch}"
            i = i + 1
    result

# =============================================================================
# Environment and System Info
# =============================================================================

# Print environment variable (placeholder - Simple doesn't have env access)
fn print_env_info():
    print_info("Environment information not available in Simple runtime")

# Print system info
fn print_system_info():
    print_info("Simple Language CLI Utilities v1.0.0")
    print_info("Pure Simple implementation")

# =============================================================================
# Exit Helpers
# =============================================================================

# Exit with success message
fn exit_success(message: text):
    print_success(message)
    # Note: Simple doesn't have exit(), just print

# Exit with error message
fn exit_error(message: text):
    print_error(message)
    # Note: Simple doesn't have exit(), just print

# =============================================================================
# Convenience Functions
# =============================================================================

# Create a simple CLI with just flags
fn simple_cli_with_flags(name: text, version: text, flag_defs: list) -> tuple:
    var parser = create_parser(name, version)
    var i = 0
    while i < len(flag_defs):
        val flag_def = flag_defs[i]
        val flag_name = flag_def[0]
        val flag_short = flag_def[1]
        val flag_long = flag_def[2]
        val flag_help = flag_def[3]
        parser = add_flag(parser, flag_name, flag_short, flag_long, flag_help)
        i = i + 1
    parser

# Parse and validate in one step
fn parse_and_validate(parser: tuple, args: list) -> tuple:
    val result = parse_args(parser, args)
    if has_errors(result):
        print_validation_errors(result)
    result

# Print parse result summary
fn print_parse_summary(result: tuple):
    print_info("Parse Result Summary:")

    val flags = result[0]
    if len(flags) > 0:
        print "Flags:"
        var i = 0
        while i < len(flags):
            val flag = flags[i]
            val name = flag[0]
            val value = flag[4]
            print "  {name}: {value}"
            i = i + 1

    val options = result[1]
    if len(options) > 0:
        print "Options:"
        var j = 0
        while j < len(options):
            val option = options[j]
            val name = option[0]
            val value = option[5]
            print "  {name}: {value}"
            j = j + 1

    val positionals = result[2]
    if len(positionals) > 0:
        print "Positionals:"
        var k = 0
        while k < len(positionals):
            val pos = positionals[k]
            val name = pos[0]
            val value = pos[2]
            print "  {name}: {value}"
            k = k + 1
