# File System Utilities
#
# Miscellaneous utilities: temporary files, glob patterns, tree operations,
# symbolic links, disk usage, file type detection.
# Pure Simple implementations with mock backends.

mod file_system.types
mod file_system.file_ops
mod file_system.dir_ops
mod file_system.path_ops
mod file_system.metadata

# ============================================================================
# Temporary Files
# ============================================================================

fn temp_file_create() -> types.TempFile?:
    """Create a temporary file.

    Returns:
        Some(TempFile) or nil on error
    """
    val path = "/tmp/simple_temp_" + random_suffix()
    if not file_ops.file_create(path):
        return nil
    val temp = types.TempFile(path: path, cleanup_on_drop: true)
    Some(temp)

fn temp_file_create_with_name(name: text) -> types.TempFile?:
    """Create a temporary file with specific name.

    Args:
        name: File name

    Returns:
        Some(TempFile) or nil on error
    """
    val path = "/tmp/" + name
    if not file_ops.file_create(path):
        return nil
    val temp = types.TempFile(path: path, cleanup_on_drop: true)
    Some(temp)

fn temp_dir_create() -> text?:
    """Create a temporary directory.

    Returns:
        Some(path) or nil on error
    """
    val path = "/tmp/simple_temp_dir_" + random_suffix()
    if not dir_ops.dir_create(path):
        return nil
    Some(path)

fn temp_file_cleanup(temp: types.TempFile) -> bool:
    """Clean up temporary file.

    Args:
        temp: TempFile handle

    Returns:
        true on success, false on error
    """
    file_ops.file_delete(temp.path)

fn random_suffix() -> text:
    """Generate random suffix for temp files."""
    # Mock: return fixed suffix
    "abc123"

# ============================================================================
# Glob Pattern Matching
# ============================================================================

fn glob_match(pattern: text, path: text) -> bool:
    """Check if path matches glob pattern.

    Supports: *, ?, [abc]

    Args:
        pattern: Glob pattern
        path: Path to test

    Returns:
        true if matches
    """
    glob_match_recursive(pattern, path, 0, 0)

fn glob_match_recursive(pattern: text, path: text, pi: i64, pathi: i64) -> bool:
    """Recursive glob matching helper."""
    # Base cases
    if pi >= pattern.len() and pathi >= path.len():
        return true
    if pi >= pattern.len():
        return false
    if pathi >= path.len():
        # Check if remaining pattern is all *
        for i in pi..pattern.len():
            if pattern[i:i+1] != "*":
                return false
        return true

    val pc = pattern[pi:pi+1]
    val pathc = path[pathi:pathi+1]

    if pc == "*":
        # Try matching 0 or more characters
        val match_zero = glob_match_recursive(pattern, path, pi + 1, pathi)
        if match_zero:
            return true
        val match_more = glob_match_recursive(pattern, path, pi, pathi + 1)
        return match_more
    elif pc == "?":
        # Match any single character
        return glob_match_recursive(pattern, path, pi + 1, pathi + 1)
    elif pc == "[":
        # Character class (simplified)
        return glob_match_recursive(pattern, path, pi + 3, pathi + 1)
    else:
        # Literal character
        if pc == pathc:
            return glob_match_recursive(pattern, path, pi + 1, pathi + 1)
        return false

fn glob_find(pattern: text, root: text) -> [text]:
    """Find all files matching glob pattern.

    Args:
        pattern: Glob pattern
        root: Root directory to search

    Returns:
        Array of matching paths
    """
    val all_files = dir_ops.dir_walk_files(root)
    var matches = []
    for file in all_files:
        if glob_match(pattern, file):
            matches.push(file)
    matches

fn glob_find_files(pattern: text) -> [text]:
    """Find files matching pattern in current directory.

    Args:
        pattern: Glob pattern

    Returns:
        Array of matching paths
    """
    glob_find(pattern, ".")

fn glob_filter(paths: [text], pattern: text) -> [text]:
    """Filter paths by glob pattern.

    Args:
        paths: Array of paths
        pattern: Glob pattern

    Returns:
        Filtered array
    """
    var matches = []
    for p in paths:
        if glob_match(pattern, p):
            matches.push(p)
    matches

# ============================================================================
# Directory Tree Operations
# ============================================================================

fn tree_create(root: text, structure: [text]) -> bool:
    """Create directory tree from path list.

    Args:
        root: Root directory
        structure: Array of relative paths

    Returns:
        true on success, false on error
    """
    if not dir_ops.dir_create_all(root):
        return false

    for rel_path in structure:
        val full_path = path_ops.path_join2(root, rel_path)
        if rel_path.ends_with("/"):
            if not dir_ops.dir_create_all(full_path):
                return false
        else:
            val dir = path_ops.path_dirname(full_path)
            if not dir_ops.dir_create_all(dir):
                return false
            if not file_ops.file_create(full_path):
                return false

    true

fn tree_print(root: text) -> text:
    """Generate tree structure string.

    Args:
        root: Root directory

    Returns:
        Tree visualization
    """
    var output = root + "\n"
    tree_print_recursive(root, "", output)
    output

fn tree_print_recursive(path: text, indent: text, output):
    """Helper for tree printing."""
    val entries_opt = dir_ops.dir_list(path)
    if not entries_opt.?:
        return pass

    val entries = entries_opt.unwrap()
    for i in 0..entries.len():
        val entry = entries[i]
        val is_last = i == entries.len() - 1
        val branch = if is_last:
            "└── "
        else:
            "├── "

        output.push(indent + branch + entry + "\n")

        val full_path = path_ops.path_join2(path, entry)
        if dir_ops.dir_exists(full_path):
            val new_indent = if is_last:
                indent + "    "
            else:
                indent + "│   "
            tree_print_recursive(full_path, new_indent, output)

# ============================================================================
# Symbolic Links
# ============================================================================

fn symlink_create(target: text, link: text) -> bool:
    """Create symbolic link.

    Args:
        target: Target path
        link: Link path

    Returns:
        true on success, false on error
    """
    if target == "" or link == "":
        return false
    # Mock: simulate symlink creation
    true

fn symlink_read(link: text) -> text?:
    """Read symbolic link target.

    Args:
        link: Link path

    Returns:
        Some(target) or nil on error
    """
    if not metadata.file_is_symlink(link):
        return nil
    Some("/mock/target")

fn symlink_resolve(path: text) -> text?:
    """Resolve symbolic link to final target.

    Args:
        path: Path (may contain symlinks)

    Returns:
        Some(resolved) or nil on error
    """
    if not file_ops.file_exists(path):
        return nil
    # Mock: return path itself
    Some(path)

# ============================================================================
# Disk Usage
# ============================================================================

fn disk_usage(path: text) -> i64:
    """Calculate disk usage of path recursively.

    Args:
        path: File or directory path

    Returns:
        Total size in bytes
    """
    if metadata.file_is_file(path):
        val size_opt = metadata.file_size(path)
        if size_opt.?:
            return size_opt.unwrap()
        return 0
    elif metadata.file_is_directory(path):
        return dir_ops.dir_size(path)
    else:
        return 0

fn disk_usage_human(bytes: i64) -> text:
    """Format bytes as human-readable size.

    Args:
        bytes: Size in bytes

    Returns:
        Formatted string (e.g., "1.5 MB")
    """
    if bytes < 1024:
        return "{bytes} B"
    elif bytes < 1048576:
        val kb = bytes / 1024
        return "{kb} KB"
    elif bytes < 1073741824:
        val mb = bytes / 1048576
        return "{mb} MB"
    else:
        val gb = bytes / 1073741824
        return "{gb} GB"

# ============================================================================
# File Type Detection
# ============================================================================

fn file_type_from_extension(ext: text) -> text:
    """Guess file type from extension.

    Args:
        ext: File extension

    Returns:
        File type description
    """
    if ext == "txt" or ext == "md":
        return "text"
    elif ext == "jpg" or ext == "png" or ext == "gif":
        return "image"
    elif ext == "mp3" or ext == "wav" or ext == "flac":
        return "audio"
    elif ext == "mp4" or ext == "avi" or ext == "mkv":
        return "video"
    elif ext == "pdf":
        return "document"
    elif ext == "zip" or ext == "tar" or ext == "gz":
        return "archive"
    elif ext == "spl" or ext == "py" or ext == "js":
        return "code"
    else:
        return "unknown"

fn file_mime_type(path: text) -> text:
    """Guess MIME type from file extension.

    Args:
        path: File path

    Returns:
        MIME type string
    """
    val ext = path_ops.path_extension(path)

    if ext == "txt":
        return "text/plain"
    elif ext == "html" or ext == "htm":
        return "text/html"
    elif ext == "css":
        return "text/css"
    elif ext == "js":
        return "application/javascript"
    elif ext == "json":
        return "application/json"
    elif ext == "xml":
        return "application/xml"
    elif ext == "jpg" or ext == "jpeg":
        return "image/jpeg"
    elif ext == "png":
        return "image/png"
    elif ext == "gif":
        return "image/gif"
    elif ext == "svg":
        return "image/svg+xml"
    elif ext == "pdf":
        return "application/pdf"
    elif ext == "zip":
        return "application/zip"
    else:
        return "application/octet-stream"

fn file_is_text(path: text) -> bool:
    """Check if file is likely text based on extension.

    Args:
        path: File path

    Returns:
        true if likely text
    """
    val ext = path_ops.path_extension(path)
    val text_exts = ["txt", "md", "spl", "py", "js", "html", "css", "json", "xml", "csv"]

    for text_ext in text_exts:
        if ext == text_ext:
            return true

    false

fn file_is_binary(path: text) -> bool:
    """Check if file is likely binary based on extension.

    Args:
        path: File path

    Returns:
        true if likely binary
    """
    not file_is_text(path)

fn files_filter_by_extension(paths: [text], ext: text) -> [text]:
    """Filter files by extension.

    Args:
        paths: Array of paths
        ext: Extension to filter

    Returns:
        Filtered array
    """
    var result = []
    for p in paths:
        if path_ops.path_has_extension(p, ext):
            result.push(p)
    result

fn files_group_by_extension(paths: [text]) -> [(text, [text])]:
    """Group files by extension.

    Args:
        paths: Array of paths

    Returns:
        Array of (extension, paths) tuples
    """
    var groups = []
    var extensions = []

    # Collect unique extensions
    for p in paths:
        val ext = path_ops.path_extension(p)
        var found = false
        for e in extensions:
            if e == ext:
                found = true
                break
        if not found:
            extensions.push(ext)

    # Group by extension
    for ext in extensions:
        val filtered = files_filter_by_extension(paths, ext)
        groups.push((ext, filtered))

    groups

fn file_line_count(path: text) -> i64?:
    """Count lines in text file.

    Args:
        path: File path

    Returns:
        Some(line count) or nil on error
    """
    val lines_opt = file_ops.file_read_lines(path)
    if not lines_opt.?:
        return nil
    val lines = lines_opt.unwrap()
    Some(lines.len())

fn file_word_count(path: text) -> i64?:
    """Count words in text file.

    Args:
        path: File path

    Returns:
        Some(word count) or nil on error
    """
    val content_opt = file_ops.file_read_text(path)
    if not content_opt.?:
        return nil

    val content = content_opt.unwrap()
    val words = content.split(" ")
    Some(words.len())

fn file_char_count(path: text) -> i64?:
    """Count characters in text file.

    Args:
        path: File path

    Returns:
        Some(char count) or nil on error
    """
    val content_opt = file_ops.file_read_text(path)
    if not content_opt.?:
        return nil

    val content = content_opt.unwrap()
    Some(content.len())

# ============================================================================
# Exports
# ============================================================================

# Temporary files
export temp_file_create, temp_file_create_with_name, temp_dir_create, temp_file_cleanup

# Glob patterns
export glob_match, glob_find, glob_find_files, glob_filter

# Directory tree
export tree_create, tree_print

# Symbolic links
export symlink_create, symlink_read, symlink_resolve

# Disk usage
export disk_usage, disk_usage_human

# File type detection
export file_type_from_extension, file_mime_type
export file_is_text, file_is_binary
export files_filter_by_extension, files_group_by_extension
export file_line_count, file_word_count, file_char_count
