# Protocol Buffers Wire Format Utilities
# Provides comprehensive protobuf encoding/decoding functionality
# NO generics - uses concrete types and tuples

# ==============================================================================
# Wire Type Constants
# ==============================================================================

fn WIRE_TYPE_VARINT() -> i64: 0
fn WIRE_TYPE_FIXED64() -> i64: 1
fn WIRE_TYPE_LENGTH_DELIMITED() -> i64: 2
fn WIRE_TYPE_START_GROUP() -> i64: 3  # Deprecated
fn WIRE_TYPE_END_GROUP() -> i64: 4    # Deprecated
fn WIRE_TYPE_FIXED32() -> i64: 5

# ==============================================================================
# Varint Encoding/Decoding
# ==============================================================================

# Encode unsigned 64-bit integer as varint
# Returns list of bytes
fn encode_varint(value: i64) -> list:
    var result = []
    var v = value
    loop:
        if v < 128:
            result = result + [v]
            break
        var byte = (v & 127) | 128
        result = result + [byte]
        v = v >> 7
    result

# Decode varint from byte list starting at offset
# Returns (value, bytes_consumed) or nil on error
fn decode_varint(bytes: list, offset: i64) -> any:
    var result = 0
    var shift = 0
    var pos = offset
    var byte_count = bytes.length()

    loop:
        if pos >= byte_count:
            return nil
        if shift >= 64:
            return nil

        var byte_val = bytes[pos]
        var has_more = (byte_val & 128) != 0
        var value_bits = byte_val & 127

        result = result | (value_bits << shift)
        pos = pos + 1
        shift = shift + 7

        if not has_more:
            break

    (result, pos - offset)

# Compute size of varint encoding
fn varint_size(value: i64) -> i64:
    if value < 0:
        return 10  # Negative numbers always take 10 bytes

    var size = 1
    var v = value
    loop:
        v = v >> 7
        if v == 0:
            break
        size = size + 1
    size

# ==============================================================================
# ZigZag Encoding (for signed integers)
# ==============================================================================

# Encode signed 32-bit integer using ZigZag
fn zigzag_encode_32(value: i64) -> i64:
    ((value << 1) ^ (value >> 31)) & 0xFFFFFFFF

# Decode ZigZag encoded 32-bit integer
fn zigzag_decode_32(value: i64) -> i64:
    var unsigned = value & 0xFFFFFFFF
    var result = (unsigned >> 1) ^ (-(unsigned & 1))

    # Sign extend if negative
    if result & 0x80000000:
        result = result | 0xFFFFFFFF00000000
    result

# Encode signed 64-bit integer using ZigZag
fn zigzag_encode_64(value: i64) -> i64:
    (value << 1) ^ (value >> 63)

# Decode ZigZag encoded 64-bit integer
fn zigzag_decode_64(value: i64) -> i64:
    (value >> 1) ^ (-(value & 1))

# ==============================================================================
# Tag Encoding/Decoding
# ==============================================================================

# Encode field tag (field_number << 3 | wire_type)
fn encode_tag(field_number: i64, wire_type: i64) -> i64:
    (field_number << 3) | wire_type

# Decode tag into (field_number, wire_type)
fn decode_tag(tag: i64) -> any:
    var field_number = tag >> 3
    var wire_type = tag & 7
    (field_number, wire_type)

# Get field number from tag
fn tag_field_number(tag: i64) -> i64:
    tag >> 3

# Get wire type from tag
fn tag_wire_type(tag: i64) -> i64:
    tag & 7

# ==============================================================================
# Fixed-Width Encoding/Decoding
# ==============================================================================

# Encode 32-bit fixed value as little-endian bytes
fn encode_fixed32(value: i64) -> list:
    var v = value & 0xFFFFFFFF
    [
        v & 0xFF,
        (v >> 8) & 0xFF,
        (v >> 16) & 0xFF,
        (v >> 24) & 0xFF
    ]

# Decode 32-bit fixed value from little-endian bytes
fn decode_fixed32(bytes: list, offset: i64) -> any:
    var byte_count = bytes.length()
    if offset + 4 > byte_count:
        return nil

    var b0 = bytes[offset]
    var b1 = bytes[offset + 1]
    var b2 = bytes[offset + 2]
    var b3 = bytes[offset + 3]

    var result = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    (result, 4)

# Encode 64-bit fixed value as little-endian bytes
fn encode_fixed64(value: i64) -> list:
    [
        value & 0xFF,
        (value >> 8) & 0xFF,
        (value >> 16) & 0xFF,
        (value >> 24) & 0xFF,
        (value >> 32) & 0xFF,
        (value >> 40) & 0xFF,
        (value >> 48) & 0xFF,
        (value >> 56) & 0xFF
    ]

# Decode 64-bit fixed value from little-endian bytes
fn decode_fixed64(bytes: list, offset: i64) -> any:
    var byte_count = bytes.length()
    if offset + 8 > byte_count:
        return nil

    var b0 = bytes[offset]
    var b1 = bytes[offset + 1]
    var b2 = bytes[offset + 2]
    var b3 = bytes[offset + 3]
    var b4 = bytes[offset + 4]
    var b5 = bytes[offset + 5]
    var b6 = bytes[offset + 6]
    var b7 = bytes[offset + 7]

    var low = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    var high = b4 | (b5 << 8) | (b6 << 16) | (b7 << 24)
    var result = low | (high << 32)
    (result, 8)

# ==============================================================================
# Float/Double Encoding (using fixed-width as proxy)
# ==============================================================================

# Encode float as fixed32 (simplified - no actual IEEE 754 conversion)
fn encode_float(value: i64) -> list:
    encode_fixed32(value)

# Decode float from fixed32 bytes
fn decode_float(bytes: list, offset: i64) -> any:
    decode_fixed32(bytes, offset)

# Encode double as fixed64 (simplified - no actual IEEE 754 conversion)
fn encode_double(value: i64) -> list:
    encode_fixed64(value)

# Decode double from fixed64 bytes
fn decode_double(bytes: list, offset: i64) -> any:
    decode_fixed64(bytes, offset)

# ==============================================================================
# String/Bytes Encoding (Length-Delimited)
# ==============================================================================

# Encode string as length-delimited bytes
fn encode_string(value: text) -> list:
    var str_bytes = string_to_bytes(value)
    var len_bytes = encode_varint(str_bytes.length())
    len_bytes + str_bytes

# Encode bytes as length-delimited
fn encode_bytes(value: list) -> list:
    var len_bytes = encode_varint(value.length())
    len_bytes + value

# Decode length-delimited string
fn decode_string(bytes: list, offset: i64) -> any:
    var len_result = decode_varint(bytes, offset)
    if len_result == nil:
        return nil

    var length = len_result[0]
    var len_size = len_result[1]
    var start = offset + len_size
    var byte_count = bytes.length()

    if start + length > byte_count:
        return nil

    var str_bytes = bytes[start:start + length]
    var text_value = bytes_to_string(str_bytes)
    (text_value, len_size + length)

# Decode length-delimited bytes
fn decode_bytes(bytes: list, offset: i64) -> any:
    var len_result = decode_varint(bytes, offset)
    if len_result == nil:
        return nil

    var length = len_result[0]
    var len_size = len_result[1]
    var start = offset + len_size
    var byte_count = bytes.length()

    if start + length > byte_count:
        return nil

    var data = bytes[start:start + length]
    (data, len_size + length)

# ==============================================================================
# String/Bytes Conversion Helpers
# ==============================================================================

# Convert string to byte list (ASCII/UTF-8)
fn string_to_bytes(s: text) -> list:
    var result = []
    var i = 0
    var len = s.length()
    loop:
        if i >= len:
            break
        var char_code = s.char_at(i).ord()
        result = result + [char_code]
        i = i + 1
    result

# Convert byte list to string
fn bytes_to_string(bytes: list) -> text:
    var result = ""
    var i = 0
    var len = bytes.length()
    loop:
        if i >= len:
            break
        var byte_val = bytes[i]
        var char = byte_val.chr()
        result = result + char
        i = i + 1
    result

# ==============================================================================
# Field Encoding (Complete Fields)
# ==============================================================================

# Encode int32 field (varint)
fn encode_int32_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var value_masked = value & 0xFFFFFFFF
    var value_bytes = encode_varint(value_masked)
    tag_bytes + value_bytes

# Encode int64 field (varint)
fn encode_int64_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_varint(value)
    tag_bytes + value_bytes

# Encode uint32 field (varint)
fn encode_uint32_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var value_masked = value & 0xFFFFFFFF
    var value_bytes = encode_varint(value_masked)
    tag_bytes + value_bytes

# Encode uint64 field (varint)
fn encode_uint64_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_varint(value)
    tag_bytes + value_bytes

# Encode sint32 field (ZigZag + varint)
fn encode_sint32_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var zigzag = zigzag_encode_32(value)
    var value_bytes = encode_varint(zigzag)
    tag_bytes + value_bytes

# Encode sint64 field (ZigZag + varint)
fn encode_sint64_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var zigzag = zigzag_encode_64(value)
    var value_bytes = encode_varint(zigzag)
    tag_bytes + value_bytes

# Encode bool field (varint 0 or 1)
fn encode_bool_field(field_number: i64, value: bool) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var int_value = 0
    if value:
        int_value = 1
    var value_bytes = encode_varint(int_value)
    tag_bytes + value_bytes

# Encode enum field (varint)
fn encode_enum_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_VARINT())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_varint(value)
    tag_bytes + value_bytes

# Encode fixed32 field
fn encode_fixed32_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_FIXED32())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_fixed32(value)
    tag_bytes + value_bytes

# Encode fixed64 field
fn encode_fixed64_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_FIXED64())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_fixed64(value)
    tag_bytes + value_bytes

# Encode sfixed32 field (signed fixed32)
fn encode_sfixed32_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_FIXED32())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_fixed32(value)
    tag_bytes + value_bytes

# Encode sfixed64 field (signed fixed64)
fn encode_sfixed64_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_FIXED64())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_fixed64(value)
    tag_bytes + value_bytes

# Encode float field
fn encode_float_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_FIXED32())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_float(value)
    tag_bytes + value_bytes

# Encode double field
fn encode_double_field(field_number: i64, value: i64) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_FIXED64())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_double(value)
    tag_bytes + value_bytes

# Encode string field
fn encode_string_field(field_number: i64, value: text) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_LENGTH_DELIMITED())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_string(value)
    tag_bytes + value_bytes

# Encode bytes field
fn encode_bytes_field(field_number: i64, value: list) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_LENGTH_DELIMITED())
    var tag_bytes = encode_varint(tag)
    var value_bytes = encode_bytes(value)
    tag_bytes + value_bytes

# Encode embedded message field
fn encode_message_field(field_number: i64, message_bytes: list) -> list:
    var tag = encode_tag(field_number, WIRE_TYPE_LENGTH_DELIMITED())
    var tag_bytes = encode_varint(tag)
    var len_bytes = encode_varint(message_bytes.length())
    tag_bytes + len_bytes + message_bytes

# ==============================================================================
# Field Decoding
# ==============================================================================

# Decode field from bytes at offset
# Returns (field_number, wire_type, value, bytes_consumed) or nil
fn decode_field(bytes: list, offset: i64) -> any:
    var tag_result = decode_varint(bytes, offset)
    if tag_result == nil:
        return nil

    var tag = tag_result[0]
    var tag_size = tag_result[1]
    var decoded = decode_tag(tag)
    var field_number = decoded[0]
    var wire_type = decoded[1]

    var value_offset = offset + tag_size
    var value_result = nil

    if wire_type == WIRE_TYPE_VARINT():
        value_result = decode_varint(bytes, value_offset)
    if wire_type == WIRE_TYPE_FIXED64():
        value_result = decode_fixed64(bytes, value_offset)
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        value_result = decode_bytes(bytes, value_offset)
    if wire_type == WIRE_TYPE_FIXED32():
        value_result = decode_fixed32(bytes, value_offset)

    if value_result == nil:
        return nil

    var value = value_result[0]
    var value_size = value_result[1]
    var total_size = tag_size + value_size

    (field_number, wire_type, value, total_size)

# Decode int32 field value
fn decode_int32_value(value: i64) -> i64:
    var masked = value & 0xFFFFFFFF
    # Sign extend if negative
    if masked & 0x80000000:
        masked = masked | 0xFFFFFFFF00000000
    masked

# Decode uint32 field value
fn decode_uint32_value(value: i64) -> i64:
    value & 0xFFFFFFFF

# Decode sint32 field value (ZigZag)
fn decode_sint32_value(value: i64) -> i64:
    zigzag_decode_32(value)

# Decode sint64 field value (ZigZag)
fn decode_sint64_value(value: i64) -> i64:
    zigzag_decode_64(value)

# Decode bool field value
fn decode_bool_value(value: i64) -> bool:
    value != 0

# ==============================================================================
# Repeated Fields (Packed)
# ==============================================================================

# Encode packed repeated varint field
fn encode_packed_varint(field_number: i64, values: list) -> list:
    var data = []
    var i = 0
    var count = values.length()
    loop:
        if i >= count:
            break
        var v = values[i]
        var bytes = encode_varint(v)
        data = data + bytes
        i = i + 1

    encode_bytes_field(field_number, data)

# Encode packed repeated fixed32 field
fn encode_packed_fixed32(field_number: i64, values: list) -> list:
    var data = []
    var i = 0
    var count = values.length()
    loop:
        if i >= count:
            break
        var v = values[i]
        var bytes = encode_fixed32(v)
        data = data + bytes
        i = i + 1

    encode_bytes_field(field_number, data)

# Encode packed repeated fixed64 field
fn encode_packed_fixed64(field_number: i64, values: list) -> list:
    var data = []
    var i = 0
    var count = values.length()
    loop:
        if i >= count:
            break
        var v = values[i]
        var bytes = encode_fixed64(v)
        data = data + bytes
        i = i + 1

    encode_bytes_field(field_number, data)

# Decode packed repeated varint field
fn decode_packed_varint(bytes: list) -> list:
    var result = []
    var offset = 0
    var len = bytes.length()

    loop:
        if offset >= len:
            break
        var value_result = decode_varint(bytes, offset)
        if value_result == nil:
            break
        var value = value_result[0]
        var size = value_result[1]
        result = result + [value]
        offset = offset + size

    result

# Decode packed repeated fixed32 field
fn decode_packed_fixed32(bytes: list) -> list:
    var result = []
    var offset = 0
    var len = bytes.length()

    loop:
        if offset + 4 > len:
            break
        var value_result = decode_fixed32(bytes, offset)
        if value_result == nil:
            break
        var value = value_result[0]
        result = result + [value]
        offset = offset + 4

    result

# Decode packed repeated fixed64 field
fn decode_packed_fixed64(bytes: list) -> list:
    var result = []
    var offset = 0
    var len = bytes.length()

    loop:
        if offset + 8 > len:
            break
        var value_result = decode_fixed64(bytes, offset)
        if value_result == nil:
            break
        var value = value_result[0]
        result = result + [value]
        offset = offset + 8

    result

# ==============================================================================
# Message Encoding/Decoding
# ==============================================================================

# Encode complete message from field list
# Each field is (field_number, wire_type, value)
fn encode_message(fields: list) -> list:
    var result = []
    var i = 0
    var count = fields.length()

    loop:
        if i >= count:
            break
        var field = fields[i]
        var field_number = field[0]
        var wire_type = field[1]
        var value = field[2]

        var field_bytes = []

        if wire_type == WIRE_TYPE_VARINT():
            field_bytes = encode_int64_field(field_number, value)
        if wire_type == WIRE_TYPE_FIXED64():
            field_bytes = encode_fixed64_field(field_number, value)
        if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
            field_bytes = encode_bytes_field(field_number, value)
        if wire_type == WIRE_TYPE_FIXED32():
            field_bytes = encode_fixed32_field(field_number, value)

        result = result + field_bytes
        i = i + 1

    result

# Decode complete message into field list
# Returns list of (field_number, wire_type, value)
fn decode_message(bytes: list) -> list:
    var result = []
    var offset = 0
    var len = bytes.length()

    loop:
        if offset >= len:
            break

        var field_result = decode_field(bytes, offset)
        if field_result == nil:
            break

        var field_number = field_result[0]
        var wire_type = field_result[1]
        var value = field_result[2]
        var size = field_result[3]

        result = result + [(field_number, wire_type, value)]
        offset = offset + size

    result

# ==============================================================================
# Unknown Field Handling
# ==============================================================================

# Skip unknown field at offset
# Returns bytes consumed or nil
fn skip_field(bytes: list, offset: i64, wire_type: i64) -> any:
    if wire_type == WIRE_TYPE_VARINT():
        return decode_varint(bytes, offset)[1]
    if wire_type == WIRE_TYPE_FIXED64():
        return 8
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        var len_result = decode_varint(bytes, offset)
        if len_result == nil:
            return nil
        var length = len_result[0]
        var len_size = len_result[1]
        return len_size + length
    if wire_type == WIRE_TYPE_FIXED32():
        return 4
    nil

# Preserve unknown fields during decode
fn preserve_unknown_fields(bytes: list, known_field_numbers: list) -> list:
    var unknown = []
    var offset = 0
    var len = bytes.length()

    loop:
        if offset >= len:
            break

        var tag_result = decode_varint(bytes, offset)
        if tag_result == nil:
            break

        var tag = tag_result[0]
        var tag_size = tag_result[1]
        var decoded = decode_tag(tag)
        var field_number = decoded[0]
        var wire_type = decoded[1]

        var is_known = false
        var i = 0
        var known_count = known_field_numbers.length()
        loop:
            if i >= known_count:
                break
            if known_field_numbers[i] == field_number:
                is_known = true
                break
            i = i + 1

        var skip_size = skip_field(bytes, offset + tag_size, wire_type)
        if skip_size == nil:
            break

        if not is_known:
            var field_data = bytes[offset:offset + tag_size + skip_size]
            unknown = unknown + [field_data]

        offset = offset + tag_size + skip_size

    unknown

# ==============================================================================
# Default Value Handling
# ==============================================================================

# Get default value for wire type
fn default_value_for_type(wire_type: i64) -> any:
    if wire_type == WIRE_TYPE_VARINT():
        return 0
    if wire_type == WIRE_TYPE_FIXED64():
        return 0
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        return []
    if wire_type == WIRE_TYPE_FIXED32():
        return 0
    nil

# Check if value is default for type
fn is_default_value(value: any, wire_type: i64) -> bool:
    if wire_type == WIRE_TYPE_VARINT():
        return value == 0
    if wire_type == WIRE_TYPE_FIXED64():
        return value == 0
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        return value.length() == 0
    if wire_type == WIRE_TYPE_FIXED32():
        return value == 0
    false

# ==============================================================================
# Field Presence Detection
# ==============================================================================

# Find field in decoded message by field number
fn find_field(fields: list, field_number: i64) -> any:
    var i = 0
    var count = fields.length()
    loop:
        if i >= count:
            break
        var field = fields[i]
        if field[0] == field_number:
            return field
        i = i + 1
    nil

# Check if field is present in message
fn has_field(fields: list, field_number: i64) -> bool:
    var found = find_field(fields, field_number)
    found != nil

# Get field value or default
fn get_field_value(fields: list, field_number: i64, default: any) -> any:
    var field = find_field(fields, field_number)
    if field == nil:
        return default
    field[2]

# ==============================================================================
# Size Computation
# ==============================================================================

# Compute encoded size of field
fn field_size(field_number: i64, wire_type: i64, value: any) -> i64:
    var tag = encode_tag(field_number, wire_type)
    var tag_size = varint_size(tag)

    var value_size = 0
    if wire_type == WIRE_TYPE_VARINT():
        value_size = varint_size(value)
    if wire_type == WIRE_TYPE_FIXED64():
        value_size = 8
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        var len = value.length()
        value_size = varint_size(len) + len
    if wire_type == WIRE_TYPE_FIXED32():
        value_size = 4

    tag_size + value_size

# Compute encoded size of complete message
fn message_size(fields: list) -> i64:
    var total = 0
    var i = 0
    var count = fields.length()
    loop:
        if i >= count:
            break
        var field = fields[i]
        var field_number = field[0]
        var wire_type = field[1]
        var value = field[2]
        var size = field_size(field_number, wire_type, value)
        total = total + size
        i = i + 1
    total

# ==============================================================================
# Validation
# ==============================================================================

# Validate wire type
fn is_valid_wire_type(wire_type: i64) -> bool:
    wire_type >= 0 and wire_type <= 5

# Validate field number
fn is_valid_field_number(field_number: i64) -> bool:
    field_number > 0 and field_number < 536870912  # 2^29

# Validate message bytes (basic check)
fn is_valid_message(bytes: list) -> bool:
    var offset = 0
    var len = bytes.length()

    loop:
        if offset >= len:
            break

        var tag_result = decode_varint(bytes, offset)
        if tag_result == nil:
            return false

        var tag = tag_result[0]
        var tag_size = tag_result[1]
        var decoded = decode_tag(tag)
        var field_number = decoded[0]
        var wire_type = decoded[1]

        var valid_type = is_valid_wire_type(wire_type)
        if not valid_type:
            return false

        var valid_num = is_valid_field_number(field_number)
        if not valid_num:
            return false

        var skip_size = skip_field(bytes, offset + tag_size, wire_type)
        if skip_size == nil:
            return false

        offset = offset + tag_size + skip_size

    true

# ==============================================================================
# Utility Functions
# ==============================================================================

# Concatenate multiple byte lists
fn concat_bytes(byte_lists: list) -> list:
    var result = []
    var i = 0
    var count = byte_lists.length()
    loop:
        if i >= count:
            break
        var bytes = byte_lists[i]
        result = result + bytes
        i = i + 1
    result

# Create field tuple
fn make_field(field_number: i64, wire_type: i64, value: any) -> any:
    (field_number, wire_type, value)

# Compare two messages for equality
fn messages_equal(msg1: list, msg2: list) -> bool:
    var len1 = msg1.length()
    var len2 = msg2.length()
    if len1 != len2:
        return false

    var i = 0
    loop:
        if i >= len1:
            break
        var field1 = msg1[i]
        var field2 = msg2[i]

        if field1[0] != field2[0]:
            return false
        if field1[1] != field2[1]:
            return false
        if field1[2] != field2[2]:
            return false

        i = i + 1

    true

# Clone message (deep copy)
fn clone_message(fields: list) -> list:
    var result = []
    var i = 0
    var count = fields.length()
    loop:
        if i >= count:
            break
        var field = fields[i]
        var field_number = field[0]
        var wire_type = field[1]
        var value = field[2]
        result = result + [(field_number, wire_type, value)]
        i = i + 1
    result
