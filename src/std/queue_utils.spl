# Queue, Stack, and Deque Utilities
#
# Comprehensive data structure implementations for queues, stacks, deques,
# priority queues, and circular buffers.
# Pure Simple implementation - no generics at runtime, no FFI.
#
# Data Structures:
# - Queue: FIFO (First In First Out) operations
# - Stack: LIFO (Last In First Out) operations
# - Deque: Double-ended queue (push/pop from both ends)
# - Priority Queue: Elements ordered by priority
# - Circular Buffer: Fixed-size ring buffer
#
# Note: All implementations use arrays internally.
# Due to runtime limitations, we avoid generics and use dynamic typing.
#
# Queue Functions (FIFO):
# - queue_new: Create empty queue
# - queue_enqueue: Add element to back
# - queue_dequeue: Remove element from front
# - queue_peek: View front element
# - queue_is_empty: Check if empty
# - queue_size: Get element count
# - queue_clear: Remove all elements
# - queue_to_array: Convert to array
# - queue_from_array: Create from array
#
# Stack Functions (LIFO):
# - stack_new: Create empty stack
# - stack_push: Add element to top
# - stack_pop: Remove element from top
# - stack_peek: View top element
# - stack_is_empty: Check if empty
# - stack_size: Get element count
# - stack_clear: Remove all elements
# - stack_to_array: Convert to array
# - stack_from_array: Create from array
#
# Deque Functions (Double-ended):
# - deque_new: Create empty deque
# - deque_push_front: Add to front
# - deque_push_back: Add to back
# - deque_pop_front: Remove from front
# - deque_pop_back: Remove from back
# - deque_peek_front: View front element
# - deque_peek_back: View back element
# - deque_is_empty: Check if empty
# - deque_size: Get element count
# - deque_clear: Remove all elements
#
# Priority Queue Functions:
# - pqueue_new: Create empty priority queue
# - pqueue_insert: Insert with priority
# - pqueue_extract_max: Remove highest priority
# - pqueue_extract_min: Remove lowest priority
# - pqueue_peek_max: View highest priority
# - pqueue_peek_min: View lowest priority
# - pqueue_is_empty: Check if empty
# - pqueue_size: Get element count
#
# Circular Buffer Functions:
# - cbuffer_new: Create with capacity
# - cbuffer_write: Write element (overwrites oldest)
# - cbuffer_read: Read oldest element
# - cbuffer_peek: View oldest element
# - cbuffer_is_empty: Check if empty
# - cbuffer_is_full: Check if full
# - cbuffer_size: Get element count
# - cbuffer_capacity: Get total capacity
# - cbuffer_clear: Remove all elements

# ============================================================================
# Queue Implementation (FIFO)
# ============================================================================

fn queue_new():
    """Create a new empty queue.

    Queues are FIFO (First In First Out).

    Example:
        val q = queue_new()
    """
    (items: [], )

fn queue_enqueue(queue, item):
    """Add item to the back of the queue.

    Modifies the queue in place.

    Example:
        val q = queue_new()
        queue_enqueue(q, 1)
        queue_enqueue(q, 2)
        # Queue now contains: [1, 2]
    """
    queue.items.push(item)

fn queue_dequeue(queue):
    """Remove and return item from the front of the queue.

    Returns Some(item) if queue is not empty, nil otherwise.

    Example:
        val q = queue_from_array([1, 2, 3])
        queue_dequeue(q)  # Some(1)
        queue_dequeue(q)  # Some(2)
    """
    if queue.items.len() == 0:
        return nil

    val item = queue.items[0]
    var new_items = []
    var i = 1
    while i < queue.items.len():
        new_items.push(queue.items[i])
        i = i + 1

    queue.items = new_items
    Some(item)

fn queue_peek(queue):
    """View the front item without removing it.

    Returns Some(item) if queue is not empty, nil otherwise.

    Example:
        val q = queue_from_array([1, 2, 3])
        queue_peek(q)  # Some(1)
        queue_peek(q)  # Some(1) - still there
    """
    if queue.items.len() == 0:
        return nil
    Some(queue.items[0])

fn queue_is_empty(queue):
    """Check if queue is empty.

    Example:
        val q = queue_new()
        queue_is_empty(q)  # true
    """
    queue.items.len() == 0

fn queue_size(queue):
    """Get number of items in queue.

    Example:
        val q = queue_from_array([1, 2, 3])
        queue_size(q)  # 3
    """
    queue.items.len()

fn queue_clear(queue):
    """Remove all items from queue.

    Example:
        queue_clear(q)
    """
    queue.items = []

fn queue_to_array(queue):
    """Convert queue to array (front to back).

    Example:
        val q = queue_from_array([1, 2, 3])
        queue_to_array(q)  # [1, 2, 3]
    """
    queue.items

fn queue_from_array(arr):
    """Create queue from array.

    First element becomes front of queue.

    Example:
        val q = queue_from_array([1, 2, 3])
        queue_dequeue(q)  # Some(1)
    """
    var items = []
    for item in arr:
        items.push(item)
    (items: items, )

fn queue_contains(queue, item):
    """Check if queue contains item.

    Example:
        val q = queue_from_array([1, 2, 3])
        queue_contains(q, 2)  # true
    """
    for elem in queue.items:
        if elem == item:
            return true
    false

# ============================================================================
# Stack Implementation (LIFO)
# ============================================================================

fn stack_new():
    """Create a new empty stack.

    Stacks are LIFO (Last In First Out).

    Example:
        val s = stack_new()
    """
    (items: [], )

fn stack_push(stack, item):
    """Push item onto the top of the stack.

    Example:
        val s = stack_new()
        stack_push(s, 1)
        stack_push(s, 2)
        # Stack now has 2 on top, 1 on bottom
    """
    stack.items.push(item)

fn stack_pop(stack):
    """Pop and return item from the top of the stack.

    Returns Some(item) if stack is not empty, nil otherwise.

    Example:
        val s = stack_from_array([1, 2, 3])
        stack_pop(s)  # Some(3)
        stack_pop(s)  # Some(2)
    """
    if stack.items.len() == 0:
        return nil

    val idx = stack.items.len() - 1
    val item = stack.items[idx]

    var new_items = []
    var i = 0
    while i < idx:
        new_items.push(stack.items[i])
        i = i + 1

    stack.items = new_items
    Some(item)

fn stack_peek(stack):
    """View the top item without removing it.

    Returns Some(item) if stack is not empty, nil otherwise.

    Example:
        val s = stack_from_array([1, 2, 3])
        stack_peek(s)  # Some(3)
    """
    if stack.items.len() == 0:
        return nil
    Some(stack.items[stack.items.len() - 1])

fn stack_is_empty(stack):
    """Check if stack is empty.

    Example:
        val s = stack_new()
        stack_is_empty(s)  # true
    """
    stack.items.len() == 0

fn stack_size(stack):
    """Get number of items in stack.

    Example:
        val s = stack_from_array([1, 2, 3])
        stack_size(s)  # 3
    """
    stack.items.len()

fn stack_clear(stack):
    """Remove all items from stack.

    Example:
        stack_clear(s)
    """
    stack.items = []

fn stack_to_array(stack):
    """Convert stack to array (bottom to top).

    Example:
        val s = stack_from_array([1, 2, 3])
        stack_to_array(s)  # [1, 2, 3]
    """
    stack.items

fn stack_from_array(arr):
    """Create stack from array.

    Last element becomes top of stack.

    Example:
        val s = stack_from_array([1, 2, 3])
        stack_pop(s)  # Some(3)
    """
    var items = []
    for item in arr:
        items.push(item)
    (items: items, )

fn stack_contains(stack, item):
    """Check if stack contains item.

    Example:
        val s = stack_from_array([1, 2, 3])
        stack_contains(s, 2)  # true
    """
    for elem in stack.items:
        if elem == item:
            return true
    false

# ============================================================================
# Deque Implementation (Double-ended Queue)
# ============================================================================

fn deque_new():
    """Create a new empty deque (double-ended queue).

    Can push/pop from both front and back.

    Example:
        val d = deque_new()
    """
    (items: [], )

fn deque_push_front(deque, item):
    """Add item to the front of the deque.

    Example:
        val d = deque_new()
        deque_push_back(d, 2)
        deque_push_front(d, 1)
        # Deque: [1, 2]
    """
    var new_items = [item]
    for elem in deque.items:
        new_items.push(elem)
    deque.items = new_items

fn deque_push_back(deque, item):
    """Add item to the back of the deque.

    Example:
        val d = deque_new()
        deque_push_back(d, 1)
        deque_push_back(d, 2)
        # Deque: [1, 2]
    """
    deque.items.push(item)

fn deque_pop_front(deque):
    """Remove and return item from the front.

    Returns Some(item) if not empty, nil otherwise.

    Example:
        val d = deque_from_array([1, 2, 3])
        deque_pop_front(d)  # Some(1)
    """
    if deque.items.len() == 0:
        return nil

    val item = deque.items[0]
    var new_items = []
    var i = 1
    while i < deque.items.len():
        new_items.push(deque.items[i])
        i = i + 1

    deque.items = new_items
    Some(item)

fn deque_pop_back(deque):
    """Remove and return item from the back.

    Returns Some(item) if not empty, nil otherwise.

    Example:
        val d = deque_from_array([1, 2, 3])
        deque_pop_back(d)  # Some(3)
    """
    if deque.items.len() == 0:
        return nil

    val idx = deque.items.len() - 1
    val item = deque.items[idx]

    var new_items = []
    var i = 0
    while i < idx:
        new_items.push(deque.items[i])
        i = i + 1

    deque.items = new_items
    Some(item)

fn deque_peek_front(deque):
    """View the front item without removing it.

    Returns Some(item) if not empty, nil otherwise.

    Example:
        val d = deque_from_array([1, 2, 3])
        deque_peek_front(d)  # Some(1)
    """
    if deque.items.len() == 0:
        return nil
    Some(deque.items[0])

fn deque_peek_back(deque):
    """View the back item without removing it.

    Returns Some(item) if not empty, nil otherwise.

    Example:
        val d = deque_from_array([1, 2, 3])
        deque_peek_back(d)  # Some(3)
    """
    if deque.items.len() == 0:
        return nil
    Some(deque.items[deque.items.len() - 1])

fn deque_is_empty(deque):
    """Check if deque is empty.

    Example:
        val d = deque_new()
        deque_is_empty(d)  # true
    """
    deque.items.len() == 0

fn deque_size(deque):
    """Get number of items in deque.

    Example:
        val d = deque_from_array([1, 2, 3])
        deque_size(d)  # 3
    """
    deque.items.len()

fn deque_clear(deque):
    """Remove all items from deque.

    Example:
        deque_clear(d)
    """
    deque.items = []

fn deque_to_array(deque):
    """Convert deque to array.

    Example:
        val d = deque_from_array([1, 2, 3])
        deque_to_array(d)  # [1, 2, 3]
    """
    deque.items

fn deque_from_array(arr):
    """Create deque from array.

    Example:
        val d = deque_from_array([1, 2, 3])
    """
    var items = []
    for item in arr:
        items.push(item)
    (items: items, )

# ============================================================================
# Priority Queue Implementation
# ============================================================================

fn pqueue_new():
    """Create a new empty priority queue.

    Items are stored as (priority, value) tuples.
    Higher priority numbers = higher priority.

    Example:
        val pq = pqueue_new()
    """
    (items: [], )

fn pqueue_insert(pqueue, priority, value):
    """Insert item with given priority.

    Items with higher priority values are extracted first.

    Example:
        val pq = pqueue_new()
        pqueue_insert(pq, 5, "medium")
        pqueue_insert(pq, 10, "high")
        pqueue_insert(pq, 1, "low")
    """
    pqueue.items.push((priority, value))

fn pqueue_extract_max(pqueue):
    """Remove and return item with highest priority.

    Returns Some((priority, value)) if not empty, nil otherwise.

    Example:
        val pq = pqueue_new()
        pqueue_insert(pq, 5, "A")
        pqueue_insert(pq, 10, "B")
        pqueue_extract_max(pq)  # Some((10, "B"))
    """
    if pqueue.items.len() == 0:
        return nil

    # Find index of max priority
    var max_idx = 0
    var max_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority > max_priority:
            max_priority = current_priority
            max_idx = i
        i = i + 1

    val item = pqueue.items[max_idx]

    # Remove item at max_idx
    var new_items = []
    var idx = 0
    while idx < pqueue.items.len():
        if idx != max_idx:
            new_items.push(pqueue.items[idx])
        idx = idx + 1

    pqueue.items = new_items
    Some(item)

fn pqueue_extract_min(pqueue):
    """Remove and return item with lowest priority.

    Returns Some((priority, value)) if not empty, nil otherwise.

    Example:
        val pq = pqueue_new()
        pqueue_insert(pq, 5, "A")
        pqueue_insert(pq, 1, "B")
        pqueue_extract_min(pq)  # Some((1, "B"))
    """
    if pqueue.items.len() == 0:
        return nil

    # Find index of min priority
    var min_idx = 0
    var min_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority < min_priority:
            min_priority = current_priority
            min_idx = i
        i = i + 1

    val item = pqueue.items[min_idx]

    # Remove item at min_idx
    var new_items = []
    var idx = 0
    while idx < pqueue.items.len():
        if idx != min_idx:
            new_items.push(pqueue.items[idx])
        idx = idx + 1

    pqueue.items = new_items
    Some(item)

fn pqueue_peek_max(pqueue):
    """View item with highest priority without removing it.

    Returns Some((priority, value)) if not empty, nil otherwise.

    Example:
        val pq = pqueue_new()
        pqueue_insert(pq, 5, "A")
        pqueue_peek_max(pq)  # Some((5, "A"))
    """
    if pqueue.items.len() == 0:
        return nil

    var max_idx = 0
    var max_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority > max_priority:
            max_priority = current_priority
            max_idx = i
        i = i + 1

    Some(pqueue.items[max_idx])

fn pqueue_peek_min(pqueue):
    """View item with lowest priority without removing it.

    Returns Some((priority, value)) if not empty, nil otherwise.

    Example:
        val pq = pqueue_new()
        pqueue_insert(pq, 5, "A")
        pqueue_peek_min(pq)  # Some((5, "A"))
    """
    if pqueue.items.len() == 0:
        return nil

    var min_idx = 0
    var min_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority < min_priority:
            min_priority = current_priority
            min_idx = i
        i = i + 1

    Some(pqueue.items[min_idx])

fn pqueue_is_empty(pqueue):
    """Check if priority queue is empty.

    Example:
        val pq = pqueue_new()
        pqueue_is_empty(pq)  # true
    """
    pqueue.items.len() == 0

fn pqueue_size(pqueue):
    """Get number of items in priority queue.

    Example:
        val pq = pqueue_new()
        pqueue_insert(pq, 5, "A")
        pqueue_size(pq)  # 1
    """
    pqueue.items.len()

fn pqueue_clear(pqueue):
    """Remove all items from priority queue.

    Example:
        pqueue_clear(pq)
    """
    pqueue.items = []

fn pqueue_to_array(pqueue):
    """Convert priority queue to array of (priority, value) tuples.

    Order is arbitrary (not sorted by priority).

    Example:
        pqueue_to_array(pq)
    """
    pqueue.items

# ============================================================================
# Circular Buffer Implementation (Ring Buffer)
# ============================================================================

fn cbuffer_new(capacity):
    """Create a new circular buffer with given capacity.

    Circular buffers have fixed size. When full, writing
    overwrites the oldest element.

    Example:
        val cb = cbuffer_new(5)  # capacity of 5 items
    """
    (items: [], capacity: capacity, head: 0, tail: 0, full: false, )

fn cbuffer_write(cbuffer, item):
    """Write item to circular buffer.

    If buffer is full, overwrites oldest item.

    Example:
        val cb = cbuffer_new(3)
        cbuffer_write(cb, 1)
        cbuffer_write(cb, 2)
        cbuffer_write(cb, 3)
        cbuffer_write(cb, 4)  # overwrites 1
    """
    if cbuffer.items.len() < cbuffer.capacity:
        # Buffer not yet at capacity
        cbuffer.items.push(item)
        cbuffer.tail = cbuffer.items.len()
        if cbuffer.tail == cbuffer.capacity:
            cbuffer.full = true
    else:
        # Buffer at capacity - overwrite
        cbuffer.items[cbuffer.tail] = item
        cbuffer.tail = (cbuffer.tail + 1) % cbuffer.capacity

        if cbuffer.full:
            cbuffer.head = cbuffer.tail

fn cbuffer_read(cbuffer):
    """Read and remove oldest item from buffer.

    Returns Some(item) if not empty, nil otherwise.

    Example:
        val cb = cbuffer_new(3)
        cbuffer_write(cb, 1)
        cbuffer_write(cb, 2)
        cbuffer_read(cb)  # Some(1)
    """
    if cbuffer_is_empty(cbuffer):
        return nil

    val item = cbuffer.items[cbuffer.head]

    val was_full = cbuffer.full
    cbuffer.full = false
    cbuffer.head = (cbuffer.head + 1) % cbuffer.items.len()

    # If we read the last item, reset
    if not was_full and cbuffer.head == cbuffer.tail:
        cbuffer.head = 0
        cbuffer.tail = 0
        cbuffer.items = []

    Some(item)

fn cbuffer_peek(cbuffer):
    """View oldest item without removing it.

    Returns Some(item) if not empty, nil otherwise.

    Example:
        val cb = cbuffer_new(3)
        cbuffer_write(cb, 1)
        cbuffer_peek(cb)  # Some(1)
    """
    if cbuffer_is_empty(cbuffer):
        return nil
    Some(cbuffer.items[cbuffer.head])

fn cbuffer_is_empty(cbuffer):
    """Check if circular buffer is empty.

    Example:
        val cb = cbuffer_new(5)
        cbuffer_is_empty(cb)  # true
    """
    not cbuffer.full and cbuffer.head == cbuffer.tail

fn cbuffer_is_full(cbuffer):
    """Check if circular buffer is full.

    Example:
        val cb = cbuffer_new(2)
        cbuffer_write(cb, 1)
        cbuffer_write(cb, 2)
        cbuffer_is_full(cb)  # true
    """
    cbuffer.full

fn cbuffer_size(cbuffer):
    """Get current number of items in buffer.

    Example:
        val cb = cbuffer_new(5)
        cbuffer_write(cb, 1)
        cbuffer_write(cb, 2)
        cbuffer_size(cb)  # 2
    """
    if cbuffer.full:
        return cbuffer.capacity

    if cbuffer.tail >= cbuffer.head:
        cbuffer.tail - cbuffer.head
    else:
        cbuffer.capacity - (cbuffer.head - cbuffer.tail)

fn cbuffer_capacity(cbuffer):
    """Get total capacity of buffer.

    Example:
        val cb = cbuffer_new(5)
        cbuffer_capacity(cb)  # 5
    """
    cbuffer.capacity

fn cbuffer_clear(cbuffer):
    """Remove all items from buffer.

    Example:
        cbuffer_clear(cb)
    """
    cbuffer.items = []
    cbuffer.head = 0
    cbuffer.tail = 0
    cbuffer.full = false

fn cbuffer_to_array(cbuffer):
    """Convert buffer contents to array (oldest to newest).

    Example:
        val cb = cbuffer_new(5)
        cbuffer_write(cb, 1)
        cbuffer_write(cb, 2)
        cbuffer_to_array(cb)  # [1, 2]
    """
    if cbuffer_is_empty(cbuffer):
        return []

    var result = []

    if not cbuffer.full:
        # Simple case: items from head to tail
        var i = cbuffer.head
        while i < cbuffer.tail:
            result.push(cbuffer.items[i])
            i = i + 1
    else:
        # Full buffer: wrap around case
        var i = cbuffer.head
        while i < cbuffer.items.len():
            result.push(cbuffer.items[i])
            i = i + 1

        var j = 0
        while j < cbuffer.tail:
            result.push(cbuffer.items[j])
            j = j + 1

    result

# ============================================================================
# Utility Functions
# ============================================================================

fn queue_filter(queue, predicate):
    """Create new queue with items matching predicate.

    Example:
        val q = queue_from_array([1, 2, 3, 4, 5])
        val evens = queue_filter(q, \x: x % 2 == 0)
        # evens contains [2, 4]
    """
    var items = []
    for item in queue.items:
        if predicate(item):
            items.push(item)
    (items: items, )

fn stack_filter(stack, predicate):
    """Create new stack with items matching predicate.

    Example:
        val s = stack_from_array([1, 2, 3, 4, 5])
        val evens = stack_filter(s, \x: x % 2 == 0)
    """
    var items = []
    for item in stack.items:
        if predicate(item):
            items.push(item)
    (items: items, )

fn queue_map(queue, f):
    """Create new queue by applying function to each item.

    Example:
        val q = queue_from_array([1, 2, 3])
        val doubled = queue_map(q, \x: x * 2)
        # doubled contains [2, 4, 6]
    """
    var items = []
    for item in queue.items:
        items.push(f(item))
    (items: items, )

fn stack_map(stack, f):
    """Create new stack by applying function to each item.

    Example:
        val s = stack_from_array([1, 2, 3])
        val doubled = stack_map(s, \x: x * 2)
    """
    var items = []
    for item in stack.items:
        items.push(f(item))
    (items: items, )

fn queue_reverse(queue):
    """Create new queue with items in reverse order.

    Example:
        val q = queue_from_array([1, 2, 3])
        val r = queue_reverse(q)
        # r contains [3, 2, 1]
    """
    var items = []
    var i = queue.items.len() - 1
    while i >= 0:
        items.push(queue.items[i])
        i = i - 1
    (items: items, )

fn stack_reverse(stack):
    """Create new stack with items in reverse order.

    Example:
        val s = stack_from_array([1, 2, 3])
        val r = stack_reverse(s)
    """
    var items = []
    var i = stack.items.len() - 1
    while i >= 0:
        items.push(stack.items[i])
        i = i - 1
    (items: items, )

fn pqueue_sorted_array(pqueue, descending):
    """Convert priority queue to sorted array.

    If descending is true, highest priority first.
    Otherwise, lowest priority first.

    Example:
        val pq = pqueue_new()
        pqueue_insert(pq, 5, "A")
        pqueue_insert(pq, 2, "B")
        pqueue_sorted_array(pq, true)  # [(5, "A"), (2, "B")]
    """
    # Simple bubble sort
    var sorted = []
    for item in pqueue.items:
        sorted.push(item)

    var n = sorted.len()
    var swapped = true
    while swapped:
        swapped = false
        var i = 1
        while i < n:
            var should_swap = false
            if descending:
                should_swap = sorted[i-1].0 < sorted[i].0
            else:
                should_swap = sorted[i-1].0 > sorted[i].0

            if should_swap:
                val temp = sorted[i-1]
                sorted[i-1] = sorted[i]
                sorted[i] = temp
                swapped = true
            i = i + 1
        n = n - 1

    sorted
