# Collection Utilities
#
# Additional collection helper functions for arrays and lists.
# Complements array.spl and list_utils.spl with advanced operations.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - partition: Split array by predicate
# - group_consecutive: Group consecutive equal elements
# - intersperse: Insert element between all elements
# - transpose: Transpose 2D array
# - cartesian_product: Cartesian product of two arrays
# - sliding_window: Create sliding windows
# - frequencies: Count element frequencies
# - mode: Find most common element
# - median: Find median value
# - remove_duplicates: Remove duplicate elements (preserve order)
# - intersect: Find common elements
# - difference: Find elements in first but not second
# - union: Combine unique elements from both arrays

# ============================================================================
# Array Partitioning
# ============================================================================

fn partition(arr, predicate):
    """Split array into two: [matches, non-matches].

    Returns tuple of two arrays.

    Example:
        partition([1,2,3,4,5], \x: x % 2 == 0)
        # ([2, 4], [1, 3, 5])
    """
    var matches = []
    var non_matches = []

    for item in arr:
        if predicate(item):
            matches.push(item)
        else:
            non_matches.push(item)

    (matches, non_matches)

fn group_consecutive(arr):
    """Group consecutive equal elements.

    Example:
        group_consecutive([1,1,2,2,2,3,1])
        # [[1,1], [2,2,2], [3], [1]]
    """
    if arr.len() == 0:
        return []

    var result = []
    var current_group = [arr[0]]

    var i = 1
    while i < arr.len():
        if arr[i] == arr[i-1]:
            current_group.push(arr[i])
        else:
            result.push(current_group)
            current_group = [arr[i]]
        i = i + 1

    result.push(current_group)
    result

# ============================================================================
# Array Transformation
# ============================================================================

fn intersperse(arr, separator):
    """Insert separator between all elements.

    Example:
        intersperse([1,2,3], 0)  # [1,0,2,0,3]
    """
    if arr.len() <= 1:
        return arr

    var result = [arr[0]]
    var i = 1
    while i < arr.len():
        result.push(separator)
        result.push(arr[i])
        i = i + 1

    result

fn transpose(matrix):
    """Transpose a 2D array (matrix).

    Example:
        transpose([[1,2,3], [4,5,6]])
        # [[1,4], [2,5], [3,6]]
    """
    if matrix.len() == 0:
        return []

    val rows = matrix.len()
    val cols = matrix[0].len()

    var result = []
    var col = 0
    while col < cols:
        var new_row = []
        var row = 0
        while row < rows:
            new_row.push(matrix[row][col])
            row = row + 1
        result.push(new_row)
        col = col + 1

    result

fn cartesian_product(arr1, arr2):
    """Cartesian product of two arrays.

    Returns array of tuples representing all pairs.

    Example:
        cartesian_product([1,2], [3,4])
        # [(1,3), (1,4), (2,3), (2,4)]
    """
    var result = []

    for a in arr1:
        for b in arr2:
            result.push((a, b))

    result

fn sliding_window(arr, size):
    """Create sliding windows of given size.

    Example:
        sliding_window([1,2,3,4,5], 3)
        # [[1,2,3], [2,3,4], [3,4,5]]
    """
    if size > arr.len() or size <= 0:
        return []

    var result = []
    var i = 0
    while i <= arr.len() - size:
        var window = []
        var j = 0
        while j < size:
            window.push(arr[i + j])
            j = j + 1
        result.push(window)
        i = i + 1

    result

# ============================================================================
# Statistical Functions
# ============================================================================

fn frequencies(arr):
    """Count element frequencies.

    Returns dictionary-like representation as array of (element, count) tuples.

    Example:
        frequencies([1,2,2,3,3,3])
        # [(1,1), (2,2), (3,3)]
    """
    var counts = []

    for item in arr:
        # Find if item already counted
        var found = false
        var idx = 0
        while idx < counts.len():
            val (elem, count) = counts[idx]
            if elem == item:
                counts[idx] = (elem, count + 1)
                found = true
                break
            idx = idx + 1

        if not found:
            counts.push((item, 1))

    counts

fn mode(arr):
    """Find most common element.

    Returns the element that appears most frequently.
    If multiple elements tie, returns the first one encountered.

    Returns nil for empty array.
    """
    if arr.len() == 0:
        return nil

    val freqs = frequencies(arr)

    var max_count = 0
    var mode_elem = nil

    for (elem, count) in freqs:
        if count > max_count:
            max_count = count
            mode_elem = elem

    mode_elem

fn median(arr):
    """Find median value of sorted numeric array.

    Array must be sorted for correct result.
    For even-length arrays, returns lower middle element.

    Returns nil for empty array.
    """
    if arr.len() == 0:
        return nil

    val mid = arr.len() / 2

    if arr.len() % 2 == 1:
        # Odd length: return middle element
        arr[mid]
    else:
        # Even length: return lower middle
        # (Ideally would average the two middle elements,
        # but that requires float conversion)
        arr[mid - 1]

# ============================================================================
# Set Operations
# ============================================================================

fn remove_duplicates(arr):
    """Remove duplicate elements, preserving first occurrence order.

    Example:
        remove_duplicates([1,2,2,3,1,4])  # [1,2,3,4]
    """
    var result = []
    var seen = []

    for item in arr:
        var found = false
        for s in seen:
            if s == item:
                found = true
                break

        if not found:
            result.push(item)
            seen.push(item)

    result

fn intersect(arr1, arr2):
    """Find common elements (set intersection).

    Returns elements that appear in both arrays.
    Duplicates are removed.

    Example:
        intersect([1,2,3], [2,3,4])  # [2,3]
    """
    var result = []
    var seen = []

    for item in arr1:
        # Check if in arr2
        var in_arr2 = false
        for item2 in arr2:
            if item == item2:
                in_arr2 = true
                break

        # Check if not already added
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if in_arr2 and not already_added:
            result.push(item)
            seen.push(item)

    result

fn difference(arr1, arr2):
    """Find elements in arr1 but not in arr2 (set difference).

    Example:
        difference([1,2,3,4], [2,4])  # [1,3]
    """
    var result = []

    for item in arr1:
        var in_arr2 = false
        for item2 in arr2:
            if item == item2:
                in_arr2 = true
                break

        if not in_arr2:
            var already_added = false
            for r in result:
                if r == item:
                    already_added = true
                    break

            if not already_added:
                result.push(item)

    result

fn union(arr1, arr2):
    """Combine unique elements from both arrays (set union).

    Example:
        union([1,2,3], [3,4,5])  # [1,2,3,4,5]
    """
    var result = []
    var seen = []

    # Add all from arr1
    for item in arr1:
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if not already_added:
            result.push(item)
            seen.push(item)

    # Add new elements from arr2
    for item in arr2:
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if not already_added:
            result.push(item)
            seen.push(item)

    result

fn is_subset(arr1, arr2):
    """Check if arr1 is a subset of arr2.

    Returns true if all elements of arr1 are in arr2.
    """
    for item in arr1:
        var found = false
        for item2 in arr2:
            if item == item2:
                found = true
                break

        if not found:
            return false

    true

# ============================================================================
# Array Comparison
# ============================================================================

fn array_equals(arr1, arr2):
    """Check if two arrays are equal (same elements in same order).
    """
    if arr1.len() != arr2.len():
        return false

    var i = 0
    while i < arr1.len():
        if arr1[i] != arr2[i]:
            return false
        i = i + 1

    true

fn starts_with_subarray(arr, prefix):
    """Check if array starts with given prefix array.

    Example:
        starts_with_subarray([1,2,3,4], [1,2])  # true
    """
    if prefix.len() > arr.len():
        return false

    var i = 0
    while i < prefix.len():
        if arr[i] != prefix[i]:
            return false
        i = i + 1

    true

fn ends_with_subarray(arr, suffix):
    """Check if array ends with given suffix array.

    Example:
        ends_with_subarray([1,2,3,4], [3,4])  # true
    """
    if suffix.len() > arr.len():
        return false

    val offset = arr.len() - suffix.len()
    var i = 0
    while i < suffix.len():
        if arr[offset + i] != suffix[i]:
            return false
        i = i + 1

    true

# ============================================================================
# Array Search
# ============================================================================

fn index_of_subarray(arr, subarray):
    """Find index of first occurrence of subarray.

    Returns -1 if not found.

    Example:
        index_of_subarray([1,2,3,2,3], [2,3])  # 1
    """
    if subarray.len() == 0 or subarray.len() > arr.len():
        return -1

    var i = 0
    while i <= arr.len() - subarray.len():
        var match = true
        var j = 0
        while j < subarray.len():
            if arr[i + j] != subarray[j]:
                match = false
                break
            j = j + 1

        if match:
            return i

        i = i + 1

    -1

fn contains_subarray(arr, subarray):
    """Check if array contains subarray.

    Example:
        contains_subarray([1,2,3,4], [2,3])  # true
    """
    index_of_subarray(arr, subarray) >= 0
