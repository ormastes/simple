# CBOR (Concise Binary Object Representation) Utilities Module - Facade
#
# Comprehensive CBOR encoding/decoding implementation following RFC 8949.
# CBOR is a binary data serialization format designed for small code size
# and compact message size.
#
# FEATURES:
# - Major types: unsigned int, negative int, byte string, text string, array, map
# - Tag support: timestamps, bignums, URIs, regex, MIME, etc.
# - Simple values: false, true, null, undefined
# - Floating-point: half, single, double precision
# - Indefinite-length: streaming for strings, arrays, maps
# - Deterministic encoding: canonical CBOR
# - CBOR sequences: concatenated items
# - Self-describing: magic tag 55799
# - Utility functions: type detection, validation, size calculation

import "std/cbor/types" as types
import "std/cbor/encode" as encode
import "std/cbor/decode" as decode
import "std/cbor/major_types" as major_types
import "std/cbor/utilities" as utilities

# ============================================================================
# CBOR MAJOR TYPES
# ============================================================================

fn major_unsigned_int() -> i64: types.major_unsigned_int()
fn major_negative_int() -> i64: types.major_negative_int()
fn major_byte_string() -> i64: types.major_byte_string()
fn major_text_string() -> i64: types.major_text_string()
fn major_array() -> i64: types.major_array()
fn major_map() -> i64: types.major_map()
fn major_tag() -> i64: types.major_tag()
fn major_simple_float() -> i64: types.major_simple_float()

# ============================================================================
# ADDITIONAL INFO CONSTANTS
# ============================================================================

fn addl_immediate() -> i64: types.addl_immediate()
fn addl_uint8() -> i64: types.addl_uint8()
fn addl_uint16() -> i64: types.addl_uint16()
fn addl_uint32() -> i64: types.addl_uint32()
fn addl_uint64() -> i64: types.addl_uint64()
fn addl_indefinite() -> i64: types.addl_indefinite()

# ============================================================================
# SIMPLE VALUES
# ============================================================================

fn simple_false() -> i64: types.simple_false()
fn simple_true() -> i64: types.simple_true()
fn simple_null() -> i64: types.simple_null()
fn simple_undefined() -> i64: types.simple_undefined()
fn simple_float16() -> i64: types.simple_float16()
fn simple_float32() -> i64: types.simple_float32()
fn simple_float64() -> i64: types.simple_float64()
fn simple_break() -> i64: types.simple_break()

# ============================================================================
# ENCODING FUNCTIONS
# ============================================================================

fn cbor_encode_unsigned(value: i64) -> [i64]: encode.cbor_encode_unsigned(value)
fn cbor_encode_int(value: i64) -> [i64]: encode.cbor_encode_int(value)
fn cbor_encode_bytes(bytes: [i64]) -> [i64]: encode.cbor_encode_bytes(bytes)
fn cbor_encode_text(text: text) -> [i64]: encode.cbor_encode_text(text)
fn cbor_encode_array_header(length: i64) -> [i64]: encode.cbor_encode_array_header(length)
fn cbor_encode_array_start() -> [i64]: encode.cbor_encode_array_start()
fn cbor_encode_map_header(length: i64) -> [i64]: encode.cbor_encode_map_header(length)
fn cbor_encode_map_start() -> [i64]: encode.cbor_encode_map_start()
fn cbor_encode_break() -> [i64]: encode.cbor_encode_break()
fn cbor_encode_false() -> [i64]: encode.cbor_encode_false()
fn cbor_encode_true() -> [i64]: encode.cbor_encode_true()
fn cbor_encode_bool(value: bool) -> [i64]: encode.cbor_encode_bool(value)
fn cbor_encode_null() -> [i64]: encode.cbor_encode_null()
fn cbor_encode_undefined() -> [i64]: encode.cbor_encode_undefined()
fn cbor_encode_simple(value: i64) -> [i64]: encode.cbor_encode_simple(value)
fn cbor_encode_float64(value: f64) -> [i64]: encode.cbor_encode_float64(value)
fn cbor_encode_float32(value: f64) -> [i64]: encode.cbor_encode_float32(value)
fn cbor_encode_tagged(tag: i64, value: [i64]) -> [i64]: encode.cbor_encode_tagged(tag, value)
fn cbor_encode_timestamp(unix_seconds: i64) -> [i64]: encode.cbor_encode_timestamp(unix_seconds)
fn cbor_encode_datetime_string(iso8601: text) -> [i64]: encode.cbor_encode_datetime_string(iso8601)
fn cbor_encode_uri(uri: text) -> [i64]: encode.cbor_encode_uri(uri)
fn cbor_encode_regex(pattern: text) -> [i64]: encode.cbor_encode_regex(pattern)
fn cbor_encode_base64(data: text) -> [i64]: encode.cbor_encode_base64(data)
fn cbor_encode_base64url(data: text) -> [i64]: encode.cbor_encode_base64url(data)
fn cbor_encode_base16(data: text) -> [i64]: encode.cbor_encode_base16(data)
fn cbor_encode_mime(mime_message: text) -> [i64]: encode.cbor_encode_mime(mime_message)
fn cbor_encode_self_describe(value: [i64]) -> [i64]: encode.cbor_encode_self_describe(value)

# ============================================================================
# DECODING FUNCTIONS
# ============================================================================

fn cbor_decode_unsigned(bytes: [i64], offset: i64) -> (i64, i64): decode.cbor_decode_unsigned(bytes, offset)
fn cbor_decode_int(bytes: [i64], offset: i64) -> (i64, i64): decode.cbor_decode_int(bytes, offset)
fn cbor_decode_bytes(bytes: [i64], offset: i64) -> ([i64], i64): decode.cbor_decode_bytes(bytes, offset)
fn cbor_decode_text(bytes: [i64], offset: i64) -> (text, i64): decode.cbor_decode_text(bytes, offset)
fn cbor_decode_array_header(bytes: [i64], offset: i64) -> (i64, i64, i64): decode.cbor_decode_array_header(bytes, offset)
fn cbor_decode_map_header(bytes: [i64], offset: i64) -> (i64, i64, i64): decode.cbor_decode_map_header(bytes, offset)
fn cbor_decode_bool(bytes: [i64], offset: i64) -> (bool, i64): decode.cbor_decode_bool(bytes, offset)
fn cbor_decode_null(bytes: [i64], offset: i64) -> (i64, i64): decode.cbor_decode_null(bytes, offset)
fn cbor_decode_undefined(bytes: [i64], offset: i64) -> (i64, i64): decode.cbor_decode_undefined(bytes, offset)
fn cbor_decode_simple_value(bytes: [i64], offset: i64) -> (i64, i64): decode.cbor_decode_simple_value(bytes, offset)
fn cbor_decode_tag(bytes: [i64], offset: i64) -> (i64, i64): decode.cbor_decode_tag(bytes, offset)

# ============================================================================
# TYPE DETECTION AND VALIDATION
# ============================================================================

fn cbor_decode_type(bytes: [i64], offset: i64) -> (i64, i64, i64): major_types.cbor_decode_type(bytes, offset)
fn cbor_is_unsigned_int(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_unsigned_int(bytes, offset)
fn cbor_is_negative_int(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_negative_int(bytes, offset)
fn cbor_is_byte_string(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_byte_string(bytes, offset)
fn cbor_is_text_string(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_text_string(bytes, offset)
fn cbor_is_array(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_array(bytes, offset)
fn cbor_is_map(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_map(bytes, offset)
fn cbor_is_tagged(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_tagged(bytes, offset)
fn cbor_is_simple(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_simple(bytes, offset)
fn cbor_is_indefinite(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_indefinite(bytes, offset)
fn cbor_is_break(bytes: [i64], offset: i64) -> bool: major_types.cbor_is_break(bytes, offset)
fn cbor_item_size(bytes: [i64], offset: i64) -> i64: major_types.cbor_item_size(bytes, offset)
fn cbor_validate(bytes: [i64]) -> bool: major_types.cbor_validate(bytes)
fn cbor_validate_sequence(bytes: [i64]) -> bool: major_types.cbor_validate_sequence(bytes)
fn cbor_is_canonical_int(value: i64, encoding: [i64]) -> bool: major_types.cbor_is_canonical_int(value, encoding)

# ============================================================================
# UTILITIES
# ============================================================================

fn cbor_sequence_count(bytes: [i64]) -> i64: utilities.cbor_sequence_count(bytes)
fn cbor_sequence_item(bytes: [i64], index: i64) -> ([i64], i64): utilities.cbor_sequence_item(bytes, index)
fn cbor_to_diagnostic(bytes: [i64], offset: i64) -> (text, i64): utilities.cbor_to_diagnostic(bytes, offset)
fn cbor_hexdump(bytes: [i64]) -> text: utilities.cbor_hexdump(bytes)
