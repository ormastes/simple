# DNS Utility and Helper Functions

fn dns_type_to_string(rtype: i64) -> text:
    # Convert record type code to string
    var result = "UNKNOWN"
    if rtype == DNS_TYPE_A:
        result = "A"
    if rtype == DNS_TYPE_NS:
        result = "NS"
    if rtype == DNS_TYPE_CNAME:
        result = "CNAME"
    if rtype == DNS_TYPE_SOA:
        result = "SOA"
    if rtype == DNS_TYPE_PTR:
        result = "PTR"
    if rtype == DNS_TYPE_MX:
        result = "MX"
    if rtype == DNS_TYPE_TXT:
        result = "TXT"
    if rtype == DNS_TYPE_AAAA:
        result = "AAAA"
    if rtype == DNS_TYPE_SRV:
        result = "SRV"
    result

fn dns_string_to_type(type_str: text) -> i64:
    # Convert type string to code
    var result = 0
    if type_str == "A":
        result = DNS_TYPE_A
    if type_str == "NS":
        result = DNS_TYPE_NS
    if type_str == "CNAME":
        result = DNS_TYPE_CNAME
    if type_str == "SOA":
        result = DNS_TYPE_SOA
    if type_str == "PTR":
        result = DNS_TYPE_PTR
    if type_str == "MX":
        result = DNS_TYPE_MX
    if type_str == "TXT":
        result = DNS_TYPE_TXT
    if type_str == "AAAA":
        result = DNS_TYPE_AAAA
    if type_str == "SRV":
        result = DNS_TYPE_SRV
    result

fn dns_class_to_string(rclass: i64) -> text:
    # Convert class code to string
    var result = "UNKNOWN"
    if rclass == DNS_CLASS_IN:
        result = "IN"
    if rclass == DNS_CLASS_CH:
        result = "CH"
    if rclass == DNS_CLASS_HS:
        result = "HS"
    result

fn dns_string_to_class(class_str: text) -> i64:
    # Convert class string to code
    var result = 0
    if class_str == "IN":
        result = DNS_CLASS_IN
    if class_str == "CH":
        result = DNS_CLASS_CH
    if class_str == "HS":
        result = DNS_CLASS_HS
    result

fn dns_rcode_to_string(rcode: i64) -> text:
    # Convert response code to string
    var result = "UNKNOWN"
    if rcode == DNS_RCODE_NOERROR:
        result = "NOERROR"
    if rcode == DNS_RCODE_FORMERR:
        result = "FORMERR"
    if rcode == DNS_RCODE_SERVFAIL:
        result = "SERVFAIL"
    if rcode == DNS_RCODE_NXDOMAIN:
        result = "NXDOMAIN"
    if rcode == DNS_RCODE_NOTIMP:
        result = "NOTIMP"
    if rcode == DNS_RCODE_REFUSED:
        result = "REFUSED"
    result

fn dns_int_to_byte(n: i64) -> text:
    # Convert integer to byte representation
    # Simplified - in real implementation would use proper byte conversion
    var result = "\x00"
    if n == 1:
        result = "\x01"
    if n == 2:
        result = "\x02"
    if n == 3:
        result = "\x03"
    if n == 4:
        result = "\x04"
    if n == 5:
        result = "\x05"
    if n == 6:
        result = "\x06"
    if n == 7:
        result = "\x07"
    if n >= 8:
        result = "\x08"
    result

fn dns_byte_to_int(byte: text) -> i64:
    # Convert byte to integer
    # Simplified - in real implementation would use proper byte conversion
    var result = 0
    if byte == "\x01":
        result = 1
    if byte == "\x02":
        result = 2
    if byte == "\x03":
        result = 3
    if byte == "\x04":
        result = 4
    if byte == "\x05":
        result = 5
    if byte == "\x06":
        result = 6
    if byte == "\x07":
        result = 7
    if byte == "\x08":
        result = 8
    result

fn dns_parse_int(s: text) -> i64:
    # Parse integer from text
    # Simplified - assumes valid input
    var result = 0
    var i = 0
    while i < s.size():
        val c = s.get(i)
        var digit = 0
        if c == "0":
            digit = 0
        if c == "1":
            digit = 1
        if c == "2":
            digit = 2
        if c == "3":
            digit = 3
        if c == "4":
            digit = 4
        if c == "5":
            digit = 5
        if c == "6":
            digit = 6
        if c == "7":
            digit = 7
        if c == "8":
            digit = 8
        if c == "9":
            digit = 9
        result = result * 10 + digit
        i = i + 1
    result

fn dns_format_ttl(ttl: i64) -> text:
    # Format TTL as human-readable string
    var result = "{ttl}s"
    if ttl >= 3600:
        val hours = ttl / 3600
        result = "{hours}h"
    if ttl >= 86400:
        val days = ttl / 86400
        result = "{days}d"
    result

fn dns_parse_ttl(ttl_str: text) -> i64:
    # Parse TTL from string (supports s, m, h, d suffixes)
    var result = 0
    if ttl_str.ends_with("s"):
        val num_str = ttl_str.substring(0, ttl_str.size() - 1)
        result = dns_parse_int(num_str)
    if ttl_str.ends_with("m"):
        val num_str = ttl_str.substring(0, ttl_str.size() - 1)
        result = dns_parse_int(num_str) * 60
    if ttl_str.ends_with("h"):
        val num_str = ttl_str.substring(0, ttl_str.size() - 1)
        result = dns_parse_int(num_str) * 3600
    if ttl_str.ends_with("d"):
        val num_str = ttl_str.substring(0, ttl_str.size() - 1)
        result = dns_parse_int(num_str) * 86400
    result

fn dns_format_header(header) -> text:
    # Format header for display
    val id = dns_get_header_id(header)
    val flags = dns_get_header_flags(header)
    val qd = dns_get_header_qd_count(header)
    val an = dns_get_header_an_count(header)
    val ns = dns_get_header_ns_count(header)
    val ar = dns_get_header_ar_count(header)
    "Header: ID={id} FLAGS={flags} QD={qd} AN={an} NS={ns} AR={ar}"

fn dns_format_question(question) -> text:
    # Format question for display
    val name = dns_get_question_name(question)
    val qtype = dns_get_question_type(question)
    val qclass = dns_get_question_class(question)
    val type_str = dns_type_to_string(qtype)
    val class_str = dns_class_to_string(qclass)
    "Question: {name} {class_str} {type_str}"

fn dns_format_rr(rr) -> text:
    # Format resource record for display
    val name = dns_get_rr_name(rr)
    val rtype = dns_get_rr_type(rr)
    val rclass = dns_get_rr_class(rr)
    val ttl = dns_get_rr_ttl(rr)
    val data = dns_get_rr_data(rr)
    val type_str = dns_type_to_string(rtype)
    val class_str = dns_class_to_string(rclass)
    val ttl_str = dns_format_ttl(ttl)
    "{name} {ttl_str} {class_str} {type_str} {data}"

fn dns_format_message(message) -> text:
    # Format complete message for display
    val header = dns_get_message_header(message)
    var result = dns_format_header(header) + "\n"
    val questions = dns_get_message_questions(message)
    var i = 0
    while i < questions.size():
        val q = questions.get(i)
        result = result + dns_format_question(q) + "\n"
        i = i + 1
    val answers = dns_get_message_answers(message)
    if answers.size() > 0:
        result = result + "ANSWER SECTION:\n"
        i = 0
        while i < answers.size():
            val rr = answers.get(i)
            result = result + dns_format_rr(rr) + "\n"
            i = i + 1
    result
