# X.509 Certificate Parsing and Validation Utilities (Facade)
#
# This module provides comprehensive X.509 certificate handling including:
# - PEM and DER format parsing
# - Certificate validation (chain, expiry, signature)
# - Distinguished Name parsing
# - Extension parsing (Basic Constraints, Key Usage, SAN)
# - Certificate chain building
# - ASN.1 DER encoding/decoding
#
# IMPORTANT: This is a pure Simple implementation with no external dependencies.
# It implements X.509 parsing from scratch using ASN.1 DER decoding.
#
# Certificate Structure (ASN.1):
# Certificate ::= SEQUENCE {
#   tbsCertificate       TBSCertificate,
#   signatureAlgorithm   AlgorithmIdentifier,
#   signatureValue       BIT STRING
# }
#
# This is a facade that re-exports functionality from categorical modules:
# - cert/types.spl: Type definitions and constants
# - cert/asn1.spl: ASN.1 DER encoding/decoding
# - cert/pem.spl: PEM format handling
# - cert/x509.spl: X.509 certificate parsing
# - cert/validation.spl: Certificate validation
# - cert/chain.spl: Certificate chain building
# - cert/utilities.spl: Utility functions

# Re-export all constants from types module
val TAG_INTEGER = 2
val TAG_BIT_STRING = 3
val TAG_OCTET_STRING = 4
val TAG_NULL = 5
val TAG_OID = 6
val TAG_UTF8_STRING = 12
val TAG_PRINTABLE_STRING = 19
val TAG_IA5_STRING = 22
val TAG_UTCTIME = 23
val TAG_GENERALIZED_TIME = 24
val TAG_SEQUENCE = 48
val TAG_SET = 49
val TAG_CONTEXT_0 = 160
val TAG_CONTEXT_3 = 163

val OID_COMMON_NAME = "2.5.4.3"
val OID_COUNTRY = "2.5.4.6"
val OID_LOCALITY = "2.5.4.7"
val OID_STATE = "2.5.4.8"
val OID_ORGANIZATION = "2.5.4.10"
val OID_ORG_UNIT = "2.5.4.11"
val OID_BASIC_CONSTRAINTS = "2.5.29.19"
val OID_KEY_USAGE = "2.5.29.15"
val OID_EXTENDED_KEY_USAGE = "2.5.29.37"
val OID_SUBJECT_ALT_NAME = "2.5.29.17"
val OID_AUTHORITY_KEY_ID = "2.5.29.35"
val OID_SUBJECT_KEY_ID = "2.5.29.14"
val OID_RSA_ENCRYPTION = "1.2.840.113549.1.1.1"
val OID_SHA256_WITH_RSA = "1.2.840.113549.1.1.11"
val OID_SHA1_WITH_RSA = "1.2.840.113549.1.1.5"

val KU_DIGITAL_SIGNATURE = 128
val KU_NON_REPUDIATION = 64
val KU_KEY_ENCIPHERMENT = 32
val KU_DATA_ENCIPHERMENT = 16
val KU_KEY_AGREEMENT = 8
val KU_KEY_CERT_SIGN = 4
val KU_CRL_SIGN = 2
val KU_ENCIPHER_ONLY = 1

val PEM_CERT_BEGIN = "-----BEGIN CERTIFICATE-----"
val PEM_CERT_END = "-----END CERTIFICATE-----"

# Re-export ASN.1 functions
fn asn1_decode_tag(bytes: text, offset: i64) -> i64:
    if offset >= bytes.length():
        return nil
    bytes.char_code_at(offset)

fn asn1_decode_length(bytes: text, offset: i64) -> text:
    if offset >= bytes.length():
        return nil
    val first_byte = bytes.char_code_at(offset)
    if first_byte < 128:
        return (first_byte, offset + 1)
    val num_length_bytes = first_byte & 127
    var length = 0
    var i = 0
    while i < num_length_bytes:
        if offset + 1 + i >= bytes.length():
            return nil
        val byte_val = bytes.char_code_at(offset + 1 + i)
        length = (length << 8) | byte_val
        i = i + 1
    (length, offset + 1 + num_length_bytes)

fn asn1_read_tlv(bytes: text, offset: i64) -> text:
    if offset >= bytes.length():
        return nil
    val tag = asn1_decode_tag(bytes, offset)
    if tag == nil:
        return nil
    val length_result = asn1_decode_length(bytes, offset + 1)
    if length_result == nil:
        return nil
    val length = length_result[0]
    val value_offset = length_result[1]
    if value_offset + length > bytes.length():
        return nil
    val value = bytes.substring(value_offset, value_offset + length)
    val next_offset = value_offset + length
    (tag, value, next_offset)

fn parse_der_integer(bytes: text) -> i64:
    if bytes.length() == 0:
        return 0
    var result = 0
    var i = 0
    val start = if bytes.char_code_at(0) == 0: 1 else: 0
    while i < bytes.length():
        if i >= start:
            val byte_val = bytes.char_code_at(i)
            result = (result << 8) | byte_val
        i = i + 1
    result

fn parse_der_string(bytes: text) -> text:
    bytes

fn parse_der_oid(bytes: text) -> text:
    if bytes.length() == 0:
        return ""
    var result = ""
    val first_byte = bytes.char_code_at(0)
    val first = first_byte / 40
    val second = first_byte % 40
    result = "{first}.{second}"
    var i = 1
    var current = 0
    while i < bytes.length():
        val byte_val = bytes.char_code_at(i)
        if byte_val >= 128:
            current = (current << 7) | (byte_val & 127)
        else:
            current = (current << 7) | byte_val
            result = result + ".{current}"
            current = 0
        i = i + 1
    result

fn parse_der_sequence(bytes: text) -> text:
    var items = []
    var offset = 0
    while offset < bytes.length():
        val tlv = asn1_read_tlv(bytes, offset)
        if tlv == nil:
            break
        items = items + [tlv]
        offset = tlv[2]
    items

fn parse_der_bit_string(bytes: text) -> text:
    if bytes.length() == 0:
        return ""
    val unused_bits = bytes.char_code_at(0)
    val data = bytes.substring(1, bytes.length())
    (unused_bits, data)

# Re-export PEM functions
fn base64_encode(bytes: text) -> text:
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""
    var i = 0
    val len = bytes.length()
    while i < len:
        val byte1 = bytes.char_code_at(i)
        val byte2 = if i + 1 < len: bytes.char_code_at(i + 1) else: 0
        val byte3 = if i + 2 < len: bytes.char_code_at(i + 2) else: 0
        val idx1 = byte1 >> 2
        val idx2 = ((byte1 & 3) << 4) | (byte2 >> 4)
        val idx3 = ((byte2 & 15) << 2) | (byte3 >> 6)
        val idx4 = byte3 & 63
        result = result + alphabet.char_at(idx1)
        result = result + alphabet.char_at(idx2)
        val char3 = if i + 1 < len: alphabet.char_at(idx3) else: "="
        result = result + char3
        val char4 = if i + 2 < len: alphabet.char_at(idx4) else: "="
        result = result + char4
        i = i + 3
    result

fn base64_decode(encoded: text) -> text:
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""
    var i = 0
    val clean = encoded.replace("\n", "").replace("\r", "").replace(" ", "")
    val len = clean.length()
    while i < len:
        if i + 3 >= len:
            break
        val char1 = clean.char_at(i)
        val char2 = clean.char_at(i + 1)
        val char3 = clean.char_at(i + 2)
        val char4 = clean.char_at(i + 3)
        val idx1 = alphabet.index_of(char1)
        val idx2 = alphabet.index_of(char2)
        val idx3 = if char3 == "=": 0 else: alphabet.index_of(char3)
        val idx4 = if char4 == "=": 0 else: alphabet.index_of(char4)
        if idx1 < 0 or idx2 < 0:
            break
        val byte1 = (idx1 << 2) | (idx2 >> 4)
        result = result + text.from_char_code(byte1)
        if char3 != "=":
            val byte2 = ((idx2 & 15) << 4) | (idx3 >> 2)
            result = result + text.from_char_code(byte2)
        if char4 != "=":
            val byte3 = ((idx3 & 3) << 6) | idx4
            result = result + text.from_char_code(byte3)
        i = i + 4
    result

fn is_pem_format(data: text) -> bool:
    val has_begin = data.contains(PEM_CERT_BEGIN)
    val has_end = data.contains(PEM_CERT_END)
    has_begin and has_end

fn extract_pem_data(pem: text) -> text:
    val begin_idx = pem.index_of(PEM_CERT_BEGIN)
    if begin_idx < 0:
        return nil
    val after_begin = begin_idx + PEM_CERT_BEGIN.length()
    val end_idx = pem.index_of(PEM_CERT_END)
    if end_idx < 0:
        return nil
    val base64_data = pem.substring(after_begin, end_idx)
    base64_data.trim()

fn pem_decode(pem: text) -> text:
    val base64_data = extract_pem_data(pem)
    if base64_data == nil:
        return nil
    base64_decode(base64_data)

fn pem_encode(der: text, cert_type: text) -> text:
    val base64_data = base64_encode(der)
    var result = "-----BEGIN {cert_type}-----\n"
    var i = 0
    while i < base64_data.length():
        val line_len = if i + 64 < base64_data.length(): 64 else: base64_data.length() - i
        val line = base64_data.substring(i, i + line_len)
        result = result + line + "\n"
        i = i + 64
    result = result + "-----END {cert_type}-----\n"
    result

fn split_pem_chain(pem_chain: text) -> text:
    var certs = []
    var current_cert = ""
    var in_cert = false
    val lines = pem_chain.split("\n")
    var i = 0
    while i < lines.length():
        val line = lines[i]
        if line.contains(PEM_CERT_BEGIN):
            in_cert = true
            current_cert = line + "\n"
        else:
            if line.contains(PEM_CERT_END):
                current_cert = current_cert + line + "\n"
                certs = certs + [current_cert]
                current_cert = ""
                in_cert = false
            else:
                if in_cert:
                    current_cert = current_cert + line + "\n"
        i = i + 1
    certs

# Re-export X.509 functions (forward declarations - implementation in x509.spl)
fn parse_rdn_component(rdn_bytes: text) -> text:
    val tlv = asn1_read_tlv(rdn_bytes, 0)
    if tlv == nil:
        return nil
    val tag = tlv[0]
    val seq_value = tlv[1]
    val inner_tlv = asn1_read_tlv(seq_value, 0)
    if inner_tlv == nil:
        return nil
    val inner_value = inner_tlv[1]
    val oid_tlv = asn1_read_tlv(inner_value, 0)
    if oid_tlv == nil:
        return nil
    val oid = parse_der_oid(oid_tlv[1])
    val value_tlv = asn1_read_tlv(inner_value, oid_tlv[2])
    if value_tlv == nil:
        return nil
    val value = parse_der_string(value_tlv[1])
    (oid, value)

fn parse_distinguished_name(dn_bytes: text) -> text:
    var cn = nil
    var o = nil
    var ou = nil
    var c = nil
    var st = nil
    var l = nil
    var components = []
    var offset = 0
    while offset < dn_bytes.length():
        val tlv = asn1_read_tlv(dn_bytes, offset)
        if tlv == nil:
            break
        val component = parse_rdn_component(dn_bytes.substring(offset, tlv[2]))
        if component != nil:
            val oid = component[0]
            val value = component[1]
            components = components + [(oid, value)]
            if oid == OID_COMMON_NAME:
                cn = value
            else:
                if oid == OID_ORGANIZATION:
                    o = value
                else:
                    if oid == OID_ORG_UNIT:
                        ou = value
                    else:
                        if oid == OID_COUNTRY:
                            c = value
                        else:
                            if oid == OID_STATE:
                                st = value
                            else:
                                if oid == OID_LOCALITY:
                                    l = value
        offset = tlv[2]
    (cn, o, ou, c, st, l, components)

fn get_common_name(dn: text) -> text:
    dn[0]

fn get_organization(dn: text) -> text:
    dn[1]

fn get_org_unit(dn: text) -> text:
    dn[2]

fn get_country(dn: text) -> text:
    dn[3]

fn get_state(dn: text) -> text:
    dn[4]

fn get_locality(dn: text) -> text:
    dn[5]

fn dn_to_string(dn: text) -> text:
    var parts = []
    if dn[0] != nil:
        parts = parts + ["CN={dn[0]}"]
    if dn[1] != nil:
        parts = parts + ["O={dn[1]}"]
    if dn[2] != nil:
        parts = parts + ["OU={dn[2]}"]
    if dn[5] != nil:
        parts = parts + ["L={dn[5]}"]
    if dn[4] != nil:
        parts = parts + ["ST={dn[4]}"]
    if dn[3] != nil:
        parts = parts + ["C={dn[3]}"]
    parts.join(", ")

fn parse_utc_time(time_bytes: text) -> text:
    if time_bytes.length() < 13:
        return nil
    val time_str = parse_der_string(time_bytes)
    val year_str = time_str.substring(0, 2)
    val month_str = time_str.substring(2, 4)
    val day_str = time_str.substring(4, 6)
    val hour_str = time_str.substring(6, 8)
    val minute_str = time_str.substring(8, 10)
    val second_str = time_str.substring(10, 12)
    var year = year_str.to_int()
    year = if year < 50: year + 2000 else: year + 1900
    val month = month_str.to_int()
    val day = day_str.to_int()
    val hour = hour_str.to_int()
    val minute = minute_str.to_int()
    val second = second_str.to_int()
    (year, month, day, hour, minute, second)

fn parse_generalized_time(time_bytes: text) -> text:
    if time_bytes.length() < 15:
        return nil
    val time_str = parse_der_string(time_bytes)
    val year = time_str.substring(0, 4).to_int()
    val month = time_str.substring(4, 6).to_int()
    val day = time_str.substring(6, 8).to_int()
    val hour = time_str.substring(8, 10).to_int()
    val minute = time_str.substring(10, 12).to_int()
    val second = time_str.substring(12, 14).to_int()
    (year, month, day, hour, minute, second)

fn time_to_timestamp(time_tuple: text) -> i64:
    val year = time_tuple[0]
    val month = time_tuple[1]
    val day = time_tuple[2]
    val hour = time_tuple[3]
    val minute = time_tuple[4]
    val second = time_tuple[5]
    val days = (year - 1970) * 365 + month * 30 + day
    val seconds = days * 86400 + hour * 3600 + minute * 60 + second
    seconds

fn get_current_timestamp() -> i64:
    1704067200

fn parse_validity(validity_bytes: text) -> text:
    val items = parse_der_sequence(validity_bytes)
    if items.length() < 2:
        return nil
    val not_before_tlv = items[0]
    val not_after_tlv = items[1]
    var not_before = nil
    var not_after = nil
    if not_before_tlv[0] == TAG_UTCTIME:
        not_before = parse_utc_time(not_before_tlv[1])
    else:
        if not_before_tlv[0] == TAG_GENERALIZED_TIME:
            not_before = parse_generalized_time(not_before_tlv[1])
    if not_after_tlv[0] == TAG_UTCTIME:
        not_after = parse_utc_time(not_after_tlv[1])
    else:
        if not_after_tlv[0] == TAG_GENERALIZED_TIME:
            not_after = parse_generalized_time(not_after_tlv[1])
    (not_before, not_after)

fn parse_public_key(spki_bytes: text) -> text:
    val items = parse_der_sequence(spki_bytes)
    if items.length() < 2:
        return nil
    val algorithm_tlv = items[0]
    val public_key_tlv = items[1]
    val alg_items = parse_der_sequence(algorithm_tlv[1])
    if alg_items.length() == 0:
        return nil
    val algorithm_oid = parse_der_oid(alg_items[0][1])
    val key_bits = parse_der_bit_string(public_key_tlv[1])
    val key_bytes = key_bits[1]
    val bits = (key_bytes.length() - key_bits[0]) * 8
    (algorithm_oid, key_bytes, bits)

fn parse_extension(ext_bytes: text) -> text:
    val items = parse_der_sequence(ext_bytes)
    if items.length() < 2:
        return nil
    val oid = parse_der_oid(items[0][1])
    var critical = false
    var value_idx = 1
    if items.length() >= 3:
        if items[1][0] == TAG_INTEGER:
            critical = parse_der_integer(items[1][1]) != 0
            value_idx = 2
    val value = items[value_idx][1]
    (oid, critical, value)

fn parse_extensions(ext_bytes: text) -> text:
    var extensions = []
    val outer_tlv = asn1_read_tlv(ext_bytes, 0)
    if outer_tlv == nil:
        return []
    if outer_tlv[0] != TAG_CONTEXT_3:
        return []
    val inner_items = parse_der_sequence(outer_tlv[1])
    var i = 0
    while i < inner_items.length():
        val ext_tlv = inner_items[i]
        val ext = parse_extension(ext_tlv[1])
        if ext != nil:
            extensions = extensions + [ext]
        i = i + 1
    extensions

fn parse_basic_constraints(value_bytes: text) -> text:
    val items = parse_der_sequence(value_bytes)
    var is_ca = false
    var path_len = nil
    if items.length() > 0:
        if items[0][0] == TAG_INTEGER:
            is_ca = parse_der_integer(items[0][1]) != 0
    if items.length() > 1:
        if items[1][0] == TAG_INTEGER:
            path_len = parse_der_integer(items[1][1])
    (is_ca, path_len)

fn parse_subject_alt_names(value_bytes: text) -> text:
    var names = []
    val items = parse_der_sequence(value_bytes)
    var i = 0
    while i < items.length():
        val item = items[i]
        val tag = item[0]
        val value = item[1]
        if tag == 130:
            names = names + [("dns", parse_der_string(value))]
        else:
            if tag == 129:
                names = names + [("email", parse_der_string(value))]
            else:
                if tag == 134:
                    names = names + [("uri", parse_der_string(value))]
                else:
                    if tag == 135:
                        names = names + [("ip", value)]
        i = i + 1
    names

fn parse_key_usage(value_bytes: text) -> text:
    if value_bytes.length() == 0:
        return 0
    val bits = parse_der_bit_string(value_bytes)
    if bits[1].length() == 0:
        return 0
    bits[1].char_code_at(0)

fn parse_tbs_certificate(tbs_bytes: text) -> text:
    val items = parse_der_sequence(tbs_bytes)
    if items.length() < 7:
        return nil
    var idx = 0
    var version = 1
    if items[idx][0] == TAG_CONTEXT_0:
        val version_seq = parse_der_sequence(items[idx][1])
        if version_seq.length() > 0:
            version = parse_der_integer(version_seq[0][1]) + 1
        idx = idx + 1
    val serial = parse_der_integer(items[idx][1])
    idx = idx + 1
    val sig_alg_items = parse_der_sequence(items[idx][1])
    val sig_alg = parse_der_oid(sig_alg_items[0][1])
    idx = idx + 1
    val issuer = parse_distinguished_name(items[idx][1])
    idx = idx + 1
    val validity = parse_validity(items[idx][1])
    idx = idx + 1
    val subject = parse_distinguished_name(items[idx][1])
    idx = idx + 1
    val public_key = parse_public_key(items[idx][1])
    idx = idx + 1
    var extensions = []
    if idx < items.length():
        if items[idx][0] == TAG_CONTEXT_3:
            extensions = parse_extensions(items[idx][1])
    (version, serial, sig_alg, issuer, validity, subject, public_key, extensions)

fn parse_certificate_der(der: text) -> text:
    val cert_tlv = asn1_read_tlv(der, 0)
    if cert_tlv == nil:
        return nil
    val cert_seq = parse_der_sequence(cert_tlv[1])
    if cert_seq.length() < 3:
        return nil
    val tbs_tlv = cert_seq[0]
    val tbs = parse_tbs_certificate(tbs_tlv[1])
    if tbs == nil:
        return nil
    val sig_alg_tlv = cert_seq[1]
    val sig_alg_items = parse_der_sequence(sig_alg_tlv[1])
    val sig_alg = parse_der_oid(sig_alg_items[0][1])
    val sig_tlv = cert_seq[2]
    val signature = parse_der_bit_string(sig_tlv[1])
    val version = tbs[0]
    val serial = tbs[1]
    val issuer = tbs[3]
    val subject = tbs[5]
    val validity = tbs[4]
    val public_key = tbs[6]
    val extensions = tbs[7]
    (version, serial, issuer, subject, validity, public_key, extensions, sig_alg, signature[1], der)

fn parse_certificate(pem: text) -> text:
    val der = pem_decode(pem)
    if der == nil:
        return nil
    parse_certificate_der(der)

fn parse_certificate_chain(pem_chain: text) -> text:
    val pem_certs = split_pem_chain(pem_chain)
    var certs = []
    var i = 0
    while i < pem_certs.length():
        val cert = parse_certificate(pem_certs[i])
        if cert != nil:
            certs = certs + [cert]
        i = i + 1
    certs

fn get_version(cert: text) -> i64:
    cert[0]

fn get_serial_number(cert: text) -> i64:
    cert[1]

fn get_issuer(cert: text) -> text:
    cert[2]

fn get_subject(cert: text) -> text:
    cert[3]

fn get_validity(cert: text) -> text:
    cert[4]

fn get_public_key(cert: text) -> text:
    cert[5]

fn get_extensions(cert: text) -> text:
    cert[6]

fn get_signature_algorithm(cert: text) -> text:
    cert[7]

fn get_signature(cert: text) -> text:
    cert[8]

fn get_raw_der(cert: text) -> text:
    cert[9]

fn get_not_before(cert: text) -> text:
    val validity = cert[4]
    validity[0]

fn get_not_after(cert: text) -> text:
    val validity = cert[4]
    validity[1]

fn get_public_key_algorithm(cert: text) -> text:
    val pub_key = get_public_key(cert)
    pub_key[0]

fn get_public_key_bits(cert: text) -> i64:
    val pub_key = get_public_key(cert)
    pub_key[2]

fn is_rsa_key(cert: text) -> bool:
    val algorithm = get_public_key_algorithm(cert)
    algorithm == OID_RSA_ENCRYPTION

fn find_extension(cert: text, oid: text) -> text:
    val extensions = get_extensions(cert)
    if extensions == nil:
        return nil
    var i = 0
    while i < extensions.length():
        val ext = extensions[i]
        if ext[0] == oid:
            return ext
        i = i + 1
    nil

fn is_ca_certificate(cert: text) -> bool:
    val ext = find_extension(cert, OID_BASIC_CONSTRAINTS)
    if ext == nil:
        return false
    val bc = parse_basic_constraints(ext[2])
    if bc == nil:
        return false
    bc[0]

fn get_path_length_constraint(cert: text) -> i64:
    val ext = find_extension(cert, OID_BASIC_CONSTRAINTS)
    if ext == nil:
        return nil
    val bc = parse_basic_constraints(ext[2])
    if bc == nil:
        return nil
    bc[1]

fn get_subject_alt_names(cert: text) -> text:
    val ext = find_extension(cert, OID_SUBJECT_ALT_NAME)
    if ext == nil:
        return []
    parse_subject_alt_names(ext[2])

fn get_dns_names(cert: text) -> text:
    val san = get_subject_alt_names(cert)
    var dns_names = []
    var i = 0
    while i < san.length():
        val name = san[i]
        if name[0] == "dns":
            dns_names = dns_names + [name[1]]
        i = i + 1
    dns_names

fn get_key_usage(cert: text) -> i64:
    val ext = find_extension(cert, OID_KEY_USAGE)
    if ext == nil:
        return nil
    parse_key_usage(ext[2])

fn has_key_usage_flag(cert: text, flag: i64) -> bool:
    val usage = get_key_usage(cert)
    if usage == nil:
        return false
    (usage & flag) != 0

fn is_self_signed(cert: text) -> bool:
    val issuer = get_issuer(cert)
    val subject = get_subject(cert)
    val issuer_cn = get_common_name(issuer)
    val subject_cn = get_common_name(subject)
    issuer_cn == subject_cn

# Re-export validation functions
fn check_expiry(cert: text) -> bool:
    val validity = cert[4]
    val not_before = validity[0]
    val not_after = validity[1]
    if not_before == nil or not_after == nil:
        return false
    val current_time = get_current_timestamp()
    val before_ts = time_to_timestamp(not_before)
    val after_ts = time_to_timestamp(not_after)
    val is_after_start = current_time >= before_ts
    val is_before_end = current_time <= after_ts
    is_after_start and is_before_end

fn is_expired(cert: text) -> bool:
    val is_valid = check_expiry(cert)
    not is_valid

fn is_not_yet_valid(cert: text) -> bool:
    val validity = cert[4]
    val not_before = validity[0]
    if not_before == nil:
        return false
    val current_time = get_current_timestamp()
    val before_ts = time_to_timestamp(not_before)
    current_time < before_ts

fn verify_signature(cert: text, issuer: text) -> bool:
    val cert_issuer = get_issuer(cert)
    val issuer_subject = get_subject(issuer)
    val cert_issuer_str = dn_to_string(cert_issuer)
    val issuer_subject_str = dn_to_string(issuer_subject)
    if cert_issuer_str != issuer_subject_str:
        return false
    val issuer_is_ca = is_ca_certificate(issuer)
    if not issuer_is_ca:
        return false
    val cert_sig_alg = get_signature_algorithm(cert)
    val issuer_key = get_public_key(issuer)
    var issuer_key_type = ""
    if issuer_key.length() > 0:
        issuer_key_type = issuer_key[0]
    var alg_matches = false
    var cert_sig_lower = cert_sig_alg.lower()
    var has_rsa = cert_sig_lower.contains("rsa")
    var has_ecdsa = cert_sig_lower.contains("ecdsa")
    if has_rsa:
        alg_matches = issuer_key_type == "RSA"
    if has_ecdsa:
        alg_matches = issuer_key_type == "EC"
    var is_neither = (not has_rsa) and (not has_ecdsa)
    if is_neither:
        alg_matches = true
    alg_matches

fn verify_chain(chain: text) -> bool:
    if chain.length() == 0:
        return false
    var i = 0
    while i < chain.length():
        val cert = chain[i]
        val is_valid = check_expiry(cert)
        if not is_valid:
            return false
        if i > 0:
            val is_ca = is_ca_certificate(cert)
            if not is_ca:
                return false
        i = i + 1
    true

fn validate_certificate(cert: text, roots: text) -> bool:
    val is_valid = check_expiry(cert)
    if not is_valid:
        return false
    val chain = build_certificate_chain(cert, [], roots)
    verify_chain(chain)

fn is_valid_for_domain(cert: text, domain: text) -> bool:
    val subject = get_subject(cert)
    val cn = get_common_name(subject)
    if cn == domain:
        return true
    if cn.starts_with("*."):
        val wildcard_domain = cn.substring(2, cn.length())
        if domain.ends_with(wildcard_domain):
            return true
    val dns_names = get_dns_names(cert)
    var i = 0
    while i < dns_names.length():
        val name = dns_names[i]
        if name == domain:
            return true
        if name.starts_with("*."):
            val wildcard_domain = name.substring(2, name.length())
            if domain.ends_with(wildcard_domain):
                return true
        i = i + 1
    false

fn get_certificate_age_days(cert: text) -> i64:
    val validity = get_validity(cert)
    val not_before = validity[0]
    if not_before == nil:
        return 0
    val current_time = get_current_timestamp()
    val before_ts = time_to_timestamp(not_before)
    val age_seconds = current_time - before_ts
    val age_days = age_seconds / 86400
    age_days

fn get_certificate_remaining_days(cert: text) -> i64:
    val validity = get_validity(cert)
    val not_after = validity[1]
    if not_after == nil:
        return 0
    val current_time = get_current_timestamp()
    val after_ts = time_to_timestamp(not_after)
    val remaining_seconds = after_ts - current_time
    val remaining_days = remaining_seconds / 86400
    remaining_days

fn will_expire_soon(cert: text, days: i64) -> bool:
    val remaining = get_certificate_remaining_days(cert)
    remaining <= days

# Re-export chain functions
fn find_issuer(cert: text, candidates: text) -> text:
    val issuer_dn = get_issuer(cert)
    val issuer_cn = get_common_name(issuer_dn)
    var i = 0
    while i < candidates.length():
        val candidate = candidates[i]
        val subject_dn = get_subject(candidate)
        val subject_cn = get_common_name(subject_dn)
        if issuer_cn == subject_cn:
            return candidate
        i = i + 1
    nil

fn build_certificate_chain(cert: text, intermediates: text, roots: text) -> text:
    var chain = [cert]
    var current = cert
    var all_certs = intermediates + roots
    var max_depth = 10
    var depth = 0
    while depth < max_depth:
        if is_self_signed(current):
            break
        val issuer = find_issuer(current, all_certs)
        if issuer == nil:
            break
        chain = chain + [issuer]
        current = issuer
        depth = depth + 1
    chain

# Re-export utility functions
fn simple_hash(data: text, seed: i64) -> i64:
    var hash = seed
    if hash == 0:
        hash = 5381
    var i = 0
    var data_len = data.length()
    while i < data_len:
        val char_code = data.char_code_at(i)
        hash = ((hash << 5) + hash) + char_code
        i = i + 1
    hash

fn bytes_to_hex(bytes: text) -> text:
    val hex_chars = "0123456789ABCDEF"
    var result = ""
    var i = 0
    while i < bytes.length():
        val byte_val = bytes.char_code_at(i)
        val high = (byte_val >> 4) & 15
        val low = byte_val & 15
        result = result + hex_chars.char_at(high) + hex_chars.char_at(low)
        i = i + 1
    result

fn certificate_fingerprint(cert: text) -> text:
    val der = get_raw_der(cert)
    val hex = _sha256_hex_of_text(der)
    hex

fn sha256_fingerprint(cert: text) -> text:
    val der = get_raw_der(cert)
    val hex = _sha256_hex_of_text(der)
    var formatted = ""
    var i = 0
    var hex_len = hex.length()
    while i < hex_len:
        if i > 0:
            var is_even = (i % 2) == 0
            if is_even:
                formatted = formatted + ":"
        var ch = hex.substring(i, i + 1)
        formatted = formatted + ch.to_upper()
        i = i + 1
    formatted

fn sha1_fingerprint(cert: text) -> text:
    val der = get_raw_der(cert)
    val hex = _sha1_hex_of_text(der)
    var formatted = ""
    var i = 0
    var hex_len = hex.length()
    while i < hex_len:
        if i > 0:
            var is_even = (i % 2) == 0
            if is_even:
                formatted = formatted + ":"
        var ch = hex.substring(i, i + 1)
        formatted = formatted + ch.to_upper()
        i = i + 1
    formatted

fn _sha256_hex_of_text(data: text) -> text:
    val mask32 = 4294967295
    var h0 = 1779033703
    var h1 = 3144134277
    var h2 = 1013904242
    var h3 = 2773480762
    var h4 = 1359893119
    var h5 = 2600822924
    var h6 = 528734635
    var h7 = 1541459225
    var kk = [
        1116352408, 1899447441, 3049323471, 3921009573,
        961987163, 1508970993, 2453635748, 2870763221,
        3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037,
        2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877,
        958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298
    ]
    var data_len = data.length()
    var bytes = []
    var bi = 0
    while bi < data_len:
        bytes.push(data.char_code_at(bi))
        bi = bi + 1
    bytes.push(128)
    var pad_target = data_len + 1
    var pad_zeros = 56 - (pad_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        bytes.push(0)
        pz = pz + 1
    var bit_length = data_len * 8
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push((bit_length >> 24) & 255)
    bytes.push((bit_length >> 16) & 255)
    bytes.push((bit_length >> 8) & 255)
    bytes.push(bit_length & 255)
    var total_len = bytes.length()
    var block_off = 0
    while block_off < total_len:
        var w = []
        var wi = 0
        while wi < 16:
            var base = block_off + (wi * 4)
            var word = ((bytes[base] & 255) << 24) | ((bytes[base + 1] & 255) << 16) | ((bytes[base + 2] & 255) << 8) | (bytes[base + 3] & 255)
            word = word & mask32
            w.push(word)
            wi = wi + 1
        wi = 16
        while wi < 64:
            var w15 = w[wi - 15] & mask32
            var w2 = w[wi - 2] & mask32
            var s0 = (((w15 >> 7) | (w15 << 25)) ^ ((w15 >> 18) | (w15 << 14)) ^ (w15 >> 3)) & mask32
            var s1 = (((w2 >> 17) | (w2 << 15)) ^ ((w2 >> 19) | (w2 << 13)) ^ (w2 >> 10)) & mask32
            var new_w = (w[wi - 16] + s0 + w[wi - 7] + s1) & mask32
            w.push(new_w)
            wi = wi + 1
        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var hv = h7
        var ri = 0
        while ri < 64:
            var ea = e & mask32
            var big_s1 = (((ea >> 6) | (ea << 26)) ^ ((ea >> 11) | (ea << 21)) ^ ((ea >> 25) | (ea << 7))) & mask32
            var ch = ((ea & (f & mask32)) ^ ((~ea & mask32) & (g & mask32))) & mask32
            var temp1 = (hv + big_s1 + ch + kk[ri] + w[ri]) & mask32
            var aa = a & mask32
            var big_s0 = (((aa >> 2) | (aa << 30)) ^ ((aa >> 13) | (aa << 19)) ^ ((aa >> 22) | (aa << 10))) & mask32
            var maj = ((aa & (b & mask32)) ^ (aa & (c & mask32)) ^ ((b & mask32) & (c & mask32))) & mask32
            var temp2 = (big_s0 + maj) & mask32
            hv = g
            g = f
            f = e
            e = (d + temp1) & mask32
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & mask32
            ri = ri + 1
        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        h5 = (h5 + f) & mask32
        h6 = (h6 + g) & mask32
        h7 = (h7 + hv) & mask32
        block_off = block_off + 64
    var hex_chars = "0123456789abcdef"
    var result = ""
    var h_vals = [h0, h1, h2, h3, h4, h5, h6, h7]
    var hi = 0
    while hi < 8:
        var word = h_vals[hi] & mask32
        var nidx = 7
        while nidx >= 0:
            var nibble = (word >> (nidx * 4)) & 15
            result = result + hex_chars.substring(nibble, nibble + 1)
            nidx = nidx - 1
        hi = hi + 1
    result

fn _sha1_hex_of_text(data: text) -> text:
    val mask32 = 4294967295
    var h0 = 1732584193
    var h1 = 4023233417
    var h2 = 2562383102
    var h3 = 271733878
    var h4 = 3285377520
    var data_len = data.length()
    var bytes = []
    var bi = 0
    while bi < data_len:
        bytes.push(data.char_code_at(bi))
        bi = bi + 1
    bytes.push(128)
    var pad_target = data_len + 1
    var pad_zeros = 56 - (pad_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        bytes.push(0)
        pz = pz + 1
    var bit_length = data_len * 8
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push((bit_length >> 24) & 255)
    bytes.push((bit_length >> 16) & 255)
    bytes.push((bit_length >> 8) & 255)
    bytes.push(bit_length & 255)
    var total_len = bytes.length()
    var block_off = 0
    while block_off < total_len:
        var w = []
        var wi = 0
        while wi < 16:
            var base = block_off + (wi * 4)
            var word = ((bytes[base] & 255) << 24) | ((bytes[base + 1] & 255) << 16) | ((bytes[base + 2] & 255) << 8) | (bytes[base + 3] & 255)
            word = word & mask32
            w.push(word)
            wi = wi + 1
        wi = 16
        while wi < 80:
            var xor_val = w[wi - 3] ^ w[wi - 8] ^ w[wi - 14] ^ w[wi - 16]
            var rotated = ((xor_val << 1) | (xor_val >> 31)) & mask32
            w.push(rotated)
            wi = wi + 1
        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var ri = 0
        while ri < 80:
            var f_val = 0
            var k_val = 0
            if ri < 20:
                f_val = ((b & c) ^ ((~b & mask32) & d)) & mask32
                k_val = 1518500249
            else:
                if ri < 40:
                    f_val = (b ^ c ^ d) & mask32
                    k_val = 1859775393
                else:
                    if ri < 60:
                        f_val = ((b & c) ^ (b & d) ^ (c & d)) & mask32
                        k_val = 2400959708
                    else:
                        f_val = (b ^ c ^ d) & mask32
                        k_val = 3395469782
            var a_rot = ((a << 5) | (a >> 27)) & mask32
            var temp = (a_rot + f_val + e + k_val + w[ri]) & mask32
            e = d
            d = c
            c = ((b << 30) | (b >> 2)) & mask32
            b = a
            a = temp
            ri = ri + 1
        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        block_off = block_off + 64
    var hex_chars = "0123456789abcdef"
    var result = ""
    var h_vals = [h0, h1, h2, h3, h4]
    var hi = 0
    while hi < 5:
        var word = h_vals[hi] & mask32
        var nidx = 7
        while nidx >= 0:
            var nibble = (word >> (nidx * 4)) & 15
            result = result + hex_chars.substring(nibble, nibble + 1)
            nidx = nidx - 1
        hi = hi + 1
    result

fn certificate_to_string(cert: text) -> text:
    var result = "Certificate:\n"
    result = result + "  Version: {get_version(cert)}\n"
    result = result + "  Serial Number: {get_serial_number(cert)}\n"
    val issuer = get_issuer(cert)
    result = result + "  Issuer: {dn_to_string(issuer)}\n"
    val subject = get_subject(cert)
    result = result + "  Subject: {dn_to_string(subject)}\n"
    val validity = get_validity(cert)
    val not_before = validity[0]
    val not_after = validity[1]
    result = result + "  Valid from: {not_before[0]}-{not_before[1]}-{not_before[2]}\n"
    result = result + "  Valid to: {not_after[0]}-{not_after[1]}-{not_after[2]}\n"
    val pub_key = get_public_key(cert)
    result = result + "  Public Key: {pub_key[2]} bits\n"
    val is_ca = is_ca_certificate(cert)
    result = result + "  CA: {is_ca}\n"
    result

fn certificates_match(cert1: text, cert2: text) -> bool:
    val serial1 = get_serial_number(cert1)
    val serial2 = get_serial_number(cert2)
    if serial1 != serial2:
        return false
    val subject1 = get_subject(cert1)
    val subject2 = get_subject(cert2)
    val cn1 = get_common_name(subject1)
    val cn2 = get_common_name(subject2)
    cn1 == cn2

fn get_certificate_purposes(cert: text) -> text:
    var purposes = []
    val is_ca = is_ca_certificate(cert)
    if is_ca:
        purposes = purposes + ["CA"]
    val key_usage = get_key_usage(cert)
    if key_usage != nil:
        if has_key_usage_flag(cert, KU_DIGITAL_SIGNATURE):
            purposes = purposes + ["Digital Signature"]
        if has_key_usage_flag(cert, KU_KEY_ENCIPHERMENT):
            purposes = purposes + ["Key Encipherment"]
        if has_key_usage_flag(cert, KU_KEY_CERT_SIGN):
            purposes = purposes + ["Certificate Signing"]
    purposes

fn extract_certificate_info(cert: text) -> text:
    val subject = get_subject(cert)
    val issuer = get_issuer(cert)
    val validity = get_validity(cert)
    val serial = get_serial_number(cert)
    val is_ca = is_ca_certificate(cert)
    val dns_names = get_dns_names(cert)
    val key_bits = get_public_key_bits(cert)
    (subject, issuer, validity, serial, is_ca, dns_names, key_bits)
