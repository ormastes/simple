# Target Architecture
#
# Target architecture abstraction for cross-compilation support.
# Port of rust/common/src/target.rs

export TargetArch, PointerSize, TargetOS, TargetConfig, Target, WasmRuntime

# Supported CPU architectures
enum TargetArch:
    X86_64      # x86-64 (AMD64)
    Aarch64     # ARM64
    X86         # x86 32-bit (i686)
    Arm         # ARM 32-bit (ARMv7)
    Riscv64     # RISC-V 64-bit
    Riscv32     # RISC-V 32-bit
    Wasm32      # WebAssembly 32-bit
    Wasm64      # WebAssembly 64-bit

impl TargetArch:
    # Get host architecture via FFI
    static fn host() -> TargetArch:
        extern fn rt_host_arch() -> text
        # TODO: Replace direct FFI call with wrapper (host_arch) from app.io or compiler.ffi
        val arch = rt_host_arch()
        TargetArch.parse(arch) ?? TargetArch.X86_64

    static fn parse(name: text) -> TargetArch?:
        val lower = name.lower()
        match lower:
            case "x86_64" | "x86-64" | "amd64" | "x64": Some(TargetArch.X86_64)
            case "aarch64" | "arm64": Some(TargetArch.Aarch64)
            case "x86" | "i686" | "i386": Some(TargetArch.X86)
            case "arm" | "armv7" | "arm32": Some(TargetArch.Arm)
            case "riscv64" | "riscv64gc": Some(TargetArch.Riscv64)
            case "riscv32" | "riscv32gc": Some(TargetArch.Riscv32)
            case "wasm32" | "wasm": Some(TargetArch.Wasm32)
            case "wasm64": Some(TargetArch.Wasm64)
            case _: None

    fn pointer_size() -> PointerSize:
        match self:
            case TargetArch.X86_64 | TargetArch.Aarch64 | TargetArch.Riscv64 | TargetArch.Wasm64:
                PointerSize.Bits64
            case _:
                PointerSize.Bits32

    fn is_64bit() -> bool:
        self.pointer_size() == PointerSize.Bits64

    fn is_32bit() -> bool:
        self.pointer_size() == PointerSize.Bits32

    fn is_wasm() -> bool:
        match self:
            case TargetArch.Wasm32 | TargetArch.Wasm64: true
            case _: false

    fn name() -> text:
        match self:
            case TargetArch.X86_64: "x86_64"
            case TargetArch.Aarch64: "aarch64"
            case TargetArch.X86: "i686"
            case TargetArch.Arm: "armv7"
            case TargetArch.Riscv64: "riscv64"
            case TargetArch.Riscv32: "riscv32"
            case TargetArch.Wasm32: "wasm32"
            case TargetArch.Wasm64: "wasm64"

    fn triple_str() -> text:
        match self:
            case TargetArch.X86_64: "x86_64-unknown-linux-gnu"
            case TargetArch.Aarch64: "aarch64-unknown-linux-gnu"
            case TargetArch.X86: "i686-unknown-linux-gnu"
            case TargetArch.Arm: "armv7-unknown-linux-gnueabihf"
            case TargetArch.Riscv64: "riscv64gc-unknown-linux-gnu"
            case TargetArch.Riscv32: "riscv32gc-unknown-linux-gnu"
            case TargetArch.Wasm32: "wasm32-unknown-unknown"
            case TargetArch.Wasm64: "wasm64-unknown-unknown"

    # Target triple for bare-metal (no OS) targets
    fn triple_str_baremetal() -> text:
        match self:
            case TargetArch.X86_64: "x86_64-unknown-none"
            case TargetArch.Aarch64: "aarch64-unknown-none"
            case TargetArch.X86: "i686-unknown-none"
            case TargetArch.Arm: "thumbv7m-none-eabi"
            case TargetArch.Riscv64: "riscv64gc-unknown-none-elf"
            case TargetArch.Riscv32: "riscv32gc-unknown-none-elf"
            case TargetArch.Wasm32: "wasm32-unknown-unknown"
            case TargetArch.Wasm64: "wasm64-unknown-unknown"

# Pointer size
enum PointerSize:
    Bits32
    Bits64

impl PointerSize:
    fn bytes() -> i64:
        match self:
            case PointerSize.Bits32: 4
            case PointerSize.Bits64: 8

    fn bits() -> i64:
        match self:
            case PointerSize.Bits32: 32
            case PointerSize.Bits64: 64

# Supported operating systems
enum TargetOS:
    Any
    Linux
    Windows
    MacOS
    FreeBSD
    None
    BareMetal   # No OS, direct hardware access (embedded/QEMU)

impl TargetOS:
    static fn host() -> TargetOS:
        extern fn rt_host_os() -> text
        # TODO: Replace direct FFI call with wrapper (host_os) from app.io or compiler.ffi
        val os = rt_host_os()
        match os.lower():
            case "linux": TargetOS.Linux
            case "windows": TargetOS.Windows
            case "macos" | "darwin": TargetOS.MacOS
            case "freebsd": TargetOS.FreeBSD
            case _: TargetOS.Any

    fn name() -> text:
        match self:
            case TargetOS.Any: "any"
            case TargetOS.Linux: "linux"
            case TargetOS.Windows: "windows"
            case TargetOS.MacOS: "macos"
            case TargetOS.FreeBSD: "freebsd"
            case TargetOS.None: "none"
            case TargetOS.BareMetal: "none"  # Same as None for triple

    fn is_baremetal() -> bool:
        match self:
            case TargetOS.BareMetal: true
            case _: false

    fn is_hosted() -> bool:
        match self:
            case TargetOS.Linux | TargetOS.Windows | TargetOS.MacOS | TargetOS.FreeBSD: true
            case _: false

# WebAssembly runtime environment
enum WasmRuntime:
    Standalone
    Wasi
    Browser
    Emscripten

impl WasmRuntime:
    fn name() -> text:
        match self:
            case WasmRuntime.Standalone: "standalone"
            case WasmRuntime.Wasi: "wasi"
            case WasmRuntime.Browser: "browser"
            case WasmRuntime.Emscripten: "emscripten"

# Target-specific configuration constants
struct TargetConfig:
    arch: TargetArch
    pointer_bytes: i64
    value_bytes: i64
    tag_bits: i64
    heap_align: i64
    is_little_endian: bool
    default_stack_size: i64

impl TargetConfig:
    static fn for_arch(arch: TargetArch) -> TargetConfig:
        if arch.is_64bit():
            TargetConfig(arch: arch, pointer_bytes: 8, value_bytes: 8,
                         tag_bits: 3, heap_align: 8, is_little_endian: true,
                         default_stack_size: 8 * 1024 * 1024)
        else:
            TargetConfig(arch: arch, pointer_bytes: 4, value_bytes: 8,
                         tag_bits: 3, heap_align: 8, is_little_endian: true,
                         default_stack_size: 2 * 1024 * 1024)

    fn tag_mask() -> i64:
        (1 << self.tag_bits) - 1

# Full target specification
struct Target:
    arch: TargetArch
    os: TargetOS
    wasm_runtime: WasmRuntime?

impl Target:
    static fn host() -> Target:
        Target(arch: TargetArch.host(), os: TargetOS.host(), wasm_runtime: None)

    fn config() -> TargetConfig:
        TargetConfig.for_arch(self.arch)

    fn is_host() -> bool:
        self.arch == TargetArch.host() and self.os == TargetOS.host()

    fn is_baremetal() -> bool:
        self.os.is_baremetal()

    fn triple() -> text:
        if self.os.is_baremetal():
            self.arch.triple_str_baremetal()
        else:
            self.arch.triple_str()

    fn to_text() -> text:
        "{self.arch.name()}-{self.os.name()}"

    static fn parse(s: text) -> Target?:
        val parts = s.split("-")
        if parts.len() == 0:
            return None
        val arch = TargetArch.parse(parts[0])
        if not arch.?:
            return None
        # Check for baremetal-* prefix format
        if s.starts_with("baremetal-"):
            val arch_part = s.substring(10)  # After "baremetal-"
            val bare_arch = TargetArch.parse(arch_part)
            if bare_arch.?:
                return Some(Target(arch: bare_arch.unwrap(), os: TargetOS.BareMetal, wasm_runtime: None))
        val os = if parts.len() > 1:
            match parts[1].lower():
                case "linux" | "gnu": TargetOS.Linux
                case "windows" | "win" | "msvc": TargetOS.Windows
                case "macos" | "darwin" | "apple": TargetOS.MacOS
                case "freebsd": TargetOS.FreeBSD
                case "none" | "bare" | "unknown" | "wasi": TargetOS.None
                case "baremetal": TargetOS.BareMetal
                case _: TargetOS.Any
        else:
            TargetOS.host()
        Some(Target(arch: arch.unwrap(), os: os, wasm_runtime: None))
