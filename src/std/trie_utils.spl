# Trie (Prefix Tree) Implementation
#
# A trie is a tree data structure used for efficient string storage and retrieval.
# Each node represents a character, and paths from root to nodes form strings.
# Ideal for autocomplete, spell checking, and prefix-based searches.
#
# Examples:
#   trie = trie_create()
#   trie_insert(trie, "cat")
#   trie_insert(trie, "car")
#   trie_insert(trie, "card")
#   trie_contains(trie, "cat")  # true
#   trie_starts_with(trie, "ca")  # true
#   trie_find_all_with_prefix(trie, "ca")  # ["cat", "car", "card"]
#   trie_suggest(trie, "ca", 2)  # ["cat", "car"]

# Core Trie Operations

# Creates a new empty trie
# Returns: Empty trie node (dict with 'children' and 'is_end' fields)
fn trie_create():
    {
        "children": {},
        "is_end": false
    }

# Creates a trie node
# Returns: Trie node with empty children and not marked as end
fn trie_node():
    {
        "children": {},
        "is_end": false
    }

# Inserts a word into the trie
# Args:
#   trie: The trie root node
#   word: String to insert
# Returns: nil
fn trie_insert(trie, word):
    var current = trie
    var i = 0
    var len = word.length()

    while i < len:
        var ch = word.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            children[ch] = trie_node()

        current = children[ch]
        i = i + 1

    current["is_end"] = true
    nil

# Searches for a complete word in the trie
# Args:
#   trie: The trie root node
#   word: String to search for
# Returns: true if word exists as complete word, false otherwise
fn trie_search(trie, word):
    var node = trie_find_node(trie, word)
    if node == nil:
        false
    else:
        node["is_end"]

# Checks if a word exists in the trie (alias for trie_search)
# Args:
#   trie: The trie root node
#   word: String to check
# Returns: true if word exists, false otherwise
fn trie_contains(trie, word):
    trie_search(trie, word)

# Checks if any word in the trie starts with the given prefix
# Args:
#   trie: The trie root node
#   prefix: String prefix to check
# Returns: true if prefix exists, false otherwise
fn trie_starts_with(trie, prefix):
    var node = trie_find_node(trie, prefix)
    node != nil

# Finds the trie node corresponding to a given string
# Args:
#   trie: The trie root node
#   str: String to find node for
# Returns: The trie node if found, nil otherwise
fn trie_find_node(trie, str):
    var current = trie
    var i = 0
    var len = str.length()

    while i < len:
        var ch = str.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            return nil

        current = children[ch]
        i = i + 1

    current

# Deletes a word from the trie
# Args:
#   trie: The trie root node
#   word: String to delete
# Returns: true if word was deleted, false if not found
fn trie_delete(trie, word):
    trie_delete_helper(trie, word, 0)

# Helper function for deleting a word (recursive simulation)
# Args:
#   node: Current trie node
#   word: Word to delete
#   index: Current position in word
# Returns: true if node should be deleted, false otherwise
fn trie_delete_helper(node, word, index):
    if node == nil:
        return false

    var len = word.length()

    if index == len:
        if not node["is_end"]:
            return false

        node["is_end"] = false
        var children = node["children"]
        return children.size() == 0

    var ch = word.char_at(index)
    var children = node["children"]

    if not children.has_key(ch):
        return false

    var child_node = children[ch]
    var should_delete = trie_delete_helper(child_node, word, index + 1)

    if should_delete:
        children.remove(ch)
        var remaining = children.size()
        return remaining == 0 and not node["is_end"]

    false

# Prefix Operations

# Finds all words in the trie that start with the given prefix
# Args:
#   trie: The trie root node
#   prefix: String prefix to search for
# Returns: List of all words with the given prefix
fn trie_find_all_with_prefix(trie, prefix):
    var results = []
    var node = trie_find_node(trie, prefix)

    if node == nil:
        return results

    trie_collect_words(node, prefix, results)
    results

# Helper function to collect all words from a node
# Args:
#   node: Starting trie node
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_collect_words(node, current, results):
    if node["is_end"]:
        results.append(current)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var next_str = current + ch
        trie_collect_words(child, next_str, results)
        i = i + 1

    nil

# Counts how many words start with the given prefix
# Args:
#   trie: The trie root node
#   prefix: String prefix to count
# Returns: Number of words with the prefix
fn trie_count_with_prefix(trie, prefix):
    var words = trie_find_all_with_prefix(trie, prefix)
    words.length()

# Finds the longest common prefix among all words in the trie
# Args:
#   trie: The trie root node
# Returns: Longest common prefix string
fn trie_longest_common_prefix(trie):
    var result = ""
    var current = trie

    while true:
        var children = current["children"]
        var keys = children.keys()

        if keys.length() != 1:
            return result

        if current["is_end"]:
            return result

        var ch = keys[0]
        result = result + ch
        current = children[ch]

    result

# Finds the longest prefix of the given string that exists in the trie
# Args:
#   trie: The trie root node
#   str: String to find longest prefix for
# Returns: Longest prefix that exists in trie
fn trie_longest_prefix(trie, str):
    var current = trie
    var result = ""
    var i = 0
    var len = str.length()

    while i < len:
        var ch = str.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            return result

        result = result + ch
        current = children[ch]
        i = i + 1

    result

# Gets all prefixes of a word that exist as complete words in the trie
# Args:
#   trie: The trie root node
#   word: Word to find prefixes of
# Returns: List of all prefixes that are complete words
fn trie_all_prefixes(trie, word):
    var results = []
    var current = trie
    var prefix = ""
    var i = 0
    var len = word.length()

    while i < len:
        var ch = word.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            return results

        prefix = prefix + ch
        current = children[ch]

        if current["is_end"]:
            results.append(prefix)

        i = i + 1

    results

# Traversal Operations

# Gets all words stored in the trie
# Args:
#   trie: The trie root node
# Returns: List of all words in the trie
fn trie_all_words(trie):
    var results = []
    trie_collect_words(trie, "", results)
    results

# Gets all unique prefixes in the trie (including complete words)
# Args:
#   trie: The trie root node
# Returns: List of all prefixes
fn trie_all_unique_prefixes(trie):
    var results = []
    trie_collect_all_prefixes(trie, "", results)
    results

# Helper function to collect all prefixes from a node
# Args:
#   node: Starting trie node
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_collect_all_prefixes(node, current, results):
    if current.length() > 0:
        results.append(current)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var next_str = current + ch
        trie_collect_all_prefixes(child, next_str, results)
        i = i + 1

    nil

# Autocomplete Operations

# Suggests words based on a prefix (limited results)
# Args:
#   trie: The trie root node
#   prefix: String prefix to suggest from
#   max_results: Maximum number of suggestions to return
# Returns: List of suggested words (up to max_results)
fn trie_suggest(trie, prefix, max_results):
    var all_words = trie_find_all_with_prefix(trie, prefix)
    var results = []
    var i = 0
    var len = all_words.length()
    var count = 0

    while i < len and count < max_results:
        results.append(all_words[i])
        count = count + 1
        i = i + 1

    results

# Completes a partial word with the shortest completion
# Args:
#   trie: The trie root node
#   prefix: Partial word to complete
# Returns: Shortest complete word with the prefix, or nil if none exists
fn trie_complete_word(trie, prefix):
    var words = trie_find_all_with_prefix(trie, prefix)
    if words.length() == 0:
        return nil

    var shortest = words[0]
    var shortest_len = shortest.length()
    var i = 1
    var len = words.length()

    while i < len:
        var word = words[i]
        var word_len = word.length()
        if word_len < shortest_len:
            shortest = word
            shortest_len = word_len
        i = i + 1

    shortest

# Trie Properties

# Returns the number of words in the trie
# Args:
#   trie: The trie root node
# Returns: Count of words
fn trie_size(trie):
    var count = 0
    trie_count_words(trie, count)

# Helper function to count words in the trie
# Args:
#   node: Current trie node
#   count: Current count (passed by value, need to sum results)
# Returns: Total count of words from this node
fn trie_count_words(node, count):
    var total = count
    if node["is_end"]:
        total = total + 1

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        total = trie_count_words(child, total)
        i = i + 1

    total

# Checks if the trie is empty
# Args:
#   trie: The trie root node
# Returns: true if trie has no words, false otherwise
fn trie_is_empty(trie):
    var children = trie["children"]
    children.size() == 0

# Returns the maximum depth of the trie
# Args:
#   trie: The trie root node
# Returns: Maximum depth (longest word length)
fn trie_depth(trie):
    trie_max_depth(trie, 0)

# Helper function to find maximum depth
# Args:
#   node: Current trie node
#   current_depth: Current depth level
# Returns: Maximum depth from this node
fn trie_max_depth(node, current_depth):
    var children = node["children"]
    if children.size() == 0:
        return current_depth

    var max = current_depth
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var depth = trie_max_depth(child, current_depth + 1)
        if depth > max:
            max = depth
        i = i + 1

    max

# Returns the minimum depth where a word ends
# Args:
#   trie: The trie root node
# Returns: Minimum depth (shortest word length), or 0 if empty
fn trie_min_depth(trie):
    trie_min_depth_helper(trie, 0)

# Helper function to find minimum depth
# Args:
#   node: Current trie node
#   current_depth: Current depth level
# Returns: Minimum depth from this node, or very large number if no words
fn trie_min_depth_helper(node, current_depth):
    if node["is_end"]:
        return current_depth

    var children = node["children"]
    if children.size() == 0:
        return 999999

    var min = 999999
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var depth = trie_min_depth_helper(child, current_depth + 1)
        if depth < min:
            min = depth
        i = i + 1

    min

# Pattern Matching Operations

# Searches for words matching a wildcard pattern
# Args:
#   trie: The trie root node
#   pattern: Pattern string with ? (any single char) and * (any sequence)
# Returns: List of matching words
fn trie_wildcard_search(trie, pattern):
    var results = []
    trie_wildcard_search_helper(trie, pattern, 0, "", results)
    results

# Helper function for wildcard search
# Args:
#   node: Current trie node
#   pattern: Pattern to match
#   p_index: Current position in pattern
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_wildcard_search_helper(node, pattern, p_index, current, results):
    var p_len = pattern.length()

    if p_index == p_len:
        if node["is_end"]:
            results.append(current)
        return nil

    var ch = pattern.char_at(p_index)
    var children = node["children"]

    if ch == "?":
        var keys = children.keys()
        var i = 0
        var len = keys.length()

        while i < len:
            var key = keys[i]
            var child = children[key]
            var next_str = current + key
            trie_wildcard_search_helper(child, pattern, p_index + 1, next_str, results)
            i = i + 1
    elif ch == "*":
        trie_wildcard_star_helper(node, pattern, p_index, current, results)
    else:
        if children.has_key(ch):
            var child = children[ch]
            var next_str = current + ch
            trie_wildcard_search_helper(child, pattern, p_index + 1, next_str, results)

    nil

# Helper function for * wildcard matching
# Args:
#   node: Current trie node
#   pattern: Pattern to match
#   p_index: Current position in pattern (at *)
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_wildcard_star_helper(node, pattern, p_index, current, results):
    trie_wildcard_search_helper(node, pattern, p_index + 1, current, results)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var key = keys[i]
        var child = children[key]
        var next_str = current + key
        trie_wildcard_star_helper(child, pattern, p_index, next_str, results)
        i = i + 1

    nil

# Finds words matching a specific pattern (exact length with ?)
# Args:
#   trie: The trie root node
#   pattern: Pattern with ? for any character
# Returns: List of matching words
fn trie_words_with_pattern(trie, pattern):
    trie_wildcard_search(trie, pattern)

# Utility Operations

# Finds the shortest word in the trie
# Args:
#   trie: The trie root node
# Returns: Shortest word, or nil if trie is empty
fn trie_shortest_word(trie):
    var words = trie_all_words(trie)
    if words.length() == 0:
        return nil

    var shortest = words[0]
    var shortest_len = shortest.length()
    var i = 1
    var len = words.length()

    while i < len:
        var word = words[i]
        var word_len = word.length()
        if word_len < shortest_len:
            shortest = word
            shortest_len = word_len
        i = i + 1

    shortest

# Finds the longest word in the trie
# Args:
#   trie: The trie root node
# Returns: Longest word, or nil if trie is empty
fn trie_longest_word(trie):
    var words = trie_all_words(trie)
    if words.length() == 0:
        return nil

    var longest = words[0]
    var longest_len = longest.length()
    var i = 1
    var len = words.length()

    while i < len:
        var word = words[i]
        var word_len = word.length()
        if word_len > longest_len:
            longest = word
            longest_len = word_len
        i = i + 1

    longest

# Merges two tries into a new trie
# Args:
#   trie1: First trie
#   trie2: Second trie
# Returns: New trie containing all words from both tries
fn trie_merge(trie1, trie2):
    var result = trie_create()
    var words1 = trie_all_words(trie1)
    var words2 = trie_all_words(trie2)

    var i = 0
    var len1 = words1.length()
    while i < len1:
        trie_insert(result, words1[i])
        i = i + 1

    var j = 0
    var len2 = words2.length()
    while j < len2:
        trie_insert(result, words2[j])
        j = j + 1

    result

# Creates a trie from a list of words
# Args:
#   words: List of strings to insert
# Returns: New trie containing all words
fn trie_from_list(words):
    var trie = trie_create()
    var i = 0
    var len = words.length()

    while i < len:
        trie_insert(trie, words[i])
        i = i + 1

    trie

# Converts a trie to a list of words
# Args:
#   trie: The trie root node
# Returns: List of all words in the trie
fn trie_to_list(trie):
    trie_all_words(trie)

# Clears all words from the trie
# Args:
#   trie: The trie root node
# Returns: nil
fn trie_clear(trie):
    trie["children"] = {}
    trie["is_end"] = false
    nil

# Checks if a trie contains any word from a list
# Args:
#   trie: The trie root node
#   words: List of words to check
# Returns: true if any word exists in trie, false otherwise
fn trie_contains_any(trie, words):
    var i = 0
    var len = words.length()

    while i < len:
        if trie_contains(trie, words[i]):
            return true
        i = i + 1

    false

# Checks if a trie contains all words from a list
# Args:
#   trie: The trie root node
#   words: List of words to check
# Returns: true if all words exist in trie, false otherwise
fn trie_contains_all(trie, words):
    var i = 0
    var len = words.length()

    while i < len:
        if not trie_contains(trie, words[i]):
            return false
        i = i + 1

    true

# Gets the number of children of the root node
# Args:
#   trie: The trie root node
# Returns: Number of direct children
fn trie_branch_count(trie):
    var children = trie["children"]
    children.size()

# Finds all words of a specific length
# Args:
#   trie: The trie root node
#   length: Desired word length
# Returns: List of words with the specified length
fn trie_words_of_length(trie, length):
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()

    while i < len:
        var word = all_words[i]
        if word.length() == length:
            results.append(word)
        i = i + 1

    results

# Finds all words within a length range
# Args:
#   trie: The trie root node
#   min_len: Minimum word length (inclusive)
#   max_len: Maximum word length (inclusive)
# Returns: List of words within the length range
fn trie_words_in_range(trie, min_len, max_len):
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()

    while i < len:
        var word = all_words[i]
        var word_len = word.length()
        if word_len >= min_len and word_len <= max_len:
            results.append(word)
        i = i + 1

    results

# Counts the total number of nodes in the trie
# Args:
#   trie: The trie root node
# Returns: Total number of nodes (including root)
fn trie_node_count(trie):
    trie_count_nodes_helper(trie)

# Helper function to count all nodes
# Args:
#   node: Current trie node
# Returns: Total number of nodes from this node (inclusive)
fn trie_count_nodes_helper(node):
    var count = 1
    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        count = count + trie_count_nodes_helper(child)
        i = i + 1

    count

# Checks if one word is a prefix of another word in the trie
# Args:
#   trie: The trie root node
#   word: Word to check if it's a prefix
# Returns: true if word is a prefix of a longer word in trie, false otherwise
fn trie_is_prefix_of_word(trie, word):
    var node = trie_find_node(trie, word)
    if node == nil:
        return false

    var children = node["children"]
    children.size() > 0

# Gets all words that have the given word as a prefix
# Args:
#   trie: The trie root node
#   prefix: The prefix word
# Returns: List of words that start with prefix (excluding prefix itself if it's a word)
fn trie_words_with_prefix_only(trie, prefix):
    var all_matches = trie_find_all_with_prefix(trie, prefix)
    var results = []
    var i = 0
    var len = all_matches.length()

    while i < len:
        var word = all_matches[i]
        if word != prefix:
            results.append(word)
        i = i + 1

    results

# Serialization Operations

# Converts trie to a simple string representation (all words separated by newlines)
# Args:
#   trie: The trie root node
# Returns: String with all words, one per line
fn trie_to_string(trie):
    var words = trie_all_words(trie)
    var result = ""
    var i = 0
    var len = words.length()

    while i < len:
        result = result + words[i]
        if i < len - 1:
            result = result + "\n"
        i = i + 1

    result

# Creates a trie from a string with words separated by newlines
# Args:
#   str: String containing words separated by newlines
# Returns: New trie containing all words
fn trie_from_string(str):
    var trie = trie_create()
    var lines = str.split("\n")
    var i = 0
    var len = lines.length()

    while i < len:
        var line = lines[i].trim()
        if line.length() > 0:
            trie_insert(trie, line)
        i = i + 1

    trie
