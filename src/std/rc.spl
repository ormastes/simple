# Reference Counting - Rc<T> and Arc<T>
#
# Smart pointers with automatic reference counting for shared ownership.
# Provides deterministic deallocation (unlike GC) with reference tracking.
#
# Implementation: Functional approach using dicts with closures
# (Classes don't export properly across modules in current Simple)
#
# Types:
# - Rc<T>: Single-threaded reference counting (fast)
# - Arc<T>: Atomic reference counting (thread-safe)
# - Weak<T>: Weak references (don't prevent deallocation)
#
# Usage:
#   val rc = Rc.new(obj)
#   val clone = rc.clone()  // Increment refcount
#   // When all Rc dropped, object deallocated
#
# Arc for thread-safe sharing:
#   val arc = Arc.new(obj)
#   // Safe to share across threads

use std.atomic.*
use std.allocator.*

# ============================================================================
# FFI Functions (Rc/Arc Box Management)
# ============================================================================

# Rc box operations (non-atomic)
extern fn rc_box_size() -> usize
extern fn rc_box_init(ptr: i64, value: i64, strong: usize, weak: usize)
extern fn rc_box_get_value(ptr: i64) -> i64
extern fn rc_box_drop_value(ptr: i64)
extern fn rc_box_strong_count(ptr: i64) -> usize
extern fn rc_box_weak_count(ptr: i64) -> usize
extern fn rc_box_inc_strong(ptr: i64)
extern fn rc_box_dec_strong(ptr: i64) -> usize
extern fn rc_box_inc_weak(ptr: i64)
extern fn rc_box_dec_weak(ptr: i64) -> usize

# Arc box operations (atomic)
extern fn arc_box_size() -> usize
extern fn arc_box_init(ptr: i64, value: i64, strong: usize, weak: usize)
extern fn arc_box_get_value(ptr: i64) -> i64
extern fn arc_box_drop_value(ptr: i64)
extern fn arc_box_strong_count(ptr: i64) -> usize
extern fn arc_box_weak_count(ptr: i64) -> usize
extern fn arc_box_inc_strong(ptr: i64)
extern fn arc_box_dec_strong(ptr: i64) -> usize
extern fn arc_box_inc_weak(ptr: i64)
extern fn arc_box_dec_weak(ptr: i64) -> usize

# System allocator (from allocator module)
extern fn sys_malloc(size: usize, align: usize) -> i64
extern fn sys_free(ptr: i64, size: usize, align: usize)

# ============================================================================
# Rc Namespace - Single-Threaded Reference Counting
# ============================================================================

val Rc = {
    new: fn(value):
        """Create new Rc with value.

        Args:
            value: Value to store (moved into Rc)

        Returns:
            Rc object owning the value
        """
        # Allocate RcBox
        val box_size = rc_box_size()
        val ptr = sys_malloc(box_size, 8)

        # Initialize RcBox
        rc_box_init(ptr, value, 1, 0)

        # Return Rc object with methods
        {
            __rc_ptr: ptr,
            __rc_type: "Rc",

            clone: fn():
                """Clone Rc, incrementing reference count."""
                rc_box_inc_strong(ptr)
                {
                    __rc_ptr: ptr,
                    __rc_type: "Rc",
                    clone: self.clone,
                    borrow: self.borrow,
                    strong_count: self.strong_count,
                    weak_count: self.weak_count,
                    downgrade: self.downgrade,
                    drop: self.drop
                },

            borrow: fn():
                """Borrow value immutably."""
                rc_box_get_value(ptr),

            strong_count: fn():
                """Get strong reference count."""
                rc_box_strong_count(ptr),

            weak_count: fn():
                """Get weak reference count."""
                rc_box_weak_count(ptr),

            downgrade: fn():
                """Create weak reference."""
                rc_box_inc_weak(ptr)
                Weak._from_ptr(ptr, "Rc"),

            drop: fn():
                """Drop Rc, decrementing reference count."""
                val count = rc_box_dec_strong(ptr)

                if count == 0:
                    # Last strong reference - deallocate data
                    rc_box_drop_value(ptr)

                    # Check weak count
                    val weak = rc_box_weak_count(ptr)
                    if weak == 0:
                        # No weak references - free box
                        sys_free(ptr, box_size, 8)
        }
}

# ============================================================================
# Arc Namespace - Atomic Reference Counting
# ============================================================================

val Arc = {
    new: fn(value):
        """Create new Arc with value.

        Args:
            value: Value to store (moved into Arc)

        Returns:
            Arc object owning the value
        """
        # Allocate ArcBox
        val box_size = arc_box_size()
        val ptr = sys_malloc(box_size, 8)

        # Initialize ArcBox
        arc_box_init(ptr, value, 1, 0)

        # Return Arc object with methods
        {
            __arc_ptr: ptr,
            __arc_type: "Arc",

            clone: fn():
                """Clone Arc, atomically incrementing reference count."""
                arc_box_inc_strong(ptr)
                {
                    __arc_ptr: ptr,
                    __arc_type: "Arc",
                    clone: self.clone,
                    borrow: self.borrow,
                    strong_count: self.strong_count,
                    weak_count: self.weak_count,
                    downgrade: self.downgrade,
                    drop: self.drop
                },

            borrow: fn():
                """Borrow value immutably."""
                arc_box_get_value(ptr),

            strong_count: fn():
                """Get strong reference count (atomic read)."""
                arc_box_strong_count(ptr),

            weak_count: fn():
                """Get weak reference count (atomic read)."""
                arc_box_weak_count(ptr),

            downgrade: fn():
                """Create weak reference (thread-safe)."""
                arc_box_inc_weak(ptr)
                Weak._from_ptr(ptr, "Arc"),

            drop: fn():
                """Drop Arc, atomically decrementing reference count."""
                val count = arc_box_dec_strong(ptr)

                if count == 1:  # Was last reference (count before decrement)
                    # Last strong reference - deallocate data
                    arc_box_drop_value(ptr)

                    # Check weak count
                    val weak = arc_box_weak_count(ptr)
                    if weak == 0:
                        # No weak references - free box
                        sys_free(ptr, box_size, 8)
        }
}

# ============================================================================
# Weak Namespace - Weak References
# ============================================================================

val Weak = {
    _from_ptr: fn(ptr, rc_type):
        """Internal: Create Weak from pointer.

        Args:
            ptr: Pointer to RcBox/ArcBox
            rc_type: "Rc" or "Arc"

        Returns:
            Weak object
        """
        {
            __weak_ptr: ptr,
            __weak_type: rc_type,

            upgrade: fn():
                """Try to upgrade to Rc/Arc.

                Returns:
                    Some(Rc/Arc) if data still alive, None if deallocated
                """
                # Check strong count
                val strong = if rc_type == "Rc":
                    rc_box_strong_count(ptr)
                else:
                    arc_box_strong_count(ptr)

                if strong == 0:
                    # Data already deallocated
                    return nil

                # Increment strong count
                if rc_type == "Rc":
                    rc_box_inc_strong(ptr)
                    Some({
                        __rc_ptr: ptr,
                        __rc_type: "Rc",
                        clone: Rc.new(0).clone,  # FIXME: Need proper closure capture
                        borrow: Rc.new(0).borrow,
                        strong_count: Rc.new(0).strong_count,
                        weak_count: Rc.new(0).weak_count,
                        downgrade: Rc.new(0).downgrade,
                        drop: Rc.new(0).drop
                    })
                else:
                    arc_box_inc_strong(ptr)
                    Some({
                        __arc_ptr: ptr,
                        __arc_type: "Arc",
                        clone: Arc.new(0).clone,
                        borrow: Arc.new(0).borrow,
                        strong_count: Arc.new(0).strong_count,
                        weak_count: Arc.new(0).weak_count,
                        downgrade: Arc.new(0).downgrade,
                        drop: Arc.new(0).drop
                    }),

            strong_count: fn():
                """Get strong reference count."""
                if rc_type == "Rc":
                    rc_box_strong_count(ptr)
                else:
                    arc_box_strong_count(ptr),

            weak_count: fn():
                """Get weak reference count."""
                if rc_type == "Rc":
                    rc_box_weak_count(ptr)
                else:
                    arc_box_weak_count(ptr),

            drop: fn():
                """Drop weak reference."""
                val count = if rc_type == "Rc":
                    rc_box_dec_weak(ptr)
                else:
                    arc_box_dec_weak(ptr)

                if count == 0:
                    # Last weak reference
                    val strong = if rc_type == "Rc":
                        rc_box_strong_count(ptr)
                    else:
                        arc_box_strong_count(ptr)

                    if strong == 0:
                        # No strong references either - free box
                        val box_size = if rc_type == "Rc":
                            rc_box_size()
                        else:
                            arc_box_size()
                        sys_free(ptr, box_size, 8)
        }
}

# ============================================================================
# Utility Functions
# ============================================================================

fn make_rc(value):
    """Convenience function to create Rc.

    Args:
        value: Value to wrap in Rc

    Returns:
        Rc owning value
    """
    Rc.new(value)

fn make_arc(value):
    """Convenience function to create Arc.

    Args:
        value: Value to wrap in Arc

    Returns:
        Arc owning value
    """
    Arc.new(value)

# ============================================================================
# Exports
# ============================================================================

export Rc
export Arc
export Weak
export make_rc
export make_arc
