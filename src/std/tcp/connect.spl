# TCP Connection Management
#
# Functions for managing connection lifecycle

import "types" as Types

# Complete connection (SYN_SENT -> ESTABLISHED)
fn tcp_complete_connect(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val state = Types.tcp_connection_get_state(conn)
    val is_syn_sent = state == Types.TCP_STATE_SYN_SENT
    if is_syn_sent:
        Types.tcp_connection_set_state(conn, Types.TCP_STATE_ESTABLISHED)
    else:
        conn

# Close connection gracefully
fn tcp_close(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val state = Types.tcp_connection_get_state(conn)
    val is_established = state == Types.TCP_STATE_ESTABLISHED
    if is_established:
        Types.tcp_connection_set_state(conn, Types.TCP_STATE_FIN_WAIT_1)
    else:
        val is_close_wait = state == Types.TCP_STATE_CLOSE_WAIT
        if is_close_wait:
            Types.tcp_connection_set_state(conn, Types.TCP_STATE_LAST_ACK)
        else:
            Types.tcp_connection_set_state(conn, Types.TCP_STATE_CLOSED)

# Abort connection immediately
fn tcp_abort(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    Types.tcp_connection_set_state(conn, Types.TCP_STATE_CLOSED)

# Create timeout configuration
fn tcp_timeout_create(connect: i64, read: i64, write: i64) -> (i64, i64, i64):
    (connect, read, write)

# Get connect timeout
fn tcp_timeout_get_connect(config: (i64, i64, i64)) -> i64:
    val timeout = config.0
    timeout

# Get read timeout
fn tcp_timeout_get_read(config: (i64, i64, i64)) -> i64:
    val timeout = config.1
    timeout

# Get write timeout
fn tcp_timeout_get_write(config: (i64, i64, i64)) -> i64:
    val timeout = config.2
    timeout

# Set connect timeout
fn tcp_timeout_set_connect(config: (i64, i64, i64), timeout: i64) -> (i64, i64, i64):
    val read = config.1
    val write = config.2
    (timeout, read, write)

# Set read timeout
fn tcp_timeout_set_read(config: (i64, i64, i64), timeout: i64) -> (i64, i64, i64):
    val connect = config.0
    val write = config.2
    (connect, timeout, write)

# Set write timeout
fn tcp_timeout_set_write(config: (i64, i64, i64), timeout: i64) -> (i64, i64, i64):
    val connect = config.0
    val read = config.1
    (connect, read, timeout)

# Create default timeout configuration
fn tcp_timeout_default() -> (i64, i64, i64):
    tcp_timeout_create(Types.TCP_DEFAULT_CONNECT_TIMEOUT, Types.TCP_DEFAULT_READ_TIMEOUT, Types.TCP_DEFAULT_WRITE_TIMEOUT)

# Check if elapsed time exceeds timeout
fn tcp_timeout_exceeded(start_time: i64, current_time: i64, timeout: i64) -> bool:
    val elapsed = current_time - start_time
    elapsed > timeout

# Calculate remaining timeout
fn tcp_timeout_remaining(start_time: i64, current_time: i64, timeout: i64) -> i64:
    val elapsed = current_time - start_time
    val remaining = timeout - elapsed
    if remaining > 0:
        remaining
    else:
        0

# Create connection pool
fn tcp_pool_create(max_size: i64) -> (i64, list, i64):
    val empty_conns = []
    val timestamp = 0
    (max_size, empty_conns, timestamp)

# Get pool max size
fn tcp_pool_get_max_size(pool: (i64, list, i64)) -> i64:
    val size = pool.0
    size

# Get pool connections
fn tcp_pool_get_connections(pool: (i64, list, i64)) -> list:
    val conns = pool.1
    conns

# Get pool current size
fn tcp_pool_get_size(pool: (i64, list, i64)) -> i64:
    val conns = tcp_pool_get_connections(pool)
    conns.len()

# Check if pool is full
fn tcp_pool_is_full(pool: (i64, list, i64)) -> bool:
    val current = tcp_pool_get_size(pool)
    val max_size = tcp_pool_get_max_size(pool)
    current >= max_size

# Check if pool is empty
fn tcp_pool_is_empty(pool: (i64, list, i64)) -> bool:
    val size = tcp_pool_get_size(pool)
    size == 0

# Add connection to pool
fn tcp_pool_add(pool: (i64, list, i64), conn: (text, i64, i64, text, text, list, i64)) -> (i64, list, i64):
    val is_full = tcp_pool_is_full(pool)
    if is_full:
        pool
    else:
        val max_size = pool.0
        val conns = pool.1
        val timestamp = pool.2
        val new_conns = conns.append(conn)
        (max_size, new_conns, timestamp)

# Remove connection from pool by index
fn tcp_pool_remove(pool: (i64, list, i64), index: i64) -> (i64, list, i64):
    val conns = tcp_pool_get_connections(pool)
    val len = conns.len()
    if index >= len:
        pool
    else:
        val max_size = pool.0
        val timestamp = pool.2
        val new_conns = tcp_pool_remove_at(conns, index, [], 0)
        (max_size, new_conns, timestamp)

# Helper to remove connection at index
fn tcp_pool_remove_at(conns: list, target: i64, result: list, index: i64) -> list:
    val len = conns.len()
    if index >= len:
        result
    else:
        val is_target = index == target
        if is_target:
            val next = index + 1
            tcp_pool_remove_at(conns, target, result, next)
        else:
            val conn = conns.get(index)
            val new_result = result.append(conn)
            val next = index + 1
            tcp_pool_remove_at(conns, target, new_result, next)

# Get connection from pool
fn tcp_pool_get(pool: (i64, list, i64), address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val conns = tcp_pool_get_connections(pool)
    tcp_pool_find_connection(conns, address, port, 0)

# Helper to find matching connection
fn tcp_pool_find_connection(conns: list, address: text, port: i64, index: i64) -> (text, i64, i64, text, text, list, i64):
    val len = conns.len()
    if index >= len:
        Types.tcp_connection_create("", 0)
    else:
        val conn = conns.get(index)
        val conn_tuple = Types.tcp_connection_create("", 0)
        val conn_addr = Types.tcp_connection_get_address(conn_tuple)
        val addr_match = conn_addr == address
        if addr_match:
            val conn_port = Types.tcp_connection_get_port(conn_tuple)
            val port_match = conn_port == port
            if port_match:
                conn_tuple
            else:
                val next = index + 1
                tcp_pool_find_connection(conns, address, port, next)
        else:
            val next = index + 1
            tcp_pool_find_connection(conns, address, port, next)

# Clear all connections from pool
fn tcp_pool_clear(pool: (i64, list, i64)) -> (i64, list, i64):
    val max_size = tcp_pool_get_max_size(pool)
    val timestamp = pool.2
    val empty = []
    (max_size, empty, timestamp)

export tcp_complete_connect
export tcp_close
export tcp_abort
export tcp_timeout_create
export tcp_timeout_get_connect
export tcp_timeout_get_read
export tcp_timeout_get_write
export tcp_timeout_set_connect
export tcp_timeout_set_read
export tcp_timeout_set_write
export tcp_timeout_default
export tcp_timeout_exceeded
export tcp_timeout_remaining
export tcp_pool_create
export tcp_pool_get_max_size
export tcp_pool_get_connections
export tcp_pool_get_size
export tcp_pool_is_full
export tcp_pool_is_empty
export tcp_pool_add
export tcp_pool_remove
export tcp_pool_get
export tcp_pool_clear
