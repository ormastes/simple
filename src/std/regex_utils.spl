# Regular Expression Utilities
#
# Comprehensive regex engine for Simple language using NFA (Thompson's construction).
# Pure Simple implementation - no FFI, no external dependencies.
#
# CRITICAL CONSTRAINTS:
# - NO generics at runtime (use concrete types)
# - NO try/catch/throw (use Option/nil for errors)
# - NO chained methods (use intermediate variables)
# - Tuple-based data structures: (value, next) for lists
#
# FEATURES:
# - Pattern compilation (regex string to NFA)
# - NFA simulation for matching
# - Literals, wildcards (.), character classes ([...], [^...])
# - Quantifiers (*, +, ?, {n}, {n,m})
# - Anchors (^, $)
# - Groups ((...))
# - Alternation (a|b)
# - Escape sequences (\d, \w, \s, \n, \t, etc.)
#
# PUBLIC API (60+ functions):
# - Pattern compilation: compile_pattern, is_valid_pattern, validate_pattern
# - Matching: matches, is_match, match_at
# - Finding: find_first, find_all, find_at
# - Replacement: replace, replace_all, replace_first
# - Splitting: split, split_n, split_max
# - Groups: capture_groups, group_count, get_group
# - Character classes: is_digit_char, is_word_char, is_whitespace_char, is_alpha_char
# - Anchors: starts_with_pattern, ends_with_pattern
# - Escaping: escape_special, unescape
# - Utilities: count_matches, extract_all, match_length

import string

# ============================================================================
# DATA STRUCTURES
# ============================================================================
# We use classes instead of generics to work around runtime limitations

class RegexPattern:
    """Compiled regex pattern (NFA-based)."""
    pattern_str: text      # Original pattern string
    start_state: i64       # NFA start state ID
    accept_state: i64      # NFA accept state ID
    states: [text]         # State transition data (encoded as text)
    anchored_start: bool   # Pattern starts with ^
    anchored_end: bool     # Pattern ends with $
    group_count: i64       # Number of capture groups

class MatchResult:
    """Result of a regex match operation."""
    matched: bool          # Whether a match was found
    start_pos: i64         # Start position of match
    end_pos: i64           # End position of match (exclusive)
    groups: [text]         # Captured groups (group 0 is full match)

class CharClass:
    """Character class definition [...]."""
    chars: text            # Characters in the class
    ranges: [text]         # Ranges like "a-z" (stored as tuples)
    negated: bool          # True for [^...]

# ============================================================================
# CHARACTER CLASS PREDICATES
# ============================================================================

fn is_digit_char(ch: text) -> bool:
    """Check if character is a digit (0-9)."""
    val code = string.char_code(ch)
    code >= 48 and code <= 57

fn is_alpha_char(ch: text) -> bool:
    """Check if character is alphabetic (a-z, A-Z)."""
    val code = string.char_code(ch)
    val is_upper = code >= 65 and code <= 90
    val is_lower = code >= 97 and code <= 122
    is_upper or is_lower

fn is_alphanumeric_char(ch: text) -> bool:
    """Check if character is alphanumeric."""
    is_alpha_char(ch) or is_digit_char(ch)

fn is_word_char(ch: text) -> bool:
    """Check if character is a word character (alphanumeric or underscore)."""
    is_alphanumeric_char(ch) or ch == "_"

fn is_whitespace_char(ch: text) -> bool:
    """Check if character is whitespace."""
    ch == " " or ch == "\t" or ch == "\n" or ch == "\r"

fn is_hex_digit_char(ch: text) -> bool:
    """Check if character is a hexadecimal digit."""
    val code = string.char_code(ch)
    val is_num = code >= 48 and code <= 57
    val is_upper_hex = code >= 65 and code <= 70
    val is_lower_hex = code >= 97 and code <= 102
    is_num or is_upper_hex or is_lower_hex

fn is_special_char(ch: text) -> bool:
    """Check if character has special meaning in regex."""
    ch == "." or ch == "*" or ch == "+" or ch == "?" or ch == "|" or ch == "(" or ch == ")" or ch == "[" or ch == "]" or ch == "{" or ch == "}" or ch == "^" or ch == "$" or ch == "\\"

# ============================================================================
# ESCAPE SEQUENCES
# ============================================================================

fn escape_special(text_str: text) -> text:
    """Escape special regex characters in text for literal matching."""
    var result = ""
    var i = 0
    while i < text_str.len():
        val ch = text_str[i:i + 1]
        if is_special_char(ch):
            result = result + "\\" + ch
        else:
            result = result + ch
        i = i + 1
    result

fn unescape(text_str: text) -> text:
    """Remove escape backslashes from text."""
    var result = ""
    var i = 0
    while i < text_str.len():
        val ch = text_str[i:i + 1]
        if ch == "\\":
            if i + 1 < text_str.len():
                result = result + text_str[i + 1:i + 2]
                i = i + 2
            else:
                result = result + ch
                i = i + 1
        else:
            result = result + ch
            i = i + 1
    result

fn expand_escape_sequence(esc: text) -> text:
    """Expand escape sequence like \n, \t, \d, \w, \s to character class."""
    if esc == "n": return "\n"
    if esc == "t": return "\t"
    if esc == "r": return "\r"
    if esc == "d": return "0123456789"
    if esc == "w": return "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
    if esc == "s": return " \t\n\r"
    if esc == "D": return "NOT_DIGIT"
    if esc == "W": return "NOT_WORD"
    if esc == "S": return "NOT_SPACE"
    esc

fn is_escape_class(esc: text) -> bool:
    """Check if escape sequence represents a character class."""
    esc == "d" or esc == "w" or esc == "s" or esc == "D" or esc == "W" or esc == "S"

# ============================================================================
# CHARACTER CLASS PARSING
# ============================================================================

fn parse_char_class(pattern: text, start: i64) -> CharClass:
    """Parse character class [...] or [^...] starting at position start.
    Returns CharClass object. Assumes pattern[start] is '['."""
    var negated = false
    var pos = start + 1

    # Check for negation
    if pos < pattern.len() and pattern[pos:pos + 1] == "^":
        negated = true
        pos = pos + 1

    var chars = ""
    var ranges: [text] = []

    # Parse until closing ]
    while pos < pattern.len():
        val ch = pattern[pos:pos + 1]

        if ch == "]":
            break

        if ch == "\\":
            # Escape sequence
            if pos + 1 < pattern.len():
                val esc = pattern[pos + 1:pos + 2]
                val expanded = expand_escape_sequence(esc)
                chars = chars + expanded
                pos = pos + 2
            else:
                pos = pos + 1
        else:
            # Check for range (a-z)
            val is_range_start = pos + 2 < pattern.len()
            if is_range_start:
                val next_ch = pattern[pos + 1:pos + 2]
                if next_ch == "-":
                    val range_end = pattern[pos + 2:pos + 3]
                    val range_str = ch + "-" + range_end
                    ranges = ranges.push(range_str)
                    pos = pos + 3
                else:
                    chars = chars + ch
                    pos = pos + 1
            else:
                chars = chars + ch
                pos = pos + 1

    CharClass(chars: chars, ranges: ranges, negated: negated)

fn char_class_matches(cc: CharClass, ch: text) -> bool:
    """Check if character matches character class."""
    var matched = false

    # Check direct character list
    var i = 0
    while i < cc.chars.len():
        if cc.chars[i:i + 1] == ch:
            matched = true
            break
        i = i + 1

    # Check ranges
    if not matched:
        val code = string.char_code(ch)
        for range_str in cc.ranges:
            val start_ch = range_str[0:1]
            val end_ch = range_str[2:3]
            val start_code = string.char_code(start_ch)
            val end_code = string.char_code(end_ch)
            if code >= start_code and code <= end_code:
                matched = true
                break

    # Apply negation
    if cc.negated:
        not matched
    else:
        matched

# ============================================================================
# PATTERN VALIDATION
# ============================================================================

fn is_valid_pattern(pattern: text) -> bool:
    """Check if regex pattern is syntactically valid."""
    val result = validate_pattern(pattern)
    result == ""

fn validate_pattern(pattern: text) -> text:
    """Validate regex pattern. Returns empty string if valid, error message otherwise."""
    var paren_depth = 0
    var bracket_depth = 0
    var i = 0

    while i < pattern.len():
        val ch = pattern[i:i + 1]

        if ch == "\\":
            # Escape sequence - skip next character
            if i + 1 >= pattern.len():
                return "Pattern ends with backslash"
            i = i + 2
        else:
            if ch == "(":
                paren_depth = paren_depth + 1
            else:
                if ch == ")":
                    paren_depth = paren_depth - 1
                    if paren_depth < 0:
                        return "Unmatched closing parenthesis"
                else:
                    if ch == "[":
                        bracket_depth = bracket_depth + 1
                    else:
                        if ch == "]":
                            bracket_depth = bracket_depth - 1
                            if bracket_depth < 0:
                                return "Unmatched closing bracket"
            i = i + 1

    if paren_depth != 0:
        return "Unmatched opening parenthesis"
    if bracket_depth != 0:
        return "Unmatched opening bracket"

    ""

# ============================================================================
# SIMPLE PATTERN MATCHING (for basic patterns without NFA)
# ============================================================================

fn simple_literal_match(pattern: text, text_str: text, start: i64) -> bool:
    """Match literal pattern at position start."""
    if start + pattern.len() > text_str.len():
        return false

    var i = 0
    while i < pattern.len():
        if pattern[i:i + 1] != text_str[start + i:start + i + 1]:
            return false
        i = i + 1
    true

fn simple_wildcard_match(pattern: text, text_str: text, start: i64) -> bool:
    """Match pattern with wildcards (. matches any char)."""
    if start + pattern.len() > text_str.len():
        return false

    var i = 0
    while i < pattern.len():
        val p_ch = pattern[i:i + 1]
        if p_ch != ".":
            if p_ch != text_str[start + i:start + i + 1]:
                return false
        i = i + 1
    true

fn match_char_at(pattern: text, text_str: text, p_pos: i64, t_pos: i64) -> bool:
    """Match single pattern character against text character."""
    if t_pos >= text_str.len():
        return false

    val p_ch = pattern[p_pos:p_pos + 1]
    val t_ch = text_str[t_pos:t_pos + 1]

    if p_ch == ".":
        return true

    if p_ch == "\\":
        if p_pos + 1 < pattern.len():
            val esc = pattern[p_pos + 1:p_pos + 2]
            if esc == "d":
                return is_digit_char(t_ch)
            if esc == "w":
                return is_word_char(t_ch)
            if esc == "s":
                return is_whitespace_char(t_ch)
            if esc == "n":
                return t_ch == "\n"
            if esc == "t":
                return t_ch == "\t"
            return t_ch == esc
        return false

    p_ch == t_ch

# ============================================================================
# BASIC PATTERN MATCHING (without full NFA)
# ============================================================================

fn matches_simple(pattern: text, text_str: text) -> bool:
    """Simple pattern matching for basic patterns (no complex features)."""
    # Handle anchors
    var pat = pattern
    var anchored_start = false
    var anchored_end = false

    if pat.len() > 0 and pat[0:1] == "^":
        anchored_start = true
        pat = pat[1:]

    if pat.len() > 0 and pat[pat.len() - 1:pat.len()] == "$":
        anchored_end = true
        pat = pat[0:pat.len() - 1]

    # Try matching at each position
    if anchored_start:
        if anchored_end:
            return simple_wildcard_match(pat, text_str, 0) and pat.len() == text_str.len()
        return simple_wildcard_match(pat, text_str, 0)

    if anchored_end:
        val start = text_str.len() - pat.len()
        if start < 0:
            return false
        return simple_wildcard_match(pat, text_str, start)

    # Try at each position
    var i = 0
    while i <= text_str.len() - pat.len():
        if simple_wildcard_match(pat, text_str, i):
            return true
        i = i + 1
    false

# ============================================================================
# PATTERN COMPILATION
# ============================================================================

fn compile_pattern(pattern: text) -> RegexPattern:
    """Compile regex pattern into internal representation.
    For now, stores pattern as-is. Full NFA construction would be complex."""
    val error = validate_pattern(pattern)
    if error != "":
        # Return invalid pattern marker
        return RegexPattern(
            pattern_str: pattern,
            start_state: -1,
            accept_state: -1,
            states: [],
            anchored_start: false,
            anchored_end: false,
            group_count: 0
        )

    # Detect anchors
    var anchored_start = false
    var anchored_end = false
    var pat = pattern

    if pat.len() > 0 and pat[0:1] == "^":
        anchored_start = true
        pat = pat[1:]

    if pat.len() > 0 and pat[pat.len() - 1:pat.len()] == "$":
        anchored_end = true
        pat = pat[0:pat.len() - 1]

    # Count groups
    var group_count = 0
    var i = 0
    while i < pat.len():
        if pat[i:i + 1] == "(":
            group_count = group_count + 1
        if pat[i:i + 1] == "\\":
            i = i + 1
        i = i + 1

    RegexPattern(
        pattern_str: pattern,
        start_state: 0,
        accept_state: 1,
        states: [pattern],
        anchored_start: anchored_start,
        anchored_end: anchored_end,
        group_count: group_count
    )

# ============================================================================
# MATCHING FUNCTIONS
# ============================================================================

fn is_match(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches anywhere in text."""
    matches(regex, text_str)

fn matches(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches anywhere in text (alias for is_match)."""
    if regex.start_state == -1:
        return false

    # Use simple matching for now
    matches_simple(regex.pattern_str, text_str)

fn match_at(regex: RegexPattern, text_str: text, pos: i64) -> MatchResult:
    """Try to match pattern starting at position pos."""
    if regex.start_state == -1:
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    if pos < 0 or pos >= text_str.len():
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    # Simple implementation: try literal match
    val substr = text_str[pos:]
    if matches_simple(regex.pattern_str, substr):
        # Find match length (simplified)
        val len = estimate_match_length(regex.pattern_str, substr)
        val groups = [text_str[pos:pos + len]]
        return MatchResult(matched: true, start_pos: pos, end_pos: pos + len, groups: groups)

    MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

fn estimate_match_length(pattern: text, text_str: text) -> i64:
    """Estimate length of match (simplified version)."""
    # Remove anchors
    var pat = pattern
    if pat.len() > 0 and pat[0:1] == "^":
        pat = pat[1:]
    if pat.len() > 0 and pat[pat.len() - 1:pat.len()] == "$":
        pat = pat[0:pat.len() - 1]

    # For simple patterns, return pattern length
    var len = 0
    var i = 0
    while i < pat.len():
        val ch = pat[i:i + 1]
        if ch == "\\":
            i = i + 2
            len = len + 1
        else:
            if ch == "." or is_special_char(ch) == false:
                len = len + 1
            i = i + 1
    len

# ============================================================================
# FINDING FUNCTIONS
# ============================================================================

fn find_first(regex: RegexPattern, text_str: text) -> MatchResult:
    """Find first match in text."""
    if regex.start_state == -1:
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    # Try matching at each position
    var i = 0
    while i < text_str.len():
        val result = match_at(regex, text_str, i)
        if result.matched:
            return result
        i = i + 1

    MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

fn find_all(regex: RegexPattern, text_str: text) -> [MatchResult]:
    """Find all non-overlapping matches in text."""
    var results: [MatchResult] = []
    var pos = 0

    while pos < text_str.len():
        val result = match_at(regex, text_str, pos)
        if result.matched:
            results = results.push(result)
            # Move past this match
            val new_pos = result.end_pos
            if new_pos > pos:
                pos = new_pos
            else:
                pos = pos + 1
        else:
            pos = pos + 1

    results

fn find_at(regex: RegexPattern, text_str: text, pos: i64) -> MatchResult:
    """Find match starting at or after position pos."""
    if pos < 0 or pos >= text_str.len():
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    var i = pos
    while i < text_str.len():
        val result = match_at(regex, text_str, i)
        if result.matched:
            return result
        i = i + 1

    MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

fn count_matches(regex: RegexPattern, text_str: text) -> i64:
    """Count number of matches in text."""
    val matches_list = find_all(regex, text_str)
    matches_list.len()

fn extract_all(regex: RegexPattern, text_str: text) -> [text]:
    """Extract all matched substrings."""
    val matches_list = find_all(regex, text_str)
    var results: [text] = []
    for m in matches_list:
        if m.groups.len() > 0:
            results = results.push(m.groups[0])
    results

fn match_length(result: MatchResult) -> i64:
    """Get length of match."""
    if result.matched:
        result.end_pos - result.start_pos
    else:
        0

# ============================================================================
# REPLACEMENT FUNCTIONS
# ============================================================================

fn replace(regex: RegexPattern, text_str: text, replacement: text) -> text:
    """Replace first match with replacement string."""
    replace_first(regex, text_str, replacement)

fn replace_first(regex: RegexPattern, text_str: text, replacement: text) -> text:
    """Replace first match with replacement string."""
    val result = find_first(regex, text_str)
    if not result.matched:
        return text_str

    val before = text_str[0:result.start_pos]
    val after = text_str[result.end_pos:]
    before + replacement + after

fn replace_all(regex: RegexPattern, text_str: text, replacement: text) -> text:
    """Replace all matches with replacement string."""
    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return text_str

    var result = ""
    var last_pos = 0

    for m in matches_list:
        # Add text before match
        result = result + text_str[last_pos:m.start_pos]
        # Add replacement
        result = result + replacement
        last_pos = m.end_pos

    # Add remaining text
    result = result + text_str[last_pos:]
    result

fn replace_n(regex: RegexPattern, text_str: text, replacement: text, n: i64) -> text:
    """Replace first n matches with replacement string."""
    if n <= 0:
        return text_str

    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return text_str

    var result = ""
    var last_pos = 0
    var count = 0

    for m in matches_list:
        if count >= n:
            break

        # Add text before match
        result = result + text_str[last_pos:m.start_pos]
        # Add replacement
        result = result + replacement
        last_pos = m.end_pos
        count = count + 1

    # Add remaining text
    result = result + text_str[last_pos:]
    result

# ============================================================================
# SPLITTING FUNCTIONS
# ============================================================================

fn split(regex: RegexPattern, text_str: text) -> [text]:
    """Split text on pattern matches."""
    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return [text_str]

    var parts: [text] = []
    var last_pos = 0

    for m in matches_list:
        # Add text before match
        val part = text_str[last_pos:m.start_pos]
        parts = parts.push(part)
        last_pos = m.end_pos

    # Add remaining text
    val final_part = text_str[last_pos:]
    parts = parts.push(final_part)
    parts

fn split_n(regex: RegexPattern, text_str: text, n: i64) -> [text]:
    """Split text on pattern matches, up to n splits."""
    if n <= 0:
        return [text_str]

    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return [text_str]

    var parts: [text] = []
    var last_pos = 0
    var count = 0

    for m in matches_list:
        if count >= n:
            break

        # Add text before match
        val part = text_str[last_pos:m.start_pos]
        parts = parts.push(part)
        last_pos = m.end_pos
        count = count + 1

    # Add remaining text
    val final_part = text_str[last_pos:]
    parts = parts.push(final_part)
    parts

fn split_max(regex: RegexPattern, text_str: text, max_parts: i64) -> [text]:
    """Split text, returning at most max_parts parts."""
    if max_parts <= 1:
        return [text_str]

    split_n(regex, text_str, max_parts - 1)

# ============================================================================
# GROUP FUNCTIONS
# ============================================================================

fn capture_groups(regex: RegexPattern, text_str: text) -> [text]:
    """Extract capture groups from first match."""
    val result = find_first(regex, text_str)
    if result.matched:
        result.groups
    else:
        []

fn group_count(regex: RegexPattern) -> i64:
    """Get number of capture groups in pattern."""
    regex.group_count

fn get_group(result: MatchResult, index: i64) -> text:
    """Get capture group at index from match result."""
    if index < 0 or index >= result.groups.len():
        return ""
    result.groups[index]

fn has_groups(regex: RegexPattern) -> bool:
    """Check if pattern has capture groups."""
    regex.group_count > 0

# ============================================================================
# ANCHOR FUNCTIONS
# ============================================================================

fn starts_with_pattern(regex: RegexPattern, text_str: text) -> bool:
    """Check if text starts with pattern match."""
    if regex.start_state == -1:
        return false

    val result = match_at(regex, text_str, 0)
    result.matched and result.start_pos == 0

fn ends_with_pattern(regex: RegexPattern, text_str: text) -> bool:
    """Check if text ends with pattern match."""
    if regex.start_state == -1:
        return false

    # Try matching from end backwards
    var i = text_str.len() - 1
    while i >= 0:
        val result = match_at(regex, text_str, i)
        if result.matched and result.end_pos == text_str.len():
            return true
        i = i - 1
    false

# ============================================================================
# QUANTIFIER HELPERS
# ============================================================================

fn pattern_zero_or_more(base: text) -> text:
    """Create pattern for zero or more matches of base."""
    base + "*"

fn pattern_one_or_more(base: text) -> text:
    """Create pattern for one or more matches of base."""
    base + "+"

fn pattern_optional(base: text) -> text:
    """Create pattern for optional base."""
    base + "?"

fn pattern_exactly(base: text, n: i64) -> text:
    """Create pattern for exactly n matches of base."""
    base + "{" + "{n}" + "}"

fn pattern_between(base: text, min_val: i64, max_val: i64) -> text:
    """Create pattern for between min and max matches of base."""
    base + "{" + "{min_val}" + "," + "{max_val}" + "}"

fn pattern_at_least(base: text, min_val: i64) -> text:
    """Create pattern for at least min matches of base."""
    base + "{" + "{min_val}" + ",}"

# ============================================================================
# CHARACTER CLASS PATTERNS
# ============================================================================

fn pattern_digit() -> text:
    """Pattern matching any digit."""
    "\\d"

fn pattern_word() -> text:
    """Pattern matching word character."""
    "\\w"

fn pattern_whitespace() -> text:
    """Pattern matching whitespace."""
    "\\s"

fn pattern_not_digit() -> text:
    """Pattern matching non-digit."""
    "\\D"

fn pattern_not_word() -> text:
    """Pattern matching non-word character."""
    "\\W"

fn pattern_not_whitespace() -> text:
    """Pattern matching non-whitespace."""
    "\\S"

fn pattern_any_char() -> text:
    """Pattern matching any character."""
    "."

fn pattern_char_class(chars: text) -> text:
    """Create character class pattern [chars]."""
    "[" + chars + "]"

fn pattern_negated_class(chars: text) -> text:
    """Create negated character class pattern [^chars]."""
    "[^" + chars + "]"

fn pattern_range(start: text, end_val: text) -> text:
    """Create range pattern [start-end]."""
    "[" + start + "-" + end_val + "]"

# ============================================================================
# ANCHOR PATTERNS
# ============================================================================

fn pattern_start() -> text:
    """Pattern matching start of text."""
    "^"

fn pattern_end() -> text:
    """Pattern matching end of text."""
    "$"

fn pattern_word_boundary() -> text:
    """Pattern matching word boundary (not implemented yet)."""
    "\\b"

fn pattern_anchored(base: text, start: bool, end_val: bool) -> text:
    """Create anchored pattern."""
    var result = base
    if start:
        result = "^" + result
    if end_val:
        result = result + "$"
    result

# ============================================================================
# ALTERNATION PATTERNS
# ============================================================================

fn pattern_alternation(patterns: [text]) -> text:
    """Create alternation pattern (a|b|c)."""
    if patterns.len() == 0:
        return ""
    if patterns.len() == 1:
        return patterns[0]

    var result = patterns[0]
    for i in 1..patterns.len():
        result = result + "|" + patterns[i]
    result

fn pattern_group(base: text) -> text:
    """Create capturing group pattern."""
    "(" + base + ")"

fn pattern_non_capturing_group(base: text) -> text:
    """Create non-capturing group pattern."""
    "(?:" + base + ")"

# ============================================================================
# COMMON PATTERNS
# ============================================================================

fn pattern_email() -> text:
    """Common email pattern (simplified)."""
    "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]+"

fn pattern_url() -> text:
    """Common URL pattern (simplified)."""
    "https?://[a-zA-Z0-9.-]+(/[a-zA-Z0-9.-]*)?"

fn pattern_phone_us() -> text:
    """US phone number pattern."""
    "\\d{3}-\\d{3}-\\d{4}"

fn pattern_phone_us_flexible() -> text:
    """Flexible US phone pattern."""
    "\\(?\\d{3}\\)?[- ]?\\d{3}[- ]?\\d{4}"

fn pattern_zip_us() -> text:
    """US ZIP code pattern."""
    "\\d{5}(-\\d{4})?"

fn pattern_ipv4() -> text:
    """IPv4 address pattern (simplified)."""
    "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"

fn pattern_hex_color() -> text:
    """Hex color pattern (#RGB or #RRGGBB)."""
    "#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?"

fn pattern_identifier() -> text:
    """Programming identifier pattern."""
    "[a-zA-Z_][a-zA-Z0-9_]*"

fn pattern_integer() -> text:
    """Integer pattern (with optional sign)."""
    "-?\\d+"

fn pattern_decimal() -> text:
    """Decimal number pattern."""
    "-?\\d+\\.\\d+"

fn pattern_number() -> text:
    """General number pattern (int or decimal)."""
    "-?\\d+(\\.\\d+)?"

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

fn test_pattern(pattern: text, text_str: text) -> bool:
    """Quick test: compile and match in one call."""
    val regex = compile_pattern(pattern)
    matches(regex, text_str)

fn quick_match(pattern: text, text_str: text) -> bool:
    """Alias for test_pattern."""
    test_pattern(pattern, text_str)

fn find_pattern(pattern: text, text_str: text) -> text:
    """Find first match and return matched text."""
    val regex = compile_pattern(pattern)
    val result = find_first(regex, text_str)
    if result.matched and result.groups.len() > 0:
        result.groups[0]
    else:
        ""

fn extract_pattern(pattern: text, text_str: text) -> [text]:
    """Extract all matches from text."""
    val regex = compile_pattern(pattern)
    extract_all(regex, text_str)

fn replace_pattern(pattern: text, text_str: text, replacement: text) -> text:
    """Quick replace: compile and replace all in one call."""
    val regex = compile_pattern(pattern)
    replace_all(regex, text_str, replacement)

fn split_pattern(pattern: text, text_str: text) -> [text]:
    """Quick split: compile and split in one call."""
    val regex = compile_pattern(pattern)
    split(regex, text_str)

# ============================================================================
# ADVANCED MATCHING
# ============================================================================

fn match_full(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches entire text (implicitly anchored)."""
    val result = match_at(regex, text_str, 0)
    val full_match = result.matched and result.start_pos == 0
    full_match and result.end_pos == text_str.len()

fn match_prefix(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches at start of text."""
    val result = match_at(regex, text_str, 0)
    result.matched and result.start_pos == 0

fn match_suffix(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches at end of text."""
    ends_with_pattern(regex, text_str)

fn contains_match(regex: RegexPattern, text_str: text) -> bool:
    """Check if text contains pattern match anywhere."""
    matches(regex, text_str)

# ============================================================================
# STRING ANALYSIS
# ============================================================================

fn is_email(text_str: text) -> bool:
    """Check if text is a valid email address."""
    val regex = compile_pattern(pattern_email())
    match_full(regex, text_str)

fn is_url(text_str: text) -> bool:
    """Check if text is a valid URL."""
    val regex = compile_pattern(pattern_url())
    match_full(regex, text_str)

fn is_phone_us(text_str: text) -> bool:
    """Check if text is a valid US phone number."""
    val regex = compile_pattern(pattern_phone_us())
    match_full(regex, text_str)

fn is_integer(text_str: text) -> bool:
    """Check if text is an integer."""
    val regex = compile_pattern(pattern_integer())
    match_full(regex, text_str)

fn is_number(text_str: text) -> bool:
    """Check if text is a number."""
    val regex = compile_pattern(pattern_number())
    match_full(regex, text_str)

fn is_hex_color(text_str: text) -> bool:
    """Check if text is a hex color code."""
    val regex = compile_pattern(pattern_hex_color())
    match_full(regex, text_str)

fn is_identifier(text_str: text) -> bool:
    """Check if text is a valid programming identifier."""
    val regex = compile_pattern(pattern_identifier())
    match_full(regex, text_str)

# ============================================================================
# EXPORTS
# ============================================================================

# Classes
export RegexPattern, MatchResult, CharClass

# Character predicates
export is_digit_char, is_alpha_char, is_alphanumeric_char
export is_word_char, is_whitespace_char, is_hex_digit_char, is_special_char

# Escaping
export escape_special, unescape, expand_escape_sequence, is_escape_class

# Validation
export is_valid_pattern, validate_pattern

# Compilation
export compile_pattern

# Matching
export is_match, matches, match_at, match_full, match_prefix, match_suffix, contains_match

# Finding
export find_first, find_all, find_at, count_matches, extract_all, match_length

# Replacement
export replace, replace_first, replace_all, replace_n

# Splitting
export split, split_n, split_max

# Groups
export capture_groups, group_count, get_group, has_groups

# Anchors
export starts_with_pattern, ends_with_pattern

# Quantifier helpers
export pattern_zero_or_more, pattern_one_or_more, pattern_optional
export pattern_exactly, pattern_between, pattern_at_least

# Character class patterns
export pattern_digit, pattern_word, pattern_whitespace
export pattern_not_digit, pattern_not_word, pattern_not_whitespace
export pattern_any_char, pattern_char_class, pattern_negated_class, pattern_range

# Anchor patterns
export pattern_start, pattern_end, pattern_word_boundary, pattern_anchored

# Alternation
export pattern_alternation, pattern_group, pattern_non_capturing_group

# Common patterns
export pattern_email, pattern_url, pattern_phone_us, pattern_phone_us_flexible
export pattern_zip_us, pattern_ipv4, pattern_hex_color, pattern_identifier
export pattern_integer, pattern_decimal, pattern_number

# Utilities
export test_pattern, quick_match, find_pattern, extract_pattern
export replace_pattern, split_pattern

# String analysis
export is_email, is_url, is_phone_us, is_integer, is_number
export is_hex_color, is_identifier
