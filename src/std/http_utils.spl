# HTTP Protocol Utilities Module
#
# Provides comprehensive HTTP/1.1 protocol handling including:
# - Request parsing and building
# - Response parsing and building
# - Header manipulation
# - URL encoding/decoding
# - Query string handling
# - Cookie parsing
# - Multipart form data
# - Chunked transfer encoding
# - Status code utilities
# - Authentication helpers
#
# All implementations are pure Simple with no FFI dependencies.
# Uses tuple-based data structures to avoid generic type issues at runtime.
#
# This module uses the facade pattern to organize HTTP functionality into
# logical categories while maintaining a unified public interface.

import types from "std/http/types"
import request from "std/http/request"
import response from "std/http/response"
import headers from "std/http/headers"
import url from "std/http/url"
import cookie from "std/http/cookie"
import utilities from "std/http/utilities"

# ============================================================================
# Types Module - Status codes and content type utilities
# ============================================================================

# Status code utilities
fn status_text(code: i64) -> text:
    return types.status_text(code)

fn is_success(code: i64) -> bool:
    return types.is_success(code)

fn is_redirect(code: i64) -> bool:
    return types.is_redirect(code)

fn is_client_error(code: i64) -> bool:
    return types.is_client_error(code)

fn is_server_error(code: i64) -> bool:
    return types.is_server_error(code)

fn is_error(code: i64) -> bool:
    return types.is_error(code)

fn is_informational(code: i64) -> bool:
    return types.is_informational(code)

# HTTP method utilities
fn is_safe_method(method: text) -> bool:
    return types.is_safe_method(method)

fn is_idempotent(method: text) -> bool:
    return types.is_idempotent(method)

fn has_request_body(method: text) -> bool:
    return types.has_request_body(method)

fn is_valid_method(method: text) -> bool:
    return types.is_valid_method(method)

# Content type utilities
fn parse_content_type(header: text) -> tuple:
    return types.parse_content_type(header)

fn is_json(content_type: text) -> bool:
    return types.is_json(content_type)

fn is_html(content_type: text) -> bool:
    return types.is_html(content_type)

fn is_xml(content_type: text) -> bool:
    return types.is_xml(content_type)

fn is_text(content_type: text) -> bool:
    return types.is_text(content_type)

# ============================================================================
# Request Module - HTTP request parsing and building
# ============================================================================

fn parse_request(text: text) -> tuple:
    return request.parse_request(text)

fn parse_request_line(line: text) -> tuple:
    return request.parse_request_line(line)

fn parse_method(text: text) -> text:
    return request.parse_method(text)

fn parse_path(text: text) -> text:
    return request.parse_path(text)

fn parse_version(text: text) -> text:
    return request.parse_version(text)

fn build_request(method: text, path: text, headers: list, body: text) -> text:
    return request.build_request(method, path, headers, body)

fn create_get_request(url: text, headers: list) -> text:
    return request.create_get_request(url, headers)

fn create_post_request(url: text, headers: list, body: text) -> text:
    return request.create_post_request(url, headers, body)

fn create_put_request(url: text, headers: list, body: text) -> text:
    return request.create_put_request(url, headers, body)

fn create_delete_request(url: text, headers: list) -> text:
    return request.create_delete_request(url, headers)

fn create_patch_request(url: text, headers: list, body: text) -> text:
    return request.create_patch_request(url, headers, body)

fn create_head_request(url: text, headers: list) -> text:
    return request.create_head_request(url, headers)

fn create_options_request(url: text, headers: list) -> text:
    return request.create_options_request(url, headers)

# ============================================================================
# Response Module - HTTP response parsing and building
# ============================================================================

fn parse_response(text: text) -> tuple:
    return response.parse_response(text)

fn parse_status_line(line: text) -> tuple:
    return response.parse_status_line(line)

fn parse_status_code(text: text) -> i64:
    return response.parse_status_code(text)

fn build_response(status: i64, headers: list, body: text) -> text:
    return response.build_response(status, headers, body)

fn create_response(status: i64) -> text:
    return response.create_response(status)

fn create_ok_response(body: text) -> text:
    return response.create_ok_response(body)

fn create_not_found_response() -> text:
    return response.create_not_found_response()

fn create_server_error_response() -> text:
    return response.create_server_error_response()

fn create_json_response(status: i64, json: text) -> text:
    return response.create_json_response(status, json)

fn create_html_response(status: i64, html: text) -> text:
    return response.create_html_response(status, html)

fn create_redirect_response(location: text) -> text:
    return response.create_redirect_response(location)

# ============================================================================
# Headers Module - HTTP headers manipulation
# ============================================================================

fn parse_headers(lines: list) -> list:
    return headers.parse_headers(lines)

fn parse_header(line: text) -> tuple:
    return headers.parse_header(line)

fn format_headers(headers: list) -> text:
    return headers.format_headers(headers)

fn get_header(headers: list, name: text) -> text:
    return headers.get_header(headers, name)

fn set_header(headers: list, name: text, value: text) -> list:
    return headers.set_header(headers, name, value)

fn remove_header(headers: list, name: text) -> list:
    return headers.remove_header(headers, name)

fn normalize_header_name(name: text) -> text:
    return headers.normalize_header_name(name)

fn get_content_length(headers: list) -> i64:
    return headers.get_content_length(headers)

fn is_chunked(headers: list) -> bool:
    return headers.is_chunked(headers)

# Chunked transfer encoding
fn encode_chunked(data: text) -> text:
    return headers.encode_chunked(data)

fn decode_chunked(encoded: text) -> text:
    return headers.decode_chunked(encoded)

# Range headers
fn parse_range_header(header: text) -> tuple:
    return headers.parse_range_header(header)

fn build_range_header(start: i64, end: i64) -> text:
    return headers.build_range_header(start, end)

# Multipart form data
fn parse_multipart(body: text, boundary: text) -> list:
    return headers.parse_multipart(body, boundary)

fn build_multipart(parts: list, boundary: text) -> text:
    return headers.build_multipart(parts, boundary)

fn generate_boundary() -> text:
    return headers.generate_boundary()

# ============================================================================
# URL Module - URL encoding and query strings
# ============================================================================

fn parse_query_string(query: text) -> list:
    return url.parse_query_string(query)

fn parse_query_param(pair: text) -> tuple:
    return url.parse_query_param(pair)

fn build_query_string(params: list) -> text:
    return url.build_query_string(params)

fn encode_query_param(value: text) -> text:
    return url.encode_query_param(value)

fn get_query_param(params: list, name: text) -> text:
    return url.get_query_param(params, name)

fn url_encode(text: text) -> text:
    return url.url_encode(text)

fn url_decode(encoded: text) -> text:
    return url.url_decode(encoded)

fn url_encode_component(text: text) -> text:
    return url.url_encode_component(text)

# ============================================================================
# Cookie Module - Cookie parsing and building
# ============================================================================

fn parse_cookie_header(header: text) -> list:
    return cookie.parse_cookie_header(header)

fn parse_cookie_pair(pair: text) -> tuple:
    return cookie.parse_cookie_pair(pair)

fn build_cookie(name: text, value: text, options: tuple) -> text:
    return cookie.build_cookie(name, value, options)

fn parse_set_cookie(header: text) -> tuple:
    return cookie.parse_set_cookie(header)

# ============================================================================
# Utilities Module - Authentication and general utilities
# ============================================================================

fn parse_basic_auth(header: text) -> tuple:
    return utilities.parse_basic_auth(header)

fn build_basic_auth(username: text, password: text) -> text:
    return utilities.build_basic_auth(username, password)

fn parse_bearer_token(header: text) -> text:
    return utilities.parse_bearer_token(header)

fn build_bearer_auth(token: text) -> text:
    return utilities.build_bearer_auth(token)

fn base64_encode_simple(input: text) -> text:
    return utilities.base64_encode_simple(input)

fn base64_decode_simple(encoded: text) -> text:
    return utilities.base64_decode_simple(encoded)

fn trim(text: text) -> text:
    return utilities.trim(text)

fn contains(text: text, substring: text) -> bool:
    return utilities.contains(text, substring)

fn index_of(text: text, substring: text, start: i64) -> i64:
    return utilities.index_of(text, substring, start)
