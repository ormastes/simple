# Union-Find Union Operations

fn uf_union(uf, x, y):
    """Union sets containing x and y (by rank).

    Attaches smaller tree under root of larger tree to keep trees shallow.
    Returns updated Union-Find structure.

    Example:
        val uf2 = uf_union(uf, 0, 1)  # Merge sets containing 0 and 1
    """
    val (parent, rank, size, count) = uf

    val root_x = uf_find(uf, x)
    val root_y = uf_find(uf, y)

    # Already in same set
    if root_x == root_y:
        return uf

    # Union by rank: attach smaller tree under larger
    if rank[root_x] < rank[root_y]:
        parent[root_x] = root_y
        size[root_y] = size[root_y] + size[root_x]
    else:
        if rank[root_x] == rank[root_y]:
            rank[root_x] = rank[root_x] + 1
        parent[root_y] = root_x
        size[root_x] = size[root_x] + size[root_y]

    (parent, rank, size, count - 1)

fn uf_merge_sets(uf, elements):
    """Merge all elements in array into single set.

    Example:
        val uf2 = uf_merge_sets(uf, [0, 2, 4])  # Merge 0, 2, 4 into one set
    """
    if elements.len() == 0:
        return uf

    var result = uf
    var first = elements[0]

    var i = 1
    while i < elements.len():
        result = uf_union(result, first, elements[i])
        i = i + 1

    result

fn uf_union_all(uf, pairs):
    """Perform union on array of (x, y) pairs.

    Example:
        val uf2 = uf_union_all(uf, [(0, 1), (2, 3), (1, 2)])
    """
    var result = uf
    for (x, y) in pairs:
        result = uf_union(result, x, y)
    result

fn uf_union_weighted(uf, x, y, w):
    """Union with weight: weight[x] + w = weight[y].

    Maintains relative weights between elements in same set.
    Useful for coordinate systems, distance tracking, etc.

    Example:
        val wuf = uf_union_weighted(wuf, 0, 1, 5)  # weight[1] = weight[0] + 5
    """
    val (parent, rank, size, weight, count) = uf

    val root_x = uf_find(uf, x)
    val root_y = uf_find(uf, y)

    if root_x == root_y:
        return uf

    # Calculate relative weight
    val weight_diff = weight[x] + w - weight[y]

    # Union by rank
    if rank[root_x] < rank[root_y]:
        parent[root_x] = root_y
        weight[root_x] = weight_diff
        size[root_y] = size[root_y] + size[root_x]
    else:
        if rank[root_x] == rank[root_y]:
            rank[root_x] = rank[root_x] + 1
        parent[root_y] = root_x
        weight[root_y] = 0 - weight_diff
        size[root_x] = size[root_x] + size[root_y]

    (parent, rank, size, weight, count - 1)
