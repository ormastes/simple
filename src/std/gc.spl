# Garbage Collector - Mark-and-Sweep with Tri-Color Marking
#
# Automatic memory management using mark-and-sweep algorithm.
# Provides safe memory reclamation without manual deallocation.
#
# Algorithm:
# 1. Mark Phase: Traverse object graph from roots, mark reachable objects
# 2. Sweep Phase: Reclaim unmarked objects
#
# Features:
# - Tri-color marking (white, gray, black)
# - Write barriers for incremental collection
# - Generational collection (young/old generations)
# - Weak references
# - Finalization support
#
# Usage:
#   val gc = GcHeap.new()
#   val obj = gc.allocate<MyObject>(size)
#   // Use object...
#   gc.collect()  // Automatic cleanup
#
# Architecture:
# - GcHeap: Main heap manager
# - GcObject: Base class for managed objects
# - GcPtr<T>: Smart pointer with write barrier
# - GcRoot: Stack/global roots for GC scanning

use std.atomic.*
use std.allocator.*
use std.runtime_value.*

# ============================================================================
# GC Color Marking
# ============================================================================

enum GcColor:
    """Tri-color marking for incremental GC.

    - White: Unvisited (potentially garbage)
    - Gray: Visited but children not scanned
    - Black: Visited and all children scanned
    """
    White  # Not yet visited
    Gray   # Visited, children pending
    Black  # Fully scanned

# ============================================================================
# GC Object Header
# ============================================================================

struct GcObjectHeader:
    """Header for garbage-collected objects.

    Stored before each GC-managed object in memory.
    Contains metadata for GC algorithm.

    Memory layout:
    ┌──────────────┬────────────────┐
    │ GcObjectHeader │ Object data    │
    └──────────────┴────────────────┘
    """
    size: usize           # Object size (bytes)
    color: GcColor        # Tri-color marking
    marked: bool          # Mark bit (for simple GC)
    generation: i32       # Generation (0 = young, 1+ = old)
    finalize: bool        # Has finalizer
    next: [u8]?           # Next object in heap (linked list)
    type_id: i32          # Type identifier for polymorphism

impl GcObjectHeader:
    static fn new(size: usize, type_id: i32) -> GcObjectHeader:
        """Create new object header."""
        GcObjectHeader(
            size: size,
            color: GcColor.White,
            marked: false,
            generation: 0,
            finalize: false,
            next: None,
            type_id: type_id
        )

    fn is_marked() -> bool:
        """Check if object is marked as reachable."""
        self.marked or self.color == GcColor.Black

    me mark():
        """Mark object as reachable."""
        self.marked = true
        self.color = GcColor.Gray

    me unmark():
        """Unmark object (for new GC cycle)."""
        self.marked = false
        self.color = GcColor.White

    me make_black():
        """Mark as fully scanned."""
        self.color = GcColor.Black

    fn is_young() -> bool:
        """Check if in young generation."""
        self.generation == 0

    me promote():
        """Promote to old generation."""
        self.generation = self.generation + 1

# ============================================================================
# GC Heap Configuration
# ============================================================================

struct GcConfig:
    """Configuration for garbage collector."""
    young_size: usize      # Young generation size (bytes)
    old_size: usize        # Old generation size (bytes)
    growth_factor: f64     # Heap growth factor (default 2.0)
    min_heap_size: usize   # Minimum heap size
    max_heap_size: usize   # Maximum heap size
    gc_threshold: usize    # Trigger GC when allocated > threshold
    incremental: bool      # Enable incremental GC
    concurrent: bool       # Enable concurrent marking (future)

impl GcConfig:
    static fn default() -> GcConfig:
        """Default GC configuration."""
        GcConfig(
            young_size: 1024 * 1024,      # 1 MB young generation
            old_size: 4 * 1024 * 1024,    # 4 MB old generation
            growth_factor: 2.0,
            min_heap_size: 1024 * 1024,   # 1 MB minimum
            max_heap_size: 1024 * 1024 * 1024,  # 1 GB maximum
            gc_threshold: 512 * 1024,     # GC at 512 KB
            incremental: false,
            concurrent: false
        )

    static fn with_heap_size(size: usize) -> GcConfig:
        """Create config with specific heap size."""
        var config = GcConfig__default()
        config.young_size = size / 5     # 20% young
        config.old_size = size * 4 / 5   # 80% old
        config

# ============================================================================
# GC Statistics
# ============================================================================

struct GcStats:
    """Garbage collection statistics."""
    collections: usize       # Total GC runs
    objects_allocated: usize # Total objects allocated
    objects_freed: usize     # Total objects freed
    bytes_allocated: usize   # Total bytes allocated
    bytes_freed: usize       # Total bytes freed
    young_collections: usize # Young generation collections
    full_collections: usize  # Full heap collections
    total_pause_time: i64    # Total pause time (microseconds)
    last_pause_time: i64     # Last collection pause time

impl GcStats:
    static fn new() -> GcStats:
        """Create empty stats."""
        GcStats(
            collections: 0,
            objects_allocated: 0,
            objects_freed: 0,
            bytes_allocated: 0,
            bytes_freed: 0,
            young_collections: 0,
            full_collections: 0,
            total_pause_time: 0,
            last_pause_time: 0
        )

    fn avg_pause_time() -> i64:
        """Get average pause time in microseconds."""
        if self.collections == 0:
            return 0
        (self.total_pause_time / self.collections as i64)

    fn survival_rate() -> f64:
        """Get object survival rate (0.0 - 1.0)."""
        if self.objects_allocated == 0:
            return 0.0
        val alive = self.objects_allocated - self.objects_freed
        (alive as f64) / (self.objects_allocated as f64)

# ============================================================================
# GC Heap
# ============================================================================

class GcHeap:
    """Main garbage collector heap.

    Manages object allocation, marking, and sweeping.
    Uses tri-color marking for incremental collection.

    Example:
        val gc = GcHeap__new()

        // Allocate objects
        val obj1 = gc.allocate<MyType>(size: 128)
        val obj2 = gc.allocate<MyType>(size: 256)

        // Automatic GC when threshold reached
        // or manual trigger:
        gc.collect()
    """
    config: GcConfig          # Configuration
    young_alloc: ArenaAllocator    # Young generation allocator
    old_alloc: SlabAllocator       # Old generation allocator
    objects: [u8]?            # Head of object list (all objects)
    gray_stack: [[u8]]        # Gray objects to scan (mark phase)
    roots: [[u8]]             # Root set (stack, globals)
    allocated: usize          # Current allocated bytes
    stats: GcStats            # Collection statistics
    collecting: AtomicBool    # Currently collecting

    static fn new() -> GcHeap:
        """Create GC heap with default config."""
        GcHeap__with_config(GcConfig__default())

    static fn with_config(config: GcConfig) -> GcHeap:
        """Create GC heap with custom config."""
        GcHeap(
            config: config,
            young_alloc: ArenaAllocator__new(capacity: config.young_size),
            old_alloc: SlabAllocator__new(),
            objects: None,
            gray_stack: [],
            roots: [],
            allocated: 0,
            stats: GcStats__new(),
            collecting: AtomicBool__new(false)
        )

    # ========================================================================
    # Allocation
    # ========================================================================

    me allocate<T>(size: usize) -> [u8]?:
        """Allocate object on GC heap.

        Args:
            size: Object size in bytes

        Returns:
            Some(ptr) - Pointer to object (with GC header)
            None - Allocation failed

        Note: Triggers GC if threshold reached
        """
        # Check if GC needed
        if self.should_collect():
            self.collect()

        # Allocate with header
        val total_size = size + header_size()
        val ptr = self.young_alloc.allocate(total_size, 8)?

        # Initialize header
        val header_ptr = ptr
        val header = GcObjectHeader__new(size, type_id_of::<T>())
        write_header(header_ptr, header)

        # Link into object list
        val old_head = self.objects
        write_header_field(header_ptr, "next", old_head)
        self.objects = Some(header_ptr)

        # Update stats
        self.allocated = self.allocated + size
        self.stats.objects_allocated = self.stats.objects_allocated + 1
        self.stats.bytes_allocated = self.stats.bytes_allocated + size

        # Return object pointer (skip header)
        Some(ptr_add(ptr, header_size()))

    fn should_collect() -> bool:
        """Check if GC should be triggered.

        Triggers when allocated > threshold.
        """
        self.allocated > self.config.gc_threshold

    # ========================================================================
    # Root Management
    # ========================================================================

    me add_root(ptr: [u8]):
        """Add GC root (stack variable, global).

        Args:
            ptr: Pointer to object

        Roots are starting points for mark phase.
        """
        self.roots = self.roots.push(ptr)

    me remove_root(ptr: [u8]):
        """Remove GC root.

        Args:
            ptr: Pointer to object
        """
        self.roots = self.roots.filter(\p: p != ptr)

    me clear_roots():
        """Clear all roots (for testing)."""
        self.roots = []

    # ========================================================================
    # Collection
    # ========================================================================

    me collect():
        """Run garbage collection.

        Phases:
        1. Mark: Traverse object graph from roots
        2. Sweep: Reclaim unmarked objects

        This is a stop-the-world collection.
        """
        # Prevent recursive collection
        if self.collecting.load(MemoryOrdering.Acquire):
            return

        self.collecting.store(true, MemoryOrdering.Release)

        val start_time = current_time_micros()

        # Phase 1: Mark
        self.mark_phase()

        # Phase 2: Sweep
        self.sweep_phase()

        # Update stats
        val end_time = current_time_micros()
        val pause_time = end_time - start_time
        self.stats.collections = self.stats.collections + 1
        self.stats.full_collections = self.stats.full_collections + 1
        self.stats.total_pause_time = self.stats.total_pause_time + pause_time
        self.stats.last_pause_time = pause_time

        self.collecting.store(false, MemoryOrdering.Release)

    me collect_young():
        """Collect young generation only (minor GC).

        Faster than full collection, but only reclaims young objects.
        """
        # Generational collection: only scan young generation objects
        # Young objects are those allocated since the last minor GC
        # For now, do a full collection since young/old generation tracking
        # requires write barrier support in the runtime
        self.collect()

    # ========================================================================
    # Mark Phase
    # ========================================================================

    me mark_phase():
        """Mark phase: Traverse object graph from roots.

        Algorithm:
        1. Mark all roots as gray (add to gray stack)
        2. While gray stack not empty:
           a. Pop object from gray stack
           b. Mark object as black
           c. Scan children, mark gray (add to gray stack)
        3. All reachable objects are black
        """
        # Clear gray stack
        self.gray_stack = []

        # Mark roots as gray
        for root_ptr in self.roots:
            self.mark_gray(root_ptr)

        # Process gray stack (depth-first traversal)
        while not self.gray_stack.is_empty():
            val obj_ptr = self.gray_stack.pop()
            if obj_ptr.?:
                self.scan_object(obj_ptr.unwrap())

    me mark_gray(ptr: [u8]):
        """Mark object as gray (reachable but not scanned).

        Args:
            ptr: Pointer to object (with header)
        """
        # Get header
        val header_ptr = ptr_sub(ptr, header_size())
        var header = read_header(header_ptr)

        # Already marked?
        if header.is_marked():
            return

        # Mark gray
        header.mark()
        write_header(header_ptr, header)

        # Add to gray stack
        self.gray_stack = self.gray_stack.push(ptr)

    me scan_object(ptr: [u8]):
        """Scan object children, mark them gray.

        Args:
            ptr: Pointer to object (with header)

        Algorithm:
        1. Get object header
        2. Mark object as black
        3. Scan object fields for pointers
        4. Mark each pointer as gray
        """
        val header_ptr = ptr_sub(ptr, header_size())
        var header = read_header(header_ptr)

        # Mark black
        header.make_black()
        write_header(header_ptr, header)

        # Scan object fields for pointers using type layout information
        # Use type_id from header to look up pointer field offsets
        val obj_data_ptr = ptr
        val obj_size = header.size
        val type_info = self.type_registry.get(header.type_id)
        if type_info.? and type_info.unwrap().pointer_offsets.?:
            # Precise scanning: only check known pointer fields
            val offsets = type_info.unwrap().pointer_offsets.unwrap()
            for offset in offsets:
                self.scan_pointer_at(obj_data_ptr, offset)
        else:
            # Conservative scanning: scan entire object assuming all RuntimeValue
            self.scan_for_pointers(obj_data_ptr, obj_size)

    me scan_for_pointers(ptr: [u8], size: usize):
        """Scan memory region for pointers, mark them gray.

        Args:
            ptr: Start of memory region
            size: Size of region

        Scans for tagged pointers (RuntimeValue with ptr tag).
        """
        val word_size = 8  # 64-bit words
        val num_words = size / word_size

        for i in 0..num_words:
            val word_ptr = ptr_add(ptr, i * word_size)
            val value_bits = read_i64(word_ptr)
            val value = RuntimeValue(bits: value_bits)

            # Is it a heap pointer?
            if value.is_ptr():
                val child_ptr = value.as_ptr()
                self.mark_gray(child_ptr)

    # ========================================================================
    # Sweep Phase
    # ========================================================================

    me sweep_phase():
        """Sweep phase: Reclaim unmarked objects.

        Algorithm:
        1. Traverse object list
        2. For each object:
           - If marked: Unmark for next cycle
           - If unmarked: Deallocate
        3. Update object list (remove freed objects)
        """
        var current = self.objects
        var prev: [u8]? = None
        var freed_count: usize = 0
        var freed_bytes: usize = 0

        while current.?:
            val obj_ptr = current.unwrap()
            val header = read_header(obj_ptr)

            if header.is_marked():
                # Object is reachable - unmark for next cycle
                var new_header = header
                new_header.unmark()
                write_header(obj_ptr, new_header)

                # Move to next
                prev = current
                current = header.next
            else:
                # Object is garbage - free it
                val next_obj = header.next

                # Run finalizer if needed
                if header.finalize:
                    self.finalize_object(obj_ptr, header)

                # Deallocate
                val total_size = header.size + header_size()
                # Note: Arena allocator doesn't free individual objects
                # Old generation would use slab allocator

                # Update stats
                freed_count = freed_count + 1
                freed_bytes = freed_bytes + header.size

                # Unlink from list
                if prev.?:
                    # Update previous object's next pointer
                    write_header_field(prev.unwrap(), "next", next_obj)
                else:
                    # This was head of list
                    self.objects = next_obj

                current = next_obj

        # Update stats
        self.stats.objects_freed = self.stats.objects_freed + freed_count
        self.stats.bytes_freed = self.stats.bytes_freed + freed_bytes
        self.allocated = self.allocated - freed_bytes

    me finalize_object(ptr: [u8], header: GcObjectHeader):
        """Run finalizer for object before deallocation.

        Args:
            ptr: Object pointer (with header)
            header: Object header

        Finalizers allow cleanup (close files, release resources).
        """
        # Call type-specific finalizer if registered
        val type_info = self.type_registry.get(header.type_id)
        if type_info.? and type_info.unwrap().finalizer.?:
            val finalizer = type_info.unwrap().finalizer.unwrap()
            finalizer(ptr)
        # Log finalization in debug mode
        if self.config.incremental:
            pass  # Finalization complete

    # ========================================================================
    # Utility
    # ========================================================================

    fn stats() -> GcStats:
        """Get GC statistics."""
        self.stats

    fn allocated_bytes() -> usize:
        """Get current allocated bytes."""
        self.allocated

    fn is_collecting() -> bool:
        """Check if GC is currently running."""
        self.collecting.load(MemoryOrdering.Acquire)

# ============================================================================
# GC Smart Pointer
# ============================================================================

class GcPtr<T>:
    """Smart pointer for GC-managed objects.

    Automatically registers/unregisters as GC root.
    Provides write barrier for incremental GC.

    Example:
        val gc = GcHeap__new()
        var ptr = GcPtr<MyObject>.new(gc, obj)
        // ptr automatically registered as root
        // When ptr goes out of scope, unregistered
    """
    heap: GcHeap   # GC heap
    ptr: [u8]?     # Pointer to object

    static fn new(heap: GcHeap, ptr: [u8]) -> GcPtr<T>:
        """Create GC pointer.

        Args:
            heap: GC heap
            ptr: Object pointer

        Note: Automatically registered as root
        """
        heap.add_root(ptr)
        GcPtr(heap: heap, ptr: Some(ptr))

    me set(new_ptr: [u8]):
        """Update pointer (with write barrier).

        Args:
            new_ptr: New object pointer

        Write barrier ensures GC correctness during incremental collection.
        """
        # Remove old root
        if self.ptr.?:
            self.heap.remove_root(self.ptr.unwrap())

        # Add new root
        self.heap.add_root(new_ptr)
        self.ptr = Some(new_ptr)

        # Write barrier (for incremental GC)
        if self.heap.config.incremental:
            self.write_barrier(new_ptr)

    me write_barrier(ptr: [u8]):
        """Write barrier for incremental GC.

        Ensures new references are marked if collector is running.
        """
        if self.heap.is_collecting():
            self.heap.mark_gray(ptr)

    fn get() -> [u8]?:
        """Get raw pointer."""
        self.ptr

    me drop():
        """Cleanup: unregister root."""
        if self.ptr.?:
            self.heap.remove_root(self.ptr.unwrap())

# ============================================================================
# FFI Functions (GC Internals)
# ============================================================================

# Header operations
extern fn header_size() -> usize
extern fn write_header(ptr: [u8], header: GcObjectHeader)
extern fn read_header(ptr: [u8]) -> GcObjectHeader
extern fn write_header_field(ptr: [u8], field: text, value: [u8]?)
extern fn type_id_of<T>() -> i32

# Pointer arithmetic
extern fn ptr_add(ptr: [u8], offset: usize) -> [u8]
extern fn ptr_sub(ptr: [u8], offset: usize) -> [u8]
extern fn read_i64(ptr: [u8]) -> i64

# Time
extern fn current_time_micros() -> i64

# ============================================================================
# Exports
# ============================================================================

export GcHeap
export GcConfig
export GcStats
export GcPtr
export GcColor
export GcObjectHeader
