# Concurrent Data Structures
#
# Thread-safe data structures for concurrent programming.
# Built on working SFFI primitives: channels, atomic ints, atomic bools, and hashmaps.
#
# Components:
# - MpscQueue: Multi-producer single-consumer queue (channel-based)
# - MpmcQueue: Multi-producer multi-consumer queue (channel-based, bounded)
# - ConcurrentMap: Thread-safe hash map (__rt_hashmap-based)
# - AtomicFlag: Simple atomic boolean flag
# - Once: Run initialization exactly once
# - Barrier: Synchronize multiple threads

# ============================================================================
# FFI Declarations (all known-working SFFI)
# ============================================================================

# Channel operations
extern fn rt_channel_new() -> i64
extern fn rt_channel_send(channel_id: i64, value: Any)
extern fn rt_channel_try_recv(channel_id: i64) -> Any
extern fn rt_channel_close(channel_id: i64)

# Atomic integer operations
extern fn rt_atomic_int_new(initial: i64) -> i64
extern fn rt_atomic_int_load(handle: i64) -> i64
extern fn rt_atomic_int_store(handle: i64, value: i64)
extern fn rt_atomic_int_fetch_add(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_fetch_sub(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_compare_exchange(handle: i64, current: i64, new_value: i64) -> bool
extern fn rt_atomic_int_free(handle: i64)

# Atomic boolean operations
extern fn rt_atomic_bool_new(initial: bool) -> i64
extern fn rt_atomic_bool_load(handle: i64) -> bool
extern fn rt_atomic_bool_store(handle: i64, value: bool)
extern fn rt_atomic_bool_swap(handle: i64, value: bool) -> bool
extern fn rt_atomic_bool_free(handle: i64)

# HashMap operations
extern fn __rt_hashmap_new() -> i64
extern fn __rt_hashmap_insert(handle: i64, key: text, value: Any) -> bool
extern fn __rt_hashmap_get(handle: i64, key: text) -> Any
extern fn __rt_hashmap_contains_key(handle: i64, key: text) -> bool
extern fn __rt_hashmap_remove(handle: i64, key: text) -> Any
extern fn __rt_hashmap_len(handle: i64) -> i64

# Thread operations
extern fn rt_thread_yield()

# ============================================================================
# MpscQueue - Multi-Producer Single-Consumer Queue
# ============================================================================

class MpscQueue:
    _channel_id: i64
    _size_handle: i64

    fn push(value: Any):
        rt_channel_send(self._channel_id, value)
        rt_atomic_int_fetch_add(self._size_handle, 1)

    fn pop() -> Any:
        val result = rt_channel_try_recv(self._channel_id)
        if result != nil:
            rt_atomic_int_fetch_sub(self._size_handle, 1)
        result

    fn is_empty() -> bool:
        rt_atomic_int_load(self._size_handle) <= 0

    fn len() -> i64:
        val size = rt_atomic_int_load(self._size_handle)
        if size < 0:
            return 0
        size

    fn close():
        rt_channel_close(self._channel_id)
        rt_atomic_int_free(self._size_handle)

fn mpsc_queue_new() -> MpscQueue:
    MpscQueue(
        _channel_id: rt_channel_new(),
        _size_handle: rt_atomic_int_new(0)
    )

# ============================================================================
# MpmcQueue - Multi-Producer Multi-Consumer Queue
# ============================================================================

class MpmcQueue:
    _channel_id: i64
    _capacity: i64
    _size_handle: i64

    fn push(value: Any) -> bool:
        val current = rt_atomic_int_load(self._size_handle)
        if current >= self._capacity:
            return false
        rt_channel_send(self._channel_id, value)
        rt_atomic_int_fetch_add(self._size_handle, 1)
        true

    fn pop() -> Any:
        val result = rt_channel_try_recv(self._channel_id)
        if result != nil:
            rt_atomic_int_fetch_sub(self._size_handle, 1)
        result

    fn len() -> i64:
        val size = rt_atomic_int_load(self._size_handle)
        if size < 0:
            return 0
        size

    fn is_empty() -> bool:
        rt_atomic_int_load(self._size_handle) <= 0

    fn is_full() -> bool:
        rt_atomic_int_load(self._size_handle) >= self._capacity

    fn close():
        rt_channel_close(self._channel_id)
        rt_atomic_int_free(self._size_handle)

fn mpmc_queue_with_capacity(capacity: i64) -> MpmcQueue:
    MpmcQueue(
        _channel_id: rt_channel_new(),
        _capacity: capacity,
        _size_handle: rt_atomic_int_new(0)
    )

# ============================================================================
# ConcurrentMap - Thread-Safe Hash Map
# ============================================================================

class ConcurrentMap:
    _handle: i64

    fn insert(key: text, value: Any) -> bool:
        __rt_hashmap_insert(self._handle, key, value)

    fn get(key: text) -> Any:
        __rt_hashmap_get(self._handle, key)

    fn remove(key: text) -> Any:
        __rt_hashmap_remove(self._handle, key)

    fn contains_key(key: text) -> bool:
        __rt_hashmap_contains_key(self._handle, key)

    fn len() -> i64:
        __rt_hashmap_len(self._handle)

    fn is_empty() -> bool:
        __rt_hashmap_len(self._handle) == 0

fn concurrent_map_new() -> ConcurrentMap:
    ConcurrentMap(_handle: __rt_hashmap_new())

# Provided for API compat - sharding not needed (runtime HashMap is thread-safe)
fn concurrent_map_with_shards(num_shards: i64) -> ConcurrentMap:
    ConcurrentMap(_handle: __rt_hashmap_new())

# ============================================================================
# AtomicFlag - Simple Atomic Boolean Flag
# ============================================================================

class AtomicFlag:
    _handle: i64

    fn set():
        rt_atomic_bool_store(self._handle, true)

    fn clear():
        rt_atomic_bool_store(self._handle, false)

    fn is_set() -> bool:
        rt_atomic_bool_load(self._handle)

    fn test_and_set() -> bool:
        rt_atomic_bool_swap(self._handle, true)

    fn free():
        rt_atomic_bool_free(self._handle)

fn atomic_flag_new() -> AtomicFlag:
    AtomicFlag(_handle: rt_atomic_bool_new(false))

fn atomic_flag_new_set() -> AtomicFlag:
    AtomicFlag(_handle: rt_atomic_bool_new(true))

# ============================================================================
# Once - Run Initialization Exactly Once
# ============================================================================

class Once:
    _state: i64  # AtomicInt handle: 0=not run, 1=running, 2=done

    fn call_once(f: fn()):
        # Fast path: already done
        if rt_atomic_int_load(self._state) == 2:
            return
        # Try to claim execution
        val ok = rt_atomic_int_compare_exchange(self._state, 0, 1)
        if ok:
            f()
            rt_atomic_int_store(self._state, 2)
        else:
            # Spin-wait for completion
            while rt_atomic_int_load(self._state) != 2:
                rt_thread_yield()

    fn is_completed() -> bool:
        rt_atomic_int_load(self._state) == 2

    fn free():
        rt_atomic_int_free(self._state)

fn once_new() -> Once:
    Once(_state: rt_atomic_int_new(0))

# ============================================================================
# Barrier - Synchronize Multiple Threads
# ============================================================================

class Barrier:
    _count: i64
    _arrived: i64    # AtomicInt handle
    _generation: i64 # AtomicInt handle

    fn wait():
        val gen = rt_atomic_int_load(self._generation)
        val arrived = rt_atomic_int_fetch_add(self._arrived, 1)
        if arrived + 1 == self._count:
            # Last thread - reset and advance generation
            rt_atomic_int_store(self._arrived, 0)
            rt_atomic_int_fetch_add(self._generation, 1)
        else:
            # Wait for generation to advance
            while rt_atomic_int_load(self._generation) == gen:
                rt_thread_yield()

    fn free():
        rt_atomic_int_free(self._arrived)
        rt_atomic_int_free(self._generation)

fn barrier_new(count: i64) -> Barrier:
    Barrier(
        _count: count,
        _arrived: rt_atomic_int_new(0),
        _generation: rt_atomic_int_new(0)
    )

# ============================================================================
# Exports
# ============================================================================

export MpscQueue
export MpmcQueue
export ConcurrentMap
export AtomicFlag
export Once
export Barrier
