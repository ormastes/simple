# Circle and Shape Operations
#
# A circle is represented as: ((x, y), radius)
# A rectangle is represented as: ((x, y), width, height) where (x, y) is the top-left corner
# A triangle is represented as three points: (p1, p2, p3)

import "std/math" as math
import "std/geometry/types" as types
import "std/geometry/point" as point

# ============================================================================
# Circle Operations
# ============================================================================

# Create a circle
fn circle_create(x: f64, y: f64, radius: f64) -> ((f64, f64), f64):
    ((x, y), radius)

# Get circle center
fn circle_center(circle: ((f64, f64), f64)) -> (f64, f64):
    circle.0

# Get circle radius
fn circle_radius(circle: ((f64, f64), f64)) -> f64:
    circle.1

# Check if a circle contains a point
fn circle_contains_point(circle: ((f64, f64), f64), p: (f64, f64)) -> bool:
    val center = circle.0
    val radius = circle.1
    val dist_sq = point.point_distance_squared(center, p)
    dist_sq <= radius * radius

# Check if two circles intersect
fn circle_intersects(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    val center1 = c1.0
    val radius1 = c1.1
    val center2 = c2.0
    val radius2 = c2.1
    val dist = point.point_distance(center1, center2)
    val sum_radii = radius1 + radius2
    dist <= sum_radii

# Check if a circle intersects a rectangle
fn circle_rect_intersects(circle: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool:
    val center = circle.0
    val radius = circle.1
    val pos = rect.0
    val w = rect.1
    val h = rect.2

    val closest_x = math.max(pos.0, math.min(center.0, pos.0 + w))
    val closest_y = math.max(pos.1, math.min(center.1, pos.1 + h))
    val closest = (closest_x, closest_y)

    val dist_sq = point.point_distance_squared(center, closest)
    dist_sq <= radius * radius

# Calculate the area of a circle
fn circle_area(circle: ((f64, f64), f64)) -> f64:
    val radius = circle.1
    math.pi() * radius * radius

# Calculate the circumference of a circle
fn circle_circumference(circle: ((f64, f64), f64)) -> f64:
    val radius = circle.1
    2.0 * math.pi() * radius

# Get a point on the circle at the given angle (radians)
fn circle_point_at_angle(circle: ((f64, f64), f64), angle: f64) -> (f64, f64):
    val center = circle.0
    val radius = circle.1
    val x = center.0 + radius * math.cos(angle)
    val y = center.1 + radius * math.sin(angle)
    (x, y)

# Check if two circles are tangent (externally or internally)
fn circle_is_tangent(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    val center1 = c1.0
    val radius1 = c1.1
    val center2 = c2.0
    val radius2 = c2.1
    val dist = point.point_distance(center1, center2)
    val sum_radii = radius1 + radius2
    val diff_radii = math.abs(radius1 - radius2)
    val is_external = math.abs(dist - sum_radii) < types.EPSILON
    val is_internal = math.abs(dist - diff_radii) < types.EPSILON
    is_external or is_internal

# Get the bounding box of a circle
fn circle_bounding_box(circle: ((f64, f64), f64)) -> ((f64, f64), f64, f64):
    val center = circle.0
    val radius = circle.1
    val x = center.0 - radius
    val y = center.1 - radius
    val w = 2.0 * radius
    val h = 2.0 * radius
    ((x, y), w, h)

# ============================================================================
# Rectangle Operations
# ============================================================================

# Create a rectangle
fn rect_create(x: f64, y: f64, width: f64, height: f64) -> ((f64, f64), f64, f64):
    ((x, y), width, height)

# Get rectangle corners: top-left, top-right, bottom-right, bottom-left
fn rect_corners(rect: ((f64, f64), f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64), (f64, f64)):
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    val tl = pos
    val tr = (pos.0 + w, pos.1)
    val br = (pos.0 + w, pos.1 + h)
    val bl = (pos.0, pos.1 + h)
    (tl, tr, br, bl)

# Get rectangle center
fn rect_center(rect: ((f64, f64), f64, f64)) -> (f64, f64):
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    (pos.0 + w / 2.0, pos.1 + h / 2.0)

# Check if a rectangle contains a point
fn rect_contains_point(rect: ((f64, f64), f64, f64), p: (f64, f64)) -> bool:
    val pos = rect.0
    val w = rect.1
    val h = rect.2
    p.0 >= pos.0 and p.0 <= pos.0 + w and p.1 >= pos.1 and p.1 <= pos.1 + h

# Check if two rectangles intersect
fn rect_intersects(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool:
    val pos1 = r1.0
    val w1 = r1.1
    val h1 = r1.2
    val pos2 = r2.0
    val w2 = r2.1
    val h2 = r2.2

    val left1 = pos1.0
    val right1 = pos1.0 + w1
    val top1 = pos1.1
    val bottom1 = pos1.1 + h1

    val left2 = pos2.0
    val right2 = pos2.0 + w2
    val top2 = pos2.1
    val bottom2 = pos2.1 + h2

    not (right1 < left2 or left1 > right2 or bottom1 < top2 or top1 > bottom2)

# Calculate the area of a rectangle
fn rect_area(rect: ((f64, f64), f64, f64)) -> f64:
    val w = rect.1
    val h = rect.2
    w * h

# Calculate the perimeter of a rectangle
fn rect_perimeter(rect: ((f64, f64), f64, f64)) -> f64:
    val w = rect.1
    val h = rect.2
    2.0 * (w + h)

# Get the intersection of two rectangles
# Returns nil if they don't intersect
fn rect_intersection(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> ((f64, f64), f64, f64)?:
    if not rect_intersects(r1, r2):
        nil
    else:
        val pos1 = r1.0
        val w1 = r1.1
        val h1 = r1.2
        val pos2 = r2.0
        val w2 = r2.1
        val h2 = r2.2

        val left = math.max(pos1.0, pos2.0)
        val top = math.max(pos1.1, pos2.1)
        val right = math.min(pos1.0 + w1, pos2.0 + w2)
        val bottom = math.min(pos1.1 + h1, pos2.1 + h2)

        ((left, top), right - left, bottom - top)

# ============================================================================
# Triangle Operations
# ============================================================================

# Create a triangle
fn triangle_create(p1: (f64, f64), p2: (f64, f64), p3: (f64, f64)) -> ((f64, f64), (f64, f64), (f64, f64)):
    (p1, p2, p3)

# Calculate the area of a triangle using the cross product
fn triangle_area(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val v1 = point.vector_from_points(p1, p2)
    val v2 = point.vector_from_points(p1, p3)
    val cross = point.vector_cross(v1, v2)
    math.abs(cross) / 2.0

# Calculate the perimeter of a triangle
fn triangle_perimeter(tri: ((f64, f64), (f64, f64), (f64, f64))) -> f64:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val d12 = point.point_distance(p1, p2)
    val d23 = point.point_distance(p2, p3)
    val d31 = point.point_distance(p3, p1)
    d12 + d23 + d31

# Calculate the centroid of a triangle
fn triangle_centroid(tri: ((f64, f64), (f64, f64), (f64, f64))) -> (f64, f64):
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val x = (p1.0 + p2.0 + p3.0) / 3.0
    val y = (p1.1 + p2.1 + p3.1) / 3.0
    (x, y)

# Check if a triangle contains a point (using barycentric coordinates)
fn triangle_contains_point(tri: ((f64, f64), (f64, f64), (f64, f64)), p: (f64, f64)) -> bool:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2

    val v0 = point.vector_from_points(p1, p3)
    val v1 = point.vector_from_points(p1, p2)
    val v2 = point.vector_from_points(p1, p)

    val dot00 = point.vector_dot(v0, v0)
    val dot01 = point.vector_dot(v0, v1)
    val dot02 = point.vector_dot(v0, v2)
    val dot11 = point.vector_dot(v1, v1)
    val dot12 = point.vector_dot(v1, v2)

    val denom = dot00 * dot11 - dot01 * dot01
    if math.abs(denom) < types.EPSILON:
        false
    else:
        val inv_denom = 1.0 / denom
        val u = (dot11 * dot02 - dot01 * dot12) * inv_denom
        val v = (dot00 * dot12 - dot01 * dot02) * inv_denom

        u >= 0.0 and v >= 0.0 and u + v <= 1.0

# Check if a triangle is clockwise
fn triangle_is_clockwise(tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val v1 = point.vector_from_points(p1, p2)
    val v2 = point.vector_from_points(p2, p3)
    val cross = point.vector_cross(v1, v2)
    cross < 0.0

# Calculate the circumcircle of a triangle (returns center and radius)
fn triangle_circumcircle(tri: ((f64, f64), (f64, f64), (f64, f64))) -> ((f64, f64), f64)?:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val ax = p1.0
    val ay = p1.1
    val bx = p2.0
    val by = p2.1
    val cx = p3.0
    val cy = p3.1
    val d = 2.0 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))
    if math.abs(d) < types.EPSILON:
        nil
    else:
        val ax2_ay2 = ax * ax + ay * ay
        val bx2_by2 = bx * bx + by * by
        val cx2_cy2 = cx * cx + cy * cy
        val ux = (ax2_ay2 * (by - cy) + bx2_by2 * (cy - ay) + cx2_cy2 * (ay - by)) / d
        val uy = (ax2_ay2 * (cx - bx) + bx2_by2 * (ax - cx) + cx2_cy2 * (bx - ax)) / d
        val center = (ux, uy)
        val radius = point.point_distance(center, p1)
        (center, radius)

# Calculate the incircle of a triangle (returns center and radius)
fn triangle_incircle(tri: ((f64, f64), (f64, f64), (f64, f64))) -> ((f64, f64), f64)?:
    val p1 = tri.0
    val p2 = tri.1
    val p3 = tri.2
    val a = point.point_distance(p2, p3)
    val b = point.point_distance(p1, p3)
    val c = point.point_distance(p1, p2)
    val perim = a + b + c
    if math.abs(perim) < types.EPSILON:
        nil
    else:
        val cx = (a * p1.0 + b * p2.0 + c * p3.0) / perim
        val cy = (a * p1.1 + b * p2.1 + c * p3.1) / perim
        val s = perim / 2.0
        val area = triangle_area(tri)
        val radius = area / s
        val center = (cx, cy)
        (center, radius)
