# Mutex Module - Mutual Exclusion Lock
# @tag:stdlib
# @tag:api
#
# Provides mutual exclusion locks for protecting shared mutable state.
# Mutex ensures only one thread can access the protected value at a time.
#
# Locking Model:
#   - Exclusive access - only one thread holds lock at any time
#   - lock() blocks until lock is acquired and returns protected value
#   - unlock(new_value) updates value and releases lock atomically
#   - try_lock() returns nil if lock is held by another thread
#
# Thread Safety:
#   - Lock operations are atomic - no race conditions
#   - Blocking lock() cannot be interrupted (no timeout)
#   - No deadlock detection - avoid circular lock dependencies
#   - No automatic unlock - must call unlock() explicitly
#
# Ownership Semantics:
#   - lock() transfers value ownership to caller thread
#   - unlock() transfers updated value back to mutex
#   - Value is copied on lock/unlock (no zero-copy RAII guards yet)
#
# SDoctest Examples:
#
# Example 1: Basic Lock/Unlock
# ```simple
# use std.concurrent.mutex.{mutex_new}
#
# val m = mutex_new(0)
# val current = m.lock()
# m.unlock(current + 1)
# val final_val = m.lock()
# m.unlock(final_val)
# print final_val  # Prints: 1
# ```
#
# Example 2: Shared Counter Across Threads
# ```simple
# use std.concurrent.mutex.{mutex_new}
# use std.concurrent.thread.{thread_spawn}
#
# val counter = mutex_new(0)
# val inc = \:
#     val v = counter.lock()
#     counter.unlock(v + 1)
# val h1 = thread_spawn(inc)
# val h2 = thread_spawn(inc)
# h1.join()
# h2.join()
# val result = counter.lock()
# counter.unlock(result)
# print result  # Prints: 2
# ```
#
# Example 3: Try Lock (Non-Blocking)
# ```simple
# use std.concurrent.mutex.{mutex_new}
#
# val m = mutex_new(42)
# val first_lock = m.lock()
# print first_lock  # Prints: 42
# val try_result = m.try_lock()
# print (try_result == nil)  # Prints: true (lock held)
# m.unlock(100)
# val second_lock = m.try_lock()
# print second_lock  # Prints: 100
# m.unlock(second_lock)
# ```
#
# Performance Notes:
#   - Lock acquire: ~50ns if uncontended, blocking if contended
#   - Unlock: ~30ns (atomic release)
#   - try_lock: ~40ns (never blocks)
#   - Value copy overhead depends on value size
#
# Common Patterns:
#   - Shared Counter: Lock, increment, unlock
#   - Conditional Update: Lock, check condition, update if true, unlock
#   - Read-Modify-Write: Lock, read, compute, unlock with new value
#
# Deadlock Prevention:
#   - Always acquire locks in same order across threads
#   - Use try_lock() to avoid indefinite blocking
#   - Keep critical sections (lock-to-unlock) as short as possible
#   - Avoid calling functions that acquire locks while holding a lock
#
# Limitations:
#   - No RAII guards - must manually unlock (forgetting unlock causes deadlock)
#   - No poisoning - no detection if thread panics while holding lock
#   - No timeout on lock() - blocks indefinitely
#   - No recursive locking - same thread cannot lock twice

# --- SFFI declarations ---
extern fn rt_mutex_new(initial: Any) -> Any
extern fn rt_mutex_lock(mutex: Any) -> Any
extern fn rt_mutex_try_lock(mutex: Any) -> Any
extern fn rt_mutex_unlock(mutex: Any, new_value: Any) -> Any

# --- Mutex ---
# @tag:api
#
# Handle to a mutual exclusion lock protecting a value.
# Only one thread can hold the lock at any time.

class Mutex:
    _handle: Any  # Rust Mutex handle (opaque)

    # Acquires lock and returns protected value (blocking).
    # Blocks current thread until lock is available.
    # Must call unlock() to release - no automatic unlock.
    # @tag:api
    fn lock() -> Any:
        rt_mutex_lock(self._handle)

    # Non-blocking lock attempt - returns nil if lock held.
    # Returns protected value if lock acquired successfully.
    # If successful, must call unlock() to release.
    # @tag:api
    fn try_lock() -> Any:
        rt_mutex_try_lock(self._handle)

    # Releases lock and updates protected value atomically.
    # new_value becomes the new protected value.
    # After unlock, other threads can acquire the lock.
    # @tag:api
    fn unlock(new_value: Any) -> Any:
        rt_mutex_unlock(self._handle, new_value)

# --- API ---

# Creates a new mutex protecting the given initial value.
# Lock starts in unlocked state - first lock() succeeds immediately.
# @tag:api
fn mutex_new(initial: Any) -> Mutex:
    val handle = rt_mutex_new(initial)
    Mutex(_handle: handle)
