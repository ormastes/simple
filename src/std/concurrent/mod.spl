# Concurrent Module - Safe Concurrency Primitives
# @tag:stdlib
# @tag:api
#
# Provides thread-safe concurrency primitives for parallel computation.
# All operations are backed by Rust runtime FFI for safety and performance.
#
# Concurrency Model:
#   - Threads: OS threads for parallel execution
#   - Channels: Message passing for thread communication (MPMC)
#   - Locks: Mutual exclusion (Mutex) and read-write locks (RwLock)
#   - Actors: Isolated computation with message passing
#   - Collections: Lock-free concurrent data structures
#
# Safety Guarantees:
#   - All locks prevent data races through runtime enforcement
#   - Channels provide safe cross-thread communication
#   - Actors isolate mutable state to prevent shared memory bugs
#   - Thread handles ensure proper cleanup via join/free
#
# Thread Safety Notes:
#   - Mutex provides exclusive access (one writer OR one reader)
#   - RwLock allows multiple readers OR one writer
#   - Channels are MPMC (multiple producers, multiple consumers)
#   - All concurrent collections are lock-free for performance
#
# Modules:
#   thread      - Thread spawning, joining, sleep, yield
#   channel     - Inter-thread message passing (MPMC)
#   mutex       - Mutual exclusion locks
#   rwlock      - Read-write locks
#   actor       - Lightweight actor-based concurrency
#   collections - Thread-safe HashMap, HashSet, BTreeMap, BTreeSet
#
# Basic Usage:
#   use std.concurrent.thread.{thread_spawn, thread_sleep}
#   use std.concurrent.channel.{channel_new}
#   use std.concurrent.mutex.{mutex_new}
#
# SDoctest Examples:
#
# Example 1: Thread Creation and Joining
# ```simple
# use std.concurrent.thread.{thread_spawn}
#
# val handle = thread_spawn(\: 42)
# val result = handle.join()
# print result  # Prints: 42
# ```
#
# Example 2: Channel-Based Message Passing
# ```simple
# use std.concurrent.channel.{channel_new}
# use std.concurrent.thread.{thread_spawn, thread_sleep}
#
# val ch = channel_new()
# val producer = thread_spawn(\:
#     ch.send(100)
#     ch.send(200)
#     ch.close()
# )
# thread_sleep(10)
# val v1 = ch.recv()
# val v2 = ch.recv()
# print v1  # Prints: 100
# print v2  # Prints: 200
# producer.join()
# ```
#
# Example 3: Mutex for Shared State
# ```simple
# use std.concurrent.mutex.{mutex_new}
# use std.concurrent.thread.{thread_spawn}
#
# val counter = mutex_new(0)
# val increment_fn = \:
#     val current = counter.lock()
#     counter.unlock(current + 1)
# val handles = [
#     thread_spawn(increment_fn),
#     thread_spawn(increment_fn)
# ]
# handles[0].join()
# handles[1].join()
# val final_val = counter.lock()
# counter.unlock(final_val)
# print final_val  # Prints: 2
# ```
#
# Example 4: Actor Pattern for Isolated Computation
# ```simple
# use std.concurrent.actor.{actor_spawn}
#
# val doubler = actor_spawn(\msg: msg * 2)
# doubler.send(21)
# val result = doubler.recv()
# print result  # Prints: 42
# ```
#
# Example 5: Concurrent HashMap
# ```simple
# use std.concurrent.collections.{hashmap_new}
#
# val map = hashmap_new()
# map.insert("name", "Alice")
# map.insert("age", 30)
# val name = map.get("name")
# val exists = map.contains_key("age")
# print name   # Prints: Alice
# print exists # Prints: true
# ```
#
# Performance Considerations:
#   - Thread spawning has ~100Î¼s overhead - reuse threads when possible
#   - Channels are lock-free but bounded - avoid unbounded growth
#   - Mutexes have ~50ns lock/unlock cost - minimize critical sections
#   - Actors add message queue overhead - batch messages when possible
#   - Concurrent collections use CAS operations - faster than locked structures
#
# Common Patterns:
#   - Producer-Consumer: Use channels for work distribution
#   - Shared Counter: Use Mutex or atomic operations
#   - Read-Heavy Data: Use RwLock for concurrent reads
#   - Isolated State: Use actors to avoid shared memory
#
# Limitations:
#   - Thread closures cannot capture mutable outer variables (use channels)
#   - No automatic cleanup - call join() or free() on thread handles
#   - Channel close() must be explicit - no automatic close on drop
#   - Mutex/RwLock require manual unlock - no RAII guards yet
#
# See Also:
#   - Thread documentation: src/std/concurrent/thread.spl
#   - Channel documentation: src/std/concurrent/channel.spl
#   - Mutex documentation: src/std/concurrent/mutex.spl
#   - Actor documentation: src/std/concurrent/actor.spl
