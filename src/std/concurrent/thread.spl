# Thread Module - OS Thread Management
# @tag:stdlib
# @tag:api
#
# Provides OS-level thread creation, management, and synchronization.
# All operations delegate to Rust std::thread via runtime FFI.
#
# Thread Safety:
#   - Each thread runs in isolated memory space
#   - Thread closures cannot modify outer variables (use return values or channels)
#   - Thread handles must be joined or freed to prevent resource leaks
#   - Multiple threads can run concurrently on available CPU cores
#
# Resource Management:
#   - ThreadHandle.join() blocks until thread completes and returns result
#   - ThreadHandle.free() releases resources without waiting for completion
#   - Unjoined threads continue running but their results are lost
#   - Always call join() or free() to prevent handle leaks
#
# SDoctest Examples:
#
# Example 1: Basic Thread Spawning
# ```simple
# use std.concurrent.thread.{thread_spawn}
#
# val handle = thread_spawn(\: 42)
# val result = handle.join()
# print result  # Prints: 42
# ```
#
# Example 2: Parallel Computation
# ```simple
# use std.concurrent.thread.{thread_spawn}
#
# val compute = \: 10 * 10
# val h1 = thread_spawn(compute)
# val h2 = thread_spawn(compute)
# val r1 = h1.join()
# val r2 = h2.join()
# print (r1 + r2)  # Prints: 200
# ```
#
# Example 3: Thread Sleep and Yield
# ```simple
# use std.concurrent.thread.{thread_sleep, thread_yield}
#
# thread_sleep(100)   # Sleep for 100ms
# thread_yield()      # Yield to other threads
# print "awake"       # Prints: awake
# ```
#
# Example 4: Checking Thread Completion
# ```simple
# use std.concurrent.thread.{thread_spawn, thread_sleep}
#
# val handle = thread_spawn(\:
#     thread_sleep(50)
#     "done"
# )
# val done = handle.is_done()
# print done  # Prints: false (thread still running)
# thread_sleep(100)
# val done2 = handle.is_done()
# print done2  # Prints: true
# handle.join()
# ```
#
# Performance Notes:
#   - Thread spawn overhead: ~100-200μs per thread
#   - Context switch cost: ~1-10μs depending on OS
#   - Memory overhead: ~2MB stack per thread on Linux
#   - Use thread pools for frequent short-lived tasks
#
# Common Patterns:
#   - Fork-Join: Spawn multiple threads, join all before proceeding
#   - Background Work: Spawn thread, free handle if result not needed
#   - Periodic Tasks: Loop with thread_sleep() for polling
#
# Limitations:
#   - Closures cannot capture mutable outer state (use channels or return values)
#   - No thread-local storage support yet
#   - No thread priority control
#   - No CPU affinity pinning

# --- SFFI declarations ---
extern fn rt_thread_spawn_isolated(closure: Any) -> i64
extern fn rt_thread_spawn_isolated2(closure: Any, data1: Any, data2: Any) -> i64
extern fn rt_thread_join(handle: i64) -> Any
extern fn rt_thread_is_done(handle: i64) -> i64
extern fn rt_thread_id(handle: i64) -> i64
extern fn rt_thread_free(handle: i64)
extern fn rt_thread_available_parallelism() -> i64
extern fn rt_thread_sleep(millis: i64)
extern fn rt_thread_yield()

# --- ThreadHandle ---
# @tag:api
#
# Opaque handle to a running OS thread.
# Provides methods to wait for completion, check status, and release resources.

class ThreadHandle:
    _handle: i64  # Rust thread handle ID (opaque)

    # Blocks until thread completes and returns its result value.
    # Thread handle is consumed - cannot call join() twice.
    # @tag:api
    fn join() -> Any:
        rt_thread_join(self._handle)

    # Non-blocking check if thread has completed.
    # Returns true if thread finished, false if still running.
    # @tag:api
    fn is_done() -> bool:
        rt_thread_is_done(self._handle) == 1

    # Returns the OS-assigned thread ID.
    # Useful for debugging and logging.
    # @tag:api
    fn id() -> i64:
        rt_thread_id(self._handle)

    # Releases thread resources without waiting for completion.
    # Thread continues running but result is discarded.
    # Call this if you don't need the thread's return value.
    # @tag:api
    fn free():
        rt_thread_free(self._handle)

# --- API ---

# Spawns a new OS thread executing the given closure.
# Closure is executed in isolated memory - cannot modify outer variables.
# Returns ThreadHandle for joining or freeing the thread.
# @tag:api
fn thread_spawn(closure: Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated(closure)
    ThreadHandle(_handle: handle)

# Spawns thread with two data arguments passed to closure.
# Useful for passing immutable data without closure capture.
# closure receives (data1, data2) as arguments.
# @tag:api
fn thread_spawn2(data1: Any, data2: Any, closure: Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated2(closure, data1, data2)
    ThreadHandle(_handle: handle)

# Returns number of CPU cores available for parallel execution.
# Useful for sizing thread pools and work distribution.
# Typically equals physical CPU core count.
# @tag:api
fn thread_available_parallelism() -> i64:
    rt_thread_available_parallelism()

# Pauses current thread for specified milliseconds.
# Other threads continue executing during sleep.
# Minimum sleep duration is OS-dependent (typically 1ms).
# @tag:api
fn thread_sleep(millis: i64):
    rt_thread_sleep(millis)

# Voluntarily yields CPU to other threads.
# Useful in spin loops to reduce CPU usage.
# Thread may be rescheduled immediately by OS.
# @tag:api
fn thread_yield():
    rt_thread_yield()
