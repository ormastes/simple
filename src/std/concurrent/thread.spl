# Thread Module
#
# Pure Simple wrappers around Rust runtime thread SFFI.
#
# Usage:
#   val handle = thread_spawn(\: 42)
#   val result = handle.join()  # 42

# --- SFFI declarations ---
extern fn rt_thread_spawn_isolated(closure: Any) -> i64
extern fn rt_thread_spawn_isolated2(closure: Any, data1: Any, data2: Any) -> i64
extern fn rt_thread_join(handle: i64) -> Any
extern fn rt_thread_is_done(handle: i64) -> i64
extern fn rt_thread_id(handle: i64) -> i64
extern fn rt_thread_free(handle: i64)
extern fn rt_thread_available_parallelism() -> i64
extern fn rt_thread_sleep(millis: i64)
extern fn rt_thread_yield()

# --- ThreadHandle ---

class ThreadHandle:
    _handle: i64

    fn join() -> Any:
        rt_thread_join(self._handle)

    fn is_done() -> bool:
        rt_thread_is_done(self._handle) == 1

    fn id() -> i64:
        rt_thread_id(self._handle)

    fn free():
        rt_thread_free(self._handle)

# --- API ---

fn thread_spawn(closure: Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated(closure)
    ThreadHandle(_handle: handle)

fn thread_spawn2(data1: Any, data2: Any, closure: Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated2(closure, data1, data2)
    ThreadHandle(_handle: handle)

fn thread_available_parallelism() -> i64:
    rt_thread_available_parallelism()

fn thread_sleep(millis: i64):
    rt_thread_sleep(millis)

fn thread_yield():
    rt_thread_yield()
