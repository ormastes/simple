# Concurrent Collections Module
#
# Wraps Rust runtime concurrent collection FFI:
# HashMap, HashSet, BTreeMap, BTreeSet.
# All are handle-based (opaque i64 handle to Rust-managed data).
#
# Usage:
#   val m = hashmap_new()
#   m.insert("key", 42)
#   val v = m.get("key")  # 42
#
#   val s = hashset_new()
#   s.insert("hello")
#   s.contains("hello")   # true

# --- HashMap extern FFI (runtime uses __rt_ prefix) ---
extern fn __rt_hashmap_new() -> i64
extern fn __rt_hashmap_insert(handle: i64, key: text, value: Any) -> bool
extern fn __rt_hashmap_get(handle: i64, key: text) -> Any
extern fn __rt_hashmap_contains_key(handle: i64, key: text) -> bool
extern fn __rt_hashmap_remove(handle: i64, key: text) -> Any
extern fn __rt_hashmap_len(handle: i64) -> i64
extern fn __rt_hashmap_keys(handle: i64) -> Any
extern fn __rt_hashmap_values(handle: i64) -> Any
extern fn __rt_hashmap_entries(handle: i64) -> Any

# --- HashSet extern FFI ---
extern fn __rt_hashset_new() -> i64
extern fn __rt_hashset_insert(handle: i64, value: text) -> bool
extern fn __rt_hashset_contains(handle: i64, value: text) -> bool
extern fn __rt_hashset_remove(handle: i64, value: text) -> bool
extern fn __rt_hashset_len(handle: i64) -> i64
extern fn __rt_hashset_to_array(handle: i64) -> Any
extern fn __rt_hashset_intersection(a: i64, b: i64) -> i64
extern fn __rt_hashset_difference(a: i64, b: i64) -> i64
extern fn __rt_hashset_symmetric_difference(a: i64, b: i64) -> i64
extern fn __rt_hashset_is_subset(a: i64, b: i64) -> bool
extern fn __rt_hashset_is_superset(a: i64, b: i64) -> bool
extern fn __rt_hashset_drop(handle: i64)

# --- BTreeMap extern FFI ---
extern fn __rt_btreemap_new() -> i64
extern fn __rt_btreemap_insert(handle: i64, key: text, value: Any) -> bool
extern fn __rt_btreemap_get(handle: i64, key: text) -> Any
extern fn __rt_btreemap_contains_key(handle: i64, key: text) -> bool
extern fn __rt_btreemap_remove(handle: i64, key: text) -> Any
extern fn __rt_btreemap_len(handle: i64) -> i64
extern fn __rt_btreemap_clear(handle: i64) -> bool
extern fn __rt_btreemap_keys(handle: i64) -> Any
extern fn __rt_btreemap_values(handle: i64) -> Any
extern fn __rt_btreemap_entries(handle: i64) -> Any
extern fn __rt_btreemap_first_key(handle: i64) -> Any
extern fn __rt_btreemap_last_key(handle: i64) -> Any

# --- BTreeSet extern FFI ---
extern fn __rt_btreeset_new() -> i64
extern fn __rt_btreeset_insert(handle: i64, value: text) -> bool
extern fn __rt_btreeset_contains(handle: i64, value: text) -> bool
extern fn __rt_btreeset_remove(handle: i64, value: text) -> bool
extern fn __rt_btreeset_len(handle: i64) -> i64
extern fn __rt_btreeset_clear(handle: i64) -> bool
extern fn __rt_btreeset_to_array(handle: i64) -> Any
extern fn __rt_btreeset_first(handle: i64) -> Any
extern fn __rt_btreeset_last(handle: i64) -> Any
extern fn __rt_btreeset_union(a: i64, b: i64) -> i64
extern fn __rt_btreeset_intersection(a: i64, b: i64) -> i64
extern fn __rt_btreeset_difference(a: i64, b: i64) -> i64
extern fn __rt_btreeset_symmetric_difference(a: i64, b: i64) -> i64
extern fn __rt_btreeset_is_subset(a: i64, b: i64) -> bool
extern fn __rt_btreeset_is_superset(a: i64, b: i64) -> bool

# --- HashMap wrapper ---

class HashMap:
    _handle: i64

    fn insert(key: text, value: Any) -> bool:
        __rt_hashmap_insert(self._handle, key, value)

    fn get(key: text) -> Any:
        __rt_hashmap_get(self._handle, key)

    fn contains_key(key: text) -> bool:
        __rt_hashmap_contains_key(self._handle, key)

    fn remove(key: text) -> Any:
        __rt_hashmap_remove(self._handle, key)

    fn len() -> i64:
        __rt_hashmap_len(self._handle)

    fn keys() -> Any:
        __rt_hashmap_keys(self._handle)

    fn values() -> Any:
        __rt_hashmap_values(self._handle)

    fn entries() -> Any:
        __rt_hashmap_entries(self._handle)

# --- HashSet wrapper ---

class HashSet:
    _handle: i64

    fn insert(value: text) -> bool:
        __rt_hashset_insert(self._handle, value)

    fn contains(value: text) -> bool:
        __rt_hashset_contains(self._handle, value)

    fn remove(value: text) -> bool:
        __rt_hashset_remove(self._handle, value)

    fn len() -> i64:
        __rt_hashset_len(self._handle)

    fn to_array() -> Any:
        __rt_hashset_to_array(self._handle)

    fn intersection(other: HashSet) -> HashSet:
        val h = __rt_hashset_intersection(self._handle, other._handle)
        HashSet(_handle: h)

    fn difference(other: HashSet) -> HashSet:
        val h = __rt_hashset_difference(self._handle, other._handle)
        HashSet(_handle: h)

    fn symmetric_difference(other: HashSet) -> HashSet:
        val h = __rt_hashset_symmetric_difference(self._handle, other._handle)
        HashSet(_handle: h)

    fn is_subset(other: HashSet) -> bool:
        __rt_hashset_is_subset(self._handle, other._handle)

    fn is_superset(other: HashSet) -> bool:
        __rt_hashset_is_superset(self._handle, other._handle)

    fn drop():
        __rt_hashset_drop(self._handle)

# --- BTreeMap wrapper ---

class BTreeMap:
    _handle: i64

    fn insert(key: text, value: Any) -> bool:
        __rt_btreemap_insert(self._handle, key, value)

    fn get(key: text) -> Any:
        __rt_btreemap_get(self._handle, key)

    fn contains_key(key: text) -> bool:
        __rt_btreemap_contains_key(self._handle, key)

    fn remove(key: text) -> Any:
        __rt_btreemap_remove(self._handle, key)

    fn len() -> i64:
        __rt_btreemap_len(self._handle)

    fn clear() -> bool:
        __rt_btreemap_clear(self._handle)

    fn keys() -> Any:
        __rt_btreemap_keys(self._handle)

    fn values() -> Any:
        __rt_btreemap_values(self._handle)

    fn entries() -> Any:
        __rt_btreemap_entries(self._handle)

    fn first_key() -> Any:
        __rt_btreemap_first_key(self._handle)

    fn last_key() -> Any:
        __rt_btreemap_last_key(self._handle)

# --- BTreeSet wrapper ---

class BTreeSet:
    _handle: i64

    fn insert(value: text) -> bool:
        __rt_btreeset_insert(self._handle, value)

    fn contains(value: text) -> bool:
        __rt_btreeset_contains(self._handle, value)

    fn remove(value: text) -> bool:
        __rt_btreeset_remove(self._handle, value)

    fn len() -> i64:
        __rt_btreeset_len(self._handle)

    fn clear() -> bool:
        __rt_btreeset_clear(self._handle)

    fn to_array() -> Any:
        __rt_btreeset_to_array(self._handle)

    fn first() -> Any:
        __rt_btreeset_first(self._handle)

    fn last() -> Any:
        __rt_btreeset_last(self._handle)

    fn union(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_union(self._handle, other._handle)
        BTreeSet(_handle: h)

    fn intersection(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_intersection(self._handle, other._handle)
        BTreeSet(_handle: h)

    fn difference(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_difference(self._handle, other._handle)
        BTreeSet(_handle: h)

    fn symmetric_difference(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_symmetric_difference(self._handle, other._handle)
        BTreeSet(_handle: h)

    fn is_subset(other: BTreeSet) -> bool:
        __rt_btreeset_is_subset(self._handle, other._handle)

    fn is_superset(other: BTreeSet) -> bool:
        __rt_btreeset_is_superset(self._handle, other._handle)

# --- Factories ---

fn hashmap_new() -> HashMap:
    HashMap(_handle: __rt_hashmap_new())

fn hashset_new() -> HashSet:
    HashSet(_handle: __rt_hashset_new())

fn btreemap_new() -> BTreeMap:
    BTreeMap(_handle: __rt_btreemap_new())

fn btreeset_new() -> BTreeSet:
    BTreeSet(_handle: __rt_btreeset_new())
