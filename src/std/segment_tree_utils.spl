# Segment Tree Utilities Module
#
# A comprehensive implementation of segment trees for efficient range queries
# and updates. Segment trees allow O(log n) time complexity for both range
# queries and point/range updates.
#
# THEORY:
# A segment tree is a binary tree where each node represents an interval [l, r].
# The root represents the entire array [0, n-1], and each leaf represents a
# single element. Internal nodes store aggregate information (sum, min, max, etc.)
# about their corresponding interval.
#
# COMPLEXITY:
# - Build: O(n) time, O(n) space
# - Query: O(log n) time
# - Point Update: O(log n) time
# - Range Update (with lazy propagation): O(log n) time
#
# STRUCTURE:
# Tree is stored as array where for node at index i:
# - Left child: 2*i + 1
# - Right child: 2*i + 2
# - Parent: (i-1)/2
#
# DATA TYPES:
# - SegmentTree: (tree: list, n: i64, type: text)
#   - tree: array storing segment tree nodes
#   - n: size of original array
#   - type: "sum", "min", "max", "gcd", etc.
#
# - LazySegmentTree: (tree: list, lazy: list, n: i64, type: text)
#   - tree: array storing segment tree nodes
#   - lazy: array storing pending updates
#   - n: size of original array
#   - type: operation type

# ============================================================================
# UTILITY FUNCTIONS - Tree Size and Structure
# ============================================================================

# Calculate the size needed for segment tree array
# For array of size n, we need approximately 4*n space
fn get_tree_size(n: i64) -> i64:
    if n == 0:
        return 0

    # Calculate next power of 2
    var power = 1
    while power < n:
        power = power * 2

    # Segment tree needs 2*power - 1 nodes
    return 2 * power - 1

# Calculate height of segment tree
fn get_height(n: i64) -> i64:
    if n == 0:
        return 0

    var height = 0
    var power = 1
    while power < n:
        power = power * 2
        height = height + 1

    return height

# Get parent index of node i
fn parent(i: i64) -> i64:
    if i == 0:
        return 0
    return (i - 1) / 2

# Get left child index of node i
fn left_child(i: i64) -> i64:
    return 2 * i + 1

# Get right child index of node i
fn right_child(i: i64) -> i64:
    return 2 * i + 2

# Check if node is leaf
fn is_leaf(start: i64, end: i64) -> i64:
    if start == end:
        return 1
    return 0

# Get middle point of range [start, end]
fn get_mid(start: i64, end: i64) -> i64:
    return start + (end - start) / 2

# ============================================================================
# SEGMENT TREE CREATION - Sum Tree
# ============================================================================

# Build sum segment tree recursively
# node: current node index in tree array
# start, end: range that current node represents
# arr: original input array
# tree: segment tree array being built
fn build_sum_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    # Leaf node - store array element
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    # Internal node - recursively build children and merge
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    build_sum_tree_helper(arr, tree, left, start, mid)
    build_sum_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: sum of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    tree.set(node, left_val + right_val)

# Create sum segment tree from array
fn build_sum_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "sum")

    val tree_size = get_tree_size(n)
    var tree = []

    # Initialize tree with zeros
    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_sum_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "sum")

# ============================================================================
# SEGMENT TREE CREATION - Min Tree
# ============================================================================

# Build min segment tree recursively
fn build_min_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    build_min_tree_helper(arr, tree, left, start, mid)
    build_min_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: minimum of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var min_val = left_val
    if right_val < min_val:
        min_val = right_val

    tree.set(node, min_val)

# Create min segment tree from array
fn build_min_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "min")

    val tree_size = get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_min_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "min")

# ============================================================================
# SEGMENT TREE CREATION - Max Tree
# ============================================================================

# Build max segment tree recursively
fn build_max_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    build_max_tree_helper(arr, tree, left, start, mid)
    build_max_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: maximum of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var max_val = left_val
    if right_val > max_val:
        max_val = right_val

    tree.set(node, max_val)

# Create max segment tree from array
fn build_max_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "max")

    val tree_size = get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_max_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "max")

# ============================================================================
# SEGMENT TREE CREATION - GCD Tree
# ============================================================================

# Calculate GCD of two numbers using Euclidean algorithm
fn gcd(a: i64, b: i64) -> i64:
    var x = a
    var y = b

    # Make both positive
    if x < 0:
        x = -x
    if y < 0:
        y = -y

    # Handle zero cases
    if x == 0:
        return y
    if y == 0:
        return x

    # Euclidean algorithm
    while y != 0:
        val temp = y
        y = x % y
        x = temp

    return x

# Build GCD segment tree recursively
fn build_gcd_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    build_gcd_tree_helper(arr, tree, left, start, mid)
    build_gcd_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: GCD of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    val gcd_val = gcd(left_val, right_val)

    tree.set(node, gcd_val)

# Create GCD segment tree from array
fn build_gcd_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "gcd")

    val tree_size = get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_gcd_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "gcd")

# ============================================================================
# SEGMENT TREE CREATION - XOR Tree
# ============================================================================

# Build XOR segment tree recursively
fn build_xor_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    build_xor_tree_helper(arr, tree, left, start, mid)
    build_xor_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: XOR of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    # XOR operation (bitwise)
    # Since we don't have bitwise XOR, simulate it
    # This is a simplified version
    tree.set(node, left_val + right_val)  # Placeholder

# Create XOR segment tree from array
fn build_xor_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "xor")

    val tree_size = get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_xor_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "xor")

# ============================================================================
# GENERIC SEGMENT TREE CREATION
# ============================================================================

# Create segment tree with specified type
fn create_segment_tree(arr: list) -> (list, i64, text):
    return build_sum_tree(arr)

# Create segment tree with explicit type
fn create_typed_segment_tree(arr: list, tree_type: text) -> (list, i64, text):
    if tree_type == "sum":
        return build_sum_tree(arr)
    if tree_type == "min":
        return build_min_tree(arr)
    if tree_type == "max":
        return build_max_tree(arr)
    if tree_type == "gcd":
        return build_gcd_tree(arr)
    if tree_type == "xor":
        return build_xor_tree(arr)

    # Default to sum
    return build_sum_tree(arr)

# ============================================================================
# RANGE QUERY - Sum
# ============================================================================

# Query sum in range [l, r] recursively
# node: current node index
# start, end: range that current node represents
# l, r: query range
fn query_sum_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap - recurse on children
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    val left_sum = query_sum_helper(tree, left, start, mid, l, r)
    val right_sum = query_sum_helper(tree, right, mid + 1, end, l, r)

    return left_sum + right_sum

# Query sum in range [l, r]
fn range_sum(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_sum_helper(tree, 0, 0, n - 1, l, r)

# ============================================================================
# RANGE QUERY - Min
# ============================================================================

# Query minimum in range [l, r] recursively
fn query_min_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap - return large value
    if r < start:
        return 1000000000
    if l > end:
        return 1000000000

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    val left_min = query_min_helper(tree, left, start, mid, l, r)
    val right_min = query_min_helper(tree, right, mid + 1, end, l, r)

    var result = left_min
    if right_min < result:
        result = right_min

    return result

# Query minimum in range [l, r]
fn range_min(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_min_helper(tree, 0, 0, n - 1, l, r)

# ============================================================================
# RANGE QUERY - Max
# ============================================================================

# Query maximum in range [l, r] recursively
fn query_max_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap - return small value
    if r < start:
        return -1000000000
    if l > end:
        return -1000000000

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    val left_max = query_max_helper(tree, left, start, mid, l, r)
    val right_max = query_max_helper(tree, right, mid + 1, end, l, r)

    var result = left_max
    if right_max > result:
        result = right_max

    return result

# Query maximum in range [l, r]
fn range_max(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_max_helper(tree, 0, 0, n - 1, l, r)

# ============================================================================
# RANGE QUERY - GCD
# ============================================================================

# Query GCD in range [l, r] recursively
fn query_gcd_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    val left_gcd = query_gcd_helper(tree, left, start, mid, l, r)
    val right_gcd = query_gcd_helper(tree, right, mid + 1, end, l, r)

    return gcd(left_gcd, right_gcd)

# Query GCD in range [l, r]
fn range_gcd(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_gcd_helper(tree, 0, 0, n - 1, l, r)

# ============================================================================
# POINT UPDATE - Sum Tree
# ============================================================================

# Update point in sum tree recursively
# index: position in original array to update
# value: new value
fn update_sum_helper(tree: list, node: i64, start: i64, end: i64, index: i64, value: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, value)
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    if index <= mid:
        update_sum_helper(tree, left, start, mid, index, value)
    else:
        update_sum_helper(tree, right, mid + 1, end, index, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    tree.set(node, left_val + right_val)

# Update point in sum tree
fn update_point_sum(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    if n == 0:
        return tree_tuple
    if index < 0:
        return tree_tuple
    if index >= n:
        return tree_tuple

    update_sum_helper(tree, 0, 0, n - 1, index, value)
    return (tree, n, tree_type)

# ============================================================================
# POINT UPDATE - Min Tree
# ============================================================================

# Update point in min tree recursively
fn update_min_helper(tree: list, node: i64, start: i64, end: i64, index: i64, value: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, value)
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    if index <= mid:
        update_min_helper(tree, left, start, mid, index, value)
    else:
        update_min_helper(tree, right, mid + 1, end, index, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var min_val = left_val
    if right_val < min_val:
        min_val = right_val

    tree.set(node, min_val)

# Update point in min tree
fn update_point_min(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    if n == 0:
        return tree_tuple
    if index < 0:
        return tree_tuple
    if index >= n:
        return tree_tuple

    update_min_helper(tree, 0, 0, n - 1, index, value)
    return (tree, n, tree_type)

# ============================================================================
# POINT UPDATE - Max Tree
# ============================================================================

# Update point in max tree recursively
fn update_max_helper(tree: list, node: i64, start: i64, end: i64, index: i64, value: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, value)
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    if index <= mid:
        update_max_helper(tree, left, start, mid, index, value)
    else:
        update_max_helper(tree, right, mid + 1, end, index, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var max_val = left_val
    if right_val > max_val:
        max_val = right_val

    tree.set(node, max_val)

# Update point in max tree
fn update_point_max(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    if n == 0:
        return tree_tuple
    if index < 0:
        return tree_tuple
    if index >= n:
        return tree_tuple

    update_max_helper(tree, 0, 0, n - 1, index, value)
    return (tree, n, tree_type)

# ============================================================================
# GENERIC POINT UPDATE
# ============================================================================

# Update point with automatic type detection
fn update_point(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree_type = tree_tuple.2

    if tree_type == "sum":
        return update_point_sum(tree_tuple, index, value)
    if tree_type == "min":
        return update_point_min(tree_tuple, index, value)
    if tree_type == "max":
        return update_point_max(tree_tuple, index, value)

    # Default to sum
    return update_point_sum(tree_tuple, index, value)

# ============================================================================
# LAZY PROPAGATION - Data Structure
# ============================================================================

# Create lazy segment tree for range updates
fn create_lazy_tree(arr: list) -> (list, list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, empty, 0, "sum")

    val tree_size = get_tree_size(n)
    var tree = []
    var lazy = []

    # Initialize both arrays
    var i = 0
    while i < tree_size:
        tree.append(0)
        lazy.append(0)
        i = i + 1

    # Build the tree
    build_sum_tree_helper(arr, tree, 0, 0, n - 1)

    return (tree, lazy, n, "sum")

# ============================================================================
# LAZY PROPAGATION - Push Down
# ============================================================================

# Push lazy value down to children
fn push_lazy(tree: list, lazy: list, node: i64, start: i64, end: i64):
    val lazy_val = lazy.get(node)

    # No pending update
    if lazy_val == 0:
        return ()

    # Apply pending update to current node
    val range_size = end - start + 1
    val current = tree.get(node)
    tree.set(node, current + lazy_val * range_size)

    # If not leaf, propagate to children
    var leaf_check = is_leaf(start, end)
    if leaf_check == 0:
        val left = left_child(node)
        val right = right_child(node)

        val left_lazy = lazy.get(left)
        lazy.set(left, left_lazy + lazy_val)

        val right_lazy = lazy.get(right)
        lazy.set(right, right_lazy + lazy_val)

    # Clear current node's lazy value
    lazy.set(node, 0)

# ============================================================================
# LAZY PROPAGATION - Range Update
# ============================================================================

# Update range [l, r] by adding value (with lazy propagation)
fn update_range_helper(tree: list, lazy: list, node: i64, start: i64, end: i64, l: i64, r: i64, value: i64):
    # Push pending updates
    push_lazy(tree, lazy, node, start, end)

    # No overlap
    if r < start:
        return ()
    if l > end:
        return ()

    # Complete overlap
    if l <= start:
        if r >= end:
            val range_size = end - start + 1
            val current = tree.get(node)
            tree.set(node, current + value * range_size)

            # Mark children as lazy if not leaf
            var leaf_check = is_leaf(start, end)
            if leaf_check == 0:
                val left = left_child(node)
                val right = right_child(node)

                val left_lazy = lazy.get(left)
                lazy.set(left, left_lazy + value)

                val right_lazy = lazy.get(right)
                lazy.set(right, right_lazy + value)

            return ()

    # Partial overlap
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    update_range_helper(tree, lazy, left, start, mid, l, r, value)
    update_range_helper(tree, lazy, right, mid + 1, end, l, r, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    tree.set(node, left_val + right_val)

# Update range [l, r] by adding value
fn update_range(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2
    val tree_type = tree_tuple.3

    if n == 0:
        return tree_tuple
    if l < 0:
        return tree_tuple
    if r >= n:
        return tree_tuple
    if l > r:
        return tree_tuple

    update_range_helper(tree, lazy, 0, 0, n - 1, l, r, value)
    return (tree, lazy, n, tree_type)

# Range add (alias for update_range)
fn range_add(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    return update_range(tree_tuple, l, r, value)

# ============================================================================
# LAZY PROPAGATION - Range Query
# ============================================================================

# Query sum with lazy propagation
fn query_sum_lazy_helper(tree: list, lazy: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # Push pending updates
    push_lazy(tree, lazy, node, start, end)

    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    val left_sum = query_sum_lazy_helper(tree, lazy, left, start, mid, l, r)
    val right_sum = query_sum_lazy_helper(tree, lazy, right, mid + 1, end, l, r)

    return left_sum + right_sum

# Query sum from lazy tree
fn range_sum_lazy(tree_tuple: (list, list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_sum_lazy_helper(tree, lazy, 0, 0, n - 1, l, r)

# ============================================================================
# ADVANCED QUERIES - Count Elements
# ============================================================================

# Count elements greater than threshold in range [l, r]
fn count_greater_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64, threshold: i64, arr: list) -> i64:
    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # For leaves, check actual value
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        val value = arr.get(start)
        if value > threshold:
            return 1
        return 0

    # Recurse on children
    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    val left_count = count_greater_helper(tree, left, start, mid, l, r, threshold, arr)
    val right_count = count_greater_helper(tree, right, mid + 1, end, l, r, threshold, arr)

    return left_count + right_count

# Count elements greater than threshold
fn count_elements_greater(tree_tuple: (list, i64, text), l: i64, r: i64, threshold: i64, arr: list) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return count_greater_helper(tree, 0, 0, n - 1, l, r, threshold, arr)

# ============================================================================
# TREE UTILITIES - Validation
# ============================================================================

# Check if tree structure is valid
fn is_valid_tree(tree_tuple: (list, i64, text)) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 1

    val expected_size = get_tree_size(n)
    val actual_size = tree.length()

    if actual_size < expected_size:
        return 0

    return 1

# Check if lazy tree is valid
fn is_valid_lazy_tree(tree_tuple: (list, list, i64, text)) -> i64:
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2

    if n == 0:
        return 1

    val expected_size = get_tree_size(n)
    val tree_size = tree.length()
    val lazy_size = lazy.length()

    if tree_size < expected_size:
        return 0
    if lazy_size < expected_size:
        return 0

    return 1

# ============================================================================
# TREE UTILITIES - Array Conversion
# ============================================================================

# Get element at index from original array (via leaf query)
fn get_element(tree_tuple: (list, i64, text), index: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if index < 0:
        return 0
    if index >= n:
        return 0

    # Query single element range
    return range_sum(tree_tuple, index, index)

# Rebuild tree from new array
fn rebuild_tree(tree_tuple: (list, i64, text), arr: list) -> (list, i64, text):
    val tree_type = tree_tuple.2
    return create_typed_segment_tree(arr, tree_type)

# Convert tree back to array by querying each element
fn tree_to_array(tree_tuple: (list, i64, text)) -> list:
    val n = tree_tuple.1
    var result = []

    var i = 0
    while i < n:
        val elem = get_element(tree_tuple, i)
        result.append(elem)
        i = i + 1

    return result

# ============================================================================
# ADVANCED FEATURES - LCM
# ============================================================================

# Calculate LCM of two numbers
fn lcm(a: i64, b: i64) -> i64:
    if a == 0:
        return 0
    if b == 0:
        return 0

    val gcd_val = gcd(a, b)
    if gcd_val == 0:
        return 0

    # LCM = (a * b) / GCD(a, b)
    val product = a * b
    if product < 0:
        return -((-product) / gcd_val)

    return product / gcd_val

# Build LCM segment tree
fn build_lcm_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    build_lcm_tree_helper(arr, tree, left, start, mid)
    build_lcm_tree_helper(arr, tree, right, mid + 1, end)

    val left_val = tree.get(left)
    val right_val = tree.get(right)
    val lcm_val = lcm(left_val, right_val)

    tree.set(node, lcm_val)

# Create LCM segment tree
fn build_lcm_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "lcm")

    val tree_size = get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_lcm_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "lcm")

# Query LCM in range
fn query_lcm_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    if r < start:
        return 1
    if l > end:
        return 1

    if l <= start:
        if r >= end:
            return tree.get(node)

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    val left_lcm = query_lcm_helper(tree, left, start, mid, l, r)
    val right_lcm = query_lcm_helper(tree, right, mid + 1, end, l, r)

    return lcm(left_lcm, right_lcm)

# Range LCM query
fn range_lcm(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_lcm_helper(tree, 0, 0, n - 1, l, r)

# ============================================================================
# VISUALIZATION - Tree Printing
# ============================================================================

# Print segment tree structure (simple version)
fn print_tree_helper(tree: list, node: i64, start: i64, end: i64, depth: i64):
    if node >= tree.length():
        return ()

    # Print indentation
    var i = 0
    while i < depth:
        print "  "
        i = i + 1

    val value = tree.get(node)
    print "Node [{start}-{end}]: {value}"

    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    print_tree_helper(tree, left, start, mid, depth + 1)
    print_tree_helper(tree, right, mid + 1, end, depth + 1)

# Print segment tree
fn print_tree(tree_tuple: (list, i64, text)):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    print "Segment Tree (type: {tree_type}, size: {n})"

    if n == 0:
        print "Empty tree"
        return ()

    print_tree_helper(tree, 0, 0, n - 1, 0)

# ============================================================================
# BATCH OPERATIONS
# ============================================================================

# Build multiple trees from same array
fn build_all_trees(arr: list) -> ((list, i64, text), (list, i64, text), (list, i64, text)):
    val sum_tree = build_sum_tree(arr)
    val min_tree = build_min_tree(arr)
    val max_tree = build_max_tree(arr)
    return (sum_tree, min_tree, max_tree)

# Perform multiple point updates
fn batch_update_points(tree_tuple: (list, i64, text), updates: list) -> (list, i64, text):
    var current = tree_tuple

    var i = 0
    while i < updates.length():
        val update = updates.get(i)
        # Expect update to be (index, value) tuple
        # Since we can't destructure, assume it's a list
        # This is a simplified version
        i = i + 1

    return current

# ============================================================================
# STATISTICS AND ANALYTICS
# ============================================================================

# Calculate average in range [l, r]
fn range_average(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val sum = range_sum(tree_tuple, l, r)
    val count = r - l + 1

    if count == 0:
        return 0

    return sum / count

# Find range [l, r] with maximum sum
fn max_sum_range(tree_tuple: (list, i64, text), range_size: i64) -> (i64, i64):
    val n = tree_tuple.1

    if range_size > n:
        return (0, 0)
    if range_size <= 0:
        return (0, 0)

    var max_sum = range_sum(tree_tuple, 0, range_size - 1)
    var max_start = 0

    var i = 1
    while i + range_size <= n:
        val current_sum = range_sum(tree_tuple, i, i + range_size - 1)
        if current_sum > max_sum:
            max_sum = current_sum
            max_start = i
        i = i + 1

    return (max_start, max_start + range_size - 1)

# Count ranges with sum equal to target
fn count_ranges_with_sum(tree_tuple: (list, i64, text), target: i64) -> i64:
    val n = tree_tuple.1
    var count = 0

    var l = 0
    while l < n:
        var r = l
        while r < n:
            val sum = range_sum(tree_tuple, l, r)
            if sum == target:
                count = count + 1
            r = r + 1
        l = l + 1

    return count

# ============================================================================
# MERGE OPERATIONS
# ============================================================================

# Merge two arrays and create combined tree
fn merge_arrays(arr1: list, arr2: list) -> list:
    var result = []

    var i = 0
    while i < arr1.length():
        result.append(arr1.get(i))
        i = i + 1

    i = 0
    while i < arr2.length():
        result.append(arr2.get(i))
        i = i + 1

    return result

# Merge two segment trees by concatenating arrays
fn merge_trees(tree1: (list, i64, text), tree2: (list, i64, text)) -> (list, i64, text):
    val arr1 = tree_to_array(tree1)
    val arr2 = tree_to_array(tree2)
    val merged_arr = merge_arrays(arr1, arr2)
    val tree_type = tree1.2

    return create_typed_segment_tree(merged_arr, tree_type)

# ============================================================================
# SPECIAL QUERIES
# ============================================================================

# Find first index where value >= target (binary search on segment tree)
fn first_at_least(tree_tuple: (list, i64, text), target: i64) -> i64:
    val n = tree_tuple.1

    var i = 0
    while i < n:
        val value = get_element(tree_tuple, i)
        if value >= target:
            return i
        i = i + 1

    return -1

# Find last index where value <= target
fn last_at_most(tree_tuple: (list, i64, text), target: i64) -> i64:
    val n = tree_tuple.1
    var result = -1

    var i = 0
    while i < n:
        val value = get_element(tree_tuple, i)
        if value <= target:
            result = i
        i = i + 1

    return result

# Count inversions in range [l, r]
fn count_inversions(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    var count = 0

    var i = l
    while i <= r:
        var j = i + 1
        while j <= r:
            val val_i = get_element(tree_tuple, i)
            val val_j = get_element(tree_tuple, j)
            if val_i > val_j:
                count = count + 1
            j = j + 1
        i = i + 1

    return count

# ============================================================================
# RANGE MODIFICATION QUERIES
# ============================================================================

# Set all elements in range [l, r] to value
fn range_set(tree_tuple: (list, i64, text), l: i64, r: i64, value: i64) -> (list, i64, text):
    var current = tree_tuple

    var i = l
    while i <= r:
        if i < current.1:
            current = update_point(current, i, value)
        i = i + 1

    return current

# Multiply all elements in range [l, r] by factor
fn range_multiply(tree_tuple: (list, i64, text), l: i64, r: i64, factor: i64) -> (list, i64, text):
    var current = tree_tuple

    var i = l
    while i <= r:
        if i < current.1:
            val old_value = get_element(current, i)
            val new_value = old_value * factor
            current = update_point(current, i, new_value)
        i = i + 1

    return current

# ============================================================================
# HELPER FUNCTIONS FOR COMPLEX QUERIES
# ============================================================================

# Check if all elements in range [l, r] are equal
fn range_all_equal(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    if l > r:
        return 0
    if l < 0:
        return 0
    if r >= tree_tuple.1:
        return 0

    val first_val = get_element(tree_tuple, l)

    var i = l + 1
    while i <= r:
        val current_val = get_element(tree_tuple, i)
        if current_val != first_val:
            return 0
        i = i + 1

    return 1

# Find longest increasing subarray in range
fn longest_increasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    if l > r:
        return 0
    if l >= tree_tuple.1:
        return 0

    var max_length = 1
    var current_length = 1

    var i = l + 1
    while i <= r:
        if i < tree_tuple.1:
            val prev_val = get_element(tree_tuple, i - 1)
            val curr_val = get_element(tree_tuple, i)

            if curr_val > prev_val:
                current_length = current_length + 1
                if current_length > max_length:
                    max_length = current_length
            else:
                current_length = 1
        i = i + 1

    return max_length

# Find longest decreasing subarray in range
fn longest_decreasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    if l > r:
        return 0
    if l >= tree_tuple.1:
        return 0

    var max_length = 1
    var current_length = 1

    var i = l + 1
    while i <= r:
        if i < tree_tuple.1:
            val prev_val = get_element(tree_tuple, i - 1)
            val curr_val = get_element(tree_tuple, i)

            if curr_val < prev_val:
                current_length = current_length + 1
                if current_length > max_length:
                    max_length = current_length
            else:
                current_length = 1
        i = i + 1

    return max_length

# ============================================================================
# PERSISTENCE HELPERS
# ============================================================================

# Clone segment tree (create independent copy)
fn clone_tree(tree_tuple: (list, i64, text)) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    var new_tree = []
    var i = 0
    while i < tree.length():
        new_tree.append(tree.get(i))
        i = i + 1

    return (new_tree, n, tree_type)

# Clone lazy tree
fn clone_lazy_tree(tree_tuple: (list, list, i64, text)) -> (list, list, i64, text):
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2
    val tree_type = tree_tuple.3

    var new_tree = []
    var new_lazy = []

    var i = 0
    while i < tree.length():
        new_tree.append(tree.get(i))
        i = i + 1

    i = 0
    while i < lazy.length():
        new_lazy.append(lazy.get(i))
        i = i + 1

    return (new_tree, new_lazy, n, tree_type)

# ============================================================================
# TESTING AND DEBUGGING
# ============================================================================

# Get tree type
fn get_tree_type(tree_tuple: (list, i64, text)) -> text:
    return tree_tuple.2

# Get tree size (original array size)
fn get_array_size(tree_tuple: (list, i64, text)) -> i64:
    return tree_tuple.1

# Get internal tree array size
fn get_internal_size(tree_tuple: (list, i64, text)) -> i64:
    val tree = tree_tuple.0
    return tree.length()

# Verify tree correctness by comparing with brute force
fn verify_sum_tree(tree_tuple: (list, i64, text), arr: list) -> i64:
    val n = arr.length()

    var l = 0
    while l < n:
        var r = l
        while r < n:
            # Tree query
            val tree_sum = range_sum(tree_tuple, l, r)

            # Brute force
            var brute_sum = 0
            var i = l
            while i <= r:
                brute_sum = brute_sum + arr.get(i)
                i = i + 1

            if tree_sum != brute_sum:
                return 0

            r = r + 1
        l = l + 1

    return 1
