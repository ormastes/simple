# Segment Tree Utilities Module - Facade Pattern
#
# A comprehensive implementation of segment trees for efficient range queries
# and updates. Segment trees allow O(log n) time complexity for both range
# queries and point/range updates.
#
# THEORY:
# A segment tree is a binary tree where each node represents an interval [l, r].
# The root represents the entire array [0, n-1], and each leaf represents a
# single element. Internal nodes store aggregate information (sum, min, max, etc.)
# about their corresponding interval.
#
# COMPLEXITY:
# - Build: O(n) time, O(n) space
# - Query: O(log n) time
# - Point Update: O(log n) time
# - Range Update (with lazy propagation): O(log n) time
#
# STRUCTURE:
# Tree is stored as array where for node at index i:
# - Left child: 2*i + 1
# - Right child: 2*i + 2
# - Parent: (i-1)/2
#
# DATA TYPES:
# - SegmentTree: (tree: list, n: i64, type: text)
#   - tree: array storing segment tree nodes
#   - n: size of original array
#   - type: "sum", "min", "max", "gcd", etc.
#
# - LazySegmentTree: (tree: list, lazy: list, n: i64, type: text)
#   - tree: array storing segment tree nodes
#   - lazy: array storing pending updates
#   - n: size of original array
#   - type: operation type
#
# REFACTORED STRUCTURE:
# This module now uses the facade pattern. Implementation is split into:
# - segment_tree/types: Type definitions
# - segment_tree/utilities: Helper functions
# - segment_tree/build: Tree construction
# - segment_tree/query: Range queries
# - segment_tree/update: Point updates
# - segment_tree/range_ops: Advanced range operations
# - segment_tree/lazy: Lazy propagation

# Import facade module
import std.segment_tree.mod

# Re-export all functions from the facade

# Type functions
fn get_tree_type(tree_tuple: (list, i64, text)) -> text:
    return mod.get_tree_type(tree_tuple)

fn get_array_size(tree_tuple: (list, i64, text)) -> i64:
    return mod.get_array_size(tree_tuple)

fn get_internal_size(tree_tuple: (list, i64, text)) -> i64:
    return mod.get_internal_size(tree_tuple)

# Utility functions
fn get_tree_size(n: i64) -> i64:
    return mod.get_tree_size(n)

fn get_height(n: i64) -> i64:
    return mod.get_height(n)

fn parent(i: i64) -> i64:
    return mod.parent(i)

fn left_child(i: i64) -> i64:
    return mod.left_child(i)

fn right_child(i: i64) -> i64:
    return mod.right_child(i)

fn is_leaf(start: i64, end: i64) -> i64:
    return mod.is_leaf(start, end)

fn get_mid(start: i64, end: i64) -> i64:
    return mod.get_mid(start, end)

fn gcd(a: i64, b: i64) -> i64:
    return mod.gcd(a, b)

fn lcm(a: i64, b: i64) -> i64:
    return mod.lcm(a, b)

fn is_valid_tree(tree_tuple: (list, i64, text)) -> i64:
    return mod.is_valid_tree(tree_tuple)

fn is_valid_lazy_tree(tree_tuple: (list, list, i64, text)) -> i64:
    return mod.is_valid_lazy_tree(tree_tuple)

fn merge_arrays(arr1: list, arr2: list) -> list:
    return mod.merge_arrays(arr1, arr2)

fn clone_tree(tree_tuple: (list, i64, text)) -> (list, i64, text):
    return mod.clone_tree(tree_tuple)

fn clone_lazy_tree(tree_tuple: (list, list, i64, text)) -> (list, list, i64, text):
    return mod.clone_lazy_tree(tree_tuple)

fn print_tree(tree_tuple: (list, i64, text)):
    return mod.print_tree(tree_tuple)

# Build functions
fn build_sum_tree(arr: list) -> (list, i64, text):
    return mod.build_sum_tree(arr)

fn build_min_tree(arr: list) -> (list, i64, text):
    return mod.build_min_tree(arr)

fn build_max_tree(arr: list) -> (list, i64, text):
    return mod.build_max_tree(arr)

fn build_gcd_tree(arr: list) -> (list, i64, text):
    return mod.build_gcd_tree(arr)

fn build_xor_tree(arr: list) -> (list, i64, text):
    return mod.build_xor_tree(arr)

fn build_lcm_tree(arr: list) -> (list, i64, text):
    return mod.build_lcm_tree(arr)

fn create_segment_tree(arr: list) -> (list, i64, text):
    return mod.create_segment_tree(arr)

fn create_typed_segment_tree(arr: list, tree_type: text) -> (list, i64, text):
    return mod.create_typed_segment_tree(arr, tree_type)

fn rebuild_tree(tree_tuple: (list, i64, text), arr: list) -> (list, i64, text):
    return mod.rebuild_tree(tree_tuple, arr)

fn build_all_trees(arr: list) -> ((list, i64, text), (list, i64, text), (list, i64, text)):
    return mod.build_all_trees(arr)

fn merge_trees(tree1: (list, i64, text), tree2: (list, i64, text)) -> (list, i64, text):
    return mod.merge_trees(tree1, tree2)

# Query functions
fn range_sum(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_sum(tree_tuple, l, r)

fn range_min(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_min(tree_tuple, l, r)

fn range_max(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_max(tree_tuple, l, r)

fn range_gcd(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_gcd(tree_tuple, l, r)

fn range_lcm(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_lcm(tree_tuple, l, r)

fn range_average(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_average(tree_tuple, l, r)

fn get_element(tree_tuple: (list, i64, text), index: i64) -> i64:
    return mod.get_element(tree_tuple, index)

fn tree_to_array(tree_tuple: (list, i64, text)) -> list:
    return mod.tree_to_array(tree_tuple)

fn verify_sum_tree(tree_tuple: (list, i64, text), arr: list) -> i64:
    return mod.verify_sum_tree(tree_tuple, arr)

fn count_elements_greater(tree_tuple: (list, i64, text), l: i64, r: i64, threshold: i64, arr: list) -> i64:
    return mod.count_elements_greater(tree_tuple, l, r, threshold, arr)

fn first_at_least(tree_tuple: (list, i64, text), target: i64) -> i64:
    return mod.first_at_least(tree_tuple, target)

fn last_at_most(tree_tuple: (list, i64, text), target: i64) -> i64:
    return mod.last_at_most(tree_tuple, target)

fn range_all_equal(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_all_equal(tree_tuple, l, r)

fn longest_increasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.longest_increasing(tree_tuple, l, r)

fn longest_decreasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.longest_decreasing(tree_tuple, l, r)

# Update functions
fn update_point_sum(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return mod.update_point_sum(tree_tuple, index, value)

fn update_point_min(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return mod.update_point_min(tree_tuple, index, value)

fn update_point_max(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return mod.update_point_max(tree_tuple, index, value)

fn update_point(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return mod.update_point(tree_tuple, index, value)

fn batch_update_points(tree_tuple: (list, i64, text), updates: list) -> (list, i64, text):
    return mod.batch_update_points(tree_tuple, updates)

# Range operations
fn max_sum_range(tree_tuple: (list, i64, text), range_size: i64) -> (i64, i64):
    return mod.max_sum_range(tree_tuple, range_size)

fn count_ranges_with_sum(tree_tuple: (list, i64, text), target: i64) -> i64:
    return mod.count_ranges_with_sum(tree_tuple, target)

fn range_set(tree_tuple: (list, i64, text), l: i64, r: i64, value: i64) -> (list, i64, text):
    return mod.range_set(tree_tuple, l, r, value)

fn range_multiply(tree_tuple: (list, i64, text), l: i64, r: i64, factor: i64) -> (list, i64, text):
    return mod.range_multiply(tree_tuple, l, r, factor)

fn count_inversions(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return mod.count_inversions(tree_tuple, l, r)

# Lazy propagation
fn create_lazy_tree(arr: list) -> (list, list, i64, text):
    return mod.create_lazy_tree(arr)

fn update_range(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    return mod.update_range(tree_tuple, l, r, value)

fn range_add(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    return mod.range_add(tree_tuple, l, r, value)

fn range_sum_lazy(tree_tuple: (list, list, i64, text), l: i64, r: i64) -> i64:
    return mod.range_sum_lazy(tree_tuple, l, r)
