# Linear Algebra - Eigenvalues and Eigenvectors
#
# Computing eigenvalues and eigenvectors using iterative methods.

from .types import LA_EPSILON

# ============================================================================
# Eigenvalues and Eigenvectors
# ============================================================================

fn la_power_iteration(matrix: [[f64]], max_iter: i64) -> (f64, [f64])?:
    """Find dominant eigenvalue and eigenvector using power iteration."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    var v = []
    var i = 0
    while i < n:
        v.push(1.0)
        i = i + 1
    var iteration = 0
    while iteration < max_iter:
        val mv = la_matrix_vector_multiply(matrix, v)
        if not mv.?:
            return nil
        val norm = la_vector_magnitude(mv)
        if not norm.?:
            return nil
        if norm < LA_EPSILON:
            return nil
        val v_new = la_vector_scalar_multiply(mv, 1.0 / norm)
        v = v_new
        iteration = iteration + 1
    val mv_final = la_matrix_vector_multiply(matrix, v)
    if not mv_final.?:
        return nil
    val eigenvalue = la_vector_dot(mv_final, v)
    if not eigenvalue.?:
        return nil
    (eigenvalue, v)

fn la_inverse_power_iteration(matrix: [[f64]], max_iter: i64) -> (f64, [f64])?:
    """Find smallest eigenvalue using inverse power iteration."""
    val inv = la_matrix_inverse(matrix)
    if not inv.?:
        return nil
    val result = la_power_iteration(inv, max_iter)
    if not result.?:
        return nil
    val inv_eigenvalue = result[0]
    val eigenvector = result[1]
    val eigenvalue = 1.0 / inv_eigenvalue
    (eigenvalue, eigenvector)

fn la_qr_algorithm(matrix: [[f64]], max_iter: i64) -> [f64]?:
    """Estimate eigenvalues using QR algorithm.

    Returns approximate eigenvalues (diagonal of final matrix).
    """
    if not la_matrix_is_square(matrix):
        return nil
    var a = matrix
    var iteration = 0
    while iteration < max_iter:
        val qr = la_matrix_qr_decomposition(a)
        if not qr.?:
            return nil
        val q = qr[0]
        val r = qr[1]
        val rq = la_matrix_multiply(r, q)
        if not rq.?:
            return nil
        a = rq
        iteration = iteration + 1
    la_matrix_diagonal_elements(a)

fn la_eigenvalue_estimate(matrix: [[f64]]) -> [f64]?:
    """Estimate eigenvalues using QR algorithm with 100 iterations."""
    la_qr_algorithm(matrix, 100)

# Helper functions needed from other modules
fn la_matrix_is_square(matrix: [[f64]]) -> bool:
    """Check if matrix is square."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    rows == cols and rows > 0

fn la_matrix_dimensions(matrix: [[f64]]) -> (i64, i64):
    """Get matrix dimensions (rows, cols)."""
    if matrix.len() == 0:
        return (0, 0)
    (matrix.len(), matrix[0].len())

fn la_matrix_vector_multiply(matrix: [[f64]], vector: [f64]) -> [f64]?:
    """Multiply matrix by column vector."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if cols != vector.len():
        return nil
    var result = []
    var i = 0
    while i < rows:
        var sum = 0.0
        var j = 0
        while j < cols:
            sum = sum + matrix[i][j] * vector[j]
            j = j + 1
        result.push(sum)
        i = i + 1
    result

fn la_vector_magnitude(v: [f64]) -> f64?:
    """Calculate magnitude (L2 norm) of vector."""
    val dot = la_vector_dot(v, v)
    if not dot.?:
        return nil
    var sqrt_val = dot
    var iteration = 0
    while iteration < 20:
        if sqrt_val == 0.0:
            return 0.0
        sqrt_val = (sqrt_val + dot / sqrt_val) / 2.0
        iteration = iteration + 1
    sqrt_val

fn la_vector_dot(v1: [f64], v2: [f64]) -> f64?:
    """Calculate dot product of two vectors."""
    if v1.len() != v2.len():
        return nil
    var sum = 0.0
    var i = 0
    while i < v1.len():
        sum = sum + v1[i] * v2[i]
        i = i + 1
    sum

fn la_vector_scalar_multiply(v: [f64], scalar: f64) -> [f64]:
    """Multiply vector by scalar."""
    var result = []
    for elem in v:
        result.push(elem * scalar)
    result

fn la_matrix_inverse(matrix: [[f64]]) -> [[f64]]?:
    """Calculate matrix inverse."""
    # Forward declaration - implementation in matrix_ops
    nil

fn la_matrix_qr_decomposition(matrix: [[f64]]) -> ([[f64]], [[f64]])?:
    """QR decomposition."""
    # Forward declaration - implementation in decomposition
    nil

fn la_matrix_multiply(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Matrix multiplication."""
    # Forward declaration - implementation in matrix_ops
    nil

fn la_matrix_diagonal_elements(matrix: [[f64]]) -> [f64]?:
    """Get diagonal elements."""
    # Forward declaration - implementation in matrix_ops
    nil

# ============================================================================
# Exports
# ============================================================================

# Eigenvalues/Eigenvectors (4 functions)
export la_power_iteration, la_inverse_power_iteration
export la_qr_algorithm, la_eigenvalue_estimate
