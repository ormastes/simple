# Linear Algebra - Matrix Operations
#
# Matrix creation, access, properties, arithmetic, and transformations.

from .types import LA_EPSILON

# ============================================================================
# Matrix Creation
# ============================================================================

fn la_matrix_create(rows: i64, cols: i64, fill_value: f64) -> [[f64]]:
    """Create matrix filled with specified value.

    Example:
        la_matrix_create(3, 3, 0.0)  # 3x3 zero matrix
    """
    var matrix = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            row.push(fill_value)
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

fn la_matrix_zero(rows: i64, cols: i64) -> [[f64]]:
    """Create zero matrix.

    Example:
        la_matrix_zero(2, 3)  # [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
    """
    la_matrix_create(rows, cols, 0.0)

fn la_matrix_ones(rows: i64, cols: i64) -> [[f64]]:
    """Create matrix filled with ones.

    Example:
        la_matrix_ones(2, 2)  # [[1.0, 1.0], [1.0, 1.0]]
    """
    la_matrix_create(rows, cols, 1.0)

fn la_matrix_identity(n: i64) -> [[f64]]:
    """Create n√ón identity matrix.

    Example:
        la_matrix_identity(3)
        # [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
    """
    var matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        matrix[i][i] = 1.0
        i = i + 1
    matrix

fn la_matrix_diagonal(values: [f64]) -> [[f64]]:
    """Create diagonal matrix from values.

    Example:
        la_matrix_diagonal([1.0, 2.0, 3.0])
        # [[1.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 3.0]]
    """
    val n = values.len()
    var matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        matrix[i][i] = values[i]
        i = i + 1
    matrix

fn la_matrix_from_rows(rows: [[f64]]) -> [[f64]]:
    """Create matrix from array of row arrays.

    Example:
        la_matrix_from_rows([[1.0, 2.0], [3.0, 4.0]])
    """
    rows

fn la_matrix_from_columns(cols: [[f64]]) -> [[f64]]:
    """Create matrix from array of column arrays.

    Example:
        la_matrix_from_columns([[1.0, 3.0], [2.0, 4.0]])  # [[1.0, 2.0], [3.0, 4.0]]
    """
    if cols.len() == 0:
        return []
    val rows = cols[0].len()
    val columns = cols.len()
    var matrix = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < columns:
            row.push(cols[j][i])
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

fn la_matrix_symmetric(values: [[f64]]) -> [[f64]]:
    """Create symmetric matrix from upper triangular values.

    Example:
        la_matrix_symmetric([[1.0, 2.0], [3.0]])
        # [[1.0, 2.0], [2.0, 3.0]]
    """
    val n = values.len()
    var matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        var j = i
        while j < n:
            val val_val = values[i][j - i]
            matrix[i][j] = val_val
            matrix[j][i] = val_val
            j = j + 1
        i = i + 1
    matrix

fn la_matrix_random(rows: i64, cols: i64, seed: i64) -> [[f64]]:
    """Create matrix with pseudo-random values between 0.0 and 1.0.

    Simple LCG random number generator.
    """
    var matrix = []
    var rng_state = seed
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            rng_state = (rng_state * 1103515245 + 12345) % 2147483648
            val rand_val = (rng_state % 10000) / 10000.0
            row.push(rand_val)
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

# ============================================================================
# Matrix Access
# ============================================================================

fn la_matrix_dimensions(matrix: [[f64]]) -> (i64, i64):
    """Get matrix dimensions (rows, cols).

    Example:
        la_matrix_dimensions([[1.0, 2.0], [3.0, 4.0]])  # (2, 2)
    """
    if matrix.len() == 0:
        return (0, 0)
    (matrix.len(), matrix[0].len())

fn la_matrix_shape(matrix: [[f64]]) -> (i64, i64):
    """Alias for la_matrix_dimensions."""
    la_matrix_dimensions(matrix)

fn la_matrix_get(matrix: [[f64]], row: i64, col: i64) -> f64?:
    """Get element at position. Returns nil if out of bounds."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if row < 0 or row >= rows:
        return nil
    if col < 0 or col >= cols:
        return nil
    matrix[row][col]

fn la_matrix_set(matrix: [[f64]], row: i64, col: i64, value: f64) -> [[f64]]?:
    """Set element at position. Returns new matrix or nil if out of bounds."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if row < 0 or row >= rows:
        return nil
    if col < 0 or col >= cols:
        return nil
    var result = la_matrix_copy(matrix)
    result[row][col] = value
    result

fn la_matrix_get_row(matrix: [[f64]], row: i64) -> [f64]?:
    """Get row as array."""
    if row < 0 or row >= matrix.len():
        return nil
    matrix[row]

fn la_matrix_get_column(matrix: [[f64]], col: i64) -> [f64]?:
    """Get column as array."""
    if matrix.len() == 0:
        return nil
    if col < 0 or col >= matrix[0].len():
        return nil
    var column = []
    for row in matrix:
        column.push(row[col])
    column

fn la_matrix_diagonal_elements(matrix: [[f64]]) -> [f64]?:
    """Get main diagonal as array."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if rows != cols:
        return nil
    var diagonal = []
    var i = 0
    while i < rows:
        diagonal.push(matrix[i][i])
        i = i + 1
    diagonal

# ============================================================================
# Matrix Properties
# ============================================================================

fn la_matrix_is_square(matrix: [[f64]]) -> bool:
    """Check if matrix is square."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    rows == cols and rows > 0

fn la_matrix_is_symmetric(matrix: [[f64]]) -> bool:
    """Check if matrix is symmetric (M = M^T)."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = i + 1
        while j < n:
            val diff = matrix[i][j] - matrix[j][i]
            var abs_diff = diff
            if abs_diff < 0.0:
                abs_diff = -abs_diff
            if abs_diff > LA_EPSILON:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_diagonal(matrix: [[f64]]) -> bool:
    """Check if matrix is diagonal."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = 0
        while j < n:
            if i != j:
                var abs_val = matrix[i][j]
                if abs_val < 0.0:
                    abs_val = -abs_val
                if abs_val > LA_EPSILON:
                    return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_upper_triangular(matrix: [[f64]]) -> bool:
    """Check if matrix is upper triangular."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = 0
        while j < i:
            var abs_val = matrix[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_lower_triangular(matrix: [[f64]]) -> bool:
    """Check if matrix is lower triangular."""
    if not la_matrix_is_square(matrix):
        return false
    val n = matrix.len()
    var i = 0
    while i < n:
        var j = i + 1
        while j < n:
            var abs_val = matrix[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_orthogonal(matrix: [[f64]]) -> bool:
    """Check if matrix is orthogonal (M^T * M = I)."""
    if not la_matrix_is_square(matrix):
        return false
    val transpose_m = la_matrix_transpose(matrix)
    val product = la_matrix_multiply(transpose_m, matrix)
    if not product.?:
        return false
    val identity = la_matrix_identity(matrix.len())
    la_matrix_is_close(product, identity, LA_EPSILON)

fn la_matrix_trace(matrix: [[f64]]) -> f64?:
    """Calculate trace (sum of diagonal elements)."""
    if not la_matrix_is_square(matrix):
        return nil
    var sum = 0.0
    var i = 0
    while i < matrix.len():
        sum = sum + matrix[i][i]
        i = i + 1
    sum

fn la_matrix_rank(matrix: [[f64]]) -> i64:
    """Calculate rank using row reduction.

    Returns number of non-zero rows in RREF.
    """
    val rref = la_matrix_rref(matrix)
    if not rref.?:
        return 0
    var rank = 0
    for row in rref:
        var is_zero_row = true
        for elem in row:
            var abs_elem = elem
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            if abs_elem > LA_EPSILON:
                is_zero_row = false
        if not is_zero_row:
            rank = rank + 1
    rank

fn la_matrix_condition_number(matrix: [[f64]]) -> f64?:
    """Estimate condition number (ratio of largest to smallest singular value).

    Simplified estimate using norm of matrix and its inverse.
    """
    val inv = la_matrix_inverse(matrix)
    if not inv.?:
        return nil
    val norm_m = la_matrix_norm_frobenius(matrix)
    val norm_inv = la_matrix_norm_frobenius(inv)
    norm_m * norm_inv

# ============================================================================
# Matrix Arithmetic
# ============================================================================

fn la_matrix_add(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Add two matrices element-wise."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] + m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_subtract(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Subtract two matrices element-wise."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] - m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_multiply(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Multiply two matrices (standard matrix multiplication)."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if cols1 != rows2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols2:
            var sum = 0.0
            var k = 0
            while k < cols1:
                sum = sum + (m1[i][k] * m2[k][j])
                k = k + 1
            row.push(sum)
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_scalar_multiply(matrix: [[f64]], scalar: f64) -> [[f64]]:
    """Multiply matrix by scalar."""
    var result = []
    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem * scalar)
        result.push(new_row)
    result

fn la_matrix_element_multiply(m1: [[f64]], m2: [[f64]]) -> [[f64]]?:
    """Element-wise multiplication (Hadamard product)."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return nil
    var result = []
    var i = 0
    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] * m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1
    result

fn la_matrix_negate(matrix: [[f64]]) -> [[f64]]:
    """Negate all elements in matrix."""
    la_matrix_scalar_multiply(matrix, -1.0)

fn la_matrix_power(matrix: [[f64]], n: i64) -> [[f64]]?:
    """Raise square matrix to power n."""
    if not la_matrix_is_square(matrix):
        return nil
    if n == 0:
        return la_matrix_identity(matrix.len())
    if n == 1:
        return matrix
    if n < 0:
        val inv = la_matrix_inverse(matrix)
        if not inv.?:
            return nil
        return la_matrix_power(inv, -n)
    var result = matrix
    var i = 1
    while i < n:
        val temp = la_matrix_multiply(result, matrix)
        if not temp.?:
            return nil
        result = temp
        i = i + 1
    result

# ============================================================================
# Matrix Transformations
# ============================================================================

fn la_matrix_transpose(matrix: [[f64]]) -> [[f64]]:
    """Transpose matrix (swap rows and columns)."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if rows == 0 or cols == 0:
        return []
    var result = []
    var j = 0
    while j < cols:
        var column = []
        var i = 0
        while i < rows:
            column.push(matrix[i][j])
            i = i + 1
        result.push(column)
        j = j + 1
    result

fn la_matrix_conjugate_transpose(matrix: [[f64]]) -> [[f64]]:
    """Conjugate transpose (for real matrices, same as transpose)."""
    la_matrix_transpose(matrix)

fn la_matrix_minor(matrix: [[f64]], exclude_row: i64, exclude_col: i64) -> [[f64]]:
    """Get minor (matrix with row and column removed)."""
    var result = []
    var i = 0
    while i < matrix.len():
        if i != exclude_row:
            var row = []
            var j = 0
            while j < matrix[0].len():
                if j != exclude_col:
                    row.push(matrix[i][j])
                j = j + 1
            result.push(row)
        i = i + 1
    result

fn la_matrix_cofactor(matrix: [[f64]], row: i64, col: i64) -> f64?:
    """Calculate cofactor of element at (row, col)."""
    val minor_mat = la_matrix_minor(matrix, row, col)
    val det = la_matrix_determinant(minor_mat)
    if not det.?:
        return nil
    val sign = if (row + col) % 2 == 0: 1.0 else: -1.0
    sign * det

fn la_matrix_adjugate(matrix: [[f64]]) -> [[f64]]?:
    """Calculate adjugate matrix (transpose of cofactor matrix)."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    var cofactor_matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        var j = 0
        while j < n:
            val cof = la_matrix_cofactor(matrix, i, j)
            if not cof.?:
                return nil
            cofactor_matrix[i][j] = cof
            j = j + 1
        i = i + 1
    la_matrix_transpose(cofactor_matrix)

fn la_matrix_inverse(matrix: [[f64]]) -> [[f64]]?:
    """Calculate matrix inverse using Gauss-Jordan elimination."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    var augmented = []
    var i = 0
    while i < n:
        var row = []
        var j = 0
        while j < n:
            row.push(matrix[i][j])
            j = j + 1
        j = 0
        while j < n:
            val id_val = if i == j: 1.0 else: 0.0
            row.push(id_val)
            j = j + 1
        augmented.push(row)
        i = i + 1
    val rref = la_matrix_rref(augmented)
    if not rref.?:
        return nil
    i = 0
    while i < n:
        var abs_pivot = rref[i][i]
        if abs_pivot < 0.0:
            abs_pivot = -abs_pivot
        if abs_pivot < LA_EPSILON:
            return nil
        i = i + 1
    var inverse = []
    i = 0
    while i < n:
        var row = []
        var j = n
        while j < 2 * n:
            row.push(rref[i][j])
            j = j + 1
        inverse.push(row)
        i = i + 1
    inverse

# ============================================================================
# Matrix Determinant
# ============================================================================

fn la_matrix_determinant(matrix: [[f64]]) -> f64?:
    """Calculate determinant of square matrix using LU decomposition."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    if n == 1:
        return matrix[0][0]
    if n == 2:
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
    val lu_result = la_matrix_lu_decomposition(matrix)
    if not lu_result.?:
        return nil
    val lower = lu_result[0]
    val upper = lu_result[1]
    val parity = lu_result[2]
    var det = parity
    var i = 0
    while i < n:
        det = det * upper[i][i]
        i = i + 1
    det

# ============================================================================
# Matrix Row Operations and Reduction
# ============================================================================

fn la_matrix_row_reduce(matrix: [[f64]]) -> [[f64]]:
    """Row reduce to row echelon form (REF)."""
    la_matrix_ref(matrix)

fn la_matrix_ref(matrix: [[f64]]) -> [[f64]]:
    """Convert to row echelon form."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var result = la_matrix_copy(matrix)
    var pivot_row = 0
    var pivot_col = 0
    while pivot_row < rows and pivot_col < cols:
        var max_row = pivot_row
        var max_val = result[pivot_row][pivot_col]
        if max_val < 0.0:
            max_val = -max_val
        var i = pivot_row + 1
        while i < rows:
            var abs_val = result[i][pivot_col]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > max_val:
                max_val = abs_val
                max_row = i
            i = i + 1
        if max_val < LA_EPSILON:
            pivot_col = pivot_col + 1
        else:
            if max_row != pivot_row:
                val temp_row = result[pivot_row]
                result[pivot_row] = result[max_row]
                result[max_row] = temp_row
            i = pivot_row + 1
            while i < rows:
                val factor = result[i][pivot_col] / result[pivot_row][pivot_col]
                result[i][pivot_col] = 0.0
                var j = pivot_col + 1
                while j < cols:
                    result[i][j] = result[i][j] - factor * result[pivot_row][j]
                    j = j + 1
                i = i + 1
            pivot_row = pivot_row + 1
            pivot_col = pivot_col + 1
    result

fn la_matrix_rref(matrix: [[f64]]) -> [[f64]]:
    """Convert to reduced row echelon form."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var result = la_matrix_ref(matrix)
    var i = rows - 1
    while i >= 0:
        var pivot_col = -1
        var j = 0
        while j < cols:
            var abs_val = result[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                pivot_col = j
                j = cols
            j = j + 1
        if pivot_col >= 0:
            val pivot_val = result[i][pivot_col]
            j = 0
            while j < cols:
                result[i][j] = result[i][j] / pivot_val
                j = j + 1
            var k = 0
            while k < i:
                val factor = result[k][pivot_col]
                j = 0
                while j < cols:
                    result[k][j] = result[k][j] - factor * result[i][j]
                    j = j + 1
                k = k + 1
        i = i - 1
    result

# ============================================================================
# Matrix Norms
# ============================================================================

fn la_matrix_norm_frobenius(matrix: [[f64]]) -> f64:
    """Calculate Frobenius norm (square root of sum of squared elements)."""
    var sum = 0.0
    for row in matrix:
        for elem in row:
            sum = sum + elem * elem
    var sqrt_val = sum
    var iteration = 0
    while iteration < 20:
        if sqrt_val == 0.0:
            return 0.0
        sqrt_val = (sqrt_val + sum / sqrt_val) / 2.0
        iteration = iteration + 1
    sqrt_val

fn la_matrix_norm_l1(matrix: [[f64]]) -> f64:
    """Calculate L1 norm (maximum absolute column sum)."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var max_sum = 0.0
    var j = 0
    while j < cols:
        var col_sum = 0.0
        var i = 0
        while i < rows:
            var abs_elem = matrix[i][j]
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            col_sum = col_sum + abs_elem
            i = i + 1
        if col_sum > max_sum:
            max_sum = col_sum
        j = j + 1
    max_sum

fn la_matrix_norm_inf(matrix: [[f64]]) -> f64:
    """Calculate infinity norm (maximum absolute row sum)."""
    var max_sum = 0.0
    for row in matrix:
        var row_sum = 0.0
        for elem in row:
            var abs_elem = elem
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            row_sum = row_sum + abs_elem
        if row_sum > max_sum:
            max_sum = row_sum
    max_sum

# ============================================================================
# Matrix-Vector Operations
# ============================================================================

fn la_matrix_vector_multiply(matrix: [[f64]], vector: [f64]) -> [f64]?:
    """Multiply matrix by column vector."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if cols != vector.len():
        return nil
    var result = []
    var i = 0
    while i < rows:
        var sum = 0.0
        var j = 0
        while j < cols:
            sum = sum + matrix[i][j] * vector[j]
            j = j + 1
        result.push(sum)
        i = i + 1
    result

# ============================================================================
# Utility Functions
# ============================================================================

fn la_matrix_copy(matrix: [[f64]]) -> [[f64]]:
    """Create deep copy of matrix."""
    var result = []
    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem)
        result.push(new_row)
    result

fn la_matrix_fill(matrix: [[f64]], value: f64) -> [[f64]]:
    """Fill all elements of matrix with value."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    la_matrix_create(rows, cols, value)

fn la_matrix_equals(m1: [[f64]], m2: [[f64]]) -> bool:
    """Check if two matrices are exactly equal."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return false
    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            if m1[i][j] != m2[i][j]:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_close(m1: [[f64]], m2: [[f64]], tolerance: f64) -> bool:
    """Check if two matrices are approximately equal within tolerance."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return false
    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            val diff = m1[i][j] - m2[i][j]
            var abs_diff = diff
            if abs_diff < 0.0:
                abs_diff = -abs_diff
            if abs_diff > tolerance:
                return false
            j = j + 1
        i = i + 1
    true

# ============================================================================
# Exports
# ============================================================================

# Matrix Creation (9 functions)
export la_matrix_create, la_matrix_zero, la_matrix_ones, la_matrix_identity
export la_matrix_diagonal, la_matrix_from_rows, la_matrix_from_columns
export la_matrix_symmetric, la_matrix_random

# Matrix Access (7 functions)
export la_matrix_get, la_matrix_set, la_matrix_get_row, la_matrix_get_column
export la_matrix_dimensions, la_matrix_shape, la_matrix_diagonal_elements

# Matrix Properties (11 functions)
export la_matrix_is_square, la_matrix_is_symmetric, la_matrix_is_diagonal
export la_matrix_is_orthogonal, la_matrix_is_upper_triangular, la_matrix_is_lower_triangular
export la_matrix_trace, la_matrix_rank, la_matrix_condition_number

# Matrix Arithmetic (7 functions)
export la_matrix_add, la_matrix_subtract, la_matrix_multiply
export la_matrix_scalar_multiply, la_matrix_element_multiply
export la_matrix_negate, la_matrix_power

# Matrix Transformations (7 functions)
export la_matrix_transpose, la_matrix_conjugate_transpose, la_matrix_inverse
export la_matrix_minor, la_matrix_cofactor, la_matrix_adjugate

# Matrix Operations (4 functions)
export la_matrix_determinant, la_matrix_row_reduce, la_matrix_ref, la_matrix_rref

# Matrix Norms (3 functions)
export la_matrix_norm_frobenius, la_matrix_norm_l1, la_matrix_norm_inf

# Matrix-Vector Operations (1 function)
export la_matrix_vector_multiply

# Utility (4 functions)
export la_matrix_copy, la_matrix_fill, la_matrix_equals, la_matrix_is_close
