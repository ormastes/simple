# Linear Algebra - System Solving
#
# Solving linear systems Ax = b using various methods.

from .types import LA_EPSILON
from .matrix_ops import la_matrix_dimensions, la_matrix_rref, la_matrix_transpose
from .matrix_ops import la_matrix_multiply, la_matrix_vector_multiply
from .decomposition import la_matrix_lu_decomposition

# ============================================================================
# System Solving
# ============================================================================

fn la_solve_gaussian_elimination(a: [[f64]], b: [f64]) -> [f64]?:
    """Solve system Ax = b using Gaussian elimination."""
    val dims = la_matrix_dimensions(a)
    val rows = dims[0]
    val cols = dims[1]
    if b.len() != rows:
        return nil
    var augmented = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            row.push(a[i][j])
            j = j + 1
        row.push(b[i])
        augmented.push(row)
        i = i + 1
    val rref = la_matrix_rref(augmented)
    var x = []
    i = 0
    while i < cols:
        x.push(0.0)
        i = i + 1
    i = rows - 1
    while i >= 0:
        var pivot_col = -1
        var j = 0
        while j < cols:
            var abs_val = rref[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                pivot_col = j
                j = cols
            j = j + 1
        if pivot_col >= 0:
            var sum = rref[i][cols]
            j = pivot_col + 1
            while j < cols:
                sum = sum - rref[i][j] * x[j]
                j = j + 1
            x[pivot_col] = sum
        i = i - 1
    x

fn la_solve_lu(a: [[f64]], b: [f64]) -> [f64]?:
    """Solve system Ax = b using LU decomposition."""
    val lu_result = la_matrix_lu_decomposition(a)
    if not lu_result.?:
        return nil
    val lower = lu_result[0]
    val upper = lu_result[1]
    val n = lower.len()
    var y = []
    var i = 0
    while i < n:
        y.push(0.0)
        i = i + 1
    i = 0
    while i < n:
        var sum = b[i]
        var j = 0
        while j < i:
            sum = sum - lower[i][j] * y[j]
            j = j + 1
        y[i] = sum
        i = i + 1
    var x = []
    i = 0
    while i < n:
        x.push(0.0)
        i = i + 1
    i = n - 1
    while i >= 0:
        var sum = y[i]
        var j = i + 1
        while j < n:
            sum = sum - upper[i][j] * x[j]
            j = j + 1
        x[i] = sum / upper[i][i]
        i = i - 1
    x

fn la_solve_least_squares(a: [[f64]], b: [f64]) -> [f64]?:
    """Solve least squares problem using normal equations.

    Solves (A^T A) x = A^T b.
    """
    val at = la_matrix_transpose(a)
    val ata = la_matrix_multiply(at, a)
    if not ata.?:
        return nil
    val atb = la_matrix_vector_multiply(at, b)
    if not atb.?:
        return nil
    la_solve_gaussian_elimination(ata, atb)

fn la_solve_iterative(a: [[f64]], b: [f64], max_iter: i64) -> [f64]?:
    """Solve system using Jacobi iteration.

    Simple iterative method for diagonally dominant systems.
    """
    val dims = la_matrix_dimensions(a)
    val n = dims[0]
    if b.len() != n:
        return nil
    var x = []
    var i = 0
    while i < n:
        x.push(0.0)
        i = i + 1
    var iteration = 0
    while iteration < max_iter:
        var x_new = []
        i = 0
        while i < n:
            var sum = b[i]
            var j = 0
            while j < n:
                if i != j:
                    sum = sum - a[i][j] * x[j]
                j = j + 1
            x_new.push(sum / a[i][i])
            i = i + 1
        x = x_new
        iteration = iteration + 1
    x

# ============================================================================
# Exports
# ============================================================================

# System Solving (4 functions)
export la_solve_gaussian_elimination, la_solve_lu
export la_solve_least_squares, la_solve_iterative
