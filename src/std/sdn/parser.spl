# SDN Parser
#
# One-pass LL(2) parser for SDN documents.
# Port of rust/sdn/src/parser.rs

from value import {SdnValue, Span}
from lexer import {Token, TokenKind, Lexer}

export parse, parse_file, SdnParser, SdnError

# Parse error
enum SdnError:
    SyntaxError(message: text, span: Span)
    UnexpectedEof(span: Span?)
    InvalidTableRow(expected: i64, found: i64)

impl SdnError:
    fn message() -> text:
        match self:
            case SdnError.SyntaxError(msg, _): msg
            case SdnError.UnexpectedEof(_): "Unexpected end of file"
            case SdnError.InvalidTableRow(expected, found):
                "Expected {expected} columns, found {found}"

# SDN Parser state
class SdnParser:
    tokens: [Token]
    pos: i64
    source: text
    current_path: [text]

impl SdnParser:
    static fn from_source(source: text) -> SdnParser:
        var lexer = Lexer.from_source(source)
        val tokens = lexer.tokenize()
        SdnParser(
            tokens: tokens,
            pos: 0,
            source: source,
            current_path: []
        )

    # Parse document into SdnValue (typically a Dict)
    fn parse() -> Result<SdnValue, SdnError>:
        var root = {}
        while not self.is_at_end():
            self.skip_newlines()
            if self.is_at_end():
                break
            val stmt = self.parse_statement()
            match stmt:
                case Ok(Some((key, value))):
                    root[key] = value
                case Ok(None):
                    pass
                case Err(e):
                    return Err(e)
        Ok(SdnValue.Dict(root))

    # Parse a single statement
    me parse_statement() -> Result<(text, SdnValue)?, SdnError>:
        self.skip_newlines()
        if self.is_at_end():
            return Ok(None)

        val name = self.expect_identifier()?
        self.current_path.push(name)

        val result = match self.peek_kind():
            case Some(TokenKind.Colon):
                self.advance()
                self.parse_colon_stmt(name)
            case Some(TokenKind.Equals):
                self.advance()
                val value = self.parse_inline_value()?
                self.skip_newlines()
                Ok(Some((name, value)))
            case Some(TokenKind.Pipe):
                self.parse_named_table(name)
            case _:
                Err(SdnError.SyntaxError(
                    message: "Expected ':', '=', or '|' after identifier '{name}'",
                    span: self.current_span()
                ))

        self.current_path.pop()
        result

    # Parse after ':'
    me parse_colon_stmt(name: text) -> Result<(text, SdnValue)?, SdnError>:
        match self.peek_kind():
            case Some(TokenKind.Table):
                self.parse_typed_table(name)
            case Some(TokenKind.Newline) | Some(TokenKind.Indent):
                self.skip_newlines()
                if self.peek_kind_matches_indent():
                    self.advance()  # consume INDENT
                    val value = self.parse_block()?
                    Ok(Some((name, value)))
                else:
                    Ok(Some((name, SdnValue.Null)))
            case _:
                val value = self.parse_value()?
                self.skip_newlines()
                Ok(Some((name, value)))

    # Parse a block after INDENT
    me parse_block() -> Result<SdnValue, SdnError>:
        self.skip_newlines()
        if self.is_dict_block():
            self.parse_dict_block()
        else:
            self.parse_array_block()

    # Check if block is dict-like (ident: value)
    fn is_dict_block() -> bool:
        match self.peek_kind():
            case Some(TokenKind.Identifier(_)):
                match self.peek_kind_at(1):
                    case Some(TokenKind.Colon): true
                    case _: false
            case _: false

    # Parse dict block
    me parse_dict_block() -> Result<SdnValue, SdnError>:
        var dict = {}
        while true:
            self.skip_newlines()
            match self.peek_kind():
                case Some(TokenKind.Dedent) | Some(TokenKind.Eof) | None:
                    if self.peek_kind_matches_dedent():
                        self.advance()
                    break
                case Some(TokenKind.Identifier(_)):
                    val key = self.expect_identifier()?
                    self.current_path.push(key)
                    match self.peek_kind():
                        case Some(TokenKind.Colon):
                            self.advance()
                            val stmt = self.parse_colon_stmt(key)?
                            if stmt.?:
                                val (k, v) = stmt.unwrap()
                                dict[k] = v
                        case Some(TokenKind.Equals):
                            self.advance()
                            val value = self.parse_inline_value()?
                            dict[key] = value
                            self.skip_newlines()
                        case Some(TokenKind.Pipe):
                            val table = self.parse_named_table(key)?
                            if table.?:
                                val (k, v) = table.unwrap()
                                dict[k] = v
                        case _:
                            # Bare identifier as value
                            dict[key] = SdnValue.String(key)
                            self.skip_newlines()
                    self.current_path.pop()
                case _:
                    self.advance()
        Ok(SdnValue.Dict(dict))

    # Parse array block
    me parse_array_block() -> Result<SdnValue, SdnError>:
        var arr = []
        while true:
            self.skip_newlines()
            match self.peek_kind():
                case Some(TokenKind.Dedent) | Some(TokenKind.Eof) | None:
                    if self.peek_kind_matches_dedent():
                        self.advance()
                    break
                case _:
                    val value = self.parse_value()?
                    arr.push(value)
                    self.skip_newlines()
        Ok(SdnValue.Array(arr))

    # Parse named table: name |fields|
    me parse_named_table(name: text) -> Result<(text, SdnValue)?, SdnError>:
        self.expect_pipe()?
        var fields = []
        while true:
            if self.peek_kind_matches_pipe():
                break
            val field = self.expect_identifier()?
            fields.push(field)
            if self.peek_kind_matches_comma():
                self.advance()
            else:
                break
        self.expect_pipe()?

        val rows = match self.peek_kind():
            case Some(TokenKind.Newline) | Some(TokenKind.Indent):
                self.skip_newlines()
                if self.peek_kind_matches_indent():
                    self.advance()
                    self.parse_table_rows(fields.len())?
                else:
                    []
            case Some(TokenKind.Eof) | None:
                []
            case _:
                val row = self.parse_table_row(fields.len())?
                self.skip_newlines()
                [row]

        Ok(Some((name, SdnValue.Table(fields: Some(fields), types: None, rows: rows))))

    # Parse typed table: name: table{types}
    me parse_typed_table(name: text) -> Result<(text, SdnValue)?, SdnError>:
        self.advance()  # consume 'table'
        self.expect_lbrace()?
        var types = []
        while true:
            if self.peek_kind_matches_rbrace():
                break
            val type_name = self.expect_identifier()?
            types.push(type_name)
            if self.peek_kind_matches_comma():
                self.advance()
            else:
                break
        self.expect_rbrace()?

        val rows = match self.peek_kind():
            case Some(TokenKind.Equals):
                self.advance()
                self.parse_inline_tuple_list()?
            case Some(TokenKind.Newline) | Some(TokenKind.Indent):
                self.skip_newlines()
                if self.peek_kind_matches_indent():
                    self.advance()
                    self.parse_table_rows(types.len())?
                else:
                    []
            case _:
                []

        Ok(Some((name, SdnValue.Table(fields: None, types: Some(types), rows: rows))))

    # Parse table rows in block form
    me parse_table_rows(expected_cols: i64) -> Result<[[SdnValue]], SdnError>:
        var rows = []
        while true:
            self.skip_newlines()
            match self.peek_kind():
                case Some(TokenKind.Dedent) | Some(TokenKind.Eof) | None:
                    if self.peek_kind_matches_dedent():
                        self.advance()
                    break
                case _:
                    val row = self.parse_table_row(expected_cols)?
                    rows.push(row)
                    self.skip_newlines()
        Ok(rows)

    # Parse a single table row
    me parse_table_row(expected_cols: i64) -> Result<[SdnValue], SdnError>:
        var row = []
        var after_comma = false

        while true:
            if self.is_at_end() or self.peek_kind_matches_newline() or self.peek_kind_matches_dedent():
                if after_comma:
                    row.push(SdnValue.String(""))
                break

            if self.peek_kind_matches_comma():
                row.push(SdnValue.String(""))
                self.advance()
                after_comma = true
                continue

            val value = self.parse_value()?
            row.push(value)

            if self.peek_kind_matches_comma():
                self.advance()
                after_comma = true
            else:
                break

        if row.len() != expected_cols and expected_cols > 0:
            return Err(SdnError.InvalidTableRow(expected: expected_cols, found: row.len()))
        Ok(row)

    # Parse inline tuple list: [(v1, v2), ...]
    me parse_inline_tuple_list() -> Result<[[SdnValue]], SdnError>:
        self.expect_lbracket()?
        var rows = []
        while true:
            if self.peek_kind_matches_rbracket():
                break
            self.expect_lparen()?
            var row = []
            while true:
                if self.peek_kind_matches_rparen():
                    break
                val value = self.parse_value()?
                row.push(value)
                if self.peek_kind_matches_comma():
                    self.advance()
                else:
                    break
            self.expect_rparen()?
            rows.push(row)
            if self.peek_kind_matches_comma():
                self.advance()
            else:
                break
        self.expect_rbracket()?
        Ok(rows)

    # Parse inline value (dict, array, or simple value)
    me parse_inline_value() -> Result<SdnValue, SdnError>:
        match self.peek_kind():
            case Some(TokenKind.LBrace): self.parse_inline_dict()
            case Some(TokenKind.LBracket): self.parse_inline_array()
            case _: self.parse_value()

    # Parse inline dict: {k: v, k: v}
    me parse_inline_dict() -> Result<SdnValue, SdnError>:
        self.expect_lbrace()?
        var dict = {}
        while true:
            if self.peek_kind_matches_rbrace():
                break
            val key = self.expect_identifier()?
            self.expect_colon()?
            val value = self.parse_value()?
            dict[key] = value
            if self.peek_kind_matches_comma():
                self.advance()
            else:
                break
        self.expect_rbrace()?
        Ok(SdnValue.Dict(dict))

    # Parse inline array: [v, v, v]
    me parse_inline_array() -> Result<SdnValue, SdnError>:
        self.expect_lbracket()?
        var arr = []
        while true:
            if self.peek_kind_matches_rbracket():
                break
            val value = self.parse_value()?
            arr.push(value)
            if self.peek_kind_matches_comma():
                self.advance()
            else:
                break
        self.expect_rbracket()?
        Ok(SdnValue.Array(arr))

    # Parse a single value
    me parse_value() -> Result<SdnValue, SdnError>:
        match self.peek_kind():
            case Some(TokenKind.Integer(i)):
                self.advance()
                Ok(SdnValue.Int(i))
            case Some(TokenKind.Float(f)):
                self.advance()
                Ok(SdnValue.Float(f))
            case Some(TokenKind.Str(s)):
                self.advance()
                Ok(SdnValue.String(s))
            case Some(TokenKind.Bool(b)):
                self.advance()
                Ok(SdnValue.Bool(b))
            case Some(TokenKind.Null):
                self.advance()
                Ok(SdnValue.Null)
            case Some(TokenKind.Identifier(s)):
                self.advance()
                Ok(SdnValue.String(s))
            case Some(TokenKind.LBrace):
                self.parse_inline_dict()
            case Some(TokenKind.LBracket):
                self.parse_inline_array()
            case _:
                Err(SdnError.SyntaxError(
                    message: "Expected value",
                    span: self.current_span()
                ))

    # === Helper methods ===

    fn peek_kind() -> TokenKind?:
        if self.pos < self.tokens.len():
            Some(self.tokens[self.pos].kind)
        else:
            None

    fn peek_kind_at(offset: i64) -> TokenKind?:
        val idx = self.pos + offset
        if idx < self.tokens.len():
            Some(self.tokens[idx].kind)
        else:
            None

    me advance() -> Token?:
        if self.pos < self.tokens.len():
            val token = self.tokens[self.pos]
            self.pos = self.pos + 1
            Some(token)
        else:
            None

    fn is_at_end() -> bool:
        match self.peek_kind():
            case Some(TokenKind.Eof) | None: true
            case _: false

    me skip_newlines():
        while true:
            match self.peek_kind():
                case Some(TokenKind.Newline):
                    self.advance()
                case _:
                    break

    fn current_span() -> Span:
        if self.pos < self.tokens.len():
            self.tokens[self.pos].span
        else:
            Span.empty()

    # Token kind matchers (needed because match in Simple can't always
    # match enum variants without bindings in certain positions)
    fn peek_kind_matches_indent() -> bool:
        match self.peek_kind():
            case Some(TokenKind.Indent): true
            case _: false

    fn peek_kind_matches_dedent() -> bool:
        match self.peek_kind():
            case Some(TokenKind.Dedent): true
            case _: false

    fn peek_kind_matches_newline() -> bool:
        match self.peek_kind():
            case Some(TokenKind.Newline): true
            case _: false

    fn peek_kind_matches_comma() -> bool:
        match self.peek_kind():
            case Some(TokenKind.Comma): true
            case _: false

    fn peek_kind_matches_pipe() -> bool:
        match self.peek_kind():
            case Some(TokenKind.Pipe): true
            case _: false

    fn peek_kind_matches_rbrace() -> bool:
        match self.peek_kind():
            case Some(TokenKind.RBrace): true
            case _: false

    fn peek_kind_matches_rbracket() -> bool:
        match self.peek_kind():
            case Some(TokenKind.RBracket): true
            case _: false

    fn peek_kind_matches_rparen() -> bool:
        match self.peek_kind():
            case Some(TokenKind.RParen): true
            case _: false

    # Expect specific tokens
    me expect_identifier() -> Result<text, SdnError>:
        match self.peek_kind():
            case Some(TokenKind.Identifier(s)):
                self.advance()
                Ok(s)
            case Some(kind):
                Err(SdnError.SyntaxError(
                    message: "Expected identifier, got {kind.name()}",
                    span: self.current_span()
                ))
            case None:
                Err(SdnError.UnexpectedEof(span: None))

    me expect_pipe() -> Result<(), SdnError>:
        if self.peek_kind_matches_pipe():
            self.advance()
            Ok(())
        else:
            Err(SdnError.SyntaxError(
                message: "Expected '|'",
                span: self.current_span()
            ))

    me expect_colon() -> Result<(), SdnError>:
        match self.peek_kind():
            case Some(TokenKind.Colon):
                self.advance()
                Ok(())
            case _:
                Err(SdnError.SyntaxError(
                    message: "Expected ':'",
                    span: self.current_span()
                ))

    me expect_lbrace() -> Result<(), SdnError>:
        match self.peek_kind():
            case Some(TokenKind.LBrace):
                self.advance()
                Ok(())
            case _:
                Err(SdnError.SyntaxError(message: "Expected '{'", span: self.current_span()))

    me expect_rbrace() -> Result<(), SdnError>:
        if self.peek_kind_matches_rbrace():
            self.advance()
            Ok(())
        else:
            Err(SdnError.SyntaxError(message: "Expected '}'", span: self.current_span()))

    me expect_lbracket() -> Result<(), SdnError>:
        match self.peek_kind():
            case Some(TokenKind.LBracket):
                self.advance()
                Ok(())
            case _:
                Err(SdnError.SyntaxError(message: "Expected '['", span: self.current_span()))

    me expect_rbracket() -> Result<(), SdnError>:
        if self.peek_kind_matches_rbracket():
            self.advance()
            Ok(())
        else:
            Err(SdnError.SyntaxError(message: "Expected ']'", span: self.current_span()))

    me expect_lparen() -> Result<(), SdnError>:
        match self.peek_kind():
            case Some(TokenKind.LParen):
                self.advance()
                Ok(())
            case _:
                Err(SdnError.SyntaxError(message: "Expected '('", span: self.current_span()))

    me expect_rparen() -> Result<(), SdnError>:
        if self.peek_kind_matches_rparen():
            self.advance()
            Ok(())
        else:
            Err(SdnError.SyntaxError(message: "Expected ')'", span: self.current_span()))

# ============================================================================
# Public API
# ============================================================================

# Parse SDN source into a value tree
fn parse(source: text) -> Result<SdnValue, SdnError>:
    var parser = SdnParser.from_source(source)
    parser.parse()

# Parse SDN file
fn parse_file(path: text) -> Result<SdnValue, SdnError>:
    extern fn rt_file_read_text(path: text) -> text
    val source = rt_file_read_text(path)
    parse(source)
