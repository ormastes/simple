# SDN Document API
#
# Editable documents with formatting preservation and path-based access.
# Port of rust/sdn/src/document.rs

from value import {SdnValue, Span}
from error import {SdnError}
from parser import {parse}

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool

# ============================================================================
# SdnDocument
# ============================================================================

class SdnDocument:
    """Editable SDN document that preserves formatting where possible."""
    source: text
    root: SdnValue
    spans: Dict<text, Span>
    modified: bool

impl SdnDocument:
    static fn parse_doc(source: text) -> Result<SdnDocument, SdnError>:
        """Parse source into an editable document."""
        val result = parse(source)
        match result:
            case Ok(root):
                Ok(SdnDocument(
                    source: source,
                    root: root,
                    spans: {},
                    modified: false
                ))
            case Err(e):
                Err(e)

    static fn from_file(path: text) -> Result<SdnDocument, SdnError>:
        """Load document from file."""
        val source = rt_file_read_text(path)
        if source.is_empty():
            return Err(SdnError.IoError("Failed to read file: {path}"))
        SdnDocument.parse_doc(source)

    fn get(path: text) -> SdnValue?:
        """Get value at dotted path (e.g., 'server.port')."""
        self.root.get_path(path)

    me set(path: text, value: SdnValue) -> Result<(), SdnError>:
        """Set value at dotted path."""
        self.modified = true
        val parts = path.split(".")
        if parts.is_empty():
            return Err(SdnError.PathNotFound(path: path))

        if parts.len() == 1:
            # Direct child of root
            match self.root:
                case Dict(d):
                    d[parts[0]] = value
                    return Ok(())
                case _:
                    return Err(SdnError.TypeMismatch(expected: "dict", found: self.root.type_name()))

        # Navigate to parent
        val parent_path = parts[0:parts.len() - 1].join(".")
        val key = parts[parts.len() - 1]
        val parent = self.root.get_path(parent_path)
        if parent.?:
            match parent.unwrap():
                case Dict(d):
                    d[key] = value
                    return Ok(())
                case _:
                    pass
        Err(SdnError.PathNotFound(path: path))

    me delete(path: text) -> Result<(), SdnError>:
        """Delete value at dotted path."""
        self.modified = true
        val parts = path.split(".")
        if parts.is_empty():
            return Err(SdnError.PathNotFound(path: path))

        if parts.len() == 1:
            match self.root:
                case Dict(d):
                    if d.contains(parts[0]):
                        d.remove(parts[0])
                        return Ok(())
                case _:
                    pass
            return Err(SdnError.PathNotFound(path: path))

        val parent_path = parts[0:parts.len() - 1].join(".")
        val key = parts[parts.len() - 1]
        val parent = self.root.get_path(parent_path)
        if parent.?:
            match parent.unwrap():
                case Dict(d):
                    if d.contains(key):
                        d.remove(key)
                        return Ok(())
                case _:
                    pass
        Err(SdnError.PathNotFound(path: path))

    fn is_modified() -> bool:
        self.modified

    fn to_sdn() -> text:
        """Render document back to SDN format."""
        render_value(self.root, 0)

    fn to_json() -> text:
        """Render document as JSON."""
        render_json(self.root)

    fn write_file(path: text) -> Result<(), SdnError>:
        """Write document to file."""
        val content = self.to_sdn()
        val ok = rt_file_write_text(path, content)
        if not ok:
            return Err(SdnError.IoError("Failed to write file: {path}"))
        Ok(())

# ============================================================================
# SDN Rendering
# ============================================================================

fn render_value(value: SdnValue, indent: i64) -> text:
    """Render SDN value to string with indentation."""
    val prefix = "    " * indent
    match value:
        case Null: "null"
        case Bool(b): if b: "true" else: "false"
        case Int(i): "{i}"
        case Float(f): "{f}"
        case String(s):
            if s.contains(" ") or s.contains(",") or s.contains(":") or s.contains("\""):
                val escaped = s.replace("\\", "\\\\").replace("\"", "\\\"")
                "\"{escaped}\""
            else:
                s
        case Array(arr):
            if arr.is_empty():
                "[]"
            elif is_simple_array(arr):
                val items = arr.map(\v: render_value(v, 0))
                "[{items.join(", ")}]"
            else:
                var result = ""
                for v in arr:
                    result = result + "\n{prefix}    {render_value(v, indent + 1)}"
                result
        case Dict(d):
            if d.is_empty():
                "{}"
            elif is_simple_dict(d):
                val items = [for (k, v) in d: "{k}: {render_value(v, 0)}"]
                "{" + items.join(", ") + "}"
            else:
                var result = ""
                for (k, v) in d:
                    if v.is_table():
                        result = result + "\n{prefix}{k} {render_value(v, indent + 1)}"
                    elif is_block_value(v):
                        result = result + "\n{prefix}{k}:{render_value(v, indent + 1)}"
                    else:
                        result = result + "\n{prefix}{k}: {render_value(v, 0)}"
                result
        case Table(fields, _, rows):
            var result = ""
            if fields.?:
                result = "|{fields.unwrap().join(", ")}|"
            for row in rows:
                val items = row.map(\v: render_value(v, 0))
                result = result + "\n{prefix}    {items.join(", ")}"
            result

fn is_simple_array(arr: [SdnValue]) -> bool:
    """Check if array can be rendered inline."""
    if arr.len() > 5:
        return false
    arr.all(\v:
        match v:
            case Null | Bool(_) | Int(_) | Float(_) | String(_): true
            case _: false
    )

fn is_simple_dict(d: Dict<text, SdnValue>) -> bool:
    """Check if dict can be rendered inline."""
    if d.len() > 3:
        return false
    [for (_, v) in d: v].all(\v:
        match v:
            case Null | Bool(_) | Int(_) | Float(_) | String(_): true
            case _: false
    )

fn is_block_value(value: SdnValue) -> bool:
    """Check if value should be rendered as block."""
    match value:
        case Dict(d): not is_simple_dict(d)
        case Array(arr): not is_simple_array(arr)
        case Table(_, _, _): true
        case _: false

# ============================================================================
# JSON Rendering
# ============================================================================

fn render_json(value: SdnValue) -> text:
    """Render SDN value as JSON string."""
    match value:
        case Null: "null"
        case Bool(b): if b: "true" else: "false"
        case Int(i): "{i}"
        case Float(f): "{f}"
        case String(s): "\"{escape_json(s)}\""
        case Array(arr):
            val items = arr.map(\v: render_json(v))
            "[{items.join(", ")}]"
        case Dict(d):
            val items = [for (k, v) in d: "\"{escape_json(k)}\": {render_json(v)}"]
            "{" + items.join(", ") + "}"
        case Table(fields, _, rows):
            val items = rows.map(\row:
                if fields.?:
                    val f = fields.unwrap()
                    var pairs: [text] = []
                    var i = 0
                    while i < f.len() and i < row.len():
                        pairs = pairs.push("\"{escape_json(f[i])}\": {render_json(row[i])}")
                        i = i + 1
                    "{" + pairs.join(", ") + "}"
                else:
                    val values = row.map(\v: render_json(v))
                    "[{values.join(", ")}]"
            )
            "[{items.join(", ")}]"

fn escape_json(s: text) -> text:
    """Escape string for JSON output."""
    s.replace("\\", "\\\\")
     .replace("\"", "\\\"")
     .replace("\n", "\\n")
     .replace("\r", "\\r")
     .replace("\t", "\\t")

export SdnDocument
export render_value, render_json
