# Red-Black Tree Utilities Module
#
# A comprehensive implementation of Red-Black trees (self-balancing binary search trees)
# in Pure Simple with no external dependencies.
#
# Red-Black Tree Properties:
# 1. Every node is either red or black
# 2. The root is always black
# 3. All leaves (NIL) are black
# 4. If a node is red, both its children are black (no consecutive red nodes)
# 5. Every path from root to leaf contains the same number of black nodes
#
# These properties ensure O(log n) worst-case time for insert, delete, and search operations.

# Color constants
val RED = 0
val BLACK = 1

# Node structure: (value, color, left, right, parent)
# Tree structure: (root, size, nil_node)

# ============================================================================
# NODE CREATION AND ACCESS
# ============================================================================

# Create a new Red-Black tree node
# Returns: (value, color, left, right, parent)
fn create_node(value, color, left, right, parent):
    (value, color, left, right, parent)

# Get node value
fn node_value(node):
    node.0

# Get node color
fn node_color(node):
    node.1

# Get left child
fn node_left(node):
    node.2

# Get right child
fn node_right(node):
    node.3

# Get parent node
fn node_parent(node):
    node.4

# Set node value (returns new node)
fn set_node_value(node, value):
    (value, node.1, node.2, node.3, node.4)

# Set node color (returns new node)
fn set_node_color(node, color):
    (node.0, color, node.2, node.3, node.4)

# Set left child (returns new node)
fn set_node_left(node, left):
    (node.0, node.1, left, node.3, node.4)

# Set right child (returns new node)
fn set_node_right(node, right):
    (node.0, node.1, node.2, right, node.4)

# Set parent (returns new node)
fn set_node_parent(node, parent):
    (node.0, node.1, node.2, node.3, parent)

# ============================================================================
# TREE CREATION AND BASIC PROPERTIES
# ============================================================================

# Create NIL sentinel node (black, special marker)
fn nil_node():
    create_node(-1, BLACK, nil, nil, nil)

# Create an empty Red-Black tree
# Returns: (root, size, nil_sentinel)
fn create_rbtree():
    val nil_sentinel = nil_node()
    (nil_sentinel, 0, nil_sentinel)

# Get tree root
fn tree_root(tree):
    tree.0

# Get tree size
fn tree_size(tree):
    tree.1

# Get tree NIL sentinel
fn tree_nil(tree):
    tree.2

# Set tree root (returns new tree)
fn set_tree_root(tree, root):
    (root, tree.1, tree.2)

# Set tree size (returns new tree)
fn set_tree_size(tree, size):
    (tree.0, size, tree.2)

# Increment tree size (returns new tree)
fn increment_tree_size(tree):
    set_tree_size(tree, tree.1 + 1)

# Decrement tree size (returns new tree)
fn decrement_tree_size(tree):
    set_tree_size(tree, tree.1 - 1)

# Check if tree is empty
fn rb_is_empty(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    is_nil_node(root, nil_sentinel)

# Check if node is NIL sentinel
fn is_nil_node(node, nil_sentinel):
    if node == nil:
        true
    else:
        val is_sentinel = node == nil_sentinel
        if is_sentinel:
            true
        else:
            val node_val = node_value(node)
            node_val == -1

# ============================================================================
# COLOR OPERATIONS
# ============================================================================

# Check if node is red
fn is_red(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        false
    else:
        val color = node_color(node)
        color == RED

# Check if node is black
fn is_black(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        true
    else:
        val color = node_color(node)
        color == BLACK

# Get node color (NIL nodes are black)
fn get_color(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        BLACK
    else:
        node_color(node)

# Set node color
fn set_color(node, color):
    set_node_color(node, color)

# ============================================================================
# TREE ROTATIONS
# ============================================================================

# Left rotation around node x
#     x                y
#    / \              / \
#   a   y     =>     x   c
#      / \          / \
#     b   c        a   b
fn rotate_left(tree, x):
    val nil_sentinel = tree_nil(tree)
    val y = node_right(x)
    val b = node_left(y)

    # Turn y's left subtree into x's right subtree
    var new_x = set_node_right(x, b)

    # Update b's parent if it's not NIL
    var new_b = b
    if is_nil_node(b, nil_sentinel) == false:
        new_b = set_node_parent(b, new_x)

    # Link x's parent to y
    val x_parent = node_parent(x)
    var new_y = set_node_parent(y, x_parent)

    var new_root = tree_root(tree)
    if is_nil_node(x_parent, nil_sentinel):
        # x was root
        new_root = new_y
    else:
        val parent_left = node_left(x_parent)
        if parent_left == x:
            # x was left child
            var new_parent = set_node_left(x_parent, new_y)
            ()
        else:
            # x was right child
            var new_parent = set_node_right(x_parent, new_y)
            ()

    # Put x on y's left
    new_y = set_node_left(new_y, new_x)
    new_x = set_node_parent(new_x, new_y)

    var result_tree = set_tree_root(tree, new_root)
    (result_tree, new_x, new_y)

# Right rotation around node y
#       y              x
#      / \            / \
#     x   c    =>    a   y
#    / \                / \
#   a   b              b   c
fn rotate_right(tree, y):
    val nil_sentinel = tree_nil(tree)
    val x = node_left(y)
    val b = node_right(x)

    # Turn x's right subtree into y's left subtree
    var new_y = set_node_left(y, b)

    # Update b's parent if it's not NIL
    var new_b = b
    if is_nil_node(b, nil_sentinel) == false:
        new_b = set_node_parent(b, new_y)

    # Link y's parent to x
    val y_parent = node_parent(y)
    var new_x = set_node_parent(x, y_parent)

    var new_root = tree_root(tree)
    if is_nil_node(y_parent, nil_sentinel):
        # y was root
        new_root = new_x
    else:
        val parent_left = node_left(y_parent)
        if parent_left == y:
            # y was left child
            var new_parent = set_node_left(y_parent, new_x)
            ()
        else:
            # y was right child
            var new_parent = set_node_right(y_parent, new_x)
            ()

    # Put y on x's right
    new_x = set_node_right(new_x, new_y)
    new_y = set_node_parent(new_y, new_x)

    var result_tree = set_tree_root(tree, new_root)
    (result_tree, new_x, new_y)

# ============================================================================
# TREE MINIMUM AND MAXIMUM
# ============================================================================

# Find minimum node in subtree rooted at node
fn tree_minimum(node, nil_sentinel):
    var current = node
    var parent = nil_sentinel
    var keep_going = true

    if is_nil_node(current, nil_sentinel):
        keep_going = false
    else:
        ()

    if keep_going:
        var left = node_left(current)
        var continue = is_nil_node(left, nil_sentinel) == false

        if continue:
            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                # Deep tree - recursive helper
                current = tree_minimum_helper(current, nil_sentinel)
            else:
                ()
        else:
            ()
    else:
        ()

    current

# Recursive helper for deep trees
fn tree_minimum_helper(node, nil_sentinel):
    val left = node_left(node)
    if is_nil_node(left, nil_sentinel):
        node
    else:
        tree_minimum_helper(left, nil_sentinel)

# Find maximum node in subtree rooted at node
fn tree_maximum(node, nil_sentinel):
    var current = node
    var parent = nil_sentinel
    var keep_going = true

    if is_nil_node(current, nil_sentinel):
        keep_going = false
    else:
        ()

    if keep_going:
        var right = node_right(current)
        var continue = is_nil_node(right, nil_sentinel) == false

        if continue:
            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                # Deep tree - recursive helper
                current = tree_maximum_helper(current, nil_sentinel)
            else:
                ()
        else:
            ()
    else:
        ()

    current

# Recursive helper for deep trees
fn tree_maximum_helper(node, nil_sentinel):
    val right = node_right(node)
    if is_nil_node(right, nil_sentinel):
        node
    else:
        tree_maximum_helper(right, nil_sentinel)

# Get minimum value in tree
fn rb_min(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        nil
    else:
        val min_node = tree_minimum(root, nil_sentinel)
        node_value(min_node)

# Get maximum value in tree
fn rb_max(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        nil
    else:
        val max_node = tree_maximum(root, nil_sentinel)
        node_value(max_node)

# ============================================================================
# SUCCESSOR AND PREDECESSOR
# ============================================================================

# Find successor node (next larger value)
fn successor(node, nil_sentinel):
    val right = node_right(node)

    if is_nil_node(right, nil_sentinel) == false:
        # Minimum in right subtree
        tree_minimum(right, nil_sentinel)
    else:
        # Go up until we find a left ancestor
        var current = node
        var parent = node_parent(current)
        var keep_going = is_nil_node(parent, nil_sentinel) == false

        if keep_going:
            val parent_right = node_right(parent)
            var is_right_child = current == parent_right
            keep_going = is_right_child

            if keep_going:
                current = parent
                parent = node_parent(current)
                keep_going = is_nil_node(parent, nil_sentinel) == false

                if keep_going:
                    val parent_right2 = node_right(parent)
                    is_right_child = current == parent_right2
                    keep_going = is_right_child

                    if keep_going:
                        current = parent
                        parent = node_parent(current)
                        keep_going = is_nil_node(parent, nil_sentinel) == false

                        if keep_going:
                            # Deep path - use helper
                            parent = successor_helper(current, parent, nil_sentinel)
                        else:
                            ()
                    else:
                        ()
                else:
                    ()
            else:
                ()
        else:
            ()

        parent

# Helper for finding successor up the tree
fn successor_helper(node, parent, nil_sentinel):
    if is_nil_node(parent, nil_sentinel):
        parent
    else:
        val parent_right = node_right(parent)
        if node == parent_right:
            val grandparent = node_parent(parent)
            successor_helper(parent, grandparent, nil_sentinel)
        else:
            parent

# Find predecessor node (next smaller value)
fn predecessor(node, nil_sentinel):
    val left = node_left(node)

    if is_nil_node(left, nil_sentinel) == false:
        # Maximum in left subtree
        tree_maximum(left, nil_sentinel)
    else:
        # Go up until we find a right ancestor
        var current = node
        var parent = node_parent(current)
        var keep_going = is_nil_node(parent, nil_sentinel) == false

        if keep_going:
            val parent_left = node_left(parent)
            var is_left_child = current == parent_left
            keep_going = is_left_child

            if keep_going:
                current = parent
                parent = node_parent(current)
                keep_going = is_nil_node(parent, nil_sentinel) == false

                if keep_going:
                    val parent_left2 = node_left(parent)
                    is_left_child = current == parent_left2
                    keep_going = is_left_child

                    if keep_going:
                        current = parent
                        parent = node_parent(current)
                        keep_going = is_nil_node(parent, nil_sentinel) == false

                        if keep_going:
                            # Deep path - use helper
                            parent = predecessor_helper(current, parent, nil_sentinel)
                        else:
                            ()
                    else:
                        ()
                else:
                    ()
            else:
                ()
        else:
            ()

        parent

# Helper for finding predecessor up the tree
fn predecessor_helper(node, parent, nil_sentinel):
    if is_nil_node(parent, nil_sentinel):
        parent
    else:
        val parent_left = node_left(parent)
        if node == parent_left:
            val grandparent = node_parent(parent)
            predecessor_helper(parent, grandparent, nil_sentinel)
        else:
            parent

# Find successor by value
fn rb_successor(tree, value):
    val nil_sentinel = tree_nil(tree)
    val node = search_node(tree_root(tree), value, nil_sentinel)

    if is_nil_node(node, nil_sentinel):
        nil
    else:
        val succ = successor(node, nil_sentinel)
        if is_nil_node(succ, nil_sentinel):
            nil
        else:
            node_value(succ)

# Find predecessor by value
fn rb_predecessor(tree, value):
    val nil_sentinel = tree_nil(tree)
    val node = search_node(tree_root(tree), value, nil_sentinel)

    if is_nil_node(node, nil_sentinel):
        nil
    else:
        val pred = predecessor(node, nil_sentinel)
        if is_nil_node(pred, nil_sentinel):
            nil
        else:
            node_value(pred)

# ============================================================================
# SEARCH OPERATIONS
# ============================================================================

# Search for a node with given value
fn search_node(node, value, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        nil_sentinel
    else:
        val node_val = node_value(node)

        if value == node_val:
            node
        else:
            if value < node_val:
                val left = node_left(node)
                search_node(left, value, nil_sentinel)
            else:
                val right = node_right(node)
                search_node(right, value, nil_sentinel)

# Search for value in tree (returns true if found)
fn rb_search(tree, value):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    val result = search_node(root, value, nil_sentinel)
    is_nil_node(result, nil_sentinel) == false

# Alias for rb_search
fn rb_contains(tree, value):
    rb_search(tree, value)

# ============================================================================
# INSERTION
# ============================================================================

# Insert a value into the tree
fn rb_insert(tree, value):
    val nil_sentinel = tree_nil(tree)
    val root = tree_root(tree)

    # Create new red node
    val new_node = create_node(value, RED, nil_sentinel, nil_sentinel, nil_sentinel)

    # Standard BST insertion
    var y = nil_sentinel
    var x = root
    var x_is_nil = is_nil_node(x, nil_sentinel)

    # Find insertion point
    if x_is_nil == false:
        y = x
        val node_val = node_value(x)

        if value < node_val:
            x = node_left(x)
        else:
            x = node_right(x)

        x_is_nil = is_nil_node(x, nil_sentinel)

        if x_is_nil == false:
            y = x
            val node_val2 = node_value(x)

            if value < node_val2:
                x = node_left(x)
            else:
                x = node_right(x)

            x_is_nil = is_nil_node(x, nil_sentinel)

            if x_is_nil == false:
                # Deep tree - use helper
                y = insert_find_parent(x, value, nil_sentinel)
            else:
                ()
        else:
            ()
    else:
        ()

    # Set parent
    var inserted_node = set_node_parent(new_node, y)

    # Insert node
    var new_root = root
    if is_nil_node(y, nil_sentinel):
        # Tree was empty
        new_root = inserted_node
    else:
        val y_val = node_value(y)
        if value < y_val:
            y = set_node_left(y, inserted_node)
        else:
            y = set_node_right(y, inserted_node)

    # Update tree
    var result_tree = set_tree_root(tree, new_root)
    result_tree = increment_tree_size(result_tree)

    # Fix Red-Black properties
    insert_fixup(result_tree, inserted_node)

# Helper to find parent for insertion in deep tree
fn insert_find_parent(node, value, nil_sentinel):
    val node_val = node_value(node)
    val next = if value < node_val:
        node_left(node)
    else:
        node_right(node)

    if is_nil_node(next, nil_sentinel):
        node
    else:
        insert_find_parent(next, value, nil_sentinel)

# Fix Red-Black properties after insertion
# Handles three cases:
# Case 1: Uncle is red - recolor
# Case 2: Uncle is black, node is right child - left rotate
# Case 3: Uncle is black, node is left child - right rotate and recolor
fn insert_fixup(tree, z):
    val nil_sentinel = tree_nil(tree)
    var current = z
    var result_tree = tree

    # Get parent and check color
    var parent = node_parent(current)
    var parent_is_red = is_red(parent, nil_sentinel)

    if parent_is_red:
        # Get grandparent
        val grandparent = node_parent(parent)
        val gp_left = node_left(grandparent)

        if parent == gp_left:
            # Parent is left child
            val uncle = node_right(grandparent)
            val uncle_is_red = is_red(uncle, nil_sentinel)

            if uncle_is_red:
                # Case 1: Uncle is red - recolor
                parent = set_node_color(parent, BLACK)
                val new_uncle = set_node_color(uncle, BLACK)
                val new_gp = set_node_color(grandparent, RED)
                current = new_gp
                result_tree = set_tree_root(result_tree, tree_root(result_tree))

                # Continue fixup at grandparent
                parent = node_parent(current)
                parent_is_red = is_red(parent, nil_sentinel)

                if parent_is_red:
                    result_tree = insert_fixup_continue(result_tree, current)
                else:
                    ()
            else:
                # Uncle is black
                val parent_right = node_right(parent)

                if current == parent_right:
                    # Case 2: Node is right child - left rotate
                    current = parent
                    val rotate_result = rotate_left(result_tree, current)
                    result_tree = rotate_result.0
                    parent = node_parent(current)
                else:
                    ()

                # Case 3: Node is left child - right rotate and recolor
                parent = set_node_color(parent, BLACK)
                val gp2 = node_parent(parent)
                val new_gp2 = set_node_color(gp2, RED)
                val rotate_result2 = rotate_right(result_tree, new_gp2)
                result_tree = rotate_result2.0

        else:
            # Parent is right child (symmetric)
            val uncle = node_left(grandparent)
            val uncle_is_red = is_red(uncle, nil_sentinel)

            if uncle_is_red:
                # Case 1: Uncle is red - recolor
                parent = set_node_color(parent, BLACK)
                val new_uncle = set_node_color(uncle, BLACK)
                val new_gp = set_node_color(grandparent, RED)
                current = new_gp
                result_tree = set_tree_root(result_tree, tree_root(result_tree))

                # Continue fixup at grandparent
                parent = node_parent(current)
                parent_is_red = is_red(parent, nil_sentinel)

                if parent_is_red:
                    result_tree = insert_fixup_continue(result_tree, current)
                else:
                    ()
            else:
                # Uncle is black
                val parent_left = node_left(parent)

                if current == parent_left:
                    # Case 2: Node is left child - right rotate
                    current = parent
                    val rotate_result = rotate_right(result_tree, current)
                    result_tree = rotate_result.0
                    parent = node_parent(current)
                else:
                    ()

                # Case 3: Node is right child - left rotate and recolor
                parent = set_node_color(parent, BLACK)
                val gp2 = node_parent(parent)
                val new_gp2 = set_node_color(gp2, RED)
                val rotate_result2 = rotate_left(result_tree, new_gp2)
                result_tree = rotate_result2.0
    else:
        ()

    # Ensure root is black
    val root = tree_root(result_tree)
    val new_root = set_node_color(root, BLACK)
    set_tree_root(result_tree, new_root)

# Continue insert fixup (helper to avoid deep nesting)
fn insert_fixup_continue(tree, node):
    insert_fixup(tree, node)

# ============================================================================
# DELETION
# ============================================================================

# Transplant subtree v in place of subtree u
fn rb_transplant(tree, u, v):
    val nil_sentinel = tree_nil(tree)
    val u_parent = node_parent(u)
    var new_root = tree_root(tree)

    if is_nil_node(u_parent, nil_sentinel):
        # u is root
        new_root = v
    else:
        val parent_left = node_left(u_parent)
        if u == parent_left:
            val new_parent = set_node_left(u_parent, v)
            ()
        else:
            val new_parent = set_node_right(u_parent, v)
            ()

    var new_v = v
    if is_nil_node(v, nil_sentinel) == false:
        new_v = set_node_parent(v, u_parent)
    else:
        ()

    val result_tree = set_tree_root(tree, new_root)
    (result_tree, new_v)

# Delete a value from the tree
fn rb_delete(tree, value):
    val nil_sentinel = tree_nil(tree)
    val root = tree_root(tree)

    # Find node to delete
    val z = search_node(root, value, nil_sentinel)

    if is_nil_node(z, nil_sentinel):
        # Value not found
        tree
    else:
        var y = z
        var y_original_color = node_color(y)
        var x = nil_sentinel
        var result_tree = tree

        val z_left = node_left(z)
        val z_right = node_right(z)
        val z_left_is_nil = is_nil_node(z_left, nil_sentinel)
        val z_right_is_nil = is_nil_node(z_right, nil_sentinel)

        if z_left_is_nil:
            # No left child
            x = z_right
            val transplant_result = rb_transplant(result_tree, z, z_right)
            result_tree = transplant_result.0
            x = transplant_result.1
        else:
            if z_right_is_nil:
                # No right child
                x = z_left
                val transplant_result = rb_transplant(result_tree, z, z_left)
                result_tree = transplant_result.0
                x = transplant_result.1
            else:
                # Two children - find successor
                y = tree_minimum(z_right, nil_sentinel)
                y_original_color = node_color(y)
                x = node_right(y)

                val y_parent = node_parent(y)
                if y_parent == z:
                    if is_nil_node(x, nil_sentinel) == false:
                        x = set_node_parent(x, y)
                    else:
                        ()
                else:
                    val transplant_result1 = rb_transplant(result_tree, y, node_right(y))
                    result_tree = transplant_result1.0
                    y = set_node_right(y, z_right)
                    val y_right = node_right(y)
                    if is_nil_node(y_right, nil_sentinel) == false:
                        val new_y_right = set_node_parent(y_right, y)
                        ()
                    else:
                        ()

                val transplant_result2 = rb_transplant(result_tree, z, y)
                result_tree = transplant_result2.0
                y = set_node_left(y, z_left)
                val y_left = node_left(y)
                if is_nil_node(y_left, nil_sentinel) == false:
                    val new_y_left = set_node_parent(y_left, y)
                    ()
                else:
                    ()
                y = set_node_color(y, node_color(z))

        # Update size
        result_tree = decrement_tree_size(result_tree)

        # Fix Red-Black properties if needed
        if y_original_color == BLACK:
            delete_fixup(result_tree, x)
        else:
            result_tree

# Fix Red-Black properties after deletion
fn delete_fixup(tree, x):
    val nil_sentinel = tree_nil(tree)
    var current = x
    var result_tree = tree
    val root = tree_root(result_tree)

    var current_is_black = is_black(current, nil_sentinel)
    var current_is_not_root = current != root
    var continue = current_is_black
    if continue:
        continue = current_is_not_root
    else:
        ()

    if continue:
        val parent = node_parent(current)
        val parent_left = node_left(parent)

        if current == parent_left:
            # Current is left child
            result_tree = delete_fixup_left(result_tree, current)
        else:
            # Current is right child
            result_tree = delete_fixup_right(result_tree, current)
    else:
        ()

    # Ensure current is black
    if is_nil_node(current, nil_sentinel) == false:
        val new_current = set_node_color(current, BLACK)
        result_tree
    else:
        result_tree

# Delete fixup when node is left child
fn delete_fixup_left(tree, x):
    val nil_sentinel = tree_nil(tree)
    var result_tree = tree
    var parent = node_parent(x)
    var sibling = node_right(parent)

    # Case 1: Sibling is red
    if is_red(sibling, nil_sentinel):
        sibling = set_node_color(sibling, BLACK)
        parent = set_node_color(parent, RED)
        val rotate_result = rotate_left(result_tree, parent)
        result_tree = rotate_result.0
        parent = node_parent(x)
        sibling = node_right(parent)
    else:
        ()

    # Case 2: Sibling and both children are black
    val sibling_left = node_left(sibling)
    val sibling_right = node_right(sibling)
    val left_is_black = is_black(sibling_left, nil_sentinel)
    val right_is_black = is_black(sibling_right, nil_sentinel)

    if left_is_black:
        if right_is_black:
            sibling = set_node_color(sibling, RED)
            result_tree = delete_fixup(result_tree, parent)
        else:
            # Case 4: Sibling is black, far child is red
            sibling = set_node_color(sibling, node_color(parent))
            parent = set_node_color(parent, BLACK)
            val new_sibling_right = set_node_color(sibling_right, BLACK)
            val rotate_result = rotate_left(result_tree, parent)
            result_tree = rotate_result.0
    else:
        # Case 3: Sibling is black, near child is red, far child is black
        if right_is_black:
            val new_sibling_left = set_node_color(sibling_left, BLACK)
            sibling = set_node_color(sibling, RED)
            val rotate_result = rotate_right(result_tree, sibling)
            result_tree = rotate_result.0
            parent = node_parent(x)
            sibling = node_right(parent)
        else:
            ()

        # Case 4
        sibling = set_node_color(sibling, node_color(parent))
        parent = set_node_color(parent, BLACK)
        val sibling_right2 = node_right(sibling)
        val new_sibling_right2 = set_node_color(sibling_right2, BLACK)
        val rotate_result = rotate_left(result_tree, parent)
        result_tree = rotate_result.0

    result_tree

# Delete fixup when node is right child (symmetric to left)
fn delete_fixup_right(tree, x):
    val nil_sentinel = tree_nil(tree)
    var result_tree = tree
    var parent = node_parent(x)
    var sibling = node_left(parent)

    # Case 1: Sibling is red
    if is_red(sibling, nil_sentinel):
        sibling = set_node_color(sibling, BLACK)
        parent = set_node_color(parent, RED)
        val rotate_result = rotate_right(result_tree, parent)
        result_tree = rotate_result.0
        parent = node_parent(x)
        sibling = node_left(parent)
    else:
        ()

    # Case 2: Sibling and both children are black
    val sibling_left = node_left(sibling)
    val sibling_right = node_right(sibling)
    val left_is_black = is_black(sibling_left, nil_sentinel)
    val right_is_black = is_black(sibling_right, nil_sentinel)

    if right_is_black:
        if left_is_black:
            sibling = set_node_color(sibling, RED)
            result_tree = delete_fixup(result_tree, parent)
        else:
            # Case 4: Sibling is black, far child is red
            sibling = set_node_color(sibling, node_color(parent))
            parent = set_node_color(parent, BLACK)
            val new_sibling_left = set_node_color(sibling_left, BLACK)
            val rotate_result = rotate_right(result_tree, parent)
            result_tree = rotate_result.0
    else:
        # Case 3: Sibling is black, near child is red, far child is black
        if left_is_black:
            val new_sibling_right = set_node_color(sibling_right, BLACK)
            sibling = set_node_color(sibling, RED)
            val rotate_result = rotate_left(result_tree, sibling)
            result_tree = rotate_result.0
            parent = node_parent(x)
            sibling = node_left(parent)
        else:
            ()

        # Case 4
        sibling = set_node_color(sibling, node_color(parent))
        parent = set_node_color(parent, BLACK)
        val sibling_left2 = node_left(sibling)
        val new_sibling_left2 = set_node_color(sibling_left2, BLACK)
        val rotate_result = rotate_right(result_tree, parent)
        result_tree = rotate_result.0

    result_tree

# ============================================================================
# TREE STATISTICS
# ============================================================================

# Get tree size (number of nodes)
fn rb_size(tree):
    tree_size(tree)

# Calculate tree height (longest path from root to leaf)
fn rb_height(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    calculate_height(root, nil_sentinel)

# Helper to calculate height
fn calculate_height(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        0
    else:
        val left = node_left(node)
        val right = node_right(node)
        val left_height = calculate_height(left, nil_sentinel)
        val right_height = calculate_height(right, nil_sentinel)
        val max_height = if left_height > right_height:
            left_height
        else:
            right_height
        max_height + 1

# Calculate black height (number of black nodes on path to leaf)
fn black_height(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    calculate_black_height(root, nil_sentinel)

# Helper to calculate black height
fn calculate_black_height(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        1
    else:
        val left = node_left(node)
        val bh = calculate_black_height(left, nil_sentinel)
        val node_is_black = is_black(node, nil_sentinel)
        if node_is_black:
            bh + 1
        else:
            bh

# ============================================================================
# TREE VALIDATION
# ============================================================================

# Validate Red-Black tree properties
fn is_valid_rbtree(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        true
    else:
        # Property 2: Root is black
        val root_is_black = is_black(root, nil_sentinel)

        if root_is_black == false:
            false
        else:
            # Check other properties
            val valid = validate_rbtree_properties(root, nil_sentinel)
            valid.0

# Validate Red-Black properties recursively
# Returns (valid, black_height)
fn validate_rbtree_properties(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        (true, 1)
    else:
        # Property 4: Red node has black children
        val node_is_red = is_red(node, nil_sentinel)

        if node_is_red:
            val left = node_left(node)
            val right = node_right(node)
            val left_is_red = is_red(left, nil_sentinel)
            val right_is_red = is_red(right, nil_sentinel)

            if left_is_red:
                (false, 0)
            else:
                if right_is_red:
                    (false, 0)
                else:
                    validate_subtrees(node, nil_sentinel)
        else:
            validate_subtrees(node, nil_sentinel)

# Validate both subtrees and check black height
fn validate_subtrees(node, nil_sentinel):
    val left = node_left(node)
    val right = node_right(node)

    val left_result = validate_rbtree_properties(left, nil_sentinel)
    val left_valid = left_result.0
    val left_bh = left_result.1

    if left_valid == false:
        (false, 0)
    else:
        val right_result = validate_rbtree_properties(right, nil_sentinel)
        val right_valid = right_result.0
        val right_bh = right_result.1

        if right_valid == false:
            (false, 0)
        else:
            # Property 5: Equal black height
            if left_bh != right_bh:
                (false, 0)
            else:
                val node_is_black = is_black(node, nil_sentinel)
                val bh = if node_is_black:
                    left_bh + 1
                else:
                    left_bh
                (true, bh)

# ============================================================================
# TREE TRAVERSALS
# ============================================================================

# Inorder traversal (sorted order)
fn inorder(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    var result = []
    inorder_helper(root, nil_sentinel, result)

# Inorder helper
fn inorder_helper(node, nil_sentinel, result):
    if is_nil_node(node, nil_sentinel):
        result
    else:
        val left = node_left(node)
        var new_result = inorder_helper(left, nil_sentinel, result)
        val value = node_value(node)
        new_result = new_result + [value]
        val right = node_right(node)
        inorder_helper(right, nil_sentinel, new_result)

# Preorder traversal
fn preorder(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    var result = []
    preorder_helper(root, nil_sentinel, result)

# Preorder helper
fn preorder_helper(node, nil_sentinel, result):
    if is_nil_node(node, nil_sentinel):
        result
    else:
        val value = node_value(node)
        var new_result = result + [value]
        val left = node_left(node)
        new_result = preorder_helper(left, nil_sentinel, new_result)
        val right = node_right(node)
        preorder_helper(right, nil_sentinel, new_result)

# Postorder traversal
fn postorder(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    var result = []
    postorder_helper(root, nil_sentinel, result)

# Postorder helper
fn postorder_helper(node, nil_sentinel, result):
    if is_nil_node(node, nil_sentinel):
        result
    else:
        val left = node_left(node)
        var new_result = postorder_helper(left, nil_sentinel, result)
        val right = node_right(node)
        new_result = postorder_helper(right, nil_sentinel, new_result)
        val value = node_value(node)
        new_result + [value]

# Level-order traversal (breadth-first)
fn level_order(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        []
    else:
        var result = []
        var queue = [root]
        level_order_helper(queue, nil_sentinel, result)

# Level-order helper
fn level_order_helper(queue, nil_sentinel, result):
    if queue == []:
        result
    else:
        val node = queue.0
        val rest_queue = queue[1:]
        val value = node_value(node)
        var new_result = result + [value]

        val left = node_left(node)
        var new_queue = rest_queue
        if is_nil_node(left, nil_sentinel) == false:
            new_queue = new_queue + [left]
        else:
            ()

        val right = node_right(node)
        if is_nil_node(right, nil_sentinel) == false:
            new_queue = new_queue + [right]
        else:
            ()

        level_order_helper(new_queue, nil_sentinel, new_result)

# Convert tree to sorted list
fn rb_to_list(tree):
    inorder(tree)

# ============================================================================
# RANGE QUERIES
# ============================================================================

# Find all values in range [min, max]
fn range_query(tree, min, max):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    var result = []
    range_query_helper(root, min, max, nil_sentinel, result)

# Range query helper
fn range_query_helper(node, min, max, nil_sentinel, result):
    if is_nil_node(node, nil_sentinel):
        result
    else:
        val value = node_value(node)
        var new_result = result

        # Search left if value > min
        if value > min:
            val left = node_left(node)
            new_result = range_query_helper(left, min, max, nil_sentinel, new_result)
        else:
            ()

        # Include value if in range
        if value >= min:
            if value <= max:
                new_result = new_result + [value]
            else:
                ()
        else:
            ()

        # Search right if value < max
        if value < max:
            val right = node_right(node)
            new_result = range_query_helper(right, min, max, nil_sentinel, new_result)
        else:
            ()

        new_result

# Count values in range [min, max]
fn count_range(tree, min, max):
    val values = range_query(tree, min, max)
    values.len

# ============================================================================
# ADVANCED QUERIES
# ============================================================================

# Find largest value <= target (floor)
fn floor(tree, value):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    floor_helper(root, value, nil_sentinel, nil)

# Floor helper
fn floor_helper(node, value, nil_sentinel, best):
    if is_nil_node(node, nil_sentinel):
        best
    else:
        val node_val = node_value(node)

        if node_val == value:
            node_val
        else:
            if node_val < value:
                # This could be floor, search right for better
                val right = node_right(node)
                floor_helper(right, value, nil_sentinel, node_val)
            else:
                # Node value too large, search left
                val left = node_left(node)
                floor_helper(left, value, nil_sentinel, best)

# Find smallest value >= target (ceiling)
fn ceiling(tree, value):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    ceiling_helper(root, value, nil_sentinel, nil)

# Ceiling helper
fn ceiling_helper(node, value, nil_sentinel, best):
    if is_nil_node(node, nil_sentinel):
        best
    else:
        val node_val = node_value(node)

        if node_val == value:
            node_val
        else:
            if node_val > value:
                # This could be ceiling, search left for better
                val left = node_left(node)
                ceiling_helper(left, value, nil_sentinel, node_val)
            else:
                # Node value too small, search right
                val right = node_right(node)
                ceiling_helper(right, value, nil_sentinel, best)

# Find k-th smallest element (1-indexed)
fn kth_smallest(tree, k):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    kth_smallest_helper(root, k, nil_sentinel)

# K-th smallest helper
fn kth_smallest_helper(node, k, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        nil
    else:
        val left = node_left(node)
        val left_size = count_nodes(left, nil_sentinel)

        if k == left_size + 1:
            node_value(node)
        else:
            if k <= left_size:
                kth_smallest_helper(left, k, nil_sentinel)
            else:
                val right = node_right(node)
                kth_smallest_helper(right, k - left_size - 1, nil_sentinel)

# Count nodes in subtree
fn count_nodes(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        0
    else:
        val left = node_left(node)
        val right = node_right(node)
        val left_count = count_nodes(left, nil_sentinel)
        val right_count = count_nodes(right, nil_sentinel)
        left_count + right_count + 1

# Count values less than target
fn count_less_than(tree, value):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    count_less_than_helper(root, value, nil_sentinel)

# Count less than helper
fn count_less_than_helper(node, value, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        0
    else:
        val node_val = node_value(node)

        if node_val >= value:
            # Count only left subtree
            val left = node_left(node)
            count_less_than_helper(left, value, nil_sentinel)
        else:
            # Count left subtree + this node + part of right
            val left = node_left(node)
            val right = node_right(node)
            val left_count = count_nodes(left, nil_sentinel)
            val right_count = count_less_than_helper(right, value, nil_sentinel)
            left_count + 1 + right_count

# ============================================================================
# TREE UTILITIES
# ============================================================================

# Clear all nodes from tree
fn rb_clear(tree):
    val nil_sentinel = tree_nil(tree)
    (nil_sentinel, 0, nil_sentinel)

# Clone a tree (deep copy)
fn clone_tree(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    val size = tree_size(tree)
    val new_root = clone_node(root, nil_sentinel)
    (new_root, size, nil_sentinel)

# Clone a node and its subtree
fn clone_node(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        nil_sentinel
    else:
        val value = node_value(node)
        val color = node_color(node)
        val left = node_left(node)
        val right = node_right(node)

        val new_left = clone_node(left, nil_sentinel)
        val new_right = clone_node(right, nil_sentinel)

        var new_node = create_node(value, color, new_left, new_right, nil_sentinel)

        # Set parent references
        if is_nil_node(new_left, nil_sentinel) == false:
            val updated_left = set_node_parent(new_left, new_node)
            new_node = set_node_left(new_node, updated_left)
        else:
            ()

        if is_nil_node(new_right, nil_sentinel) == false:
            val updated_right = set_node_parent(new_right, new_node)
            new_node = set_node_right(new_node, updated_right)
        else:
            ()

        new_node

# ============================================================================
# TREE VISUALIZATION
# ============================================================================

# Print tree in ASCII format
fn print_tree(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        print "Empty tree"
    else:
        print_tree_helper(root, "", true, nil_sentinel)

    ()

# Print tree helper
fn print_tree_helper(node, prefix, is_tail, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        ()
    else:
        val value = node_value(node)
        val color = node_color(node)
        val color_str = if color == RED:
            "R"
        else:
            "B"

        val connector = if is_tail:
            "└── "
        else:
            "├── "

        print "{prefix}{connector}{value}({color_str})"

        val left = node_left(node)
        val right = node_right(node)
        val has_left = is_nil_node(left, nil_sentinel) == false
        val has_right = is_nil_node(right, nil_sentinel) == false

        val new_prefix = if is_tail:
            prefix + "    "
        else:
            prefix + "│   "

        if has_left:
            print_tree_helper(left, new_prefix, has_right == false, nil_sentinel)
        else:
            ()

        if has_right:
            print_tree_helper(right, new_prefix, true, nil_sentinel)
        else:
            ()

# Generate Graphviz DOT format
fn tree_to_dot(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    var dot = "digraph RBTree {\n"
    dot = dot + "  node [style=filled];\n"

    if is_nil_node(root, nil_sentinel):
        dot = dot + "  empty [label=\"Empty\"];\n"
    else:
        dot = tree_to_dot_helper(root, nil_sentinel, dot, 0).0

    dot + "}\n"

# DOT format helper
# Returns (dot_string, next_id)
fn tree_to_dot_helper(node, nil_sentinel, dot, node_id):
    if is_nil_node(node, nil_sentinel):
        (dot, node_id)
    else:
        val value = node_value(node)
        val color = node_color(node)
        val color_str = if color == RED:
            "red"
        else:
            "black"
        val text_color = if color == RED:
            "white"
        else:
            "white"

        var new_dot = dot + "  n{node_id} [label=\"{value}\", fillcolor={color_str}, fontcolor={text_color}];\n"

        val left = node_left(node)
        val right = node_right(node)

        # Process left child
        val left_id = node_id + 1
        val left_result = tree_to_dot_helper(left, nil_sentinel, new_dot, left_id)
        new_dot = left_result.0
        var next_id = left_result.1

        if is_nil_node(left, nil_sentinel) == false:
            new_dot = new_dot + "  n{node_id} -> n{left_id};\n"
        else:
            ()

        # Process right child
        val right_id = next_id
        val right_result = tree_to_dot_helper(right, nil_sentinel, new_dot, right_id)
        new_dot = right_result.0
        next_id = right_result.1

        if is_nil_node(right, nil_sentinel) == false:
            new_dot = new_dot + "  n{node_id} -> n{right_id};\n"
        else:
            ()

        (new_dot, next_id)

# ============================================================================
# BULK OPERATIONS
# ============================================================================

# Build tree from sorted array (efficient O(n) construction)
fn build_from_sorted_array(arr):
    val len = arr.len
    if len == 0:
        create_rbtree()
    else:
        val nil_sentinel = nil_node()
        val root = build_balanced_helper(arr, 0, len - 1, nil_sentinel, 0)
        var tree = (root, len, nil_sentinel)

        # Color nodes to maintain Red-Black properties
        val colored_root = color_tree_helper(root, nil_sentinel, true)
        set_tree_root(tree, colored_root)

# Build balanced tree from sorted array
fn build_balanced_helper(arr, start, end, nil_sentinel, depth):
    if start > end:
        nil_sentinel
    else:
        val mid = start + (end - start) / 2
        val value = arr[mid]

        val left = build_balanced_helper(arr, start, mid - 1, nil_sentinel, depth + 1)
        val right = build_balanced_helper(arr, mid + 1, end, nil_sentinel, depth + 1)

        # Create node (color assigned later)
        val node = create_node(value, BLACK, left, right, nil_sentinel)

        # Set parent references
        var new_node = node
        if is_nil_node(left, nil_sentinel) == false:
            val updated_left = set_node_parent(left, new_node)
            new_node = set_node_left(new_node, updated_left)
        else:
            ()

        if is_nil_node(right, nil_sentinel) == false:
            val updated_right = set_node_parent(right, new_node)
            new_node = set_node_right(new_node, updated_right)
        else:
            ()

        new_node

# Color tree to maintain Red-Black properties
fn color_tree_helper(node, nil_sentinel, is_root):
    if is_nil_node(node, nil_sentinel):
        nil_sentinel
    else:
        # Root and every other level should be black
        val color = if is_root:
            BLACK
        else:
            RED  # Simplified coloring

        var colored = set_node_color(node, color)

        val left = node_left(colored)
        val right = node_right(colored)

        val new_left = color_tree_helper(left, nil_sentinel, false)
        val new_right = color_tree_helper(right, nil_sentinel, false)

        colored = set_node_left(colored, new_left)
        set_node_right(colored, new_right)

# Insert multiple values
fn rb_insert_many(tree, values):
    if values == []:
        tree
    else:
        val first = values.0
        val rest = values[1:]
        var new_tree = rb_insert(tree, first)
        rb_insert_many(new_tree, rest)

# Delete multiple values
fn rb_delete_many(tree, values):
    if values == []:
        tree
    else:
        val first = values.0
        val rest = values[1:]
        var new_tree = rb_delete(tree, first)
        rb_delete_many(new_tree, rest)

# ============================================================================
# COMPARISON AND SET OPERATIONS
# ============================================================================

# Check if two trees contain the same values
fn trees_equal(tree1, tree2):
    val list1 = rb_to_list(tree1)
    val list2 = rb_to_list(tree2)
    list1 == list2

# Check if tree1 is subset of tree2
fn is_subset(tree1, tree2):
    val values = rb_to_list(tree1)
    all_contained(values, tree2)

# Check if all values are in tree
fn all_contained(values, tree):
    if values == []:
        true
    else:
        val first = values.0
        val rest = values[1:]
        val found = rb_search(tree, first)
        if found:
            all_contained(rest, tree)
        else:
            false

# Union of two trees
fn rb_union(tree1, tree2):
    val values2 = rb_to_list(tree2)
    rb_insert_many(tree1, values2)

# Intersection of two trees
fn rb_intersection(tree1, tree2):
    val values1 = rb_to_list(tree1)
    val common = filter_contained(values1, tree2)
    rb_insert_many(create_rbtree(), common)

# Filter values that are in tree
fn filter_contained(values, tree):
    if values == []:
        []
    else:
        val first = values.0
        val rest = values[1:]
        val rest_filtered = filter_contained(rest, tree)
        val found = rb_search(tree, first)
        if found:
            [first] + rest_filtered
        else:
            rest_filtered

# Difference (values in tree1 but not in tree2)
fn rb_difference(tree1, tree2):
    val values1 = rb_to_list(tree1)
    val diff = filter_not_contained(values1, tree2)
    rb_insert_many(create_rbtree(), diff)

# Filter values not in tree
fn filter_not_contained(values, tree):
    if values == []:
        []
    else:
        val first = values.0
        val rest = values[1:]
        val rest_filtered = filter_not_contained(rest, tree)
        val found = rb_search(tree, first)
        if found:
            rest_filtered
        else:
            [first] + rest_filtered
