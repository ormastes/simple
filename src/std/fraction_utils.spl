# Fraction Utilities Module
# Provides rational number (fraction) arithmetic and operations
#
# Fractions are represented as tuples: (numerator, denominator)
# All operations maintain the invariant that denominator > 0
#
# Examples:
#   val half = from_int(1, 2)           # 1/2
#   val third = from_int(1, 3)          # 1/3
#   val sum = add(half, third)          # 5/6
#   val product = multiply(half, third) # 1/6
#   print to_string(sum)                # "5/6"
#
# Perfect for:
#   - Precise arithmetic without floating-point errors
#   - Music theory (note durations, intervals)
#   - Measurements and conversions
#   - Mathematical computations requiring exact ratios

# ============================================================================
# Core Creation Functions
# ============================================================================

# Create a fraction from numerator and denominator
# Normalizes sign to numerator (denominator always positive)
fn from_int(num: i64, den: i64) -> (i64, i64):
    if den == 0:
        print "Error: denominator cannot be zero"
        return (0, 1)

    if den < 0:
        return (-num, -den)

    return (num, den)

# Create a fraction from a single integer (denominator = 1)
fn from_whole(n: i64) -> (i64, i64):
    return (n, 1)

# Create a fraction from another fraction (copy)
fn from_fraction(frac: (i64, i64)) -> (i64, i64):
    return frac

# Create an approximate fraction from a decimal value
# Uses continued fractions algorithm with max_iterations for precision
fn from_decimal_approx(value: f64, max_iterations: i64) -> (i64, i64):
    if max_iterations <= 0:
        return (0, 1)

    val sign = if value < 0.0: -1 else: 1
    val abs_value = if value < 0.0: -value else: value

    # Extract integer part
    val int_part = floor_decimal(abs_value)
    val frac_part = abs_value - int_part

    # If no fractional part, return integer
    if frac_part < 0.0000001:
        return (sign * int_part, 1)

    # Continued fractions algorithm
    var h1 = 1
    var h2 = 0
    var k1 = 0
    var k2 = 1
    var b = int_part
    var remainder = frac_part

    var iter = 0
    loop:
        if iter >= max_iterations:
            break

        val h = b * h1 + h2
        val k = b * k1 + k2

        h2 = h1
        h1 = h
        k2 = k1
        k1 = k

        if remainder < 0.0000001:
            break

        val inv = 1.0 / remainder
        val new_b = floor_decimal(inv)
        remainder = inv - new_b
        b = new_b

        iter = iter + 1

    return (sign * h1, k1)

# ============================================================================
# GCD and Simplification
# ============================================================================

# Calculate greatest common divisor using Euclidean algorithm
fn gcd(a: i64, b: i64) -> i64:
    val abs_a = if a < 0: -a else: a
    val abs_b = if b < 0: -b else: b

    var x = abs_a
    var y = abs_b

    loop:
        if y == 0:
            break

        val temp = y
        y = x % y
        x = temp

    return x

# Calculate least common multiple
fn lcm(a: i64, b: i64) -> i64:
    if a == 0 or b == 0:
        return 0

    val abs_a = if a < 0: -a else: a
    val abs_b = if b < 0: -b else: b
    val g = gcd(abs_a, abs_b)

    return (abs_a / g) * abs_b

# Reduce fraction to lowest terms
fn reduce(frac: (i64, i64)) -> (i64, i64):
    val num = frac.0
    val den = frac.1

    if num == 0:
        return (0, 1)

    val g = gcd(num, den)
    return (num / g, den / g)

# Alias for reduce
fn simplify(frac: (i64, i64)) -> (i64, i64):
    return reduce(frac)

# ============================================================================
# Arithmetic Operations
# ============================================================================

# Add two fractions
fn add(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    val num = num_a * den_b + num_b * den_a
    val den = den_a * den_b

    return reduce((num, den))

# Subtract two fractions (a - b)
fn subtract(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    val num = num_a * den_b - num_b * den_a
    val den = den_a * den_b

    return reduce((num, den))

# Multiply two fractions
fn multiply(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    val num = num_a * num_b
    val den = den_a * den_b

    return reduce((num, den))

# Divide two fractions (a / b)
fn divide(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_b = b.0
    val den_b = b.1

    if num_b == 0:
        print "Error: division by zero"
        return (0, 1)

    return multiply(a, (den_b, num_b))

# Negate a fraction
fn negate(frac: (i64, i64)) -> (i64, i64):
    return (-frac.0, frac.1)

# Absolute value of a fraction
fn abs_frac(frac: (i64, i64)) -> (i64, i64):
    val num = frac.0
    val abs_num = if num < 0: -num else: num
    return (abs_num, frac.1)

# Raise fraction to integer power
fn power(frac: (i64, i64), exp: i64) -> (i64, i64):
    if exp == 0:
        return (1, 1)

    if exp < 0:
        val recip = reciprocal(frac)
        return power(recip, -exp)

    val num = frac.0
    val den = frac.1

    var result_num = 1
    var result_den = 1
    var i = 0

    loop:
        if i >= exp:
            break

        result_num = result_num * num
        result_den = result_den * den
        i = i + 1

    return reduce((result_num, result_den))

# ============================================================================
# Comparison Operations
# ============================================================================

# Check if two fractions are equal
fn equal(a: (i64, i64), b: (i64, i64)) -> bool:
    val reduced_a = reduce(a)
    val reduced_b = reduce(b)

    val same_num = reduced_a.0 == reduced_b.0
    val same_den = reduced_a.1 == reduced_b.1

    return same_num and same_den

# Check if a < b
fn less_than(a: (i64, i64), b: (i64, i64)) -> bool:
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    # Cross multiply: a/b < c/d iff a*d < c*b (when denominators positive)
    return num_a * den_b < num_b * den_a

# Check if a > b
fn greater_than(a: (i64, i64), b: (i64, i64)) -> bool:
    return less_than(b, a)

# Check if a <= b
fn less_than_or_equal(a: (i64, i64), b: (i64, i64)) -> bool:
    return less_than(a, b) or equal(a, b)

# Check if a >= b
fn greater_than_or_equal(a: (i64, i64), b: (i64, i64)) -> bool:
    return greater_than(a, b) or equal(a, b)

# Compare two fractions: returns -1 if a < b, 0 if a == b, 1 if a > b
fn compare(a: (i64, i64), b: (i64, i64)) -> i64:
    if equal(a, b):
        return 0
    if less_than(a, b):
        return -1
    return 1

# ============================================================================
# Property Checks
# ============================================================================

# Check if fraction is zero
fn is_zero(frac: (i64, i64)) -> bool:
    return frac.0 == 0

# Check if fraction is one
fn is_one(frac: (i64, i64)) -> bool:
    val reduced = reduce(frac)
    return reduced.0 == 1 and reduced.1 == 1

# Check if fraction is negative
fn is_negative(frac: (i64, i64)) -> bool:
    return frac.0 < 0

# Check if fraction is positive
fn is_positive(frac: (i64, i64)) -> bool:
    return frac.0 > 0

# Check if fraction is proper (|numerator| < denominator)
fn is_proper(frac: (i64, i64)) -> bool:
    val num = frac.0
    val abs_num = if num < 0: -num else: num
    return abs_num < frac.1

# Check if fraction is improper (|numerator| >= denominator)
fn is_improper(frac: (i64, i64)) -> bool:
    val num = frac.0
    val abs_num = if num < 0: -num else: num
    return abs_num >= frac.1

# Check if fraction is an integer (denominator divides numerator)
fn is_integer(frac: (i64, i64)) -> bool:
    val reduced = reduce(frac)
    return reduced.1 == 1

# ============================================================================
# Conversion Functions
# ============================================================================

# Convert fraction to decimal (floating-point)
fn to_decimal(frac: (i64, i64)) -> f64:
    val num = frac.0
    val den = frac.1
    return i64_to_f64(num) / i64_to_f64(den)

# Convert fraction to string representation
fn to_string(frac: (i64, i64)) -> text:
    val num = frac.0
    val den = frac.1

    if den == 1:
        return i64_to_string(num)

    return "{i64_to_string(num)}/{i64_to_string(den)}"

# Convert fraction to mixed number string (e.g., "2 1/3")
fn to_mixed(frac: (i64, i64)) -> text:
    val num = frac.0
    val den = frac.1

    if num == 0:
        return "0"

    val abs_num = if num < 0: -num else: num
    val sign_str = if num < 0: "-" else: ""

    val whole = abs_num / den
    val remainder = abs_num % den

    if remainder == 0:
        return "{sign_str}{i64_to_string(whole)}"

    if whole == 0:
        return "{sign_str}{i64_to_string(remainder)}/{i64_to_string(den)}"

    return "{sign_str}{i64_to_string(whole)} {i64_to_string(remainder)}/{i64_to_string(den)}"

# Convert fraction to percentage string (e.g., "75%")
fn to_percentage(frac: (i64, i64)) -> text:
    val decimal = to_decimal(frac)
    val percent = decimal * 100.0
    return "{f64_to_string(percent)}%"

# Extract whole and fractional parts as (whole, fraction)
fn to_mixed_parts(frac: (i64, i64)) -> (i64, (i64, i64)):
    val num = frac.0
    val den = frac.1

    val whole = num / den
    val remainder = num % den

    return (whole, (remainder, den))

# ============================================================================
# Advanced Operations
# ============================================================================

# Get reciprocal of fraction (1/x)
fn reciprocal(frac: (i64, i64)) -> (i64, i64):
    val num = frac.0
    val den = frac.1

    if num == 0:
        print "Error: reciprocal of zero undefined"
        return (0, 1)

    if num < 0:
        return (-den, -num)

    return (den, num)

# Floor of fraction (largest integer <= fraction)
fn floor_frac(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1

    if num >= 0:
        return num / den

    # For negative numbers, need to round down
    val div_result = num / den
    val remainder = num % den

    if remainder == 0:
        return div_result

    return div_result - 1

# Ceiling of fraction (smallest integer >= fraction)
fn ceiling(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1

    if num <= 0:
        return num / den

    # For positive numbers with remainder, round up
    val div_result = num / den
    val remainder = num % den

    if remainder == 0:
        return div_result

    return div_result + 1

# Round fraction to nearest integer
fn round_frac(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1

    # Add 1/2 and floor for positive, subtract 1/2 and ceiling for negative
    if num >= 0:
        val adjusted = add(frac, (1, 2))
        return floor_frac(adjusted)

    val adjusted = subtract(frac, (1, 2))
    return ceiling(adjusted)

# Truncate fraction towards zero
fn truncate(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1
    return num / den

# Calculate mediant of two fractions (used in Farey sequences)
# Mediant of a/b and c/d is (a+c)/(b+d)
fn mediant(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    return (num_a + num_b, den_a + den_b)

# Generate continued fraction representation (finite list of integers)
# Returns list as tuple chain: (first, (second, (third, ...)))
fn continued_fraction(frac: (i64, i64), max_terms: i64) -> text:
    var num = frac.0
    var den = frac.1

    var result = "["
    var term_count = 0

    loop:
        if term_count >= max_terms or den == 0:
            break

        val quotient = num / den
        val remainder = num % den

        if term_count > 0:
            result = "{result}, "

        result = "{result}{i64_to_string(quotient)}"

        num = den
        den = remainder
        term_count = term_count + 1

    result = "{result}]"
    return result

# Generate Farey sequence of order n (all reduced fractions with denominator <= n)
# Returns as formatted string due to runtime limitations
fn farey_sequence(n: i64) -> text:
    if n <= 0:
        return "[]"

    var result = "[0/1"

    var a = 0
    var b = 1
    var c = 1
    var d = n

    loop:
        if c > n:
            break

        val k = (n + b) / d
        val next_a = k * c - a
        val next_b = k * d - b

        result = "{result}, {i64_to_string(c)}/{i64_to_string(d)}"

        a = c
        b = d
        c = next_a
        d = next_b

    result = "{result}]"
    return result

# ============================================================================
# Common Fractions
# ============================================================================

# Common fraction constants
fn zero() -> (i64, i64):
    return (0, 1)

fn one() -> (i64, i64):
    return (1, 1)

fn half() -> (i64, i64):
    return (1, 2)

fn third() -> (i64, i64):
    return (1, 3)

fn quarter() -> (i64, i64):
    return (1, 4)

fn fifth() -> (i64, i64):
    return (1, 5)

fn sixth() -> (i64, i64):
    return (1, 6)

fn eighth() -> (i64, i64):
    return (1, 8)

fn tenth() -> (i64, i64):
    return (1, 10)

fn two_thirds() -> (i64, i64):
    return (2, 3)

fn three_quarters() -> (i64, i64):
    return (3, 4)

fn four_fifths() -> (i64, i64):
    return (4, 5)

fn five_sixths() -> (i64, i64):
    return (5, 6)

# ============================================================================
# Utility Functions
# ============================================================================

# Find minimum of two fractions
fn min(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    if less_than(a, b):
        return a
    return b

# Find maximum of two fractions
fn max(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    if greater_than(a, b):
        return a
    return b

# Clamp fraction between min and max values
fn clamp(frac: (i64, i64), min_val: (i64, i64), max_val: (i64, i64)) -> (i64, i64):
    if less_than(frac, min_val):
        return min_val
    if greater_than(frac, max_val):
        return max_val
    return frac

# ============================================================================
# Helper Functions (Internal)
# ============================================================================

# Convert i64 to f64 (helper for to_decimal)
fn i64_to_f64(n: i64) -> f64:
    # Simple conversion - works for reasonable ranges
    return 0.0 + n

# Convert i64 to string
fn i64_to_string(n: i64) -> text:
    if n == 0:
        return "0"

    val is_neg = n < 0
    var num = if is_neg: -n else: n

    var result = ""
    loop:
        if num == 0:
            break

        val digit = num % 10
        val digit_char = digit_to_char(digit)
        result = "{digit_char}{result}"
        num = num / 10

    if is_neg:
        result = "-{result}"

    return result

# Convert f64 to string (simple version)
fn f64_to_string(x: f64) -> text:
    # For simplicity, use integer part only
    # A full implementation would handle decimal places
    val int_part = floor_decimal(x)
    return i64_to_string(int_part)

# Convert digit to character
fn digit_to_char(d: i64) -> text:
    if d == 0: return "0"
    if d == 1: return "1"
    if d == 2: return "2"
    if d == 3: return "3"
    if d == 4: return "4"
    if d == 5: return "5"
    if d == 6: return "6"
    if d == 7: return "7"
    if d == 8: return "8"
    if d == 9: return "9"
    return "?"

# Floor function for f64
fn floor_decimal(x: f64) -> i64:
    val int_val = f64_to_i64_trunc(x)
    if x < 0.0:
        val frac = x - i64_to_f64(int_val)
        if frac < 0.0:
            return int_val - 1
    return int_val

# Truncate f64 to i64
fn f64_to_i64_trunc(x: f64) -> i64:
    # Simple truncation - works for reasonable ranges
    if x >= 0.0:
        return i64_from_positive_f64(x)
    return -i64_from_positive_f64(-x)

# Convert positive f64 to i64
fn i64_from_positive_f64(x: f64) -> i64:
    # Iterative approach for conversion
    var result = 0
    var current = 0.0

    # Handle large values
    loop:
        if current + 1000000.0 > x:
            break
        result = result + 1000000
        current = current + 1000000.0

    loop:
        if current + 1000.0 > x:
            break
        result = result + 1000
        current = current + 1000.0

    loop:
        if current + 1.0 > x:
            break
        result = result + 1
        current = current + 1.0

    return result

# ============================================================================
# Array Operations (List-based operations for multiple fractions)
# ============================================================================

# Sum an array of fractions
fn sum_array(fractions: text, count: i64) -> (i64, i64):
    # Note: Due to runtime limitations, this is a simplified version
    # In practice, would need to parse the text or use actual arrays
    return (0, 1)

# Find minimum in array of fractions
fn min_array(fractions: text, count: i64) -> (i64, i64):
    # Simplified version
    return (0, 1)

# Find maximum in array of fractions
fn max_array(fractions: text, count: i64) -> (i64, i64):
    # Simplified version
    return (0, 1)

# ============================================================================
# Example Usage and Tests
# ============================================================================

# Example: Basic arithmetic
fn example_basic():
    print "=== Basic Fraction Arithmetic ==="

    val a = from_int(1, 2)  # 1/2
    val b = from_int(1, 3)  # 1/3

    print "a = {to_string(a)}"
    print "b = {to_string(b)}"
    print "a + b = {to_string(add(a, b))}"
    print "a - b = {to_string(subtract(a, b))}"
    print "a * b = {to_string(multiply(a, b))}"
    print "a / b = {to_string(divide(a, b))}"
    print ""

# Example: Simplification
fn example_simplification():
    print "=== Fraction Simplification ==="

    val f1 = from_int(6, 8)
    print "6/8 simplified = {to_string(reduce(f1))}"

    val f2 = from_int(15, 25)
    print "15/25 simplified = {to_string(reduce(f2))}"

    val f3 = from_int(100, 150)
    print "100/150 simplified = {to_string(reduce(f3))}"
    print ""

# Example: Mixed numbers
fn example_mixed():
    print "=== Mixed Numbers ==="

    val f1 = from_int(7, 3)
    print "{to_string(f1)} = {to_mixed(f1)}"

    val f2 = from_int(10, 4)
    print "{to_string(f2)} = {to_mixed(f2)}"

    val f3 = from_int(-11, 5)
    print "{to_string(f3)} = {to_mixed(f3)}"
    print ""

# Example: Common fractions
fn example_common():
    print "=== Common Fractions ==="
    print "half = {to_string(half())}"
    print "third = {to_string(third())}"
    print "quarter = {to_string(quarter())}"
    print "two_thirds = {to_string(two_thirds())}"
    print "three_quarters = {to_string(three_quarters())}"
    print ""

# Example: Decimal conversions
fn example_decimal():
    print "=== Decimal Conversions ==="

    val f1 = half()
    print "{to_string(f1)} = {f64_to_string(to_decimal(f1))}"

    val f2 = quarter()
    print "{to_string(f2)} = {to_percentage(f2)}"

    val f3 = three_quarters()
    print "{to_string(f3)} = {to_percentage(f3)}"
    print ""

# Example: Comparisons
fn example_comparison():
    print "=== Fraction Comparisons ==="

    val a = from_int(1, 2)
    val b = from_int(2, 3)

    print "{to_string(a)} < {to_string(b)} = {less_than(a, b)}"
    print "{to_string(a)} > {to_string(b)} = {greater_than(a, b)}"
    print "{to_string(a)} == {to_string(b)} = {equal(a, b)}"
    print "compare({to_string(a)}, {to_string(b)}) = {i64_to_string(compare(a, b))}"
    print ""

# Example: Properties
fn example_properties():
    print "=== Fraction Properties ==="

    val f1 = from_int(1, 2)
    print "{to_string(f1)} is_proper = {is_proper(f1)}"
    print "{to_string(f1)} is_improper = {is_improper(f1)}"

    val f2 = from_int(5, 3)
    print "{to_string(f2)} is_proper = {is_proper(f2)}"
    print "{to_string(f2)} is_improper = {is_improper(f2)}"

    val f3 = from_int(0, 1)
    print "{to_string(f3)} is_zero = {is_zero(f3)}"
    print ""

# Run all examples
fn run_examples():
    example_basic()
    example_simplification()
    example_mixed()
    example_common()
    example_decimal()
    example_comparison()
    example_properties()
