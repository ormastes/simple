# FSM Transition Operations

fn get_transitions(fsm: FSM, from_state: text) -> [FSMTransition]:
    """Get all transitions from a given state."""
    var result: [FSMTransition] = []
    for i in 0..fsm.transitions.len():
        if fsm.transitions[i].from_state == from_state:
            result = result + [fsm.transitions[i]]
    result

fn has_transition(fsm: FSM, from_state: text, symbol: text) -> bool:
    """Check if a transition exists from state on symbol."""
    for i in 0..fsm.transitions.len():
        var trans = fsm.transitions[i]
        if trans.from_state == from_state and trans.symbol == symbol:
            return true
    false

fn remove_transition(fsm: FSM, from_state: text, to_state: text, symbol: text) -> FSM:
    """Remove a specific transition from the FSM."""
    var new_transitions: [FSMTransition] = []

    for i in 0..fsm.transitions.len():
        var trans = fsm.transitions[i]
        var remove_it = false
        if trans.from_state == from_state and trans.to_state == to_state and trans.symbol == symbol:
            remove_it = true

        if not remove_it:
            new_transitions = new_transitions + [trans]

    FSM(
        states: fsm.states,
        transitions: new_transitions,
        initial_state: fsm.initial_state,
        current: fsm.current,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn has_epsilon_transitions(fsm: FSM) -> bool:
    """Check if FSM has any epsilon transitions."""
    for i in 0..fsm.transitions.len():
        var symbol = fsm.transitions[i].symbol
        if symbol == "epsilon" or symbol == "":
            return true
    false

fn epsilon_closure(fsm: FSM, state: text) -> [text]:
    """Compute epsilon closure of a state (all states reachable via epsilon transitions)."""
    var closure: [text] = [state]
    var queue: [text] = [state]
    var queue_start = 0

    while queue_start < queue.len():
        var current = queue[queue_start]
        queue_start = queue_start + 1

        # Find epsilon transitions from current state
        for i in 0..fsm.transitions.len():
            var trans = fsm.transitions[i]
            var is_epsilon = false
            if trans.symbol == "epsilon" or trans.symbol == "":
                is_epsilon = true

            if trans.from_state == current and is_epsilon:
                # Check if to_state is already in closure
                var already_in_closure = false
                for j in 0..closure.len():
                    if closure[j] == trans.to_state:
                        already_in_closure = true

                if not already_in_closure:
                    closure = closure + [trans.to_state]
                    queue = queue + [trans.to_state]

    closure
