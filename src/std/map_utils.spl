# Map/Dictionary Utilities Module
#
# Map/dictionary operations using array-based implementation.
# Maps are represented as arrays of (key, value) tuples.
# Keys are strings (text), values are any type.
#
# Note: Not optimized for large datasets (O(n) lookups).
# For production use, consider implementing hash-based structures.
#
# Categories:
# - Core operations: map_create, map_get, map_put, map_remove
# - Access helpers: map_get_or_default, map_get_or_compute, map_update
# - Predicates: map_contains_key, map_is_empty, map_size
# - Iteration: map_keys, map_values, map_entries, map_for_each
# - Transformations: map_map_keys, map_map_values, map_filter, map_partition
# - Set operations: map_merge, map_merge_with, map_difference, map_intersection
# - Conversion: map_from_array, map_to_array, map_from_entries
# - Advanced: map_group_by, map_invert, map_flatten, map_nested_get, map_nested_put
#
# Example:
#     val m = map_create()
#     val m2 = map_put(m, "name", "Alice")
#     val m3 = map_put(m2, "age", 30)
#     map_get(m3, "name")  # "Alice"
#     map_keys(m3)         # ["name", "age"]

# ============================================================================
# Core Map Operations
# ============================================================================

fn map_create():
    """Create an empty map.

    Example:
        val m = map_create()  # []
    """
    []

fn map_get(map, key: text):
    """Get value for key. Returns nil if key not found.

    Example:
        val m = map_put(map_create(), "x", 10)
        map_get(m, "x")  # 10
        map_get(m, "y")  # nil
    """
    var i = 0
    while i < map.len():
        val entry = map[i]
        if entry[0] == key:
            return entry[1]
        i = i + 1
    nil

fn map_put(map, key: text, value):
    """Add or update key-value pair. Returns new map.

    If key exists, updates value. Otherwise adds new entry.

    Example:
        val m = map_create()
        val m2 = map_put(m, "x", 10)
        val m3 = map_put(m2, "x", 20)  # Updates x
        map_get(m3, "x")  # 20
    """
    var result = []
    var found = false

    var i = 0
    while i < map.len():
        val entry = map[i]
        if entry[0] == key:
            result.push((key, value))
            found = true
        else:
            result.push(entry)
        i = i + 1

    if not found:
        result.push((key, value))

    result

fn map_remove(map, key: text):
    """Remove key from map. Returns new map without the key.

    Example:
        val m = map_put(map_create(), "x", 10)
        val m2 = map_remove(m, "x")
        map_get(m2, "x")  # nil
    """
    var result = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        if entry[0] != key:
            result.push(entry)
        i = i + 1
    result

fn map_clear(map):
    """Remove all entries from map. Returns empty map.

    Example:
        val m = map_put(map_create(), "x", 10)
        val m2 = map_clear(m)
        map_size(m2)  # 0
    """
    []

# ============================================================================
# Access Helpers
# ============================================================================

fn map_get_or_default(map, key: text, default_value):
    """Get value for key, or return default if not found.

    Example:
        val m = map_put(map_create(), "x", 10)
        map_get_or_default(m, "x", 0)  # 10
        map_get_or_default(m, "y", 0)  # 0
    """
    val result = map_get(map, key)
    if result == nil:
        return default_value
    result

fn map_get_or_compute(map, key: text, compute_fn):
    """Get value for key, or compute and store if not found.

    Returns tuple: (new_map, value)

    Example:
        val m = map_create()
        val result = map_get_or_compute(m, "x", \: 42)
        val new_map = result[0]
        val value = result[1]  # 42
    """
    val existing = map_get(map, key)
    if existing != nil:
        return (map, existing)

    val computed = compute_fn()
    val new_map = map_put(map, key, computed)
    (new_map, computed)

fn map_update(map, key: text, update_fn):
    """Update value for key using function. Returns new map.

    If key doesn't exist, does nothing.

    Example:
        val m = map_put(map_create(), "x", 10)
        val m2 = map_update(m, "x", \v: v + 5)
        map_get(m2, "x")  # 15
    """
    val existing = map_get(map, key)
    if existing == nil:
        return map

    val new_value = update_fn(existing)
    map_put(map, key, new_value)

fn map_update_or_insert(map, key: text, update_fn, default_value):
    """Update existing value or insert default if key not found.

    Example:
        val m = map_create()
        val m2 = map_update_or_insert(m, "x", \v: v + 1, 0)
        map_get(m2, "x")  # 0
        val m3 = map_update_or_insert(m2, "x", \v: v + 1, 0)
        map_get(m3, "x")  # 1
    """
    val existing = map_get(map, key)
    if existing == nil:
        return map_put(map, key, default_value)

    val new_value = update_fn(existing)
    map_put(map, key, new_value)

# ============================================================================
# Predicates
# ============================================================================

fn map_contains_key(map, key: text) -> bool:
    """Check if map contains the given key.

    Example:
        val m = map_put(map_create(), "x", 10)
        map_contains_key(m, "x")  # true
        map_contains_key(m, "y")  # false
    """
    var i = 0
    while i < map.len():
        val entry = map[i]
        if entry[0] == key:
            return true
        i = i + 1
    false

fn map_contains_value(map, value) -> bool:
    """Check if map contains the given value.

    Example:
        val m = map_put(map_create(), "x", 10)
        map_contains_value(m, 10)  # true
        map_contains_value(m, 20)  # false
    """
    var i = 0
    while i < map.len():
        val entry = map[i]
        if entry[1] == value:
            return true
        i = i + 1
    false

fn map_is_empty(map) -> bool:
    """Check if map is empty.

    Example:
        map_is_empty(map_create())  # true
        map_is_empty(map_put(map_create(), "x", 1))  # false
    """
    map.len() == 0

fn map_size(map) -> i64:
    """Get number of key-value pairs in map.

    Example:
        val m = map_put(map_create(), "x", 10)
        map_size(m)  # 1
    """
    map.len()

# ============================================================================
# Iteration
# ============================================================================

fn map_keys(map):
    """Get array of all keys in map.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        map_keys(m)  # ["x", "y"]
    """
    var result = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        result.push(entry[0])
        i = i + 1
    result

fn map_values(map):
    """Get array of all values in map.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        map_values(m)  # [1, 2]
    """
    var result = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        result.push(entry[1])
        i = i + 1
    result

fn map_entries(map):
    """Get array of all (key, value) tuples.

    Same as the map itself, but provided for consistency.

    Example:
        val m = map_put(map_create(), "x", 1)
        map_entries(m)  # [("x", 1)]
    """
    map

fn map_for_each(map, fn):
    """Apply function to each key-value pair.

    Function receives (key, value) as arguments.

    Example:
        val m = map_put(map_create(), "x", 1)
        map_for_each(m, \k, v: print "{k} -> {v}")
    """
    var i = 0
    while i < map.len():
        val entry = map[i]
        fn(entry[0], entry[1])
        i = i + 1
    nil

fn map_find(map, predicate):
    """Find first entry matching predicate. Returns tuple or nil.

    Predicate receives (key, value) and returns bool.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        map_find(m, \k, v: v > 1)  # ("y", 2)
    """
    var i = 0
    while i < map.len():
        val entry = map[i]
        if predicate(entry[0], entry[1]):
            return entry
        i = i + 1
    nil

# ============================================================================
# Transformations
# ============================================================================

fn map_map_keys(map, key_fn):
    """Transform all keys using function. Returns new map.

    Warning: If transformation creates duplicate keys, last one wins.

    Example:
        val m = map_put(map_create(), "x", 1)
        val m2 = map_map_keys(m, \k: k.to_upper())
        map_keys(m2)  # ["X"]
    """
    var result = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        val new_key = key_fn(entry[0])
        result.push((new_key, entry[1]))
        i = i + 1
    result

fn map_map_values(map, value_fn):
    """Transform all values using function. Returns new map.

    Example:
        val m = map_put(map_create(), "x", 1)
        val m2 = map_map_values(m, \v: v * 2)
        map_get(m2, "x")  # 2
    """
    var result = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        val new_value = value_fn(entry[1])
        result.push((entry[0], new_value))
        i = i + 1
    result

fn map_map_entries(map, entry_fn):
    """Transform all entries using function. Returns new map.

    Function receives (key, value) and returns new (key, value) tuple.

    Example:
        val m = map_put(map_create(), "x", 1)
        val m2 = map_map_entries(m, \k, v: (k.to_upper(), v * 2))
        map_get(m2, "X")  # 2
    """
    var result = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        val new_entry = entry_fn(entry[0], entry[1])
        result.push(new_entry)
        i = i + 1
    result

fn map_filter(map, predicate):
    """Filter map by predicate. Returns new map with matching entries.

    Predicate receives (key, value) and returns bool.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_filter(m, \k, v: v > 1)
        map_size(m2)  # 1
        map_get(m2, "y")  # 2
    """
    var result = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        if predicate(entry[0], entry[1]):
            result.push(entry)
        i = i + 1
    result

fn map_filter_keys(map, key_predicate):
    """Filter map by key predicate.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_filter_keys(m, \k: k == "x")
        map_size(m2)  # 1
    """
    map_filter(map, \k, v: key_predicate(k))

fn map_filter_values(map, value_predicate):
    """Filter map by value predicate.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_filter_values(m, \v: v > 1)
        map_get(m2, "y")  # 2
    """
    map_filter(map, \k, v: value_predicate(v))

fn map_partition(map, predicate):
    """Partition map into two maps based on predicate.

    Returns tuple: (matching_map, non_matching_map)

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        val parts = map_partition(m, \k, v: v > 1)
        val high = parts[0]  # {"y": 2}
        val low = parts[1]   # {"x": 1}
    """
    var true_map = []
    var false_map = []

    var i = 0
    while i < map.len():
        val entry = map[i]
        if predicate(entry[0], entry[1]):
            true_map.push(entry)
        else:
            false_map.push(entry)
        i = i + 1

    (true_map, false_map)

# ============================================================================
# Set Operations
# ============================================================================

fn map_merge(map1, map2):
    """Merge two maps. Values from map2 override map1 for duplicate keys.

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "y", 2)
        val m3 = map_merge(m1, m2)
        map_size(m3)  # 2
    """
    var result = map1
    var i = 0
    while i < map2.len():
        val entry = map2[i]
        result = map_put(result, entry[0], entry[1])
        i = i + 1
    result

fn map_merge_with(map1, map2, merge_fn):
    """Merge two maps using function to resolve conflicts.

    merge_fn receives (key, value1, value2) and returns merged value.

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "x", 2)
        val m3 = map_merge_with(m1, m2, \k, v1, v2: v1 + v2)
        map_get(m3, "x")  # 3
    """
    var result = map1
    var i = 0
    while i < map2.len():
        val entry = map2[i]
        val key = entry[0]
        val value2 = entry[1]

        val existing = map_get(map1, key)
        if existing == nil:
            result = map_put(result, key, value2)
        else:
            val merged = merge_fn(key, existing, value2)
            result = map_put(result, key, merged)
        i = i + 1
    result

fn map_merge_all(maps):
    """Merge multiple maps. Later maps override earlier ones.

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "y", 2)
        val m3 = map_merge_all([m1, m2])
        map_size(m3)  # 2
    """
    var result = map_create()
    var i = 0
    while i < maps.len():
        result = map_merge(result, maps[i])
        i = i + 1
    result

fn map_difference(map1, map2):
    """Get entries in map1 whose keys are not in map2.

    Example:
        val m1 = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_put(map_create(), "y", 3)
        val m3 = map_difference(m1, m2)
        map_size(m3)  # 1
        map_get(m3, "x")  # 1
    """
    var result = []
    var i = 0
    while i < map1.len():
        val entry = map1[i]
        if not map_contains_key(map2, entry[0]):
            result.push(entry)
        i = i + 1
    result

fn map_intersection(map1, map2):
    """Get entries whose keys exist in both maps. Uses values from map1.

    Example:
        val m1 = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_put(map_create(), "y", 3)
        val m3 = map_intersection(m1, m2)
        map_size(m3)  # 1
        map_get(m3, "y")  # 2
    """
    var result = []
    var i = 0
    while i < map1.len():
        val entry = map1[i]
        if map_contains_key(map2, entry[0]):
            result.push(entry)
        i = i + 1
    result

fn map_symmetric_difference(map1, map2):
    """Get entries whose keys exist in exactly one map.

    Example:
        val m1 = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_put(map_put(map_create(), "y", 3), "z", 4)
        val m3 = map_symmetric_difference(m1, m2)
        map_size(m3)  # 2 (x and z)
    """
    val diff1 = map_difference(map1, map2)
    val diff2 = map_difference(map2, map1)
    map_merge(diff1, diff2)

# ============================================================================
# Conversion
# ============================================================================

fn map_from_array(pairs):
    """Create map from array of (key, value) tuples.

    Same as map itself, but normalizes duplicates (last wins).

    Example:
        val m = map_from_array([("x", 1), ("y", 2)])
        map_get(m, "x")  # 1
    """
    var result = map_create()
    var i = 0
    while i < pairs.len():
        val pair = pairs[i]
        result = map_put(result, pair[0], pair[1])
        i = i + 1
    result

fn map_to_array(map):
    """Convert map to array of (key, value) tuples.

    Same as map itself, provided for consistency.

    Example:
        val m = map_put(map_create(), "x", 1)
        map_to_array(m)  # [("x", 1)]
    """
    map

fn map_from_entries(entries):
    """Create map from array of (key, value) tuples.

    Alias for map_from_array.
    """
    map_from_array(entries)

fn map_from_keys(keys, value_fn):
    """Create map from array of keys using function to generate values.

    Example:
        val m = map_from_keys(["x", "y"], \k: k.len())
        map_get(m, "x")  # 1
    """
    var result = map_create()
    var i = 0
    while i < keys.len():
        val key = keys[i]
        val value = value_fn(key)
        result = map_put(result, key, value)
        i = i + 1
    result

fn map_from_values(values, key_fn):
    """Create map from array of values using function to generate keys.

    Example:
        val m = map_from_values([1, 2, 3], \v: "key{v}")
        map_get(m, "key1")  # 1
    """
    var result = map_create()
    var i = 0
    while i < values.len():
        val value = values[i]
        val key = key_fn(value)
        result = map_put(result, key, value)
        i = i + 1
    result

# ============================================================================
# Advanced Operations
# ============================================================================

fn map_group_by(items, key_fn):
    """Group items by key function. Returns map of key -> [items].

    Example:
        val items = [("Alice", 25), ("Bob", 30), ("Charlie", 25)]
        val m = map_group_by(items, \item: "{item[1]}")
        map_get(m, "25")  # [("Alice", 25), ("Charlie", 25)]
    """
    var result = map_create()
    var i = 0
    while i < items.len():
        val item = items[i]
        val key = key_fn(item)

        val existing = map_get(result, key)
        if existing == nil:
            result = map_put(result, key, [item])
        else:
            var new_group = existing
            new_group.push(item)
            result = map_put(result, key, new_group)
        i = i + 1
    result

fn map_invert(map):
    """Invert map (swap keys and values). Values become keys as strings.

    Warning: If multiple keys have same value, last one wins.

    Example:
        val m = map_put(map_create(), "x", 1)
        val m2 = map_invert(m)
        map_get(m2, "1")  # "x"
    """
    var result = map_create()
    var i = 0
    while i < map.len():
        val entry = map[i]
        val new_key = "{entry[1]}"
        val new_value = entry[0]
        result = map_put(result, new_key, new_value)
        i = i + 1
    result

fn map_flatten(map):
    """Flatten nested map structure (one level only).

    If values are maps, merges them into parent with combined keys.
    Uses "parent.child" key format.

    Example:
        val inner = map_put(map_create(), "b", 2)
        val outer = map_put(map_create(), "a", inner)
        val flat = map_flatten(outer)
        # Not applicable for non-map values
    """
    var result = map_create()
    var i = 0
    while i < map.len():
        val entry = map[i]
        val key = entry[0]
        val value = entry[1]

        result = map_put(result, key, value)
        i = i + 1
    result

fn map_nested_get(map, keys):
    """Get value from nested map using array of keys.

    Example:
        val inner = map_put(map_create(), "b", 2)
        val outer = map_put(map_create(), "a", inner)
        map_nested_get(outer, ["a", "b"])  # 2
    """
    var current = map
    var i = 0
    while i < keys.len():
        val key = keys[i]
        current = map_get(current, key)
        if current == nil:
            return nil
        i = i + 1
    current

fn map_nested_put(map, keys, value):
    """Set value in nested map using array of keys.

    Creates intermediate maps as needed.

    Example:
        val m = map_create()
        val m2 = map_nested_put(m, ["a", "b"], 2)
        map_nested_get(m2, ["a", "b"])  # 2
    """
    if keys.len() == 0:
        return map

    if keys.len() == 1:
        return map_put(map, keys[0], value)

    val first_key = keys[0]
    val rest_keys = keys[1:]

    val existing = map_get(map, first_key)
    val inner_map = if existing == nil: map_create() else: existing

    val updated_inner = map_nested_put(inner_map, rest_keys, value)
    map_put(map, first_key, updated_inner)

fn map_count_by(items, key_fn):
    """Count items by key function. Returns map of key -> count.

    Example:
        val items = ["a", "b", "a", "c", "a"]
        val m = map_count_by(items, \x: x)
        map_get(m, "a")  # 3
    """
    var result = map_create()
    var i = 0
    while i < items.len():
        val item = items[i]
        val key = key_fn(item)

        val existing = map_get(result, key)
        val count = if existing == nil: 1 else: existing + 1
        result = map_put(result, key, count)
        i = i + 1
    result

fn map_reduce(map, init, reduce_fn):
    """Reduce map to single value using accumulator function.

    reduce_fn receives (accumulator, key, value) and returns new accumulator.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        val sum = map_reduce(m, 0, \acc, k, v: acc + v)  # 3
    """
    var acc = init
    var i = 0
    while i < map.len():
        val entry = map[i]
        acc = reduce_fn(acc, entry[0], entry[1])
        i = i + 1
    acc

fn map_every(map, predicate) -> bool:
    """Check if all entries match predicate.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        map_every(m, \k, v: v > 0)  # true
    """
    var i = 0
    while i < map.len():
        val entry = map[i]
        if not predicate(entry[0], entry[1]):
            return false
        i = i + 1
    true

fn map_some(map, predicate) -> bool:
    """Check if any entry matches predicate.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        map_some(m, \k, v: v > 1)  # true
    """
    var i = 0
    while i < map.len():
        val entry = map[i]
        if predicate(entry[0], entry[1]):
            return true
        i = i + 1
    false

fn map_equals(map1, map2) -> bool:
    """Check if two maps are equal (same keys and values).

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "x", 1)
        map_equals(m1, m2)  # true
    """
    if map_size(map1) != map_size(map2):
        return false

    var i = 0
    while i < map1.len():
        val entry = map1[i]
        val key = entry[0]
        val value1 = entry[1]
        val value2 = map_get(map2, key)

        if value2 == nil:
            return false
        if value1 != value2:
            return false
        i = i + 1

    true

fn map_pick(map, keys):
    """Create new map with only specified keys.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_pick(m, ["x"])
        map_size(m2)  # 1
    """
    var result = map_create()
    var i = 0
    while i < keys.len():
        val key = keys[i]
        val value = map_get(map, key)
        if value != nil:
            result = map_put(result, key, value)
        i = i + 1
    result

fn map_omit(map, keys):
    """Create new map without specified keys.

    Example:
        val m = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_omit(m, ["y"])
        map_size(m2)  # 1
    """
    var result = map_create()
    var i = 0
    while i < map.len():
        val entry = map[i]
        val key = entry[0]

        var should_include = true
        var j = 0
        while j < keys.len():
            if keys[j] == key:
                should_include = false
            j = j + 1

        if should_include:
            result.push(entry)
        i = i + 1
    result

fn map_rename_keys(map, key_map):
    """Rename keys according to key mapping.

    key_map is a map of old_key -> new_key.

    Example:
        val m = map_put(map_create(), "x", 1)
        val key_mapping = map_put(map_create(), "x", "y")
        val m2 = map_rename_keys(m, key_mapping)
        map_get(m2, "y")  # 1
    """
    var result = map_create()
    var i = 0
    while i < map.len():
        val entry = map[i]
        val old_key = entry[0]
        val value = entry[1]

        val new_key = map_get(key_map, old_key)
        val final_key = if new_key == nil: old_key else: new_key

        result = map_put(result, final_key, value)
        i = i + 1
    result

fn map_to_string(map) -> text:
    """Convert map to string representation.

    Example:
        val m = map_put(map_create(), "x", 1)
        map_to_string(m)  # "{x: 1}"
    """
    if map_is_empty(map):
        return "{}"

    var parts = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        parts.push("{entry[0]}: {entry[1]}")
        i = i + 1

    "{" + parts.join(", ") + "}"
