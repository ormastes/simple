"""Async Host Module - OS-integrated async runtime for high-performance I/O

@tag:stdlib
@tag:api
@tag:async

This module provides host-side async runtime that integrates with OS-level
async I/O mechanisms (epoll on Linux, kqueue on BSD/macOS, IOCP on Windows).
It offers better performance than std.async for I/O-heavy workloads by
leveraging native OS primitives.

Core Features
-------------

- **OS integration**: epoll/kqueue/IOCP for efficient event notification
- **Join sets**: Manage groups of concurrent tasks
- **Waker mechanism**: Low-overhead task notification
- **Unordered execution**: Process futures as they complete
- **Resource handles**: File descriptors, sockets, timers

Public API
----------

Host runtime:
```simple
use std.async_host.runtime.{HostRuntime, run_until_complete}
```

Host futures:
```simple
use std.async_host.future.{HostFuture, spawn_blocking}
```

Join sets for task management:
```simple
use std.async_host.joinset.{JoinSet}
```

Waker and handles:
```simple
use std.async_host.waker.{Waker}
use std.async_host.handle.{Handle, FileHandle, SocketHandle}
```

Difference from std.async
-------------------------

| Feature | std.async | std.async_host |
|---------|-----------|----------------|
| Portability | Pure Simple, embeddable | OS-specific |
| Performance | Good | Excellent for I/O |
| Use case | General async | High-perf I/O |
| Platform deps | None | epoll/kqueue/IOCP |
| Memory overhead | Lower | Higher |

Use **std.async** for:
- Portable code (no OS dependencies)
- Embedded systems
- Simple async patterns
- Learning async programming

Use **std.async_host** for:
- High-performance servers
- I/O-intensive applications
- Need for OS event loop integration
- Scaling to thousands of connections

Examples
--------

Basic host runtime:
```simple
use std.async_host.runtime.{HostRuntime}
use std.async_host.future.{HostFuture}

# Create host runtime
val runtime = HostRuntime.new()

# Spawn async task
val future = HostFuture.from_fn(\:
    # Async I/O operation
    val data = async_read_file("/tmp/config.txt")
    data.len()
)

# Run until complete
val result = runtime.run_until_complete(future)
print "Read {result} bytes"
```

Join set for multiple tasks:
```simple
use std.async_host.joinset.{JoinSet}
use std.async_host.runtime.{HostRuntime}

val runtime = HostRuntime.new()
val join_set = JoinSet.new()

# Spawn multiple tasks
for i in range(10):
    val future = HostFuture.from_fn(\:
        async_fetch_url("https://example.com/api/{i}")
    )
    join_set.spawn(future)

# Wait for all to complete
while not join_set.is_empty():
    val result = runtime.run_until_complete(join_set.join_next())
    match result:
        case Some(data):
            print "Task completed: {data.len()} bytes"
        case nil:
            break
```

Async file I/O with handles:
```simple
use std.async_host.handle.{FileHandle}
use std.async_host.runtime.{HostRuntime}

val runtime = HostRuntime.new()

# Open file handle
val file = FileHandle.open("/tmp/large_file.txt")

# Async read operation
val future = file.read_async(1024 * 1024)  # Read 1MB

# Run until complete
val data = runtime.run_until_complete(future)
print "Read {data.len()} bytes"

file.close()
```

Async TCP server with OS event loop:
```simple
use std.async_host.handle.{SocketHandle}
use std.async_host.runtime.{HostRuntime}
use std.async_host.joinset.{JoinSet}

val runtime = HostRuntime.new()
val listener = SocketHandle.bind("127.0.0.1:8080")
val join_set = JoinSet.new()

print "Server listening on 127.0.0.1:8080"

# Accept loop
var running = true
while running:
    # Async accept
    val accept_future = listener.accept_async()
    val client = runtime.run_until_complete(accept_future)

    # Spawn handler for each connection
    val handler = HostFuture.from_fn(\:
        # Async read request
        val request = client.read_async(4096)
        val req_data = runtime.run_until_complete(request)

        # Process and respond
        val response = b"HTTP/1.1 200 OK\r\n\r\nHello, World!"
        val write_future = client.write_async(response)
        runtime.run_until_complete(write_future)

        client.close()
    )

    join_set.spawn(handler)
```

Unordered task execution:
```simple
use std.async_host.joinset.{JoinSet}
use std.async_host.runtime.{HostRuntime}

val runtime = HostRuntime.new()
val join_set = JoinSet.new()

# Spawn tasks with different completion times
val urls = [
    "https://fast-api.com/data",
    "https://slow-api.com/data",
    "https://medium-api.com/data"
]

for url in urls:
    val future = HostFuture.from_fn(\: async_fetch(url))
    join_set.spawn(future)

# Process as they complete (not in spawn order)
while not join_set.is_empty():
    val next = join_set.join_next_unordered()
    val result = runtime.run_until_complete(next)
    print "Task completed: {result}"
```

OS Event Loop Integration
--------------------------

Under the hood, std.async_host uses:

- **Linux**: epoll (edge-triggered, supports millions of fds)
- **macOS/BSD**: kqueue (efficient event notification)
- **Windows**: IOCP (completion-based I/O)

The runtime automatically selects the best backend for your OS.

Waker System
------------

Wakers enable efficient task notification:

```simple
use std.async_host.waker.{Waker}

# Create waker for a task
val waker = Waker.new()

# Register waker with I/O system
register_io_waker(fd, waker)

# When I/O ready, waker notifies task
# (Happens automatically in runtime)
```

Performance Tuning
------------------

Configure runtime for best performance:

```simple
val runtime = HostRuntime.new()
    .set_thread_pool_size(4)        # Worker threads
    .set_max_concurrent_ops(10000)  # Max concurrent I/O ops
    .set_event_batch_size(256)      # Events per batch

# Use thread pool for blocking operations
val blocking_task = spawn_blocking(\:
    # CPU-intensive work
    compute_heavy_operation()
)

val result = runtime.run_until_complete(blocking_task)
```

Resource Management
-------------------

Handles provide automatic cleanup:

```simple
# File handle automatically closes on drop
fn process_file() -> i64:
    val file = FileHandle.open("/tmp/data.bin")
    val data = file.read_to_end()
    # file closes automatically here
    data.len()
```

Manual cleanup:
```simple
val file = FileHandle.open("/tmp/data.bin")
# ... use file ...
file.close()  # Explicit close
```

Error Handling
--------------

All async operations return Result types:

```simple
val future = file.read_async(1024)
val result = runtime.run_until_complete(future)

match result:
    case Ok(data):
        print "Read {data.len()} bytes"
    case Err(error):
        print "I/O error: {error.message}"
```

Submodules
----------

- **runtime**: Host runtime and event loop
- **future**: Host-specific future types
- **joinset**: Task group management
- **waker**: Waker and notification system
- **handle**: Resource handles (file, socket, timer)

Related Modules
---------------

- **std.async**: Pure Simple async runtime (portable)
- **std.net**: Synchronous networking (blocking I/O)
- **std.fs**: Synchronous filesystem operations

Performance Notes
-----------------

- Host runtime scales to 100,000+ concurrent connections
- Zero-copy I/O where possible
- Batch event processing reduces syscalls
- Thread pool for blocking operations
- Minimal allocations per task

See Also
--------

- **doc/guide/async_host_runtime.md**: Host runtime guide
- **doc/design/os_event_loops.md**: Event loop design
- **test/unit/std/async_host/**: Async host test examples
"""

# All submodules are automatically available.
