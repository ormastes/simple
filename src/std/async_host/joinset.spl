# HostJoinSet - Await Group
#
# Collection of tasks with streaming completion notification.

use std.async_core.*
use std.async_host.handle.{HostTaskHandle}
use std.async_host.future.{HostFuture}

class HostJoinSet<T>:
    """Dynamic task group with streaming completion.

    Like Rust's tokio::task::JoinSet:
    - Spawn tasks dynamically
    - Yields results as tasks complete
    - Supports cancellation

    Example:
        var set = HostJoinSet<i64>.new()

        for i in 0..10:
            set.add_task(\: compute(i))

        while val Some((id, result)) = await set.join_next():
            print "Task {id}: {result}"
    """
    handles: [HostTaskHandle<T>]
    completed_queue: [(usize, T)]
    next_poll: usize

    static fn new() -> HostJoinSet<T>:
        HostJoinSet(handles: [], completed_queue: [], next_poll: 0)

    fn len() -> usize:
        self.handles.len()

    fn is_empty() -> bool:
        self.handles.is_empty()

    me add_task(f: fn() -> T) -> usize:
        """Add task into set."""
        val id = task_alloc_id()
        val handle = HostTaskHandle(
            task_id: id,
            state: TaskState.Pending,
            result: nil,
            error: nil,
            cancel_token: CancellationToken.new(),
            wakers: []
        )
        self.handles = self.handles.push(handle)
        id

    me add_task_with_priority(f: fn() -> T, priority: Priority) -> usize:
        """Add task with priority."""
        self.add_task(f)  # Priority handled by scheduler

    fn try_join_next() -> Option<(usize, T)>:
        """Non-blocking: get next completed result."""
        # Check completed queue first
        if not self.completed_queue.is_empty():
            val (id, result) = self.completed_queue[0]
            self.completed_queue = self.completed_queue[1:]
            return Some((id, result))

        # Poll handles
        for idx in 0..self.handles.len():
            val handle = self.handles[idx]
            if handle.is_finished():
                match handle.try_join():
                    case Some(result):
                        val id = handle.id()
                        # Remove from handles
                        self.handles = self.handles.remove(idx)
                        return Some((id, result))
                    case nil:
                        pass
        nil

    fn join_next() -> HostFuture<Option<(usize, T)>>:
        """Awaitable: get next completed result."""
        match self.try_join_next():
            case Some(result):
                val ready: HostFuture<Option<(usize, T)>> = HostFuture.ready(Some(result))
                ready
            case nil:
                if self.is_empty():
                    val ready_nil: HostFuture<Option<(usize, T)>> = HostFuture.ready(nil)
                    ready_nil
                else:
                    val pending: HostFuture<Option<(usize, T)>> = HostFuture.pending()
                    pending

    me cancel_all():
        """Cancel all tasks."""
        for handle in self.handles:
            handle.cancel()

    fn pending_count() -> usize:
        """Count of tasks not yet completed."""
        var count: usize = 0
        for handle in self.handles:
            if not handle.is_finished():
                count = count + 1
        count

# Note: HostJoinSet implements JoinSetCore<T> via duck typing


export HostJoinSet
