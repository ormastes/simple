# Host Combinators
#
# Higher-level combinators for working with HostFutures.

use std.async_core.*
use std.async_host.future.{HostFuture}

    """Wait for all futures (preserves order)."""
    var results: [T] = []
    var all_ready = true

    for f in futures:
        match f.poll():
            case Poll.Ready(v):
                results = results.push(v)
            case Poll.Pending:
                all_ready = false

    if all_ready:
        val ready: HostFuture<[T]> = HostFuture.ready(results)
        ready
    else:
        val pending: HostFuture<[T]> = HostFuture.pending()
        pending

fn select<T>(futures: [HostFuture<T>]) -> HostFuture<(usize, T)>:
    """Return first completed future with index."""
    for idx in 0..futures.len():
        match futures[idx].poll():
            case Poll.Ready(v):
                val ready: HostFuture<(usize, T)> = HostFuture.ready((idx, v))
                return ready
            case Poll.Pending:
                pass
    val pending: HostFuture<(usize, T)> = HostFuture.pending()
    pending

fn race<T>(futures: [HostFuture<T>]) -> HostFuture<T>:
    """Return first completed future (discards index)."""
    select(futures).map(\pair: pair.1)

fn timeout<T>(future: HostFuture<T>, millis: usize) -> HostFuture<Result<T, AsyncError>>:
    """Add timeout to future.

    Races the future against a timer. Returns Err(AsyncError.Timeout) if
    the timer fires first.
    """
    val timer = HostFuture.delay(millis).map(\v: Err(AsyncError.Timeout(millis)))
    val wrapped = future.map(\v: Ok(v))
    race([wrapped, timer])


export join_all, select, race, timeout
