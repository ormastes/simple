# HostFuture - Full-Featured Future
#
# Heap-allocated future with waker support, chaining, timeout, and cancellation.

use std.async_core.*
use std.async_host.waker.{Waker, Context}
use ffi.system.{time_now_unix_millis}

class HostFuture<T>:
    """Heap-allocated future with waker support.

    More powerful than EmbeddedFuture:
    - Waker-based notification
    - Chaining with map/then
    - Timeout support
    - Cancellation
    """
    state: FutureState<T>
    wakers: [Waker]
    deadline: i64

enum FutureState<T>:
    Pending
    Ready(T)
    Failed(AsyncError)

impl HostFuture<T>:
    static fn ready(value: T) -> HostFuture<T>:
        """Create completed future."""
        HostFuture(state: FutureState.Ready(value), wakers: [], deadline: 0)

    static fn pending() -> HostFuture<T>:
        """Create pending future."""
        HostFuture(state: FutureState.Pending, wakers: [], deadline: 0)

    static fn failed(err: AsyncError) -> HostFuture<T>:
        """Create failed future."""
        HostFuture(state: FutureState.Failed(err), wakers: [], deadline: 0)

    static fn delay(millis: i64) -> HostFuture<()>:
        """Create a future that completes after millis milliseconds."""
        if millis <= 0:
            return HostFuture.ready(())
        val deadline = time_now_unix_millis() + millis
        HostFuture(state: FutureState.Pending, wakers: [], deadline: deadline)

    fn poll(cx: Context) -> Poll<T>:
        """Poll with context (waker)."""
        # Auto-complete deadline-based futures
        if self.deadline > 0 and time_now_unix_millis() >= self.deadline:
            self.deadline = 0
            self.state = FutureState.Ready(())
            for waker in self.wakers:
                waker.wake()
            self.wakers = []
            return Poll.Ready(())
        match self.state:
            case FutureState.Ready(v):
                Poll.Ready(v)
            case FutureState.Pending:
                # Register waker
                self.wakers = self.wakers.push(cx.waker())
                Poll.Pending
            case FutureState.Failed(e):
                panic("Future failed: {e.message()}")

    fn is_ready() -> bool:
        if self.deadline > 0 and time_now_unix_millis() >= self.deadline:
            return true
        match self.state:
            case FutureState.Ready(_): true
            case _: false

    me complete(value: T):
        """Complete future and wake all waiters."""
        self.state = FutureState.Ready(value)
        for waker in self.wakers:
            waker.wake()
        self.wakers = []

    me fail(err: AsyncError):
        """Fail future."""
        self.state = FutureState.Failed(err)
        for waker in self.wakers:
            waker.wake()
        self.wakers = []

    fn map<U>(f: fn(T) -> U) -> HostFuture<U>:
        """Transform future value."""
        match self.state:
            case FutureState.Ready(v):
                val result: HostFuture<U> = HostFuture.ready(f(v))
                result
            case FutureState.Pending:
                # Create mapped future, propagate deadline
                val pending: HostFuture<U> = HostFuture(
                    state: FutureState.Pending, wakers: [], deadline: self.deadline)
                pending
            case FutureState.Failed(e):
                val failed: HostFuture<U> = HostFuture.failed(e)
                failed

    fn then<U>(f: fn(T) -> HostFuture<U>) -> HostFuture<U>:
        """Chain futures (flatMap)."""
        match self.state:
            case FutureState.Ready(v):
                f(v)
            case FutureState.Pending:
                val pending: HostFuture<U> = HostFuture(
                    state: FutureState.Pending, wakers: [], deadline: self.deadline)
                pending
            case FutureState.Failed(e):
                val failed: HostFuture<U> = HostFuture.failed(e)
                failed

# Note: HostFuture implements FutureCore<T> via duck typing


export HostFuture, FutureState
