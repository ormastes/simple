# HostFuture - Full-Featured Future
#
# Heap-allocated future with waker support, chaining, timeout, and cancellation.

use std.async_core.*
use std.async_host.waker.{Waker, Context}

class HostFuture<T>:
    """Heap-allocated future with waker support.

    More powerful than EmbeddedFuture:
    - Waker-based notification
    - Chaining with map/then
    - Timeout support
    - Cancellation
    """
    state: FutureState<T>
    wakers: [Waker]

enum FutureState<T>:
    Pending
    Ready(T)
    Failed(AsyncError)

impl HostFuture<T>:
    static fn ready(value: T) -> HostFuture<T>:
        """Create completed future."""
        HostFuture(state: FutureState.Ready(value), wakers: [])

    static fn pending() -> HostFuture<T>:
        """Create pending future."""
        HostFuture(state: FutureState.Pending, wakers: [])

    static fn failed(err: AsyncError) -> HostFuture<T>:
        """Create failed future."""
        HostFuture(state: FutureState.Failed(err), wakers: [])

    fn poll(cx: Context) -> Poll<T>:
        """Poll with context (waker)."""
        match self.state:
            case FutureState.Ready(v):
                Poll.Ready(v)
            case FutureState.Pending:
                # Register waker
                self.wakers = self.wakers.push(cx.waker())
                Poll.Pending
            case FutureState.Failed(e):
                panic("Future failed: {e.message()}")

    fn is_ready() -> bool:
        match self.state:
            case FutureState.Ready(_): true
            case _: false

    me complete(value: T):
        """Complete future and wake all waiters."""
        self.state = FutureState.Ready(value)
        for waker in self.wakers:
            waker.wake()
        self.wakers = []

    me fail(err: AsyncError):
        """Fail future."""
        self.state = FutureState.Failed(err)
        for waker in self.wakers:
            waker.wake()
        self.wakers = []

    fn map<U>(f: fn(T) -> U) -> HostFuture<U>:
        """Transform future value."""
        match self.state:
            case FutureState.Ready(v):
                val result: HostFuture<U> = HostFuture.ready(f(v))
                result
            case FutureState.Pending:
                # Create mapped future
                val pending: HostFuture<U> = HostFuture.pending()
                pending
            case FutureState.Failed(e):
                val failed: HostFuture<U> = HostFuture.failed(e)
                failed

    fn then<U>(f: fn(T) -> HostFuture<U>) -> HostFuture<U>:
        """Chain futures (flatMap)."""
        match self.state:
            case FutureState.Ready(v):
                f(v)
            case FutureState.Pending:
                val pending: HostFuture<U> = HostFuture.pending()
                pending
            case FutureState.Failed(e):
                val failed: HostFuture<U> = HostFuture.failed(e)
                failed

# Note: HostFuture implements FutureCore<T> via duck typing


export HostFuture, FutureState
