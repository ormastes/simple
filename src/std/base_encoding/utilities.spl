# Base Encoding Utilities
#
# Text, byte, alphabet, padding, and helper utilities

use string.{char_from_code}
use base_encoding.types.{char_code, PADDING_CHAR}

# ============================================================================
# TEXT UTILITIES
# ============================================================================

fn text_char_at(s: text, pos: i64) -> text:
    """Get character at position in text."""
    var i = 0
    var current_pos = 0
    var result = ""
    var found = false
    while i < s.len():
        if current_pos == pos:
            result = s[i:i+1]
            found = true
            return result
        current_pos = current_pos + 1
        i = i + 1
    result

fn text_length(s: text) -> i64:
    """Get length of text string."""
    s.len()

fn text_contains(s: text, substr: text) -> bool:
    """Check if text contains substring."""
    s.contains(substr)

fn text_concat(a: text, b: text) -> text:
    """Concatenate two text strings."""
    a + b

fn text_split_at(s: text, pos: i64) -> list:
    """Split text at position into two parts."""
    var left = s[0:pos]
    var right = s[pos:s.len()]
    [left, right]

# ============================================================================
# BYTE LIST UTILITIES
# ============================================================================

fn bytes_new() -> list:
    """Create new empty byte list."""
    []

fn bytes_push(bytes: list, byte: i64) -> list:
    """Add byte to list (creates new list)."""
    var result = bytes
    result.push(byte)
    result

fn bytes_get(bytes: list, index: i64) -> i64:
    """Get byte at index."""
    bytes[index]

fn bytes_length(bytes: list) -> i64:
    """Get length of byte list."""
    bytes.len()

fn bytes_slice(bytes: list, start: i64, end: i64) -> list:
    """Get slice of byte list."""
    bytes[start:end]

fn text_to_bytes(s: text) -> list:
    """Convert text to byte list (ASCII codes)."""
    var bytes = []
    var i = 0
    while i < s.len():
        var c = text_char_at(s, i)
        var code = char_code(c)
        bytes.push(code)
        i = i + 1
    bytes

fn bytes_to_text(bytes: list) -> text:
    """Convert byte list to text."""
    var result = ""
    var i = 0
    while i < bytes.len():
        var code = bytes[i]
        var c = char_from_code(code)
        result = result + c
        i = i + 1
    result

# ============================================================================
# ALPHABET UTILITIES
# ============================================================================

fn alphabet_char_at(alphabet: text, index: i64) -> text:
    """Get character from alphabet at index."""
    text_char_at(alphabet, index)

fn alphabet_find_index(alphabet: text, c: text) -> i64:
    """Find index of character in alphabet. Returns -1 if not found."""
    var i = 0
    while i < alphabet.len():
        var ch = text_char_at(alphabet, i)
        if ch == c:
            return i
        i = i + 1
    -1

fn alphabet_validate(alphabet: text, min_length: i64) -> bool:
    """Validate alphabet has minimum length and no duplicates."""
    if alphabet.len() < min_length:
        return false
    var i = 0
    while i < alphabet.len():
        var c = text_char_at(alphabet, i)
        var j = i + 1
        while j < alphabet.len():
            var c2 = text_char_at(alphabet, j)
            if c == c2:
                return false
            j = j + 1
        i = i + 1
    true

fn alphabet_length(alphabet: text) -> i64:
    """Get alphabet length."""
    alphabet.len()

# ============================================================================
# PADDING UTILITIES
# ============================================================================

fn padding_add(encoded: text, block_size: i64) -> text:
    """Add padding to reach block size multiple."""
    var current_len = encoded.len()
    var remainder = current_len % block_size
    if remainder == 0:
        return encoded
    var padding_needed = block_size - remainder
    var result = encoded
    var i = 0
    while i < padding_needed:
        result = result + PADDING_CHAR
        i = i + 1
    result

fn padding_remove(encoded: text) -> text:
    """Remove trailing padding characters."""
    var result = encoded
    var len = result.len()
    while len > 0:
        var last_char = text_char_at(result, len - 1)
        if last_char != PADDING_CHAR:
            return result
        result = result[0:len-1]
        len = len - 1
    result

fn padding_count(encoded: text) -> i64:
    """Count trailing padding characters."""
    var count = 0
    var i = encoded.len() - 1
    while i >= 0:
        var c = text_char_at(encoded, i)
        if c != PADDING_CHAR:
            return count
        count = count + 1
        i = i - 1
    count

fn padding_validate(encoded: text, block_size: i64) -> bool:
    """Validate padding is correct for block size."""
    var pad_count = padding_count(encoded)
    if pad_count == 0:
        return true
    if pad_count >= block_size:
        return false
    var data_len = encoded.len() - pad_count
    var remainder = data_len % block_size
    var expected_padding = block_size - remainder
    if remainder == 0:
        expected_padding = 0
    pad_count == expected_padding

# ============================================================================
# WHITESPACE UTILITIES
# ============================================================================

fn whitespace_strip(encoded: text) -> text:
    """Remove all whitespace from encoded string."""
    var result = ""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        var is_ws = whitespace_is_char(c)
        if is_ws == false:
            result = result + c
        i = i + 1
    result

fn whitespace_is_char(c: text) -> bool:
    """Check if character is whitespace."""
    if c == " ": return true
    if c == "\t": return true
    if c == "\n": return true
    if c == "\r": return true
    false

# ============================================================================
# LINE WRAPPING UTILITIES
# ============================================================================

fn line_wrap(encoded: text, line_length: i64) -> text:
    """Wrap encoded string at specified line length."""
    var result = ""
    var i = 0
    while i < encoded.len():
        var end = i + line_length
        if end > encoded.len():
            end = encoded.len()
        var line = encoded[i:end]
        result = result + line
        if end < encoded.len():
            result = result + "\n"
        i = end
    result

fn line_unwrap(encoded: text) -> text:
    """Remove line breaks from wrapped encoded string."""
    var result = ""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        if c != "\n":
            if c != "\r":
                result = result + c
        i = i + 1
    result

fn line_count(encoded: text) -> i64:
    """Count lines in wrapped encoded string."""
    var count = 1
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        if c == "\n":
            count = count + 1
        i = i + 1
    count

# ============================================================================
# HELPER UTILITIES
# ============================================================================

fn power_of_2(exponent: i64) -> i64:
    """Calculate 2^exponent."""
    var result = 1
    var i = 0
    while i < exponent:
        result = result * 2
        i = i + 1
    result

fn power_of_85(exponent: i64) -> i64:
    """Calculate 85^exponent."""
    var result = 1
    var i = 0
    while i < exponent:
        result = result * 85
        i = i + 1
    result

fn min_i64(a: i64, b: i64) -> i64:
    """Return minimum of two integers."""
    if a < b:
        a
    else:
        b

fn max_i64(a: i64, b: i64) -> i64:
    """Return maximum of two integers."""
    if a > b:
        a
    else:
        b

# ============================================================================
# SIZE CALCULATION UTILITIES
# ============================================================================

fn base16_encoded_size(input_bytes: i64) -> i64:
    """Calculate Base16 encoded size from input byte count."""
    input_bytes * 2

fn base16_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base16 decoded size from encoded length."""
    encoded_length / 2

fn base32_encoded_size(input_bytes: i64, use_padding: bool) -> i64:
    """Calculate Base32 encoded size from input byte count."""
    var bits = input_bytes * 8
    var chars = (bits + 4) / 5
    if use_padding:
        var remainder = chars % 8
        if remainder != 0:
            chars = chars + (8 - remainder)
    chars

fn base32_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base32 decoded size from encoded length."""
    var bits = encoded_length * 5
    bits / 8

fn base64_encoded_size(input_bytes: i64, use_padding: bool) -> i64:
    """Calculate Base64 encoded size from input byte count."""
    var chars = (input_bytes + 2) / 3 * 4
    if use_padding == false:
        var remainder = input_bytes % 3
        if remainder == 1:
            chars = chars - 2
        else:
            if remainder == 2:
                chars = chars - 1
    chars

fn base64_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base64 decoded size from encoded length."""
    (encoded_length * 3) / 4

fn base85_encoded_size(input_bytes: i64) -> i64:
    """Calculate Base85 encoded size from input byte count."""
    var blocks = (input_bytes + 3) / 4
    blocks * 5

fn base85_decoded_size(encoded_length: i64) -> i64:
    """Calculate Base85 decoded size from encoded length."""
    var blocks = encoded_length / 5
    blocks * 4
