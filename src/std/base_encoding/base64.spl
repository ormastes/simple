# Base64 Encoding Module

use base_encoding.types.{BASE64_STD_ALPHABET, BASE64_URL_ALPHABET, PADDING_CHAR}
use base_encoding.utilities.{alphabet_char_at, alphabet_find_index, text_char_at, padding_remove, padding_validate}

# ============================================================================
# BASE64 ENCODING
# ============================================================================

fn base64_encode(bytes: list) -> text:
    """Encode bytes to Base64 standard with padding."""
    base64_encode_with_config(bytes, BASE64_STD_ALPHABET, true)

fn base64_encode_no_pad(bytes: list) -> text:
    """Encode bytes to Base64 standard without padding."""
    base64_encode_with_config(bytes, BASE64_STD_ALPHABET, false)

fn base64_encode_url(bytes: list) -> text:
    """Encode bytes to Base64 URL-safe with padding."""
    base64_encode_with_config(bytes, BASE64_URL_ALPHABET, true)

fn base64_encode_url_no_pad(bytes: list) -> text:
    """Encode bytes to Base64 URL-safe without padding."""
    base64_encode_with_config(bytes, BASE64_URL_ALPHABET, false)

fn base64_encode_with_config(bytes: list, alphabet: text, use_padding: bool) -> text:
    """Encode bytes to Base64 with custom alphabet and padding option."""
    var result = ""
    var i = 0
    while i < bytes.len():
        var b1 = bytes[i]
        var b2 = 0
        var b3 = 0
        var has_b2 = false
        var has_b3 = false
        if i + 1 < bytes.len():
            b2 = bytes[i + 1]
            has_b2 = true
        if i + 2 < bytes.len():
            b3 = bytes[i + 2]
            has_b3 = true
        var idx1 = b1 / 4
        var c1 = alphabet_char_at(alphabet, idx1)
        result = result + c1
        var idx2 = (b1 % 4) * 16
        if has_b2:
            idx2 = idx2 + b2 / 16
        var c2 = alphabet_char_at(alphabet, idx2)
        result = result + c2
        if has_b2:
            var idx3 = (b2 % 16) * 4
            if has_b3:
                idx3 = idx3 + b3 / 64
            var c3 = alphabet_char_at(alphabet, idx3)
            result = result + c3
        else:
            if use_padding:
                result = result + PADDING_CHAR
        if has_b3:
            var idx4 = b3 % 64
            var c4 = alphabet_char_at(alphabet, idx4)
            result = result + c4
        else:
            if use_padding:
                result = result + PADDING_CHAR
        i = i + 3
    result

fn base64_decode(encoded: text) -> list:
    """Decode Base64 standard to bytes."""
    base64_decode_with_alphabet(encoded, BASE64_STD_ALPHABET)

fn base64_decode_url(encoded: text) -> list:
    """Decode Base64 URL-safe to bytes."""
    base64_decode_with_alphabet(encoded, BASE64_URL_ALPHABET)

fn base64_decode_with_alphabet(encoded: text, alphabet: text) -> list:
    """Decode Base64 with custom alphabet to bytes."""
    var clean = padding_remove(encoded)
    var bytes = []
    var i = 0
    while i < clean.len():
        if i + 1 >= clean.len():
            return bytes
        var c1 = text_char_at(clean, i)
        var c2 = text_char_at(clean, i + 1)
        var idx1 = alphabet_find_index(alphabet, c1)
        var idx2 = alphabet_find_index(alphabet, c2)
        if idx1 == -1:
            return bytes
        if idx2 == -1:
            return bytes
        var b1 = idx1 * 4 + idx2 / 16
        bytes.push(b1)
        if i + 2 < clean.len():
            var c3 = text_char_at(clean, i + 2)
            var idx3 = alphabet_find_index(alphabet, c3)
            if idx3 == -1:
                return bytes
            var b2 = (idx2 % 16) * 16 + idx3 / 4
            bytes.push(b2)
            if i + 3 < clean.len():
                var c4 = text_char_at(clean, i + 3)
                var idx4 = alphabet_find_index(alphabet, c4)
                if idx4 == -1:
                    return bytes
                var b3 = (idx3 % 4) * 64 + idx4
                bytes.push(b3)
        i = i + 4
    bytes

fn base64_validate(encoded: text) -> bool:
    """Validate Base64 standard encoded string."""
    base64_validate_with_alphabet(encoded, BASE64_STD_ALPHABET)

fn base64_validate_url(encoded: text) -> bool:
    """Validate Base64 URL-safe encoded string."""
    base64_validate_with_alphabet(encoded, BASE64_URL_ALPHABET)

fn base64_validate_with_alphabet(encoded: text, alphabet: text) -> bool:
    """Validate Base64 encoded string with custom alphabet."""
    var i = 0
    while i < encoded.len():
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            i = i + 1
            pass
        else:
            var index = alphabet_find_index(alphabet, c)
            if index == -1:
                return false
            i = i + 1
    padding_validate(encoded, 4)
