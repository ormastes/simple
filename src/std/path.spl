# std.path - Path manipulation utilities
# Pure Simple implementation (no FFI)

## Path Component Extraction

pub fn basename(path: text) -> text:
    """Extract filename from path.

    Examples:
        basename("/home/user/file.txt") => "file.txt"
        basename("/home/user/") => "user"
        basename("file.txt") => "file.txt"
        basename("/") => ""
    """
    if path == "":
        return ""

    # Remove trailing slashes
    var clean_path = path
    while clean_path.ends_with("/") and clean_path.len() > 1:
        clean_path = clean_path.substring(0, clean_path.len() - 1)

    # Split by "/" and get last component
    val parts = clean_path.split("/")
    return parts.last ?? ""

pub fn dirname(path: text) -> text:
    """Extract directory name from path.

    Examples:
        dirname("/home/user/file.txt") => "/home/user"
        dirname("/home/user/") => "/home"
        dirname("file.txt") => "."
        dirname("/") => "/"
    """
    if path == "":
        return "."

    if path == "/":
        return "/"

    # Remove trailing slashes
    var clean_path = path
    while clean_path.ends_with("/") and clean_path.len() > 1:
        clean_path = clean_path.substring(0, clean_path.len() - 1)

    # Find last separator
    val last_sep = clean_path.rfind("/")
    if not last_sep.?:
        return "."

    val sep_idx = last_sep.unwrap()
    if sep_idx == 0:
        return "/"

    return clean_path.substring(0, sep_idx)

pub fn extension(path: text) -> text:
    """Get file extension (without dot).

    Examples:
        extension("file.txt") => "txt"
        extension("archive.tar.gz") => "gz"
        extension("README") => ""
        extension(".gitignore") => ""
    """
    val name = basename(path)

    # No extension if starts with dot (hidden file)
    if name.starts_with("."):
        return ""

    val last_dot = name.rfind(".")
    if not last_dot.?:
        return ""

    val dot_idx = last_dot.unwrap()
    return name.substring(dot_idx + 1)

pub fn stem(path: text) -> text:
    """Get filename without extension.

    Examples:
        stem("file.txt") => "file"
        stem("archive.tar.gz") => "archive.tar"
        stem("/path/to/README") => "README"
    """
    val name = basename(path)
    val ext = extension(path)

    if ext == "":
        return name

    # Remove extension + dot
    return name.substring(0, name.len() - ext.len() - 1)

## Path Construction

pub fn join(parts: [text]) -> text:
    """Join path components with separator.

    Examples:
        join(["home", "user", "file.txt"]) => "home/user/file.txt"
        join(["/home", "user"]) => "/home/user"
        join([]) => ""
    """
    if parts.len() == 0:
        return ""

    var result = parts[0]
    for i in 1..parts.len():
        val part = parts[i]
        if part == "":
            continue

        # Add separator if needed
        if not result.ends_with("/"):
            result = result + "/"

        # Skip leading slash in part if result already ends with slash
        if part.starts_with("/"):
            result = result + part.substring(1)
        else:
            result = result + part

    return result

pub fn join2(a: text, b: text) -> text:
    """Join two path components.

    Examples:
        join2("/home/user", "file.txt") => "/home/user/file.txt"
        join2("/home/user/", "file.txt") => "/home/user/file.txt"
    """
    return join([a, b])

## Path Normalization

pub fn normalize(path: text) -> text:
    """Normalize path by removing redundant separators and resolving . and ..

    Examples:
        normalize("//home//user") => "/home/user"
        normalize("/home/./user") => "/home/user"
        normalize("/home/foo/../user") => "/home/user"
    """
    if path == "":
        return "."

    val is_absolute = path.starts_with("/")
    val parts = path.split("/")
    var result_parts: [text] = []

    for part in parts:
        if part == "" or part == ".":
            continue
        elif part == "..":
            if result_parts.len() > 0 and result_parts.last != Some(".."):
                result_parts.pop()
            elif not is_absolute:
                result_parts.push("..")
        else:
            result_parts.push(part)

    if result_parts.len() == 0:
        return if is_absolute: "/" else: "."

    val normalized = result_parts.join("/")
    return if is_absolute: "/" + normalized else: normalized

## Path Predicates

pub fn is_absolute(path: text) -> bool:
    """Check if path is absolute.

    Examples:
        is_absolute("/home/user") => true
        is_absolute("home/user") => false
        is_absolute("") => false
    """
    return path.starts_with("/")

pub fn is_relative(path: text) -> bool:
    """Check if path is relative."""
    return not is_absolute(path)

pub fn has_extension(path: text, ext: text) -> bool:
    """Check if path has given extension.

    Examples:
        has_extension("file.txt", "txt") => true
        has_extension("file.txt", ".txt") => true (dot is optional)
        has_extension("README", "txt") => false
    """
    val actual_ext = extension(path)
    val check_ext = if ext.starts_with("."): ext.substring(1) else: ext
    return actual_ext == check_ext
