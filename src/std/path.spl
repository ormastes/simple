# std.path - Path manipulation utilities
# Pure Simple implementation (no FFI)

fn basename(path: text) -> text:
    if path == "":
        return ""
    var clean_path = path
    while clean_path.ends_with("/") and clean_path.len() > 1:
        clean_path = clean_path.substring(0, clean_path.len() - 1)
    val parts = clean_path.split("/")
    return parts.last ?? ""

fn dirname(path: text) -> text:
    if path == "":
        return "."
    if path == "/":
        return "/"
    var clean_path = path
    while clean_path.ends_with("/") and clean_path.len() > 1:
        clean_path = clean_path.substring(0, clean_path.len() - 1)
    val last_sep = clean_path.rfind("/")
    if not last_sep.?:
        return "."
    val sep_idx = last_sep.unwrap()
    if sep_idx == 0:
        return "/"
    return clean_path.substring(0, sep_idx)

fn extension(path: text) -> text:
    val name = basename(path)
    if name == "":
        return ""
    val last_dot = name.rfind(".")
    if not last_dot.?:
        return ""
    val dot_idx = last_dot.unwrap()
    if dot_idx == 0:
        return ""
    if dot_idx == name.len() - 1:
        return ""
    return name.substring(dot_idx + 1)

fn stem(path: text) -> text:
    val name = basename(path)
    val ext = extension(path)
    if ext == "":
        return name
    return name.substring(0, name.len() - ext.len() - 1)

fn path_join(parts: [text]) -> text:
    if parts.len() == 0:
        return ""
    var result = parts[0]
    for i in 1..parts.len():
        val part = parts[i]
        if part == "":
            continue
        if not result.ends_with("/"):
            result = result + "/"
        if part.starts_with("/"):
            result = result + part.substring(1)
        else:
            result = result + part
    return result

fn join2(a: text, b: text) -> text:
    return path_join([a, b])

fn normalize(path: text) -> text:
    if path == "":
        return "."
    val is_abs = path.starts_with("/")
    val parts = path.split("/")
    var result_parts: [text] = []
    for part in parts:
        if part == "" or part == ".":
            continue
        elif part == "..":
            if result_parts.len() > 0 and result_parts.last != Some(".."):
                result_parts.pop()
            elif not is_abs:
                result_parts.push("..")
        else:
            result_parts.push(part)
    if result_parts.len() == 0:
        if is_abs:
            return "/"
        return "."
    val normalized = result_parts.join("/")
    if is_abs:
        return "/" + normalized
    return normalized

fn is_absolute(path: text) -> bool:
    return path.starts_with("/")

fn is_relative(path: text) -> bool:
    return not is_absolute(path)

fn has_extension(path: text, ext: text) -> bool:
    val actual_ext = extension(path)
    var check_ext = ext
    if ext.starts_with("."):
        check_ext = ext.substring(1)
    return actual_ext == check_ext

fn resolve(path: text, base: text) -> text:
    if path.starts_with("/"):
        return normalize(path)
    return normalize(join2(base, path))

fn relative_to(path: text, base: text) -> text:
    val np = normalize(path)
    val nb = normalize(base)
    if np == nb:
        return "."
    if np.starts_with(nb + "/"):
        return np.substring(nb.len() + 1)
    if nb.starts_with(np + "/"):
        val remainder = nb.substring(np.len() + 1)
        val depth = remainder.split("/").len()
        var ups = ".."
        for x in 1..depth:
            ups = ups + "/.."
        return ups
    val pp = np.split("/")
    val bp = nb.split("/")
    var c = 0
    for x in 0..pp.len():
        if c < bp.len() and pp[c] == bp[c]:
            c = c + 1
        else:
            break
    var result = ""
    for x in c..bp.len():
        if bp[x] != "":
            if result != "":
                result = result + "/"
            result = result + ".."
    for x in c..pp.len():
        if pp[x] != "":
            if result != "":
                result = result + "/"
            result = result + pp[x]
    if result == "":
        return "."
    return result

# Alias: export 'join' pointing to path_join for backward compatibility
fn join(parts: [text]) -> text:
    return path_join(parts)

export basename, dirname, extension, stem
export join, join2, path_join
export normalize
export is_absolute, is_relative, has_extension
export resolve, relative_to
