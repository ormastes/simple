# Cryptographic Hashing Utilities Module
#
# SECURITY NOTES:
# - Use SHA-256 or SHA-512 for new applications
# - Use HMAC for message authentication
# - Use PBKDF2 with high iteration count (100,000+) for passwords
# - DO NOT use MD5 or SHA-1 for security-critical applications
# - Use constant-time comparison to prevent timing attacks
#
# Pure Simple implementation - no FFI, no external dependencies
# All algorithms implemented from scratch following official specifications

# =============================================================================
# Bit Operation Utilities
# =============================================================================

# Right rotate for 32-bit values
fn rotr32(x: i64, n: i64) -> i64:
    val mask = 0xFFFFFFFF
    val x_masked = x & mask
    val shifted = (x_masked >> n) | ((x_masked << (32 - n)) & mask)
    shifted & mask

# Right rotate for 64-bit values
fn rotr64(x: i64, n: i64) -> i64:
    # For 64-bit, we need to be careful with overflow
    val high = x >> n
    val low = x << (64 - n)
    high | low

# Right shift for 32-bit values
fn shr32(x: i64, n: i64) -> i64:
    val mask = 0xFFFFFFFF
    ((x & mask) >> n) & mask

# Right shift for 64-bit values
fn shr64(x: i64, n: i64) -> i64:
    x >> n

# Addition modulo 2^32
fn add_mod32(a: i64, b: i64) -> i64:
    val mask = 0xFFFFFFFF
    (a + b) & mask

# Addition modulo 2^64 (for SHA-512)
fn add_mod64(a: i64, b: i64) -> i64:
    # Simple's i64 handles this naturally
    a + b

# =============================================================================
# Byte/Hex Conversion Utilities
# =============================================================================

# Convert byte list to hexadecimal string
fn bytes_to_hex(bytes: list) -> text:
    var result = ""
    var i = 0
    while i < bytes.len():
        val byte = bytes.get(i)
        val high = (byte >> 4) & 0xF
        val low = byte & 0xF

        # Convert nibbles to hex chars
        val high_char = if high < 10:
            "0123456789".get(high)
        else:
            "abcdef".get(high - 10)

        val low_char = if low < 10:
            "0123456789".get(low)
        else:
            "abcdef".get(low - 10)

        result = result + high_char + low_char
        i = i + 1

    result

# Convert hexadecimal string to byte list
fn hex_to_bytes(hex: text) -> list:
    var bytes = []
    var i = 0

    while i < hex.len():
        if i + 1 >= hex.len():
            # Odd length, pad with 0
            bytes.push(0)
            i = i + 1
        else:
            val high_char = hex.get(i)
            val low_char = hex.get(i + 1)

            # Convert hex chars to nibbles
            var high = 0
            if high_char >= "0" && high_char <= "9":
                high = "0123456789".find(high_char)
            else:
                if high_char >= "a" && high_char <= "f":
                    high = 10 + "abcdef".find(high_char)
                else:
                    if high_char >= "A" && high_char <= "F":
                        high = 10 + "ABCDEF".find(high_char)

            var low = 0
            if low_char >= "0" && low_char <= "9":
                low = "0123456789".find(low_char)
            else:
                if low_char >= "a" && low_char <= "f":
                    low = 10 + "abcdef".find(low_char)
                else:
                    if low_char >= "A" && low_char <= "F":
                        low = 10 + "ABCDEF".find(low_char)

            bytes.push((high << 4) | low)
            i = i + 2

    bytes

# Convert text to byte list (UTF-8 encoding)
fn text_to_bytes(text: text) -> list:
    var bytes = []
    var i = 0

    while i < text.len():
        val char = text.get(i)
        val code = char.ord()

        # Simple UTF-8 encoding (ASCII range for now)
        if code < 128:
            bytes.push(code)
        else:
            # For non-ASCII, we'll use a simple encoding
            # In production, full UTF-8 encoding would be needed
            bytes.push(code & 0xFF)

        i = i + 1

    bytes

# Convert byte list to text (UTF-8 decoding)
fn bytes_to_text(bytes: list) -> text:
    var result = ""
    var i = 0

    while i < bytes.len():
        val byte = bytes.get(i)
        result = result + byte.chr()
        i = i + 1

    result

# =============================================================================
# SHA-256 Implementation
# =============================================================================

# SHA-256 constants (first 32 bits of fractional parts of cube roots of first 64 primes)
fn sha256_k_constants() -> list:
    [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]

# SHA-256 initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
fn sha256_initial_hash() -> list:
    [
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ]

# SHA-256 choice function
fn sha256_ch(x: i64, y: i64, z: i64) -> i64:
    (x & y) ^ ((~x) & z)

# SHA-256 majority function
fn sha256_maj(x: i64, y: i64, z: i64) -> i64:
    (x & y) ^ (x & z) ^ (y & z)

# SHA-256 Sigma0 function
fn sha256_sigma0(x: i64) -> i64:
    val r2 = rotr32(x, 2)
    val r13 = rotr32(x, 13)
    val r22 = rotr32(x, 22)
    r2 ^ r13 ^ r22

# SHA-256 Sigma1 function
fn sha256_sigma1(x: i64) -> i64:
    val r6 = rotr32(x, 6)
    val r11 = rotr32(x, 11)
    val r25 = rotr32(x, 25)
    r6 ^ r11 ^ r25

# SHA-256 sigma0 function (lowercase)
fn sha256_little_sigma0(x: i64) -> i64:
    val r7 = rotr32(x, 7)
    val r18 = rotr32(x, 18)
    val s3 = shr32(x, 3)
    r7 ^ r18 ^ s3

# SHA-256 sigma1 function (lowercase)
fn sha256_little_sigma1(x: i64) -> i64:
    val r17 = rotr32(x, 17)
    val r19 = rotr32(x, 19)
    val s10 = shr32(x, 10)
    r17 ^ r19 ^ s10

# Create SHA-256 context for incremental hashing
# Returns tuple: (h: list[8], data: list, datalen: i64, bitlen: i64)
fn create_sha256_context() -> tuple:
    val h = sha256_initial_hash()
    val data = []
    (h, data, 0, 0)

# Pad message for SHA-256 (512-bit blocks)
fn sha256_pad_message(bytes: list) -> list:
    var padded = []
    var i = 0

    # Copy original bytes
    while i < bytes.len():
        padded.push(bytes.get(i))
        i = i + 1

    val original_len = bytes.len()
    val original_bit_len = original_len * 8

    # Append 1 bit (0x80)
    padded.push(0x80)

    # Append 0 bits until length ≡ 448 (mod 512)
    val target_len = ((original_len + 8) / 64 + 1) * 64
    while padded.len() < target_len - 8:
        padded.push(0)

    # Append length as 64-bit big-endian
    # For simplicity, assume length fits in 32 bits
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push((original_bit_len >> 24) & 0xFF)
    padded.push((original_bit_len >> 16) & 0xFF)
    padded.push((original_bit_len >> 8) & 0xFF)
    padded.push(original_bit_len & 0xFF)

    padded

# Process one 512-bit block for SHA-256
fn sha256_process_block(h: list, block: list) -> list:
    # Prepare message schedule (64 entries)
    var w = []
    var i = 0

    # First 16 words from block (big-endian)
    while i < 16:
        val idx = i * 4
        val b0 = block.get(idx)
        val b1 = block.get(idx + 1)
        val b2 = block.get(idx + 2)
        val b3 = block.get(idx + 3)
        val word = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
        w.push(word)
        i = i + 1

    # Extend to 64 words
    while i < 64:
        val w15 = w.get(i - 15)
        val w2 = w.get(i - 2)
        val w16 = w.get(i - 16)
        val w7 = w.get(i - 7)

        val s0 = sha256_little_sigma0(w15)
        val s1 = sha256_little_sigma1(w2)

        val word = add_mod32(add_mod32(add_mod32(s1, w7), s0), w16)
        w.push(word)
        i = i + 1

    # Initialize working variables
    var a = h.get(0)
    var b = h.get(1)
    var c = h.get(2)
    var d = h.get(3)
    var e = h.get(4)
    var f = h.get(5)
    var g = h.get(6)
    var h_var = h.get(7)

    val k = sha256_k_constants()

    # 64 rounds
    i = 0
    while i < 64:
        val S1 = sha256_sigma1(e)
        val ch = sha256_ch(e, f, g)
        val temp1_part1 = add_mod32(h_var, S1)
        val temp1_part2 = add_mod32(ch, k.get(i))
        val temp1_part3 = add_mod32(temp1_part2, w.get(i))
        val temp1 = add_mod32(temp1_part1, temp1_part3)

        val S0 = sha256_sigma0(a)
        val maj = sha256_maj(a, b, c)
        val temp2 = add_mod32(S0, maj)

        h_var = g
        g = f
        f = e
        e = add_mod32(d, temp1)
        d = c
        c = b
        b = a
        a = add_mod32(temp1, temp2)

        i = i + 1

    # Add compressed chunk to current hash value
    var new_h = []
    new_h.push(add_mod32(h.get(0), a))
    new_h.push(add_mod32(h.get(1), b))
    new_h.push(add_mod32(h.get(2), c))
    new_h.push(add_mod32(h.get(3), d))
    new_h.push(add_mod32(h.get(4), e))
    new_h.push(add_mod32(h.get(5), f))
    new_h.push(add_mod32(h.get(6), g))
    new_h.push(add_mod32(h.get(7), h_var))

    new_h

# Update SHA-256 context with new data
fn sha256_update(ctx: tuple, data: list) -> tuple:
    val h = ctx.get(0)
    val existing_data = ctx.get(1)
    val datalen = ctx.get(2)
    val bitlen = ctx.get(3)

    # Append new data
    var updated_data = []
    var i = 0
    while i < existing_data.len():
        updated_data.push(existing_data.get(i))
        i = i + 1

    i = 0
    while i < data.len():
        updated_data.push(data.get(i))
        i = i + 1

    val new_datalen = datalen + data.len()
    val new_bitlen = bitlen + (data.len() * 8)

    (h, updated_data, new_datalen, new_bitlen)

# Finalize SHA-256 hash
fn sha256_finalize(ctx: tuple) -> list:
    val h = ctx.get(0)
    val data = ctx.get(1)

    # Pad the data
    val padded = sha256_pad_message(data)

    # Process all blocks
    var current_h = h
    var i = 0
    while i < padded.len():
        var block = []
        var j = 0
        while j < 64:
            block.push(padded.get(i + j))
            j = j + 1

        current_h = sha256_process_block(current_h, block)
        i = i + 64

    # Convert hash values to bytes (big-endian)
    var result = []
    i = 0
    while i < 8:
        val h_val = current_h.get(i)
        result.push((h_val >> 24) & 0xFF)
        result.push((h_val >> 16) & 0xFF)
        result.push((h_val >> 8) & 0xFF)
        result.push(h_val & 0xFF)
        i = i + 1

    result

# Reset SHA-256 context
fn sha256_reset(ctx: tuple) -> tuple:
    create_sha256_context()

# SHA-256 hash of byte list (returns byte list)
fn sha256_bytes(bytes: list) -> list:
    val ctx = create_sha256_context()
    val updated_ctx = sha256_update(ctx, bytes)
    sha256_finalize(updated_ctx)

# SHA-256 hash of text (returns byte list)
fn sha256(text: text) -> list:
    val bytes = text_to_bytes(text)
    sha256_bytes(bytes)

# SHA-256 hash of text (returns hex string)
fn sha256_hex(text: text) -> text:
    val hash = sha256(text)
    bytes_to_hex(hash)

# =============================================================================
# SHA-512 Implementation
# =============================================================================

# SHA-512 constants (first 64 bits of fractional parts of cube roots of first 80 primes)
fn sha512_k_constants() -> list:
    [
        0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
        0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
        0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
        0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
        0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
        0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
        0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
        0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
        0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
        0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
        0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
        0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
        0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
        0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
        0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
        0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
        0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
        0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
        0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
        0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
    ]

# SHA-512 initial hash values
fn sha512_initial_hash() -> list:
    [
        0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
        0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
    ]

# SHA-512 choice function
fn sha512_ch(x: i64, y: i64, z: i64) -> i64:
    (x & y) ^ ((~x) & z)

# SHA-512 majority function
fn sha512_maj(x: i64, y: i64, z: i64) -> i64:
    (x & y) ^ (x & z) ^ (y & z)

# SHA-512 Sigma0 function
fn sha512_sigma0(x: i64) -> i64:
    val r28 = rotr64(x, 28)
    val r34 = rotr64(x, 34)
    val r39 = rotr64(x, 39)
    r28 ^ r34 ^ r39

# SHA-512 Sigma1 function
fn sha512_sigma1(x: i64) -> i64:
    val r14 = rotr64(x, 14)
    val r18 = rotr64(x, 18)
    val r41 = rotr64(x, 41)
    r14 ^ r18 ^ r41

# SHA-512 sigma0 function (lowercase)
fn sha512_little_sigma0(x: i64) -> i64:
    val r1 = rotr64(x, 1)
    val r8 = rotr64(x, 8)
    val s7 = shr64(x, 7)
    r1 ^ r8 ^ s7

# SHA-512 sigma1 function (lowercase)
fn sha512_little_sigma1(x: i64) -> i64:
    val r19 = rotr64(x, 19)
    val r61 = rotr64(x, 61)
    val s6 = shr64(x, 6)
    r19 ^ r61 ^ s6

# Create SHA-512 context
fn create_sha512_context() -> tuple:
    val h = sha512_initial_hash()
    val data = []
    (h, data, 0, 0)

# Pad message for SHA-512 (1024-bit blocks)
fn sha512_pad_message(bytes: list) -> list:
    var padded = []
    var i = 0

    # Copy original bytes
    while i < bytes.len():
        padded.push(bytes.get(i))
        i = i + 1

    val original_len = bytes.len()
    val original_bit_len = original_len * 8

    # Append 1 bit (0x80)
    padded.push(0x80)

    # Append 0 bits until length ≡ 896 (mod 1024)
    val target_len = ((original_len + 16) / 128 + 1) * 128
    while padded.len() < target_len - 16:
        padded.push(0)

    # Append length as 128-bit big-endian (we only use lower 64 bits)
    i = 0
    while i < 8:
        padded.push(0)
        i = i + 1

    # Append actual length
    padded.push((original_bit_len >> 56) & 0xFF)
    padded.push((original_bit_len >> 48) & 0xFF)
    padded.push((original_bit_len >> 40) & 0xFF)
    padded.push((original_bit_len >> 32) & 0xFF)
    padded.push((original_bit_len >> 24) & 0xFF)
    padded.push((original_bit_len >> 16) & 0xFF)
    padded.push((original_bit_len >> 8) & 0xFF)
    padded.push(original_bit_len & 0xFF)

    padded

# Process one 1024-bit block for SHA-512
fn sha512_process_block(h: list, block: list) -> list:
    # Prepare message schedule (80 entries)
    var w = []
    var i = 0

    # First 16 words from block (big-endian, 64-bit words)
    while i < 16:
        val idx = i * 8
        val b0 = block.get(idx)
        val b1 = block.get(idx + 1)
        val b2 = block.get(idx + 2)
        val b3 = block.get(idx + 3)
        val b4 = block.get(idx + 4)
        val b5 = block.get(idx + 5)
        val b6 = block.get(idx + 6)
        val b7 = block.get(idx + 7)

        val word_high = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
        val word_low = (b4 << 24) | (b5 << 16) | (b6 << 8) | b7
        val word = (word_high << 32) | word_low

        w.push(word)
        i = i + 1

    # Extend to 80 words
    while i < 80:
        val w15 = w.get(i - 15)
        val w2 = w.get(i - 2)
        val w16 = w.get(i - 16)
        val w7 = w.get(i - 7)

        val s0 = sha512_little_sigma0(w15)
        val s1 = sha512_little_sigma1(w2)

        val word = add_mod64(add_mod64(add_mod64(s1, w7), s0), w16)
        w.push(word)
        i = i + 1

    # Initialize working variables
    var a = h.get(0)
    var b = h.get(1)
    var c = h.get(2)
    var d = h.get(3)
    var e = h.get(4)
    var f = h.get(5)
    var g = h.get(6)
    var h_var = h.get(7)

    val k = sha512_k_constants()

    # 80 rounds
    i = 0
    while i < 80:
        val S1 = sha512_sigma1(e)
        val ch = sha512_ch(e, f, g)
        val temp1_part1 = add_mod64(h_var, S1)
        val temp1_part2 = add_mod64(ch, k.get(i))
        val temp1_part3 = add_mod64(temp1_part2, w.get(i))
        val temp1 = add_mod64(temp1_part1, temp1_part3)

        val S0 = sha512_sigma0(a)
        val maj = sha512_maj(a, b, c)
        val temp2 = add_mod64(S0, maj)

        h_var = g
        g = f
        f = e
        e = add_mod64(d, temp1)
        d = c
        c = b
        b = a
        a = add_mod64(temp1, temp2)

        i = i + 1

    # Add compressed chunk to current hash value
    var new_h = []
    new_h.push(add_mod64(h.get(0), a))
    new_h.push(add_mod64(h.get(1), b))
    new_h.push(add_mod64(h.get(2), c))
    new_h.push(add_mod64(h.get(3), d))
    new_h.push(add_mod64(h.get(4), e))
    new_h.push(add_mod64(h.get(5), f))
    new_h.push(add_mod64(h.get(6), g))
    new_h.push(add_mod64(h.get(7), h_var))

    new_h

# Update SHA-512 context
fn sha512_update(ctx: tuple, data: list) -> tuple:
    val h = ctx.get(0)
    val existing_data = ctx.get(1)
    val datalen = ctx.get(2)
    val bitlen = ctx.get(3)

    # Append new data
    var updated_data = []
    var i = 0
    while i < existing_data.len():
        updated_data.push(existing_data.get(i))
        i = i + 1

    i = 0
    while i < data.len():
        updated_data.push(data.get(i))
        i = i + 1

    val new_datalen = datalen + data.len()
    val new_bitlen = bitlen + (data.len() * 8)

    (h, updated_data, new_datalen, new_bitlen)

# Finalize SHA-512 hash
fn sha512_finalize(ctx: tuple) -> list:
    val h = ctx.get(0)
    val data = ctx.get(1)

    # Pad the data
    val padded = sha512_pad_message(data)

    # Process all blocks
    var current_h = h
    var i = 0
    while i < padded.len():
        var block = []
        var j = 0
        while j < 128:
            block.push(padded.get(i + j))
            j = j + 1

        current_h = sha512_process_block(current_h, block)
        i = i + 128

    # Convert hash values to bytes (big-endian, 64-bit words)
    var result = []
    i = 0
    while i < 8:
        val h_val = current_h.get(i)
        result.push((h_val >> 56) & 0xFF)
        result.push((h_val >> 48) & 0xFF)
        result.push((h_val >> 40) & 0xFF)
        result.push((h_val >> 32) & 0xFF)
        result.push((h_val >> 24) & 0xFF)
        result.push((h_val >> 16) & 0xFF)
        result.push((h_val >> 8) & 0xFF)
        result.push(h_val & 0xFF)
        i = i + 1

    result

# Reset SHA-512 context
fn sha512_reset(ctx: tuple) -> tuple:
    create_sha512_context()

# SHA-512 hash of byte list
fn sha512_bytes(bytes: list) -> list:
    val ctx = create_sha512_context()
    val updated_ctx = sha512_update(ctx, bytes)
    sha512_finalize(updated_ctx)

# SHA-512 hash of text (returns byte list)
fn sha512(text: text) -> list:
    val bytes = text_to_bytes(text)
    sha512_bytes(bytes)

# SHA-512 hash of text (returns hex string)
fn sha512_hex(text: text) -> text:
    val hash = sha512(text)
    bytes_to_hex(hash)

# =============================================================================
# SHA-1 Implementation (DEPRECATED - for legacy support only)
# =============================================================================

# WARNING: SHA-1 is cryptographically broken and should not be used for
# security-critical applications. Use SHA-256 or SHA-512 instead.

# SHA-1 initial hash values
fn sha1_initial_hash() -> list:
    [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

# SHA-1 left rotate
fn rotl32(x: i64, n: i64) -> i64:
    val mask = 0xFFFFFFFF
    val x_masked = x & mask
    val shifted = ((x_masked << n) | (x_masked >> (32 - n))) & mask
    shifted

# SHA-1 f function
fn sha1_f(t: i64, b: i64, c: i64, d: i64) -> i64:
    if t < 20:
        (b & c) | ((~b) & d)
    else:
        if t < 40:
            b ^ c ^ d
        else:
            if t < 60:
                (b & c) | (b & d) | (c & d)
            else:
                b ^ c ^ d

# SHA-1 K constant
fn sha1_k(t: i64) -> i64:
    if t < 20:
        0x5A827999
    else:
        if t < 40:
            0x6ED9EBA1
        else:
            if t < 60:
                0x8F1BBCDC
            else:
                0xCA62C1D6

# Pad message for SHA-1
fn sha1_pad_message(bytes: list) -> list:
    var padded = []
    var i = 0

    # Copy original bytes
    while i < bytes.len():
        padded.push(bytes.get(i))
        i = i + 1

    val original_len = bytes.len()
    val original_bit_len = original_len * 8

    # Append 1 bit
    padded.push(0x80)

    # Pad to 56 bytes (mod 64)
    val target_len = ((original_len + 8) / 64 + 1) * 64
    while padded.len() < target_len - 8:
        padded.push(0)

    # Append length
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push((original_bit_len >> 24) & 0xFF)
    padded.push((original_bit_len >> 16) & 0xFF)
    padded.push((original_bit_len >> 8) & 0xFF)
    padded.push(original_bit_len & 0xFF)

    padded

# Process SHA-1 block
fn sha1_process_block(h: list, block: list) -> list:
    # Prepare message schedule
    var w = []
    var i = 0

    # First 16 words
    while i < 16:
        val idx = i * 4
        val b0 = block.get(idx)
        val b1 = block.get(idx + 1)
        val b2 = block.get(idx + 2)
        val b3 = block.get(idx + 3)
        val word = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
        w.push(word)
        i = i + 1

    # Extend to 80 words
    while i < 80:
        val w3 = w.get(i - 3)
        val w8 = w.get(i - 8)
        val w14 = w.get(i - 14)
        val w16 = w.get(i - 16)
        val word = rotl32(w3 ^ w8 ^ w14 ^ w16, 1)
        w.push(word)
        i = i + 1

    # Initialize working variables
    var a = h.get(0)
    var b = h.get(1)
    var c = h.get(2)
    var d = h.get(3)
    var e = h.get(4)

    # 80 rounds
    i = 0
    while i < 80:
        val f = sha1_f(i, b, c, d)
        val k = sha1_k(i)
        val rotated_a = rotl32(a, 5)
        val temp_sum1 = add_mod32(rotated_a, f)
        val temp_sum2 = add_mod32(temp_sum1, e)
        val temp_sum3 = add_mod32(temp_sum2, k)
        val temp = add_mod32(temp_sum3, w.get(i))

        e = d
        d = c
        c = rotl32(b, 30)
        b = a
        a = temp

        i = i + 1

    # Add to hash
    var new_h = []
    new_h.push(add_mod32(h.get(0), a))
    new_h.push(add_mod32(h.get(1), b))
    new_h.push(add_mod32(h.get(2), c))
    new_h.push(add_mod32(h.get(3), d))
    new_h.push(add_mod32(h.get(4), e))

    new_h

# SHA-1 hash of byte list
fn sha1_bytes(bytes: list) -> list:
    val padded = sha1_pad_message(bytes)
    var h = sha1_initial_hash()

    var i = 0
    while i < padded.len():
        var block = []
        var j = 0
        while j < 64:
            block.push(padded.get(i + j))
            j = j + 1

        h = sha1_process_block(h, block)
        i = i + 64

    # Convert to bytes
    var result = []
    i = 0
    while i < 5:
        val h_val = h.get(i)
        result.push((h_val >> 24) & 0xFF)
        result.push((h_val >> 16) & 0xFF)
        result.push((h_val >> 8) & 0xFF)
        result.push(h_val & 0xFF)
        i = i + 1

    result

# SHA-1 hash of text (DEPRECATED)
fn sha1(text: text) -> list:
    val bytes = text_to_bytes(text)
    sha1_bytes(bytes)

# SHA-1 hash hex (DEPRECATED)
fn sha1_hex(text: text) -> text:
    val hash = sha1(text)
    bytes_to_hex(hash)

# =============================================================================
# MD5 Implementation (INSECURE - for legacy support only)
# =============================================================================

# WARNING: MD5 is cryptographically broken and should NEVER be used for
# security purposes. Provided only for compatibility with legacy systems.

# MD5 initial hash values
fn md5_initial_hash() -> list:
    [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]

# MD5 F function
fn md5_f(x: i64, y: i64, z: i64) -> i64:
    (x & y) | ((~x) & z)

# MD5 G function
fn md5_g(x: i64, y: i64, z: i64) -> i64:
    (x & z) | (y & (~z))

# MD5 H function
fn md5_h(x: i64, y: i64, z: i64) -> i64:
    x ^ y ^ z

# MD5 I function
fn md5_i(x: i64, y: i64, z: i64) -> i64:
    y ^ (x | (~z))

# MD5 sine table
fn md5_t(i: i64) -> i64:
    # Precomputed values from floor(abs(sin(i + 1)) * 2^32)
    val table = [
        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
    ]
    table.get(i)

# Pad message for MD5
fn md5_pad_message(bytes: list) -> list:
    var padded = []
    var i = 0

    while i < bytes.len():
        padded.push(bytes.get(i))
        i = i + 1

    val original_len = bytes.len()
    val original_bit_len = original_len * 8

    padded.push(0x80)

    val target_len = ((original_len + 8) / 64 + 1) * 64
    while padded.len() < target_len - 8:
        padded.push(0)

    # Length in little-endian
    padded.push(original_bit_len & 0xFF)
    padded.push((original_bit_len >> 8) & 0xFF)
    padded.push((original_bit_len >> 16) & 0xFF)
    padded.push((original_bit_len >> 24) & 0xFF)
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push(0)

    padded

# Process MD5 block
fn md5_process_block(h: list, block: list) -> list:
    # Parse block into 16 words (little-endian)
    var m = []
    var i = 0
    while i < 16:
        val idx = i * 4
        val b0 = block.get(idx)
        val b1 = block.get(idx + 1)
        val b2 = block.get(idx + 2)
        val b3 = block.get(idx + 3)
        val word = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
        m.push(word)
        i = i + 1

    var a = h.get(0)
    var b = h.get(1)
    var c = h.get(2)
    var d = h.get(3)

    # Round 1
    val s1 = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22]
    i = 0
    while i < 16:
        val f = md5_f(b, c, d)
        val g = i
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s1.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Round 2
    val s2 = [5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20]
    i = 0
    while i < 16:
        val f = md5_g(b, c, d)
        val g = (5 * i + 1) % 16
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(16 + i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s2.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Round 3
    val s3 = [4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23]
    i = 0
    while i < 16:
        val f = md5_h(b, c, d)
        val g = (3 * i + 5) % 16
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(32 + i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s3.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Round 4
    val s4 = [6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
    i = 0
    while i < 16:
        val f = md5_i(b, c, d)
        val g = (7 * i) % 16
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(48 + i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s4.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Add to hash
    var new_h = []
    new_h.push(add_mod32(h.get(0), a))
    new_h.push(add_mod32(h.get(1), b))
    new_h.push(add_mod32(h.get(2), c))
    new_h.push(add_mod32(h.get(3), d))

    new_h

# MD5 hash of byte list
fn md5_bytes(bytes: list) -> list:
    val padded = md5_pad_message(bytes)
    var h = md5_initial_hash()

    var i = 0
    while i < padded.len():
        var block = []
        var j = 0
        while j < 64:
            block.push(padded.get(i + j))
            j = j + 1

        h = md5_process_block(h, block)
        i = i + 64

    # Convert to bytes (little-endian)
    var result = []
    i = 0
    while i < 4:
        val h_val = h.get(i)
        result.push(h_val & 0xFF)
        result.push((h_val >> 8) & 0xFF)
        result.push((h_val >> 16) & 0xFF)
        result.push((h_val >> 24) & 0xFF)
        i = i + 1

    result

# MD5 hash of text (INSECURE)
fn md5(text: text) -> list:
    val bytes = text_to_bytes(text)
    md5_bytes(bytes)

# MD5 hash hex (INSECURE)
fn md5_hex(text: text) -> text:
    val hash = md5(text)
    bytes_to_hex(hash)

# =============================================================================
# HMAC (Hash-based Message Authentication Code)
# =============================================================================

# HMAC-SHA256
fn hmac_sha256(key: text, message: text) -> list:
    val key_bytes = text_to_bytes(key)
    val message_bytes = text_to_bytes(message)
    hmac_sha256_bytes(key_bytes, message_bytes)

# HMAC-SHA256 with byte inputs
fn hmac_sha256_bytes(key_bytes: list, message_bytes: list) -> list:
    val block_size = 64  # SHA-256 block size

    # Prepare key
    var k = []
    if key_bytes.len() > block_size:
        # Hash the key if too long
        k = sha256_bytes(key_bytes)
    else:
        var i = 0
        while i < key_bytes.len():
            k.push(key_bytes.get(i))
            i = i + 1

    # Pad key to block size
    while k.len() < block_size:
        k.push(0)

    # Create inner and outer padded keys
    var i_key_pad = []
    var o_key_pad = []
    var i = 0
    while i < block_size:
        val k_byte = k.get(i)
        i_key_pad.push(k_byte ^ 0x36)
        o_key_pad.push(k_byte ^ 0x5c)
        i = i + 1

    # Inner hash: H((K ⊕ ipad) || message)
    var inner_input = []
    i = 0
    while i < i_key_pad.len():
        inner_input.push(i_key_pad.get(i))
        i = i + 1
    i = 0
    while i < message_bytes.len():
        inner_input.push(message_bytes.get(i))
        i = i + 1

    val inner_hash = sha256_bytes(inner_input)

    # Outer hash: H((K ⊕ opad) || inner_hash)
    var outer_input = []
    i = 0
    while i < o_key_pad.len():
        outer_input.push(o_key_pad.get(i))
        i = i + 1
    i = 0
    while i < inner_hash.len():
        outer_input.push(inner_hash.get(i))
        i = i + 1

    sha256_bytes(outer_input)

# HMAC-SHA512
fn hmac_sha512(key: text, message: text) -> list:
    val key_bytes = text_to_bytes(key)
    val message_bytes = text_to_bytes(message)
    hmac_sha512_bytes(key_bytes, message_bytes)

# HMAC-SHA512 with byte inputs
fn hmac_sha512_bytes(key_bytes: list, message_bytes: list) -> list:
    val block_size = 128  # SHA-512 block size

    # Prepare key
    var k = []
    if key_bytes.len() > block_size:
        k = sha512_bytes(key_bytes)
    else:
        var i = 0
        while i < key_bytes.len():
            k.push(key_bytes.get(i))
            i = i + 1

    # Pad key to block size
    while k.len() < block_size:
        k.push(0)

    # Create inner and outer padded keys
    var i_key_pad = []
    var o_key_pad = []
    var i = 0
    while i < block_size:
        val k_byte = k.get(i)
        i_key_pad.push(k_byte ^ 0x36)
        o_key_pad.push(k_byte ^ 0x5c)
        i = i + 1

    # Inner hash
    var inner_input = []
    i = 0
    while i < i_key_pad.len():
        inner_input.push(i_key_pad.get(i))
        i = i + 1
    i = 0
    while i < message_bytes.len():
        inner_input.push(message_bytes.get(i))
        i = i + 1

    val inner_hash = sha512_bytes(inner_input)

    # Outer hash
    var outer_input = []
    i = 0
    while i < o_key_pad.len():
        outer_input.push(o_key_pad.get(i))
        i = i + 1
    i = 0
    while i < inner_hash.len():
        outer_input.push(inner_hash.get(i))
        i = i + 1

    sha512_bytes(outer_input)

# HMAC-SHA1 (DEPRECATED)
fn hmac_sha1(key: text, message: text) -> list:
    val key_bytes = text_to_bytes(key)
    val message_bytes = text_to_bytes(message)
    hmac_sha1_bytes(key_bytes, message_bytes)

# HMAC-SHA1 with byte inputs (DEPRECATED)
fn hmac_sha1_bytes(key_bytes: list, message_bytes: list) -> list:
    val block_size = 64  # SHA-1 block size

    # Prepare key
    var k = []
    if key_bytes.len() > block_size:
        k = sha1_bytes(key_bytes)
    else:
        var i = 0
        while i < key_bytes.len():
            k.push(key_bytes.get(i))
            i = i + 1

    # Pad key
    while k.len() < block_size:
        k.push(0)

    # Create padded keys
    var i_key_pad = []
    var o_key_pad = []
    var i = 0
    while i < block_size:
        val k_byte = k.get(i)
        i_key_pad.push(k_byte ^ 0x36)
        o_key_pad.push(k_byte ^ 0x5c)
        i = i + 1

    # Inner hash
    var inner_input = []
    i = 0
    while i < i_key_pad.len():
        inner_input.push(i_key_pad.get(i))
        i = i + 1
    i = 0
    while i < message_bytes.len():
        inner_input.push(message_bytes.get(i))
        i = i + 1

    val inner_hash = sha1_bytes(inner_input)

    # Outer hash
    var outer_input = []
    i = 0
    while i < o_key_pad.len():
        outer_input.push(o_key_pad.get(i))
        i = i + 1
    i = 0
    while i < inner_hash.len():
        outer_input.push(inner_hash.get(i))
        i = i + 1

    sha1_bytes(outer_input)

# =============================================================================
# PBKDF2 (Password-Based Key Derivation Function 2)
# =============================================================================

# XOR two byte lists
fn xor_bytes(a: list, b: list) -> list:
    var result = []
    var i = 0

    val min_len = if a.len() < b.len():
        a.len()
    else:
        b.len()

    while i < min_len:
        result.push(a.get(i) ^ b.get(i))
        i = i + 1

    result

# PBKDF2-HMAC-SHA256
fn pbkdf2_sha256(password: text, salt: text, iterations: i64) -> list:
    val password_bytes = text_to_bytes(password)
    val salt_bytes = text_to_bytes(salt)
    pbkdf2_sha256_bytes(password_bytes, salt_bytes, iterations, 32)

# PBKDF2-HMAC-SHA256 with byte inputs
fn pbkdf2_sha256_bytes(password_bytes: list, salt_bytes: list, iterations: i64, key_length: i64) -> list:
    val hash_len = 32  # SHA-256 output length
    val blocks_needed = (key_length + hash_len - 1) / hash_len

    var result = []
    var block_num = 1

    while block_num <= blocks_needed:
        # U1 = HMAC(password, salt || INT(block_num))
        var salt_with_block = []
        var i = 0
        while i < salt_bytes.len():
            salt_with_block.push(salt_bytes.get(i))
            i = i + 1

        # Append block number as big-endian 32-bit integer
        salt_with_block.push((block_num >> 24) & 0xFF)
        salt_with_block.push((block_num >> 16) & 0xFF)
        salt_with_block.push((block_num >> 8) & 0xFF)
        salt_with_block.push(block_num & 0xFF)

        var u = hmac_sha256_bytes(password_bytes, salt_with_block)
        var t = []
        i = 0
        while i < u.len():
            t.push(u.get(i))
            i = i + 1

        # Iterate
        var iteration = 1
        while iteration < iterations:
            u = hmac_sha256_bytes(password_bytes, u)
            t = xor_bytes(t, u)
            iteration = iteration + 1

        # Append to result
        i = 0
        while i < t.len():
            result.push(t.get(i))
            i = i + 1

        block_num = block_num + 1

    # Truncate to desired length
    var final_result = []
    var i = 0
    while i < key_length && i < result.len():
        final_result.push(result.get(i))
        i = i + 1

    final_result

# PBKDF2-HMAC-SHA512
fn pbkdf2_sha512(password: text, salt: text, iterations: i64) -> list:
    val password_bytes = text_to_bytes(password)
    val salt_bytes = text_to_bytes(salt)
    pbkdf2_sha512_bytes(password_bytes, salt_bytes, iterations, 64)

# PBKDF2-HMAC-SHA512 with byte inputs
fn pbkdf2_sha512_bytes(password_bytes: list, salt_bytes: list, iterations: i64, key_length: i64) -> list:
    val hash_len = 64  # SHA-512 output length
    val blocks_needed = (key_length + hash_len - 1) / hash_len

    var result = []
    var block_num = 1

    while block_num <= blocks_needed:
        # U1 = HMAC(password, salt || INT(block_num))
        var salt_with_block = []
        var i = 0
        while i < salt_bytes.len():
            salt_with_block.push(salt_bytes.get(i))
            i = i + 1

        salt_with_block.push((block_num >> 24) & 0xFF)
        salt_with_block.push((block_num >> 16) & 0xFF)
        salt_with_block.push((block_num >> 8) & 0xFF)
        salt_with_block.push(block_num & 0xFF)

        var u = hmac_sha512_bytes(password_bytes, salt_with_block)
        var t = []
        i = 0
        while i < u.len():
            t.push(u.get(i))
            i = i + 1

        # Iterate
        var iteration = 1
        while iteration < iterations:
            u = hmac_sha512_bytes(password_bytes, u)
            t = xor_bytes(t, u)
            iteration = iteration + 1

        # Append to result
        i = 0
        while i < t.len():
            result.push(t.get(i))
            i = i + 1

        block_num = block_num + 1

    # Truncate to desired length
    var final_result = []
    var i = 0
    while i < key_length && i < result.len():
        final_result.push(result.get(i))
        i = i + 1

    final_result

# =============================================================================
# Security Utilities
# =============================================================================

# Constant-time comparison to prevent timing attacks
fn constant_time_compare(a: list, b: list) -> bool:
    if a.len() != b.len():
        false
    else:
        var result = 0
        var i = 0
        while i < a.len():
            result = result | (a.get(i) ^ b.get(i))
            i = i + 1

        result == 0

# Secure hash comparison
fn secure_compare(hash1: list, hash2: list) -> bool:
    constant_time_compare(hash1, hash2)

# Verify hash matches expected value
fn verify_hash(data: text, expected_hex: text) -> bool:
    val actual_hash = sha256_hex(data)
    constant_time_compare(text_to_bytes(actual_hash), text_to_bytes(expected_hex))

# =============================================================================
# High-Level Utilities
# =============================================================================

# Hash password with salt (uses PBKDF2-SHA256 with 100,000 iterations)
fn hash_password(password: text, salt: text) -> text:
    val hash = pbkdf2_sha256(password, salt, 100000)
    bytes_to_hex(hash)

# Verify password hash
fn verify_password(password: text, salt: text, expected_hash_hex: text) -> bool:
    val actual_hash = hash_password(password, salt)
    constant_time_compare(text_to_bytes(actual_hash), text_to_bytes(expected_hash_hex))

# Generate simple salt (NOT cryptographically secure - use external RNG for production)
fn generate_salt(length: i64) -> text:
    # Simple deterministic salt generation - NOT SECURE
    # In production, use a cryptographically secure random number generator
    var salt = ""
    var i = 0
    while i < length:
        val char_code = ((i * 7919) % 94) + 33  # Printable ASCII range
        salt = salt + char_code.chr()
        i = i + 1

    salt

# Hash streaming data (incremental)
fn hash_stream_sha256(chunks: list) -> text:
    var ctx = create_sha256_context()
    var i = 0

    while i < chunks.len():
        val chunk = chunks.get(i)
        val chunk_bytes = text_to_bytes(chunk)
        ctx = sha256_update(ctx, chunk_bytes)
        i = i + 1

    val hash = sha256_finalize(ctx)
    bytes_to_hex(hash)

# Hash streaming data SHA-512
fn hash_stream_sha512(chunks: list) -> text:
    var ctx = create_sha512_context()
    var i = 0

    while i < chunks.len():
        val chunk = chunks.get(i)
        val chunk_bytes = text_to_bytes(chunk)
        ctx = sha512_update(ctx, chunk_bytes)
        i = i + 1

    val hash = sha512_finalize(ctx)
    bytes_to_hex(hash)

# =============================================================================
# Additional Utility Functions
# =============================================================================

# Convert hash to uppercase hex
fn hash_to_upper_hex(hash: list) -> text:
    val hex = bytes_to_hex(hash)
    var result = ""
    var i = 0

    while i < hex.len():
        val char = hex.get(i)
        val upper_char = if char >= "a" && char <= "f":
            char.upper()
        else:
            char

        result = result + upper_char
        i = i + 1

    result

# SHA-256 hash with uppercase hex output
fn sha256_hex_upper(text: text) -> text:
    val hash = sha256(text)
    hash_to_upper_hex(hash)

# SHA-512 hash with uppercase hex output
fn sha512_hex_upper(text: text) -> text:
    val hash = sha512(text)
    hash_to_upper_hex(hash)

# Truncate hash to specified byte length
fn truncate_hash(hash: list, length: i64) -> list:
    var result = []
    var i = 0

    while i < length && i < hash.len():
        result.push(hash.get(i))
        i = i + 1

    result

# Compare two hex strings (case-insensitive)
fn compare_hex_hashes(hex1: text, hex2: text) -> bool:
    if hex1.len() != hex2.len():
        false
    else:
        var i = 0
        var match = true

        while i < hex1.len():
            val c1 = hex1.get(i)
            val c2 = hex2.get(i)

            val c1_lower = if c1 >= "A" && c1 <= "F":
                c1.lower()
            else:
                c1

            val c2_lower = if c2 >= "A" && c2 <= "F":
                c2.lower()
            else:
                c2

            if c1_lower != c2_lower:
                match = false

            i = i + 1

        match

# Create checksum (short hash for quick verification)
fn create_checksum(data: text) -> text:
    val hash = sha256(data)
    val truncated = truncate_hash(hash, 4)
    bytes_to_hex(truncated)

# Verify checksum
fn verify_checksum(data: text, expected_checksum: text) -> bool:
    val actual = create_checksum(data)
    compare_hex_hashes(actual, expected_checksum)

# Double hash (hash of hash - used in some applications)
fn double_sha256(text: text) -> list:
    val first_hash = sha256(text)
    sha256_bytes(first_hash)

# Double hash hex
fn double_sha256_hex(text: text) -> text:
    val hash = double_sha256(text)
    bytes_to_hex(hash)

# Hash with algorithm selection
fn hash_with_algorithm(text: text, algorithm: text) -> text:
    if algorithm == "sha256":
        sha256_hex(text)
    else:
        if algorithm == "sha512":
            sha512_hex(text)
        else:
            if algorithm == "sha1":
                sha1_hex(text)
            else:
                if algorithm == "md5":
                    md5_hex(text)
                else:
                    # Default to SHA-256
                    sha256_hex(text)

# HMAC with algorithm selection
fn hmac_with_algorithm(key: text, message: text, algorithm: text) -> list:
    if algorithm == "sha256":
        hmac_sha256(key, message)
    else:
        if algorithm == "sha512":
            hmac_sha512(key, message)
        else:
            if algorithm == "sha1":
                hmac_sha1(key, message)
            else:
                # Default to SHA-256
                hmac_sha256(key, message)

# PBKDF2 with algorithm selection
fn pbkdf2_with_algorithm(password: text, salt: text, iterations: i64, algorithm: text) -> list:
    if algorithm == "sha256":
        pbkdf2_sha256(password, salt, iterations)
    else:
        if algorithm == "sha512":
            pbkdf2_sha512(password, salt, iterations)
        else:
            # Default to SHA-256
            pbkdf2_sha256(password, salt, iterations)

# Get hash algorithm output length in bytes
fn get_hash_length(algorithm: text) -> i64:
    if algorithm == "sha256":
        32
    else:
        if algorithm == "sha512":
            64
        else:
            if algorithm == "sha1":
                20
            else:
                if algorithm == "md5":
                    16
                else:
                    # Default SHA-256
                    32

# Get hash algorithm block size in bytes
fn get_block_size(algorithm: text) -> i64:
    if algorithm == "sha256":
        64
    else:
        if algorithm == "sha512":
            128
        else:
            if algorithm == "sha1":
                64
            else:
                if algorithm == "md5":
                    64
                else:
                    # Default SHA-256
                    64

# Check if algorithm is secure
fn is_secure_algorithm(algorithm: text) -> bool:
    algorithm == "sha256" || algorithm == "sha512"

# Get recommended algorithm
fn get_recommended_algorithm() -> text:
    "sha256"

# Get recommended iterations for PBKDF2
fn get_recommended_pbkdf2_iterations() -> i64:
    100000
