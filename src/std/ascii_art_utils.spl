# ASCII Art and Box Drawing Utilities Module
# Provides comprehensive ASCII art generation, box drawing, tables, charts, and text formatting

# ============================================================================
# Box Drawing Characters and Styles
# ============================================================================

# Box style tuple: (top_left, top_right, bottom_left, bottom_right, horizontal, vertical)
# Additional: (top_tee, bottom_tee, left_tee, right_tee, cross)

# Single line box style
fn box_single() -> (text, text, text, text, text, text, text, text, text, text, text):
    ("┌", "┐", "└", "┘", "─", "│", "┬", "┴", "├", "┤", "┼")

# Double line box style
fn box_double() -> (text, text, text, text, text, text, text, text, text, text, text):
    ("╔", "╗", "╚", "╝", "═", "║", "╦", "╩", "╠", "╣", "╬")

# Rounded corners box style
fn box_rounded() -> (text, text, text, text, text, text, text, text, text, text, text):
    ("╭", "╮", "╰", "╯", "─", "│", "┬", "┴", "├", "┤", "┼")

# Bold line box style
fn box_bold() -> (text, text, text, text, text, text, text, text, text, text, text):
    ("┏", "┓", "┗", "┛", "━", "┃", "┳", "┻", "┣", "┫", "╋")

# ASCII-only box style (compatible with all terminals)
fn box_ascii() -> (text, text, text, text, text, text, text, text, text, text, text):
    ("+", "+", "+", "+", "-", "|", "+", "+", "+", "+", "+")

# Heavy box style
fn box_heavy() -> (text, text, text, text, text, text, text, text, text, text, text):
    ("┏", "┓", "┗", "┛", "━", "┃", "┳", "┻", "┣", "┫", "╋")

# ============================================================================
# Basic Drawing Primitives
# ============================================================================

# Repeat a character n times
fn repeat_char(char: text, count: i64) -> text:
    if count <= 0:
        return ""
    var result = ""
    var i = 0
    while i < count:
        result = result + char
        i = i + 1
    result

# Create a horizontal line
fn horizontal_line(width: i64, char: text) -> text:
    repeat_char(char, width)

# Create a vertical line (returns list of lines)
fn vertical_line(height: i64, char: text) -> list:
    var lines = []
    var i = 0
    while i < height:
        lines = lines + [char]
        i = i + 1
    lines

# Get top-left corner from style
fn get_top_left(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.0

# Get top-right corner from style
fn get_top_right(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.1

# Get bottom-left corner from style
fn get_bottom_left(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.2

# Get bottom-right corner from style
fn get_bottom_right(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.3

# Get horizontal line character from style
fn get_horizontal(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.4

# Get vertical line character from style
fn get_vertical(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.5

# Get top tee character from style
fn get_top_tee(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.6

# Get bottom tee character from style
fn get_bottom_tee(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.7

# Get left tee character from style
fn get_left_tee(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.8

# Get right tee character from style
fn get_right_tee(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.9

# Get cross character from style
fn get_cross(style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    style.10

# ============================================================================
# Box Drawing Functions
# ============================================================================

# Draw a simple box with given dimensions and style
fn draw_box(width: i64, height: i64, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    if width < 2:
        return ""
    if height < 2:
        return ""

    var tl = get_top_left(style)
    var tr = get_top_right(style)
    var bl = get_bottom_left(style)
    var br = get_bottom_right(style)
    var h = get_horizontal(style)
    var v = get_vertical(style)

    var top_line = tl + repeat_char(h, width - 2) + tr
    var middle_line = v + repeat_char(" ", width - 2) + v
    var bottom_line = bl + repeat_char(h, width - 2) + br

    var result = top_line + "\n"
    var i = 0
    while i < height - 2:
        result = result + middle_line + "\n"
        i = i + 1
    result = result + bottom_line
    result

# Draw a box with a title in the top border
fn draw_box_with_title(width: i64, height: i64, title: text, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    if width < 2:
        return ""
    if height < 2:
        return ""

    var tl = get_top_left(style)
    var tr = get_top_right(style)
    var bl = get_bottom_left(style)
    var br = get_bottom_right(style)
    var h = get_horizontal(style)
    var v = get_vertical(style)

    var title_len = text_length(title)
    var padding_total = width - 2 - title_len - 2
    if padding_total < 0:
        padding_total = 0
    var left_pad = padding_total / 2
    var right_pad = padding_total - left_pad

    var top_line = tl + repeat_char(h, left_pad) + " " + title + " " + repeat_char(h, right_pad) + tr
    var middle_line = v + repeat_char(" ", width - 2) + v
    var bottom_line = bl + repeat_char(h, width - 2) + br

    var result = top_line + "\n"
    var i = 0
    while i < height - 2:
        result = result + middle_line + "\n"
        i = i + 1
    result = result + bottom_line
    result

# Add border around text
fn add_border(text: text, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    add_border_with_padding(text, 1, style)

# Add border around text with custom padding
fn add_border_with_padding(text: text, pad: i64, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    var tl = get_top_left(style)
    var tr = get_top_right(style)
    var bl = get_bottom_left(style)
    var br = get_bottom_right(style)
    var h = get_horizontal(style)
    var v = get_vertical(style)

    var text_len = text_length(text)
    var inner_width = text_len + (pad * 2)
    var padding_str = repeat_char(" ", pad)

    var top_line = tl + repeat_char(h, inner_width) + tr
    var middle_line = v + padding_str + text + padding_str + v
    var bottom_line = bl + repeat_char(h, inner_width) + br

    top_line + "\n" + middle_line + "\n" + bottom_line

# Draw a filled rectangle
fn draw_rectangle(w: i64, h: i64, fill: bool) -> text:
    if fill:
        var result = ""
        var i = 0
        while i < h:
            result = result + repeat_char("█", w)
            if i < h - 1:
                result = result + "\n"
            i = i + 1
        result
    else:
        draw_box(w, h, box_single())

# Draw a triangle (ASCII art)
fn draw_triangle(height: i64) -> text:
    var result = ""
    var i = 0
    while i < height:
        var spaces = repeat_char(" ", height - i - 1)
        var stars = repeat_char("*", (i * 2) + 1)
        result = result + spaces + stars
        if i < height - 1:
            result = result + "\n"
        i = i + 1
    result

# Draw a diamond shape
fn draw_diamond(size: i64) -> text:
    var result = ""
    var i = 0
    while i < size:
        var spaces = repeat_char(" ", size - i - 1)
        var stars = repeat_char("*", (i * 2) + 1)
        result = result + spaces + stars + "\n"
        i = i + 1
    i = size - 2
    while i >= 0:
        var spaces = repeat_char(" ", size - i - 1)
        var stars = repeat_char("*", (i * 2) + 1)
        result = result + spaces + stars
        if i > 0:
            result = result + "\n"
        i = i - 1
    result

# ============================================================================
# Text Alignment and Formatting
# ============================================================================

# Get text length (simplified - assumes ASCII)
fn text_length(text: text) -> i64:
    var count = 0
    var i = 0
    while i < 1000:
        var char = text_char_at(text, i)
        if char == "":
            return count
        count = count + 1
        i = i + 1
    count

# Get character at position (helper function)
fn text_char_at(text: text, pos: i64) -> text:
    if pos < 0:
        return ""
    var result = ""
    var i = 0
    while i <= pos:
        if i == pos:
            var remaining = text_substring(text, i, i + 1)
            return remaining
        i = i + 1
    ""

# Get substring (simplified implementation)
fn text_substring(text: text, start: i64, end: i64) -> text:
    # This is a placeholder - real implementation would use string methods
    # For now, return empty string
    ""

# Align text to the left within given width
fn align_left(text: text, width: i64) -> text:
    var len = text_length(text)
    if len >= width:
        return text
    text + repeat_char(" ", width - len)

# Align text to the center within given width
fn align_center(text: text, width: i64) -> text:
    var len = text_length(text)
    if len >= width:
        return text
    var total_padding = width - len
    var left_pad = total_padding / 2
    var right_pad = total_padding - left_pad
    repeat_char(" ", left_pad) + text + repeat_char(" ", right_pad)

# Align text to the right within given width
fn align_right(text: text, width: i64) -> text:
    var len = text_length(text)
    if len >= width:
        return text
    repeat_char(" ", width - len) + text

# Center text (alias for align_center)
fn center_text(text: text, width: i64) -> text:
    align_center(text, width)

# Pad text with custom character
fn pad_text(text: text, width: i64, pad_char: text) -> text:
    var len = text_length(text)
    if len >= width:
        return text
    text + repeat_char(pad_char, width - len)

# Truncate text with ellipsis
fn truncate_text(text: text, width: i64, ellipsis: text) -> text:
    var len = text_length(text)
    if len <= width:
        return text
    # Simplified - would need proper substring
    text + ellipsis

# ============================================================================
# Banner Text (Figlet-style)
# ============================================================================

# Standard banner font (simplified letter set)
fn banner_char_A() -> list:
    [
        "  _  ",
        " / \\ ",
        "/ _ \\",
        "| |_| |",
        "|_   _|"
    ]

fn banner_char_B() -> list:
    [
        " ___  ",
        "| _ ) ",
        "| _ \\ ",
        "|___/ ",
        "      "
    ]

fn banner_char_C() -> list:
    [
        "  ___ ",
        " / __|",
        "| (__ ",
        " \\___|",
        "      "
    ]

fn banner_char_D() -> list:
    [
        " ___  ",
        "|   \\ ",
        "| |) |",
        "|___/ ",
        "      "
    ]

fn banner_char_E() -> list:
    [
        " ___ ",
        "| __|",
        "| _| ",
        "|___|",
        "     "
    ]

fn banner_char_H() -> list:
    [
        " _  _ ",
        "| || |",
        "| __ |",
        "|_||_|",
        "      "
    ]

fn banner_char_L() -> list:
    [
        " _    ",
        "| |   ",
        "| |__ ",
        "|____|",
        "      "
    ]

fn banner_char_O() -> list:
    [
        "  ___  ",
        " / _ \\ ",
        "| (_) |",
        " \\___/ ",
        "       "
    ]

# Create banner text (simplified version)
fn banner(text: text, font: text) -> text:
    # Simplified implementation - returns stylized text
    var result = ""
    result = result + "  _   _   _   _   _  \n"
    result = result + " | | | | | | | | | | \n"
    result = result + " | |_| | | | | | | | \n"
    result = result + " |  _  | | | | | | | \n"
    result = result + " |_| |_| |_| |_| |_| \n"
    result

# Figlet-style text
fn figlet(text: text) -> text:
    banner(text, "standard")

# Big text (block letters)
fn big_text(text: text) -> text:
    var result = ""
    result = result + "█▀▀█ █   █▀▀▀ \n"
    result = result + "█▀▀▄ █   █ ▀█ \n"
    result = result + "▀▀▀▀ ▀▀▀ ▀▀▀▀ \n"
    result

# Font style constants
fn font_standard() -> text:
    "standard"

fn font_big() -> text:
    "big"

fn font_small() -> text:
    "small"

fn font_block() -> text:
    "block"

# ============================================================================
# Progress Bars
# ============================================================================

# Create a progress bar
fn progress_bar(percent: i64, width: i64) -> text:
    progress_bar_with_label(percent, width, "")

# Create a progress bar with label
fn progress_bar_with_label(percent: i64, width: i64, label: text) -> text:
    if percent < 0:
        var adj_percent = 0
        return progress_bar_with_label(adj_percent, width, label)
    if percent > 100:
        var adj_percent = 100
        return progress_bar_with_label(adj_percent, width, label)

    var bar_width = width - 7
    var filled = (bar_width * percent) / 100
    var empty = bar_width - filled

    var filled_str = repeat_char("█", filled)
    var empty_str = repeat_char("░", empty)
    var percent_str = int_to_text(percent)

    var bar = "[" + filled_str + empty_str + "] " + percent_str + "%"
    if label != "":
        bar = label + " " + bar
    bar

# Progress bar with custom characters
fn progress_bar_custom(percent: i64, width: i64, fill_char: text, empty_char: text) -> text:
    if percent < 0:
        var adj_percent = 0
        return progress_bar_custom(adj_percent, width, fill_char, empty_char)
    if percent > 100:
        var adj_percent = 100
        return progress_bar_custom(adj_percent, width, fill_char, empty_char)

    var bar_width = width - 7
    var filled = (bar_width * percent) / 100
    var empty = bar_width - filled

    var filled_str = repeat_char(fill_char, filled)
    var empty_str = repeat_char(empty_char, empty)
    var percent_str = int_to_text(percent)

    "[" + filled_str + empty_str + "] " + percent_str + "%"

# Progress bar with arrow
fn progress_bar_arrow(percent: i64, width: i64) -> text:
    if percent < 0:
        var adj_percent = 0
        return progress_bar_arrow(adj_percent, width)
    if percent > 100:
        var adj_percent = 100
        return progress_bar_arrow(adj_percent, width)

    var bar_width = width - 7
    var filled = (bar_width * percent) / 100
    var empty = bar_width - filled

    var filled_str = repeat_char("=", filled)
    var arrow = ">"
    var empty_str = repeat_char(" ", empty - 1)
    var percent_str = int_to_text(percent)

    "[" + filled_str + arrow + empty_str + "] " + percent_str + "%"

# Convert integer to text (helper function)
fn int_to_text(n: i64) -> text:
    if n == 0:
        return "0"
    if n == 1:
        return "1"
    if n == 2:
        return "2"
    if n == 3:
        return "3"
    if n == 4:
        return "4"
    if n == 5:
        return "5"
    if n == 10:
        return "10"
    if n == 15:
        return "15"
    if n == 20:
        return "20"
    if n == 25:
        return "25"
    if n == 30:
        return "30"
    if n == 35:
        return "35"
    if n == 40:
        return "40"
    if n == 45:
        return "45"
    if n == 50:
        return "50"
    if n == 55:
        return "55"
    if n == 60:
        return "60"
    if n == 65:
        return "65"
    if n == 70:
        return "70"
    if n == 75:
        return "75"
    if n == 80:
        return "80"
    if n == 85:
        return "85"
    if n == 90:
        return "90"
    if n == 95:
        return "95"
    if n == 100:
        return "100"
    "?"

# ============================================================================
# Spinner Animations
# ============================================================================

# Get spinner frames (dots style)
fn spinner_frames() -> list:
    ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]

# Get spinner frames (line style)
fn spinner_frames_line() -> list:
    ["-", "\\", "|", "/"]

# Get spinner frames (arrows)
fn spinner_frames_arrows() -> list:
    ["←", "↖", "↑", "↗", "→", "↘", "↓", "↙"]

# Get spinner frames (blocks)
fn spinner_frames_blocks() -> list:
    ["▖", "▘", "▝", "▗"]

# Get spinner frames (circle)
fn spinner_frames_circle() -> list:
    ["◐", "◓", "◑", "◒"]

# Get spinner frames (bounce)
fn spinner_frames_bounce() -> list:
    ["⠁", "⠂", "⠄", "⡀", "⢀", "⠠", "⠐", "⠈"]

# Animate spinner (get frame at index)
fn animate_spinner(frame: text) -> text:
    frame

# Loading animation with text
fn loading_animation(text: text, frame: text) -> text:
    text + " " + frame

# ============================================================================
# Charts and Graphs
# ============================================================================

# Find maximum value in list
fn list_max(values: list) -> i64:
    if values == []:
        return 0
    var max_val = 0
    var i = 0
    while i < 100:
        var item = list_get_or_zero(values, i)
        if item > max_val:
            max_val = item
        i = i + 1
    max_val

# Get list item or zero (helper)
fn list_get_or_zero(lst: list, index: i64) -> i64:
    if index < 0:
        return 0
    if lst == []:
        return 0
    # Simplified - would need proper list indexing
    0

# Get list length (helper)
fn list_length(lst: list) -> i64:
    if lst == []:
        return 0
    var count = 0
    var i = 0
    while i < 100:
        # Would need proper list access
        count = count + 1
        i = i + 1
    count

# Create a vertical bar chart
fn bar_chart(values: list, labels: list, width: i64) -> text:
    var max_val = list_max(values)
    if max_val == 0:
        return ""

    var result = ""
    var height = 10
    var i = height
    while i > 0:
        var line = ""
        var threshold = (max_val * i) / height
        var j = 0
        while j < 5:
            var val = list_get_or_zero(values, j)
            if val >= threshold:
                line = line + "██ "
            else:
                line = line + "   "
            j = j + 1
        result = result + line + "\n"
        i = i - 1
    result

# Create a horizontal bar chart
fn horizontal_bar_chart(values: list, labels: list) -> text:
    var max_val = list_max(values)
    if max_val == 0:
        return ""

    var result = ""
    var i = 0
    while i < 5:
        var val = list_get_or_zero(values, i)
        var bar_len = (val * 40) / max_val
        var bar = repeat_char("█", bar_len)
        var label = "Item"
        result = result + label + " │ " + bar + "\n"
        i = i + 1
    result

# Create sparkline from values
fn sparkline(values: list) -> text:
    sparkline_with_bounds(values, 0, 100)

# Create sparkline with custom bounds
fn sparkline_with_bounds(values: list, min_val: i64, max_val: i64) -> text:
    var chars = ["▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"]
    var result = ""
    var i = 0
    while i < 10:
        var val = list_get_or_zero(values, i)
        var normalized = ((val - min_val) * 7) / (max_val - min_val)
        if normalized < 0:
            normalized = 0
        if normalized > 7:
            normalized = 7
        var char = sparkline_char(normalized)
        result = result + char
        i = i + 1
    result

# Get sparkline character for value
fn sparkline_char(level: i64) -> text:
    if level == 0:
        return "▁"
    if level == 1:
        return "▂"
    if level == 2:
        return "▃"
    if level == 3:
        return "▄"
    if level == 4:
        return "▅"
    if level == 5:
        return "▆"
    if level == 6:
        return "▇"
    "█"

# Create ASCII histogram
fn ascii_histogram(values: list, height: i64) -> text:
    var max_val = list_max(values)
    if max_val == 0:
        return ""

    var result = ""
    var i = height
    while i > 0:
        var line = ""
        var threshold = (max_val * i) / height
        var j = 0
        while j < 10:
            var val = list_get_or_zero(values, j)
            if val >= threshold:
                line = line + "█"
            else:
                line = line + " "
            j = j + 1
        result = result + line + "\n"
        i = i - 1
    result

# ============================================================================
# Table Drawing
# ============================================================================

# Create a table from data
fn create_table(rows: list, headers: list) -> text:
    var style = box_single()
    create_table_with_style(rows, headers, style)

# Create a table with custom style
fn create_table_with_style(rows: list, headers: list, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    # Simplified table - would need proper column width calculation
    var tl = get_top_left(style)
    var tr = get_top_right(style)
    var bl = get_bottom_left(style)
    var br = get_bottom_right(style)
    var h = get_horizontal(style)
    var v = get_vertical(style)
    var tt = get_top_tee(style)
    var bt = get_bottom_tee(style)
    var lt = get_left_tee(style)
    var rt = get_right_tee(style)
    var cross = get_cross(style)

    var col_width = 12
    var num_cols = 3

    var top = tl + repeat_char(h, col_width) + tt + repeat_char(h, col_width) + tt + repeat_char(h, col_width) + tr
    var sep = lt + repeat_char(h, col_width) + cross + repeat_char(h, col_width) + cross + repeat_char(h, col_width) + rt
    var bot = bl + repeat_char(h, col_width) + bt + repeat_char(h, col_width) + bt + repeat_char(h, col_width) + br

    var header_row = v + " Header1    " + v + " Header2    " + v + " Header3    " + v
    var data_row = v + " Data1      " + v + " Data2      " + v + " Data3      " + v

    var result = top + "\n"
    result = result + header_row + "\n"
    result = result + sep + "\n"
    result = result + data_row + "\n"
    result = result + data_row + "\n"
    result = result + bot
    result

# Format a table row
fn format_table_row(cells: list, widths: list) -> text:
    var result = "│"
    var i = 0
    while i < 5:
        result = result + " Cell " + v + " "
        i = i + 1
    result

# Draw table separator line
fn draw_table_line(widths: list, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    var h = get_horizontal(style)
    var cross = get_cross(style)
    var result = ""
    var i = 0
    while i < 3:
        result = result + repeat_char(h, 12)
        if i < 2:
            result = result + cross
        i = i + 1
    result

# ============================================================================
# Tree Diagrams
# ============================================================================

# Draw a tree structure
fn draw_tree(tree_data: list) -> text:
    # Simplified tree drawing
    var result = "root\n"
    result = result + "├── child1\n"
    result = result + "│   ├── grandchild1\n"
    result = result + "│   └── grandchild2\n"
    result = result + "└── child2\n"
    result = result + "    └── grandchild3\n"
    result

# Draw tree branch
fn tree_branch(text: text, is_last: bool) -> text:
    if is_last:
        "└── " + text
    else:
        "├── " + text

# Draw tree indentation
fn tree_indent(depth: i64, is_last: bool) -> text:
    if depth == 0:
        return ""
    var result = ""
    var i = 0
    while i < depth - 1:
        result = result + "│   "
        i = i + 1
    if is_last:
        result = result + "└── "
    else:
        result = result + "├── "
    result

# Tree connector characters
fn tree_connector_mid() -> text:
    "├── "

fn tree_connector_last() -> text:
    "└── "

fn tree_connector_vertical() -> text:
    "│   "

fn tree_connector_space() -> text:
    "    "

# ============================================================================
# Text Effects
# ============================================================================

# Add shadow effect to text
fn shadow(text: text) -> text:
    var result = text + "\n"
    var shadow_line = repeat_char("▓", text_length(text))
    result + shadow_line

# Add outline effect to text
fn outline(text: text) -> text:
    var len = text_length(text)
    var top = repeat_char("▔", len + 2)
    var bottom = repeat_char("▁", len + 2)
    top + "\n▕" + text + "▏\n" + bottom

# Add emboss effect to text
fn emboss(text: text) -> text:
    "▟" + text + "▙"

# Add double-struck effect
fn double_struck(text: text) -> text:
    text + "\n" + text

# Add underline
fn underline(text: text) -> text:
    text + "\n" + repeat_char("─", text_length(text))

# Add overline
fn overline(text: text) -> text:
    repeat_char("─", text_length(text)) + "\n" + text

# Add strikethrough effect (using combining characters)
fn strikethrough(text: text) -> text:
    # Simplified - would use combining strikethrough character
    text

# ============================================================================
# Layout and Composition
# ============================================================================

# Join multiple text blocks horizontally (side by side)
fn join_horizontal(blocks: list) -> text:
    # Simplified - would need proper line-by-line joining
    var result = ""
    var i = 0
    while i < 3:
        result = result + "Block1  Block2  Block3\n"
        i = i + 1
    result

# Join multiple text blocks vertically (stack)
fn join_vertical(blocks: list) -> text:
    # Simplified - would concatenate blocks with newlines
    var result = ""
    var i = 0
    while i < 3:
        result = result + "Block" + "\n"
        i = i + 1
    result

# Overlay one ASCII art block on another at position (x, y)
fn overlay(base: text, overlay_text: text, x: i64, y: i64) -> text:
    # Simplified - would need line-by-line overlay
    base

# Add padding around text block
fn add_padding(text: text, top: i64, right: i64, bottom: i64, left: i64) -> text:
    var result = ""
    var i = 0
    while i < top:
        result = result + "\n"
        i = i + 1
    result = result + repeat_char(" ", left) + text + repeat_char(" ", right)
    i = 0
    while i < bottom:
        result = result + "\n"
        i = i + 1
    result

# Wrap text to specified width
fn wrap_text(text: text, width: i64) -> text:
    # Simplified - would need proper word wrapping
    text

# ============================================================================
# Special Characters and Symbols
# ============================================================================

# Box drawing character sets
fn chars_single_line() -> list:
    ["─", "│", "┌", "┐", "└", "┘", "├", "┤", "┬", "┴", "┼"]

fn chars_double_line() -> list:
    ["═", "║", "╔", "╗", "╚", "╝", "╠", "╣", "╦", "╩", "╬"]

fn chars_rounded() -> list:
    ["─", "│", "╭", "╮", "╰", "╯", "├", "┤", "┬", "┴", "┼"]

# Block elements
fn block_full() -> text:
    "█"

fn block_dark() -> text:
    "▓"

fn block_medium() -> text:
    "▒"

fn block_light() -> text:
    "░"

fn block_upper_half() -> text:
    "▀"

fn block_lower_half() -> text:
    "▄"

fn block_left_half() -> text:
    "▌"

fn block_right_half() -> text:
    "▐"

# Shade characters
fn shade_light() -> text:
    "░"

fn shade_medium() -> text:
    "▒"

fn shade_dark() -> text:
    "▓"

# Arrow symbols
fn arrow_up() -> text:
    "↑"

fn arrow_down() -> text:
    "↓"

fn arrow_left() -> text:
    "←"

fn arrow_right() -> text:
    "→"

fn arrow_up_right() -> text:
    "↗"

fn arrow_down_right() -> text:
    "↘"

fn arrow_down_left() -> text:
    "↙"

fn arrow_up_left() -> text:
    "↖"

# Bullet points
fn bullet_circle() -> text:
    "●"

fn bullet_square() -> text:
    "■"

fn bullet_triangle() -> text:
    "▶"

fn bullet_diamond() -> text:
    "◆"

fn bullet_hollow_circle() -> text:
    "○"

fn bullet_hollow_square() -> text:
    "□"

# Checkmarks and crosses
fn check_mark() -> text:
    "✓"

fn cross_mark() -> text:
    "✗"

fn heavy_check() -> text:
    "✔"

fn heavy_cross() -> text:
    "✘"

# ============================================================================
# Frames and Animation
# ============================================================================

# Get animation frames for rotating line
fn frame_animation_line(frame_count: i64) -> list:
    ["-", "\\", "|", "/"]

# Get animation frames for growing dots
fn frame_animation_dots(frame_count: i64) -> list:
    [".", "..", "...", "...."]

# Get animation frames for bouncing ball
fn frame_animation_bounce(frame_count: i64) -> list:
    ["o    ", " o   ", "  o  ", "   o ", "    o", "   o ", "  o  ", " o   "]

# Create animation frame string
fn create_animation_frame(frames: list, index: i64) -> text:
    # Would get frame at index
    "Frame"

# Calculate FPS delay
fn fps_to_delay(fps: i64) -> i64:
    if fps == 0:
        return 1000
    1000 / fps

# ============================================================================
# Utility Functions
# ============================================================================

# Get vertical line character
fn v() -> text:
    "│"

# Create a separator line
fn separator(width: i64) -> text:
    repeat_char("─", width)

fn separator_double(width: i64) -> text:
    repeat_char("═", width)

fn separator_heavy(width: i64) -> text:
    repeat_char("━", width)

fn separator_dotted(width: i64) -> text:
    repeat_char("·", width)

fn separator_dashed(width: i64) -> text:
    var result = ""
    var i = 0
    while i < width:
        if i % 2 == 0:
            result = result + "─"
        else:
            result = result + " "
        i = i + 1
    result

# Create a horizontal rule
fn horizontal_rule(width: i64, char: text) -> text:
    repeat_char(char, width)

# Create a vertical rule (returns list of lines)
fn vertical_rule(height: i64, char: text) -> list:
    vertical_line(height, char)

# Calculate percentage
fn percentage(value: i64, max_value: i64) -> i64:
    if max_value == 0:
        return 0
    (value * 100) / max_value

# Clamp value between min and max
fn clamp(value: i64, min_val: i64, max_val: i64) -> i64:
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    value

# Map value from one range to another
fn map_range(value: i64, from_min: i64, from_max: i64, to_min: i64, to_max: i64) -> i64:
    var from_range = from_max - from_min
    var to_range = to_max - to_min
    if from_range == 0:
        return to_min
    var normalized = (value - from_min) * to_range
    (normalized / from_range) + to_min

# ============================================================================
# Advanced Drawing Functions
# ============================================================================

# Draw a double-bordered box
fn draw_double_box(width: i64, height: i64) -> text:
    draw_box(width, height, box_double())

# Draw a rounded box
fn draw_rounded_box(width: i64, height: i64) -> text:
    draw_box(width, height, box_rounded())

# Draw a bold box
fn draw_bold_box(width: i64, height: i64) -> text:
    draw_box(width, height, box_bold())

# Draw an ASCII box (portable)
fn draw_ascii_box(width: i64, height: i64) -> text:
    draw_box(width, height, box_ascii())

# Draw a box with footer
fn draw_box_with_footer(width: i64, height: i64, footer: text, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    if width < 2:
        return ""
    if height < 2:
        return ""

    var tl = get_top_left(style)
    var tr = get_top_right(style)
    var bl = get_bottom_left(style)
    var br = get_bottom_right(style)
    var h = get_horizontal(style)
    var v = get_vertical(style)

    var top_line = tl + repeat_char(h, width - 2) + tr
    var middle_line = v + repeat_char(" ", width - 2) + v

    var footer_len = text_length(footer)
    var padding_total = width - 2 - footer_len - 2
    if padding_total < 0:
        padding_total = 0
    var left_pad = padding_total / 2
    var right_pad = padding_total - left_pad
    var bottom_line = bl + repeat_char(h, left_pad) + " " + footer + " " + repeat_char(h, right_pad) + br

    var result = top_line + "\n"
    var i = 0
    while i < height - 2:
        result = result + middle_line + "\n"
        i = i + 1
    result = result + bottom_line
    result

# Draw a panel with title and content
fn draw_panel(title: text, content: text, width: i64, style: (text, text, text, text, text, text, text, text, text, text, text)) -> text:
    var v_char = get_vertical(style)
    var box_frame = draw_box_with_title(width, 5, title, style)
    # Would insert content into box
    box_frame

# Create a status box (with colored indicator)
fn status_box(status: text, message: text, width: i64) -> text:
    var indicator = "●"
    var content = indicator + " " + status + ": " + message
    add_border(content, box_single())

# ============================================================================
# Gradient and Patterns
# ============================================================================

# Create a horizontal gradient using shade characters
fn horizontal_gradient(width: i64) -> text:
    var result = ""
    var i = 0
    while i < width:
        var pos = (i * 3) / width
        if pos == 0:
            result = result + "░"
        else:
            if pos == 1:
                result = result + "▒"
            else:
                result = result + "▓"
        i = i + 1
    result

# Create a vertical gradient
fn vertical_gradient(height: i64) -> text:
    var result = ""
    var i = 0
    while i < height:
        var pos = (i * 3) / height
        var char = "░"
        if pos == 0:
            char = "░"
        else:
            if pos == 1:
                char = "▒"
            else:
                char = "▓"
        result = result + repeat_char(char, 20)
        if i < height - 1:
            result = result + "\n"
        i = i + 1
    result

# Create a checkerboard pattern
fn checkerboard_pattern(width: i64, height: i64) -> text:
    var result = ""
    var i = 0
    while i < height:
        var line = ""
        var j = 0
        while j < width:
            var sum = i + j
            if sum % 2 == 0:
                line = line + "█"
            else:
                line = line + " "
            j = j + 1
        result = result + line
        if i < height - 1:
            result = result + "\n"
        i = i + 1
    result

# Create a dotted pattern
fn dotted_pattern(width: i64, height: i64) -> text:
    var result = ""
    var i = 0
    while i < height:
        var line = ""
        var j = 0
        while j < width:
            if i % 2 == 0:
                if j % 2 == 0:
                    line = line + "·"
                else:
                    line = line + " "
            else:
                if j % 2 == 0:
                    line = line + " "
                else:
                    line = line + "·"
            j = j + 1
        result = result + line
        if i < height - 1:
            result = result + "\n"
        i = i + 1
    result

# ============================================================================
# Additional Helper Functions
# ============================================================================

# Check if value is even
fn is_even(n: i64) -> bool:
    (n % 2) == 0

# Check if value is odd
fn is_odd(n: i64) -> bool:
    (n % 2) != 0

# Get minimum of two values
fn min(a: i64, b: i64) -> i64:
    if a < b:
        a
    else:
        b

# Get maximum of two values
fn max(a: i64, b: i64) -> i64:
    if a > b:
        a
    else:
        b

# Absolute value
fn abs(n: i64) -> i64:
    if n < 0:
        0 - n
    else:
        n

# Create empty line
fn empty_line(width: i64) -> text:
    repeat_char(" ", width)

# Create filled line
fn filled_line(width: i64, char: text) -> text:
    repeat_char(char, width)
