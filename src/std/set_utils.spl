# Set Utilities Module
#
# Comprehensive set data structure implementation for Simple.
# Sets are collections of unique elements with efficient membership testing.
#
# Implementation Strategy:
# - Uses dictionary-backed sets for O(1) membership testing
# - Supports conversion to/from arrays and lists
# - Pure Simple implementation - no generics at runtime
# - Works with any hashable type (strings, numbers, etc.)
#
# Categories:
# - Creation: set_new, set_from_array, set_from_list
# - Basic ops: set_add, set_remove, set_contains, set_size, set_is_empty, set_clear
# - Set algebra: set_union, set_intersection, set_difference, set_symmetric_difference
# - Predicates: set_is_subset, set_is_superset, set_is_disjoint, set_equals
# - Transformations: set_map, set_filter, set_partition
# - Conversion: set_to_array, set_to_list, set_to_sorted_array
# - Multi-element: set_add_all, set_remove_all, set_retain_all
# - Advanced: set_powerset, set_cartesian_product, set_comprehension
# - Iteration: set_foreach, set_reduce, set_any, set_all
# - Copying: set_copy, set_clone
#
# Set representation: Dictionary where keys are elements (as strings) and values are the original elements.
# This allows O(1) lookup while preserving the original values.

# ============================================================================
# Type Helpers - Convert values to hashable keys
# ============================================================================

fn _to_key(value) -> text:
    """Convert value to string key for hashing.
    Works around runtime limitations by using string representation."""
    "{value}"

fn _from_key(key: text, original):
    """Extract original value. For simple types, use the original passed value."""
    original

# ============================================================================
# Set Creation
# ============================================================================

fn set_new():
    """Create a new empty set.

    Returns a dictionary representing the set.

    Example:
        val s = set_new()
        set_is_empty(s)  # true
    """
    {}

fn set_from_array(arr):
    """Create a set from an array, removing duplicates.

    Example:
        set_from_array([1, 2, 2, 3, 1])  # Set containing {1, 2, 3}
    """
    var s = {}
    for item in arr:
        val key = "{item}"
        s[key] = item
    s

fn set_from_list(list):
    """Create a set from a list, removing duplicates.

    Example:
        set_from_list([1, 2, 2, 3])  # Set containing {1, 2, 3}
    """
    set_from_array(list)

fn set_of(items):
    """Create a set from variable number of items (passed as array).

    Example:
        set_of([1, 2, 3])  # Set containing {1, 2, 3}
    """
    set_from_array(items)

# ============================================================================
# Basic Set Operations
# ============================================================================

fn set_add(s, item):
    """Add an element to the set. Returns new set.
    If element already exists, returns the original set unchanged.

    Example:
        var s = set_new()
        s = set_add(s, 42)
        set_contains(s, 42)  # true
    """
    val key = _to_key(item)
    if s.contains_key(key):
        return s
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    result[key] = item
    result

fn set_remove(s, item):
    """Remove an element from the set. Returns new set.
    If element doesn't exist, returns the original set unchanged.

    Example:
        var s = set_from_array([1, 2, 3])
        s = set_remove(s, 2)
        set_contains(s, 2)  # false
    """
    val key = _to_key(item)
    if not s.contains_key(key):
        return s
    var result = {}
    for k in s.keys():
        if k != key:
            result[k] = s[k]
    result

fn set_contains(s, item) -> bool:
    """Check if element is in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_contains(s, 2)  # true
        set_contains(s, 5)  # false
    """
    val key = _to_key(item)
    s.contains_key(key)

fn set_size(s) -> i64:
    """Get the number of elements in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_size(s)  # 3
    """
    s.keys().len()

fn set_is_empty(s) -> bool:
    """Check if set is empty.

    Example:
        set_is_empty(set_new())  # true
    """
    s.keys().len() == 0

fn set_clear(s):
    """Remove all elements from the set. Returns empty set.

    Example:
        var s = set_from_array([1, 2, 3])
        s = set_clear(s)
        set_is_empty(s)  # true
    """
    {}

# ============================================================================
# Set Algebra Operations
# ============================================================================

fn set_union(a, b):
    """Union of two sets - all elements from both sets.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([3, 4, 5])
        val u = set_union(a, b)  # {1, 2, 3, 4, 5}
    """
    var result = {}
    for k in a.keys():
        result[k] = a[k]
    for k in b.keys():
        result[k] = b[k]
    result

fn set_intersection(a, b):
    """Intersection of two sets - elements present in both.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val i = set_intersection(a, b)  # {2, 3}
    """
    var result = {}
    for k in a.keys():
        if b.contains_key(k):
            result[k] = a[k]
    result

fn set_difference(a, b):
    """Difference of two sets - elements in A but not in B.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val d = set_difference(a, b)  # {1}
    """
    var result = {}
    for k in a.keys():
        if not b.contains_key(k):
            result[k] = a[k]
    result

fn set_symmetric_difference(a, b):
    """Symmetric difference - elements in A or B but not in both.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val sd = set_symmetric_difference(a, b)  # {1, 4}
    """
    var result = {}
    for k in a.keys():
        if not b.contains_key(k):
            result[k] = a[k]
    for k in b.keys():
        if not a.contains_key(k):
            result[k] = b[k]
    result

# ============================================================================
# Set Predicates
# ============================================================================

fn set_is_subset(a, b) -> bool:
    """Check if A is a subset of B (all elements of A are in B).

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array([1, 2, 3])
        set_is_subset(a, b)  # true
    """
    for k in a.keys():
        if not b.contains_key(k):
            return false
    true

fn set_is_superset(a, b) -> bool:
    """Check if A is a superset of B (all elements of B are in A).

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([1, 2])
        set_is_superset(a, b)  # true
    """
    set_is_subset(b, a)

fn set_is_disjoint(a, b) -> bool:
    """Check if two sets have no elements in common.

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array([3, 4])
        set_is_disjoint(a, b)  # true
    """
    for k in a.keys():
        if b.contains_key(k):
            return false
    true

fn set_equals(a, b) -> bool:
    """Check if two sets are equal (same elements).

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([3, 2, 1])
        set_equals(a, b)  # true
    """
    if set_size(a) != set_size(b):
        return false
    set_is_subset(a, b)

# ============================================================================
# Set Transformations
# ============================================================================

fn set_map(s, mapper):
    """Map a function over all elements, creating a new set.

    Example:
        val s = set_from_array([1, 2, 3])
        val doubled = set_map(s, \x: x * 2)  # {2, 4, 6}
    """
    var result = {}
    for k in s.keys():
        val mapped = mapper(s[k])
        val mk = "{mapped}"
        result[mk] = mapped
    result

fn set_filter(s, predicate):
    """Filter set elements by predicate, creating a new set.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val evens = set_filter(s, \x: x % 2 == 0)  # {2, 4}
    """
    var result = {}
    for k in s.keys():
        if predicate(s[k]):
            result[k] = s[k]
    result

fn set_partition(s, predicate):
    """Partition set into two sets based on predicate.
    Returns tuple (matching_set, non_matching_set).

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val parts = set_partition(s, \x: x % 2 == 0)
        # parts[0] = {2, 4}, parts[1] = {1, 3, 5}
    """
    var matching = {}
    var non_matching = {}
    for k in s.keys():
        if predicate(s[k]):
            matching[k] = s[k]
        else:
            non_matching[k] = s[k]
    (matching, non_matching)

# ============================================================================
# Set Conversion
# ============================================================================

fn set_to_array(s):
    """Convert set to array. Order is not guaranteed.

    Example:
        val s = set_from_array([3, 1, 2])
        val arr = set_to_array(s)  # [1, 2, 3] or any order
    """
    var result = []
    for k in s.keys():
        result = result.push(s[k])
    result

fn set_to_list(s):
    """Convert set to list. Order is not guaranteed.

    Example:
        val s = set_from_array([3, 1, 2])
        val list = set_to_list(s)
    """
    set_to_array(s)

fn set_to_sorted_array(s):
    """Convert set to sorted array.
    Uses built-in sort() which works for comparable types.

    Example:
        val s = set_from_array([3, 1, 2])
        val arr = set_to_sorted_array(s)  # [1, 2, 3]
    """
    var arr = set_to_array(s)
    arr.sort()
    arr

# ============================================================================
# Multi-element Operations
# ============================================================================

fn set_add_all(s, items):
    """Add multiple elements to the set. Returns new set.

    Example:
        var s = set_new()
        s = set_add_all(s, [1, 2, 3])
        set_size(s)  # 3
    """
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    for item in items:
        val key = "{item}"
        result[key] = item
    result

fn set_remove_all(s, items):
    """Remove multiple elements from the set. Returns new set.

    Example:
        var s = set_from_array([1, 2, 3, 4, 5])
        s = set_remove_all(s, [2, 4])
        # s now contains {1, 3, 5}
    """
    # Build a lookup set of keys to remove
    var to_remove = {}
    for item in items:
        val key = "{item}"
        to_remove[key] = true
    # Copy only keys not in the removal set
    var result = {}
    for k in s.keys():
        if not to_remove.contains_key(k):
            result[k] = s[k]
    result

fn set_retain_all(s, items):
    """Retain only the specified elements. Returns new set.
    Equivalent to intersection with items.

    Example:
        var s = set_from_array([1, 2, 3, 4, 5])
        s = set_retain_all(s, [2, 3, 6])
        # s now contains {2, 3}
    """
    # Build a lookup set of keys to retain
    var to_retain = {}
    for item in items:
        val key = "{item}"
        to_retain[key] = true
    # Copy only keys present in the retain set
    var result = {}
    for k in s.keys():
        if to_retain.contains_key(k):
            result[k] = s[k]
    result

# ============================================================================
# Advanced Set Operations
# ============================================================================

fn set_powerset(s):
    """Generate the powerset (set of all subsets).
    Returns array of sets.

    Warning: Size grows exponentially (2^n). Use with small sets.

    Example:
        val s = set_from_array([1, 2])
        val ps = set_powerset(s)
        # [{}, {1}, {2}, {1, 2}]
    """
    val elements = set_to_array(s)
    var subsets = [{}]

    for elem in elements:
        val ek = "{elem}"
        var new_subsets = []
        for subset in subsets:
            # Build new subset by copying existing + adding elem directly
            var ns = {}
            for k in subset.keys():
                ns[k] = subset[k]
            ns[ek] = elem
            new_subsets = new_subsets.push(ns)
        for ns in new_subsets:
            subsets = subsets.push(ns)

    subsets

fn set_cartesian_product(a, b):
    """Compute Cartesian product of two sets.
    Returns set of tuples (pairs).

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array(["x", "y"])
        val prod = set_cartesian_product(a, b)
        # {(1, "x"), (1, "y"), (2, "x"), (2, "y")}
    """
    var result = {}
    for k1 in a.keys():
        for k2 in b.keys():
            val pair = (a[k1], b[k2])
            val pk = "{pair}"
            result[pk] = pair
    result

fn set_comprehension(source, predicate, mapper):
    """Set comprehension: {mapper(x) | x <- source if predicate(x)}.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val comp = set_comprehension(s, \x: x % 2 == 0, \x: x * x)
        # {4, 16} - squares of even numbers
    """
    var result = {}
    for k in source.keys():
        if predicate(source[k]):
            val mapped = mapper(source[k])
            val mk = "{mapped}"
            result[mk] = mapped
    result

# ============================================================================
# Iteration Operations
# ============================================================================

fn set_foreach(s, action):
    """Execute action for each element in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_foreach(s, \x: print("{x}"))
    """
    for k in s.keys():
        action(s[k])
    nil

fn set_reduce(s, initial, reducer):
    """Reduce set to a single value using reducer function.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        val sum = set_reduce(s, 0, \acc, x: acc + x)  # 10
    """
    var acc = initial
    for k in s.keys():
        acc = reducer(acc, s[k])
    acc

fn set_any(s, predicate) -> bool:
    """Check if any element satisfies the predicate.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        set_any(s, \x: x > 3)  # true
    """
    for k in s.keys():
        if predicate(s[k]):
            return true
    false

fn set_all(s, predicate) -> bool:
    """Check if all elements satisfy the predicate.

    Example:
        val s = set_from_array([2, 4, 6, 8])
        set_all(s, \x: x % 2 == 0)  # true
    """
    for k in s.keys():
        if not predicate(s[k]):
            return false
    true

fn set_count(s, predicate) -> i64:
    """Count elements that satisfy the predicate.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        set_count(s, \x: x % 2 == 0)  # 2
    """
    var count = 0
    for k in s.keys():
        if predicate(s[k]):
            count = count + 1
    count

fn set_find(s, predicate):
    """Find first element satisfying predicate. Returns nil if not found.

    Note: Order is not guaranteed in sets.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val found = set_find(s, \x: x > 3)  # Could be 4 or 5
    """
    for k in s.keys():
        if predicate(s[k]):
            return s[k]
    nil

# ============================================================================
# Set Copying
# ============================================================================

fn set_copy(s):
    """Create a shallow copy of the set.

    Example:
        val s1 = set_from_array([1, 2, 3])
        val s2 = set_copy(s1)
        set_equals(s1, s2)  # true
    """
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    result

fn set_clone(s):
    """Alias for set_copy.

    Example:
        val s2 = set_clone(s1)
    """
    set_copy(s)

# ============================================================================
# Set Utility Operations
# ============================================================================

fn set_min(s):
    """Find minimum element in set. Returns nil for empty set.

    Example:
        val s = set_from_array([3, 1, 4, 1, 5])
        set_min(s)  # 1
    """
    val arr = set_to_array(s)
    if arr.len() == 0:
        return nil
    var min_val = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] < min_val:
            min_val = arr[i]
        i = i + 1
    min_val

fn set_max(s):
    """Find maximum element in set. Returns nil for empty set.

    Example:
        val s = set_from_array([3, 1, 4, 1, 5])
        set_max(s)  # 5
    """
    val arr = set_to_array(s)
    if arr.len() == 0:
        return nil
    var max_val = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] > max_val:
            max_val = arr[i]
        i = i + 1
    max_val

fn set_sum(s):
    """Sum all numeric elements in set.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        set_sum(s)  # 10
    """
    set_reduce(s, 0, \acc, x: acc + x)

fn set_product(s):
    """Multiply all numeric elements in set.

    Example:
        val s = set_from_array([2, 3, 4])
        set_product(s)  # 24
    """
    set_reduce(s, 1, \acc, x: acc * x)

# ============================================================================
# Set Display
# ============================================================================

fn set_to_string(s) -> text:
    """Convert set to string representation.

    Example:
        val s = set_from_array([1, 2, 3])
        set_to_string(s)  # "{1, 2, 3}" (order may vary)
    """
    val arr = set_to_sorted_array(s)
    if arr.len() == 0:
        return "{}"

    var result = "{"
    var i = 0
    while i < arr.len():
        if i > 0:
            result = result + ", "
        result = result + "{arr[i]}"
        i = i + 1
    result + "}"

# ============================================================================
# Convenience Functions
# ============================================================================

fn set_pop(s):
    """Remove and return an arbitrary element from the set.
    Returns tuple (element, new_set) or (nil, s) if empty.

    Example:
        var s = set_from_array([1, 2, 3])
        val result = set_pop(s)
        val elem = result[0]
        s = result[1]
    """
    val keys = s.keys()
    if keys.len() == 0:
        return (nil, s)

    val first_key = keys[0]
    val elem = s[first_key]
    val new_set = set_remove(s, elem)
    (elem, new_set)

fn set_sample(s):
    """Get an arbitrary element from the set without removing it.
    Returns nil if empty.

    Example:
        val s = set_from_array([1, 2, 3])
        val elem = set_sample(s)  # Could be 1, 2, or 3
    """
    val keys = s.keys()
    if keys.len() == 0:
        return nil
    s[keys[0]]

fn set_split_at(s, n: i64):
    """Split set into two sets at position n.
    Returns tuple (first_n_elements_set, rest_set).

    Note: Order is not guaranteed.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val parts = set_split_at(s, 3)
        # parts[0] has 3 elements, parts[1] has 2
    """
    val keys = s.keys()
    if n >= keys.len():
        return (s, set_new())
    if n <= 0:
        return (set_new(), s)

    var first_part = {}
    var second_part = {}
    var i = 0
    for k in keys:
        if i < n:
            first_part[k] = s[k]
        else:
            second_part[k] = s[k]
        i = i + 1
    (first_part, second_part)

# ============================================================================
# Examples and Usage
# ============================================================================

fn _example_basic_usage():
    """Example: Basic set operations"""
    # Create a set
    var s = set_new()
    s = set_add(s, 1)
    s = set_add(s, 2)
    s = set_add(s, 3)
    s = set_add(s, 2)  # Duplicate ignored

    print("Size: {set_size(s)}")  # 3
    print("Contains 2: {set_contains(s, 2)}")  # true
    print("Contains 5: {set_contains(s, 5)}")  # false

    # Remove element
    s = set_remove(s, 2)
    print("After removing 2: {set_to_string(s)}")

fn _example_set_algebra():
    """Example: Set algebra operations"""
    val a = set_from_array([1, 2, 3, 4])
    val b = set_from_array([3, 4, 5, 6])

    print("Union: {set_to_string(set_union(a, b))}")
    print("Intersection: {set_to_string(set_intersection(a, b))}")
    print("Difference A-B: {set_to_string(set_difference(a, b))}")
    print("Symmetric diff: {set_to_string(set_symmetric_difference(a, b))}")

fn _example_transformations():
    """Example: Set transformations"""
    val s = set_from_array([1, 2, 3, 4, 5])

    # Map: square all numbers
    val squared = set_map(s, \x: x * x)
    print("Squared: {set_to_string(squared)}")

    # Filter: keep only even numbers
    val evens = set_filter(s, \x: x % 2 == 0)
    print("Evens: {set_to_string(evens)}")

    # Partition: separate even and odd
    val parts = set_partition(s, \x: x % 2 == 0)
    print("Even partition: {set_to_string(parts[0])}")
    print("Odd partition: {set_to_string(parts[1])}")

fn _example_advanced():
    """Example: Advanced operations"""
    val s = set_from_array([1, 2, 3])

    # Powerset
    val ps = set_powerset(s)
    print("Powerset size: {ps.len()}")  # 2^3 = 8

    # Cartesian product
    val colors = set_from_array(["red", "blue"])
    val sizes = set_from_array(["S", "M"])
    val combos = set_cartesian_product(colors, sizes)
    print("Combinations: {set_size(combos)}")  # 4

    # Set comprehension
    val numbers = set_from_array([1, 2, 3, 4, 5, 6])
    val result = set_comprehension(numbers, \x: x % 2 == 0, \x: x * x)
    print("Squares of evens: {set_to_string(result)}")  # {4, 16, 36}
