# Comprehensive Markdown to HTML Parser Module
# Pure Simple implementation - NO generics, NO try/catch, NO chained methods
# Tuple-based AST, supports CommonMark + GFM features

# =============================================================================
# Character and String Utilities (15 functions)
# =============================================================================

fn is_whitespace(c: text) -> bool:
    c == " " or c == "\t" or c == "\n" or c == "\r"

fn is_digit(c: text) -> bool:
    val code = c.code_at(0)
    code >= 48 and code <= 57

fn is_letter(c: text) -> bool:
    val code = c.code_at(0)
    val is_upper = code >= 65 and code <= 90
    val is_lower = code >= 97 and code <= 122
    is_upper or is_lower

fn is_alphanumeric(c: text) -> bool:
    is_letter(c) or is_digit(c)

fn char_to_lower(c: text) -> text:
    val code = c.code_at(0)
    if code >= 65 and code <= 90:
        return text.from_code(code + 32)
    c

fn to_lowercase(s: text) -> text:
    var result = ""
    var i = 0
    var len = s.length()
    while i < len:
        val c = s.char_at(i)
        val lower = char_to_lower(c)
        result = result + lower
        i = i + 1
    result

fn trim_start(s: text) -> text:
    var i = 0
    var len = s.length()
    while i < len:
        val c = s.char_at(i)
        if not is_whitespace(c):
            break
        i = i + 1
    s.substring(i, len)

fn trim_end(s: text) -> text:
    var i = s.length() - 1
    while i >= 0:
        val c = s.char_at(i)
        if not is_whitespace(c):
            break
        i = i - 1
    s.substring(0, i + 1)

fn trim(s: text) -> text:
    val temp = trim_start(s)
    trim_end(temp)

fn repeat_char(c: text, count: i64) -> text:
    var result = ""
    var i = 0
    while i < count:
        result = result + c
        i = i + 1
    result

fn starts_with(s: text, prefix: text) -> bool:
    val len = prefix.length()
    if s.length() < len:
        return false
    val sub = s.substring(0, len)
    sub == prefix

fn ends_with(s: text, suffix: text) -> bool:
    val slen = s.length()
    val suflen = suffix.length()
    if slen < suflen:
        return false
    val sub = s.substring(slen - suflen, slen)
    sub == suffix

fn count_leading_chars(s: text, c: text) -> i64:
    var count = 0
    var i = 0
    var len = s.length()
    while i < len:
        val ch = s.char_at(i)
        if ch != c:
            break
        count = count + 1
        i = i + 1
    count

fn count_trailing_chars(s: text, c: text) -> i64:
    var count = 0
    var i = s.length() - 1
    while i >= 0:
        val ch = s.char_at(i)
        if ch != c:
            break
        count = count + 1
        i = i - 1
    count

fn find_char(s: text, c: text, start: i64) -> i64:
    var i = start
    var len = s.length()
    while i < len:
        val ch = s.char_at(i)
        if ch == c:
            return i
        i = i + 1
    -1

# =============================================================================
# HTML Escaping and Utilities (5 functions)
# =============================================================================

fn escape_html_char(c: text) -> text:
    if c == "&":
        return "&amp;"
    if c == "<":
        return "&lt;"
    if c == ">":
        return "&gt;"
    if c == "\"":
        return "&quot;"
    if c == "'":
        return "&#39;"
    c

fn escape_html(s: text) -> text:
    var result = ""
    var i = 0
    var len = s.length()
    while i < len:
        val c = s.char_at(i)
        val escaped = escape_html_char(c)
        result = result + escaped
        i = i + 1
    result

fn escape_attr(s: text) -> text:
    escape_html(s)

fn unescape_text(s: text) -> text:
    var result = ""
    var i = 0
    var len = s.length()
    while i < len:
        val c = s.char_at(i)
        if c == "\\":
            if i + 1 < len:
                val next = s.char_at(i + 1)
                val escapable = next == "*" or next == "_" or next == "`"
                val more = next == "[" or next == "]" or next == "\\" or next == "!"
                if escapable or more:
                    result = result + next
                    i = i + 2
                else:
                    result = result + c
                    i = i + 1
            else:
                result = result + c
                i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn is_escaped(s: text, pos: i64) -> bool:
    if pos == 0:
        return false
    val prev = s.char_at(pos - 1)
    prev == "\\"

# =============================================================================
# Slugification for Heading Anchors (1 function)
# =============================================================================

fn slugify(s: text) -> text:
    var result = ""
    var i = 0
    var len = s.length()
    var last_was_dash = false
    while i < len:
        val c = s.char_at(i)
        if is_alphanumeric(c):
            val lower = char_to_lower(c)
            result = result + lower
            last_was_dash = false
        else:
            if not last_was_dash and result.length() > 0:
                result = result + "-"
                last_was_dash = true
        i = i + 1
    if ends_with(result, "-"):
        return result.substring(0, result.length() - 1)
    result

# =============================================================================
# Line Processing (5 functions)
# =============================================================================

fn split_lines(s: text) -> array:
    var lines = []
    var current = ""
    var i = 0
    var len = s.length()
    while i < len:
        val c = s.char_at(i)
        if c == "\n":
            lines = lines.push(current)
            current = ""
        else:
            if c != "\r":
                current = current + c
        i = i + 1
    if current.length() > 0 or len > 0:
        lines = lines.push(current)
    lines

fn join_lines(lines: array, sep: text) -> text:
    var result = ""
    var i = 0
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        result = result + line
        if i < len - 1:
            result = result + sep
        i = i + 1
    result

fn is_blank_line(line: text) -> bool:
    val trimmed = trim(line)
    trimmed.length() == 0

fn count_leading_spaces(line: text) -> i64:
    count_leading_chars(line, " ")

fn count_line_indent(line: text) -> i64:
    var spaces = 0
    var i = 0
    var len = line.length()
    while i < len and line.char_at(i) == " ":
        spaces = spaces + 1
        i = i + 1
    spaces

# =============================================================================
# Block-level Pattern Detection (15 functions)
# =============================================================================

fn is_heading_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() == 0:
        return false
    val first = trimmed.char_at(0)
    if first != "#":
        return false
    val hashes = count_leading_chars(trimmed, "#")
    if hashes < 1 or hashes > 6:
        return false
    if trimmed.length() == hashes:
        return true
    val after = trimmed.char_at(hashes)
    is_whitespace(after)

fn parse_heading_level(line: text) -> i64:
    val trimmed = trim_start(line)
    count_leading_chars(trimmed, "#")

fn parse_heading_content(line: text) -> text:
    val trimmed = trim_start(line)
    val hashes = count_leading_chars(trimmed, "#")
    var content = trimmed.substring(hashes, trimmed.length())
    content = trim(content)
    val trailing = count_trailing_chars(content, "#")
    if trailing > 0:
        content = content.substring(0, content.length() - trailing)
        content = trim_end(content)
    content

fn is_horizontal_rule(line: text) -> bool:
    val trimmed = trim(line)
    if trimmed.length() < 3:
        return false
    val first = trimmed.char_at(0)
    if first != "-" and first != "*" and first != "_":
        return false
    var count = 0
    var i = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if c == first:
            count = count + 1
        else:
            if c != " " and c != "\t":
                return false
        i = i + 1
    count >= 3

fn is_code_fence(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() < 3:
        return false
    val backticks = count_leading_chars(trimmed, "`")
    if backticks >= 3:
        return true
    val tildes = count_leading_chars(trimmed, "~")
    tildes >= 3

fn get_code_fence_char(line: text) -> text:
    val trimmed = trim_start(line)
    if trimmed.length() == 0:
        return ""
    val first = trimmed.char_at(0)
    if first == "`" or first == "~":
        return first
    ""

fn parse_code_fence_lang(line: text) -> text:
    val trimmed = trim_start(line)
    val backticks = count_leading_chars(trimmed, "`")
    val tildes = count_leading_chars(trimmed, "~")
    var fence_len = 0
    if backticks >= 3:
        fence_len = backticks
    else:
        fence_len = tildes
    var lang = trimmed.substring(fence_len, trimmed.length())
    lang = trim(lang)
    lang

fn is_blockquote_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() == 0:
        return false
    val first = trimmed.char_at(0)
    first == ">"

fn parse_blockquote_content(line: text) -> text:
    val trimmed = trim_start(line)
    var content = trimmed.substring(1, trimmed.length())
    if content.length() > 0:
        val first = content.char_at(0)
        if is_whitespace(first):
            content = content.substring(1, content.length())
    content

fn is_unordered_list_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() < 2:
        return false
    val first = trimmed.char_at(0)
    val marker = first == "-" or first == "*" or first == "+"
    if not marker:
        return false
    val second = trimmed.char_at(1)
    is_whitespace(second)

fn parse_unordered_list_content(line: text) -> text:
    val trimmed = trim_start(line)
    var content = trimmed.substring(1, trimmed.length())
    content = trim_start(content)
    content

fn is_ordered_list_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() < 3:
        return false
    var i = 0
    var digits = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if is_digit(c):
            digits = digits + 1
        else:
            break
        i = i + 1
    if digits == 0:
        return false
    if i >= len:
        return false
    val dot = trimmed.char_at(i)
    if dot != ".":
        return false
    if i + 1 >= len:
        return false
    val after = trimmed.char_at(i + 1)
    is_whitespace(after)

fn parse_ordered_list_number(line: text) -> i64:
    val trimmed = trim_start(line)
    var num_str = ""
    var i = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if is_digit(c):
            num_str = num_str + c
        else:
            break
        i = i + 1
    num_str.to_int()

fn parse_ordered_list_content(line: text) -> text:
    val trimmed = trim_start(line)
    var i = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if is_digit(c):
            i = i + 1
        else:
            break
    i = i + 1
    var content = trimmed.substring(i, len)
    content = trim_start(content)
    content

fn is_list_item_line(line: text) -> bool:
    is_unordered_list_line(line) or is_ordered_list_line(line)

# =============================================================================
# Table Detection and Parsing (4 functions)
# =============================================================================

fn is_table_separator_line(line: text) -> bool:
    val trimmed = trim(line)
    if trimmed.length() < 3:
        return false
    if not starts_with(trimmed, "|"):
        return false
    var i = 1
    var len = trimmed.length()
    var has_dash = false
    while i < len:
        val c = trimmed.char_at(i)
        if c == "-":
            has_dash = true
        else:
            if c != "|" and c != ":" and c != " ":
                return false
        i = i + 1
    has_dash

fn parse_table_row(line: text) -> array:
    var cells = []
    var current = ""
    var i = 0
    var len = line.length()
    var in_cell = false
    while i < len:
        val c = line.char_at(i)
        if c == "|":
            if in_cell:
                val trimmed = trim(current)
                cells = cells.push(trimmed)
                current = ""
            in_cell = true
        else:
            current = current + c
        i = i + 1
    if current.length() > 0:
        val trimmed = trim(current)
        cells = cells.push(trimmed)
    cells

fn parse_table_alignments(line: text) -> array:
    val cells = parse_table_row(line)
    var alignments = []
    var i = 0
    var len = cells.length()
    while i < len:
        val cell = cells.get(i)
        val left = starts_with(cell, ":")
        val right = ends_with(cell, ":")
        var align = "left"
        if left and right:
            align = "center"
        else:
            if right:
                align = "right"
        alignments = alignments.push(align)
        i = i + 1
    alignments

fn is_table_row_line(line: text) -> bool:
    val trimmed = trim(line)
    if trimmed.length() == 0:
        return false
    starts_with(trimmed, "|")

# =============================================================================
# Inline Parsing Helpers (5 functions)
# =============================================================================

fn find_matching_delim(s: text, delim: text, start: i64) -> i64:
    var i = start
    var len = s.length()
    var delim_len = delim.length()
    while i < len - delim_len + 1:
        var match = true
        var j = 0
        while j < delim_len:
            val ch = s.char_at(i + j)
            val delim_ch = delim.char_at(j)
            if ch != delim_ch:
                match = false
                break
            j = j + 1
        if match:
            if i > 0:
                val prev = s.char_at(i - 1)
                if prev != "\\":
                    return i
            else:
                return i
        i = i + 1
    -1

fn find_unescaped_char(s: text, c: text, start: i64) -> i64:
    var i = start
    var len = s.length()
    while i < len:
        val ch = s.char_at(i)
        if ch == c:
            if not is_escaped(s, i):
                return i
        i = i + 1
    -1

fn count_emphasis_markers(s: text, start: i64) -> i64:
    var count = 0
    var i = start
    var len = s.length()
    if i >= len:
        return 0
    val marker = s.char_at(i)
    while i < len and s.char_at(i) == marker:
        count = count + 1
        i = i + 1
    count

fn extract_url_from_link(s: text) -> tuple:
    var url = ""
    var title = ""
    val space_pos = find_char(s, " ", 0)
    if space_pos == -1:
        url = s
    else:
        url = s.substring(0, space_pos)
        var title_part = s.substring(space_pos + 1, s.length())
        title_part = trim(title_part)
        if starts_with(title_part, "\"") and ends_with(title_part, "\""):
            title = title_part.substring(1, title_part.length() - 1)
    (url, title)

fn is_valid_url_char(c: text) -> bool:
    if is_alphanumeric(c):
        return true
    val special = c == ":" or c == "/" or c == "." or c == "-" or c == "_"
    val more = c == "?" or c == "=" or c == "&" or c == "#" or c == "%"
    special or more

# =============================================================================
# Inline Token Parsing (8 functions)
# =============================================================================

fn parse_bold(s: text, start: i64) -> tuple:
    val close = find_matching_delim(s, "**", start + 2)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 2, close)
    val tokens = parse_inline_tokens(content)
    val token = ("bold", tokens)
    (token, close + 2)

fn parse_italic(s: text, start: i64) -> tuple:
    val close = find_matching_delim(s, "*", start + 1)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 1, close)
    val tokens = parse_inline_tokens(content)
    val token = ("italic", tokens)
    (token, close + 1)

fn parse_code(s: text, start: i64) -> tuple:
    val close = find_char(s, "`", start + 1)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 1, close)
    val token = ("code", content)
    (token, close + 1)

fn parse_link(s: text, start: i64, is_image: bool) -> tuple:
    var pos = start + 1
    val close_bracket = find_char(s, "]", pos)
    if close_bracket == -1:
        return (nil, start + 1)
    val text_content = s.substring(pos, close_bracket)
    pos = close_bracket + 1
    if pos >= s.length():
        return (nil, start + 1)
    val paren = s.char_at(pos)
    if paren != "(":
        return (nil, start + 1)
    pos = pos + 1
    val close_paren = find_char(s, ")", pos)
    if close_paren == -1:
        return (nil, start + 1)
    val url_part = s.substring(pos, close_paren)
    val url_data = extract_url_from_link(url_part)
    val url = url_data.0
    val title = url_data.1
    if is_image:
        val token = ("image", text_content, url, title)
        return (token, close_paren + 1)
    val text_tokens = parse_inline_tokens(text_content)
    val token = ("link", text_tokens, url, title)
    (token, close_paren + 1)

fn parse_image(s: text, start: i64) -> tuple:
    parse_link(s, start + 1, true)

fn parse_autolink(s: text, start: i64) -> tuple:
    val close = find_char(s, ">", start + 1)
    if close == -1:
        return (nil, start + 1)
    val url = s.substring(start + 1, close)
    val token = ("autolink", url)
    (token, close + 1)

fn parse_strikethrough(s: text, start: i64) -> tuple:
    val close = find_matching_delim(s, "~~", start + 2)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 2, close)
    val tokens = parse_inline_tokens(content)
    val token = ("strikethrough", tokens)
    (token, close + 2)

fn parse_line_break(s: text, start: i64) -> tuple:
    val token = ("line_break")
    (token, start + 4)

# =============================================================================
# Main Inline Tokenizer (1 function)
# =============================================================================

fn parse_inline_tokens(s: text) -> array:
    var tokens = []
    var i = 0
    var len = s.length()
    var current_text = ""
    while i < len:
        val c = s.char_at(i)
        if c == "\\":
            if i + 1 < len:
                val next = s.char_at(i + 1)
                current_text = current_text + next
                i = i + 2
            else:
                current_text = current_text + c
                i = i + 1
        else:
            if c == "*":
                if i + 1 < len and s.char_at(i + 1) == "*":
                    if current_text.length() > 0:
                        val text_token = ("text", current_text)
                        tokens = tokens.push(text_token)
                        current_text = ""
                    val result = parse_bold(s, i)
                    val token = result.0
                    val next_i = result.1
                    if token != nil:
                        tokens = tokens.push(token)
                        i = next_i
                    else:
                        current_text = current_text + c
                        i = i + 1
                else:
                    if current_text.length() > 0:
                        val text_token = ("text", current_text)
                        tokens = tokens.push(text_token)
                        current_text = ""
                    val result = parse_italic(s, i)
                    val token = result.0
                    val next_i = result.1
                    if token != nil:
                        tokens = tokens.push(token)
                        i = next_i
                    else:
                        current_text = current_text + c
                        i = i + 1
            else:
                if c == "`":
                    if current_text.length() > 0:
                        val text_token = ("text", current_text)
                        tokens = tokens.push(text_token)
                        current_text = ""
                    val result = parse_code(s, i)
                    val token = result.0
                    val next_i = result.1
                    if token != nil:
                        tokens = tokens.push(token)
                        i = next_i
                    else:
                        current_text = current_text + c
                        i = i + 1
                else:
                    if c == "[":
                        if current_text.length() > 0:
                            val text_token = ("text", current_text)
                            tokens = tokens.push(text_token)
                            current_text = ""
                        val result = parse_link(s, i, false)
                        val token = result.0
                        val next_i = result.1
                        if token != nil:
                            tokens = tokens.push(token)
                            i = next_i
                        else:
                            current_text = current_text + c
                            i = i + 1
                    else:
                        if c == "!":
                            if i + 1 < len and s.char_at(i + 1) == "[":
                                if current_text.length() > 0:
                                    val text_token = ("text", current_text)
                                    tokens = tokens.push(text_token)
                                    current_text = ""
                                val result = parse_image(s, i)
                                val token = result.0
                                val next_i = result.1
                                if token != nil:
                                    tokens = tokens.push(token)
                                    i = next_i
                                else:
                                    current_text = current_text + c
                                    i = i + 1
                            else:
                                current_text = current_text + c
                                i = i + 1
                        else:
                            if c == "<":
                                if i + 1 < len:
                                    val peek = s.substring(i + 1, len)
                                    val is_link = starts_with(peek, "http://") or starts_with(peek, "https://")
                                    val has_at = find_char(peek, "@", 0) != -1
                                    if is_link or has_at:
                                        if current_text.length() > 0:
                                            val text_token = ("text", current_text)
                                            tokens = tokens.push(text_token)
                                            current_text = ""
                                        val result = parse_autolink(s, i)
                                        val token = result.0
                                        val next_i = result.1
                                        if token != nil:
                                            tokens = tokens.push(token)
                                            i = next_i
                                        else:
                                            current_text = current_text + c
                                            i = i + 1
                                    else:
                                        current_text = current_text + c
                                        i = i + 1
                                else:
                                    current_text = current_text + c
                                    i = i + 1
                            else:
                                if c == "~":
                                    if i + 1 < len and s.char_at(i + 1) == "~":
                                        if current_text.length() > 0:
                                            val text_token = ("text", current_text)
                                            tokens = tokens.push(text_token)
                                            current_text = ""
                                        val result = parse_strikethrough(s, i)
                                        val token = result.0
                                        val next_i = result.1
                                        if token != nil:
                                            tokens = tokens.push(token)
                                            i = next_i
                                        else:
                                            current_text = current_text + c
                                            i = i + 1
                                    else:
                                        current_text = current_text + c
                                        i = i + 1
                                else:
                                    current_text = current_text + c
                                    i = i + 1
    if current_text.length() > 0:
        val text_token = ("text", current_text)
        tokens = tokens.push(text_token)
    tokens

# =============================================================================
# Block Parsing (8 functions)
# =============================================================================

fn parse_heading_block(line: text) -> tuple:
    val level = parse_heading_level(line)
    val content = parse_heading_content(line)
    val tokens = parse_inline_tokens(content)
    ("heading", level, tokens)

fn parse_code_block(lines: array, start: i64) -> tuple:
    val first_line = lines.get(start)
    val fence_char = get_code_fence_char(first_line)
    val trimmed = trim_start(first_line)
    val fence_count = count_leading_chars(trimmed, fence_char)
    val lang = parse_code_fence_lang(first_line)
    var code_lines = []
    var i = start + 1
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if is_code_fence(line):
            val line_trimmed = trim_start(line)
            val line_char = get_code_fence_char(line)
            if line_char == fence_char:
                val close_count = count_leading_chars(line_trimmed, line_char)
                if close_count >= fence_count:
                    i = i + 1
                    break
        code_lines = code_lines.push(line)
        i = i + 1
    val code = join_lines(code_lines, "\n")
    val block = ("code_block", lang, code)
    (block, i - start)

fn parse_blockquote_block(lines: array, start: i64) -> tuple:
    var content_lines = []
    var i = start
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if not is_blockquote_line(line):
            break
        val content = parse_blockquote_content(line)
        content_lines = content_lines.push(content)
        i = i + 1
    val child_blocks = parse_blocks(content_lines)
    val block = ("blockquote", child_blocks)
    (block, i - start)

fn parse_unordered_list_block(lines: array, start: i64) -> tuple:
    var items = []
    var i = start
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if not is_unordered_list_line(line):
            break
        val content = parse_unordered_list_content(line)
        val tokens = parse_inline_tokens(content)
        items = items.push(tokens)
        i = i + 1
    val block = ("unordered_list", items)
    (block, i - start)

fn parse_ordered_list_block(lines: array, start: i64) -> tuple:
    var items = []
    var i = start
    var len = lines.length()
    val first_line = lines.get(start)
    val start_num = parse_ordered_list_number(first_line)
    while i < len:
        val line = lines.get(i)
        if not is_ordered_list_line(line):
            break
        val content = parse_ordered_list_content(line)
        val tokens = parse_inline_tokens(content)
        items = items.push(tokens)
        i = i + 1
    val block = ("ordered_list", start_num, items)
    (block, i - start)

fn parse_table_block(lines: array, start: i64) -> tuple:
    val header_line = lines.get(start)
    val sep_line = lines.get(start + 1)
    val headers = parse_table_row(header_line)
    val alignments = parse_table_alignments(sep_line)
    var rows = []
    var i = start + 2
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        val trimmed = trim(line)
        if not starts_with(trimmed, "|"):
            break
        val row = parse_table_row(line)
        rows = rows.push(row)
        i = i + 1
    val block = ("table", headers, alignments, rows)
    (block, i - start)

fn parse_paragraph_block(lines: array, start: i64) -> tuple:
    var content_lines = []
    var i = start
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if is_blank_line(line):
            break
        if is_heading_line(line):
            break
        if is_horizontal_rule(line):
            break
        if is_code_fence(line):
            break
        if is_blockquote_line(line):
            break
        if is_unordered_list_line(line):
            break
        if is_ordered_list_line(line):
            break
        content_lines = content_lines.push(line)
        i = i + 1
    val content = join_lines(content_lines, " ")
    val tokens = parse_inline_tokens(content)
    val block = ("paragraph", tokens)
    (block, i - start)

fn parse_blocks(lines: array) -> array:
    var blocks = []
    var i = 0
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if is_blank_line(line):
            i = i + 1
        else:
            if is_heading_line(line):
                val block = parse_heading_block(line)
                blocks = blocks.push(block)
                i = i + 1
            else:
                if is_horizontal_rule(line):
                    val block = ("horizontal_rule")
                    blocks = blocks.push(block)
                    i = i + 1
                else:
                    if is_code_fence(line):
                        val result = parse_code_block(lines, i)
                        val block = result.0
                        val consumed = result.1
                        blocks = blocks.push(block)
                        i = i + consumed
                    else:
                        if is_blockquote_line(line):
                            val result = parse_blockquote_block(lines, i)
                            val block = result.0
                            val consumed = result.1
                            blocks = blocks.push(block)
                            i = i + consumed
                        else:
                            if is_unordered_list_line(line):
                                val result = parse_unordered_list_block(lines, i)
                                val block = result.0
                                val consumed = result.1
                                blocks = blocks.push(block)
                                i = i + consumed
                            else:
                                if is_ordered_list_line(line):
                                    val result = parse_ordered_list_block(lines, i)
                                    val block = result.0
                                    val consumed = result.1
                                    blocks = blocks.push(block)
                                    i = i + consumed
                                else:
                                    if i + 1 < len:
                                        val next_line = lines.get(i + 1)
                                        if is_table_separator_line(next_line):
                                            val result = parse_table_block(lines, i)
                                            val block = result.0
                                            val consumed = result.1
                                            blocks = blocks.push(block)
                                            i = i + consumed
                                        else:
                                            val result = parse_paragraph_block(lines, i)
                                            val block = result.0
                                            val consumed = result.1
                                            blocks = blocks.push(block)
                                            i = i + consumed
                                    else:
                                        val result = parse_paragraph_block(lines, i)
                                        val block = result.0
                                        val consumed = result.1
                                        blocks = blocks.push(block)
                                        i = i + consumed
    blocks

# =============================================================================
# HTML Rendering (12 functions)
# =============================================================================

fn render_inline_token(token: tuple) -> text:
    val type = token.0
    if type == "text":
        val content = token.1
        return escape_html(content)
    if type == "bold":
        val tokens = token.1
        val inner = render_inline_tokens(tokens)
        return "<strong>" + inner + "</strong>"
    if type == "italic":
        val tokens = token.1
        val inner = render_inline_tokens(tokens)
        return "<em>" + inner + "</em>"
    if type == "code":
        val content = token.1
        val escaped = escape_html(content)
        return "<code>" + escaped + "</code>"
    if type == "link":
        val text_tokens = token.1
        val url = token.2
        val title = token.3
        val text_html = render_inline_tokens(text_tokens)
        val url_escaped = escape_attr(url)
        var html = "<a href=\"" + url_escaped + "\""
        if title.length() > 0:
            val title_escaped = escape_attr(title)
            html = html + " title=\"" + title_escaped + "\""
        html = html + ">" + text_html + "</a>"
        return html
    if type == "image":
        val alt = token.1
        val url = token.2
        val title = token.3
        val alt_escaped = escape_attr(alt)
        val url_escaped = escape_attr(url)
        var html = "<img src=\"" + url_escaped + "\" alt=\"" + alt_escaped + "\""
        if title.length() > 0:
            val title_escaped = escape_attr(title)
            html = html + " title=\"" + title_escaped + "\""
        html = html + " />"
        return html
    if type == "autolink":
        val url = token.1
        val url_escaped = escape_attr(url)
        val url_text = escape_html(url)
        return "<a href=\"" + url_escaped + "\">" + url_text + "</a>"
    if type == "strikethrough":
        val tokens = token.1
        val inner = render_inline_tokens(tokens)
        return "<del>" + inner + "</del>"
    if type == "line_break":
        return "<br />"
    ""

fn render_inline_tokens(tokens: array) -> text:
    var html = ""
    var i = 0
    var len = tokens.length()
    while i < len:
        val token = tokens.get(i)
        val token_html = render_inline_token(token)
        html = html + token_html
        i = i + 1
    html

fn extract_text_from_tokens(tokens: array) -> text:
    var text = ""
    var i = 0
    var len = tokens.length()
    while i < len:
        val token = tokens.get(i)
        val type = token.0
        if type == "text":
            val content = token.1
            text = text + content
        else:
            if type == "bold" or type == "italic" or type == "link" or type == "strikethrough":
                val inner_tokens = token.1
                val inner_text = extract_text_from_tokens(inner_tokens)
                text = text + inner_text
            else:
                if type == "code":
                    val content = token.1
                    text = text + content
                else:
                    if type == "image":
                        val alt = token.1
                        text = text + alt
        i = i + 1
    text

fn render_heading_block(block: tuple) -> text:
    val level = block.1
    val tokens = block.2
    val content = render_inline_tokens(tokens)
    val text = extract_text_from_tokens(tokens)
    val id = slugify(text)
    val tag = "h" + level.to_text()
    var html = "<" + tag
    if id.length() > 0:
        html = html + " id=\"" + id + "\""
    html = html + ">" + content + "</" + tag + ">"
    html

fn render_paragraph_block(block: tuple) -> text:
    val tokens = block.1
    val content = render_inline_tokens(tokens)
    "<p>" + content + "</p>"

fn render_code_block(block: tuple) -> text:
    val lang = block.1
    val code = block.2
    val escaped = escape_html(code)
    var html = "<pre><code"
    if lang.length() > 0:
        val lang_escaped = escape_attr(lang)
        html = html + " class=\"language-" + lang_escaped + "\""
    html = html + ">" + escaped + "</code></pre>"
    html

fn render_blockquote_block(block: tuple) -> text:
    val child_blocks = block.1
    val inner = render_blocks(child_blocks)
    "<blockquote>" + inner + "</blockquote>"

fn render_unordered_list_block(block: tuple) -> text:
    val items = block.1
    var html = "<ul>"
    var i = 0
    var len = items.length()
    while i < len:
        val item_tokens = items.get(i)
        val item_html = render_inline_tokens(item_tokens)
        html = html + "<li>" + item_html + "</li>"
        i = i + 1
    html = html + "</ul>"
    html

fn render_ordered_list_block(block: tuple) -> text:
    val start_num = block.1
    val items = block.2
    var html = "<ol"
    if start_num != 1:
        html = html + " start=\"" + start_num.to_text() + "\""
    html = html + ">"
    var i = 0
    var len = items.length()
    while i < len:
        val item_tokens = items.get(i)
        val item_html = render_inline_tokens(item_tokens)
        html = html + "<li>" + item_html + "</li>"
        i = i + 1
    html = html + "</ol>"
    html

fn render_table_block(block: tuple) -> text:
    val headers = block.1
    val alignments = block.2
    val rows = block.3
    var html = "<table><thead><tr>"
    var i = 0
    var header_len = headers.length()
    while i < header_len:
        val header = headers.get(i)
        var align = "left"
        if i < alignments.length():
            align = alignments.get(i)
        var th = "<th"
        if align != "left":
            th = th + " style=\"text-align: " + align + "\""
        th = th + ">" + escape_html(header) + "</th>"
        html = html + th
        i = i + 1
    html = html + "</tr></thead><tbody>"
    var row_i = 0
    var row_len = rows.length()
    while row_i < row_len:
        val row = rows.get(row_i)
        html = html + "<tr>"
        var cell_i = 0
        var cell_len = row.length()
        while cell_i < cell_len:
            val cell = row.get(cell_i)
            var align = "left"
            if cell_i < alignments.length():
                align = alignments.get(cell_i)
            var td = "<td"
            if align != "left":
                td = td + " style=\"text-align: " + align + "\""
            td = td + ">" + escape_html(cell) + "</td>"
            html = html + td
            cell_i = cell_i + 1
        html = html + "</tr>"
        row_i = row_i + 1
    html = html + "</tbody></table>"
    html

fn render_block(block: tuple) -> text:
    val type = block.0
    if type == "heading":
        return render_heading_block(block)
    if type == "paragraph":
        return render_paragraph_block(block)
    if type == "code_block":
        return render_code_block(block)
    if type == "blockquote":
        return render_blockquote_block(block)
    if type == "unordered_list":
        return render_unordered_list_block(block)
    if type == "ordered_list":
        return render_ordered_list_block(block)
    if type == "horizontal_rule":
        return "<hr />"
    if type == "table":
        return render_table_block(block)
    ""

fn render_blocks(blocks: array) -> text:
    var html = ""
    var i = 0
    var len = blocks.length()
    while i < len:
        val block = blocks.get(i)
        val block_html = render_block(block)
        html = html + block_html + "\n"
        i = i + 1
    html

# =============================================================================
# Public API (6 functions)
# =============================================================================

fn markdown_to_html(markdown: text) -> text:
    val lines = split_lines(markdown)
    val blocks = parse_blocks(lines)
    render_blocks(blocks)

fn markdown_to_ast(markdown: text) -> array:
    val lines = split_lines(markdown)
    parse_blocks(lines)

fn extract_headings(blocks: array) -> array:
    var headings = []
    var i = 0
    var len = blocks.length()
    while i < len:
        val block = blocks.get(i)
        val type = block.0
        if type == "heading":
            val level = block.1
            val tokens = block.2
            val text = extract_text_from_tokens(tokens)
            headings = headings.push((level, text))
        i = i + 1
    headings

fn extract_links(blocks: array) -> array:
    var links = []
    var i = 0
    var len = blocks.length()
    while i < len:
        val block = blocks.get(i)
        val block_links = extract_links_from_block(block)
        var j = 0
        var link_len = block_links.length()
        while j < link_len:
            links = links.push(block_links.get(j))
            j = j + 1
        i = i + 1
    links

fn extract_links_from_block(block: tuple) -> array:
    var links = []
    val type = block.0
    if type == "heading":
        val tokens = block.2
        return extract_links_from_tokens(tokens)
    if type == "paragraph":
        val tokens = block.1
        return extract_links_from_tokens(tokens)
    if type == "blockquote":
        val child_blocks = block.1
        return extract_links(child_blocks)
    if type == "unordered_list":
        val items = block.1
        var i = 0
        var len = items.length()
        while i < len:
            val item_tokens = items.get(i)
            val item_links = extract_links_from_tokens(item_tokens)
            var j = 0
            var link_len = item_links.length()
            while j < link_len:
                links = links.push(item_links.get(j))
                j = j + 1
            i = i + 1
    if type == "ordered_list":
        val items = block.2
        var i = 0
        var len = items.length()
        while i < len:
            val item_tokens = items.get(i)
            val item_links = extract_links_from_tokens(item_tokens)
            var j = 0
            var link_len = item_links.length()
            while j < link_len:
                links = links.push(item_links.get(j))
                j = j + 1
            i = i + 1
    links

fn extract_links_from_tokens(tokens: array) -> array:
    var links = []
    var i = 0
    var len = tokens.length()
    while i < len:
        val token = tokens.get(i)
        val type = token.0
        if type == "link":
            val text_tokens = token.1
            val url = token.2
            val text = extract_text_from_tokens(text_tokens)
            links = links.push((text, url))
        else:
            if type == "bold" or type == "italic" or type == "strikethrough":
                val inner_tokens = token.1
                val inner_links = extract_links_from_tokens(inner_tokens)
                var j = 0
                var link_len = inner_links.length()
                while j < link_len:
                    links = links.push(inner_links.get(j))
                    j = j + 1
        i = i + 1
    links
