# Sorting Algorithms and Utilities Module
# Comprehensive collection of sorting algorithms, partition strategies, and utilities
# All implementations use i64 arrays with custom comparator support

# ============================================================================
# COMPARATOR TYPES AND UTILITIES
# ============================================================================

# Comparator function type: takes two values, returns -1/0/1
# Result: -1 if a < b, 0 if a == b, 1 if a > b

fn ascending_comparator(a: i64, b: i64) -> i64:
    if a < b:
        -1
    else if a > b:
        1
    else:
        0

fn descending_comparator(a: i64, b: i64) -> i64:
    if a > b:
        -1
    else if a < b:
        1
    else:
        0

fn abs_comparator(a: i64, b: i64) -> i64:
    val abs_a = if a < 0: -a else: a
    val abs_b = if b < 0: -b else: b
    if abs_a < abs_b:
        -1
    else if abs_a > abs_b:
        1
    else:
        0

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

fn is_sorted(arr: List<i64>) -> bool:
    val len = arr.len()
    if len <= 1:
        return true

    var i = 0
    while i < len - 1:
        val curr = arr.get(i)
        val next = arr.get(i + 1)
        if curr > next:
            return false
        i = i + 1
    true

fn is_sorted_descending(arr: List<i64>) -> bool:
    val len = arr.len()
    if len <= 1:
        return true

    var i = 0
    while i < len - 1:
        val curr = arr.get(i)
        val next = arr.get(i + 1)
        if curr < next:
            return false
        i = i + 1
    true

fn is_sorted_with_comparator(arr: List<i64>, cmp: fn(i64, i64) -> i64) -> bool:
    val len = arr.len()
    if len <= 1:
        return true

    var i = 0
    while i < len - 1:
        val curr = arr.get(i)
        val next = arr.get(i + 1)
        val result = cmp(curr, next)
        if result > 0:
            return false
        i = i + 1
    true

fn reverse_array(arr: List<i64>) -> List<i64>:
    val len = arr.len()
    var result = []
    var i = len - 1
    while i >= 0:
        val elem = arr.get(i)
        result = result.push(elem)
        i = i - 1
    result

fn reverse_in_place(arr: List<i64>, start: i64, end: i64):
    var left = start
    var right = end
    while left < right:
        val temp = arr.get(left)
        arr.set(left, arr.get(right))
        arr.set(right, temp)
        left = left + 1
        right = right - 1

fn shuffle_fisher_yates(arr: List<i64>, seed: i64) -> List<i64>:
    # Fisher-Yates shuffle algorithm
    # Note: Uses simple LCG for random numbers (not cryptographically secure)
    var result = arr.copy()
    val len = result.len()
    var rng_state = seed

    var i = len - 1
    while i > 0:
        # Simple LCG: next = (a * prev + c) mod m
        rng_state = (rng_state * 1103515245 + 12345) % 2147483648
        val j = rng_state % (i + 1)

        val temp = result.get(i)
        result.set(i, result.get(j))
        result.set(j, temp)
        i = i - 1
    result

fn copy_range(arr: List<i64>, start: i64, end: i64) -> List<i64>:
    var result = []
    var i = start
    while i <= end:
        val elem = arr.get(i)
        result = result.push(elem)
        i = i + 1
    result

fn min_in_range(arr: List<i64>, start: i64, end: i64) -> i64:
    var min_val = arr.get(start)
    var i = start + 1
    while i <= end:
        val curr = arr.get(i)
        if curr < min_val:
            min_val = curr
        i = i + 1
    min_val

fn max_in_range(arr: List<i64>, start: i64, end: i64) -> i64:
    var max_val = arr.get(start)
    var i = start + 1
    while i <= end:
        val curr = arr.get(i)
        if curr > max_val:
            max_val = curr
        i = i + 1
    max_val

# ============================================================================
# SIMPLE COMPARISON SORTS
# ============================================================================

fn bubble_sort(arr: List<i64>) -> List<i64>:
    # Stable, O(n²) all cases
    # In-place: Yes, Stable: Yes
    var result = arr.copy()
    val len = result.len()

    var i = 0
    while i < len:
        var j = 0
        while j < len - i - 1:
            val curr = result.get(j)
            val next = result.get(j + 1)
            if curr > next:
                result.set(j, next)
                result.set(j + 1, curr)
            j = j + 1
        i = i + 1
    result

fn bubble_sort_optimized(arr: List<i64>) -> List<i64>:
    # Optimized bubble sort with early exit
    var result = arr.copy()
    val len = result.len()

    var i = 0
    var swapped = true
    while i < len and swapped:
        swapped = false
        var j = 0
        while j < len - i - 1:
            val curr = result.get(j)
            val next = result.get(j + 1)
            if curr > next:
                result.set(j, next)
                result.set(j + 1, curr)
                swapped = true
            j = j + 1
        i = i + 1
    result

fn selection_sort(arr: List<i64>) -> List<i64>:
    # Unstable, O(n²) all cases
    # In-place: Yes, Stable: No
    var result = arr.copy()
    val len = result.len()

    var i = 0
    while i < len - 1:
        var min_idx = i
        var j = i + 1
        while j < len:
            val curr_min = result.get(min_idx)
            val candidate = result.get(j)
            if candidate < curr_min:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = result.get(i)
            result.set(i, result.get(min_idx))
            result.set(min_idx, temp)
        i = i + 1
    result

fn insertion_sort(arr: List<i64>) -> List<i64>:
    # Stable, O(n²) worst, O(n) best
    # In-place: Yes, Stable: Yes
    var result = arr.copy()
    val len = result.len()

    var i = 1
    while i < len:
        val key = result.get(i)
        var j = i - 1

        var done = false
        while j >= 0 and not done:
            val curr = result.get(j)
            if curr > key:
                result.set(j + 1, curr)
                j = j - 1
            else:
                done = true

        result.set(j + 1, key)
        i = i + 1
    result

fn insertion_sort_range(arr: List<i64>, start: i64, end: i64):
    # In-place insertion sort for a range
    var i = start + 1
    while i <= end:
        val key = arr.get(i)
        var j = i - 1

        var done = false
        while j >= start and not done:
            val curr = arr.get(j)
            if curr > key:
                arr.set(j + 1, curr)
                j = j - 1
            else:
                done = true

        arr.set(j + 1, key)
        i = i + 1

# ============================================================================
# PARTITION ALGORITHMS
# ============================================================================

fn lomuto_partition(arr: List<i64>, low: i64, high: i64) -> i64:
    # Lomuto partition scheme
    # Pivot is last element
    val pivot = arr.get(high)
    var i = low - 1

    var j = low
    while j < high:
        val curr = arr.get(j)
        if curr <= pivot:
            i = i + 1
            val temp = arr.get(i)
            arr.set(i, curr)
            arr.set(j, temp)
        j = j + 1

    val temp = arr.get(i + 1)
    arr.set(i + 1, arr.get(high))
    arr.set(high, temp)
    i + 1

fn hoare_partition(arr: List<i64>, low: i64, high: i64) -> i64:
    # Hoare partition scheme (more efficient)
    # Pivot is middle element
    val mid = low + (high - low) / 2
    val pivot = arr.get(mid)
    var i = low - 1
    var j = high + 1

    var done = false
    while not done:
        var i_done = false
        while not i_done:
            i = i + 1
            val curr = arr.get(i)
            if curr >= pivot:
                i_done = true

        var j_done = false
        while not j_done:
            j = j - 1
            val curr = arr.get(j)
            if curr <= pivot:
                j_done = true

        if i >= j:
            done = true
        else:
            val temp = arr.get(i)
            arr.set(i, arr.get(j))
            arr.set(j, temp)
    j

fn three_way_partition(arr: List<i64>, low: i64, high: i64) -> List<i64>:
    # Dutch National Flag partition (3-way)
    # Returns [lt_boundary, gt_boundary]
    val pivot = arr.get(high)
    var lt = low
    var i = low
    var gt = high

    while i <= gt:
        val curr = arr.get(i)
        if curr < pivot:
            val temp = arr.get(lt)
            arr.set(lt, curr)
            arr.set(i, temp)
            lt = lt + 1
            i = i + 1
        else if curr > pivot:
            val temp = arr.get(gt)
            arr.set(gt, curr)
            arr.set(i, temp)
            gt = gt - 1
        else:
            i = i + 1

    [lt, gt]

# ============================================================================
# QUICKSORT FAMILY
# ============================================================================

fn quicksort_lomuto(arr: List<i64>) -> List<i64>:
    # Unstable, O(n log n) average, O(n²) worst
    # In-place: Yes, Stable: No
    var result = arr.copy()
    quicksort_lomuto_helper(result, 0, result.len() - 1)
    result

fn quicksort_lomuto_helper(arr: List<i64>, low: i64, high: i64):
    if low < high:
        val pi = lomuto_partition(arr, low, high)
        quicksort_lomuto_helper(arr, low, pi - 1)
        quicksort_lomuto_helper(arr, pi + 1, high)

fn quicksort_hoare(arr: List<i64>) -> List<i64>:
    # Unstable, O(n log n) average, O(n²) worst
    # Uses Hoare partition (more efficient)
    var result = arr.copy()
    quicksort_hoare_helper(result, 0, result.len() - 1)
    result

fn quicksort_hoare_helper(arr: List<i64>, low: i64, high: i64):
    if low < high:
        val pi = hoare_partition(arr, low, high)
        quicksort_hoare_helper(arr, low, pi)
        quicksort_hoare_helper(arr, pi + 1, high)

fn quicksort_3way(arr: List<i64>) -> List<i64>:
    # 3-way quicksort (Dutch National Flag)
    # Better for arrays with many duplicates
    var result = arr.copy()
    quicksort_3way_helper(result, 0, result.len() - 1)
    result

fn quicksort_3way_helper(arr: List<i64>, low: i64, high: i64):
    if low < high:
        val boundaries = three_way_partition(arr, low, high)
        val lt = boundaries.get(0)
        val gt = boundaries.get(1)
        quicksort_3way_helper(arr, low, lt - 1)
        quicksort_3way_helper(arr, gt + 1, high)

# ============================================================================
# MERGE OPERATIONS
# ============================================================================

fn merge_sorted_arrays(left: List<i64>, right: List<i64>) -> List<i64>:
    # Merge two sorted arrays into one sorted array
    var result = []
    var i = 0
    var j = 0
    val left_len = left.len()
    val right_len = right.len()

    while i < left_len and j < right_len:
        val left_val = left.get(i)
        val right_val = right.get(j)
        if left_val <= right_val:
            result = result.push(left_val)
            i = i + 1
        else:
            result = result.push(right_val)
            j = j + 1

    while i < left_len:
        val val = left.get(i)
        result = result.push(val)
        i = i + 1

    while j < right_len:
        val val = right.get(j)
        result = result.push(val)
        j = j + 1

    result

fn merge_in_place(arr: List<i64>, left: i64, mid: i64, right: i64):
    # In-place merge for merge sort
    val left_part = copy_range(arr, left, mid)
    val right_part = copy_range(arr, mid + 1, right)

    var i = 0
    var j = 0
    var k = left
    val left_len = left_part.len()
    val right_len = right_part.len()

    while i < left_len and j < right_len:
        val left_val = left_part.get(i)
        val right_val = right_part.get(j)
        if left_val <= right_val:
            arr.set(k, left_val)
            i = i + 1
        else:
            arr.set(k, right_val)
            j = j + 1
        k = k + 1

    while i < left_len:
        val val = left_part.get(i)
        arr.set(k, val)
        i = i + 1
        k = k + 1

    while j < right_len:
        val val = right_part.get(j)
        arr.set(k, val)
        j = j + 1
        k = k + 1

# ============================================================================
# MERGESORT FAMILY
# ============================================================================

fn mergesort(arr: List<i64>) -> List<i64>:
    # Stable, O(n log n) all cases
    # In-place: No, Stable: Yes
    val len = arr.len()
    if len <= 1:
        return arr

    val mid = len / 2
    val left = copy_range(arr, 0, mid - 1)
    val right = copy_range(arr, mid, len - 1)

    val sorted_left = mergesort(left)
    val sorted_right = mergesort(right)
    merge_sorted_arrays(sorted_left, sorted_right)

fn mergesort_in_place(arr: List<i64>) -> List<i64>:
    # Stable merge sort with in-place merge
    var result = arr.copy()
    mergesort_in_place_helper(result, 0, result.len() - 1)
    result

fn mergesort_in_place_helper(arr: List<i64>, left: i64, right: i64):
    if left < right:
        val mid = left + (right - left) / 2
        mergesort_in_place_helper(arr, left, mid)
        mergesort_in_place_helper(arr, mid + 1, right)
        merge_in_place(arr, left, mid, right)

fn mergesort_iterative(arr: List<i64>) -> List<i64>:
    # Bottom-up iterative merge sort
    var result = arr.copy()
    val len = result.len()

    var curr_size = 1
    while curr_size < len:
        var left_start = 0
        while left_start < len:
            val mid_calc = left_start + curr_size - 1
            val mid = if mid_calc < len - 1: mid_calc else: len - 1

            val right_end_calc = left_start + curr_size * 2 - 1
            val right_end = if right_end_calc < len - 1: right_end_calc else: len - 1

            if mid < right_end:
                merge_in_place(result, left_start, mid, right_end)

            left_start = left_start + curr_size * 2

        curr_size = curr_size * 2

    result

# ============================================================================
# HEAP OPERATIONS
# ============================================================================

fn heap_parent(i: i64) -> i64:
    (i - 1) / 2

fn heap_left_child(i: i64) -> i64:
    2 * i + 1

fn heap_right_child(i: i64) -> i64:
    2 * i + 2

fn heap_sift_down(arr: List<i64>, start: i64, end: i64):
    # Sift down to maintain max-heap property
    var root = start

    var done = false
    while not done:
        val left = heap_left_child(root)
        val right = heap_right_child(root)
        var largest = root

        if left <= end:
            val root_val = arr.get(largest)
            val left_val = arr.get(left)
            if left_val > root_val:
                largest = left

        if right <= end:
            val largest_val = arr.get(largest)
            val right_val = arr.get(right)
            if right_val > largest_val:
                largest = right

        if largest != root:
            val temp = arr.get(root)
            arr.set(root, arr.get(largest))
            arr.set(largest, temp)
            root = largest
        else:
            done = true

fn heap_sift_up(arr: List<i64>, child: i64):
    # Sift up to maintain max-heap property
    var curr = child

    var done = false
    while curr > 0 and not done:
        val parent = heap_parent(curr)
        val curr_val = arr.get(curr)
        val parent_val = arr.get(parent)

        if curr_val > parent_val:
            arr.set(curr, parent_val)
            arr.set(parent, curr_val)
            curr = parent
        else:
            done = true

fn heapify(arr: List<i64>):
    # Build max-heap from array
    val len = arr.len()
    var start = heap_parent(len - 1)

    while start >= 0:
        heap_sift_down(arr, start, len - 1)
        start = start - 1

fn heap_extract_max(arr: List<i64>, heap_size: i64) -> i64:
    # Extract maximum element from heap
    val max = arr.get(0)
    val last = arr.get(heap_size)
    arr.set(0, last)
    heap_sift_down(arr, 0, heap_size - 1)
    max

# ============================================================================
# HEAPSORT
# ============================================================================

fn heapsort(arr: List<i64>) -> List<i64>:
    # Unstable, O(n log n) all cases
    # In-place: Yes, Stable: No
    var result = arr.copy()
    val len = result.len()

    # Build max-heap
    heapify(result)

    # Extract elements one by one
    var end = len - 1
    while end > 0:
        val temp = result.get(0)
        result.set(0, result.get(end))
        result.set(end, temp)

        end = end - 1
        heap_sift_down(result, 0, end)

    result

# ============================================================================
# NON-COMPARISON SORTS
# ============================================================================

fn counting_sort(arr: List<i64>, max_val: i64) -> List<i64>:
    # Stable, O(n + k) where k is range of values
    # Works for non-negative integers only
    # In-place: No, Stable: Yes
    val len = arr.len()

    # Count occurrences
    var counts = []
    var i = 0
    while i <= max_val:
        counts = counts.push(0)
        i = i + 1

    var j = 0
    while j < len:
        val val = arr.get(j)
        val old_count = counts.get(val)
        counts.set(val, old_count + 1)
        j = j + 1

    # Build output
    var result = []
    var k = 0
    while k <= max_val:
        val count = counts.get(k)
        var m = 0
        while m < count:
            result = result.push(k)
            m = m + 1
        k = k + 1

    result

fn counting_sort_stable(arr: List<i64>, max_val: i64) -> List<i64>:
    # Stable counting sort using cumulative counts
    val len = arr.len()

    # Count occurrences
    var counts = []
    var i = 0
    while i <= max_val:
        counts = counts.push(0)
        i = i + 1

    var j = 0
    while j < len:
        val val = arr.get(j)
        val old_count = counts.get(val)
        counts.set(val, old_count + 1)
        j = j + 1

    # Cumulative counts
    var k = 1
    while k <= max_val:
        val prev = counts.get(k - 1)
        val curr = counts.get(k)
        counts.set(k, prev + curr)
        k = k + 1

    # Build output
    var result = []
    var m = 0
    while m < len:
        result = result.push(0)
        m = m + 1

    var n = len - 1
    while n >= 0:
        val val = arr.get(n)
        val pos = counts.get(val)
        result.set(pos - 1, val)
        counts.set(val, pos - 1)
        n = n - 1

    result

fn get_digit(num: i64, exp: i64) -> i64:
    # Get digit at position exp (1, 10, 100, etc.)
    (num / exp) % 10

fn radix_sort_lsd(arr: List<i64>, max_digits: i64) -> List<i64>:
    # LSD Radix Sort (Least Significant Digit first)
    # Stable, O(d * n) where d is number of digits
    # Works for non-negative integers only
    var result = arr.copy()

    var exp = 1
    var digit = 0
    while digit < max_digits:
        result = radix_sort_lsd_pass(result, exp)
        exp = exp * 10
        digit = digit + 1

    result

fn radix_sort_lsd_pass(arr: List<i64>, exp: i64) -> List<i64>:
    # Single pass of radix sort for digit at position exp
    val len = arr.len()

    # Count occurrences of digits (0-9)
    var counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    var i = 0
    while i < len:
        val val = arr.get(i)
        val digit = get_digit(val, exp)
        val old_count = counts.get(digit)
        counts.set(digit, old_count + 1)
        i = i + 1

    # Cumulative counts
    var j = 1
    while j < 10:
        val prev = counts.get(j - 1)
        val curr = counts.get(j)
        counts.set(j, prev + curr)
        j = j + 1

    # Build output
    var result = []
    var k = 0
    while k < len:
        result = result.push(0)
        k = k + 1

    var m = len - 1
    while m >= 0:
        val val = arr.get(m)
        val digit = get_digit(val, exp)
        val pos = counts.get(digit)
        result.set(pos - 1, val)
        counts.set(digit, pos - 1)
        m = m - 1

    result

fn radix_sort_msd(arr: List<i64>, max_val: i64) -> List<i64>:
    # MSD Radix Sort (Most Significant Digit first)
    # Stable, O(d * n) where d is number of digits
    var result = arr.copy()

    # Calculate max digits needed
    var max_exp = 1
    var temp = max_val
    while temp >= 10:
        max_exp = max_exp * 10
        temp = temp / 10

    radix_sort_msd_helper(result, 0, result.len() - 1, max_exp)
    result

fn radix_sort_msd_helper(arr: List<i64>, low: i64, high: i64, exp: i64):
    if low >= high or exp < 1:
        return ()

    # Use insertion sort for small subarrays
    val size = high - low + 1
    if size < 10:
        insertion_sort_range(arr, low, high)
        return ()

    # Count digits and partition
    var counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    var i = low
    while i <= high:
        val val = arr.get(i)
        val digit = get_digit(val, exp)
        val old_count = counts.get(digit + 1)
        counts.set(digit + 1, old_count + 1)
        i = i + 1

    # Cumulative counts
    var j = 1
    while j < 11:
        val prev = counts.get(j - 1)
        val curr = counts.get(j)
        counts.set(j, prev + curr)
        j = j + 1

    # Build temporary output
    var temp = []
    var k = 0
    val range_size = high - low + 1
    while k < range_size:
        temp = temp.push(0)
        k = k + 1

    var m = low
    while m <= high:
        val val = arr.get(m)
        val digit = get_digit(val, exp)
        val pos = counts.get(digit)
        temp.set(pos, val)
        counts.set(digit, pos + 1)
        m = m + 1

    # Copy back
    var n = 0
    while n < range_size:
        val val = temp.get(n)
        arr.set(low + n, val)
        n = n + 1

    # Recursively sort each bucket
    var digit_idx = 0
    while digit_idx < 10:
        val bucket_start = counts.get(digit_idx)
        val bucket_end = counts.get(digit_idx + 1) - 1
        if bucket_start < bucket_end:
            radix_sort_msd_helper(arr, low + bucket_start, low + bucket_end, exp / 10)
        digit_idx = digit_idx + 1

fn bucket_sort(arr: List<i64>, bucket_count: i64, max_val: i64) -> List<i64>:
    # Bucket sort for uniform distribution
    # Average O(n + k), worst O(n²)
    val len = arr.len()

    # Create buckets
    var buckets = []
    var i = 0
    while i < bucket_count:
        buckets = buckets.push([])
        i = i + 1

    # Distribute elements into buckets
    var j = 0
    while j < len:
        val val = arr.get(j)
        val bucket_idx = (val * bucket_count) / (max_val + 1)
        val bucket = buckets.get(bucket_idx)
        val new_bucket = bucket.push(val)
        buckets.set(bucket_idx, new_bucket)
        j = j + 1

    # Sort each bucket and concatenate
    var result = []
    var k = 0
    while k < bucket_count:
        val bucket = buckets.get(k)
        val sorted_bucket = insertion_sort(bucket)

        var m = 0
        val bucket_len = sorted_bucket.len()
        while m < bucket_len:
            val val = sorted_bucket.get(m)
            result = result.push(val)
            m = m + 1

        k = k + 1

    result

# ============================================================================
# HYBRID ALGORITHMS
# ============================================================================

fn introsort(arr: List<i64>) -> List<i64>:
    # Introspective sort (hybrid: quicksort + heapsort)
    # Unstable, O(n log n) all cases
    # Switches to heapsort when recursion depth exceeds limit
    var result = arr.copy()
    val len = result.len()
    val max_depth = log2_floor(len) * 2
    introsort_helper(result, 0, len - 1, max_depth)
    result

fn introsort_helper(arr: List<i64>, low: i64, high: i64, depth_limit: i64):
    val size = high - low + 1

    # Use insertion sort for small subarrays
    if size < 16:
        insertion_sort_range(arr, low, high)
        return ()

    # Switch to heapsort if depth limit exceeded
    if depth_limit == 0:
        heap_sort_range(arr, low, high)
        return ()

    # Otherwise use quicksort
    val pi = lomuto_partition(arr, low, high)
    introsort_helper(arr, low, pi - 1, depth_limit - 1)
    introsort_helper(arr, pi + 1, high, depth_limit - 1)

fn heap_sort_range(arr: List<i64>, low: i64, high: i64):
    # Heapsort for a specific range
    val size = high - low + 1

    # Build max-heap
    var start = low + (size / 2) - 1
    while start >= low:
        heap_sift_down_range(arr, start, high, low)
        start = start - 1

    # Extract elements
    var end = high
    while end > low:
        val temp = arr.get(low)
        arr.set(low, arr.get(end))
        arr.set(end, temp)

        end = end - 1
        heap_sift_down_range(arr, low, end, low)

fn heap_sift_down_range(arr: List<i64>, start: i64, end: i64, offset: i64):
    # Sift down for heap in a range with offset
    var root = start

    var done = false
    while not done:
        val left = offset + 2 * (root - offset) + 1
        val right = offset + 2 * (root - offset) + 2
        var largest = root

        if left <= end:
            val root_val = arr.get(largest)
            val left_val = arr.get(left)
            if left_val > root_val:
                largest = left

        if right <= end:
            val largest_val = arr.get(largest)
            val right_val = arr.get(right)
            if right_val > largest_val:
                largest = right

        if largest != root:
            val temp = arr.get(root)
            arr.set(root, arr.get(largest))
            arr.set(largest, temp)
            root = largest
        else:
            done = true

fn log2_floor(n: i64) -> i64:
    # Floor of log2(n)
    var result = 0
    var val = n
    while val > 1:
        val = val / 2
        result = result + 1
    result

fn timsort_simple(arr: List<i64>) -> List<i64>:
    # Simplified Timsort (hybrid: insertion sort + merge sort)
    # Stable, O(n log n) worst, O(n) best
    # Uses runs of size 32
    var result = arr.copy()
    val len = result.len()
    val run_size = 32

    # Sort individual runs
    var i = 0
    while i < len:
        val end_calc = i + run_size - 1
        val end = if end_calc < len - 1: end_calc else: len - 1
        insertion_sort_range(result, i, end)
        i = i + run_size

    # Merge runs
    var size = run_size
    while size < len:
        var left = 0
        while left < len:
            val mid_calc = left + size - 1
            val mid = if mid_calc < len - 1: mid_calc else: len - 1

            val right_calc = left + size * 2 - 1
            val right = if right_calc < len - 1: right_calc else: len - 1

            if mid < right:
                merge_in_place(result, left, mid, right)

            left = left + size * 2

        size = size * 2

    result

# ============================================================================
# SPECIALIZED SORTING FUNCTIONS
# ============================================================================

fn sort_with_comparator(arr: List<i64>, cmp: fn(i64, i64) -> i64) -> List<i64>:
    # Generic sort using custom comparator (merge sort based)
    mergesort_with_comparator(arr, cmp)

fn mergesort_with_comparator(arr: List<i64>, cmp: fn(i64, i64) -> i64) -> List<i64>:
    val len = arr.len()
    if len <= 1:
        return arr

    val mid = len / 2
    val left = copy_range(arr, 0, mid - 1)
    val right = copy_range(arr, mid, len - 1)

    val sorted_left = mergesort_with_comparator(left, cmp)
    val sorted_right = mergesort_with_comparator(right, cmp)
    merge_with_comparator(sorted_left, sorted_right, cmp)

fn merge_with_comparator(left: List<i64>, right: List<i64>, cmp: fn(i64, i64) -> i64) -> List<i64>:
    var result = []
    var i = 0
    var j = 0
    val left_len = left.len()
    val right_len = right.len()

    while i < left_len and j < right_len:
        val left_val = left.get(i)
        val right_val = right.get(j)
        val comparison = cmp(left_val, right_val)

        if comparison <= 0:
            result = result.push(left_val)
            i = i + 1
        else:
            result = result.push(right_val)
            j = j + 1

    while i < left_len:
        val val = left.get(i)
        result = result.push(val)
        i = i + 1

    while j < right_len:
        val val = right.get(j)
        result = result.push(val)
        j = j + 1

    result

fn partial_sort(arr: List<i64>, k: i64) -> List<i64>:
    # Sort only first k elements (using selection)
    var result = arr.copy()
    val len = result.len()
    val limit = if k < len: k else: len

    var i = 0
    while i < limit:
        var min_idx = i
        var j = i + 1
        while j < len:
            val curr_min = result.get(min_idx)
            val candidate = result.get(j)
            if candidate < curr_min:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = result.get(i)
            result.set(i, result.get(min_idx))
            result.set(min_idx, temp)
        i = i + 1

    result

fn quickselect(arr: List<i64>, k: i64) -> i64:
    # Find k-th smallest element (0-indexed)
    # Average O(n), worst O(n²)
    var working = arr.copy()
    quickselect_helper(working, 0, working.len() - 1, k)

fn quickselect_helper(arr: List<i64>, low: i64, high: i64, k: i64) -> i64:
    if low == high:
        return arr.get(low)

    val pi = lomuto_partition(arr, low, high)

    if k == pi:
        arr.get(k)
    else if k < pi:
        quickselect_helper(arr, low, pi - 1, k)
    else:
        quickselect_helper(arr, pi + 1, high, k)

fn median(arr: List<i64>) -> i64:
    # Find median using quickselect
    val len = arr.len()
    val mid = len / 2
    quickselect(arr, mid)

fn kth_smallest(arr: List<i64>, k: i64) -> i64:
    # Find k-th smallest element (1-indexed)
    quickselect(arr, k - 1)

fn kth_largest(arr: List<i64>, k: i64) -> i64:
    # Find k-th largest element (1-indexed)
    val len = arr.len()
    quickselect(arr, len - k)

# ============================================================================
# STABILITY AND COMPLEXITY ANALYSIS
# ============================================================================

fn get_sort_stability(sort_name: text) -> bool:
    # Returns whether a sorting algorithm is stable
    match sort_name:
        "bubble": true
        "insertion": true
        "merge": true
        "counting": true
        "radix": true
        "bucket": true
        "timsort": true
        "selection": false
        "quicksort": false
        "heapsort": false
        "introsort": false
        _: false

fn get_sort_best_case(sort_name: text) -> text:
    # Returns best case time complexity as string
    match sort_name:
        "bubble": "O(n)"
        "insertion": "O(n)"
        "selection": "O(n²)"
        "merge": "O(n log n)"
        "quicksort": "O(n log n)"
        "heapsort": "O(n log n)"
        "counting": "O(n + k)"
        "radix": "O(d * n)"
        "bucket": "O(n + k)"
        "timsort": "O(n)"
        "introsort": "O(n log n)"
        _: "Unknown"

fn get_sort_average_case(sort_name: text) -> text:
    # Returns average case time complexity as string
    match sort_name:
        "bubble": "O(n²)"
        "insertion": "O(n²)"
        "selection": "O(n²)"
        "merge": "O(n log n)"
        "quicksort": "O(n log n)"
        "heapsort": "O(n log n)"
        "counting": "O(n + k)"
        "radix": "O(d * n)"
        "bucket": "O(n + k)"
        "timsort": "O(n log n)"
        "introsort": "O(n log n)"
        _: "Unknown"

fn get_sort_worst_case(sort_name: text) -> text:
    # Returns worst case time complexity as string
    match sort_name:
        "bubble": "O(n²)"
        "insertion": "O(n²)"
        "selection": "O(n²)"
        "merge": "O(n log n)"
        "quicksort": "O(n²)"
        "heapsort": "O(n log n)"
        "counting": "O(n + k)"
        "radix": "O(d * n)"
        "bucket": "O(n²)"
        "timsort": "O(n log n)"
        "introsort": "O(n log n)"
        _: "Unknown"

fn get_sort_space_complexity(sort_name: text) -> text:
    # Returns space complexity as string
    match sort_name:
        "bubble": "O(1)"
        "insertion": "O(1)"
        "selection": "O(1)"
        "merge": "O(n)"
        "quicksort": "O(log n)"
        "heapsort": "O(1)"
        "counting": "O(k)"
        "radix": "O(n + k)"
        "bucket": "O(n + k)"
        "timsort": "O(n)"
        "introsort": "O(log n)"
        _: "Unknown"

fn is_in_place_sort(sort_name: text) -> bool:
    # Returns whether algorithm sorts in-place
    match sort_name:
        "bubble": true
        "insertion": true
        "selection": true
        "quicksort": true
        "heapsort": true
        "introsort": true
        "merge": false
        "counting": false
        "radix": false
        "bucket": false
        "timsort": false
        _: false
