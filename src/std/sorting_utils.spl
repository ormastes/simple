# Sorting Utilities
#
# Sorting algorithms and utilities.
# Pure Simple implementation - no external dependencies.
#
# Provides multiple sorting algorithms with different characteristics:
# - Comparison-based sorting (bubble, insertion, selection, merge, quick)
# - Specialized sorting (counting sort for integers)
# - Utilities (is_sorted, sorting with custom comparators)
#
# Functions:
# - Basic sorts: bubble_sort, insertion_sort, selection_sort
# - Advanced sorts: merge_sort, quick_sort, heap_sort
# - Specialized: counting_sort, bucket_sort
# - Utilities: is_sorted, is_sorted_desc, sort_with

# ============================================================================
# Sorting Predicates
# ============================================================================

fn is_sorted(arr):
    """Check if array is sorted in ascending order.

    Example:
        is_sorted([1, 2, 3, 4])  # true
        is_sorted([1, 3, 2])     # false
    """
    if arr.len() <= 1:
        return true

    var i = 1
    while i < arr.len():
        if arr[i - 1] > arr[i]:
            return false
        i = i + 1

    true

fn is_sorted_desc(arr):
    """Check if array is sorted in descending order.

    Example:
        is_sorted_desc([4, 3, 2, 1])  # true
        is_sorted_desc([1, 2, 3])     # false
    """
    if arr.len() <= 1:
        return true

    var i = 1
    while i < arr.len():
        if arr[i - 1] < arr[i]:
            return false
        i = i + 1

    true

fn is_sorted_by(arr, compare_fn):
    """Check if array is sorted according to comparator.

    compare_fn should return true if first arg <= second arg.

    Example:
        is_sorted_by([1, 2, 3], \a, b: a <= b)  # true
    """
    if arr.len() <= 1:
        return true

    var i = 1
    while i < arr.len():
        if not compare_fn(arr[i - 1], arr[i]):
            return false
        i = i + 1

    true

# ============================================================================
# Bubble Sort
# ============================================================================

fn bubble_sort(arr):
    """Sort array using bubble sort.

    Time: O(n²), Space: O(1)
    Stable sort.

    Example:
        bubble_sort([3, 1, 4, 1, 5])  # [1, 1, 3, 4, 5]
    """
    var result = arr
    val n = result.len()

    var i = 0
    while i < n:
        var j = 0
        while j < n - i - 1:
            if result[j] > result[j + 1]:
                # Swap
                val temp = result[j]
                result[j] = result[j + 1]
                result[j + 1] = temp
            j = j + 1
        i = i + 1

    result

fn bubble_sort_optimized(arr):
    """Optimized bubble sort with early termination.

    Example:
        bubble_sort_optimized([1, 2, 3, 5, 4])  # [1, 2, 3, 4, 5]
    """
    var result = arr
    val n = result.len()

    var i = 0
    while i < n:
        var swapped = false
        var j = 0
        while j < n - i - 1:
            if result[j] > result[j + 1]:
                val temp = result[j]
                result[j] = result[j + 1]
                result[j + 1] = temp
                swapped = true
            j = j + 1

        if not swapped:
            break

        i = i + 1

    result

# ============================================================================
# Insertion Sort
# ============================================================================

fn insertion_sort(arr):
    """Sort array using insertion sort.

    Time: O(n²), Space: O(1)
    Stable sort, efficient for small or nearly sorted arrays.

    Example:
        insertion_sort([3, 1, 4, 1, 5])  # [1, 1, 3, 4, 5]
    """
    var result = arr
    val n = result.len()

    var i = 1
    while i < n:
        val key = result[i]
        var j = i - 1

        # Move elements greater than key one position ahead
        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1

        result[j + 1] = key
        i = i + 1

    result

fn insertion_sort_range(arr, start: i64, end: i64):
    """Sort subrange using insertion sort.

    Example:
        insertion_sort_range([1, 5, 3, 2, 4], 1, 4)  # [1, 2, 3, 5, 4]
    """
    var result = arr

    var i = start + 1
    while i <= end and i < result.len():
        val key = result[i]
        var j = i - 1

        while j >= start and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1

        result[j + 1] = key
        i = i + 1

    result

# ============================================================================
# Selection Sort
# ============================================================================

fn selection_sort(arr):
    """Sort array using selection sort.

    Time: O(n²), Space: O(1)
    Not stable.

    Example:
        selection_sort([3, 1, 4, 1, 5])  # [1, 1, 3, 4, 5]
    """
    var result = arr
    val n = result.len()

    var i = 0
    while i < n - 1:
        var min_idx = i
        var j = i + 1

        # Find minimum element
        while j < n:
            if result[j] < result[min_idx]:
                min_idx = j
            j = j + 1

        # Swap
        if min_idx != i:
            val temp = result[i]
            result[i] = result[min_idx]
            result[min_idx] = temp

        i = i + 1

    result

# ============================================================================
# Merge Sort
# ============================================================================

fn merge_sorted_arrays(left, right):
    """Merge two sorted arrays.

    Example:
        merge_sorted_arrays([1, 3], [2, 4])  # [1, 2, 3, 4]
    """
    var result = []
    var i = 0
    var j = 0

    while i < left.len() and j < right.len():
        if left[i] <= right[j]:
            result.push(left[i])
            i = i + 1
        else:
            result.push(right[j])
            j = j + 1

    # Add remaining elements
    while i < left.len():
        result.push(left[i])
        i = i + 1

    while j < right.len():
        result.push(right[j])
        j = j + 1

    result

fn merge_sort(arr):
    """Sort array using merge sort.

    Time: O(n log n), Space: O(n)
    Stable sort.

    Example:
        merge_sort([3, 1, 4, 1, 5, 9, 2, 6])  # [1, 1, 2, 3, 4, 5, 6, 9]
    """
    if arr.len() <= 1:
        return arr

    # Split array
    val mid = arr.len() / 2
    var left = []
    var right = []

    var i = 0
    while i < mid:
        left.push(arr[i])
        i = i + 1

    while i < arr.len():
        right.push(arr[i])
        i = i + 1

    # Recursive sort
    val sorted_left = merge_sort(left)
    val sorted_right = merge_sort(right)

    # Merge
    merge_sorted_arrays(sorted_left, sorted_right)

# ============================================================================
# Quick Sort
# ============================================================================

fn partition(arr, low: i64, high: i64) -> i64:
    """Partition array for quicksort.

    Returns partition index.
    """
    val pivot = arr[high]
    var i = low - 1

    var j = low
    while j < high:
        if arr[j] <= pivot:
            i = i + 1
            # Swap arr[i] and arr[j]
            val temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        j = j + 1

    # Swap arr[i+1] and arr[high] (pivot)
    val temp = arr[i + 1]
    arr[i + 1] = arr[high]
    arr[high] = temp

    i + 1

fn quick_sort_helper(arr, low: i64, high: i64):
    """Quick sort helper function."""
    if low < high:
        val pi = partition(arr, low, high)
        quick_sort_helper(arr, low, pi - 1)
        quick_sort_helper(arr, pi + 1, high)

fn quick_sort(arr):
    """Sort array using quick sort.

    Time: O(n log n) average, O(n²) worst, Space: O(log n)
    Not stable.

    Example:
        quick_sort([3, 1, 4, 1, 5, 9, 2, 6])  # [1, 1, 2, 3, 4, 5, 6, 9]
    """
    var result = arr
    if result.len() > 1:
        quick_sort_helper(result, 0, result.len() - 1)
    result

# ============================================================================
# Heap Sort
# ============================================================================

fn heapify(arr, n: i64, i: i64):
    """Heapify subtree rooted at index i."""
    var largest = i
    val left = 2 * i + 1
    val right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        # Swap
        val temp = arr[i]
        arr[i] = arr[largest]
        arr[largest] = temp

        # Recursively heapify
        heapify(arr, n, largest)

fn heap_sort(arr):
    """Sort array using heap sort.

    Time: O(n log n), Space: O(1)
    Not stable.

    Example:
        heap_sort([3, 1, 4, 1, 5, 9, 2, 6])  # [1, 1, 2, 3, 4, 5, 6, 9]
    """
    var result = arr
    val n = result.len()

    # Build max heap
    var i = n / 2 - 1
    while i >= 0:
        heapify(result, n, i)
        i = i - 1

    # Extract elements from heap
    i = n - 1
    while i > 0:
        # Swap root with last element
        val temp = result[0]
        result[0] = result[i]
        result[i] = temp

        # Heapify reduced heap
        heapify(result, i, 0)
        i = i - 1

    result

# ============================================================================
# Counting Sort
# ============================================================================

fn counting_sort(arr):
    """Sort array of non-negative integers using counting sort.

    Time: O(n + k) where k is range, Space: O(k)
    Stable sort. Only works for non-negative integers.

    Example:
        counting_sort([3, 1, 4, 1, 5, 9, 2, 6])  # [1, 1, 2, 3, 4, 5, 6, 9]
    """
    if arr.len() == 0:
        return []

    # Find max value
    var max_val = arr[0]
    for x in arr:
        if x > max_val:
            max_val = x

    # Count occurrences
    var counts = []
    var i = 0
    while i <= max_val:
        counts.push(0)
        i = i + 1

    for x in arr:
        counts[x] = counts[x] + 1

    # Build result
    var result = []
    i = 0
    while i <= max_val:
        var j = 0
        while j < counts[i]:
            result.push(i)
            j = j + 1
        i = i + 1

    result

fn counting_sort_with_range(arr, min_val: i64, max_val: i64):
    """Counting sort with specified range.

    Example:
        counting_sort_with_range([3, 1, 4, 1, 5], 1, 5)
    """
    val range_size = max_val - min_val + 1
    var counts = []
    var i = 0
    while i < range_size:
        counts.push(0)
        i = i + 1

    # Count
    for x in arr:
        val idx = x - min_val
        counts[idx] = counts[idx] + 1

    # Build result
    var result = []
    i = 0
    while i < range_size:
        var j = 0
        while j < counts[i]:
            result.push(i + min_val)
            j = j + 1
        i = i + 1

    result

# ============================================================================
# Bucket Sort
# ============================================================================

fn bucket_sort(arr, num_buckets: i64):
    """Sort array using bucket sort.

    Assumes elements are uniformly distributed.
    Time: O(n + k) average, Space: O(n + k)

    Example:
        bucket_sort([3, 1, 4, 1, 5, 9, 2, 6], 5)
    """
    if arr.len() == 0 or num_buckets <= 0:
        return arr

    # Find min and max
    var min_val = arr[0]
    var max_val = arr[0]
    for x in arr:
        if x < min_val:
            min_val = x
        if x > max_val:
            max_val = x

    val range = max_val - min_val + 1
    val bucket_size = range / num_buckets + 1

    # Create buckets
    var buckets = []
    var i = 0
    while i < num_buckets:
        buckets.push([])
        i = i + 1

    # Distribute elements
    for x in arr:
        val bucket_idx = (x - min_val) / bucket_size
        if bucket_idx >= num_buckets:
            buckets[num_buckets - 1].push(x)
        else:
            buckets[bucket_idx].push(x)

    # Sort each bucket and concatenate
    var result = []
    for bucket in buckets:
        val sorted_bucket = insertion_sort(bucket)
        for x in sorted_bucket:
            result.push(x)

    result

# ============================================================================
# Partial Sorting
# ============================================================================

fn partial_sort(arr, k: i64):
    """Partially sort array (first k elements sorted).

    Returns array where first k elements are in sorted order.
    Remaining elements are unordered.

    Example:
        partial_sort([3, 1, 4, 1, 5, 9, 2], 3)
        # First 3 elements: [1, 1, 2, ...]
    """
    var result = arr

    var i = 0
    while i < k and i < result.len():
        var min_idx = i
        var j = i + 1

        while j < result.len():
            if result[j] < result[min_idx]:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = result[i]
            result[i] = result[min_idx]
            result[min_idx] = temp

        i = i + 1

    result

fn nth_element(arr, n: i64):
    """Find nth smallest element (0-indexed).

    Uses quickselect algorithm.
    Time: O(n) average.

    Example:
        nth_element([3, 1, 4, 1, 5], 2)  # 3 (third smallest)
    """
    var work = arr

    var low = 0
    var high = work.len() - 1

    while low <= high:
        val pi = partition(work, low, high)

        if pi == n:
            return work[pi]
        elif pi < n:
            low = pi + 1
        else:
            high = pi - 1

    nil

# ============================================================================
# Sorting with Custom Comparator
# ============================================================================

fn sort_with(arr, compare_fn):
    """Sort array using custom comparator.

    compare_fn(a, b) should return true if a <= b.

    Example:
        sort_with([3, 1, 4], \a, b: a >= b)  # [4, 3, 1] (descending)
    """
    var result = arr
    val n = result.len()

    var i = 1
    while i < n:
        val key = result[i]
        var j = i - 1

        while j >= 0 and not compare_fn(result[j], key):
            result[j + 1] = result[j]
            j = j - 1

        result[j + 1] = key
        i = i + 1

    result

fn sort_descending(arr):
    """Sort array in descending order.

    Example:
        sort_descending([3, 1, 4, 1, 5])  # [5, 4, 3, 1, 1]
    """
    sort_with(arr, \a, b: a >= b)

# ============================================================================
# Stable Sorting Utilities
# ============================================================================

fn stable_sort_with_indices(arr):
    """Stable sort that preserves original indices.

    Returns array of (value, original_index) tuples.

    Example:
        stable_sort_with_indices([3, 1, 4, 1])
        # [(1, 1), (1, 3), (3, 0), (4, 2)]
    """
    # Create indexed array
    var indexed = []
    var i = 0
    while i < arr.len():
        indexed.push((arr[i], i))
        i = i + 1

    # Sort by value (using stable merge sort)
    fn compare_indexed(a, b):
        val (val_a, _) = a
        val (val_b, _) = b
        val_a <= val_b

    sort_with(indexed, compare_indexed)

# ============================================================================
# Utility Functions
# ============================================================================

fn reverse_array(arr):
    """Reverse array in place.

    Example:
        reverse_array([1, 2, 3, 4])  # [4, 3, 2, 1]
    """
    var result = arr
    var left = 0
    var right = result.len() - 1

    while left < right:
        val temp = result[left]
        result[left] = result[right]
        result[right] = temp
        left = left + 1
        right = right - 1

    result

fn is_permutation(arr1, arr2):
    """Check if arr2 is a permutation of arr1.

    Example:
        is_permutation([1, 2, 3], [3, 1, 2])  # true
    """
    if arr1.len() != arr2.len():
        return false

    val sorted1 = merge_sort(arr1)
    val sorted2 = merge_sort(arr2)

    var i = 0
    while i < sorted1.len():
        if sorted1[i] != sorted2[i]:
            return false
        i = i + 1

    true

fn best_sorting_algorithm(n: i64, nearly_sorted):
    """Recommend best sorting algorithm.

    Returns name of recommended algorithm.

    Example:
        best_sorting_algorithm(10, true)  # "insertion_sort"
    """
    if n <= 10:
        return "insertion_sort"

    if nearly_sorted:
        return "insertion_sort"

    if n <= 1000:
        return "quick_sort"

    "merge_sort"
