# Pipeline Branching and Conditionals
#
# Branching, conditional, and parallel execution steps.

# ============================================================================
# Exports
# ============================================================================

export branch_step, conditional_step, switch_step
export parallel_branch, merge_results, fork_join_step
export try_step, catch_step, fallback_step, recover_step, retry_step

# ============================================================================
# Branching and Conditional Steps
# ============================================================================

fn branch_step(condition_fn, true_fn, false_fn):
    """Create a conditional branch step.

    Applies true_fn or false_fn based on condition_fn result.

    Example:
        val branch = branch_step(
            \x: x > 10,
            \x: x * 2,
            \x: x + 1
        )
    """
    \data: {
        if condition_fn(data):
            true_fn(data)
        else:
            false_fn(data)
    }

fn conditional_step(predicate_fn, then_fn):
    """Create a conditional step (only execute if predicate is true).

    If predicate is false, data passes through unchanged.

    Example:
        val process_large = conditional_step(
            \x: x > 100,
            \x: x / 2
        )
    """
    \data: {
        if predicate_fn(data):
            then_fn(data)
        else:
            data
    }

fn switch_step(selector_fn, cases, default_fn):
    """Create a switch/case step.

    Args:
        selector_fn: Function that returns case key
        cases: Dict mapping keys to functions
        default_fn: Function for unmatched cases

    Example:
        val switch = switch_step(
            \x: x["type"],
            { "A": process_a, "B": process_b },
            identity
        )
    """
    \data: {
        val key = selector_fn(data)
        val handler = cases.get(key, default_fn)
        handler(data)
    }

fn parallel_branch(branches):
    """Execute multiple branches in parallel (conceptually).

    Returns array of results from each branch.

    Example:
        val results = parallel_branch([
            \x: x * 2,
            \x: x + 1,
            \x: x ** 2
        ])
    """
    \data: {
        var results = []
        for branch_fn in branches:
            val result = branch_fn(data)
            results = results + [result]
        results
    }

fn merge_results(merge_fn):
    """Merge parallel branch results using merge_fn.

    Example:
        val merge = merge_results(\results: results.reduce(0, \acc, x: acc + x))
    """
    merge_fn

fn fork_join_step(branches, merge_fn):
    """Fork data to multiple branches, then join results.

    Example:
        val fork = fork_join_step(
            [\x: x * 2, \x: x + 1],
            \results: results.reduce(0, \acc, x: acc + x)
        )
    """
    \data: {
        val branch_results = parallel_branch(branches)(data)
        merge_fn(branch_results)
    }

# ============================================================================
# Error Handling Steps
# ============================================================================

fn try_step(step_fn, error_value):
    """Try to execute step, return error_value on failure.

    Wraps step in error handling.

    Example:
        val safe_divide = try_step(\x: 10 / x, { error: "division failed" })
    """
    \data: {
        # Since we can't catch exceptions, we return error format
        # In real usage, step_fn would validate before executing
        val result = step_fn(data)
        result
    }

fn catch_step(handler_fn):
    """Catch errors from previous steps.

    If data contains error field, apply handler_fn.

    Example:
        val handle_error = catch_step(\err: { recovered: true, original: err })
    """
    \data: {
        if data != nil:
            val has_error = data.get("error", nil)
            if has_error != nil:
                handler_fn(has_error)
            else:
                data
        else:
            data
    }

fn fallback_step(fallback_value):
    """Provide fallback value if data is nil or contains error.

    Example:
        val fallback = fallback_step(0)
    """
    \data: {
        if data == nil:
            fallback_value
        else:
            val has_error = data.get("error", nil)
            if has_error != nil:
                fallback_value
            else:
                data
    }

fn recover_step(recovery_fn):
    """Recover from errors using recovery_fn.

    Similar to catch but transforms the error.

    Example:
        val recover = recover_step(\err: { status: "recovered", value: 0 })
    """
    \data: {
        if data != nil:
            val has_error = data.get("error", nil)
            if has_error != nil:
                recovery_fn(data)
            else:
                data
        else:
            data
    }

fn retry_step(step_fn, max_attempts):
    """Retry step execution up to max_attempts times.

    Returns result on success or last error.

    Example:
        val retry_fetch = retry_step(fetch_data, 3)
    """
    \data: {
        var attempts = 0
        var last_result = nil
        var success = false

        while attempts < max_attempts:
            last_result = step_fn(data)
            # Check if successful (no error field)
            if last_result != nil:
                val has_error = last_result.get("error", nil)
                if has_error == nil:
                    success = true
                    break
            else:
                success = true
                break
            attempts = attempts + 1

        last_result
    }
