# K-d Tree Types and Core Data Structures
# Point, KdNode, and BoundingBox types with accessors

# ============================================================================
# Core Types and Constants
# ============================================================================

# Point: List of i64 coordinates (variable dimension)
# KdNode: (dim: i64, value: i64, left: KdNode?, right: KdNode?, point: List<i64>)
# BoundingBox: (min: List<i64>, max: List<i64>)
# Distance metric types: 0=Euclidean, 1=Manhattan, 2=Chebyshev

# ============================================================================
# Point Operations
# ============================================================================

fn point_create(coords: List<i64>) -> List<i64>:
    # Create a point from coordinate list
    coords

fn point_dimension(point: List<i64>) -> i64:
    # Get dimension of point
    point.length()

fn point_get(point: List<i64>, dim: i64) -> i64:
    # Get coordinate at dimension
    point.get(dim)

fn point_set(point: List<i64>, dim: i64, value: i64) -> List<i64>:
    # Set coordinate at dimension (returns new point)
    var result = []
    var i = 0
    while i < point.length():
        if i == dim:
            result.push(value)
        else:
            val coord = point.get(i)
            result.push(coord)
        i = i + 1
    result

fn point_equal(p1: List<i64>, p2: List<i64>) -> i64:
    # Check if two points are equal
    val len1 = p1.length()
    val len2 = p2.length()
    if len1 != len2:
        return 0
    var i = 0
    while i < len1:
        val coord1 = p1.get(i)
        val coord2 = p2.get(i)
        if coord1 != coord2:
            return 0
        i = i + 1
    1

fn point_copy(point: List<i64>) -> List<i64>:
    # Create a copy of a point
    var result = []
    var i = 0
    while i < point.length():
        val coord = point.get(i)
        result.push(coord)
        i = i + 1
    result

fn point_distance_squared_euclidean(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate squared Euclidean distance between two points
    var sum = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        sum = sum + (diff * diff)
        i = i + 1
    sum

fn point_distance_manhattan(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate Manhattan distance between two points
    var sum = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        val abs_diff = if diff < 0: -diff else: diff
        sum = sum + abs_diff
        i = i + 1
    sum

fn point_distance_chebyshev(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate Chebyshev distance between two points
    var max_dist = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        val abs_diff = if diff < 0: -diff else: diff
        if abs_diff > max_dist:
            max_dist = abs_diff
        i = i + 1
    max_dist

fn point_distance(p1: List<i64>, p2: List<i64>, metric: i64) -> i64:
    # Calculate distance using specified metric
    # metric: 0=Euclidean (squared), 1=Manhattan, 2=Chebyshev
    if metric == 1:
        point_distance_manhattan(p1, p2)
    else:
        if metric == 2:
            point_distance_chebyshev(p1, p2)
        else:
            point_distance_squared_euclidean(p1, p2)

fn point_distance_minkowski(p1: List<i64>, p2: List<i64>, p: i64) -> i64:
    # Calculate Minkowski distance with parameter p
    var sum = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        val abs_diff = if diff < 0: -diff else: diff
        var powered = abs_diff
        var j = 1
        while j < p:
            powered = powered * abs_diff
            j = j + 1
        sum = sum + powered
        i = i + 1
    sum

fn point_distance_canberra(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate Canberra distance
    var sum = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        val diff = c1 - c2
        val abs_diff = if diff < 0: -diff else: diff
        val abs_c1 = if c1 < 0: -c1 else: c1
        val abs_c2 = if c2 < 0: -c2 else: c2
        val denom = abs_c1 + abs_c2
        if denom != 0:
            sum = sum + (abs_diff * 100 / denom)
        i = i + 1
    sum

fn point_distance_hamming(p1: List<i64>, p2: List<i64>) -> i64:
    # Calculate Hamming distance (count of different coordinates)
    var count = 0
    var i = 0
    val len = p1.length()
    while i < len:
        val c1 = p1.get(i)
        val c2 = p2.get(i)
        if c1 != c2:
            count = count + 1
        i = i + 1
    count

# ============================================================================
# KdNode Operations
# ============================================================================

fn kdnode_create(dim: i64, value: i64, point: List<i64>) -> List:
    # Create a new KdNode: [dim, value, left, right, point]
    [dim, value, nil, nil, point]

fn kdnode_get_dim(node: List) -> i64:
    # Get splitting dimension
    node.get(0)

fn kdnode_get_value(node: List) -> i64:
    # Get pivot value
    node.get(1)

fn kdnode_get_left(node: List):
    # Get left child
    node.get(2)

fn kdnode_get_right(node: List):
    # Get right child
    node.get(3)

fn kdnode_get_point(node: List) -> List<i64>:
    # Get point stored at node
    node.get(4)

fn kdnode_set_left(node: List, left):
    # Set left child
    node.set(2, left)

fn kdnode_set_right(node: List, right):
    # Set right child
    node.set(3, right)

fn kdnode_is_leaf(node: List) -> i64:
    # Check if node is a leaf
    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_nil = if left == nil: 1 else: 0
    val right_nil = if right == nil: 1 else: 0
    if left_nil == 1:
        if right_nil == 1:
            return 1
    0

# ============================================================================
# Bounding Box Operations
# ============================================================================

fn bbox_create(points: List<List<i64>>) -> List:
    # Create bounding box from points
    # Returns [min_bounds, max_bounds]
    if points.length() == 0:
        return [[], []]

    val first = points.get(0)
    val k = first.length()

    var min_bounds = []
    var max_bounds = []
    var d = 0
    while d < k:
        min_bounds.push(999999999)
        max_bounds.push(-999999999)
        d = d + 1

    var i = 0
    while i < points.length():
        val point = points.get(i)
        var j = 0
        while j < k:
            val coord = point.get(j)
            val min_val = min_bounds.get(j)
            val max_val = max_bounds.get(j)
            if coord < min_val:
                min_bounds.set(j, coord)
            if coord > max_val:
                max_bounds.set(j, coord)
            j = j + 1
        i = i + 1

    [min_bounds, max_bounds]

fn bbox_get_min(bbox: List) -> List<i64>:
    # Get minimum bounds
    bbox.get(0)

fn bbox_get_max(bbox: List) -> List<i64>:
    # Get maximum bounds
    bbox.get(1)

fn bbox_contains_point(bbox: List, point: List<i64>) -> i64:
    # Check if bounding box contains point
    val min_bounds = bbox_get_min(bbox)
    val max_bounds = bbox_get_max(bbox)
    point_in_range(point, min_bounds, max_bounds)

fn bbox_intersects(bbox1: List, bbox2: List) -> i64:
    # Check if two bounding boxes intersect
    val min1 = bbox_get_min(bbox1)
    val max1 = bbox_get_max(bbox1)
    val min2 = bbox_get_min(bbox2)
    val max2 = bbox_get_max(bbox2)

    var i = 0
    while i < min1.length():
        val min1_val = min1.get(i)
        val max1_val = max1.get(i)
        val min2_val = min2.get(i)
        val max2_val = max2.get(i)
        if max1_val < min2_val:
            return 0
        if min1_val > max2_val:
            return 0
        i = i + 1
    1

fn bbox_volume(bbox: List) -> i64:
    # Calculate volume of bounding box
    val min_bounds = bbox_get_min(bbox)
    val max_bounds = bbox_get_max(bbox)

    var volume = 1
    var i = 0
    while i < min_bounds.length():
        val min_val = min_bounds.get(i)
        val max_val = max_bounds.get(i)
        val extent = max_val - min_val
        volume = volume * extent
        i = i + 1
    volume

fn bbox_center(bbox: List) -> List<i64>:
    # Calculate center of bounding box
    val min_bounds = bbox_get_min(bbox)
    val max_bounds = bbox_get_max(bbox)

    var center = []
    var i = 0
    while i < min_bounds.length():
        val min_val = min_bounds.get(i)
        val max_val = max_bounds.get(i)
        val mid = (min_val + max_val) / 2
        center.push(mid)
        i = i + 1
    center

# ============================================================================
# Helper for range check (used by bbox_contains_point)
# ============================================================================

fn point_in_range(point: List<i64>, min_bounds: List<i64>, max_bounds: List<i64>) -> i64:
    # Check if point is within range
    var i = 0
    while i < point.length():
        val coord = point.get(i)
        val min_val = min_bounds.get(i)
        val max_val = max_bounds.get(i)
        if coord < min_val:
            return 0
        if coord > max_val:
            return 0
        i = i + 1
    1
