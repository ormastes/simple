# K-d Tree Range Search
# Rectangular range queries and radius-based searches

import kd_tree.types

# ============================================================================
# Range Search
# ============================================================================

fn kdtree_range_search_recursive(node, min_bounds: List<i64>, max_bounds: List<i64>, result: List):
    # Recursively search for points in range
    if node == nil:
        return

    val point = kdnode_get_point(node)
    val in_range = point_in_range(point, min_bounds, max_bounds)
    if in_range == 1:
        result.push(point)

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val min_val = min_bounds.get(dim)
    val max_val = max_bounds.get(dim)

    if min_val <= pivot:
        val left = kdnode_get_left(node)
        kdtree_range_search_recursive(left, min_bounds, max_bounds, result)

    if max_val >= pivot:
        val right = kdnode_get_right(node)
        kdtree_range_search_recursive(right, min_bounds, max_bounds, result)

fn kdtree_range_search(node, min_bounds: List<i64>, max_bounds: List<i64>) -> List<List<i64>>:
    # Find all points within range
    var result = []
    kdtree_range_search_recursive(node, min_bounds, max_bounds, result)
    result

fn kdtree_range_search_radius(node, center: List<i64>, radius: i64, metric: i64) -> List<List<i64>>:
    # Find all points within radius of center
    # Uses range search followed by distance filtering
    var min_bounds = []
    var max_bounds = []
    var i = 0
    while i < center.length():
        val coord = center.get(i)
        min_bounds.push(coord - radius)
        max_bounds.push(coord + radius)
        i = i + 1

    val candidates = kdtree_range_search(node, min_bounds, max_bounds)
    var result = []
    var j = 0
    while j < candidates.length():
        val point = candidates.get(j)
        val dist = point_distance(point, center, metric)
        val rad_squared = radius * radius
        if dist <= rad_squared:
            result.push(point)
        j = j + 1

    result

# ============================================================================
# Spatial Queries
# ============================================================================

fn kdtree_count_in_range(node, min_bounds: List<i64>, max_bounds: List<i64>) -> i64:
    # Count points in range without collecting them
    if node == nil:
        return 0

    var count = 0
    val point = kdnode_get_point(node)
    val in_range = point_in_range(point, min_bounds, max_bounds)
    if in_range == 1:
        count = count + 1

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val min_val = min_bounds.get(dim)
    val max_val = max_bounds.get(dim)

    if min_val <= pivot:
        val left = kdnode_get_left(node)
        count = count + kdtree_count_in_range(left, min_bounds, max_bounds)

    if max_val >= pivot:
        val right = kdnode_get_right(node)
        count = count + kdtree_count_in_range(right, min_bounds, max_bounds)

    count

fn kdtree_count_in_radius(node, center: List<i64>, radius: i64, metric: i64) -> i64:
    # Count points within radius
    if node == nil:
        return 0

    var count = 0
    val point = kdnode_get_point(node)
    val dist = point_distance(point, center, metric)
    val rad_squared = radius * radius
    if dist <= rad_squared:
        count = count + 1

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = center.get(dim)

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    val diff = coord - pivot
    val abs_diff = if diff < 0: -diff else: diff
    val axis_dist = abs_diff * abs_diff

    if coord < pivot:
        count = count + kdtree_count_in_radius(left, center, radius, metric)
        if axis_dist <= rad_squared:
            count = count + kdtree_count_in_radius(right, center, radius, metric)
    else:
        count = count + kdtree_count_in_radius(right, center, radius, metric)
        if axis_dist <= rad_squared:
            count = count + kdtree_count_in_radius(left, center, radius, metric)

    count

fn kdtree_exists_in_range(node, min_bounds: List<i64>, max_bounds: List<i64>) -> i64:
    # Check if any point exists in range
    if node == nil:
        return 0

    val point = kdnode_get_point(node)
    val in_range = point_in_range(point, min_bounds, max_bounds)
    if in_range == 1:
        return 1

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val min_val = min_bounds.get(dim)
    val max_val = max_bounds.get(dim)

    if min_val <= pivot:
        val left = kdnode_get_left(node)
        val left_exists = kdtree_exists_in_range(left, min_bounds, max_bounds)
        if left_exists == 1:
            return 1

    if max_val >= pivot:
        val right = kdnode_get_right(node)
        val right_exists = kdtree_exists_in_range(right, min_bounds, max_bounds)
        if right_exists == 1:
            return 1

    0
