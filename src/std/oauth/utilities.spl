# OAuth 2.0 Utilities Module
# Helper functions, crypto, URL encoding

import string
import array
import math

# ============================================================================
# URL and Parameter Utilities
# ============================================================================

# ============================================================================

# URL encode a string
fn url_encode(input: text) -> text:
    var result = ""
    var i = 0
    val len = string.length(input)

    while i < len:
        val char = string.char_at(input, i)

        if is_unreserved_char(char):
            result = string.concat(result, char)
        else:
            # Encode as %XX (simplified - proper encoding needed)
            val encoded = percent_encode_char(char)
            result = string.concat(result, encoded)

        i = i + 1

    result

# Check if character is unreserved (no encoding needed)
fn is_unreserved_char(char: text) -> bool:
    val is_alpha = is_alphanumeric(char)
    val is_hyphen = string.equals(char, "-")
    val is_underscore = string.equals(char, "_")
    val is_dot = string.equals(char, ".")
    val is_tilde = string.equals(char, "~")

    if is_alpha:
        true
    else:
        if is_hyphen:
            true
        else:
            if is_underscore:
                true
            else:
                if is_dot:
                    true
                else:
                    is_tilde

# Parse query parameters from URL
fn parse_query_params(url: text):
    val query_start = string.index_of(url, "?")
    if query_start < 0:
        return []

    val query_string = string.substring(url, query_start + 1, string.length(url))
    val pairs = string.split(query_string, "&")

    var params = []
    var i = 0
    while i < array.length(pairs):
        val pair = array.get(pairs, i)
        val parts = string.split(pair, "=")

        if array.length(parts) >= 2:
            val key = array.get(parts, 0)
            val value = array.get(parts, 1)
            params = array.append(params, (key, url_decode(value)))

        i = i + 1

    params

# Get parameter value from params array
fn get_param_value(params, key: text) -> text:
    var i = 0
    var value = ""

    while i < array.length(params):
        val param = array.get(params, i)
        val param_key = param.0

        if string.equals(param_key, key):
            value = param.1

        i = i + 1

    value

# URL decode a string
fn url_decode(input: text) -> text:
    # Simplified implementation
    var result = input
    result = string.replace(result, "+", " ")
    result = string.replace(result, "%20", " ")
    result

# Build URL with query parameters
fn build_url_with_params(base_url: text, params):
    var url = base_url

    var i = 0
    while i < array.length(params):
        val param = array.get(params, i)
        val key = param.0
        val value = param.1

        val separator = if i == 0: "?" else: "&"
        val param_str = string.concat(string.concat(string.concat(separator, key), "="), url_encode(value))
        url = string.concat(url, param_str)

        i = i + 1

    url


# ============================================================================
# Helper Functions
# ============================================================================

# ============================================================================

# Get current timestamp (seconds since epoch)
fn get_current_timestamp() -> i64:
    # Simplified - in production use system time
    1707753600  # Mock timestamp

# Generate random integer in range [min, max]
fn random_int(min: i64, max: i64) -> i64:
    # Simplified random - in production use proper PRNG
    val range = max - min + 1
    min + (get_current_timestamp() % range)

# Generate random alphanumeric string
fn generate_random_string(length: i64) -> text:
    val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    var result = ""
    var i = 0
    while i < length:
        val idx = random_int(0, string.length(chars) - 1)
        val char = string.char_at(chars, idx)
        result = string.concat(result, char)
        i = i + 1
    result

# Check if character is alphanumeric
fn is_alphanumeric(char: text) -> bool:
    val code = string.char_code(char)
    val is_digit = code >= 48  # '0' = 48
    val is_digit_end = code <= 57  # '9' = 57
    val is_upper = code >= 65  # 'A' = 65
    val is_upper_end = code <= 90  # 'Z' = 90
    val is_lower = code >= 97  # 'a' = 97
    val is_lower_end = code <= 122  # 'z' = 122

    var result = false
    if is_digit:
        if is_digit_end:
            result = true

    if is_upper:
        if is_upper_end:
            result = true

    if is_lower:
        if is_lower_end:
            result = true

    result

# Check if array contains element
fn array_contains(arr, element: text) -> bool:
    var i = 0
    var found = false
    while i < array.length(arr):
        val item = array.get(arr, i)
        if string.equals(item, element):
            found = true
        i = i + 1
    found

# Convert i64 to text
fn i64_to_text(value: i64) -> text:
    # Simplified - in production use proper conversion
    if value == 0:
        return "0"

    var result = ""
    var num = value
    var is_negative = num < 0

    if is_negative:
        num = 0 - num

    while num > 0:
        val digit = num % 10
        val char = digit_to_char(digit)
        result = string.concat(char, result)
        num = num / 10

    if is_negative:
        result = string.concat("-", result)

    result

# Convert text to i64
fn text_to_i64(text: text) -> i64:
    # Simplified - in production use proper parsing
    val len = string.length(text)
    if len == 0:
        return 0

    var result = 0
    var i = 0
    var is_negative = string.equals(string.char_at(text, 0), "-")

    if is_negative:
        i = 1

    while i < len:
        val char = string.char_at(text, i)
        val digit = char_to_digit(char)
        result = result * 10 + digit
        i = i + 1

    if is_negative:
        result = 0 - result

    result

# Convert digit to character
fn digit_to_char(digit: i64) -> text:
    val digits = "0123456789"
    string.char_at(digits, digit)

# Convert character to digit
fn char_to_digit(char: text) -> i64:
    val code = string.char_code(char)
    code - 48  # '0' = 48

# Real SHA-256 hash per FIPS 180-4
# Returns 64-character lowercase hex string
fn hash_sha256(input: text) -> text:
    val mask32 = 4294967295

    # SHA-256 initial hash values
    var h0 = 1779033703
    var h1 = 3144134277
    var h2 = 1013904242
    var h3 = 2773480762
    var h4 = 1359893119
    var h5 = 2600822924
    var h6 = 528734635
    var h7 = 1541459225

    # Round constants
    var kk = [
        1116352408, 1899447441, 3049323471, 3921009573,
        961987163, 1508970993, 2453635748, 2870763221,
        3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037,
        2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877,
        958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298
    ]

    # Convert to bytes
    val input_len = string.length(input)
    var bytes = []
    var bi = 0
    while bi < input_len:
        val ch = string.char_at(input, bi)
        val code = string.char_code(ch)
        bytes = array.push(bytes, code)
        bi = bi + 1

    # Pad message
    val data_len = array.length(bytes)
    bytes = array.push(bytes, 128)
    val pad_target = data_len + 1
    var pad_zeros = 56 - (pad_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        bytes = array.push(bytes, 0)
        pz = pz + 1

    val bit_length = data_len * 8
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, 0)
    bytes = array.push(bytes, (bit_length >> 24) & 255)
    bytes = array.push(bytes, (bit_length >> 16) & 255)
    bytes = array.push(bytes, (bit_length >> 8) & 255)
    bytes = array.push(bytes, bit_length & 255)

    # Process 64-byte blocks
    val total_len = array.length(bytes)
    var block_off = 0
    while block_off < total_len:
        var w = []
        var wi = 0
        while wi < 16:
            val base = block_off + (wi * 4)
            val vb0 = bytes[base] & 255
            val vb1 = bytes[base + 1] & 255
            val vb2 = bytes[base + 2] & 255
            val vb3 = bytes[base + 3] & 255
            val word = ((vb0 << 24) | (vb1 << 16) | (vb2 << 8) | vb3) & mask32
            w = array.push(w, word)
            wi = wi + 1

        wi = 16
        while wi < 64:
            val w15 = w[wi - 15] & mask32
            val w2 = w[wi - 2] & mask32
            val r7 = ((w15 >> 7) | (w15 << 25)) & mask32
            val r18 = ((w15 >> 18) | (w15 << 14)) & mask32
            val sh3 = (w15 >> 3) & mask32
            val s0 = (r7 ^ r18 ^ sh3) & mask32
            val r17 = ((w2 >> 17) | (w2 << 15)) & mask32
            val r19 = ((w2 >> 19) | (w2 << 13)) & mask32
            val sh10 = (w2 >> 10) & mask32
            val s1 = (r17 ^ r19 ^ sh10) & mask32
            val new_w = (w[wi - 16] + s0 + w[wi - 7] + s1) & mask32
            w = array.push(w, new_w)
            wi = wi + 1

        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var hv = h7

        var ri = 0
        while ri < 64:
            val ea = e & mask32
            val er6 = ((ea >> 6) | (ea << 26)) & mask32
            val er11 = ((ea >> 11) | (ea << 21)) & mask32
            val er25 = ((ea >> 25) | (ea << 7)) & mask32
            val big_s1 = (er6 ^ er11 ^ er25) & mask32
            val ch = ((ea & (f & mask32)) ^ ((~ea & mask32) & (g & mask32))) & mask32
            val temp1 = (hv + big_s1 + ch + kk[ri] + w[ri]) & mask32

            val aa = a & mask32
            val ar2 = ((aa >> 2) | (aa << 30)) & mask32
            val ar13 = ((aa >> 13) | (aa << 19)) & mask32
            val ar22 = ((aa >> 22) | (aa << 10)) & mask32
            val big_s0 = (ar2 ^ ar13 ^ ar22) & mask32
            val maj = ((aa & (b & mask32)) ^ (aa & (c & mask32)) ^ ((b & mask32) & (c & mask32))) & mask32
            val temp2 = (big_s0 + maj) & mask32

            hv = g
            g = f
            f = e
            e = (d + temp1) & mask32
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & mask32
            ri = ri + 1

        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        h5 = (h5 + f) & mask32
        h6 = (h6 + g) & mask32
        h7 = (h7 + hv) & mask32

        block_off = block_off + 64

    # Convert to hex string
    val hex_chars = "0123456789abcdef"
    var result = ""
    var h_vals = [h0, h1, h2, h3, h4, h5, h6, h7]
    var hi = 0
    while hi < 8:
        val word = h_vals[hi] & mask32
        var nibble_idx = 7
        while nibble_idx >= 0:
            val nibble = (word >> (nibble_idx * 4)) & 15
            val hex_char = string.char_at(hex_chars, nibble)
            result = string.concat(result, hex_char)
            nibble_idx = nibble_idx - 1
        hi = hi + 1

    result

# Convert i64 to hex
fn i64_to_hex(value: i64) -> text:
    val hex_chars = "0123456789abcdef"
    var result = ""
    var num = value

    if num == 0:
        return "00"

    while num > 0:
        val digit = num % 16
        val char = string.char_at(hex_chars, digit)
        result = string.concat(char, result)
        num = num / 16

    # Pad to 2 characters
    while string.length(result) < 2:
        result = string.concat("0", result)

    result

# Base64 URL encode (simplified)
fn base64url_encode(input: text) -> text:
    # In production, use proper base64url encoding
    # This is a simplified mock
    var result = input
    result = string.replace(result, "+", "-")
    result = string.replace(result, "/", "_")
    result = string.replace(result, "=", "")
    result

# Percent encode character
fn percent_encode_char(char: text) -> text:
    val code = string.char_code(char)
    val hex = i64_to_hex(code)
    string.concat("%", hex)

# Extract string until delimiter
fn extract_until_delimiter(input: text, delimiters: text) -> text:
    var result = ""
    var i = 0
    val len = string.length(input)

    while i < len:
        val char = string.char_at(input, i)
        val is_delimiter = string.contains(delimiters, char)

        if is_delimiter:
            return result

        result = string.concat(result, char)
        i = i + 1

    result

# Create mock access token for testing
fn create_mock_access_token():
    create_token_now(
        "mock_access_token_" + generate_random_string(32),
        "Bearer",
        3600,
        "mock_refresh_token_" + generate_random_string(32),
        "read write profile"
    )

# ============================================================================
# Error Handling
# ============================================================================

# OAuth error codes (RFC 6749)
fn get_invalid_request_error() -> text:
    "invalid_request"

fn get_invalid_client_error() -> text:
    "invalid_client"

fn get_invalid_grant_error() -> text:
    "invalid_grant"

fn get_unauthorized_client_error() -> text:
    "unauthorized_client"

fn get_unsupported_grant_type_error() -> text:
    "unsupported_grant_type"

fn get_invalid_scope_error() -> text:
    "invalid_scope"

fn get_access_denied_error() -> text:
    "access_denied"

# Create error response
fn create_error_response(error: text, description: text):
    (error, description)

# Get error code from error response
fn get_error_code(error_response):
    error_response.0

# Get error description from error response
fn get_error_description(error_response):
    error_response.1

# ============================================================================
# EXPORTS
# ============================================================================

export url_encode, is_unreserved_char, parse_query_params, get_param_value
export url_decode, build_url_with_params
export get_current_timestamp, random_int, generate_random_string, is_alphanumeric
export array_contains, i64_to_text, text_to_i64, digit_to_char, char_to_digit
export hash_sha256, i64_to_hex, base64url_encode, percent_encode_char
export extract_until_delimiter, create_mock_access_token
export generate_client_id, generate_client_secret, hash_client_secret, verify_client_secret
export get_invalid_request_error, get_invalid_client_error, get_invalid_grant_error
export get_unauthorized_client_error, get_unsupported_grant_type_error
export get_invalid_scope_error, get_access_denied_error
export create_error_response, get_error_code, get_error_description
