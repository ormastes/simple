# Numerical Integration
#
# Purpose: Numerical quadrature methods for definite integrals
#
# Contains:
# - Trapezoidal rule (O(h²) error)
# - Simpson's rules (1/3 and 3/8, O(h⁴) error)
# - Romberg integration (Richardson extrapolation)
# - Gaussian quadrature (2-point and 3-point)
# - Adaptive Simpson (recursive subdivision)
# - Monte Carlo integration (random sampling)

fn nm_trapezoidal(f, a: f64, b: f64, n: i64) -> f64:
    """Integrate using trapezoidal rule.

    Divides interval into n subintervals and approximates with trapezoids.
    Error is O(h^2) where h = (b-a)/n.

    Example:
        nm_trapezoidal(lambda x: x*x, 0.0, 1.0, 100)  # Integral of x^2 from 0 to 1
    """
    if n <= 0:
        return 0.0

    val h = (b - a) / n
    var sum = (f(a) + f(b)) / 2.0

    var i = 1
    while i < n:
        val x = a + i * h
        sum = sum + f(x)
        i = i + 1

    sum * h

fn nm_simpson(f, a: f64, b: f64, n: i64) -> f64:
    """Integrate using Simpson's 1/3 rule.

    Requires n to be even. Uses quadratic interpolation.
    Error is O(h^4) where h = (b-a)/n.

    Example:
        nm_simpson(lambda x: x*x, 0.0, 1.0, 100)
    """
    var n_adjusted = n
    if n % 2 == 1:
        n_adjusted = n + 1

    if n_adjusted <= 0:
        return 0.0

    val h = (b - a) / n_adjusted
    var sum = f(a) + f(b)

    var i = 1
    while i < n_adjusted:
        val x = a + i * h
        val factor = if i % 2 == 0: 2.0 else: 4.0
        sum = sum + factor * f(x)
        i = i + 1

    sum * h / 3.0

fn nm_simpson_three_eighths(f, a: f64, b: f64, n: i64) -> f64:
    """Integrate using Simpson's 3/8 rule.

    Requires n to be divisible by 3. Uses cubic interpolation.

    Example:
        nm_simpson_three_eighths(lambda x: x*x*x, 0.0, 1.0, 99)
    """
    var n_adjusted = n
    while n_adjusted % 3 != 0:
        n_adjusted = n_adjusted + 1

    if n_adjusted <= 0:
        return 0.0

    val h = (b - a) / n_adjusted
    var sum = f(a) + f(b)

    var i = 1
    while i < n_adjusted:
        val x = a + i * h
        val factor = if i % 3 == 0: 2.0 else: 3.0
        sum = sum + factor * f(x)
        i = i + 1

    sum * 3.0 * h / 8.0

fn nm_romberg_integration(f, a: f64, b: f64, max_level: i64) -> f64:
    """Integrate using Romberg integration.

    Uses Richardson extrapolation on trapezoidal rule results.
    Very accurate for smooth functions.

    Example:
        nm_romberg_integration(lambda x: x*x, 0.0, 1.0, 5)
    """
    if max_level <= 0:
        return nm_trapezoidal(f, a, b, 1)

    var table = []
    var level = 0
    while level <= max_level:
        var row = []
        var col = 0
        while col <= level:
            row.push(0.0)
            col = col + 1
        table.push(row)
        level = level + 1

    var k = 0
    while k <= max_level:
        val n = 1
        var n_intervals = n
        var i = 0
        while i < k:
            n_intervals = n_intervals * 2
            i = i + 1

        table[k][0] = nm_trapezoidal(f, a, b, n_intervals)

        var m = 1
        while m <= k:
            val factor = 1.0
            var power = 1.0
            var p = 0
            while p < m:
                power = power * 4.0
                p = p + 1

            val numerator = power * table[k][m - 1] - table[k - 1][m - 1]
            val denominator = power - 1.0
            table[k][m] = numerator / denominator
            m = m + 1

        k = k + 1

    table[max_level][max_level]

fn nm_gaussian_quadrature_2point(f, a: f64, b: f64) -> f64:
    """Integrate using 2-point Gaussian quadrature.

    Exact for polynomials up to degree 3.

    Example:
        nm_gaussian_quadrature_2point(lambda x: x*x, 0.0, 1.0)
    """
    val mid = (a + b) / 2.0
    val half_width = (b - a) / 2.0

    val sqrt3_inv = 0.57735026918962576
    val x1 = mid - half_width * sqrt3_inv
    val x2 = mid + half_width * sqrt3_inv

    (f(x1) + f(x2)) * half_width

fn nm_gaussian_quadrature_3point(f, a: f64, b: f64) -> f64:
    """Integrate using 3-point Gaussian quadrature.

    Exact for polynomials up to degree 5.

    Example:
        nm_gaussian_quadrature_3point(lambda x: x*x*x, 0.0, 1.0)
    """
    val mid = (a + b) / 2.0
    val half_width = (b - a) / 2.0

    val sqrt3_5 = 0.7745966692414834
    val w1 = 0.5555555555555556
    val w2 = 0.8888888888888888

    val x1 = mid - half_width * sqrt3_5
    val x2 = mid
    val x3 = mid + half_width * sqrt3_5

    (w1 * f(x1) + w2 * f(x2) + w1 * f(x3)) * half_width

fn nm_adaptive_simpson(f, a: f64, b: f64, tolerance: f64, max_depth: i64) -> f64:
    """Integrate using adaptive Simpson's rule.

    Recursively subdivides intervals where error is large.
    More efficient than uniform grid for varying smoothness.

    Example:
        nm_adaptive_simpson(lambda x: x*x, 0.0, 1.0, 1e-6, 10)
    """
    val mid = (a + b) / 2.0
    val h = (b - a) / 6.0

    val fa = f(a)
    val fm = f(mid)
    val fb = f(b)

    val s_full = h * (fa + 4.0 * fm + fb)

    nm_adaptive_simpson_recursive(f, a, b, tolerance, s_full, fa, fm, fb, max_depth)

fn nm_adaptive_simpson_recursive(f, a: f64, b: f64, tol: f64, s_full: f64, fa: f64, fm: f64, fb: f64, depth: i64) -> f64:
    """Helper for adaptive Simpson integration."""
    if depth <= 0:
        return s_full

    val mid = (a + b) / 2.0
    val h = (b - a) / 12.0

    val f_left = f((a + mid) / 2.0)
    val f_right = f((mid + b) / 2.0)

    val s_left = h * (fa + 4.0 * f_left + fm)
    val s_right = h * (fm + 4.0 * f_right + fb)
    val s_combined = s_left + s_right

    val error = s_combined - s_full
    var abs_error = error
    if abs_error < 0.0:
        abs_error = -abs_error

    if abs_error < 15.0 * tol:
        return s_combined + error / 15.0

    val left_part = nm_adaptive_simpson_recursive(f, a, mid, tol / 2.0, s_left, fa, f_left, fm, depth - 1)
    val right_part = nm_adaptive_simpson_recursive(f, mid, b, tol / 2.0, s_right, fm, f_right, fb, depth - 1)

    left_part + right_part

fn nm_monte_carlo_integration(f, a: f64, b: f64, n: i64, seed: i64) -> f64:
    """Integrate using Monte Carlo method.

    Uses random sampling. Convergence is O(1/√n).
    Useful for high-dimensional integrals.

    Example:
        nm_monte_carlo_integration(lambda x: x*x, 0.0, 1.0, 10000, 42)
    """
    if n <= 0:
        return 0.0

    var sum = 0.0
    var rng_state = seed

    var i = 0
    while i < n:
        rng_state = (rng_state * 1103515245 + 12345) % 2147483648
        val u = rng_state / 2147483648.0
        val x = a + u * (b - a)
        sum = sum + f(x)
        i = i + 1

    (b - a) * sum / n

export *
