# Lazy Evaluation Utilities
#
# Additional utility functions:
# - Memoization helpers (nullary, unary, binary)

# ============================================================================
# Exports
# ============================================================================

export memoize_nullary, memoize_unary, memoize_binary

# ============================================================================
# Memoization Helpers
# ============================================================================

fn memoize_nullary(f):
    """Memoize a nullary function (no arguments).

    Returns a new function that caches the result of first call.

    Example:
        var call_count = 0
        val expensive = \: (call_count = call_count + 1, 42)[1]
        val memoized = memoize_nullary(expensive)
        memoized()  # call_count = 1, returns 42
        memoized()  # call_count = 1, returns 42 (cached)
    """
    val cache = {"computed": false, "value": nil}

    \: if cache["computed"]:
        cache["value"]
    else:
        val result = f()
        cache["computed"] = true
        cache["value"] = result
        result

fn memoize_unary(f):
    """Memoize a unary function (one argument).

    Returns a new function that caches results by argument value.

    Example:
        var call_count = 0
        val expensive = \x: (call_count = call_count + 1, x * x)[1]
        val memoized = memoize_unary(expensive)
        memoized(5)  # call_count = 1, returns 25
        memoized(5)  # call_count = 1, returns 25 (cached)
    """
    val cache = {}

    \x:
        val key = "{x}"
        if cache.contains(key):
            cache[key]
        else:
            val result = f(x)
            cache[key] = result
            result

fn memoize_binary(f):
    """Memoize a binary function (two arguments).

    Returns a new function that caches results by argument pair.

    Example:
        var call_count = 0
        val expensive = \x, y: (call_count = call_count + 1, x + y)[1]
        val memoized = memoize_binary(expensive)
        memoized(3, 4)  # call_count = 1, returns 7
        memoized(3, 4)  # call_count = 1, returns 7 (cached)
    """
    val cache = {}

    \x, y:
        val key = "{x},{y}"
        if cache.contains(key):
            cache[key]
        else:
            val result = f(x, y)
            cache[key] = result
            result
