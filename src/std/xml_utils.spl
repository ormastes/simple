# XML Parsing and Generation Module
# Provides comprehensive XML parsing, generation, and manipulation utilities

# =============================================================================
# Data Structures
# =============================================================================

# XmlElement: (tag: text, attributes: List<(text, text)>, children: List<XmlElement>, text: text)
# Using tuple format to avoid runtime generics issues

# XmlToken: (type: text, value: text, line: i64, col: i64)
# Token types: "open_tag", "close_tag", "text", "cdata", "comment", "pi", "doctype"

# Namespace: (prefix: text, uri: text)

# =============================================================================
# Core Element Creation
# =============================================================================

fn xml_element(tag: text, attributes: list, children: list, text_content: text) -> tuple:
    # Create a new XML element
    (tag, attributes, children, text_content)

fn xml_element_simple(tag: text) -> tuple:
    # Create a simple element with no attributes, children, or text
    val empty_attrs = []
    val empty_children = []
    xml_element(tag, empty_attrs, empty_children, "")

fn xml_element_with_text(tag: text, text_content: text) -> tuple:
    # Create an element with text content
    val empty_attrs = []
    val empty_children = []
    xml_element(tag, empty_attrs, empty_children, text_content)

fn xml_element_with_attrs(tag: text, attributes: list) -> tuple:
    # Create an element with attributes
    val empty_children = []
    xml_element(tag, attributes, empty_children, "")

fn xml_element_with_children(tag: text, children: list) -> tuple:
    # Create an element with children
    val empty_attrs = []
    xml_element(tag, empty_attrs, children, "")

# =============================================================================
# Element Accessors
# =============================================================================

fn xml_get_tag(element: tuple) -> text:
    # Get the tag name from an element
    element.0

fn xml_get_attributes(element: tuple) -> list:
    # Get all attributes from an element
    element.1

fn xml_get_children(element: tuple) -> list:
    # Get all children from an element
    element.2

fn xml_get_text(element: tuple) -> text:
    # Get the text content from an element
    element.3

fn xml_set_tag(element: tuple, new_tag: text) -> tuple:
    # Set a new tag name
    val attrs = xml_get_attributes(element)
    val children = xml_get_children(element)
    val text_val = xml_get_text(element)
    xml_element(new_tag, attrs, children, text_val)

fn xml_set_attributes(element: tuple, new_attrs: list) -> tuple:
    # Set new attributes
    val tag = xml_get_tag(element)
    val children = xml_get_children(element)
    val text_val = xml_get_text(element)
    xml_element(tag, new_attrs, children, text_val)

fn xml_set_children(element: tuple, new_children: list) -> tuple:
    # Set new children
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val text_val = xml_get_text(element)
    xml_element(tag, attrs, new_children, text_val)

fn xml_set_text(element: tuple, new_text: text) -> tuple:
    # Set new text content
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val children = xml_get_children(element)
    xml_element(tag, attrs, children, new_text)

# =============================================================================
# Attribute Operations
# =============================================================================

fn xml_get_attr(element: tuple, attr_name: text) -> text:
    # Get an attribute value by name, returns empty string if not found
    val attrs = xml_get_attributes(element)
    var result = ""
    var i = 0
    val len = attrs.len()
    var found = false

    while i < len and not found:
        val attr = attrs[i]
        val name = attr.0
        val value = attr.1
        if name == attr_name:
            result = value
            found = true
        i = i + 1

    result

fn xml_has_attr(element: tuple, attr_name: text) -> bool:
    # Check if an element has a specific attribute
    val attrs = xml_get_attributes(element)
    var i = 0
    val len = attrs.len()
    var found = false

    while i < len and not found:
        val attr = attrs[i]
        val name = attr.0
        if name == attr_name:
            found = true
        i = i + 1

    found

fn xml_set_attr(element: tuple, attr_name: text, attr_value: text) -> tuple:
    # Set or update an attribute
    val old_attrs = xml_get_attributes(element)
    var new_attrs = []
    var i = 0
    val len = old_attrs.len()
    var found = false

    # Update existing or collect others
    while i < len:
        val attr = old_attrs[i]
        val name = attr.0
        val value = attr.1
        if name == attr_name:
            new_attrs = new_attrs.append((attr_name, attr_value))
            found = true
        else:
            new_attrs = new_attrs.append(attr)
        i = i + 1

    # Add new if not found
    if not found:
        new_attrs = new_attrs.append((attr_name, attr_value))

    xml_set_attributes(element, new_attrs)

fn xml_remove_attr(element: tuple, attr_name: text) -> tuple:
    # Remove an attribute by name
    val old_attrs = xml_get_attributes(element)
    var new_attrs = []
    var i = 0
    val len = old_attrs.len()

    while i < len:
        val attr = old_attrs[i]
        val name = attr.0
        val value = attr.1
        if name != attr_name:
            new_attrs = new_attrs.append(attr)
        i = i + 1

    xml_set_attributes(element, new_attrs)

fn xml_clear_attrs(element: tuple) -> tuple:
    # Remove all attributes
    val empty_attrs = []
    xml_set_attributes(element, empty_attrs)

fn xml_get_attr_names(element: tuple) -> list:
    # Get all attribute names
    val attrs = xml_get_attributes(element)
    var names = []
    var i = 0
    val len = attrs.len()

    while i < len:
        val attr = attrs[i]
        val name = attr.0
        names = names.append(name)
        i = i + 1

    names

fn xml_get_attr_count(element: tuple) -> i64:
    # Get the number of attributes
    val attrs = xml_get_attributes(element)
    attrs.len()

# =============================================================================
# Child Operations
# =============================================================================

fn xml_add_child(element: tuple, child: tuple) -> tuple:
    # Add a child element
    val children = xml_get_children(element)
    val new_children = children.append(child)
    xml_set_children(element, new_children)

fn xml_prepend_child(element: tuple, child: tuple) -> tuple:
    # Add a child at the beginning
    val children = xml_get_children(element)
    var new_children = [child]
    var i = 0
    val len = children.len()

    while i < len:
        new_children = new_children.append(children[i])
        i = i + 1

    xml_set_children(element, new_children)

fn xml_remove_child(element: tuple, index: i64) -> tuple:
    # Remove a child by index
    val children = xml_get_children(element)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        if i != index:
            new_children = new_children.append(children[i])
        i = i + 1

    xml_set_children(element, new_children)

fn xml_get_child(element: tuple, index: i64) -> tuple:
    # Get a child by index
    val children = xml_get_children(element)
    children[index]

fn xml_get_child_count(element: tuple) -> i64:
    # Get the number of children
    val children = xml_get_children(element)
    children.len()

fn xml_clear_children(element: tuple) -> tuple:
    # Remove all children
    val empty_children = []
    xml_set_children(element, empty_children)

fn xml_has_children(element: tuple) -> bool:
    # Check if element has children
    val count = xml_get_child_count(element)
    count > 0

# =============================================================================
# Text Content Operations
# =============================================================================

fn xml_get_all_text(element: tuple) -> text:
    # Get all text content including from children
    var result = xml_get_text(element)
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_text = xml_get_all_text(child)
        result = result + child_text
        i = i + 1

    result

fn xml_append_text(element: tuple, additional_text: text) -> tuple:
    # Append text to existing text content
    val current = xml_get_text(element)
    val new_text = current + additional_text
    xml_set_text(element, new_text)

fn xml_has_text(element: tuple) -> bool:
    # Check if element has text content
    val text_val = xml_get_text(element)
    text_val.len() > 0

fn xml_is_empty(element: tuple) -> bool:
    # Check if element has no text and no children
    val has_text_val = xml_has_text(element)
    val has_children_val = xml_has_children(element)
    var is_empty_val = false
    if not has_text_val and not has_children_val:
        is_empty_val = true
    is_empty_val

# =============================================================================
# Entity Encoding/Decoding
# =============================================================================

fn xml_encode_entities(text_val: text) -> text:
    # Encode XML entities
    var result = text_val
    result = result.replace("&", "&amp;")
    result = result.replace("<", "&lt;")
    result = result.replace(">", "&gt;")
    result = result.replace("\"", "&quot;")
    result = result.replace("'", "&apos;")
    result

fn xml_decode_entities(text_val: text) -> text:
    # Decode XML entities
    var result = text_val
    result = result.replace("&lt;", "<")
    result = result.replace("&gt;", ">")
    result = result.replace("&quot;", "\"")
    result = result.replace("&apos;", "'")
    result = result.replace("&amp;", "&")
    result

fn xml_encode_attr_value(text_val: text) -> text:
    # Encode attribute value (includes quotes)
    xml_encode_entities(text_val)

fn xml_decode_attr_value(text_val: text) -> text:
    # Decode attribute value
    xml_decode_entities(text_val)

# =============================================================================
# Serialization
# =============================================================================

fn xml_to_string(element: tuple) -> text:
    # Convert element to XML string
    xml_to_string_indent(element, 0, false)

fn xml_to_string_pretty(element: tuple) -> text:
    # Convert element to pretty-printed XML string
    xml_to_string_indent(element, 0, true)

fn xml_to_string_indent(element: tuple, indent_level: i64, pretty: bool) -> text:
    # Convert element to XML string with indentation
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val children = xml_get_children(element)
    val text_val = xml_get_text(element)

    # Build indent string
    var indent = ""
    if pretty:
        var i = 0
        while i < indent_level:
            indent = indent + "  "
            i = i + 1

    # Build opening tag
    var result = indent + "<" + tag

    # Add attributes
    var i = 0
    val attr_len = attrs.len()
    while i < attr_len:
        val attr = attrs[i]
        val name = attr.0
        val value = attr.1
        val encoded_value = xml_encode_attr_value(value)
        result = result + " " + name + "=\"" + encoded_value + "\""
        i = i + 1

    # Check if self-closing
    val has_content = xml_has_text(element)
    val has_kids = xml_has_children(element)
    var is_self_closing = false
    if not has_content and not has_kids:
        is_self_closing = true

    if is_self_closing:
        result = result + " />"
        if pretty:
            result = result + "\n"
    else:
        result = result + ">"

        # Add text content
        if has_content:
            val encoded_text = xml_encode_entities(text_val)
            result = result + encoded_text

        # Add children
        if has_kids:
            if pretty and not has_content:
                result = result + "\n"

            var j = 0
            val child_len = children.len()
            while j < child_len:
                val child = children[j]
                val next_indent = indent_level + 1
                val child_str = xml_to_string_indent(child, next_indent, pretty)
                result = result + child_str
                j = j + 1

            if pretty and not has_content:
                result = result + indent

        # Add closing tag
        result = result + "</" + tag + ">"
        if pretty:
            result = result + "\n"

    result

fn xml_format(xml_str: text) -> text:
    # Format XML string with pretty printing
    val elem = xml_parse(xml_str)
    xml_to_string_pretty(elem)

# =============================================================================
# Parsing - Tokenization
# =============================================================================

fn xml_tokenize(xml_str: text) -> list:
    # Tokenize XML string
    var tokens = []
    var i = 0
    val len = xml_str.len()
    var line = 1
    var col = 1

    while i < len:
        val ch = xml_str.slice(i, i + 1)

        if ch == "<":
            # Check for comment, CDATA, or processing instruction
            val remaining = xml_str.slice(i, len)

            if remaining.starts_with("<!--"):
                # Comment
                val end_pos = remaining.index("-->")
                var comment_end = 0
                if end_pos >= 0:
                    comment_end = i + end_pos + 3
                else:
                    comment_end = len

                val comment_text = xml_str.slice(i + 4, comment_end - 3)
                val token = ("comment", comment_text, line, col)
                tokens = tokens.append(token)
                i = comment_end
                col = col + (comment_end - i)
            elif remaining.starts_with("<![CDATA["):
                # CDATA
                val end_pos = remaining.index("]]>")
                var cdata_end = 0
                if end_pos >= 0:
                    cdata_end = i + end_pos + 3
                else:
                    cdata_end = len

                val cdata_text = xml_str.slice(i + 9, cdata_end - 3)
                val token = ("cdata", cdata_text, line, col)
                tokens = tokens.append(token)
                i = cdata_end
                col = col + (cdata_end - i)
            elif remaining.starts_with("<?"):
                # Processing instruction
                val end_pos = remaining.index("?>")
                var pi_end = 0
                if end_pos >= 0:
                    pi_end = i + end_pos + 2
                else:
                    pi_end = len

                val pi_text = xml_str.slice(i + 2, pi_end - 2)
                val token = ("pi", pi_text, line, col)
                tokens = tokens.append(token)
                i = pi_end
                col = col + (pi_end - i)
            elif remaining.starts_with("<!DOCTYPE"):
                # DOCTYPE
                val end_pos = remaining.index(">")
                var doctype_end = 0
                if end_pos >= 0:
                    doctype_end = i + end_pos + 1
                else:
                    doctype_end = len

                val doctype_text = xml_str.slice(i + 9, doctype_end - 1)
                val token = ("doctype", doctype_text, line, col)
                tokens = tokens.append(token)
                i = doctype_end
                col = col + (doctype_end - i)
            elif remaining.starts_with("</"):
                # Closing tag
                val end_pos = remaining.index(">")
                var tag_end = 0
                if end_pos >= 0:
                    tag_end = i + end_pos + 1
                else:
                    tag_end = len

                val tag_text = xml_str.slice(i + 2, tag_end - 1)
                val trimmed = tag_text.trim()
                val token = ("close_tag", trimmed, line, col)
                tokens = tokens.append(token)
                i = tag_end
                col = col + (tag_end - i)
            else:
                # Opening tag
                val end_pos = remaining.index(">")
                var tag_end = 0
                if end_pos >= 0:
                    tag_end = i + end_pos + 1
                else:
                    tag_end = len

                val tag_text = xml_str.slice(i + 1, tag_end - 1)
                val token = ("open_tag", tag_text, line, col)
                tokens = tokens.append(token)
                i = tag_end
                col = col + (tag_end - i)
        elif ch == "\n":
            # Newline
            line = line + 1
            col = 1
            i = i + 1
        elif ch == " " or ch == "\t" or ch == "\r":
            # Whitespace
            col = col + 1
            i = i + 1
        else:
            # Text content
            var text_start = i
            var text_val = ""

            while i < len:
                val curr = xml_str.slice(i, i + 1)
                if curr == "<":
                    break
                text_val = text_val + curr
                if curr == "\n":
                    line = line + 1
                    col = 1
                else:
                    col = col + 1
                i = i + 1

            val trimmed_text = text_val.trim()
            if trimmed_text.len() > 0:
                val token = ("text", trimmed_text, line, col)
                tokens = tokens.append(token)

    tokens

# =============================================================================
# Parsing - Tag and Attribute Parsing
# =============================================================================

fn xml_parse_tag(tag_text: text) -> tuple:
    # Parse tag text to extract name, attributes, and self-closing flag
    # Returns: (tag_name, attributes, is_self_closing)

    val trimmed = tag_text.trim()
    var is_self_closing = false
    var working_text = trimmed

    # Check for self-closing
    if trimmed.ends_with("/"):
        is_self_closing = true
        val new_len = trimmed.len() - 1
        working_text = trimmed.slice(0, new_len)
        working_text = working_text.trim()

    # Split by whitespace to separate tag name from attributes
    val parts = working_text.split(" ")
    var tag_name = ""
    if parts.len() > 0:
        tag_name = parts[0]

    # Parse attributes
    var attrs = []
    if parts.len() > 1:
        var i = 1
        val len = parts.len()
        var attr_text = ""

        while i < len:
            attr_text = attr_text + parts[i] + " "
            i = i + 1

        attrs = xml_parse_attributes(attr_text)

    (tag_name, attrs, is_self_closing)

fn xml_parse_attributes(attr_text: text) -> list:
    # Parse attribute string into list of (name, value) pairs
    var attrs = []
    val trimmed = attr_text.trim()

    if trimmed.len() == 0:
        return attrs

    var i = 0
    val len = trimmed.len()

    while i < len:
        # Skip whitespace
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            var is_space = false
            if ch == " " or ch == "\t" or ch == "\n" or ch == "\r":
                is_space = true
            if not is_space:
                break
            i = i + 1

        if i >= len:
            break

        # Read attribute name
        var name = ""
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            var should_break = false
            if ch == "=" or ch == " " or ch == "\t":
                should_break = true
            if should_break:
                break
            name = name + ch
            i = i + 1

        # Skip to equals sign
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            if ch == "=":
                i = i + 1
                break
            i = i + 1

        # Skip whitespace and find quote
        while i < len:
            val ch = trimmed.slice(i, i + 1)
            var is_space = false
            if ch == " " or ch == "\t" or ch == "\n" or ch == "\r":
                is_space = true
            if not is_space:
                break
            i = i + 1

        # Read value
        var value = ""
        var quote_char = ""

        if i < len:
            val ch = trimmed.slice(i, i + 1)
            if ch == "\"" or ch == "'":
                quote_char = ch
                i = i + 1

        while i < len:
            val ch = trimmed.slice(i, i + 1)
            if quote_char.len() > 0:
                if ch == quote_char:
                    i = i + 1
                    break
            else:
                var is_space = false
                if ch == " " or ch == "\t" or ch == "\n" or ch == "\r":
                    is_space = true
                if is_space:
                    break

            value = value + ch
            i = i + 1

        if name.len() > 0:
            val decoded_value = xml_decode_attr_value(value)
            val attr = (name, decoded_value)
            attrs = attrs.append(attr)

    attrs

# =============================================================================
# Parsing - Element Parsing
# =============================================================================

fn xml_parse(xml_str: text) -> tuple:
    # Parse XML string to element
    val tokens = xml_tokenize(xml_str)
    val result = xml_parse_tokens(tokens, 0)
    result.0

fn xml_parse_tokens(tokens: list, start_index: i64) -> tuple:
    # Parse tokens starting at index, return (element, next_index)
    var i = start_index
    val len = tokens.len()

    # Skip non-tag tokens
    while i < len:
        val token = tokens[i]
        val token_type = token.0
        var is_open = false
        if token_type == "open_tag":
            is_open = true
        if is_open:
            break
        i = i + 1

    if i >= len:
        # No element found, return empty
        val empty_elem = xml_element_simple("")
        return (empty_elem, i)

    # Parse opening tag
    val open_token = tokens[i]
    val tag_text = open_token.1
    val tag_info = xml_parse_tag(tag_text)
    val tag_name = tag_info.0
    val attributes = tag_info.1
    val is_self_closing = tag_info.2

    i = i + 1

    if is_self_closing:
        val elem = xml_element(tag_name, attributes, [], "")
        return (elem, i)

    # Parse children and text
    var children = []
    var text_content = ""

    while i < len:
        val token = tokens[i]
        val token_type = token.0
        val token_value = token.1

        if token_type == "close_tag":
            # Found closing tag
            if token_value == tag_name:
                i = i + 1
                break
            i = i + 1
        elif token_type == "open_tag":
            # Parse child element
            val child_result = xml_parse_tokens(tokens, i)
            val child_elem = child_result.0
            val next_i = child_result.1
            children = children.append(child_elem)
            i = next_i
        elif token_type == "text":
            # Add text content
            text_content = text_content + token_value
            i = i + 1
        elif token_type == "cdata":
            # Add CDATA content
            text_content = text_content + token_value
            i = i + 1
        else:
            # Skip other token types
            i = i + 1

    val elem = xml_element(tag_name, attributes, children, text_content)
    (elem, i)

# =============================================================================
# Querying - Find Operations
# =============================================================================

fn xml_find_by_tag(element: tuple, tag_name: text) -> list:
    # Find all descendant elements with matching tag name
    var results = []
    val elem_tag = xml_get_tag(element)

    if elem_tag == tag_name:
        results = results.append(element)

    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_results = xml_find_by_tag(child, tag_name)
        var j = 0
        val child_len = child_results.len()

        while j < child_len:
            results = results.append(child_results[j])
            j = j + 1

        i = i + 1

    results

fn xml_find_first_by_tag(element: tuple, tag_name: text) -> tuple:
    # Find first descendant element with matching tag name
    val results = xml_find_by_tag(element, tag_name)
    var first_elem = xml_element_simple("")

    if results.len() > 0:
        first_elem = results[0]

    first_elem

fn xml_find_by_attr(element: tuple, attr_name: text, attr_value: text) -> list:
    # Find all descendant elements with matching attribute
    var results = []
    val elem_attr = xml_get_attr(element, attr_name)

    if elem_attr == attr_value:
        results = results.append(element)

    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_results = xml_find_by_attr(child, attr_name, attr_value)
        var j = 0
        val child_len = child_results.len()

        while j < child_len:
            results = results.append(child_results[j])
            j = j + 1

        i = i + 1

    results

fn xml_find_first_by_attr(element: tuple, attr_name: text, attr_value: text) -> tuple:
    # Find first descendant element with matching attribute
    val results = xml_find_by_attr(element, attr_name, attr_value)
    var first_elem = xml_element_simple("")

    if results.len() > 0:
        first_elem = results[0]

    first_elem

fn xml_get_descendants(element: tuple) -> list:
    # Get all descendant elements
    var results = []
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        results = results.append(child)

        val child_descendants = xml_get_descendants(child)
        var j = 0
        val desc_len = child_descendants.len()

        while j < desc_len:
            results = results.append(child_descendants[j])
            j = j + 1

        i = i + 1

    results

fn xml_filter_by_tag(elements: list, tag_name: text) -> list:
    # Filter list of elements by tag name
    var results = []
    var i = 0
    val len = elements.len()

    while i < len:
        val elem = elements[i]
        val elem_tag = xml_get_tag(elem)

        if elem_tag == tag_name:
            results = results.append(elem)

        i = i + 1

    results

# =============================================================================
# XPath-like Simple Query
# =============================================================================

fn xml_query(element: tuple, path: text) -> list:
    # Simple XPath-like query
    # Supports: "//tag", "tag", "tag[@attr='value']", "tag/child"

    var results = []

    # Check for descendant search
    if path.starts_with("//"):
        val tag_part = path.slice(2, path.len())
        val bracket_pos = tag_part.index("[")

        var tag_name = tag_part
        var attr_filter = ""

        if bracket_pos >= 0:
            tag_name = tag_part.slice(0, bracket_pos)
            val bracket_end = tag_part.index("]")
            var filter_len = 0
            if bracket_end >= 0:
                filter_len = bracket_end
            else:
                filter_len = tag_part.len()
            attr_filter = tag_part.slice(bracket_pos + 1, filter_len)

        results = xml_find_by_tag(element, tag_name)

        # Apply attribute filter
        if attr_filter.len() > 0:
            val attr_parts = xml_parse_attr_filter(attr_filter)
            val attr_name = attr_parts.0
            val attr_value = attr_parts.1
            results = xml_filter_by_attr_value(results, attr_name, attr_value)
    elif path.contains("/"):
        # Path navigation
        val parts = path.split("/")
        var current = [element]
        var i = 0
        val len = parts.len()

        while i < len:
            val part = parts[i]
            var next_elements = []
            var j = 0
            val curr_len = current.len()

            while j < curr_len:
                val elem = current[j]
                val children = xml_get_children(elem)
                val filtered = xml_filter_by_tag(children, part)
                var k = 0
                val filt_len = filtered.len()

                while k < filt_len:
                    next_elements = next_elements.append(filtered[k])
                    k = k + 1

                j = j + 1

            current = next_elements
            i = i + 1

        results = current
    else:
        # Direct child search
        val children = xml_get_children(element)
        results = xml_filter_by_tag(children, path)

    results

fn xml_parse_attr_filter(filter_str: text) -> tuple:
    # Parse attribute filter like "@id='123'"
    # Returns: (attr_name, attr_value)

    var attr_name = ""
    var attr_value = ""

    if filter_str.starts_with("@"):
        val without_at = filter_str.slice(1, filter_str.len())
        val eq_pos = without_at.index("=")

        if eq_pos >= 0:
            attr_name = without_at.slice(0, eq_pos)
            val value_part = without_at.slice(eq_pos + 1, without_at.len())

            # Remove quotes
            var clean_value = value_part
            if value_part.starts_with("'") or value_part.starts_with("\""):
                clean_value = value_part.slice(1, value_part.len())
            if clean_value.ends_with("'") or clean_value.ends_with("\""):
                val new_len = clean_value.len() - 1
                clean_value = clean_value.slice(0, new_len)

            attr_value = clean_value

    (attr_name, attr_value)

fn xml_filter_by_attr_value(elements: list, attr_name: text, attr_value: text) -> list:
    # Filter elements by attribute value
    var results = []
    var i = 0
    val len = elements.len()

    while i < len:
        val elem = elements[i]
        val elem_attr = xml_get_attr(elem, attr_name)

        if elem_attr == attr_value:
            results = results.append(elem)

        i = i + 1

    results

fn xml_query_first(element: tuple, path: text) -> tuple:
    # Get first element matching query
    val results = xml_query(element, path)
    var first_elem = xml_element_simple("")

    if results.len() > 0:
        first_elem = results[0]

    first_elem

# =============================================================================
# Namespace Support
# =============================================================================

fn xml_create_namespace(prefix: text, uri: text) -> tuple:
    # Create a namespace tuple
    (prefix, uri)

fn xml_get_namespace_prefix(ns: tuple) -> text:
    # Get namespace prefix
    ns.0

fn xml_get_namespace_uri(ns: tuple) -> text:
    # Get namespace URI
    ns.1

fn xml_set_namespace(element: tuple, ns: tuple) -> tuple:
    # Set namespace on element
    val prefix = xml_get_namespace_prefix(ns)
    val uri = xml_get_namespace_uri(ns)
    val attr_name = "xmlns:" + prefix
    xml_set_attr(element, attr_name, uri)

fn xml_get_qualified_name(prefix: text, local_name: text) -> text:
    # Get qualified name with namespace prefix
    var qname = local_name
    if prefix.len() > 0:
        qname = prefix + ":" + local_name
    qname

fn xml_split_qualified_name(qname: text) -> tuple:
    # Split qualified name into (prefix, local_name)
    val colon_pos = qname.index(":")
    var prefix = ""
    var local_name = qname

    if colon_pos >= 0:
        prefix = qname.slice(0, colon_pos)
        local_name = qname.slice(colon_pos + 1, qname.len())

    (prefix, local_name)

fn xml_has_namespace(element: tuple, prefix: text) -> bool:
    # Check if element has namespace declaration
    val attr_name = "xmlns:" + prefix
    xml_has_attr(element, attr_name)

# =============================================================================
# Validation
# =============================================================================

fn xml_is_well_formed(xml_str: text) -> bool:
    # Check if XML string is well-formed
    val tokens = xml_tokenize(xml_str)
    xml_validate_tokens(tokens)

fn xml_validate_tokens(tokens: list) -> bool:
    # Validate token structure
    var tag_stack = []
    var i = 0
    val len = tokens.len()
    var is_valid = true

    while i < len and is_valid:
        val token = tokens[i]
        val token_type = token.0
        val token_value = token.1

        if token_type == "open_tag":
            val tag_info = xml_parse_tag(token_value)
            val tag_name = tag_info.0
            val is_self_closing = tag_info.2

            if not is_self_closing:
                tag_stack = tag_stack.append(tag_name)
        elif token_type == "close_tag":
            val stack_len = tag_stack.len()
            if stack_len == 0:
                is_valid = false
            else:
                val expected_tag = tag_stack[stack_len - 1]
                if expected_tag != token_value:
                    is_valid = false
                else:
                    # Pop from stack
                    var new_stack = []
                    var j = 0
                    while j < stack_len - 1:
                        new_stack = new_stack.append(tag_stack[j])
                        j = j + 1
                    tag_stack = new_stack

        i = i + 1

    # Check if all tags are closed
    if tag_stack.len() > 0:
        is_valid = false

    is_valid

fn xml_validate_element(element: tuple) -> bool:
    # Validate element structure
    val tag = xml_get_tag(element)
    var is_valid = true

    # Tag name should not be empty
    if tag.len() == 0:
        is_valid = false

    # Validate children recursively
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len and is_valid:
        val child = children[i]
        val child_valid = xml_validate_element(child)
        if not child_valid:
            is_valid = false
        i = i + 1

    is_valid

# =============================================================================
# Utility Functions
# =============================================================================

fn xml_clone(element: tuple) -> tuple:
    # Deep clone an element
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val text_val = xml_get_text(element)
    val children = xml_get_children(element)

    # Clone attributes
    var cloned_attrs = []
    var i = 0
    val attr_len = attrs.len()

    while i < attr_len:
        val attr = attrs[i]
        cloned_attrs = cloned_attrs.append(attr)
        i = i + 1

    # Clone children
    var cloned_children = []
    var j = 0
    val child_len = children.len()

    while j < child_len:
        val child = children[j]
        val cloned_child = xml_clone(child)
        cloned_children = cloned_children.append(cloned_child)
        j = j + 1

    xml_element(tag, cloned_attrs, cloned_children, text_val)

fn xml_equals(elem1: tuple, elem2: tuple) -> bool:
    # Compare two elements for equality
    val tag1 = xml_get_tag(elem1)
    val tag2 = xml_get_tag(elem2)

    if tag1 != tag2:
        return false

    val text1 = xml_get_text(elem1)
    val text2 = xml_get_text(elem2)

    if text1 != text2:
        return false

    val attrs1 = xml_get_attributes(elem1)
    val attrs2 = xml_get_attributes(elem2)

    if attrs1.len() != attrs2.len():
        return false

    val children1 = xml_get_children(elem1)
    val children2 = xml_get_children(elem2)

    if children1.len() != children2.len():
        return false

    # Compare children
    var i = 0
    val len = children1.len()

    while i < len:
        val child1 = children1[i]
        val child2 = children2[i]
        val are_equal = xml_equals(child1, child2)

        if not are_equal:
            return false

        i = i + 1

    true

fn xml_get_depth(element: tuple) -> i64:
    # Get maximum depth of element tree
    val children = xml_get_children(element)
    var max_depth = 0
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_depth = xml_get_depth(child)

        if child_depth > max_depth:
            max_depth = child_depth

        i = i + 1

    max_depth + 1

fn xml_count_elements(element: tuple) -> i64:
    # Count total number of elements in tree
    var count = 1
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_count = xml_count_elements(child)
        count = count + child_count
        i = i + 1

    count

fn xml_create_cdata(content: text) -> text:
    # Create CDATA section
    "<![CDATA[" + content + "]]>"

fn xml_create_comment(content: text) -> text:
    # Create XML comment
    "<!-- " + content + " -->"

fn xml_create_processing_instruction(target: text, data: text) -> text:
    # Create processing instruction
    "<?" + target + " " + data + "?>"

fn xml_create_declaration(version: text, encoding: text, standalone: text) -> text:
    # Create XML declaration
    var decl = "<?xml version=\"" + version + "\""

    if encoding.len() > 0:
        decl = decl + " encoding=\"" + encoding + "\""

    if standalone.len() > 0:
        decl = decl + " standalone=\"" + standalone + "\""

    decl = decl + "?>"
    decl

# =============================================================================
# Additional Utility Functions
# =============================================================================

fn xml_get_parent_map(root: tuple) -> list:
    # Build a mapping of child to parent relationships
    # Returns list of (child, parent) tuples
    var map = []
    val children = xml_get_children(root)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        map = map.append((child, root))

        # Recursively process children
        val child_map = xml_get_parent_map(child)
        var j = 0
        val child_len = child_map.len()

        while j < child_len:
            map = map.append(child_map[j])
            j = j + 1

        i = i + 1

    map

fn xml_get_siblings(element: tuple, parent: tuple) -> list:
    # Get all sibling elements (excluding the element itself)
    var siblings = []
    val children = xml_get_children(parent)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if not xml_equals(child, element):
            siblings = siblings.append(child)
        i = i + 1

    siblings

fn xml_get_next_sibling(element: tuple, parent: tuple) -> tuple:
    # Get the next sibling element
    val children = xml_get_children(parent)
    var i = 0
    val len = children.len()
    var found = false

    while i < len:
        val child = children[i]
        if found:
            return child
        if xml_equals(child, element):
            found = true
        i = i + 1

    xml_element_simple("")

fn xml_get_prev_sibling(element: tuple, parent: tuple) -> tuple:
    # Get the previous sibling element
    val children = xml_get_children(parent)
    var prev = xml_element_simple("")
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if xml_equals(child, element):
            return prev
        prev = child
        i = i + 1

    xml_element_simple("")

fn xml_insert_before(parent: tuple, new_child: tuple, ref_child: tuple) -> tuple:
    # Insert new child before reference child
    val children = xml_get_children(parent)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if xml_equals(child, ref_child):
            new_children = new_children.append(new_child)
        new_children = new_children.append(child)
        i = i + 1

    xml_set_children(parent, new_children)

fn xml_insert_after(parent: tuple, new_child: tuple, ref_child: tuple) -> tuple:
    # Insert new child after reference child
    val children = xml_get_children(parent)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        new_children = new_children.append(child)
        if xml_equals(child, ref_child):
            new_children = new_children.append(new_child)
        i = i + 1

    xml_set_children(parent, new_children)

fn xml_replace_element(parent: tuple, old_elem: tuple, new_elem: tuple) -> tuple:
    # Replace old element with new element
    val children = xml_get_children(parent)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if xml_equals(child, old_elem):
            new_children = new_children.append(new_elem)
        else:
            new_children = new_children.append(child)
        i = i + 1

    xml_set_children(parent, new_children)

fn xml_is_ancestor(ancestor: tuple, descendant: tuple) -> bool:
    # Check if ancestor is an ancestor of descendant
    val descendants = xml_get_descendants(ancestor)
    var i = 0
    val len = descendants.len()

    while i < len:
        val desc = descendants[i]
        if xml_equals(desc, descendant):
            return true
        i = i + 1

    false

fn xml_get_attribute_value_or_default(element: tuple, attr_name: text, default_value: text) -> text:
    # Get attribute value with default fallback
    val value = xml_get_attr(element, attr_name)
    if value.len() == 0:
        return default_value
    value

fn xml_has_child_with_tag(element: tuple, tag_name: text) -> bool:
    # Check if element has a direct child with specified tag
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_tag = xml_get_tag(child)
        if child_tag == tag_name:
            return true
        i = i + 1

    false

fn xml_count_children_with_tag(element: tuple, tag_name: text) -> i64:
    # Count direct children with specified tag
    val children = xml_get_children(element)
    var count = 0
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_tag = xml_get_tag(child)
        if child_tag == tag_name:
            count = count + 1
        i = i + 1

    count

fn xml_merge_attributes(elem1: tuple, elem2: tuple) -> tuple:
    # Merge attributes from elem2 into elem1 (elem2 takes precedence)
    var result = elem1
    val attrs2 = xml_get_attributes(elem2)
    var i = 0
    val len = attrs2.len()

    while i < len:
        val attr = attrs2[i]
        val name = attr.0
        val value = attr.1
        result = xml_set_attr(result, name, value)
        i = i + 1

    result

fn xml_strip_attributes(element: tuple) -> tuple:
    # Remove all attributes from element and its descendants
    var result = xml_clear_attrs(element)
    val children = xml_get_children(result)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val stripped_child = xml_strip_attributes(child)
        new_children = new_children.append(stripped_child)
        i = i + 1

    xml_set_children(result, new_children)

fn xml_normalize_text(element: tuple) -> tuple:
    # Normalize whitespace in all text content
    val text_val = xml_get_text(element)
    var normalized = text_val.trim()
    normalized = normalized.replace("\n", " ")
    normalized = normalized.replace("\r", " ")
    normalized = normalized.replace("\t", " ")

    # Collapse multiple spaces
    while normalized.contains("  "):
        normalized = normalized.replace("  ", " ")

    var result = xml_set_text(element, normalized)

    # Recursively normalize children
    val children = xml_get_children(result)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val normalized_child = xml_normalize_text(child)
        new_children = new_children.append(normalized_child)
        i = i + 1

    xml_set_children(result, new_children)

fn xml_compact(element: tuple) -> tuple:
    # Remove empty text nodes and normalize whitespace
    var result = element
    val text_val = xml_get_text(result)
    val trimmed = text_val.trim()

    if trimmed.len() == 0:
        result = xml_set_text(result, "")

    # Process children
    val children = xml_get_children(result)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val compacted_child = xml_compact(child)

        # Only add if not empty
        val child_text = xml_get_text(compacted_child)
        val has_kids = xml_has_children(compacted_child)

        if child_text.len() > 0 or has_kids:
            new_children = new_children.append(compacted_child)

        i = i + 1

    xml_set_children(result, new_children)

fn xml_reverse_children(element: tuple) -> tuple:
    # Reverse the order of children
    val children = xml_get_children(element)
    var reversed = []
    var i = children.len() - 1

    while i >= 0:
        reversed = reversed.append(children[i])
        i = i - 1

    xml_set_children(element, reversed)

fn xml_sort_children_by_tag(element: tuple) -> tuple:
    # Sort children alphabetically by tag name (simple bubble sort)
    val children = xml_get_children(element)
    var sorted = children
    val len = sorted.len()
    var i = 0

    while i < len:
        var j = 0
        while j < len - i - 1:
            val tag1 = xml_get_tag(sorted[j])
            val tag2 = xml_get_tag(sorted[j + 1])

            if tag1 > tag2:
                val temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp

            j = j + 1
        i = i + 1

    xml_set_children(element, sorted)

fn xml_flatten(element: tuple) -> list:
    # Flatten element tree to list of elements
    var result = [element]
    val descendants = xml_get_descendants(element)
    var i = 0
    val len = descendants.len()

    while i < len:
        result = result.append(descendants[i])
        i = i + 1

    result

fn xml_to_compact_string(element: tuple) -> text:
    # Convert to string without any whitespace
    val xml_str = xml_to_string(element)
    var compact = xml_str.replace("\n", "")
    compact = compact.replace("\r", "")
    compact = compact.replace("\t", "")

    # Remove spaces between tags
    while compact.contains("> <"):
        compact = compact.replace("> <", "><")

    compact
