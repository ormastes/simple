# Signal Processing Types and Constants
#
# Mathematical constants and basic math utilities for signal processing

# ============================================================================
# CONSTANTS
# ============================================================================

val PI = 3.141592653589793
val TWO_PI = 6.283185307179586
val HALF_PI = 1.5707963267948966

# ============================================================================
# BASIC MATH UTILITIES
# ============================================================================

fn abs_f64(x: f64) -> f64:
    if x < 0.0:
        return 0.0 - x
    return x

fn sqrt_f64(x: f64) -> f64:
    # Newton-Raphson method for square root
    if x < 0.0:
        return 0.0
    if x == 0.0:
        return 0.0

    var guess = x / 2.0
    var iteration = 0
    while iteration < 20:
        var next_guess = (guess + x / guess) / 2.0
        var diff = abs_f64(next_guess - guess)
        if diff < 0.000001:
            return next_guess
        guess = next_guess
        iteration = iteration + 1
    return guess

fn pow_f64(base: f64, exp: f64) -> f64:
    # Simple power function for integer exponents
    if exp == 0.0:
        return 1.0
    if exp == 1.0:
        return base

    var result = 1.0
    var abs_exp = abs_f64(exp)
    var i = 0.0
    while i < abs_exp:
        result = result * base
        i = i + 1.0

    if exp < 0.0:
        return 1.0 / result
    return result

fn sin_f64(x: f64) -> f64:
    # Taylor series approximation for sine
    var norm_x = x
    while norm_x > PI:
        norm_x = norm_x - TWO_PI
    while norm_x < 0.0 - PI:
        norm_x = norm_x + TWO_PI

    var term = norm_x
    var sum = term
    var i = 1
    while i < 15:
        var mult = 0.0 - (norm_x * norm_x)
        var denom = (2 * i) * (2 * i + 1)
        term = term * mult / denom
        sum = sum + term
        i = i + 1
    return sum

fn cos_f64(x: f64) -> f64:
    # cos(x) = sin(x + Ï€/2)
    return sin_f64(x + HALF_PI)

fn tan_f64(x: f64) -> f64:
    var cos_val = cos_f64(x)
    if abs_f64(cos_val) < 0.000001:
        return 0.0
    return sin_f64(x) / cos_val

fn atan_f64(x: f64) -> f64:
    # Approximation for arctangent
    if abs_f64(x) > 1.0:
        var sign = 1.0
        if x < 0.0:
            sign = 0.0 - 1.0
        var inv = 1.0 / x
        return sign * (HALF_PI - atan_f64(inv * sign))

    var x2 = x * x
    var x3 = x2 * x
    var x5 = x3 * x2
    var x7 = x5 * x2
    return x - x3 / 3.0 + x5 / 5.0 - x7 / 7.0

fn atan2_f64(y: f64, x: f64) -> f64:
    if x > 0.0:
        return atan_f64(y / x)
    if x < 0.0:
        if y >= 0.0:
            return atan_f64(y / x) + PI
        return atan_f64(y / x) - PI
    if y > 0.0:
        return HALF_PI
    if y < 0.0:
        return 0.0 - HALF_PI
    return 0.0

fn exp_f64(x: f64) -> f64:
    # Taylor series for e^x
    if x > 50.0:
        return 1.0e20
    if x < 0.0 - 50.0:
        return 0.0

    var sum = 1.0
    var term = 1.0
    var i = 1
    while i < 30:
        term = term * x / i
        sum = sum + term
        i = i + 1
    return sum

fn log_f64(x: f64) -> f64:
    # Natural logarithm using series expansion
    if x <= 0.0:
        return 0.0
    if x == 1.0:
        return 0.0

    # For x near 1, use ln(1+u) series
    if x > 0.5 and x < 1.5:
        var u = x - 1.0
        var u2 = u * u
        var u3 = u2 * u
        var u4 = u3 * u
        var u5 = u4 * u
        return u - u2/2.0 + u3/3.0 - u4/4.0 + u5/5.0

    # For larger x, reduce range
    var exp_count = 0.0
    var reduced = x
    while reduced > 2.0:
        reduced = reduced / 2.0
        exp_count = exp_count + 1.0
    while reduced < 0.5:
        reduced = reduced * 2.0
        exp_count = exp_count - 1.0

    var ln2 = 0.693147180559945
    return log_f64(reduced) + exp_count * ln2

fn log10_f64(x: f64) -> f64:
    var ln10 = 2.302585092994046
    return log_f64(x) / ln10

fn floor_f64(x: f64) -> f64:
    var int_part = x
    if x < 0.0 and x != int_part:
        return int_part - 1.0
    return int_part

fn ceil_f64(x: f64) -> f64:
    var int_part = x
    if x > 0.0 and x != int_part:
        return int_part + 1.0
    return int_part

# ============================================================================
# ARRAY UTILITIES
# ============================================================================

fn array_copy(src: list, dest: list, n: i64):
    var i = 0
    while i < n:
        dest[i] = src[i]
        i = i + 1
    pass

fn array_fill(arr: list, value: f64, n: i64):
    var i = 0
    while i < n:
        arr[i] = value
        i = i + 1
    pass

fn array_add(a: list, b: list, result: list, n: i64):
    var i = 0
    while i < n:
        result[i] = a[i] + b[i]
        i = i + 1
    pass

fn array_multiply(arr: list, scalar: f64, result: list, n: i64):
    var i = 0
    while i < n:
        result[i] = arr[i] * scalar
        i = i + 1
    pass

fn array_max(arr: list, n: i64) -> f64:
    if n == 0:
        return 0.0
    var max_val = arr[0]
    var i = 1
    while i < n:
        if arr[i] > max_val:
            max_val = arr[i]
        i = i + 1
    return max_val

fn array_min(arr: list, n: i64) -> f64:
    if n == 0:
        return 0.0
    var min_val = arr[0]
    var i = 1
    while i < n:
        if arr[i] < min_val:
            min_val = arr[i]
        i = i + 1
    return min_val

fn array_sum(arr: list, n: i64) -> f64:
    var sum = 0.0
    var i = 0
    while i < n:
        sum = sum + arr[i]
        i = i + 1
    return sum

fn array_mean(arr: list, n: i64) -> f64:
    if n == 0:
        return 0.0
    return array_sum(arr, n) / n
