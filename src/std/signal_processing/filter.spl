# Signal Processing - Filter Module
#
# FIR and IIR filter implementations

use signal_processing.types.{PI, TWO_PI, sin_f64, cos_f64, sqrt_f64, pow_f64, abs_f64, array_sum}

# ============================================================================
# FILTERING - FIR FILTERS
# ============================================================================

fn fir_filter(signal: list, sig_len: i64, coeffs: list, num_taps: i64, output: list):
    # Apply FIR filter
    var i = 0
    while i < sig_len:
        var sum = 0.0
        var j = 0
        while j < num_taps:
            var sig_idx = i - j
            if sig_idx >= 0:
                sum = sum + coeffs[j] * signal[sig_idx]
            j = j + 1
        output[i] = sum
        i = i + 1
    pass

fn fir_lowpass_coeffs(cutoff_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR lowpass filter using windowed sinc
    var fc = cutoff_freq / sample_rate
    var mid = (num_taps - 1) / 2.0

    var i = 0
    while i < num_taps:
        var n = i - mid
        if abs_f64(n) < 0.001:
            coeffs[i] = 2.0 * fc
        else:
            var sinc_arg = TWO_PI * fc * n
            coeffs[i] = sin_f64(sinc_arg) / (PI * n)

        # Apply Hamming window
        var phase = TWO_PI * i / (num_taps - 1)
        var window_val = 0.54 - 0.46 * cos_f64(phase)
        coeffs[i] = coeffs[i] * window_val
        i = i + 1

    # Normalize
    var sum = array_sum(coeffs, num_taps)
    if abs_f64(sum) > 0.001:
        i = 0
        while i < num_taps:
            coeffs[i] = coeffs[i] / sum
            i = i + 1
    pass

fn fir_highpass_coeffs(cutoff_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR highpass filter
    fir_lowpass_coeffs(cutoff_freq, sample_rate, num_taps, coeffs)

    # Spectral inversion
    var i = 0
    while i < num_taps:
        coeffs[i] = 0.0 - coeffs[i]
        i = i + 1

    var mid = (num_taps - 1) / 2
    coeffs[mid] = coeffs[mid] + 1.0
    pass

fn fir_bandpass_coeffs(low_freq: f64, high_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR bandpass filter
    var low_coeffs = []
    var high_coeffs = []

    fir_lowpass_coeffs(high_freq, sample_rate, num_taps, high_coeffs)
    fir_lowpass_coeffs(low_freq, sample_rate, num_taps, low_coeffs)

    # Subtract lowpass from lowpass
    var i = 0
    while i < num_taps:
        coeffs[i] = high_coeffs[i] - low_coeffs[i]
        i = i + 1
    pass

fn fir_bandstop_coeffs(low_freq: f64, high_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR bandstop filter
    fir_bandpass_coeffs(low_freq, high_freq, sample_rate, num_taps, coeffs)

    # Spectral inversion
    var i = 0
    while i < num_taps:
        coeffs[i] = 0.0 - coeffs[i]
        i = i + 1

    var mid = (num_taps - 1) / 2
    coeffs[mid] = coeffs[mid] + 1.0
    pass

# ============================================================================
# FILTERING - IIR FILTERS (BIQUAD CASCADE)
# ============================================================================

fn biquad_filter(signal: list, sig_len: i64, b0: f64, b1: f64, b2: f64, a1: f64, a2: f64, output: list):
    # Apply single biquad section
    var x1 = 0.0
    var x2 = 0.0
    var y1 = 0.0
    var y2 = 0.0

    var i = 0
    while i < sig_len:
        var x0 = signal[i]
        var y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2

        output[i] = y0

        x2 = x1
        x1 = x0
        y2 = y1
        y1 = y0
        i = i + 1
    pass

fn butterworth_lowpass_biquad(cutoff_freq: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth lowpass biquad coefficients
    # Returns [b0, b1, b2, a1, a2]
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var alpha = omega_s / (2.0 * 1.414213562373095)  # Q = 1/sqrt(2)

    var a0 = 1.0 + alpha
    coeffs[0] = (1.0 - omega_c) / (2.0 * a0)  # b0
    coeffs[1] = (1.0 - omega_c) / a0           # b1
    coeffs[2] = (1.0 - omega_c) / (2.0 * a0)  # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn butterworth_highpass_biquad(cutoff_freq: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth highpass biquad coefficients
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var alpha = omega_s / (2.0 * 1.414213562373095)

    var a0 = 1.0 + alpha
    coeffs[0] = (1.0 + omega_c) / (2.0 * a0)  # b0
    coeffs[1] = (0.0 - (1.0 + omega_c)) / a0   # b1
    coeffs[2] = (1.0 + omega_c) / (2.0 * a0)  # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn butterworth_bandpass_biquad(center_freq: f64, bandwidth: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth bandpass biquad coefficients
    var omega = TWO_PI * center_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var bw_norm = bandwidth / sample_rate
    var alpha = omega_s * bw_norm

    var a0 = 1.0 + alpha
    coeffs[0] = alpha / a0                     # b0
    coeffs[1] = 0.0                            # b1
    coeffs[2] = (0.0 - alpha) / a0             # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn butterworth_bandstop_biquad(center_freq: f64, bandwidth: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth bandstop (notch) biquad coefficients
    var omega = TWO_PI * center_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var bw_norm = bandwidth / sample_rate
    var alpha = omega_s * bw_norm

    var a0 = 1.0 + alpha
    coeffs[0] = 1.0 / a0                       # b0
    coeffs[1] = (0.0 - 2.0 * omega_c) / a0     # b1
    coeffs[2] = 1.0 / a0                       # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn chebyshev_lowpass_biquad(cutoff_freq: f64, sample_rate: f64, ripple_db: f64, coeffs: list):
    # Design 2nd order Chebyshev Type I lowpass biquad
    # Simplified version with fixed parameters
    var epsilon = sqrt_f64(pow_f64(10.0, ripple_db / 10.0) - 1.0)
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)

    # Simplified calculation
    var alpha = omega_s / 2.0
    var a0 = 1.0 + alpha

    coeffs[0] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[1] = (1.0 - omega_c) / a0
    coeffs[2] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0
    coeffs[4] = (1.0 - alpha) / a0
    pass

fn bessel_lowpass_biquad(cutoff_freq: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Bessel lowpass biquad (approximation)
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)

    # Bessel Q factor for 2nd order
    var q = 0.577350269189626  # 1/sqrt(3)
    var alpha = omega_s / (2.0 * q)

    var a0 = 1.0 + alpha
    coeffs[0] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[1] = (1.0 - omega_c) / a0
    coeffs[2] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0
    coeffs[4] = (1.0 - alpha) / a0
    pass

# ============================================================================
# MOVING FILTERS
# ============================================================================

fn moving_average(signal: list, sig_len: i64, window_size: i64, output: list):
    # Moving average filter
    var i = 0
    while i < sig_len:
        var sum = 0.0
        var count = 0
        var j = 0
        while j < window_size:
            var idx = i - j
            if idx >= 0:
                sum = sum + signal[idx]
                count = count + 1
            j = j + 1
        output[i] = sum / count
        i = i + 1
    pass

fn median_filter(signal: list, sig_len: i64, window_size: i64, output: list):
    # Median filter (simplified - for small windows)
    var temp = []
    var i = 0
    while i < sig_len:
        var count = 0
        var j = 0
        while j < window_size:
            var idx = i - window_size / 2 + j
            if idx >= 0 and idx < sig_len:
                temp[count] = signal[idx]
                count = count + 1
            j = j + 1

        # Simple bubble sort for median
        var k = 0
        while k < count - 1:
            var m = 0
            while m < count - k - 1:
                if temp[m] > temp[m + 1]:
                    var swap = temp[m]
                    temp[m] = temp[m + 1]
                    temp[m + 1] = swap
                m = m + 1
            k = k + 1

        output[i] = temp[count / 2]
        i = i + 1
    pass

fn savitzky_golay_smooth(signal: list, sig_len: i64, window_size: i64, output: list):
    # Savitzky-Golay smoothing filter (quadratic, simplified)
    # Using pre-computed coefficients for common window sizes
    var half_window = window_size / 2

    var i = 0
    while i < sig_len:
        var sum = 0.0
        var norm = 0.0

        var j = 0
        while j < window_size:
            var idx = i - half_window + j
            if idx >= 0 and idx < sig_len:
                # Simplified quadratic coefficients
                var offset = j - half_window
                var coeff = 1.0 - abs_f64(offset) / (half_window + 1.0)
                sum = sum + signal[idx] * coeff
                norm = norm + coeff
            j = j + 1

        if norm > 0.0:
            output[i] = sum / norm
        else:
            output[i] = signal[i]
        i = i + 1
    pass

fn exponential_moving_average(signal: list, sig_len: i64, alpha: f64, output: list):
    # Exponential moving average (EMA)
    if sig_len == 0:
        return pass

    output[0] = signal[0]
    var i = 1
    while i < sig_len:
        output[i] = alpha * signal[i] + (1.0 - alpha) * output[i - 1]
        i = i + 1
    pass
