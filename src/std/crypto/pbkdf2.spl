# PBKDF2 (Password-Based Key Derivation Function 2)
#
# Password-based key derivation using HMAC
# Recommended for password hashing with high iteration count (100,000+)
#
# Supports PBKDF2-HMAC-SHA256 and PBKDF2-HMAC-SHA512

mod crypto.types
mod crypto.hmac

# =============================================================================
# PBKDF2-HMAC-SHA256
# =============================================================================

# PBKDF2-HMAC-SHA256
fn pbkdf2_sha256(password: text, salt: text, iterations: i64) -> list:
    val password_bytes = text_to_bytes(password)
    val salt_bytes = text_to_bytes(salt)
    pbkdf2_sha256_bytes(password_bytes, salt_bytes, iterations, 32)

# PBKDF2-HMAC-SHA256 with byte inputs
fn pbkdf2_sha256_bytes(password_bytes: list, salt_bytes: list, iterations: i64, key_length: i64) -> list:
    val hash_len = 32  # SHA-256 output length
    val blocks_needed = (key_length + hash_len - 1) / hash_len

    var result = []
    var block_num = 1

    while block_num <= blocks_needed:
        # U1 = HMAC(password, salt || INT(block_num))
        var salt_with_block = []
        var i = 0
        while i < salt_bytes.len():
            salt_with_block.push(salt_bytes.get(i))
            i = i + 1

        # Append block number as big-endian 32-bit integer
        salt_with_block.push((block_num >> 24) & 0xFF)
        salt_with_block.push((block_num >> 16) & 0xFF)
        salt_with_block.push((block_num >> 8) & 0xFF)
        salt_with_block.push(block_num & 0xFF)

        var u = hmac_sha256_bytes(password_bytes, salt_with_block)
        var t = []
        i = 0
        while i < u.len():
            t.push(u.get(i))
            i = i + 1

        # Iterate
        var iteration = 1
        while iteration < iterations:
            u = hmac_sha256_bytes(password_bytes, u)
            t = xor_bytes(t, u)
            iteration = iteration + 1

        # Append to result
        i = 0
        while i < t.len():
            result.push(t.get(i))
            i = i + 1

        block_num = block_num + 1

    # Truncate to desired length
    var final_result = []
    var i = 0
    while i < key_length && i < result.len():
        final_result.push(result.get(i))
        i = i + 1

    final_result

# =============================================================================
# PBKDF2-HMAC-SHA512
# =============================================================================

# PBKDF2-HMAC-SHA512
fn pbkdf2_sha512(password: text, salt: text, iterations: i64) -> list:
    val password_bytes = text_to_bytes(password)
    val salt_bytes = text_to_bytes(salt)
    pbkdf2_sha512_bytes(password_bytes, salt_bytes, iterations, 64)

# PBKDF2-HMAC-SHA512 with byte inputs
fn pbkdf2_sha512_bytes(password_bytes: list, salt_bytes: list, iterations: i64, key_length: i64) -> list:
    val hash_len = 64  # SHA-512 output length
    val blocks_needed = (key_length + hash_len - 1) / hash_len

    var result = []
    var block_num = 1

    while block_num <= blocks_needed:
        # U1 = HMAC(password, salt || INT(block_num))
        var salt_with_block = []
        var i = 0
        while i < salt_bytes.len():
            salt_with_block.push(salt_bytes.get(i))
            i = i + 1

        salt_with_block.push((block_num >> 24) & 0xFF)
        salt_with_block.push((block_num >> 16) & 0xFF)
        salt_with_block.push((block_num >> 8) & 0xFF)
        salt_with_block.push(block_num & 0xFF)

        var u = hmac_sha512_bytes(password_bytes, salt_with_block)
        var t = []
        i = 0
        while i < u.len():
            t.push(u.get(i))
            i = i + 1

        # Iterate
        var iteration = 1
        while iteration < iterations:
            u = hmac_sha512_bytes(password_bytes, u)
            t = xor_bytes(t, u)
            iteration = iteration + 1

        # Append to result
        i = 0
        while i < t.len():
            result.push(t.get(i))
            i = i + 1

        block_num = block_num + 1

    # Truncate to desired length
    var final_result = []
    var i = 0
    while i < key_length && i < result.len():
        final_result.push(result.get(i))
        i = i + 1

    final_result

# =============================================================================
# Generic PBKDF2 with algorithm selection
# =============================================================================

# PBKDF2 with algorithm selection
fn pbkdf2_with_algorithm(password: text, salt: text, iterations: i64, algorithm: text) -> list:
    if algorithm == "sha256":
        pbkdf2_sha256(password, salt, iterations)
    else:
        if algorithm == "sha512":
            pbkdf2_sha512(password, salt, iterations)
        else:
            # Default to SHA-256
            pbkdf2_sha256(password, salt, iterations)

# Get recommended iterations for PBKDF2
fn get_recommended_pbkdf2_iterations() -> i64:
    100000
