# Error Handling
#
# Error trait hierarchy with context, backtrace, and conversion support.
# Provides structured error handling for Simple programs.
#
# Components:
# - Error: Base error trait
# - ErrorKind: Common error categories
# - Context: Error context with source chain
# - Backtrace: Stack trace capture
# - Result<T, E> extensions: Error conversion helpers
#
# Usage:
#   fn risky_operation() -> Result<i64, Error>:
#       val value = compute()?
#       Ok(value)
#
# Architecture:
# - Trait-based error hierarchy
# - Source chain tracking
# - Backtrace capture on error creation
# - Zero-cost when errors don't occur

use std.text.{NL}

# ============================================================================
# Error - Base Error Trait
# ============================================================================

trait Error:
    """Base error trait.

    All error types should implement this trait.

    Example:
        struct MyError:
            message: text

        impl Error for MyError:
            fn message() -> text:
                self.message

            fn source() -> Error?:
                nil
    """
    fn message() -> text
    fn source() -> Error?
    fn backtrace() -> Backtrace?

# ============================================================================
# ErrorKind - Common Error Categories
# ============================================================================

enum ErrorKind:
    """Common error categories.

    Provides standard error classifications.

    Example:
        match error.kind():
            case ErrorKind.NotFound:
                print "Resource not found"
            case ErrorKind.PermissionDenied:
                print "Access denied"
    """
    # I/O errors
    NotFound           # Resource not found
    PermissionDenied   # Insufficient permissions
    ConnectionRefused  # Network connection refused
    ConnectionReset    # Connection reset by peer
    Interrupted        # Operation interrupted
    TimedOut           # Operation timed out

    # Data errors
    InvalidInput       # Invalid input data
    InvalidData        # Data format error
    UnexpectedEof      # Unexpected end of file

    # State errors
    AlreadyExists      # Resource already exists
    WouldBlock         # Operation would block

    # Other
    Other              # Other error
    Unknown            # Unknown error

impl ErrorKind:
    fn to_string() -> text:
        """Convert error kind to string.

        Returns:
            Human-readable error kind
        """
        match self:
            case ErrorKind.NotFound: "not found"
            case ErrorKind.PermissionDenied: "permission denied"
            case ErrorKind.ConnectionRefused: "connection refused"
            case ErrorKind.ConnectionReset: "connection reset"
            case ErrorKind.Interrupted: "interrupted"
            case ErrorKind.TimedOut: "timed out"
            case ErrorKind.InvalidInput: "invalid input"
            case ErrorKind.InvalidData: "invalid data"
            case ErrorKind.UnexpectedEof: "unexpected end of file"
            case ErrorKind.AlreadyExists: "already exists"
            case ErrorKind.WouldBlock: "would block"
            case ErrorKind.Other: "other error"
            case ErrorKind.Unknown: "unknown error"

# ============================================================================
# SimpleError - Basic Error Implementation
# ============================================================================

class SimpleError:
    """Simple error with message and kind.

    Basic error implementation for common cases.

    Example:
        val error = SimpleError.new(
            ErrorKind.NotFound,
            "File not found: data.txt"
        )
        return Err(error)
    """
    kind: ErrorKind
    msg: text
    source_error: Error?
    trace: Backtrace?

    static fn new(kind: ErrorKind, message: text) -> SimpleError:
        """Create new simple error.

        Args:
            kind: Error kind
            message: Error message

        Returns:
            Simple error
        """
        val trace = if capture_backtraces():
            Some(Backtrace.capture())
        else:
            nil

        SimpleError(
            kind: kind,
            msg: message,
            source_error: nil,
            trace: trace
        )

    static fn with_source(kind: ErrorKind, message: text, source: Error) -> SimpleError:
        """Create error with source.

        Args:
            kind: Error kind
            message: Error message
            source: Source error

        Returns:
            Simple error with source
        """
        var error = SimpleError.new(kind, message)
        error.source_error = Some(source)
        error

    fn kind() -> ErrorKind:
        """Get error kind.

        Returns:
            Error kind
        """
        self.kind

impl Error for SimpleError:
    fn message() -> text:
        """Get error message."""
        self.msg

    fn source() -> Error?:
        """Get source error."""
        self.source_error

    fn backtrace() -> Backtrace?:
        """Get backtrace."""
        self.trace

# ============================================================================
# Context - Error Context
# ============================================================================

class Context<E>:
    """Error with additional context.

    Wraps an error with additional context information.

    Example:
        fn read_config() -> Result<Config, Context<IoError>>:
            val content = File.read("config.json")
                .context("Failed to read config file")?
            Ok(parse_config(content))
    """
    message: text
    error: E
    trace: Backtrace?

    static fn new(message: text, error: E) -> Context<E>:
        """Create error context.

        Args:
            message: Context message
            error: Underlying error

        Returns:
            Error with context
        """
        val trace = if capture_backtraces():
            Some(Backtrace.capture())
        else:
            nil

        Context(
            message: message,
            error: error,
            trace: trace
        )

    fn inner() -> E:
        """Get inner error.

        Returns:
            Underlying error
        """
        self.error

impl<E> Error for Context<E> where E: Error:
    fn message() -> text:
        """Get context message."""
        "{self.message}: {self.error.message()}"

    fn source() -> Error?:
        """Get source error."""
        Some(self.error)

    fn backtrace() -> Backtrace?:
        """Get backtrace."""
        self.trace.or(self.error.backtrace())

# ============================================================================
# Backtrace - Stack Trace
# ============================================================================

class Backtrace:
    """Stack trace for error debugging.

    Captures call stack when error occurs.

    Example:
        val trace = Backtrace.capture()
        print trace.to_string()
    """
    frames: [StackFrame]

    static fn capture() -> Backtrace:
        """Capture current backtrace.

        Returns:
            Backtrace
        """
        val frames = capture_backtrace()
        Backtrace(frames: frames)

    fn to_string() -> text:
        """Format backtrace as string.

        Returns:
            Formatted backtrace
        """
        var result = "Stack backtrace:{NL}"
        for i in 0..self.frames.len():
            val frame = self.frames[i]
            result = result + "  {i}: {frame.to_string()}{NL}"
        result

    fn frames() -> [StackFrame]:
        """Get stack frames.

        Returns:
            Stack frames
        """
        self.frames

struct StackFrame:
    """Single stack frame.

    Example:
        val frame = StackFrame(
            function: "main",
            file: "main.spl",
            line: 42
        )
    """
    function: text   # Function name
    file: text       # Source file
    line: usize      # Line number

impl StackFrame:
    fn to_string() -> text:
        """Format stack frame.

        Returns:
            Formatted frame
        """
        "{self.function} at {self.file}:{self.line}"

# ============================================================================
# Result Extensions - Error Conversion Helpers
# ============================================================================

impl<T, E> Result<T, E>:
    """Result extensions for error handling.

    Provides convenience methods for error conversion.
    """

    fn context(self, message: text) -> Result<T, Context<E>>:
        """Add context to error.

        Args:
            message: Context message

        Returns:
            Result with context

        Example:
            val value = risky_op()
                .context("Failed to perform operation")?
        """
        match self:
            case Ok(value): Ok(value)
            case Err(error): Err(Context.new(message, error))

    fn map_err<F>(self, f: fn(E) -> F) -> Result<T, F>:
        """Transform error type.

        Args:
            f: Error transformation function

        Returns:
            Result with transformed error

        Example:
            val result = operation()
                .map_err(\e: CustomError.from(e))
        """
        match self:
            case Ok(value): Ok(value)
            case Err(error): Err(f(error))

    fn or_else<F>(self, f: fn(E) -> Result<T, F>) -> Result<T, F>:
        """Recover from error.

        Args:
            f: Recovery function

        Returns:
            Original success or recovery result

        Example:
            val value = try_primary()
                .or_else(\e: try_fallback())
        """
        match self:
            case Ok(value): Ok(value)
            case Err(error): f(error)

    fn expect_err(self, message: text) -> E:
        """Unwrap error (panics on Ok).

        Args:
            message: Panic message

        Returns:
            Error value

        Panics: If result is Ok
        """
        match self:
            case Ok(_): panic(message)
            case Err(error): error

# ============================================================================
# Error Creation Macros (Functions)
# ============================================================================

fn error(message: text) -> SimpleError:
    """Create simple error with unknown kind.

    Args:
        message: Error message

    Returns:
        Simple error

    Example:
        return Err(error("Something went wrong"))
    """
    SimpleError.new(ErrorKind.Unknown, message)

fn io_error(kind: ErrorKind, message: text) -> SimpleError:
    """Create I/O error.

    Args:
        kind: Error kind
        message: Error message

    Returns:
        Simple error

    Example:
        return Err(io_error(ErrorKind.NotFound, "File not found"))
    """
    SimpleError.new(kind, message)

fn validation_error(message: text) -> SimpleError:
    """Create validation error.

    Args:
        message: Error message

    Returns:
        Simple error

    Example:
        if value < 0:
            return Err(validation_error("Value must be positive"))
    """
    SimpleError.new(ErrorKind.InvalidInput, message)

# ============================================================================
# Error Chain Iterator
# ============================================================================

class ErrorChain:
    """Iterator over error source chain.

    Walks the chain of error sources.

    Example:
        for error in ErrorChain.new(top_error):
            print error.message()
    """
    current: Error?

    static fn new(error: Error) -> ErrorChain:
        """Create error chain iterator.

        Args:
            error: Top-level error

        Returns:
            Error chain
        """
        ErrorChain(current: Some(error))

    fn next() -> Error?:
        """Get next error in chain.

        Returns:
            Some(error) or nil if end of chain
        """
        if not self.current.?:
            return nil

        val error = self.current.unwrap()
        self.current = error.source()
        Some(error)

    fn to_list() -> [Error]:
        """Collect all errors in chain.

        Returns:
            List of errors
        """
        var errors: [Error] = []
        while val Some(error) = self.next():
            errors = errors.push(error)
        errors

# ============================================================================
# Error Formatting
# ============================================================================

fn format_error(error: Error) -> text:
    """Format error with full chain.

    Args:
        error: Error to format

    Returns:
        Formatted error message

    Example:
        val msg = format_error(error)
        print msg
    """
    var result = "Error: {error.message()}"

    # Add error chain
    var current = error.source()
    while current.?:
        val source = current.unwrap()
        result = result + "{NL}Caused by: {source.message()}"
        current = source.source()

    # Add backtrace if available
    if val Some(trace) = error.backtrace():
        result = result + "{NL}{NL}{trace.to_string()}"

    result

fn format_error_compact(error: Error) -> text:
    """Format error without backtrace.

    Args:
        error: Error to format

    Returns:
        Compact error message
    """
    var result = error.message()

    var current = error.source()
    while current.?:
        val source = current.unwrap()
        result = result + ": {source.message()}"
        current = source.source()

    result

# ============================================================================
# FFI Functions
# ============================================================================

# Backtrace capture
extern fn capture_backtraces() -> bool
extern fn capture_backtrace() -> [StackFrame]

# ============================================================================
# Exports
# ============================================================================

export Error
export ErrorKind
export SimpleError
export Context
export Backtrace
export StackFrame
export ErrorChain
export error
export io_error
export validation_error
export format_error
export format_error_compact
