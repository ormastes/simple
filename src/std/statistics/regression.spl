# statistics/regression.spl - Regression analysis functions

import math from "std/math"
import types from "./types"
import descriptive from "./descriptive"

# ============================================================================
# REGRESSION
# ============================================================================

fn linear_regression(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    """Calculate linear regression (returns [slope, intercept])."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val mean_x_opt = descriptive.mean(x)
    val mean_y_opt = descriptive.mean(y)

    if mean_x_opt == nil or mean_y_opt == nil:
        return nil

    val mx = mean_x_opt
    val my = mean_y_opt

    var sum_xy = 0.0
    var sum_xx = 0.0

    var i = 0
    while i < x.length():
        val dx = x[i] - mx
        val dy = y[i] - my
        sum_xy = sum_xy + (dx * dy)
        sum_xx = sum_xx + (dx * dx)
        i = i + 1

    if sum_xx < types.EPSILON:
        return nil

    val slope = sum_xy / sum_xx
    val intercept = my - (slope * mx)

    Some([slope, intercept])

fn r_squared(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate coefficient of determination (RÂ²)."""
    val reg_opt = linear_regression(x, y)
    if reg_opt == nil:
        return nil

    val params = reg_opt
    val slope = params[0]
    val intercept = params[1]

    val mean_y_opt = descriptive.mean(y)
    if mean_y_opt == nil:
        return nil

    val my = mean_y_opt

    var ss_res = 0.0
    var ss_tot = 0.0

    var i = 0
    while i < x.length():
        val pred = slope * x[i] + intercept
        val res = y[i] - pred
        val tot = y[i] - my
        ss_res = ss_res + (res * res)
        ss_tot = ss_tot + (tot * tot)
        i = i + 1

    if ss_tot < types.EPSILON:
        return nil

    Some(1.0 - (ss_res / ss_tot))

fn residuals(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    """Calculate regression residuals."""
    val reg_opt = linear_regression(x, y)
    if reg_opt == nil:
        return nil

    val params = reg_opt
    val slope = params[0]
    val intercept = params[1]

    var res = []
    var i = 0
    while i < x.length():
        val pred = slope * x[i] + intercept
        res.push(y[i] - pred)
        i = i + 1

    Some(res)
