# statistics/correlation.spl - Correlation and covariance analysis

import math from "std/math"
import types from "./types"
import utilities from "./utilities"
import descriptive from "./descriptive"

# ============================================================================
# CORRELATION
# ============================================================================

fn covariance(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate population covariance between two arrays."""
    if x.length() != y.length() or x.length() == 0:
        return nil

    val mean_x_opt = descriptive.mean(x)
    val mean_y_opt = descriptive.mean(y)

    if mean_x_opt == nil or mean_y_opt == nil:
        return nil

    val mx = mean_x_opt
    val my = mean_y_opt
    var sum_prod = 0.0

    var i = 0
    while i < x.length():
        sum_prod = sum_prod + ((x[i] - mx) * (y[i] - my))
        i = i + 1

    Some(sum_prod / x.length())

fn covariance_sample(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate sample covariance between two arrays."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val mean_x_opt = descriptive.mean(x)
    val mean_y_opt = descriptive.mean(y)

    if mean_x_opt == nil or mean_y_opt == nil:
        return nil

    val mx = mean_x_opt
    val my = mean_y_opt
    var sum_prod = 0.0

    var i = 0
    while i < x.length():
        sum_prod = sum_prod + ((x[i] - mx) * (y[i] - my))
        i = i + 1

    Some(sum_prod / (x.length() - 1))

fn correlation_pearson(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate Pearson correlation coefficient."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val cov_opt = covariance(x, y)
    val std_x_opt = descriptive.stddev(x)
    val std_y_opt = descriptive.stddev(y)

    if cov_opt == nil or std_x_opt == nil or std_y_opt == nil:
        return nil

    val denominator = std_x_opt * std_y_opt
    if denominator < types.EPSILON:
        return nil

    Some(cov_opt / denominator)

fn correlation_spearman(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate Spearman rank correlation coefficient."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val ranks_x = utilities.rank_data(x)
    val ranks_y = utilities.rank_data(y)

    correlation_pearson(ranks_x, ranks_y)

fn correlation_kendall(x: List<f64>, y: List<f64>) -> Option<f64>:
    """Calculate Kendall's tau correlation coefficient."""
    if x.length() != y.length() or x.length() < 2:
        return nil

    val n = x.length()
    var concordant = 0
    var discordant = 0

    var i = 0
    while i < n - 1:
        var j = i + 1
        while j < n:
            val dx = x[j] - x[i]
            val dy = y[j] - y[i]

            if dx * dy > 0.0:
                concordant = concordant + 1
            else:
                if dx * dy < 0.0:
                    discordant = discordant + 1

            j = j + 1
        i = i + 1

    val pairs = n * (n - 1) / 2
    val tau = (concordant - discordant) / pairs
    Some(tau)

fn autocorrelation(data: List<f64>, lag: i64) -> Option<f64>:
    """Calculate autocorrelation at given lag."""
    if lag < 0 or lag >= data.length():
        return nil

    val n = data.length() - lag
    if n < 1:
        return nil

    var x = []
    var y = []

    var i = 0
    while i < n:
        x.push(data[i])
        y.push(data[i + lag])
        i = i + 1

    correlation_pearson(x, y)

fn cross_correlation(x: List<f64>, y: List<f64>, lag: i64) -> Option<f64>:
    """Calculate cross-correlation at given lag."""
    if lag < 0:
        return nil

    if x.length() - lag < 1 or y.length() < 1:
        return nil

    val n = math.min(x.length() - lag, y.length())

    var x_subset = []
    var y_subset = []

    var i = 0
    while i < n:
        x_subset.push(x[i + lag])
        y_subset.push(y[i])
        i = i + 1

    correlation_pearson(x_subset, y_subset)
