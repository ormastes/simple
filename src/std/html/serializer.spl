# HTML Serialization and Rendering
#
# Converts DOM trees back to HTML with pretty-printing support.

# =============================================================================
# HTML Rendering Helpers
# =============================================================================

fn render_attrs(attrs: list) -> text:
    var result = ""
    var i = 0
    while i < attrs.length():
        val attr = attrs[i]
        val name = attr[0]
        val value = attr[1]
        result = result + " " + name
        if value != name:
            val escaped = encode_html_entities(value)
            result = result + "=\"" + escaped + "\""
        i = i + 1
    result

fn create_indent(level: i64) -> text:
    var result = ""
    var i = 0
    while i < level:
        result = result + "  "
        i = i + 1
    result

# =============================================================================
# HTML Rendering
# =============================================================================

fn render_html_node(node: tuple, indent_level: i64, pretty: bool) -> text:
    var result = ""
    val ntype = node_type(node)
    val indent_str = create_indent(indent_level)

    if ntype == NODE_ELEMENT:
        val tag = node_tag(node)
        val attrs = node_attrs(node)
        val children = node_children(node)
        val attrs_str = render_attrs(attrs)

        if pretty:
            result = result + indent_str
        result = result + "<" + tag + attrs_str + ">"

        if children.length() > 0:
            var has_element_child = false
            var i = 0
            while i < children.length():
                val child = children[i]
                val child_type = node_type(child)
                if child_type == NODE_ELEMENT:
                    has_element_child = true
                i = i + 1

            if has_element_child:
                if pretty:
                    result = result + "\n"

            i = 0
            while i < children.length():
                val child = children[i]
                val child_html = render_html_node(child, indent_level + 1, pretty)
                result = result + child_html
                i = i + 1

            if has_element_child:
                if pretty:
                    result = result + indent_str

        result = result + "</" + tag + ">"
        if pretty:
            result = result + "\n"
    else:
        if ntype == NODE_TEXT:
            val text = node_text(node)
            val encoded = encode_html_entities(text)
            result = encoded
        else:
            if ntype == NODE_COMMENT:
                val text = node_text(node)
                if pretty:
                    result = indent_str
                result = result + "<!--" + text + "-->"
                if pretty:
                    result = result + "\n"
            else:
                if ntype == NODE_DOCTYPE:
                    val text = node_text(node)
                    if pretty:
                        result = indent_str
                    result = result + "<!DOCTYPE" + text + ">"
                    if pretty:
                        result = result + "\n"

    result

fn render_html(node: tuple, pretty: bool) -> text:
    var result = ""
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_html = render_html_node(child, 0, pretty)
        result = result + child_html
        i = i + 1
    result

fn render_html_pretty(node: tuple) -> text:
    render_html(node, true)

fn render_html_compact(node: tuple) -> text:
    render_html(node, false)

# =============================================================================
# Fragment Rendering
# =============================================================================

fn render_fragment(nodes: list, pretty: bool) -> text:
    var result = ""
    var i = 0
    while i < nodes.length():
        val node = nodes[i]
        val node_html = render_html_node(node, 0, pretty)
        result = result + node_html
        i = i + 1
    result

fn render_fragment_pretty(nodes: list) -> text:
    render_fragment(nodes, true)

fn render_fragment_compact(nodes: list) -> text:
    render_fragment(nodes, false)

# =============================================================================
# Dependencies (from other modules)
# =============================================================================

val NODE_ELEMENT = "element"
val NODE_TEXT = "text"
val NODE_COMMENT = "comment"
val NODE_DOCTYPE = "doctype"

fn node_type(node: tuple) -> text:
    node[0]

fn node_tag(node: tuple) -> text:
    node[1]

fn node_attrs(node: tuple) -> list:
    node[2]

fn node_children(node: tuple) -> list:
    node[3]

fn node_text(node: tuple) -> text:
    node[4]

# Placeholder import - will be resolved by facade
fn encode_html_entities(text: text) -> text:
    text
