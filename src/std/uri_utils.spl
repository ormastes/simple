# URI/URL Parsing and Manipulation - Facade
# Pure Simple implementation for URI/URL handling
# Supports parsing, building, encoding, and manipulating URIs
#
# This is a facade that re-exports all URI functionality from submodules:
# - uri/types.spl: UriComponents and QueryParam classes
# - uri/parse.spl: URI parsing and component access
# - uri/build.spl: URI building and query operations
# - uri/encode.spl: Percent encoding/decoding
# - uri/validate.spl: URI validation functions
# - uri/utilities.spl: Helper string functions

# Import all submodules
import uri.types
import uri.parse
import uri.build
import uri.encode
import uri.validate
import uri.utilities

# Re-export types
class UriComponents:
    scheme: text
    userinfo: text
    host: text
    port: text
    path: text
    query: text
    fragment: text

    fn to_string() -> text:
        uri.types.UriComponents.to_string(self)

class QueryParam:
    key: text
    value: text

# Re-export parse module
fn parse_uri(uri: text) -> UriComponents: uri.parse.parse_uri(uri)
fn parse_url(url: text) -> UriComponents: uri.parse.parse_url(url)
fn parse_query_string(query: text) -> array: uri.parse.parse_query_string(query)
fn get_scheme(uri: text) -> text: uri.parse.get_scheme(uri)
fn get_host(uri: text) -> text: uri.parse.get_host(uri)
fn get_port(uri: text) -> text: uri.parse.get_port(uri)
fn get_path(uri: text) -> text: uri.parse.get_path(uri)
fn get_query(uri: text) -> text: uri.parse.get_query(uri)
fn get_fragment(uri: text) -> text: uri.parse.get_fragment(uri)
fn get_userinfo(uri: text) -> text: uri.parse.get_userinfo(uri)
fn get_authority(uri: text) -> text: uri.parse.get_authority(uri)
fn join_path(segments: array) -> text: uri.parse.join_path(segments)
fn normalize_path(path: text) -> text: uri.parse.normalize_path(path)
fn resolve_relative(base: text, relative: text) -> text: uri.parse.resolve_relative(base, relative)

# Re-export build module
fn build_uri(components: UriComponents) -> text: uri.build.build_uri(components)
fn build_url(scheme: text, host: text, path: text, query: text, fragment: text) -> text: uri.build.build_url(scheme, host, path, query, fragment)
fn build_query_string(params: array) -> text: uri.build.build_query_string(params)
fn add_query_param(uri: text, key: text, value: text) -> text: uri.build.add_query_param(uri, key, value)
fn remove_query_param(uri: text, key: text) -> text: uri.build.remove_query_param(uri, key)
fn get_query_param(uri: text, key: text) -> text: uri.build.get_query_param(uri, key)
fn get_query_param_all(uri: text, key: text) -> array: uri.build.get_query_param_all(uri, key)
fn set_query_param(uri: text, key: text, value: text) -> text: uri.build.set_query_param(uri, key, value)

# Re-export encode module
fn uri_encode(str: text) -> text: uri.encode.uri_encode(str)
fn uri_decode(str: text) -> text: uri.encode.uri_decode(str)
fn uri_encode_query(str: text) -> text: uri.encode.uri_encode_query(str)

# Re-export validate module
fn is_valid_uri(uri: text) -> bool: uri.validate.is_valid_uri(uri)
fn is_absolute(uri: text) -> bool: uri.validate.is_absolute(uri)
fn is_relative(uri: text) -> bool: uri.validate.is_relative(uri)
fn is_valid_scheme(scheme: text) -> bool: uri.validate.is_valid_scheme(scheme)
fn is_http_scheme(scheme: text) -> bool: uri.validate.is_http_scheme(scheme)
fn is_file_scheme(scheme: text) -> bool: uri.validate.is_file_scheme(scheme)
fn is_mailto_scheme(scheme: text) -> bool: uri.validate.is_mailto_scheme(scheme)
fn get_default_port(scheme: text) -> text: uri.validate.get_default_port(scheme)
fn is_default_port(scheme: text, port: text) -> bool: uri.validate.is_default_port(scheme, port)
fn build_http_url(host: text, path: text) -> text: uri.validate.build_http_url(host, path)
fn build_https_url(host: text, path: text) -> text: uri.validate.build_https_url(host, path)
fn build_file_uri(path: text) -> text: uri.validate.build_file_uri(path)
fn build_mailto_uri(email: text) -> text: uri.validate.build_mailto_uri(email)

# Re-export utilities module
fn to_hex_byte(value: i64) -> text: uri.utilities.to_hex_byte(value)
fn from_hex_byte(hex1: text, hex2: text) -> i64: uri.utilities.from_hex_byte(hex1, hex2)
fn hex_digit_value(digit: text) -> i64: uri.utilities.hex_digit_value(digit)
fn is_numeric(str: text) -> bool: uri.utilities.is_numeric(str)
fn get_domain(host: text) -> text: uri.utilities.get_domain(host)
fn is_ip_address(host: text) -> bool: uri.utilities.is_ip_address(host)
fn remove_default_port(uri: text) -> text: uri.utilities.remove_default_port(uri)
fn ensure_trailing_slash(uri: text) -> text: uri.utilities.ensure_trailing_slash(uri)
fn remove_trailing_slash(uri: text) -> text: uri.utilities.remove_trailing_slash(uri)
fn string_to_lower(s: text) -> text: uri.utilities.string_to_lower(s)
fn string_starts_with(s: text, prefix: text) -> bool: uri.utilities.string_starts_with(s, prefix)
fn string_ends_with(s: text, suffix: text) -> bool: uri.utilities.string_ends_with(s, suffix)
fn string_index_of(s: text, needle: text) -> i64: uri.utilities.string_index_of(s, needle)
fn string_last_index_of(s: text, needle: text) -> i64: uri.utilities.string_last_index_of(s, needle)
fn string_replace_all(s: text, old: text, new: text) -> text: uri.utilities.string_replace_all(s, old, new)
fn string_contains(s: text, needle: text) -> bool: uri.utilities.string_contains(s, needle)
