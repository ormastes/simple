# URI/URL Parsing and Manipulation
# Pure Simple implementation for URI/URL handling
# Supports parsing, building, encoding, and manipulating URIs

# URI Component Structure
class UriComponents:
    scheme: text      # http, https, ftp, file, mailto, etc.
    userinfo: text    # username:password (optional)
    host: text        # domain or IP address
    port: text        # port number as text (empty if default)
    path: text        # /path/to/resource
    query: text       # query string without '?'
    fragment: text    # fragment without '#'

    fn to_string() -> text:
        var result = ""

        # Scheme
        if self.scheme != "":
            result = result + self.scheme + ":"

        # Authority (userinfo + host + port)
        var has_authority = self.host != ""
        if has_authority:
            result = result + "//"
            if self.userinfo != "":
                result = result + self.userinfo + "@"
            result = result + self.host
            if self.port != "":
                result = result + ":" + self.port

        # Path
        result = result + self.path

        # Query
        if self.query != "":
            result = result + "?" + self.query

        # Fragment
        if self.fragment != "":
            result = result + "#" + self.fragment

        result

# Query Parameter Structure
class QueryParam:
    key: text
    value: text

# ============================================================================
# URI Parsing Functions
# ============================================================================

# Parse a complete URI into components
# Returns UriComponents with all parts extracted
fn parse_uri(uri: text) -> UriComponents:
    var components = UriComponents(
        scheme: "",
        userinfo: "",
        host: "",
        port: "",
        path: "",
        query: "",
        fragment: ""
    )

    if uri == "":
        return components

    var remaining = uri

    # Extract fragment first (rightmost)
    var fragment_idx = string_index_of(remaining, "#")
    if fragment_idx >= 0:
        components.fragment = string_substring(remaining, fragment_idx + 1, string_length(remaining))
        remaining = string_substring(remaining, 0, fragment_idx)

    # Extract query
    var query_idx = string_index_of(remaining, "?")
    if query_idx >= 0:
        components.query = string_substring(remaining, query_idx + 1, string_length(remaining))
        remaining = string_substring(remaining, 0, query_idx)

    # Extract scheme
    var scheme_idx = string_index_of(remaining, ":")
    if scheme_idx > 0:
        var potential_scheme = string_substring(remaining, 0, scheme_idx)
        if is_valid_scheme(potential_scheme):
            components.scheme = string_to_lower(potential_scheme)
            remaining = string_substring(remaining, scheme_idx + 1, string_length(remaining))

    # Check for authority (starts with //)
    if string_starts_with(remaining, "//"):
        remaining = string_substring(remaining, 2, string_length(remaining))

        # Find where path starts
        var path_idx = string_index_of(remaining, "/")
        var authority = ""
        if path_idx >= 0:
            authority = string_substring(remaining, 0, path_idx)
            components.path = string_substring(remaining, path_idx, string_length(remaining))
        else:
            authority = remaining
            components.path = ""

        # Parse authority: [userinfo@]host[:port]
        var at_idx = string_index_of(authority, "@")
        var host_port = authority
        if at_idx >= 0:
            components.userinfo = string_substring(authority, 0, at_idx)
            host_port = string_substring(authority, at_idx + 1, string_length(authority))

        # Parse host and port
        var port_idx = string_last_index_of(host_port, ":")
        if port_idx >= 0:
            # Check if it's actually a port (not IPv6)
            var potential_port = string_substring(host_port, port_idx + 1, string_length(host_port))
            if is_numeric(potential_port):
                components.host = string_substring(host_port, 0, port_idx)
                components.port = potential_port
            else:
                components.host = host_port
        else:
            components.host = host_port
    else:
        # No authority, remaining is path
        components.path = remaining

    components

# Parse a URL (alias for parse_uri with HTTP/HTTPS assumption)
fn parse_url(url: text) -> UriComponents:
    parse_uri(url)

# Parse a query string into list of QueryParam
# Input: "key1=value1&key2=value2" or "?key1=value1&key2=value2"
fn parse_query_string(query: text) -> array:
    var params = []

    var query_str = query
    if string_starts_with(query_str, "?"):
        query_str = string_substring(query_str, 1, string_length(query_str))

    if query_str == "":
        return params

    var pairs = string_split(query_str, "&")
    var i = 0
    while i < array_length(pairs):
        var pair = array_get(pairs, i)
        var eq_idx = string_index_of(pair, "=")
        if eq_idx >= 0:
            var key = string_substring(pair, 0, eq_idx)
            var value = string_substring(pair, eq_idx + 1, string_length(pair))
            var param = QueryParam(key: uri_decode(key), value: uri_decode(value))
            params = array_push(params, param)
        else:
            var param = QueryParam(key: uri_decode(pair), value: "")
            params = array_push(params, param)
        i = i + 1

    params

# ============================================================================
# URI Building Functions
# ============================================================================

# Build a URI from components
fn build_uri(components: UriComponents) -> text:
    components.to_string()

# Build a URL with common parameters
fn build_url(scheme: text, host: text, path: text, query: text, fragment: text) -> text:
    var components = UriComponents(
        scheme: scheme,
        userinfo: "",
        host: host,
        port: "",
        path: path,
        query: query,
        fragment: fragment
    )
    build_uri(components)

# Build a query string from array of QueryParam
fn build_query_string(params: array) -> text:
    if array_length(params) == 0:
        return ""

    var result = ""
    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if i > 0:
            result = result + "&"
        result = result + uri_encode(param.key) + "=" + uri_encode(param.value)
        i = i + 1

    result

# ============================================================================
# Component Access Functions
# ============================================================================

# Get scheme from URI string
fn get_scheme(uri: text) -> text:
    var components = parse_uri(uri)
    components.scheme

# Get host from URI string
fn get_host(uri: text) -> text:
    var components = parse_uri(uri)
    components.host

# Get port from URI string
fn get_port(uri: text) -> text:
    var components = parse_uri(uri)
    components.port

# Get path from URI string
fn get_path(uri: text) -> text:
    var components = parse_uri(uri)
    components.path

# Get query from URI string
fn get_query(uri: text) -> text:
    var components = parse_uri(uri)
    components.query

# Get fragment from URI string
fn get_fragment(uri: text) -> text:
    var components = parse_uri(uri)
    components.fragment

# Get userinfo from URI string
fn get_userinfo(uri: text) -> text:
    var components = parse_uri(uri)
    components.userinfo

# Get full authority (userinfo@host:port)
fn get_authority(uri: text) -> text:
    var components = parse_uri(uri)
    var authority = ""

    if components.userinfo != "":
        authority = components.userinfo + "@"

    authority = authority + components.host

    if components.port != "":
        authority = authority + ":" + components.port

    authority

# ============================================================================
# Path Operations
# ============================================================================

# Join path segments with proper separators
fn join_path(segments: array) -> text:
    if array_length(segments) == 0:
        return ""

    var result = ""
    var i = 0
    while i < array_length(segments):
        var segment = array_get(segments, i)

        # Skip empty segments
        if segment != "":
            if i > 0 and not string_starts_with(segment, "/"):
                result = result + "/"
            result = result + segment

        i = i + 1

    result

# Normalize a path by resolving . and .. segments
fn normalize_path(path: text) -> text:
    if path == "" or path == "/":
        return path

    var is_absolute = string_starts_with(path, "/")
    var segments = string_split(path, "/")
    var normalized = []

    var i = 0
    while i < array_length(segments):
        var segment = array_get(segments, i)

        if segment == "" or segment == ".":
            # Skip empty and current directory
            pass
        else:
            if segment == "..":
                # Go up one level if possible
                if array_length(normalized) > 0:
                    var last = array_get(normalized, array_length(normalized) - 1)
                    if last != "..":
                        normalized = array_pop(normalized)
                    else:
                        normalized = array_push(normalized, segment)
                else:
                    if not is_absolute:
                        normalized = array_push(normalized, segment)
            else:
                normalized = array_push(normalized, segment)

        i = i + 1

    var result = join_path(normalized)
    if is_absolute and not string_starts_with(result, "/"):
        result = "/" + result

    result

# Resolve a relative URI against a base URI
fn resolve_relative(base: text, relative: text) -> text:
    if relative == "":
        return base

    var rel_components = parse_uri(relative)

    # If relative URI has scheme, it's absolute
    if rel_components.scheme != "":
        return relative

    var base_components = parse_uri(base)
    var result = UriComponents(
        scheme: base_components.scheme,
        userinfo: base_components.userinfo,
        host: base_components.host,
        port: base_components.port,
        path: base_components.path,
        query: base_components.query,
        fragment: base_components.fragment
    )

    # If relative has authority, use it
    if rel_components.host != "":
        result.userinfo = rel_components.userinfo
        result.host = rel_components.host
        result.port = rel_components.port
        result.path = normalize_path(rel_components.path)
        result.query = rel_components.query
        result.fragment = rel_components.fragment
        return build_uri(result)

    # Relative path resolution
    if rel_components.path == "":
        # Only query or fragment
        if rel_components.query != "":
            result.query = rel_components.query
        if rel_components.fragment != "":
            result.fragment = rel_components.fragment
    else:
        if string_starts_with(rel_components.path, "/"):
            # Absolute path
            result.path = normalize_path(rel_components.path)
        else:
            # Relative path - merge with base
            var base_path = base_components.path
            var last_slash = string_last_index_of(base_path, "/")
            var merged = ""
            if last_slash >= 0:
                merged = string_substring(base_path, 0, last_slash + 1) + rel_components.path
            else:
                merged = rel_components.path
            result.path = normalize_path(merged)

        result.query = rel_components.query
        result.fragment = rel_components.fragment

    build_uri(result)

# ============================================================================
# Query Operations
# ============================================================================

# Add a query parameter to a URI
fn add_query_param(uri: text, key: text, value: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var new_param = QueryParam(key: key, value: value)
    params = array_push(params, new_param)
    components.query = build_query_string(params)
    build_uri(components)

# Remove a query parameter from a URI
fn remove_query_param(uri: text, key: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var filtered = []

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key != key:
            filtered = array_push(filtered, param)
        i = i + 1

    components.query = build_query_string(filtered)
    build_uri(components)

# Get a query parameter value from a URI
fn get_query_param(uri: text, key: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key == key:
            return param.value
        i = i + 1

    ""

# Get all values for a query parameter (for keys that appear multiple times)
fn get_query_param_all(uri: text, key: text) -> array:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var values = []

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key == key:
            values = array_push(values, param.value)
        i = i + 1

    values

# Update or add a query parameter
fn set_query_param(uri: text, key: text, value: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var found = false
    var updated = []

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key == key:
            if not found:
                var new_param = QueryParam(key: key, value: value)
                updated = array_push(updated, new_param)
                found = true
            # Skip duplicate keys
        else:
            updated = array_push(updated, param)
        i = i + 1

    if not found:
        var new_param = QueryParam(key: key, value: value)
        updated = array_push(updated, new_param)

    components.query = build_query_string(updated)
    build_uri(components)

# ============================================================================
# URI Encoding/Decoding (Percent Encoding)
# ============================================================================

# Encode a string for use in URI components
fn uri_encode(str: text) -> text:
    var result = ""
    var i = 0
    while i < string_length(str):
        var ch = string_char_at(str, i)
        var code = string_char_code(ch)

        # Unreserved characters (RFC 3986)
        var is_unreserved = false
        is_unreserved = (code >= 65 and code <= 90) or (code >= 97 and code <= 122)  # A-Z, a-z
        is_unreserved = is_unreserved or (code >= 48 and code <= 57)  # 0-9
        is_unreserved = is_unreserved or ch == "-" or ch == "_" or ch == "." or ch == "~"

        if is_unreserved:
            result = result + ch
        else:
            # Percent encode
            var hex = to_hex_byte(code)
            result = result + "%" + hex

        i = i + 1

    result

# Decode a percent-encoded string
fn uri_decode(str: text) -> text:
    var result = ""
    var i = 0
    while i < string_length(str):
        var ch = string_char_at(str, i)

        if ch == "%":
            if i + 2 < string_length(str):
                var hex1 = string_char_at(str, i + 1)
                var hex2 = string_char_at(str, i + 2)
                var code = from_hex_byte(hex1, hex2)
                var decoded = string_from_char_code(code)
                result = result + decoded
                i = i + 3
            else:
                result = result + ch
                i = i + 1
        else:
            if ch == "+":
                result = result + " "
            else:
                result = result + ch
            i = i + 1

    result

# Encode query string component (spaces become +)
fn uri_encode_query(str: text) -> text:
    var encoded = uri_encode(str)
    string_replace_all(encoded, "%20", "+")

# ============================================================================
# Validation Functions
# ============================================================================

# Check if a string is a valid URI
fn is_valid_uri(uri: text) -> bool:
    if uri == "":
        return false

    # Try to parse it
    var components = parse_uri(uri)

    # At minimum, should have a scheme or a path
    (components.scheme != "" or components.path != "") to_equal true

# Check if a URI is absolute (has scheme)
fn is_absolute(uri: text) -> bool:
    var components = parse_uri(uri)
    components.scheme != ""

# Check if a URI is relative (no scheme)
fn is_relative(uri: text) -> bool:
    not is_absolute(uri)

# Check if a scheme is valid
fn is_valid_scheme(scheme: text) -> bool:
    if scheme == "":
        return false

    # Must start with letter
    var first = string_char_at(scheme, 0)
    var first_code = string_char_code(first)
    var valid = (first_code >= 65 and first_code <= 90) or (first_code >= 97 and first_code <= 122)

    if not valid:
        return false

    # Rest can be letter, digit, +, -, .
    var i = 1
    while i < string_length(scheme):
        var ch = string_char_at(scheme, i)
        var code = string_char_code(ch)
        var ch_valid = false
        ch_valid = (code >= 65 and code <= 90) or (code >= 97 and code <= 122)
        ch_valid = ch_valid or (code >= 48 and code <= 57)
        ch_valid = ch_valid or ch == "+" or ch == "-" or ch == "."

        if not ch_valid:
            return false

        i = i + 1

    true

# Check if scheme is HTTP or HTTPS
fn is_http_scheme(scheme: text) -> bool:
    var lower = string_to_lower(scheme)
    (lower == "http" or lower == "https") to_equal true

# Check if scheme is a file scheme
fn is_file_scheme(scheme: text) -> bool:
    var lower = string_to_lower(scheme)
    lower == "file"

# Check if scheme is mailto
fn is_mailto_scheme(scheme: text) -> bool:
    var lower = string_to_lower(scheme)
    lower == "mailto"

# ============================================================================
# Scheme-Specific Functions
# ============================================================================

# Get default port for common schemes
fn get_default_port(scheme: text) -> text:
    var lower = string_to_lower(scheme)
    if lower == "http":
        return "80"
    if lower == "https":
        return "443"
    if lower == "ftp":
        return "21"
    if lower == "ftps":
        return "990"
    if lower == "ssh":
        return "22"
    if lower == "telnet":
        return "23"
    if lower == "smtp":
        return "25"
    if lower == "pop3":
        return "110"
    if lower == "imap":
        return "143"
    ""

# Check if port is the default for the scheme
fn is_default_port(scheme: text, port: text) -> bool:
    var default_port = get_default_port(scheme)
    if default_port == "":
        return false
    default_port == port

# Build an HTTP URL
fn build_http_url(host: text, path: text) -> text:
    build_url("http", host, path, "", "")

# Build an HTTPS URL
fn build_https_url(host: text, path: text) -> text:
    build_url("https", host, path, "", "")

# Build a file URI
fn build_file_uri(path: text) -> text:
    var components = UriComponents(
        scheme: "file",
        userinfo: "",
        host: "",
        port: "",
        path: path,
        query: "",
        fragment: ""
    )
    build_uri(components)

# Build a mailto URI
fn build_mailto_uri(email: text) -> text:
    var components = UriComponents(
        scheme: "mailto",
        userinfo: "",
        host: "",
        port: "",
        path: email,
        query: "",
        fragment: ""
    )
    build_uri(components)

# ============================================================================
# Utility Functions
# ============================================================================

# Convert byte value to 2-digit hex string
fn to_hex_byte(value: i64) -> text:
    var hex_chars = "0123456789ABCDEF"
    var high = value / 16
    var low = value % 16
    var high_char = string_char_at(hex_chars, high)
    var low_char = string_char_at(hex_chars, low)
    high_char + low_char

# Convert 2 hex digits to byte value
fn from_hex_byte(hex1: text, hex2: text) -> i64:
    var h1 = hex_digit_value(hex1)
    var h2 = hex_digit_value(hex2)
    h1 * 16 + h2

# Get numeric value of hex digit
fn hex_digit_value(digit: text) -> i64:
    var code = string_char_code(digit)
    if code >= 48 and code <= 57:
        return code - 48  # 0-9
    if code >= 65 and code <= 70:
        return code - 65 + 10  # A-F
    if code >= 97 and code <= 102:
        return code - 97 + 10  # a-f
    0

# Check if string is numeric
fn is_numeric(str: text) -> bool:
    if str == "":
        return false

    var i = 0
    while i < string_length(str):
        var ch = string_char_at(str, i)
        var code = string_char_code(ch)
        if code < 48 or code > 57:
            return false
        i = i + 1

    true

# Extract domain from host (remove subdomain)
fn get_domain(host: text) -> text:
    if host == "":
        return ""

    var parts = string_split(host, ".")
    var len = array_length(parts)

    if len < 2:
        return host

    # Return last 2 parts (domain.tld)
    var domain = array_get(parts, len - 2)
    var tld = array_get(parts, len - 1)
    domain + "." + tld

# Check if host is an IP address (simple check)
fn is_ip_address(host: text) -> bool:
    if host == "":
        return false

    # IPv4 simple check
    var parts = string_split(host, ".")
    if array_length(parts) == 4:
        var all_numeric = true
        var i = 0
        while i < 4:
            var part = array_get(parts, i)
            if not is_numeric(part):
                all_numeric = false
            i = i + 1
        return all_numeric

    # IPv6 simple check (contains :)
    string_contains(host, ":")

# Remove default port from URI if present
fn remove_default_port(uri: text) -> text:
    var components = parse_uri(uri)
    if components.port != "" and is_default_port(components.scheme, components.port):
        components.port = ""
    build_uri(components)

# Add trailing slash to path if not present
fn ensure_trailing_slash(uri: text) -> text:
    var components = parse_uri(uri)
    if components.path != "" and not string_ends_with(components.path, "/"):
        components.path = components.path + "/"
    build_uri(components)

# Remove trailing slash from path if present
fn remove_trailing_slash(uri: text) -> text:
    var components = parse_uri(uri)
    if string_ends_with(components.path, "/") and string_length(components.path) > 1:
        components.path = string_substring(components.path, 0, string_length(components.path) - 1)
    build_uri(components)

# ============================================================================
# Helper Functions (String operations not in stdlib)
# ============================================================================

fn string_to_lower(s: text) -> text:
    var result = ""
    var i = 0
    while i < string_length(s):
        var ch = string_char_at(s, i)
        var code = string_char_code(ch)
        if code >= 65 and code <= 90:  # A-Z
            var lower_code = code + 32
            var lower_ch = string_from_char_code(lower_code)
            result = result + lower_ch
        else:
            result = result + ch
        i = i + 1
    result

fn string_starts_with(s: text, prefix: text) -> bool:
    var s_len = string_length(s)
    var p_len = string_length(prefix)
    if p_len > s_len:
        return false
    var i = 0
    while i < p_len:
        var s_ch = string_char_at(s, i)
        var p_ch = string_char_at(prefix, i)
        if s_ch != p_ch:
            return false
        i = i + 1
    true

fn string_ends_with(s: text, suffix: text) -> bool:
    var s_len = string_length(s)
    var suf_len = string_length(suffix)
    if suf_len > s_len:
        return false
    var start = s_len - suf_len
    var i = 0
    while i < suf_len:
        var s_ch = string_char_at(s, start + i)
        var suf_ch = string_char_at(suffix, i)
        if s_ch != suf_ch:
            return false
        i = i + 1
    true

fn string_index_of(s: text, needle: text) -> i64:
    var s_len = string_length(s)
    var n_len = string_length(needle)
    if n_len == 0 or n_len > s_len:
        return -1
    var i = 0
    while i <= s_len - n_len:
        var match = true
        var j = 0
        while j < n_len:
            var s_ch = string_char_at(s, i + j)
            var n_ch = string_char_at(needle, j)
            if s_ch != n_ch:
                match = false
            j = j + 1
        if match:
            return i
        i = i + 1
    -1

fn string_last_index_of(s: text, needle: text) -> i64:
    var s_len = string_length(s)
    var n_len = string_length(needle)
    if n_len == 0 or n_len > s_len:
        return -1
    var i = s_len - n_len
    while i >= 0:
        var match = true
        var j = 0
        while j < n_len:
            var s_ch = string_char_at(s, i + j)
            var n_ch = string_char_at(needle, j)
            if s_ch != n_ch:
                match = false
            j = j + 1
        if match:
            return i
        i = i - 1
    -1

fn string_replace_all(s: text, old: text, new: text) -> text:
    var result = ""
    var i = 0
    var s_len = string_length(s)
    var old_len = string_length(old)

    while i < s_len:
        var found = true
        var j = 0
        while j < old_len and i + j < s_len:
            var s_ch = string_char_at(s, i + j)
            var old_ch = string_char_at(old, j)
            if s_ch != old_ch:
                found = false
            j = j + 1

        if found and j == old_len:
            result = result + new
            i = i + old_len
        else:
            var ch = string_char_at(s, i)
            result = result + ch
            i = i + 1

    result

fn string_contains(s: text, needle: text) -> bool:
    string_index_of(s, needle) >= 0
