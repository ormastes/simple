# Union-Find (Disjoint Set) Utilities
#
# Efficient data structure for tracking disjoint sets with union and find operations.
# Pure Simple implementation - no external dependencies.
#
# The Union-Find (also called Disjoint Set Union, DSU) data structure maintains
# a collection of non-overlapping sets. It supports two main operations:
# - find: Determine which set an element belongs to
# - union: Merge two sets into one
#
# Optimizations:
# - Path compression: During find, flatten tree to reduce future lookups
# - Union by rank/size: Merge smaller tree under larger to keep trees shallow
#
# Representation:
# UnionFind = (parent: array, rank: array, size: array, count: i64)
# - parent[i]: parent of element i (or i if root)
# - rank[i]: approximate depth of tree rooted at i
# - size[i]: number of elements in set rooted at i
# - count: number of disjoint sets
#
# Functions:
# - Core: uf_create, uf_find, uf_union, uf_connected
# - Queries: uf_count_sets, uf_set_size, uf_all_sets, uf_representatives
# - Applications: connected_components, is_tree_check, detect_cycle_edges
# - Kruskal MST: kruskal_mst, kruskal_mst_cost
# - Utilities: uf_reset, uf_merge_sets, uf_compress_all

# ============================================================================
# Core Union-Find Operations
# ============================================================================

fn uf_create(n):
    """Create Union-Find structure for n elements (0 to n-1).

    Initially, each element is in its own set.

    Example:
        val uf = uf_create(5)  # 5 disjoint sets: {0}, {1}, {2}, {3}, {4}
    """
    var parent = []
    var rank = []
    var size = []

    var i = 0
    while i < n:
        parent.push(i)    # Each element is its own parent
        rank.push(0)      # Initial rank is 0
        size.push(1)      # Initial size is 1
        i = i + 1

    (parent, rank, size, n)

fn uf_find(uf, x):
    """Find root of set containing x (with path compression).

    Path compression: makes all nodes on path point directly to root,
    flattening the tree structure for future operations.

    Example:
        val root = uf_find(uf, 3)
    """
    val (parent, rank, size, count) = uf

    # Find root
    var root = x
    while parent[root] != root:
        root = parent[root]

    # Path compression: make all nodes on path point to root
    var current = x
    while current != root:
        val next = parent[current]
        parent[current] = root
        current = next

    root

fn uf_union(uf, x, y):
    """Union sets containing x and y (by rank).

    Attaches smaller tree under root of larger tree to keep trees shallow.
    Returns updated Union-Find structure.

    Example:
        val uf2 = uf_union(uf, 0, 1)  # Merge sets containing 0 and 1
    """
    val (parent, rank, size, count) = uf

    val root_x = uf_find(uf, x)
    val root_y = uf_find(uf, y)

    # Already in same set
    if root_x == root_y:
        return uf

    # Union by rank: attach smaller tree under larger
    if rank[root_x] < rank[root_y]:
        parent[root_x] = root_y
        size[root_y] = size[root_y] + size[root_x]
    else:
        if rank[root_x] == rank[root_y]:
            rank[root_x] = rank[root_x] + 1
        parent[root_y] = root_x
        size[root_x] = size[root_x] + size[root_y]

    (parent, rank, size, count - 1)

fn uf_connected(uf, x, y):
    """Check if x and y are in the same set.

    Example:
        uf_connected(uf, 0, 1)  # true if in same set
    """
    uf_find(uf, x) == uf_find(uf, y)

fn uf_same_set(uf, x, y):
    """Alias for uf_connected.

    Example:
        uf_same_set(uf, 2, 3)
    """
    uf_connected(uf, x, y)

# ============================================================================
# Query Operations
# ============================================================================

fn uf_count_sets(uf):
    """Get number of disjoint sets.

    Example:
        val num_sets = uf_count_sets(uf)  # 3 means 3 separate components
    """
    val (_, _, _, count) = uf
    count

fn uf_set_size(uf, x):
    """Get size of set containing x.

    Example:
        val sz = uf_set_size(uf, 0)  # Size of component containing 0
    """
    val (_, _, size, _) = uf
    val root = uf_find(uf, x)
    size[root]

fn uf_representatives(uf):
    """Get array of representative (root) elements from each set.

    Returns array of root elements, one per disjoint set.

    Example:
        uf_representatives(uf)  # [0, 3, 5] means 3 sets with roots 0, 3, 5
    """
    val (parent, _, _, _) = uf
    var roots = []

    var i = 0
    while i < parent.len():
        val root = uf_find(uf, i)

        # Check if root already in list
        var found = false
        for r in roots:
            if r == root:
                found = true
                break

        if not found:
            roots.push(root)

        i = i + 1

    roots

fn uf_all_sets(uf):
    """Get all sets as array of arrays.

    Returns array where each element is an array of elements in one set.

    Example:
        uf_all_sets(uf)  # [[0, 1, 2], [3, 4], [5]]
    """
    val (parent, _, _, _) = uf

    # Build map from root to elements
    var sets_map = []

    var i = 0
    while i < parent.len():
        val root = uf_find(uf, i)

        # Find or create set for this root
        var found_idx = -1
        var j = 0
        while j < sets_map.len():
            val (r, _) = sets_map[j]
            if r == root:
                found_idx = j
                break
            j = j + 1

        if found_idx == -1:
            # Create new set
            sets_map.push((root, [i]))
        else:
            # Add to existing set
            val (r, elements) = sets_map[found_idx]
            elements.push(i)
            sets_map[found_idx] = (r, elements)

        i = i + 1

    # Extract just the element arrays
    var result = []
    for (_, elements) in sets_map:
        result.push(elements)

    result

fn uf_elements_in_set(uf, x):
    """Get all elements in the same set as x.

    Example:
        uf_elements_in_set(uf, 0)  # [0, 1, 2] if 0, 1, 2 are connected
    """
    val (parent, _, _, _) = uf
    val root = uf_find(uf, x)

    var elements = []
    var i = 0
    while i < parent.len():
        if uf_find(uf, i) == root:
            elements.push(i)
        i = i + 1

    elements

# ============================================================================
# Advanced Operations
# ============================================================================

fn uf_reset(uf):
    """Reset Union-Find to initial state (all elements separate).

    Example:
        val uf2 = uf_reset(uf)  # Back to all separate sets
    """
    val (parent, _, _, _) = uf
    val n = parent.len()
    uf_create(n)

fn uf_merge_sets(uf, elements):
    """Merge all elements in array into single set.

    Example:
        val uf2 = uf_merge_sets(uf, [0, 2, 4])  # Merge 0, 2, 4 into one set
    """
    if elements.len() == 0:
        return uf

    var result = uf
    var first = elements[0]

    var i = 1
    while i < elements.len():
        result = uf_union(result, first, elements[i])
        i = i + 1

    result

fn uf_compress_all(uf):
    """Apply path compression to all elements.

    Forces all elements to point directly to their root for optimal
    subsequent operations. Useful after many union operations.

    Example:
        val uf2 = uf_compress_all(uf)
    """
    val (parent, rank, size, count) = uf

    var i = 0
    while i < parent.len():
        uf_find(uf, i)  # Side effect: compresses path
        i = i + 1

    uf

fn uf_set_sizes(uf):
    """Get array of sizes for all disjoint sets.

    Returns array of set sizes (one per set).

    Example:
        uf_set_sizes(uf)  # [3, 2, 1] means sets of size 3, 2, and 1
    """
    val roots = uf_representatives(uf)
    var sizes = []

    for root in roots:
        sizes.push(uf_set_size(uf, root))

    sizes

fn uf_largest_set_size(uf):
    """Get size of largest set.

    Example:
        uf_largest_set_size(uf)  # 5 if largest component has 5 elements
    """
    val sizes = uf_set_sizes(uf)

    if sizes.len() == 0:
        return 0

    var max_size = sizes[0]
    for sz in sizes:
        if sz > max_size:
            max_size = sz

    max_size

fn uf_smallest_set_size(uf):
    """Get size of smallest set.

    Example:
        uf_smallest_set_size(uf)  # 1 if smallest component has 1 element
    """
    val sizes = uf_set_sizes(uf)

    if sizes.len() == 0:
        return 0

    var min_size = sizes[0]
    for sz in sizes:
        if sz < min_size:
            min_size = sz

    min_size

# ============================================================================
# Graph Applications
# ============================================================================

fn connected_components_uf(edges, n):
    """Find connected components in undirected graph using Union-Find.

    edges: array of (u, v) tuples representing undirected edges
    n: number of nodes (0 to n-1)

    Returns (uf, components) where components is array of arrays.

    Example:
        val edges = [(0, 1), (1, 2), (3, 4)]
        val (uf, comps) = connected_components_uf(edges, 5)
        # comps = [[0, 1, 2], [3, 4]]
    """
    var uf = uf_create(n)

    for (u, v) in edges:
        uf = uf_union(uf, u, v)

    val components = uf_all_sets(uf)
    (uf, components)

fn count_components(edges, n):
    """Count number of connected components.

    Example:
        count_components([(0, 1), (2, 3)], 4)  # 2 components
    """
    val (uf, _) = connected_components_uf(edges, n)
    uf_count_sets(uf)

fn is_tree_check(edges, n):
    """Check if undirected graph is a tree.

    A tree has exactly n-1 edges and is connected (one component).

    Example:
        is_tree_check([(0, 1), (1, 2)], 3)  # true
        is_tree_check([(0, 1), (1, 2), (2, 0)], 3)  # false (has cycle)
    """
    # Tree must have exactly n-1 edges
    if edges.len() != n - 1:
        return false

    # Tree must be connected (one component)
    val num_components = count_components(edges, n)
    num_components == 1

fn detect_cycle_edges(edges, n):
    """Detect cycle edges in undirected graph.

    Returns array of edges that create cycles when added.
    An edge creates a cycle if both endpoints are already connected.

    Example:
        val cycle_edges = detect_cycle_edges([(0, 1), (1, 2), (2, 0)], 3)
        # cycle_edges = [(2, 0)]  # This edge creates the cycle
    """
    var uf = uf_create(n)
    var cycle_edges = []

    for edge in edges:
        val (u, v) = edge

        if uf_connected(uf, u, v):
            # Edge creates a cycle
            cycle_edges.push(edge)
        else:
            uf = uf_union(uf, u, v)

    cycle_edges

fn has_cycle(edges, n):
    """Check if undirected graph has a cycle.

    Example:
        has_cycle([(0, 1), (1, 2), (2, 0)], 3)  # true
        has_cycle([(0, 1), (1, 2)], 3)  # false
    """
    val cycle_edges = detect_cycle_edges(edges, n)
    cycle_edges.len() > 0

# ============================================================================
# Kruskal's MST Algorithm
# ============================================================================

fn kruskal_mst(edges, n):
    """Find Minimum Spanning Tree using Kruskal's algorithm.

    edges: array of (u, v, weight) tuples
    n: number of nodes (0 to n-1)

    Returns array of edges in MST, or nil if graph is not connected.

    Example:
        val edges = [(0, 1, 4), (1, 2, 8), (0, 2, 7)]
        val mst = kruskal_mst(edges, 3)  # [(0, 1, 4), (0, 2, 7)]
    """
    # Sort edges by weight (simple bubble sort)
    var sorted_edges = edges
    var changed = true
    while changed:
        changed = false
        var i = 0
        while i < sorted_edges.len() - 1:
            val (_, _, w1) = sorted_edges[i]
            val (_, _, w2) = sorted_edges[i + 1]
            if w1 > w2:
                val temp = sorted_edges[i]
                sorted_edges[i] = sorted_edges[i + 1]
                sorted_edges[i + 1] = temp
                changed = true
            i = i + 1

    var uf = uf_create(n)
    var mst_edges = []

    for edge in sorted_edges:
        val (u, v, weight) = edge

        # Add edge if it doesn't create a cycle
        if not uf_connected(uf, u, v):
            mst_edges.push(edge)
            uf = uf_union(uf, u, v)

            # MST complete when we have n-1 edges
            if mst_edges.len() == n - 1:
                break

    # Check if graph is connected
    if mst_edges.len() != n - 1:
        return nil

    mst_edges

fn kruskal_mst_cost(edges, n):
    """Calculate total cost of MST.

    Returns total weight of MST, or nil if graph is not connected.

    Example:
        kruskal_mst_cost([(0, 1, 4), (1, 2, 8), (0, 2, 7)], 3)  # 11
    """
    val mst = kruskal_mst(edges, n)

    if not mst.?:
        return nil

    var total = 0
    for (_, _, weight) in mst:
        total = total + weight

    total

fn kruskal_forest(edges, n):
    """Find Minimum Spanning Forest (MST for each component).

    Similar to kruskal_mst but works on disconnected graphs.
    Returns array of edges forming the forest.

    Example:
        val edges = [(0, 1, 4), (3, 4, 5)]
        kruskal_forest(edges, 5)  # [(0, 1, 4), (3, 4, 5)]
    """
    # Sort edges by weight
    var sorted_edges = edges
    var changed = true
    while changed:
        changed = false
        var i = 0
        while i < sorted_edges.len() - 1:
            val (_, _, w1) = sorted_edges[i]
            val (_, _, w2) = sorted_edges[i + 1]
            if w1 > w2:
                val temp = sorted_edges[i]
                sorted_edges[i] = sorted_edges[i + 1]
                sorted_edges[i + 1] = temp
                changed = true
            i = i + 1

    var uf = uf_create(n)
    var forest_edges = []

    for edge in sorted_edges:
        val (u, v, weight) = edge

        if not uf_connected(uf, u, v):
            forest_edges.push(edge)
            uf = uf_union(uf, u, v)

    forest_edges

# ============================================================================
# Path and Component Queries
# ============================================================================

fn are_all_connected(uf, elements):
    """Check if all elements are in the same set.

    Example:
        are_all_connected(uf, [0, 1, 2])  # true if all in same component
    """
    if elements.len() <= 1:
        return true

    val first_root = uf_find(uf, elements[0])

    var i = 1
    while i < elements.len():
        if uf_find(uf, elements[i]) != first_root:
            return false
        i = i + 1

    true

fn partition_by_sets(uf, elements):
    """Partition elements into groups by their sets.

    Returns array of arrays, where each inner array contains elements
    from the same set.

    Example:
        partition_by_sets(uf, [0, 1, 2, 3, 4])
        # [[0, 2], [1, 3, 4]] if 0,2 are connected and 1,3,4 are connected
    """
    var groups = []

    for elem in elements:
        val root = uf_find(uf, elem)

        # Find or create group for this root
        var found_idx = -1
        var i = 0
        while i < groups.len():
            val (group_root, _) = groups[i]
            if group_root == root:
                found_idx = i
                break
            i = i + 1

        if found_idx == -1:
            groups.push((root, [elem]))
        else:
            val (r, group_elems) = groups[found_idx]
            group_elems.push(elem)
            groups[found_idx] = (r, group_elems)

    # Extract just element arrays
    var result = []
    for (_, group_elems) in groups:
        result.push(group_elems)

    result

# ============================================================================
# Union-Find with Custom Weights
# ============================================================================

fn uf_create_weighted(n):
    """Create weighted Union-Find structure.

    Extends standard UF with weight tracking for weighted quick-union.
    Structure: (parent, rank, size, weight, count)

    Example:
        val wuf = uf_create_weighted(5)
    """
    var parent = []
    var rank = []
    var size = []
    var weight = []

    var i = 0
    while i < n:
        parent.push(i)
        rank.push(0)
        size.push(1)
        weight.push(0)
        i = i + 1

    (parent, rank, size, weight, n)

fn uf_union_weighted(uf, x, y, w):
    """Union with weight: weight[x] + w = weight[y].

    Maintains relative weights between elements in same set.
    Useful for coordinate systems, distance tracking, etc.

    Example:
        val wuf = uf_union_weighted(wuf, 0, 1, 5)  # weight[1] = weight[0] + 5
    """
    val (parent, rank, size, weight, count) = uf

    val root_x = uf_find(uf, x)
    val root_y = uf_find(uf, y)

    if root_x == root_y:
        return uf

    # Calculate relative weight
    val weight_diff = weight[x] + w - weight[y]

    # Union by rank
    if rank[root_x] < rank[root_y]:
        parent[root_x] = root_y
        weight[root_x] = weight_diff
        size[root_y] = size[root_y] + size[root_x]
    else:
        if rank[root_x] == rank[root_y]:
            rank[root_x] = rank[root_x] + 1
        parent[root_y] = root_x
        weight[root_y] = 0 - weight_diff
        size[root_x] = size[root_x] + size[root_y]

    (parent, rank, size, weight, count - 1)

fn uf_weight_diff(uf, x, y):
    """Get weight difference between x and y if in same set.

    Returns weight[y] - weight[x], or nil if not connected.

    Example:
        uf_weight_diff(wuf, 0, 1)  # 5 if union_weighted(0, 1, 5) was called
    """
    if not uf_connected(uf, x, y):
        return nil

    val (_, _, _, weight, _) = uf
    weight[y] - weight[x]

# ============================================================================
# Statistics and Analysis
# ============================================================================

fn uf_statistics(uf):
    """Get comprehensive statistics about Union-Find structure.

    Returns tuple:
    (num_sets, total_elements, avg_set_size, max_set_size, min_set_size)

    Example:
        val (sets, elems, avg, max, min) = uf_statistics(uf)
    """
    val (parent, _, _, _) = uf
    val num_sets = uf_count_sets(uf)
    val total_elements = parent.len()
    val sizes = uf_set_sizes(uf)

    var max_size = 0
    var min_size = 0
    var sum_size = 0

    if sizes.len() > 0:
        max_size = sizes[0]
        min_size = sizes[0]

        for sz in sizes:
            sum_size = sum_size + sz
            if sz > max_size:
                max_size = sz
            if sz < min_size:
                min_size = sz

    val avg_size = if num_sets > 0: sum_size / num_sets else: 0

    (num_sets, total_elements, avg_size, max_size, min_size)

fn uf_is_fully_connected(uf):
    """Check if all elements are in single set.

    Example:
        uf_is_fully_connected(uf)  # true if only one component
    """
    uf_count_sets(uf) == 1

fn uf_is_fully_disconnected(uf):
    """Check if all elements are in separate sets.

    Example:
        uf_is_fully_disconnected(uf)  # true if no unions performed
    """
    val (parent, _, _, _) = uf
    uf_count_sets(uf) == parent.len()

# ============================================================================
# Batch Operations
# ============================================================================

fn uf_union_all(uf, pairs):
    """Perform union on array of (x, y) pairs.

    Example:
        val uf2 = uf_union_all(uf, [(0, 1), (2, 3), (1, 2)])
    """
    var result = uf
    for (x, y) in pairs:
        result = uf_union(result, x, y)
    result

fn uf_connected_all(uf, pairs):
    """Check if all pairs are connected.

    Returns true only if every (x, y) pair is in the same set.

    Example:
        uf_connected_all(uf, [(0, 1), (1, 2)])  # true if 0,1,2 all connected
    """
    for (x, y) in pairs:
        if not uf_connected(uf, x, y):
            return false
    true

fn uf_connected_any(uf, pairs):
    """Check if any pair is connected.

    Returns true if at least one (x, y) pair is in the same set.

    Example:
        uf_connected_any(uf, [(0, 1), (2, 3)])  # true if either pair connected
    """
    for (x, y) in pairs:
        if uf_connected(uf, x, y):
            return true
    false

# ============================================================================
# Examples and Test Helpers
# ============================================================================

fn uf_example_graph():
    """Create example Union-Find structure with sample graph.

    Graph has 10 nodes with three components:
    - Component 1: {0, 1, 2, 3}
    - Component 2: {4, 5, 6}
    - Component 3: {7, 8, 9}

    Example:
        val uf = uf_example_graph()
        uf_count_sets(uf)  # 3
    """
    var uf = uf_create(10)

    # Component 1: 0-1-2-3
    uf = uf_union(uf, 0, 1)
    uf = uf_union(uf, 1, 2)
    uf = uf_union(uf, 2, 3)

    # Component 2: 4-5-6
    uf = uf_union(uf, 4, 5)
    uf = uf_union(uf, 5, 6)

    # Component 3: 7-8-9
    uf = uf_union(uf, 7, 8)
    uf = uf_union(uf, 8, 9)

    uf

fn uf_print_structure(uf):
    """Print Union-Find structure for debugging.

    Shows parent array, ranks, sizes, and component count.

    Example:
        uf_print_structure(uf)
    """
    val (parent, rank, size, count) = uf

    print "Union-Find Structure:"
    print "  Elements: {parent.len()}"
    print "  Components: {count}"
    print "  Parent: {parent}"
    print "  Rank: {rank}"
    print "  Size: {size}"
    print ""

fn uf_print_sets(uf):
    """Print all disjoint sets.

    Example:
        uf_print_sets(uf)
        # Output:
        # Set 0: [0, 1, 2]
        # Set 1: [3, 4]
    """
    val sets = uf_all_sets(uf)

    print "Disjoint Sets:"
    var i = 0
    for s in sets:
        print "  Set {i}: {s}"
        i = i + 1
    print ""
