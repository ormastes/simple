# Standard Library â€” Result Chaining Methods
#
# @tag:api
# @tag:stdlib
#
# Functional chaining methods for Result/Option values.
# Simple language uses nil = None/Error, non-nil = Some/Ok convention.
#
# Result convention:
#   - nil   = failure/error
#   - value = success
#
# Usage:
#   val result = ok_value
#   val mapped = result_map(result, fn(x): x * 2)
#   val or_val = result_unwrap_or(mapped, 0)

# Maps a successful result value with a transform function.
# Returns nil if input is nil (propagates failure).
fn result_map(res, transform: fn()) -> i64:
    if res == nil:
        return nil
    transform(res)

# Maps an error (nil) to a different error or value.
# Called only when res is nil.
fn result_map_err(res, on_error: fn()):
    if res != nil:
        return res
    on_error()

# Chains a function that returns a Result (flatMap for Result).
# Called only when res is not nil.
fn result_and_then(res, chain: fn()):
    if res == nil:
        return nil
    chain(res)

# Returns alternative if res is nil.
fn result_or_else(res, alternative: fn()):
    if res != nil:
        return res
    alternative()

# Returns the value or a default if nil.
fn result_unwrap_or(res, default_val):
    if res == nil:
        return default_val
    res

# Returns the value or calls a function to produce default.
fn result_unwrap_or_else(res, default_fn: fn()):
    if res == nil:
        return default_fn()
    res

# Returns true if result is successful (not nil).
fn result_is_ok(res) -> bool:
    res != nil

# Returns true if result is a failure (nil).
fn result_is_err(res) -> bool:
    res == nil

# Converts an Option to a Result, treating nil as error.
fn result_from_option(opt, error_msg: text):
    if opt == nil:
        return nil
    opt

export result_map, result_map_err, result_and_then, result_or_else
export result_unwrap_or, result_unwrap_or_else
export result_is_ok, result_is_err, result_from_option
