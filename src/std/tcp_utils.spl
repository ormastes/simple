# TCP Socket Utilities Module
# Comprehensive TCP socket management, connection handling, and protocol state management

# Connection State Constants
val TCP_STATE_CLOSED = 0
val TCP_STATE_LISTEN = 1
val TCP_STATE_SYN_SENT = 2
val TCP_STATE_SYN_RECEIVED = 3
val TCP_STATE_ESTABLISHED = 4
val TCP_STATE_FIN_WAIT_1 = 5
val TCP_STATE_FIN_WAIT_2 = 6
val TCP_STATE_CLOSE_WAIT = 7
val TCP_STATE_CLOSING = 8
val TCP_STATE_LAST_ACK = 9
val TCP_STATE_TIME_WAIT = 10

# Socket Option Constants
val TCP_OPT_KEEPALIVE = 1
val TCP_OPT_NODELAY = 2
val TCP_OPT_QUICKACK = 3
val TCP_OPT_CORK = 4
val TCP_OPT_LINGER = 5
val TCP_OPT_REUSEADDR = 6
val TCP_OPT_REUSEPORT = 7

# Buffer Size Constants
val TCP_DEFAULT_RECV_BUFFER = 65536
val TCP_DEFAULT_SEND_BUFFER = 65536
val TCP_MAX_BUFFER_SIZE = 2097152
val TCP_MIN_BUFFER_SIZE = 1024

# Port Range Constants
val TCP_MIN_PORT = 1
val TCP_MAX_PORT = 65535
val TCP_EPHEMERAL_START = 49152
val TCP_EPHEMERAL_END = 65535
val TCP_WELL_KNOWN_END = 1023
val TCP_REGISTERED_END = 49151

# Timeout Constants (milliseconds)
val TCP_DEFAULT_CONNECT_TIMEOUT = 30000
val TCP_DEFAULT_READ_TIMEOUT = 60000
val TCP_DEFAULT_WRITE_TIMEOUT = 60000
val TCP_KEEPALIVE_INTERVAL = 75000

# Connection Pool Constants
val TCP_POOL_DEFAULT_SIZE = 10
val TCP_POOL_MAX_SIZE = 100
val TCP_POOL_IDLE_TIMEOUT = 300000

# Error Constants
val TCP_ERR_INVALID_ADDRESS = -1
val TCP_ERR_INVALID_PORT = -2
val TCP_ERR_CONNECTION_REFUSED = -3
val TCP_ERR_TIMEOUT = -4
val TCP_ERR_BUFFER_FULL = -5
val TCP_ERR_INVALID_STATE = -6
val TCP_ERR_POOL_FULL = -7

# ============================================================================
# Core Connection Structure Functions
# ============================================================================

# Create a new TCP connection tuple
# Returns: (address, port, state, recv_buffer, send_buffer, options, timestamp)
fn tcp_connection_create(address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val empty_buffer = ""
    val empty_options = []
    val timestamp = 0
    (address, port, TCP_STATE_CLOSED, empty_buffer, empty_buffer, empty_options, timestamp)

# Get connection address
fn tcp_connection_get_address(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val addr = conn.0
    addr

# Get connection port
fn tcp_connection_get_port(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val port = conn.1
    port

# Get connection state
fn tcp_connection_get_state(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val state = conn.2
    state

# Get receive buffer
fn tcp_connection_get_recv_buffer(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val buffer = conn.3
    buffer

# Get send buffer
fn tcp_connection_get_send_buffer(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val buffer = conn.4
    buffer

# Get connection options
fn tcp_connection_get_options(conn: (text, i64, i64, text, text, list, i64)) -> list:
    val opts = conn.5
    opts

# Get connection timestamp
fn tcp_connection_get_timestamp(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val ts = conn.6
    ts

# Set connection state
fn tcp_connection_set_state(conn: (text, i64, i64, text, text, list, i64), state: i64) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val recv_buf = conn.3
    val send_buf = conn.4
    val opts = conn.5
    val ts = conn.6
    (addr, port, state, recv_buf, send_buf, opts, ts)

# Set receive buffer
fn tcp_connection_set_recv_buffer(conn: (text, i64, i64, text, text, list, i64), buffer: text) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val send_buf = conn.4
    val opts = conn.5
    val ts = conn.6
    (addr, port, state, buffer, send_buf, opts, ts)

# Set send buffer
fn tcp_connection_set_send_buffer(conn: (text, i64, i64, text, text, list, i64), buffer: text) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val recv_buf = conn.3
    val opts = conn.5
    val ts = conn.6
    (addr, port, state, recv_buf, buffer, opts, ts)

# Set connection options
fn tcp_connection_set_options(conn: (text, i64, i64, text, text, list, i64), options: list) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val recv_buf = conn.3
    val send_buf = conn.4
    val ts = conn.6
    (addr, port, state, recv_buf, send_buf, options, ts)

# Set connection timestamp
fn tcp_connection_set_timestamp(conn: (text, i64, i64, text, text, list, i64), timestamp: i64) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val recv_buf = conn.3
    val send_buf = conn.4
    val opts = conn.5
    (addr, port, state, recv_buf, send_buf, opts, timestamp)

# ============================================================================
# Connection State Management
# ============================================================================

# Get state name from state code
fn tcp_state_to_string(state: i64) -> text:
    if state == TCP_STATE_CLOSED:
        "CLOSED"
    else:
        if state == TCP_STATE_LISTEN:
            "LISTEN"
        else:
            if state == TCP_STATE_SYN_SENT:
                "SYN_SENT"
            else:
                if state == TCP_STATE_SYN_RECEIVED:
                    "SYN_RECEIVED"
                else:
                    if state == TCP_STATE_ESTABLISHED:
                        "ESTABLISHED"
                    else:
                        if state == TCP_STATE_FIN_WAIT_1:
                            "FIN_WAIT_1"
                        else:
                            if state == TCP_STATE_FIN_WAIT_2:
                                "FIN_WAIT_2"
                            else:
                                if state == TCP_STATE_CLOSE_WAIT:
                                    "CLOSE_WAIT"
                                else:
                                    if state == TCP_STATE_CLOSING:
                                        "CLOSING"
                                    else:
                                        if state == TCP_STATE_LAST_ACK:
                                            "LAST_ACK"
                                        else:
                                            if state == TCP_STATE_TIME_WAIT:
                                                "TIME_WAIT"
                                            else:
                                                "UNKNOWN"

# Check if state is valid
fn tcp_state_is_valid(state: i64) -> bool:
    val valid = state >= TCP_STATE_CLOSED
    if valid:
        state <= TCP_STATE_TIME_WAIT
    else:
        false

# Check if connection can send data
fn tcp_state_can_send(state: i64) -> bool:
    val established = state == TCP_STATE_ESTABLISHED
    if established:
        true
    else:
        state == TCP_STATE_CLOSE_WAIT

# Check if connection can receive data
fn tcp_state_can_receive(state: i64) -> bool:
    val established = state == TCP_STATE_ESTABLISHED
    if established:
        true
    else:
        val fin_wait = state == TCP_STATE_FIN_WAIT_1
        if fin_wait:
            true
        else:
            state == TCP_STATE_FIN_WAIT_2

# Check if connection is closed
fn tcp_state_is_closed(state: i64) -> bool:
    state == TCP_STATE_CLOSED

# Check if connection is established
fn tcp_state_is_established(state: i64) -> bool:
    state == TCP_STATE_ESTABLISHED

# Check if connection is listening
fn tcp_state_is_listening(state: i64) -> bool:
    state == TCP_STATE_LISTEN

# Validate state transition
fn tcp_state_transition_valid(from_state: i64, to_state: i64) -> bool:
    if from_state == TCP_STATE_CLOSED:
        val listen = to_state == TCP_STATE_LISTEN
        if listen:
            true
        else:
            to_state == TCP_STATE_SYN_SENT
    else:
        if from_state == TCP_STATE_LISTEN:
            val syn_recv = to_state == TCP_STATE_SYN_RECEIVED
            if syn_recv:
                true
            else:
                to_state == TCP_STATE_CLOSED
        else:
            if from_state == TCP_STATE_SYN_SENT:
                val established = to_state == TCP_STATE_ESTABLISHED
                if established:
                    true
                else:
                    val syn_recv = to_state == TCP_STATE_SYN_RECEIVED
                    if syn_recv:
                        true
                    else:
                        to_state == TCP_STATE_CLOSED
            else:
                if from_state == TCP_STATE_ESTABLISHED:
                    val fin_wait = to_state == TCP_STATE_FIN_WAIT_1
                    if fin_wait:
                        true
                    else:
                        to_state == TCP_STATE_CLOSE_WAIT
                else:
                    true

# ============================================================================
# Address Validation and Parsing
# ============================================================================

# Validate IPv4 address format
fn tcp_ipv4_is_valid(address: text) -> bool:
    val parts = address.split(".")
    val len = parts.len()
    if len == 4:
        tcp_ipv4_validate_parts(parts, 0)
    else:
        false

# Helper to validate IPv4 parts
fn tcp_ipv4_validate_parts(parts: list, index: i64) -> bool:
    val len = parts.len()
    if index >= len:
        true
    else:
        val part = parts.get(index)
        val part_str = part.to_str()
        val part_len = part_str.len()
        if part_len > 0:
            val valid = tcp_ipv4_part_is_digit(part_str)
            if valid:
                tcp_ipv4_validate_parts(parts, index + 1)
            else:
                false
        else:
            false

# Check if string contains only digits
fn tcp_ipv4_part_is_digit(s: text) -> bool:
    val len = s.len()
    if len > 0:
        val valid = len <= 3
        if valid:
            true
        else:
            false
    else:
        false

# Parse IPv4 address to tuple
fn tcp_ipv4_parse(address: text) -> (i64, i64, i64, i64):
    val parts = address.split(".")
    val a = 0
    val b = 0
    val c = 0
    val d = 0
    (a, b, c, d)

# Format IPv4 from tuple
fn tcp_ipv4_format(octets: (i64, i64, i64, i64)) -> text:
    val a = octets.0
    val b = octets.1
    val c = octets.2
    val d = octets.3
    val a_str = a.to_str()
    val b_str = b.to_str()
    val c_str = c.to_str()
    val d_str = d.to_str()
    val part1 = a_str + "."
    val part2 = part1 + b_str
    val part3 = part2 + "."
    val part4 = part3 + c_str
    val part5 = part4 + "."
    val result = part5 + d_str
    result

# Check if IPv4 is loopback
fn tcp_ipv4_is_loopback(address: text) -> bool:
    val starts = address.starts_with("127.")
    starts

# Check if IPv4 is private
fn tcp_ipv4_is_private(address: text) -> bool:
    val class_a = address.starts_with("10.")
    if class_a:
        true
    else:
        val class_b = address.starts_with("192.168.")
        if class_b:
            true
        else:
            address.starts_with("172.")

# Check if IPv4 is multicast
fn tcp_ipv4_is_multicast(address: text) -> bool:
    address.starts_with("224.")

# Validate IPv6 address (simplified)
fn tcp_ipv6_is_valid(address: text) -> bool:
    val contains_colon = address.contains(":")
    if contains_colon:
        val parts = address.split(":")
        val len = parts.len()
        val valid = len >= 2
        if valid:
            len <= 8
        else:
            false
    else:
        false

# Check if IPv6 is loopback
fn tcp_ipv6_is_loopback(address: text) -> bool:
    val loopback = address == "::1"
    loopback

# Format address with port
fn tcp_address_format(address: text, port: i64) -> text:
    val is_ipv6 = address.contains(":")
    if is_ipv6:
        val bracket_start = "["
        val with_addr = bracket_start + address
        val with_bracket = with_addr + "]:"
        val port_str = port.to_str()
        val result = with_bracket + port_str
        result
    else:
        val with_addr = address + ":"
        val port_str = port.to_str()
        val result = with_addr + port_str
        result

# ============================================================================
# Port Operations
# ============================================================================

# Validate port number
fn tcp_port_is_valid(port: i64) -> bool:
    val min_valid = port >= TCP_MIN_PORT
    if min_valid:
        port <= TCP_MAX_PORT
    else:
        false

# Check if port is well-known
fn tcp_port_is_well_known(port: i64) -> bool:
    val valid = port >= TCP_MIN_PORT
    if valid:
        port <= TCP_WELL_KNOWN_END
    else:
        false

# Check if port is registered
fn tcp_port_is_registered(port: i64) -> bool:
    val start_valid = port > TCP_WELL_KNOWN_END
    if start_valid:
        port <= TCP_REGISTERED_END
    else:
        false

# Check if port is ephemeral
fn tcp_port_is_ephemeral(port: i64) -> bool:
    val start_valid = port >= TCP_EPHEMERAL_START
    if start_valid:
        port <= TCP_EPHEMERAL_END
    else:
        false

# Allocate ephemeral port (simple counter-based)
fn tcp_port_allocate_ephemeral(used_ports: list) -> i64:
    tcp_port_find_free(TCP_EPHEMERAL_START, used_ports)

# Find next free port
fn tcp_port_find_free(start_port: i64, used_ports: list) -> i64:
    val candidate = start_port
    val is_used = tcp_port_in_list(candidate, used_ports)
    if is_used:
        val next = start_port + 1
        val valid = next <= TCP_EPHEMERAL_END
        if valid:
            tcp_port_find_free(next, used_ports)
        else:
            TCP_EPHEMERAL_START
    else:
        candidate

# Check if port is in list
fn tcp_port_in_list(port: i64, ports: list) -> bool:
    val len = ports.len()
    tcp_port_in_list_helper(port, ports, 0, len)

# Helper for port list check
fn tcp_port_in_list_helper(port: i64, ports: list, index: i64, len: i64) -> bool:
    if index >= len:
        false
    else:
        val current = ports.get(index)
        val current_port = current.to_i64()
        val matches = current_port == port
        if matches:
            true
        else:
            val next_idx = index + 1
            tcp_port_in_list_helper(port, ports, next_idx, len)

# Get standard port for service
fn tcp_port_get_standard(service: text) -> i64:
    if service == "http":
        80
    else:
        if service == "https":
            443
        else:
            if service == "ftp":
                21
            else:
                if service == "ssh":
                    22
                else:
                    if service == "smtp":
                        25
                    else:
                        if service == "dns":
                            53
                        else:
                            if service == "pop3":
                                110
                            else:
                                if service == "imap":
                                    143
                                else:
                                    0

# ============================================================================
# Socket Operations
# ============================================================================

# Connect to remote address
fn tcp_connect(address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val addr_valid = tcp_ipv4_is_valid(address)
    if addr_valid:
        val port_valid = tcp_port_is_valid(port)
        if port_valid:
            val conn = tcp_connection_create(address, port)
            val syn_sent = tcp_connection_set_state(conn, TCP_STATE_SYN_SENT)
            syn_sent
        else:
            tcp_connection_create("", TCP_ERR_INVALID_PORT)
    else:
        tcp_connection_create("", TCP_ERR_INVALID_ADDRESS)

# Bind to local address
fn tcp_bind(address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val addr_valid = tcp_ipv4_is_valid(address)
    if addr_valid:
        val port_valid = tcp_port_is_valid(port)
        if port_valid:
            tcp_connection_create(address, port)
        else:
            tcp_connection_create("", TCP_ERR_INVALID_PORT)
    else:
        tcp_connection_create("", TCP_ERR_INVALID_ADDRESS)

# Listen on bound socket
fn tcp_listen(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val state = tcp_connection_get_state(conn)
    val is_closed = state == TCP_STATE_CLOSED
    if is_closed:
        tcp_connection_set_state(conn, TCP_STATE_LISTEN)
    else:
        conn

# Accept incoming connection
fn tcp_accept(server_conn: (text, i64, i64, text, text, list, i64), client_addr: text, client_port: i64) -> (text, i64, i64, text, text, list, i64):
    val state = tcp_connection_get_state(server_conn)
    val is_listening = state == TCP_STATE_LISTEN
    if is_listening:
        val new_conn = tcp_connection_create(client_addr, client_port)
        tcp_connection_set_state(new_conn, TCP_STATE_ESTABLISHED)
    else:
        tcp_connection_create("", TCP_ERR_INVALID_STATE)

# Complete connection (SYN_SENT -> ESTABLISHED)
fn tcp_complete_connect(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val state = tcp_connection_get_state(conn)
    val is_syn_sent = state == TCP_STATE_SYN_SENT
    if is_syn_sent:
        tcp_connection_set_state(conn, TCP_STATE_ESTABLISHED)
    else:
        conn

# Close connection gracefully
fn tcp_close(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val state = tcp_connection_get_state(conn)
    val is_established = state == TCP_STATE_ESTABLISHED
    if is_established:
        tcp_connection_set_state(conn, TCP_STATE_FIN_WAIT_1)
    else:
        val is_close_wait = state == TCP_STATE_CLOSE_WAIT
        if is_close_wait:
            tcp_connection_set_state(conn, TCP_STATE_LAST_ACK)
        else:
            tcp_connection_set_state(conn, TCP_STATE_CLOSED)

# Abort connection immediately
fn tcp_abort(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    tcp_connection_set_state(conn, TCP_STATE_CLOSED)

# ============================================================================
# Data Operations
# ============================================================================

# Send data (add to send buffer)
fn tcp_send(conn: (text, i64, i64, text, text, list, i64), data: text) -> (text, i64, i64, text, text, list, i64):
    val state = tcp_connection_get_state(conn)
    val can_send = tcp_state_can_send(state)
    if can_send:
        val current_buf = tcp_connection_get_send_buffer(conn)
        val new_buf = current_buf + data
        tcp_connection_set_send_buffer(conn, new_buf)
    else:
        conn

# Receive data (read from receive buffer)
fn tcp_receive(conn: (text, i64, i64, text, text, list, i64), max_bytes: i64) -> (text, (text, i64, i64, text, text, list, i64)):
    val state = tcp_connection_get_state(conn)
    val can_recv = tcp_state_can_receive(state)
    if can_recv:
        val buffer = tcp_connection_get_recv_buffer(conn)
        val buf_len = buffer.len()
        if buf_len > max_bytes:
            val data = buffer.substring(0, max_bytes)
            val remaining = buffer.substring(max_bytes, buf_len)
            val new_conn = tcp_connection_set_recv_buffer(conn, remaining)
            (data, new_conn)
        else:
            val empty = ""
            val new_conn = tcp_connection_set_recv_buffer(conn, empty)
            (buffer, new_conn)
    else:
        val empty = ""
        (empty, conn)

# Add data to receive buffer (simulates incoming data)
fn tcp_buffer_receive(conn: (text, i64, i64, text, text, list, i64), data: text) -> (text, i64, i64, text, text, list, i64):
    val current_buf = tcp_connection_get_recv_buffer(conn)
    val new_buf = current_buf + data
    val new_len = new_buf.len()
    val exceeds = new_len > TCP_MAX_BUFFER_SIZE
    if exceeds:
        conn
    else:
        tcp_connection_set_recv_buffer(conn, new_buf)

# Flush send buffer
fn tcp_flush_send_buffer(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val empty = ""
    tcp_connection_set_send_buffer(conn, empty)

# Get receive buffer size
fn tcp_get_recv_buffer_size(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val buffer = tcp_connection_get_recv_buffer(conn)
    buffer.len()

# Get send buffer size
fn tcp_get_send_buffer_size(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val buffer = tcp_connection_get_send_buffer(conn)
    buffer.len()

# Check if receive buffer is empty
fn tcp_recv_buffer_is_empty(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val size = tcp_get_recv_buffer_size(conn)
    size == 0

# Check if send buffer is empty
fn tcp_send_buffer_is_empty(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val size = tcp_get_send_buffer_size(conn)
    size == 0

# ============================================================================
# Socket Options
# ============================================================================

# Create socket option tuple
fn tcp_option_create(option_type: i64, value: i64) -> (i64, i64):
    (option_type, value)

# Add option to connection
fn tcp_option_set(conn: (text, i64, i64, text, text, list, i64), option: (i64, i64)) -> (text, i64, i64, text, text, list, i64):
    val current_opts = tcp_connection_get_options(conn)
    val new_opts = current_opts.append(option)
    tcp_connection_set_options(conn, new_opts)

# Get option value
fn tcp_option_get(conn: (text, i64, i64, text, text, list, i64), option_type: i64) -> i64:
    val opts = tcp_connection_get_options(conn)
    tcp_option_find(opts, option_type, 0)

# Helper to find option in list
fn tcp_option_find(opts: list, option_type: i64, index: i64) -> i64:
    val len = opts.len()
    if index >= len:
        0
    else:
        val opt = opts.get(index)
        val opt_tuple = (opt.to_i64(), 0)
        val type_val = opt_tuple.0
        val matches = type_val == option_type
        if matches:
            opt_tuple.1
        else:
            val next = index + 1
            tcp_option_find(opts, option_type, next)

# Enable keepalive
fn tcp_enable_keepalive(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val opt = tcp_option_create(TCP_OPT_KEEPALIVE, 1)
    tcp_option_set(conn, opt)

# Disable Nagle algorithm
fn tcp_disable_nagle(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val opt = tcp_option_create(TCP_OPT_NODELAY, 1)
    tcp_option_set(conn, opt)

# Enable address reuse
fn tcp_enable_reuseaddr(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val opt = tcp_option_create(TCP_OPT_REUSEADDR, 1)
    tcp_option_set(conn, opt)

# Check if keepalive is enabled
fn tcp_has_keepalive(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val value = tcp_option_get(conn, TCP_OPT_KEEPALIVE)
    value == 1

# Check if Nagle is disabled
fn tcp_has_nodelay(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val value = tcp_option_get(conn, TCP_OPT_NODELAY)
    value == 1

# ============================================================================
# Connection Pool Management
# ============================================================================

# Create connection pool
fn tcp_pool_create(max_size: i64) -> (i64, list, i64):
    val empty_conns = []
    val timestamp = 0
    (max_size, empty_conns, timestamp)

# Get pool max size
fn tcp_pool_get_max_size(pool: (i64, list, i64)) -> i64:
    val size = pool.0
    size

# Get pool connections
fn tcp_pool_get_connections(pool: (i64, list, i64)) -> list:
    val conns = pool.1
    conns

# Get pool current size
fn tcp_pool_get_size(pool: (i64, list, i64)) -> i64:
    val conns = tcp_pool_get_connections(pool)
    conns.len()

# Check if pool is full
fn tcp_pool_is_full(pool: (i64, list, i64)) -> bool:
    val current = tcp_pool_get_size(pool)
    val max_size = tcp_pool_get_max_size(pool)
    current >= max_size

# Check if pool is empty
fn tcp_pool_is_empty(pool: (i64, list, i64)) -> bool:
    val size = tcp_pool_get_size(pool)
    size == 0

# Add connection to pool
fn tcp_pool_add(pool: (i64, list, i64), conn: (text, i64, i64, text, text, list, i64)) -> (i64, list, i64):
    val is_full = tcp_pool_is_full(pool)
    if is_full:
        pool
    else:
        val max_size = pool.0
        val conns = pool.1
        val timestamp = pool.2
        val new_conns = conns.append(conn)
        (max_size, new_conns, timestamp)

# Remove connection from pool by index
fn tcp_pool_remove(pool: (i64, list, i64), index: i64) -> (i64, list, i64):
    val conns = tcp_pool_get_connections(pool)
    val len = conns.len()
    if index >= len:
        pool
    else:
        val max_size = pool.0
        val timestamp = pool.2
        val new_conns = tcp_pool_remove_at(conns, index, [], 0)
        (max_size, new_conns, timestamp)

# Helper to remove connection at index
fn tcp_pool_remove_at(conns: list, target: i64, result: list, index: i64) -> list:
    val len = conns.len()
    if index >= len:
        result
    else:
        val is_target = index == target
        if is_target:
            val next = index + 1
            tcp_pool_remove_at(conns, target, result, next)
        else:
            val conn = conns.get(index)
            val new_result = result.append(conn)
            val next = index + 1
            tcp_pool_remove_at(conns, target, new_result, next)

# Get connection from pool
fn tcp_pool_get(pool: (i64, list, i64), address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val conns = tcp_pool_get_connections(pool)
    tcp_pool_find_connection(conns, address, port, 0)

# Helper to find matching connection
fn tcp_pool_find_connection(conns: list, address: text, port: i64, index: i64) -> (text, i64, i64, text, text, list, i64):
    val len = conns.len()
    if index >= len:
        tcp_connection_create("", 0)
    else:
        val conn = conns.get(index)
        val conn_tuple = tcp_connection_create("", 0)
        val conn_addr = tcp_connection_get_address(conn_tuple)
        val addr_match = conn_addr == address
        if addr_match:
            val conn_port = tcp_connection_get_port(conn_tuple)
            val port_match = conn_port == port
            if port_match:
                conn_tuple
            else:
                val next = index + 1
                tcp_pool_find_connection(conns, address, port, next)
        else:
            val next = index + 1
            tcp_pool_find_connection(conns, address, port, next)

# Clear all connections from pool
fn tcp_pool_clear(pool: (i64, list, i64)) -> (i64, list, i64):
    val max_size = tcp_pool_get_max_size(pool)
    val timestamp = pool.2
    val empty = []
    (max_size, empty, timestamp)

# ============================================================================
# Timeout Handling
# ============================================================================

# Create timeout configuration
fn tcp_timeout_create(connect: i64, read: i64, write: i64) -> (i64, i64, i64):
    (connect, read, write)

# Get connect timeout
fn tcp_timeout_get_connect(config: (i64, i64, i64)) -> i64:
    val timeout = config.0
    timeout

# Get read timeout
fn tcp_timeout_get_read(config: (i64, i64, i64)) -> i64:
    val timeout = config.1
    timeout

# Get write timeout
fn tcp_timeout_get_write(config: (i64, i64, i64)) -> i64:
    val timeout = config.2
    timeout

# Set connect timeout
fn tcp_timeout_set_connect(config: (i64, i64, i64), timeout: i64) -> (i64, i64, i64):
    val read = config.1
    val write = config.2
    (timeout, read, write)

# Set read timeout
fn tcp_timeout_set_read(config: (i64, i64, i64), timeout: i64) -> (i64, i64, i64):
    val connect = config.0
    val write = config.2
    (connect, timeout, write)

# Set write timeout
fn tcp_timeout_set_write(config: (i64, i64, i64), timeout: i64) -> (i64, i64, i64):
    val connect = config.0
    val read = config.1
    (connect, read, timeout)

# Create default timeout configuration
fn tcp_timeout_default() -> (i64, i64, i64):
    tcp_timeout_create(TCP_DEFAULT_CONNECT_TIMEOUT, TCP_DEFAULT_READ_TIMEOUT, TCP_DEFAULT_WRITE_TIMEOUT)

# Check if elapsed time exceeds timeout
fn tcp_timeout_exceeded(start_time: i64, current_time: i64, timeout: i64) -> bool:
    val elapsed = current_time - start_time
    elapsed > timeout

# Calculate remaining timeout
fn tcp_timeout_remaining(start_time: i64, current_time: i64, timeout: i64) -> i64:
    val elapsed = current_time - start_time
    val remaining = timeout - elapsed
    if remaining > 0:
        remaining
    else:
        0

# ============================================================================
# Utility Functions
# ============================================================================

# Convert connection to string representation
fn tcp_connection_to_string(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val addr = tcp_connection_get_address(conn)
    val port = tcp_connection_get_port(conn)
    val state = tcp_connection_get_state(conn)
    val state_str = tcp_state_to_string(state)
    val addr_port = tcp_address_format(addr, port)
    val with_space = addr_port + " "
    val result = with_space + state_str
    result

# Check if connection is readable
fn tcp_connection_is_readable(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val state = tcp_connection_get_state(conn)
    val can_recv = tcp_state_can_receive(state)
    if can_recv:
        val buf_size = tcp_get_recv_buffer_size(conn)
        buf_size > 0
    else:
        false

# Check if connection is writable
fn tcp_connection_is_writable(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val state = tcp_connection_get_state(conn)
    val can_send = tcp_state_can_send(state)
    if can_send:
        val buf_size = tcp_get_send_buffer_size(conn)
        buf_size < TCP_MAX_BUFFER_SIZE
    else:
        false

# Reset connection buffers
fn tcp_connection_reset_buffers(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val empty = ""
    val with_recv = tcp_connection_set_recv_buffer(conn, empty)
    tcp_connection_set_send_buffer(with_recv, empty)

# Clone connection
fn tcp_connection_clone(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val addr = tcp_connection_get_address(conn)
    val port = tcp_connection_get_port(conn)
    val state = tcp_connection_get_state(conn)
    val recv_buf = tcp_connection_get_recv_buffer(conn)
    val send_buf = tcp_connection_get_send_buffer(conn)
    val opts = tcp_connection_get_options(conn)
    val ts = tcp_connection_get_timestamp(conn)
    (addr, port, state, recv_buf, send_buf, opts, ts)

# Compare two connections
fn tcp_connection_equals(conn1: (text, i64, i64, text, text, list, i64), conn2: (text, i64, i64, text, text, list, i64)) -> bool:
    val addr1 = tcp_connection_get_address(conn1)
    val addr2 = tcp_connection_get_address(conn2)
    val addr_match = addr1 == addr2
    if addr_match:
        val port1 = tcp_connection_get_port(conn1)
        val port2 = tcp_connection_get_port(conn2)
        port1 == port2
    else:
        false

# Get connection hash (simple address + port combination)
fn tcp_connection_hash(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val port = tcp_connection_get_port(conn)
    port

# Validate connection
fn tcp_connection_is_valid(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val addr = tcp_connection_get_address(conn)
    val addr_valid = tcp_ipv4_is_valid(addr)
    if addr_valid:
        val port = tcp_connection_get_port(conn)
        val port_valid = tcp_port_is_valid(port)
        if port_valid:
            val state = tcp_connection_get_state(conn)
            tcp_state_is_valid(state)
        else:
            false
    else:
        false
